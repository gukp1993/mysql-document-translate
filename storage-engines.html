<html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
    <title>Chapter&nbsp;15 Alternative Storage Engines</title>
    <link rel="stylesheet" href="mvl.css" type="text/css">
    <meta name="generator" content="DocBook XSL Stylesheets + chunker.py v1.9.2">
    <link rel="start" href="index.html" title="{book-title}">
    <link rel="up" href="" title="">
    <link rel="prev" href="innodb-storage-engine.html" title="Chapter&nbsp;14 The InnoDB Storage Engine">
    <link rel="next" href="replication.html" title="Chapter&nbsp;16 Replication">
    <script src="https://code.jquery.com/jquery-3.3.1.min.js"></script><script src="https://code.jquery.com/jquery-3.3.1.min.js"></script><script src="https://code.jquery.com/jquery-3.3.1.min.js"></script><script src="https://code.jquery.com/jquery-3.3.1.min.js"></script></head>
<body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF">
<div class="navheader">
    <table width="100%" summary="Navigation header">
        <tbody><tr>
            <th colspan="3" align="center">Chapter&nbsp;15 Alternative Storage Engines</th>
        </tr>
        <tr>
            <td width="20%" align="left"><a accesskey="p" href="innodb-storage-engine.html">Prev</a>&nbsp;</td>
            <th width="60%" align="center"></th>
            <td width="20%" align="right">&nbsp;<a accesskey="n" href="replication.html">Next</a></td>
        </tr>
        </tbody></table>
    <hr>
</div>
<div class="chapter">
    <div class="titlepage">
        <div>
            <div>
                <h1 class="title"><a name="storage-engines"></a>Chapter&nbsp;15&nbsp;Alternative Storage Engines</h1>

            </div>

        </div>

    </div>
    <div class="toc">
        <p><b>Table of Contents</b></p><p style="color:blue;">目录</p><dl class="toc"><dt><span class="section"><a href="storage-engines.html#storage-engine-setting">15.1 Setting the Storage Engine</a></span></dt><dt><span class="section"><a href="storage-engines.html#myisam-storage-engine">15.2 The MyISAM Storage Engine</a></span></dt><dd><dl><dt><span class="section"><a href="storage-engines.html#myisam-start">15.2.1 MyISAM Startup Options</a></span></dt><dt><span class="section"><a href="storage-engines.html#key-space">15.2.2 Space Needed for Keys</a></span></dt><dt><span class="section"><a href="storage-engines.html#myisam-table-formats">15.2.3 MyISAM Table Storage Formats</a></span></dt><dt><span class="section"><a href="storage-engines.html#myisam-table-problems">15.2.4 MyISAM Table Problems</a></span></dt></dl></dd><dt><span class="section"><a href="storage-engines.html#memory-storage-engine">15.3 The MEMORY Storage Engine</a></span></dt><dt><span class="section"><a href="storage-engines.html#csv-storage-engine">15.4 The CSV Storage Engine</a></span></dt><dd><dl><dt><span class="section"><a href="storage-engines.html#se-csv-repair">15.4.1 Repairing and Checking CSV Tables</a></span></dt><dt><span class="section"><a href="storage-engines.html#se-csv-limitations">15.4.2 CSV Limitations</a></span></dt></dl></dd><dt><span class="section"><a href="storage-engines.html#archive-storage-engine">15.5 The ARCHIVE Storage Engine</a></span></dt><dt><span class="section"><a href="storage-engines.html#blackhole-storage-engine">15.6 The BLACKHOLE Storage Engine</a></span></dt><dt><span class="section"><a href="storage-engines.html#merge-storage-engine">15.7 The MERGE Storage Engine</a></span></dt><dd><dl><dt><span class="section"><a href="storage-engines.html#merge-table-advantages">15.7.1 MERGE Table Advantages and Disadvantages</a></span></dt><dt><span class="section"><a href="storage-engines.html#merge-table-problems">15.7.2 MERGE Table Problems</a></span></dt></dl></dd><dt><span class="section"><a href="storage-engines.html#federated-storage-engine">15.8 The FEDERATED Storage Engine</a></span></dt><dd><dl><dt><span class="section"><a href="storage-engines.html#federated-description">15.8.1 FEDERATED Storage Engine Overview</a></span></dt><dt><span class="section"><a href="storage-engines.html#federated-create">15.8.2 How to Create FEDERATED Tables</a></span></dt><dt><span class="section"><a href="storage-engines.html#federated-usagenotes">15.8.3 FEDERATED Storage Engine Notes and Tips</a></span></dt><dt><span class="section"><a href="storage-engines.html#federated-storage-engine-resources">15.8.4 FEDERATED Storage Engine Resources</a></span></dt></dl></dd><dt><span class="section"><a href="storage-engines.html#example-storage-engine">15.9 The EXAMPLE Storage Engine</a></span></dt><dt><span class="section"><a href="storage-engines.html#storage-engines-other">15.10 Other Storage Engines</a></span></dt><dt><span class="section"><a href="storage-engines.html#pluggable-storage-overview">15.11 Overview of MySQL Storage Engine Architecture</a></span></dt><dd><dl><dt><span class="section"><a href="storage-engines.html#pluggable-storage">15.11.1 Pluggable Storage Engine Architecture</a></span></dt><dt><span class="section"><a href="storage-engines.html#pluggable-storage-common-layer">15.11.2 The Common Database Server Layer</a></span></dt></dl></dd></dl>
    </div>
    <a class="indexterm" name="idm140286804081008"></a><a class="indexterm" name="idm140286804079552"></a><a class="indexterm" name="idm140286804078064"></a><a class="indexterm" name="idm140286804076576"></a><a class="indexterm" name="idm140286804075504"></a><a class="indexterm" name="idm140286804074432"></a><a class="indexterm" name="idm140286804073360"></a><a class="indexterm" name="idm140286804072288"></a><a class="indexterm" name="idm140286804071216"></a><a class="indexterm" name="idm140286804070144"></a><a class="indexterm" name="idm140286804069072"></a><a class="indexterm" name="idm140286804068000"></a><a class="indexterm" name="idm140286804066928"></a><a class="indexterm" name="idm140286804065840"></a><p>
    Storage engines are MySQL components that handle the SQL operations
    for different table types. <a class="link" href="innodb-storage-engine.html" title="Chapter&nbsp;14&nbsp;The InnoDB Storage Engine"><code class="literal">InnoDB</code></a> is
    the default and most general-purpose storage engine, and Oracle
    recommends using it for tables except for specialized use cases.
    (The <a class="link" href="sql-syntax.html#create-table" title="13.1.18&nbsp;CREATE TABLE Syntax"><code class="literal">CREATE TABLE</code></a> statement in MySQL
    5.7 creates <code class="literal">InnoDB</code> tables by
    default.)
</p><p style="color:blue;">存储引擎是处理不同表类型的sql操作的mysql组件。innodb是默认的、最通用的存储引擎，除了特殊的用例之外，oracle建议将其用于表。（mysql 5.7中的create table语句默认创建innodb表。）</p><p>
    MySQL Server uses a pluggable storage engine architecture that
    enables storage engines to be loaded into and unloaded from a
    running MySQL server.
</p><p style="color:blue;">mysql服务器使用可插入的存储引擎体系结构，使存储引擎能够加载到正在运行的mysql服务器中并从中卸载。</p><p>
    To determine which storage engines your server supports, use the
    <a class="link" href="sql-syntax.html#show-engines" title="13.7.5.16&nbsp;SHOW ENGINES Syntax"><code class="literal">SHOW ENGINES</code></a> statement. The value in
    the <code class="literal">Support</code> column indicates whether an engine
    can be used. A value of <code class="literal">YES</code>,
    <code class="literal">NO</code>, or <code class="literal">DEFAULT</code> indicates that
    an engine is available, not available, or available and currently
    set as the default storage engine.
</p><p style="color:blue;">要确定服务器支持哪些存储引擎，请使用show engines语句。“支持”列中的值指示是否可以使用引擎。值yes、no或default表示引擎可用、不可用或可用，并且当前设置为默认存储引擎。</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>SHOW ENGINES\G</code></strong>
*************************** 1. row ***************************
      Engine: PERFORMANCE_SCHEMA
     Support: YES
     Comment: Performance Schema
Transactions: NO
          XA: NO
  Savepoints: NO
*************************** 2. row ***************************
      Engine: InnoDB
     Support: DEFAULT
     Comment: Supports transactions, row-level locking, and foreign keys
Transactions: YES
          XA: YES
  Savepoints: YES
*************************** 3. row ***************************
      Engine: MRG_MYISAM
     Support: YES
     Comment: Collection of identical MyISAM tables
Transactions: NO
          XA: NO
  Savepoints: NO
*************************** 4. row ***************************
      Engine: BLACKHOLE
     Support: YES
     Comment: /dev/null storage engine (anything you write to it disappears)
Transactions: NO
          XA: NO
  Savepoints: NO
*************************** 5. row ***************************
      Engine: MyISAM
     Support: YES
     Comment: MyISAM storage engine
Transactions: NO
          XA: NO
  Savepoints: NO
...
</pre><p>
    This chapter covers use cases for special-purpose MySQL storage
    engines. It does not cover the default
    <a class="link" href="innodb-storage-engine.html" title="Chapter&nbsp;14&nbsp;The InnoDB Storage Engine"><code class="literal">InnoDB</code></a> storage engine or the
    <a class="link" href="mysql-cluster.html" title="Chapter&nbsp;21&nbsp;MySQL NDB Cluster 7.5 and NDB Cluster 7.6"><code class="literal">NDB</code></a> storage engine which are covered in
    <a class="xref" href="innodb-storage-engine.html" title="Chapter&nbsp;14&nbsp;The InnoDB Storage Engine">Chapter&nbsp;14, <i>The InnoDB Storage Engine</i></a>, and
    <a class="xref" href="mysql-cluster.html" title="Chapter&nbsp;21&nbsp;MySQL NDB Cluster 7.5 and NDB Cluster 7.6">Chapter&nbsp;21, <i>MySQL NDB Cluster 7.5 and NDB Cluster 7.6</i></a>. For advanced users, this chapter
    also contains a description of the pluggable storage engine
    architecture (see <a class="xref" href="storage-engines.html#pluggable-storage-overview" title="15.11&nbsp;Overview of MySQL Storage Engine Architecture">Section&nbsp;15.11, “Overview of MySQL Storage Engine Architecture”</a>).
</p><p style="color:blue;">本章介绍专用mysql存储引擎的用例。它不包括默认的innodb存储引擎或ndb存储引擎，这在第14章、innodb存储引擎和第21章、mysql ndb cluster 7.5和ndb cluster 7.6中都有涉及。对于高级用户，本章还包含可插入存储引擎体系结构的描述（请参阅15.11节，“MySQL存储引擎体系结构概述”）。</p><p>
    For information about features offered in commercial MySQL Server
    binaries, see
    <a class="ulink" href="https://www.mysql.com/products/" target="_top"><em class="citetitle">MySQL
        Editions</em></a>, on the MySQL website. The storage
    engines available might depend on which edition of MySQL you are
    using.
</p><p style="color:blue;">有关商业mysql服务器二进制文件中提供的功能的信息，请参阅mysql网站上的mysql版本。可用的存储引擎可能取决于您使用的mysql版本。</p><p>
    For answers to commonly asked questions about MySQL storage engines,
    see <a class="xref" href="faqs.html#faqs-storage-engines" title="A.2&nbsp;MySQL 5.7 FAQ: Storage Engines">Section&nbsp;A.2, “MySQL 5.7 FAQ: Storage Engines”</a>.
</p><p style="color:blue;">有关mysql存储引擎常见问题的解答，请参阅a.2节，“mysql 5.7常见问题解答：存储引擎”。</p>
    <h2><a name="idm140286804044816"></a>MySQL 5.7 Supported Storage Engines</h2>
    <div class="itemizedlist">
        <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            <a class="link" href="innodb-storage-engine.html" title="Chapter&nbsp;14&nbsp;The InnoDB Storage Engine"><code class="literal">InnoDB</code></a>:
            The default storage engine in MySQL 5.7.
            <code class="literal">InnoDB</code> is a transaction-safe (ACID compliant)
            storage engine for MySQL that has commit, rollback, and
            crash-recovery capabilities to protect user data.
            <code class="literal">InnoDB</code> row-level locking (without escalation
            to coarser granularity locks) and Oracle-style consistent
            nonlocking reads increase multi-user concurrency and
            performance. <code class="literal">InnoDB</code> stores user data in
            clustered indexes to reduce I/O for common queries based on
            primary keys. To maintain data integrity,
            <code class="literal">InnoDB</code> also supports <code class="literal">FOREIGN
            KEY</code> referential-integrity constraints. For more
            information about <code class="literal">InnoDB</code>, see
            <a class="xref" href="innodb-storage-engine.html" title="Chapter&nbsp;14&nbsp;The InnoDB Storage Engine">Chapter&nbsp;14, <i>The InnoDB Storage Engine</i></a>.
        </p><p style="color:blue;">innodb:mysql 5.7中的默认存储引擎。InnoDB是一个面向MySQL的事务安全（ACID兼容）存储引擎，它具有提交、回滚和崩溃恢复功能来保护用户数据。innodb行级锁定（不升级到更粗粒度的锁）和oracle风格的一致非锁定读取增加了多用户并发性和性能。InnoDB将用户数据存储在聚集索引中，以减少基于主键的常见查询的I/O。为了维护数据完整性，innodb还支持外键引用完整性约束。有关InnoDB的更多信息，请参阅第14章，InnoDB存储引擎。</p></li><li class="listitem"><p>
            <a class="link" href="storage-engines.html#myisam-storage-engine" title="15.2&nbsp;The MyISAM Storage Engine"><code class="literal">MyISAM</code></a>:
            These tables have a small footprint.
            <a class="link" href="glossary.html#glos_table_lock" title="table lock">Table-level locking</a>
            limits the performance in read/write workloads, so it is often
            used in read-only or read-mostly workloads in Web and data
            warehousing configurations.
        </p><p style="color:blue;">米萨姆：这些桌子的脚印很小。表级锁定限制了读/写工作负载中的性能，因此在web和数据仓库配置中，它通常用于只读或以读为主的工作负载。</p></li><li class="listitem"><p>
            <a class="link" href="storage-engines.html#memory-storage-engine" title="15.3&nbsp;The MEMORY Storage Engine"><code class="literal">Memory</code></a>:
            Stores all data in RAM, for fast access in environments that
            require quick lookups of non-critical data. This engine was
            formerly known as the <code class="literal">HEAP</code> engine. Its use
            cases are decreasing; <code class="literal">InnoDB</code> with its buffer
            pool memory area provides a general-purpose and durable way to
            keep most or all data in memory, and
            <code class="literal">NDBCLUSTER</code> provides fast key-value lookups
            for huge distributed data sets.
        </p><p style="color:blue;">内存：将所有数据存储在RAM中，以便在需要快速查找非关键数据的环境中快速访问。这个引擎以前被称为堆引擎。它的使用案例正在减少；innodb及其缓冲池内存区域提供了一种通用且持久的方法来将大部分或所有数据保存在内存中，ndbcluster为大型分布式数据集提供了快速的键值查找。</p></li><li class="listitem"><p>
            <a class="link" href="storage-engines.html#csv-storage-engine" title="15.4&nbsp;The CSV Storage Engine"><code class="literal">CSV</code></a>:
            Its tables are really text files with comma-separated values.
            CSV tables let you import or dump data in CSV format, to
            exchange data with scripts and applications that read and write
            that same format. Because CSV tables are not indexed, you
            typically keep the data in <code class="literal">InnoDB</code> tables
            during normal operation, and only use CSV tables during the
            import or export stage.
        </p><p style="color:blue;">csv：它的表实际上是带有逗号分隔值的文本文件。csv表允许您导入或转储csv格式的数据，以便与读写相同格式的脚本和应用程序交换数据。因为csv表没有索引，所以通常在正常操作期间将数据保存在innodb表中，并且只在导入或导出阶段使用csv表。</p></li><li class="listitem"><p>
            <a class="link" href="storage-engines.html#archive-storage-engine" title="15.5&nbsp;The ARCHIVE Storage Engine"><code class="literal">Archive</code></a>:
            These compact, unindexed tables are intended for storing and
            retrieving large amounts of seldom-referenced historical,
            archived, or security audit information.
        </p><p style="color:blue;">存档：这些紧凑的、未编制索引的表用于存储和检索大量很少被引用的历史、存档或安全审核信息。</p></li><li class="listitem"><p>
            <a class="link" href="storage-engines.html#blackhole-storage-engine" title="15.6&nbsp;The BLACKHOLE Storage Engine"><code class="literal">Blackhole</code></a>:
            The Blackhole storage engine accepts but does not store data,
            similar to the Unix <code class="literal">/dev/null</code> device. Queries
            always return an empty set. These tables can be used in
            replication configurations where DML statements are sent to
            slave servers, but the master server does not keep its own copy
            of the data.
        </p><p style="color:blue;">黑洞：黑洞存储引擎接受但不存储数据，类似于unix/dev/null设备。查询总是返回空集。这些表可用于复制配置，其中DML语句被发送到从属服务器，但主服务器不保留自己的数据副本。</p></li><li class="listitem"><p>
            <a class="link" href="mysql-cluster.html" title="Chapter&nbsp;21&nbsp;MySQL NDB Cluster 7.5 and NDB Cluster 7.6"><code class="literal">NDB</code></a> (also known as
            <a class="link" href="mysql-cluster.html" title="Chapter&nbsp;21&nbsp;MySQL NDB Cluster 7.5 and NDB Cluster 7.6"><code class="literal">NDBCLUSTER</code></a>): This clustered
            database engine is particularly suited for applications that
            require the highest possible degree of uptime and availability.
        </p><p style="color:blue;">ndb（也称为ndbcluster）：这个集群数据库引擎特别适合于需要尽可能高的正常运行时间和可用性的应用程序。</p></li><li class="listitem"><p>
            <a class="link" href="storage-engines.html#merge-storage-engine" title="15.7&nbsp;The MERGE Storage Engine"><code class="literal">Merge</code></a>:
            Enables a MySQL DBA or developer to logically group a series of
            identical <code class="literal">MyISAM</code> tables and reference them as
            one object. Good for VLDB environments such as data warehousing.
        </p><p style="color:blue;">合并：使mysql dba或开发人员能够逻辑地将一系列相同的myisam表分组，并将它们作为一个对象引用。适用于VLDB环境，如数据仓库。</p></li><li class="listitem"><p>
            <a class="link" href="storage-engines.html#federated-storage-engine" title="15.8&nbsp;The FEDERATED Storage Engine"><code class="literal">Federated</code></a>:
            Offers the ability to link separate MySQL servers to create one
            logical database from many physical servers. Very good for
            distributed or data mart environments.
        </p><p style="color:blue;">federed：提供了链接单独的mysql服务器的能力，以便从许多物理服务器创建一个逻辑数据库。非常适合分布式或数据集市环境。</p></li><li class="listitem"><p>
            <a class="link" href="storage-engines.html#example-storage-engine" title="15.9&nbsp;The EXAMPLE Storage Engine"><code class="literal">Example</code></a>:
            This engine serves as an example in the MySQL source code that
            illustrates how to begin writing new storage engines. It is
            primarily of interest to developers. The storage engine is a
            <span class="quote">“<span class="quote">stub</span>”</span> that does nothing. You can create tables
            with this engine, but no data can be stored in them or retrieved
            from them.
        </p><p style="color:blue;">示例：此引擎作为mysql源代码中的示例，演示如何开始编写新的存储引擎。它主要是开发商感兴趣的。存储引擎是一个不起作用的“存根”。您可以使用此引擎创建表，但不能在其中存储或从中检索任何数据。</p></li></ul>
    </div>
    <p>
        You are not restricted to using the same storage engine for an
        entire server or schema. You can specify the storage engine for any
        table. For example, an application might use mostly
        <code class="literal">InnoDB</code> tables, with one <code class="literal">CSV</code>
        table for exporting data to a spreadsheet and a few
        <code class="literal">MEMORY</code> tables for temporary workspaces.
    </p><p style="color:blue;">不限制您对整个服务器或架构使用相同的存储引擎。可以为任何表指定存储引擎。例如，应用程序可能主要使用innodb表，其中一个csv表用于将数据导出到电子表格，而一些内存表用于临时工作区。</p><p>
    <span class="bold"><strong>Choosing a Storage Engine</strong></span>
</p><p style="color:blue;">选择存储引擎</p><p>
    The various storage engines provided with MySQL are designed with
    different use cases in mind. The following table provides an
    overview of some storage engines provided with MySQL, with
    clarifying notes following the table.
</p><p style="color:blue;">mysql提供的各种存储引擎都是根据不同的用例设计的。下表概述了mysql提供的一些存储引擎，并在下表中说明了注意事项。</p>
    <div class="table">
        <a name="idm140286804004496"></a><p class="title"><b>Table&nbsp;15.1&nbsp;Storage Engines Feature Summary</b></p><p style="color:blue;">表15.1存储引擎功能摘要</p>
        <div class="table-contents">
            <table frame="box" rules="all" summary="Summary of features supported per storage engine."><colgroup><col width="10%"><col width="16%"><col width="16%"><col width="16%"><col width="16%"><col width="16%"></colgroup><thead><tr><th scope="col">Feature</th>
                <th scope="col">MyISAM</th>
                <th scope="col">Memory</th>
                <th scope="col">InnoDB</th>
                <th scope="col">Archive</th>
                <th scope="col">NDB</th>
            </tr></thead><tbody><tr><td scope="row"><span class="bold"><strong>B-tree indexes</strong></span></td>
                <td>Yes</td>
                <td>Yes</td>
                <td>Yes</td>
                <td>No</td>
                <td>No</td>
            </tr><tr><td scope="row"><span class="bold"><strong>Backup/point-in-time recovery</strong></span> (note 1)</td>
                <td>Yes</td>
                <td>Yes</td>
                <td>Yes</td>
                <td>Yes</td>
                <td>Yes</td>
            </tr><tr><td scope="row"><span class="bold"><strong>Cluster database support</strong></span></td>
                <td>No</td>
                <td>No</td>
                <td>No</td>
                <td>No</td>
                <td>Yes</td>
            </tr><tr><td scope="row"><span class="bold"><strong>Clustered indexes</strong></span></td>
                <td>No</td>
                <td>No</td>
                <td>Yes</td>
                <td>No</td>
                <td>No</td>
            </tr><tr><td scope="row"><span class="bold"><strong>Compressed data</strong></span></td>
                <td>Yes (note 2)</td>
                <td>No</td>
                <td>Yes</td>
                <td>Yes</td>
                <td>No</td>
            </tr><tr><td scope="row"><span class="bold"><strong>Data caches</strong></span></td>
                <td>No</td>
                <td>N/A</td>
                <td>Yes</td>
                <td>No</td>
                <td>Yes</td>
            </tr><tr><td scope="row"><span class="bold"><strong>Encrypted data</strong></span></td>
                <td>Yes (note 3)</td>
                <td>Yes (note 3)</td>
                <td>Yes (note 4)</td>
                <td>Yes (note 3)</td>
                <td>Yes (note 3)</td>
            </tr><tr><td scope="row"><span class="bold"><strong>Foreign key support</strong></span></td>
                <td>No</td>
                <td>No</td>
                <td>Yes</td>
                <td>No</td>
                <td>Yes (note 5)</td>
            </tr><tr><td scope="row"><span class="bold"><strong>Full-text search indexes</strong></span></td>
                <td>Yes</td>
                <td>No</td>
                <td>Yes (note 6)</td>
                <td>No</td>
                <td>No</td>
            </tr><tr><td scope="row"><span class="bold"><strong>Geospatial data type support</strong></span></td>
                <td>Yes</td>
                <td>No</td>
                <td>Yes</td>
                <td>Yes</td>
                <td>Yes</td>
            </tr><tr><td scope="row"><span class="bold"><strong>Geospatial indexing support</strong></span></td>
                <td>Yes</td>
                <td>No</td>
                <td>Yes (note 7)</td>
                <td>No</td>
                <td>No</td>
            </tr><tr><td scope="row"><span class="bold"><strong>Hash indexes</strong></span></td>
                <td>No</td>
                <td>Yes</td>
                <td>No (note 8)</td>
                <td>No</td>
                <td>Yes</td>
            </tr><tr><td scope="row"><span class="bold"><strong>Index caches</strong></span></td>
                <td>Yes</td>
                <td>N/A</td>
                <td>Yes</td>
                <td>No</td>
                <td>Yes</td>
            </tr><tr><td scope="row"><span class="bold"><strong>Locking granularity</strong></span></td>
                <td>Table</td>
                <td>Table</td>
                <td>Row</td>
                <td>Row</td>
                <td>Row</td>
            </tr><tr><td scope="row"><span class="bold"><strong>MVCC</strong></span></td>
                <td>No</td>
                <td>No</td>
                <td>Yes</td>
                <td>No</td>
                <td>No</td>
            </tr><tr><td scope="row"><span class="bold"><strong>Replication support</strong></span> (note 1)</td>
                <td>Yes</td>
                <td>Limited (note 9)</td>
                <td>Yes</td>
                <td>Yes</td>
                <td>Yes</td>
            </tr><tr><td scope="row"><span class="bold"><strong>Storage limits</strong></span></td>
                <td>256TB</td>
                <td>RAM</td>
                <td>64TB</td>
                <td>None</td>
                <td>384EB</td>
            </tr><tr><td scope="row"><span class="bold"><strong>T-tree indexes</strong></span></td>
                <td>No</td>
                <td>No</td>
                <td>No</td>
                <td>No</td>
                <td>Yes</td>
            </tr><tr><td scope="row"><span class="bold"><strong>Transactions</strong></span></td>
                <td>No</td>
                <td>No</td>
                <td>Yes</td>
                <td>No</td>
                <td>Yes</td>
            </tr><tr><td scope="row"><span class="bold"><strong>Update statistics for data dictionary</strong></span></td>
                <td>Yes</td>
                <td>Yes</td>
                <td>Yes</td>
                <td>Yes</td>
                <td>Yes</td>
            </tr></tbody></table>
        </div>

    </div>
    <br class="table-break"><p><span class="bold"><strong>Notes:</strong></span></p><p style="color:blue;">笔记：</p><p>1. Implemented in the server, rather than in the storage engine.</p><p style="color:blue;">一。在服务器中实现，而不是在存储引擎中实现。</p><p>2. Compressed MyISAM tables are supported only when using the compressed row format. Tables using the compressed row format with MyISAM are read only.</p><p style="color:blue;">2.仅当使用压缩行格式时，才支持压缩myisam表。使用myisam压缩行格式的表是只读的。</p><p>3. Implemented in the server via encryption functions.</p><p style="color:blue;">三。通过加密功能在服务器中实现。</p><p>4. Implemented in the server via encryption functions; In MySQL 5.7 and later, data-at-rest tablespace encryption is supported.</p><p style="color:blue;">四。通过加密功能在服务器中实现；在mysql 5.7及更高版本中，支持静态数据表空间加密。</p><p>5. Support for foreign keys is available in MySQL Cluster NDB 7.3 and later.</p><p style="color:blue;">5个。mysql cluster ndb 7.3及更高版本中提供了对外键的支持。</p><p>6. InnoDB support for FULLTEXT indexes is available in MySQL 5.6 and later.</p><p style="color:blue;">6.InnoDB对全文索引的支持在MySQL5.6及更高版本中提供。</p><p>7. InnoDB support for geospatial indexing is available in MySQL 5.7 and later.</p><p style="color:blue;">7号。地理空间索引的NYNDB支持在MySQL 5.7和以后可用。</p><p>8. InnoDB utilizes hash indexes internally for its Adaptive Hash Index feature.</p><p style="color:blue;">8个。innodb在内部利用散列索引来实现其自适应散列索引特性。</p><p>9. See the discussion later in this section.</p><p style="color:blue;">9号。请参阅本节后面的讨论。</p>
    <div class="section">

        <div class="titlepage">
            <div>
                <div>
                    <h2 class="title" style="clear: both"><a name="storage-engine-setting"></a>15.1&nbsp;Setting the Storage Engine</h2>

                </div>

            </div>

        </div>
        <p>
            When you create a new table, you can specify which storage engine
            to use by adding an <code class="literal">ENGINE</code> table option to the
            <a class="link" href="sql-syntax.html#create-table" title="13.1.18&nbsp;CREATE TABLE Syntax"><code class="literal">CREATE TABLE</code></a> statement:
        </p><p style="color:blue;">创建新表时，可以通过向CREATE TABLE语句添加ENGINE TABLE选项来指定要使用的存储引擎：</p><pre data-lang="sql" class="programlisting">-- ENGINE=INNODB not needed unless you have set a different
-- default storage engine.
CREATE TABLE t1 (i INT) ENGINE = INNODB;
-- Simple table definitions can be switched from one to another.
CREATE TABLE t2 (i INT) ENGINE = CSV;
CREATE TABLE t3 (i INT) ENGINE = MEMORY;
</pre><p>
        When you omit the <code class="literal">ENGINE</code> option, the default
        storage engine is used. The default engine is
        <a class="link" href="innodb-storage-engine.html" title="Chapter&nbsp;14&nbsp;The InnoDB Storage Engine"><code class="literal">InnoDB</code></a> in MySQL 5.7. You
        can specify the default engine by using the
        <a class="link" href="server-administration.html#sysvar_default_storage_engine"><code class="literal">--default-storage-engine</code></a> server
        startup option, or by setting the
        <a class="link" href="server-administration.html#sysvar_default_storage_engine"><code class="literal">default-storage-engine</code></a> option in
        the <code class="filename">my.cnf</code> configuration file.
    </p><p style="color:blue;">当您省略engine选项时，将使用默认的存储引擎。mysql 5.7的默认引擎是innodb。您可以使用--default storage engine server startup选项或通过在my.cnf配置文件中设置default storage engine选项来指定默认引擎。</p><p>
        You can set the default storage engine for the current session by
        setting the
        <a class="link" href="server-administration.html#sysvar_default_storage_engine"><code class="literal">default_storage_engine</code></a> variable:
    </p><p style="color:blue;">通过设置默认存储引擎变量，可以为当前会话设置默认存储引擎：</p><pre data-lang="sql" class="programlisting">SET default_storage_engine=NDBCLUSTER;
</pre><p>
        The storage engine for <code class="literal">TEMPORARY</code> tables created
        with <a class="link" href="sql-syntax.html#create-table" title="13.1.18&nbsp;CREATE TABLE Syntax"><code class="literal">CREATE
        TEMPORARY TABLE</code></a> can be set separately from the engine
        for permanent tables by setting the
        <a class="link" href="server-administration.html#sysvar_default_tmp_storage_engine"><code class="literal">default_tmp_storage_engine</code></a>,
        either at startup or at runtime.
    </p><p style="color:blue;">使用create temporary table创建的临时表的存储引擎可以通过在启动或运行时设置默认的存储引擎与永久表的引擎分开设置。</p><p>
        To convert a table from one storage engine to another, use an
        <a class="link" href="sql-syntax.html#alter-table" title="13.1.8&nbsp;ALTER TABLE Syntax"><code class="literal">ALTER TABLE</code></a> statement that
        indicates the new engine:
    </p><p style="color:blue;">要将表从一个存储引擎转换为另一个存储引擎，请使用指示新引擎的alter table语句：</p><pre data-lang="sql" class="programlisting">ALTER TABLE t ENGINE = InnoDB;
</pre><p>
        See <a class="xref" href="sql-syntax.html#create-table" title="13.1.18&nbsp;CREATE TABLE Syntax">Section&nbsp;13.1.18, “CREATE TABLE Syntax”</a>, and
        <a class="xref" href="sql-syntax.html#alter-table" title="13.1.8&nbsp;ALTER TABLE Syntax">Section&nbsp;13.1.8, “ALTER TABLE Syntax”</a>.
    </p><p style="color:blue;">参见第13.1.18节“创建表语法”和第13.1.8节“更改表语法”。</p><p>
        If you try to use a storage engine that is not compiled in or that
        is compiled in but deactivated, MySQL instead creates a table
        using the default storage engine. For example, in a replication
        setup, perhaps your master server uses <code class="literal">InnoDB</code>
        tables for maximum safety, but the slave servers use other storage
        engines for speed at the expense of durability or concurrency.
    </p><p style="color:blue;">如果尝试使用未在中编译或已在中编译但已停用的存储引擎，mysql将使用默认存储引擎创建表。例如，在复制设置中，也许您的主服务器使用UNIB DB表以获得最大的安全性，但是从服务器使用其他存储引擎以牺牲持久性或并发性为代价。</p><p>
        By default, a warning is generated whenever
        <a class="link" href="sql-syntax.html#create-table" title="13.1.18&nbsp;CREATE TABLE Syntax"><code class="literal">CREATE TABLE</code></a> or
        <a class="link" href="sql-syntax.html#alter-table" title="13.1.8&nbsp;ALTER TABLE Syntax"><code class="literal">ALTER TABLE</code></a> cannot use the default
        storage engine. To prevent confusing, unintended behavior if the
        desired engine is unavailable, enable the
        <a class="link" href="server-administration.html#sqlmode_no_engine_substitution"><code class="literal">NO_ENGINE_SUBSTITUTION</code></a> SQL mode.
        If the desired engine is unavailable, this setting produces an
        error instead of a warning, and the table is not created or
        altered. See <a class="xref" href="server-administration.html#sql-mode" title="5.1.10&nbsp;Server SQL Modes">Section&nbsp;5.1.10, “Server SQL Modes”</a>.
    </p><p style="color:blue;">默认情况下，当create table或alter table不能使用默认存储引擎时，将生成警告。为了防止在所需引擎不可用时出现混乱、意外的行为，请启用“无引擎替换SQL”模式。如果所需的引擎不可用，此设置将生成错误而不是警告，并且不会创建或更改表。参见第5.1.10节“服务器SQL模式”。</p><p>
        For new tables, MySQL always creates an <code class="filename">.frm</code>
        file to hold the table and column definitions. The table's index
        and data may be stored in one or more other files, depending on
        the storage engine. The server creates the
        <code class="filename">.frm</code> file above the storage engine level.
        Individual storage engines create any additional files required
        for the tables that they manage. If a table name contains special
        characters, the names for the table files contain encoded versions
        of those characters as described in
        <a class="xref" href="language-structure.html#identifier-mapping" title="9.2.4&nbsp;Mapping of Identifiers to File Names">Section&nbsp;9.2.4, “Mapping of Identifiers to File Names”</a>.
    </p><p style="color:blue;">对于新表，mysql总是创建一个.frm文件来保存表和列定义。表的索引和数据可以存储在一个或多个其他文件中，具体取决于存储引擎。服务器在存储引擎级别之上创建.frm文件。单个存储引擎创建它们管理的表所需的任何其他文件。如果表名包含特殊字符，则表文件的名称包含这些字符的编码版本，如第9.2.4节“标识符到文件名的映射”所述。</p>
    </div>
    <div class="section">
        <div class="titlepage">
            <div>
                <div>
                    <h2 class="title" style="clear: both"><a name="myisam-storage-engine"></a>15.2&nbsp;The MyISAM Storage Engine</h2>

                </div>

            </div>

        </div>
        <div class="toc">
            <dl class="toc"><dt><span class="section"><a href="storage-engines.html#myisam-start">15.2.1 MyISAM Startup Options</a></span></dt><dt><span class="section"><a href="storage-engines.html#key-space">15.2.2 Space Needed for Keys</a></span></dt><dt><span class="section"><a href="storage-engines.html#myisam-table-formats">15.2.3 MyISAM Table Storage Formats</a></span></dt><dt><span class="section"><a href="storage-engines.html#myisam-table-problems">15.2.4 MyISAM Table Problems</a></span></dt></dl>
        </div>
        <a class="indexterm" name="idm140286803830448"></a><a class="indexterm" name="idm140286803829408"></a><p>
        <code class="literal">MyISAM</code> is based on the older (and no longer
        available) <code class="literal">ISAM</code> storage engine but has many
        useful extensions.
    </p><p style="color:blue;">myisam基于旧的（并且不再可用的）isam存储引擎，但是有许多有用的扩展。</p>
        <div class="table">
            <a name="idm140286803826032"></a><p class="title"><b>Table&nbsp;15.2&nbsp;MyISAM Storage Engine Features</b></p><p style="color:blue;">表15.2 MyISAM存储引擎特性</p>
            <div class="table-contents">
                <table frame="box" rules="all" summary="Features supported by the MyISAM storage engine."><colgroup><col width="60%"><col width="40%"></colgroup><thead><tr><th scope="col">Feature</th>
                    <th scope="col">Support</th>
                </tr></thead><tbody><tr><td scope="row"><span class="bold"><strong>B-tree indexes</strong></span></td>
                    <td>Yes</td>
                </tr><tr><td scope="row"><span class="bold"><strong>Backup/point-in-time recovery</strong></span> (Implemented in the server, rather than in the storage engine.)</td>
                    <td>Yes</td>
                </tr><tr><td scope="row"><span class="bold"><strong>Cluster database support</strong></span></td>
                    <td>No</td>
                </tr><tr><td scope="row"><span class="bold"><strong>Clustered indexes</strong></span></td>
                    <td>No</td>
                </tr><tr><td scope="row"><span class="bold"><strong>Compressed data</strong></span></td>
                    <td>Yes (Compressed MyISAM tables are supported only when using the compressed row format. Tables using the compressed row format with MyISAM are read only.)</td>
                </tr><tr><td scope="row"><span class="bold"><strong>Data caches</strong></span></td>
                    <td>No</td>
                </tr><tr><td scope="row"><span class="bold"><strong>Encrypted data</strong></span></td>
                    <td>Yes (Implemented in the server via encryption functions.)</td>
                </tr><tr><td scope="row"><span class="bold"><strong>Foreign key support</strong></span></td>
                    <td>No</td>
                </tr><tr><td scope="row"><span class="bold"><strong>Full-text search indexes</strong></span></td>
                    <td>Yes</td>
                </tr><tr><td scope="row"><span class="bold"><strong>Geospatial data type support</strong></span></td>
                    <td>Yes</td>
                </tr><tr><td scope="row"><span class="bold"><strong>Geospatial indexing support</strong></span></td>
                    <td>Yes</td>
                </tr><tr><td scope="row"><span class="bold"><strong>Hash indexes</strong></span></td>
                    <td>No</td>
                </tr><tr><td scope="row"><span class="bold"><strong>Index caches</strong></span></td>
                    <td>Yes</td>
                </tr><tr><td scope="row"><span class="bold"><strong>Locking granularity</strong></span></td>
                    <td>Table</td>
                </tr><tr><td scope="row"><span class="bold"><strong>MVCC</strong></span></td>
                    <td>No</td>
                </tr><tr><td scope="row"><span class="bold"><strong>Replication support</strong></span> (Implemented in the server, rather than in the storage engine.)</td>
                    <td>Yes</td>
                </tr><tr><td scope="row"><span class="bold"><strong>Storage limits</strong></span></td>
                    <td>256TB</td>
                </tr><tr><td scope="row"><span class="bold"><strong>T-tree indexes</strong></span></td>
                    <td>No</td>
                </tr><tr><td scope="row"><span class="bold"><strong>Transactions</strong></span></td>
                    <td>No</td>
                </tr><tr><td scope="row"><span class="bold"><strong>Update statistics for data dictionary</strong></span></td>
                    <td>Yes</td>
                </tr></tbody></table>
            </div>

        </div>
        <br class="table-break"><p>
        Each <code class="literal">MyISAM</code> table is stored on disk in three
        files. The files have names that begin with the table name and have
        an extension to indicate the file type. An <code class="filename">.frm</code>
        file stores the table format. The data file has an
        <code class="filename">.MYD</code> (<code class="literal">MYData</code>) extension. The
        index file has an <code class="filename">.MYI</code>
        (<code class="literal">MYIndex</code>) extension.
    </p><p style="color:blue;">每个myisam表都存储在磁盘上的三个文件中。这些文件的名称以表名开头，并且有一个扩展名来指示文件类型。.frm文件存储表格式。数据文件的扩展名为.myd（mydata）。索引文件的扩展名为.myi（myindex）。</p><p>
        To specify explicitly that you want a <code class="literal">MyISAM</code>
        table, indicate that with an <code class="literal">ENGINE</code> table option:
    </p><p style="color:blue;">要显式指定需要myisam表，请使用引擎表选项指定：</p><pre data-lang="sql" class="programlisting">CREATE TABLE t (i INT) ENGINE = MYISAM;
</pre><p>
        In MySQL 5.7, it is normally necessary to use
        <code class="literal">ENGINE</code> to specify the <code class="literal">MyISAM</code>
        storage engine because <code class="literal">InnoDB</code> is the default
        engine.
    </p><p style="color:blue;">在mysql 5.7中，通常需要使用engine来指定myisam存储引擎，因为innodb是默认引擎。</p><p>
        You can check or repair <code class="literal">MyISAM</code> tables with the
        <a class="link" href="programs.html#mysqlcheck" title="4.5.3&nbsp;mysqlcheck — A Table Maintenance Program"><span class="command"><strong>mysqlcheck</strong></span></a> client or <a class="link" href="programs.html#myisamchk" title="4.6.3&nbsp;myisamchk — MyISAM Table-Maintenance Utility"><span class="command"><strong>myisamchk</strong></span></a>
        utility. You can also compress <code class="literal">MyISAM</code> tables with
        <a class="link" href="programs.html#myisampack" title="4.6.5&nbsp;myisampack — Generate Compressed, Read-Only MyISAM Tables"><span class="command"><strong>myisampack</strong></span></a> to take up much less space. See
        <a class="xref" href="programs.html#mysqlcheck" title="4.5.3&nbsp;mysqlcheck — A Table Maintenance Program">Section&nbsp;4.5.3, “<span class="command"><strong>mysqlcheck</strong></span> — A Table Maintenance Program”</a>, <a class="xref" href="programs.html#myisamchk" title="4.6.3&nbsp;myisamchk — MyISAM Table-Maintenance Utility">Section&nbsp;4.6.3, “<span class="command"><strong>myisamchk</strong></span> — MyISAM Table-Maintenance Utility”</a>, and
        <a class="xref" href="programs.html#myisampack" title="4.6.5&nbsp;myisampack — Generate Compressed, Read-Only MyISAM Tables">Section&nbsp;4.6.5, “<span class="command"><strong>myisampack</strong></span> — Generate Compressed, Read-Only MyISAM Tables”</a>.
    </p><p style="color:blue;">您可以使用mysqlcheck客户端或myisamchk实用程序检查或修复myisam表。您还可以使用myisampack压缩myisam表以占用更少的空间。请参阅第4.5.3节，“mysqlcheck-a table maintenance program”，第4.6.3节，“myisamchk-myisam table maintenance utility”，和第4.6.5节，“myisampack-generate compressed，read only myisam tables”。</p><p>
        <code class="literal">MyISAM</code> tables have the following characteristics:
    </p><p style="color:blue;">myisam表具有以下特征：</p>
        <div class="itemizedlist">
            <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                All data values are stored with the low byte first. This makes
                the data machine and operating system independent. The only
                requirements for binary portability are that the machine uses
                two's-complement signed integers and IEEE floating-point format.
                These requirements are widely used among mainstream machines.
                Binary compatibility might not be applicable to embedded
                systems, which sometimes have peculiar processors.
            </p><p style="color:blue;">所有数据值首先以低字节存储。这使得数据机和操作系统独立。二进制可移植性的唯一要求是机器使用2的补码有符号整数和ieee浮点格式。这些要求在主流机器中广泛应用。二进制兼容性可能不适用于嵌入式系统，后者有时具有特殊的处理器。</p><p>
                There is no significant speed penalty for storing data low byte
                first; the bytes in a table row normally are unaligned and it
                takes little more processing to read an unaligned byte in order
                than in reverse order. Also, the code in the server that fetches
                column values is not time critical compared to other code.
            </p><p style="color:blue;">先存储低字节的数据没有明显的速度损失；表行中的字节通常是未对齐的，按顺序读取未对齐的字节所需的处理比按相反顺序读取所需的处理稍多。此外，与其他代码相比，服务器中获取列值的代码不是时间关键型代码。</p></li><li class="listitem"><p>
                All numeric key values are stored with the high byte first to
                permit better index compression.
            </p><p style="color:blue;">所有数字键值都先用高字节存储，以便更好地进行索引压缩。</p></li><li class="listitem"><p>
                Large files (up to 63-bit file length) are supported on file
                systems and operating systems that support large files.
            </p><p style="color:blue;">支持大文件的文件系统和操作系统支持大文件（最多63位文件长度）。</p></li><li class="listitem"><p>
                There is a limit of
                (2<sup>32</sup>)<sup>2</sup>
                (1.844E+19) rows in a <code class="literal">MyISAM</code> table.
            </p><p style="color:blue;">myisam表中的行数限制为（232）2（1.844e+19）。</p></li><li class="listitem"><p>
                The maximum number of indexes per <code class="literal">MyISAM</code>
                table is 64.
            </p><p style="color:blue;">每个MyISAM表的最大索引数是64个。</p><p>
                The maximum number of columns per index is 16.
            </p><p style="color:blue;">每个索引的最大列数为16个。</p></li><li class="listitem"><p>
                The maximum key length is 1000 bytes. This can also be changed
                by changing the source and recompiling. For the case of a key
                longer than 250 bytes, a larger key block size than the default
                of 1024 bytes is used.
            </p><p style="color:blue;">最大密钥长度为1000字节。这也可以通过更改源和重新编译来更改。对于长度超过250字节的密钥，使用比默认值1024字节更大的密钥块大小。</p></li><li class="listitem"><p>
                When rows are inserted in sorted order (as when you are using an
                <code class="literal">AUTO_INCREMENT</code> column), the index tree is
                split so that the high node only contains one key. This improves
                space utilization in the index tree.
            </p><p style="color:blue;">按排序顺序插入行时（如使用自动递增列时），将拆分索引树，以便高节点仅包含一个键。这提高了索引树中的空间利用率。</p></li><li class="listitem"><p>
                Internal handling of one <code class="literal">AUTO_INCREMENT</code>
                column per table is supported. <code class="literal">MyISAM</code>
                automatically updates this column for
                <a class="link" href="sql-syntax.html#insert" title="13.2.5&nbsp;INSERT Syntax"><code class="literal">INSERT</code></a> and
                <a class="link" href="sql-syntax.html#update" title="13.2.11&nbsp;UPDATE Syntax"><code class="literal">UPDATE</code></a> operations. This makes
                <code class="literal">AUTO_INCREMENT</code> columns faster (at least 10%).
                Values at the top of the sequence are not reused after being
                deleted. (When an <code class="literal">AUTO_INCREMENT</code> column is
                defined as the last column of a multiple-column index, reuse of
                values deleted from the top of a sequence does occur.) The
                <code class="literal">AUTO_INCREMENT</code> value can be reset with
                <a class="link" href="sql-syntax.html#alter-table" title="13.1.8&nbsp;ALTER TABLE Syntax"><code class="literal">ALTER TABLE</code></a> or
                <a class="link" href="programs.html#myisamchk" title="4.6.3&nbsp;myisamchk — MyISAM Table-Maintenance Utility"><span class="command"><strong>myisamchk</strong></span></a>.
            </p><p style="color:blue;">支持每个表一个自动递增列的内部处理。myisam自动更新此列以进行插入和更新操作。这使得自动增加列的速度更快（至少10%）。序列顶部的值在被删除后不被重用。（当自动递增列定义为多列索引的最后一列时，将重复使用从序列顶部删除的值。）可以使用alter table或myisamchk重置自动递增值。</p></li><li class="listitem"><p>
                Dynamic-sized rows are much less fragmented when mixing deletes
                with updates and inserts. This is done by automatically
                combining adjacent deleted blocks and by extending blocks if the
                next block is deleted.
            </p><p style="color:blue;">当混合删除与更新和插入时，动态大小行更少碎片化。这是通过自动组合相邻的已删除块和扩展块（如果删除下一个块）来完成的。</p></li><li class="listitem"><p>
                <code class="literal">MyISAM</code> supports concurrent inserts: If a
                table has no free blocks in the middle of the data file, you can
                <a class="link" href="sql-syntax.html#insert" title="13.2.5&nbsp;INSERT Syntax"><code class="literal">INSERT</code></a> new rows into it at the
                same time that other threads are reading from the table. A free
                block can occur as a result of deleting rows or an update of a
                dynamic length row with more data than its current contents.
                When all free blocks are used up (filled in), future inserts
                become concurrent again. See
                <a class="xref" href="optimization.html#concurrent-inserts" title="8.11.3&nbsp;Concurrent Inserts">Section&nbsp;8.11.3, “Concurrent Inserts”</a>.
            </p><p style="color:blue;">myisam支持并发插入：如果一个表的数据文件中间没有空闲块，那么可以在其他线程从表中读取数据的同时向其中插入新行。删除行或更新包含比当前内容更多数据的动态长度行时，可能会出现自由块。当所有空闲块用完（填充）时，以后的插入将再次并发。见第8.11.3节“并发插入”。</p></li><li class="listitem"><p>
                You can put the data file and index file in different
                directories on different physical devices to get more speed with
                the <code class="literal">DATA DIRECTORY</code> and <code class="literal">INDEX
                DIRECTORY</code> table options to <a class="link" href="sql-syntax.html#create-table" title="13.1.18&nbsp;CREATE TABLE Syntax"><code class="literal">CREATE
                TABLE</code></a>. See <a class="xref" href="sql-syntax.html#create-table" title="13.1.18&nbsp;CREATE TABLE Syntax">Section&nbsp;13.1.18, “CREATE TABLE Syntax”</a>.
            </p><p style="color:blue;">您可以将数据文件和索引文件放在不同物理设备上的不同目录中，以便使用数据目录和索引目录表选项来创建表，从而获得更快的速度。参见第13.1.18节“创建表语法”。</p></li><li class="listitem"><p>
                <a class="link" href="data-types.html#blob" title="11.4.3&nbsp;The BLOB and TEXT Types"><code class="literal">BLOB</code></a> and
                <a class="link" href="data-types.html#blob" title="11.4.3&nbsp;The BLOB and TEXT Types"><code class="literal">TEXT</code></a> columns can be indexed.
            </p><p style="color:blue;">blob列和文本列可以被索引。</p></li><li class="listitem"><p>
                <code class="literal">NULL</code> values are permitted in indexed columns.
                This takes 0 to 1 bytes per key.
            </p><p style="color:blue;">索引列中允许空值。每个密钥需要0到1个字节。</p></li><li class="listitem"><p>
                Each character column can have a different character set. See
                <a class="xref" href="charset.html" title="Chapter&nbsp;10&nbsp;Character Sets, Collations, Unicode">Chapter&nbsp;10, <i>Character Sets, Collations, Unicode</i></a>.
            </p><p style="color:blue;">每个字符列可以有不同的字符集。见第10章，字符集，排序规则，Unicode。</p></li><li class="listitem"><p>
                There is a flag in the <code class="literal">MyISAM</code> index file that
                indicates whether the table was closed correctly. If
                <a class="link" href="programs.html#mysqld" title="4.3.1&nbsp;mysqld — The MySQL Server"><span class="command"><strong>mysqld</strong></span></a> is started with the
                <a class="link" href="server-administration.html#sysvar_myisam_recover_options"><code class="literal">myisam_recover_options</code></a> system
                variable set, <code class="literal">MyISAM</code> tables are automatically
                checked when opened, and are repaired if the table wasn't closed
                properly.
            </p><p style="color:blue;">myisam索引文件中有一个标志，指示表是否正确关闭。如果mysqld是使用myisam_recover_options系统变量集启动的，则myisam表在打开时会自动检查，如果该表未正确关闭，则会进行修复。</p></li><li class="listitem"><p>
                <a class="link" href="programs.html#myisamchk" title="4.6.3&nbsp;myisamchk — MyISAM Table-Maintenance Utility"><span class="command"><strong>myisamchk</strong></span></a> marks tables as checked if you run
                it with the <a class="link" href="programs.html#option_myisamchk_update-state"><code class="option">--update-state</code></a>
                option. <a class="link" href="programs.html#myisamchk" title="4.6.3&nbsp;myisamchk — MyISAM Table-Maintenance Utility"><span class="command"><strong>myisamchk --fast</strong></span></a> checks only those
                tables that don't have this mark.
            </p><p style="color:blue;">如果使用--update state选项运行myisamchk，则将表标记为选中。Myisamchk——Fast只检查那些没有这个标记的桌子。</p></li><li class="listitem"><p>
                <a class="link" href="programs.html#myisamchk" title="4.6.3&nbsp;myisamchk — MyISAM Table-Maintenance Utility"><span class="command"><strong>myisamchk --analyze</strong></span></a> stores statistics for
                portions of keys, as well as for entire keys.
            </p><p style="color:blue;">myisamchk——分析部分键和整个键的存储统计信息。</p></li><li class="listitem"><p>
                <a class="link" href="programs.html#myisampack" title="4.6.5&nbsp;myisampack — Generate Compressed, Read-Only MyISAM Tables"><span class="command"><strong>myisampack</strong></span></a> can pack
                <a class="link" href="data-types.html#blob" title="11.4.3&nbsp;The BLOB and TEXT Types"><code class="literal">BLOB</code></a> and
                <a class="link" href="data-types.html#char" title="11.4.1&nbsp;The CHAR and VARCHAR Types"><code class="literal">VARCHAR</code></a> columns.
            </p><p style="color:blue;">myisampack可以打包blob和varchar列。</p></li></ul>
        </div>
        <p>
            <code class="literal">MyISAM</code> also supports the following features:
        </p><p style="color:blue;">myisam还支持以下功能：</p>
        <div class="itemizedlist">
            <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                Support for a true <a class="link" href="data-types.html#char" title="11.4.1&nbsp;The CHAR and VARCHAR Types"><code class="literal">VARCHAR</code></a> type;
                a <a class="link" href="data-types.html#char" title="11.4.1&nbsp;The CHAR and VARCHAR Types"><code class="literal">VARCHAR</code></a> column starts with a
                length stored in one or two bytes.
            </p><p style="color:blue;">支持真正的varchar类型；varchar列以存储在一个或两个字节中的长度开头。</p></li><li class="listitem"><p>
                Tables with <a class="link" href="data-types.html#char" title="11.4.1&nbsp;The CHAR and VARCHAR Types"><code class="literal">VARCHAR</code></a> columns may
                have fixed or dynamic row length.
            </p><p style="color:blue;">具有varchar列的表可能具有固定或动态行长度。</p></li><li class="listitem"><p>
                The sum of the lengths of the
                <a class="link" href="data-types.html#char" title="11.4.1&nbsp;The CHAR and VARCHAR Types"><code class="literal">VARCHAR</code></a> and
                <a class="link" href="data-types.html#char" title="11.4.1&nbsp;The CHAR and VARCHAR Types"><code class="literal">CHAR</code></a> columns in a table may be up
                to 64KB.
            </p><p style="color:blue;">表中varchar列和char列的长度之和可能高达64kb。</p></li><li class="listitem"><p>
                Arbitrary length <code class="literal">UNIQUE</code> constraints.
            </p><p style="color:blue;">任意长度唯一约束。</p></li></ul>
        </div>
        <h3><a name="idm140286803682416"></a>Additional Resources</h3>
        <div class="itemizedlist">
            <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                A forum dedicated to the <code class="literal">MyISAM</code> storage
                engine is available at <a class="ulink" href="https://forums.mysql.com/list.php?21" target="_top">https://forums.mysql.com/list.php?21</a>.
            </p><p style="color:blue;">在https://forums.mysql.com/list.php上有一个专门讨论myisam存储引擎的论坛？21。</p></li></ul>
        </div>
        <div class="section">
            <div class="titlepage">
                <div>
                    <div>
                        <h3 class="title"><a name="myisam-start"></a>15.2.1&nbsp;MyISAM Startup Options</h3>

                    </div>

                </div>

            </div>
            <p>
                The following options to <a class="link" href="programs.html#mysqld" title="4.3.1&nbsp;mysqld — The MySQL Server"><span class="command"><strong>mysqld</strong></span></a> can be used to
                change the behavior of <code class="literal">MyISAM</code> tables. For
                additional information, see <a class="xref" href="server-administration.html#server-options" title="5.1.6&nbsp;Server Command Options">Section&nbsp;5.1.6, “Server Command Options”</a>.
            </p><p style="color:blue;">mysqld的以下选项可用于更改myisam表的行为。有关更多信息，请参阅第5.1.6节“服务器命令选项”。</p>
            <div class="table">
                <a name="idm140286803674976"></a><p class="title"><b>Table&nbsp;15.3&nbsp;MyISAM Option and Variable Reference</b></p><p style="color:blue;">表15.3 MyISAM选项和变量参考</p>
                <div class="table-contents">
                    <table frame="box" rules="all" summary="Reference for MyISAM command-line options and system variables."><colgroup><col width="20%"><col width="15%"><col width="15%"><col width="15%"><col width="15%"><col width="15%"><col width="15%"></colgroup><thead><tr><th scope="col">Name</th>
                        <th scope="col">Cmd-Line</th>
                        <th scope="col">Option File</th>
                        <th scope="col">System Var</th>
                        <th scope="col">Status Var</th>
                        <th scope="col">Var Scope</th>
                        <th scope="col">Dynamic</th>
                    </tr></thead><tbody><tr><td scope="row"><a class="link" href="server-administration.html#sysvar_bulk_insert_buffer_size">bulk_insert_buffer_size</a></td>
                        <td>Yes</td>
                        <td>Yes</td>
                        <td>Yes</td>
                        <td></td>
                        <td>Both</td>
                        <td>Yes</td>
                    </tr><tr><td scope="row"><a class="link" href="server-administration.html#sysvar_concurrent_insert">concurrent_insert</a></td>
                        <td>Yes</td>
                        <td>Yes</td>
                        <td>Yes</td>
                        <td></td>
                        <td>Global</td>
                        <td>Yes</td>
                    </tr><tr><td scope="row"><a class="link" href="server-administration.html#sysvar_delay_key_write">delay_key_write</a></td>
                        <td>Yes</td>
                        <td>Yes</td>
                        <td>Yes</td>
                        <td></td>
                        <td>Global</td>
                        <td>Yes</td>
                    </tr><tr><td scope="row"><a class="link" href="server-administration.html#sysvar_have_rtree_keys">have_rtree_keys</a></td>
                        <td></td>
                        <td></td>
                        <td>Yes</td>
                        <td></td>
                        <td>Global</td>
                        <td>No</td>
                    </tr><tr><td scope="row"><a class="link" href="server-administration.html#sysvar_key_buffer_size">key_buffer_size</a></td>
                        <td>Yes</td>
                        <td>Yes</td>
                        <td>Yes</td>
                        <td></td>
                        <td>Global</td>
                        <td>Yes</td>
                    </tr><tr><td scope="row"><a class="link" href="server-administration.html#option_mysqld_log-isam">log-isam</a></td>
                        <td>Yes</td>
                        <td>Yes</td>
                        <td></td>
                        <td></td>
                        <td></td>
                        <td></td>
                    </tr><tr><td scope="row"><a class="link" href="server-administration.html#option_mysqld_myisam-block-size">myisam-block-size</a></td>
                        <td>Yes</td>
                        <td>Yes</td>
                        <td></td>
                        <td></td>
                        <td></td>
                        <td></td>
                    </tr><tr><td scope="row"><a class="link" href="server-administration.html#sysvar_myisam_data_pointer_size">myisam_data_pointer_size</a></td>
                        <td>Yes</td>
                        <td>Yes</td>
                        <td>Yes</td>
                        <td></td>
                        <td>Global</td>
                        <td>Yes</td>
                    </tr><tr><td scope="row"><a class="link" href="server-administration.html#sysvar_myisam_max_sort_file_size">myisam_max_sort_file_size</a></td>
                        <td>Yes</td>
                        <td>Yes</td>
                        <td>Yes</td>
                        <td></td>
                        <td>Global</td>
                        <td>Yes</td>
                    </tr><tr><td scope="row"><a class="link" href="server-administration.html#sysvar_myisam_mmap_size">myisam_mmap_size</a></td>
                        <td>Yes</td>
                        <td>Yes</td>
                        <td>Yes</td>
                        <td></td>
                        <td>Global</td>
                        <td>No</td>
                    </tr><tr><td scope="row"><a class="link" href="server-administration.html#sysvar_myisam_recover_options">myisam_recover_options</a></td>
                        <td>Yes</td>
                        <td>Yes</td>
                        <td>Yes</td>
                        <td></td>
                        <td>Global</td>
                        <td>No</td>
                    </tr><tr><td scope="row"><a class="link" href="server-administration.html#sysvar_myisam_repair_threads">myisam_repair_threads</a></td>
                        <td>Yes</td>
                        <td>Yes</td>
                        <td>Yes</td>
                        <td></td>
                        <td>Both</td>
                        <td>Yes</td>
                    </tr><tr><td scope="row"><a class="link" href="server-administration.html#sysvar_myisam_sort_buffer_size">myisam_sort_buffer_size</a></td>
                        <td>Yes</td>
                        <td>Yes</td>
                        <td>Yes</td>
                        <td></td>
                        <td>Both</td>
                        <td>Yes</td>
                    </tr><tr><td scope="row"><a class="link" href="server-administration.html#sysvar_myisam_stats_method">myisam_stats_method</a></td>
                        <td>Yes</td>
                        <td>Yes</td>
                        <td>Yes</td>
                        <td></td>
                        <td>Both</td>
                        <td>Yes</td>
                    </tr><tr><td scope="row"><a class="link" href="server-administration.html#sysvar_myisam_use_mmap">myisam_use_mmap</a></td>
                        <td>Yes</td>
                        <td>Yes</td>
                        <td>Yes</td>
                        <td></td>
                        <td>Global</td>
                        <td>Yes</td>
                    </tr><tr><td scope="row"><a class="link" href="server-administration.html#option_mysqld_skip-concurrent-insert">skip-concurrent-insert</a></td>
                        <td>Yes</td>
                        <td>Yes</td>
                        <td></td>
                        <td></td>
                        <td></td>
                        <td></td>
                    </tr><tr><td scope="row"> - <span class="emphasis"><em>Variable</em></span>: <a class="link" href="server-administration.html#sysvar_concurrent_insert">concurrent_insert</a></td>
                        <td></td>
                        <td></td>
                        <td></td>
                        <td></td>
                        <td></td>
                        <td></td>
                    </tr><tr><td scope="row"><a class="link" href="server-administration.html#sysvar_tmp_table_size">tmp_table_size</a></td>
                        <td>Yes</td>
                        <td>Yes</td>
                        <td>Yes</td>
                        <td></td>
                        <td>Both</td>
                        <td>Yes</td>
                    </tr></tbody></table>
                </div>

            </div>
            <br class="table-break"><p>
            The following system variables affect the behavior of
            <code class="literal">MyISAM</code> tables. For additional information, see
            <a class="xref" href="server-administration.html#server-system-variables" title="5.1.7&nbsp;Server System Variables">Section&nbsp;5.1.7, “Server System Variables”</a>.
        </p><p style="color:blue;">以下系统变量影响myisam表的行为。有关更多信息，请参阅第5.1.7节“服务器系统变量”。</p>
            <div class="itemizedlist">
                <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                    <a class="link" href="server-administration.html#sysvar_bulk_insert_buffer_size"><code class="literal">bulk_insert_buffer_size</code></a>
                </p><p style="color:blue;">大容量插入缓冲区大小</p><a class="indexterm" name="idm140286803530560"></a><a class="indexterm" name="idm140286803529520"></a><p>
                    The size of the tree cache used in bulk insert optimization.
                </p><p style="color:blue;">批量插入优化中使用的树缓存的大小。</p>
                    <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">

                        <div class="admon-title">
                            Note
                        </div>
                        <p>
                            This is a limit <span class="emphasis"><em>per thread</em></span>!
                        </p><p style="color:blue;">这是每个线程的限制！</p>
                    </div>
                </li><li class="listitem"><p>
                    <a class="link" href="server-administration.html#sysvar_delay_key_write"><code class="option">delay_key_write=ALL</code></a>
                </p><p style="color:blue;">delay_key_write=全部</p><a class="indexterm" name="idm140286803524592"></a><a class="indexterm" name="idm140286803523504"></a><p>
                    Don't flush key buffers between writes for any
                    <code class="literal">MyISAM</code> table.
                </p><p style="color:blue;">不要在任何myisam表的写入之间刷新密钥缓冲区。</p>
                    <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">

                        <div class="admon-title">
                            Note
                        </div>
                        <p>
                            If you do this, you should not access
                            <code class="literal">MyISAM</code> tables from another program (such
                            as from another MySQL server or with
                            <a class="link" href="programs.html#myisamchk" title="4.6.3&nbsp;myisamchk — MyISAM Table-Maintenance Utility"><span class="command"><strong>myisamchk</strong></span></a>) when the tables are in use.
                            Doing so risks index corruption. Using
                            <a class="link" href="server-administration.html#option_mysqld_external-locking"><code class="option">--external-locking</code></a> does not
                            eliminate this risk.
                        </p><p style="color:blue;">如果这样做，则在使用myisamchk表时，不应从其他程序（例如从另一个mysql服务器）访问myisam表。这样做有腐败的风险。使用——外部锁定并不能消除这种风险。</p>
                    </div>
                </li><li class="listitem"><p>
                    <a class="link" href="server-administration.html#sysvar_myisam_max_sort_file_size"><code class="literal">myisam_max_sort_file_size</code></a>
                </p><p style="color:blue;">myisam_max_sort_文件大小</p><a class="indexterm" name="idm140286803514832"></a><a class="indexterm" name="idm140286803513728"></a><p>
                    The maximum size of the temporary file that MySQL is permitted
                    to use while re-creating a <code class="literal">MyISAM</code> index
                    (during <a class="link" href="sql-syntax.html#repair-table" title="13.7.2.5&nbsp;REPAIR TABLE Syntax"><code class="literal">REPAIR TABLE</code></a>,
                    <a class="link" href="sql-syntax.html#alter-table" title="13.1.8&nbsp;ALTER TABLE Syntax"><code class="literal">ALTER TABLE</code></a>, or
                    <a class="link" href="sql-syntax.html#load-data" title="13.2.6&nbsp;LOAD DATA Syntax"><code class="literal">LOAD DATA</code></a>). If the file size
                    would be larger than this value, the index is created using
                    the key cache instead, which is slower. The value is given in
                    bytes.
                </p><p style="color:blue;">MySQL允许在重新创建索引时使用的临时文件的最大大小（在修复表、更改表或加载数据期间）。如果文件大小将大于此值，则使用键缓存创建索引，这会比较慢。该值以字节为单位。</p></li><li class="listitem"><p>
                    <a class="link" href="server-administration.html#sysvar_myisam_recover_options"><code class="literal">myisam_recover_options=<em class="replaceable"><code>mode</code></em></code></a>
                </p><p style="color:blue;">myisam_recover_options=模式</p><a class="indexterm" name="idm140286803504768"></a><a class="indexterm" name="idm140286803503728"></a><p>
                    Set the mode for automatic recovery of crashed
                    <code class="literal">MyISAM</code> tables.
                </p><p style="color:blue;">设置崩溃的myisam表的自动恢复模式。</p></li><li class="listitem"><p>
                    <a class="link" href="server-administration.html#sysvar_myisam_sort_buffer_size"><code class="literal">myisam_sort_buffer_size</code></a>
                </p><p style="color:blue;">myisam_sort_缓冲区大小</p><a class="indexterm" name="idm140286803499008"></a><a class="indexterm" name="idm140286803497968"></a><p>
                    Set the size of the buffer used when recovering tables.
                </p><p style="color:blue;">设置恢复表时使用的缓冲区大小。</p></li></ul>
            </div>
            <p>
                Automatic recovery is activated if you start
                <a class="link" href="programs.html#mysqld" title="4.3.1&nbsp;mysqld — The MySQL Server"><span class="command"><strong>mysqld</strong></span></a> with the
                <a class="link" href="server-administration.html#sysvar_myisam_recover_options"><code class="literal">myisam_recover_options</code></a> system
                variable set. In this case, when the server opens a
                <code class="literal">MyISAM</code> table, it checks whether the table is
                marked as crashed or whether the open count variable for the table
                is not 0 and you are running the server with external locking
                disabled. If either of these conditions is true, the following
                happens:
            </p><p style="color:blue;">如果使用myisam_recover_options系统变量集启动mysqld，则会激活自动恢复。在这种情况下，当服务器打开myisam表时，它会检查该表是否标记为崩溃，或者该表的open count变量是否不是0，并且您正在运行禁用外部锁定的服务器。如果上述任一条件为真，则发生以下情况：</p>
            <div class="itemizedlist">
                <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                    The server checks the table for errors.
                </p><p style="color:blue;">服务器检查表是否有错误。</p></li><li class="listitem"><p>
                    If the server finds an error, it tries to do a fast table
                    repair (with sorting and without re-creating the data file).
                </p><p style="color:blue;">如果服务器发现错误，它会尝试执行快速表修复（包括排序和不重新创建数据文件）。</p></li><li class="listitem"><p>
                    If the repair fails because of an error in the data file (for
                    example, a duplicate-key error), the server tries again, this
                    time re-creating the data file.
                </p><p style="color:blue;">如果修复由于数据文件中的错误（例如，重复密钥错误）而失败，服务器将再次尝试，这次将重新创建数据文件。</p></li><li class="listitem"><p>
                    If the repair still fails, the server tries once more with the
                    old repair option method (write row by row without sorting).
                    This method should be able to repair any type of error and has
                    low disk space requirements.
                </p><p style="color:blue;">如果修复仍然失败，服务器将使用旧的修复选项方法（不排序地逐行写入）再次尝试。此方法应该能够修复任何类型的错误，并且磁盘空间要求较低。</p></li></ul>
            </div>
            <p>
                If the recovery wouldn't be able to recover all rows from
                previously completed statements and you didn't specify
                <code class="literal">FORCE</code> in the value of the
                <a class="link" href="server-administration.html#sysvar_myisam_recover_options"><code class="literal">myisam_recover_options</code></a> system
                variable, automatic repair aborts with an error message in the
                error log:
            </p><p style="color:blue;">如果恢复无法从以前完成的语句中恢复所有行，并且未在myisam_recover_options系统变量的值中指定force，则自动修复将中止，并在错误日志中显示错误消息：</p><pre data-lang="none" class="programlisting">Error: Couldn't repair table: test.g00pages
</pre><p>
            If you specify <code class="literal">FORCE</code>, a warning like this is
            written instead:
        </p><p style="color:blue;">如果指定force，则会改为写入这样的警告：</p><pre data-lang="none" class="programlisting">Warning: Found 344 of 354 rows when repairing ./test/g00pages
</pre><p>
            If the automatic recovery value includes
            <code class="literal">BACKUP</code>, the recovery process creates files with
            names of the form
            <code class="filename"><em class="replaceable"><code>tbl_name-datetime</code></em>.BAK</code>.
            You should have a <span class="command"><strong>cron</strong></span> script that
            automatically moves these files from the database directories to
            backup media.
        </p><p style="color:blue;">如果自动恢复值包括backup，则恢复过程将创建名称格式为tbl_name-datetime.bak的文件。您应该有一个cron脚本，可以自动将这些文件从数据库目录移动到备份媒体。</p>
        </div>
        <div class="section">
            <div class="titlepage">
                <div>
                    <div>
                        <h3 class="title"><a name="key-space"></a>15.2.2&nbsp;Space Needed for Keys</h3>

                    </div>

                </div>

            </div>
            <a class="indexterm" name="idm140286803477472"></a><p>
            <code class="literal">MyISAM</code> tables use B-tree indexes. You can
            roughly calculate the size for the index file as
            <code class="literal">(key_length+4)/0.67</code>, summed over all keys. This
            is for the worst case when all keys are inserted in sorted order
            and the table doesn't have any compressed keys.
        </p><p style="color:blue;">myisam表使用b树索引。您可以粗略地计算索引文件的大小（key_length+4）/0.67，在所有键上求和。当所有键都按排序顺序插入并且表没有任何压缩键时，这是最坏的情况。</p><p>
            String indexes are space compressed. If the first index part is a
            string, it is also prefix compressed. Space compression makes the
            index file smaller than the worst-case figure if a string column
            has a lot of trailing space or is a
            <a class="link" href="data-types.html#char" title="11.4.1&nbsp;The CHAR and VARCHAR Types"><code class="literal">VARCHAR</code></a> column that is not always
            used to the full length. Prefix compression is used on keys that
            start with a string. Prefix compression helps if there are many
            strings with an identical prefix.
        </p><p style="color:blue;">字符串索引是空间压缩的。如果第一个索引部分是一个字符串，它也被前缀压缩。如果一个字符串列有很多尾随空格，或者是一个不总是使用完整长度的varchar列，那么空间压缩会使索引文件小于最坏情况下的数字。前缀压缩用于以字符串开头的键。如果有多个字符串具有相同的前缀，前缀压缩会有帮助。</p><p>
            In <code class="literal">MyISAM</code> tables, you can also prefix compress
            numbers by specifying the <code class="literal">PACK_KEYS=1</code> table
            option when you create the table. Numbers are stored with the high
            byte first, so this helps when you have many integer keys that
            have an identical prefix.
        </p><p style="color:blue;">在myisam表中，也可以在创建表时指定pack_keys=1 table选项作为压缩号的前缀。数字首先与高字节一起存储，因此当您有许多具有相同前缀的整数键时，这会有所帮助。</p>
        </div>
        <div class="section">
            <div class="titlepage">
                <div>
                    <div>
                        <h3 class="title"><a name="myisam-table-formats"></a>15.2.3&nbsp;MyISAM Table Storage Formats</h3>

                    </div>

                </div>

            </div>
            <div class="toc">
                <dl class="toc"><dt><span class="section"><a href="storage-engines.html#static-format">15.2.3.1 Static (Fixed-Length) Table Characteristics</a></span></dt><dt><span class="section"><a href="storage-engines.html#dynamic-format">15.2.3.2 Dynamic Table Characteristics</a></span></dt><dt><span class="section"><a href="storage-engines.html#compressed-format">15.2.3.3 Compressed Table Characteristics</a></span></dt></dl>
            </div>
            <p>
                <code class="literal">MyISAM</code> supports three different storage
                formats. Two of them, fixed and dynamic format, are chosen
                automatically depending on the type of columns you are using. The
                third, compressed format, can be created only with the
                <a class="link" href="programs.html#myisampack" title="4.6.5&nbsp;myisampack — Generate Compressed, Read-Only MyISAM Tables"><span class="command"><strong>myisampack</strong></span></a> utility (see
                <a class="xref" href="programs.html#myisampack" title="4.6.5&nbsp;myisampack — Generate Compressed, Read-Only MyISAM Tables">Section&nbsp;4.6.5, “<span class="command"><strong>myisampack</strong></span> — Generate Compressed, Read-Only MyISAM Tables”</a>).
            </p><p style="color:blue;">myisam支持三种不同的存储格式。其中两种格式（固定格式和动态格式）是根据所使用的列类型自动选择的。第三种是压缩格式，只能使用myisampack实用程序创建（请参见第4.6.5节“myisampack-生成压缩的只读myisam表”）。</p><p>
            When you use <a class="link" href="sql-syntax.html#create-table" title="13.1.18&nbsp;CREATE TABLE Syntax"><code class="literal">CREATE TABLE</code></a> or
            <a class="link" href="sql-syntax.html#alter-table" title="13.1.8&nbsp;ALTER TABLE Syntax"><code class="literal">ALTER TABLE</code></a> for a table that has no
            <a class="link" href="data-types.html#blob" title="11.4.3&nbsp;The BLOB and TEXT Types"><code class="literal">BLOB</code></a> or
            <a class="link" href="data-types.html#blob" title="11.4.3&nbsp;The BLOB and TEXT Types"><code class="literal">TEXT</code></a> columns, you can force the
            table format to <code class="literal">FIXED</code> or
            <code class="literal">DYNAMIC</code> with the <code class="literal">ROW_FORMAT</code>
            table option.
        </p><p style="color:blue;">对于没有blob或文本列的表使用create table或alter table时，可以使用row_format table选项将表格式强制为fixed或dynamic。</p><p>
            See <a class="xref" href="sql-syntax.html#create-table" title="13.1.18&nbsp;CREATE TABLE Syntax">Section&nbsp;13.1.18, “CREATE TABLE Syntax”</a>, for information about
            <code class="literal">ROW_FORMAT</code>.
        </p><p style="color:blue;">有关行格式的信息，请参阅第13.1.18节“创建表语法”。</p><p>
            You can decompress (unpack) compressed <code class="literal">MyISAM</code>
            tables using <a class="link" href="programs.html#myisamchk" title="4.6.3&nbsp;myisamchk — MyISAM Table-Maintenance Utility"><span class="command"><strong>myisamchk</strong></span></a>
            <a class="link" href="programs.html#option_myisamchk_unpack"><code class="option">--unpack</code></a>; see
            <a class="xref" href="programs.html#myisamchk" title="4.6.3&nbsp;myisamchk — MyISAM Table-Maintenance Utility">Section&nbsp;4.6.3, “<span class="command"><strong>myisamchk</strong></span> — MyISAM Table-Maintenance Utility”</a>, for more information.
        </p><p style="color:blue;">您可以使用myisamchk--unpack解压缩（unpack）压缩的myisam表；有关详细信息，请参阅第4.6.3节“myisamchk-myisam表维护实用程序”。</p>
            <div class="section">

                <div class="titlepage">
                    <div>
                        <div>
                            <h4 class="title"><a name="static-format"></a>15.2.3.1&nbsp;Static (Fixed-Length) Table Characteristics</h4>
                        </div>
                    </div>
                </div>
                <p>
                    Static format is the default for <code class="literal">MyISAM</code>
                    tables. It is used when the table contains no variable-length
                    columns (<a class="link" href="data-types.html#char" title="11.4.1&nbsp;The CHAR and VARCHAR Types"><code class="literal">VARCHAR</code></a>,
                    <a class="link" href="data-types.html#binary-varbinary" title="11.4.2&nbsp;The BINARY and VARBINARY Types"><code class="literal">VARBINARY</code></a>,
                    <a class="link" href="data-types.html#blob" title="11.4.3&nbsp;The BLOB and TEXT Types"><code class="literal">BLOB</code></a>, or
                    <a class="link" href="data-types.html#blob" title="11.4.3&nbsp;The BLOB and TEXT Types"><code class="literal">TEXT</code></a>). Each row is stored using a
                    fixed number of bytes.
                </p><p style="color:blue;">静态格式是myisam表的默认格式。当表不包含可变长度列（varchar、varbinary、blob或text）时使用。每行使用固定字节数存储。</p><p>
                Of the three <code class="literal">MyISAM</code> storage formats, static
                format is the simplest and most secure (least subject to
                corruption). It is also the fastest of the on-disk formats due
                to the ease with which rows in the data file can be found on
                disk: To look up a row based on a row number in the index,
                multiply the row number by the row length to calculate the row
                position. Also, when scanning a table, it is very easy to read a
                constant number of rows with each disk read operation.
            </p><p style="color:blue;">在三种myisam存储格式中，静态格式是最简单和最安全的（最不易损坏）。它也是磁盘上最快的格式，因为数据文件中的行可以很容易地在磁盘上找到：要基于索引中的行号查找行，请将行号乘以行长度以计算行位置。另外，扫描表时，每次磁盘读取操作都很容易读取固定数量的行。</p><p>
                The security is evidenced if your computer crashes while the
                MySQL server is writing to a fixed-format
                <code class="literal">MyISAM</code> file. In this case,
                <a class="link" href="programs.html#myisamchk" title="4.6.3&nbsp;myisamchk — MyISAM Table-Maintenance Utility"><span class="command"><strong>myisamchk</strong></span></a> can easily determine where each row
                starts and ends, so it can usually reclaim all rows except the
                partially written one. <code class="literal">MyISAM</code> table indexes
                can always be reconstructed based on the data rows.
            </p><p style="color:blue;">如果您的计算机在mysql服务器写入固定格式的myisam文件时崩溃，则可以证明安全性。在这种情况下，myisamchk可以很容易地确定每一行的开始和结束位置，因此它通常可以回收除部分写入的行之外的所有行。myisam表索引始终可以基于数据行进行重构。</p>
                <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">

                    <div class="admon-title">
                        Note
                    </div>
                    <p>
                        Fixed-length row format is only available for tables without
                        <a class="link" href="data-types.html#blob" title="11.4.3&nbsp;The BLOB and TEXT Types"><code class="literal">BLOB</code></a> or
                        <a class="link" href="data-types.html#blob" title="11.4.3&nbsp;The BLOB and TEXT Types"><code class="literal">TEXT</code></a> columns. Creating a table
                        with these columns with an explicit
                        <code class="literal">ROW_FORMAT</code> clause will not raise an error
                        or warning; the format specification will be ignored.
                    </p><p style="color:blue;">固定长度行格式仅适用于没有blob或文本列的表。使用显式row_format子句创建包含这些列的表不会引发错误或警告；格式规范将被忽略。</p>
                </div>
                <p>
                    Static-format tables have these characteristics:
                </p><p style="color:blue;">静态格式表具有以下特征：</p>
                <div class="itemizedlist">
                    <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                        <a class="link" href="data-types.html#char" title="11.4.1&nbsp;The CHAR and VARCHAR Types"><code class="literal">CHAR</code></a> and
                        <a class="link" href="data-types.html#char" title="11.4.1&nbsp;The CHAR and VARCHAR Types"><code class="literal">VARCHAR</code></a> columns are
                        space-padded to the specified column width, although the
                        column type is not altered.
                        <a class="link" href="data-types.html#binary-varbinary" title="11.4.2&nbsp;The BINARY and VARBINARY Types"><code class="literal">BINARY</code></a> and
                        <a class="link" href="data-types.html#binary-varbinary" title="11.4.2&nbsp;The BINARY and VARBINARY Types"><code class="literal">VARBINARY</code></a> columns are padded
                        with <code class="literal">0x00</code> bytes to the column width.
                    </p><p style="color:blue;">char和varchar列用空格填充到指定的列宽，尽管列类型没有改变。binary和varbinary列用0x00字节填充到列宽。</p></li><li class="listitem"><p>
                        <code class="literal">NULL</code> columns require additional space in
                        the row to record whether their values are
                        <code class="literal">NULL</code>. Each <code class="literal">NULL</code> column
                        takes one bit extra, rounded up to the nearest byte.
                    </p><p style="color:blue;">空列需要行中的额外空间来记录其值是否为空。每个空列需要额外一位，四舍五入到最接近的字节。</p></li><li class="listitem"><p>
                        Very quick.
                    </p><p style="color:blue;">很快。</p></li><li class="listitem"><p>
                        Easy to cache.
                    </p><p style="color:blue;">易于缓存。</p></li><li class="listitem"><p>
                        Easy to reconstruct after a crash, because rows are located
                        in fixed positions.
                    </p><p style="color:blue;">很容易在崩溃后重建，因为行位于固定位置。</p></li><li class="listitem"><p>
                        Reorganization is unnecessary unless you delete a huge
                        number of rows and want to return free disk space to the
                        operating system. To do this, use
                        <a class="link" href="sql-syntax.html#optimize-table" title="13.7.2.4&nbsp;OPTIMIZE TABLE Syntax"><code class="literal">OPTIMIZE TABLE</code></a> or
                        <a class="link" href="programs.html#myisamchk" title="4.6.3&nbsp;myisamchk — MyISAM Table-Maintenance Utility"><span class="command"><strong>myisamchk -r</strong></span></a>.
                    </p><p style="color:blue;">除非删除大量行并希望将可用磁盘空间返回给操作系统，否则重组是不必要的。为此，请使用optimize table或myisamchk-r。</p></li><li class="listitem"><p>
                        Usually require more disk space than dynamic-format tables.
                    </p><p style="color:blue;">通常需要比动态格式表更多的磁盘空间。</p></li><li class="listitem"><p>
                        The expected row length in bytes for static-sized rows is
                        calculated using the following expression:
                    </p><p style="color:blue;">使用以下表达式计算静态大小行的预期行长度（字节）：</p><pre data-lang="none" class="programlisting">row length = 1
             + (<em class="replaceable"><code>sum of column lengths</code></em>)
             + (<em class="replaceable"><code>number of NULL columns</code></em> + <em class="replaceable"><code>delete_flag</code></em> + 7)/8
             + (<em class="replaceable"><code>number of variable-length columns</code></em>)
</pre><p>
                        <em class="replaceable"><code>delete_flag</code></em> is 1 for tables with
                        static row format. Static tables use a bit in the row record
                        for a flag that indicates whether the row has been deleted.
                        <em class="replaceable"><code>delete_flag</code></em> is 0 for dynamic
                        tables because the flag is stored in the dynamic row header.
                    </p><p style="color:blue;">对于静态行格式的表，delete_标志为1。静态表在行记录中使用一个位作为标志，该标志指示行是否已被删除。动态表的delete_标志为0，因为该标志存储在动态行标题中。</p></li></ul>
                </div>

            </div>
            <div class="section">
                <div class="titlepage">
                    <div>
                        <div>
                            <h4 class="title"><a name="dynamic-format"></a>15.2.3.2&nbsp;Dynamic Table Characteristics</h4>

                        </div>

                    </div>

                </div>
                <a class="indexterm" name="idm140286803411376"></a><a class="indexterm" name="idm140286803410320"></a><p>
                Dynamic storage format is used if a <code class="literal">MyISAM</code>
                table contains any variable-length columns
                (<a class="link" href="data-types.html#char" title="11.4.1&nbsp;The CHAR and VARCHAR Types"><code class="literal">VARCHAR</code></a>,
                <a class="link" href="data-types.html#binary-varbinary" title="11.4.2&nbsp;The BINARY and VARBINARY Types"><code class="literal">VARBINARY</code></a>,
                <a class="link" href="data-types.html#blob" title="11.4.3&nbsp;The BLOB and TEXT Types"><code class="literal">BLOB</code></a>, or
                <a class="link" href="data-types.html#blob" title="11.4.3&nbsp;The BLOB and TEXT Types"><code class="literal">TEXT</code></a>), or if the table was
                created with the <code class="literal">ROW_FORMAT=DYNAMIC</code> table
                option.
            </p><p style="color:blue;">如果myisam表包含任何可变长度的列（varchar、varbinary、blob或text），或者该表是使用row_format=dynamic table选项创建的，则使用动态存储格式。</p><p>
                Dynamic format is a little more complex than static format
                because each row has a header that indicates how long it is. A
                row can become fragmented (stored in noncontiguous pieces) when
                it is made longer as a result of an update.
            </p><p style="color:blue;">动态格式比静态格式稍微复杂一点，因为每一行都有一个表示其长度的标题。当一行由于更新而变长时，它可能会变得碎片化（存储在非连续的片段中）。</p><a class="indexterm" name="idm140286803401248"></a><p>
                You can use <a class="link" href="sql-syntax.html#optimize-table" title="13.7.2.4&nbsp;OPTIMIZE TABLE Syntax"><code class="literal">OPTIMIZE TABLE</code></a> or
                <a class="link" href="programs.html#myisamchk" title="4.6.3&nbsp;myisamchk — MyISAM Table-Maintenance Utility"><span class="command"><strong>myisamchk -r</strong></span></a> to defragment a table. If you
                have fixed-length columns that you access or change frequently
                in a table that also contains some variable-length columns, it
                might be a good idea to move the variable-length columns to
                other tables just to avoid fragmentation.
            </p><p style="color:blue;">您可以使用optimize table或myisamchk-r对表进行碎片整理。如果在还包含一些可变长度列的表中有经常访问或更改的固定长度列，则最好将可变长度列移到其他表中，以避免碎片化。</p><p>
                Dynamic-format tables have these characteristics:
            </p><p style="color:blue;">动态格式表具有以下特点：</p>
                <div class="itemizedlist">
                    <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                        All string columns are dynamic except those with a length
                        less than four.
                    </p><p style="color:blue;">所有字符串列都是动态的，但长度小于4的列除外。</p></li><li class="listitem"><p>
                        Each row is preceded by a bitmap that indicates which
                        columns contain the empty string (for string columns) or
                        zero (for numeric columns). This does not include columns
                        that contain <code class="literal">NULL</code> values. If a string
                        column has a length of zero after trailing space removal, or
                        a numeric column has a value of zero, it is marked in the
                        bitmap and not saved to disk. Nonempty strings are saved as
                        a length byte plus the string contents.
                    </p><p style="color:blue;">每行前面都有一个位图，指示哪些列包含空字符串（对于字符串列）或零（对于数值列）。这不包括包含空值的列。如果删除尾随空格后字符串列的长度为零，或者数值列的值为零，则该列将在位图中标记，而不会保存到磁盘。非空字符串保存为长度字节加上字符串内容。</p></li><li class="listitem"><p>
                        <code class="literal">NULL</code> columns require additional space in
                        the row to record whether their values are
                        <code class="literal">NULL</code>. Each <code class="literal">NULL</code> column
                        takes one bit extra, rounded up to the nearest byte.
                    </p><p style="color:blue;">空列需要行中的额外空间来记录其值是否为空。每个空列需要额外一位，四舍五入到最接近的字节。</p></li><li class="listitem"><p>
                        Much less disk space usually is required than for
                        fixed-length tables.
                    </p><p style="color:blue;">通常需要的磁盘空间比固定长度的表要少得多。</p></li><li class="listitem"><p>
                        Each row uses only as much space as is required. However, if
                        a row becomes larger, it is split into as many pieces as are
                        required, resulting in row fragmentation. For example, if
                        you update a row with information that extends the row
                        length, the row becomes fragmented. In this case, you may
                        have to run <a class="link" href="sql-syntax.html#optimize-table" title="13.7.2.4&nbsp;OPTIMIZE TABLE Syntax"><code class="literal">OPTIMIZE TABLE</code></a> or
                        <a class="link" href="programs.html#myisamchk" title="4.6.3&nbsp;myisamchk — MyISAM Table-Maintenance Utility"><span class="command"><strong>myisamchk -r</strong></span></a> from time to time to improve
                        performance. Use <a class="link" href="programs.html#myisamchk" title="4.6.3&nbsp;myisamchk — MyISAM Table-Maintenance Utility"><span class="command"><strong>myisamchk -ei</strong></span></a> to obtain
                        table statistics.
                    </p><p style="color:blue;">每行只使用所需的空间。但是，如果行变大，它将被拆分为所需的多个部分，从而导致行碎片化。例如，如果使用扩展行长度的信息更新行，则该行将变为碎片。在这种情况下，您可能需要不时运行optimize table或myisamchk-r来提高性能。使用myisamchk-ei获取表统计信息。</p></li><li class="listitem"><p>
                        More difficult than static-format tables to reconstruct
                        after a crash, because rows may be fragmented into many
                        pieces and links (fragments) may be missing.
                    </p><p style="color:blue;">比静态格式表更难在崩溃后重建，因为行可能被分割成许多片段，链接（片段）可能丢失。</p></li><li class="listitem"><p>
                        The expected row length for dynamic-sized rows is calculated
                        using the following expression:
                    </p><p style="color:blue;">使用以下表达式计算动态大小的行的预期行长度：</p><pre data-lang="none" class="programlisting">3
+ (<em class="replaceable"><code>number of columns</code></em> + 7) / 8
+ (<em class="replaceable"><code>number of char columns</code></em>)
+ (<em class="replaceable"><code>packed size of numeric columns</code></em>)
+ (<em class="replaceable"><code>length of strings</code></em>)
+ (<em class="replaceable"><code>number of NULL columns</code></em> + 7) / 8
</pre><p>
                        There is a penalty of 6 bytes for each link. A dynamic row
                        is linked whenever an update causes an enlargement of the
                        row. Each new link is at least 20 bytes, so the next
                        enlargement probably goes in the same link. If not, another
                        link is created. You can find the number of links using
                        <a class="link" href="programs.html#myisamchk" title="4.6.3&nbsp;myisamchk — MyISAM Table-Maintenance Utility"><span class="command"><strong>myisamchk -ed</strong></span></a>. All links may be removed
                        with <a class="link" href="sql-syntax.html#optimize-table" title="13.7.2.4&nbsp;OPTIMIZE TABLE Syntax"><code class="literal">OPTIMIZE TABLE</code></a> or
                        <a class="link" href="programs.html#myisamchk" title="4.6.3&nbsp;myisamchk — MyISAM Table-Maintenance Utility"><span class="command"><strong>myisamchk -r</strong></span></a>.
                    </p><p style="color:blue;">每个链接有6个字节的惩罚。每当更新导致行增大时，动态行都被链接。每一个新的链路至少有20个字节，所以下一个扩展可能在同一个链路中进行。否则，将创建另一个链接。您可以使用myisamchk-ed找到链接的数量。可以使用optimize table或myisamchk-r删除所有链接。</p></li></ul>
                </div>

            </div>
            <div class="section">
                <div class="titlepage">
                    <div>
                        <div>
                            <h4 class="title"><a name="compressed-format"></a>15.2.3.3&nbsp;Compressed Table Characteristics</h4>

                        </div>

                    </div>

                </div>
                <a class="indexterm" name="idm140286803373024"></a><a class="indexterm" name="idm140286803371568"></a><a class="indexterm" name="idm140286803370496"></a><a class="indexterm" name="idm140286803369008"></a><p>
                Compressed storage format is a read-only format that is
                generated with the <a class="link" href="programs.html#myisampack" title="4.6.5&nbsp;myisampack — Generate Compressed, Read-Only MyISAM Tables"><span class="command"><strong>myisampack</strong></span></a> tool.
                Compressed tables can be uncompressed with
                <a class="link" href="programs.html#myisamchk" title="4.6.3&nbsp;myisamchk — MyISAM Table-Maintenance Utility"><span class="command"><strong>myisamchk</strong></span></a>.
            </p><p style="color:blue;">压缩存储格式是一种只读格式，由myisampack工具生成。压缩表可以用myisamchk解压缩。</p><p>
                Compressed tables have the following characteristics:
            </p><p style="color:blue;">压缩表具有以下特征：</p>
                <div class="itemizedlist">
                    <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                        Compressed tables take very little disk space. This
                        minimizes disk usage, which is helpful when using slow disks
                        (such as CD-ROMs).
                    </p><p style="color:blue;">压缩表只占用很少的磁盘空间。这样可以最大限度地减少磁盘使用，这在使用慢速磁盘（如CD-ROM）时非常有用。</p></li><li class="listitem"><p>
                        Each row is compressed separately, so there is very little
                        access overhead. The header for a row takes up one to three
                        bytes depending on the biggest row in the table. Each column
                        is compressed differently. There is usually a different
                        Huffman tree for each column. Some of the compression types
                        are:
                    </p><p style="color:blue;">每一行都是单独压缩的，因此访问开销很小。根据表中最大的行，行的标题将占用1到3个字节。每列的压缩方式不同。每一列通常有不同的哈夫曼树。一些压缩类型是：</p>
                        <div class="itemizedlist">
                            <ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
                                Suffix space compression.
                            </p><p style="color:blue;">后缀空间压缩。</p></li><li class="listitem"><p>
                                Prefix space compression.
                            </p><p style="color:blue;">前缀空间压缩。</p></li><li class="listitem"><p>
                                Numbers with a value of zero are stored using one bit.
                            </p><p style="color:blue;">值为零的数字用一位存储。</p></li><li class="listitem"><p>
                                If values in an integer column have a small range, the
                                column is stored using the smallest possible type. For
                                example, a <a class="link" href="data-types.html#integer-types" title="11.2.1&nbsp;Integer Types (Exact Value) - INTEGER, INT, SMALLINT, TINYINT, MEDIUMINT, BIGINT"><code class="literal">BIGINT</code></a> column
                                (eight bytes) can be stored as a
                                <a class="link" href="data-types.html#integer-types" title="11.2.1&nbsp;Integer Types (Exact Value) - INTEGER, INT, SMALLINT, TINYINT, MEDIUMINT, BIGINT"><code class="literal">TINYINT</code></a> column (one byte)
                                if all its values are in the range from
                                <code class="literal">-128</code> to <code class="literal">127</code>.
                            </p><p style="color:blue;">如果整数列中的值的范围很小，则该列将使用尽可能小的类型存储。例如，如果bigint列（八个字节）的所有值都在-128到127的范围内，则它可以存储为tinyint列（一个字节）。</p></li><li class="listitem"><p>
                                If a column has only a small set of possible values, the
                                data type is converted to
                                <a class="link" href="data-types.html#enum" title="11.4.4&nbsp;The ENUM Type"><code class="literal">ENUM</code></a>.
                            </p><p style="color:blue;">如果列只有一小部分可能的值，则数据类型将转换为枚举。</p></li><li class="listitem"><p>
                                A column may use any combination of the preceding
                                compression types.
                            </p><p style="color:blue;">列可以使用前面压缩类型的任意组合。</p></li></ul>
                        </div>
                    </li><li class="listitem"><p>
                        Can be used for fixed-length or dynamic-length rows.
                    </p><p style="color:blue;">可用于固定长度或动态长度的行。</p></li></ul>
                </div>
                <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">
                    <div class="admon-title">
                        Note
                    </div>
                    <p>
                        While a compressed table is read only, and you cannot
                        therefore update or add rows in the table, DDL (Data
                        Definition Language) operations are still valid. For example,
                        you may still use <code class="literal">DROP</code> to drop the table,
                        and <a class="link" href="sql-syntax.html#truncate-table" title="13.1.34&nbsp;TRUNCATE TABLE Syntax"><code class="literal">TRUNCATE TABLE</code></a> to empty the
                        table.
                    </p><p style="color:blue;">虽然压缩表是只读的，因此不能在表中更新或添加行，但DDL（数据定义语言）操作仍然有效。例如，您仍然可以使用drop删除表，使用truncate table清空表。</p>
                </div>

            </div>

        </div>
        <div class="section">
            <div class="titlepage">
                <div>
                    <div>
                        <h3 class="title"><a name="myisam-table-problems"></a>15.2.4&nbsp;MyISAM Table Problems</h3>

                    </div>

                </div>

            </div>
            <div class="toc">
                <dl class="toc"><dt><span class="section"><a href="storage-engines.html#corrupted-myisam-tables">15.2.4.1 Corrupted MyISAM Tables</a></span></dt><dt><span class="section"><a href="storage-engines.html#myisam-table-close">15.2.4.2 Problems from Tables Not Being Closed Properly</a></span></dt></dl>
            </div>
            <p>
                The file format that MySQL uses to store data has been extensively
                tested, but there are always circumstances that may cause database
                tables to become corrupted. The following discussion describes how
                this can happen and how to handle it.
            </p><p style="color:blue;">mysql用来存储数据的文件格式已经过了广泛的测试，但是总是有可能导致数据库表损坏的情况。下面的讨论描述了这是如何发生的以及如何处理它。</p>
            <div class="section">

                <div class="titlepage">
                    <div>
                        <div>
                            <h4 class="title"><a name="corrupted-myisam-tables"></a>15.2.4.1&nbsp;Corrupted MyISAM Tables</h4>
                        </div>
                    </div>
                </div>
                <p>
                    Even though the <code class="literal">MyISAM</code> table format is very
                    reliable (all changes to a table made by an SQL statement are
                    written before the statement returns), you can still get
                    corrupted tables if any of the following events occur:
                </p><p style="color:blue;">尽管myisam表格式非常可靠（sql语句对表所做的所有更改都是在语句返回之前写入的），但如果发生以下任何事件，仍然可能会损坏表：</p>
                <div class="itemizedlist">
                    <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                        The <a class="link" href="programs.html#mysqld" title="4.3.1&nbsp;mysqld — The MySQL Server"><span class="command"><strong>mysqld</strong></span></a> process is killed in the
                        middle of a write.
                    </p><p style="color:blue;">mysqld进程在写入过程中被终止。</p></li><li class="listitem"><p>
                        An unexpected computer shutdown occurs (for example, the
                        computer is turned off).
                    </p><p style="color:blue;">发生意外的计算机关闭（例如，计算机已关闭）。</p></li><li class="listitem"><p>
                        Hardware failures.
                    </p><p style="color:blue;">硬件故障。</p></li><li class="listitem"><p>
                        You are using an external program (such as
                        <a class="link" href="programs.html#myisamchk" title="4.6.3&nbsp;myisamchk — MyISAM Table-Maintenance Utility"><span class="command"><strong>myisamchk</strong></span></a>) to modify a table that is
                        being modified by the server at the same time.
                    </p><p style="color:blue;">您正在使用外部程序（例如myisamchk）修改服务器同时修改的表。</p></li><li class="listitem"><p>
                        A software bug in the MySQL or <code class="literal">MyISAM</code>
                        code.
                    </p><p style="color:blue;">mysql或myisam代码中的软件错误。</p></li></ul>
                </div>
                <p>
                    Typical symptoms of a corrupt table are:
                </p><p style="color:blue;">损坏表的典型症状是：</p>
                <div class="itemizedlist">
                    <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                        You get the following error while selecting data from the
                        table:
                    </p><p style="color:blue;">从表中选择数据时出现以下错误：</p><pre data-lang="none" class="programlisting">Incorrect key file for table: '...'. Try to repair it
</pre></li><li class="listitem"><p>
                        Queries don't find rows in the table or return incomplete
                        results.
                    </p><p style="color:blue;">查询在表中找不到行或返回不完整的结果。</p></li></ul>
                </div>
                <p>
                    You can check the health of a <code class="literal">MyISAM</code> table
                    using the <a class="link" href="sql-syntax.html#check-table" title="13.7.2.2&nbsp;CHECK TABLE Syntax"><code class="literal">CHECK TABLE</code></a> statement,
                    and repair a corrupted <code class="literal">MyISAM</code> table with
                    <a class="link" href="sql-syntax.html#repair-table" title="13.7.2.5&nbsp;REPAIR TABLE Syntax"><code class="literal">REPAIR TABLE</code></a>. When
                    <a class="link" href="programs.html#mysqld" title="4.3.1&nbsp;mysqld — The MySQL Server"><span class="command"><strong>mysqld</strong></span></a> is not running, you can also check or
                    repair a table with the <a class="link" href="programs.html#myisamchk" title="4.6.3&nbsp;myisamchk — MyISAM Table-Maintenance Utility"><span class="command"><strong>myisamchk</strong></span></a> command.
                    See <a class="xref" href="sql-syntax.html#check-table" title="13.7.2.2&nbsp;CHECK TABLE Syntax">Section&nbsp;13.7.2.2, “CHECK TABLE Syntax”</a>,
                    <a class="xref" href="sql-syntax.html#repair-table" title="13.7.2.5&nbsp;REPAIR TABLE Syntax">Section&nbsp;13.7.2.5, “REPAIR TABLE Syntax”</a>, and <a class="xref" href="programs.html#myisamchk" title="4.6.3&nbsp;myisamchk — MyISAM Table-Maintenance Utility">Section&nbsp;4.6.3, “<span class="command"><strong>myisamchk</strong></span> — MyISAM Table-Maintenance Utility”</a>.
                </p><p style="color:blue;">可以使用check table语句检查myisam表的运行状况，并使用repair table修复损坏的myisam表。当mysqld未运行时，还可以使用myisamchk命令检查或修复表。见第13.7.2.2节，“检查表语法”，第13.7.2.5节，“修复表语法”，第4.6.3节，“myisamchk-myisam表维护实用程序”。</p><p>
                If your tables become corrupted frequently, you should try to
                determine why this is happening. The most important thing to
                know is whether the table became corrupted as a result of a
                server crash. You can verify this easily by looking for a recent
                <code class="literal">restarted mysqld</code> message in the error log. If
                there is such a message, it is likely that table corruption is a
                result of the server dying. Otherwise, corruption may have
                occurred during normal operation. This is a bug. You should try
                to create a reproducible test case that demonstrates the
                problem. See <a class="xref" href="error-handling.html#crashing" title="B.4.3.3&nbsp;What to Do If MySQL Keeps Crashing">Section&nbsp;B.4.3.3, “What to Do If MySQL Keeps Crashing”</a>, and
                <a class="xref" href="extending-mysql.html#porting" title="28.5&nbsp;Debugging and Porting MySQL">Section&nbsp;28.5, “Debugging and Porting MySQL”</a>.
            </p><p style="color:blue;">如果您的表经常损坏，则应尝试确定发生这种情况的原因。最重要的是要知道表是否由于服务器崩溃而损坏。您可以通过在错误日志中查找最近重新启动的mysqld消息来轻松验证这一点。如果存在这样的消息，则表损坏很可能是服务器死亡的结果。否则，在正常运行期间可能会发生损坏。这是一只虫子。您应该尝试创建一个可重复的测试用例来演示这个问题。请参阅B.4.3.3节，“如果MySQL继续崩溃该怎么办”，以及28.5节，“调试和移植MySQL”。</p>
            </div>
            <div class="section">
                <div class="titlepage">
                    <div>
                        <div>
                            <h4 class="title"><a name="myisam-table-close"></a>15.2.4.2&nbsp;Problems from Tables Not Being Closed Properly</h4>

                        </div>

                    </div>

                </div>
                <p>
                    Each <code class="literal">MyISAM</code> index file
                    (<code class="filename">.MYI</code> file) has a counter in the header
                    that can be used to check whether a table has been closed
                    properly. If you get the following warning from
                    <a class="link" href="sql-syntax.html#check-table" title="13.7.2.2&nbsp;CHECK TABLE Syntax"><code class="literal">CHECK TABLE</code></a> or
                    <a class="link" href="programs.html#myisamchk" title="4.6.3&nbsp;myisamchk — MyISAM Table-Maintenance Utility"><span class="command"><strong>myisamchk</strong></span></a>, it means that this counter has
                    gone out of sync:
                </p><p style="color:blue;">每个myisam索引文件（.myi文件）的头中都有一个计数器，可用于检查表是否已正确关闭。如果从check table或myisamchk收到以下警告，则表示此计数器已不同步：</p><pre data-lang="none" class="programlisting">clients are using or haven't closed the table properly
</pre><p>
                This warning doesn't necessarily mean that the table is
                corrupted, but you should at least check the table.
            </p><p style="color:blue;">此警告不一定表示表已损坏，但至少应该检查表。</p><p>
                The counter works as follows:
            </p><p style="color:blue;">柜台的工作原理如下：</p>
                <div class="itemizedlist">
                    <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                        The first time a table is updated in MySQL, a counter in the
                        header of the index files is incremented.
                    </p><p style="color:blue;">在mysql中，第一次更新表时，索引文件头中的计数器将递增。</p></li><li class="listitem"><p>
                        The counter is not changed during further updates.
                    </p><p style="color:blue;">计数器在进一步更新期间不会更改。</p></li><li class="listitem"><p>
                        When the last instance of a table is closed (because a
                        <a class="link" href="sql-syntax.html#flush-tables"><code class="literal">FLUSH TABLES</code></a> operation was
                        performed or because there is no room in the table cache),
                        the counter is decremented if the table has been updated at
                        any point.
                    </p><p style="color:blue;">当表的最后一个实例关闭时（因为执行了刷新表操作，或者因为表缓存中没有空间），如果表在任何时候已更新，则计数器将递减。</p></li><li class="listitem"><p>
                        When you repair the table or check the table and it is found
                        to be okay, the counter is reset to zero.
                    </p><p style="color:blue;">当你修理桌子或检查桌子，发现它是好的，计数器被重置为零。</p></li><li class="listitem"><p>
                        To avoid problems with interaction with other processes that
                        might check the table, the counter is not decremented on
                        close if it was zero.
                    </p><p style="color:blue;">为了避免与可能检查表的其他进程交互时出现问题，如果计数器为零，则在关闭时不会递减。</p></li></ul>
                </div>
                <p>
                    In other words, the counter can become incorrect only under
                    these conditions:
                </p><p style="color:blue;">换言之，只有在以下情况下，计数器才会出错：</p>
                <div class="itemizedlist">
                    <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                        A <code class="literal">MyISAM</code> table is copied without first
                        issuing <a class="link" href="sql-syntax.html#lock-tables" title="13.3.5&nbsp;LOCK TABLES and UNLOCK TABLES Syntax"><code class="literal">LOCK TABLES</code></a> and
                        <a class="link" href="sql-syntax.html#flush-tables"><code class="literal">FLUSH TABLES</code></a>.
                    </p><p style="color:blue;">复制myisam表时，不会首先发出锁表和刷新表。</p></li><li class="listitem"><p>
                        MySQL has crashed between an update and the final close.
                        (The table may still be okay because MySQL always issues
                        writes for everything between each statement.)
                    </p><p style="color:blue;">MySQL在更新和最终关闭之间崩溃。（该表可能仍然可以，因为mysql总是为每个语句之间的所有内容发出写操作。）</p></li><li class="listitem"><p>
                        A table was modified by <a class="link" href="programs.html#myisamchk" title="4.6.3&nbsp;myisamchk — MyISAM Table-Maintenance Utility"><span class="command"><strong>myisamchk
            --recover</strong></span></a> or <a class="link" href="programs.html#myisamchk" title="4.6.3&nbsp;myisamchk — MyISAM Table-Maintenance Utility"><span class="command"><strong>myisamchk
            --update-state</strong></span></a> at the same time that it was in use
                        by <a class="link" href="programs.html#mysqld" title="4.3.1&nbsp;mysqld — The MySQL Server"><span class="command"><strong>mysqld</strong></span></a>.
                    </p><p style="color:blue;">myisamchk--recover或myisamchk--update state在mysqld使用表的同时修改了该表。</p></li><li class="listitem"><p>
                        Multiple <a class="link" href="programs.html#mysqld" title="4.3.1&nbsp;mysqld — The MySQL Server"><span class="command"><strong>mysqld</strong></span></a> servers are using the
                        table and one server performed a <a class="link" href="sql-syntax.html#repair-table" title="13.7.2.5&nbsp;REPAIR TABLE Syntax"><code class="literal">REPAIR
                        TABLE</code></a> or <a class="link" href="sql-syntax.html#check-table" title="13.7.2.2&nbsp;CHECK TABLE Syntax"><code class="literal">CHECK
                        TABLE</code></a> on the table while it was in use by another
                        server. In this setup, it is safe to use
                        <a class="link" href="sql-syntax.html#check-table" title="13.7.2.2&nbsp;CHECK TABLE Syntax"><code class="literal">CHECK TABLE</code></a>, although you
                        might get the warning from other servers. However,
                        <a class="link" href="sql-syntax.html#repair-table" title="13.7.2.5&nbsp;REPAIR TABLE Syntax"><code class="literal">REPAIR TABLE</code></a> should be
                        avoided because when one server replaces the data file with
                        a new one, this is not known to the other servers.
                    </p><p style="color:blue;">多台mysqld服务器正在使用该表，一台服务器在另一台服务器使用该表时对该表执行了修复表或检查表。在这个设置中，使用check table是安全的，尽管您可能会从其他服务器收到警告。但是，应该避免使用repair table，因为当一台服务器用新的数据文件替换数据文件时，其他服务器并不知道这一点。</p><p>
                        In general, it is a bad idea to share a data directory among
                        multiple servers. See <a class="xref" href="server-administration.html#multiple-servers" title="5.7&nbsp;Running Multiple MySQL Instances on One Machine">Section&nbsp;5.7, “Running Multiple MySQL Instances on One Machine”</a>,
                        for additional discussion.
                    </p><p style="color:blue;">一般来说，在多个服务器之间共享一个数据目录是一个坏主意。有关更多讨论，请参见第5.7节“在一台计算机上运行多个mysql实例”。</p></li></ul>
                </div>

            </div>

        </div>

    </div>
    <div class="section">
        <div class="titlepage">
            <div>
                <div>
                    <h2 class="title" style="clear: both"><a name="memory-storage-engine"></a>15.3&nbsp;The MEMORY Storage Engine</h2>

                </div>

            </div>

        </div>
        <a class="indexterm" name="idm140286803284480"></a><a class="indexterm" name="idm140286803283440"></a><a class="indexterm" name="idm140286803282368"></a><a class="indexterm" name="idm140286803280880"></a><p>
        The <code class="literal">MEMORY</code> storage engine (formerly known as
        <code class="literal">HEAP</code>) creates special-purpose tables with
        contents that are stored in memory. Because the data is vulnerable
        to crashes, hardware issues, or power outages, only use these tables
        as temporary work areas or read-only caches for data pulled from
        other tables.
    </p><p style="color:blue;">内存存储引擎（以前称为堆）使用存储在内存中的内容创建特殊用途的表。由于数据易受崩溃、硬件问题或断电的影响，因此只能将这些表用作临时工作区或从其他表中提取的数据的只读缓存。</p>
        <div class="table">
            <a name="idm140286803277264"></a><p class="title"><b>Table&nbsp;15.4&nbsp;MEMORY Storage Engine Features</b></p><p style="color:blue;">表15.4内存存储引擎特性</p>
            <div class="table-contents">
                <table frame="box" rules="all" summary="Features supported by the MEMORY storage engine."><colgroup><col width="60%"><col width="40%"></colgroup><thead><tr><th scope="col">Feature</th>
                    <th scope="col">Support</th>
                </tr></thead><tbody><tr><td scope="row"><span class="bold"><strong>B-tree indexes</strong></span></td>
                    <td>Yes</td>
                </tr><tr><td scope="row"><span class="bold"><strong>Backup/point-in-time recovery</strong></span> (Implemented in the server, rather than in the storage engine.)</td>
                    <td>Yes</td>
                </tr><tr><td scope="row"><span class="bold"><strong>Cluster database support</strong></span></td>
                    <td>No</td>
                </tr><tr><td scope="row"><span class="bold"><strong>Clustered indexes</strong></span></td>
                    <td>No</td>
                </tr><tr><td scope="row"><span class="bold"><strong>Compressed data</strong></span></td>
                    <td>No</td>
                </tr><tr><td scope="row"><span class="bold"><strong>Data caches</strong></span></td>
                    <td>N/A</td>
                </tr><tr><td scope="row"><span class="bold"><strong>Encrypted data</strong></span></td>
                    <td>Yes (Implemented in the server via encryption functions.)</td>
                </tr><tr><td scope="row"><span class="bold"><strong>Foreign key support</strong></span></td>
                    <td>No</td>
                </tr><tr><td scope="row"><span class="bold"><strong>Full-text search indexes</strong></span></td>
                    <td>No</td>
                </tr><tr><td scope="row"><span class="bold"><strong>Geospatial data type support</strong></span></td>
                    <td>No</td>
                </tr><tr><td scope="row"><span class="bold"><strong>Geospatial indexing support</strong></span></td>
                    <td>No</td>
                </tr><tr><td scope="row"><span class="bold"><strong>Hash indexes</strong></span></td>
                    <td>Yes</td>
                </tr><tr><td scope="row"><span class="bold"><strong>Index caches</strong></span></td>
                    <td>N/A</td>
                </tr><tr><td scope="row"><span class="bold"><strong>Locking granularity</strong></span></td>
                    <td>Table</td>
                </tr><tr><td scope="row"><span class="bold"><strong>MVCC</strong></span></td>
                    <td>No</td>
                </tr><tr><td scope="row"><span class="bold"><strong>Replication support</strong></span> (Implemented in the server, rather than in the storage engine.)</td>
                    <td>Limited (See the discussion later in this section.)</td>
                </tr><tr><td scope="row"><span class="bold"><strong>Storage limits</strong></span></td>
                    <td>RAM</td>
                </tr><tr><td scope="row"><span class="bold"><strong>T-tree indexes</strong></span></td>
                    <td>No</td>
                </tr><tr><td scope="row"><span class="bold"><strong>Transactions</strong></span></td>
                    <td>No</td>
                </tr><tr><td scope="row"><span class="bold"><strong>Update statistics for data dictionary</strong></span></td>
                    <td>Yes</td>
                </tr></tbody></table>
            </div>

        </div>
        <br class="table-break">
        <div class="itemizedlist">
            <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><a class="xref" href="storage-engines.html#memory-storage-engine-compared-cluster" title="When to Use MEMORY or NDB Cluster">When to Use MEMORY or NDB Cluster</a></p><p style="color:blue;">何时使用内存或ndb集群</p></li><li class="listitem"><p><a class="xref" href="storage-engines.html#memory-storage-engine-performance-characteristics" title="Performance Characteristics">Performance Characteristics</a></p><p style="color:blue;">性能特点</p></li><li class="listitem"><p><a class="xref" href="storage-engines.html#memory-storage-engine-characteristics-of-memory-tables" title="Characteristics of MEMORY Tables">Characteristics of MEMORY Tables</a></p><p style="color:blue;">内存表的特性</p></li><li class="listitem"><p><a class="xref" href="storage-engines.html#memory-storage-engine-ddl-operations-for-memory-tables" title="DDL Operations for MEMORY Tables">DDL Operations for MEMORY Tables</a></p><p style="color:blue;">内存表的ddl操作</p></li><li class="listitem"><p><a class="xref" href="storage-engines.html#memory-storage-engine-indexes" title="Indexes">Indexes</a></p><p style="color:blue;">索引</p></li><li class="listitem"><p><a class="xref" href="storage-engines.html#memory-storage-engine-user-created-and-temporary-tables" title="User-Created and Temporary Tables">User-Created and Temporary Tables</a></p><p style="color:blue;">用户创建的表和临时表</p></li><li class="listitem"><p><a class="xref" href="storage-engines.html#memory-storage-engine-loading-data" title="Loading Data">Loading Data</a></p><p style="color:blue;">加载数据</p></li><li class="listitem"><p><a class="xref" href="storage-engines.html#memory-tables-replication" title="MEMORY Tables and Replication">MEMORY Tables and Replication</a></p><p style="color:blue;">内存表和复制</p></li><li class="listitem"><p><a class="xref" href="storage-engines.html#memory-storage-engine-managing-memory-use" title="Managing Memory Use">Managing Memory Use</a></p><p style="color:blue;">管理内存使用</p></li><li class="listitem"><p><a class="xref" href="storage-engines.html#memory-storage-engine-additional-resources" title="Additional Resources">Additional Resources</a></p><p style="color:blue;">额外资源</p></li></ul>
        </div>

        <div class="simplesect">

            <div class="titlepage">
                <div>

                    <div class="simple">
                        <h3 class="title"><a name="memory-storage-engine-compared-cluster"></a>When to Use MEMORY or NDB Cluster</h3>

                    </div>

                </div>

            </div>
            <p>
                Developers looking to deploy applications that use the
                <code class="literal">MEMORY</code> storage engine for important, highly
                available, or frequently updated data should consider whether NDB
                Cluster is a better choice. A typical use case for the
                <code class="literal">MEMORY</code> engine involves these characteristics:
            </p><p style="color:blue;">如果开发人员希望部署使用内存存储引擎来存储重要、高可用或频繁更新的数据的应用程序，则应考虑ndb集群是否是一个更好的选择。内存引擎的典型用例包含以下特性：</p>
            <div class="itemizedlist">
                <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                    Operations involving transient, non-critical data such as
                    session management or caching. When the MySQL server halts or
                    restarts, the data in <code class="literal">MEMORY</code> tables is
                    lost.
                </p><p style="color:blue;">涉及瞬态、非关键数据的操作，如会话管理或缓存。当mysql服务器停止或重新启动时，内存表中的数据将丢失。</p></li><li class="listitem"><p>
                    In-memory storage for fast access and low latency. Data volume
                    can fit entirely in memory without causing the operating
                    system to swap out virtual memory pages.
                </p><p style="color:blue;">内存存储，访问速度快，延迟低。数据卷可以完全放在内存中，而不会导致操作系统交换虚拟内存页。</p></li><li class="listitem"><p>
                    A read-only or read-mostly data access pattern (limited
                    updates).
                </p><p style="color:blue;">只读或以读为主的数据访问模式（有限更新）。</p></li></ul>
            </div>
            <p>
                NDB Cluster offers the same features as the
                <code class="literal">MEMORY</code> engine with higher performance levels,
                and provides additional features not available with
                <code class="literal">MEMORY</code>:
            </p><p style="color:blue;">ndb集群提供了与内存引擎相同的功能，具有更高的性能级别，并提供了内存不可用的其他功能：</p>
            <div class="itemizedlist">
                <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                    Row-level locking and multiple-thread operation for low
                    contention between clients.
                </p><p style="color:blue;">行级锁定和多线程操作，以减少客户端之间的争用。</p></li><li class="listitem"><p>
                    Scalability even with statement mixes that include writes.
                </p><p style="color:blue;">可伸缩性，即使是包含写操作的语句混合。</p></li><li class="listitem"><p>
                    Optional disk-backed operation for data durability.
                </p><p style="color:blue;">可选的磁盘备份操作，保证数据的持久性。</p></li><li class="listitem"><p>
                    Shared-nothing architecture and multiple-host operation with
                    no single point of failure, enabling 99.999% availability.
                </p><p style="color:blue;">无共享架构和多主机操作，无单点故障，支持99.999%的可用性。</p></li><li class="listitem"><p>
                    Automatic data distribution across nodes; application
                    developers need not craft custom sharding or partitioning
                    solutions.
                </p><p style="color:blue;">跨节点的自动数据分发；应用程序开发人员不需要定制分片或分区解决方案。</p></li><li class="listitem"><p>
                    Support for variable-length data types (including
                    <a class="link" href="data-types.html#blob" title="11.4.3&nbsp;The BLOB and TEXT Types"><code class="literal">BLOB</code></a> and
                    <a class="link" href="data-types.html#blob" title="11.4.3&nbsp;The BLOB and TEXT Types"><code class="literal">TEXT</code></a>) not supported by
                    <code class="literal">MEMORY</code>.
                </p><p style="color:blue;">内存不支持可变长度数据类型（包括blob和文本）。</p></li></ul>
            </div>

        </div>
        <div class="simplesect">
            <div class="titlepage">
                <div>
                    <div class="simple">
                        <h3 class="title"><a name="memory-storage-engine-performance-characteristics"></a>Performance Characteristics</h3>

                    </div>

                </div>

            </div>
            <p>
                <code class="literal">MEMORY</code> performance is constrained by contention
                resulting from single-thread execution and table lock overhead
                when processing updates. This limits scalability when load
                increases, particularly for statement mixes that include writes.
            </p><p style="color:blue;">内存性能受单线程执行导致的争用和处理更新时的表锁开销限制。这限制了负载增加时的可伸缩性，特别是对于包含写操作的语句混合。</p><p>
            Despite the in-memory processing for <code class="literal">MEMORY</code>
            tables, they are not necessarily faster than
            <a class="link" href="innodb-storage-engine.html" title="Chapter&nbsp;14&nbsp;The InnoDB Storage Engine"><code class="literal">InnoDB</code></a> tables on a busy server, for
            general-purpose queries, or under a read/write workload. In
            particular, the table locking involved with performing updates can
            slow down concurrent usage of <code class="literal">MEMORY</code> tables
            from multiple sessions.
        </p><p style="color:blue;">尽管对内存表进行了内存处理，但对于通用查询或读/写工作负载，它们并不一定比繁忙服务器上的innodb表快。特别是，执行更新所涉及的表锁定可以减缓多个会话中内存表的并发使用。</p><p>
            Depending on the kinds of queries performed on a
            <code class="literal">MEMORY</code> table, you might create indexes as
            either the default hash data structure (for looking up single
            values based on a unique key), or a general-purpose B-tree data
            structure (for all kinds of queries involving equality,
            inequality, or range operators such as less than or greater than).
            The following sections illustrate the syntax for creating both
            kinds of indexes. A common performance issue is using the default
            hash indexes in workloads where B-tree indexes are more efficient.
        </p><p style="color:blue;">根据对内存表执行的查询类型，可以将索引创建为默认哈希数据结构（用于基于唯一键查找单个值）或通用B树数据结构（用于涉及等式、不等式或范围运算符（如小于或大于）的所有查询）。以下各节说明创建这两种索引的语法。一个常见的性能问题是在b树索引效率更高的工作负载中使用默认哈希索引。</p>
        </div>
        <div class="simplesect">
            <div class="titlepage">
                <div>
                    <div class="simple">
                        <h3 class="title"><a name="memory-storage-engine-characteristics-of-memory-tables"></a>Characteristics of MEMORY Tables</h3>

                    </div>

                </div>

            </div>
            <p>
                The <code class="literal">MEMORY</code> storage engine associates each table
                with one disk file, which stores the table definition (not the
                data). The file name begins with the table name and has an
                extension of <code class="filename">.frm</code>.
            </p><p style="color:blue;">内存存储引擎将每个表与一个存储表定义（而不是数据）的磁盘文件相关联。文件名以表名开头，扩展名为.frm。</p><p>
            <code class="literal">MEMORY</code> tables have the following
            characteristics:
        </p><p style="color:blue;">内存表具有以下特征：</p>
            <div class="itemizedlist">
                <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                    Space for <code class="literal">MEMORY</code> tables is allocated in
                    small blocks. Tables use 100% dynamic hashing for inserts. No
                    overflow area or extra key space is needed. No extra space is
                    needed for free lists. Deleted rows are put in a linked list
                    and are reused when you insert new data into the table.
                    <code class="literal">MEMORY</code> tables also have none of the
                    problems commonly associated with deletes plus inserts in
                    hashed tables.
                </p><p style="color:blue;">内存表的空间是以小块的形式分配的。表对插入使用100%动态哈希。不需要溢出区域或额外的密钥空间。免费列表不需要额外的空间。删除的行放在链接列表中，并在向表中插入新数据时重复使用。内存表也没有通常与哈希表中的delete和insert相关联的问题。</p></li><li class="listitem"><p>
                    <code class="literal">MEMORY</code> tables use a fixed-length
                    row-storage format. Variable-length types such as
                    <a class="link" href="data-types.html#char" title="11.4.1&nbsp;The CHAR and VARCHAR Types"><code class="literal">VARCHAR</code></a> are stored using a
                    fixed length.
                </p><p style="color:blue;">内存表使用固定长度的行存储格式。可变长度类型（如varchar）使用固定长度存储。</p></li><li class="listitem"><p>
                    <code class="literal">MEMORY</code> tables cannot contain
                    <a class="link" href="data-types.html#blob" title="11.4.3&nbsp;The BLOB and TEXT Types"><code class="literal">BLOB</code></a> or
                    <a class="link" href="data-types.html#blob" title="11.4.3&nbsp;The BLOB and TEXT Types"><code class="literal">TEXT</code></a> columns.
                </p><p style="color:blue;">内存表不能包含blob列或文本列。</p></li><li class="listitem"><p>
                    <code class="literal">MEMORY</code> includes support for
                    <code class="literal">AUTO_INCREMENT</code> columns.
                </p><p style="color:blue;">内存包括对自动递增列的支持。</p></li><li class="listitem"><p>
                    Non-<code class="literal">TEMPORARY</code> <code class="literal">MEMORY</code>
                    tables are shared among all clients, just like any other
                    non-<code class="literal">TEMPORARY</code> table.
                </p><p style="color:blue;">非临时内存表在所有客户机之间共享，就像任何其他非临时表一样。</p></li></ul>
            </div>

        </div>
        <div class="simplesect">
            <div class="titlepage">
                <div>
                    <div class="simple">
                        <h3 class="title"><a name="memory-storage-engine-ddl-operations-for-memory-tables"></a>DDL Operations for MEMORY Tables</h3>

                    </div>

                </div>

            </div>
            <p>
                To create a <code class="literal">MEMORY</code> table, specify the clause
                <code class="literal">ENGINE=MEMORY</code> on the
                <a class="link" href="sql-syntax.html#create-table" title="13.1.18&nbsp;CREATE TABLE Syntax"><code class="literal">CREATE TABLE</code></a> statement.
            </p><p style="color:blue;">要创建内存表，请在CREATETABLE语句中指定ENGINE=memory子句。</p><pre data-lang="sql" class="programlisting">CREATE TABLE t (i INT) ENGINE = MEMORY;
</pre><p>
            As indicated by the engine name, <code class="literal">MEMORY</code> tables
            are stored in memory. They use hash indexes by default, which
            makes them very fast for single-value lookups, and very useful for
            creating temporary tables. However, when the server shuts down,
            all rows stored in <code class="literal">MEMORY</code> tables are lost. The
            tables themselves continue to exist because their definitions are
            stored in <code class="filename">.frm</code> files on disk, but they are
            empty when the server restarts.
        </p><p style="color:blue;">如引擎名所示，内存表存储在内存中。默认情况下，它们使用散列索引，这使得它们对于单值查找非常快速，并且对于创建临时表非常有用。但是，当服务器关闭时，存储在内存表中的所有行都将丢失。表本身仍然存在，因为它们的定义存储在磁盘上的.FRM文件中，但当服务器重新启动时，它们是空的。</p><p>
            This example shows how you might create, use, and remove a
            <code class="literal">MEMORY</code> table:
        </p><p style="color:blue;">此示例显示如何创建、使用和删除内存表：</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>CREATE TABLE test ENGINE=MEMORY</code></strong>
           <strong class="userinput"><code>SELECT ip,SUM(downloads) AS down</code></strong>
           <strong class="userinput"><code>FROM log_table GROUP BY ip;</code></strong>
mysql&gt; <strong class="userinput"><code>SELECT COUNT(ip),AVG(down) FROM test;</code></strong>
mysql&gt; <strong class="userinput"><code>DROP TABLE test;</code></strong>
</pre><p>
            The maximum size of <code class="literal">MEMORY</code> tables is limited by
            the <a class="link" href="server-administration.html#sysvar_max_heap_table_size"><code class="literal">max_heap_table_size</code></a> system
            variable, which has a default value of 16MB. To enforce different
            size limits for <code class="literal">MEMORY</code> tables, change the value
            of this variable. The value in effect for
            <a class="link" href="sql-syntax.html#create-table" title="13.1.18&nbsp;CREATE TABLE Syntax"><code class="literal">CREATE TABLE</code></a>, or a subsequent
            <a class="link" href="sql-syntax.html#alter-table" title="13.1.8&nbsp;ALTER TABLE Syntax"><code class="literal">ALTER TABLE</code></a> or
            <a class="link" href="sql-syntax.html#truncate-table" title="13.1.34&nbsp;TRUNCATE TABLE Syntax"><code class="literal">TRUNCATE TABLE</code></a>, is the value used
            for the life of the table. A server restart also sets the maximum
            size of existing <code class="literal">MEMORY</code> tables to the global
            <a class="link" href="server-administration.html#sysvar_max_heap_table_size"><code class="literal">max_heap_table_size</code></a> value. You
            can set the size for individual tables as described later in this
            section.
        </p><p style="color:blue;">内存表的最大大小受Max HeaPaTable大小系统变量的限制，该变量具有16MB的默认值。要对内存表强制不同的大小限制，请更改此变量的值。对于create table、后续alter table或truncate table有效的值是用于表生命周期的值。服务器重新启动还将现有内存表的最大大小设置为全局Max HypAppTable大小的值。您可以设置单个表的大小，如本节后面所述。</p>
        </div>
        <div class="simplesect">
            <div class="titlepage">
                <div>
                    <div class="simple">
                        <h3 class="title"><a name="memory-storage-engine-indexes"></a>Indexes</h3>

                    </div>

                </div>

            </div>
            <p>
                The <code class="literal">MEMORY</code> storage engine supports both
                <code class="literal">HASH</code> and <code class="literal">BTREE</code> indexes. You
                can specify one or the other for a given index by adding a
                <code class="literal">USING</code> clause as shown here:
            </p><p style="color:blue;">内存存储引擎支持哈希和btree索引。通过添加using子句，可以为给定索引指定一个或另一个，如下所示：</p><pre data-lang="sql" class="programlisting">CREATE TABLE lookup
    (id INT, INDEX USING HASH (id))
    ENGINE = MEMORY;
CREATE TABLE lookup
    (id INT, INDEX USING BTREE (id))
    ENGINE = MEMORY;
</pre><p>
            For general characteristics of B-tree and hash indexes, see
            <a class="xref" href="optimization.html#mysql-indexes" title="8.3.1&nbsp;How MySQL Uses Indexes">Section&nbsp;8.3.1, “How MySQL Uses Indexes”</a>.
        </p><p style="color:blue;">有关b树和散列索引的一般特性，请参阅8.3.1节“MySQL如何使用索引”。</p><p>
            <code class="literal">MEMORY</code> tables can have up to 64 indexes per
            table, 16 columns per index and a maximum key length of 3072
            bytes.
        </p><p style="color:blue;">内存表每表最多可有64个索引，每个索引有16个列，最大的密钥长度为3072个字节。</p><p>
            If a <code class="literal">MEMORY</code> table hash index has a high degree
            of key duplication (many index entries containing the same value),
            updates to the table that affect key values and all deletes are
            significantly slower. The degree of this slowdown is proportional
            to the degree of duplication (or, inversely proportional to the
            index cardinality). You can use a <code class="literal">BTREE</code> index
            to avoid this problem.
        </p><p style="color:blue;">如果内存表哈希索引具有高度的键重复（许多索引项包含相同的值），则对影响键值和所有删除的表的更新速度会明显减慢。这种放缓的程度与重复程度成正比（或与指数基数成反比）。可以使用btree索引来避免此问题。</p><p>
            <code class="literal">MEMORY</code> tables can have nonunique keys. (This is
            an uncommon feature for implementations of hash indexes.)
        </p><p style="color:blue;">内存表可以有非唯一键。（对于哈希索引的实现，这是一个不常见的特性。）</p><p>
            Columns that are indexed can contain <code class="literal">NULL</code>
            values.
        </p><p style="color:blue;">索引的列可以包含空值。</p>
        </div>
        <div class="simplesect">
            <div class="titlepage">
                <div>
                    <div class="simple">
                        <h3 class="title"><a name="memory-storage-engine-user-created-and-temporary-tables"></a>User-Created and Temporary Tables</h3>

                    </div>

                </div>

            </div>
            <p>
                <code class="literal">MEMORY</code> table contents are stored in memory,
                which is a property that <code class="literal">MEMORY</code> tables share
                with internal temporary tables that the server creates on the fly
                while processing queries. However, the two types of tables differ
                in that <code class="literal">MEMORY</code> tables are not subject to
                storage conversion, whereas internal temporary tables are:
            </p><p style="color:blue;">内存表内容存储在内存中，这是内存表与服务器在处理查询时动态创建的内部临时表共享的属性。但是，这两种表的不同之处在于，内存表不受存储转换的影响，而内部临时表是：</p>
            <div class="itemizedlist">
                <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                    If an internal temporary table becomes too large, the server
                    automatically converts it to on-disk storage, as described in
                    <a class="xref" href="optimization.html#internal-temporary-tables" title="8.4.4&nbsp;Internal Temporary Table Use in MySQL">Section&nbsp;8.4.4, “Internal Temporary Table Use in MySQL”</a>.
                </p><p style="color:blue;">如果内部临时表太大，服务器会自动将其转换为磁盘存储，如8.4.4节“MySQL中的内部临时表使用”所述。</p></li><li class="listitem"><p>
                    User-created <code class="literal">MEMORY</code> tables are never
                    converted to disk tables.
                </p><p style="color:blue;">用户创建的内存表永远不会转换为磁盘表。</p></li></ul>
            </div>

        </div>
        <div class="simplesect">
            <div class="titlepage">
                <div>
                    <div class="simple">
                        <h3 class="title"><a name="memory-storage-engine-loading-data"></a>Loading Data</h3>

                    </div>

                </div>

            </div>
            <p>
                To populate a <code class="literal">MEMORY</code> table when the MySQL
                server starts, you can use the
                <a class="link" href="server-administration.html#sysvar_init_file"><code class="literal">init_file</code></a> system variable. For
                example, you can put statements such as
                <a class="link" href="sql-syntax.html#insert-select" title="13.2.5.1&nbsp;INSERT ... SELECT Syntax"><code class="literal">INSERT INTO ...
                    SELECT</code></a> or <a class="link" href="sql-syntax.html#load-data" title="13.2.6&nbsp;LOAD DATA Syntax"><code class="literal">LOAD DATA</code></a> into
                a file to load the table from a persistent data source, and use
                <a class="link" href="server-administration.html#sysvar_init_file"><code class="literal">init_file</code></a> to name the file. See
                <a class="xref" href="server-administration.html#server-system-variables" title="5.1.7&nbsp;Server System Variables">Section&nbsp;5.1.7, “Server System Variables”</a>, and
                <a class="xref" href="sql-syntax.html#load-data" title="13.2.6&nbsp;LOAD DATA Syntax">Section&nbsp;13.2.6, “LOAD DATA Syntax”</a>.
            </p><p style="color:blue;">要在mysql服务器启动时填充内存表，可以使用init_file系统变量。例如，可以将insert等语句放入…选择或将数据加载到文件中以从持久数据源加载表，并使用init_file命名文件。参见第5.1.7节“服务器系统变量”和第13.2.6节“加载数据语法”。</p>
        </div>
        <div class="simplesect">
            <div class="titlepage">
                <div>
                    <div class="simple">
                        <h3 class="title"><a name="memory-tables-replication"></a>MEMORY Tables and Replication</h3>

                    </div>

                </div>

            </div>
            <p>
                A server's <code class="literal">MEMORY</code> tables become empty when it
                is shut down and restarted. If the server is a replication master,
                its slaves are not aware that these tables have become empty, so
                you see out-of-date content if you select data from the tables on
                the slaves. To synchronize master and slave
                <code class="literal">MEMORY</code> tables, when a <code class="literal">MEMORY</code>
                table is used on a master for the first time since it was started,
                a <a class="link" href="sql-syntax.html#delete" title="13.2.2&nbsp;DELETE Syntax"><code class="literal">DELETE</code></a> statement is written to
                the master's binary log, to empty the table on the slaves also.
                The slave still has outdated data in the table during the interval
                between the master's restart and its first use of the table. To
                avoid this interval when a direct query to the slave could return
                stale data, use the <a class="link" href="server-administration.html#sysvar_init_file"><code class="literal">init_file</code></a>
                system variable set to name a file containing statements that
                populate the <code class="literal">MEMORY</code> table on the master at
                startup.
            </p><p style="color:blue;">服务器的内存表在关闭和重新启动时变为空。如果服务器是复制主服务器，则其从属服务器不会意识到这些表已变为空，因此如果从从属服务器上的表中选择数据，则会看到过期的内容。要同步主内存表和从内存表，当主内存表自启动以来第一次在主内存表上使用时，会将delete语句写入主内存的二进制日志，同时清空从内存表。从机在主机重新启动和首次使用表之间的时间间隔内，表中仍有过时的数据。要避免直接查询从机可能返回过时数据时出现此间隔，请使用init_file系统变量集命名一个文件，该文件包含在启动时填充主机内存表的语句。</p>
        </div>
        <div class="simplesect">
            <div class="titlepage">
                <div>
                    <div class="simple">
                        <h3 class="title"><a name="memory-storage-engine-managing-memory-use"></a>Managing Memory Use</h3>

                    </div>

                </div>

            </div>
            <p>
                The server needs sufficient memory to maintain all
                <code class="literal">MEMORY</code> tables that are in use at the same time.
            </p><p style="color:blue;">服务器需要足够的内存来维护同时使用的所有内存表。</p><p>
            Memory is not reclaimed if you delete individual rows from a
            <code class="literal">MEMORY</code> table. Memory is reclaimed only when the
            entire table is deleted. Memory that was previously used for
            deleted rows is re-used for new rows within the same table. To
            free all the memory used by a <code class="literal">MEMORY</code> table when
            you no longer require its contents, execute
            <a class="link" href="sql-syntax.html#delete" title="13.2.2&nbsp;DELETE Syntax"><code class="literal">DELETE</code></a> or
            <a class="link" href="sql-syntax.html#truncate-table" title="13.1.34&nbsp;TRUNCATE TABLE Syntax"><code class="literal">TRUNCATE TABLE</code></a> to remove all rows,
            or remove the table altogether using <a class="link" href="sql-syntax.html#drop-table" title="13.1.29&nbsp;DROP TABLE Syntax"><code class="literal">DROP
            TABLE</code></a>. To free up the memory used by deleted rows, use
            <code class="literal">ALTER TABLE ENGINE=MEMORY</code> to force a table
            rebuild.
        </p><p style="color:blue;">如果从内存表中删除单个行，则不会回收内存。只有删除整个表时，才会回收内存。以前用于删除行的内存将重新用于同一表中的新行。若要在不再需要内存表的内容时释放该表使用的所有内存，请执行delete或truncate table以删除所有行，或使用drop table完全删除该表。要释放已删除行使用的内存，请使用alter table engine=memory强制表重建。</p><p>
            The memory needed for one row in a <code class="literal">MEMORY</code> table
            is calculated using the following expression:
        </p><p style="color:blue;">使用以下表达式计算内存表中一行所需的内存：</p><pre data-lang="sql" class="programlisting">SUM_OVER_ALL_BTREE_KEYS(<em class="replaceable"><code>max_length_of_key</code></em> + sizeof(char*) * 4)
+ SUM_OVER_ALL_HASH_KEYS(sizeof(char*) * 2)
+ ALIGN(<em class="replaceable"><code>length_of_row</code></em>+1, sizeof(char*))
</pre><p>
            <code class="literal">ALIGN()</code> represents a round-up factor to cause
            the row length to be an exact multiple of the
            <code class="literal">char</code> pointer size.
            <code class="literal">sizeof(char*)</code> is 4 on 32-bit machines and 8 on
            64-bit machines.
        </p><p style="color:blue;">align（）表示使行长度为字符指针大小的精确倍数的舍入因子。sizeof（char*）在32位计算机上为4，在64位计算机上为8。</p><p>
            As mentioned earlier, the
            <a class="link" href="server-administration.html#sysvar_max_heap_table_size"><code class="literal">max_heap_table_size</code></a> system
            variable sets the limit on the maximum size of
            <code class="literal">MEMORY</code> tables. To control the maximum size for
            individual tables, set the session value of this variable before
            creating each table. (Do not change the global
            <a class="link" href="server-administration.html#sysvar_max_heap_table_size"><code class="literal">max_heap_table_size</code></a> value unless
            you intend the value to be used for <code class="literal">MEMORY</code>
            tables created by all clients.) The following example creates two
            <code class="literal">MEMORY</code> tables, with a maximum size of 1MB and
            2MB, respectively:
        </p><p style="color:blue;">正如前面提到的，Max HeaPaTabLayLyStand系统变量设置了内存表最大大小的限制。要控制单个表的最大大小，在创建每个表之前，先设置这个变量的会话值。（除非您想将值用于所有客户端创建的内存表中，否则不更改全局Max HeavaPabl大小）。下面的示例分别创建两个内存表，最大大小分别为1MB和2MB：</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>SET max_heap_table_size = 1024*1024;</code></strong>
Query OK, 0 rows affected (0.00 sec)

mysql&gt; <strong class="userinput"><code>CREATE TABLE t1 (id INT, UNIQUE(id)) ENGINE = MEMORY;</code></strong>
Query OK, 0 rows affected (0.01 sec)

mysql&gt; <strong class="userinput"><code>SET max_heap_table_size = 1024*1024*2;</code></strong>
Query OK, 0 rows affected (0.00 sec)

mysql&gt; <strong class="userinput"><code>CREATE TABLE t2 (id INT, UNIQUE(id)) ENGINE = MEMORY;</code></strong>
Query OK, 0 rows affected (0.00 sec)
</pre><p>
            Both tables revert to the server's global
            <a class="link" href="server-administration.html#sysvar_max_heap_table_size"><code class="literal">max_heap_table_size</code></a> value if the
            server restarts.
        </p><p style="color:blue;">如果服务器重新启动，两个表都将还原为服务器的全局最大堆表大小值。</p><p>
            You can also specify a <code class="literal">MAX_ROWS</code> table option in
            <a class="link" href="sql-syntax.html#create-table" title="13.1.18&nbsp;CREATE TABLE Syntax"><code class="literal">CREATE TABLE</code></a> statements for
            <code class="literal">MEMORY</code> tables to provide a hint about the
            number of rows you plan to store in them. This does not enable the
            table to grow beyond the
            <a class="link" href="server-administration.html#sysvar_max_heap_table_size"><code class="literal">max_heap_table_size</code></a> value, which
            still acts as a constraint on maximum table size. For maximum
            flexibility in being able to use <code class="literal">MAX_ROWS</code>, set
            <a class="link" href="server-administration.html#sysvar_max_heap_table_size"><code class="literal">max_heap_table_size</code></a> at least as
            high as the value to which you want each <code class="literal">MEMORY</code>
            table to be able to grow.
        </p><p style="color:blue;">还可以在内存表的CREATE TABLE语句中指定MAX U ROWS TABLE选项，以提供有关计划存储在其中的行数的提示。这并不能使表超出Max HeAPPabTable大小的值，这仍然是对最大表大小的限制。为了能够最大限度地使用Max行，请将Max THEAPAPTable大小设置为与每个内存表能够增长的值一样高。</p>
        </div>
        <div class="simplesect">
            <div class="titlepage">
                <div>
                    <div class="simple">
                        <h3 class="title"><a name="memory-storage-engine-additional-resources"></a>Additional Resources</h3>

                    </div>

                </div>

            </div>
            <p>
                A forum dedicated to the <code class="literal">MEMORY</code> storage engine
                is available at <a class="ulink" href="https://forums.mysql.com/list.php?92" target="_top">https://forums.mysql.com/list.php?92</a>.
            </p><p style="color:blue;">在https://forums.mysql.com/list.php上有一个专门讨论内存存储引擎的论坛？92。</p>
        </div>

    </div>
    <div class="section">
        <div class="titlepage">
            <div>
                <div>
                    <h2 class="title" style="clear: both"><a name="csv-storage-engine"></a>15.4&nbsp;The CSV Storage Engine</h2>

                </div>

            </div>

        </div>
        <div class="toc">
            <dl class="toc"><dt><span class="section"><a href="storage-engines.html#se-csv-repair">15.4.1 Repairing and Checking CSV Tables</a></span></dt><dt><span class="section"><a href="storage-engines.html#se-csv-limitations">15.4.2 CSV Limitations</a></span></dt></dl>
        </div>
        <a class="indexterm" name="idm140286803061680"></a><a class="indexterm" name="idm140286803060608"></a><p>
        The <code class="literal">CSV</code> storage engine stores data in text files
        using comma-separated values format.
    </p><p style="color:blue;">csv存储引擎使用逗号分隔值格式将数据存储在文本文件中。</p><p>
        The <code class="literal">CSV</code> storage engine is always compiled into
        the MySQL server.
    </p><p style="color:blue;">csv存储引擎总是编译到mysql服务器中。</p><p>
        To examine the source for the <code class="literal">CSV</code> engine, look in
        the <code class="filename">storage/csv</code> directory of a MySQL source
        distribution.
    </p><p style="color:blue;">要检查csv引擎的源代码，请查看mysql源代码发行版的storage/csv目录。</p><p>
        When you create a <code class="literal">CSV</code> table, the server creates a
        table format file in the database directory. The file begins with
        the table name and has an <code class="filename">.frm</code> extension. The
        storage engine also creates plain text data file having a name that
        begins with the table name and has a <code class="filename">.CSV</code>
        extension. When you store data into the table, the storage engine
        saves it into the data file in comma-separated values format.
    </p><p style="color:blue;">创建csv表时，服务器将在数据库目录中创建表格式文件。文件以表名开头，扩展名为.frm。存储引擎还创建纯文本数据文件，该文件的名称以表名开头，扩展名为.csv。将数据存储到表中时，存储引擎将其以逗号分隔值格式保存到数据文件中。</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>CREATE TABLE test (i INT NOT NULL, c CHAR(10) NOT NULL)</code></strong>
       <strong class="userinput"><code>ENGINE = CSV;</code></strong>
Query OK, 0 rows affected (0.06 sec)

mysql&gt; <strong class="userinput"><code>INSERT INTO test VALUES(1,'record one'),(2,'record two');</code></strong>
Query OK, 2 rows affected (0.05 sec)
Records: 2  Duplicates: 0  Warnings: 0

mysql&gt; <strong class="userinput"><code>SELECT * FROM test;</code></strong>
+---+------------+
| i | c          |
+---+------------+
| 1 | record one |
| 2 | record two |
+---+------------+
2 rows in set (0.00 sec)
</pre><p>
        Creating a <code class="literal">CSV</code> table also creates a corresponding
        metafile that stores the state of the table and the number of rows
        that exist in the table. The name of this file is the same as the
        name of the table with the extension <code class="filename">CSM</code>.
    </p><p style="color:blue;">创建CSV表还创建一个对应的元文件，它存储表的状态和表中存在的行数。此文件的名称与扩展名为csm的表的名称相同。</p><p>
        If you examine the <code class="filename">test.CSV</code> file in the
        database directory created by executing the preceding statements,
        its contents should look like this:
    </p><p style="color:blue;">如果检查通过执行上述语句创建的数据库目录中的test.csv文件，其内容应如下所示：</p><pre data-lang="none" class="programlisting">"1","record one"
"2","record two"
</pre><p>
        This format can be read, and even written, by spreadsheet
        applications such as Microsoft Excel or StarOffice Calc.
    </p><p style="color:blue;">这种格式可以由电子表格应用程序（如Microsoft Excel或StarOffice Calc）读取甚至写入。</p>
        <div class="section">

            <div class="titlepage">
                <div>
                    <div>
                        <h3 class="title"><a name="se-csv-repair"></a>15.4.1&nbsp;Repairing and Checking CSV Tables</h3>
                    </div>
                </div>
            </div>
            <p>
                The <code class="literal">CSV</code> storage engine supports the
                <a class="link" href="sql-syntax.html#check-table" title="13.7.2.2&nbsp;CHECK TABLE Syntax"><code class="literal">CHECK TABLE</code></a> and
                <a class="link" href="sql-syntax.html#repair-table" title="13.7.2.5&nbsp;REPAIR TABLE Syntax"><code class="literal">REPAIR TABLE</code></a> statements to verify
                and, if possible, repair a damaged <code class="literal">CSV</code> table.
            </p><p style="color:blue;">csv存储引擎支持check table和repair table语句，以验证并在可能的情况下修复损坏的csv表。</p><p>
            When running the <a class="link" href="sql-syntax.html#check-table" title="13.7.2.2&nbsp;CHECK TABLE Syntax"><code class="literal">CHECK TABLE</code></a>
            statement, the <code class="literal">CSV</code> file will be checked for
            validity by looking for the correct field separators, escaped
            fields (matching or missing quotation marks), the correct number
            of fields compared to the table definition and the existence of a
            corresponding <code class="literal">CSV</code> metafile. The first invalid
            row discovered will report an error. Checking a valid table
            produces output like that shown below:
        </p><p style="color:blue;">运行检查表语句时，将通过查找正确的字段分隔符、转义字段（匹配或丢失引号）、与表定义相比的正确字段数以及对应的CSV元文件的存在来检查CSV文件的有效性。发现的第一个无效行将报告错误。检查有效表会产生如下所示的输出：</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>CHECK TABLE csvtest;</code></strong>
+--------------+-------+----------+----------+
| Table        | Op    | Msg_type | Msg_text |
+--------------+-------+----------+----------+
| test.csvtest | check | status   | OK       |
+--------------+-------+----------+----------+
</pre><p>
            A check on a corrupted table returns a fault:
        </p><p style="color:blue;">对损坏表的检查返回错误：</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>CHECK TABLE csvtest;</code></strong>
+--------------+-------+----------+----------+
| Table        | Op    | Msg_type | Msg_text |
+--------------+-------+----------+----------+
| test.csvtest | check | error    | Corrupt  |
+--------------+-------+----------+----------+
</pre><p>
            If the check fails, the table is marked as crashed (corrupt). Once
            a table has been marked as corrupt, it is automatically repaired
            when you next run <a class="link" href="sql-syntax.html#check-table" title="13.7.2.2&nbsp;CHECK TABLE Syntax"><code class="literal">CHECK TABLE</code></a> or
            execute a <a class="link" href="sql-syntax.html#select" title="13.2.9&nbsp;SELECT Syntax"><code class="literal">SELECT</code></a> statement. The
            corresponding corrupt status and new status will be displayed when
            running <a class="link" href="sql-syntax.html#check-table" title="13.7.2.2&nbsp;CHECK TABLE Syntax"><code class="literal">CHECK TABLE</code></a>:
        </p><p style="color:blue;">如果检查失败，则将表标记为崩溃（损坏）。一旦表被标记为已损坏，则在下次运行check table或执行select语句时会自动修复该表。运行检查表时，将显示相应的损坏状态和新状态：</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>CHECK TABLE csvtest;</code></strong>
+--------------+-------+----------+----------------------------+
| Table        | Op    | Msg_type | Msg_text                   |
+--------------+-------+----------+----------------------------+
| test.csvtest | check | warning  | Table is marked as crashed |
| test.csvtest | check | status   | OK                         |
+--------------+-------+----------+----------------------------+
</pre><p>
            To repair a table, use <a class="link" href="sql-syntax.html#repair-table" title="13.7.2.5&nbsp;REPAIR TABLE Syntax"><code class="literal">REPAIR
            TABLE</code></a>, which copies as many valid rows from the existing
            <code class="literal">CSV</code> data as possible, and then replaces the
            existing <code class="literal">CSV</code> file with the recovered rows. Any
            rows beyond the corrupted data are lost.
        </p><p style="color:blue;">若要修复表，请使用修复表，该表尽可能从现有CSV数据复制尽可能多的有效行，然后用恢复的行替换现有CSV文件。损坏数据之外的任何行都将丢失。</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>REPAIR TABLE csvtest;</code></strong>
+--------------+--------+----------+----------+
| Table        | Op     | Msg_type | Msg_text |
+--------------+--------+----------+----------+
| test.csvtest | repair | status   | OK       |
+--------------+--------+----------+----------+
</pre>
            <div class="warning" style="margin-left: 0.5in; margin-right: 0.5in;">

                <div class="admon-title">
                    Warning
                </div>
                <p>
                    During repair, only the rows from the <code class="literal">CSV</code>
                    file up to the first damaged row are copied to the new table.
                    All other rows from the first damaged row to the end of the
                    table are removed, even valid rows.
                </p><p style="color:blue;">在修复过程中，只有从csv文件到第一个损坏行的行被复制到新表中。从第一个损坏行到表末尾的所有其他行都将被删除，即使是有效行。</p>
            </div>

        </div>
        <div class="section">
            <div class="titlepage">
                <div>
                    <div>
                        <h3 class="title"><a name="se-csv-limitations"></a>15.4.2&nbsp;CSV Limitations</h3>

                    </div>

                </div>

            </div>
            <p>
                The <code class="literal">CSV</code> storage engine does not support
                indexing.
            </p><p style="color:blue;">CSV存储引擎不支持索引。</p><p>
            Partitioning is not supported for tables using the
            <code class="literal">CSV</code> storage engine.
        </p><p style="color:blue;">使用csv存储引擎的表不支持分区。</p><p>
            All tables that you create using the <code class="literal">CSV</code>
            storage engine must have the <code class="literal">NOT NULL</code> attribute
            on all columns.
        </p><p style="color:blue;">使用csv存储引擎创建的所有表在所有列上都必须具有not null属性。</p>
        </div>

    </div>
    <div class="section">
        <div class="titlepage">
            <div>
                <div>
                    <h2 class="title" style="clear: both"><a name="archive-storage-engine"></a>15.5&nbsp;The ARCHIVE Storage Engine</h2>

                </div>

            </div>

        </div>
        <a class="indexterm" name="idm140286803009968"></a><a class="indexterm" name="idm140286803008928"></a><p>
        The <code class="literal">ARCHIVE</code> storage engine produces
        special-purpose tables that store large amounts of unindexed data in
        a very small footprint.
    </p><p style="color:blue;">存档存储引擎生成特殊用途的表，这些表将大量未编制索引的数据存储在非常小的内存中。</p>
        <div class="table">
            <a name="idm140286803006144"></a><p class="title"><b>Table&nbsp;15.5&nbsp;ARCHIVE Storage Engine Features</b></p><p style="color:blue;">表15.5存档存储引擎功能</p>
            <div class="table-contents">
                <table frame="box" rules="all" summary="Features supported by the ARCHIVE storage engine."><colgroup><col width="60%"><col width="40%"></colgroup><thead><tr><th scope="col">Feature</th>
                    <th scope="col">Support</th>
                </tr></thead><tbody><tr><td scope="row"><span class="bold"><strong>B-tree indexes</strong></span></td>
                    <td>No</td>
                </tr><tr><td scope="row"><span class="bold"><strong>Backup/point-in-time recovery</strong></span> (Implemented in the server, rather than in the storage engine.)</td>
                    <td>Yes</td>
                </tr><tr><td scope="row"><span class="bold"><strong>Cluster database support</strong></span></td>
                    <td>No</td>
                </tr><tr><td scope="row"><span class="bold"><strong>Clustered indexes</strong></span></td>
                    <td>No</td>
                </tr><tr><td scope="row"><span class="bold"><strong>Compressed data</strong></span></td>
                    <td>Yes</td>
                </tr><tr><td scope="row"><span class="bold"><strong>Data caches</strong></span></td>
                    <td>No</td>
                </tr><tr><td scope="row"><span class="bold"><strong>Encrypted data</strong></span></td>
                    <td>Yes (Implemented in the server via encryption functions.)</td>
                </tr><tr><td scope="row"><span class="bold"><strong>Foreign key support</strong></span></td>
                    <td>No</td>
                </tr><tr><td scope="row"><span class="bold"><strong>Full-text search indexes</strong></span></td>
                    <td>No</td>
                </tr><tr><td scope="row"><span class="bold"><strong>Geospatial data type support</strong></span></td>
                    <td>Yes</td>
                </tr><tr><td scope="row"><span class="bold"><strong>Geospatial indexing support</strong></span></td>
                    <td>No</td>
                </tr><tr><td scope="row"><span class="bold"><strong>Hash indexes</strong></span></td>
                    <td>No</td>
                </tr><tr><td scope="row"><span class="bold"><strong>Index caches</strong></span></td>
                    <td>No</td>
                </tr><tr><td scope="row"><span class="bold"><strong>Locking granularity</strong></span></td>
                    <td>Row</td>
                </tr><tr><td scope="row"><span class="bold"><strong>MVCC</strong></span></td>
                    <td>No</td>
                </tr><tr><td scope="row"><span class="bold"><strong>Replication support</strong></span> (Implemented in the server, rather than in the storage engine.)</td>
                    <td>Yes</td>
                </tr><tr><td scope="row"><span class="bold"><strong>Storage limits</strong></span></td>
                    <td>None</td>
                </tr><tr><td scope="row"><span class="bold"><strong>T-tree indexes</strong></span></td>
                    <td>No</td>
                </tr><tr><td scope="row"><span class="bold"><strong>Transactions</strong></span></td>
                    <td>No</td>
                </tr><tr><td scope="row"><span class="bold"><strong>Update statistics for data dictionary</strong></span></td>
                    <td>Yes</td>
                </tr></tbody></table>
            </div>

        </div>
        <br class="table-break"><p>
        The <code class="literal">ARCHIVE</code> storage engine is included in MySQL
        binary distributions. To enable this storage engine if you build
        MySQL from source, invoke <span class="command"><strong>CMake</strong></span> with the
        <a class="link" href="installing.html#option_cmake_storage_engine_options" title="Storage Engine Options"><code class="option">-DWITH_ARCHIVE_STORAGE_ENGINE</code></a>
        option.
    </p><p style="color:blue;">存档存储引擎包含在mysql二进制发行版中。若要在从源代码构建MySQL时启用此存储引擎，请使用-dwith_archive_storage_engine选项调用cmake。</p><p>
        To examine the source for the <code class="literal">ARCHIVE</code> engine,
        look in the <code class="filename">storage/archive</code> directory of a
        MySQL source distribution.
    </p><p style="color:blue;">要检查存档引擎的源代码，请查看mysql源发行版的storage/archive目录。</p><p>
        You can check whether the <code class="literal">ARCHIVE</code> storage engine
        is available with the <a class="link" href="sql-syntax.html#show-engines" title="13.7.5.16&nbsp;SHOW ENGINES Syntax"><code class="literal">SHOW ENGINES</code></a>
        statement.
    </p><p style="color:blue;">您可以使用show engines语句检查存档存储引擎是否可用。</p><p>
        When you create an <code class="literal">ARCHIVE</code> table, the server
        creates a table format file in the database directory. The file
        begins with the table name and has an <code class="filename">.frm</code>
        extension. The storage engine creates other files, all having names
        beginning with the table name. The data file has an extension of
        <code class="filename">.ARZ</code>. An <code class="filename">.ARN</code> file may
        appear during optimization operations.
    </p><p style="color:blue;">创建存档表时，服务器将在数据库目录中创建表格式文件。文件以表名开头，扩展名为.frm。存储引擎创建其他文件，所有文件的名称都以表名开头。数据文件的扩展名为.arz。优化操作期间可能会出现.arn文件。</p><p>
        The <code class="literal">ARCHIVE</code> engine supports
        <a class="link" href="sql-syntax.html#insert" title="13.2.5&nbsp;INSERT Syntax"><code class="literal">INSERT</code></a>,
        <a class="link" href="sql-syntax.html#replace" title="13.2.8&nbsp;REPLACE Syntax"><code class="literal">REPLACE</code></a>, and
        <a class="link" href="sql-syntax.html#select" title="13.2.9&nbsp;SELECT Syntax"><code class="literal">SELECT</code></a>, but not
        <a class="link" href="sql-syntax.html#delete" title="13.2.2&nbsp;DELETE Syntax"><code class="literal">DELETE</code></a> or
        <a class="link" href="sql-syntax.html#update" title="13.2.11&nbsp;UPDATE Syntax"><code class="literal">UPDATE</code></a>. It does support
        <code class="literal">ORDER BY</code> operations,
        <a class="link" href="data-types.html#blob" title="11.4.3&nbsp;The BLOB and TEXT Types"><code class="literal">BLOB</code></a> columns, and basically all data
        types including spatial data types (see
        <a class="xref" href="data-types.html#spatial-type-overview" title="11.5.1&nbsp;Spatial Data Types">Section&nbsp;11.5.1, “Spatial Data Types”</a>). Geographic spatial
        reference systems are not supported. The <code class="literal">ARCHIVE</code>
        engine uses row-level locking.
    </p><p style="color:blue;">存档引擎支持插入、替换和选择，但不支持删除或更新。它确实支持按顺序操作、blob列和基本上所有的数据类型，包括空间数据类型（参见第11.5.1节“空间数据类型”）。不支持地理空间参考系统。存档引擎使用行级锁定。</p><p>
        The <code class="literal">ARCHIVE</code> engine supports the
        <code class="literal">AUTO_INCREMENT</code> column attribute. The
        <code class="literal">AUTO_INCREMENT</code> column can have either a unique or
        nonunique index. Attempting to create an index on any other column
        results in an error. The <code class="literal">ARCHIVE</code> engine also
        supports the <code class="literal">AUTO_INCREMENT</code> table option in
        <a class="link" href="sql-syntax.html#create-table" title="13.1.18&nbsp;CREATE TABLE Syntax"><code class="literal">CREATE TABLE</code></a> statements to specify
        the initial sequence value for a new table or reset the sequence
        value for an existing table, respectively.
    </p><p style="color:blue;">存档引擎支持自动递增列属性。“自动增量”列可以具有唯一索引或非唯一索引。试图在任何其他列上创建索引将导致错误。归档引擎还支持CREATETABLE语句中的AutoYLoad表选项，以指定新表的初始序列值或重置现有表的序列值。</p><p>
        <code class="literal">ARCHIVE</code> does not support inserting a value into
        an <code class="literal">AUTO_INCREMENT</code> column less than the current
        maximum column value. Attempts to do so result in an
        <a class="link" href="error-handling.html#error_er_dup_key"><code class="literal">ER_DUP_KEY</code></a> error.
    </p><p style="color:blue;">归档不支持将值插入小于当前最大列值的子列表列中。尝试执行此操作会导致重复密钥错误。</p><p>
        The <code class="literal">ARCHIVE</code> engine ignores
        <a class="link" href="data-types.html#blob" title="11.4.3&nbsp;The BLOB and TEXT Types"><code class="literal">BLOB</code></a> columns if they are not
        requested and scans past them while reading.
    </p><p style="color:blue;">如果没有请求blob列，存档引擎将忽略它们，并在读取时扫描它们。</p><p>
        <span class="bold"><strong>Storage:</strong></span> Rows are compressed as
        they are inserted. The <code class="literal">ARCHIVE</code> engine uses
        <code class="literal">zlib</code> lossless data compression (see
        <a class="ulink" href="http://www.zlib.net/" target="_top">http://www.zlib.net/</a>). You can use
        <a class="link" href="sql-syntax.html#optimize-table" title="13.7.2.4&nbsp;OPTIMIZE TABLE Syntax"><code class="literal">OPTIMIZE TABLE</code></a> to analyze the table
        and pack it into a smaller format (for a reason to use
        <a class="link" href="sql-syntax.html#optimize-table" title="13.7.2.4&nbsp;OPTIMIZE TABLE Syntax"><code class="literal">OPTIMIZE TABLE</code></a>, see later in this
        section). The engine also supports <a class="link" href="sql-syntax.html#check-table" title="13.7.2.2&nbsp;CHECK TABLE Syntax"><code class="literal">CHECK
        TABLE</code></a>. There are several types of insertions that are
        used:
    </p><p style="color:blue;">存储：行在插入时被压缩。存档引擎使用zlib无损数据压缩（请参见http://www.zlib.net/）。您可以使用optimize table来分析表并将其打包成较小的格式（有关使用optimize table的原因，请参阅本节后面的内容）。发动机还支持检查台。有几种类型的插入使用：</p>
        <div class="itemizedlist">
            <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                An <a class="link" href="sql-syntax.html#insert" title="13.2.5&nbsp;INSERT Syntax"><code class="literal">INSERT</code></a> statement just pushes
                rows into a compression buffer, and that buffer flushes as
                necessary. The insertion into the buffer is protected by a lock.
                A <a class="link" href="sql-syntax.html#select" title="13.2.9&nbsp;SELECT Syntax"><code class="literal">SELECT</code></a> forces a flush to occur.
            </p><p style="color:blue;">insert语句只是将行推入压缩缓冲区，该缓冲区根据需要进行刷新。插入缓冲区受锁保护。选择将强制发生刷新。</p></li><li class="listitem"><p>
                A bulk insert is visible only after it completes, unless other
                inserts occur at the same time, in which case it can be seen
                partially. A <a class="link" href="sql-syntax.html#select" title="13.2.9&nbsp;SELECT Syntax"><code class="literal">SELECT</code></a> never causes
                a flush of a bulk insert unless a normal insert occurs while it
                is loading.
            </p><p style="color:blue;">大容量插入只有在完成后才可见，除非同时发生其他插入，在这种情况下，可以部分看到它。除非加载时发生正常插入，否则select永远不会导致大容量插入的刷新。</p></li></ul>
        </div>
        <p>
            <span class="bold"><strong>Retrieval</strong></span>: On retrieval, rows are
            uncompressed on demand; there is no row cache. A
            <a class="link" href="sql-syntax.html#select" title="13.2.9&nbsp;SELECT Syntax"><code class="literal">SELECT</code></a> operation performs a complete
            table scan: When a <a class="link" href="sql-syntax.html#select" title="13.2.9&nbsp;SELECT Syntax"><code class="literal">SELECT</code></a> occurs, it
            finds out how many rows are currently available and reads that
            number of rows. <a class="link" href="sql-syntax.html#select" title="13.2.9&nbsp;SELECT Syntax"><code class="literal">SELECT</code></a> is performed
            as a consistent read. Note that lots of
            <a class="link" href="sql-syntax.html#select" title="13.2.9&nbsp;SELECT Syntax"><code class="literal">SELECT</code></a> statements during insertion
            can deteriorate the compression, unless only bulk or delayed inserts
            are used. To achieve better compression, you can use
            <a class="link" href="sql-syntax.html#optimize-table" title="13.7.2.4&nbsp;OPTIMIZE TABLE Syntax"><code class="literal">OPTIMIZE TABLE</code></a> or
            <a class="link" href="sql-syntax.html#repair-table" title="13.7.2.5&nbsp;REPAIR TABLE Syntax"><code class="literal">REPAIR TABLE</code></a>. The number of rows in
            <code class="literal">ARCHIVE</code> tables reported by
            <a class="link" href="sql-syntax.html#show-table-status" title="13.7.5.36&nbsp;SHOW TABLE STATUS Syntax"><code class="literal">SHOW TABLE STATUS</code></a> is always accurate.
            See <a class="xref" href="sql-syntax.html#optimize-table" title="13.7.2.4&nbsp;OPTIMIZE TABLE Syntax">Section&nbsp;13.7.2.4, “OPTIMIZE TABLE Syntax”</a>,
            <a class="xref" href="sql-syntax.html#repair-table" title="13.7.2.5&nbsp;REPAIR TABLE Syntax">Section&nbsp;13.7.2.5, “REPAIR TABLE Syntax”</a>, and
            <a class="xref" href="sql-syntax.html#show-table-status" title="13.7.5.36&nbsp;SHOW TABLE STATUS Syntax">Section&nbsp;13.7.5.36, “SHOW TABLE STATUS Syntax”</a>.
        </p><p style="color:blue;">检索：检索时，行按需解压缩；没有行缓存。select操作执行一个完整的表扫描：当select发生时，它会发现当前有多少行可用，并读取该行数。选择作为一致读取执行。请注意，除非只使用大容量插入或延迟插入，否则插入过程中的许多select语句可能会恶化压缩。为了获得更好的压缩，可以使用优化表或修复表。“显示表状态”报告的存档表中的行数始终准确。参见第13.7.2.4节“优化表语法”，第13.7.2.5节“修复表语法”，第13.7.5.36节“显示表状态语法”。</p>
        <h3><a name="idm140286802887216"></a>Additional Resources</h3>
        <div class="itemizedlist">
            <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                A forum dedicated to the <code class="literal">ARCHIVE</code> storage
                engine is available at <a class="ulink" href="https://forums.mysql.com/list.php?112" target="_top">https://forums.mysql.com/list.php?112</a>.
            </p><p style="color:blue;">在https://forums.mysql.com/list.php上有一个专门讨论归档存储引擎的论坛？112号。</p></li></ul>
        </div>

    </div>
    <div class="section">
        <div class="titlepage">
            <div>
                <div>
                    <h2 class="title" style="clear: both"><a name="blackhole-storage-engine"></a>15.6&nbsp;The BLACKHOLE Storage Engine</h2>

                </div>

            </div>

        </div>
        <a class="indexterm" name="idm140286802882720"></a><a class="indexterm" name="idm140286802881632"></a><p>
        The <code class="literal">BLACKHOLE</code> storage engine acts as a
        <span class="quote">“<span class="quote">black hole</span>”</span> that accepts data but throws it away and
        does not store it. Retrievals always return an empty result:
    </p><p style="color:blue;">黑洞存储引擎充当一个“黑洞”，接受数据，但将其扔掉，不存储数据。检索始终返回空结果：</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>CREATE TABLE test(i INT, c CHAR(10)) ENGINE = BLACKHOLE;</code></strong>
Query OK, 0 rows affected (0.03 sec)

mysql&gt; <strong class="userinput"><code>INSERT INTO test VALUES(1,'record one'),(2,'record two');</code></strong>
Query OK, 2 rows affected (0.00 sec)
Records: 2  Duplicates: 0  Warnings: 0

mysql&gt; <strong class="userinput"><code>SELECT * FROM test;</code></strong>
Empty set (0.00 sec)
</pre><p>
        To enable the <code class="literal">BLACKHOLE</code> storage engine if you
        build MySQL from source, invoke <span class="command"><strong>CMake</strong></span> with the
        <a class="link" href="installing.html#option_cmake_storage_engine_options" title="Storage Engine Options"><code class="option">-DWITH_BLACKHOLE_STORAGE_ENGINE</code></a>
        option.
    </p><p style="color:blue;">若要在从源代码构建MySQL时启用黑洞存储引擎，请使用-dwith_blackhole_storage_engine选项调用cmake。</p><p>
        To examine the source for the <code class="literal">BLACKHOLE</code> engine,
        look in the <code class="filename">sql</code> directory of a MySQL source
        distribution.
    </p><p style="color:blue;">要检查黑洞引擎的源代码，请查看mysql源代码发行版的sql目录。</p><p>
        When you create a <code class="literal">BLACKHOLE</code> table, the server
        creates a table format file in the database directory. The file
        begins with the table name and has an <code class="filename">.frm</code>
        extension. There are no other files associated with the table.
    </p><p style="color:blue;">创建黑洞表时，服务器将在数据库目录中创建表格式文件。文件以表名开头，扩展名为.frm。没有与表关联的其他文件。</p><p>
        The <code class="literal">BLACKHOLE</code> storage engine supports all kinds
        of indexes. That is, you can include index declarations in the table
        definition.
    </p><p style="color:blue;">黑洞存储引擎支持各种索引。也就是说，可以在表定义中包含索引声明。</p><p>
        You can check whether the <code class="literal">BLACKHOLE</code> storage
        engine is available with the <a class="link" href="sql-syntax.html#show-engines" title="13.7.5.16&nbsp;SHOW ENGINES Syntax"><code class="literal">SHOW
        ENGINES</code></a> statement.
    </p><p style="color:blue;">您可以使用show engines语句检查黑洞存储引擎是否可用。</p><p>
        Inserts into a <code class="literal">BLACKHOLE</code> table do not store any
        data, but if statement based binary logging is enabled, the SQL
        statements are logged and replicated to slave servers. This can be
        useful as a repeater or filter mechanism.
    </p><p style="color:blue;">插入到黑洞表中不会存储任何数据，但如果启用了基于语句的二进制日志记录，则会记录SQL语句并将其复制到从属服务器。这可以用作中继器或过滤机制。</p><p>
        Suppose that your application requires slave-side filtering rules,
        but transferring all binary log data to the slave first results in
        too much traffic. In such a case, it is possible to set up on the
        master host a <span class="quote">“<span class="quote">dummy</span>”</span> slave process whose default
        storage engine is <code class="literal">BLACKHOLE</code>, depicted as follows:
    </p><p style="color:blue;">假设您的应用程序需要从端过滤规则，但是首先将所有二进制日志数据传输到从端会导致太多流量。在这种情况下，可以在主主机上设置一个默认存储引擎为黑洞的“虚拟”从进程，如下所示：</p>
        <div class="figure">
            <a name="idm140286802861376"></a><p class="title"><b>Figure&nbsp;15.1&nbsp;Replication using BLACKHOLE for Filtering</b></p><p style="color:blue;">图15.1使用黑洞进行过滤的复制</p>
            <div class="figure-contents">

                <div class="mediaobject">
                    <img src="images/blackhole-1.png" width="520" height="245" alt="Replication using BLACKHOLE for filtering">
                </div>

            </div>

        </div>
        <br class="figure-break"><p>
        The master writes to its binary log. The <span class="quote">“<span class="quote">dummy</span>”</span>
        <a class="link" href="programs.html#mysqld" title="4.3.1&nbsp;mysqld — The MySQL Server"><span class="command"><strong>mysqld</strong></span></a> process acts as a slave, applying the
        desired combination of <code class="literal">replicate-do-*</code> and
        <code class="literal">replicate-ignore-*</code> rules, and writes a new,
        filtered binary log of its own. (See
        <a class="xref" href="replication.html#replication-options" title="16.1.6&nbsp;Replication and Binary Logging Options and Variables">Section&nbsp;16.1.6, “Replication and Binary Logging Options and Variables”</a>.) This filtered log is
        provided to the slave.
    </p><p style="color:blue;">主机写入其二进制日志。“dummy”mysqld进程充当从进程，应用所需的replicate do-*和replicate ignore-*规则的组合，并编写自己的新的过滤二进制日志。（见第16.1.6节，“复制和二进制日志选项和变量”。）此过滤日志提供给从机。</p><p>
        The dummy process does not actually store any data, so there is
        little processing overhead incurred by running the additional
        <a class="link" href="programs.html#mysqld" title="4.3.1&nbsp;mysqld — The MySQL Server"><span class="command"><strong>mysqld</strong></span></a> process on the replication master host.
        This type of setup can be repeated with additional replication
        slaves.
    </p><p style="color:blue;">虚拟进程实际上并不存储任何数据，因此在复制主主机上运行额外的mysqld进程所产生的处理开销很小。这种类型的设置可以与其他复制从机一起重复。</p><p>
        <a class="link" href="sql-syntax.html#insert" title="13.2.5&nbsp;INSERT Syntax"><code class="literal">INSERT</code></a> triggers for
        <code class="literal">BLACKHOLE</code> tables work as expected. However,
        because the <code class="literal">BLACKHOLE</code> table does not actually
        store any data, <a class="link" href="sql-syntax.html#update" title="13.2.11&nbsp;UPDATE Syntax"><code class="literal">UPDATE</code></a> and
        <a class="link" href="sql-syntax.html#delete" title="13.2.2&nbsp;DELETE Syntax"><code class="literal">DELETE</code></a> triggers are not activated:
        The <code class="literal">FOR EACH ROW</code> clause in the trigger definition
        does not apply because there are no rows.
    </p><p style="color:blue;">黑洞表的insert触发器按预期工作。但是，由于黑洞表实际上并不存储任何数据，因此不会激活update和delete触发器：触发器定义中的for each row子句不适用，因为没有行。</p><p>
        Other possible uses for the <code class="literal">BLACKHOLE</code> storage
        engine include:
    </p><p style="color:blue;">黑洞存储引擎的其他可能用途包括：</p>
        <div class="itemizedlist">
            <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                Verification of dump file syntax.
            </p><p style="color:blue;">转储文件语法的验证。</p></li><li class="listitem"><p>
                Measurement of the overhead from binary logging, by comparing
                performance using <code class="literal">BLACKHOLE</code> with and without
                binary logging enabled.
            </p><p style="color:blue;">通过比较启用和不启用二进制日志记录时使用黑洞的性能来测量二进制日志记录的开销。</p></li><li class="listitem"><p>
                <code class="literal">BLACKHOLE</code> is essentially a
                <span class="quote">“<span class="quote">no-op</span>”</span> storage engine, so it could be used for
                finding performance bottlenecks not related to the storage
                engine itself.
            </p><p style="color:blue;">黑洞本质上是一个“无操作”的存储引擎，因此它可以用来寻找与存储引擎本身无关的性能瓶颈。</p></li></ul>
        </div>
        <p>
            The <code class="literal">BLACKHOLE</code> engine is transaction-aware, in the
            sense that committed transactions are written to the binary log and
            rolled-back transactions are not.
        </p><p style="color:blue;">黑洞引擎是事务感知的，因为提交的事务被写入二进制日志，而回滚的事务则不是。</p><p>
    <span class="bold"><strong>Blackhole Engine and Auto Increment
    Columns</strong></span>
    </p><p style="color:blue;">黑洞引擎和自动增量列</p><p>
        The Blackhole engine is a no-op engine. Any operations performed on
        a table using Blackhole will have no effect. This should be born in
        mind when considering the behavior of primary key columns that auto
        increment. The engine will not automatically increment field values,
        and does not retain auto increment field state. This has important
        implications in replication.
    </p><p style="color:blue;">黑洞引擎是一个不工作的引擎。在使用黑洞的工作台上执行的任何操作都将无效。在考虑自动递增的主键列的行为时，应该牢记这一点。引擎不会自动递增字段值，也不会保留自动递增字段状态。这对复制有重要影响。</p><p>
        Consider the following replication scenario where all three of the
        following conditions apply:
    </p><p style="color:blue;">考虑以下复制场景，其中应用以下三个条件：</p>
        <div class="orderedlist">
            <ol class="orderedlist" type="1"><li class="listitem"><p>
                On a master server there is a blackhole table with an auto
                increment field that is a primary key.
            </p><p style="color:blue;">在主服务器上有一个黑洞表，其中有一个自动递增字段，该字段是主键。</p></li><li class="listitem"><p>
                On a slave the same table exists but using the MyISAM engine.
            </p><p style="color:blue;">在同一个表上存在一个从属，但使用MyISAM引擎。</p></li><li class="listitem"><p>
                Inserts are performed into the master's table without explicitly
                setting the auto increment value in the
                <code class="literal">INSERT</code> statement itself or through using a
                <code class="literal">SET INSERT_ID</code> statement.
            </p><p style="color:blue;">在主表中执行插入操作时，不必在INSERT语句本身中显式设置自动增量值，也不必使用SET INSERT\U ID语句。</p></li></ol>
        </div>
        <p>
            In this scenario replication will fail with a duplicate entry error
            on the primary key column.
        </p><p style="color:blue;">在这种情况下，复制将失败，在主键列上出现重复条目错误。</p><p>
        In statement based replication, the value of
        <code class="literal">INSERT_ID</code> in the context event will always be the
        same. Replication will therefore fail due to trying insert a row
        with a duplicate value for a primary key column.
    </p><p style="color:blue;">在基于语句的复制中，上下文事件中insert_id的值将始终相同。因此，由于尝试插入主键列具有重复值的行，复制将失败。</p><p>
        In row based replication, the value that the engine returns for the
        row always be the same for each insert. This will result in the
        slave attempting to replay two insert log entries using the same
        value for the primary key column, and so replication will fail.
    </p><p style="color:blue;">在基于行的复制中，引擎为行返回的值对于每次插入总是相同的。这将导致从属服务器尝试使用主键列的相同值重播两个插入日志条目，因此复制将失败。</p><p>
        <span class="bold"><strong>Column Filtering</strong></span>
    </p><p style="color:blue;">列筛选</p><p>
        When using row-based replication,
        (<a class="link" href="replication.html#sysvar_binlog_format"><code class="literal">binlog_format=ROW</code></a>), a slave where
        the last columns are missing from a table is supported, as described
        in the section
        <a class="xref" href="replication.html#replication-features-differing-tables" title="16.4.1.10&nbsp;Replication with Differing Table Definitions on Master and Slave">Section&nbsp;16.4.1.10, “Replication with Differing Table Definitions on Master and Slave”</a>.
    </p><p style="color:blue;">使用基于行的复制时，（binlog_format=row），支持表中缺少最后一列的从机，如16.4.1.10节“在主机和从机上使用不同表定义的复制”所述。</p><p>
        This filtering works on the slave side, that is, the columns are
        copied to the slave before they are filtered out. There are at least
        two cases where it is not desirable to copy the columns to the
        slave:
    </p><p style="color:blue;">这种过滤在从属端工作，也就是说，列在被过滤掉之前被复制到从属端。至少有两种情况不希望将列复制到从属：</p>
        <div class="orderedlist">
            <ol class="orderedlist" type="1"><li class="listitem"><p>
                If the data is confidential, so the slave server should not have
                access to it.
            </p><p style="color:blue;">如果数据是机密的，那么从服务器不应该有权访问它。</p></li><li class="listitem"><p>
                If the master has many slaves, filtering before sending to the
                slaves may reduce network traffic.
            </p><p style="color:blue;">如果主服务器有许多从服务器，在发送到从服务器之前进行过滤可能会减少网络流量。</p></li></ol>
        </div>
        <p>
            Master column filtering can be achieved using the
            <code class="literal">BLACKHOLE</code> engine. This is carried out in a way
            similar to how master table filtering is achieved - by using the
            <code class="literal">BLACKHOLE</code> engine and the
            <a class="link" href="replication.html#option_mysqld_replicate-do-table"><code class="option">--replicate-do-table</code></a> or
            <a class="link" href="replication.html#option_mysqld_replicate-ignore-table"><code class="option">--replicate-ignore-table</code></a> option.
        </p><p style="color:blue;">使用黑洞引擎可以实现主柱过滤。这是以类似于如何实现主表过滤的方式执行的—使用黑洞引擎和--replicate do table或--replicate ignore table选项。</p><p>
        The setup for the master is:
    </p><p style="color:blue;">主机的设置为：</p><pre data-lang="sql" class="programlisting">CREATE TABLE t1 (public_col_1, ..., public_col_N,
                 secret_col_1, ..., secret_col_M) ENGINE=MyISAM;
</pre><p>
        The setup for the trusted slave is:
    </p><p style="color:blue;">受信任从属服务器的设置为：</p><pre data-lang="sql" class="programlisting">CREATE TABLE t1 (public_col_1, ..., public_col_N) ENGINE=BLACKHOLE;
</pre><p>
        The setup for the untrusted slave is:
    </p><p style="color:blue;">不受信任的从属服务器的设置为：</p><pre data-lang="sql" class="programlisting">CREATE TABLE t1 (public_col_1, ..., public_col_N) ENGINE=MyISAM;</pre>
    </div>
    <div class="section">
        <div class="titlepage">
            <div>
                <div>
                    <h2 class="title" style="clear: both"><a name="merge-storage-engine"></a>15.7&nbsp;The MERGE Storage Engine</h2>

                </div>

            </div>

        </div>
        <div class="toc">
            <dl class="toc"><dt><span class="section"><a href="storage-engines.html#merge-table-advantages">15.7.1 MERGE Table Advantages and Disadvantages</a></span></dt><dt><span class="section"><a href="storage-engines.html#merge-table-problems">15.7.2 MERGE Table Problems</a></span></dt></dl>
        </div>
        <a class="indexterm" name="idm140286802807760"></a><a class="indexterm" name="idm140286802806720"></a><a class="indexterm" name="idm140286802805232"></a><a class="indexterm" name="idm140286802803744"></a><a class="indexterm" name="idm140286802802256"></a><p>
        The <code class="literal">MERGE</code> storage engine, also known as the
        <code class="literal">MRG_MyISAM</code> engine, is a collection of identical
        <code class="literal">MyISAM</code> tables that can be used as one.
        <span class="quote">“<span class="quote">Identical</span>”</span> means that all tables have identical column
        data types and index information. You cannot merge
        <code class="literal">MyISAM</code> tables in which the columns are listed in
        a different order, do not have exactly the same data types in
        corresponding columns, or have the indexes in different order.
        However, any or all of the <code class="literal">MyISAM</code> tables can be
        compressed with <a class="link" href="programs.html#myisampack" title="4.6.5&nbsp;myisampack — Generate Compressed, Read-Only MyISAM Tables"><span class="command"><strong>myisampack</strong></span></a>. See
        <a class="xref" href="programs.html#myisampack" title="4.6.5&nbsp;myisampack — Generate Compressed, Read-Only MyISAM Tables">Section&nbsp;4.6.5, “<span class="command"><strong>myisampack</strong></span> — Generate Compressed, Read-Only MyISAM Tables”</a>. Differences between tables such as
        these do not matter:
    </p><p style="color:blue;">合并存储引擎，也称为mrg_myisam引擎，是可以用作一个引擎的相同myisam表的集合。“相同”是指所有表具有相同的列数据类型和索引信息。不能合并列以不同顺序列出、相应列中的数据类型不完全相同或索引顺序不同的myisam表。但是，任何或所有myisam表都可以使用myisampack进行压缩。请参阅4.6.5节，“myisampack-生成压缩的只读myisam表”。这些表格之间的差异无关紧要：</p>
        <div class="itemizedlist">
            <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                Names of corresponding columns and indexes can differ.
            </p><p style="color:blue;">相应列和索引的名称可以不同。</p></li><li class="listitem"><p>
                Comments for tables, columns, and indexes can differ.
            </p><p style="color:blue;">表、列和索引的注释可能不同。</p></li><li class="listitem"><p>
                Table options such as <code class="literal">AVG_ROW_LENGTH</code>,
                <code class="literal">MAX_ROWS</code>, or <code class="literal">PACK_KEYS</code> can
                differ.
            </p><p style="color:blue;">表选项（如avg_row_length、max_rows或pack_keys）可能不同。</p></li></ul>
        </div>
        <p>
            An alternative to a <code class="literal">MERGE</code> table is a partitioned
            table, which stores partitions of a single table in separate files.
            Partitioning enables some operations to be performed more
            efficiently and is not limited to the <code class="literal">MyISAM</code>
            storage engine. For more information, see
            <a class="xref" href="partitioning.html" title="Chapter&nbsp;22&nbsp;Partitioning">Chapter&nbsp;22, <i>Partitioning</i></a>.
        </p><p style="color:blue;">合并表的另一种选择是分区表，它将单个表的分区存储在单独的文件中。分区使某些操作能够更有效地执行，并且不限于myisam存储引擎。有关更多信息，请参阅第22章，分区。</p><p>
        When you create a <code class="literal">MERGE</code> table, MySQL creates two
        files on disk. The files have names that begin with the table name
        and have an extension to indicate the file type. An
        <code class="filename">.frm</code> file stores the table format, and an
        <code class="filename">.MRG</code> file contains the names of the underlying
        <code class="literal">MyISAM</code> tables that should be used as one. The
        tables do not have to be in the same database as the
        <code class="literal">MERGE</code> table.
    </p><p style="color:blue;">创建合并表时，mysql会在磁盘上创建两个文件。这些文件的名称以表名开头，并且有一个扩展名来指示文件类型。.frm文件存储表格式，.mrg文件包含应作为一个表使用的基础myisam表的名称。这些表不必与合并表位于同一数据库中。</p><p>
        You can use <a class="link" href="sql-syntax.html#select" title="13.2.9&nbsp;SELECT Syntax"><code class="literal">SELECT</code></a>,
        <a class="link" href="sql-syntax.html#delete" title="13.2.2&nbsp;DELETE Syntax"><code class="literal">DELETE</code></a>,
        <a class="link" href="sql-syntax.html#update" title="13.2.11&nbsp;UPDATE Syntax"><code class="literal">UPDATE</code></a>, and
        <a class="link" href="sql-syntax.html#insert" title="13.2.5&nbsp;INSERT Syntax"><code class="literal">INSERT</code></a> on <code class="literal">MERGE</code>
        tables. You must have <a class="link" href="security.html#priv_select"><code class="literal">SELECT</code></a>,
        <a class="link" href="security.html#priv_delete"><code class="literal">DELETE</code></a>, and
        <a class="link" href="security.html#priv_update"><code class="literal">UPDATE</code></a> privileges on the
        <code class="literal">MyISAM</code> tables that you map to a
        <code class="literal">MERGE</code> table.
    </p><p style="color:blue;">可以在合并表上使用“选择”、“删除”、“更新”和“插入”。您必须对映射到合并表的myisam表具有选择、删除和更新权限。</p>
        <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">

            <div class="admon-title">
                Note
            </div>
            <p>
                The use of <code class="literal">MERGE</code> tables entails the following
                security issue: If a user has access to <code class="literal">MyISAM</code>
                table <em class="replaceable"><code>t</code></em>, that user can create a
                <code class="literal">MERGE</code> table <em class="replaceable"><code>m</code></em> that
                accesses <em class="replaceable"><code>t</code></em>. However, if the user's
                privileges on <em class="replaceable"><code>t</code></em> are subsequently
                revoked, the user can continue to access
                <em class="replaceable"><code>t</code></em> by doing so through
                <em class="replaceable"><code>m</code></em>.
            </p><p style="color:blue;">使用合并表会产生以下安全问题：如果用户有权访问myisam表t，则该用户可以创建访问t的合并表m。但是，如果用户对t的权限随后被吊销，则该用户可以通过m继续访问t。</p>
        </div>
        <p>
            Use of <a class="link" href="sql-syntax.html#drop-table" title="13.1.29&nbsp;DROP TABLE Syntax"><code class="literal">DROP TABLE</code></a> with a
            <code class="literal">MERGE</code> table drops only the
            <code class="literal">MERGE</code> specification. The underlying tables are
            not affected.
        </p><p style="color:blue;">对合并表使用drop table只删除合并规范。基础表不受影响。</p><p>
        To create a <code class="literal">MERGE</code> table, you must specify a
        <code class="literal">UNION=(<em class="replaceable"><code>list-of-tables</code></em>)</code>
        option that indicates which <code class="literal">MyISAM</code> tables to use.
        You can optionally specify an <code class="literal">INSERT_METHOD</code>
        option to control how inserts into the <code class="literal">MERGE</code>
        table take place. Use a value of <code class="literal">FIRST</code> or
        <code class="literal">LAST</code> to cause inserts to be made in the first or
        last underlying table, respectively. If you specify no
        <code class="literal">INSERT_METHOD</code> option or if you specify it with a
        value of <code class="literal">NO</code>, inserts into the
        <code class="literal">MERGE</code> table are not permitted and attempts to do
        so result in an error.
    </p><p style="color:blue;">要创建合并表，必须指定union=（表列表）选项，该选项指示要使用哪个myisam表。您可以选择指定insert_method选项来控制如何插入合并表。使用值first或last分别在第一个或最后一个基础表中进行插入。如果指定no insert_method选项，或者使用no值指定该选项，则不允许插入合并表，并且尝试这样做会导致错误。</p><p>
        The following example shows how to create a <code class="literal">MERGE</code>
        table:
    </p><p style="color:blue;">下面的示例演示如何创建合并表：</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>CREATE TABLE t1 (</code></strong>
    -&gt;    <strong class="userinput"><code>a INT NOT NULL AUTO_INCREMENT PRIMARY KEY,</code></strong>
    -&gt;    <strong class="userinput"><code>message CHAR(20)) ENGINE=MyISAM;</code></strong>
mysql&gt; <strong class="userinput"><code>CREATE TABLE t2 (</code></strong>
    -&gt;    <strong class="userinput"><code>a INT NOT NULL AUTO_INCREMENT PRIMARY KEY,</code></strong>
    -&gt;    <strong class="userinput"><code>message CHAR(20)) ENGINE=MyISAM;</code></strong>
mysql&gt; <strong class="userinput"><code>INSERT INTO t1 (message) VALUES ('Testing'),('table'),('t1');</code></strong>
mysql&gt; <strong class="userinput"><code>INSERT INTO t2 (message) VALUES ('Testing'),('table'),('t2');</code></strong>
mysql&gt; <strong class="userinput"><code>CREATE TABLE total (</code></strong>
    -&gt;    <strong class="userinput"><code>a INT NOT NULL AUTO_INCREMENT,</code></strong>
    -&gt;    <strong class="userinput"><code>message CHAR(20), INDEX(a))</code></strong>
    -&gt;    <strong class="userinput"><code>ENGINE=MERGE UNION=(t1,t2) INSERT_METHOD=LAST;</code></strong>
</pre><p>
        Column <code class="literal">a</code> is indexed as a <code class="literal">PRIMARY
        KEY</code> in the underlying <code class="literal">MyISAM</code> tables,
        but not in the <code class="literal">MERGE</code> table. There it is indexed
        but not as a <code class="literal">PRIMARY KEY</code> because a
        <code class="literal">MERGE</code> table cannot enforce uniqueness over the
        set of underlying tables. (Similarly, a column with a
        <code class="literal">UNIQUE</code> index in the underlying tables should be
        indexed in the <code class="literal">MERGE</code> table but not as a
        <code class="literal">UNIQUE</code> index.)
    </p><p style="color:blue;">列A作为主键在基础MyISAM表中编制索引，但不在合并表中编制索引。在那里它被索引，但不是作为主键，因为合并表不能对基础表集强制唯一性。（类似地，在基础表中具有唯一索引的列应在合并表中编制索引，但不能作为唯一索引。）</p><p>
        After creating the <code class="literal">MERGE</code> table, you can use it to
        issue queries that operate on the group of tables as a whole:
    </p><p style="color:blue;">创建合并表后，可以使用它发出对整个表组进行操作的查询：</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT * FROM total;</code></strong>
+---+---------+
| a | message |
+---+---------+
| 1 | Testing |
| 2 | table   |
| 3 | t1      |
| 1 | Testing |
| 2 | table   |
| 3 | t2      |
+---+---------+
</pre><p>
        To remap a <code class="literal">MERGE</code> table to a different collection
        of <code class="literal">MyISAM</code> tables, you can use one of the
        following methods:
    </p><p style="color:blue;">要将合并表重新映射到不同的myisam表集合，可以使用以下方法之一：</p>
        <div class="itemizedlist">
            <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                <code class="literal">DROP</code> the <code class="literal">MERGE</code> table and
                re-create it.
            </p><p style="color:blue;">删除合并表并重新创建它。</p></li><li class="listitem"><p>
                Use <code class="literal">ALTER TABLE <em class="replaceable"><code>tbl_name</code></em>
                UNION=(...)</code> to change the list of underlying tables.
            </p><p style="color:blue;">使用alter table tbl_name union=（…）更改基础表的列表。</p><p>
                It is also possible to use <code class="literal">ALTER TABLE ...
                UNION=()</code> (that is, with an empty
                <a class="link" href="sql-syntax.html#union" title="13.2.9.3&nbsp;UNION Syntax"><code class="literal">UNION</code></a> clause) to remove all of
                the underlying tables. However, in this case, the table is
                effectively empty and inserts fail because there is no
                underlying table to take new rows. Such a table might be useful
                as a template for creating new <code class="literal">MERGE</code> tables
                with <a class="link" href="sql-syntax.html#create-table-like" title="13.1.18.4&nbsp;CREATE TABLE ... LIKE Syntax"><code class="literal">CREATE
                TABLE ... LIKE</code></a>.
            </p><p style="color:blue;">也可以使用alter table…union=（即，使用空union子句）删除所有基础表。但是，在这种情况下，表实际上是空的，插入操作失败，因为没有基础表来获取新行。这样的表可以用作创建带有create table的新合并表的模板…就像。</p></li></ul>
        </div>
        <p>
            The underlying table definitions and indexes must conform closely to
            the definition of the <code class="literal">MERGE</code> table. Conformance is
            checked when a table that is part of a <code class="literal">MERGE</code>
            table is opened, not when the <code class="literal">MERGE</code> table is
            created. If any table fails the conformance checks, the operation
            that triggered the opening of the table fails. This means that
            changes to the definitions of tables within a
            <code class="literal">MERGE</code> may cause a failure when the
            <code class="literal">MERGE</code> table is accessed. The conformance checks
            applied to each table are:
        </p><p style="color:blue;">基础表定义和索引必须与合并表的定义紧密一致。打开作为合并表一部分的表时，而不是创建合并表时，将检查一致性。如果任何表未通过一致性检查，则触发表打开的操作将失败。这意味着当访问合并表时，对合并中表定义的更改可能会导致失败。应用于每个表的一致性检查包括：</p>
        <div class="itemizedlist">
            <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                The underlying table and the <code class="literal">MERGE</code> table must
                have the same number of columns.
            </p><p style="color:blue;">基础表和合并表的列数必须相同。</p></li><li class="listitem"><p>
                The column order in the underlying table and the
                <code class="literal">MERGE</code> table must match.
            </p><p style="color:blue;">基础表和合并表中的列顺序必须匹配。</p></li><li class="listitem"><p>
                Additionally, the specification for each corresponding column in
                the parent <code class="literal">MERGE</code> table and the underlying
                tables are compared and must satisfy these checks:
            </p><p style="color:blue;">此外，还将比较父合并表和基础表中每个对应列的规范，这些规范必须满足以下检查：</p>
                <div class="itemizedlist">
                    <ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
                        The column type in the underlying table and the
                        <code class="literal">MERGE</code> table must be equal.
                    </p><p style="color:blue;">基础表和合并表中的列类型必须相等。</p></li><li class="listitem"><p>
                        The column length in the underlying table and the
                        <code class="literal">MERGE</code> table must be equal.
                    </p><p style="color:blue;">基础表和合并表中的列长度必须相等。</p></li><li class="listitem"><p>
                        The column of the underlying table and the
                        <code class="literal">MERGE</code> table can be
                        <code class="literal">NULL</code>.
                    </p><p style="color:blue;">基础表和合并表的列可以为空。</p></li></ul>
                </div>
            </li><li class="listitem"><p>
                The underlying table must have at least as many indexes as the
                <code class="literal">MERGE</code> table. The underlying table may have
                more indexes than the <code class="literal">MERGE</code> table, but cannot
                have fewer.
            </p><p style="color:blue;">基础表的索引数必须至少与合并表的索引数相同。基础表的索引可能比合并表多，但不能少。</p>
                <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">

                    <div class="admon-title">
                        Note
                    </div>
                    <p>
                        A known issue exists where indexes on the same columns must be
                        in identical order, in both the <code class="literal">MERGE</code> table
                        and the underlying <code class="literal">MyISAM</code> table. See Bug
                        #33653.
                    </p><p style="color:blue;">在合并表和基础MyISAM表中，同一列的索引必须以相同的顺序存在一个已知的问题。见Bug 33653。</p>
                </div>
                <p>
                    Each index must satisfy these checks:
                </p><p style="color:blue;">每个索引必须满足这些检查：</p>
                <div class="itemizedlist">
                    <ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
                        The index type of the underlying table and the
                        <code class="literal">MERGE</code> table must be the same.
                    </p><p style="color:blue;">基础表和合并表的索引类型必须相同。</p></li><li class="listitem"><p>
                        The number of index parts (that is, multiple columns within
                        a compound index) in the index definition for the underlying
                        table and the <code class="literal">MERGE</code> table must be the
                        same.
                    </p><p style="color:blue;">基础表和合并表的索引定义中的索引部分（即复合索引中的多个列）数必须相同。</p></li><li class="listitem"><p>
                        For each index part:
                    </p><p style="color:blue;">对于每个索引部分：</p>
                        <div class="itemizedlist">
                            <ul class="itemizedlist" style="list-style-type: square; "><li class="listitem"><p>
                                Index part lengths must be equal.
                            </p><p style="color:blue;">索引部分长度必须相等。</p></li><li class="listitem"><p>
                                Index part types must be equal.
                            </p><p style="color:blue;">索引部件类型必须相等。</p></li><li class="listitem"><p>
                                Index part languages must be equal.
                            </p><p style="color:blue;">索引部分语言必须相等。</p></li><li class="listitem"><p>
                                Check whether index parts can be
                                <code class="literal">NULL</code>.
                            </p><p style="color:blue;">检查索引部分是否可以为空。</p></li></ul>
                        </div>
                    </li></ul>
                </div>
            </li></ul>
        </div>
        <p>
            If a <code class="literal">MERGE</code> table cannot be opened or used because
            of a problem with an underlying table, <a class="link" href="sql-syntax.html#check-table" title="13.7.2.2&nbsp;CHECK TABLE Syntax"><code class="literal">CHECK
            TABLE</code></a> displays information about which table caused the
            problem.
        </p><p style="color:blue;">如果由于基础表出现问题而无法打开或使用合并表，则check table将显示有关导致问题的表的信息。</p>
        <h3><a name="idm140286802685824"></a>Additional Resources</h3>
        <div class="itemizedlist">
            <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                A forum dedicated to the <code class="literal">MERGE</code> storage engine
                is available at <a class="ulink" href="https://forums.mysql.com/list.php?93" target="_top">https://forums.mysql.com/list.php?93</a>.
            </p><p style="color:blue;">专供合并存储引擎的论坛可以在https://forums.mysql.com/list.php上找到？93。</p></li></ul>
        </div>
        <div class="section">
            <div class="titlepage">
                <div>
                    <div>
                        <h3 class="title"><a name="merge-table-advantages"></a>15.7.1&nbsp;MERGE Table Advantages and Disadvantages</h3>

                    </div>

                </div>

            </div>
            <p>
                <code class="literal">MERGE</code> tables can help you solve the following
                problems:
            </p><p style="color:blue;">合并表可以帮助您解决以下问题：</p>
            <div class="itemizedlist">
                <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                    Easily manage a set of log tables. For example, you can put
                    data from different months into separate tables, compress some
                    of them with <a class="link" href="programs.html#myisampack" title="4.6.5&nbsp;myisampack — Generate Compressed, Read-Only MyISAM Tables"><span class="command"><strong>myisampack</strong></span></a>, and then create a
                    <code class="literal">MERGE</code> table to use them as one.
                </p><p style="color:blue;">轻松管理一组日志表。例如，您可以将不同月份的数据放在不同的表中，用myisampack压缩其中一些数据，然后创建一个合并表，将它们作为一个表使用。</p></li><li class="listitem"><p>
                    Obtain more speed. You can split a large read-only table based
                    on some criteria, and then put individual tables on different
                    disks. A <code class="literal">MERGE</code> table structured this way
                    could be much faster than using a single large table.
                </p><p style="color:blue;">获得更多速度。您可以根据某些条件拆分大型只读表，然后将各个表放在不同的磁盘上。这样构造的合并表可能比使用单个大表快得多。</p></li><li class="listitem"><p>
                    Perform more efficient searches. If you know exactly what you
                    are looking for, you can search in just one of the underlying
                    tables for some queries and use a <code class="literal">MERGE</code>
                    table for others. You can even have many different
                    <code class="literal">MERGE</code> tables that use overlapping sets of
                    tables.
                </p><p style="color:blue;">执行更有效的搜索。如果您确切知道要查找的是什么，则可以只在一个基础表中搜索某些查询，并为其他查询使用合并表。甚至可以有许多不同的合并表使用重叠的表集。</p></li><li class="listitem"><p>
                    Perform more efficient repairs. It is easier to repair
                    individual smaller tables that are mapped to a
                    <code class="literal">MERGE</code> table than to repair a single large
                    table.
                </p><p style="color:blue;">执行更有效的维修。修复映射到合并表的单个小表比修复单个大表更容易。</p></li><li class="listitem"><p>
                    Instantly map many tables as one. A <code class="literal">MERGE</code>
                    table need not maintain an index of its own because it uses
                    the indexes of the individual tables. As a result,
                    <code class="literal">MERGE</code> table collections are
                    <span class="emphasis"><em>very</em></span> fast to create or remap. (You must
                    still specify the index definitions when you create a
                    <code class="literal">MERGE</code> table, even though no indexes are
                    created.)
                </p><p style="color:blue;">立即将多张表映射为一张。合并表不需要维护自己的索引，因为它使用各个表的索引。因此，合并表集合的创建或重新映射速度非常快。（创建合并表时，即使未创建索引，也必须指定索引定义。）</p></li><li class="listitem"><p>
                    If you have a set of tables from which you create a large
                    table on demand, you can instead create a
                    <code class="literal">MERGE</code> table from them on demand. This is
                    much faster and saves a lot of disk space.
                </p><p style="color:blue;">如果有一组按需创建大型表的表，则可以根据需要从中创建合并表。这样速度更快，节省了大量磁盘空间。</p></li><li class="listitem"><p>
                    Exceed the file size limit for the operating system. Each
                    <code class="literal">MyISAM</code> table is bound by this limit, but a
                    collection of <code class="literal">MyISAM</code> tables is not.
                </p><p style="color:blue;">超出操作系统的文件大小限制。每个myisam表都受此限制的约束，但myisam表的集合不受此限制。</p></li><li class="listitem"><p>
                    You can create an alias or synonym for a
                    <code class="literal">MyISAM</code> table by defining a
                    <code class="literal">MERGE</code> table that maps to that single table.
                    There should be no really notable performance impact from
                    doing this (only a couple of indirect calls and
                    <code class="literal">memcpy()</code> calls for each read).
                </p><p style="color:blue;">通过定义映射到myisam表的合并表，可以为myisam表创建别名或同义词。这样做应该不会对性能产生显著的影响（对于每个读操作，只有两个间接调用和memcpy（）调用）。</p></li></ul>
            </div>
            <p>
                The disadvantages of <code class="literal">MERGE</code> tables are:
            </p><p style="color:blue;">合并表的缺点是：</p>
            <div class="itemizedlist">
                <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                    You can use only identical <code class="literal">MyISAM</code> tables
                    for a <code class="literal">MERGE</code> table.
                </p><p style="color:blue;">对于合并表，只能使用相同的myisam表。</p></li><li class="listitem"><p>
                    Some <code class="literal">MyISAM</code> features are unavailable in
                    <code class="literal">MERGE</code> tables. For example, you cannot
                    create <code class="literal">FULLTEXT</code> indexes on
                    <code class="literal">MERGE</code> tables. (You can create
                    <code class="literal">FULLTEXT</code> indexes on the underlying
                    <code class="literal">MyISAM</code> tables, but you cannot search the
                    <code class="literal">MERGE</code> table with a full-text search.)
                </p><p style="color:blue;">某些myisam功能在合并表中不可用。例如，不能在合并表上创建全文索引。（可以在基础myisam表上创建全文索引，但不能使用全文搜索搜索合并表。）</p></li><li class="listitem"><p>
                    If the <code class="literal">MERGE</code> table is nontemporary, all
                    underlying <code class="literal">MyISAM</code> tables must be
                    nontemporary. If the <code class="literal">MERGE</code> table is
                    temporary, the <code class="literal">MyISAM</code> tables can be any mix
                    of temporary and nontemporary.
                </p><p style="color:blue;">如果合并表是非临时的，那么所有底层的myisam表都必须是非临时的。如果合并表是临时的，那么myisam表可以是临时表和非临时表的任意组合。</p></li><li class="listitem"><p>
                    <code class="literal">MERGE</code> tables use more file descriptors than
                    <code class="literal">MyISAM</code> tables. If 10 clients are using a
                    <code class="literal">MERGE</code> table that maps to 10 tables, the
                    server uses (10 × 10) + 10 file descriptors. (10 data
                    file descriptors for each of the 10 clients, and 10 index file
                    descriptors shared among the clients.)
                </p><p style="color:blue;">合并表比myisam表使用更多的文件描述符。如果10个客户端使用映射到10个表的合并表，则服务器使用（10×10）+10个文件描述符。（10个客户端的每个客户端有10个数据文件描述符，客户端之间共享10个索引文件描述符。）</p></li><li class="listitem"><p>
                    Index reads are slower. When you read an index, the
                    <code class="literal">MERGE</code> storage engine needs to issue a read
                    on all underlying tables to check which one most closely
                    matches a given index value. To read the next index value, the
                    <code class="literal">MERGE</code> storage engine needs to search the
                    read buffers to find the next value. Only when one index
                    buffer is used up does the storage engine need to read the
                    next index block. This makes <code class="literal">MERGE</code> indexes
                    much slower on <a class="link" href="optimization.html#jointype_eq_ref"><code class="literal">eq_ref</code></a>
                    searches, but not much slower on
                    <a class="link" href="optimization.html#jointype_ref"><code class="literal">ref</code></a> searches. For more
                    information about <a class="link" href="optimization.html#jointype_eq_ref"><code class="literal">eq_ref</code></a>
                    and <a class="link" href="optimization.html#jointype_ref"><code class="literal">ref</code></a>, see
                    <a class="xref" href="sql-syntax.html#explain" title="13.8.2&nbsp;EXPLAIN Syntax">Section&nbsp;13.8.2, “EXPLAIN Syntax”</a>.
                </p><p style="color:blue;">索引读取速度较慢。读取索引时，合并存储引擎需要对所有基础表发出读取操作，以检查哪个表与给定索引值最匹配。要读取下一个索引值，合并存储引擎需要搜索读取缓冲区以查找下一个值。只有当一个索引缓冲区用完时，存储引擎才需要读取下一个索引块。这使得合并索引在eq-ref搜索上慢得多，但在ref搜索上慢得多。有关eq_ref和ref的更多信息，请参见第13.8.2节“解释语法”。</p></li></ul>
            </div>

        </div>
        <div class="section">
            <div class="titlepage">
                <div>
                    <div>
                        <h3 class="title"><a name="merge-table-problems"></a>15.7.2&nbsp;MERGE Table Problems</h3>

                    </div>

                </div>

            </div>
            <p>
                The following are known problems with <code class="literal">MERGE</code>
                tables:
            </p><p style="color:blue;">以下是合并表的已知问题：</p>
            <div class="itemizedlist">
                <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                    In versions of MySQL Server prior to 5.1.23, it was possible
                    to create temporary merge tables with nontemporary child
                    MyISAM tables.
                </p><p style="color:blue;">在5.1.23之前的mysql服务器版本中，可以使用非临时子myisam表创建临时合并表。</p><p>
                    From versions 5.1.23, MERGE children were locked through the
                    parent table. If the parent was temporary, it was not locked
                    and so the children were not locked either. Parallel use of
                    the MyISAM tables corrupted them.
                </p><p style="color:blue;">在5.1.23版本中，合并子项通过父表锁定。如果父对象是临时的，则它不会被锁定，因此子对象也不会被锁定。并行使用myisam表损坏了它们。</p></li><li class="listitem"><p>
                    If you use <a class="link" href="sql-syntax.html#alter-table" title="13.1.8&nbsp;ALTER TABLE Syntax"><code class="literal">ALTER TABLE</code></a> to
                    change a <code class="literal">MERGE</code> table to another storage
                    engine, the mapping to the underlying tables is lost. Instead,
                    the rows from the underlying <code class="literal">MyISAM</code> tables
                    are copied into the altered table, which then uses the
                    specified storage engine.
                </p><p style="color:blue;">如果使用alter table将合并表更改为另一个存储引擎，则到基础表的映射将丢失。相反，底层myisam表中的行被复制到修改后的表中，然后使用指定的存储引擎。</p></li><li class="listitem"><p>
                    The <code class="literal">INSERT_METHOD</code> table option for a
                    <code class="literal">MERGE</code> table indicates which underlying
                    <code class="literal">MyISAM</code> table to use for inserts into the
                    <code class="literal">MERGE</code> table. However, use of the
                    <code class="literal">AUTO_INCREMENT</code> table option for that
                    <code class="literal">MyISAM</code> table has no effect for inserts into
                    the <code class="literal">MERGE</code> table until at least one row has
                    been inserted directly into the <code class="literal">MyISAM</code>
                    table.
                </p><p style="color:blue;">合并表的insert_method table选项指示要用于插入合并表的基础myisam表。但是，在将至少一行直接插入myisam表之前，对该myisam表使用auto_increment table选项对插入合并表没有影响。</p></li><li class="listitem"><p>
                    A <code class="literal">MERGE</code> table cannot maintain uniqueness
                    constraints over the entire table. When you perform an
                    <a class="link" href="sql-syntax.html#insert" title="13.2.5&nbsp;INSERT Syntax"><code class="literal">INSERT</code></a>, the data goes into the
                    first or last <code class="literal">MyISAM</code> table (as determined
                    by the <code class="literal">INSERT_METHOD</code> option). MySQL ensures
                    that unique key values remain unique within that
                    <code class="literal">MyISAM</code> table, but not over all the
                    underlying tables in the collection.
                </p><p style="color:blue;">合并表不能在整个表上保持唯一性约束。执行插入时，数据将进入第一个或最后一个myisam表（由insert_method选项确定）。mysql确保唯一的键值在myisam表中保持唯一，但不能覆盖集合中的所有基础表。</p></li><li class="listitem"><p>
                    Because the <code class="literal">MERGE</code> engine cannot enforce
                    uniqueness over the set of underlying tables,
                    <a class="link" href="sql-syntax.html#replace" title="13.2.8&nbsp;REPLACE Syntax"><code class="literal">REPLACE</code></a> does not work as
                    expected. The two key facts are:
                </p><p style="color:blue;">由于合并引擎无法对基础表集强制唯一性，因此replace无法按预期工作。两个关键事实是：</p>
                    <div class="itemizedlist">
                        <ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
                            <a class="link" href="sql-syntax.html#replace" title="13.2.8&nbsp;REPLACE Syntax"><code class="literal">REPLACE</code></a> can detect unique
                            key violations only in the underlying table to which it is
                            going to write (which is determined by the
                            <code class="literal">INSERT_METHOD</code> option). This differs
                            from violations in the <code class="literal">MERGE</code> table
                            itself.
                        </p><p style="color:blue;">replace只能在它要写入的基础表（由insert_method选项决定）中检测唯一的键冲突。这与合并表本身的冲突不同。</p></li><li class="listitem"><p>
                            If <a class="link" href="sql-syntax.html#replace" title="13.2.8&nbsp;REPLACE Syntax"><code class="literal">REPLACE</code></a> detects a unique
                            key violation, it will change only the corresponding row
                            in the underlying table it is writing to; that is, the
                            first or last table, as determined by the
                            <code class="literal">INSERT_METHOD</code> option.
                        </p><p style="color:blue;">如果replace检测到唯一的密钥冲突，它将只更改它正在写入的基础表中的相应行；即第一个或最后一个表，由insert_method选项确定。</p></li></ul>
                    </div>
                    <p>
                        Similar considerations apply for
                        <a class="link" href="sql-syntax.html#insert-on-duplicate" title="13.2.5.2&nbsp;INSERT ... ON DUPLICATE KEY UPDATE Syntax"><code class="literal">INSERT
                            ... ON DUPLICATE KEY UPDATE</code></a>.
                    </p><p style="color:blue;">类似的考虑适用于插入…在重复密钥更新时。</p></li><li class="listitem"><p>
                    <code class="literal">MERGE</code> tables do not support partitioning.
                    That is, you cannot partition a <code class="literal">MERGE</code>
                    table, nor can any of a <code class="literal">MERGE</code> table's
                    underlying <code class="literal">MyISAM</code> tables be partitioned.
                </p><p style="color:blue;">合并表不支持分区。也就是说，不能对合并表进行分区，也不能对合并表的任何底层myisam表进行分区。</p></li><li class="listitem"><p>
                    You should not use <a class="link" href="sql-syntax.html#analyze-table" title="13.7.2.1&nbsp;ANALYZE TABLE Syntax"><code class="literal">ANALYZE
                    TABLE</code></a>, <a class="link" href="sql-syntax.html#repair-table" title="13.7.2.5&nbsp;REPAIR TABLE Syntax"><code class="literal">REPAIR TABLE</code></a>,
                    <a class="link" href="sql-syntax.html#optimize-table" title="13.7.2.4&nbsp;OPTIMIZE TABLE Syntax"><code class="literal">OPTIMIZE TABLE</code></a>,
                    <a class="link" href="sql-syntax.html#alter-table" title="13.1.8&nbsp;ALTER TABLE Syntax"><code class="literal">ALTER TABLE</code></a>,
                    <a class="link" href="sql-syntax.html#drop-table" title="13.1.29&nbsp;DROP TABLE Syntax"><code class="literal">DROP TABLE</code></a>,
                    <a class="link" href="sql-syntax.html#delete" title="13.2.2&nbsp;DELETE Syntax"><code class="literal">DELETE</code></a> without a
                    <code class="literal">WHERE</code> clause, or
                    <a class="link" href="sql-syntax.html#truncate-table" title="13.1.34&nbsp;TRUNCATE TABLE Syntax"><code class="literal">TRUNCATE TABLE</code></a> on any of the
                    tables that are mapped into an open <code class="literal">MERGE</code>
                    table. If you do so, the <code class="literal">MERGE</code> table may
                    still refer to the original table and yield unexpected
                    results. To work around this problem, ensure that no
                    <code class="literal">MERGE</code> tables remain open by issuing a
                    <a class="link" href="sql-syntax.html#flush-tables"><code class="literal">FLUSH TABLES</code></a> statement prior to
                    performing any of the named operations.
                </p><p style="color:blue;">在映射到打开合并表的任何表上，都不应使用analyze table、repair table、optimize table、alter table、drop table、delete without a where子句或truncate table。如果这样做，合并表可能仍然引用原始表并产生意外结果。要解决此问题，请在执行任何命名操作之前发出flush tables语句，确保没有合并表保持打开状态。</p><p>
                    The unexpected results include the possibility that the
                    operation on the <code class="literal">MERGE</code> table will report
                    table corruption. If this occurs after one of the named
                    operations on the underlying <code class="literal">MyISAM</code> tables,
                    the corruption message is spurious. To deal with this, issue a
                    <a class="link" href="sql-syntax.html#flush-tables"><code class="literal">FLUSH TABLES</code></a> statement after
                    modifying the <code class="literal">MyISAM</code> tables.
                </p><p style="color:blue;">意外结果包括合并表上的操作可能会报告表损坏。如果这发生在底层myisam表上的一个命名操作之后，则损坏消息是假的。要处理这个问题，请在修改myisam表之后发出flush tables语句。</p></li><li class="listitem"><p>
                    <a class="link" href="sql-syntax.html#drop-table" title="13.1.29&nbsp;DROP TABLE Syntax"><code class="literal">DROP TABLE</code></a> on a table that is
                    in use by a <code class="literal">MERGE</code> table does not work on
                    Windows because the <code class="literal">MERGE</code> storage engine's
                    table mapping is hidden from the upper layer of MySQL. Windows
                    does not permit open files to be deleted, so you first must
                    flush all <code class="literal">MERGE</code> tables (with
                    <a class="link" href="sql-syntax.html#flush-tables"><code class="literal">FLUSH TABLES</code></a>) or drop the
                    <code class="literal">MERGE</code> table before dropping the table.
                </p><p style="color:blue;">合并表正在使用的表上的drop table在windows上不起作用，因为合并存储引擎的表映射在mysql的上层是隐藏的。Windows不允许删除打开的文件，因此在删除合并表之前，必须先刷新所有合并表（使用刷新表）或删除合并表。</p></li><li class="listitem"><p>
                    The definition of the <code class="literal">MyISAM</code> tables and the
                    <code class="literal">MERGE</code> table are checked when the tables are
                    accessed (for example, as part of a
                    <a class="link" href="sql-syntax.html#select" title="13.2.9&nbsp;SELECT Syntax"><code class="literal">SELECT</code></a> or
                    <a class="link" href="sql-syntax.html#insert" title="13.2.5&nbsp;INSERT Syntax"><code class="literal">INSERT</code></a> statement). The checks
                    ensure that the definitions of the tables and the parent
                    <code class="literal">MERGE</code> table definition match by comparing
                    column order, types, sizes and associated indexes. If there is
                    a difference between the tables, an error is returned and the
                    statement fails. Because these checks take place when the
                    tables are opened, any changes to the definition of a single
                    table, including column changes, column ordering, and engine
                    alterations will cause the statement to fail.
                </p><p style="color:blue;">当访问myisam表和合并表时（例如，作为select或insert语句的一部分），将检查这些表的定义。这些检查通过比较列顺序、类型、大小和关联索引，确保表定义与父合并表定义匹配。如果表之间存在差异，则返回错误，语句将失败。因为这些检查在打开表时进行，所以对单个表定义的任何更改（包括列更改、列排序和引擎更改）都将导致语句失败。</p></li><li class="listitem"><p>
                    The order of indexes in the <code class="literal">MERGE</code> table and
                    its underlying tables should be the same. If you use
                    <a class="link" href="sql-syntax.html#alter-table" title="13.1.8&nbsp;ALTER TABLE Syntax"><code class="literal">ALTER TABLE</code></a> to add a
                    <code class="literal">UNIQUE</code> index to a table used in a
                    <code class="literal">MERGE</code> table, and then use
                    <a class="link" href="sql-syntax.html#alter-table" title="13.1.8&nbsp;ALTER TABLE Syntax"><code class="literal">ALTER TABLE</code></a> to add a nonunique
                    index on the <code class="literal">MERGE</code> table, the index
                    ordering is different for the tables if there was already a
                    nonunique index in the underlying table. (This happens because
                    <a class="link" href="sql-syntax.html#alter-table" title="13.1.8&nbsp;ALTER TABLE Syntax"><code class="literal">ALTER TABLE</code></a> puts
                    <code class="literal">UNIQUE</code> indexes before nonunique indexes to
                    facilitate rapid detection of duplicate keys.) Consequently,
                    queries on tables with such indexes may return unexpected
                    results.
                </p><p style="color:blue;">合并表及其基础表中的索引顺序应相同。如果使用alter table向合并表中使用的表添加唯一索引，然后使用alter table在合并表上添加非唯一索引，则如果基础表中已存在非唯一索引，则表的索引顺序将不同。（发生这种情况是因为alter table将唯一索引放在非唯一索引之前，以便于快速检测重复键。）因此，对具有此类索引的表的查询可能会返回意外结果。</p></li><li class="listitem"><p>
                    If you encounter an error message similar to <span class="errortext">ERROR
          1017 (HY000): Can't find file:
          '<em class="replaceable"><code>tbl_name</code></em>.MRG' (errno:
          2)</span>, it generally indicates that some of the
                    underlying tables do not use the <code class="literal">MyISAM</code>
                    storage engine. Confirm that all of these tables are
                    <code class="literal">MyISAM</code>.
                </p><p style="color:blue;">如果遇到类似错误1017（hy000）：找不到文件“tbl_name.mrg”（errno:2）的错误消息，则通常表示某些基础表不使用myisam存储引擎。确认所有这些表都是myisam。</p></li><li class="listitem"><p>
                    The maximum number of rows in a <code class="literal">MERGE</code> table
                    is 2<sup>64</sup> (~1.844E+19; the same as for
                    a <code class="literal">MyISAM</code> table). It is not possible to
                    merge multiple <code class="literal">MyISAM</code> tables into a single
                    <code class="literal">MERGE</code> table that would have more than this
                    number of rows.
                </p><p style="color:blue;">合并表中的最大行数为264（~1.844 e+1；与MyISAM表相同）。无法将多个myisam表合并到一个合并表中，该合并表的行数将超过此数目。</p></li><li class="listitem"><p>
                    Use of underlying <code class="literal">MyISAM</code> tables of
                    differing row formats with a parent <code class="literal">MERGE</code>
                    table is currently known to fail. See Bug #32364.
                </p><p style="color:blue;">将不同行格式的底层myisam表与父合并表一起使用目前已知会失败。参见Bug 32364。</p></li><li class="listitem"><p>
                    You cannot change the union list of a nontemporary
                    <code class="literal">MERGE</code> table when <a class="link" href="sql-syntax.html#lock-tables" title="13.3.5&nbsp;LOCK TABLES and UNLOCK TABLES Syntax"><code class="literal">LOCK
                    TABLES</code></a> is in effect. The following does
                    <span class="emphasis"><em>not</em></span> work:
                </p><p style="color:blue;">当锁表生效时，不能更改非临时合并表的联合列表。以下操作不起作用：</p><pre data-lang="sql" class="programlisting">CREATE TABLE m1 ... ENGINE=MRG_MYISAM ...;
LOCK TABLES t1 WRITE, t2 WRITE, m1 WRITE;
ALTER TABLE m1 ... UNION=(t1,t2) ...;
</pre><p>
                    However, you can do this with a temporary
                    <code class="literal">MERGE</code> table.
                </p><p style="color:blue;">但是，可以使用临时合并表来执行此操作。</p></li><li class="listitem"><p>
                    You cannot create a <code class="literal">MERGE</code> table with
                    <code class="literal">CREATE ... SELECT</code>, neither as a temporary
                    <code class="literal">MERGE</code> table, nor as a nontemporary
                    <code class="literal">MERGE</code> table. For example:
                </p><p style="color:blue;">不能使用CREATE创建合并表…选择，既不作为临时合并表，也不作为非临时合并表。例如：</p><pre data-lang="sql" class="programlisting">CREATE TABLE m1 ... ENGINE=MRG_MYISAM ... SELECT ...;</pre><p>
                    Attempts to do this result in an error:
                    <em class="replaceable"><code>tbl_name</code></em> is not <code class="literal">BASE
                    TABLE</code>.
                </p><p style="color:blue;">尝试执行此操作会导致错误：tbl_name不是基表。</p></li><li class="listitem"><p>
                    In some cases, differing <code class="literal">PACK_KEYS</code> table
                    option values among the <code class="literal">MERGE</code> and
                    underlying tables cause unexpected results if the underlying
                    tables contain <code class="literal">CHAR</code> or
                    <code class="literal">BINARY</code> columns. As a workaround, use
                    <code class="literal">ALTER TABLE</code> to ensure that all involved
                    tables have the same <code class="literal">PACK_KEYS</code> value. (Bug
                    #50646)
                </p><p style="color:blue;">在某些情况下，如果基础表包含char或binary列，则合并表和基础表之间的pack_keys table选项值不同会导致意外结果。作为解决方法，使用alter table确保所有涉及的表具有相同的pack_keys值。（错误50646）</p></li></ul>
            </div>

        </div>

    </div>
    <div class="section">
        <div class="titlepage">
            <div>
                <div>
                    <h2 class="title" style="clear: both"><a name="federated-storage-engine"></a>15.8&nbsp;The FEDERATED Storage Engine</h2>

                </div>

            </div>

        </div>
        <div class="toc">
            <dl class="toc"><dt><span class="section"><a href="storage-engines.html#federated-description">15.8.1 FEDERATED Storage Engine Overview</a></span></dt><dt><span class="section"><a href="storage-engines.html#federated-create">15.8.2 How to Create FEDERATED Tables</a></span></dt><dt><span class="section"><a href="storage-engines.html#federated-usagenotes">15.8.3 FEDERATED Storage Engine Notes and Tips</a></span></dt><dt><span class="section"><a href="storage-engines.html#federated-storage-engine-resources">15.8.4 FEDERATED Storage Engine Resources</a></span></dt></dl>
        </div>
        <a class="indexterm" name="idm140286802530912"></a><a class="indexterm" name="idm140286802529824"></a><p>
        The <code class="literal">FEDERATED</code> storage engine lets you access data
        from a remote MySQL database without using replication or cluster
        technology. Querying a local <code class="literal">FEDERATED</code> table
        automatically pulls the data from the remote (federated) tables. No
        data is stored on the local tables.
    </p><p style="color:blue;">联邦存储引擎允许您从远程mysql数据库访问数据，而无需使用复制或群集技术。查询本地联合表会自动从远程（联合）表中提取数据。本地表中不存储任何数据。</p><p>
        To include the <code class="literal">FEDERATED</code> storage engine if you
        build MySQL from source, invoke <span class="command"><strong>CMake</strong></span> with the
        <a class="link" href="installing.html#option_cmake_storage_engine_options" title="Storage Engine Options"><code class="option">-DWITH_FEDERATED_STORAGE_ENGINE</code></a>
        option.
    </p><p style="color:blue;">要在从源代码构建MySQL时包含联邦存储引擎，请使用-dwith_federated_storage_engine选项调用cmake。</p><p>
        The <code class="literal">FEDERATED</code> storage engine is not enabled by
        default in the running server; to enable
        <code class="literal">FEDERATED</code>, you must start the MySQL server binary
        using the <code class="option">--federated</code> option.
    </p><p style="color:blue;">默认情况下，运行服务器中未启用联邦存储引擎；若要启用联邦存储引擎，必须使用--federed选项启动mysql服务器二进制文件。</p><p>
        To examine the source for the <code class="literal">FEDERATED</code> engine,
        look in the <code class="filename">storage/federated</code> directory of a
        MySQL source distribution.
    </p><p style="color:blue;">要检查联邦引擎的源代码，请查看mysql源发行版的storage/federed目录。</p>
        <div class="section">

            <div class="titlepage">
                <div>
                    <div>
                        <h3 class="title"><a name="federated-description"></a>15.8.1&nbsp;FEDERATED Storage Engine Overview</h3>
                    </div>
                </div>
            </div>
            <p>
                When you create a table using one of the standard storage engines
                (such as <code class="literal">MyISAM</code>, <code class="literal">CSV</code> or
                <code class="literal">InnoDB</code>), the table consists of the table
                definition and the associated data. When you create a
                <code class="literal">FEDERATED</code> table, the table definition is the
                same, but the physical storage of the data is handled on a remote
                server.
            </p><p style="color:blue;">使用标准存储引擎（如myisam、csv或innodb）创建表时，该表由表定义和相关数据组成。创建联合表时，表定义是相同的，但数据的物理存储是在远程服务器上处理的。</p><p>
            A <code class="literal">FEDERATED</code> table consists of two elements:
        </p><p style="color:blue;">联合表由两个元素组成：</p>
            <div class="itemizedlist">
                <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                    A <span class="emphasis"><em>remote server</em></span> with a database table,
                    which in turn consists of the table definition (stored in the
                    <code class="filename">.frm</code> file) and the associated table. The
                    table type of the remote table may be any type supported by
                    the remote <code class="literal">mysqld</code> server, including
                    <code class="literal">MyISAM</code> or <code class="literal">InnoDB</code>.
                </p><p style="color:blue;">带有数据库表的远程服务器，数据库表又由表定义（存储在.frm文件中）和相关表组成。远程表的表类型可以是远程mysqld服务器支持的任何类型，包括myisam或innodb。</p></li><li class="listitem"><p>
                    A <span class="emphasis"><em>local server</em></span> with a database table,
                    where the table definition matches that of the corresponding
                    table on the remote server. The table definition is stored
                    within the <code class="filename">.frm</code> file. However, there is
                    no data file on the local server. Instead, the table
                    definition includes a connection string that points to the
                    remote table.
                </p><p style="color:blue;">具有数据库表的本地服务器，其中表定义与远程服务器上相应表的定义匹配。表定义存储在.frm文件中。但是，本地服务器上没有数据文件。相反，表定义包含指向远程表的连接字符串。</p></li></ul>
            </div>
            <p>
                When executing queries and statements on a
                <code class="literal">FEDERATED</code> table on the local server, the
                operations that would normally insert, update or delete
                information from a local data file are instead sent to the remote
                server for execution, where they update the data file on the
                remote server or return matching rows from the remote server.
            </p><p style="color:blue;">在本地服务器上对联合表执行查询和语句时，通常从本地数据文件插入、更新或删除信息的操作将被发送到远程服务器执行，在远程服务器上更新数据文件或从远程服务器返回匹配行。</p><p>
            The basic structure of a <code class="literal">FEDERATED</code> table setup
            is shown in <a class="xref" href="storage-engines.html#figure-se-federated-structure" title="Figure&nbsp;15.2&nbsp;FEDERATED Table Structure">Figure&nbsp;15.2, “FEDERATED Table Structure”</a>.
        </p><p style="color:blue;">联邦表设置的基本结构如图15.2“联邦表结构”所示。</p>
            <div class="figure">
                <a name="figure-se-federated-structure"></a><p class="title"><b>Figure&nbsp;15.2&nbsp;FEDERATED Table Structure</b></p><p style="color:blue;">图15.2联邦表结构</p>
                <div class="figure-contents">

                    <div class="mediaobject">
                        <img src="images/se-federated-structure.png" width="475" height="269" alt="Content is described in the surrounding text.">
                    </div>

                </div>

            </div>
            <br class="figure-break"><p>
            When a client issues an SQL statement that refers to a
            <code class="literal">FEDERATED</code> table, the flow of information
            between the local server (where the SQL statement is executed) and
            the remote server (where the data is physically stored) is as
            follows:
        </p><p style="color:blue;">当客户端发出引用联邦表的sql语句时，本地服务器（执行sql语句的位置）和远程服务器（数据物理存储位置）之间的信息流如下：</p>
            <div class="orderedlist">
                <ol class="orderedlist" type="1"><li class="listitem"><p>
                    The storage engine looks through each column that the
                    <code class="literal">FEDERATED</code> table has and constructs an
                    appropriate SQL statement that refers to the remote table.
                </p><p style="color:blue;">存储引擎检查联合表所具有的每一列，并构造一个引用远程表的适当sql语句。</p></li><li class="listitem"><p>
                    The statement is sent to the remote server using the MySQL
                    client API.
                </p><p style="color:blue;">语句使用mysql客户机api发送到远程服务器。</p></li><li class="listitem"><p>
                    The remote server processes the statement and the local server
                    retrieves any result that the statement produces (an
                    affected-rows count or a result set).
                </p><p style="color:blue;">远程服务器处理该语句，本地服务器检索该语句生成的任何结果（受影响的行数或结果集）。</p></li><li class="listitem"><p>
                    If the statement produces a result set, each column is
                    converted to internal storage engine format that the
                    <code class="literal">FEDERATED</code> engine expects and can use to
                    display the result to the client that issued the original
                    statement.
                </p><p style="color:blue;">如果语句生成一个结果集，则每一列都将转换为联合引擎所期望的内部存储引擎格式，并可用于向发出原始语句的客户端显示结果。</p></li></ol>
            </div>
            <p>
                The local server communicates with the remote server using MySQL
                client C API functions. It invokes
                <a class="link" href="connectors-apis.html#mysql-real-query" title="27.8.7.57&nbsp;mysql_real_query()"><code class="literal">mysql_real_query()</code></a> to send the
                statement. To read a result set, it uses
                <a class="link" href="connectors-apis.html#mysql-store-result" title="27.8.7.75&nbsp;mysql_store_result()"><code class="literal">mysql_store_result()</code></a> and fetches
                rows one at a time using
                <a class="link" href="connectors-apis.html#mysql-fetch-row" title="27.8.7.21&nbsp;mysql_fetch_row()"><code class="literal">mysql_fetch_row()</code></a>.
            </p><p style="color:blue;">本地服务器使用mysql client c api函数与远程服务器通信。它调用mysql_real_query（）发送语句。要读取结果集，它使用mysql_store_result（）并使用mysql_fetch_row（）每次获取一行。</p>
        </div>
        <div class="section">
            <div class="titlepage">
                <div>
                    <div>
                        <h3 class="title"><a name="federated-create"></a>15.8.2&nbsp;How to Create FEDERATED Tables</h3>

                    </div>

                </div>

            </div>
            <div class="toc">
                <dl class="toc"><dt><span class="section"><a href="storage-engines.html#federated-create-connection">15.8.2.1 Creating a FEDERATED Table Using CONNECTION</a></span></dt><dt><span class="section"><a href="storage-engines.html#federated-create-server">15.8.2.2 Creating a FEDERATED Table Using CREATE SERVER</a></span></dt></dl>
            </div>
            <p>
                To create a <code class="literal">FEDERATED</code> table you should follow
                these steps:
            </p><p style="color:blue;">要创建联合表，应遵循以下步骤：</p>
            <div class="orderedlist">
                <ol class="orderedlist" type="1"><li class="listitem"><p>
                    Create the table on the remote server. Alternatively, make a
                    note of the table definition of an existing table, perhaps
                    using the <a class="link" href="sql-syntax.html#show-create-table" title="13.7.5.10&nbsp;SHOW CREATE TABLE Syntax"><code class="literal">SHOW CREATE TABLE</code></a>
                    statement.
                </p><p style="color:blue;">在远程服务器上创建表。或者，使用现有的表创建表的注释，也许是使用Studio CREATETABLE语句。</p></li><li class="listitem"><p>
                    Create the table on the local server with an identical table
                    definition, but adding the connection information that links
                    the local table to the remote table.
                </p><p style="color:blue;">使用相同的表定义在本地服务器上创建表，但添加将本地表链接到远程表的连接信息。</p></li></ol>
            </div>
            <p>
                For example, you could create the following table on the remote
                server:
            </p><p style="color:blue;">例如，可以在远程服务器上创建下表：</p><pre data-lang="sql" class="programlisting">CREATE TABLE test_table (
    id     INT(20) NOT NULL AUTO_INCREMENT,
    name   VARCHAR(32) NOT NULL DEFAULT '',
    other  INT(20) NOT NULL DEFAULT '0',
    PRIMARY KEY  (id),
    INDEX name (name),
    INDEX other_key (other)
)
ENGINE=MyISAM
DEFAULT CHARSET=latin1;
</pre><p>
            To create the local table that will be federated to the remote
            table, there are two options available. You can either create the
            local table and specify the connection string (containing the
            server name, login, password) to be used to connect to the remote
            table using the <code class="literal">CONNECTION</code>, or you can use an
            existing connection that you have previously created using the
            <a class="link" href="sql-syntax.html#create-server" title="13.1.17&nbsp;CREATE SERVER Syntax"><code class="literal">CREATE SERVER</code></a> statement.
        </p><p style="color:blue;">要创建将联合到远程表的本地表，有两个选项可用。您可以创建本地表并指定连接字符串（包含服务器名称、登录名、密码），用于使用连接连接到远程表，或者您可以使用以前使用CREATESSERVER语句创建的现有连接。</p>
            <div class="important" style="margin-left: 0.5in; margin-right: 0.5in;">

                <div class="admon-title">
                    Important
                </div>
                <p>
                    When you create the local table it <span class="emphasis"><em>must</em></span>
                    have an identical field definition to the remote table.
                </p><p style="color:blue;">创建本地表时，它必须具有与远程表相同的字段定义。</p>
            </div>
            <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">
                <div class="admon-title">
                    Note
                </div>
                <p>
                    You can improve the performance of a
                    <code class="literal">FEDERATED</code> table by adding indexes to the
                    table on the host. The optimization will occur because the query
                    sent to the remote server will include the contents of the
                    <code class="literal">WHERE</code> clause and will be sent to the remote
                    server and subsequently executed locally. This reduces the
                    network traffic that would otherwise request the entire table
                    from the server for local processing.
                </p><p style="color:blue;">可以通过向主机上的表添加索引来提高联合表的性能。优化将发生，因为发送到远程服务器的查询将包含where子句的内容，并将发送到远程服务器，然后在本地执行。这减少了网络通信量，否则将从服务器请求整个表进行本地处理。</p>
            </div>
            <div class="section">
                <div class="titlepage">
                    <div>
                        <div>
                            <h4 class="title"><a name="federated-create-connection"></a>15.8.2.1&nbsp;Creating a FEDERATED Table Using CONNECTION</h4>

                        </div>

                    </div>

                </div>
                <p>
                    To use the first method, you must specify the
                    <code class="literal">CONNECTION</code> string after the engine type in a
                    <a class="link" href="sql-syntax.html#create-table" title="13.1.18&nbsp;CREATE TABLE Syntax"><code class="literal">CREATE TABLE</code></a> statement. For
                    example:
                </p><p style="color:blue;">要使用第一个方法，必须在CREATETABLE语句中的引擎类型之后指定连接字符串。例如：</p><pre data-lang="sql" class="programlisting">CREATE TABLE federated_table (
    id     INT(20) NOT NULL AUTO_INCREMENT,
    name   VARCHAR(32) NOT NULL DEFAULT '',
    other  INT(20) NOT NULL DEFAULT '0',
    PRIMARY KEY  (id),
    INDEX name (name),
    INDEX other_key (other)
)
ENGINE=FEDERATED
DEFAULT CHARSET=latin1
CONNECTION='mysql://fed_user@remote_host:9306/federated/test_table';
</pre>
                <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">

                    <div class="admon-title">
                        Note
                    </div>
                    <p>
                        <code class="literal">CONNECTION</code> replaces the
                        <code class="literal">COMMENT</code> used in some previous versions of
                        MySQL.
                    </p><p style="color:blue;">connection替换了mysql的一些早期版本中使用的注释。</p>
                </div>
                <p>
                    The <code class="literal">CONNECTION</code> string contains the
                    information required to connect to the remote server containing
                    the table that will be used to physically store the data. The
                    connection string specifies the server name, login credentials,
                    port number and database/table information. In the example, the
                    remote table is on the server <code class="literal">remote_host</code>,
                    using port 9306. The name and port number should match the host
                    name (or IP address) and port number of the remote MySQL server
                    instance you want to use as your remote table.
                </p><p style="color:blue;">连接字符串包含连接到包含将用于物理存储数据的表的远程服务器所需的信息。连接字符串指定服务器名称、登录凭据、端口号和数据库/表信息。在本例中，远程表位于服务器远程主机上，使用端口9306。名称和端口号应与要用作远程表的远程mysql服务器实例的主机名（或ip地址）和端口号匹配。</p><p>
                The format of the connection string is as follows:
            </p><p style="color:blue;">连接字符串的格式如下：</p><pre data-lang="none" class="programlisting"><em class="replaceable"><code>scheme</code></em>://<em class="replaceable"><code>user_name</code></em>[:<em class="replaceable"><code>password</code></em>]@<em class="replaceable"><code>host_name</code></em>[:<em class="replaceable"><code>port_num</code></em>]/<em class="replaceable"><code>db_name</code></em>/<em class="replaceable"><code>tbl_name</code></em>
</pre><p>
                Where:
            </p><p style="color:blue;">在哪里？</p>
                <div class="itemizedlist">
                    <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                        <em class="replaceable"><code>scheme</code></em>: A recognized connection
                        protocol. Only <code class="literal">mysql</code> is supported as the
                        <em class="replaceable"><code>scheme</code></em> value at this point.
                    </p><p style="color:blue;">方案：可识别的连接协议。此时只支持将mysql作为scheme值。</p></li><li class="listitem"><p>
                        <em class="replaceable"><code>user_name</code></em>: The user name for the
                        connection. This user must have been created on the remote
                        server, and must have suitable privileges to perform the
                        required actions (<a class="link" href="sql-syntax.html#select" title="13.2.9&nbsp;SELECT Syntax"><code class="literal">SELECT</code></a>,
                        <a class="link" href="sql-syntax.html#insert" title="13.2.5&nbsp;INSERT Syntax"><code class="literal">INSERT</code></a>,
                        <a class="link" href="sql-syntax.html#update" title="13.2.11&nbsp;UPDATE Syntax"><code class="literal">UPDATE</code></a>, and so forth) on the
                        remote table.
                    </p><p style="color:blue;">用户名：连接的用户名。此用户必须是在远程服务器上创建的，并且必须具有在远程表上执行所需操作（选择、插入、更新等）的适当权限。</p></li><li class="listitem"><p>
                        <em class="replaceable"><code>password</code></em>: (Optional) The
                        corresponding password for
                        <em class="replaceable"><code>user_name</code></em>.
                    </p><p style="color:blue;">password：（可选）用户名对应的密码。</p></li><li class="listitem"><p>
                        <em class="replaceable"><code>host_name</code></em>: The host name or IP
                        address of the remote server.
                    </p><p style="color:blue;">主机名：远程服务器的主机名或IP地址。</p></li><li class="listitem"><p>
                        <em class="replaceable"><code>port_num</code></em>: (Optional) The port
                        number for the remote server. The default is 3306.
                    </p><p style="color:blue;">port_num：（可选）远程服务器的端口号。默认值为3306。</p></li><li class="listitem"><p>
                        <em class="replaceable"><code>db_name</code></em>: The name of the database
                        holding the remote table.
                    </p><p style="color:blue;">db_name：保存远程表的数据库的名称。</p></li><li class="listitem"><p>
                        <em class="replaceable"><code>tbl_name</code></em>: The name of the remote
                        table. The name of the local and the remote table do not
                        have to match.
                    </p><p style="color:blue;">tbl_name：远程表的名称。本地表和远程表的名称不必匹配。</p></li></ul>
                </div>
                <p>
                    Sample connection strings:
                </p><p style="color:blue;">示例连接字符串：</p><pre data-lang="sql" class="programlisting">CONNECTION='mysql://username:password@hostname:port/database/tablename'
CONNECTION='mysql://username@hostname/database/tablename'
CONNECTION='mysql://username:password@hostname/database/tablename'
</pre>
            </div>
            <div class="section">
                <div class="titlepage">
                    <div>
                        <div>
                            <h4 class="title"><a name="federated-create-server"></a>15.8.2.2&nbsp;Creating a FEDERATED Table Using CREATE SERVER</h4>

                        </div>

                    </div>

                </div>
                <p>
                    If you are creating a number of <code class="literal">FEDERATED</code>
                    tables on the same server, or if you want to simplify the
                    process of creating <code class="literal">FEDERATED</code> tables, you can
                    use the <a class="link" href="sql-syntax.html#create-server" title="13.1.17&nbsp;CREATE SERVER Syntax"><code class="literal">CREATE SERVER</code></a> statement
                    to define the server connection parameters, just as you would
                    with the <code class="literal">CONNECTION</code> string.
                </p><p style="color:blue;">如果要在同一服务器上创建多个联合表，或者要简化创建联合表的过程，可以使用create server语句定义服务器连接参数，就像使用连接字符串一样。</p><p>
                The format of the <a class="link" href="sql-syntax.html#create-server" title="13.1.17&nbsp;CREATE SERVER Syntax"><code class="literal">CREATE SERVER</code></a>
                statement is:
            </p><p style="color:blue;">CREATE SERVER语句的格式为：</p><pre data-lang="sql" class="programlisting">CREATE SERVER
<em class="replaceable"><code>server_name</code></em>
FOREIGN DATA WRAPPER <em class="replaceable"><code>wrapper_name</code></em>
OPTIONS (<em class="replaceable"><code>option</code></em> [, <em class="replaceable"><code>option</code></em>] ...)</pre><p>
                The <em class="replaceable"><code>server_name</code></em> is used in the
                connection string when creating a new
                <code class="literal">FEDERATED</code> table.
            </p><p style="color:blue;">创建新的联合表时，在连接字符串中使用服务器名。</p><p>
                For example, to create a server connection identical to the
                <code class="literal">CONNECTION</code> string:
            </p><p style="color:blue;">例如，要创建与连接字符串相同的服务器连接：</p><pre data-lang="sql" class="programlisting">CONNECTION='mysql://fed_user@remote_host:9306/federated/test_table';</pre><p>
                You would use the following statement:
            </p><p style="color:blue;">您可以使用以下语句：</p><pre data-lang="sql" class="programlisting">CREATE SERVER fedlink
FOREIGN DATA WRAPPER mysql
OPTIONS (USER 'fed_user', HOST 'remote_host', PORT 9306, DATABASE 'federated');</pre><p>
                To create a <code class="literal">FEDERATED</code> table that uses this
                connection, you still use the <code class="literal">CONNECTION</code>
                keyword, but specify the name you used in the
                <a class="link" href="sql-syntax.html#create-server" title="13.1.17&nbsp;CREATE SERVER Syntax"><code class="literal">CREATE SERVER</code></a> statement.
            </p><p style="color:blue;">若要创建使用此连接的联合表，仍然使用connection关键字，但请指定在create server语句中使用的名称。</p><pre data-lang="sql" class="programlisting">CREATE TABLE test_table (
    id     INT(20) NOT NULL AUTO_INCREMENT,
    name   VARCHAR(32) NOT NULL DEFAULT '',
    other  INT(20) NOT NULL DEFAULT '0',
    PRIMARY KEY  (id),
    INDEX name (name),
    INDEX other_key (other)
)
ENGINE=FEDERATED
DEFAULT CHARSET=latin1
CONNECTION='fedlink/test_table';</pre><p>
                The connection name in this example contains the name of the
                connection (<code class="literal">fedlink</code>) and the name of the
                table (<code class="literal">test_table</code>) to link to, separated by a
                slash. If you specify only the connection name without a table
                name, the table name of the local table is used instead.
            </p><p style="color:blue;">本例中的连接名包含连接名（fedlink）和要链接到的表名（test_table），用斜线分隔。如果只指定连接名而不指定表名，则改用本地表的表名。</p><p>
                For more information on <a class="link" href="sql-syntax.html#create-server" title="13.1.17&nbsp;CREATE SERVER Syntax"><code class="literal">CREATE
                SERVER</code></a>, see <a class="xref" href="sql-syntax.html#create-server" title="13.1.17&nbsp;CREATE SERVER Syntax">Section&nbsp;13.1.17, “CREATE SERVER Syntax”</a>.
            </p><p style="color:blue;">有关创建服务器的更多信息，请参见第13.1.17节“创建服务器语法”。</p><p>
                The <a class="link" href="sql-syntax.html#create-server" title="13.1.17&nbsp;CREATE SERVER Syntax"><code class="literal">CREATE SERVER</code></a> statement
                accepts the same arguments as the <code class="literal">CONNECTION</code>
                string. The <a class="link" href="sql-syntax.html#create-server" title="13.1.17&nbsp;CREATE SERVER Syntax"><code class="literal">CREATE SERVER</code></a>
                statement updates the rows in the
                <code class="literal">mysql.servers</code> table. See the following table
                for information on the correspondence between parameters in a
                connection string, options in the <a class="link" href="sql-syntax.html#create-server" title="13.1.17&nbsp;CREATE SERVER Syntax"><code class="literal">CREATE
                SERVER</code></a> statement, and the columns in the
                <code class="literal">mysql.servers</code> table. For reference, the
                format of the <code class="literal">CONNECTION</code> string is as
                follows:
            </p><p style="color:blue;">create server语句接受与连接字符串相同的参数。create server语句更新mysql.servers表中的行。有关连接字符串中的参数、create server语句中的选项和mysql.servers表中的列之间的对应关系的信息，请参见下表。作为参考，连接字符串的格式如下：</p><pre data-lang="none" class="programlisting"><em class="replaceable"><code>scheme</code></em>://<em class="replaceable"><code>user_name</code></em>[:<em class="replaceable"><code>password</code></em>]@<em class="replaceable"><code>host_name</code></em>[:<em class="replaceable"><code>port_num</code></em>]/<em class="replaceable"><code>db_name</code></em>/<em class="replaceable"><code>tbl_name</code></em>
</pre>
                <div class="informaltable">
                    <table summary="The correspondence between parameters in a connection string, options in the CREATE SERVER statement, and the columns in the mysql.servers table."><colgroup><col width="25%"><col width="25%"><col width="25%"><col width="25%"></colgroup><thead><tr>
                        <th scope="col">Description</th>
                        <th scope="col"><code class="literal">CONNECTION</code> string</th>
                        <th scope="col"><a class="link" href="sql-syntax.html#create-server" title="13.1.17&nbsp;CREATE SERVER Syntax"><code class="literal">CREATE SERVER</code></a> option</th>
                        <th scope="col"><code class="literal">mysql.servers</code> column</th>
                    </tr></thead><tbody><tr>
                        <td scope="row">Connection scheme</td>
                        <td><em class="replaceable"><code>scheme</code></em></td>
                        <td><code class="literal">wrapper_name</code></td>
                        <td><code class="literal">Wrapper</code></td>
                    </tr><tr>
                        <td scope="row">Remote user</td>
                        <td><em class="replaceable"><code>user_name</code></em></td>
                        <td><code class="literal">USER</code></td>
                        <td><code class="literal">Username</code></td>
                    </tr><tr>
                        <td scope="row">Remote password</td>
                        <td><em class="replaceable"><code>password</code></em></td>
                        <td><code class="literal">PASSWORD</code></td>
                        <td><code class="literal">Password</code></td>
                    </tr><tr>
                        <td scope="row">Remote host</td>
                        <td><em class="replaceable"><code>host_name</code></em></td>
                        <td><code class="literal">HOST</code></td>
                        <td><code class="literal">Host</code></td>
                    </tr><tr>
                        <td scope="row">Remote port</td>
                        <td><em class="replaceable"><code>port_num</code></em></td>
                        <td><code class="literal">PORT</code></td>
                        <td><code class="literal">Port</code></td>
                    </tr><tr>
                        <td scope="row">Remote database</td>
                        <td><em class="replaceable"><code>db_name</code></em></td>
                        <td><code class="literal">DATABASE</code></td>
                        <td><code class="literal">Db</code></td>
                    </tr></tbody></table>
                </div>

            </div>

        </div>
        <div class="section">
            <div class="titlepage">
                <div>
                    <div>
                        <h3 class="title"><a name="federated-usagenotes"></a>15.8.3&nbsp;FEDERATED Storage Engine Notes and Tips</h3>

                    </div>

                </div>

            </div>
            <p>
                You should be aware of the following points when using the
                <code class="literal">FEDERATED</code> storage engine:
            </p><p style="color:blue;">使用联合存储引擎时，应注意以下几点：</p>
            <div class="itemizedlist">
                <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                    <code class="literal">FEDERATED</code> tables may be replicated to other
                    slaves, but you must ensure that the slave servers are able to
                    use the user/password combination that is defined in the
                    <code class="literal">CONNECTION</code> string (or the row in the
                    <code class="literal">mysql.servers</code> table) to connect to the
                    remote server.
                </p><p style="color:blue;">联合表可以复制到其他从属服务器，但必须确保从属服务器能够使用连接字符串（或mysql.servers表中的行）中定义的用户/密码组合连接到远程服务器。</p></li></ul>
            </div>
            <p>
                The following items indicate features that the
                <code class="literal">FEDERATED</code> storage engine does and does not
                support:
            </p><p style="color:blue;">以下项目指示联合存储引擎支持和不支持的功能：</p>
            <div class="itemizedlist">
                <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                    The remote server must be a MySQL server.
                </p><p style="color:blue;">远程服务器必须是MySQL服务器。</p></li><li class="listitem"><p>
                    The remote table that a <code class="literal">FEDERATED</code> table
                    points to <span class="emphasis"><em>must</em></span> exist before you try to
                    access the table through the <code class="literal">FEDERATED</code>
                    table.
                </p><p style="color:blue;">在尝试通过联邦表访问表之前，联邦表指向的远程表必须存在。</p></li><li class="listitem"><p>
                    It is possible for one <code class="literal">FEDERATED</code> table to
                    point to another, but you must be careful not to create a
                    loop.
                </p><p style="color:blue;">一个联邦表可以指向另一个联邦表，但必须注意不要创建循环。</p></li><li class="listitem"><p>
                    A <code class="literal">FEDERATED</code> table does not support indexes
                    in the usual sense; because access to the table data is
                    handled remotely, it is actually the remote table that makes
                    use of indexes. This means that, for a query that cannot use
                    any indexes and so requires a full table scan, the server
                    fetches all rows from the remote table and filters them
                    locally. This occurs regardless of any
                    <code class="literal">WHERE</code> or <code class="literal">LIMIT</code> used with
                    this <a class="link" href="sql-syntax.html#select" title="13.2.9&nbsp;SELECT Syntax"><code class="literal">SELECT</code></a> statement; these
                    clauses are applied locally to the returned rows.
                </p><p style="color:blue;">联合表不支持通常意义上的索引；因为对表数据的访问是远程处理的，所以实际上使用索引的是远程表。这意味着，对于不能使用任何索引、因此需要进行完整表扫描的查询，服务器将从远程表获取所有行并在本地对其进行筛选。无论此select语句使用的位置或限制如何，都会发生这种情况；这些子句将在本地应用于返回的行。</p><p>
                    Queries that fail to use indexes can thus cause poor
                    performance and network overload. In addition, since returned
                    rows must be stored in memory, such a query can also lead to
                    the local server swapping, or even hanging.
                </p><p style="color:blue;">无法使用索引的查询会导致性能差和网络过载。此外，由于返回的行必须存储在内存中，这样的查询还可能导致本地服务器交换，甚至挂起。</p></li><li class="listitem"><p>
                    Care should be taken when creating a
                    <code class="literal">FEDERATED</code> table since the index definition
                    from an equivalent <code class="literal">MyISAM</code> or other table
                    may not be supported. For example, creating a
                    <code class="literal">FEDERATED</code> table with an index prefix on
                    <a class="link" href="data-types.html#char" title="11.4.1&nbsp;The CHAR and VARCHAR Types"><code class="literal">VARCHAR</code></a>,
                    <a class="link" href="data-types.html#blob" title="11.4.3&nbsp;The BLOB and TEXT Types"><code class="literal">TEXT</code></a> or
                    <a class="link" href="data-types.html#blob" title="11.4.3&nbsp;The BLOB and TEXT Types"><code class="literal">BLOB</code></a> columns will fail. The
                    following definition in <code class="literal">MyISAM</code> is valid:
                </p><p style="color:blue;">创建联合表时应小心，因为可能不支持来自等效myisam或其他表的索引定义。例如，在varchar、text或blob列上创建带有索引前缀的联合表将失败。MyISAM中的以下定义有效：</p><pre data-lang="sql" class="programlisting">CREATE TABLE `T1`(`A` VARCHAR(100),UNIQUE KEY(`A`(30))) ENGINE=MYISAM;</pre><p>
                    The key prefix in this example is incompatible with the
                    <code class="literal">FEDERATED</code> engine, and the equivalent
                    statement will fail:
                </p><p style="color:blue;">此示例中的密钥前缀与联合引擎不兼容，等效语句将失败：</p><pre data-lang="sql" class="programlisting">CREATE TABLE `T1`(`A` VARCHAR(100),UNIQUE KEY(`A`(30))) ENGINE=FEDERATED
  CONNECTION='MYSQL://127.0.0.1:3306/TEST/T1';</pre><p>
                    If possible, you should try to separate the column and index
                    definition when creating tables on both the remote server and
                    the local server to avoid these index issues.
                </p><p style="color:blue;">如果可能，在远程服务器和本地服务器上创建表时，应尝试分离列和索引定义，以避免这些索引问题。</p></li><li class="listitem"><p>
                    Internally, the implementation uses
                    <a class="link" href="sql-syntax.html#select" title="13.2.9&nbsp;SELECT Syntax"><code class="literal">SELECT</code></a>,
                    <a class="link" href="sql-syntax.html#insert" title="13.2.5&nbsp;INSERT Syntax"><code class="literal">INSERT</code></a>,
                    <a class="link" href="sql-syntax.html#update" title="13.2.11&nbsp;UPDATE Syntax"><code class="literal">UPDATE</code></a>, and
                    <a class="link" href="sql-syntax.html#delete" title="13.2.2&nbsp;DELETE Syntax"><code class="literal">DELETE</code></a>, but not
                    <a class="link" href="sql-syntax.html#handler" title="13.2.4&nbsp;HANDLER Syntax"><code class="literal">HANDLER</code></a>.
                </p><p style="color:blue;">在内部，实现使用select、insert、update和delete，但不使用handler。</p></li><li class="listitem"><p>
                    The <code class="literal">FEDERATED</code> storage engine supports
                    <a class="link" href="sql-syntax.html#select" title="13.2.9&nbsp;SELECT Syntax"><code class="literal">SELECT</code></a>,
                    <a class="link" href="sql-syntax.html#insert" title="13.2.5&nbsp;INSERT Syntax"><code class="literal">INSERT</code></a>,
                    <a class="link" href="sql-syntax.html#update" title="13.2.11&nbsp;UPDATE Syntax"><code class="literal">UPDATE</code></a>,
                    <a class="link" href="sql-syntax.html#delete" title="13.2.2&nbsp;DELETE Syntax"><code class="literal">DELETE</code></a>,
                    <a class="link" href="sql-syntax.html#truncate-table" title="13.1.34&nbsp;TRUNCATE TABLE Syntax"><code class="literal">TRUNCATE TABLE</code></a>, and indexes. It
                    does not support <a class="link" href="sql-syntax.html#alter-table" title="13.1.8&nbsp;ALTER TABLE Syntax"><code class="literal">ALTER TABLE</code></a>,
                    or any Data Definition Language statements that directly
                    affect the structure of the table, other than
                    <a class="link" href="sql-syntax.html#drop-table" title="13.1.29&nbsp;DROP TABLE Syntax"><code class="literal">DROP TABLE</code></a>. The current
                    implementation does not use prepared statements.


                </p><p style="color:blue;">联合存储引擎支持选择、插入、更新、删除、截断表和索引。它不支持alter table或任何直接影响表结构的数据定义语言语句，drop table除外。当前实现不使用准备好的语句。</p></li><li class="listitem"><p>
                    <code class="literal">FEDERATED</code> accepts
                    <a class="link" href="sql-syntax.html#insert-on-duplicate" title="13.2.5.2&nbsp;INSERT ... ON DUPLICATE KEY UPDATE Syntax"><code class="literal">INSERT
                        ... ON DUPLICATE KEY UPDATE</code></a> statements, but if a
                    duplicate-key violation occurs, the statement fails with an
                    error.
                </p><p style="color:blue;">联合接受插入…对于重复的密钥更新语句，但如果发生重复密钥冲突，则该语句将失败并返回错误。</p></li><li class="listitem"><p>
                    Transactions are not supported.
                </p><p style="color:blue;">不支持事务。</p></li><li class="listitem"><p>
                    <code class="literal">FEDERATED</code> performs bulk-insert handling
                    such that multiple rows are sent to the remote table in a
                    batch, which improves performance. Also, if the remote table
                    is transactional, it enables the remote storage engine to
                    perform statement rollback properly should an error occur.
                    This capability has the following limitations:
                </p><p style="color:blue;">联邦执行大容量插入处理，以便在一个批处理中将多行发送到远程表，从而提高性能。此外，如果远程表是事务性的，则它允许远程存储引擎在发生错误时正确执行语句回滚。此功能具有以下限制：</p>
                    <div class="itemizedlist">
                        <ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
                            The size of the insert cannot exceed the maximum packet
                            size between servers. If the insert exceeds this size, it
                            is broken into multiple packets and the rollback problem
                            can occur.
                        </p><p style="color:blue;">插入的大小不能超过服务器之间的最大数据包大小。如果插入超过此大小，则会将其分为多个数据包，并可能发生回滚问题。</p></li><li class="listitem"><p>
                            Bulk-insert handling does not occur for
                            <a class="link" href="sql-syntax.html#insert-on-duplicate" title="13.2.5.2&nbsp;INSERT ... ON DUPLICATE KEY UPDATE Syntax"><code class="literal">INSERT
                                ... ON DUPLICATE KEY UPDATE</code></a>.
                        </p><p style="color:blue;">对插入不进行大容量插入处理…在重复密钥更新时。</p></li></ul>
                    </div>
                </li><li class="listitem"><p>
                    There is no way for the <code class="literal">FEDERATED</code> engine to
                    know if the remote table has changed. The reason for this is
                    that this table must work like a data file that would never be
                    written to by anything other than the database system. The
                    integrity of the data in the local table could be breached if
                    there was any change to the remote database.
                </p><p style="color:blue;">联邦引擎无法知道远程表是否已更改。原因是这个表必须像一个数据文件一样工作，除了数据库系统之外，其他任何东西都不会写入这个数据文件。如果远程数据库发生任何更改，则可能会破坏本地表中数据的完整性。</p></li><li class="listitem"><p>
                    When using a <code class="literal">CONNECTION</code> string, you cannot
                    use an '@' character in the password. You can get round this
                    limitation by using the <a class="link" href="sql-syntax.html#create-server" title="13.1.17&nbsp;CREATE SERVER Syntax"><code class="literal">CREATE
                    SERVER</code></a> statement to create a server connection.
                </p><p style="color:blue;">使用连接字符串时，不能在密码中使用“@”字符。通过使用create server语句创建服务器连接，可以绕过此限制。</p></li><li class="listitem"><p>
                    The <a class="link" href="server-administration.html#sysvar_insert_id"><code class="literal">insert_id</code></a> and
                    <a class="link" href="server-administration.html#sysvar_timestamp"><code class="literal">timestamp</code></a> options are not
                    propagated to the data provider.
                </p><p style="color:blue;">插入id和时间戳选项不会传播到数据提供程序。</p></li><li class="listitem"><p>
                    Any <a class="link" href="sql-syntax.html#drop-table" title="13.1.29&nbsp;DROP TABLE Syntax"><code class="literal">DROP TABLE</code></a> statement issued
                    against a <code class="literal">FEDERATED</code> table drops only the
                    local table, not the remote table.
                </p><p style="color:blue;">对联合表发出的任何DROP TABLE语句只删除本地表，而不删除远程表。</p></li><li class="listitem"><p>
                    <code class="literal">FEDERATED</code> tables do not work with the query
                    cache.
                </p><p style="color:blue;">联合表不能与查询缓存一起使用。</p></li><li class="listitem"><p>
                    User-defined partitioning is not supported for
                    <code class="literal">FEDERATED</code> tables.
                </p><p style="color:blue;">联合表不支持用户定义的分区。</p></li></ul>
            </div>

        </div>
        <div class="section">
            <div class="titlepage">
                <div>
                    <div>
                        <h3 class="title"><a name="federated-storage-engine-resources"></a>15.8.4&nbsp;FEDERATED Storage Engine Resources</h3>

                    </div>

                </div>

            </div>
            <p>
                The following additional resources are available for the
                <code class="literal">FEDERATED</code> storage engine:
            </p><p style="color:blue;">以下附加资源可用于联合存储引擎：</p>
            <div class="itemizedlist">
                <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                    A forum dedicated to the <code class="literal">FEDERATED</code> storage
                    engine is available at
                    <a class="ulink" href="https://forums.mysql.com/list.php?105" target="_top">https://forums.mysql.com/list.php?105</a>.
                </p><p style="color:blue;">在https://forums.mysql.com/list.php上有一个专门讨论联邦存储引擎的论坛？105。</p></li></ul>
            </div>

        </div>

    </div>
    <div class="section">
        <div class="titlepage">
            <div>
                <div>
                    <h2 class="title" style="clear: both"><a name="example-storage-engine"></a>15.9&nbsp;The EXAMPLE Storage Engine</h2>

                </div>

            </div>

        </div>
        <a class="indexterm" name="idm140286802283024"></a><a class="indexterm" name="idm140286802281984"></a><p>
        The <code class="literal">EXAMPLE</code> storage engine is a stub engine that
        does nothing. Its purpose is to serve as an example in the MySQL
        source code that illustrates how to begin writing new storage
        engines. As such, it is primarily of interest to developers.
    </p><p style="color:blue;">示例存储引擎是一个不执行任何操作的存根引擎。它的目的是作为mysql源代码中的一个示例，演示如何开始编写新的存储引擎。因此，它主要是开发商感兴趣的。</p><p>
        To enable the <code class="literal">EXAMPLE</code> storage engine if you build
        MySQL from source, invoke <span class="command"><strong>CMake</strong></span> with the
        <a class="link" href="installing.html#option_cmake_storage_engine_options" title="Storage Engine Options"><code class="option">-DWITH_EXAMPLE_STORAGE_ENGINE</code></a>
        option.
    </p><p style="color:blue;">要在从源代码构建MySQL时启用示例存储引擎，请使用-dwith-example-storage-engine选项调用cmake。</p><p>
        To examine the source for the <code class="literal">EXAMPLE</code> engine,
        look in the <code class="filename">storage/example</code> directory of a
        MySQL source distribution.
    </p><p style="color:blue;">要检查示例引擎的源代码，请查看mysql源代码发行版的storage/example目录。</p><p>
        When you create an <code class="literal">EXAMPLE</code> table, the server
        creates a table format file in the database directory. The file
        begins with the table name and has an <code class="filename">.frm</code>
        extension. No other files are created. No data can be stored into
        the table. Retrievals return an empty result.
    </p><p style="color:blue;">创建示例表时，服务器将在数据库目录中创建表格式文件。文件以表名开头，扩展名为.frm。没有创建其他文件。表中不能存储任何数据。retrievals返回空结果。</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>CREATE TABLE test (i INT) ENGINE = EXAMPLE;</code></strong>
Query OK, 0 rows affected (0.78 sec)

mysql&gt; <strong class="userinput"><code>INSERT INTO test VALUES(1),(2),(3);</code></strong>
ERROR 1031 (HY000): Table storage engine for 'test' doesn't »
                    have this option

mysql&gt; <strong class="userinput"><code>SELECT * FROM test;</code></strong>
Empty set (0.31 sec)
</pre><p>
        The <code class="literal">EXAMPLE</code> storage engine does not support
        indexing.
    </p><p style="color:blue;">示例存储引擎不支持索引。</p>
    </div>
    <div class="section">
        <div class="titlepage">
            <div>
                <div>
                    <h2 class="title" style="clear: both"><a name="storage-engines-other"></a>15.10&nbsp;Other Storage Engines</h2>

                </div>

            </div>

        </div>
        <p>
            Other storage engines may be available from third parties and
            community members that have used the Custom Storage Engine
            interface.
        </p><p style="color:blue;">其他存储引擎可以从使用自定义存储引擎接口的第三方和社区成员处获得。</p><p>
        Third party engines are not supported by MySQL. For further
        information, documentation, installation guides, bug reporting or
        for any help or assistance with these engines, please contact the
        developer of the engine directly.
    </p><p style="color:blue;">MySQL不支持第三方引擎。有关更多信息、文档、安装指南、错误报告或这些引擎的任何帮助或帮助，请直接与引擎的开发人员联系。</p><p>
        For more information on developing a customer storage engine that
        can be used with the Pluggable Storage Engine Architecture, see
        <a class="ulink" href="https://dev.mysql.com/doc/internals/en/custom-engine.html" target="_top">MySQL
            Internals: Writing a Custom Storage Engine</a>.
    </p><p style="color:blue;">有关开发可与可插入存储引擎体系结构一起使用的客户存储引擎的更多信息，请参阅mysql内部：编写自定义存储引擎。</p>
    </div>
    <div class="section">
        <div class="titlepage">
            <div>
                <div>
                    <h2 class="title" style="clear: both"><a name="pluggable-storage-overview"></a>15.11&nbsp;Overview of MySQL Storage Engine Architecture</h2>

                </div>

            </div>

        </div>
        <div class="toc">
            <dl class="toc"><dt><span class="section"><a href="storage-engines.html#pluggable-storage">15.11.1 Pluggable Storage Engine Architecture</a></span></dt><dt><span class="section"><a href="storage-engines.html#pluggable-storage-common-layer">15.11.2 The Common Database Server Layer</a></span></dt></dl>
        </div>
        <p>
            The MySQL pluggable storage engine architecture enables a database
            professional to select a specialized storage engine for a
            particular application need while being completely shielded from
            the need to manage any specific application coding requirements.
            The MySQL server architecture isolates the application programmer
            and DBA from all of the low-level implementation details at the
            storage level, providing a consistent and easy application model
            and API. Thus, although there are different capabilities across
            different storage engines, the application is shielded from these
            differences.
        </p><p style="color:blue;">mysql可插拔存储引擎体系结构使数据库专业人员能够为特定的应用程序需求选择专门的存储引擎，同时完全不必管理任何特定的应用程序编码需求。mysql服务器体系结构将应用程序程序员和dba与存储层的所有底层实现细节隔离开来，提供了一致且简单的应用程序模型和api。因此，尽管不同的存储引擎具有不同的功能，但应用程序可以避免这些差异。</p><p>
        The pluggable storage engine architecture provides a standard set
        of management and support services that are common among all
        underlying storage engines. The storage engines themselves are the
        components of the database server that actually perform actions on
        the underlying data that is maintained at the physical server
        level.
    </p><p style="color:blue;">可插入存储引擎体系结构提供了一组标准的管理和支持服务，这些服务在所有底层存储引擎中都是通用的。存储引擎本身是数据库服务器的组件，它实际对在物理服务器级别维护的底层数据执行操作。</p><p>
        This efficient and modular architecture provides huge benefits for
        those wishing to specifically target a particular application
        need—such as data warehousing, transaction processing, or
        high availability situations—while enjoying the advantage of
        utilizing a set of interfaces and services that are independent of
        any one storage engine.
    </p><p style="color:blue;">这种高效且模块化的体系结构为那些希望专门针对特定应用程序需求（如数据仓库、事务处理或高可用性情况）的用户提供了巨大的好处，同时还可以利用一组独立于任何一个存储引擎的接口和服务。</p><p>
        The application programmer and DBA interact with the MySQL
        database through Connector APIs and service layers that are above
        the storage engines. If application changes bring about
        requirements that demand the underlying storage engine change, or
        that one or more storage engines be added to support new needs, no
        significant coding or process changes are required to make things
        work. The MySQL server architecture shields the application from
        the underlying complexity of the storage engine by presenting a
        consistent and easy-to-use API that applies across storage
        engines.
    </p><p style="color:blue;">应用程序程序员和dba通过存储引擎之上的连接器api和服务层与mysql数据库交互。如果应用程序更改带来要求底层存储引擎更改的需求，或者需要添加一个或多个存储引擎以支持新的需求，则无需进行重大的编码或过程更改即可使工作正常进行。MySQL服务器体系结构通过应用跨存储引擎的一致和易于使用的API来屏蔽应用程序与存储引擎的底层复杂性。</p>
        <div class="section">

            <div class="titlepage">
                <div>
                    <div>
                        <h3 class="title"><a name="pluggable-storage"></a>15.11.1&nbsp;Pluggable Storage Engine Architecture</h3>
                    </div>
                </div>
            </div>
            <p>
                MySQL Server uses a pluggable storage engine architecture that
                enables storage engines to be loaded into and unloaded from a
                running MySQL server.
            </p><p style="color:blue;">mysql服务器使用可插入的存储引擎体系结构，使存储引擎能够加载到正在运行的mysql服务器中并从中卸载。</p><p>
            <span class="bold"><strong>Plugging in a Storage Engine</strong></span>
        </p><p style="color:blue;">插入存储引擎</p><p>
            Before a storage engine can be used, the storage engine plugin
            shared library must be loaded into MySQL using the
            <a class="link" href="sql-syntax.html#install-plugin" title="13.7.3.3&nbsp;INSTALL PLUGIN Syntax"><code class="literal">INSTALL PLUGIN</code></a> statement. For
            example, if the <code class="literal">EXAMPLE</code> engine plugin is
            named <code class="literal">example</code> and the shared library is named
            <code class="filename">ha_example.so</code>, you load it with the
            following statement:
        </p><p style="color:blue;">在使用存储引擎之前，必须使用install plugin语句将存储引擎插件共享库加载到mysql中。例如，如果示例引擎插件命名为example，而共享库命名为ha_example.so，则使用以下语句加载它：</p><pre data-lang="sql" class="programlisting">INSTALL PLUGIN example SONAME 'ha_example.so';
</pre><p>
            To install a pluggable storage engine, the plugin file must be
            located in the MySQL plugin directory, and the user issuing the
            <a class="link" href="sql-syntax.html#install-plugin" title="13.7.3.3&nbsp;INSTALL PLUGIN Syntax"><code class="literal">INSTALL PLUGIN</code></a> statement must
            have <a class="link" href="security.html#priv_insert"><code class="literal">INSERT</code></a> privilege for the
            <code class="literal">mysql.plugin</code> table.
        </p><p style="color:blue;">要安装可插入存储引擎，插件文件必须位于mysql plugin目录中，发出install plugin语句的用户必须具有mysql.plugin表的insert权限。</p><p>
            The shared library must be located in the MySQL server plugin
            directory, the location of which is given by the
            <a class="link" href="server-administration.html#sysvar_plugin_dir"><code class="literal">plugin_dir</code></a> system variable.
        </p><p style="color:blue;">共享库必须位于mysql server plugin目录中，其位置由plugin dir系统变量指定。</p><p>
            <span class="bold"><strong>Unplugging a Storage Engine</strong></span>
        </p><p style="color:blue;">拔下存储引擎的插头</p><p>
            To unplug a storage engine, use the
            <a class="link" href="sql-syntax.html#uninstall-plugin" title="13.7.3.4&nbsp;UNINSTALL PLUGIN Syntax"><code class="literal">UNINSTALL PLUGIN</code></a> statement:
        </p><p style="color:blue;">要拔出存储引擎，请使用uninstall plugin语句：</p><pre data-lang="sql" class="programlisting">UNINSTALL PLUGIN example;
</pre><p>
            If you unplug a storage engine that is needed by existing
            tables, those tables become inaccessible, but will still be
            present on disk (where applicable). Ensure that there are no
            tables using a storage engine before you unplug the storage
            engine.
        </p><p style="color:blue;">如果拔出现有表所需的存储引擎，这些表变得不可访问，但仍将存在于磁盘上（适用时）。在拔下存储引擎之前，请确保没有使用存储引擎的表。</p>
        </div>
        <div class="section">
            <div class="titlepage">
                <div>
                    <div>
                        <h3 class="title"><a name="pluggable-storage-common-layer"></a>15.11.2&nbsp;The Common Database Server Layer</h3>

                    </div>

                </div>

            </div>
            <p>
                A MySQL pluggable storage engine is the component in the MySQL
                database server that is responsible for performing the actual
                data I/O operations for a database as well as enabling and
                enforcing certain feature sets that target a specific
                application need. A major benefit of using specific storage
                engines is that you are only delivered the features needed for a
                particular application, and therefore you have less system
                overhead in the database, with the end result being more
                efficient and higher database performance. This is one of the
                reasons that MySQL has always been known to have such high
                performance, matching or beating proprietary monolithic
                databases in industry standard benchmarks.
            </p><p style="color:blue;">mysql可插入存储引擎是mysql数据库服务器中的组件，负责执行数据库的实际数据i/o操作，以及启用和实施针对特定应用程序需要的特定功能集。使用特定存储引擎的一个主要好处是，您只能获得特定应用程序所需的功能，因此您在数据库中的系统开销较少，最终的结果是更高效和更高的数据库性能。这也是mysql在行业标准基准测试中一直拥有如此高性能、匹配或优于专有单片数据库的原因之一。</p><p>
            From a technical perspective, what are some of the unique
            supporting infrastructure components that are in a storage
            engine? Some of the key feature differentiations include:
        </p><p style="color:blue;">从技术角度来看，存储引擎中有哪些独特的支持基础架构组件？一些关键的功能差异包括：</p>
            <div class="itemizedlist">
                <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                    <span class="emphasis"><em>Concurrency</em></span>: Some applications have
                    more granular lock requirements (such as row-level locks)
                    than others. Choosing the right locking strategy can reduce
                    overhead and therefore improve overall performance. This
                    area also includes support for capabilities such as
                    multi-version concurrency control or <span class="quote">“<span class="quote">snapshot</span>”</span>
                    read.
                </p><p style="color:blue;">并发性：一些应用程序比其他应用程序有更细粒度的锁需求（如行级锁）。选择正确的锁定策略可以减少开销，从而提高整体性能。此区域还包括对多版本并发控制或“快照”读取等功能的支持。</p></li><li class="listitem"><p>
                    <span class="emphasis"><em>Transaction Support</em></span>: Not every
                    application needs transactions, but for those that do, there
                    are very well defined requirements such as ACID compliance
                    and more.
                </p><p style="color:blue;">事务支持：并非每个应用程序都需要事务，但对于那些需要事务的应用程序，有非常明确的需求，如acid遵从性等。</p></li><li class="listitem"><p>
                    <span class="emphasis"><em>Referential Integrity</em></span>: The need to have
                    the server enforce relational database referential integrity
                    through DDL defined foreign keys.
                </p><p style="color:blue;">引用完整性：需要让服务器通过ddl定义的外键强制关系数据库引用完整性。</p></li><li class="listitem"><p>
                    <span class="emphasis"><em>Physical Storage</em></span>: This involves
                    everything from the overall page size for tables and indexes
                    as well as the format used for storing data to physical
                    disk.
                </p><p style="color:blue;">物理存储：这包括从表和索引的总页面大小，以及用于存储数据到物理磁盘的格式等所有内容。</p></li><li class="listitem"><p>
                    <span class="emphasis"><em>Index Support</em></span>: Different application
                    scenarios tend to benefit from different index strategies.
                    Each storage engine generally has its own indexing methods,
                    although some (such as B-tree indexes) are common to nearly
                    all engines.
                </p><p style="color:blue;">索引支持：不同的应用场景往往受益于不同的索引策略。每个存储引擎通常都有自己的索引方法，尽管一些（例如B-树索引）对于几乎所有的引擎都是通用的。</p></li><li class="listitem"><p>
                    <span class="emphasis"><em>Memory Caches</em></span>: Different applications
                    respond better to some memory caching strategies than
                    others, so although some memory caches are common to all
                    storage engines (such as those used for user connections or
                    MySQL's high-speed Query Cache), others are uniquely defined
                    only when a particular storage engine is put in play.
                </p><p style="color:blue;">内存缓存：不同的应用程序比其他应用程序对某些内存缓存策略的响应更好，因此尽管某些内存缓存对所有存储引擎都是通用的（例如用于用户连接或MySQL的高速查询缓存），但其他内存缓存只有在某个特定的存储引擎投入使用时才被唯一定义。</p></li><li class="listitem"><p>
                    <span class="emphasis"><em>Performance Aids</em></span>: This includes
                    multiple I/O threads for parallel operations, thread
                    concurrency, database checkpointing, bulk insert handling,
                    and more.
                </p><p style="color:blue;">性能帮助：这包括用于并行操作、线程并发、数据库检查点、大容量插入处理等的多个I/O线程。</p></li><li class="listitem"><p>
                    <span class="emphasis"><em>Miscellaneous Target Features</em></span>: This may
                    include support for geospatial operations, security
                    restrictions for certain data manipulation operations, and
                    other similar features.
                </p><p style="color:blue;">其他目标功能：这可能包括对地理空间操作的支持、对某些数据操作的安全限制以及其他类似功能。</p></li></ul>
            </div>
            <p>
                Each set of the pluggable storage engine infrastructure
                components are designed to offer a selective set of benefits for
                a particular application. Conversely, avoiding a set of
                component features helps reduce unnecessary overhead. It stands
                to reason that understanding a particular application's set of
                requirements and selecting the proper MySQL storage engine can
                have a dramatic impact on overall system efficiency and
                performance.
            </p><p style="color:blue;">每一组可插入存储引擎基础结构组件都是为特定应用程序提供一组选择性的好处而设计的。相反，避免一组组件特性有助于减少不必要的开销。理解特定应用程序的一组需求并选择适当的mysql存储引擎可能会对整个系统的效率和性能产生巨大的影响，这是有道理的。</p>
        </div>

    </div>

</div>
<div class="copyright-footer">

</div>
<div class="navfooter">
    <hr>
    <table width="100%" summary="Navigation footer">
        <tbody><tr>
            <td width="40%" align="left"><a accesskey="p" href="innodb-storage-engine.html">Prev</a></td>
            <td width="20%" align="center"><a accesskey="u" href="">Up</a></td>
            <td width="40%" align="right">&nbsp;<a accesskey="n" href="replication.html">Next</a></td>
        </tr>
        <tr>
            <td width="40%" align="left" valign="top">Chapter&nbsp;14 The InnoDB Storage Engine</td>
            <td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td>
            <td width="40%" align="right" valign="top">Chapter&nbsp;16 Replication</td>
        </tr>
        </tbody></table>
</div>


</body></html>