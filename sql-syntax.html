<html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
    <title>Chapter&nbsp;13 SQL Statement Syntax</title>
    <link rel="stylesheet" href="mvl.css" type="text/css">
    <meta name="generator" content="DocBook XSL Stylesheets + chunker.py v1.9.2">
    <link rel="start" href="index.html" title="{book-title}">
    <link rel="up" href="" title="">
    <link rel="prev" href="functions.html" title="Chapter&nbsp;12 Functions and Operators">
    <link rel="next" href="innodb-storage-engine.html" title="Chapter&nbsp;14 The InnoDB Storage Engine">
    <script src="https://code.jquery.com/jquery-3.3.1.min.js"></script><script src="https://code.jquery.com/jquery-3.3.1.min.js"></script><script src="https://code.jquery.com/jquery-3.3.1.min.js"></script><script src="https://code.jquery.com/jquery-3.3.1.min.js"></script></head>
<body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF">
<div class="navheader">
    <table width="100%" summary="Navigation header">
        <tbody><tr>
            <th colspan="3" align="center">Chapter&nbsp;13 SQL Statement Syntax</th>
        </tr>
        <tr>
            <td width="20%" align="left"><a accesskey="p" href="functions.html">Prev</a>&nbsp;</td>
            <th width="60%" align="center"></th>
            <td width="20%" align="right">&nbsp;<a accesskey="n" href="innodb-storage-engine.html">Next</a></td>
        </tr>
        </tbody></table>
    <hr>
</div>
<div class="chapter">
    <div class="titlepage">
        <div>
            <div>
                <h1 class="title"><a name="sql-syntax"></a>Chapter&nbsp;13&nbsp;SQL Statement Syntax</h1>

            </div>

        </div>

    </div>
    <div class="toc">
        <p><b>Table of Contents</b></p><p style="color:blue;">目录</p><dl class="toc"><dt><span class="section"><a href="sql-syntax.html#sql-syntax-data-definition">13.1 Data Definition Statements</a></span></dt><dd><dl><dt><span class="section"><a href="sql-syntax.html#alter-database">13.1.1 ALTER DATABASE Syntax</a></span></dt><dt><span class="section"><a href="sql-syntax.html#alter-event">13.1.2 ALTER EVENT Syntax</a></span></dt><dt><span class="section"><a href="sql-syntax.html#alter-function">13.1.3 ALTER FUNCTION Syntax</a></span></dt><dt><span class="section"><a href="sql-syntax.html#alter-instance">13.1.4 ALTER INSTANCE Syntax</a></span></dt><dt><span class="section"><a href="sql-syntax.html#alter-logfile-group">13.1.5 ALTER LOGFILE GROUP Syntax</a></span></dt><dt><span class="section"><a href="sql-syntax.html#alter-procedure">13.1.6 ALTER PROCEDURE Syntax</a></span></dt><dt><span class="section"><a href="sql-syntax.html#alter-server">13.1.7 ALTER SERVER Syntax</a></span></dt><dt><span class="section"><a href="sql-syntax.html#alter-table">13.1.8 ALTER TABLE Syntax</a></span></dt><dt><span class="section"><a href="sql-syntax.html#alter-tablespace">13.1.9 ALTER TABLESPACE Syntax</a></span></dt><dt><span class="section"><a href="sql-syntax.html#alter-view">13.1.10 ALTER VIEW Syntax</a></span></dt><dt><span class="section"><a href="sql-syntax.html#create-database">13.1.11 CREATE DATABASE Syntax</a></span></dt><dt><span class="section"><a href="sql-syntax.html#create-event">13.1.12 CREATE EVENT Syntax</a></span></dt><dt><span class="section"><a href="sql-syntax.html#create-function">13.1.13 CREATE FUNCTION Syntax</a></span></dt><dt><span class="section"><a href="sql-syntax.html#create-index">13.1.14 CREATE INDEX Syntax</a></span></dt><dt><span class="section"><a href="sql-syntax.html#create-logfile-group">13.1.15 CREATE LOGFILE GROUP Syntax</a></span></dt><dt><span class="section"><a href="sql-syntax.html#create-procedure">13.1.16 CREATE PROCEDURE and CREATE FUNCTION Syntax</a></span></dt><dt><span class="section"><a href="sql-syntax.html#create-server">13.1.17 CREATE SERVER Syntax</a></span></dt><dt><span class="section"><a href="sql-syntax.html#create-table">13.1.18 CREATE TABLE Syntax</a></span></dt><dt><span class="section"><a href="sql-syntax.html#create-tablespace">13.1.19 CREATE TABLESPACE Syntax</a></span></dt><dt><span class="section"><a href="sql-syntax.html#create-trigger">13.1.20 CREATE TRIGGER Syntax</a></span></dt><dt><span class="section"><a href="sql-syntax.html#create-view">13.1.21 CREATE VIEW Syntax</a></span></dt><dt><span class="section"><a href="sql-syntax.html#drop-database">13.1.22 DROP DATABASE Syntax</a></span></dt><dt><span class="section"><a href="sql-syntax.html#drop-event">13.1.23 DROP EVENT Syntax</a></span></dt><dt><span class="section"><a href="sql-syntax.html#drop-function">13.1.24 DROP FUNCTION Syntax</a></span></dt><dt><span class="section"><a href="sql-syntax.html#drop-index">13.1.25 DROP INDEX Syntax</a></span></dt><dt><span class="section"><a href="sql-syntax.html#drop-logfile-group">13.1.26 DROP LOGFILE GROUP Syntax</a></span></dt><dt><span class="section"><a href="sql-syntax.html#drop-procedure">13.1.27 DROP PROCEDURE and DROP FUNCTION Syntax</a></span></dt><dt><span class="section"><a href="sql-syntax.html#drop-server">13.1.28 DROP SERVER Syntax</a></span></dt><dt><span class="section"><a href="sql-syntax.html#drop-table">13.1.29 DROP TABLE Syntax</a></span></dt><dt><span class="section"><a href="sql-syntax.html#drop-tablespace">13.1.30 DROP TABLESPACE Syntax</a></span></dt><dt><span class="section"><a href="sql-syntax.html#drop-trigger">13.1.31 DROP TRIGGER Syntax</a></span></dt><dt><span class="section"><a href="sql-syntax.html#drop-view">13.1.32 DROP VIEW Syntax</a></span></dt><dt><span class="section"><a href="sql-syntax.html#rename-table">13.1.33 RENAME TABLE Syntax</a></span></dt><dt><span class="section"><a href="sql-syntax.html#truncate-table">13.1.34 TRUNCATE TABLE Syntax</a></span></dt></dl></dd><dt><span class="section"><a href="sql-syntax.html#sql-syntax-data-manipulation">13.2 Data Manipulation Statements</a></span></dt><dd><dl><dt><span class="section"><a href="sql-syntax.html#call">13.2.1 CALL Syntax</a></span></dt><dt><span class="section"><a href="sql-syntax.html#delete">13.2.2 DELETE Syntax</a></span></dt><dt><span class="section"><a href="sql-syntax.html#do">13.2.3 DO Syntax</a></span></dt><dt><span class="section"><a href="sql-syntax.html#handler">13.2.4 HANDLER Syntax</a></span></dt><dt><span class="section"><a href="sql-syntax.html#insert">13.2.5 INSERT Syntax</a></span></dt><dt><span class="section"><a href="sql-syntax.html#load-data">13.2.6 LOAD DATA Syntax</a></span></dt><dt><span class="section"><a href="sql-syntax.html#load-xml">13.2.7 LOAD XML Syntax</a></span></dt><dt><span class="section"><a href="sql-syntax.html#replace">13.2.8 REPLACE Syntax</a></span></dt><dt><span class="section"><a href="sql-syntax.html#select">13.2.9 SELECT Syntax</a></span></dt><dt><span class="section"><a href="sql-syntax.html#subqueries">13.2.10 Subquery Syntax</a></span></dt><dt><span class="section"><a href="sql-syntax.html#update">13.2.11 UPDATE Syntax</a></span></dt></dl></dd><dt><span class="section"><a href="sql-syntax.html#sql-syntax-transactions">13.3 Transactional and Locking Statements</a></span></dt><dd><dl><dt><span class="section"><a href="sql-syntax.html#commit">13.3.1 START TRANSACTION, COMMIT, and ROLLBACK Syntax</a></span></dt><dt><span class="section"><a href="sql-syntax.html#cannot-roll-back">13.3.2 Statements That Cannot Be Rolled Back</a></span></dt><dt><span class="section"><a href="sql-syntax.html#implicit-commit">13.3.3 Statements That Cause an Implicit Commit</a></span></dt><dt><span class="section"><a href="sql-syntax.html#savepoint">13.3.4 SAVEPOINT, ROLLBACK TO SAVEPOINT, and RELEASE SAVEPOINT Syntax</a></span></dt><dt><span class="section"><a href="sql-syntax.html#lock-tables">13.3.5 LOCK TABLES and UNLOCK TABLES Syntax</a></span></dt><dt><span class="section"><a href="sql-syntax.html#set-transaction">13.3.6 SET TRANSACTION Syntax</a></span></dt><dt><span class="section"><a href="sql-syntax.html#xa">13.3.7 XA Transactions</a></span></dt></dl></dd><dt><span class="section"><a href="sql-syntax.html#sql-syntax-replication">13.4 Replication Statements</a></span></dt><dd><dl><dt><span class="section"><a href="sql-syntax.html#replication-master-sql">13.4.1 SQL Statements for Controlling Master Servers</a></span></dt><dt><span class="section"><a href="sql-syntax.html#replication-slave-sql">13.4.2 SQL Statements for Controlling Slave Servers</a></span></dt><dt><span class="section"><a href="sql-syntax.html#replication-group-sql">13.4.3 SQL Statements for Controlling Group Replication</a></span></dt></dl></dd><dt><span class="section"><a href="sql-syntax.html#sql-syntax-prepared-statements">13.5 Prepared SQL Statement Syntax</a></span></dt><dd><dl><dt><span class="section"><a href="sql-syntax.html#prepare">13.5.1 PREPARE Syntax</a></span></dt><dt><span class="section"><a href="sql-syntax.html#execute">13.5.2 EXECUTE Syntax</a></span></dt><dt><span class="section"><a href="sql-syntax.html#deallocate-prepare">13.5.3 DEALLOCATE PREPARE Syntax</a></span></dt></dl></dd><dt><span class="section"><a href="sql-syntax.html#sql-syntax-compound-statements">13.6 Compound-Statement Syntax</a></span></dt><dd><dl><dt><span class="section"><a href="sql-syntax.html#begin-end">13.6.1 BEGIN ... END Compound-Statement Syntax</a></span></dt><dt><span class="section"><a href="sql-syntax.html#statement-labels">13.6.2 Statement Label Syntax</a></span></dt><dt><span class="section"><a href="sql-syntax.html#declare">13.6.3 DECLARE Syntax</a></span></dt><dt><span class="section"><a href="sql-syntax.html#stored-program-variables">13.6.4 Variables in Stored Programs</a></span></dt><dt><span class="section"><a href="sql-syntax.html#flow-control-statements">13.6.5 Flow Control Statements</a></span></dt><dt><span class="section"><a href="sql-syntax.html#cursors">13.6.6 Cursors</a></span></dt><dt><span class="section"><a href="sql-syntax.html#condition-handling">13.6.7 Condition Handling</a></span></dt></dl></dd><dt><span class="section"><a href="sql-syntax.html#sql-syntax-server-administration">13.7 Database Administration Statements</a></span></dt><dd><dl><dt><span class="section"><a href="sql-syntax.html#account-management-sql">13.7.1 Account Management Statements</a></span></dt><dt><span class="section"><a href="sql-syntax.html#table-maintenance-sql">13.7.2 Table Maintenance Statements</a></span></dt><dt><span class="section"><a href="sql-syntax.html#component-sql">13.7.3 Plugin and User-Defined Function Statements</a></span></dt><dt><span class="section"><a href="sql-syntax.html#set-statement">13.7.4 SET Syntax</a></span></dt><dt><span class="section"><a href="sql-syntax.html#show">13.7.5 SHOW Syntax</a></span></dt><dt><span class="section"><a href="sql-syntax.html#other-administrative-sql">13.7.6 Other Administrative Statements</a></span></dt></dl></dd><dt><span class="section"><a href="sql-syntax.html#sql-syntax-utility">13.8 Utility Statements</a></span></dt><dd><dl><dt><span class="section"><a href="sql-syntax.html#describe">13.8.1 DESCRIBE Syntax</a></span></dt><dt><span class="section"><a href="sql-syntax.html#explain">13.8.2 EXPLAIN Syntax</a></span></dt><dt><span class="section"><a href="sql-syntax.html#help">13.8.3 HELP Syntax</a></span></dt><dt><span class="section"><a href="sql-syntax.html#use">13.8.4 USE Syntax</a></span></dt></dl></dd></dl>
    </div>
    <p>
        This chapter describes the syntax for the
        <a class="link" href="glossary.html#glos_sql" title="SQL">SQL</a> statements supported by MySQL.
    </p><p style="color:blue;">本章介绍mysql支持的sql语句的语法。</p>
    <div class="section">

        <div class="titlepage">
            <div>
                <div>
                    <h2 class="title" style="clear: both"><a name="sql-syntax-data-definition"></a>13.1&nbsp;Data Definition Statements</h2>

                </div>

            </div>

        </div>

        <div class="toc">
            <dl class="toc"><dt><span class="section"><a href="sql-syntax.html#alter-database">13.1.1 ALTER DATABASE Syntax</a></span></dt><dt><span class="section"><a href="sql-syntax.html#alter-event">13.1.2 ALTER EVENT Syntax</a></span></dt><dt><span class="section"><a href="sql-syntax.html#alter-function">13.1.3 ALTER FUNCTION Syntax</a></span></dt><dt><span class="section"><a href="sql-syntax.html#alter-instance">13.1.4 ALTER INSTANCE Syntax</a></span></dt><dt><span class="section"><a href="sql-syntax.html#alter-logfile-group">13.1.5 ALTER LOGFILE GROUP Syntax</a></span></dt><dt><span class="section"><a href="sql-syntax.html#alter-procedure">13.1.6 ALTER PROCEDURE Syntax</a></span></dt><dt><span class="section"><a href="sql-syntax.html#alter-server">13.1.7 ALTER SERVER Syntax</a></span></dt><dt><span class="section"><a href="sql-syntax.html#alter-table">13.1.8 ALTER TABLE Syntax</a></span></dt><dt><span class="section"><a href="sql-syntax.html#alter-tablespace">13.1.9 ALTER TABLESPACE Syntax</a></span></dt><dt><span class="section"><a href="sql-syntax.html#alter-view">13.1.10 ALTER VIEW Syntax</a></span></dt><dt><span class="section"><a href="sql-syntax.html#create-database">13.1.11 CREATE DATABASE Syntax</a></span></dt><dt><span class="section"><a href="sql-syntax.html#create-event">13.1.12 CREATE EVENT Syntax</a></span></dt><dt><span class="section"><a href="sql-syntax.html#create-function">13.1.13 CREATE FUNCTION Syntax</a></span></dt><dt><span class="section"><a href="sql-syntax.html#create-index">13.1.14 CREATE INDEX Syntax</a></span></dt><dt><span class="section"><a href="sql-syntax.html#create-logfile-group">13.1.15 CREATE LOGFILE GROUP Syntax</a></span></dt><dt><span class="section"><a href="sql-syntax.html#create-procedure">13.1.16 CREATE PROCEDURE and CREATE FUNCTION Syntax</a></span></dt><dt><span class="section"><a href="sql-syntax.html#create-server">13.1.17 CREATE SERVER Syntax</a></span></dt><dt><span class="section"><a href="sql-syntax.html#create-table">13.1.18 CREATE TABLE Syntax</a></span></dt><dt><span class="section"><a href="sql-syntax.html#create-tablespace">13.1.19 CREATE TABLESPACE Syntax</a></span></dt><dt><span class="section"><a href="sql-syntax.html#create-trigger">13.1.20 CREATE TRIGGER Syntax</a></span></dt><dt><span class="section"><a href="sql-syntax.html#create-view">13.1.21 CREATE VIEW Syntax</a></span></dt><dt><span class="section"><a href="sql-syntax.html#drop-database">13.1.22 DROP DATABASE Syntax</a></span></dt><dt><span class="section"><a href="sql-syntax.html#drop-event">13.1.23 DROP EVENT Syntax</a></span></dt><dt><span class="section"><a href="sql-syntax.html#drop-function">13.1.24 DROP FUNCTION Syntax</a></span></dt><dt><span class="section"><a href="sql-syntax.html#drop-index">13.1.25 DROP INDEX Syntax</a></span></dt><dt><span class="section"><a href="sql-syntax.html#drop-logfile-group">13.1.26 DROP LOGFILE GROUP Syntax</a></span></dt><dt><span class="section"><a href="sql-syntax.html#drop-procedure">13.1.27 DROP PROCEDURE and DROP FUNCTION Syntax</a></span></dt><dt><span class="section"><a href="sql-syntax.html#drop-server">13.1.28 DROP SERVER Syntax</a></span></dt><dt><span class="section"><a href="sql-syntax.html#drop-table">13.1.29 DROP TABLE Syntax</a></span></dt><dt><span class="section"><a href="sql-syntax.html#drop-tablespace">13.1.30 DROP TABLESPACE Syntax</a></span></dt><dt><span class="section"><a href="sql-syntax.html#drop-trigger">13.1.31 DROP TRIGGER Syntax</a></span></dt><dt><span class="section"><a href="sql-syntax.html#drop-view">13.1.32 DROP VIEW Syntax</a></span></dt><dt><span class="section"><a href="sql-syntax.html#rename-table">13.1.33 RENAME TABLE Syntax</a></span></dt><dt><span class="section"><a href="sql-syntax.html#truncate-table">13.1.34 TRUNCATE TABLE Syntax</a></span></dt></dl>
        </div>
        <a class="indexterm" name="idm140286841829504"></a>
        <div class="section">

            <div class="titlepage">
                <div>
                    <div>
                        <h3 class="title"><a name="alter-database"></a>13.1.1&nbsp;ALTER DATABASE Syntax</h3>

                    </div>

                </div>

            </div>
            <a class="indexterm" name="idm140286841827312"></a><a class="indexterm" name="idm140286841826240"></a><a class="indexterm" name="idm140286841825168"></a><a class="indexterm" name="idm140286841823680"></a><a class="indexterm" name="idm140286841822192"></a><a class="indexterm" name="idm140286841820704"></a><pre data-lang="sql" class="programlisting">ALTER {DATABASE | SCHEMA} [<em class="replaceable"><code>db_name</code></em>]
    <em class="replaceable"><code>alter_specification</code></em> ...
ALTER {DATABASE | SCHEMA} <em class="replaceable"><code>db_name</code></em>
    UPGRADE DATA DIRECTORY NAME

<em class="replaceable"><code>alter_specification</code></em>:
    [DEFAULT] CHARACTER SET [=] <em class="replaceable"><code>charset_name</code></em>
  | [DEFAULT] COLLATE [=] <em class="replaceable"><code>collation_name</code></em>
</pre><p>
            <a class="link" href="sql-syntax.html#alter-database" title="13.1.1&nbsp;ALTER DATABASE Syntax"><code class="literal">ALTER DATABASE</code></a> enables you to
            change the overall characteristics of a database. These
            characteristics are stored in the <code class="filename">db.opt</code> file
            in the database directory. To use <a class="link" href="sql-syntax.html#alter-database" title="13.1.1&nbsp;ALTER DATABASE Syntax"><code class="literal">ALTER
            DATABASE</code></a>, you need the
            <a class="link" href="security.html#priv_alter"><code class="literal">ALTER</code></a> privilege on the database.
            <a class="link" href="sql-syntax.html#alter-database" title="13.1.1&nbsp;ALTER DATABASE Syntax"><code class="literal">ALTER
                SCHEMA</code></a> is a synonym for <a class="link" href="sql-syntax.html#alter-database" title="13.1.1&nbsp;ALTER DATABASE Syntax"><code class="literal">ALTER
            DATABASE</code></a>.
        </p><p style="color:blue;">alter database允许您更改数据库的总体特性。这些特性存储在数据库目录中的db.opt文件中。要使用alter database，您需要数据库的alter特权。alter schema是alter database的同义词。</p><p>
            The database name can be omitted from the first syntax, in which
            case the statement applies to the default database.
        </p><p style="color:blue;">可以从第一个语法中省略数据库名称，在这种情况下，语句将应用于默认数据库。</p>
            <h4><a name="idm140286841804192"></a>National Language Characteristics</h4>
            <p>
                The <code class="literal">CHARACTER SET</code> clause changes the default
                database character set. The <code class="literal">COLLATE</code> clause
                changes the default database collation. <a class="xref" href="charset.html" title="Chapter&nbsp;10&nbsp;Character Sets, Collations, Unicode">Chapter&nbsp;10, <i>Character Sets, Collations, Unicode</i></a>,
                discusses character set and collation names.
            </p><p style="color:blue;">character set子句更改默认数据库字符集。collate子句更改默认的数据库排序规则。第10章，字符集，排序规则，Unicode，讨论字符集和排序规则名称。</p><p>
            You can see what character sets and collations are available
            using, respectively, the <a class="link" href="sql-syntax.html#show-character-set" title="13.7.5.3&nbsp;SHOW CHARACTER SET Syntax"><code class="literal">SHOW CHARACTER
            SET</code></a> and <a class="link" href="sql-syntax.html#show-collation" title="13.7.5.4&nbsp;SHOW COLLATION Syntax"><code class="literal">SHOW COLLATION</code></a>
            statements. See <a class="xref" href="sql-syntax.html#show-character-set" title="13.7.5.3&nbsp;SHOW CHARACTER SET Syntax">Section&nbsp;13.7.5.3, “SHOW CHARACTER SET Syntax”</a>, and
            <a class="xref" href="sql-syntax.html#show-collation" title="13.7.5.4&nbsp;SHOW COLLATION Syntax">Section&nbsp;13.7.5.4, “SHOW COLLATION Syntax”</a>, for more information.
        </p><p style="color:blue;">您可以分别使用show character set和show collation语句查看哪些字符集和排序规则可用。有关详细信息，请参阅第13.7.5.3节“显示字符集语法”和第13.7.5.4节“显示排序规则语法”。</p><p>
            If you change the default character set or collation for a
            database, stored routines that use the database defaults must be
            dropped and recreated so that they use the new defaults. (In a
            stored routine, variables with character data types use the
            database defaults if the character set or collation are not
            specified explicitly. See <a class="xref" href="sql-syntax.html#create-procedure" title="13.1.16&nbsp;CREATE PROCEDURE and CREATE FUNCTION Syntax">Section&nbsp;13.1.16, “CREATE PROCEDURE and CREATE FUNCTION Syntax”</a>.)
        </p><p style="color:blue;">如果更改数据库的默认字符集或排序规则，则必须删除并重新创建使用数据库默认值的存储例程，以便它们使用新的默认值。（在存储例程中，如果未显式指定字符集或排序规则，则具有字符数据类型的变量将使用数据库默认值。见第13.1.16节，“创建过程和创建函数语法”。</p>
            <h4><a name="idm140286841795040"></a>Upgrading from Versions Older than MySQL 5.1</h4>
            <p>
                The syntax that includes the <code class="literal">UPGRADE DATA DIRECTORY
                NAME</code> clause updates the name of the directory associated
                with the database to use the encoding implemented in MySQL 5.1 for
                mapping database names to database directory names (see
                <a class="xref" href="language-structure.html#identifier-mapping" title="9.2.4&nbsp;Mapping of Identifiers to File Names">Section&nbsp;9.2.4, “Mapping of Identifiers to File Names”</a>). This clause is for use
                under these conditions:
            </p><p style="color:blue;">包含upgrade data directory name子句的语法将更新与数据库关联的目录的名称，以使用mysql 5.1中实现的编码将数据库名称映射到数据库目录名称（请参见9.2.4节“标识符到文件名的映射”）。本条款适用于以下情况：</p>
            <div class="itemizedlist">
                <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                    It is intended when upgrading MySQL to 5.1 or later from older
                    versions.
                </p><p style="color:blue;">它是在将MySQL从旧版本升级到5.1或更高版本时使用的。</p></li><li class="listitem"><p>
                    It is intended to update a database directory name to the
                    current encoding format if the name contains special
                    characters that need encoding.
                </p><p style="color:blue;">如果数据库目录名包含需要编码的特殊字符，则将其更新为当前编码格式。</p></li><li class="listitem"><p>
                    The statement is used by <a class="link" href="programs.html#mysqlcheck" title="4.5.3&nbsp;mysqlcheck — A Table Maintenance Program"><span class="command"><strong>mysqlcheck</strong></span></a> (as
                    invoked by <a class="link" href="programs.html#mysql-upgrade" title="4.4.7&nbsp;mysql_upgrade — Check and Upgrade MySQL Tables"><span class="command"><strong>mysql_upgrade</strong></span></a>).
                </p><p style="color:blue;">mysqlcheck使用该语句（mysql_upgrade调用）。</p></li></ul>
            </div>
            <p>
                For example, if a database in MySQL 5.0 has the name
                <code class="literal">a-b-c</code>, the name contains instances of the
                <code class="literal">-</code> (dash) character. In MySQL 5.0, the database
                directory is also named <code class="literal">a-b-c</code>, which is not
                necessarily safe for all file systems. In MySQL 5.1 and later, the
                same database name is encoded as <code class="literal">a@002db@002dc</code>
                to produce a file system-neutral directory name.
            </p><p style="color:blue;">例如，如果mysql 5.0中的数据库名为a-b-c，则该名称包含-（破折号）字符的实例。在mysql 5.0中，数据库目录也被命名为a-b-c，这对于所有的文件系统来说并不一定是安全的。在mysql 5.1及更高版本中，相同的数据库名被编码为@002db@002dc，以生成与文件系统无关的目录名。</p><p>
            When a MySQL installation is upgraded to MySQL 5.1 or later from
            an older version,the server displays a name such as
            <code class="literal">a-b-c</code> (which is in the old format) as
            <code class="literal">#mysql50#a-b-c</code>, and you must refer to the name
            using the <code class="literal">#mysql50#</code> prefix. Use
            <code class="literal">UPGRADE DATA DIRECTORY NAME</code> in this case to
            explicitly tell the server to re-encode the database directory
            name to the current encoding format:
        </p><p style="color:blue;">当mysql安装从旧版本升级到mysql 5.1或更高版本时，服务器会将a-b-c（旧格式）等名称显示为mysql50-a-b-c，并且必须使用mysql50前缀引用该名称。在这种情况下，使用upgrade data directory name显式地告诉服务器将数据库目录名重新编码为当前编码格式：</p><pre data-lang="sql" class="programlisting">ALTER DATABASE `#mysql50#a-b-c` UPGRADE DATA DIRECTORY NAME;
</pre><p>
            After executing this statement, you can refer to the database as
            <code class="literal">a-b-c</code> without the special
            <code class="literal">#mysql50#</code> prefix.
        </p><p style="color:blue;">执行此语句后，可以将数据库引用为a-b-c，而不使用特殊的mysql50前缀。</p>
            <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">

                <div class="admon-title">
                    Note
                </div>
                <p>
                    The <code class="literal">UPGRADE DATA DIRECTORY NAME</code> clause is
                    deprecated in MySQL 5.7.6 and will be removed in a future
                    version of MySQL. If it is necessary to convert MySQL 5.0
                    database or table names, a workaround is to upgrade a MySQL 5.0
                    installation to MySQL 5.1 before upgrading to a more recent
                    release.
                </p><p style="color:blue;">mysql 5.7.6中不推荐使用upgrade data directory name子句，它将在mysql的未来版本中被删除。如果需要转换mysql 5.0数据库或表名，解决方法是在升级到更新版本之前将mysql 5.0安装升级到mysql 5.1。</p>
            </div>

        </div>
        <div class="section">
            <div class="titlepage">
                <div>
                    <div>
                        <h3 class="title"><a name="alter-event"></a>13.1.2&nbsp;ALTER EVENT Syntax</h3>

                    </div>

                </div>

            </div>
            <a class="indexterm" name="idm140286841773040"></a><a class="indexterm" name="idm140286841771552"></a><a class="indexterm" name="idm140286841770064"></a><pre data-lang="sql" class="programlisting">ALTER
    [DEFINER = <em class="replaceable"><code>user</code></em>]
    EVENT <em class="replaceable"><code>event_name</code></em>
    [ON SCHEDULE <em class="replaceable"><code>schedule</code></em>]
    [ON COMPLETION [NOT] PRESERVE]
    [RENAME TO <em class="replaceable"><code>new_event_name</code></em>]
    [ENABLE | DISABLE | DISABLE ON SLAVE]
    [COMMENT '<em class="replaceable"><code>string</code></em>']
    [DO <em class="replaceable"><code>event_body</code></em>]
</pre><p>
            The <a class="link" href="sql-syntax.html#alter-event" title="13.1.2&nbsp;ALTER EVENT Syntax"><code class="literal">ALTER EVENT</code></a> statement changes
            one or more of the characteristics of an existing event without
            the need to drop and recreate it. The syntax for each of the
            <code class="literal">DEFINER</code>, <code class="literal">ON SCHEDULE</code>,
            <code class="literal">ON COMPLETION</code>, <code class="literal">COMMENT</code>,
            <code class="literal">ENABLE</code> / <code class="literal">DISABLE</code>, and
            <a class="link" href="sql-syntax.html#do" title="13.2.3&nbsp;DO Syntax"><code class="literal">DO</code></a> clauses is exactly the same as
            when used with <a class="link" href="sql-syntax.html#create-event" title="13.1.12&nbsp;CREATE EVENT Syntax"><code class="literal">CREATE EVENT</code></a>. (See
            <a class="xref" href="sql-syntax.html#create-event" title="13.1.12&nbsp;CREATE EVENT Syntax">Section&nbsp;13.1.12, “CREATE EVENT Syntax”</a>.)
        </p><p style="color:blue;">ALTURE事件语句更改现有事件的一个或多个特性，而不需要删除并重新创建它。每个definer、on schedule、on completion、comment、enable/disable和do子句的语法与用于create event时的语法完全相同。（见第13.1.12节，“创建事件语法”。）</p><p>
            Any user can alter an event defined on a database for which that
            user has the <a class="link" href="security.html#priv_event"><code class="literal">EVENT</code></a> privilege. When
            a user executes a successful <a class="link" href="sql-syntax.html#alter-event" title="13.1.2&nbsp;ALTER EVENT Syntax"><code class="literal">ALTER
            EVENT</code></a> statement, that user becomes the definer for the
            affected event.
        </p><p style="color:blue;">任何用户都可以更改数据库中定义的事件，该用户对该数据库具有事件权限。当用户执行一个成功的alter event语句时，该用户将成为受影响事件的定义者。</p><p>
            <a class="link" href="sql-syntax.html#alter-event" title="13.1.2&nbsp;ALTER EVENT Syntax"><code class="literal">ALTER EVENT</code></a> works only with an
            existing event:
        </p><p style="color:blue;">ALTER事件只与现有事件一起工作：</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>ALTER EVENT no_such_event </code></strong>
     &gt;     <strong class="userinput"><code>ON SCHEDULE </code></strong>
     &gt;       <strong class="userinput"><code>EVERY '2:3' DAY_HOUR;</code></strong>
<span class="errortext">ERROR 1517 (HY000): Unknown event 'no_such_event'</span>
</pre><p>
            In each of the following examples, assume that the event named
            <code class="literal">myevent</code> is defined as shown here:
        </p><p style="color:blue;">在以下每个示例中，假设名为myEvent的事件定义如下所示：</p><pre data-lang="sql" class="programlisting">CREATE EVENT myevent
    ON SCHEDULE
      EVERY 6 HOUR
    COMMENT 'A sample comment.'
    DO
      UPDATE myschema.mytable SET mycol = mycol + 1;
</pre><p>
            The following statement changes the schedule for
            <code class="literal">myevent</code> from once every six hours starting
            immediately to once every twelve hours, starting four hours from
            the time the statement is run:
        </p><p style="color:blue;">以下语句将MyEvent的计划从每六小时一次立即开始更改为每十二小时一次，从运行语句的四小时开始更改：</p><pre data-lang="sql" class="programlisting">ALTER EVENT myevent
    ON SCHEDULE
      EVERY 12 HOUR
    STARTS CURRENT_TIMESTAMP + INTERVAL 4 HOUR;
</pre><p>
            It is possible to change multiple characteristics of an event in a
            single statement. This example changes the SQL statement executed
            by <code class="literal">myevent</code> to one that deletes all records from
            <code class="literal">mytable</code>; it also changes the schedule for the
            event such that it executes once, one day after this
            <a class="link" href="sql-syntax.html#alter-event" title="13.1.2&nbsp;ALTER EVENT Syntax"><code class="literal">ALTER EVENT</code></a> statement is run.
        </p><p style="color:blue;">可以在单个语句中更改事件的多个特征。此示例将myEvent执行的SQL语句更改为从myTable中删除所有记录的语句；还将更改事件的计划，以便在运行此alter event语句的一天后执行一次。</p><pre data-lang="sql" class="programlisting">ALTER EVENT myevent
    ON SCHEDULE
      AT CURRENT_TIMESTAMP + INTERVAL 1 DAY
    DO
      TRUNCATE TABLE myschema.mytable;
</pre><p>
            Specify the options in an <a class="link" href="sql-syntax.html#alter-event" title="13.1.2&nbsp;ALTER EVENT Syntax"><code class="literal">ALTER
            EVENT</code></a> statement only for those characteristics that you
            want to change; omitted options keep their existing values. This
            includes any default values for <a class="link" href="sql-syntax.html#create-event" title="13.1.12&nbsp;CREATE EVENT Syntax"><code class="literal">CREATE
            EVENT</code></a> such as <code class="literal">ENABLE</code>.
        </p><p style="color:blue;">在ALTE事件语句中只指定要更改的那些特性；省略的选项保留它们现有的值。这包括创建事件（如enable）的任何默认值。</p><p>
            To disable <code class="literal">myevent</code>, use this
            <a class="link" href="sql-syntax.html#alter-event" title="13.1.2&nbsp;ALTER EVENT Syntax"><code class="literal">ALTER EVENT</code></a> statement:
        </p><p style="color:blue;">要禁用myEvent，请使用以下alter event语句：</p><pre data-lang="sql" class="programlisting">ALTER EVENT myevent
    DISABLE;
</pre><p>
            The <code class="literal">ON SCHEDULE</code> clause may use expressions
            involving built-in MySQL functions and user variables to obtain
            any of the <em class="replaceable"><code>timestamp</code></em> or
            <em class="replaceable"><code>interval</code></em> values which it contains. You
            cannot use stored routines or user-defined functions in such
            expressions, and you cannot use any table references; however, you
            can use <code class="literal">SELECT FROM DUAL</code>. This is true for both
            <a class="link" href="sql-syntax.html#alter-event" title="13.1.2&nbsp;ALTER EVENT Syntax"><code class="literal">ALTER EVENT</code></a> and
            <a class="link" href="sql-syntax.html#create-event" title="13.1.12&nbsp;CREATE EVENT Syntax"><code class="literal">CREATE EVENT</code></a> statements. References
            to stored routines, user-defined functions, and tables in such
            cases are specifically not permitted, and fail with an error (see
            Bug #22830).
        </p><p style="color:blue;">on schedule子句可以使用包含内置mysql函数和用户变量的表达式来获取它包含的任何时间戳或间隔值。您不能在此类表达式中使用存储例程或用户定义函数，也不能使用任何表引用；但是，您可以使用select from dual。alter event和create event语句都是这样。在这种情况下，对存储例程、用户定义函数和表的引用是不允许的，并且会因错误而失败（请参阅错误22830）。</p><p>
            Although an <a class="link" href="sql-syntax.html#alter-event" title="13.1.2&nbsp;ALTER EVENT Syntax"><code class="literal">ALTER EVENT</code></a> statement
            that contains another <a class="link" href="sql-syntax.html#alter-event" title="13.1.2&nbsp;ALTER EVENT Syntax"><code class="literal">ALTER EVENT</code></a>
            statement in its <a class="link" href="sql-syntax.html#do" title="13.2.3&nbsp;DO Syntax"><code class="literal">DO</code></a> clause appears
            to succeed, when the server attempts to execute the resulting
            scheduled event, the execution fails with an error.
        </p><p style="color:blue;">尽管在do子句中包含另一个alter event语句的alter event语句似乎成功，但当服务器尝试执行生成的调度事件时，执行失败，并出现错误。</p><p>
            To rename an event, use the <a class="link" href="sql-syntax.html#alter-event" title="13.1.2&nbsp;ALTER EVENT Syntax"><code class="literal">ALTER
            EVENT</code></a> statement's <code class="literal">RENAME TO</code> clause.
            This statement renames the event <code class="literal">myevent</code> to
            <code class="literal">yourevent</code>:
        </p><p style="color:blue;">要重命名事件，请使用alter event语句的rename to子句。此语句将事件MyEvent重命名为YourEvent：</p><pre data-lang="sql" class="programlisting">ALTER EVENT myevent
    RENAME TO yourevent;
</pre><p>
            You can also move an event to a different database using
            <code class="literal">ALTER EVENT ... RENAME TO ...</code> and
            <code class="literal"><em class="replaceable"><code>db_name.event_name</code></em></code>
            notation, as shown here:
        </p><p style="color:blue;">也可以使用alter event将事件移动到其他数据库…重命名为…和db_name.event_name表示法，如下所示：</p><pre data-lang="sql" class="programlisting">ALTER EVENT olddb.myevent
    RENAME TO newdb.myevent;
</pre><p>
            To execute the previous statement, the user executing it must have
            the <a class="link" href="security.html#priv_event"><code class="literal">EVENT</code></a> privilege on both the
            <code class="literal">olddb</code> and <code class="literal">newdb</code> databases.
        </p><p style="color:blue;">要执行前一条语句，执行它的用户必须同时具有olddb和newdb数据库的事件权限。</p>
            <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">

                <div class="admon-title">
                    Note
                </div>
                <p>
                    There is no <code class="literal">RENAME EVENT</code> statement.
                </p><p style="color:blue;">没有重命名事件语句。</p>
            </div>
            <p>
                The value <code class="literal">DISABLE ON SLAVE</code> is used on a
                replication slave instead of <code class="literal">ENABLE</code> or
                <code class="literal">DISABLE</code> to indicate an event that was created
                on the master and replicated to the slave, but that is not
                executed on the slave. Normally, <code class="literal">DISABLE ON
                SLAVE</code> is set automatically as required; however, there
                are some circumstances under which you may want or need to change
                it manually. See <a class="xref" href="replication.html#replication-features-invoked" title="16.4.1.16&nbsp;Replication of Invoked Features">Section&nbsp;16.4.1.16, “Replication of Invoked Features”</a>,
                for more information.
            </p><p style="color:blue;">值disable on slave用于复制从机，而不是enable或disable来指示在主机上创建并复制到从机上的事件，但该事件不会在从机上执行。通常，从机上禁用是根据需要自动设置的；但是，在某些情况下，您可能需要或需要手动更改它。有关更多信息，请参见第16.4.1.16节“调用功能的复制”。</p>
        </div>
        <div class="section">
            <div class="titlepage">
                <div>
                    <div>
                        <h3 class="title"><a name="alter-function"></a>13.1.3&nbsp;ALTER FUNCTION Syntax</h3>

                    </div>

                </div>

            </div>
            <a class="indexterm" name="idm140286841700528"></a><pre data-lang="sql" class="programlisting">ALTER FUNCTION <em class="replaceable"><code>func_name</code></em> [<em class="replaceable"><code>characteristic</code></em> ...]

<em class="replaceable"><code>characteristic</code></em>:
    COMMENT '<em class="replaceable"><code>string</code></em>'
  | LANGUAGE SQL
  | { CONTAINS SQL | NO SQL | READS SQL DATA | MODIFIES SQL DATA }
  | SQL SECURITY { DEFINER | INVOKER }
</pre><p>
            This statement can be used to change the characteristics of a
            stored function. More than one change may be specified in an
            <a class="link" href="sql-syntax.html#alter-function" title="13.1.3&nbsp;ALTER FUNCTION Syntax"><code class="literal">ALTER FUNCTION</code></a> statement. However,
            you cannot change the parameters or body of a stored function
            using this statement; to make such changes, you must drop and
            re-create the function using <a class="link" href="sql-syntax.html#drop-function" title="13.1.24&nbsp;DROP FUNCTION Syntax"><code class="literal">DROP
            FUNCTION</code></a> and <a class="link" href="sql-syntax.html#create-function" title="13.1.13&nbsp;CREATE FUNCTION Syntax"><code class="literal">CREATE
            FUNCTION</code></a>.
        </p><p style="color:blue;">此语句可用于更改存储函数的特性。在alter function语句中可以指定多个更改。但是，不能使用此语句更改存储函数的参数或主体；若要进行此类更改，必须使用drop function和create function删除并重新创建该函数。</p><p>
            You must have the <a class="link" href="security.html#priv_alter-routine"><code class="literal">ALTER ROUTINE</code></a>
            privilege for the function. (That privilege is granted
            automatically to the function creator.) If binary logging is
            enabled, the <a class="link" href="sql-syntax.html#alter-function" title="13.1.3&nbsp;ALTER FUNCTION Syntax"><code class="literal">ALTER FUNCTION</code></a>
            statement might also require the
            <a class="link" href="security.html#priv_super"><code class="literal">SUPER</code></a> privilege, as described in
            <a class="xref" href="stored-objects.html#stored-programs-logging" title="23.7&nbsp;Stored Program Binary Logging">Section&nbsp;23.7, “Stored Program Binary Logging”</a>.
        </p><p style="color:blue;">您必须具有该函数的alter例程特权。（该特权自动授予函数创建者）如果启用了二进制日志记录，alter function语句也可能需要超级特权，如23.7节“存储程序二进制日志记录”中所述。</p>
        </div>
        <div class="section">
            <div class="titlepage">
                <div>
                    <div>
                        <h3 class="title"><a name="alter-instance"></a>13.1.4&nbsp;ALTER INSTANCE Syntax</h3>

                    </div>

                </div>

            </div>
            <a class="indexterm" name="idm140286841682080"></a><pre data-lang="sql" class="programlisting">ALTER INSTANCE ROTATE INNODB MASTER KEY</pre><p>
            <code class="literal">ALTER INSTANCE</code>, introduced in MySQL 5.7.11,
            defines actions applicable to a MySQL server instance.
        </p><p style="color:blue;">在mysql 5.7.11中引入的alter instance定义了适用于mysql服务器实例的操作。</p><p>
            The <code class="literal">ALTER INSTANCE ROTATE INNODB MASTER KEY</code>
            statement is used to rotate the master encryption key used for
            <code class="literal">InnoDB</code> tablespace encryption. A keyring plugin
            must be installed and configured to use this statement. For
            information about keyring plugins, see <a class="xref" href="security.html#keyring" title="6.4.4&nbsp;The MySQL Keyring">Section&nbsp;6.4.4, “The MySQL Keyring”</a>.
            Key rotation requires the <a class="link" href="security.html#priv_super"><code class="literal">SUPER</code></a>
            privilege.
        </p><p style="color:blue;">alter instance rotate innodb master key语句用于旋转用于innodb表空间加密的主加密密钥。必须安装并配置keyring插件才能使用此语句。有关keyring插件的信息，请参见第6.4.4节“mysql keyring”。密钥轮换需要超级特权。</p><p>
            <code class="literal">ALTER INSTANCE ROTATE INNODB MASTER KEY</code>
            supports concurrent DML. However, it cannot be run concurrently
            with <a class="link" href="sql-syntax.html#create-table" title="13.1.18&nbsp;CREATE TABLE Syntax"><code class="literal">CREATE TABLE
            ... ENCRYPTION</code></a> or
            <a class="link" href="sql-syntax.html#alter-table" title="13.1.8&nbsp;ALTER TABLE Syntax"><code class="literal">ALTER TABLE ...
                ENCRYPTION</code></a> operations, and locks are taken to prevent
            conflicts that could arise from concurrent execution of these
            statements. If one of the conflicting statements is running, it
            must complete before another can proceed.
        </p><p style="color:blue;">alter instance rotate innodb主键支持并发dml。但是，它不能与create table同时运行…加密或更改表…加密操作和锁用于防止这些语句的并发执行可能引起的冲突。如果其中一个冲突语句正在运行，则必须先完成该语句，然后另一个语句才能继续。</p><p>
            <code class="literal">ALTER INSTANCE</code> actions are written to the
            binary log so that they can be executed on replicated servers.
        </p><p style="color:blue;">alter实例操作被写入二进制日志，以便它们可以在复制的服务器上执行。</p><p>
            For additional <code class="literal">ALTER INSTANCE ROTATE INNODB MASTER
            KEY</code> usage information, see
            <a class="xref" href="innodb-storage-engine.html#innodb-tablespace-encryption" title="14.6.3.8&nbsp;InnoDB Data-at-Rest Encryption">Section&nbsp;14.6.3.8, “InnoDB Data-at-Rest Encryption”</a>. For information
            about keyring plugins, see <a class="xref" href="security.html#keyring" title="6.4.4&nbsp;The MySQL Keyring">Section&nbsp;6.4.4, “The MySQL Keyring”</a>.
        </p><p style="color:blue;">有关其他alter instance rotate innodb master key用法信息，请参阅14.6.3.8节，“innodb data at rest encryption”。有关keyring插件的信息，请参见第6.4.4节“mysql keyring”。</p>
        </div>
        <div class="section">
            <div class="titlepage">
                <div>
                    <div>
                        <h3 class="title"><a name="alter-logfile-group"></a>13.1.5&nbsp;ALTER LOGFILE GROUP Syntax</h3>

                    </div>

                </div>

            </div>
            <a class="indexterm" name="idm140286841662784"></a><pre data-lang="sql" class="programlisting">ALTER LOGFILE GROUP <em class="replaceable"><code>logfile_group</code></em>
    ADD UNDOFILE '<em class="replaceable"><code>file_name</code></em>'
    [INITIAL_SIZE [=] <em class="replaceable"><code>size</code></em>]
    [WAIT]
    ENGINE [=] <em class="replaceable"><code>engine_name</code></em>
</pre><p>
            This statement adds an <code class="literal">UNDO</code> file named
            '<em class="replaceable"><code>file_name</code></em>' to an existing log file
            group <em class="replaceable"><code>logfile_group</code></em>. An
            <a class="link" href="sql-syntax.html#alter-logfile-group" title="13.1.5&nbsp;ALTER LOGFILE GROUP Syntax"><code class="literal">ALTER LOGFILE GROUP</code></a> statement has
            one and only one <code class="literal">ADD UNDOFILE</code> clause. No
            <code class="literal">DROP UNDOFILE</code> clause is currently supported.
        </p><p style="color:blue;">此语句将一个名为“文件名”的撤销文件添加到现有日志文件组LogFielyGROUP中。alter logfile group语句只有一个add undofile子句。当前不支持DROP UNDOFILE子句。</p>
            <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">

                <div class="admon-title">
                    Note
                </div>
                <p>
                    All NDB Cluster Disk Data objects share the same namespace. This
                    means that <span class="emphasis"><em>each Disk Data object</em></span> must be
                    uniquely named (and not merely each Disk Data object of a given
                    type). For example, you cannot have a tablespace and an undo log
                    file with the same name, or an undo log file and a data file
                    with the same name.
                </p><p style="color:blue;">所有ndb群集磁盘数据对象共享同一命名空间。这意味着每个磁盘数据对象必须有唯一的名称（而不仅仅是给定类型的每个磁盘数据对象）。例如，不能有同名的表空间和撤消日志文件，也不能有同名的撤消日志文件和数据文件。</p>
            </div>
            <p>
                The optional <code class="literal">INITIAL_SIZE</code> parameter sets the
                <code class="literal">UNDO</code> file's initial size in bytes; if not
                specified, the initial size defaults to 134217728 (128 MB). You
                may optionally follow <em class="replaceable"><code>size</code></em> with a
                one-letter abbreviation for an order of magnitude, similar to
                those used in <code class="filename">my.cnf</code>. Generally, this is one
                of the letters <code class="literal">M</code> (megabytes) or
                <code class="literal">G</code> (gigabytes). (Bug #13116514, Bug #16104705,
                Bug #62858)
            </p><p style="color:blue;">可选的initial_size参数以字节为单位设置撤消文件的初始大小；如果未指定，则初始大小默认为134217728（128 MB）。您可以选择使用一个字母的缩写来表示数量级，与my.cnf中使用的类似。通常，这是m（兆字节）或g（千兆字节）中的一个字母。（错误13116514，错误16104705，错误62858）</p><p>
            On 32-bit systems, the maximum supported value for
            <code class="literal">INITIAL_SIZE</code> is 4294967296 (4 GB). (Bug #29186)
        </p><p style="color:blue;">在32位系统上，初始值的最大支持值为4294967296（4 GB）。（错误29186）</p><p>
            The minimum allowed value for <code class="literal">INITIAL_SIZE</code> is
            1048576 (1 MB). (Bug #29574)
        </p><p style="color:blue;">初始大小的最小允许值为1048576（1 MB）。（错误29574）</p>
            <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">

                <div class="admon-title">
                    Note
                </div>
                <p>
                    <code class="literal">WAIT</code> is parsed but otherwise ignored. This
                    keyword currently has no effect, and is intended for future
                    expansion.
                </p><p style="color:blue;">wait被解析，但在其他情况下被忽略。此关键字当前无效，用于将来的扩展。</p>
            </div>
            <p>
                The <code class="literal">ENGINE</code> parameter (required) determines the
                storage engine which is used by this log file group, with
                <em class="replaceable"><code>engine_name</code></em> being the name of the
                storage engine. Currently, the only accepted values for
                <em class="replaceable"><code>engine_name</code></em> are
                <span class="quote">“<span class="quote"><a class="link" href="mysql-cluster.html" title="Chapter&nbsp;21&nbsp;MySQL NDB Cluster 7.5 and NDB Cluster 7.6"><code class="literal">NDBCLUSTER</code></a></span>”</span> and
                <span class="quote">“<span class="quote"><a class="link" href="mysql-cluster.html" title="Chapter&nbsp;21&nbsp;MySQL NDB Cluster 7.5 and NDB Cluster 7.6"><code class="literal">NDB</code></a></span>”</span>. The two values
                are equivalent.
            </p><p style="color:blue;">引擎参数（必需）确定此日志文件组使用的存储引擎，其中engine_name是存储引擎的名称。目前，引擎名的唯一可接受值是“ndbcluster”和“ndb”。这两个值是相等的。</p><p>
            Here is an example, which assumes that the log file group
            <code class="literal">lg_3</code> has already been created using
            <a class="link" href="sql-syntax.html#create-logfile-group" title="13.1.15&nbsp;CREATE LOGFILE GROUP Syntax"><code class="literal">CREATE LOGFILE GROUP</code></a> (see
            <a class="xref" href="sql-syntax.html#create-logfile-group" title="13.1.15&nbsp;CREATE LOGFILE GROUP Syntax">Section&nbsp;13.1.15, “CREATE LOGFILE GROUP Syntax”</a>):
        </p><p style="color:blue;">下面是一个示例，假设日志文件组lg_3已经使用create log file group创建（请参阅第13.1.15节“create logfile group syntax”）：</p><pre data-lang="sql" class="programlisting">ALTER LOGFILE GROUP lg_3
    ADD UNDOFILE 'undo_10.dat'
    INITIAL_SIZE=32M
    ENGINE=NDBCLUSTER;
</pre><p>
            When <a class="link" href="sql-syntax.html#alter-logfile-group" title="13.1.5&nbsp;ALTER LOGFILE GROUP Syntax"><code class="literal">ALTER LOGFILE GROUP</code></a> is used
            with <code class="literal">ENGINE = NDBCLUSTER</code> (alternatively,
            <code class="literal">ENGINE = NDB</code>), an <code class="literal">UNDO</code> log
            file is created on each NDB Cluster data node. You can verify that
            the <code class="literal">UNDO</code> files were created and obtain
            information about them by querying the
            <a class="link" href="information-schema.html#files-table" title="24.9&nbsp;The INFORMATION_SCHEMA FILES Table"><code class="literal">INFORMATION_SCHEMA.FILES</code></a> table. For
            example:
        </p><p style="color:blue;">当alter log file group与engine=ndb cluster（或者engine=ndb）一起使用时，将在每个ndb集群数据节点上创建一个撤销日志文件。您可以通过查询information\schema.files表来验证撤消文件是否已创建，并获取有关这些文件的信息。例如：</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT FILE_NAME, LOGFILE_GROUP_NUMBER, EXTRA</code></strong>
    -&gt; <strong class="userinput"><code>FROM INFORMATION_SCHEMA.FILES</code></strong>
    -&gt; <strong class="userinput"><code>WHERE LOGFILE_GROUP_NAME = 'lg_3';</code></strong>
+-------------+----------------------+----------------+
| FILE_NAME   | LOGFILE_GROUP_NUMBER | EXTRA          |
+-------------+----------------------+----------------+
| newdata.dat |                    0 | CLUSTER_NODE=3 |
| newdata.dat |                    0 | CLUSTER_NODE=4 |
| undo_10.dat |                   11 | CLUSTER_NODE=3 |
| undo_10.dat |                   11 | CLUSTER_NODE=4 |
+-------------+----------------------+----------------+
4 rows in set (0.01 sec)
</pre><p>
            (See <a class="xref" href="information-schema.html#files-table" title="24.9&nbsp;The INFORMATION_SCHEMA FILES Table">Section&nbsp;24.9, “The INFORMATION_SCHEMA FILES Table”</a>.)
        </p><p style="color:blue;">（见第24.9节，“信息架构文件表”。）</p><p>
            Memory used for <code class="literal">UNDO_BUFFER_SIZE</code> comes from the
            global pool whose size is determined by the value of the
            <a class="link" href="mysql-cluster.html#ndbparam-ndbd-sharedglobalmemory"><code class="literal">SharedGlobalMemory</code></a> data
            node configuration parameter. This includes any default value
            implied for this option by the setting of the
            <a class="link" href="mysql-cluster.html#ndbparam-ndbd-initiallogfilegroup"><code class="literal">InitialLogFileGroup</code></a> data
            node configuration parameter.
        </p><p style="color:blue;">用于撤消缓冲区大小的内存来自全局池，其大小由sharedglobalmemory数据节点配置参数的值决定。这包括通过设置initiallogfilegroup数据节点配置参数为该选项隐含的任何默认值。</p><p>
            <a class="link" href="sql-syntax.html#alter-logfile-group" title="13.1.5&nbsp;ALTER LOGFILE GROUP Syntax"><code class="literal">ALTER LOGFILE GROUP</code></a> is useful only
            with Disk Data storage for NDB Cluster. For more information, see
            <a class="xref" href="mysql-cluster.html#mysql-cluster-disk-data" title="21.5.13&nbsp;NDB Cluster Disk Data Tables">Section&nbsp;21.5.13, “NDB Cluster Disk Data Tables”</a>.
        </p><p style="color:blue;">alter logfile group只对ndb集群的磁盘数据存储有用。有关更多信息，请参阅21.5.13节“ndb群集磁盘数据表”。</p>
        </div>
        <div class="section">
            <div class="titlepage">
                <div>
                    <div>
                        <h3 class="title"><a name="alter-procedure"></a>13.1.6&nbsp;ALTER PROCEDURE Syntax</h3>

                    </div>

                </div>

            </div>
            <a class="indexterm" name="idm140286841612496"></a><pre data-lang="sql" class="programlisting">ALTER PROCEDURE <em class="replaceable"><code>proc_name</code></em> [<em class="replaceable"><code>characteristic</code></em> ...]

<em class="replaceable"><code>characteristic</code></em>:
    COMMENT '<em class="replaceable"><code>string</code></em>'
  | LANGUAGE SQL
  | { CONTAINS SQL | NO SQL | READS SQL DATA | MODIFIES SQL DATA }
  | SQL SECURITY { DEFINER | INVOKER }
</pre><p>
            This statement can be used to change the characteristics of a
            stored procedure. More than one change may be specified in an
            <a class="link" href="sql-syntax.html#alter-procedure" title="13.1.6&nbsp;ALTER PROCEDURE Syntax"><code class="literal">ALTER PROCEDURE</code></a> statement. However,
            you cannot change the parameters or body of a stored procedure
            using this statement; to make such changes, you must drop and
            re-create the procedure using <a class="link" href="sql-syntax.html#drop-procedure" title="13.1.27&nbsp;DROP PROCEDURE and DROP FUNCTION Syntax"><code class="literal">DROP
            PROCEDURE</code></a> and <a class="link" href="sql-syntax.html#create-procedure" title="13.1.16&nbsp;CREATE PROCEDURE and CREATE FUNCTION Syntax"><code class="literal">CREATE
            PROCEDURE</code></a>.
        </p><p style="color:blue;">此语句可用于更改存储过程的特性。在alter procedure语句中可以指定多个更改。但是，不能使用此语句更改存储过程的参数或主体；若要进行此类更改，必须使用DROP PROCEDURE和CREATE PROCEDURE删除并重新创建过程。</p><p>
            You must have the <a class="link" href="security.html#priv_alter-routine"><code class="literal">ALTER ROUTINE</code></a>
            privilege for the procedure. By default, that privilege is granted
            automatically to the procedure creator. This behavior can be
            changed by disabling the
            <a class="link" href="server-administration.html#sysvar_automatic_sp_privileges"><code class="literal">automatic_sp_privileges</code></a> system
            variable. See <a class="xref" href="stored-objects.html#stored-routines-privileges" title="23.2.2&nbsp;Stored Routines and MySQL Privileges">Section&nbsp;23.2.2, “Stored Routines and MySQL Privileges”</a>.
        </p><p style="color:blue;">您必须具有该过程的alter例程特权。默认情况下，该权限自动授予过程创建者。此行为可以通过禁用automatic_sp_privileges系统变量来更改。参见第23.2.2节“存储例程和mysql特权”。</p>
        </div>
        <div class="section">
            <div class="titlepage">
                <div>
                    <div>
                        <h3 class="title"><a name="alter-server"></a>13.1.7&nbsp;ALTER SERVER Syntax</h3>

                    </div>

                </div>

            </div>
            <a class="indexterm" name="idm140286841595232"></a><pre data-lang="sql" class="programlisting">ALTER SERVER  <em class="replaceable"><code>server_name</code></em>
    OPTIONS (<em class="replaceable"><code>option</code></em> [, <em class="replaceable"><code>option</code></em>] ...)
</pre><p>
            Alters the server information for
            <code class="literal"><em class="replaceable"><code>server_name</code></em></code>,
            adjusting any of the options permitted in the
            <a class="link" href="sql-syntax.html#create-server" title="13.1.17&nbsp;CREATE SERVER Syntax"><code class="literal">CREATE SERVER</code></a> statement. The
            corresponding fields in the <code class="literal">mysql.servers</code> table
            are updated accordingly. This statement requires the
            <a class="link" href="security.html#priv_super"><code class="literal">SUPER</code></a> privilege.
        </p><p style="color:blue;">更改服务器名的服务器信息，调整create server语句中允许的任何选项。相应地更新mysql.servers表中的相应字段。此语句需要超级特权。</p><p>
            For example, to update the <code class="literal">USER</code> option:
        </p><p style="color:blue;">例如，要更新用户选项：</p><pre data-lang="sql" class="programlisting">ALTER SERVER s OPTIONS (USER 'sally');</pre><p>
            <code class="literal">ALTER SERVER</code> causes an implicit commit. See
            <a class="xref" href="sql-syntax.html#implicit-commit" title="13.3.3&nbsp;Statements That Cause an Implicit Commit">Section&nbsp;13.3.3, “Statements That Cause an Implicit Commit”</a>.
        </p><p style="color:blue;">alter server导致隐式提交。参见第13.3.3节，“导致隐式提交的语句”。</p><p>
            <code class="literal">ALTER SERVER</code> is not written to the binary log,
            regardless of the logging format that is in use.
        </p><p style="color:blue;">无论使用何种日志格式，alter server都不会写入二进制日志。</p>
        </div>
        <div class="section">
            <div class="titlepage">
                <div>
                    <div>
                        <h3 class="title"><a name="alter-table"></a>13.1.8&nbsp;ALTER TABLE Syntax</h3>

                    </div>

                </div>

            </div>
            <div class="toc">
                <dl class="toc"><dt><span class="section"><a href="sql-syntax.html#alter-table-partition-operations">13.1.8.1 ALTER TABLE Partition Operations</a></span></dt><dt><span class="section"><a href="sql-syntax.html#alter-table-generated-columns">13.1.8.2 ALTER TABLE and Generated Columns</a></span></dt><dt><span class="section"><a href="sql-syntax.html#alter-table-examples">13.1.8.3 ALTER TABLE Examples</a></span></dt></dl>
            </div>
            <a class="indexterm" name="idm140286841577392"></a><a class="indexterm" name="idm140286841576320"></a><a class="indexterm" name="idm140286841574832"></a><pre data-lang="sql" class="programlisting">ALTER TABLE <em class="replaceable"><code>tbl_name</code></em>
    [<em class="replaceable"><code>alter_specification</code></em> [, <em class="replaceable"><code>alter_specification</code></em>] ...]
    [<em class="replaceable"><code>partition_options</code></em>]

<em class="replaceable"><code>alter_specification</code></em>:
    <em class="replaceable"><code>table_options</code></em>
  | ADD [COLUMN] <em class="replaceable"><code>col_name</code></em> <em class="replaceable"><code>column_definition</code></em>
        [FIRST | AFTER <em class="replaceable"><code>col_name</code></em>]
  | ADD [COLUMN] (<em class="replaceable"><code>col_name</code></em> <em class="replaceable"><code>column_definition</code></em>,...)
  | ADD {INDEX|KEY} [<em class="replaceable"><code>index_name</code></em>]
        [<em class="replaceable"><code>index_type</code></em>] (<em class="replaceable"><code>key_part</code></em>,...) [<em class="replaceable"><code>index_option</code></em>] ...
  | ADD {FULLTEXT|SPATIAL} [INDEX|KEY] [<em class="replaceable"><code>index_name</code></em>]
        (<em class="replaceable"><code>key_part</code></em>,...) [<em class="replaceable"><code>index_option</code></em>] ...
  | ADD [CONSTRAINT [<em class="replaceable"><code>symbol</code></em>]] PRIMARY KEY
        [<em class="replaceable"><code>index_type</code></em>] (<em class="replaceable"><code>key_part</code></em>,...)
        [<em class="replaceable"><code>index_option</code></em>] ...
  | ADD [CONSTRAINT [<em class="replaceable"><code>symbol</code></em>]] UNIQUE [INDEX|KEY]
        [<em class="replaceable"><code>index_name</code></em>] [<em class="replaceable"><code>index_type</code></em>] (<em class="replaceable"><code>key_part</code></em>,...)
        [<em class="replaceable"><code>index_option</code></em>] ...
  | ADD [CONSTRAINT [<em class="replaceable"><code>symbol</code></em>]] FOREIGN KEY
        [<em class="replaceable"><code>index_name</code></em>] (<em class="replaceable"><code>col_name</code></em>,...)
        <em class="replaceable"><code>reference_definition</code></em>
  | ADD CHECK (<em class="replaceable"><code>expr</code></em>)
  | ALGORITHM [=] {DEFAULT|INPLACE|COPY}
  | ALTER [COLUMN] <em class="replaceable"><code>col_name</code></em> {SET DEFAULT <em class="replaceable"><code>literal</code></em> | DROP DEFAULT}
  | CHANGE [COLUMN] <em class="replaceable"><code>old_col_name</code></em> <em class="replaceable"><code>new_col_name</code></em> <em class="replaceable"><code>column_definition</code></em>
        [FIRST|AFTER <em class="replaceable"><code>col_name</code></em>]
  | [DEFAULT] CHARACTER SET [=] <em class="replaceable"><code>charset_name</code></em> [COLLATE [=] <em class="replaceable"><code>collation_name</code></em>]
  | CONVERT TO CHARACTER SET <em class="replaceable"><code>charset_name</code></em> [COLLATE <em class="replaceable"><code>collation_name</code></em>]
  | {DISABLE|ENABLE} KEYS
  | {DISCARD|IMPORT} TABLESPACE
  | DROP [COLUMN] <em class="replaceable"><code>col_name</code></em>
  | DROP {INDEX|KEY} <em class="replaceable"><code>index_name</code></em>
  | DROP PRIMARY KEY
  | DROP FOREIGN KEY <em class="replaceable"><code>fk_symbol</code></em>
  | FORCE
  | LOCK [=] {DEFAULT|NONE|SHARED|EXCLUSIVE}
  | MODIFY [COLUMN] <em class="replaceable"><code>col_name</code></em> <em class="replaceable"><code>column_definition</code></em>
        [FIRST | AFTER <em class="replaceable"><code>col_name</code></em>]
  | ORDER BY <em class="replaceable"><code>col_name</code></em> [, <em class="replaceable"><code>col_name</code></em>] ...
  | RENAME {INDEX|KEY} <em class="replaceable"><code>old_index_name</code></em> TO <em class="replaceable"><code>new_index_name</code></em>
  | RENAME [TO|AS] <em class="replaceable"><code>new_tbl_name</code></em>
  | {WITHOUT|WITH} VALIDATION

<em class="replaceable"><code>partition_options</code></em>:
    <em class="replaceable"><code>partition_option</code></em> [<em class="replaceable"><code>partition_option</code></em>] ...

<em class="replaceable"><code>partition_option</code></em>:
    ADD PARTITION (<em class="replaceable"><code>partition_definition</code></em>)
  | DROP PARTITION <em class="replaceable"><code>partition_names</code></em>
  | DISCARD PARTITION {<em class="replaceable"><code>partition_names</code></em> | ALL} TABLESPACE
  | IMPORT PARTITION {<em class="replaceable"><code>partition_names</code></em> | ALL} TABLESPACE
  | TRUNCATE PARTITION {<em class="replaceable"><code>partition_names</code></em> | ALL}
  | COALESCE PARTITION <em class="replaceable"><code>number</code></em>
  | REORGANIZE PARTITION <em class="replaceable"><code>partition_names</code></em> INTO (<em class="replaceable"><code>partition_definitions</code></em>)
  | EXCHANGE PARTITION <em class="replaceable"><code>partition_name</code></em> WITH TABLE <em class="replaceable"><code>tbl_name</code></em> [{WITH|WITHOUT} VALIDATION]
  | ANALYZE PARTITION {<em class="replaceable"><code>partition_names</code></em> | ALL}
  | CHECK PARTITION {<em class="replaceable"><code>partition_names</code></em> | ALL}
  | OPTIMIZE PARTITION {<em class="replaceable"><code>partition_names</code></em> | ALL}
  | REBUILD PARTITION {<em class="replaceable"><code>partition_names</code></em> | ALL}
  | REPAIR PARTITION {<em class="replaceable"><code>partition_names</code></em> | ALL}
  | REMOVE PARTITIONING
  | UPGRADE PARTITIONING

<em class="replaceable"><code>key_part</code></em>:
    <em class="replaceable"><code>col_name</code></em> [(<em class="replaceable"><code>length</code></em>)] [ASC | DESC]

<em class="replaceable"><code>index_type</code></em>:
    USING {BTREE | HASH}

<em class="replaceable"><code>index_option</code></em>:
    KEY_BLOCK_SIZE [=] <em class="replaceable"><code>value</code></em>
  | <em class="replaceable"><code>index_type</code></em>
  | WITH PARSER <em class="replaceable"><code>parser_name</code></em>
  | COMMENT '<em class="replaceable"><code>string</code></em>'

<em class="replaceable"><code>table_options</code></em>:
    <em class="replaceable"><code>table_option</code></em> [[,] <em class="replaceable"><code>table_option</code></em>] ...

<em class="replaceable"><code>table_option</code></em>:
    AUTO_INCREMENT [=] <em class="replaceable"><code>value</code></em>
  | AVG_ROW_LENGTH [=] <em class="replaceable"><code>value</code></em>
  | [DEFAULT] CHARACTER SET [=] <em class="replaceable"><code>charset_name</code></em>
  | CHECKSUM [=] {0 | 1}
  | [DEFAULT] COLLATE [=] <em class="replaceable"><code>collation_name</code></em>
  | COMMENT [=] '<em class="replaceable"><code>string</code></em>'
  | COMPRESSION [=] {'ZLIB'|'LZ4'|'NONE'}
  | CONNECTION [=] '<em class="replaceable"><code>connect_string</code></em>'
  | {DATA|INDEX} DIRECTORY [=] '<em class="replaceable"><code>absolute path to directory</code></em>'
  | DELAY_KEY_WRITE [=] {0 | 1}
  | ENCRYPTION [=] {'Y' | 'N'}
  | ENGINE [=] <em class="replaceable"><code>engine_name</code></em>
  | INSERT_METHOD [=] { NO | FIRST | LAST }
  | KEY_BLOCK_SIZE [=] <em class="replaceable"><code>value</code></em>
  | MAX_ROWS [=] <em class="replaceable"><code>value</code></em>
  | MIN_ROWS [=] <em class="replaceable"><code>value</code></em>
  | PACK_KEYS [=] {0 | 1 | DEFAULT}
  | PASSWORD [=] '<em class="replaceable"><code>string</code></em>'
  | ROW_FORMAT [=] {DEFAULT|DYNAMIC|FIXED|COMPRESSED|REDUNDANT|COMPACT}
  | STATS_AUTO_RECALC [=] {DEFAULT|0|1}
  | STATS_PERSISTENT [=] {DEFAULT|0|1}
  | STATS_SAMPLE_PAGES [=] <em class="replaceable"><code>value</code></em>
  | TABLESPACE <em class="replaceable"><code>tablespace_name</code></em> [STORAGE {DISK|MEMORY}]
  | UNION [=] (<em class="replaceable"><code>tbl_name</code></em>[,<em class="replaceable"><code>tbl_name</code></em>]...)

<em class="replaceable"><code>partition_options</code></em>:
    (see <a class="link" href="sql-syntax.html#create-table" title="13.1.18&nbsp;CREATE TABLE Syntax"><code class="literal">CREATE TABLE</code></a> options)
</pre><p>
            <a class="link" href="sql-syntax.html#alter-table" title="13.1.8&nbsp;ALTER TABLE Syntax"><code class="literal">ALTER TABLE</code></a> changes the structure
            of a table. For example, you can add or delete columns, create or
            destroy indexes, change the type of existing columns, or rename
            columns or the table itself. You can also change characteristics
            such as the storage engine used for the table or the table
            comment.
        </p><p style="color:blue;">alter table更改表的结构。例如，可以添加或删除列、创建或销毁索引、更改现有列的类型、或重命名列或表本身。还可以更改特性，例如用于表或表注释的存储引擎。</p>
            <div class="itemizedlist">
                <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                    To use <a class="link" href="sql-syntax.html#alter-table" title="13.1.8&nbsp;ALTER TABLE Syntax"><code class="literal">ALTER TABLE</code></a>, you need
                    <a class="link" href="security.html#priv_alter"><code class="literal">ALTER</code></a>,
                    <a class="link" href="security.html#priv_create"><code class="literal">CREATE</code></a>, and
                    <a class="link" href="security.html#priv_insert"><code class="literal">INSERT</code></a> privileges for the
                    table. Renaming a table requires
                    <a class="link" href="security.html#priv_alter"><code class="literal">ALTER</code></a> and
                    <a class="link" href="security.html#priv_drop"><code class="literal">DROP</code></a> on the old table,
                    <a class="link" href="security.html#priv_alter"><code class="literal">ALTER</code></a>,
                    <a class="link" href="security.html#priv_create"><code class="literal">CREATE</code></a>, and
                    <a class="link" href="security.html#priv_insert"><code class="literal">INSERT</code></a> on the new table.
                </p><p style="color:blue;">要使用alter table，您需要表的alter、create和insert权限。重命名表需要对旧表执行alter和drop操作，对新表执行alter、create和insert操作。</p></li><li class="listitem"><p>
                    Following the table name, specify the alterations to be made.
                    If none are given, <a class="link" href="sql-syntax.html#alter-table" title="13.1.8&nbsp;ALTER TABLE Syntax"><code class="literal">ALTER TABLE</code></a>
                    does nothing.
                </p><p style="color:blue;">在表名之后，指定要进行的更改。如果没有给出，alter table将不执行任何操作。</p></li><li class="listitem"><p>
                    The syntax for many of the permissible alterations is similar
                    to clauses of the <a class="link" href="sql-syntax.html#create-table" title="13.1.18&nbsp;CREATE TABLE Syntax"><code class="literal">CREATE TABLE</code></a>
                    statement. <em class="replaceable"><code>column_definition</code></em>
                    clauses use the same syntax for <code class="literal">ADD</code> and
                    <code class="literal">CHANGE</code> as for <a class="link" href="sql-syntax.html#create-table" title="13.1.18&nbsp;CREATE TABLE Syntax"><code class="literal">CREATE
                    TABLE</code></a>. For more information, see
                    <a class="xref" href="sql-syntax.html#create-table" title="13.1.18&nbsp;CREATE TABLE Syntax">Section&nbsp;13.1.18, “CREATE TABLE Syntax”</a>.
                </p><p style="color:blue;">许多允许的更改的语法与CREATETABLE语句的子句类似。column_definition子句使用与create table相同的语法进行添加和更改。有关更多信息，请参见第13.1.18节“创建表语法”。</p></li><li class="listitem"><p>
                    The word <code class="literal">COLUMN</code> is optional and can be
                    omitted.
                </p><p style="color:blue;">word列是可选的，可以省略。</p></li><li class="listitem"><p>
                    Multiple <code class="literal">ADD</code>, <code class="literal">ALTER</code>,
                    <code class="literal">DROP</code>, and <code class="literal">CHANGE</code> clauses
                    are permitted in a single <a class="link" href="sql-syntax.html#alter-table" title="13.1.8&nbsp;ALTER TABLE Syntax"><code class="literal">ALTER
                    TABLE</code></a> statement, separated by commas. This is a
                    MySQL extension to standard SQL, which permits only one of
                    each clause per <a class="link" href="sql-syntax.html#alter-table" title="13.1.8&nbsp;ALTER TABLE Syntax"><code class="literal">ALTER TABLE</code></a>
                    statement. For example, to drop multiple columns in a single
                    statement, do this:
                </p><p style="color:blue;">允许在单个alter table语句中使用多个add、alter、drop和change子句，并用逗号分隔。这是标准sql的mysql扩展，每个alter table语句只允许一个子句。例如，要在单个语句中删除多个列，请执行以下操作：</p><pre data-lang="sql" class="programlisting">ALTER TABLE t2 DROP COLUMN c, DROP COLUMN d;
</pre></li><li class="listitem"><p>
                    If a storage engine does not support an attempted
                    <a class="link" href="sql-syntax.html#alter-table" title="13.1.8&nbsp;ALTER TABLE Syntax"><code class="literal">ALTER TABLE</code></a> operation, a
                    warning may result. Such warnings can be displayed with
                    <a class="link" href="sql-syntax.html#show-warnings" title="13.7.5.40&nbsp;SHOW WARNINGS Syntax"><code class="literal">SHOW WARNINGS</code></a>. See
                    <a class="xref" href="sql-syntax.html#show-warnings" title="13.7.5.40&nbsp;SHOW WARNINGS Syntax">Section&nbsp;13.7.5.40, “SHOW WARNINGS Syntax”</a>. For information on
                    troubleshooting <a class="link" href="sql-syntax.html#alter-table" title="13.1.8&nbsp;ALTER TABLE Syntax"><code class="literal">ALTER TABLE</code></a>,
                    see <a class="xref" href="error-handling.html#alter-table-problems" title="B.4.6.1&nbsp;Problems with ALTER TABLE">Section&nbsp;B.4.6.1, “Problems with ALTER TABLE”</a>.
                </p><p style="color:blue;">如果存储引擎不支持尝试的alter table操作，则可能会导致警告。此类警告可以与“显示警告”一起显示。见第13.7.5.40节“显示警告语法”。有关alter table故障排除的信息，请参阅第B.4.6.1节“alter table的问题”。</p></li><li class="listitem"><p>
                    For information about generated columns, see
                    <a class="xref" href="sql-syntax.html#alter-table-generated-columns" title="13.1.8.2&nbsp;ALTER TABLE and Generated Columns">Section&nbsp;13.1.8.2, “ALTER TABLE and Generated Columns”</a>.
                </p><p style="color:blue;">有关生成列的信息，请参阅第13.1.8.2节“更改表和生成列”。</p></li><li class="listitem"><p>
                    For usage examples, see
                    <a class="xref" href="sql-syntax.html#alter-table-examples" title="13.1.8.3&nbsp;ALTER TABLE Examples">Section&nbsp;13.1.8.3, “ALTER TABLE Examples”</a>.
                </p><p style="color:blue;">有关用法示例，请参见第13.1.8.3节“更改表示例”。</p></li><li class="listitem"><p>
                    With the <a class="link" href="connectors-apis.html#mysql-info" title="27.8.7.36&nbsp;mysql_info()"><code class="literal">mysql_info()</code></a> C API
                    function, you can find out how many rows were copied by
                    <a class="link" href="sql-syntax.html#alter-table" title="13.1.8&nbsp;ALTER TABLE Syntax"><code class="literal">ALTER TABLE</code></a>. See
                    <a class="xref" href="connectors-apis.html#mysql-info" title="27.8.7.36&nbsp;mysql_info()">Section&nbsp;27.8.7.36, “mysql_info()”</a>.
                </p><p style="color:blue;">使用mysql_info（）c api函数，您可以了解alter table复制了多少行。见27.8.7.36节，“mysql_info（）”。</p><a class="indexterm" name="idm140286841476960"></a></li></ul>
            </div>
            <p>
                There are several additional aspects to the <code class="literal">ALTER
                TABLE</code> statement, described under the following topics in
                this section:
            </p><p style="color:blue;">alter table语句还有几个其他方面，在本节的以下主题中进行了描述：</p>
            <div class="itemizedlist">
                <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><a class="xref" href="sql-syntax.html#alter-table-options" title="Table Options">Table Options</a></p><p style="color:blue;">表格选项</p></li><li class="listitem"><p><a class="xref" href="sql-syntax.html#alter-table-performance" title="Performance and Space Requirements">Performance and Space Requirements</a></p><p style="color:blue;">性能和空间要求</p></li><li class="listitem"><p><a class="xref" href="sql-syntax.html#alter-table-concurrency" title="Concurrency Control">Concurrency Control</a></p><p style="color:blue;">并发控制</p></li><li class="listitem"><p><a class="xref" href="sql-syntax.html#alter-table-add-drop-column" title="Adding and Dropping Columns">Adding and Dropping Columns</a></p><p style="color:blue;">添加和删除列</p></li><li class="listitem"><p><a class="xref" href="sql-syntax.html#alter-table-redefine-column" title="Renaming, Redefining, and Reordering Columns">Renaming, Redefining, and Reordering Columns</a></p><p style="color:blue;">重命名、重新定义和重新排序列</p></li><li class="listitem"><p><a class="xref" href="sql-syntax.html#alter-table-index" title="Primary Keys and Indexes">Primary Keys and Indexes</a></p><p style="color:blue;">主键和索引</p></li><li class="listitem"><p><a class="xref" href="sql-syntax.html#alter-table-foreign-key" title="Foreign Keys and Other Constraints">Foreign Keys and Other Constraints</a></p><p style="color:blue;">外键和其他约束</p></li><li class="listitem"><p><a class="xref" href="sql-syntax.html#alter-table-character-set" title="Changing the Character Set">Changing the Character Set</a></p><p style="color:blue;">更改字符集</p></li><li class="listitem"><p><a class="xref" href="sql-syntax.html#alter-table-discard-import" title="Discarding and Importing InnoDB Tablespaces">Discarding and Importing InnoDB Tablespaces</a></p><p style="color:blue;">丢弃和导入innodb表空间</p></li><li class="listitem"><p><a class="xref" href="sql-syntax.html#alter-table-row-order" title="Row Order for MyISAM Tables">Row Order for MyISAM Tables</a></p><p style="color:blue;">myisam表的行顺序</p></li><li class="listitem"><p><a class="xref" href="sql-syntax.html#alter-table-partition-options" title="Partitioning Options">Partitioning Options</a></p><p style="color:blue;">分区选项</p></li></ul>
            </div>
            <h4><a name="alter-table-options"></a>Table Options</h4>
            <p>
                <em class="replaceable"><code>table_options</code></em> signifies table options
                of the kind that can be used in the <a class="link" href="sql-syntax.html#create-table" title="13.1.18&nbsp;CREATE TABLE Syntax"><code class="literal">CREATE
                TABLE</code></a> statement, such as <code class="literal">ENGINE</code>,
                <code class="literal">AUTO_INCREMENT</code>,
                <code class="literal">AVG_ROW_LENGTH</code>, <code class="literal">MAX_ROWS</code>,
                <code class="literal">ROW_FORMAT</code>, or <code class="literal">TABLESPACE</code>.
            </p><p style="color:blue;">table_options表示可以在create table语句中使用的表选项，例如engine、auto_increment、avg_row_length、max_rows、row_format或tablespace。</p><p>
            For descriptions of all table options, see
            <a class="xref" href="sql-syntax.html#create-table" title="13.1.18&nbsp;CREATE TABLE Syntax">Section&nbsp;13.1.18, “CREATE TABLE Syntax”</a>. However,
            <a class="link" href="sql-syntax.html#alter-table" title="13.1.8&nbsp;ALTER TABLE Syntax"><code class="literal">ALTER TABLE</code></a> ignores <code class="literal">DATA
            DIRECTORY</code> and <code class="literal">INDEX DIRECTORY</code> when
            given as table options. <a class="link" href="sql-syntax.html#alter-table" title="13.1.8&nbsp;ALTER TABLE Syntax"><code class="literal">ALTER TABLE</code></a>
            permits them only as partitioning options, and, as of MySQL
            5.7.17, requires that you have the <code class="literal">FILE</code>
            privilege.
        </p><p style="color:blue;">有关所有表选项的说明，请参见第13.1.18节“创建表语法”。但是，当作为表选项提供时，alter table忽略数据目录和索引目录。alter table只允许将它们作为分区选项，并且从mysql 5.7.17开始，要求您具有文件特权。</p><p>
            Use of table options with <a class="link" href="sql-syntax.html#alter-table" title="13.1.8&nbsp;ALTER TABLE Syntax"><code class="literal">ALTER
            TABLE</code></a> provides a convenient way of altering single table
            characteristics. For example:
        </p><p style="color:blue;">将表选项与alter table一起使用提供了一种更改单表特性的方便方法。例如：</p>
            <div class="itemizedlist">
                <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                    If <code class="literal">t1</code> is currently not an
                    <code class="literal">InnoDB</code> table, this statement changes its
                    storage engine to <code class="literal">InnoDB</code>:
                </p><p style="color:blue;">如果T1当前不是InnoDB表，则此语句将其存储引擎更改为InnoDB:</p><pre data-lang="sql" class="programlisting">ALTER TABLE t1 ENGINE = InnoDB;
</pre>
                    <div class="itemizedlist">
                        <ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
                            See <a class="xref" href="innodb-storage-engine.html#converting-tables-to-innodb" title="14.6.1.3&nbsp;Converting Tables from MyISAM to InnoDB">Section&nbsp;14.6.1.3, “Converting Tables from MyISAM to InnoDB”</a> for
                            considerations when switching tables to the
                            <code class="literal">InnoDB</code> storage engine.
                        </p><p style="color:blue;">请参阅14.6.1.3节“将表从myisam转换为innodb”，了解将表切换到innodb存储引擎时的注意事项。</p></li><li class="listitem"><p>
                            When you specify an <code class="literal">ENGINE</code> clause,
                            <a class="link" href="sql-syntax.html#alter-table" title="13.1.8&nbsp;ALTER TABLE Syntax"><code class="literal">ALTER TABLE</code></a> rebuilds the
                            table. This is true even if the table already has the
                            specified storage engine.
                        </p><p style="color:blue;">指定ENGINE子句时，ALTER TABLE将重建该表。即使表已经具有指定的存储引擎，也会出现这种情况。</p></li><li class="listitem"><p>
                            Running <a class="link" href="sql-syntax.html#alter-table" title="13.1.8&nbsp;ALTER TABLE Syntax"><code class="literal">ALTER
                            TABLE <em class="replaceable"><code>tbl_name</code></em>
                            ENGINE=INNODB</code></a> on an existing
                            <code class="literal">InnoDB</code> table performs a
                            <span class="quote">“<span class="quote">null</span>”</span> <a class="link" href="sql-syntax.html#alter-table" title="13.1.8&nbsp;ALTER TABLE Syntax"><code class="literal">ALTER
                            TABLE</code></a> operation, which can be used to defragment
                            an <code class="literal">InnoDB</code> table, as described in
                            <a class="xref" href="innodb-storage-engine.html#innodb-file-defragmenting" title="14.12.4&nbsp;Defragmenting a Table">Section&nbsp;14.12.4, “Defragmenting a Table”</a>. Running
                            <a class="link" href="sql-syntax.html#alter-table" title="13.1.8&nbsp;ALTER TABLE Syntax"><code class="literal">ALTER TABLE
                                <em class="replaceable"><code>tbl_name</code></em> FORCE</code></a> on an
                            <code class="literal">InnoDB</code> table performs the same
                            function.
                        </p><p style="color:blue;">在一个现有的数据表上运行“更改表”引擎=执行一个“null”的更改表操作，该操作可用于对一个未完成的表进行碎片整理，如在第1节第1节所述的“重新编译表”中所示。对innodb表运行alter table tbl_name force执行相同的功能。</p></li><li class="listitem"><p>
                            <a class="link" href="sql-syntax.html#alter-table" title="13.1.8&nbsp;ALTER TABLE Syntax"><code class="literal">ALTER TABLE
                                <em class="replaceable"><code>tbl_name</code></em>
                                ENGINE=INNODB</code></a> and
                            <a class="link" href="sql-syntax.html#alter-table" title="13.1.8&nbsp;ALTER TABLE Syntax"><code class="literal">ALTER TABLE
                                <em class="replaceable"><code>tbl_name</code></em> FORCE</code></a> use
                            <a class="link" href="innodb-storage-engine.html#innodb-online-ddl" title="14.13&nbsp;InnoDB and Online DDL">online DDL</a>. For
                            more information, see <a class="xref" href="innodb-storage-engine.html#innodb-online-ddl" title="14.13&nbsp;InnoDB and Online DDL">Section&nbsp;14.13, “InnoDB and Online DDL”</a>.
                        </p><p style="color:blue;">alter table tbl_name engine=innodb和alter table tbl_name强制使用联机ddl。有关更多信息，请参见第14.13节“InnoDB和联机DDL”。</p></li><li class="listitem"><p>
                            The outcome of attempting to change the storage engine of
                            a table is affected by whether the desired storage engine
                            is available and the setting of the
                            <a class="link" href="server-administration.html#sqlmode_no_engine_substitution"><code class="literal">NO_ENGINE_SUBSTITUTION</code></a>
                            SQL mode, as described in <a class="xref" href="server-administration.html#sql-mode" title="5.1.10&nbsp;Server SQL Modes">Section&nbsp;5.1.10, “Server SQL Modes”</a>.
                        </p><p style="color:blue;">如第5.1.10节“服务器SQL模式”所述，试图更改表的存储引擎的结果受所需存储引擎是否可用以及无引擎替换SQL模式设置的影响。</p></li><li class="listitem"><p>
                            To prevent inadvertent loss of data,
                            <a class="link" href="sql-syntax.html#alter-table" title="13.1.8&nbsp;ALTER TABLE Syntax"><code class="literal">ALTER TABLE</code></a> cannot be used
                            to change the storage engine of a table to
                            <code class="literal">MERGE</code> or <code class="literal">BLACKHOLE</code>.
                        </p><p style="color:blue;">为了防止意外丢失数据，不能使用alter table将表的存储引擎更改为merge或blackhole。</p></li></ul>
                    </div>
                </li><li class="listitem"><p>
                    To change the <code class="literal">InnoDB</code> table to use
                    compressed row-storage format:
                </p><p style="color:blue;">要将innodb表更改为使用压缩行存储格式：</p><pre data-lang="sql" class="programlisting">ALTER TABLE t1 ROW_FORMAT = COMPRESSED;
</pre></li><li class="listitem"><p>
                    To enable or disable encryption for an
                    <code class="literal">InnoDB</code> table in a file-per-table
                    tablespace:
                </p><p style="color:blue;">要为每个表空间的文件中的innodb表启用或禁用加密：</p><pre data-lang="sql" class="programlisting">ALTER TABLE t1 ENCRYPTION='Y';
ALTER TABLE t1 ENCRYPTION='N';
</pre><p>
                    A keyring plugin must be installed and configured to use the
                    <code class="literal">ENCRYPTION</code> option. For more information,
                    see <a class="xref" href="innodb-storage-engine.html#innodb-tablespace-encryption" title="14.6.3.8&nbsp;InnoDB Data-at-Rest Encryption">Section&nbsp;14.6.3.8, “InnoDB Data-at-Rest Encryption”</a>.
                </p><p style="color:blue;">必须安装并配置密钥环插件才能使用加密选项。有关更多信息，请参阅14.6.3.8节，“InnoDB静态数据加密”。</p></li><li class="listitem"><p>
                    To reset the current auto-increment value:
                </p><p style="color:blue;">要重置当前自动增量值：</p><pre data-lang="sql" class="programlisting">ALTER TABLE t1 AUTO_INCREMENT = 13;
</pre><p>
                    You cannot reset the counter to a value less than or equal to
                    the value that is currently in use. For both
                    <code class="literal">InnoDB</code> and <code class="literal">MyISAM</code>, if
                    the value is less than or equal to the maximum value currently
                    in the <code class="literal">AUTO_INCREMENT</code> column, the value is
                    reset to the current maximum <code class="literal">AUTO_INCREMENT</code>
                    column value plus one.
                </p><p style="color:blue;">不能将计数器重置为小于或等于当前使用的值。对于NONDB和MyISAM，如果该值小于或等于当前在AutoMyPlus列中的最大值，则将该值重置为当前最大AutoY增值列值加上一个值。</p></li><li class="listitem"><p>
                    To change the default table character set:
                </p><p style="color:blue;">要更改默认表字符集，请执行以下操作：</p><pre data-lang="sql" class="programlisting">ALTER TABLE t1 CHARACTER SET = utf8;
</pre><p>
                    See also <a class="xref" href="sql-syntax.html#alter-table-character-set" title="Changing the Character Set">Changing the Character Set</a>.
                </p><p style="color:blue;">请参见更改角色集。</p></li><li class="listitem"><p>
                    To add (or change) a table comment:
                </p><p style="color:blue;">添加（或更改）表注释：</p><pre data-lang="sql" class="programlisting">ALTER TABLE t1 COMMENT = 'New table comment';
</pre></li><li class="listitem"><p>
                    Use <code class="literal">ALTER TABLE</code> with the
                    <code class="literal">TABLESPACE</code> option to move
                    <code class="literal">InnoDB</code> tables between existing
                    <a class="link" href="glossary.html#glos_general_tablespace" title="general tablespace">general
                        tablespaces</a>,
                    <a class="link" href="glossary.html#glos_file_per_table" title="file-per-table">file-per-table</a>
                    tablespaces, and the
                    <a class="link" href="glossary.html#glos_system_tablespace" title="system tablespace">system
                        tablespace</a>. See
                    <a class="xref" href="innodb-storage-engine.html#general-tablespaces-moving-non-partitioned-tables" title="Moving Tables Between Tablespaces Using ALTER TABLE">Moving Tables Between Tablespaces Using ALTER TABLE</a>.
                </p><p style="color:blue;">使用TabasSype选项的ALTER表在现有的通用表空间、每个表表空间的文件和系统表空间之间移动NYNDB表。请参阅使用alter table在表空间之间移动表。</p>
                    <div class="itemizedlist">
                        <ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
                            <code class="literal">ALTER TABLE ... TABLESPACE</code> operations
                            always cause a full table rebuild, even if the
                            <code class="literal">TABLESPACE</code> attribute has not changed
                            from its previous value.
                        </p><p style="color:blue;">更改表…表空间操作总是会导致完整的表重建，即使表空间属性与其前一个值没有更改。</p></li><li class="listitem"><p>
                            <code class="literal">ALTER TABLE ... TABLESPACE</code> syntax does
                            not support moving a table from a temporary tablespace to
                            a persistent tablespace.
                        </p><p style="color:blue;">更改表…表空间语法不支持将表从临时表空间移动到持久表空间。</p></li><li class="listitem"><p>
                            The <code class="literal">DATA DIRECTORY</code> clause, which is
                            supported with
                            <a class="link" href="sql-syntax.html#create-table" title="13.1.18&nbsp;CREATE TABLE Syntax"><code class="literal">CREATE TABLE
                                ... TABLESPACE</code></a>, is not supported with
                            <code class="literal">ALTER TABLE ... TABLESPACE</code>, and is
                            ignored if specified.
                        </p><p style="color:blue;">数据目录子句，由CREATE TABLE支持…表空间，不受alter table支持…表空间，如果指定，则忽略。</p></li><li class="listitem"><p>
                            For more information about the capabilities and
                            limitations of the <code class="literal">TABLESPACE</code> option,
                            see <a class="link" href="sql-syntax.html#create-table" title="13.1.18&nbsp;CREATE TABLE Syntax"><code class="literal">CREATE TABLE</code></a>.
                        </p><p style="color:blue;">有关“表空间”选项的功能和限制的详细信息，请参见创建表。</p></li></ul>
                    </div>
                </li><li class="listitem"><p>
                    MySQL NDB Cluster 7.5.2 and later supports setting
                    <code class="literal">NDB_TABLE</code> options for controlling a
                    table's partition balance (fragment count type),
                    read-from-any-replica capability, full replication, or any
                    combination of these, as part of the table comment for an
                    <code class="literal">ALTER TABLE</code> statement in the same manner as
                    for <a class="link" href="sql-syntax.html#create-table" title="13.1.18&nbsp;CREATE TABLE Syntax"><code class="literal">CREATE TABLE</code></a>, as shown in
                    this example:
                </p><p style="color:blue;">mysql ndb cluster 7.5.2及更高版本支持设置ndb_table选项，用于控制表的分区平衡（片段计数类型）、从任何副本功能读取、完全复制或这些功能的任何组合，作为alter table语句的表注释的一部分，其方式与create table相同，如下例所示：</p><pre data-lang="sql" class="programlisting">ALTER TABLE t1 COMMENT = "NDB_TABLE=READ_BACKUP=0,PARTITION_BALANCE=FOR_RA_BY_NODE";
</pre><p>
                    Bear in mind that <code class="literal">ALTER TABLE ... COMMENT
                    ...</code> discards any existing comment for the table. See
                    <a class="xref" href="sql-syntax.html#create-table-comment-ndb-table-options" title="Setting NDB_TABLE options">Setting NDB_TABLE options</a>, for
                    additional information and examples.
                </p><p style="color:blue;">记住，改变表…评论…丢弃表的任何现有注释。有关更多信息和示例，请参见设置ndb_表选项。</p></li></ul>
            </div>
            <p>
                To verify that the table options were changed as intended, use
                <a class="link" href="sql-syntax.html#show-create-table" title="13.7.5.10&nbsp;SHOW CREATE TABLE Syntax"><code class="literal">SHOW CREATE TABLE</code></a>, or query the
                <a class="link" href="information-schema.html#tables-table" title="24.25&nbsp;The INFORMATION_SCHEMA TABLES Table"><code class="literal">INFORMATION_SCHEMA.TABLES</code></a> table.
            </p><p style="color:blue;">要验证表选项是否按预期更改，请使用show create table或查询information_schema.tables表。</p>
            <h4><a name="alter-table-performance"></a>Performance and Space Requirements</h4>
            <p>
                <a class="link" href="sql-syntax.html#alter-table" title="13.1.8&nbsp;ALTER TABLE Syntax"><code class="literal">ALTER TABLE</code></a> operations are
                processed using one of the following algorithms:
            </p><p style="color:blue;">使用以下算法之一处理alter table操作：</p>
            <div class="itemizedlist">
                <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                    <code class="literal">COPY</code>: Operations are performed on a copy of
                    the original table, and table data is copied from the original
                    table to the new table row by row. Concurrent DML is not
                    permitted.
                </p><p style="color:blue;">复制：对原表进行复制操作，逐行将原表中的表数据复制到新表中。不允许并发DML。</p></li><li class="listitem"><p>
                    <code class="literal">INPLACE</code>: Operations avoid copying table
                    data but may rebuild the table in place. An exclusive metadata
                    lock on the table may be taken briefly during preparation and
                    execution phases of the operation. Typically, concurrent DML
                    is supported.
                </p><p style="color:blue;">就地：操作避免复制表数据，但可能就地重建表。在操作的准备和执行阶段，表上的独占元数据锁可能会被短暂地占用。通常，支持并发dml。</p></li></ul>
            </div>
            <p>
                The <code class="literal">ALGORITHM</code> clause is optional. If the
                <code class="literal">ALGORITHM</code> clause is omitted, MySQL uses
                <code class="literal">ALGORITHM=INPLACE</code> for storage engines and
                <a class="link" href="sql-syntax.html#alter-table" title="13.1.8&nbsp;ALTER TABLE Syntax"><code class="literal">ALTER TABLE</code></a> clauses that support
                it. Otherwise, <code class="literal">ALGORITHM=COPY</code> is used.
            </p><p style="color:blue;">算法子句是可选的。如果省略了algorithm子句，mysql将algorithm=inplace用于存储引擎，并更改支持它的表子句。否则，使用algorithm=copy。</p><p>
            Specifying an <code class="literal">ALGORITHM</code> clause requires the
            operation to use the specified algorithm for clauses and storage
            engines that support it, or fail with an error otherwise.
            Specifying <code class="literal">ALGORITHM=DEFAULT</code> is the same as
            omitting the <code class="literal">ALGORITHM</code> clause.
        </p><p style="color:blue;">指定算法子句要求操作对支持它的子句和存储引擎使用指定的算法，否则将失败并出现错误。指定algorithm=default与省略algorithm子句相同。</p><p>
            <a class="link" href="sql-syntax.html#alter-table" title="13.1.8&nbsp;ALTER TABLE Syntax"><code class="literal">ALTER TABLE</code></a> operations that use the
            <code class="literal">COPY</code> algorithm wait for other operations that
            are modifying the table to complete. After alterations are applied
            to the table copy, data is copied over, the original table is
            deleted, and the table copy is renamed to the name of the original
            table. While the <a class="link" href="sql-syntax.html#alter-table" title="13.1.8&nbsp;ALTER TABLE Syntax"><code class="literal">ALTER TABLE</code></a>
            operation executes, the original table is readable by other
            sessions (with the exception noted shortly). Updates and writes to
            the table started after the <a class="link" href="sql-syntax.html#alter-table" title="13.1.8&nbsp;ALTER TABLE Syntax"><code class="literal">ALTER
            TABLE</code></a> operation begins are stalled until the new table
            is ready, then are automatically redirected to the new table. The
            temporary copy of the table is created in the database directory
            of the original table unless it is a <code class="literal">RENAME TO</code>
            operation that moves the table to a database that resides in a
            different directory.
        </p><p style="color:blue;">使用复制算法的alter table操作等待修改表的其他操作完成。对表副本应用更改后，将复制数据，删除原始表，并将表副本重命名为原始表的名称。在执行alter table操作时，其他会话可以读取原始表（稍后会注意到例外情况）。在alter table操作开始后开始的对表的更新和写入将暂停，直到新表准备就绪，然后自动重定向到新表。表的临时副本是在原始表的数据库目录中创建的，除非它是将表移动到位于其他目录中的数据库的重命名为操作。</p><p>
            The exception referred to earlier is that
            <a class="link" href="sql-syntax.html#alter-table" title="13.1.8&nbsp;ALTER TABLE Syntax"><code class="literal">ALTER TABLE</code></a> blocks reads (not just
            writes) at the point where it is ready to install a new version of
            the table <code class="filename">.frm</code> file, discard the old file,
            and clear outdated table structures from the table and table
            definition caches. At this point, it must acquire an exclusive
            lock. To do so, it waits for current readers to finish, and blocks
            new reads and writes.
        </p><p style="color:blue;">前面提到的异常是，alter table块在准备安装新版本的table.frm文件、放弃旧文件以及从表和表定义缓存中清除过时的表结构时读取（而不仅仅是写入）。此时，它必须获得一个独占锁。为此，它会等待当前读卡器完成，并阻止新的读写操作。</p><p>
            An <a class="link" href="sql-syntax.html#alter-table" title="13.1.8&nbsp;ALTER TABLE Syntax"><code class="literal">ALTER TABLE</code></a> operation that uses
            the <code class="literal">COPY</code> algorithm prevents concurrent DML
            operations. Concurrent queries are still allowed. That is, a
            table-copying operation always includes at least the concurrency
            restrictions of <code class="literal">LOCK=SHARED</code> (allow queries but
            not DML). You can further restrict concurrency for operations that
            support the <code class="literal">LOCK</code> clause by specifying
            <code class="literal">LOCK=EXCLUSIVE</code>, which prevents DML and queries.
            For more information, see
            <a class="xref" href="sql-syntax.html#alter-table-concurrency" title="Concurrency Control">Concurrency Control</a>.
        </p><p style="color:blue;">使用复制算法的alter table操作可防止并发dml操作。仍然允许并发查询。也就是说，表复制操作始终至少包含lock=shared（允许查询，但不包括dml）的并发限制。您可以通过指定lock=exclusive进一步限制支持lock子句的操作的并发性，这将阻止dml和查询。有关详细信息，请参阅并发控制。</p><p>
            To force use of the <code class="literal">COPY</code> algorithm for an
            <a class="link" href="sql-syntax.html#alter-table" title="13.1.8&nbsp;ALTER TABLE Syntax"><code class="literal">ALTER TABLE</code></a> operation that would
            otherwise not use it, enable the
            <a class="link" href="server-administration.html#sysvar_old_alter_table"><code class="literal">old_alter_table</code></a> system variable
            or specify <code class="literal">ALGORITHM=COPY</code>. If there is a
            conflict between the <code class="literal">old_alter_table</code> setting
            and an <code class="literal">ALGORITHM</code> clause with a value other than
            <code class="literal">DEFAULT</code>, the <code class="literal">ALGORITHM</code>
            clause takes precedence.
        </p><p style="color:blue;">若要强制将复制算法用于不使用它的alter table操作，请启用旧的alter table系统变量或指定algorithm=copy。如果旧的alter_表设置与值不是default的algorithm子句之间存在冲突，则优先使用algorithm子句。</p><p>
            For <code class="literal">InnoDB</code> tables, an
            <a class="link" href="sql-syntax.html#alter-table" title="13.1.8&nbsp;ALTER TABLE Syntax"><code class="literal">ALTER TABLE</code></a> operation that uses the
            <code class="literal">COPY</code> algorithm on a table that resides in a
            <a class="link" href="glossary.html#glos_shared_tablespace" title="shared tablespace">shared tablespace</a>
            can increase the amount of space used by the tablespace. Such
            operations require as much additional space as the data in the
            table plus indexes. For a table residing in a shared tablespace,
            the additional space used during the operation is not released
            back to the operating system as it is for a table that resides in
            a <a class="link" href="glossary.html#glos_file_per_table" title="file-per-table">file-per-table</a>
            tablespace.
        </p><p style="color:blue;">对于innodb tables，在共享表空间中的表上使用copy算法的alter table操作可以增加表空间使用的空间量。这样的操作需要的额外空间与表中的数据加上索引一样多。对于驻留在共享表空间中的表，在操作期间使用的额外空间不会释放回操作系统，因为对于驻留在每个表表空间的文件中的表，则不会释放回操作系统。</p><p>
            For information about space requirements for online DDL
            operations, see
            <a class="xref" href="innodb-storage-engine.html#innodb-online-ddl-space-requirements" title="14.13.3&nbsp;Online DDL Space Requirements">Section&nbsp;14.13.3, “Online DDL Space Requirements”</a>.
        </p><p style="color:blue;">有关联机DDL操作的空间要求的信息，请参阅第14.13.3节“联机DDL空间要求”。</p><p>
            <a class="link" href="sql-syntax.html#alter-table" title="13.1.8&nbsp;ALTER TABLE Syntax"><code class="literal">ALTER TABLE</code></a> operations that use the
            <code class="literal">INPLACE</code> algorithm include:
        </p><p style="color:blue;">使用inplace算法的alter table操作包括：</p>
            <div class="itemizedlist">
                <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                    <code class="literal">ALTER TABLE</code> operations supported by the
                    <code class="literal">InnoDB</code>
                    <a class="link" href="glossary.html#glos_online_ddl" title="online DDL">online DDL</a> feature. See
                    <a class="xref" href="innodb-storage-engine.html#innodb-online-ddl-operations" title="14.13.1&nbsp;Online DDL Operations">Section&nbsp;14.13.1, “Online DDL Operations”</a>.
                </p><p style="color:blue;">更改innodb online ddl特性支持的表操作。见第14.13.1节“在线DDL操作”。</p></li><li class="listitem"><p>
                    Renaming a table. MySQL renames files that correspond to the
                    table <em class="replaceable"><code>tbl_name</code></em> without making a
                    copy. (You can also use the <a class="link" href="sql-syntax.html#rename-table" title="13.1.33&nbsp;RENAME TABLE Syntax"><code class="literal">RENAME
                    TABLE</code></a> statement to rename tables. See
                    <a class="xref" href="sql-syntax.html#rename-table" title="13.1.33&nbsp;RENAME TABLE Syntax">Section&nbsp;13.1.33, “RENAME TABLE Syntax”</a>.) Privileges granted
                    specifically for the renamed table are not migrated to the new
                    name. They must be changed manually.
                </p><p style="color:blue;">重命名表。mysql重命名与表tbl_name相对应的文件，而不进行复制。（也可以使用rename table语句重命名表。请参阅13.1.33节，“重命名表语法”。）专门为重命名的表授予的权限不会迁移到新名称。必须手动更改它们。</p></li><li class="listitem"><p>
                    Operations that only modify table metadata. These operations
                    are immediate because the server only alters the table
                    <code class="filename">.frm</code> file, not touch table contents.
                    Metadata-only operations include:
                </p><p style="color:blue;">只修改表元数据的操作。这些操作是立即执行的，因为服务器只更改table.frm文件，而不更改table内容。仅元数据操作包括：</p>
                    <div class="itemizedlist">
                        <ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
                            Renaming a column.
                        </p><p style="color:blue;">重命名列。</p></li><li class="listitem"><p>
                            Changing the default value of a column (except for
                            <a class="link" href="mysql-cluster.html" title="Chapter&nbsp;21&nbsp;MySQL NDB Cluster 7.5 and NDB Cluster 7.6"><code class="literal">NDB</code></a> tables).
                        </p><p style="color:blue;">更改列的默认值（ndb表除外）。</p></li><li class="listitem"><p>
                            Modifying the definition of an
                            <a class="link" href="data-types.html#enum" title="11.4.4&nbsp;The ENUM Type"><code class="literal">ENUM</code></a> or
                            <a class="link" href="data-types.html#set" title="11.4.5&nbsp;The SET Type"><code class="literal">SET</code></a> column by adding new
                            enumeration or set members to the <span class="emphasis"><em>end</em></span>
                            of the list of valid member values, as long as the storage
                            size of the data type does not change. For example, adding
                            a member to a <a class="link" href="data-types.html#set" title="11.4.5&nbsp;The SET Type"><code class="literal">SET</code></a> column
                            that has 8 members changes the required storage per value
                            from 1 byte to 2 bytes; this requires a table copy. Adding
                            members in the middle of the list causes renumbering of
                            existing members, which requires a table copy.
                        </p><p style="color:blue;">通过在有效成员值列表的末尾添加新的枚举或集合成员来修改枚举或集合列的定义，只要数据类型的存储大小不变。例如，将一个成员添加到具有8个成员的集合列会将每个值所需的存储从1字节更改为2字节；这需要一个表副本。在列表中间添加成员会导致现有成员重新编号，这需要表复制。</p></li></ul>
                    </div>
                </li><li class="listitem"><p>
                    Renaming an index.
                </p><p style="color:blue;">重命名索引。</p></li><li class="listitem"><p>
                    Adding or dropping a secondary index, for
                    <a class="link" href="innodb-storage-engine.html" title="Chapter&nbsp;14&nbsp;The InnoDB Storage Engine"><code class="literal">InnoDB</code></a> and
                    <a class="link" href="mysql-cluster.html" title="Chapter&nbsp;21&nbsp;MySQL NDB Cluster 7.5 and NDB Cluster 7.6"><code class="literal">NDB</code></a> tables. See
                    <a class="ulink" href="https://dev.mysql.com/doc/refman/5.5/en/innodb-create-index.html" target="_top">InnoDB Fast Index Creation</a>.
                </p><p style="color:blue;">添加或删除innodb和ndb表的辅助索引。请参阅innodb快速索引创建。</p></li><li class="listitem"><p>
                    For <a class="link" href="mysql-cluster.html" title="Chapter&nbsp;21&nbsp;MySQL NDB Cluster 7.5 and NDB Cluster 7.6"><code class="literal">NDB</code></a> tables, operations that
                    add and drop indexes on variable-width columns. These
                    operations occur online, without table copying and without
                    blocking concurrent DML actions for most of their duration.
                    See <a class="xref" href="mysql-cluster.html#mysql-cluster-online-operations" title="21.5.14&nbsp;Online Operations with ALTER TABLE in NDB Cluster">Section&nbsp;21.5.14, “Online Operations with ALTER TABLE in NDB Cluster”</a>.
                </p><p style="color:blue;">对于ndb表，在可变宽度列上添加和删除索引的操作。这些操作在线进行，没有表复制，也没有在大多数时间内阻止并发的dml操作。参见21.5.14节，“使用ndb集群中的alter table进行在线操作”。</p></li></ul>
            </div>
            <p>
                <a class="link" href="sql-syntax.html#alter-table" title="13.1.8&nbsp;ALTER TABLE Syntax"><code class="literal">ALTER TABLE</code></a> upgrades MySQL 5.5
                temporal columns to 5.6 format for <code class="literal">ADD COLUMN</code>,
                <code class="literal">CHANGE COLUMN</code>, <code class="literal">MODIFY
                COLUMN</code>, <code class="literal">ADD INDEX</code>, and
                <code class="literal">FORCE</code> operations. This conversion cannot be
                done using the <code class="literal">INPLACE</code> algorithm because the
                table must be rebuilt, so specifying
                <code class="literal">ALGORITHM=INPLACE</code> in these cases results in an
                error. Specify <code class="literal">ALGORITHM=COPY</code> if necessary.
            </p><p style="color:blue;">alter table将mysql 5.5临时列升级为5.6格式，用于添加列、更改列、修改列、添加索引和强制操作。此转换无法使用inplace算法完成，因为必须重建表，因此在这些情况下指定algorithm=inplace将导致错误。如有必要，指定algorithm=copy。</p><p>
            If an <code class="literal">ALTER TABLE</code> operation on a multicolumn
            index used to partition a table by <code class="literal">KEY</code> changes
            the order of the columns, it can only be performed using
            <code class="literal">ALGORITHM=COPY</code>.
        </p><p style="color:blue;">如果对用于按键分区表的多列索引执行的alter table操作更改了列的顺序，则只能使用algorithm=copy执行该操作。</p><p>
            The <code class="literal">WITHOUT VALIDATION</code> and <code class="literal">WITH
            VALIDATION</code> clauses affect whether
            <a class="link" href="sql-syntax.html#alter-table" title="13.1.8&nbsp;ALTER TABLE Syntax"><code class="literal">ALTER TABLE</code></a> performs an in-place
            operation for
            <a class="link" href="glossary.html#glos_virtual_generated_column" title="virtual generated column">virtual generated
                column</a> modifications. See
            <a class="xref" href="sql-syntax.html#alter-table-generated-columns" title="13.1.8.2&nbsp;ALTER TABLE and Generated Columns">Section&nbsp;13.1.8.2, “ALTER TABLE and Generated Columns”</a>.
        </p><p style="color:blue;">without validation和withvalidation子句影响alter table是否对虚拟生成的列修改执行就地操作。参见第13.1.8.2节“更改表和生成的列”。</p><p>
            NDB Cluster formerly supported online <code class="literal">ALTER
            TABLE</code> operations using the <code class="literal">ONLINE</code> and
            <code class="literal">OFFLINE</code> keywords. These keywords are no longer
            supported; their use causes a syntax error. MySQL NDB Cluster 7.5
            (and later) supports online operations using the same
            <code class="literal">ALGORITHM=INPLACE</code> syntax used with the standard
            MySQL Server. See
            <a class="xref" href="mysql-cluster.html#mysql-cluster-online-operations" title="21.5.14&nbsp;Online Operations with ALTER TABLE in NDB Cluster">Section&nbsp;21.5.14, “Online Operations with ALTER TABLE in NDB Cluster”</a>, for more
            information.
        </p><p style="color:blue;">ndb集群以前支持使用online和offline关键字进行联机alter表操作。不再支持这些关键字；它们的使用会导致语法错误。mysql ndb cluster 7.5（及更高版本）支持使用与标准mysql服务器相同的algorithm=inplace语法进行联机操作。有关更多信息，请参阅21.5.14节，“使用ndb集群中的alter table进行联机操作”。</p><p>
            <code class="literal">ALTER TABLE</code> with <code class="literal">DISCARD ... PARTITION
            ... TABLESPACE</code> or <code class="literal">IMPORT ... PARTITION ...
            TABLESPACE</code> does not create any temporary tables or
            temporary partition files.
        </p><p style="color:blue;">使用“放弃”更改表…分割…表空间或导入…分割…表空间不创建任何临时表或临时分区文件。</p><p>
            <code class="literal">ALTER TABLE</code> with <code class="literal">ADD
            PARTITION</code>, <code class="literal">DROP PARTITION</code>,
            <code class="literal">COALESCE PARTITION</code>, <code class="literal">REBUILD
            PARTITION</code>, or <code class="literal">REORGANIZE PARTITION</code>
            does not create temporary tables (except when used with
            <a class="link" href="mysql-cluster.html" title="Chapter&nbsp;21&nbsp;MySQL NDB Cluster 7.5 and NDB Cluster 7.6"><code class="literal">NDB</code></a> tables); however, these
            operations can and do create temporary partition files.
        </p><p style="color:blue;">使用添加分区、删除分区、合并分区、重建分区或重新组织分区来更改表不会创建临时表（除非与NDB表一起使用）；但是，这些操作可以创建临时分区文件。</p><p>
            <code class="literal">ADD</code> or <code class="literal">DROP</code> operations for
            <code class="literal">RANGE</code> or <code class="literal">LIST</code> partitions are
            immediate operations or nearly so. <code class="literal">ADD</code> or
            <code class="literal">COALESCE</code> operations for <code class="literal">HASH</code>
            or <code class="literal">KEY</code> partitions copy data between all
            partitions, unless <code class="literal">LINEAR HASH</code> or
            <code class="literal">LINEAR KEY</code> was used; this is effectively the
            same as creating a new table, although the <code class="literal">ADD</code>
            or <code class="literal">COALESCE</code> operation is performed partition by
            partition. <code class="literal">REORGANIZE</code> operations copy only
            changed partitions and do not touch unchanged ones.
        </p><p style="color:blue;">范围分区或列表分区的添加或删除操作是立即操作或几乎如此。哈希或键分区的添加或合并操作在所有分区之间复制数据，除非使用了线性哈希或线性键；这实际上与创建新表相同，尽管添加或合并操作是按分区执行的。重新组织操作只复制已更改的分区，而不接触未更改的分区。</p><p>
            For <code class="literal">MyISAM</code> tables, you can speed up index
            re-creation (the slowest part of the alteration process) by
            setting the
            <a class="link" href="server-administration.html#sysvar_myisam_sort_buffer_size"><code class="literal">myisam_sort_buffer_size</code></a> system
            variable to a high value.
        </p><p style="color:blue;">对于myisam表，可以通过将myisam sort_buffer_size系统变量设置为高值来加快索引重新创建（更改过程中最慢的部分）。</p>
            <h4><a name="alter-table-concurrency"></a>Concurrency Control</h4>
            <p>
                For <a class="link" href="sql-syntax.html#alter-table" title="13.1.8&nbsp;ALTER TABLE Syntax"><code class="literal">ALTER TABLE</code></a> operations that
                support it, you can use the <code class="literal">LOCK</code> clause to
                control the level of concurrent reads and writes on a table while
                it is being altered. Specifying a non-default value for this
                clause enables you to require a certain amount of concurrent
                access or exclusivity during the alter operation, and halts the
                operation if the requested degree of locking is not available. The
                parameters for the <code class="literal">LOCK</code> clause are:
            </p><p style="color:blue;">对于支持它的alter table操作，可以使用lock子句来控制表在被更改时的并发读写级别。为该子句指定一个非默认值可以使您在alter操作期间要求一定数量的并发访问或独占性，如果请求的锁定程度不可用，则停止该操作。lock子句的参数是：</p>
            <div class="itemizedlist">
                <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                </p><pre data-lang="sql" class="programlisting">LOCK = DEFAULT
</pre><p>

                    Maximum level of concurrency for the given
                    <code class="literal">ALGORITHM</code> clause (if any) and
                    <code class="literal">ALTER TABLE</code> operation: Permit concurrent
                    reads and writes if supported. If not, permit concurrent reads
                    if supported. If not, enforce exclusive access.
                </p><p style="color:blue;">给定算法子句（如果有的话）和ALTE表操作的最大并发级别：如果支持，允许并发读写。如果不支持，则允许并发读取（如果支持）。否则，强制独占访问。</p></li><li class="listitem"><p>
                </p><pre data-lang="sql" class="programlisting">LOCK = NONE
</pre><p>

                    If supported, permit concurrent reads and writes. Otherwise,
                    an error occurs.
                </p><p style="color:blue;">如果支持，则允许并发读写。否则，将发生错误。</p></li><li class="listitem"><p>
                </p><pre data-lang="sql" class="programlisting">LOCK = SHARED
</pre><p>

                    If supported, permit concurrent reads but block writes. Writes
                    are blocked even if concurrent writes are supported by the
                    storage engine for the given <code class="literal">ALGORITHM</code>
                    clause (if any) and <code class="literal">ALTER TABLE</code> operation.
                    If concurrent reads are not supported, an error occurs.
                </p><p style="color:blue;">如果支持，则允许并发读取，但允许块写入。即使存储引擎为给定的算法子句（如果有）和alter table操作支持并发写入，也会阻止写入。如果不支持并发读取，则会发生错误。</p></li><li class="listitem"><p>
                </p><pre data-lang="sql" class="programlisting">LOCK = EXCLUSIVE
</pre><p>

                    Enforce exclusive access. This is done even if concurrent
                    reads/writes are supported by the storage engine for the given
                    <code class="literal">ALGORITHM</code> clause (if any) and
                    <code class="literal">ALTER TABLE</code> operation.
                </p><p style="color:blue;">强制独占访问。即使存储引擎为给定的算法子句（如果有）和alter table操作支持并发读/写，也可以执行此操作。</p></li></ul>
            </div>
            <h4><a name="alter-table-add-drop-column"></a>Adding and Dropping Columns</h4>
            <p>
                Use <code class="literal">ADD</code> to add new columns to a table, and
                <code class="literal">DROP</code> to remove existing columns. <code class="literal">DROP
                <em class="replaceable"><code>col_name</code></em></code> is a MySQL extension
                to standard SQL.
            </p><p style="color:blue;">使用Add将新列添加到表中，然后删除以删除现有列。drop col_name是标准sql的mysql扩展。</p><p>
            To add a column at a specific position within a table row, use
            <code class="literal">FIRST</code> or <code class="literal">AFTER
            <em class="replaceable"><code>col_name</code></em></code>. The default is to
            add the column last.
        </p><p style="color:blue;">若要在表行中的特定位置添加列，请使用“列名”或“列名后”。默认设置是最后添加列。</p><p>
            If a table contains only one column, the column cannot be dropped.
            If what you intend is to remove the table, use the
            <a class="link" href="sql-syntax.html#drop-table" title="13.1.29&nbsp;DROP TABLE Syntax"><code class="literal">DROP TABLE</code></a> statement instead.
        </p><p style="color:blue;">如果表只包含一列，则不能删除该列。如果要删除表，请改用drop table语句。</p><p>
            If columns are dropped from a table, the columns are also removed
            from any index of which they are a part. If all columns that make
            up an index are dropped, the index is dropped as well.
        </p><p style="color:blue;">如果列是从表中删除的，则这些列也将从它们所属的任何索引中删除。如果构成索引的所有列都被删除，则索引也将被删除。</p>
            <h4><a name="alter-table-redefine-column"></a>Renaming, Redefining, and Reordering Columns</h4>
            <a class="indexterm" name="idm140286841231872"></a><a class="indexterm" name="idm140286841230384"></a><a class="indexterm" name="idm140286841228896"></a><a class="indexterm" name="idm140286841227408"></a><p>
            The <code class="literal">CHANGE</code>, <code class="literal">MODIFY</code>, and
            <code class="literal">ALTER</code> clauses enable the names and definitions
            of existing columns to be altered. They have these comparative
            characteristics:
        </p><p style="color:blue;">“更改”、“修改”和“更改子句”可更改现有列的名称和定义。它们具有以下比较特征：</p>
            <div class="itemizedlist">
                <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                    <code class="literal">CHANGE</code>:
                </p><p style="color:blue;">更改：</p>
                    <div class="itemizedlist">
                        <ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
                            Can rename a column and change its definition, or both.
                        </p><p style="color:blue;">可以重命名列和/或更改其定义。</p></li><li class="listitem"><p>
                            Has more capability than <code class="literal">MODIFY</code>, but at
                            the expense of convenience for some operations.
                            <code class="literal">CHANGE</code> requires naming the column twice
                            if not renaming it.
                        </p><p style="color:blue;">具有比修改更多的功能，但会牺牲某些操作的便利性。如果不重命名列，则更改需要将其命名两次。</p></li><li class="listitem"><p>
                            With <code class="literal">FIRST</code> or <code class="literal">AFTER</code>,
                            can reorder columns.
                        </p><p style="color:blue;">使用“第一个”或“之后”，可以对列重新排序。</p></li></ul>
                    </div>
                </li><li class="listitem"><p>
                    <code class="literal">MODIFY</code>:
                </p><p style="color:blue;">修改：</p>
                    <div class="itemizedlist">
                        <ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
                            Can change a column definition but not its name.
                        </p><p style="color:blue;">可以更改列定义，但不能更改其名称。</p></li><li class="listitem"><p>
                            More convenient than <code class="literal">CHANGE</code> to change a
                            column definition without renaming it.
                        </p><p style="color:blue;">比更改列定义而不重命名更方便。</p></li><li class="listitem"><p>
                            With <code class="literal">FIRST</code> or <code class="literal">AFTER</code>,
                            can reorder columns.
                        </p><p style="color:blue;">使用“第一个”或“之后”，可以对列重新排序。</p></li></ul>
                    </div>
                </li><li class="listitem"><p>
                    <code class="literal">ALTER</code>: Used only to change a column default
                    value.
                </p><p style="color:blue;">alter：仅用于更改列的默认值。</p></li></ul>
            </div>
            <a class="indexterm" name="idm140286841207360"></a><a class="indexterm" name="idm140286841206288"></a><p>
            <code class="literal">CHANGE</code> is a MySQL extension to standard SQL.
            <code class="literal">MODIFY</code> is a MySQL extension for Oracle
            compatibility.
        </p><p style="color:blue;">change是标准sql的mysql扩展。modify是针对oracle兼容性的mysql扩展。</p><p>
            To alter a column to change both its name and definition, use
            <code class="literal">CHANGE</code>, specifying the old and new names and
            the new definition. For example, to rename an <code class="literal">INT NOT
            NULL</code> column from <code class="literal">a</code> to
            <code class="literal">b</code> and change its definition to use the
            <code class="literal">BIGINT</code> data type while retaining the
            <code class="literal">NOT NULL</code> attribute, do this:
        </p><p style="color:blue;">若要更改列以同时更改其名称和定义，请使用“更改”，指定新旧名称和新定义。例如，要将int not null列从a重命名为b，并将其定义更改为使用bigint数据类型，同时保留not null属性，请执行以下操作：</p><pre data-lang="sql" class="programlisting">ALTER TABLE t1 CHANGE a b BIGINT NOT NULL;
</pre><p>
            To change a column definition but not its name, use
            <code class="literal">CHANGE</code> or <code class="literal">MODIFY</code>. With
            <code class="literal">CHANGE</code>, the syntax requires two column names,
            so you must specify the same name twice to leave the name
            unchanged. For example, to change the definition of column
            <code class="literal">b</code>, do this:
        </p><p style="color:blue;">若要更改列定义而不是其名称，请使用“更改”或“修改”。更改后，语法需要两个列名，因此必须指定相同的名称两次才能保持名称不变。例如，要更改B列的定义，请执行以下操作：</p><pre data-lang="sql" class="programlisting">ALTER TABLE t1 CHANGE b b INT NOT NULL;
</pre><p>
            <code class="literal">MODIFY</code> is more convenient to change the
            definition without changing the name because it requires the
            column name only once:
        </p><p style="color:blue;">modify更方便在不更改名称的情况下更改定义，因为它只需要列名一次：</p><pre data-lang="sql" class="programlisting">ALTER TABLE t1 MODIFY b INT NOT NULL;
</pre><p>
            To change a column name but not its definition, use
            <code class="literal">CHANGE</code>. The syntax requires a column
            definition, so to leave the definition unchanged, you must
            respecify the definition the column currently has. For example, to
            rename an <code class="literal">INT NOT NULL</code> column from
            <code class="literal">b</code> to <code class="literal">a</code>, do this:
        </p><p style="color:blue;">若要更改列名而不是其定义，请使用“更改”。语法需要列定义，因此若要保持定义不变，必须重新指定列当前具有的定义。例如，要将int not null列从b重命名为a，请执行以下操作：</p><pre data-lang="sql" class="programlisting">ALTER TABLE t1 CHANGE b a INT NOT NULL;
</pre><p>
            For column definition changes using <code class="literal">CHANGE</code> or
            <code class="literal">MODIFY</code>, the definition must include the data
            type and all attributes that should apply to the new column, other
            than index attributes such as <code class="literal">PRIMARY KEY</code> or
            <code class="literal">UNIQUE</code>. Attributes present in the original
            definition but not specified for the new definition are not
            carried forward. Suppose that a column <code class="literal">col1</code> is
            defined as <code class="literal">INT UNSIGNED DEFAULT 1 COMMENT 'my
            column'</code> and you modify the column as follows, intending
            to change only <code class="literal">INT</code> to
            <code class="literal">BIGINT</code>:
        </p><p style="color:blue;">对于使用change或modify进行的列定义更改，该定义必须包括数据类型和应应用于新列的所有属性，而不是主键或unique等索引属性。原始定义中存在但未为新定义指定的属性不会结转。假设col1列被定义为int unsigned default 1注释'my column'，并按如下方式修改该列，目的是只将int更改为bigint：</p><pre data-lang="sql" class="programlisting">ALTER TABLE t1 MODIFY col1 BIGINT;
</pre><p>
            That statement changes the data type from <code class="literal">INT</code>
            to <code class="literal">BIGINT</code>, but it also drops the
            <code class="literal">UNSIGNED</code>, <code class="literal">DEFAULT</code>, and
            <code class="literal">COMMENT</code> attributes. To retain them, the
            statement must include them explicitly:
        </p><p style="color:blue;">该语句将数据类型从int更改为bigint，但也会删除unsigned、default和comment属性。要保留它们，语句必须显式地包含它们：</p><pre data-lang="sql" class="programlisting">ALTER TABLE t1 MODIFY col1 BIGINT UNSIGNED DEFAULT 1 COMMENT 'my column';
</pre><p>
            For data type changes using <code class="literal">CHANGE</code> or
            <code class="literal">MODIFY</code>, MySQL tries to convert existing column
            values to the new type as well as possible.
        </p><p style="color:blue;">对于使用更改或修改的数据类型更改，MySQL尝试尽可能地将现有列值转换为新类型。</p>
            <div class="warning" style="margin-left: 0.5in; margin-right: 0.5in;">

                <div class="admon-title">
                    Warning
                </div>
                <p>
                    This conversion may result in alteration of data. For example,
                    if you shorten a string column, values may be truncated. To
                    prevent the operation from succeeding if conversions to the new
                    data type would result in loss of data, enable strict SQL mode
                    before using <a class="link" href="sql-syntax.html#alter-table" title="13.1.8&nbsp;ALTER TABLE Syntax"><code class="literal">ALTER TABLE</code></a> (see
                    <a class="xref" href="server-administration.html#sql-mode" title="5.1.10&nbsp;Server SQL Modes">Section&nbsp;5.1.10, “Server SQL Modes”</a>).
                </p><p style="color:blue;">这种转换可能导致数据的更改。例如，如果缩短字符串列，则可能会截断值。如果转换为新数据类型会导致数据丢失，要防止操作成功，请在使用alter table之前启用strict sql模式（请参阅第5.1.10节“服务器sql模式”）。</p>
            </div>
            <p>
                If you use <code class="literal">CHANGE</code> or <code class="literal">MODIFY</code>
                to shorten a column for which an index exists on the column, and
                the resulting column length is less than the index length, MySQL
                shortens the index automatically.
            </p><p style="color:blue;">如果使用更改或修改来缩短列上存在索引的列，并且所得的列长度小于索引长度，则MySQL会自动缩短索引。</p><p>
            For columns renamed by <code class="literal">CHANGE</code>, MySQL
            automatically renames these references to the renamed column:
        </p><p style="color:blue;">对于通过更改重命名的列，mysql会自动将这些引用重命名为重命名的列：</p>
            <div class="itemizedlist">
                <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                    Indexes that refer to the old column, including indexes and
                    disabled <code class="literal">MyISAM</code> indexes.
                </p><p style="color:blue;">引用旧列的索引，包括索引和禁用的myisam索引。</p></li><li class="listitem"><p>
                    Foreign keys that refer to the old column.
                </p><p style="color:blue;">引用旧列的外键。</p></li></ul>
            </div>
            <p>
                For columns renamed by <code class="literal">CHANGE</code>, MySQL does not
                automatically rename these references to the renamed column:
            </p><p style="color:blue;">对于通过更改重命名的列，mysql不会自动将这些引用重命名为重命名的列：</p>
            <div class="itemizedlist">
                <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                    Generated column and partition expressions that refer to the
                    renamed column. You must use <code class="literal">CHANGE</code> to
                    redefine such expressions in the same
                    <a class="link" href="sql-syntax.html#alter-table" title="13.1.8&nbsp;ALTER TABLE Syntax"><code class="literal">ALTER TABLE</code></a> statement as the
                    one that renames the column.
                </p><p style="color:blue;">生成引用重命名列的列和分区表达式。必须使用change在与重命名列的alter table语句相同的alter table语句中重新定义此类表达式。</p></li><li class="listitem"><p>
                    Views and stored programs that refer to the renamed column.
                    You must manually alter the definition of these objects to
                    refer to the new column name.
                </p><p style="color:blue;">引用重命名列的视图和存储程序。必须手动更改这些对象的定义以引用新列名。</p></li></ul>
            </div>
            <p>
                To reorder columns within a table, use <code class="literal">FIRST</code>
                and <code class="literal">AFTER</code> in <code class="literal">CHANGE</code> or
                <code class="literal">MODIFY</code> operations.
            </p><p style="color:blue;">若要对表中的列重新排序，请使用“更改”或“修改”操作中的“第一个”和“之后”。</p><a class="indexterm" name="idm140286841153648"></a><p>
            <code class="literal">ALTER ... SET DEFAULT</code> or <code class="literal">ALTER ...
            DROP DEFAULT</code> specify a new default value for a column or
            remove the old default value, respectively. If the old default is
            removed and the column can be <code class="literal">NULL</code>, the new
            default is <code class="literal">NULL</code>. If the column cannot be
            <code class="literal">NULL</code>, MySQL assigns a default value as
            described in <a class="xref" href="data-types.html#data-type-defaults" title="11.7&nbsp;Data Type Default Values">Section&nbsp;11.7, “Data Type Default Values”</a>.
        </p><p style="color:blue;">改变…设置默认值或更改…删除默认值分别为列指定新的默认值或删除旧的默认值。如果删除了旧的默认值并且列可以为空，则新的默认值为空。如果该列不能为空，mysql将分配一个默认值，如11.7节“数据类型默认值”所述。</p>
            <h4><a name="alter-table-index"></a>Primary Keys and Indexes</h4>
            <a class="indexterm" name="idm140286841146512"></a><a class="indexterm" name="idm140286841145472"></a><a class="indexterm" name="idm140286841143984"></a><p>
            <code class="literal">DROP PRIMARY KEY</code> drops the
            <a class="link" href="glossary.html#glos_primary_key" title="primary key">primary key</a>. If there is
            no primary key, an error occurs. For information about the
            performance characteristics of primary keys, especially for
            <code class="literal">InnoDB</code> tables, see
            <a class="xref" href="optimization.html#primary-key-optimization" title="8.3.2&nbsp;Primary Key Optimization">Section&nbsp;8.3.2, “Primary Key Optimization”</a>.
        </p><p style="color:blue;">删除主键删除主键。如果没有主键，则会发生错误。有关主键的性能特性的信息，特别是对于innodb表，请参阅8.3.2节“主键优化”。</p><a class="indexterm" name="idm140286841138832"></a><a class="indexterm" name="idm140286841137760"></a><p>
            If you add a <code class="literal">UNIQUE INDEX</code> or <code class="literal">PRIMARY
            KEY</code> to a table, MySQL stores it before any nonunique
            index to permit detection of duplicate keys as early as possible.
        </p><p style="color:blue;">如果将唯一索引或主键添加到表中，mysql会将其存储在任何非唯一索引之前，以允许尽早检测重复键。</p><a class="indexterm" name="idm140286841134720"></a><a class="indexterm" name="idm140286841133648"></a><a class="indexterm" name="idm140286841132160"></a><p>
            <a class="link" href="sql-syntax.html#drop-index" title="13.1.25&nbsp;DROP INDEX Syntax"><code class="literal">DROP INDEX</code></a> removes an index. This
            is a MySQL extension to standard SQL. See
            <a class="xref" href="sql-syntax.html#drop-index" title="13.1.25&nbsp;DROP INDEX Syntax">Section&nbsp;13.1.25, “DROP INDEX Syntax”</a>. To determine index names, use
            <code class="literal">SHOW INDEX FROM
                <em class="replaceable"><code>tbl_name</code></em></code>.
        </p><p style="color:blue;">删除索引删除索引。这是标准sql的mysql扩展。见第13.1.25节“删除索引语法”。要确定索引名称，请使用show index from tbl_name。</p><p>
            Some storage engines permit you to specify an index type when
            creating an index. The syntax for the
            <em class="replaceable"><code>index_type</code></em> specifier is <code class="literal">USING
            <em class="replaceable"><code>type_name</code></em></code>. For details about
            <code class="literal">USING</code>, see <a class="xref" href="sql-syntax.html#create-index" title="13.1.14&nbsp;CREATE INDEX Syntax">Section&nbsp;13.1.14, “CREATE INDEX Syntax”</a>. The
            preferred position is after the column list. Support for use of
            the option before the column list will be removed in a future
            MySQL release.
        </p><p style="color:blue;">某些存储引擎允许您在创建索引时指定索引类型。索引类型说明符的语法使用类型名称。有关使用的详细信息，请参见第13.1.14节“创建索引语法”。首选位置在列列表之后。支持在以后的mysql版本中删除列列表之前使用该选项。</p><p>
            <em class="replaceable"><code>index_option</code></em> values specify additional
            options for an index. For details about permissible
            <em class="replaceable"><code>index_option</code></em> values, see
            <a class="xref" href="sql-syntax.html#create-index" title="13.1.14&nbsp;CREATE INDEX Syntax">Section&nbsp;13.1.14, “CREATE INDEX Syntax”</a>.
        </p><p style="color:blue;">索引选项值指定索引的其他选项。有关允许的index_选项值的详细信息，请参阅第13.1.14节“创建索引语法”。</p><p>
            <code class="literal">RENAME INDEX <em class="replaceable"><code>old_index_name</code></em> TO
                <em class="replaceable"><code>new_index_name</code></em></code> renames an
            index. This is a MySQL extension to standard SQL. The content of
            the table remains unchanged.
            <em class="replaceable"><code>old_index_name</code></em> must be the name of an
            existing index in the table that is not dropped by the same
            <a class="link" href="sql-syntax.html#alter-table" title="13.1.8&nbsp;ALTER TABLE Syntax"><code class="literal">ALTER TABLE</code></a> statement.
            <em class="replaceable"><code>new_index_name</code></em> is the new index name,
            which cannot duplicate the name of an index in the resulting table
            after changes have been applied. Neither index name can be
            <code class="literal">PRIMARY</code>.
        </p><p style="color:blue;">重命名索引旧索引名为新索引名重命名索引。这是标准sql的mysql扩展。表的内容保持不变。OLDIX索引名称必须是表中现有索引的名称，而不是由同一ALTALTABLE语句丢弃。new_index_name是新的索引名，在应用更改后，该索引名不能与结果表中的索引名重复。两个索引名都不能是主索引名。</p><a class="indexterm" name="idm140286841116736"></a><a class="indexterm" name="idm140286841115664"></a><a class="indexterm" name="idm140286841114176"></a><p>
            If you use <a class="link" href="sql-syntax.html#alter-table" title="13.1.8&nbsp;ALTER TABLE Syntax"><code class="literal">ALTER TABLE</code></a> on a
            <code class="literal">MyISAM</code> table, all nonunique indexes are created
            in a separate batch (as for <a class="link" href="sql-syntax.html#repair-table" title="13.7.2.5&nbsp;REPAIR TABLE Syntax"><code class="literal">REPAIR
            TABLE</code></a>). This should make <a class="link" href="sql-syntax.html#alter-table" title="13.1.8&nbsp;ALTER TABLE Syntax"><code class="literal">ALTER
            TABLE</code></a> much faster when you have many indexes.
        </p><p style="color:blue;">如果对myisam表使用alter table，则所有非唯一索引都将在单独的批处理中创建（对于repair table）。当有许多索引时，这将使alter table更快。</p><p>
            For <code class="literal">MyISAM</code> tables, key updating can be
            controlled explicitly. Use <code class="literal">ALTER TABLE ... DISABLE
            KEYS</code> to tell MySQL to stop updating nonunique indexes.
            Then use <code class="literal">ALTER TABLE ... ENABLE KEYS</code> to
            re-create missing indexes. <code class="literal">MyISAM</code> does this
            with a special algorithm that is much faster than inserting keys
            one by one, so disabling keys before performing bulk insert
            operations should give a considerable speedup. Using
            <code class="literal">ALTER TABLE ... DISABLE KEYS</code> requires the
            <a class="link" href="security.html#priv_index"><code class="literal">INDEX</code></a> privilege in addition to the
            privileges mentioned earlier.
        </p><p style="color:blue;">对于myisam表，可以显式地控制密钥更新。使用更改表…禁用键以告诉mysql停止更新非唯一索引。然后使用alter table…启用键以重新创建丢失的索引。myisam使用一种特殊的算法来实现这一点，这种算法比逐个插入密钥快得多，因此在执行大容量插入操作之前禁用密钥应该会大大加快速度。使用alter table…除前面提到的权限外，禁用密钥还需要索引权限。</p><p>
            While the nonunique indexes are disabled, they are ignored for
            statements such as <a class="link" href="sql-syntax.html#select" title="13.2.9&nbsp;SELECT Syntax"><code class="literal">SELECT</code></a> and
            <a class="link" href="sql-syntax.html#explain" title="13.8.2&nbsp;EXPLAIN Syntax"><code class="literal">EXPLAIN</code></a> that otherwise would use
            them.
        </p><p style="color:blue;">当非唯一索引被禁用时，对于select和explain这样的语句，它们将被忽略，否则将使用它们。</p><p>
            After an <a class="link" href="sql-syntax.html#alter-table" title="13.1.8&nbsp;ALTER TABLE Syntax"><code class="literal">ALTER TABLE</code></a> statement, it
            may be necessary to run <a class="link" href="sql-syntax.html#analyze-table" title="13.7.2.1&nbsp;ANALYZE TABLE Syntax"><code class="literal">ANALYZE
            TABLE</code></a> to update index cardinality information. See
            <a class="xref" href="sql-syntax.html#show-index" title="13.7.5.22&nbsp;SHOW INDEX Syntax">Section&nbsp;13.7.5.22, “SHOW INDEX Syntax”</a>.
        </p><p style="color:blue;">在alter table语句之后，可能需要运行analyze table来更新索引基数信息。见第13.7.5.22节“显示索引语法”。</p>
            <h4><a name="alter-table-foreign-key"></a>Foreign Keys and Other Constraints</h4>
            <a class="indexterm" name="idm140286841094320"></a><a class="indexterm" name="idm140286841093280"></a><p>
            The <code class="literal">FOREIGN KEY</code> and
            <code class="literal">REFERENCES</code> clauses are supported by the
            <code class="literal">InnoDB</code> and <code class="literal">NDB</code> storage
            engines, which implement <code class="literal">ADD [CONSTRAINT
            [<em class="replaceable"><code>symbol</code></em>]] FOREIGN KEY
            [<em class="replaceable"><code>index_name</code></em>] (...) REFERENCES ...
            (...)</code>. See <a class="xref" href="introduction.html#constraint-foreign-key" title="1.8.3.2&nbsp;FOREIGN KEY Constraints">Section&nbsp;1.8.3.2, “FOREIGN KEY Constraints”</a>; for
            information specific to <code class="literal">InnoDB</code>, see
            <a class="xref" href="innodb-storage-engine.html#innodb-foreign-key-constraints" title="14.6.1.5&nbsp;InnoDB and FOREIGN KEY Constraints">Section&nbsp;14.6.1.5, “InnoDB and FOREIGN KEY Constraints”</a>. For other
            storage engines, the clauses are parsed but ignored.
        </p><p style="color:blue;">innodb和ndb存储引擎支持外键和引用子句，它们实现了add[constraint[symbol]]外键[index_name]（…）引用…（…）。参见第1.8.3.2节，“外键约束”；关于innodb的具体信息，参见第14.6.1.5节，“innodb和外键约束”。对于其他存储引擎，将分析这些子句，但忽略它们。</p><p>
            The <code class="literal">CHECK</code> constraint clause is parsed but
            ignored by all storage engines. See
            <a class="xref" href="sql-syntax.html#create-table" title="13.1.18&nbsp;CREATE TABLE Syntax">Section&nbsp;13.1.18, “CREATE TABLE Syntax”</a>. The reason for accepting but
            ignoring syntax clauses is for compatibility, to make it easier to
            port code from other SQL servers, and to run applications that
            create tables with references. See
            <a class="xref" href="introduction.html#differences-from-ansi" title="1.8.2&nbsp;MySQL Differences from Standard SQL">Section&nbsp;1.8.2, “MySQL Differences from Standard SQL”</a>.
        </p><p style="color:blue;">check constraint子句已被所有存储引擎分析但忽略。参见第13.1.18节“创建表语法”。接受但忽略语法子句的原因是为了兼容性，以便更容易从其他SQL服务器移植代码，并运行使用引用创建表的应用程序。参见第1.8.2节“MySQL与标准SQL的区别”。</p><p>
            For <a class="link" href="sql-syntax.html#alter-table" title="13.1.8&nbsp;ALTER TABLE Syntax"><code class="literal">ALTER TABLE</code></a>, unlike
            <a class="link" href="sql-syntax.html#create-table" title="13.1.18&nbsp;CREATE TABLE Syntax"><code class="literal">CREATE TABLE</code></a>, <code class="literal">ADD FOREIGN
            KEY</code> ignores <em class="replaceable"><code>index_name</code></em> if
            given and uses an automatically generated foreign key name. As a
            workaround, include the <code class="literal">CONSTRAINT</code> clause to
            specify the foreign key name:
        </p><p style="color:blue;">对于alter table，与create table不同，add foreign key忽略给定的索引名，并使用自动生成的外键名。作为解决方法，请包含constraint子句以指定外键名称：</p><pre data-lang="sql" class="programlisting">ADD CONSTRAINT <em class="replaceable"><code>name</code></em> FOREIGN KEY (....) ...
</pre>
            <div class="important" style="margin-left: 0.5in; margin-right: 0.5in;">

                <div class="admon-title">
                    Important
                </div>
                <p>
                    MySQL silently ignores inline <code class="literal">REFERENCES</code>
                    specifications, where the references are defined as part of the
                    column specification. MySQL accepts only
                    <code class="literal">REFERENCES</code> clauses defined as part of a
                    separate <code class="literal">FOREIGN KEY</code> specification.
                </p><p style="color:blue;">mysql静默地忽略内联引用规范，其中引用被定义为列规范的一部分。mysql只接受作为单独外键规范一部分定义的引用子句。</p>
            </div>
            <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">
                <div class="admon-title">
                    Note
                </div>
                <p>
                    Partitioned <code class="literal">InnoDB</code> tables do not support
                    foreign keys. This restriction does not apply to
                    <code class="literal">NDB</code> tables, including those explicitly
                    partitioned by <code class="literal">[LINEAR] KEY</code>. For more
                    information, see
                    <a class="xref" href="partitioning.html#partitioning-limitations-storage-engines" title="22.6.2&nbsp;Partitioning Limitations Relating to Storage Engines">Section&nbsp;22.6.2, “Partitioning Limitations Relating to Storage Engines”</a>.
                </p><p style="color:blue;">分区的innodb表不支持外键。此限制不适用于ndb表，包括由[线性]键显式分区的表。有关更多信息，请参阅第22.6.2节“与存储引擎相关的分区限制”。</p>
            </div>
            <a class="indexterm" name="idm140286841068768"></a><a class="indexterm" name="idm140286841067696"></a><a class="indexterm" name="idm140286841066208"></a><p>
            MySQL Server and NDB Cluster both support the use of
            <a class="link" href="sql-syntax.html#alter-table" title="13.1.8&nbsp;ALTER TABLE Syntax"><code class="literal">ALTER TABLE</code></a> to drop foreign keys:
        </p><p style="color:blue;">mysql server和ndb cluster都支持使用alter table删除外键：</p><pre data-lang="sql" class="programlisting">ALTER TABLE <em class="replaceable"><code>tbl_name</code></em> DROP FOREIGN KEY <em class="replaceable"><code>fk_symbol</code></em>;
</pre><p>
            Adding and dropping a foreign key in the same
            <a class="link" href="sql-syntax.html#alter-table" title="13.1.8&nbsp;ALTER TABLE Syntax"><code class="literal">ALTER TABLE</code></a> statement is supported
            for <a class="link" href="sql-syntax.html#alter-table" title="13.1.8&nbsp;ALTER TABLE Syntax"><code class="literal">ALTER TABLE ...
            ALGORITHM=INPLACE</code></a> but not for
            <a class="link" href="sql-syntax.html#alter-table" title="13.1.8&nbsp;ALTER TABLE Syntax"><code class="literal">ALTER TABLE ...
                ALGORITHM=COPY</code></a>.
        </p><p style="color:blue;">alter table支持在同一alter table语句中添加和删除外键…algorithm=inplace但不用于alter table…算法=复制。</p><p>
            The server prohibits changes to foreign key columns that have the
            potential to cause loss of referential integrity. A workaround is
            to use <a class="link" href="sql-syntax.html#alter-table" title="13.1.8&nbsp;ALTER TABLE Syntax"><code class="literal">ALTER TABLE
            ... DROP FOREIGN KEY</code></a> before changing the column
            definition and <a class="link" href="sql-syntax.html#alter-table" title="13.1.8&nbsp;ALTER TABLE Syntax"><code class="literal">ALTER
            TABLE ... ADD FOREIGN KEY</code></a> afterward. Examples of
            prohibited changes include:
        </p><p style="color:blue;">服务器禁止更改可能导致引用完整性丢失的外键列。解决方法是使用alter table…在更改列定义和更改表之前删除外键…之后添加外键。禁止更改的示例包括：</p>
            <div class="itemizedlist">
                <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                    Changes to the data type of foreign key columns that may be
                    unsafe. For example, changing
                    <a class="link" href="data-types.html#char" title="11.4.1&nbsp;The CHAR and VARCHAR Types"><code class="literal">VARCHAR(20)</code></a> to
                    <a class="link" href="data-types.html#char" title="11.4.1&nbsp;The CHAR and VARCHAR Types"><code class="literal">VARCHAR(30)</code></a> is permitted, but
                    changing it to <a class="link" href="data-types.html#char" title="11.4.1&nbsp;The CHAR and VARCHAR Types"><code class="literal">VARCHAR(1024)</code></a> is
                    not because that alters the number of length bytes required to
                    store individual values.
                </p><p style="color:blue;">可能不安全的外键列的数据类型更改。例如，允许将varchar（20）更改为varchar（30），但将其更改为varchar（1024）并不是因为这会更改存储单个值所需的长度字节数。</p></li><li class="listitem"><p>
                    Changing a <code class="literal">NULL</code> column to <code class="literal">NOT
                    NULL</code> in non-strict mode is prohibited to prevent
                    converting <code class="literal">NULL</code> values to default
                    non-<code class="literal">NULL</code> values, for which there are no
                    corresponding values in the referenced table. The operation is
                    permitted in strict mode, but an error is returned if any such
                    conversion is required.
                </p><p style="color:blue;">禁止在非严格模式下将空列更改为非空，以防止将空值转换为默认的非空值，因为引用的表中没有相应的值。在严格模式下允许该操作，但如果需要任何此类转换，则返回错误。</p></li></ul>
            </div>
            <p>
                <code class="literal">ALTER TABLE <em class="replaceable"><code>tbl_name</code></em> RENAME
                    <em class="replaceable"><code>new_tbl_name</code></em></code> changes
                internally generated foreign key constraint names and user-defined
                foreign key constraint names that begin with the string
                <span class="quote">“<span class="quote"><em class="replaceable"><code>tbl_name</code></em>_ibfk_</span>”</span> to
                reflect the new table name. <code class="literal">InnoDB</code> interprets
                foreign key constraint names that begin with the string
                <span class="quote">“<span class="quote"><em class="replaceable"><code>tbl_name</code></em>_ibfk_</span>”</span> as
                internally generated names.
            </p><p style="color:blue;">alter table tbl_name rename new_tbl_name更改内部生成的外键约束名称和以字符串“tbl_name_ibfk_”开头的用户定义的外键约束名称，以反映新表名。innodb将以字符串“tbl_name_ibfk_u”开头的外键约束名称解释为内部生成的名称。</p>
            <h4><a name="alter-table-character-set"></a>Changing the Character Set</h4>
            <p>
                <a class="indexterm" name="idm140286841039136"></a>

                To change the table default character set and all character
                columns (<a class="link" href="data-types.html#char" title="11.4.1&nbsp;The CHAR and VARCHAR Types"><code class="literal">CHAR</code></a>,
                <a class="link" href="data-types.html#char" title="11.4.1&nbsp;The CHAR and VARCHAR Types"><code class="literal">VARCHAR</code></a>,
                <a class="link" href="data-types.html#blob" title="11.4.3&nbsp;The BLOB and TEXT Types"><code class="literal">TEXT</code></a>) to a new character set, use a
                statement like this:
            </p><p style="color:blue;">要将表默认字符集和所有字符列（char、varchar、text）更改为新字符集，请使用如下语句：</p><pre data-lang="sql" class="programlisting">ALTER TABLE <em class="replaceable"><code>tbl_name</code></em> CONVERT TO CHARACTER SET <em class="replaceable"><code>charset_name</code></em>;
</pre><p>
            The statement also changes the collation of all character columns.
            If you specify no <code class="literal">COLLATE</code> clause to indicate
            which collation to use, the statement uses default collation for
            the character set. If this collation is inappropriate for the
            intended table use (for example, if it would change from a
            case-sensitive collation to a case-insensitive collation), specify
            a collation explicitly.
        </p><p style="color:blue;">语句还更改所有字符列的排序规则。如果不指定COLLATE子句来指示要使用的排序规则，则语句将对字符集使用默认排序规则。如果此排序规则不适合预期的表使用（例如，如果它将从区分大小写的排序规则更改为不区分大小写的排序规则），请显式指定排序规则。</p><p>
            For a column that has a data type of
            <a class="link" href="data-types.html#char" title="11.4.1&nbsp;The CHAR and VARCHAR Types"><code class="literal">VARCHAR</code></a> or one of the
            <a class="link" href="data-types.html#blob" title="11.4.3&nbsp;The BLOB and TEXT Types"><code class="literal">TEXT</code></a> types, <code class="literal">CONVERT TO
            CHARACTER SET</code> changes the data type as necessary to
            ensure that the new column is long enough to store as many
            characters as the original column. For example, a
            <a class="link" href="data-types.html#blob" title="11.4.3&nbsp;The BLOB and TEXT Types"><code class="literal">TEXT</code></a> column has two length bytes,
            which store the byte-length of values in the column, up to a
            maximum of 65,535. For a <code class="literal">latin1</code>
            <a class="link" href="data-types.html#blob" title="11.4.3&nbsp;The BLOB and TEXT Types"><code class="literal">TEXT</code></a> column, each character
            requires a single byte, so the column can store up to 65,535
            characters. If the column is converted to <code class="literal">utf8</code>,
            each character might require up to three bytes, for a maximum
            possible length of 3 × 65,535 = 196,605 bytes. That length
            does not fit in a <a class="link" href="data-types.html#blob" title="11.4.3&nbsp;The BLOB and TEXT Types"><code class="literal">TEXT</code></a> column's
            length bytes, so MySQL converts the data type to
            <a class="link" href="data-types.html#blob" title="11.4.3&nbsp;The BLOB and TEXT Types"><code class="literal">MEDIUMTEXT</code></a>, which is the smallest
            string type for which the length bytes can record a value of
            196,605. Similarly, a <a class="link" href="data-types.html#char" title="11.4.1&nbsp;The CHAR and VARCHAR Types"><code class="literal">VARCHAR</code></a>
            column might be converted to
            <a class="link" href="data-types.html#blob" title="11.4.3&nbsp;The BLOB and TEXT Types"><code class="literal">MEDIUMTEXT</code></a>.
        </p><p style="color:blue;">对于数据类型为varchar或其中一种文本类型的列，convert to character set根据需要更改数据类型，以确保新列足够长，可以存储与原始列一样多的字符。例如，文本列有两个长度字节，它存储列中的值的字节长度，最多为65535。对于Latin1文本列，每个字符需要一个字节，因此该列最多可以存储65535个字符。如果该列被转换为UTF8，每个字符可能需要多达三个字节，最大可能长度为3×65535＝196605字节。该长度不适合文本列的长度字节，因此mysql将数据类型转换为mediumtext，mediumtext是长度字节可以记录196605值的最小字符串类型。类似地，varchar列可以转换为mediumtext。</p><p>
            To avoid data type changes of the type just described, do not use
            <code class="literal">CONVERT TO CHARACTER SET</code>. Instead, use
            <code class="literal">MODIFY</code> to change individual columns. For
            example:
        </p><p style="color:blue;">若要避免刚描述的类型的数据类型更改，请不要使用“转换为字符集”。相反，请使用“修改”更改单个列。例如：</p><pre data-lang="sql" class="programlisting">ALTER TABLE t MODIFY latin1_text_col TEXT CHARACTER SET utf8;
ALTER TABLE t MODIFY latin1_varchar_col VARCHAR(<em class="replaceable"><code>M</code></em>) CHARACTER SET utf8;
</pre><p>
            If you specify <code class="literal">CONVERT TO CHARACTER SET binary</code>,
            the <a class="link" href="data-types.html#char" title="11.4.1&nbsp;The CHAR and VARCHAR Types"><code class="literal">CHAR</code></a>,
            <a class="link" href="data-types.html#char" title="11.4.1&nbsp;The CHAR and VARCHAR Types"><code class="literal">VARCHAR</code></a>, and
            <a class="link" href="data-types.html#blob" title="11.4.3&nbsp;The BLOB and TEXT Types"><code class="literal">TEXT</code></a> columns are converted to their
            corresponding binary string types
            (<a class="link" href="data-types.html#binary-varbinary" title="11.4.2&nbsp;The BINARY and VARBINARY Types"><code class="literal">BINARY</code></a>,
            <a class="link" href="data-types.html#binary-varbinary" title="11.4.2&nbsp;The BINARY and VARBINARY Types"><code class="literal">VARBINARY</code></a>,
            <a class="link" href="data-types.html#blob" title="11.4.3&nbsp;The BLOB and TEXT Types"><code class="literal">BLOB</code></a>). This means that the columns
            no longer will have a character set and a subsequent
            <code class="literal">CONVERT TO</code> operation will not apply to them.
        </p><p style="color:blue;">如果指定convert to character set binary，char、varchar和text列将转换为它们相应的二进制字符串类型（binary、varbinary、blob）。这意味着列将不再具有字符集，并且后续的“转换为”操作将不适用于它们。</p><p>
            If <em class="replaceable"><code>charset_name</code></em> is
            <code class="literal">DEFAULT</code> in a <code class="literal">CONVERT TO CHARACTER
            SET</code> operation, the character set named by the
            <a class="link" href="server-administration.html#sysvar_character_set_database"><code class="literal">character_set_database</code></a> system
            variable is used.
        </p><p style="color:blue;">如果“转换为字符集”操作中默认使用字符集名称，则使用由字符集数据库系统变量命名的字符集。</p>
            <div class="warning" style="margin-left: 0.5in; margin-right: 0.5in;">

                <div class="admon-title">
                    Warning
                </div>
                <p>
                    The <code class="literal">CONVERT TO</code> operation converts column
                    values between the original and named character sets. This is
                    <span class="emphasis"><em>not</em></span> what you want if you have a column in
                    one character set (like <code class="literal">latin1</code>) but the
                    stored values actually use some other, incompatible character
                    set (like <code class="literal">utf8</code>). In this case, you have to do
                    the following for each such column:
                </p><p style="color:blue;">convert to操作转换原始字符集和命名字符集之间的列值。如果一个字符集中有一列（如latin1），但存储的值实际上使用了其他不兼容的字符集（如utf8），则这不是您想要的。在这种情况下，必须对每个此类列执行以下操作：</p><pre data-lang="sql" class="programlisting">ALTER TABLE t1 CHANGE c1 c1 BLOB;
ALTER TABLE t1 CHANGE c1 c1 TEXT CHARACTER SET utf8;
</pre><p>
                The reason this works is that there is no conversion when you
                convert to or from <a class="link" href="data-types.html#blob" title="11.4.3&nbsp;The BLOB and TEXT Types"><code class="literal">BLOB</code></a> columns.
            </p><p style="color:blue;">之所以有效，是因为在转换为blob列或从blob列转换时没有转换。</p>
            </div>
            <p>
                To change only the <span class="emphasis"><em>default</em></span> character set for
                a table, use this statement:
            </p><p style="color:blue;">要仅更改表的默认字符集，请使用以下语句：</p><pre data-lang="sql" class="programlisting">ALTER TABLE <em class="replaceable"><code>tbl_name</code></em> DEFAULT CHARACTER SET <em class="replaceable"><code>charset_name</code></em>;
</pre><p>
            The word <code class="literal">DEFAULT</code> is optional. The default
            character set is the character set that is used if you do not
            specify the character set for columns that you add to a table
            later (for example, with <code class="literal">ALTER TABLE ... ADD
            column</code>).
        </p><p style="color:blue;">单词default是可选的。默认字符集是如果不为以后添加到表中的列指定字符集（例如，使用alter table…添加列）。</p><p>
            When the <a class="link" href="server-administration.html#sysvar_foreign_key_checks"><code class="literal">foreign_key_checks</code></a>
            system variable is enabled, which is the default setting,
            character set conversion is not permitted on tables that include a
            character string column used in a foreign key constraint. The
            workaround is to disable
            <a class="link" href="server-administration.html#sysvar_foreign_key_checks"><code class="literal">foreign_key_checks</code></a> before
            performing the character set conversion. You must perform the
            conversion on both tables involved in the foreign key constraint
            before re-enabling
            <a class="link" href="server-administration.html#sysvar_foreign_key_checks"><code class="literal">foreign_key_checks</code></a>. If you
            re-enable <a class="link" href="server-administration.html#sysvar_foreign_key_checks"><code class="literal">foreign_key_checks</code></a>
            after converting only one of the tables, an <code class="literal">ON DELETE
            CASCADE</code> or <code class="literal">ON UPDATE CASCADE</code>
            operation could corrupt data in the referencing table due to
            implicit conversion that occurs during these operations (Bug
            #45290, Bug #74816).
        </p><p style="color:blue;">如果启用了foreign_key_checks系统变量（这是默认设置），则不允许在包含外键约束中使用的字符串列的表上进行字符集转换。解决方法是在执行字符集转换之前禁用外键检查。在重新启用外键检查之前，必须对外键约束中涉及的两个表执行转换。如果只转换其中一个表后重新启用外键检查，则由于在这些操作期间发生的隐式转换（错误45290，错误74816），删除级联或更新级联操作可能会损坏引用表中的数据。</p>
            <h4><a name="alter-table-discard-import"></a>Discarding and Importing InnoDB Tablespaces</h4>
            <a class="indexterm" name="idm140286840981056"></a><a class="indexterm" name="idm140286840979984"></a><p>
            An <code class="literal">InnoDB</code> table created in its own
            <a class="link" href="glossary.html#glos_file_per_table" title="file-per-table">file-per-table</a>
            tablespace can be discarded and imported using the
            <code class="literal">DISCARD TABLESPACE</code> and <code class="literal">IMPORT
            TABLESPACE</code> options. These options can be used to import
            a file-per-table tablespace from a backup or to copy a
            file-per-table tablespace from one database server to another. See
            <a class="xref" href="innodb-storage-engine.html#tablespace-copying" title="14.6.3.7&nbsp;Copying Tablespaces to Another Instance">Section&nbsp;14.6.3.7, “Copying Tablespaces to Another Instance”</a>.
        </p><p style="color:blue;">可以使用discard tablespace和import tablespace选项放弃并导入在每个表空间的文件中创建的innodb表。这些选项可用于从备份中导入每表表空间文件，或将每表表空间文件从一个数据库服务器复制到另一个数据库服务器。请参阅14.6.3.7节，“将表空间复制到另一个实例”。</p>
            <h4><a name="alter-table-row-order"></a>Row Order for MyISAM Tables</h4>
            <a class="indexterm" name="idm140286840973456"></a><p>
            <code class="literal">ORDER BY</code> enables you to create the new table
            with the rows in a specific order. This option is useful primarily
            when you know that you query the rows in a certain order most of
            the time. By using this option after major changes to the table,
            you might be able to get higher performance. In some cases, it
            might make sorting easier for MySQL if the table is in order by
            the column that you want to order it by later.
        </p><p style="color:blue;">ORDERBY使您能够创建具有特定顺序的行的新表。此选项主要在您知道大多数情况下按特定顺序查询行时有用。通过在对表进行重大更改后使用此选项，可以获得更高的性能。在某些情况下，如果表是按您稍后要按其排序的列排序的，则可能会使mysql的排序更容易。</p>
            <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">

                <div class="admon-title">
                    Note
                </div>
                <p>
                    The table does not remain in the specified order after inserts
                    and deletes.
                </p><p style="color:blue;">插入和删除后，表不保持指定的顺序。</p>
            </div>
            <p>
                <code class="literal">ORDER BY</code> syntax permits one or more column
                names to be specified for sorting, each of which optionally can be
                followed by <code class="literal">ASC</code> or <code class="literal">DESC</code> to
                indicate ascending or descending sort order, respectively. The
                default is ascending order. Only column names are permitted as
                sort criteria; arbitrary expressions are not permitted. This
                clause should be given last after any other clauses.
            </p><p style="color:blue;">ORDER BY语法允许指定一个或多个列名进行排序，每个列名后面可以有ASC或DESC，分别表示升序或降序排序顺序。默认为升序。仅允许将列名用作排序条件；不允许使用任意表达式。本条款应在任何其他条款之后给出。</p><p>
            <code class="literal">ORDER BY</code> does not make sense for
            <code class="literal">InnoDB</code> tables because <code class="literal">InnoDB</code>
            always orders table rows according to the
            <a class="link" href="glossary.html#glos_clustered_index" title="clustered index">clustered index</a>.
        </p><p style="color:blue;">order by对于innodb表没有意义，因为innodb总是根据聚集索引对表行进行排序。</p><p>
            When used on a partitioned table, <code class="literal">ALTER TABLE ... ORDER
            BY</code> orders rows within each partition only.
        </p><p style="color:blue;">在分区表上使用时，请更改表…仅在每个分区中按顺序排列行。</p>
            <h4><a name="alter-table-partition-options"></a>Partitioning Options</h4>
            <p>
                <em class="replaceable"><code>partition_options</code></em> signifies options
                that can be used with partitioned tables for repartitioning, to
                add, drop, discard, import, merge, and split partitions, and to
                perform partitioning maintenance.
            </p><p style="color:blue;">partition_options表示可与分区表一起使用的选项，用于重新分区、添加、删除、放弃、导入、合并和拆分分区以及执行分区维护。</p><p>
            It is possible for an <a class="link" href="sql-syntax.html#alter-table" title="13.1.8&nbsp;ALTER TABLE Syntax"><code class="literal">ALTER TABLE</code></a>
            statement to contain a <code class="literal">PARTITION BY</code> or
            <code class="literal">REMOVE PARTITIONING</code> clause in an addition to
            other alter specifications, but the <code class="literal">PARTITION
            BY</code> or <code class="literal">REMOVE PARTITIONING</code> clause must
            be specified last after any other specifications. The <code class="literal">ADD
            PARTITION</code>, <code class="literal">DROP PARTITION</code>,
            <code class="literal">DISCARD PARTITION</code>, <code class="literal">IMPORT
            PARTITION</code>, <code class="literal">COALESCE PARTITION</code>,
            <code class="literal">REORGANIZE PARTITION</code>, <code class="literal">EXCHANGE
            PARTITION</code>, <code class="literal">ANALYZE PARTITION</code>,
            <code class="literal">CHECK PARTITION</code>, and <code class="literal">REPAIR
            PARTITION</code> options cannot be combined with other alter
            specifications in a single <code class="literal">ALTER TABLE</code>, since
            the options just listed act on individual partitions.
        </p><p style="color:blue;">ALTALTABLE语句可以在其他ALT规范的添加中包含分区或移除分区子句，但是必须在任何其他规范之后指定分区或移除分区子句。添加分区、删除分区、丢弃分区、导入分区、合并分区、重组分区、交换分区、分析分区、检查分区和修复分区选项不能与单个ALTE表中的其他ALTER规范相结合，因为刚才列出的选项对单个分区起作用。</p><p>
            For more information about partition options, see
            <a class="xref" href="sql-syntax.html#create-table" title="13.1.18&nbsp;CREATE TABLE Syntax">Section&nbsp;13.1.18, “CREATE TABLE Syntax”</a>, and
            <a class="xref" href="sql-syntax.html#alter-table-partition-operations" title="13.1.8.1&nbsp;ALTER TABLE Partition Operations">Section&nbsp;13.1.8.1, “ALTER TABLE Partition Operations”</a>. For
            information about and examples of <code class="literal">ALTER TABLE ...
            EXCHANGE PARTITION</code> statements, see
            <a class="xref" href="partitioning.html#partitioning-management-exchange" title="22.3.3&nbsp;Exchanging Partitions and Subpartitions with Tables">Section&nbsp;22.3.3, “Exchanging Partitions and Subpartitions with Tables”</a>.
        </p><p style="color:blue;">有关分区选项的更多信息，请参阅第13.1.18节“创建表语法”和第13.1.8.1节“更改表分区操作”。有关alter table的信息和示例…Exchange分区语句，参见第22.3.3节，“用表交换分区和子分区”。</p><p>
            Prior to MySQL 5.7.6, partitioned <code class="literal">InnoDB</code> tables
            used the generic <code class="literal">ha_partition</code> partitioning
            handler employed by <code class="literal">MyISAM</code> and other storage
            engines not supplying their own partitioning handlers; in MySQL
            5.7.6 and later, such tables are created using the
            <code class="literal">InnoDB</code> storage engine's own (or
            <span class="quote">“<span class="quote">native</span>”</span>) partitioning handler. Beginning with MySQL
            5.7.9, you can upgrade an <code class="literal">InnoDB</code> table that was
            created in MySQL 5.7.6 or earlier (that is, created using
            <code class="literal">ha_partition</code>) to the <code class="literal">InnoDB</code>
            native partition handler using <code class="literal">ALTER TABLE ... UPGRADE
            PARTITIONING</code>. (Bug #76734, Bug #20727344) This
            <code class="literal">ALTER TABLE</code> syntax does not accept any other
            options and can be used only on a single table at a time. You can
            also use <a class="link" href="programs.html#mysql-upgrade" title="4.4.7&nbsp;mysql_upgrade — Check and Upgrade MySQL Tables"><span class="command"><strong>mysql_upgrade</strong></span></a> in MySQL 5.7.9 or later
            to upgrade older partitioned <span class="command"><strong>InnoDB</strong></span> tables to
            the native partitioning handler.
        </p><p style="color:blue;">在mysql 5.7.6之前，分区的innodb表使用myisam和其他不提供自己分区处理程序的存储引擎使用的通用ha_分区处理程序；在mysql 5.7.6和更高版本中，这些表是使用innodb存储引擎自己（或“本机”）的分区处理程序创建的。从mysql 5.7.9开始，您可以使用alter table将在mysql 5.7.6或更早版本中创建的innodb表（即使用ha_分区创建的）升级到innodb本机分区处理程序……升级分区。（错误76734，错误20727344）此alter table语法不接受任何其他选项，一次只能在单个表上使用。您还可以使用mysql 5.7.9或更高版本中的mysql_upgrade将旧的分区innodb表升级到本机分区处理程序。</p>
            <div class="section">

                <div class="titlepage">
                    <div>
                        <div>
                            <h4 class="title"><a name="alter-table-partition-operations"></a>13.1.8.1&nbsp;ALTER TABLE Partition Operations</h4>
                        </div>
                    </div>
                </div>
                <p>
                    Partitioning-related clauses for <a class="link" href="sql-syntax.html#alter-table" title="13.1.8&nbsp;ALTER TABLE Syntax"><code class="literal">ALTER
                    TABLE</code></a> can be used with partitioned tables for
                    repartitioning, to add, drop, discard, import, merge, and split
                    partitions, and to perform partitioning maintenance.
                </p><p style="color:blue;">alter table的分区相关子句可与分区表一起用于重新分区、添加、删除、放弃、导入、合并和拆分分区以及执行分区维护。</p>
                <div class="itemizedlist">
                    <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                        Simply using a <em class="replaceable"><code>partition_options</code></em>
                        clause with <a class="link" href="sql-syntax.html#alter-table" title="13.1.8&nbsp;ALTER TABLE Syntax"><code class="literal">ALTER TABLE</code></a> on a
                        partitioned table repartitions the table according to the
                        partitioning scheme defined by the
                        <em class="replaceable"><code>partition_options</code></em>. This clause
                        always begins with <code class="literal">PARTITION BY</code>, and
                        follows the same syntax and other rules as apply to the
                        <em class="replaceable"><code>partition_options</code></em> clause for
                        <a class="link" href="sql-syntax.html#create-table" title="13.1.18&nbsp;CREATE TABLE Syntax"><code class="literal">CREATE TABLE</code></a> (for more
                        detailed information, see <a class="xref" href="sql-syntax.html#create-table" title="13.1.18&nbsp;CREATE TABLE Syntax">Section&nbsp;13.1.18, “CREATE TABLE Syntax”</a>),
                        and can also be used to partition an existing table that is
                        not already partitioned. For example, consider a
                        (nonpartitioned) table defined as shown here:
                    </p><p style="color:blue;">只需在分区表上使用带alter table的partition_options子句，就可以根据partition_options定义的分区方案重新分区表。此子句总是以分区为开始，并遵循与创建表的分区选项选项子句相同的语法和其他规则（对于更详细的信息，参见第131.18节，“创建表语法”），并且也可以用于对尚未分区的现有表进行分区。例如，考虑如下所示定义的（非分区的）表：</p><pre data-lang="sql" class="programlisting">CREATE TABLE t1 (
    id INT,
    year_col INT
);
</pre><p>
                        This table can be partitioned by <code class="literal">HASH</code>,
                        using the <code class="literal">id</code> column as the partitioning
                        key, into 8 partitions by means of this statement:
                    </p><p style="color:blue;">使用以下语句，可以使用哈希将该表分区为8个分区，使用id列作为分区键：</p><pre data-lang="sql" class="programlisting">ALTER TABLE t1
    PARTITION BY HASH(id)
    PARTITIONS 8;
</pre><p>
                        MySQL supports an <code class="literal">ALGORITHM</code> option with
                        <code class="literal">[SUB]PARTITION BY [LINEAR] KEY</code>.
                        <code class="literal">ALGORITHM=1</code> causes the server to use the
                        same key-hashing functions as MySQL 5.1 when computing the
                        placement of rows in partitions;
                        <code class="literal">ALGORITHM=2</code> means that the server employs
                        the key-hashing functions implemented and used by default
                        for new <code class="literal">KEY</code> partitioned tables in MySQL
                        5.5 and later. (Partitioned tables created with the
                        key-hashing functions employed in MySQL 5.5 and later cannot
                        be used by a MySQL 5.1 server.) Not specifying the option
                        has the same effect as using <code class="literal">ALGORITHM=2</code>.
                        This option is intended for use chiefly when upgrading or
                        downgrading <code class="literal">[LINEAR] KEY</code> partitioned
                        tables between MySQL 5.1 and later MySQL versions, or for
                        creating tables partitioned by <code class="literal">KEY</code> or
                        <code class="literal">LINEAR KEY</code> on a MySQL 5.5 or later server
                        which can be used on a MySQL 5.1 server.
                    </p><p style="color:blue;">MySQL支持[Sub]分区由[线性]键的算法选项。algorithm=1导致服务器在计算分区中行的位置时使用与mysql 5.1相同的密钥哈希函数；algorithm=2意味着服务器使用mysql 5.5及更高版本中默认实现并用于新的密钥分区表的密钥哈希函数。（使用mysql 5.5及更高版本中使用的键散列函数创建的分区表不能由mysql 5.1服务器使用。）不指定该选项的效果与使用algorithm=2相同。此选项主要用于在mysql 5.1和更高版本之间升级或降级[线性]键分区表，或用于在mysql 5.5或更高版本的服务器上创建可在mysql 5.1服务器上使用的按键或线性键分区的表。</p><p>
                        To upgrade a <code class="literal">KEY</code> partitioned table that
                        was created in MySQL 5.1, first execute
                        <a class="link" href="sql-syntax.html#show-create-table" title="13.7.5.10&nbsp;SHOW CREATE TABLE Syntax"><code class="literal">SHOW CREATE TABLE</code></a> and note
                        the exact columns and number of partitions shown. Now
                        execute an <code class="literal">ALTER TABLE</code> statement using
                        exactly the same column list and number of partitions as in
                        the <code class="literal">CREATE TABLE</code> statement, while adding
                        <code class="literal">ALGORITHM=2</code> immediately following the
                        <code class="literal">PARTITION BY</code> keywords. (You should also
                        include the <code class="literal">LINEAR</code> keyword if it was used
                        for the original table definition.) An example from a
                        session in the <a class="link" href="programs.html#mysql" title="4.5.1&nbsp;mysql — The MySQL Command-Line Client"><span class="command"><strong>mysql</strong></span></a> client is shown
                        here:
                    </p><p style="color:blue;">要升级在mysql 5.1中创建的键分区表，首先执行show create table并记下显示的确切列和分区数。现在，使用与创建表语句中相同的列列表和分区数执行ALTALTABLE语句，而在关键字分区之后立即添加算法＝2。（如果线性关键字用于原始表定义，则还应包含该关键字。）以下是MySQL客户端中会话的示例：</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>SHOW CREATE TABLE p\G</code></strong>
*************************** 1. row ***************************
       Table: p
Create Table: CREATE TABLE `p` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `cd` datetime NOT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=latin1
/*!50100 <span class="emphasis"><em>PARTITION BY LINEAR KEY (id)
PARTITIONS 32</em></span> */
1 row in set (0.00 sec)

mysql&gt; <strong class="userinput"><code>ALTER TABLE p</code></strong> <span class="emphasis"><em>PARTITION BY LINEAR KEY ALGORITHM=2 (id) PARTITIONS 32</em></span><strong class="userinput"><code>;</code></strong>
Query OK, 0 rows affected (5.34 sec)
Records: 0  Duplicates: 0  Warnings: 0

mysql&gt; <strong class="userinput"><code>SHOW CREATE TABLE p\G</code></strong>
*************************** 1. row ***************************
       Table: p
Create Table: CREATE TABLE `p` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `cd` datetime NOT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=latin1
/*!50100 PARTITION BY LINEAR KEY (id)
PARTITIONS 32 */
1 row in set (0.00 sec)
</pre><p>
                        Downgrading a table created using the default key-hashing
                        used in MySQL 5.5 and later to enable its use by a MySQL 5.1
                        server is similar, except in this case you should use
                        <code class="literal">ALGORITHM=1</code> to force the table's
                        partitions to be rebuilt using the MySQL 5.1 key-hashing
                        functions. It is recommended that you not do this except
                        when necessary for compatibility with a MySQL 5.1 server, as
                        the improved <code class="literal">KEY</code> hashing functions used
                        by default in MySQL 5.5 and later provide fixes for a number
                        of issues found in the older implementation.
                    </p><p style="color:blue;">使用mysql 5.5和更高版本中使用的默认键散列来降级创建的表，以使mysql 5.1服务器能够使用该表是类似的，但在这种情况下，您应该使用algorithm=1来强制使用mysql 5.1键散列函数重新生成表的分区。建议您不要这样做，除非在与mysql 5.1服务器兼容时需要这样做，因为mysql 5.5和更高版本中默认使用的改进的密钥散列函数可以修复在旧实现中发现的许多问题。</p>
                        <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">

                            <div class="admon-title">
                                Note
                            </div>
                            <p>
                                A table upgraded by means of <code class="literal">ALTER TABLE ...
                                PARTITION BY ALGORITHM=2 [LINEAR] KEY ...</code> can no
                                longer be used by a MySQL 5.1 server. (Such a table would
                                need to be downgraded with <code class="literal">ALTER TABLE ...
                                PARTITION BY ALGORITHM=1 [LINEAR] KEY ...</code> before
                                it could be used again by a MySQL 5.1 server.)
                            </p><p style="color:blue;">通过alter table升级的表…按算法分区= 2 [线性]键…mysql 5.1服务器不能再使用。（这样的表需要使用alter table降级…按算法分区= 1 [线性]键…在MySQL5.1服务器再次使用之前。）</p>
                        </div>
                        <p>
                            The table that results from using an <code class="literal">ALTER TABLE
                            ... PARTITION BY</code> statement must follow the same
                            rules as one created using <code class="literal">CREATE TABLE ...
                            PARTITION BY</code>. This includes the rules governing
                            the relationship between any unique keys (including any
                            primary key) that the table might have, and the column or
                            columns used in the partitioning expression, as discussed in
                            <a class="xref" href="partitioning.html#partitioning-limitations-partitioning-keys-unique-keys" title="22.6.1&nbsp;Partitioning Keys, Primary Keys, and Unique Keys">Section&nbsp;22.6.1, “Partitioning Keys, Primary Keys, and Unique Keys”</a>.
                            The <code class="literal">CREATE TABLE ... PARTITION BY</code> rules
                            for specifying the number of partitions also apply to
                            <code class="literal">ALTER TABLE ... PARTITION BY</code>.
                        </p><p style="color:blue;">使用alter表生成的表…语句分区必须遵循与使用CREATE表创建的规则相同的规则。分区。这包括控制表可能具有的任何唯一键（包括任何主键）与分区表达式中使用的列之间关系的规则，如第22.6.1节“分区键、主键和唯一键”中所述。创建表…按分区分区规则指定分区数也适用于ALTER表…分区。</p><p>
                            The <em class="replaceable"><code>partition_definition</code></em> clause
                            for <code class="literal">ALTER TABLE ADD PARTITION</code> supports
                            the same options as the clause of the same name for the
                            <a class="link" href="sql-syntax.html#create-table" title="13.1.18&nbsp;CREATE TABLE Syntax"><code class="literal">CREATE TABLE</code></a> statement. (See
                            <a class="xref" href="sql-syntax.html#create-table" title="13.1.18&nbsp;CREATE TABLE Syntax">Section&nbsp;13.1.18, “CREATE TABLE Syntax”</a>, for the syntax and
                            description.) Suppose that you have the partitioned table
                            created as shown here:
                        </p><p style="color:blue;">ALTALTABLE添加分区的分区定义子句支持与CREATETABLE语句的同名子句相同的选项。（有关语法和说明，请参见13.1.18节“创建表语法”。）假设已创建分区表，如下所示：</p><pre data-lang="sql" class="programlisting">CREATE TABLE t1 (
    id INT,
    year_col INT
)
PARTITION BY RANGE (year_col) (
    PARTITION p0 VALUES LESS THAN (1991),
    PARTITION p1 VALUES LESS THAN (1995),
    PARTITION p2 VALUES LESS THAN (1999)
);
</pre><p>
                            You can add a new partition <code class="literal">p3</code> to this
                            table for storing values less than <code class="literal">2002</code>
                            as follows:
                        </p><p style="color:blue;">可以将新分区p3添加到此表中，用于存储小于2002的值，如下所示：</p><pre data-lang="sql" class="programlisting">ALTER TABLE t1 ADD PARTITION (PARTITION p3 VALUES LESS THAN (2002));
</pre><p>
                            <code class="literal">DROP PARTITION</code> can be used to drop one or
                            more <code class="literal">RANGE</code> or <code class="literal">LIST</code>
                            partitions. This statement cannot be used with
                            <code class="literal">HASH</code> or <code class="literal">KEY</code>
                            partitions; instead, use <code class="literal">COALESCE
                            PARTITION</code> (see below). Any data that was stored in
                            the dropped partitions named in the
                            <em class="replaceable"><code>partition_names</code></em> list is
                            discarded. For example, given the table
                            <code class="literal">t1</code> defined previously, you can drop the
                            partitions named <code class="literal">p0</code> and
                            <code class="literal">p1</code> as shown here:
                        </p><p style="color:blue;">Delp分区可用于删除一个或多个范围或列表分区。此语句不能用于哈希或密钥分区；相反，请使用CueSeCe分区（见下文）。存储在分区名称列表中名为的已删除分区中的任何数据都将被丢弃。例如，给定前面定义的表T1，可以删除名为P0和P1的分区，如下所示：</p><pre data-lang="sql" class="programlisting">ALTER TABLE t1 DROP PARTITION p0, p1;
</pre>
                        <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">

                            <div class="admon-title">
                                Note
                            </div>
                            <p>
                                <code class="literal">DROP PARTITION</code> does not work with
                                tables that use the <a class="link" href="mysql-cluster.html" title="Chapter&nbsp;21&nbsp;MySQL NDB Cluster 7.5 and NDB Cluster 7.6"><code class="literal">NDB</code></a>
                                storage engine. See
                                <a class="xref" href="partitioning.html#partitioning-management-range-list" title="22.3.1&nbsp;Management of RANGE and LIST Partitions">Section&nbsp;22.3.1, “Management of RANGE and LIST Partitions”</a>, and
                                <a class="xref" href="mysql-cluster.html#mysql-cluster-limitations" title="21.1.7&nbsp;Known Limitations of NDB Cluster">Section&nbsp;21.1.7, “Known Limitations of NDB Cluster”</a>.
                            </p><p style="color:blue;">Delp分区与使用NDB存储引擎的表不起作用。参见第22.3.1节“范围和列表分区的管理”和第21.1.7节“ndb集群的已知限制”。</p>
                        </div>
                        <p>
                            <code class="literal">ADD PARTITION</code> and <code class="literal">DROP
                            PARTITION</code> do not currently support <code class="literal">IF
                            [NOT] EXISTS</code>.
                        </p><p style="color:blue;">如果存在（不存在），则当前不支持添加分区和删除分区。</p><p>
                            <a class="link" href="sql-syntax.html#alter-table" title="13.1.8&nbsp;ALTER TABLE Syntax"><code class="literal">DISCARD
                                PARTITION ... TABLESPACE</code></a> and
                            <a class="link" href="sql-syntax.html#alter-table" title="13.1.8&nbsp;ALTER TABLE Syntax"><code class="literal">IMPORT
                                PARTITION ... TABLESPACE</code></a> options extend the
                            <a class="link" href="glossary.html#glos_transportable_tablespace" title="transportable tablespace">Transportable
                                Tablespace</a> feature to individual
                            <code class="literal">InnoDB</code> table partitions. Each
                            <code class="literal">InnoDB</code> table partition has its own
                            tablespace file (<code class="filename">.ibd</code> file). The
                            <a class="link" href="glossary.html#glos_transportable_tablespace" title="transportable tablespace">Transportable
                                Tablespace</a> feature makes it easy to copy the
                            tablespaces from a running MySQL server instance to another
                            running instance, or to perform a restore on the same
                            instance. Both options take a list of one or more
                            comma-separated partition names. For example:
                        </p><p style="color:blue;">丢弃分区…表空间和导入分区…表空间选项将可传输表空间特性扩展到单个innodb表分区。每个innodb表分区都有自己的表空间文件（.ibd文件）。可移植的表空间特性使得将表空间从一个正在运行的mysql服务器实例复制到另一个正在运行的实例或在同一实例上执行还原变得很容易。两个选项都采用一个或多个逗号分隔分区名称的列表。例如：</p><pre data-lang="sql" class="programlisting">ALTER TABLE t1 DISCARD PARTITION p2, p3 TABLESPACE;
</pre><pre data-lang="sql" class="programlisting">ALTER TABLE t1 IMPORT PARTITION p2, p3 TABLESPACE;
</pre><p>
                            When running
                            <a class="link" href="sql-syntax.html#alter-table" title="13.1.8&nbsp;ALTER TABLE Syntax"><code class="literal">DISCARD
                                PARTITION ... TABLESPACE</code></a> and
                            <a class="link" href="sql-syntax.html#alter-table" title="13.1.8&nbsp;ALTER TABLE Syntax"><code class="literal">IMPORT
                                PARTITION ... TABLESPACE</code></a> on subpartitioned tables,
                            both partition and subpartition names are allowed. When a
                            partition name is specified, subpartitions of that partition
                            are included.
                        </p><p style="color:blue;">运行丢弃分区时…表空间和导入分区…子分区表上的表空间，允许同时使用分区名和子分区名。指定分区名称时，将包含该分区的子分区。</p><p>
                            The
                            <a class="link" href="glossary.html#glos_transportable_tablespace" title="transportable tablespace">Transportable
                                Tablespace</a> feature also supports copying or restoring
                            partitioned <code class="literal">InnoDB</code> tables (all partitions
                            at once). For addition information about the
                            <a class="link" href="glossary.html#glos_transportable_tablespace" title="transportable tablespace">Transportable
                                Tablespace</a> feature, see
                            <a class="xref" href="innodb-storage-engine.html#tablespace-copying" title="14.6.3.7&nbsp;Copying Tablespaces to Another Instance">Section&nbsp;14.6.3.7, “Copying Tablespaces to Another Instance”</a>. For usage examples,
                            see
                            <a class="xref" href="innodb-storage-engine.html#innodb-transportable-tablespace-examples" title="14.6.3.7.1&nbsp;Transportable Tablespace Examples">Section&nbsp;14.6.3.7.1, “Transportable Tablespace Examples”</a>.
                        </p><p style="color:blue;">transportable tablespace特性还支持复制或恢复分区的innodb表（一次复制或恢复所有分区）。有关可传输表空间功能的其他信息，请参阅14.6.3.7节“将表空间复制到另一个实例”。有关用法示例，请参阅14.6.3.7.1节“可传输表空间示例”。</p><p>
                            Renames of partitioned tables are supported. You can rename
                            individual partitions indirectly using <code class="literal">ALTER TABLE
                            ... REORGANIZE PARTITION</code>; however, this operation
                            copies the partition's data.
                        </p><p style="color:blue;">支持分区表的重命名。可以使用alter table间接重命名各个分区…重新组织分区，但是，这个操作复制分区的数据。</p><p>
                            To delete rows from selected partitions, use the
                            <code class="literal">TRUNCATE PARTITION</code> option. This option
                            takes a comma-separated list of one or more partition names.
                            For example, consider the table <code class="literal">t1</code> as
                            defined here:
                        </p><p style="color:blue;">若要删除选定分区中的行，请使用截断分区选项。此选项接受一个或多个分区名称的逗号分隔列表。例如，考虑如下定义的表T1：</p><pre data-lang="sql" class="programlisting">CREATE TABLE t1 (
    id INT,
    year_col INT
)
PARTITION BY RANGE (year_col) (
    PARTITION p0 VALUES LESS THAN (1991),
    PARTITION p1 VALUES LESS THAN (1995),
    PARTITION p2 VALUES LESS THAN (1999),
    PARTITION p3 VALUES LESS THAN (2003),
    PARTITION p4 VALUES LESS THAN (2007)
);
</pre><p>
                            To delete all rows from partition <code class="literal">p0</code>, use
                            the following statement:
                        </p><p style="color:blue;">要从分区p0中删除所有行，请使用以下语句：</p><pre data-lang="sql" class="programlisting">ALTER TABLE t1 TRUNCATE PARTITION p0;
</pre><p>
                            The statement just shown has the same effect as the
                            following <a class="link" href="sql-syntax.html#delete" title="13.2.2&nbsp;DELETE Syntax"><code class="literal">DELETE</code></a> statement:
                        </p><p style="color:blue;">刚才显示的语句与下面的delete语句具有相同的效果：</p><pre data-lang="sql" class="programlisting">DELETE FROM t1 WHERE year_col &lt; 1991;
</pre><p>
                            When truncating multiple partitions, the partitions do not
                            have to be contiguous: This can greatly simplify delete
                            operations on partitioned tables that would otherwise
                            require very complex <code class="literal">WHERE</code> conditions if
                            done with <a class="link" href="sql-syntax.html#delete" title="13.2.2&nbsp;DELETE Syntax"><code class="literal">DELETE</code></a> statements.
                            For example, this statement deletes all rows from partitions
                            <code class="literal">p1</code> and <code class="literal">p3</code>:
                        </p><p style="color:blue;">当截断多个分区时，分区不必是连续的：这可以极大地简化对分区表的删除操作，否则，如果使用delete语句，则需要非常复杂的where条件。例如，此语句删除分区p1和p3中的所有行：</p><pre data-lang="sql" class="programlisting">ALTER TABLE t1 TRUNCATE PARTITION p1, p3;
</pre><p>
                            An equivalent <a class="link" href="sql-syntax.html#delete" title="13.2.2&nbsp;DELETE Syntax"><code class="literal">DELETE</code></a>
                            statement is shown here:
                        </p><p style="color:blue;">等效的delete语句如下所示：</p><pre data-lang="sql" class="programlisting">DELETE FROM t1 WHERE
    (year_col &gt;= 1991 AND year_col &lt; 1995)
    OR
    (year_col &gt;= 2003 AND year_col &lt; 2007);
</pre><p>
                            If you use the <code class="literal">ALL</code> keyword in place of
                            the list of partition names, the statement acts on all table
                            partitions.
                        </p><p style="color:blue;">如果使用all关键字代替分区名称列表，则该语句将作用于所有表分区。</p><p>
                            <code class="literal">TRUNCATE PARTITION</code> merely deletes rows;
                            it does not alter the definition of the table itself, or of
                            any of its partitions.
                        </p><p style="color:blue;">截断分区只删除行；它不会改变表本身或其分区的定义。</p><p>
                            To verify that the rows were dropped, check the
                            <code class="literal">INFORMATION_SCHEMA.PARTITIONS</code> table,
                            using a query such as this one:
                        </p><p style="color:blue;">若要验证行已被删除，请使用诸如此查询之类的查询检查“信息”模式分区分区表：</p><pre data-lang="sql" class="programlisting">SELECT PARTITION_NAME, TABLE_ROWS
    FROM INFORMATION_SCHEMA.PARTITIONS
    WHERE TABLE_NAME = 't1';
</pre><p>
                            <code class="literal">TRUNCATE PARTITION</code> is supported only for
                            partitioned tables that use the
                            <a class="link" href="storage-engines.html#myisam-storage-engine" title="15.2&nbsp;The MyISAM Storage Engine"><code class="literal">MyISAM</code></a>,
                            <a class="link" href="innodb-storage-engine.html" title="Chapter&nbsp;14&nbsp;The InnoDB Storage Engine"><code class="literal">InnoDB</code></a>, or
                            <a class="link" href="storage-engines.html#memory-storage-engine" title="15.3&nbsp;The MEMORY Storage Engine"><code class="literal">MEMORY</code></a> storage engine. It also
                            works on <a class="link" href="storage-engines.html#blackhole-storage-engine" title="15.6&nbsp;The BLACKHOLE Storage Engine"><code class="literal">BLACKHOLE</code></a> tables (but
                            has no effect). It is not supported for
                            <a class="link" href="storage-engines.html#archive-storage-engine" title="15.5&nbsp;The ARCHIVE Storage Engine"><code class="literal">ARCHIVE</code></a> tables.
                        </p><p style="color:blue;">仅对分区表支持分区分区，该分区表使用内存、引擎或内存存储引擎。它也适用于黑洞表（但没有效果）。存档表不支持它。</p><p>
                            <code class="literal">COALESCE PARTITION</code> can be used with a
                            table that is partitioned by <code class="literal">HASH</code> or
                            <code class="literal">KEY</code> to reduce the number of partitions by
                            <em class="replaceable"><code>number</code></em>. Suppose that you have
                            created table <code class="literal">t2</code> as follows:
                        </p><p style="color:blue;">合并分区可用于由哈希或键划分的表，以减少分区的数量。假设您已经创建了表t2，如下所示：</p><pre data-lang="sql" class="programlisting">CREATE TABLE t2 (
    name VARCHAR (30),
    started DATE
)
PARTITION BY HASH( YEAR(started) )
PARTITIONS 6;
</pre><p>
                            To reduce the number of partitions used by
                            <code class="literal">t2</code> from 6 to 4, use the following
                            statement:
                        </p><p style="color:blue;">要将t2使用的分区数从6减少到4，请使用以下语句：</p><pre data-lang="sql" class="programlisting">ALTER TABLE t2 COALESCE PARTITION 2;
</pre><p>
                            The data contained in the last
                            <em class="replaceable"><code>number</code></em> partitions will be merged
                            into the remaining partitions. In this case, partitions 4
                            and 5 will be merged into the first 4 partitions (the
                            partitions numbered 0, 1, 2, and 3).
                        </p><p style="color:blue;">最后几个分区中包含的数据将合并到其余的分区中。在这种情况下，分区4和5将合并到前4个分区（编号为0、1、2和3的分区）。</p><p>
                            To change some but not all the partitions used by a
                            partitioned table, you can use <code class="literal">REORGANIZE
                            PARTITION</code>. This statement can be used in several
                            ways:
                        </p><p style="color:blue;">若要更改分区表所使用的部分但不是所有分区，可以使用重新组织分区。此语句可以通过多种方式使用：</p>
                        <div class="itemizedlist">
                            <ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
                                To merge a set of partitions into a single partition.
                                This is done by naming several partitions in the
                                <em class="replaceable"><code>partition_names</code></em> list and
                                supplying a single definition for
                                <em class="replaceable"><code>partition_definition</code></em>.
                            </p><p style="color:blue;">将一组分区合并为一个分区。这是通过在“分区名称”列表中命名多个分区并为分区定义提供单个定义来完成的。</p></li><li class="listitem"><p>
                                To split an existing partition into several partitions.
                                Accomplish this by naming a single partition for
                                <em class="replaceable"><code>partition_names</code></em> and providing
                                multiple
                                <em class="replaceable"><code>partition_definitions</code></em>.
                            </p><p style="color:blue;">将现有分区拆分为几个分区。通过为分区名称命名一个分区并提供多个分区定义来实现这一点。</p></li><li class="listitem"><p>
                                To change the ranges for a subset of partitions defined
                                using <code class="literal">VALUES LESS THAN</code> or the value
                                lists for a subset of partitions defined using
                                <code class="literal">VALUES IN</code>.
                            </p><p style="color:blue;">更改使用小于的值定义的分区子集的范围或使用中的值定义的分区子集的值列表。</p></li><li class="listitem"><p>
                                This statement may also be used without the
                                <code class="literal"><em class="replaceable"><code>partition_names</code></em> INTO
                                    (<em class="replaceable"><code>partition_definitions</code></em>)</code>
                                option on tables that are automatically partitioned
                                using <code class="literal">HASH</code> partitioning to force
                                redistribution of data. (Currently, only
                                <a class="link" href="mysql-cluster.html" title="Chapter&nbsp;21&nbsp;MySQL NDB Cluster 7.5 and NDB Cluster 7.6"><code class="literal">NDB</code></a> tables are
                                automatically partitioned in this way.) This is useful
                                in NDB Cluster where, after you have added new NDB
                                Cluster data nodes online to an existing NDB Cluster,
                                you wish to redistribute existing NDB Cluster table data
                                to the new data nodes. In such cases, you should invoke
                                the statement with the
                                <code class="literal">ALGORITHM=INPLACE</code> option; in other
                                words, as shown here:
                            </p><p style="color:blue;">对于使用哈希分区自动分区以强制重新分配数据的表，也可以在不使用partition_names into（partition_definitions）选项的情况下使用此语句。（目前，只有NDB表以这种方式自动分区）。这在NDB集群中是有用的，在您将新的NDB集群数据节点添加到现有的NDB集群之后，您希望将现有的NDB集群表数据重新分配给新的数据节点。在这种情况下，应该使用algorithm=inplace选项调用语句；换句话说，如下所示：</p><pre data-lang="sql" class="programlisting">ALTER TABLE <em class="replaceable"><code>table</code></em> ALGORITHM=INPLACE, REORGANIZE PARTITION;
</pre><p>
                                You cannot perform other DDL concurrently with online
                                table reorganization—that is, no other DDL
                                statements can be issued while an <code class="literal">ALTER TABLE
                                ... ALGORITHM=INPLACE, REORGANIZE PARTITION</code>
                                statement is executing. For more information about
                                adding NDB Cluster data nodes online, see
                                <a class="xref" href="mysql-cluster.html#mysql-cluster-online-add-node" title="21.5.15&nbsp;Adding NDB Cluster Data Nodes Online">Section&nbsp;21.5.15, “Adding NDB Cluster Data Nodes Online”</a>.
                            </p><p style="color:blue;">不能在联机表重组的同时执行其他ddl，也就是说，当alter table…算法= InPress，重新组织分区语句正在执行。有关联机添加ndb群集数据节点的详细信息，请参阅21.5.15节“联机添加ndb群集数据节点”。</p>
                                <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">

                                    <div class="admon-title">
                                        Note
                                    </div>
                                    <p>
                                        <code class="literal">ALTER TABLE ... ALGORITHM=INPLACE, REORGANIZE
                                            PARTITION</code> does not work with tables which
                                        were created using the <code class="literal">MAX_ROWS</code>
                                        option, because it uses the constant
                                        <code class="literal">MAX_ROWS</code> value specified in the
                                        original <a class="link" href="sql-syntax.html#create-table" title="13.1.18&nbsp;CREATE TABLE Syntax"><code class="literal">CREATE TABLE</code></a>
                                        statement to determine the number of partitions
                                        required, so no new partitions are created. Instead,
                                        you can use <code class="literal">ALTER TABLE ...
                                        ALGORITHM=INPLACE,
                                        MAX_ROWS=<em class="replaceable"><code>rows</code></em></code> to
                                        increase the maximum number of rows for such a table;
                                        in this case, <code class="literal">ALTER TABLE ...
                                        ALGORITHM=INPLACE, REORGANIZE PARTITION</code> is
                                        not needed (and causes an error if executed). The
                                        value of <em class="replaceable"><code>rows</code></em> must be
                                        greater than the value specified for
                                        <code class="literal">MAX_ROWS</code> in the original
                                        <code class="literal">CREATE TABLE</code> statement for this to
                                        work.
                                    </p><p style="color:blue;">更改表…算法= InPress，RealStudio分区不与使用Max Sype选项创建的表一起使用，因为它使用在原始CREATETABLE语句中指定的常数Max Sturn值来确定所需的分区数，因此不创建新的分区。相反，您可以使用alter table…算法= InPoT，Max StROWS =行以增加这样一个表的最大行数；在这种情况下，ALTER表…算法= InPoT，不需要重新组织分区（如果执行时会导致错误）。行的值必须大于在原始CREATE TABLE语句中为MAX U ROWS指定的值，才能正常工作。</p><p>
                                    Employing <code class="literal">MAX_ROWS</code> to force the
                                    number of table partitions is deprecated in NDB 7.5.4
                                    and later; use <code class="literal">PARTITION_BALANCE</code>
                                    instead (see
                                    <a class="xref" href="sql-syntax.html#create-table-comment-ndb-table-options" title="Setting NDB_TABLE options">Setting NDB_TABLE options</a>).
                                </p><p style="color:blue;">在NDB 7.5.4和更高版本中禁止使用Max行来强制表分区的数目；相反，使用StutyTyCalm（请参见设置NdBJTABLE选项）。</p>
                                </div>
                                <p>
                                    Attempting to use <code class="literal">REORGANIZE
                                    PARTITION</code> without the
                                    <code class="literal"><em class="replaceable"><code>partition_names</code></em> INTO
                                        (<em class="replaceable"><code>partition_definitions</code></em>)</code>
                                    option on explicitly partitioned tables results in the
                                    error <span class="errortext">REORGANIZE PARTITION without parameters
                can only be used on auto-partitioned tables using HASH
                partitioning</span>.
                                </p><p style="color:blue;">试图在没有显式分区表的情况下使用无分区名的分区分区（分区定义）选项，结果在没有参数的情况下，错误重新组织分区只能在使用哈希分区的自动分区表上使用。</p></li></ul>
                        </div>
                        <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">
                            <div class="admon-title">
                                Note
                            </div>
                            <p>
                                For partitions that have not been explicitly named, MySQL
                                automatically provides the default names
                                <code class="literal">p0</code>, <code class="literal">p1</code>,
                                <code class="literal">p2</code>, and so on. The same is true with
                                regard to subpartitions.
                            </p><p style="color:blue;">对于没有显式命名的分区，mysql会自动提供默认名称p0、p1、p2等。分部分也是如此。</p>
                        </div>
                        <p>
                            For more detailed information about and examples of
                            <code class="literal">ALTER TABLE ... REORGANIZE PARTITION</code>
                            statements, see
                            <a class="xref" href="partitioning.html#partitioning-management-range-list" title="22.3.1&nbsp;Management of RANGE and LIST Partitions">Section&nbsp;22.3.1, “Management of RANGE and LIST Partitions”</a>.
                        </p><p style="color:blue;">有关alter table的更多详细信息和示例…重新组织分区语句，参见第22.3.1节，“范围和列表分区的管理”。</p></li><li class="listitem"><p>
                        To exchange a table partition or subpartition with a table,
                        use the <a class="link" href="sql-syntax.html#alter-table" title="13.1.8&nbsp;ALTER TABLE Syntax"><code class="literal">ALTER
                        TABLE ... EXCHANGE PARTITION</code></a> statement—that
                        is, to move any existing rows in the partition or
                        subpartition to the nonpartitioned table, and any existing
                        rows in the nonpartitioned table to the table partition or
                        subpartition.
                    </p><p style="color:blue;">要与表交换表分区或子分区，请使用alter table…Exchange分区语句，即将分区或子分区中的任何现有行移动到非分区表，以及非分区表中的任何现有行到表分区或子分区。</p><p>
                        For usage information and examples, see
                        <a class="xref" href="partitioning.html#partitioning-management-exchange" title="22.3.3&nbsp;Exchanging Partitions and Subpartitions with Tables">Section&nbsp;22.3.3, “Exchanging Partitions and Subpartitions with Tables”</a>.
                    </p><p style="color:blue;">有关用法信息和示例，请参阅第22.3.3节“用表交换分区和子分区”。</p></li><li class="listitem"><p>
                        Several options provide partition maintenance and repair
                        functionality analogous to that implemented for
                        nonpartitioned tables by statements such as
                        <a class="link" href="sql-syntax.html#check-table" title="13.7.2.2&nbsp;CHECK TABLE Syntax"><code class="literal">CHECK TABLE</code></a> and
                        <a class="link" href="sql-syntax.html#repair-table" title="13.7.2.5&nbsp;REPAIR TABLE Syntax"><code class="literal">REPAIR TABLE</code></a> (which are also
                        supported for partitioned tables; for more information, see
                        <a class="xref" href="sql-syntax.html#table-maintenance-sql" title="13.7.2&nbsp;Table Maintenance Statements">Section&nbsp;13.7.2, “Table Maintenance Statements”</a>). These include
                        <code class="literal">ANALYZE PARTITION</code>, <code class="literal">CHECK
                        PARTITION</code>, <code class="literal">OPTIMIZE PARTITION</code>,
                        <code class="literal">REBUILD PARTITION</code>, and <code class="literal">REPAIR
                        PARTITION</code>. Each of these options takes a
                        <em class="replaceable"><code>partition_names</code></em> clause consisting
                        of one or more names of partitions, separated by commas. The
                        partitions must already exist in the table to be altered.
                        You can also use the <code class="literal">ALL</code> keyword in place
                        of <em class="replaceable"><code>partition_names</code></em>, in which case
                        the statement acts on all table partitions. For more
                        information and examples, see
                        <a class="xref" href="partitioning.html#partitioning-maintenance" title="22.3.4&nbsp;Maintenance of Partitions">Section&nbsp;22.3.4, “Maintenance of Partitions”</a>.
                    </p><p style="color:blue;">有几个选项提供分区维护和修复功能，类似于通过check table和repair table等语句实现的非分区表的分区维护和修复功能（分区表也支持这些功能；有关更多信息，请参阅第13.7.2节“表维护语句”）。包括分析分区、检查分区、优化分区、重建分区和修复分区。每个选项都有一个partition_names子句，由一个或多个分区名称组成，用逗号分隔。必须在要更改的表中存在分区。您还可以使用all关键字来代替分区名称，在这种情况下，语句将作用于所有表分区。有关更多信息和示例，请参见第22.3.4节“分区维护”。</p><p>
                        Some MySQL storage engines, such as
                        <a class="link" href="innodb-storage-engine.html" title="Chapter&nbsp;14&nbsp;The InnoDB Storage Engine"><code class="literal">InnoDB</code></a>, do not support
                        per-partition optimization. For a partitioned table using
                        such a storage engine, <code class="literal">ALTER TABLE ... OPTIMIZE
                        PARTITION</code> causes the entire table to rebuilt and
                        analyzed, and an appropriate warning to be issued. (Bug
                        #11751825, Bug #42822)
                    </p><p style="color:blue;">一些mysql存储引擎，比如innodb，不支持按分区优化。对于使用这种存储引擎的分区表，请更改表…优化分区，对整个表进行改造和分析，并发出适当警告。（错误11751825，错误42822）</p><p>
                        To work around this problem, use the statements
                        <code class="literal">ALTER TABLE ... REBUILD PARTITION</code> and
                        <code class="literal">ALTER TABLE ... ANALYZE PARTITION</code>
                        instead.
                    </p><p style="color:blue;">若要解决此问题，请使用语句alter table…重建分区和更改表…而是分析分区。</p><p>
                        The <code class="literal">ANALYZE PARTITION</code>, <code class="literal">CHECK
                        PARTITION</code>, <code class="literal">OPTIMIZE PARTITION</code>,
                        and <code class="literal">REPAIR PARTITION</code> options are not
                        permitted for tables which are not partitioned.
                    </p><p style="color:blue;">不分区的表不允许分析分区、检查分区、优化分区和修复分区选项。</p></li><li class="listitem"><p>
                        In MySQL 5.7.9 and later, you can use <code class="literal">ALTER TABLE
                        ... UPGRADE PARTITIONING</code> to upgrade a partitioned
                        <a class="link" href="innodb-storage-engine.html" title="Chapter&nbsp;14&nbsp;The InnoDB Storage Engine"><code class="literal">InnoDB</code></a> table that was created
                        with the old generic partitioning handler to the
                        <code class="literal">InnoDB</code> native partitioning employed in
                        MySQL 5.7.6 and later. Also beginning with MySQL 5.7.9, the
                        <a class="link" href="programs.html#mysql-upgrade" title="4.4.7&nbsp;mysql_upgrade — Check and Upgrade MySQL Tables"><span class="command"><strong>mysql_upgrade</strong></span></a> utility checks for such
                        partitioned <code class="literal">InnoDB</code> tables and attempts to
                        upgrade them to native partitioning as part of its normal
                        operations.
                    </p><p style="color:blue;">在mysql 5.7.9及更高版本中，可以使用alter table…升级分区以升级一个分区的IDYBB表，该表是用旧的通用分区处理程序创建的，用于在MySQL 5.7.6和更高版本中使用的YNODB本机分区。同样从mysql 5.7.9开始，mysql_upgrade实用程序检查这些分区的innodb表，并尝试将它们升级到本机分区，作为其正常操作的一部分。</p>
                        <div class="important" style="margin-left: 0.5in; margin-right: 0.5in;">

                            <div class="admon-title">
                                Important
                            </div>
                            <p>
                                Partitioned <code class="literal">InnoDB</code> tables that do not
                                use the <code class="literal">InnoDB</code> native partitioning
                                handler cannot be used in MySQL 8.0 or later.
                                <code class="literal">ALTER TABLE ... UPGRADE PARTITIONING</code> is
                                not supported in MySQL 8.0 or later; therefore, any
                                partitioned <code class="literal">InnoDB</code> tables that employ
                                the generic handler <span class="emphasis"><em>must</em></span> be upgraded
                                to the InnoDB native handler <span class="emphasis"><em>before</em></span>
                                upgrading your MySQL installation to MySQL 8.0 or later.
                            </p><p style="color:blue;">mysql 8.0或更高版本中不能使用不使用innodb本机分区处理程序的分区innodb表。更改表…在MySQL 8或更高版本中不支持升级分区；因此，在将MySQL安装升级到MySQL 8或更高版本之前，必须将使用通用处理程序的任何分区的InDB表升级到UnIDB本机处理程序。</p>
                        </div>
                    </li><li class="listitem"><p>
                        <code class="literal">REMOVE PARTITIONING</code> enables you to remove
                        a table's partitioning without otherwise affecting the table
                        or its data. This option can be combined with other
                        <a class="link" href="sql-syntax.html#alter-table" title="13.1.8&nbsp;ALTER TABLE Syntax"><code class="literal">ALTER TABLE</code></a> options such as
                        those used to add, drop, or rename columns or indexes.
                    </p><p style="color:blue;">移除分区使您可以删除表的分区，而不影响表或其数据。此选项可以与其他alter table选项（例如用于添加、删除或重命名列或索引的选项）组合使用。</p></li><li class="listitem"><p>
                        Using the <code class="literal">ENGINE</code> option with
                        <a class="link" href="sql-syntax.html#alter-table" title="13.1.8&nbsp;ALTER TABLE Syntax"><code class="literal">ALTER TABLE</code></a> changes the
                        storage engine used by the table without affecting the
                        partitioning.
                    </p><p style="color:blue;">在alter table中使用engine选项可以更改表使用的存储引擎，而不会影响分区。</p></li></ul>
                </div>
                <p>
                    When <code class="literal">ALTER TABLE ... EXCHANGE PARTITION</code> or
                    <code class="literal">ALTER TABLE ... TRUNCATE PARTITION</code> is run
                    against a partitioned table that uses
                    <a class="link" href="storage-engines.html#myisam-storage-engine" title="15.2&nbsp;The MyISAM Storage Engine"><code class="literal">MyISAM</code></a> (or another storage engine
                    that makes use of table-level locking), only those partitions
                    that are actually read from are locked. (This does not apply to
                    partitioned tables using a storage enginethat employs row-level
                    locking, such as <a class="link" href="innodb-storage-engine.html" title="Chapter&nbsp;14&nbsp;The InnoDB Storage Engine"><code class="literal">InnoDB</code></a>.) See
                    <a class="xref" href="partitioning.html#partitioning-limitations-locking" title="22.6.4&nbsp;Partitioning and Locking">Section&nbsp;22.6.4, “Partitioning and Locking”</a>.
                </p><p style="color:blue;">当更改表时…交换分区或更改表…截断分区是针对使用MyISAM的分区表（或使用表级锁定的另一个存储引擎）运行的，只有那些实际读取的分区被锁定。（这不适用于使用存储引擎的分区表，它使用行级锁定，如innodb）请参见第22.6.4节“分区和锁定”。</p><p>
                It is possible for an <a class="link" href="sql-syntax.html#alter-table" title="13.1.8&nbsp;ALTER TABLE Syntax"><code class="literal">ALTER TABLE</code></a>
                statement to contain a <code class="literal">PARTITION BY</code> or
                <code class="literal">REMOVE PARTITIONING</code> clause in an addition to
                other alter specifications, but the <code class="literal">PARTITION
                BY</code> or <code class="literal">REMOVE PARTITIONING</code> clause
                must be specified last after any other specifications.
            </p><p style="color:blue;">ALTALTABLE语句可以在其他ALT规范的添加中包含分区或移除分区子句，但是必须在任何其他规范之后指定分区或移除分区子句。</p><p>
                The <code class="literal">ADD PARTITION</code>, <code class="literal">DROP
                PARTITION</code>, <code class="literal">COALESCE PARTITION</code>,
                <code class="literal">REORGANIZE PARTITION</code>, <code class="literal">ANALYZE
                PARTITION</code>, <code class="literal">CHECK PARTITION</code>, and
                <code class="literal">REPAIR PARTITION</code> options cannot be combined
                with other alter specifications in a single <code class="literal">ALTER
                TABLE</code>, since the options just listed act on individual
                partitions. For more information, see
                <a class="xref" href="sql-syntax.html#alter-table-partition-operations" title="13.1.8.1&nbsp;ALTER TABLE Partition Operations">Section&nbsp;13.1.8.1, “ALTER TABLE Partition Operations”</a>.
            </p><p style="color:blue;">添加分区、删除分区、合并分区、重新组织分区、分析分区、检查分区和修复分区选项不能与单个ALTE表中的其他ALTER规范相结合，因为刚才列出的选项对单个分区起作用。有关更多信息，请参阅第13.1.8.1节“更改表分区操作”。</p><p>
                Only a single instance of any one of the following options can
                be used in a given <a class="link" href="sql-syntax.html#alter-table" title="13.1.8&nbsp;ALTER TABLE Syntax"><code class="literal">ALTER TABLE</code></a>
                statement: <code class="literal">PARTITION BY</code>, <code class="literal">ADD
                PARTITION</code>, <code class="literal">DROP PARTITION</code>,
                <code class="literal">TRUNCATE PARTITION</code>, <code class="literal">EXCHANGE
                PARTITION</code>, <code class="literal">REORGANIZE PARTITION</code>, or
                <code class="literal">COALESCE PARTITION</code>, <code class="literal">ANALYZE
                PARTITION</code>, <code class="literal">CHECK PARTITION</code>,
                <code class="literal">OPTIMIZE PARTITION</code>, <code class="literal">REBUILD
                PARTITION</code>, <code class="literal">REMOVE PARTITIONING</code>.
            </p><p style="color:blue;">在给定的ALTALTABLE语句中，只有一个实例可以使用：分区分区、添加分区、删除分区、截断分区、交换分区、重组分区或合并分区，分析分区、检查分区、优化分区、重建分区、移除分区。</p><p>
                For example, the following two statements are invalid:
            </p><p style="color:blue;">例如，以下两个语句无效：</p><pre data-lang="sql" class="programlisting">ALTER TABLE t1 ANALYZE PARTITION p1, ANALYZE PARTITION p2;

ALTER TABLE t1 ANALYZE PARTITION p1, CHECK PARTITION p2;
</pre><p>
                In the first case, you can analyze partitions
                <code class="literal">p1</code> and <code class="literal">p2</code> of table
                <code class="literal">t1</code> concurrently using a single statement with
                a single <code class="literal">ANALYZE PARTITION</code> option that lists
                both of the partitions to be analyzed, like this:
            </p><p style="color:blue;">在第一种情况下，您可以使用一个单一的分析分区选项同时分析表T1的分区P1和P2，其中一个分析分区选项列出了要分析的两个分区，如下所示：</p><pre data-lang="sql" class="programlisting">ALTER TABLE t1 ANALYZE PARTITION p1, p2;
</pre><p>
                In the second case, it is not possible to perform
                <code class="literal">ANALYZE</code> and <code class="literal">CHECK</code>
                operations on different partitions of the same table
                concurrently. Instead, you must issue two separate statements,
                like this:
            </p><p style="color:blue;">在第二种情况下，不可能同时对同一表的不同分区执行分析和检查操作。相反，您必须发出两个单独的声明，如下所示：</p><pre data-lang="sql" class="programlisting">ALTER TABLE t1 ANALYZE PARTITION p1;
ALTER TABLE t1 CHECK PARTITION p2;
</pre><p>
                <code class="literal">REBUILD</code> operations are currently unsupported
                for subpartitions. The <code class="literal">REBUILD</code> keyword is
                expressly disallowed with subpartitions, and causes
                <code class="literal">ALTER TABLE</code> to fail with an error if so used.
            </p><p style="color:blue;">子分区当前不支持重建操作。对于子部分，rebuild关键字被明确禁止，如果使用，则会导致alter table失败并出现错误。</p><p>
                <code class="literal">CHECK PARTITION </code>and<code class="literal"> REPAIR
                PARTITION</code> operations fail when the partition to be
                checked or repaired contains any duplicate key errors.
            </p><p style="color:blue;">当要检查或修复的分区包含任何重复的密钥错误时，检查分区和修复分区操作失败。</p><p>
                For more information about these statements, see
                <a class="xref" href="partitioning.html#partitioning-maintenance" title="22.3.4&nbsp;Maintenance of Partitions">Section&nbsp;22.3.4, “Maintenance of Partitions”</a>.
            </p><p style="color:blue;">有关这些语句的更多信息，请参见第22.3.4节“分区的维护”。</p>
            </div>
            <div class="section">
                <div class="titlepage">
                    <div>
                        <div>
                            <h4 class="title"><a name="alter-table-generated-columns"></a>13.1.8.2&nbsp;ALTER TABLE and Generated Columns</h4>

                        </div>

                    </div>

                </div>
                <a class="indexterm" name="idm140286840692800"></a><p>
                <code class="literal">ALTER TABLE</code> operations permitted for
                generated columns are <code class="literal">ADD</code>,
                <code class="literal">MODIFY</code>, and <code class="literal">CHANGE</code>.
            </p><p style="color:blue;">生成列允许的alter table操作有add、modify和change。</p>
                <div class="itemizedlist">
                    <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                        Generated columns can be added.
                    </p><p style="color:blue;">可以添加生成的列。</p><pre data-lang="sql" class="programlisting">CREATE TABLE t1 (c1 INT);
ALTER TABLE t1 ADD COLUMN c2 INT GENERATED ALWAYS AS (c1 + 1) STORED;
</pre></li><li class="listitem"><p>
                        The data type and expression of generated columns can be
                        modified.
                    </p><p style="color:blue;">可以修改生成列的数据类型和表达式。</p><pre data-lang="sql" class="programlisting">CREATE TABLE t1 (c1 INT, c2 INT GENERATED ALWAYS AS (c1 + 1) STORED);
ALTER TABLE t1 MODIFY COLUMN c2 TINYINT GENERATED ALWAYS AS (c1 + 5) STORED;
</pre></li><li class="listitem"><p>
                        Generated columns can be renamed or dropped, if no other
                        column refers to them.
                    </p><p style="color:blue;">如果没有其他列引用生成的列，则可以重命名或删除它们。</p><pre data-lang="sql" class="programlisting">CREATE TABLE t1 (c1 INT, c2 INT GENERATED ALWAYS AS (c1 + 1) STORED);
ALTER TABLE t1 CHANGE c2 c3 INT GENERATED ALWAYS AS (c1 + 1) STORED;
ALTER TABLE t1 DROP COLUMN c3;
</pre></li><li class="listitem"><p>
                        Virtual generated columns cannot be altered to stored
                        generated columns, or vice versa. To work around this, drop
                        the column, then add it with the new definition.
                    </p><p style="color:blue;">虚拟生成列不能更改为存储生成列，反之亦然。若要解决此问题，请删除列，然后将其与新定义一起添加。</p><pre data-lang="sql" class="programlisting">CREATE TABLE t1 (c1 INT, c2 INT GENERATED ALWAYS AS (c1 + 1) VIRTUAL);
ALTER TABLE t1 DROP COLUMN c2;
ALTER TABLE t1 ADD COLUMN c2 INT GENERATED ALWAYS AS (c1 + 1) STORED;
</pre></li><li class="listitem"><p>
                        Nongenerated columns can be altered to stored but not
                        virtual generated columns.
                    </p><p style="color:blue;">非生成列可以更改为已存储但不是虚拟生成列。</p><pre data-lang="sql" class="programlisting">CREATE TABLE t1 (c1 INT, c2 INT);
ALTER TABLE t1 MODIFY COLUMN c2 INT GENERATED ALWAYS AS (c1 + 1) STORED;
</pre></li><li class="listitem"><p>
                        Stored but not virtual generated columns can be altered to
                        nongenerated columns. The stored generated values become the
                        values of the nongenerated column.
                    </p><p style="color:blue;">存储但不是虚拟生成的列可以更改为非生成的列。存储的生成值将成为非生成列的值。</p><pre data-lang="sql" class="programlisting">CREATE TABLE t1 (c1 INT, c2 INT GENERATED ALWAYS AS (c1 + 1) STORED);
ALTER TABLE t1 MODIFY COLUMN c2 INT;
</pre></li><li class="listitem"><p>
                        <code class="literal">ADD COLUMN</code> is not an in-place operation
                        for stored columns (done without using a temporary table)
                        because the expression must be evaluated by the server. For
                        stored columns, indexing changes are done in place, and
                        expression changes are not done in place. Changes to column
                        comments are done in place.
                    </p><p style="color:blue;">添加列不是存储列的就地操作（在不使用临时表的情况下完成），因为服务器必须计算表达式。对于存储的列，索引更改是在适当的位置进行的，并且表达式更改不会在适当的位置完成。对列注释的更改已就地完成。</p></li><li class="listitem"><p>
                        For non-partitioned tables, <code class="literal">ADD COLUMN</code>
                        and <code class="literal">DROP COLUMN</code> are in-place operations
                        for virtual columns. However, adding or dropping a virtual
                        column cannot be performed in place in combination with
                        other <a class="link" href="sql-syntax.html#alter-table" title="13.1.8&nbsp;ALTER TABLE Syntax"><code class="literal">ALTER TABLE</code></a> operations.
                    </p><p style="color:blue;">对于非分区表，add column和drop column是虚拟列的就地操作。但是，添加或删除虚拟列不能与其他alter table操作一起就地执行。</p><p>
                        For partitioned tables, <code class="literal">ADD COLUMN</code> and
                        <code class="literal">DROP COLUMN</code> are not in-place operations
                        for virtual columns.
                    </p><p style="color:blue;">对于分区表，添加列和删除列不是针对虚拟列的就地操作。</p></li><li class="listitem"><p>
                        <code class="literal">InnoDB</code> supports secondary indexes on
                        virtual generated columns. Adding or dropping a secondary
                        index on a virtual generated column is an in-place
                        operation. For more information, see
                        <a class="xref" href="sql-syntax.html#create-table-secondary-indexes" title="13.1.18.9&nbsp;Secondary Indexes and Generated Columns">Section&nbsp;13.1.18.9, “Secondary Indexes and Generated Columns”</a>.
                    </p><p style="color:blue;">innodb支持虚拟生成列的二级索引。在虚拟生成的列上添加或删除辅助索引是就地操作。有关详细信息，请参见第13.1.18.9节“二级索引和生成的列”。</p></li><li class="listitem"><p>
                        When a <code class="literal">VIRTUAL</code> generated column is added
                        to a table or modified, it is not ensured that data being
                        calculated by the generated column expression will not be
                        out of range for the column. This can lead to inconsistent
                        data being returned and unexpectedly failed statements. To
                        permit control over whether validation occurs for such
                        columns, <code class="literal">ALTER TABLE</code> supports
                        <code class="literal">WITHOUT VALIDATION</code> and <code class="literal">WITH
                        VALIDATION</code> clauses:
                    </p><p style="color:blue;">将虚拟生成的列添加到表或修改时，不能确保由生成的列表达式计算的数据不会超出该列的范围。这可能导致返回不一致的数据和意外失败的语句。要允许控制是否对此类列进行验证，请更改不带验证和带验证子句的表支持：</p>
                        <div class="itemizedlist">
                            <ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
                                With <code class="literal">WITHOUT VALIDATION</code> (the default
                                if neither clause is specified), an in-place operation
                                is performed (if possible), data integrity is not
                                checked, and the statement finishes more quickly.
                                However, later reads from the table might report
                                warnings or errors for the column if values are out of
                                range.
                            </p><p style="color:blue;">如果不进行验证（如果未指定任何子句，则为默认值），则执行就地操作（如果可能），不检查数据完整性，语句完成得更快。但是，如果值超出范围，以后从表中读取可能会报告列的警告或错误。</p></li><li class="listitem"><p>
                                With <code class="literal">WITH VALIDATION</code>, <code class="literal">ALTER
                                TABLE</code> copies the table. If an out-of-range or
                                any other error occurs, the statement fails. Because a
                                table copy is performed, the statement takes longer.
                            </p><p style="color:blue;">使用验证，alter table复制表。如果发生超出范围或任何其他错误，则语句将失败。因为执行了表复制，所以语句需要更长的时间。</p></li></ul>
                        </div>
                        <p>
                            <code class="literal">WITHOUT VALIDATION</code> and <code class="literal">WITH
                            VALIDATION</code> are permitted only with <code class="literal">ADD
                            COLUMN</code>, <code class="literal">CHANGE COLUMN</code>, and
                            <code class="literal">MODIFY COLUMN</code> operations. Otherwise, an
                            <a class="link" href="error-handling.html#error_er_wrong_usage"><code class="literal">ER_WRONG_USAGE</code></a> error occurs.
                        </p><p style="color:blue;">仅允许对“添加列”、“更改列”和“修改列”操作执行“不验证”和“带验证”。否则，会发生er_wrong_usage错误。</p></li><li class="listitem"><p>
                        As of MySQL 5.7.10, if expression evaluation causes
                        truncation or provides incorrect input to a function, the
                        <a class="link" href="sql-syntax.html#alter-table" title="13.1.8&nbsp;ALTER TABLE Syntax"><code class="literal">ALTER TABLE</code></a> statement
                        terminates with an error and the DDL operation is rejected.
                    </p><p style="color:blue;">从mysql 5.7.10开始，如果表达式求值导致截断或为函数提供不正确的输入，则alter table语句将以错误终止，并拒绝ddl操作。</p></li><li class="listitem"><p>
                        An <a class="link" href="sql-syntax.html#alter-table" title="13.1.8&nbsp;ALTER TABLE Syntax"><code class="literal">ALTER TABLE</code></a> statement that
                        changes the default value of a column
                        <em class="replaceable"><code>col_name</code></em> may also change the
                        value of a generated column expression that refers to the
                        column using
                        <a class="link" href="functions.html#function_default"><code class="literal">DEFAULT(<em class="replaceable"><code>col_name</code></em>)</code></a>.
                        For this reason, as of MySQL 5.7.13,
                        <a class="link" href="sql-syntax.html#alter-table" title="13.1.8&nbsp;ALTER TABLE Syntax"><code class="literal">ALTER TABLE</code></a> operations that
                        change the definition of a column cause a table rebuild if
                        any generated column expression uses
                        <a class="link" href="functions.html#function_default"><code class="literal">DEFAULT()</code></a>.
                    </p><p style="color:blue;">更改列colu name的默认值的alter table语句也可以更改生成的列表达式的值，该表达式使用默认值（col name）引用列。因此，从mysql 5.7.13开始，如果任何生成的列表达式使用default（），则更改列定义的alter table操作将导致表重建。</p></li></ul>
                </div>

            </div>
            <div class="section">
                <div class="titlepage">
                    <div>
                        <div>
                            <h4 class="title"><a name="alter-table-examples"></a>13.1.8.3&nbsp;ALTER TABLE Examples</h4>

                        </div>

                    </div>

                </div>
                <p>
                    Begin with a table <code class="literal">t1</code> created as shown here:
                </p><p style="color:blue;">从创建的表T1开始，如下所示：</p><pre data-lang="sql" class="programlisting">CREATE TABLE t1 (a INTEGER, b CHAR(10));
</pre><p>
                To rename the table from <code class="literal">t1</code> to
                <code class="literal">t2</code>:
            </p><p style="color:blue;">要将表从T1重命名为T2，请执行以下操作：</p><pre data-lang="sql" class="programlisting">ALTER TABLE t1 RENAME t2;
</pre><p>
                To change column <code class="literal">a</code> from
                <a class="link" href="data-types.html#integer-types" title="11.2.1&nbsp;Integer Types (Exact Value) - INTEGER, INT, SMALLINT, TINYINT, MEDIUMINT, BIGINT"><code class="literal">INTEGER</code></a> to <code class="literal">TINYINT NOT
                NULL</code> (leaving the name the same), and to change column
                <code class="literal">b</code> from <code class="literal">CHAR(10)</code> to
                <code class="literal">CHAR(20)</code> as well as renaming it from
                <code class="literal">b</code> to <code class="literal">c</code>:
            </p><p style="color:blue;">将a列从integer改为tinyint not null（名称不变），将b列从char（10）改为char（20），并将其从b重命名为c：</p><pre data-lang="sql" class="programlisting">ALTER TABLE t2 MODIFY a TINYINT NOT NULL, CHANGE b c CHAR(20);
</pre><p>
                To add a new <a class="link" href="data-types.html#datetime" title="11.3.1&nbsp;The DATE, DATETIME, and TIMESTAMP Types"><code class="literal">TIMESTAMP</code></a> column
                named <code class="literal">d</code>:
            </p><p style="color:blue;">要添加名为d的新时间戳列，请执行以下操作：</p><pre data-lang="sql" class="programlisting">ALTER TABLE t2 ADD d TIMESTAMP;
</pre><p>
                To add an index on column <code class="literal">d</code> and a
                <code class="literal">UNIQUE</code> index on column <code class="literal">a</code>:
            </p><p style="color:blue;">要在列D上添加索引，在列A上添加唯一索引，请执行以下操作：</p><pre data-lang="sql" class="programlisting">ALTER TABLE t2 ADD INDEX (d), ADD UNIQUE (a);
</pre><p>
                To remove column <code class="literal">c</code>:
            </p><p style="color:blue;">要删除列C：</p><pre data-lang="sql" class="programlisting">ALTER TABLE t2 DROP COLUMN c;
</pre><p>
                To add a new <code class="literal">AUTO_INCREMENT</code> integer column
                named <code class="literal">c</code>:
            </p><p style="color:blue;">要添加名为C的新自动递增整数列，请执行以下操作：</p><pre data-lang="sql" class="programlisting">ALTER TABLE t2 ADD c INT UNSIGNED NOT NULL AUTO_INCREMENT,
  ADD PRIMARY KEY (c);
</pre><p>
                We indexed <code class="literal">c</code> (as a <code class="literal">PRIMARY
                KEY</code>) because <code class="literal">AUTO_INCREMENT</code> columns
                must be indexed, and we declare <code class="literal">c</code> as
                <code class="literal">NOT NULL</code> because primary key columns cannot
                be <code class="literal">NULL</code>.
            </p><p style="color:blue;">我们索引C（作为主键），因为必须索引自动递增列，并且声明C不为空，因为主键列不能为空。</p><p>
                For <a class="link" href="mysql-cluster.html" title="Chapter&nbsp;21&nbsp;MySQL NDB Cluster 7.5 and NDB Cluster 7.6"><code class="literal">NDB</code></a> tables, it is also possible
                to change the storage type used for a table or column. For
                example, consider an <a class="link" href="mysql-cluster.html" title="Chapter&nbsp;21&nbsp;MySQL NDB Cluster 7.5 and NDB Cluster 7.6"><code class="literal">NDB</code></a> table
                created as shown here:
            </p><p style="color:blue;">对于ndb表，还可以更改用于表或列的存储类型。例如，考虑如下所示创建的ndb表：</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>CREATE TABLE t1 (c1 INT) TABLESPACE ts_1 ENGINE NDB;</code></strong>
Query OK, 0 rows affected (1.27 sec)
</pre><p>
                To convert this table to disk-based storage, you can use the
                following <a class="link" href="sql-syntax.html#alter-table" title="13.1.8&nbsp;ALTER TABLE Syntax"><code class="literal">ALTER TABLE</code></a> statement:
            </p><p style="color:blue;">要将此表转换为基于磁盘的存储，可以使用以下alter table语句：</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>ALTER TABLE t1 TABLESPACE ts_1 STORAGE DISK;</code></strong>
Query OK, 0 rows affected (2.99 sec)
Records: 0  Duplicates: 0  Warnings: 0

mysql&gt; <strong class="userinput"><code>SHOW CREATE TABLE t1\G</code></strong>
*************************** 1. row ***************************
       Table: t1
Create Table: CREATE TABLE `t1` (
  `c1` int(11) DEFAULT NULL
) /*!50100 TABLESPACE ts_1 STORAGE DISK */
ENGINE=ndbcluster DEFAULT CHARSET=latin1
1 row in set (0.01 sec)
</pre><p>
                It is not necessary that the tablespace was referenced when the
                table was originally created; however, the tablespace must be
                referenced by the <a class="link" href="sql-syntax.html#alter-table" title="13.1.8&nbsp;ALTER TABLE Syntax"><code class="literal">ALTER TABLE</code></a>:
            </p><p style="color:blue;">在最初创建表时不必引用表空间；但是，表空间必须由alter table引用：</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>CREATE TABLE t2 (c1 INT) ts_1 ENGINE NDB;</code></strong>
Query OK, 0 rows affected (1.00 sec)

mysql&gt; <strong class="userinput"><code>ALTER TABLE t2 STORAGE DISK;</code></strong>
<span class="errortext">ERROR 1005 (HY000): Can't create table 'c.#sql-1750_3' (errno: 140)</span>
mysql&gt; <strong class="userinput"><code>ALTER TABLE t2 TABLESPACE ts_1 STORAGE DISK;</code></strong>
Query OK, 0 rows affected (3.42 sec)
Records: 0  Duplicates: 0  Warnings: 0
mysql&gt; <strong class="userinput"><code>SHOW CREATE TABLE t2\G</code></strong>
*************************** 1. row ***************************
       Table: t1
Create Table: CREATE TABLE `t2` (
  `c1` int(11) DEFAULT NULL
) /*!50100 TABLESPACE ts_1 STORAGE DISK */
ENGINE=ndbcluster DEFAULT CHARSET=latin1
1 row in set (0.01 sec)
</pre><p>
                To change the storage type of an individual column, you can use
                <code class="literal">ALTER TABLE ... MODIFY [COLUMN]</code>. For example,
                suppose you create an NDB Cluster Disk Data table with two
                columns, using this <a class="link" href="sql-syntax.html#create-table" title="13.1.18&nbsp;CREATE TABLE Syntax"><code class="literal">CREATE TABLE</code></a>
                statement:
            </p><p style="color:blue;">要更改单个列的存储类型，可以使用alter table…修改[列]。例如，假设使用以下create table语句创建一个包含两列的ndb集群磁盘数据表：</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>CREATE TABLE t3 (c1 INT, c2 INT)</code></strong>
    -&gt;     <strong class="userinput"><code>TABLESPACE ts_1 STORAGE DISK ENGINE NDB;</code></strong>
Query OK, 0 rows affected (1.34 sec)
</pre><p>
                To change column <code class="literal">c2</code> from disk-based to
                in-memory storage, include a STORAGE MEMORY clause in the column
                definition used by the ALTER TABLE statement, as shown here:
            </p><p style="color:blue;">要将列C2从基于磁盘更改为内存中存储，请在alter table语句使用的列定义中包含一个storage memory子句，如下所示：</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>ALTER TABLE t3 MODIFY c2 INT STORAGE MEMORY;</code></strong>
Query OK, 0 rows affected (3.14 sec)
Records: 0  Duplicates: 0  Warnings: 0
</pre><p>
                You can make an in-memory column into a disk-based column by
                using <code class="literal">STORAGE DISK</code> in a similar fashion.
            </p><p style="color:blue;">通过以类似的方式使用存储磁盘，可以将内存中的列变成基于磁盘的列。</p><p>
                Column <code class="literal">c1</code> uses disk-based storage, since this
                is the default for the table (determined by the table-level
                <code class="literal">STORAGE DISK</code> clause in the
                <a class="link" href="sql-syntax.html#create-table" title="13.1.18&nbsp;CREATE TABLE Syntax"><code class="literal">CREATE TABLE</code></a> statement). However,
                column <code class="literal">c2</code> uses in-memory storage, as can be
                seen here in the output of SHOW <a class="link" href="sql-syntax.html#create-table" title="13.1.18&nbsp;CREATE TABLE Syntax"><code class="literal">CREATE
                TABLE</code></a>:
            </p><p style="color:blue;">列c1使用基于磁盘的存储，因为这是表的默认值（由create table语句中的表级storage disk子句确定）。但是，c2列使用内存存储，如show create table的输出所示：</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>SHOW CREATE TABLE t3\G</code></strong>
*************************** 1. row ***************************
       Table: t3
Create Table: CREATE TABLE `t3` (
  `c1` int(11) DEFAULT NULL,
  `c2` int(11) /*!50120 STORAGE MEMORY */ DEFAULT NULL
) /*!50100 TABLESPACE ts_1 STORAGE DISK */ ENGINE=ndbcluster DEFAULT CHARSET=latin1
1 row in set (0.02 sec)
</pre><p>
                When you add an <code class="literal">AUTO_INCREMENT</code> column, column
                values are filled in with sequence numbers automatically. For
                <code class="literal">MyISAM</code> tables, you can set the first sequence
                number by executing <code class="literal">SET
                INSERT_ID=<em class="replaceable"><code>value</code></em></code> before
                <a class="link" href="sql-syntax.html#alter-table" title="13.1.8&nbsp;ALTER TABLE Syntax"><code class="literal">ALTER TABLE</code></a> or by using the
                <code class="literal">AUTO_INCREMENT=<em class="replaceable"><code>value</code></em></code>
                table option.
            </p><p style="color:blue;">添加自动递增列时，列值将自动填充序列号。对于myisam表，可以通过执行set insert_id=value before alter table或使用auto_increment=value table选项来设置第一个序列号。</p><p>
                With <code class="literal">MyISAM</code> tables, if you do not change the
                <code class="literal">AUTO_INCREMENT</code> column, the sequence number is
                not affected. If you drop an <code class="literal">AUTO_INCREMENT</code>
                column and then add another <code class="literal">AUTO_INCREMENT</code>
                column, the numbers are resequenced beginning with 1.
            </p><p style="color:blue;">对于myisam表，如果不更改auto_increment列，则序列号不受影响。如果删除一个自动递增列，然后添加另一个自动递增列，则数字将从1开始重新排序。</p><p>
                When replication is used, adding an
                <code class="literal">AUTO_INCREMENT</code> column to a table might not
                produce the same ordering of the rows on the slave and the
                master. This occurs because the order in which the rows are
                numbered depends on the specific storage engine used for the
                table and the order in which the rows were inserted. If it is
                important to have the same order on the master and slave, the
                rows must be ordered before assigning an
                <code class="literal">AUTO_INCREMENT</code> number. Assuming that you want
                to add an <code class="literal">AUTO_INCREMENT</code> column to the table
                <code class="literal">t1</code>, the following statements produce a new
                table <code class="literal">t2</code> identical to <code class="literal">t1</code>
                but with an <code class="literal">AUTO_INCREMENT</code> column:
            </p><p style="color:blue;">使用复制时，向表中添加自动递增列可能不会在从机和主机上产生相同的行顺序。这是因为行的编号顺序取决于用于表的特定存储引擎以及行的插入顺序。如果在主从机上有相同的顺序很重要，则在分配自动递增数之前必须对行进行排序。假设要向表T1中添加一个auto_increment列，以下语句将生成一个与T1相同但具有auto_increment列的新表T2：</p><pre data-lang="sql" class="programlisting">CREATE TABLE t2 (id INT AUTO_INCREMENT PRIMARY KEY)
SELECT * FROM t1 ORDER BY col1, col2;
</pre><p>
                This assumes that the table <code class="literal">t1</code> has columns
                <code class="literal">col1</code> and <code class="literal">col2</code>.
            </p><p style="color:blue;">这假设表T1有列COL1和COL2。</p><p>
                This set of statements will also produce a new table
                <code class="literal">t2</code> identical to <code class="literal">t1</code>, with
                the addition of an <code class="literal">AUTO_INCREMENT</code> column:
            </p><p style="color:blue;">这组语句还将生成与T1相同的新表T2，并添加一个自动递增列：</p><pre data-lang="sql" class="programlisting">CREATE TABLE t2 LIKE t1;
ALTER TABLE t2 ADD id INT AUTO_INCREMENT PRIMARY KEY;
INSERT INTO t2 SELECT * FROM t1 ORDER BY col1, col2;
</pre>
                <div class="important" style="margin-left: 0.5in; margin-right: 0.5in;">

                    <div class="admon-title">
                        Important
                    </div>
                    <p>
                        To guarantee the same ordering on both master and slave,
                        <span class="emphasis"><em>all</em></span> columns of <code class="literal">t1</code> must
                        be referenced in the <code class="literal">ORDER BY</code> clause.
                    </p><p style="color:blue;">为了保证主从机的顺序相同，必须在ORDERBY子句中引用T1的所有列。</p>
                </div>
                <p>
                    Regardless of the method used to create and populate the copy
                    having the <code class="literal">AUTO_INCREMENT</code> column, the final
                    step is to drop the original table and then rename the copy:
                </p><p style="color:blue;">无论用于创建和填充具有“自动递增”列的副本的方法如何，最后一步是删除原始表，然后重命名副本：</p><pre data-lang="sql" class="programlisting">DROP TABLE t1;
ALTER TABLE t2 RENAME t1;
</pre>
            </div>

        </div>
        <div class="section">
            <div class="titlepage">
                <div>
                    <div>
                        <h3 class="title"><a name="alter-tablespace"></a>13.1.9&nbsp;ALTER TABLESPACE Syntax</h3>

                    </div>

                </div>

            </div>
            <a class="indexterm" name="idm140286840552128"></a><pre data-lang="sql" class="programlisting">ALTER TABLESPACE <em class="replaceable"><code>tablespace_name</code></em>
    {ADD|DROP} DATAFILE '<em class="replaceable"><code>file_name</code></em>'
    [INITIAL_SIZE [=] <em class="replaceable"><code>size</code></em>]
    [WAIT]
    ENGINE [=] <em class="replaceable"><code>engine_name</code></em>
</pre><p>
            This statement is used either to add a new data file, or to drop a
            data file from a tablespace.
        </p><p style="color:blue;">此语句用于添加新数据文件或从表空间中删除数据文件。</p><p>
            The <code class="literal">ADD DATAFILE</code> variant enables you to specify
            an initial size using an <code class="literal">INITIAL_SIZE</code> clause,
            where <em class="replaceable"><code>size</code></em> is measured in bytes; the
            default value is 134217728 (128 MB). You may optionally follow
            <em class="replaceable"><code>size</code></em> with a one-letter abbreviation for
            an order of magnitude, similar to those used in
            <code class="filename">my.cnf</code>. Generally, this is one of the letters
            <code class="literal">M</code> (megabytes) or <code class="literal">G</code>
            (gigabytes).
        </p><p style="color:blue;">add datafile变量允许您使用initial-size子句指定初始大小，其中大小以字节为单位；默认值为134217728（128 MB）。您可以选择使用一个字母的缩写来表示数量级，与my.cnf中使用的类似。通常，这是m（兆字节）或g（千兆字节）中的一个字母。</p>
            <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">

                <div class="admon-title">
                    Note
                </div>
                <p>
                    All NDB Cluster Disk Data objects share the same namespace. This
                    means that <span class="emphasis"><em>each Disk Data object</em></span> must be
                    uniquely named (and not merely each Disk Data object of a given
                    type). For example, you cannot have a tablespace and a data file
                    with the same name, or an undo log file and a tablespace with
                    the same name.
                </p><p style="color:blue;">所有ndb群集磁盘数据对象共享同一命名空间。这意味着每个磁盘数据对象必须有唯一的名称（而不仅仅是给定类型的每个磁盘数据对象）。例如，不能有同名的表空间和数据文件，也不能有同名的撤消日志文件和表空间。</p>
            </div>
            <p>
                On 32-bit systems, the maximum supported value for
                <code class="literal">INITIAL_SIZE</code> is 4294967296 (4 GB). (Bug #29186)
            </p><p style="color:blue;">在32位系统上，初始值的最大支持值为4294967296（4 GB）。（错误29186）</p><p>
            <code class="literal">INITIAL_SIZE</code> is rounded, explicitly, as for
            <a class="link" href="sql-syntax.html#create-tablespace" title="13.1.19&nbsp;CREATE TABLESPACE Syntax"><code class="literal">CREATE TABLESPACE</code></a>.
        </p><p style="color:blue;">对于创建表空间，初始大小显式舍入。</p><p>
            Once a data file has been created, its size cannot be changed;
            however, you can add more data files to the tablespace using
            additional <code class="literal">ALTER TABLESPACE ... ADD DATAFILE</code>
            statements.
        </p><p style="color:blue;">一旦创建了一个数据文件，它的大小就不能更改；但是，您可以使用额外的alter tablespace向表空间添加更多的数据文件…添加数据文件语句。</p><p>
            Using <code class="literal">DROP DATAFILE</code> with
            <a class="link" href="sql-syntax.html#alter-tablespace" title="13.1.9&nbsp;ALTER TABLESPACE Syntax"><code class="literal">ALTER TABLESPACE</code></a> drops the data
            file '<em class="replaceable"><code>file_name</code></em>' from the tablespace.
            You cannot drop a data file from a tablespace which is in use by
            any table; in other words, the data file must be empty (no extents
            used). See <a class="xref" href="mysql-cluster.html#mysql-cluster-disk-data-objects" title="21.5.13.1&nbsp;NDB Cluster Disk Data Objects">Section&nbsp;21.5.13.1, “NDB Cluster Disk Data Objects”</a>. In
            addition, any data file to be dropped must previously have been
            added to the tablespace with <a class="link" href="sql-syntax.html#create-tablespace" title="13.1.19&nbsp;CREATE TABLESPACE Syntax"><code class="literal">CREATE
            TABLESPACE</code></a> or <a class="link" href="sql-syntax.html#alter-tablespace" title="13.1.9&nbsp;ALTER TABLESPACE Syntax"><code class="literal">ALTER
            TABLESPACE</code></a>.
        </p><p style="color:blue;">使用带有alter tablespace的drop data file从表空间中删除数据文件'file_name'。不能从任何表正在使用的表空间中删除数据文件；换句话说，数据文件必须为空（不使用扩展数据块）。见21.5.13.1节，“ndb群集磁盘数据对象”。此外，要删除的任何数据文件必须在以前使用create tablespace或alter tablespace添加到表空间中。</p><p>
            Both <code class="literal">ALTER TABLESPACE ... ADD DATAFILE</code> and
            <code class="literal">ALTER TABLESPACE ... DROP DATAFILE</code> require an
            <code class="literal">ENGINE</code> clause which specifies the storage
            engine used by the tablespace. Currently, the only accepted values
            for <em class="replaceable"><code>engine_name</code></em> are
            <a class="link" href="mysql-cluster.html" title="Chapter&nbsp;21&nbsp;MySQL NDB Cluster 7.5 and NDB Cluster 7.6"><code class="literal">NDB</code></a> and
            <a class="link" href="mysql-cluster.html" title="Chapter&nbsp;21&nbsp;MySQL NDB Cluster 7.5 and NDB Cluster 7.6"><code class="literal">NDBCLUSTER</code></a>.
        </p><p style="color:blue;">都改变表空间…添加数据文件并更改表空间…drop datafile需要一个engine子句，该子句指定表空间使用的存储引擎。目前，引擎名的唯一可接受值是ndb和ndbcluster。</p><p>
            <code class="literal">WAIT</code> is parsed but otherwise ignored, and so
            has no effect in MySQL 5.7. It is intended for future
            expansion.
        </p><p style="color:blue;">wait被解析，但被忽略，因此在mysql 5.7中没有效果。它是为了将来的扩展。</p><p>
            When <code class="literal">ALTER TABLESPACE ... ADD DATAFILE</code> is used
            with <code class="literal">ENGINE = NDB</code>, a data file is created on
            each Cluster data node. You can verify that the data files were
            created and obtain information about them by querying the
            <a class="link" href="information-schema.html#files-table" title="24.9&nbsp;The INFORMATION_SCHEMA FILES Table"><code class="literal">INFORMATION_SCHEMA.FILES</code></a> table. For
            example, the following query shows all data files belonging to the
            tablespace named <code class="literal">newts</code>:
        </p><p style="color:blue;">当改变表空间时…add data file与engine=ndb一起使用，在每个集群数据节点上创建一个数据文件。您可以通过查询information\schema.files表来验证数据文件是否已创建，并获取有关它们的信息。例如，以下查询显示属于名为newts的表空间的所有数据文件：</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT LOGFILE_GROUP_NAME, FILE_NAME, EXTRA</code></strong>
    -&gt; <strong class="userinput"><code>FROM INFORMATION_SCHEMA.FILES</code></strong>
    -&gt; <strong class="userinput"><code>WHERE TABLESPACE_NAME = 'newts' AND FILE_TYPE = 'DATAFILE';</code></strong>
+--------------------+--------------+----------------+
| LOGFILE_GROUP_NAME | FILE_NAME    | EXTRA          |
+--------------------+--------------+----------------+
| lg_3               | newdata.dat  | CLUSTER_NODE=3 |
| lg_3               | newdata.dat  | CLUSTER_NODE=4 |
| lg_3               | newdata2.dat | CLUSTER_NODE=3 |
| lg_3               | newdata2.dat | CLUSTER_NODE=4 |
+--------------------+--------------+----------------+
2 rows in set (0.03 sec)
</pre><p>
            See <a class="xref" href="information-schema.html#files-table" title="24.9&nbsp;The INFORMATION_SCHEMA FILES Table">Section&nbsp;24.9, “The INFORMATION_SCHEMA FILES Table”</a>.
        </p><p style="color:blue;">参见第24.9节“信息架构文件表”。</p><p>
            <a class="link" href="sql-syntax.html#alter-tablespace" title="13.1.9&nbsp;ALTER TABLESPACE Syntax"><code class="literal">ALTER TABLESPACE</code></a> is useful only
            with Disk Data storage for NDB Cluster. See
            <a class="xref" href="mysql-cluster.html#mysql-cluster-disk-data" title="21.5.13&nbsp;NDB Cluster Disk Data Tables">Section&nbsp;21.5.13, “NDB Cluster Disk Data Tables”</a>.
        </p><p style="color:blue;">alter tablespace只对ndb集群的磁盘数据存储有用。见21.5.13节，“ndb群集磁盘数据表”。</p>
        </div>
        <div class="section">
            <div class="titlepage">
                <div>
                    <div>
                        <h3 class="title"><a name="alter-view"></a>13.1.10&nbsp;ALTER VIEW Syntax</h3>

                    </div>

                </div>

            </div>
            <a class="indexterm" name="idm140286840507136"></a><pre data-lang="sql" class="programlisting">ALTER
    [ALGORITHM = {UNDEFINED | MERGE | TEMPTABLE}]
    [DEFINER = <em class="replaceable"><code>user</code></em>]
    [SQL SECURITY { DEFINER | INVOKER }]
    VIEW <em class="replaceable"><code>view_name</code></em> [(<em class="replaceable"><code>column_list</code></em>)]
    AS <em class="replaceable"><code>select_statement</code></em>
    [WITH [CASCADED | LOCAL] CHECK OPTION]
</pre><p>
            This statement changes the definition of a view, which must exist.
            The syntax is similar to that for <a class="link" href="sql-syntax.html#create-view" title="13.1.21&nbsp;CREATE VIEW Syntax"><code class="literal">CREATE
            VIEW</code></a> see <a class="xref" href="sql-syntax.html#create-view" title="13.1.21&nbsp;CREATE VIEW Syntax">Section&nbsp;13.1.21, “CREATE VIEW Syntax”</a>). This statement
            requires the <a class="link" href="security.html#priv_create-view"><code class="literal">CREATE VIEW</code></a> and
            <a class="link" href="security.html#priv_drop"><code class="literal">DROP</code></a> privileges for the view, and
            some privilege for each column referred to in the
            <a class="link" href="sql-syntax.html#select" title="13.2.9&nbsp;SELECT Syntax"><code class="literal">SELECT</code></a> statement.
            <a class="link" href="sql-syntax.html#alter-view" title="13.1.10&nbsp;ALTER VIEW Syntax"><code class="literal">ALTER VIEW</code></a> is permitted only to the
            definer or users with the <a class="link" href="security.html#priv_super"><code class="literal">SUPER</code></a>
            privilege.
        </p><p style="color:blue;">此语句更改视图的定义，该视图必须存在。语法与create view的语法类似，请参见13.1.21节，“create view syntax”）。此语句要求该视图具有CREATE VIEW和DROP权限，并要求SELECT语句中引用的每个列具有某些权限。只有具有超级权限的定义者或用户才允许使用alter view。</p>
        </div>
        <div class="section">
            <div class="titlepage">
                <div>
                    <div>
                        <h3 class="title"><a name="create-database"></a>13.1.11&nbsp;CREATE DATABASE Syntax</h3>

                    </div>

                </div>

            </div>
            <a class="indexterm" name="idm140286840490224"></a><a class="indexterm" name="idm140286840488736"></a><a class="indexterm" name="idm140286840487664"></a><a class="indexterm" name="idm140286840486592"></a><a class="indexterm" name="idm140286840485104"></a><a class="indexterm" name="idm140286840483616"></a><a class="indexterm" name="idm140286840482128"></a><pre data-lang="sql" class="programlisting">CREATE {DATABASE | SCHEMA} [IF NOT EXISTS] <em class="replaceable"><code>db_name</code></em>
    [<em class="replaceable"><code>create_specification</code></em>] ...

<em class="replaceable"><code>create_specification</code></em>:
    [DEFAULT] CHARACTER SET [=] <em class="replaceable"><code>charset_name</code></em>
  | [DEFAULT] COLLATE [=] <em class="replaceable"><code>collation_name</code></em>
</pre><p>
            <a class="link" href="sql-syntax.html#create-database" title="13.1.11&nbsp;CREATE DATABASE Syntax"><code class="literal">CREATE DATABASE</code></a> creates a database
            with the given name. To use this statement, you need the
            <a class="link" href="security.html#priv_create"><code class="literal">CREATE</code></a> privilege for the database.
            <a class="link" href="sql-syntax.html#create-database" title="13.1.11&nbsp;CREATE DATABASE Syntax"><code class="literal">CREATE
                SCHEMA</code></a> is a synonym for <a class="link" href="sql-syntax.html#create-database" title="13.1.11&nbsp;CREATE DATABASE Syntax"><code class="literal">CREATE
            DATABASE</code></a>.
        </p><p style="color:blue;">创建数据库创建具有给定名称的数据库。若要使用此语句，您需要数据库的“创建”权限。create schema是create database的同义词。</p><p>
            An error occurs if the database exists and you did not specify
            <code class="literal">IF NOT EXISTS</code>.
        </p><p style="color:blue;">如果数据库存在且没有指定是否不存在，则会发生错误。</p><p>
            <a class="link" href="sql-syntax.html#create-database" title="13.1.11&nbsp;CREATE DATABASE Syntax"><code class="literal">CREATE DATABASE</code></a> is not permitted
            within a session that has an active <a class="link" href="sql-syntax.html#lock-tables" title="13.3.5&nbsp;LOCK TABLES and UNLOCK TABLES Syntax"><code class="literal">LOCK
            TABLES</code></a> statement.
        </p><p style="color:blue;">在具有活动锁表语句的会话中不允许创建数据库。</p><p>
            <em class="replaceable"><code>create_specification</code></em> options specify
            database characteristics. Database characteristics are stored in
            the <code class="filename">db.opt</code> file in the database directory.
            The <code class="literal">CHARACTER SET</code> clause specifies the default
            database character set. The <code class="literal">COLLATE</code> clause
            specifies the default database collation.
            <a class="xref" href="charset.html" title="Chapter&nbsp;10&nbsp;Character Sets, Collations, Unicode">Chapter&nbsp;10, <i>Character Sets, Collations, Unicode</i></a>, discusses character set and collation
            names.
        </p><p style="color:blue;">创建规范选项指定数据库特征。数据库特性存储在数据库目录中的db.opt文件中。character set子句指定默认的数据库字符集。collate子句指定默认的数据库排序规则。第10章，字符集，排序规则，Unicode，讨论字符集和排序规则名称。</p><p>
            A database in MySQL is implemented as a directory containing files
            that correspond to tables in the database. Because there are no
            tables in a database when it is initially created, the
            <a class="link" href="sql-syntax.html#create-database" title="13.1.11&nbsp;CREATE DATABASE Syntax"><code class="literal">CREATE DATABASE</code></a> statement creates
            only a directory under the MySQL data directory and the
            <code class="filename">db.opt</code> file. Rules for permissible database
            names are given in <a class="xref" href="language-structure.html#identifiers" title="9.2&nbsp;Schema Object Names">Section&nbsp;9.2, “Schema Object Names”</a>. If a database
            name contains special characters, the name for the database
            directory contains encoded versions of those characters as
            described in <a class="xref" href="language-structure.html#identifier-mapping" title="9.2.4&nbsp;Mapping of Identifiers to File Names">Section&nbsp;9.2.4, “Mapping of Identifiers to File Names”</a>.
        </p><p style="color:blue;">mysql中的数据库被实现为包含与数据库中的表对应的文件的目录。由于最初创建数据库时数据库中没有表，create database语句只在mysql数据目录和db.opt文件下创建一个目录。第9.2节“模式对象名称”给出了允许的数据库名称规则。如果数据库名称包含特殊字符，则数据库目录的名称包含这些字符的编码版本，如第9.2.4节“标识符到文件名的映射”所述。</p><p>
            If you manually create a directory under the data directory (for
            example, with <span class="command"><strong>mkdir</strong></span>), the server considers it a
            database directory and it shows up in the output of
            <a class="link" href="sql-syntax.html#show-databases" title="13.7.5.14&nbsp;SHOW DATABASES Syntax"><code class="literal">SHOW DATABASES</code></a>.
        </p><p style="color:blue;">如果在数据目录下手动创建一个目录（例如，使用mkdir），服务器会将其视为数据库目录，并显示在show databases的输出中。</p><a class="indexterm" name="idm140286840453392"></a><a class="indexterm" name="idm140286840451888"></a><p>
            MySQL has no limit on the number of databases. The underlying file
            system may have a limit on the number of directories.
        </p><p style="color:blue;">mysql对数据库的数量没有限制。基础文件系统可能对目录数量有限制。</p><a class="indexterm" name="idm140286840449840"></a><p>
            You can also use the <a class="link" href="programs.html#mysqladmin" title="4.5.2&nbsp;mysqladmin — Client for Administering a MySQL Server"><span class="command"><strong>mysqladmin</strong></span></a> program to
            create databases. See <a class="xref" href="programs.html#mysqladmin" title="4.5.2&nbsp;mysqladmin — Client for Administering a MySQL Server">Section&nbsp;4.5.2, “<span class="command"><strong>mysqladmin</strong></span> — Client for Administering a MySQL Server”</a>.
        </p><p style="color:blue;">您还可以使用mysqladmin程序创建数据库。请参阅4.5.2节，“mysqladmin-用于管理mysql服务器的客户端”。</p>
        </div>
        <div class="section">
            <div class="titlepage">
                <div>
                    <div>
                        <h3 class="title"><a name="create-event"></a>13.1.12&nbsp;CREATE EVENT Syntax</h3>

                    </div>

                </div>

            </div>
            <a class="indexterm" name="idm140286840445168"></a><a class="indexterm" name="idm140286840443680"></a><a class="indexterm" name="idm140286840442192"></a><pre data-lang="sql" class="programlisting">CREATE
    [DEFINER = <em class="replaceable"><code>user</code></em>]
    EVENT
    [IF NOT EXISTS]
    <em class="replaceable"><code>event_name</code></em>
    ON SCHEDULE <em class="replaceable"><code>schedule</code></em>
    [ON COMPLETION [NOT] PRESERVE]
    [ENABLE | DISABLE | DISABLE ON SLAVE]
    [COMMENT '<em class="replaceable"><code>string</code></em>']
    DO <em class="replaceable"><code>event_body</code></em>;

<em class="replaceable"><code>schedule</code></em>:
    AT <em class="replaceable"><code>timestamp</code></em> [+ INTERVAL <em class="replaceable"><code>interval</code></em>] ...
  | EVERY <em class="replaceable"><code>interval</code></em>
    [STARTS <em class="replaceable"><code>timestamp</code></em> [+ INTERVAL <em class="replaceable"><code>interval</code></em>] ...]
    [ENDS <em class="replaceable"><code>timestamp</code></em> [+ INTERVAL <em class="replaceable"><code>interval</code></em>] ...]

<em class="replaceable"><code>interval</code></em>:
    <em class="replaceable"><code>quantity</code></em> {YEAR | QUARTER | MONTH | DAY | HOUR | MINUTE |
              WEEK | SECOND | YEAR_MONTH | DAY_HOUR | DAY_MINUTE |
              DAY_SECOND | HOUR_MINUTE | HOUR_SECOND | MINUTE_SECOND}
</pre><p>
            This statement creates and schedules a new event. The event will
            not run unless the Event Scheduler is enabled. For information
            about checking Event Scheduler status and enabling it if
            necessary, see <a class="xref" href="stored-objects.html#events-configuration" title="23.4.2&nbsp;Event Scheduler Configuration">Section&nbsp;23.4.2, “Event Scheduler Configuration”</a>.
        </p><p style="color:blue;">此语句创建并计划一个新事件。除非启用事件计划程序，否则事件将不会运行。有关检查事件计划程序状态并在必要时启用它的信息，请参阅第23.4.2节“事件计划程序配置”。</p><p>
            <a class="link" href="sql-syntax.html#create-event" title="13.1.12&nbsp;CREATE EVENT Syntax"><code class="literal">CREATE EVENT</code></a> requires the
            <a class="link" href="security.html#priv_event"><code class="literal">EVENT</code></a> privilege for the schema in
            which the event is to be created. If the
            <code class="literal">DEFINER</code> clause is present, the privileges
            required depend on the <em class="replaceable"><code>user</code></em> value, as
            discussed in <a class="xref" href="stored-objects.html#stored-objects-security" title="23.6&nbsp;Stored Object Access Control">Section&nbsp;23.6, “Stored Object Access Control”</a>.
        </p><p style="color:blue;">创建事件需要在其中创建事件的架构的事件特权。如果存在definer子句，则所需的权限取决于用户值，如第23.6节“存储对象访问控制”中所述。</p><p>
            The minimum requirements for a valid <a class="link" href="sql-syntax.html#create-event" title="13.1.12&nbsp;CREATE EVENT Syntax"><code class="literal">CREATE
            EVENT</code></a> statement are as follows:
        </p><p style="color:blue;">有效的create event语句的最低要求如下：</p>
            <div class="itemizedlist">
                <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                    The keywords <a class="link" href="sql-syntax.html#create-event" title="13.1.12&nbsp;CREATE EVENT Syntax"><code class="literal">CREATE EVENT</code></a> plus
                    an event name, which uniquely identifies the event in a
                    database schema.
                </p><p style="color:blue;">关键字create event加上一个事件名，它唯一地标识数据库架构中的事件。</p></li><li class="listitem"><p>
                    An <code class="literal">ON SCHEDULE</code> clause, which determines
                    when and how often the event executes.
                </p><p style="color:blue;">一个按计划执行的子句，它决定事件的执行时间和频率。</p></li><li class="listitem"><p>
                    A <a class="link" href="sql-syntax.html#do" title="13.2.3&nbsp;DO Syntax"><code class="literal">DO</code></a> clause, which contains the
                    SQL statement to be executed by an event.
                </p><p style="color:blue;">一个do子句，它包含由事件执行的sql语句。</p></li></ul>
            </div>
            <p>
                This is an example of a minimal <a class="link" href="sql-syntax.html#create-event" title="13.1.12&nbsp;CREATE EVENT Syntax"><code class="literal">CREATE
                EVENT</code></a> statement:
            </p><p style="color:blue;">下面是最小创建事件语句的示例：</p><pre data-lang="sql" class="programlisting">CREATE EVENT myevent
    ON SCHEDULE AT CURRENT_TIMESTAMP + INTERVAL 1 HOUR
    DO
      UPDATE myschema.mytable SET mycol = mycol + 1;
</pre><p>
            The previous statement creates an event named
            <code class="literal">myevent</code>. This event executes once—one
            hour following its creation—by running an SQL statement that
            increments the value of the <code class="literal">myschema.mytable</code>
            table's <code class="literal">mycol</code> column by 1.
        </p><p style="color:blue;">前面的语句创建一个名为myEvent的事件。此事件在创建后一小时执行一次，方法是运行一条SQL语句，将myschema.mytable表的mycol列的值增加1。</p><p>
            The <em class="replaceable"><code>event_name</code></em> must be a valid MySQL
            identifier with a maximum length of 64 characters. Event names are
            not case-sensitive, so you cannot have two events named
            <code class="literal">myevent</code> and <code class="literal">MyEvent</code> in the
            same schema. In general, the rules governing event names are the
            same as those for names of stored routines. See
            <a class="xref" href="language-structure.html#identifiers" title="9.2&nbsp;Schema Object Names">Section&nbsp;9.2, “Schema Object Names”</a>.
        </p><p style="color:blue;">事件名必须是最大长度为64个字符的有效MySQL标识符。事件名称不区分大小写，因此在同一架构中不能有两个名为myEvent和myEvent的事件。通常，控制事件名的规则与存储例程名的规则相同。参见第9.2节“模式对象名称”。</p><p>
            An event is associated with a schema. If no schema is indicated as
            part of <em class="replaceable"><code>event_name</code></em>, the default
            (current) schema is assumed. To create an event in a specific
            schema, qualify the event name with a schema using
            <code class="literal"><em class="replaceable"><code>schema_name</code></em>.<em class="replaceable"><code>event_name</code></em></code>
            syntax.
        </p><p style="color:blue;">事件与架构关联。如果没有将架构指示为事件名称的一部分，则假定为默认（当前）架构。要在特定架构中创建事件，请使用schema_name.event_name语法用架构限定事件名称。</p><p>
            The <code class="literal">DEFINER</code> clause specifies the MySQL account
            to be used when checking access privileges at event execution
            time. If the <code class="literal">DEFINER</code> clause is present, the
            <em class="replaceable"><code>user</code></em> value should be a MySQL account
            specified as
            <code class="literal">'<em class="replaceable"><code>user_name</code></em>'@'<em class="replaceable"><code>host_name</code></em>'</code>,
            <a class="link" href="functions.html#function_current-user"><code class="literal">CURRENT_USER</code></a>, or
            <a class="link" href="functions.html#function_current-user"><code class="literal">CURRENT_USER()</code></a>. The permitted
            <em class="replaceable"><code>user</code></em> values depend on the privileges
            you hold, as discussed in
            <a class="xref" href="stored-objects.html#stored-objects-security" title="23.6&nbsp;Stored Object Access Control">Section&nbsp;23.6, “Stored Object Access Control”</a>. Also see that section
            for additional information about event security.
        </p><p style="color:blue;">definer子句指定在事件执行时检查访问权限时要使用的mysql帐户。如果存在definer子句，则用户值应为mysql帐户，指定为“user_name”@“host_name”、current_user或current_user（）。允许的用户值取决于您所拥有的特权，如第23.6节“存储对象访问控制”中所述。有关事件安全性的其他信息，请参见该部分。</p><p>
            If the <code class="literal">DEFINER</code> clause is omitted, the default
            definer is the user who executes the <a class="link" href="sql-syntax.html#create-event" title="13.1.12&nbsp;CREATE EVENT Syntax"><code class="literal">CREATE
            EVENT</code></a> statement. This is the same as specifying
            <code class="literal">DEFINER = CURRENT_USER</code> explicitly.
        </p><p style="color:blue;">如果省略definer子句，则默认的definer是执行create event语句的用户。这与显式指定definer=current_user相同。</p><p>
            Within an event body, the
            <a class="link" href="functions.html#function_current-user"><code class="literal">CURRENT_USER</code></a> function returns the
            account used to check privileges at event execution time, which is
            the <code class="literal">DEFINER</code> user. For information about user
            auditing within events, see
            <a class="xref" href="security.html#account-activity-auditing" title="6.2.18&nbsp;SQL-Based Account Activity Auditing">Section&nbsp;6.2.18, “SQL-Based Account Activity Auditing”</a>.
        </p><p style="color:blue;">在事件体中，当前用户函数返回用于在事件执行时检查权限的帐户，该帐户是定义用户。有关事件内用户审核的信息，请参阅第6.2.18节“基于SQL的帐户活动审核”。</p><p>
            <code class="literal">IF NOT EXISTS</code> has the same meaning for
            <a class="link" href="sql-syntax.html#create-event" title="13.1.12&nbsp;CREATE EVENT Syntax"><code class="literal">CREATE EVENT</code></a> as for
            <a class="link" href="sql-syntax.html#create-table" title="13.1.18&nbsp;CREATE TABLE Syntax"><code class="literal">CREATE TABLE</code></a>: If an event named
            <em class="replaceable"><code>event_name</code></em> already exists in the same
            schema, no action is taken, and no error results. (However, a
            warning is generated in such cases.)
        </p><p style="color:blue;">如果不存在，则对于创建表与创建表的含义相同：如果一个名为EnvivNeNT的事件已经存在于同一模式中，则不采取任何操作，也不会产生错误。（但是，在这种情况下会生成警告。）</p><p>
            The <code class="literal">ON SCHEDULE</code> clause determines when, how
            often, and for how long the <em class="replaceable"><code>event_body</code></em>
            defined for the event repeats. This clause takes one of two forms:
        </p><p style="color:blue;">on schedule子句确定为事件定义的事件体重复的时间、频率和持续时间。本条款有两种形式：</p>
            <div class="itemizedlist">
                <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                    <code class="literal">AT <em class="replaceable"><code>timestamp</code></em></code> is
                    used for a one-time event. It specifies that the event
                    executes one time only at the date and time given by
                    <em class="replaceable"><code>timestamp</code></em>, which must include both
                    the date and time, or must be an expression that resolves to a
                    datetime value. You may use a value of either the
                    <a class="link" href="data-types.html#datetime" title="11.3.1&nbsp;The DATE, DATETIME, and TIMESTAMP Types"><code class="literal">DATETIME</code></a> or
                    <a class="link" href="data-types.html#datetime" title="11.3.1&nbsp;The DATE, DATETIME, and TIMESTAMP Types"><code class="literal">TIMESTAMP</code></a> type for this
                    purpose. If the date is in the past, a warning occurs, as
                    shown here:
                </p><p style="color:blue;">at timestamp用于一次性事件。它指定事件仅在时间戳给定的日期和时间执行一次，时间戳必须包含日期和时间，或者必须是解析为日期时间值的表达式。为此，可以使用datetime或timestamp类型的值。如果日期是过去的，则会出现警告，如下所示：</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT NOW();</code></strong>
+---------------------+
| NOW()               |
+---------------------+
| 2006-02-10 23:59:01 |
+---------------------+
1 row in set (0.04 sec)

mysql&gt; <strong class="userinput"><code>CREATE EVENT e_totals</code></strong>
    -&gt;     <strong class="userinput"><code>ON SCHEDULE AT '2006-02-10 23:59:00'</code></strong>
    -&gt;     <strong class="userinput"><code>DO INSERT INTO test.totals VALUES (NOW());</code></strong>
Query OK, 0 rows affected, 1 warning (0.00 sec)

mysql&gt; <strong class="userinput"><code>SHOW WARNINGS\G</code></strong>
*************************** 1. row ***************************
  Level: Note
   Code: 1588
Message: Event execution time is in the past and ON COMPLETION NOT
         PRESERVE is set. The event was dropped immediately after
         creation.
</pre><p>
                    <a class="link" href="sql-syntax.html#create-event" title="13.1.12&nbsp;CREATE EVENT Syntax"><code class="literal">CREATE EVENT</code></a> statements which
                    are themselves invalid—for whatever reason—fail
                    with an error.
                </p><p style="color:blue;">创建本身因任何原因无效的事件语句，但由于错误而失败。</p><p>
                    You may use <a class="link" href="functions.html#function_current-timestamp"><code class="literal">CURRENT_TIMESTAMP</code></a>
                    to specify the current date and time. In such a case, the
                    event acts as soon as it is created.
                </p><p style="color:blue;">您可以使用当前时间戳来指定当前日期和时间。在这种情况下，事件一经创建就立即生效。</p><p>
                    To create an event which occurs at some point in the future
                    relative to the current date and time—such as that
                    expressed by the phrase <span class="quote">“<span class="quote">three weeks from
          now</span>”</span>—you can use the optional clause <code class="literal">+
                    INTERVAL <em class="replaceable"><code>interval</code></em></code>. The
                    <em class="replaceable"><code>interval</code></em> portion consists of two
                    parts, a quantity and a unit of time, and follows the syntax
                    rules described in <a class="xref" href="language-structure.html#temporal-intervals" title="Temporal Intervals">Temporal Intervals</a>,
                    except that you cannot use any units keywords that involving
                    microseconds when defining an event. With some interval types,
                    complex time units may be used. For example, <span class="quote">“<span class="quote">two
          minutes and ten seconds</span>”</span> can be expressed as <code class="literal">+
                    INTERVAL '2:10' MINUTE_SECOND</code>.
                </p><p style="color:blue;">要创建一个事件，该事件发生在未来某个时间点（相对于当前日期和时间），如短语“从现在开始的三周”所表示的日期和时间，可以使用optional子句+interval interval。间隔部分由数量和时间单位两部分组成，并遵循时间间隔中描述的语法规则，但在定义事件时不能使用任何涉及微秒的单位关键字。对于某些间隔类型，可以使用复杂的时间单位。例如，“2分10秒”可以表示为+间隔“2:10”分秒。</p><p>
                    You can also combine intervals. For example, <code class="literal">AT
                    CURRENT_TIMESTAMP + INTERVAL 3 WEEK + INTERVAL 2 DAY</code>
                    is equivalent to <span class="quote">“<span class="quote">three weeks and two days from
          now</span>”</span>. Each portion of such a clause must begin with
                    <code class="literal">+ INTERVAL</code>.
                </p><p style="color:blue;">也可以合并间隔。例如，在当前时间戳+间隔3周+间隔2天等于“三周零两天后”。这类子句的每个部分都必须以+interval开头。</p></li><li class="listitem"><p>
                    To repeat actions at a regular interval, use an
                    <code class="literal">EVERY</code> clause. The <code class="literal">EVERY</code>
                    keyword is followed by an <em class="replaceable"><code>interval</code></em>
                    as described in the previous discussion of the
                    <code class="literal">AT</code> keyword. (<code class="literal">+ INTERVAL</code>
                    is <span class="emphasis"><em>not</em></span> used with
                    <code class="literal">EVERY</code>.) For example, <code class="literal">EVERY 6
                    WEEK</code> means <span class="quote">“<span class="quote">every six weeks</span>”</span>.
                </p><p style="color:blue;">要定期重复操作，请使用every子句。every关键字后面跟着一个间隔，如前面关于at关键字的讨论中所述。（+interval不用于every。）例如，每隔6周表示“每6周”。</p><p>
                    Although <code class="literal">+ INTERVAL</code> clauses are not
                    permitted in an <code class="literal">EVERY</code> clause, you can use
                    the same complex time units permitted in a <code class="literal">+
                    INTERVAL</code>.
                </p><p style="color:blue;">尽管在每个子句中都不允许使用+interval子句，但可以使用+interval中允许的相同复杂时间单位。</p><p>
                    An <code class="literal">EVERY</code> clause may contain an optional
                    <code class="literal">STARTS</code> clause. <code class="literal">STARTS</code> is
                    followed by a <em class="replaceable"><code>timestamp</code></em> value that
                    indicates when the action should begin repeating, and may also
                    use <code class="literal">+ INTERVAL
                    <em class="replaceable"><code>interval</code></em></code> to specify an
                    amount of time <span class="quote">“<span class="quote">from now</span>”</span>. For example,
                    <code class="literal">EVERY 3 MONTH STARTS CURRENT_TIMESTAMP + INTERVAL 1
                        WEEK</code> means <span class="quote">“<span class="quote">every three months, beginning one
          week from now</span>”</span>. Similarly, you can express <span class="quote">“<span class="quote">every
          two weeks, beginning six hours and fifteen minutes from
          now</span>”</span> as <code class="literal">EVERY 2 WEEK STARTS CURRENT_TIMESTAMP
                    + INTERVAL '6:15' HOUR_MINUTE</code>. Not specifying
                    <code class="literal">STARTS</code> is the same as using <code class="literal">STARTS
                    CURRENT_TIMESTAMP</code>—that is, the action
                    specified for the event begins repeating immediately upon
                    creation of the event.
                </p><p style="color:blue;">every子句可以包含可选的starts子句。starts后面跟着一个时间戳值，该值指示操作何时开始重复，还可以使用+interval interval指定“从现在开始”的时间量。例如，每3个月开始当前时间戳+间隔1周表示“每3个月，从现在开始一周”。类似地，您可以表示“每两周，从现在开始6小时15分钟”，因为每两周开始当前时间戳+间隔“6:15”小时1分钟。不指定starts与使用starts current_timestamp相同，也就是说，为事件指定的操作在创建事件时立即开始重复。</p><p>
                    An <code class="literal">EVERY</code> clause may contain an optional
                    <code class="literal">ENDS</code> clause. The <code class="literal">ENDS</code>
                    keyword is followed by a <em class="replaceable"><code>timestamp</code></em>
                    value that tells MySQL when the event should stop repeating.
                    You may also use <code class="literal">+ INTERVAL
                    <em class="replaceable"><code>interval</code></em></code> with
                    <code class="literal">ENDS</code>; for instance, <code class="literal">EVERY 12 HOUR
                    STARTS CURRENT_TIMESTAMP + INTERVAL 30 MINUTE ENDS
                    CURRENT_TIMESTAMP + INTERVAL 4 WEEK</code> is equivalent to
                    <span class="quote">“<span class="quote">every twelve hours, beginning thirty minutes from now,
          and ending four weeks from now</span>”</span>. Not using
                    <code class="literal">ENDS</code> means that the event continues
                    executing indefinitely.
                </p><p style="color:blue;">every子句可以包含可选的ends子句。ends关键字后面跟着一个时间戳值，该值告诉mysql事件何时应该停止重复。您还可以使用+interval interval和ends；例如，每12小时开始当前时间戳+interval 30分钟结束当前时间戳+interval 4 week相当于“每12小时，从现在开始30分钟，从现在开始4周结束”。不使用ends意味着事件将无限期地继续执行。</p><p>
                    <code class="literal">ENDS</code> supports the same syntax for complex
                    time units as <code class="literal">STARTS</code> does.
                </p><p style="color:blue;">对于复杂的时间单位，ends支持与start相同的语法。</p><p>
                    You may use <code class="literal">STARTS</code>,
                    <code class="literal">ENDS</code>, both, or neither in an
                    <code class="literal">EVERY</code> clause.
                </p><p style="color:blue;">在every子句中可以使用start、ends、both或both。</p><p>
                    If a repeating event does not terminate within its scheduling
                    interval, the result may be multiple instances of the event
                    executing simultaneously. If this is undesirable, you should
                    institute a mechanism to prevent simultaneous instances. For
                    example, you could use the
                    <a class="link" href="functions.html#function_get-lock"><code class="literal">GET_LOCK()</code></a> function, or row or
                    table locking.
                </p><p style="color:blue;">如果重复事件未在其调度间隔内终止，则结果可能是事件的多个实例同时执行。如果这是不可取的，您应该建立一种机制来防止同时发生实例。例如，可以使用get_lock（）函数或行或表锁定。</p></li></ul>
            </div>
            <p>
                The <code class="literal">ON SCHEDULE</code> clause may use expressions
                involving built-in MySQL functions and user variables to obtain
                any of the <em class="replaceable"><code>timestamp</code></em> or
                <em class="replaceable"><code>interval</code></em> values which it contains. You
                may not use stored functions or user-defined functions in such
                expressions, nor may you use any table references; however, you
                may use <code class="literal">SELECT FROM DUAL</code>. This is true for both
                <a class="link" href="sql-syntax.html#create-event" title="13.1.12&nbsp;CREATE EVENT Syntax"><code class="literal">CREATE EVENT</code></a> and
                <a class="link" href="sql-syntax.html#alter-event" title="13.1.2&nbsp;ALTER EVENT Syntax"><code class="literal">ALTER EVENT</code></a> statements. References
                to stored functions, user-defined functions, and tables in such
                cases are specifically not permitted, and fail with an error (see
                Bug #22830).
            </p><p style="color:blue;">on schedule子句可以使用包含内置mysql函数和用户变量的表达式来获取它包含的任何时间戳或间隔值。您不能在此类表达式中使用存储函数或用户定义函数，也不能使用任何表引用；但是，您可以使用select from dual。对于create event和alter event语句都是这样。在这种情况下，不允许引用存储的函数、用户定义的函数和表，并且会出错（请参阅错误22830）。</p><p>
            Times in the <code class="literal">ON SCHEDULE</code> clause are interpreted
            using the current session
            <a class="link" href="server-administration.html#sysvar_time_zone"><code class="literal">time_zone</code></a> value. This becomes the
            event time zone; that is, the time zone that is used for event
            scheduling and is in effect within the event as it executes. These
            times are converted to UTC and stored along with the event time
            zone in the <code class="literal">mysql.event</code> table. This enables
            event execution to proceed as defined regardless of any subsequent
            changes to the server time zone or daylight saving time effects.
            For additional information about representation of event times,
            see <a class="xref" href="stored-objects.html#events-metadata" title="23.4.4&nbsp;Event Metadata">Section&nbsp;23.4.4, “Event Metadata”</a>. See also
            <a class="xref" href="sql-syntax.html#show-events" title="13.7.5.18&nbsp;SHOW EVENTS Syntax">Section&nbsp;13.7.5.18, “SHOW EVENTS Syntax”</a>, and <a class="xref" href="information-schema.html#events-table" title="24.8&nbsp;The INFORMATION_SCHEMA EVENTS Table">Section&nbsp;24.8, “The INFORMATION_SCHEMA EVENTS Table”</a>.
        </p><p style="color:blue;">on schedule子句中的时间将使用当前会话时区值进行解释。这将成为事件时区；也就是说，用于事件调度并在事件执行时在事件内生效的时区。这些时间将转换为UTC，并与事件时区一起存储在mysql.event表中。这样，无论服务器时区或夏令时效果的任何后续更改如何，都可以按定义继续执行事件。有关事件时间表示的其他信息，请参见第23.4.4节“事件元数据”。另请参见第13.7.5.18节“显示事件语法”和第24.8节“信息架构事件表”。</p><p>
            Normally, once an event has expired, it is immediately dropped.
            You can override this behavior by specifying <code class="literal">ON
            COMPLETION PRESERVE</code>. Using <code class="literal">ON COMPLETION NOT
            PRESERVE</code> merely makes the default nonpersistent behavior
            explicit.
        </p><p style="color:blue;">通常，一旦事件过期，它会立即被删除。可以通过指定完成时保留来覆盖此行为。使用on completion而不是preserve只会使默认的非持久行为显式化。</p><p>
            You can create an event but prevent it from being active using the
            <code class="literal">DISABLE</code> keyword. Alternatively, you can use
            <code class="literal">ENABLE</code> to make explicit the default status,
            which is active. This is most useful in conjunction with
            <a class="link" href="sql-syntax.html#alter-event" title="13.1.2&nbsp;ALTER EVENT Syntax"><code class="literal">ALTER EVENT</code></a> (see
            <a class="xref" href="sql-syntax.html#alter-event" title="13.1.2&nbsp;ALTER EVENT Syntax">Section&nbsp;13.1.2, “ALTER EVENT Syntax”</a>).
        </p><p style="color:blue;">您可以创建一个事件，但使用disable关键字阻止它处于活动状态。或者，您可以使用enable将默认状态显式设置为活动状态。这与alter event结合使用最为有用（请参见第13.1.2节“alter event syntax”）。</p><p>
            A third value may also appear in place of
            <code class="literal">ENABLE</code> or <code class="literal">DISABLE</code>;
            <code class="literal">DISABLE ON SLAVE</code> is set for the status of an
            event on a replication slave to indicate that the event was
            created on the master and replicated to the slave, but is not
            executed on the slave. See
            <a class="xref" href="replication.html#replication-features-invoked" title="16.4.1.16&nbsp;Replication of Invoked Features">Section&nbsp;16.4.1.16, “Replication of Invoked Features”</a>.
        </p><p style="color:blue;">第三个值也可能出现在enable或disable的位置；disable on slave是为复制从机上的事件的状态设置的，用于指示事件是在主机上创建并复制到从机上的，但不是在从机上执行的。见16.4.1.16节，“调用功能的复制”。</p><p>
            You may supply a comment for an event using a
            <code class="literal">COMMENT</code> clause.
            <em class="replaceable"><code>comment</code></em> may be any string of up to 64
            characters that you wish to use for describing the event. The
            comment text, being a string literal, must be surrounded by
            quotation marks.
        </p><p style="color:blue;">您可以使用comment子句为事件提供注释。注释可以是任何字符串，最多64个字符，您希望用于描述事件。注释文本是字符串文本，必须用引号括起来。</p><p>
            The <a class="link" href="sql-syntax.html#do" title="13.2.3&nbsp;DO Syntax"><code class="literal">DO</code></a> clause specifies an action
            carried by the event, and consists of an SQL statement. Nearly any
            valid MySQL statement that can be used in a stored routine can
            also be used as the action statement for a scheduled event. (See
            <a class="xref" href="stored-objects.html#stored-program-restrictions" title="23.8&nbsp;Restrictions on Stored Programs">Section&nbsp;23.8, “Restrictions on Stored Programs”</a>.) For example, the
            following event <code class="literal">e_hourly</code> deletes all rows from
            the <code class="literal">sessions</code> table once per hour, where this
            table is part of the <code class="literal">site_activity</code> schema:
        </p><p style="color:blue;">do子句指定由事件执行的操作，并由sql语句组成。几乎所有可以在存储例程中使用的有效mysql语句也可以用作预定事件的操作语句。（请参阅第23.8节“存储程序的限制”。）例如，以下事件e_hourly每小时从sessions表中删除一次所有行，其中该表是site_活动架构的一部分：</p><pre data-lang="sql" class="programlisting">CREATE EVENT e_hourly
    ON SCHEDULE
      EVERY 1 HOUR
    COMMENT 'Clears out sessions table each hour.'
    DO
      DELETE FROM site_activity.sessions;
</pre><p>
            MySQL stores the <a class="link" href="server-administration.html#sysvar_sql_mode"><code class="literal">sql_mode</code></a> system
            variable setting in effect when an event is created or altered,
            and always executes the event with this setting in force,
            <span class="emphasis"><em>regardless of the current server SQL mode when the event
      begins executing</em></span>.
        </p><p style="color:blue;">mysql存储在创建或更改事件时生效的sql_mode系统变量设置，并始终使用此设置执行事件，而不管事件开始执行时的当前服务器sql模式如何。</p><p>
            A <a class="link" href="sql-syntax.html#create-event" title="13.1.12&nbsp;CREATE EVENT Syntax"><code class="literal">CREATE EVENT</code></a> statement that
            contains an <a class="link" href="sql-syntax.html#alter-event" title="13.1.2&nbsp;ALTER EVENT Syntax"><code class="literal">ALTER EVENT</code></a> statement
            in its <a class="link" href="sql-syntax.html#do" title="13.2.3&nbsp;DO Syntax"><code class="literal">DO</code></a> clause appears to
            succeed; however, when the server attempts to execute the
            resulting scheduled event, the execution fails with an error.
        </p><p style="color:blue;">在do子句中包含alter event语句的create event语句似乎成功；但是，当服务器尝试执行生成的调度事件时，执行失败，并出现错误。</p>
            <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">

                <div class="admon-title">
                    Note
                </div>
                <p>
                    Statements such as <a class="link" href="sql-syntax.html#select" title="13.2.9&nbsp;SELECT Syntax"><code class="literal">SELECT</code></a> or
                    <a class="link" href="sql-syntax.html#show" title="13.7.5&nbsp;SHOW Syntax"><code class="literal">SHOW</code></a> that merely return a result
                    set have no effect when used in an event; the output from these
                    is not sent to the MySQL Monitor, nor is it stored anywhere.
                    However, you can use statements such as
                    <a class="link" href="sql-syntax.html#select" title="13.2.9&nbsp;SELECT Syntax"><code class="literal">SELECT ...
                        INTO</code></a> and
                    <a class="link" href="sql-syntax.html#insert-select" title="13.2.5.1&nbsp;INSERT ... SELECT Syntax"><code class="literal">INSERT INTO ...
                        SELECT</code></a> that store a result. (See the next example in
                    this section for an instance of the latter.)
                </p><p style="color:blue;">像select或show这样的语句在事件中使用时仅返回一个结果集没有任何效果；这些语句的输出不会发送到mysql监视器，也不会存储在任何地方。但是，您可以使用诸如select…插入并插入…选择存储结果。（有关后者的实例，请参见本节中的下一个示例。）</p>
            </div>
            <p>
                The schema to which an event belongs is the default schema for
                table references in the <a class="link" href="sql-syntax.html#do" title="13.2.3&nbsp;DO Syntax"><code class="literal">DO</code></a> clause.
                Any references to tables in other schemas must be qualified with
                the proper schema name.
            </p><p style="color:blue;">事件所属的架构是do子句中表引用的默认架构。对其他架构中的表的任何引用都必须使用正确的架构名称进行限定。</p><p>
            As with stored routines, you can use compound-statement syntax in
            the <a class="link" href="sql-syntax.html#do" title="13.2.3&nbsp;DO Syntax"><code class="literal">DO</code></a> clause by using the
            <code class="literal">BEGIN</code> and <code class="literal">END</code> keywords, as
            shown here:
        </p><p style="color:blue;">与存储例程一样，可以通过使用begin和end关键字在do子句中使用复合语句语法，如下所示：</p><pre data-lang="sql" class="programlisting">delimiter |

CREATE EVENT e_daily
    ON SCHEDULE
      EVERY 1 DAY
    COMMENT 'Saves total number of sessions then clears the table each day'
    DO
      BEGIN
        INSERT INTO site_activity.totals (time, total)
          SELECT CURRENT_TIMESTAMP, COUNT(*)
            FROM site_activity.sessions;
        DELETE FROM site_activity.sessions;
      END |

delimiter ;
</pre><p>
            This example uses the <code class="literal">delimiter</code> command to
            change the statement delimiter. See
            <a class="xref" href="stored-objects.html#stored-programs-defining" title="23.1&nbsp;Defining Stored Programs">Section&nbsp;23.1, “Defining Stored Programs”</a>.
        </p><p style="color:blue;">本例使用delimiter命令更改语句分隔符。参见第23.1节“定义存储程序”。</p><p>
            More complex compound statements, such as those used in stored
            routines, are possible in an event. This example uses local
            variables, an error handler, and a flow control construct:
        </p><p style="color:blue;">在事件中可以使用更复杂的复合语句，如存储例程中使用的语句。此示例使用局部变量、错误处理程序和流控制构造：</p><pre data-lang="sql" class="programlisting">delimiter |

CREATE EVENT e
    ON SCHEDULE
      EVERY 5 SECOND
    DO
      BEGIN
        DECLARE v INTEGER;
        DECLARE CONTINUE HANDLER FOR SQLEXCEPTION BEGIN END;

        SET v = 0;

        WHILE v &lt; 5 DO
          INSERT INTO t1 VALUES (0);
          UPDATE t2 SET s1 = s1 + 1;
          SET v = v + 1;
        END WHILE;
    END |

delimiter ;
</pre><p>
            There is no way to pass parameters directly to or from events;
            however, it is possible to invoke a stored routine with parameters
            within an event:
        </p><p style="color:blue;">无法直接向事件传递参数或从事件传递参数；但是，可以使用事件中的参数调用存储例程：</p><pre data-lang="sql" class="programlisting">CREATE EVENT e_call_myproc
    ON SCHEDULE
      AT CURRENT_TIMESTAMP + INTERVAL 1 DAY
    DO CALL myproc(5, 27);
</pre><p>
            If an event's definer has privileges sufficient to set global
            system variables (see
            <a class="xref" href="server-administration.html#system-variable-privileges" title="5.1.8.1&nbsp;System Variable Privileges">Section&nbsp;5.1.8.1, “System Variable Privileges”</a>), the event can read
            and write global variables. As granting such privileges entails a
            potential for abuse, extreme care must be taken in doing so.
        </p><p style="color:blue;">如果事件的定义者有足够的权限设置全局系统变量（请参阅第5.1.8.1节“系统变量权限”），则事件可以读取和写入全局变量。由于给予这种特权有可能被滥用，因此在这样做时必须格外小心。</p><p>
            Generally, any statements that are valid in stored routines may be
            used for action statements executed by events. For more
            information about statements permissible within stored routines,
            see <a class="xref" href="stored-objects.html#stored-routines-syntax" title="23.2.1&nbsp;Stored Routine Syntax">Section&nbsp;23.2.1, “Stored Routine Syntax”</a>. You can create an
            event as part of a stored routine, but an event cannot be created
            by another event.
        </p><p style="color:blue;">通常，在存储例程中有效的任何语句都可以用于由事件执行的操作语句。有关存储例程中允许的语句的更多信息，请参阅第23.2.1节“存储例程语法”。可以将事件创建为存储例程的一部分，但另一个事件不能创建事件。</p>
        </div>
        <div class="section">
            <div class="titlepage">
                <div>
                    <div>
                        <h3 class="title"><a name="create-function"></a>13.1.13&nbsp;CREATE FUNCTION Syntax</h3>

                    </div>

                </div>

            </div>
            <p>
                The <a class="link" href="sql-syntax.html#create-function" title="13.1.13&nbsp;CREATE FUNCTION Syntax"><code class="literal">CREATE FUNCTION</code></a> statement is
                used to create stored functions and user-defined functions (UDFs):
            </p><p style="color:blue;">create function语句用于创建存储函数和用户定义函数（UDF）：</p>
            <div class="itemizedlist">
                <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                    For information about creating stored functions, see
                    <a class="xref" href="sql-syntax.html#create-procedure" title="13.1.16&nbsp;CREATE PROCEDURE and CREATE FUNCTION Syntax">Section&nbsp;13.1.16, “CREATE PROCEDURE and CREATE FUNCTION Syntax”</a>.
                </p><p style="color:blue;">有关创建存储函数的信息，请参见第13.1.16节“创建过程和创建函数语法”。</p><a class="indexterm" name="idm140286840270032"></a></li><li class="listitem"><p>
                    For information about creating user-defined functions, see
                    <a class="xref" href="sql-syntax.html#create-function-udf" title="13.7.3.1&nbsp;CREATE FUNCTION Syntax for User-Defined Functions">Section&nbsp;13.7.3.1, “CREATE FUNCTION Syntax for User-Defined Functions”</a>.
                </p><p style="color:blue;">有关创建用户定义函数的信息，请参见第13.7.3.1节“为用户定义函数创建函数语法”。</p></li></ul>
            </div>

        </div>
        <div class="section">
            <div class="titlepage">
                <div>
                    <div>
                        <h3 class="title"><a name="create-index"></a>13.1.14&nbsp;CREATE INDEX Syntax</h3>

                    </div>

                </div>

            </div>
            <a class="indexterm" name="idm140286840265936"></a><a class="indexterm" name="idm140286840264864"></a><a class="indexterm" name="idm140286840263792"></a><a class="indexterm" name="idm140286840262304"></a><pre data-lang="sql" class="programlisting">CREATE [UNIQUE | FULLTEXT | SPATIAL] INDEX <em class="replaceable"><code>index_name</code></em>
    [<em class="replaceable"><code>index_type</code></em>]
    ON <em class="replaceable"><code>tbl_name</code></em> (<em class="replaceable"><code>key_part</code></em>,...)
    [<em class="replaceable"><code>index_option</code></em>]
    [<em class="replaceable"><code>algorithm_option</code></em> | <em class="replaceable"><code>lock_option</code></em>] ...

<em class="replaceable"><code>key_part</code></em>:
    <em class="replaceable"><code>col_name</code></em> [(<em class="replaceable"><code>length</code></em>)] [ASC | DESC]

<em class="replaceable"><code>index_option</code></em>:
    KEY_BLOCK_SIZE [=] <em class="replaceable"><code>value</code></em>
  | <em class="replaceable"><code>index_type</code></em>
  | WITH PARSER <em class="replaceable"><code>parser_name</code></em>
  | COMMENT '<em class="replaceable"><code>string</code></em>'

<em class="replaceable"><code>index_type</code></em>:
    USING {BTREE | HASH}

<em class="replaceable"><code>algorithm_option</code></em>:
    ALGORITHM [=] {DEFAULT | INPLACE | COPY}

<em class="replaceable"><code>lock_option</code></em>:
    LOCK [=] {DEFAULT | NONE | SHARED | EXCLUSIVE}
</pre><p>
            Normally, you create all indexes on a table at the time the table
            itself is created with <a class="link" href="sql-syntax.html#create-table" title="13.1.18&nbsp;CREATE TABLE Syntax"><code class="literal">CREATE
            TABLE</code></a>. See <a class="xref" href="sql-syntax.html#create-table" title="13.1.18&nbsp;CREATE TABLE Syntax">Section&nbsp;13.1.18, “CREATE TABLE Syntax”</a>. This
            guideline is especially important for
            <a class="link" href="innodb-storage-engine.html" title="Chapter&nbsp;14&nbsp;The InnoDB Storage Engine"><code class="literal">InnoDB</code></a> tables, where the primary key
            determines the physical layout of rows in the data file.
            <a class="link" href="sql-syntax.html#create-index" title="13.1.14&nbsp;CREATE INDEX Syntax"><code class="literal">CREATE INDEX</code></a> enables you to add
            indexes to existing tables.
        </p><p style="color:blue;">通常，在使用create table创建表本身时，会在表上创建所有索引。参见第13.1.18节“创建表语法”。这条准则对于innodb表尤其重要，在innodb表中，主键决定数据文件中行的物理布局。创建索引使您可以向现有表添加索引。</p><p>
            <a class="link" href="sql-syntax.html#create-index" title="13.1.14&nbsp;CREATE INDEX Syntax"><code class="literal">CREATE INDEX</code></a> is mapped to an
            <a class="link" href="sql-syntax.html#alter-table" title="13.1.8&nbsp;ALTER TABLE Syntax"><code class="literal">ALTER TABLE</code></a> statement to create
            indexes. See <a class="xref" href="sql-syntax.html#alter-table" title="13.1.8&nbsp;ALTER TABLE Syntax">Section&nbsp;13.1.8, “ALTER TABLE Syntax”</a>.
            <a class="link" href="sql-syntax.html#create-index" title="13.1.14&nbsp;CREATE INDEX Syntax"><code class="literal">CREATE INDEX</code></a> cannot be used to
            create a <code class="literal">PRIMARY KEY</code>; use
            <a class="link" href="sql-syntax.html#alter-table" title="13.1.8&nbsp;ALTER TABLE Syntax"><code class="literal">ALTER TABLE</code></a> instead. For more
            information about indexes, see <a class="xref" href="optimization.html#mysql-indexes" title="8.3.1&nbsp;How MySQL Uses Indexes">Section&nbsp;8.3.1, “How MySQL Uses Indexes”</a>.
        </p><p style="color:blue;">create index映射到alter table语句以创建索引。见第13.1.8节“更改表语法”。创建索引不能用于创建主键；请改用alter table。有关索引的更多信息，请参阅8.3.1节，“MySQL如何使用索引”。</p><p>
            <a class="link" href="innodb-storage-engine.html" title="Chapter&nbsp;14&nbsp;The InnoDB Storage Engine"><code class="literal">InnoDB</code></a> supports secondary indexes on
            virtual columns. For more information, see
            <a class="xref" href="sql-syntax.html#create-table-secondary-indexes" title="13.1.18.9&nbsp;Secondary Indexes and Generated Columns">Section&nbsp;13.1.18.9, “Secondary Indexes and Generated Columns”</a>.
        </p><p style="color:blue;">innodb支持虚拟列上的辅助索引。有关详细信息，请参见第13.1.18.9节“二级索引和生成的列”。</p><p>
            When the <a class="link" href="innodb-storage-engine.html#sysvar_innodb_stats_persistent"><code class="literal">innodb_stats_persistent</code></a>
            setting is enabled, run the <a class="link" href="sql-syntax.html#analyze-table" title="13.7.2.1&nbsp;ANALYZE TABLE Syntax"><code class="literal">ANALYZE
            TABLE</code></a> statement for an
            <a class="link" href="innodb-storage-engine.html" title="Chapter&nbsp;14&nbsp;The InnoDB Storage Engine"><code class="literal">InnoDB</code></a> table after creating an index
            on that table.
        </p><p style="color:blue;">当innodb_stats_persistent设置被启用时，在innodb表上创建索引之后运行analyze table语句。</p><p>
            An index specification of the form
            <code class="literal">(<em class="replaceable"><code>key_part1</code></em>,
                <em class="replaceable"><code>key_part2</code></em>, ...)</code> creates an
            index with multiple key parts. Index key values are formed by
            concatenating the values of the given key parts. For example
            <code class="literal">(col1, col2, col3)</code> specifies a multiple-column
            index with index keys consisting of values from
            <code class="literal">col1</code>, <code class="literal">col2</code>, and
            <code class="literal">col3</code>.
        </p><p style="color:blue;">表单的索引规范（key_part1，key_part2，…）创建包含多个关键部分的索引。索引键值是通过连接给定键部分的值而形成的。例如（col1、col2、col3）指定具有索引键的多列索引，索引键由col1、col2和col3中的值组成。</p><p>
            A <em class="replaceable"><code>key_part</code></em> specification can end with
            <code class="literal">ASC</code> or <code class="literal">DESC</code>. These keywords
            are permitted for future extensions for specifying ascending or
            descending index value storage. Currently, they are parsed but
            ignored; index values are always stored in ascending order.
        </p><p style="color:blue;">键部件规范可以以asc或desc结尾。这些关键字可用于将来指定升序或降序索引值存储的扩展。目前，它们被解析但被忽略；索引值总是按升序存储。</p><p>
            The following sections describe different aspects of the
            <a class="link" href="sql-syntax.html#create-index" title="13.1.14&nbsp;CREATE INDEX Syntax"><code class="literal">CREATE INDEX</code></a> statement:
        </p><p style="color:blue;">以下部分描述create index语句的不同方面：</p>
            <div class="itemizedlist">
                <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><a class="xref" href="sql-syntax.html#create-index-column-prefixes" title="Column Prefix Key Parts">Column Prefix Key Parts</a></p><p style="color:blue;">列前缀键部分</p></li><li class="listitem"><p><a class="xref" href="sql-syntax.html#create-index-unique" title="Unique Indexes">Unique Indexes</a></p><p style="color:blue;">唯一索引</p></li><li class="listitem"><p><a class="xref" href="sql-syntax.html#create-index-fulltext" title="Full-Text Indexes">Full-Text Indexes</a></p><p style="color:blue;">全文索引</p></li><li class="listitem"><p><a class="xref" href="sql-syntax.html#create-index-spatial" title="Spatial Indexes">Spatial Indexes</a></p><p style="color:blue;">空间索引</p></li><li class="listitem"><p><a class="xref" href="sql-syntax.html#create-index-options" title="Index Options">Index Options</a></p><p style="color:blue;">索引选项</p></li><li class="listitem"><p><a class="xref" href="sql-syntax.html#create-index-copying" title="Table Copying and Locking Options">Table Copying and Locking Options</a></p><p style="color:blue;">表复制和锁定选项</p></li></ul>
            </div>

            <div class="simplesect">

                <div class="titlepage">
                    <div>

                        <div class="simple">
                            <h4 class="title"><a name="create-index-column-prefixes"></a>Column Prefix Key Parts</h4>

                        </div>

                    </div>

                </div>
                <p>
                    For string columns, indexes can be created that use only the
                    leading part of column values, using
                    <code class="literal"><em class="replaceable"><code>col_name</code></em>(<em class="replaceable"><code>length</code></em>)</code>
                    syntax to specify an index prefix length:
                </p><p style="color:blue;">对于字符串列，可以创建仅使用列值前导部分的索引，使用col_name（length）语法指定索引前缀长度：</p>
                <div class="itemizedlist">
                    <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                        Prefixes can be specified for
                        <a class="link" href="data-types.html#char" title="11.4.1&nbsp;The CHAR and VARCHAR Types"><code class="literal">CHAR</code></a>,
                        <a class="link" href="data-types.html#char" title="11.4.1&nbsp;The CHAR and VARCHAR Types"><code class="literal">VARCHAR</code></a>,
                        <a class="link" href="data-types.html#binary-varbinary" title="11.4.2&nbsp;The BINARY and VARBINARY Types"><code class="literal">BINARY</code></a>, and
                        <a class="link" href="data-types.html#binary-varbinary" title="11.4.2&nbsp;The BINARY and VARBINARY Types"><code class="literal">VARBINARY</code></a> key parts.
                    </p><p style="color:blue;">可以为char、varchar、binary和varbinary键部分指定前缀。</p></li><li class="listitem"><p>
                        Prefixes <span class="emphasis"><em>must</em></span> be specified for
                        <a class="link" href="data-types.html#blob" title="11.4.3&nbsp;The BLOB and TEXT Types"><code class="literal">BLOB</code></a> and
                        <a class="link" href="data-types.html#blob" title="11.4.3&nbsp;The BLOB and TEXT Types"><code class="literal">TEXT</code></a> key parts. Additionally,
                        <a class="link" href="data-types.html#blob" title="11.4.3&nbsp;The BLOB and TEXT Types"><code class="literal">BLOB</code></a> and
                        <a class="link" href="data-types.html#blob" title="11.4.3&nbsp;The BLOB and TEXT Types"><code class="literal">TEXT</code></a> columns can be indexed
                        only for <code class="literal">InnoDB</code>,
                        <code class="literal">MyISAM</code>, and <code class="literal">BLACKHOLE</code>
                        tables.
                    </p><p style="color:blue;">必须为blob和文本键部分指定前缀。此外，blob和文本列只能为innodb、myisam和blackhole表编制索引。</p><a class="indexterm" name="idm140286840196576"></a><a class="indexterm" name="idm140286840195088"></a><a class="indexterm" name="idm140286840193600"></a><a class="indexterm" name="idm140286840192112"></a></li><li class="listitem"><p>
                        Prefix <span class="emphasis"><em>limits</em></span> are measured in bytes.
                        However, prefix <span class="emphasis"><em>lengths</em></span> for index
                        specifications in <a class="link" href="sql-syntax.html#create-table" title="13.1.18&nbsp;CREATE TABLE Syntax"><code class="literal">CREATE
                        TABLE</code></a>, <a class="link" href="sql-syntax.html#alter-table" title="13.1.8&nbsp;ALTER TABLE Syntax"><code class="literal">ALTER TABLE</code></a>,
                        and <a class="link" href="sql-syntax.html#create-index" title="13.1.14&nbsp;CREATE INDEX Syntax"><code class="literal">CREATE INDEX</code></a> statements
                        are interpreted as number of characters for nonbinary string
                        types (<a class="link" href="data-types.html#char" title="11.4.1&nbsp;The CHAR and VARCHAR Types"><code class="literal">CHAR</code></a>,
                        <a class="link" href="data-types.html#char" title="11.4.1&nbsp;The CHAR and VARCHAR Types"><code class="literal">VARCHAR</code></a>,
                        <a class="link" href="data-types.html#blob" title="11.4.3&nbsp;The BLOB and TEXT Types"><code class="literal">TEXT</code></a>) and number of bytes for
                        binary string types (<a class="link" href="data-types.html#binary-varbinary" title="11.4.2&nbsp;The BINARY and VARBINARY Types"><code class="literal">BINARY</code></a>,
                        <a class="link" href="data-types.html#binary-varbinary" title="11.4.2&nbsp;The BINARY and VARBINARY Types"><code class="literal">VARBINARY</code></a>,
                        <a class="link" href="data-types.html#blob" title="11.4.3&nbsp;The BLOB and TEXT Types"><code class="literal">BLOB</code></a>). Take this into account
                        when specifying a prefix length for a nonbinary string
                        column that uses a multibyte character set.
                    </p><p style="color:blue;">前缀限制以字节为单位。但是，CREATE TABLE、ALTER TABLE和CREATE INDEX语句中索引规范的前缀长度解释为非二进制字符串类型（char、varchar、text）的字符数和二进制字符串类型（binary、varbinary、blob）的字节数。在为使用多字节字符集的非二进制字符串列指定前缀长度时，请考虑此问题。</p><p>
                        Prefix support and lengths of prefixes (where supported) are
                        storage engine dependent. For example, a prefix can be up to
                        767 bytes long for <a class="link" href="innodb-storage-engine.html" title="Chapter&nbsp;14&nbsp;The InnoDB Storage Engine"><code class="literal">InnoDB</code></a>
                        tables or 3072 bytes if the
                        <a class="link" href="innodb-storage-engine.html#sysvar_innodb_large_prefix"><code class="literal">innodb_large_prefix</code></a> option
                        is enabled. For <a class="link" href="storage-engines.html#myisam-storage-engine" title="15.2&nbsp;The MyISAM Storage Engine"><code class="literal">MyISAM</code></a> tables,
                        the prefix length limit is 1000 bytes. The
                        <a class="link" href="mysql-cluster.html" title="Chapter&nbsp;21&nbsp;MySQL NDB Cluster 7.5 and NDB Cluster 7.6"><code class="literal">NDB</code></a> storage engine does not
                        support prefixes (see
                        <a class="xref" href="mysql-cluster.html#mysql-cluster-limitations-unsupported" title="21.1.7.6&nbsp;Unsupported or Missing Features in NDB Cluster">Section&nbsp;21.1.7.6, “Unsupported or Missing Features in NDB Cluster”</a>).
                    </p><p style="color:blue;">前缀支持和前缀长度（如果支持）取决于存储引擎。例如，对于innodb表，前缀可以长达767字节，如果启用innodb_large_prefix选项，则可以长达3072字节。对于myisam表，前缀长度限制为1000字节。ndb存储引擎不支持前缀（请参阅21.1.7.6节，“ndb集群中不支持或缺少的功能”）。</p></li></ul>
                </div>
                <p>
                    As of MySQL 5.7.17, if a specified index prefix exceeds the
                    maximum column data type size, <a class="link" href="sql-syntax.html#create-index" title="13.1.14&nbsp;CREATE INDEX Syntax"><code class="literal">CREATE
                    INDEX</code></a> handles the index as follows:
                </p><p style="color:blue;">对于MySQL 5.7.17，如果指定的索引前缀超过最大列数据类型大小，则CREATE索引将按如下方式处理索引：</p>
                <div class="itemizedlist">
                    <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                        For a nonunique index, either an error occurs (if strict SQL
                        mode is enabled), or the index length is reduced to lie
                        within the maximum column data type size and a warning is
                        produced (if strict SQL mode is not enabled).
                    </p><p style="color:blue;">对于非唯一索引，要么发生错误（如果启用了严格SQL模式），或者将索引长度减少到最大列数据类型大小内，并产生警告（如果未启用严格SQL模式）。</p></li><li class="listitem"><p>
                        For a unique index, an error occurs regardless of SQL mode
                        because reducing the index length might enable insertion of
                        nonunique entries that do not meet the specified uniqueness
                        requirement.
                    </p><p style="color:blue;">对于唯一索引，无论SQL模式如何，都会发生错误，因为减小索引长度可能会插入不符合指定唯一性要求的非唯一项。</p></li></ul>
                </div>
                <p>
                    The statement shown here creates an index using the first 10
                    characters of the <code class="literal">name</code> column (assuming that
                    <code class="literal">name</code> has a nonbinary string type):
                </p><p style="color:blue;">此处显示的语句使用名称列的前10个字符创建索引（假设名称具有非二进制字符串类型）：</p><pre data-lang="sql" class="programlisting">CREATE INDEX part_of_name ON customer (name(10));
</pre><p>
                If names in the column usually differ in the first 10
                characters, lookups performed using this index should not be
                much slower than using an index created from the entire
                <code class="literal">name</code> column. Also, using column prefixes for
                indexes can make the index file much smaller, which could save a
                lot of disk space and might also speed up
                <a class="link" href="sql-syntax.html#insert" title="13.2.5&nbsp;INSERT Syntax"><code class="literal">INSERT</code></a> operations.
            </p><p style="color:blue;">如果列中的名称在前10个字符中通常不同，则使用此索引执行的查找速度不应比使用从整个名称列创建的索引慢多少。此外，对索引使用列前缀可以使索引文件小得多，这可以节省大量磁盘空间，还可以加快插入操作。</p>
            </div>
            <div class="simplesect">
                <div class="titlepage">
                    <div>
                        <div class="simple">
                            <h4 class="title"><a name="create-index-unique"></a>Unique Indexes</h4>

                        </div>

                    </div>

                </div>
                <p>
                    A <code class="literal">UNIQUE</code> index creates a constraint such that
                    all values in the index must be distinct. An error occurs if you
                    try to add a new row with a key value that matches an existing
                    row. If you specify a prefix value for a column in a
                    <code class="literal">UNIQUE</code> index, the column values must be
                    unique within the prefix length. A <code class="literal">UNIQUE</code>
                    index permits multiple <code class="literal">NULL</code> values for
                    columns that can contain <code class="literal">NULL</code>.
                </p><p style="color:blue;">唯一索引创建一个约束，使得索引中的所有值都必须是不同的。如果尝试添加具有与现有行匹配的键值的新行，则会发生错误。如果在唯一索引中为列指定前缀值，则列值在前缀长度内必须是唯一的。唯一索引允许包含空值的列有多个空值。</p><a class="indexterm" name="idm140286840155200"></a><p>
                If a table has a <code class="literal">PRIMARY KEY</code> or
                <code class="literal">UNIQUE NOT NULL</code> index that consists of a
                single column that has an integer type, you can use
                <code class="literal">_rowid</code> to refer to the indexed column in
                <a class="link" href="sql-syntax.html#select" title="13.2.9&nbsp;SELECT Syntax"><code class="literal">SELECT</code></a> statements, as follows:
            </p><p style="color:blue;">如果表具有主键或唯一的非空索引（由具有整数类型的单个列组成），则可以使用rowid引用select语句中的索引列，如下所示：</p>
                <div class="itemizedlist">
                    <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                        <code class="literal">_rowid</code> refers to the <code class="literal">PRIMARY
                        KEY</code> column if there is a <code class="literal">PRIMARY
                        KEY</code> consisting of a single integer column. If
                        there is a <code class="literal">PRIMARY KEY</code> but it does not
                        consist of a single integer column,
                        <code class="literal">_rowid</code> cannot be used.
                    </p><p style="color:blue;">_如果存在由单个整数列组成的主键，则rowid引用主键列。如果存在主键，但它不包含单个整数列，则不能使用rowid。</p></li><li class="listitem"><p>
                        Otherwise, <code class="literal">_rowid</code> refers to the column in
                        the first <code class="literal">UNIQUE NOT NULL</code> index if that
                        index consists of a single integer column. If the first
                        <code class="literal">UNIQUE NOT NULL</code> index does not consist of
                        a single integer column, <code class="literal">_rowid</code> cannot be
                        used.
                    </p><p style="color:blue;">否则，如果第一个唯一的非空索引由一个整数列组成，则“rowid”引用该索引中的列。如果第一个唯一的非空索引不包含单个整数列，则不能使用rowid。</p></li></ul>
                </div>

            </div>
            <div class="simplesect">
                <div class="titlepage">
                    <div>
                        <div class="simple">
                            <h4 class="title"><a name="create-index-fulltext"></a>Full-Text Indexes</h4>

                        </div>

                    </div>

                </div>
                <p>
                    <code class="literal">FULLTEXT</code> indexes are supported only for
                    <a class="link" href="innodb-storage-engine.html" title="Chapter&nbsp;14&nbsp;The InnoDB Storage Engine"><code class="literal">InnoDB</code></a> and
                    <a class="link" href="storage-engines.html#myisam-storage-engine" title="15.2&nbsp;The MyISAM Storage Engine"><code class="literal">MyISAM</code></a> tables and can include only
                    <a class="link" href="data-types.html#char" title="11.4.1&nbsp;The CHAR and VARCHAR Types"><code class="literal">CHAR</code></a>,
                    <a class="link" href="data-types.html#char" title="11.4.1&nbsp;The CHAR and VARCHAR Types"><code class="literal">VARCHAR</code></a>, and
                    <a class="link" href="data-types.html#blob" title="11.4.3&nbsp;The BLOB and TEXT Types"><code class="literal">TEXT</code></a> columns. Indexing always
                    happens over the entire column; column prefix indexing is not
                    supported and any prefix length is ignored if specified. See
                    <a class="xref" href="functions.html#fulltext-search" title="12.9&nbsp;Full-Text Search Functions">Section&nbsp;12.9, “Full-Text Search Functions”</a>, for details of operation.
                </p><p style="color:blue;">全文索引只支持innodb和myisam表，并且只能包含char、varchar和text列。索引始终在整个列上发生；不支持列前缀索引，如果指定了任何前缀长度，则忽略。有关操作的详细信息，请参见第12.9节“全文搜索功能”。</p>
            </div>
            <div class="simplesect">
                <div class="titlepage">
                    <div>
                        <div class="simple">
                            <h4 class="title"><a name="create-index-spatial"></a>Spatial Indexes</h4>

                        </div>

                    </div>

                </div>
                <p>
                    The <a class="link" href="storage-engines.html#myisam-storage-engine" title="15.2&nbsp;The MyISAM Storage Engine"><code class="literal">MyISAM</code></a>,
                    <a class="link" href="innodb-storage-engine.html" title="Chapter&nbsp;14&nbsp;The InnoDB Storage Engine"><code class="literal">InnoDB</code></a>,
                    <a class="link" href="mysql-cluster.html" title="Chapter&nbsp;21&nbsp;MySQL NDB Cluster 7.5 and NDB Cluster 7.6"><code class="literal">NDB</code></a>, and
                    <a class="link" href="storage-engines.html#archive-storage-engine" title="15.5&nbsp;The ARCHIVE Storage Engine"><code class="literal">ARCHIVE</code></a> storage engines support
                    spatial columns such as <a class="link" href="data-types.html#spatial-type-overview" title="11.5.1&nbsp;Spatial Data Types"><code class="literal">POINT</code></a> and
                    <a class="link" href="data-types.html#spatial-type-overview" title="11.5.1&nbsp;Spatial Data Types"><code class="literal">GEOMETRY</code></a>.
                    (<a class="xref" href="data-types.html#spatial-types" title="11.5&nbsp;Spatial Data Types">Section&nbsp;11.5, “Spatial Data Types”</a>, describes the spatial data
                    types.) However, support for spatial column indexing varies
                    among engines. Spatial and nonspatial indexes on spatial columns
                    are available according to the following rules.
                </p><p style="color:blue;">myisam、innodb、ndb和归档存储引擎支持点和几何等空间列。（11.5）“空间数据类型”描述了空间数据类型。然而，对于空间列索引的支持在引擎之间是不同的。空间列上的空间索引和非空间索引根据以下规则可用。</p><p>
                Spatial indexes on spatial columns (created using
                <code class="literal">SPATIAL INDEX</code>) have these characteristics:
            </p><p style="color:blue;">空间列上的空间索引（使用空间索引创建）具有以下特征：</p>
                <div class="itemizedlist">
                    <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                        Available only for <a class="link" href="storage-engines.html#myisam-storage-engine" title="15.2&nbsp;The MyISAM Storage Engine"><code class="literal">MyISAM</code></a> and
                        <a class="link" href="innodb-storage-engine.html" title="Chapter&nbsp;14&nbsp;The InnoDB Storage Engine"><code class="literal">InnoDB</code></a> tables. Specifying
                        <code class="literal">SPATIAL INDEX</code> for other storage engines
                        results in an error.
                    </p><p style="color:blue;">仅适用于myisam和innodb表。为其他存储引擎指定空间索引会导致错误。</p></li><li class="listitem"><p>
                        Indexed columns must be <code class="literal">NOT NULL</code>.
                    </p><p style="color:blue;">索引列不能为空。</p></li><li class="listitem"><p>
                        Column prefix lengths are prohibited. The full width of each
                        column is indexed.
                    </p><p style="color:blue;">列前缀长度是禁止的。每列的全宽都被索引。</p></li></ul>
                </div>
                <p>
                    Nonspatial indexes on spatial columns (created with
                    <code class="literal">INDEX</code>, <code class="literal">UNIQUE</code>, or
                    <code class="literal">PRIMARY KEY</code>) have these characteristics:
                </p><p style="color:blue;">空间列上的非空间索引（使用index、unique或primary key创建）具有以下特征：</p>
                <div class="itemizedlist">
                    <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                        Permitted for any storage engine that supports spatial
                        columns except <a class="link" href="storage-engines.html#archive-storage-engine" title="15.5&nbsp;The ARCHIVE Storage Engine"><code class="literal">ARCHIVE</code></a>.
                    </p><p style="color:blue;">允许用于支持除存档以外的空间列的任何存储引擎。</p></li><li class="listitem"><p>
                        Columns can be <code class="literal">NULL</code> unless the index is a
                        primary key.
                    </p><p style="color:blue;">除非索引是主键，否则列可以为空。</p></li><li class="listitem"><p>
                        For each spatial column in a non-<code class="literal">SPATIAL</code>
                        index except <a class="link" href="data-types.html#spatial-type-overview" title="11.5.1&nbsp;Spatial Data Types"><code class="literal">POINT</code></a> columns, a
                        column prefix length must be specified. (This is the same
                        requirement as for indexed
                        <a class="link" href="data-types.html#blob" title="11.4.3&nbsp;The BLOB and TEXT Types"><code class="literal">BLOB</code></a> columns.) The prefix
                        length is given in bytes.
                    </p><p style="color:blue;">对于非空间索引（点列除外）中的每个空间列，必须指定列前缀长度。（这与索引blob列的要求相同。）前缀长度以字节为单位。</p></li><li class="listitem"><p>
                        The index type for a non-<code class="literal">SPATIAL</code> index
                        depends on the storage engine. Currently, B-tree is used.
                    </p><p style="color:blue;">非空间索引的索引类型取决于存储引擎。目前使用的是b树。</p></li><li class="listitem"><p>
                        Permitted for a column that can have <code class="literal">NULL</code>
                        values only for <a class="link" href="innodb-storage-engine.html" title="Chapter&nbsp;14&nbsp;The InnoDB Storage Engine"><code class="literal">InnoDB</code></a>,
                        <a class="link" href="storage-engines.html#myisam-storage-engine" title="15.2&nbsp;The MyISAM Storage Engine"><code class="literal">MyISAM</code></a>, and
                        <a class="link" href="storage-engines.html#memory-storage-engine" title="15.3&nbsp;The MEMORY Storage Engine"><code class="literal">MEMORY</code></a> tables.
                    </p><p style="color:blue;">允许用于仅对innodb、myisam和内存表具有空值的列。</p></li></ul>
                </div>

            </div>
            <div class="simplesect">
                <div class="titlepage">
                    <div>
                        <div class="simple">
                            <h4 class="title"><a name="create-index-options"></a>Index Options</h4>

                        </div>

                    </div>

                </div>
                <p>
                    Following the key part list, index options can be given. An
                    <em class="replaceable"><code>index_option</code></em> value can be any of the
                    following:
                </p><p style="color:blue;">在关键部件列表之后，可以给出索引选项。索引选项值可以是以下任意值：</p>
                <div class="itemizedlist">
                    <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                        <code class="literal">KEY_BLOCK_SIZE [=]
                            <em class="replaceable"><code>value</code></em></code>
                    </p><p style="color:blue;">键块大小[=]值</p><p>
                        For <a class="link" href="storage-engines.html#myisam-storage-engine" title="15.2&nbsp;The MyISAM Storage Engine"><code class="literal">MyISAM</code></a> tables,
                        <code class="literal">KEY_BLOCK_SIZE</code> optionally specifies the
                        size in bytes to use for index key blocks. The value is
                        treated as a hint; a different size could be used if
                        necessary. A <code class="literal">KEY_BLOCK_SIZE</code> value
                        specified for an individual index definition overrides a
                        table-level <code class="literal">KEY_BLOCK_SIZE</code> value.
                    </p><p style="color:blue;">对于myisam表，key-block-size可以选择指定索引键块所用的字节大小。该值被视为提示；如果需要，可以使用不同的大小。为单个索引定义指定的键块大小值将替代表级键块大小值。</p><p>
                        <code class="literal">KEY_BLOCK_SIZE</code> is not supported at the
                        index level for <a class="link" href="innodb-storage-engine.html" title="Chapter&nbsp;14&nbsp;The InnoDB Storage Engine"><code class="literal">InnoDB</code></a> tables.
                        See <a class="xref" href="sql-syntax.html#create-table" title="13.1.18&nbsp;CREATE TABLE Syntax">Section&nbsp;13.1.18, “CREATE TABLE Syntax”</a>.
                    </p><p style="color:blue;">innodb表的索引级别不支持key_block_size。参见第13.1.18节“创建表语法”。</p></li><li class="listitem"><p>
                        <em class="replaceable"><code>index_type</code></em>
                    </p><p style="color:blue;">索引类型</p><p>
                        Some storage engines permit you to specify an index type
                        when creating an index. For example:
                    </p><p style="color:blue;">某些存储引擎允许您在创建索引时指定索引类型。例如：</p><pre data-lang="sql" class="programlisting">CREATE TABLE lookup (id INT) ENGINE = MEMORY;
CREATE INDEX id_index ON lookup (id) USING BTREE;
</pre><p>
                        <a class="xref" href="sql-syntax.html#create-index-storage-engine-index-types" title="Table&nbsp;13.1&nbsp;Index Types Per Storage Engine">Table&nbsp;13.1, “Index Types Per Storage Engine”</a>
                        shows the permissible index type values supported by
                        different storage engines. Where multiple index types are
                        listed, the first one is the default when no index type
                        specifier is given. Storage engines not listed in the table
                        do not support an <em class="replaceable"><code>index_type</code></em>
                        clause in index definitions.
                    </p><p style="color:blue;">表13.1“每个存储引擎的索引类型”显示了不同存储引擎支持的允许索引类型值。如果列出了多个索引类型，则在没有给定索引类型说明符时，第一个是默认的。表中未列出的存储引擎不支持索引定义中的index_type子句。</p>
                        <div class="table">
                            <a name="create-index-storage-engine-index-types"></a><p class="title"><b>Table&nbsp;13.1&nbsp;Index Types Per Storage Engine</b></p><p style="color:blue;">表13.1每个存储引擎的索引类型</p>
                            <div class="table-contents">
                                <table summary="Permissible index types by storage engine."><colgroup><col width="20%"><col width="50%"></colgroup><thead><tr>
                                    <th scope="col">Storage Engine</th>
                                    <th scope="col">Permissible Index Types</th>
                                </tr></thead><tbody><tr>
                                    <td scope="row"><a class="link" href="innodb-storage-engine.html" title="Chapter&nbsp;14&nbsp;The InnoDB Storage Engine"><code class="literal">InnoDB</code></a></td>
                                    <td><code class="literal">BTREE</code></td>
                                </tr><tr>
                                    <td scope="row"><a class="link" href="storage-engines.html#myisam-storage-engine" title="15.2&nbsp;The MyISAM Storage Engine"><code class="literal">MyISAM</code></a></td>
                                    <td><code class="literal">BTREE</code></td>
                                </tr><tr>
                                    <td scope="row"><a class="link" href="storage-engines.html#memory-storage-engine" title="15.3&nbsp;The MEMORY Storage Engine"><code class="literal">MEMORY</code></a>/<code class="literal">HEAP</code></td>
                                    <td><code class="literal">HASH</code>, <code class="literal">BTREE</code></td>
                                </tr><tr>
                                    <td scope="row"><a class="link" href="mysql-cluster.html" title="Chapter&nbsp;21&nbsp;MySQL NDB Cluster 7.5 and NDB Cluster 7.6"><code class="literal">NDB</code></a></td>
                                    <td><code class="literal">HASH</code>, <code class="literal">BTREE</code> (see note in text)</td>
                                </tr></tbody></table>
                            </div>

                        </div>
                        <br class="table-break"><p>
                            The <em class="replaceable"><code>index_type</code></em> clause cannot be
                            used for <code class="literal">FULLTEXT INDEX</code> or
                            <code class="literal">SPATIAL INDEX</code> specifications. Full-text
                            index implementation is storage engine dependent. Spatial
                            indexes are implemented as R-tree indexes.
                        </p><p style="color:blue;">index_type子句不能用于全文索引或空间索引规范。全文索引的实现依赖于存储引擎。空间索引被实现为r树索引。</p><p>
                            <code class="literal">BTREE</code> indexes are implemented by the
                            <a class="link" href="mysql-cluster.html" title="Chapter&nbsp;21&nbsp;MySQL NDB Cluster 7.5 and NDB Cluster 7.6"><code class="literal">NDB</code></a> storage engine as T-tree
                            indexes.
                        </p><p style="color:blue;">btree索引由ndb存储引擎实现为t树索引。</p><a class="indexterm" name="idm140286840051328"></a><a class="indexterm" name="idm140286840049840"></a>
                        <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">

                            <div class="admon-title">
                                Note
                            </div>
                            <p>
                                For indexes on <a class="link" href="mysql-cluster.html" title="Chapter&nbsp;21&nbsp;MySQL NDB Cluster 7.5 and NDB Cluster 7.6"><code class="literal">NDB</code></a> table
                                columns, the <code class="literal">USING</code> option can be
                                specified only for a unique index or primary key.
                                <code class="literal">USING HASH</code> prevents the creation of an
                                ordered index; otherwise, creating a unique index or
                                primary key on an <a class="link" href="mysql-cluster.html" title="Chapter&nbsp;21&nbsp;MySQL NDB Cluster 7.5 and NDB Cluster 7.6"><code class="literal">NDB</code></a> table
                                automatically results in the creation of both an ordered
                                index and a hash index, each of which indexes the same set
                                of columns.
                            </p><p style="color:blue;">对于ndb表列上的索引，只能为唯一索引或主键指定using选项。使用hash可防止创建有序索引；否则，在ndb表上创建唯一索引或主键将自动导致创建有序索引和散列索引，每个索引对同一组列进行索引。</p><p>
                            For unique indexes that include one or more
                            <code class="literal">NULL</code> columns of an
                            <a class="link" href="mysql-cluster.html" title="Chapter&nbsp;21&nbsp;MySQL NDB Cluster 7.5 and NDB Cluster 7.6"><code class="literal">NDB</code></a> table, the hash index can
                            be used only to look up literal values, which means that
                            <code class="literal">IS [NOT] NULL</code> conditions require a full
                            scan of the table. One workaround is to make sure that a
                            unique index using one or more <code class="literal">NULL</code>
                            columns on such a table is always created in such a way
                            that it includes the ordered index; that is, avoid
                            employing <code class="literal">USING HASH</code> when creating the
                            index.
                        </p><p style="color:blue;">对于包含ndb表的一个或多个空列的唯一索引，hash索引只能用于查找文本值，这意味着is not空条件需要对表进行完全扫描。一种解决方法是确保在这样一个表上使用一个或多个空列的唯一索引的创建方式始终使其包含有序索引；也就是说，在创建索引时避免使用哈希。</p>
                        </div>
                        <p>
                            If you specify an index type that is not valid for a given
                            storage engine, but another index type is available that the
                            engine can use without affecting query results, the engine
                            uses the available type. The parser recognizes
                            <code class="literal">RTREE</code> as a type name, but currently this
                            cannot be specified for any storage engine.
                        </p><p style="color:blue;">如果指定的索引类型对给定的存储引擎无效，但该引擎可以使用另一个索引类型而不影响查询结果，则该引擎将使用该可用类型。解析器将rtree识别为类型名，但目前无法为任何存储引擎指定此名称。</p>
                        <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">

                            <div class="admon-title">
                                Note
                            </div>
                            <p>
                                Use of the <em class="replaceable"><code>index_type</code></em> option
                                before the <code class="literal">ON
                                <em class="replaceable"><code>tbl_name</code></em></code> clause is
                                deprecated; support for use of the option in this position
                                will be removed in a future MySQL release. If an
                                <em class="replaceable"><code>index_type</code></em> option is given in
                                both the earlier and later positions, the final option
                                applies.
                            </p><p style="color:blue;">不赞成在on tbl_name子句之前使用index_type选项；在以后的mysql版本中将不再支持在此位置使用该选项。如果在前面和后面的位置都给出了索引类型选项，则应用最终选项。</p>
                        </div>
                        <p>
                            <code class="literal">TYPE <em class="replaceable"><code>type_name</code></em></code>
                            is recognized as a synonym for <code class="literal">USING
                            <em class="replaceable"><code>type_name</code></em></code>. However,
                            <code class="literal">USING</code> is the preferred form.
                        </p><p style="color:blue;">类型type_name被识别为使用类型_name的同义词。但是，使用是首选形式。</p><p>
                            The following tables show index characteristics for the
                            storage engines that support the
                            <em class="replaceable"><code>index_type</code></em> option.
                        </p><p style="color:blue;">下表显示了支持“索引类型”选项的存储引擎的索引特征。</p>
                        <div class="table">
                            <a name="innodb-storage-engine-index-characteristics"></a><p class="title"><b>Table&nbsp;13.2&nbsp;InnoDB Storage Engine Index Characteristics</b></p><p style="color:blue;">表13.2 InnoDB存储引擎索引特征</p>
                            <div class="table-contents">
                                <table summary="Index characteristics of the InnoDB storage engine."><colgroup><col width="15%"><col width="10%"><col width="15%"><col width="20%"><col width="20%"><col width="20%"></colgroup><thead><tr>
                                    <th scope="col">Index Class</th>
                                    <th scope="col">Index Type</th>
                                    <th scope="col">Stores NULL VALUES</th>
                                    <th scope="col">Permits Multiple NULL Values</th>
                                    <th scope="col">IS NULL Scan Type</th>
                                    <th scope="col">IS NOT NULL Scan Type</th>
                                </tr></thead><tbody><tr>
                                    <td scope="row">Primary key</td>
                                    <td><code class="literal">BTREE</code></td>
                                    <td>No</td>
                                    <td>No</td>
                                    <td>N/A</td>
                                    <td>N/A</td>
                                </tr><tr>
                                    <td scope="row">Unique</td>
                                    <td><code class="literal">BTREE</code></td>
                                    <td>Yes</td>
                                    <td>Yes</td>
                                    <td>Index</td>
                                    <td>Index</td>
                                </tr><tr>
                                    <td scope="row">Key</td>
                                    <td><code class="literal">BTREE</code></td>
                                    <td>Yes</td>
                                    <td>Yes</td>
                                    <td>Index</td>
                                    <td>Index</td>
                                </tr><tr>
                                    <td scope="row"><code class="literal">FULLTEXT</code></td>
                                    <td>N/A</td>
                                    <td>Yes</td>
                                    <td>Yes</td>
                                    <td>Table</td>
                                    <td>Table</td>
                                </tr><tr>
                                    <td scope="row"><code class="literal">SPATIAL</code></td>
                                    <td>N/A</td>
                                    <td>No</td>
                                    <td>No</td>
                                    <td>N/A</td>
                                    <td>N/A</td>
                                </tr></tbody></table>
                            </div>

                        </div>
                        <br class="table-break">
                        <div class="table">
                            <a name="myisam-storage-engine-index-characteristics"></a><p class="title"><b>Table&nbsp;13.3&nbsp;MyISAM Storage Engine Index Characteristics</b></p><p style="color:blue;">表13.3 MyISAM存储引擎索引特征</p>
                            <div class="table-contents">
                                <table summary="Index characteristics of the MyISAM storage engine."><colgroup><col width="15%"><col width="10%"><col width="15%"><col width="20%"><col width="20%"><col width="20%"></colgroup><thead><tr>
                                    <th scope="col">Index Class</th>
                                    <th scope="col">Index Type</th>
                                    <th scope="col">Stores NULL VALUES</th>
                                    <th scope="col">Permits Multiple NULL Values</th>
                                    <th scope="col">IS NULL Scan Type</th>
                                    <th scope="col">IS NOT NULL Scan Type</th>
                                </tr></thead><tbody><tr>
                                    <td scope="row">Primary key</td>
                                    <td><code class="literal">BTREE</code></td>
                                    <td>No</td>
                                    <td>No</td>
                                    <td>N/A</td>
                                    <td>N/A</td>
                                </tr><tr>
                                    <td scope="row">Unique</td>
                                    <td><code class="literal">BTREE</code></td>
                                    <td>Yes</td>
                                    <td>Yes</td>
                                    <td>Index</td>
                                    <td>Index</td>
                                </tr><tr>
                                    <td scope="row">Key</td>
                                    <td><code class="literal">BTREE</code></td>
                                    <td>Yes</td>
                                    <td>Yes</td>
                                    <td>Index</td>
                                    <td>Index</td>
                                </tr><tr>
                                    <td scope="row"><code class="literal">FULLTEXT</code></td>
                                    <td>N/A</td>
                                    <td>Yes</td>
                                    <td>Yes</td>
                                    <td>Table</td>
                                    <td>Table</td>
                                </tr><tr>
                                    <td scope="row"><code class="literal">SPATIAL</code></td>
                                    <td>N/A</td>
                                    <td>No</td>
                                    <td>No</td>
                                    <td>N/A</td>
                                    <td>N/A</td>
                                </tr></tbody></table>
                            </div>

                        </div>
                        <br class="table-break">
                        <div class="table">
                            <a name="memory-storage-engine-index-characteristics"></a><p class="title"><b>Table&nbsp;13.4&nbsp;MEMORY Storage Engine Index Characteristics</b></p><p style="color:blue;">表13.4内存存储引擎索引特征</p>
                            <div class="table-contents">
                                <table summary="Index characteristics of the Memory storage engine."><colgroup><col width="15%"><col width="10%"><col width="15%"><col width="20%"><col width="20%"><col width="20%"></colgroup><thead><tr>
                                    <th scope="col">Index Class</th>
                                    <th scope="col">Index Type</th>
                                    <th scope="col">Stores NULL VALUES</th>
                                    <th scope="col">Permits Multiple NULL Values</th>
                                    <th scope="col">IS NULL Scan Type</th>
                                    <th scope="col">IS NOT NULL Scan Type</th>
                                </tr></thead><tbody><tr>
                                    <td scope="row">Primary key</td>
                                    <td><code class="literal">BTREE</code></td>
                                    <td>No</td>
                                    <td>No</td>
                                    <td>N/A</td>
                                    <td>N/A</td>
                                </tr><tr>
                                    <td scope="row">Unique</td>
                                    <td><code class="literal">BTREE</code></td>
                                    <td>Yes</td>
                                    <td>Yes</td>
                                    <td>Index</td>
                                    <td>Index</td>
                                </tr><tr>
                                    <td scope="row">Key</td>
                                    <td><code class="literal">BTREE</code></td>
                                    <td>Yes</td>
                                    <td>Yes</td>
                                    <td>Index</td>
                                    <td>Index</td>
                                </tr><tr>
                                    <td scope="row">Primary key</td>
                                    <td><code class="literal">HASH</code></td>
                                    <td>No</td>
                                    <td>No</td>
                                    <td>N/A</td>
                                    <td>N/A</td>
                                </tr><tr>
                                    <td scope="row">Unique</td>
                                    <td><code class="literal">HASH</code></td>
                                    <td>Yes</td>
                                    <td>Yes</td>
                                    <td>Index</td>
                                    <td>Index</td>
                                </tr><tr>
                                    <td scope="row">Key</td>
                                    <td><code class="literal">HASH</code></td>
                                    <td>Yes</td>
                                    <td>Yes</td>
                                    <td>Index</td>
                                    <td>Index</td>
                                </tr></tbody></table>
                            </div>

                        </div>
                        <br class="table-break">
                        <div class="table">
                            <a name="ndb-storage-engine-index-characteristics"></a><p class="title"><b>Table&nbsp;13.5&nbsp;NDB Storage Engine Index Characteristics</b></p><p style="color:blue;">表13.5 ndb存储引擎索引特征</p>
                            <div class="table-contents">
                                <table summary="Index characteristics of the NDB storage engine."><colgroup><col width="15%"><col width="10%"><col width="15%"><col width="20%"><col width="20%"><col width="20%"></colgroup><thead><tr>
                                    <th scope="col">Index Class</th>
                                    <th scope="col">Index Type</th>
                                    <th scope="col">Stores NULL VALUES</th>
                                    <th scope="col">Permits Multiple NULL Values</th>
                                    <th scope="col">IS NULL Scan Type</th>
                                    <th scope="col">IS NOT NULL Scan Type</th>
                                </tr></thead><tbody><tr>
                                    <td scope="row">Primary key</td>
                                    <td><code class="literal">BTREE</code></td>
                                    <td>No</td>
                                    <td>No</td>
                                    <td>Index</td>
                                    <td>Index</td>
                                </tr><tr>
                                    <td scope="row">Unique</td>
                                    <td><code class="literal">BTREE</code></td>
                                    <td>Yes</td>
                                    <td>Yes</td>
                                    <td>Index</td>
                                    <td>Index</td>
                                </tr><tr>
                                    <td scope="row">Key</td>
                                    <td><code class="literal">BTREE</code></td>
                                    <td>Yes</td>
                                    <td>Yes</td>
                                    <td>Index</td>
                                    <td>Index</td>
                                </tr><tr>
                                    <td scope="row">Primary key</td>
                                    <td><code class="literal">HASH</code></td>
                                    <td>No</td>
                                    <td>No</td>
                                    <td>Table (see note 1)</td>
                                    <td>Table (see note 1)</td>
                                </tr><tr>
                                    <td scope="row">Unique</td>
                                    <td><code class="literal">HASH</code></td>
                                    <td>Yes</td>
                                    <td>Yes</td>
                                    <td>Table (see note 1)</td>
                                    <td>Table (see note 1)</td>
                                </tr><tr>
                                    <td scope="row">Key</td>
                                    <td><code class="literal">HASH</code></td>
                                    <td>Yes</td>
                                    <td>Yes</td>
                                    <td>Table (see note 1)</td>
                                    <td>Table (see note 1)</td>
                                </tr></tbody></table>
                            </div>

                        </div>
                        <br class="table-break"><p>
                            Table note:
                        </p><p style="color:blue;">表注：</p><p>
                            1. If <code class="literal">USING HASH</code> is specified that
                            prevents creation of an implicit ordered index.
                        </p><p style="color:blue;">一。如果指定使用哈希以防止创建隐式有序索引。</p></li><li class="listitem"><p>
                        <code class="literal">WITH PARSER
                            <em class="replaceable"><code>parser_name</code></em></code>
                    </p><p style="color:blue;">带解析器的名称</p><p>
                        This option can be used only with
                        <code class="literal">FULLTEXT</code> indexes. It associates a parser
                        plugin with the index if full-text indexing and searching
                        operations need special handling.
                        <a class="link" href="innodb-storage-engine.html" title="Chapter&nbsp;14&nbsp;The InnoDB Storage Engine"><code class="literal">InnoDB</code></a> and
                        <a class="link" href="storage-engines.html#myisam-storage-engine" title="15.2&nbsp;The MyISAM Storage Engine"><code class="literal">MyISAM</code></a> support full-text parser
                        plugins. See <a class="xref" href="extending-mysql.html#full-text-plugin-type" title="Full-Text Parser Plugins">Full-Text Parser Plugins</a> and
                        <a class="xref" href="extending-mysql.html#writing-full-text-plugins" title="28.2.4.4&nbsp;Writing Full-Text Parser Plugins">Section&nbsp;28.2.4.4, “Writing Full-Text Parser Plugins”</a> for more
                        information.
                    </p><p style="color:blue;">此选项只能用于全文索引。如果全文索引和搜索操作需要特殊处理，则它将解析器插件与索引关联起来。InnoDB和MyISAM支持全文解析器插件。有关详细信息，请参阅全文解析器插件和第28.2.4.4节“编写全文解析器插件”。</p></li><li class="listitem"><p>
                        <code class="literal">COMMENT
                            '<em class="replaceable"><code>string</code></em>'</code>
                    </p><p style="color:blue;">注释“string”</p><p>
                        Index definitions can include an optional comment of up to
                        1024 characters.
                    </p><p style="color:blue;">索引定义可以包含最多1024个字符的可选注释。</p><p>
                        The
                        <a class="link" href="innodb-storage-engine.html#index-page-merge-threshold" title="14.8.12&nbsp;Configuring the Merge Threshold for Index Pages"><code class="literal">MERGE_THRESHOLD</code></a>
                        for index pages can be configured for individual indexes
                        using the <em class="replaceable"><code>index_option</code></em>
                        <code class="literal">COMMENT</code> clause of the
                        <a class="link" href="sql-syntax.html#create-index" title="13.1.14&nbsp;CREATE INDEX Syntax"><code class="literal">CREATE INDEX</code></a> statement. For
                        example:
                    </p><p style="color:blue;">可以使用create index语句的index_option comment子句为单个索引配置索引页的merge_阈值。例如：</p><pre data-lang="sql" class="programlisting">CREATE TABLE t1 (id INT);
CREATE INDEX id_index ON t1 (id) COMMENT 'MERGE_THRESHOLD=40';</pre><p>
                        If the page-full percentage for an index page falls below
                        the <code class="literal">MERGE_THRESHOLD</code> value when a row is
                        deleted or when a row is shortened by an update operation,
                        <a class="link" href="innodb-storage-engine.html" title="Chapter&nbsp;14&nbsp;The InnoDB Storage Engine"><code class="literal">InnoDB</code></a> attempts to merge the
                        index page with a neighboring index page. The default
                        <code class="literal">MERGE_THRESHOLD</code> value is 50, which is the
                        previously hardcoded value.
                    </p><p style="color:blue;">如果删除行或更新操作缩短行时，索引页的页面完整百分比低于合并阈值，InnoDB将尝试将索引页与相邻索引页合并。默认的合并阈值是50，这是以前硬编码的值。</p><p>
                        <code class="literal">MERGE_THRESHOLD</code> can also be defined at
                        the index level and table level using
                        <a class="link" href="sql-syntax.html#create-table" title="13.1.18&nbsp;CREATE TABLE Syntax"><code class="literal">CREATE TABLE</code></a> and
                        <a class="link" href="sql-syntax.html#alter-table" title="13.1.8&nbsp;ALTER TABLE Syntax"><code class="literal">ALTER TABLE</code></a> statements. For
                        more information, see
                        <a class="xref" href="innodb-storage-engine.html#index-page-merge-threshold" title="14.8.12&nbsp;Configuring the Merge Threshold for Index Pages">Section&nbsp;14.8.12, “Configuring the Merge Threshold for Index Pages”</a>.
                    </p><p style="color:blue;">还可以使用create table和alter table语句在索引级别和表级别定义merge_threshold。有关更多信息，请参阅14.8.12节，“为索引页配置合并阈值”。</p></li></ul>
                </div>

            </div>
            <div class="simplesect">
                <div class="titlepage">
                    <div>
                        <div class="simple">
                            <h4 class="title"><a name="create-index-copying"></a>Table Copying and Locking Options</h4>

                        </div>

                    </div>

                </div>
                <p>
                    <code class="literal">ALGORITHM</code> and <code class="literal">LOCK</code> clauses
                    may be given to influence the table copying method and level of
                    concurrency for reading and writing the table while its indexes
                    are being modified. They have the same meaning as for the
                    <a class="link" href="sql-syntax.html#alter-table" title="13.1.8&nbsp;ALTER TABLE Syntax"><code class="literal">ALTER TABLE</code></a> statement. For more
                    information, see <a class="xref" href="sql-syntax.html#alter-table" title="13.1.8&nbsp;ALTER TABLE Syntax">Section&nbsp;13.1.8, “ALTER TABLE Syntax”</a>
                </p><p style="color:blue;">在修改表的索引时，可以使用算法和锁子句来影响表的复制方法和读写并发级别。它们的含义与alter table语句相同。有关详细信息，请参见第13.1.8节“更改表语法”</p><p>
                NDB Cluster formerly supported online <code class="literal">CREATE
                INDEX</code> operations using an alternative syntax that is
                no longer supported. NDB Cluster now supports online operations
                using the same <code class="literal">ALGORITHM=INPLACE</code> syntax used
                with the standard MySQL Server. See
                <a class="xref" href="mysql-cluster.html#mysql-cluster-online-operations" title="21.5.14&nbsp;Online Operations with ALTER TABLE in NDB Cluster">Section&nbsp;21.5.14, “Online Operations with ALTER TABLE in NDB Cluster”</a>, for more
                information.
            </p><p style="color:blue;">ndb cluster以前支持使用不再支持的替代语法的联机创建索引操作。ndb cluster现在支持在线操作，使用与标准mysql服务器相同的algorithm=inplace语法。有关更多信息，请参阅21.5.14节，“使用ndb集群中的alter table进行联机操作”。</p>
            </div>

        </div>
        <div class="section">
            <div class="titlepage">
                <div>
                    <div>
                        <h3 class="title"><a name="create-logfile-group"></a>13.1.15&nbsp;CREATE LOGFILE GROUP Syntax</h3>

                    </div>

                </div>

            </div>
            <a class="indexterm" name="idm140286839800128"></a><pre data-lang="sql" class="programlisting">CREATE LOGFILE GROUP <em class="replaceable"><code>logfile_group</code></em>
    ADD UNDOFILE '<em class="replaceable"><code>undo_file</code></em>'
    [INITIAL_SIZE [=] <em class="replaceable"><code>initial_size</code></em>]
    [UNDO_BUFFER_SIZE [=] <em class="replaceable"><code>undo_buffer_size</code></em>]
    [REDO_BUFFER_SIZE [=] <em class="replaceable"><code>redo_buffer_size</code></em>]
    [NODEGROUP [=] <em class="replaceable"><code>nodegroup_id</code></em>]
    [WAIT]
    [COMMENT [=] '<em class="replaceable"><code>string</code></em>']
    ENGINE [=] <em class="replaceable"><code>engine_name</code></em>
</pre><p>
            This statement creates a new log file group named
            <em class="replaceable"><code>logfile_group</code></em> having a single
            <code class="literal">UNDO</code> file named
            '<em class="replaceable"><code>undo_file</code></em>'. A
            <a class="link" href="sql-syntax.html#create-logfile-group" title="13.1.15&nbsp;CREATE LOGFILE GROUP Syntax"><code class="literal">CREATE LOGFILE GROUP</code></a> statement has
            one and only one <code class="literal">ADD UNDOFILE</code> clause. For rules
            covering the naming of log file groups, see
            <a class="xref" href="language-structure.html#identifiers" title="9.2&nbsp;Schema Object Names">Section&nbsp;9.2, “Schema Object Names”</a>.
        </p><p style="color:blue;">此语句创建一个名为log file_group的新日志文件组，其中有一个名为“undo_file”的撤消文件。CREATELOGFILEGROUP语句只有一个ADD UNDOFILE子句。有关日志文件组命名的规则，请参阅第9.2节“架构对象名称”。</p>
            <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">

                <div class="admon-title">
                    Note
                </div>
                <p>
                    All NDB Cluster Disk Data objects share the same namespace. This
                    means that <span class="emphasis"><em>each Disk Data object</em></span> must be
                    uniquely named (and not merely each Disk Data object of a given
                    type). For example, you cannot have a tablespace and a log file
                    group with the same name, or a tablespace and a data file with
                    the same name.
                </p><p style="color:blue;">所有ndb群集磁盘数据对象共享同一命名空间。这意味着每个磁盘数据对象必须有唯一的名称（而不仅仅是给定类型的每个磁盘数据对象）。例如，不能有同名的表空间和日志文件组，也不能有同名的表空间和数据文件。</p>
            </div>
            <p>
                There can be only one log file group per NDB Cluster instance at
                any given time.
            </p><p style="color:blue;">在任何给定时间，每个ndb群集实例只能有一个日志文件组。</p><p>
            The optional <code class="literal">INITIAL_SIZE</code> parameter sets the
            <code class="literal">UNDO</code> file's initial size; if not specified, it
            defaults to <code class="literal">128M</code> (128 megabytes). The optional
            <code class="literal">UNDO_BUFFER_SIZE</code> parameter sets the size used
            by the <code class="literal">UNDO</code> buffer for the log file group; The
            default value for <code class="literal">UNDO_BUFFER_SIZE</code> is
            <code class="literal">8M</code> (eight megabytes); this value cannot exceed
            the amount of system memory available. Both of these parameters
            are specified in bytes. You may optionally follow either or both
            of these with a one-letter abbreviation for an order of magnitude,
            similar to those used in <code class="filename">my.cnf</code>. Generally,
            this is&nbsp;one of the letters <code class="literal">M</code> (for megabytes)
            or <code class="literal">G</code> (for gigabytes).
        </p><p style="color:blue;">可选的initial_size参数设置撤消文件的初始大小；如果未指定，则默认为128m（128兆字节）。可选的undo_buffer_size参数设置日志文件组的undo缓冲区使用的大小；undo_buffer_size的默认值为8M（8M字节）；此值不能超过可用的系统内存量。这两个参数都是以字节为单位指定的。您可以选择在其中一个或两个后面加上一个字母的数量级缩写，类似于my.cnf中使用的缩写。一般来说，这是m（兆字节）或g（千兆字节）中的一个字母。</p><p>
            Memory used for <code class="literal">UNDO_BUFFER_SIZE</code> comes from the
            global pool whose size is determined by the value of the
            <a class="link" href="mysql-cluster.html#ndbparam-ndbd-sharedglobalmemory"><code class="literal">SharedGlobalMemory</code></a> data
            node configuration parameter. This includes any default value
            implied for this option by the setting of the
            <a class="link" href="mysql-cluster.html#ndbparam-ndbd-initiallogfilegroup"><code class="literal">InitialLogFileGroup</code></a> data
            node configuration parameter.
        </p><p style="color:blue;">用于撤消缓冲区大小的内存来自全局池，其大小由sharedglobalmemory数据节点配置参数的值决定。这包括通过设置initiallogfilegroup数据节点配置参数为该选项隐含的任何默认值。</p><p>
            The maximum permitted for <code class="literal">UNDO_BUFFER_SIZE</code> is
            629145600 (600 MB).
        </p><p style="color:blue;">UNdoxBuffelyStand的最大允许值为629145600（600 MB）。</p><p>
            On 32-bit systems, the maximum supported value for
            <code class="literal">INITIAL_SIZE</code> is 4294967296 (4 GB). (Bug #29186)
        </p><p style="color:blue;">在32位系统上，初始值的最大支持值为4294967296（4 GB）。（错误29186）</p><p>
            The minimum allowed value for <code class="literal">INITIAL_SIZE</code> is
            1048576 (1 MB).
        </p><p style="color:blue;">初始大小的最小允许值为1048576（1 MB）。</p><p>
            The <code class="literal">ENGINE</code> option determines the storage engine
            to be used by this log file group, with
            <em class="replaceable"><code>engine_name</code></em> being the name of the
            storage engine. In MySQL 5.7, this must be
            <a class="link" href="mysql-cluster.html" title="Chapter&nbsp;21&nbsp;MySQL NDB Cluster 7.5 and NDB Cluster 7.6"><code class="literal">NDB</code></a> (or
            <a class="link" href="mysql-cluster.html" title="Chapter&nbsp;21&nbsp;MySQL NDB Cluster 7.5 and NDB Cluster 7.6"><code class="literal">NDBCLUSTER</code></a>). If
            <code class="literal">ENGINE</code> is not set, MySQL tries to use the
            engine specified by the
            <a class="link" href="server-administration.html#sysvar_default_storage_engine"><code class="literal">default_storage_engine</code></a> server
            system variable (formerly
            <a class="link" href="server-administration.html#sysvar_storage_engine"><code class="literal">storage_engine</code></a>). In any case, if
            the engine is not specified as <a class="link" href="mysql-cluster.html" title="Chapter&nbsp;21&nbsp;MySQL NDB Cluster 7.5 and NDB Cluster 7.6"><code class="literal">NDB</code></a> or
            <a class="link" href="mysql-cluster.html" title="Chapter&nbsp;21&nbsp;MySQL NDB Cluster 7.5 and NDB Cluster 7.6"><code class="literal">NDBCLUSTER</code></a>, the <code class="literal">CREATE
            LOGFILE GROUP</code> statement appears to succeed but actually
            fails to create the log file group, as shown here:
        </p><p style="color:blue;">engine选项确定此日志文件组要使用的存储引擎，其中engine_name是存储引擎的名称。在mysql 5.7中，这必须是ndb（或ndbcluster）。如果未设置ENGINE，MySQL将尝试使用默认存储引擎服务器系统变量（以前称为存储引擎）指定的引擎。在任何情况下，如果引擎未指定为ndb或ndbcluster，则create log file group语句似乎成功，但实际上无法创建日志文件组，如下所示：</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>CREATE LOGFILE GROUP lg1</code></strong>
    -&gt;     <strong class="userinput"><code>ADD UNDOFILE 'undo.dat' INITIAL_SIZE = 10M;</code></strong>
Query OK, 0 rows affected, 1 warning (0.00 sec)

mysql&gt; <strong class="userinput"><code>SHOW WARNINGS;</code></strong>
+-------+------+------------------------------------------------------------------------------------------------+
| Level | Code | Message                                                                                        |
+-------+------+------------------------------------------------------------------------------------------------+
| Error | 1478 | <span class="errortext">Table storage engine 'InnoDB' does not support the create option 'TABLESPACE or LOGFILE GROUP'</span> |
+-------+------+------------------------------------------------------------------------------------------------+
1 row in set (0.00 sec)

mysql&gt; <strong class="userinput"><code>DROP LOGFILE GROUP lg1 ENGINE = NDB;</code></strong>
<span class="errortext">ERROR 1529 (HY000): Failed to drop LOGFILE GROUP</span>

mysql&gt; <strong class="userinput"><code>CREATE LOGFILE GROUP lg1</code></strong>
    -&gt;     <strong class="userinput"><code>ADD UNDOFILE 'undo.dat' INITIAL_SIZE = 10M</code></strong>
    -&gt;     <strong class="userinput"><code>ENGINE = NDB;</code></strong>
Query OK, 0 rows affected (2.97 sec)
</pre><p>
            The fact that the <code class="literal">CREATE LOGFILE GROUP</code>
            statement does not actually return an error when a
            non-<code class="literal">NDB</code> storage engine is named, but rather
            appears to succeed, is a known issue which we hope to address in a
            future release of NDB Cluster.
        </p><p style="color:blue;">当命名非ndb存储引擎时，create logfile group语句实际上并没有返回错误，而是似乎成功了，这是我们希望在将来的ndb集群版本中解决的一个已知问题。</p><p>
            <em class="replaceable"><code>REDO_BUFFER_SIZE</code></em>,
            <code class="literal">NODEGROUP</code>, <code class="literal">WAIT</code>, and
            <code class="literal">COMMENT</code> are parsed but ignored, and so have no
            effect in MySQL 5.7. These options are intended for
            future expansion.
        </p><p style="color:blue;">redo_buffer_size、nodegroup、wait和comment被解析，但被忽略，因此在mysql 5.7中不起作用。这些选择是为了将来的扩展。</p><p>
            When used with <code class="literal">ENGINE [=] NDB</code>, a log file group
            and associated <code class="literal">UNDO</code> log file are created on
            each Cluster data node. You can verify that the
            <code class="literal">UNDO</code> files were created and obtain information
            about them by querying the
            <a class="link" href="information-schema.html#files-table" title="24.9&nbsp;The INFORMATION_SCHEMA FILES Table"><code class="literal">INFORMATION_SCHEMA.FILES</code></a> table. For
            example:
        </p><p style="color:blue;">与engine[=]ndb一起使用时，将在每个群集数据节点上创建日志文件组和关联的撤消日志文件。您可以通过查询information\schema.files表来验证撤消文件是否已创建，并获取有关这些文件的信息。例如：</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT LOGFILE_GROUP_NAME, LOGFILE_GROUP_NUMBER, EXTRA</code></strong>
    -&gt; <strong class="userinput"><code>FROM INFORMATION_SCHEMA.FILES</code></strong>
    -&gt; <strong class="userinput"><code>WHERE FILE_NAME = 'undo_10.dat';</code></strong>
+--------------------+----------------------+----------------+
| LOGFILE_GROUP_NAME | LOGFILE_GROUP_NUMBER | EXTRA          |
+--------------------+----------------------+----------------+
| lg_3               |                   11 | CLUSTER_NODE=3 |
| lg_3               |                   11 | CLUSTER_NODE=4 |
+--------------------+----------------------+----------------+
2 rows in set (0.06 sec)
</pre><p>
            <a class="link" href="sql-syntax.html#create-logfile-group" title="13.1.15&nbsp;CREATE LOGFILE GROUP Syntax"><code class="literal">CREATE LOGFILE GROUP</code></a> is useful only
            with Disk Data storage for NDB Cluster. See
            <a class="xref" href="mysql-cluster.html#mysql-cluster-disk-data" title="21.5.13&nbsp;NDB Cluster Disk Data Tables">Section&nbsp;21.5.13, “NDB Cluster Disk Data Tables”</a>.
        </p><p style="color:blue;">创建日志文件组仅对ndb集群的磁盘数据存储有用。见21.5.13节，“ndb群集磁盘数据表”。</p>
        </div>
        <div class="section">
            <div class="titlepage">
                <div>
                    <div>
                        <h3 class="title"><a name="create-procedure"></a>13.1.16&nbsp;CREATE PROCEDURE and CREATE FUNCTION Syntax</h3>

                    </div>

                </div>

            </div>
            <a class="indexterm" name="idm140286839733808"></a><a class="indexterm" name="idm140286839732768"></a><pre data-lang="sql" class="programlisting">CREATE
    [DEFINER = <em class="replaceable"><code>user</code></em>]
    PROCEDURE <em class="replaceable"><code>sp_name</code></em> ([<em class="replaceable"><code>proc_parameter</code></em>[,...]])
    [<em class="replaceable"><code>characteristic</code></em> ...] <em class="replaceable"><code>routine_body</code></em>

CREATE
    [DEFINER = <em class="replaceable"><code>user</code></em>]
    FUNCTION <em class="replaceable"><code>sp_name</code></em> ([<em class="replaceable"><code>func_parameter</code></em>[,...]])
    RETURNS <em class="replaceable"><code>type</code></em>
    [<em class="replaceable"><code>characteristic</code></em> ...] <em class="replaceable"><code>routine_body</code></em>

<em class="replaceable"><code>proc_parameter</code></em>:
    [ IN | OUT | INOUT ] <em class="replaceable"><code>param_name</code></em> <em class="replaceable"><code>type</code></em>

<em class="replaceable"><code>func_parameter</code></em>:
    <em class="replaceable"><code>param_name</code></em> <em class="replaceable"><code>type</code></em>

<em class="replaceable"><code>type</code></em>:
    <em class="replaceable"><code>Any valid MySQL data type</code></em>

<em class="replaceable"><code>characteristic</code></em>:
    COMMENT '<em class="replaceable"><code>string</code></em>'
  | LANGUAGE SQL
  | [NOT] DETERMINISTIC
  | { CONTAINS SQL | NO SQL | READS SQL DATA | MODIFIES SQL DATA }
  | SQL SECURITY { DEFINER | INVOKER }

<em class="replaceable"><code>routine_body</code></em>:
    <em class="replaceable"><code>Valid SQL routine statement</code></em>
</pre><p>
            These statements create stored routines. By default, a routine is
            associated with the default database. To associate the routine
            explicitly with a given database, specify the name as
            <em class="replaceable"><code>db_name.sp_name</code></em> when you create it.
        </p><p style="color:blue;">这些语句创建存储例程。默认情况下，例程与默认数据库关联。若要将例程显式与给定数据库关联，请在创建该例程时将其名称指定为db_name.sp_name。</p><p>
            The <a class="link" href="sql-syntax.html#create-function" title="13.1.13&nbsp;CREATE FUNCTION Syntax"><code class="literal">CREATE FUNCTION</code></a> statement is
            also used in MySQL to support UDFs (user-defined functions). See
            <a class="xref" href="extending-mysql.html#adding-functions" title="28.4&nbsp;Adding Functions to MySQL">Section&nbsp;28.4, “Adding Functions to MySQL”</a>. A UDF can be regarded as an
            external stored function. Stored functions share their namespace
            with UDFs. See <a class="xref" href="language-structure.html#function-resolution" title="9.2.5&nbsp;Function Name Parsing and Resolution">Section&nbsp;9.2.5, “Function Name Parsing and Resolution”</a>, for the
            rules describing how the server interprets references to different
            kinds of functions.
        </p><p style="color:blue;">create function语句在mysql中也用于支持udf（用户定义函数）。参见第28.4节“向mysql添加函数”。udf可以看作是一个外部存储函数。存储函数与udf共享其命名空间。有关描述服务器如何解释对不同类型函数的引用的规则，请参阅第9.2.5节“函数名解析和解析”。</p><p>
            To invoke a stored procedure, use the
            <a class="link" href="sql-syntax.html#call" title="13.2.1&nbsp;CALL Syntax"><code class="literal">CALL</code></a> statement (see
            <a class="xref" href="sql-syntax.html#call" title="13.2.1&nbsp;CALL Syntax">Section&nbsp;13.2.1, “CALL Syntax”</a>). To invoke a stored function, refer to it
            in an expression. The function returns a value during expression
            evaluation.
        </p><p style="color:blue;">要调用存储过程，请使用call语句（请参阅第13.2.1节“调用语法”）。要调用存储函数，请在表达式中引用它。函数在表达式求值期间返回一个值。</p><p>
            <a class="link" href="sql-syntax.html#create-procedure" title="13.1.16&nbsp;CREATE PROCEDURE and CREATE FUNCTION Syntax"><code class="literal">CREATE PROCEDURE</code></a> and
            <a class="link" href="sql-syntax.html#create-function" title="13.1.13&nbsp;CREATE FUNCTION Syntax"><code class="literal">CREATE FUNCTION</code></a> require the
            <a class="link" href="security.html#priv_create-routine"><code class="literal">CREATE ROUTINE</code></a> privilege. If the
            <code class="literal">DEFINER</code> clause is present, the privileges
            required depend on the <em class="replaceable"><code>user</code></em> value, as
            discussed in <a class="xref" href="stored-objects.html#stored-objects-security" title="23.6&nbsp;Stored Object Access Control">Section&nbsp;23.6, “Stored Object Access Control”</a>. If binary
            logging is enabled, <a class="link" href="sql-syntax.html#create-function" title="13.1.13&nbsp;CREATE FUNCTION Syntax"><code class="literal">CREATE FUNCTION</code></a>
            might require the <a class="link" href="security.html#priv_super"><code class="literal">SUPER</code></a> privilege,
            as discussed in <a class="xref" href="stored-objects.html#stored-programs-logging" title="23.7&nbsp;Stored Program Binary Logging">Section&nbsp;23.7, “Stored Program Binary Logging”</a>.
        </p><p style="color:blue;">create procedure和create function需要create routine权限。如果存在definer子句，则所需的权限取决于用户值，如第23.6节“存储对象访问控制”中所述。如果启用了二进制日志记录，create函数可能需要超级权限，如23.7节“存储程序二进制日志记录”中所述。</p><p>
            By default, MySQL automatically grants the
            <a class="link" href="security.html#priv_alter-routine"><code class="literal">ALTER ROUTINE</code></a> and
            <a class="link" href="security.html#priv_execute"><code class="literal">EXECUTE</code></a> privileges to the routine
            creator. This behavior can be changed by disabling the
            <a class="link" href="server-administration.html#sysvar_automatic_sp_privileges"><code class="literal">automatic_sp_privileges</code></a> system
            variable. See <a class="xref" href="stored-objects.html#stored-routines-privileges" title="23.2.2&nbsp;Stored Routines and MySQL Privileges">Section&nbsp;23.2.2, “Stored Routines and MySQL Privileges”</a>.
        </p><p style="color:blue;">默认情况下，mysql会自动将alter例程和execute特权授予例程创建者。此行为可以通过禁用automatic_sp_privileges系统变量来更改。参见第23.2.2节“存储例程和mysql特权”。</p><p>
            The <code class="literal">DEFINER</code> and <code class="literal">SQL SECURITY</code>
            clauses specify the security context to be used when checking
            access privileges at routine execution time, as described later in
            this section.
        </p><p style="color:blue;">definer和sql security子句指定在例程执行时检查访问权限时要使用的安全上下文，如本节后面所述。</p><p>
            If the routine name is the same as the name of a built-in SQL
            function, a syntax error occurs unless you use a space between the
            name and the following parenthesis when defining the routine or
            invoking it later. For this reason, avoid using the names of
            existing SQL functions for your own stored routines.
        </p><p style="color:blue;">如果例程名称与内置SQL函数的名称相同，则会发生语法错误，除非在定义例程或稍后调用该例程时在名称和以下括号之间使用空格。因此，避免为自己的存储例程使用现有SQL函数的名称。</p><p>
            The <a class="link" href="server-administration.html#sqlmode_ignore_space"><code class="literal">IGNORE_SPACE</code></a> SQL mode
            applies to built-in functions, not to stored routines. It is
            always permissible to have spaces after a stored routine name,
            regardless of whether
            <a class="link" href="server-administration.html#sqlmode_ignore_space"><code class="literal">IGNORE_SPACE</code></a> is enabled.
        </p><p style="color:blue;">忽略空间sql模式适用于内置函数，而不是存储例程。不管是否启用了忽略空间，存储的例程名称后面始终允许有空格。</p><p>
            The parameter list enclosed within parentheses must always be
            present. If there are no parameters, an empty parameter list of
            <code class="literal">()</code> should be used. Parameter names are not case
            sensitive.
        </p><p style="color:blue;">括号内的参数列表必须始终存在。如果没有参数，则应使用空的参数列表。参数名不区分大小写。</p><p>
            Each parameter is an <code class="literal">IN</code> parameter by default.
            To specify otherwise for a parameter, use the keyword
            <code class="literal">OUT</code> or <code class="literal">INOUT</code> before the
            parameter name.
        </p><p style="color:blue;">默认情况下，每个参数都是in参数。若要为参数指定其他值，请在参数名称之前使用关键字out或inout。</p>
            <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">

                <div class="admon-title">
                    Note
                </div>
                <p>
                    Specifying a parameter as <code class="literal">IN</code>,
                    <code class="literal">OUT</code>, or <code class="literal">INOUT</code> is valid
                    only for a <code class="literal">PROCEDURE</code>. For a
                    <code class="literal">FUNCTION</code>, parameters are always regarded as
                    <code class="literal">IN</code> parameters.
                </p><p style="color:blue;">将参数指定为in、out或inout仅对过程有效。对于一个函数，参数总是被视为参数中的参数。</p>
            </div>
            <p>
                An <code class="literal">IN</code> parameter passes a value into a
                procedure. The procedure might modify the value, but the
                modification is not visible to the caller when the procedure
                returns. An <code class="literal">OUT</code> parameter passes a value from
                the procedure back to the caller. Its initial value is
                <code class="literal">NULL</code> within the procedure, and its value is
                visible to the caller when the procedure returns. An
                <code class="literal">INOUT</code> parameter is initialized by the caller,
                can be modified by the procedure, and any change made by the
                procedure is visible to the caller when the procedure returns.
            </p><p style="color:blue;">in参数将值传递给过程。过程可能会修改该值，但当过程返回时，调用方看不到该修改。out参数将一个值从过程传递回调用方。它的初始值在过程中为空，当过程返回时，它的值对调用方可见。inout参数由调用者初始化，可以由过程修改，当过程返回时，过程所做的任何更改都对调用者可见。</p><p>
            For each <code class="literal">OUT</code> or <code class="literal">INOUT</code>
            parameter, pass a user-defined variable in the
            <a class="link" href="sql-syntax.html#call" title="13.2.1&nbsp;CALL Syntax"><code class="literal">CALL</code></a> statement that invokes the
            procedure so that you can obtain its value when the procedure
            returns. If you are calling the procedure from within another
            stored procedure or function, you can also pass a routine
            parameter or local routine variable as an <code class="literal">OUT</code>
            or <code class="literal">INOUT</code> parameter. If you are calling the
            procedure from within a trigger, you can also pass
            <code class="literal">NEW.<em class="replaceable"><code>col_name</code></em></code> as an
            <code class="literal">OUT</code> or <code class="literal">INOUT</code> parameter.
        </p><p style="color:blue;">对于每个out或inout参数，在调用过程的call语句中传递一个用户定义的变量，以便在过程返回时获取其值。如果从另一个存储过程或函数中调用该过程，也可以将例程参数或局部例程变量作为out或inout参数传递。如果从触发器中调用过程，还可以将new.col_name作为out或inout参数传递。</p><p>
            For information about the effect of unhandled conditions on
            procedure parameters, see
            <a class="xref" href="sql-syntax.html#conditions-and-parameters" title="13.6.7.8&nbsp;Condition Handling and OUT or INOUT Parameters">Section&nbsp;13.6.7.8, “Condition Handling and OUT or INOUT Parameters”</a>.
        </p><p style="color:blue;">有关未处理条件对过程参数的影响的信息，请参阅第13.6.7.8节“条件处理和输出或输入输出参数”。</p><p>
            Routine parameters cannot be referenced in statements prepared
            within the routine; see
            <a class="xref" href="stored-objects.html#stored-program-restrictions" title="23.8&nbsp;Restrictions on Stored Programs">Section&nbsp;23.8, “Restrictions on Stored Programs”</a>.
        </p><p style="color:blue;">在例程中准备的语句中不能引用例程参数；请参阅第23.8节“对存储程序的限制”。</p><p>
            The following example shows a simple stored procedure that uses an
            <code class="literal">OUT</code> parameter:
        </p><p style="color:blue;">以下示例显示了使用out参数的简单存储过程：</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>delimiter //</code></strong>

mysql&gt; <strong class="userinput"><code>CREATE PROCEDURE simpleproc (OUT param1 INT)</code></strong>
    -&gt; <strong class="userinput"><code>BEGIN</code></strong>
    -&gt;   <strong class="userinput"><code>SELECT COUNT(*) INTO param1 FROM t;</code></strong>
    -&gt; <strong class="userinput"><code>END//</code></strong>
Query OK, 0 rows affected (0.00 sec)

mysql&gt; <strong class="userinput"><code>delimiter ;</code></strong>

mysql&gt; <strong class="userinput"><code>CALL simpleproc(@a);</code></strong>
Query OK, 0 rows affected (0.00 sec)

mysql&gt; <strong class="userinput"><code>SELECT @a;</code></strong>
+------+
| @a   |
+------+
| 3    |
+------+
1 row in set (0.00 sec)
</pre><p>
            The example uses the <a class="link" href="programs.html#mysql" title="4.5.1&nbsp;mysql — The MySQL Command-Line Client"><span class="command"><strong>mysql</strong></span></a> client
            <code class="literal">delimiter</code> command to change the statement
            delimiter from <code class="literal">;</code> to <code class="literal">//</code> while
            the procedure is being defined. This enables the
            <code class="literal">;</code> delimiter used in the procedure body to be
            passed through to the server rather than being interpreted by
            <a class="link" href="programs.html#mysql" title="4.5.1&nbsp;mysql — The MySQL Command-Line Client"><span class="command"><strong>mysql</strong></span></a> itself. See
            <a class="xref" href="stored-objects.html#stored-programs-defining" title="23.1&nbsp;Defining Stored Programs">Section&nbsp;23.1, “Defining Stored Programs”</a>.
        </p><p style="color:blue;">该示例使用mysql client delimiter命令在定义过程时将语句分隔符从；更改为//。这使得过程体中使用的；分隔符能够传递到服务器，而不是由mysql本身解释。参见第23.1节“定义存储程序”。</p><p>
            The <code class="literal">RETURNS</code> clause may be specified only for a
            <code class="literal">FUNCTION</code>, for which it is mandatory. It
            indicates the return type of the function, and the function body
            must contain a <code class="literal">RETURN
            <em class="replaceable"><code>value</code></em></code> statement. If the
            <a class="link" href="sql-syntax.html#return" title="13.6.5.7&nbsp;RETURN Syntax"><code class="literal">RETURN</code></a> statement returns a value of
            a different type, the value is coerced to the proper type. For
            example, if a function specifies an
            <a class="link" href="data-types.html#enum" title="11.4.4&nbsp;The ENUM Type"><code class="literal">ENUM</code></a> or
            <a class="link" href="data-types.html#set" title="11.4.5&nbsp;The SET Type"><code class="literal">SET</code></a> value in the
            <code class="literal">RETURNS</code> clause, but the
            <a class="link" href="sql-syntax.html#return" title="13.6.5.7&nbsp;RETURN Syntax"><code class="literal">RETURN</code></a> statement returns an
            integer, the value returned from the function is the string for
            the corresponding <a class="link" href="data-types.html#enum" title="11.4.4&nbsp;The ENUM Type"><code class="literal">ENUM</code></a> member of
            set of <a class="link" href="data-types.html#set" title="11.4.5&nbsp;The SET Type"><code class="literal">SET</code></a> members.
        </p><p style="color:blue;">returns子句只能为函数指定，对于函数必须指定。它指示函数的返回类型，函数体必须包含返回值语句。如果return语句返回不同类型的值，则该值将强制为正确的类型。例如，如果函数在RETURNS子句中指定枚举或集合值，但RETURN语句返回一个整数，则从函数返回的值是集合成员中相应枚举成员的字符串。</p><p>
            The following example function takes a parameter, performs an
            operation using an SQL function, and returns the result. In this
            case, it is unnecessary to use <code class="literal">delimiter</code>
            because the function definition contains no internal
            <code class="literal">;</code> statement delimiters:
        </p><p style="color:blue;">下面的示例函数接受一个参数，使用sql函数执行一个操作，并返回结果。在这种情况下，不必使用分隔符，因为函数定义不包含内部；语句分隔符：</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>CREATE FUNCTION hello (s CHAR(20))</code></strong>
mysql&gt; <strong class="userinput"><code>RETURNS CHAR(50) DETERMINISTIC</code></strong>
    -&gt; <strong class="userinput"><code>RETURN CONCAT('Hello, ',s,'!');</code></strong>
Query OK, 0 rows affected (0.00 sec)

mysql&gt; <strong class="userinput"><code>SELECT hello('world');</code></strong>
+----------------+
| hello('world') |
+----------------+
| Hello, world!  |
+----------------+
1 row in set (0.00 sec)
</pre><p>
            Parameter types and function return types can be declared to use
            any valid data type. The <code class="literal">COLLATE</code> attribute can
            be used if preceded by a <code class="literal">CHARACTER SET</code>
            specification.
        </p><p style="color:blue;">参数类型和函数返回类型可以声明为使用任何有效的数据类型。如果前面有字符集规范，则可以使用collate属性。</p><p>
            The <em class="replaceable"><code>routine_body</code></em> consists of a valid
            SQL routine statement. This can be a simple statement such as
            <a class="link" href="sql-syntax.html#select" title="13.2.9&nbsp;SELECT Syntax"><code class="literal">SELECT</code></a> or
            <a class="link" href="sql-syntax.html#insert" title="13.2.5&nbsp;INSERT Syntax"><code class="literal">INSERT</code></a>, or a compound statement
            written using <code class="literal">BEGIN</code> and <code class="literal">END</code>.
            Compound statements can contain declarations, loops, and other
            control structure statements. The syntax for these statements is
            described in <a class="xref" href="sql-syntax.html#sql-syntax-compound-statements" title="13.6&nbsp;Compound-Statement Syntax">Section&nbsp;13.6, “Compound-Statement Syntax”</a>. In
            practice, stored functions tend to use compound statements, unless
            the body consists of a single
            <a class="link" href="sql-syntax.html#return" title="13.6.5.7&nbsp;RETURN Syntax"><code class="literal">RETURN</code></a> statement.
        </p><p style="color:blue;">例程体由有效的SQL例程语句组成。这可以是一个简单的语句，如select或insert，也可以是一个使用begin和end编写的复合语句。复合语句可以包含声明、循环和其他控制结构语句。这些语句的语法在13.6节“复合语句语法”中描述。实际上，存储函数倾向于使用复合语句，除非主体由单个返回语句组成。</p><p>
            MySQL permits routines to contain DDL statements, such as
            <code class="literal">CREATE</code> and <code class="literal">DROP</code>. MySQL also
            permits stored procedures (but not stored functions) to contain
            SQL transaction statements such as
            <a class="link" href="sql-syntax.html#commit" title="13.3.1&nbsp;START TRANSACTION, COMMIT, and ROLLBACK Syntax"><code class="literal">COMMIT</code></a>. Stored functions may not
            contain statements that perform explicit or implicit commit or
            rollback. Support for these statements is not required by the SQL
            standard, which states that each DBMS vendor may decide whether to
            permit them.
        </p><p style="color:blue;">mysql允许例程包含ddl语句，例如create和drop。mysql还允许存储过程（但不允许存储函数）包含诸如commit之类的sql事务语句。存储函数不能包含执行显式或隐式提交或回滚的语句。sql标准不要求对这些语句提供支持，它规定每个dbms供应商都可以决定是否允许这些语句。</p><p>
            Statements that return a result set can be used within a stored
            procedure but not within a stored function. This prohibition
            includes <a class="link" href="sql-syntax.html#select" title="13.2.9&nbsp;SELECT Syntax"><code class="literal">SELECT</code></a> statements that do
            not have an <code class="literal">INTO
            <em class="replaceable"><code>var_list</code></em></code> clause and other
            statements such as <a class="link" href="sql-syntax.html#show" title="13.7.5&nbsp;SHOW Syntax"><code class="literal">SHOW</code></a>,
            <a class="link" href="sql-syntax.html#explain" title="13.8.2&nbsp;EXPLAIN Syntax"><code class="literal">EXPLAIN</code></a>, and
            <a class="link" href="sql-syntax.html#check-table" title="13.7.2.2&nbsp;CHECK TABLE Syntax"><code class="literal">CHECK TABLE</code></a>. For statements that
            can be determined at function definition time to return a result
            set, a <code class="literal">Not allowed to return a result set from a
            function</code> error occurs
            (<a class="link" href="error-handling.html#error_er_sp_no_retset"><code class="literal">ER_SP_NO_RETSET</code></a>). For statements
            that can be determined only at runtime to return a result set, a
            <code class="literal">PROCEDURE %s can't return a result set in the given
                context</code> error occurs
            (<a class="link" href="error-handling.html#error_er_sp_badselect"><code class="literal">ER_SP_BADSELECT</code></a>).
        </p><p style="color:blue;">返回结果集的语句可以在存储过程中使用，但不能在存储函数中使用。此禁止包括没有into var_list子句的select语句和其他语句，如show、explain和check table。对于可以在函数定义时确定返回结果集的语句，将发生不允许从函数错误返回结果集的情况（er_sp_no_retset）。对于只能在运行时确定返回结果集的语句，出现给定上下文错误时过程%s不能返回结果集（er_sp_badselect）。</p><p>
            <a class="link" href="sql-syntax.html#use" title="13.8.4&nbsp;USE Syntax"><code class="literal">USE</code></a> statements within stored
            routines are not permitted. When a routine is invoked, an implicit
            <code class="literal">USE <em class="replaceable"><code>db_name</code></em></code> is
            performed (and undone when the routine terminates). The causes the
            routine to have the given default database while it executes.
            References to objects in databases other than the routine default
            database should be qualified with the appropriate database name.
        </p><p style="color:blue;">不允许在存储例程中使用语句。调用例程时，将执行隐式使用db_name（并在例程终止时撤消）。使例程在执行时具有给定的默认数据库。对数据库中除例程默认数据库以外的对象的引用应使用适当的数据库名称进行限定。</p><p>
            For additional information about statements that are not permitted
            in stored routines, see
            <a class="xref" href="stored-objects.html#stored-program-restrictions" title="23.8&nbsp;Restrictions on Stored Programs">Section&nbsp;23.8, “Restrictions on Stored Programs”</a>.
        </p><p style="color:blue;">有关存储例程中不允许使用的语句的其他信息，请参阅23.8节“对存储程序的限制”。</p><p>
            For information about invoking stored procedures from within
            programs written in a language that has a MySQL interface, see
            <a class="xref" href="sql-syntax.html#call" title="13.2.1&nbsp;CALL Syntax">Section&nbsp;13.2.1, “CALL Syntax”</a>.
        </p><p style="color:blue;">有关从用具有mysql接口的语言编写的程序中调用存储过程的信息，请参阅13.2.1节“调用语法”。</p><p>
            MySQL stores the <a class="link" href="server-administration.html#sysvar_sql_mode"><code class="literal">sql_mode</code></a> system
            variable setting in effect when a routine is created or altered,
            and always executes the routine with this setting in force,
            <span class="emphasis"><em>regardless of the current server SQL mode when the
      routine begins executing</em></span>.
        </p><p style="color:blue;">mysql存储在创建或更改例程时生效的sql_mode系统变量设置，并始终在该设置生效时执行例程，而不管例程开始执行时的当前服务器sql模式如何。</p><p>
            The switch from the SQL mode of the invoker to that of the routine
            occurs after evaluation of arguments and assignment of the
            resulting values to routine parameters. If you define a routine in
            strict SQL mode but invoke it in nonstrict mode, assignment of
            arguments to routine parameters does not take place in strict
            mode. If you require that expressions passed to a routine be
            assigned in strict SQL mode, you should invoke the routine with
            strict mode in effect.
        </p><p style="color:blue;">在对参数求值并将结果值分配给例程参数之后，将从调用程序的sql模式切换到例程的sql模式。如果在严格SQL模式下定义例程，但在非严格模式下调用它，则不会在严格模式下为例程参数分配参数。如果要求以严格的sql模式分配传递给例程的表达式，则应在严格模式有效的情况下调用该例程。</p><p>
            The <code class="literal">COMMENT</code> characteristic is a MySQL
            extension, and may be used to describe the stored routine. This
            information is displayed by the <a class="link" href="sql-syntax.html#show-create-procedure" title="13.7.5.9&nbsp;SHOW CREATE PROCEDURE Syntax"><code class="literal">SHOW CREATE
            PROCEDURE</code></a> and <a class="link" href="sql-syntax.html#show-create-function" title="13.7.5.8&nbsp;SHOW CREATE FUNCTION Syntax"><code class="literal">SHOW CREATE
            FUNCTION</code></a> statements.
        </p><p style="color:blue;">comment特性是一个mysql扩展，可以用来描述存储的例程。此信息由show create过程和show create function语句显示。</p><p>
            The <code class="literal">LANGUAGE</code> characteristic indicates the
            language in which the routine is written. The server ignores this
            characteristic; only SQL routines are supported.
        </p><p style="color:blue;">语言特性表示编写例程的语言。服务器忽略此特性；仅支持SQL例程。</p><p>
            A routine is considered <span class="quote">“<span class="quote">deterministic</span>”</span> if it always
            produces the same result for the same input parameters, and
            <span class="quote">“<span class="quote">not deterministic</span>”</span> otherwise. If neither
            <code class="literal">DETERMINISTIC</code> nor <code class="literal">NOT
            DETERMINISTIC</code> is given in the routine definition, the
            default is <code class="literal">NOT DETERMINISTIC</code>. To declare that a
            function is deterministic, you must specify
            <code class="literal">DETERMINISTIC</code> explicitly.
        </p><p style="color:blue;">如果一个例程总是为相同的输入参数产生相同的结果，那么它被认为是“确定性的”，否则就被认为是“不确定性的”。如果例程定义中既没有确定性也没有不确定性，则默认值不是确定性的。要声明函数是确定性的，必须显式指定确定性。</p><p>
            Assessment of the nature of a routine is based on the
            <span class="quote">“<span class="quote">honesty</span>”</span> of the creator: MySQL does not check that a
            routine declared <code class="literal">DETERMINISTIC</code> is free of
            statements that produce nondeterministic results. However,
            misdeclaring a routine might affect results or affect performance.
            Declaring a nondeterministic routine as
            <code class="literal">DETERMINISTIC</code> might lead to unexpected results
            by causing the optimizer to make incorrect execution plan choices.
            Declaring a deterministic routine as
            <code class="literal">NONDETERMINISTIC</code> might diminish performance by
            causing available optimizations not to be used.
        </p><p style="color:blue;">对例程性质的评估基于创建者的“诚实”：mysql不会检查声明为deterministic的例程是否没有产生不确定结果的语句。但是，错误声明例程可能会影响结果或影响性能。将不确定例程声明为确定性例程可能会导致优化器做出错误的执行计划选择，从而导致意外结果。将确定性例程声明为不确定性可能会导致不使用可用的优化而降低性能。</p><p>
            If binary logging is enabled, the <code class="literal">DETERMINISTIC</code>
            characteristic affects which routine definitions MySQL accepts.
            See <a class="xref" href="stored-objects.html#stored-programs-logging" title="23.7&nbsp;Stored Program Binary Logging">Section&nbsp;23.7, “Stored Program Binary Logging”</a>.
        </p><p style="color:blue;">如果启用了二进制日志记录，那么确定性特征会影响mysql接受的例程定义。参见第23.7节“存储程序二进制日志”。</p><p>
            A routine that contains the <a class="link" href="functions.html#function_now"><code class="literal">NOW()</code></a>
            function (or its synonyms) or
            <a class="link" href="functions.html#function_rand"><code class="literal">RAND()</code></a> is nondeterministic, but it
            might still be replication-safe. For
            <a class="link" href="functions.html#function_now"><code class="literal">NOW()</code></a>, the binary log includes the
            timestamp and replicates correctly.
            <a class="link" href="functions.html#function_rand"><code class="literal">RAND()</code></a> also replicates correctly as
            long as it is called only a single time during the execution of a
            routine. (You can consider the routine execution timestamp and
            random number seed as implicit inputs that are identical on the
            master and slave.)
        </p><p style="color:blue;">包含now（）函数（或其同义词）或rand（）的例程是不确定的，但它可能仍然是复制安全的。对于now（），二进制日志包含时间戳并正确复制。rand（）也可以正确复制，只要在执行例程期间只调用一次。（您可以将例程执行时间戳和随机数种子视为主节点和从节点上相同的隐式输入。）</p><p>
            Several characteristics provide information about the nature of
            data use by the routine. In MySQL, these characteristics are
            advisory only. The server does not use them to constrain what
            kinds of statements a routine will be permitted to execute.
        </p><p style="color:blue;">一些特性提供了有关例程使用数据的性质的信息。在mysql中，这些特性仅供参考。服务器不使用它们来约束例程允许执行的语句类型。</p>
            <div class="itemizedlist">
                <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                    <code class="literal">CONTAINS SQL</code> indicates that the routine
                    does not contain statements that read or write data. This is
                    the default if none of these characteristics is given
                    explicitly. Examples of such statements are <code class="literal">SET @x =
                    1</code> or <code class="literal">DO RELEASE_LOCK('abc')</code>,
                    which execute but neither read nor write data.
                </p><p style="color:blue;">contains sql表示例程不包含读或写数据的语句。如果没有显式给定这些特征，则这是默认值。这类语句的示例是set@x=1或do release_lock（'abc'），它执行但不读也不写数据。</p></li><li class="listitem"><p>
                    <code class="literal">NO SQL</code> indicates that the routine contains
                    no SQL statements.
                </p><p style="color:blue;">no sql表示例程不包含sql语句。</p></li><li class="listitem"><p>
                    <code class="literal">READS SQL DATA</code> indicates that the routine
                    contains statements that read data (for example,
                    <a class="link" href="sql-syntax.html#select" title="13.2.9&nbsp;SELECT Syntax"><code class="literal">SELECT</code></a>), but not statements
                    that write data.
                </p><p style="color:blue;">reads sql data表示例程包含读取数据的语句（例如，select），但不包含写入数据的语句。</p></li><li class="listitem"><p>
                    <code class="literal">MODIFIES SQL DATA</code> indicates that the
                    routine contains statements that may write data (for example,
                    <a class="link" href="sql-syntax.html#insert" title="13.2.5&nbsp;INSERT Syntax"><code class="literal">INSERT</code></a> or
                    <a class="link" href="sql-syntax.html#delete" title="13.2.2&nbsp;DELETE Syntax"><code class="literal">DELETE</code></a>).
                </p><p style="color:blue;">modifies sql data表示例程包含可以写入数据的语句（例如，insert或delete）。</p></li></ul>
            </div>
            <p>
                The <code class="literal">SQL SECURITY</code> characteristic can be
                <code class="literal">DEFINER</code> or <code class="literal">INVOKER</code> to
                specify the security context; that is, whether the routine
                executes using the privileges of the account named in the routine
                <code class="literal">DEFINER</code> clause or the user who invokes it. This
                account must have permission to access the database with which the
                routine is associated. The default value is
                <code class="literal">DEFINER</code>. The user who invokes the routine must
                have the <a class="link" href="security.html#priv_execute"><code class="literal">EXECUTE</code></a> privilege for it,
                as must the <code class="literal">DEFINER</code> account if the routine
                executes in definer security context.
            </p><p style="color:blue;">sql安全特性可以是definer或invoker来指定安全上下文；也就是说，例程是使用routine definer子句中指定的帐户的权限执行的，还是使用调用它的用户的权限执行的。此帐户必须具有访问与例程关联的数据库的权限。默认值为definer。调用例程的用户必须具有该例程的execute特权，如果例程在definer安全上下文中执行，则definer帐户也必须具有该特权。</p><p>
            The <code class="literal">DEFINER</code> clause specifies the MySQL account
            to be used when checking access privileges at routine execution
            time for routines that have the <code class="literal">SQL SECURITY
            DEFINER</code> characteristic.
        </p><p style="color:blue;">definer子句指定在例程执行时检查具有sql security definer特性的例程的访问权限时要使用的mysql帐户。</p><p>
            If the <code class="literal">DEFINER</code> clause is present, the
            <em class="replaceable"><code>user</code></em> value should be a MySQL account
            specified as
            <code class="literal">'<em class="replaceable"><code>user_name</code></em>'@'<em class="replaceable"><code>host_name</code></em>'</code>,
            <a class="link" href="functions.html#function_current-user"><code class="literal">CURRENT_USER</code></a>, or
            <a class="link" href="functions.html#function_current-user"><code class="literal">CURRENT_USER()</code></a>. The permitted
            <em class="replaceable"><code>user</code></em> values depend on the privileges
            you hold, as discussed in
            <a class="xref" href="stored-objects.html#stored-objects-security" title="23.6&nbsp;Stored Object Access Control">Section&nbsp;23.6, “Stored Object Access Control”</a>. Also see that section
            for additional information about stored routine security.
        </p><p style="color:blue;">如果存在definer子句，则用户值应为mysql帐户，指定为“user_name”@“host_name”、current_user或current_user（）。允许的用户值取决于您所拥有的特权，如第23.6节“存储对象访问控制”中所述。有关存储例程安全性的其他信息，请参见该部分。</p><p>
            If the <code class="literal">DEFINER</code> clause is omitted, the default
            definer is the user who executes the <a class="link" href="sql-syntax.html#create-procedure" title="13.1.16&nbsp;CREATE PROCEDURE and CREATE FUNCTION Syntax"><code class="literal">CREATE
            PROCEDURE</code></a> or <a class="link" href="sql-syntax.html#create-function" title="13.1.13&nbsp;CREATE FUNCTION Syntax"><code class="literal">CREATE
            FUNCTION</code></a> statement. This is the same as specifying
            <code class="literal">DEFINER = CURRENT_USER</code> explicitly.
        </p><p style="color:blue;">如果省略definer子句，则默认的definer是执行create procedure或create function语句的用户。这与显式指定definer=current_user相同。</p><p>
            Within the body of a stored routine that is defined with the
            <code class="literal">SQL SECURITY DEFINER</code> characteristic, the
            <a class="link" href="functions.html#function_current-user"><code class="literal">CURRENT_USER</code></a> function returns the
            routine's <code class="literal">DEFINER</code> value. For information about
            user auditing within stored routines, see
            <a class="xref" href="security.html#account-activity-auditing" title="6.2.18&nbsp;SQL-Based Account Activity Auditing">Section&nbsp;6.2.18, “SQL-Based Account Activity Auditing”</a>.
        </p><p style="color:blue;">在用sql security definer特性定义的存储例程的主体中，current_user函数返回例程的definer值。有关存储例程中的用户审核的信息，请参阅第6.2.18节“基于SQL的帐户活动审核”。</p><p>
            Consider the following procedure, which displays a count of the
            number of MySQL accounts listed in the
            <code class="literal">mysql.user</code> system table:
        </p><p style="color:blue;">考虑以下过程，它显示mysql.user系统表中列出的mysql帐户数：</p><pre data-lang="sql" class="programlisting">CREATE DEFINER = 'admin'@'localhost' PROCEDURE account_count()
BEGIN
  SELECT 'Number of accounts:', COUNT(*) FROM mysql.user;
END;
</pre><p>
            The procedure is assigned a <code class="literal">DEFINER</code> account of
            <code class="literal">'admin'@'localhost'</code> no matter which user
            defines it. It executes with the privileges of that account no
            matter which user invokes it (because the default security
            characteristic is <code class="literal">DEFINER</code>). The procedure
            succeeds or fails depending on whether invoker has the
            <a class="link" href="security.html#priv_execute"><code class="literal">EXECUTE</code></a> privilege for it and
            <code class="literal">'admin'@'localhost'</code> has the
            <a class="link" href="security.html#priv_select"><code class="literal">SELECT</code></a> privilege for the
            <code class="literal">mysql.user</code> table.
        </p><p style="color:blue;">不管是哪个用户定义的，都会为过程分配一个“admin”@“localhost”的定义者帐户。无论哪个用户调用它，它都以该帐户的权限执行（因为默认的安全特性是definer）。根据调用程序是否具有执行权限以及“admin”@“localhost”是否具有mysql.user表的选择权限，过程成功或失败。</p><p>
            Now suppose that the procedure is defined with the <code class="literal">SQL
            SECURITY INVOKER</code> characteristic:
        </p><p style="color:blue;">现在假设该过程是用sql security invoker特性定义的：</p><pre data-lang="sql" class="programlisting">CREATE DEFINER = 'admin'@'localhost' PROCEDURE account_count()
SQL SECURITY INVOKER
BEGIN
  SELECT 'Number of accounts:', COUNT(*) FROM mysql.user;
END;
</pre><p>
            The procedure still has a <code class="literal">DEFINER</code> of
            <code class="literal">'admin'@'localhost'</code>, but in this case, it
            executes with the privileges of the invoking user. Thus, the
            procedure succeeds or fails depending on whether the invoker has
            the <a class="link" href="security.html#priv_execute"><code class="literal">EXECUTE</code></a> privilege for it and
            the <a class="link" href="security.html#priv_select"><code class="literal">SELECT</code></a> privilege for the
            <code class="literal">mysql.user</code> table.
        </p><p style="color:blue;">过程仍然有一个“admin”@“localhost”的定义者，但在本例中，它是以调用用户的权限执行的。因此，过程的成功与否取决于调用程序是否具有对它的execute权限和对mysql.user表的select权限。</p><p>
            The server handles the data type of a routine parameter, local
            routine variable created with
            <a class="link" href="sql-syntax.html#declare" title="13.6.3&nbsp;DECLARE Syntax"><code class="literal">DECLARE</code></a>, or function return value
            as follows:
        </p><p style="color:blue;">服务器按如下方式处理例程参数、使用declare创建的本地例程变量或函数返回值的数据类型：</p>
            <div class="itemizedlist">
                <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                    Assignments are checked for data type mismatches and overflow.
                    Conversion and overflow problems result in warnings, or errors
                    in strict SQL mode.
                </p><p style="color:blue;">检查分配是否存在数据类型不匹配和溢出。转换和溢出问题会导致警告，或在严格的SQL模式下出现错误。</p></li><li class="listitem"><p>
                    Only scalar values can be assigned. For example, a statement
                    such as <code class="literal">SET x = (SELECT 1, 2)</code> is invalid.
                </p><p style="color:blue;">只能指定标量值。例如，set x=（select 1，2）等语句无效。</p></li><li class="listitem"><p>
                    For character data types, if <code class="literal">CHARACTER SET</code>
                    is includedd in the declaration, the specified character set
                    and its default collation is used. If the
                    <code class="literal">COLLATE</code> attribute is also present, that
                    collation is used rather than the default collation.
                </p><p style="color:blue;">对于字符数据类型，如果声明中包含字符集，则使用指定的字符集及其默认排序规则。如果collate属性也存在，则使用该排序规则，而不是默认排序规则。</p><p>
                    If <code class="literal">CHARACTER SET</code> and
                    <code class="literal">COLLATE</code> are not present, the database
                    character set and collation in effect at routine creation time
                    are used. To avoid having the server use the database
                    character set and collation, provide an explicit
                    <code class="literal">CHARACTER SET</code> and a
                    <code class="literal">COLLATE</code> attribute for character data
                    parameters.
                </p><p style="color:blue;">如果不存在字符集和排序规则，则使用在例程创建时有效的数据库字符集和排序规则。为了避免服务器使用数据库字符集和排序规则，请为字符数据参数提供显式字符集和排序属性。</p><p>
                    If you change the database default character set or collation,
                    stored routines that use the database defaults must be dropped
                    and recreated so that they use the new defaults.
                </p><p style="color:blue;">如果更改数据库默认字符集或排序规则，则必须删除并重新创建使用数据库默认值的存储例程，以便它们使用新的默认值。</p><p>
                    The database character set and collation are given by the
                    value of the
                    <a class="link" href="server-administration.html#sysvar_character_set_database"><code class="literal">character_set_database</code></a> and
                    <a class="link" href="server-administration.html#sysvar_collation_database"><code class="literal">collation_database</code></a> system
                    variables. For more information, see
                    <a class="xref" href="charset.html#charset-database" title="10.3.3&nbsp;Database Character Set and Collation">Section&nbsp;10.3.3, “Database Character Set and Collation”</a>.
                </p><p style="color:blue;">数据库字符集和排序规则由字符集数据库和排序规则数据库系统变量的值给出。有关详细信息，请参阅第10.3.3节“数据库字符集和排序规则”。</p></li></ul>
            </div>

        </div>
        <div class="section">
            <div class="titlepage">
                <div>
                    <div>
                        <h3 class="title"><a name="create-server"></a>13.1.17&nbsp;CREATE SERVER Syntax</h3>

                    </div>

                </div>

            </div>
            <a class="indexterm" name="idm140286839512128"></a><pre data-lang="sql" class="programlisting">CREATE SERVER <em class="replaceable"><code>server_name</code></em>
    FOREIGN DATA WRAPPER <em class="replaceable"><code>wrapper_name</code></em>
    OPTIONS (<em class="replaceable"><code>option</code></em> [, <em class="replaceable"><code>option</code></em>] ...)

<em class="replaceable"><code>option</code></em>:
  { HOST <em class="replaceable"><code>character-literal</code></em>
  | DATABASE <em class="replaceable"><code>character-literal</code></em>
  | USER <em class="replaceable"><code>character-literal</code></em>
  | PASSWORD <em class="replaceable"><code>character-literal</code></em>
  | SOCKET <em class="replaceable"><code>character-literal</code></em>
  | OWNER <em class="replaceable"><code>character-literal</code></em>
  | PORT <em class="replaceable"><code>numeric-literal</code></em> }
</pre><p>
            This statement creates the definition of a server for use with the
            <code class="literal">FEDERATED</code> storage engine. The <code class="literal">CREATE
            SERVER</code> statement creates a new row in the
            <code class="literal">servers</code> table in the <code class="literal">mysql</code>
            database. This statement requires the
            <a class="link" href="security.html#priv_super"><code class="literal">SUPER</code></a> privilege.
        </p><p style="color:blue;">此语句创建用于联合存储引擎的服务器定义。create server语句在mysql数据库的servers表中创建一个新行。此语句需要超级特权。</p><p>
            The <code class="literal"><em class="replaceable"><code>server_name</code></em></code>
            should be a unique reference to the server. Server definitions are
            global within the scope of the server, it is not possible to
            qualify the server definition to a specific database.
            <code class="literal"><em class="replaceable"><code>server_name</code></em></code> has a
            maximum length of 64 characters (names longer than 64 characters
            are silently truncated), and is case insensitive. You may specify
            the name as a quoted string.
        </p><p style="color:blue;">服务器名应该是对服务器的唯一引用。服务器定义是服务器范围内的全局定义，无法将服务器定义限定为特定数据库。ServIrNEX的最大长度为64个字符（长度大于64个字符的字符被截断），并且大小写不敏感。可以将名称指定为带引号的字符串。</p><p>
            The <code class="literal"><em class="replaceable"><code>wrapper_name</code></em></code> is
            an identifier and may be quoted with single quotation marks.
        </p><p style="color:blue;">包装器名称是一个标识符，可以用单引号引起来。</p><p>
            For each <code class="literal"><em class="replaceable"><code>option</code></em></code> you
            must specify either a character literal or numeric literal.
            Character literals are UTF-8, support a maximum length of 64
            characters and default to a blank (empty) string. String literals
            are silently truncated to 64 characters. Numeric literals must be
            a number between 0 and 9999, default value is 0.
        </p><p style="color:blue;">对于每个选项，必须指定字符文本或数字文本。字符文本是UTF-8，支持最大长度为64个字符，默认为空（空）字符串。字符串文字将自动截断为64个字符。数字文本必须是介于0和9999之间的数字，默认值为0。</p>
            <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">

                <div class="admon-title">
                    Note
                </div>
                <p>
                    The <code class="literal">OWNER</code> option is currently not applied,
                    and has no effect on the ownership or operation of the server
                    connection that is created.
                </p><p style="color:blue;">所有者选项当前未应用，对创建的服务器连接的所有权或操作没有影响。</p>
            </div>
            <p>
                The <code class="literal">CREATE SERVER</code> statement creates an entry in
                the <code class="literal">mysql.servers</code> table that can later be used
                with the <a class="link" href="sql-syntax.html#create-table" title="13.1.18&nbsp;CREATE TABLE Syntax"><code class="literal">CREATE TABLE</code></a> statement
                when creating a <code class="literal">FEDERATED</code> table. The options
                that you specify will be used to populate the columns in the
                <code class="literal">mysql.servers</code> table. The table columns are
                <code class="literal">Server_name</code>, <code class="literal">Host</code>,
                <code class="literal">Db</code>, <code class="literal">Username</code>,
                <code class="literal">Password</code>, <code class="literal">Port</code> and
                <code class="literal">Socket</code>.
            </p><p style="color:blue;">create server语句在mysql.servers表中创建一个条目，稍后在创建联合表时可以与create table语句一起使用。您指定的选项将用于填充mysql.servers表中的列。表列是服务器名、主机、数据库、用户名、密码、端口和套接字。</p><p>
            For example:
        </p><p style="color:blue;">例如：</p><pre data-lang="sql" class="programlisting">CREATE SERVER s
FOREIGN DATA WRAPPER mysql
OPTIONS (USER 'Remote', HOST '198.51.100.106', DATABASE 'test');
</pre><p>
            Be sure to specify all options necessary to establish a connection
            to the server. The user name, host name, and database name are
            mandatory. Other options might be required as well, such as
            password.
        </p><p style="color:blue;">请确保指定与服务器建立连接所需的所有选项。用户名、主机名和数据库名是必需的。可能还需要其他选项，例如密码。</p><p>
            The data stored in the table can be used when creating a
            connection to a <code class="literal">FEDERATED</code> table:
        </p><p style="color:blue;">在创建与联合表的连接时，可以使用表中存储的数据：</p><pre data-lang="sql" class="programlisting">CREATE TABLE t (s1 INT) ENGINE=FEDERATED CONNECTION='s';</pre><p>
            For more information, see
            <a class="xref" href="storage-engines.html#federated-storage-engine" title="15.8&nbsp;The FEDERATED Storage Engine">Section&nbsp;15.8, “The FEDERATED Storage Engine”</a>.
        </p><p style="color:blue;">有关更多信息，请参阅第15.8节“联邦存储引擎”。</p><p>
            <code class="literal">CREATE SERVER</code> causes an implicit commit. See
            <a class="xref" href="sql-syntax.html#implicit-commit" title="13.3.3&nbsp;Statements That Cause an Implicit Commit">Section&nbsp;13.3.3, “Statements That Cause an Implicit Commit”</a>.
        </p><p style="color:blue;">创建服务器导致隐式提交。参见第13.3.3节，“导致隐式提交的语句”。</p><p>
            <code class="literal">CREATE SERVER</code> is not written to the binary log,
            regardless of the logging format that is in use.
        </p><p style="color:blue;">无论使用何种日志格式，创建服务器都不会写入二进制日志。</p>
        </div>
        <div class="section">
            <div class="titlepage">
                <div>
                    <div>
                        <h3 class="title"><a name="create-table"></a>13.1.18&nbsp;CREATE TABLE Syntax</h3>

                    </div>

                </div>

            </div>
            <div class="toc">
                <dl class="toc"><dt><span class="section"><a href="sql-syntax.html#create-table-statement-retention">13.1.18.1 CREATE TABLE Statement Retention</a></span></dt><dt><span class="section"><a href="sql-syntax.html#create-table-files">13.1.18.2 Files Created by CREATE TABLE</a></span></dt><dt><span class="section"><a href="sql-syntax.html#create-temporary-table">13.1.18.3 CREATE TEMPORARY TABLE Syntax</a></span></dt><dt><span class="section"><a href="sql-syntax.html#create-table-like">13.1.18.4 CREATE TABLE ... LIKE Syntax</a></span></dt><dt><span class="section"><a href="sql-syntax.html#create-table-select">13.1.18.5 CREATE TABLE ... SELECT Syntax</a></span></dt><dt><span class="section"><a href="sql-syntax.html#create-table-foreign-keys">13.1.18.6 Using FOREIGN KEY Constraints</a></span></dt><dt><span class="section"><a href="sql-syntax.html#silent-column-changes">13.1.18.7 Silent Column Specification Changes</a></span></dt><dt><span class="section"><a href="sql-syntax.html#create-table-generated-columns">13.1.18.8 CREATE TABLE and Generated Columns</a></span></dt><dt><span class="section"><a href="sql-syntax.html#create-table-secondary-indexes">13.1.18.9 Secondary Indexes and Generated Columns</a></span></dt><dt><span class="section"><a href="sql-syntax.html#create-table-ndb-table-comment-options">13.1.18.10 Setting NDB_TABLE Options</a></span></dt></dl>
            </div>
            <a class="indexterm" name="idm140286839470160"></a><pre data-lang="sql" class="programlisting">CREATE [TEMPORARY] TABLE [IF NOT EXISTS] <em class="replaceable"><code>tbl_name</code></em>
    (<em class="replaceable"><code>create_definition</code></em>,...)
    [<em class="replaceable"><code>table_options</code></em>]
    [<em class="replaceable"><code>partition_options</code></em>]

CREATE [TEMPORARY] TABLE [IF NOT EXISTS] <em class="replaceable"><code>tbl_name</code></em>
    [(<em class="replaceable"><code>create_definition</code></em>,...)]
    [<em class="replaceable"><code>table_options</code></em>]
    [<em class="replaceable"><code>partition_options</code></em>]
    [IGNORE | REPLACE]
    [AS] <em class="replaceable"><code>query_expression</code></em>

CREATE [TEMPORARY] TABLE [IF NOT EXISTS] <em class="replaceable"><code>tbl_name</code></em>
    { LIKE <em class="replaceable"><code>old_tbl_name</code></em> | (LIKE <em class="replaceable"><code>old_tbl_name</code></em>) }

<em class="replaceable"><code>create_definition</code></em>:
    <em class="replaceable"><code>col_name</code></em> <em class="replaceable"><code>column_definition</code></em>
  | {INDEX|KEY} [<em class="replaceable"><code>index_name</code></em>] [<em class="replaceable"><code>index_type</code></em>] (<em class="replaceable"><code>key_part</code></em>,...)
      [<em class="replaceable"><code>index_option</code></em>] ...
  | {FULLTEXT|SPATIAL} [INDEX|KEY] [<em class="replaceable"><code>index_name</code></em>] (<em class="replaceable"><code>key_part</code></em>,...)
      [<em class="replaceable"><code>index_option</code></em>] ...
  | [CONSTRAINT [<em class="replaceable"><code>symbol</code></em>]] PRIMARY KEY
      [<em class="replaceable"><code>index_type</code></em>] (<em class="replaceable"><code>key_part</code></em>,...)
      [<em class="replaceable"><code>index_option</code></em>] ...
  | [CONSTRAINT [<em class="replaceable"><code>symbol</code></em>]] UNIQUE [INDEX|KEY]
      [<em class="replaceable"><code>index_name</code></em>] [<em class="replaceable"><code>index_type</code></em>] (<em class="replaceable"><code>key_part</code></em>,...)
      [<em class="replaceable"><code>index_option</code></em>] ...
  | [CONSTRAINT [<em class="replaceable"><code>symbol</code></em>]] FOREIGN KEY
      [<em class="replaceable"><code>index_name</code></em>] (<em class="replaceable"><code>col_name</code></em>,...)
      <em class="replaceable"><code>reference_definition</code></em>
  | CHECK (<em class="replaceable"><code>expr</code></em>)

<em class="replaceable"><code>column_definition</code></em>:
    <em class="replaceable"><code>data_type</code></em> [NOT NULL | NULL] [DEFAULT <em class="replaceable"><code>default_value</code></em>]
      [AUTO_INCREMENT] [UNIQUE [KEY]] [[PRIMARY] KEY]
      [COMMENT '<em class="replaceable"><code>string</code></em>']
      [COLLATE <em class="replaceable"><code>collation_name</code></em>]
      [COLUMN_FORMAT {FIXED|DYNAMIC|DEFAULT}]
      [STORAGE {DISK|MEMORY}]
      [<em class="replaceable"><code>reference_definition</code></em>]
  | <em class="replaceable"><code>data_type</code></em>
      [COLLATE <em class="replaceable"><code>collation_name</code></em>]
      [GENERATED ALWAYS] AS (<em class="replaceable"><code>expr</code></em>)
      [VIRTUAL | STORED] [NOT NULL | NULL]
      [UNIQUE [KEY]] [[PRIMARY] KEY]
      [COMMENT '<em class="replaceable"><code>string</code></em>']
      [<em class="replaceable"><code>reference_definition</code></em>]

<em class="replaceable"><code>data_type</code></em>:
    (see <a class="xref" href="data-types.html" title="Chapter&nbsp;11&nbsp;Data Types">Chapter&nbsp;11, <i>Data Types</i></a>)

<em class="replaceable"><code>key_part</code></em>:
    <em class="replaceable"><code>col_name</code></em> [(<em class="replaceable"><code>length</code></em>)] [ASC | DESC]

<em class="replaceable"><code>index_type</code></em>:
    USING {BTREE | HASH}

<em class="replaceable"><code>index_option</code></em>:
    KEY_BLOCK_SIZE [=] <em class="replaceable"><code>value</code></em>
  | <em class="replaceable"><code>index_type</code></em>
  | WITH PARSER <em class="replaceable"><code>parser_name</code></em>
  | COMMENT '<em class="replaceable"><code>string</code></em>'

<em class="replaceable"><code>reference_definition</code></em>:
    REFERENCES <em class="replaceable"><code>tbl_name</code></em> (<em class="replaceable"><code>key_part</code></em>,...)
      [MATCH FULL | MATCH PARTIAL | MATCH SIMPLE]
      [ON DELETE <em class="replaceable"><code>reference_option</code></em>]
      [ON UPDATE <em class="replaceable"><code>reference_option</code></em>]

<em class="replaceable"><code>reference_option</code></em>:
    RESTRICT | CASCADE | SET NULL | NO ACTION | SET DEFAULT

<em class="replaceable"><code>table_options</code></em>:
    <em class="replaceable"><code>table_option</code></em> [[,] <em class="replaceable"><code>table_option</code></em>] ...

<em class="replaceable"><code>table_option</code></em>:
    AUTO_INCREMENT [=] <em class="replaceable"><code>value</code></em>
  | AVG_ROW_LENGTH [=] <em class="replaceable"><code>value</code></em>
  | [DEFAULT] CHARACTER SET [=] <em class="replaceable"><code>charset_name</code></em>
  | CHECKSUM [=] {0 | 1}
  | [DEFAULT] COLLATE [=] <em class="replaceable"><code>collation_name</code></em>
  | COMMENT [=] '<em class="replaceable"><code>string</code></em>'
  | COMPRESSION [=] {'ZLIB'|'LZ4'|'NONE'}
  | CONNECTION [=] '<em class="replaceable"><code>connect_string</code></em>'
  | {DATA|INDEX} DIRECTORY [=] '<em class="replaceable"><code>absolute path to directory</code></em>'
  | DELAY_KEY_WRITE [=] {0 | 1}
  | ENCRYPTION [=] {'Y' | 'N'}
  | ENGINE [=] <em class="replaceable"><code>engine_name</code></em>
  | INSERT_METHOD [=] { NO | FIRST | LAST }
  | KEY_BLOCK_SIZE [=] <em class="replaceable"><code>value</code></em>
  | MAX_ROWS [=] <em class="replaceable"><code>value</code></em>
  | MIN_ROWS [=] <em class="replaceable"><code>value</code></em>
  | PACK_KEYS [=] {0 | 1 | DEFAULT}
  | PASSWORD [=] '<em class="replaceable"><code>string</code></em>'
  | ROW_FORMAT [=] {DEFAULT|DYNAMIC|FIXED|COMPRESSED|REDUNDANT|COMPACT}
  | STATS_AUTO_RECALC [=] {DEFAULT|0|1}
  | STATS_PERSISTENT [=] {DEFAULT|0|1}
  | STATS_SAMPLE_PAGES [=] <em class="replaceable"><code>value</code></em>
  | TABLESPACE <em class="replaceable"><code>tablespace_name</code></em> [STORAGE {DISK|MEMORY}]
  | UNION [=] (<em class="replaceable"><code>tbl_name</code></em>[,<em class="replaceable"><code>tbl_name</code></em>]...)

<em class="replaceable"><code>partition_options</code></em>:
    PARTITION BY
        { [LINEAR] HASH(<em class="replaceable"><code>expr</code></em>)
        | [LINEAR] KEY [ALGORITHM={1|2}] (<em class="replaceable"><code>column_list</code></em>)
        | RANGE{(<em class="replaceable"><code>expr</code></em>) | COLUMNS(<em class="replaceable"><code>column_list</code></em>)}
        | LIST{(<em class="replaceable"><code>expr</code></em>) | COLUMNS(<em class="replaceable"><code>column_list</code></em>)} }
    [PARTITIONS <em class="replaceable"><code>num</code></em>]
    [SUBPARTITION BY
        { [LINEAR] HASH(<em class="replaceable"><code>expr</code></em>)
        | [LINEAR] KEY [ALGORITHM={1|2}] (<em class="replaceable"><code>column_list</code></em>) }
      [SUBPARTITIONS <em class="replaceable"><code>num</code></em>]
    ]
    [(<em class="replaceable"><code>partition_definition</code></em> [, <em class="replaceable"><code>partition_definition</code></em>] ...)]

<em class="replaceable"><code>partition_definition</code></em>:
    PARTITION <em class="replaceable"><code>partition_name</code></em>
        [VALUES
            {LESS THAN {(<em class="replaceable"><code>expr</code></em> | <em class="replaceable"><code>value_list</code></em>) | MAXVALUE}
            |
            IN (<em class="replaceable"><code>value_list</code></em>)}]
        [[STORAGE] ENGINE [=] <em class="replaceable"><code>engine_name</code></em>]
        [COMMENT [=] '<em class="replaceable"><code>string</code></em>' ]
        [DATA DIRECTORY [=] '<code class="filename"><em class="replaceable"><code>data_dir</code></em></code>']
        [INDEX DIRECTORY [=] '<code class="filename"><em class="replaceable"><code>index_dir</code></em></code>']
        [MAX_ROWS [=] <em class="replaceable"><code>max_number_of_rows</code></em>]
        [MIN_ROWS [=] <em class="replaceable"><code>min_number_of_rows</code></em>]
        [TABLESPACE [=] tablespace_name]
        [(<em class="replaceable"><code>subpartition_definition</code></em> [, <em class="replaceable"><code>subpartition_definition</code></em>] ...)]

<em class="replaceable"><code>subpartition_definition</code></em>:
    SUBPARTITION <em class="replaceable"><code>logical_name</code></em>
        [[STORAGE] ENGINE [=] <em class="replaceable"><code>engine_name</code></em>]
        [COMMENT [=] '<em class="replaceable"><code>string</code></em>' ]
        [DATA DIRECTORY [=] '<code class="filename"><em class="replaceable"><code>data_dir</code></em></code>']
        [INDEX DIRECTORY [=] '<code class="filename"><em class="replaceable"><code>index_dir</code></em></code>']
        [MAX_ROWS [=] <em class="replaceable"><code>max_number_of_rows</code></em>]
        [MIN_ROWS [=] <em class="replaceable"><code>min_number_of_rows</code></em>]
        [TABLESPACE [=] tablespace_name]

<em class="replaceable"><code>query_expression:</code></em>
    SELECT ...   (<em class="replaceable"><code>Some valid select or union statement</code></em>)
</pre><p>
            <a class="link" href="sql-syntax.html#create-table" title="13.1.18&nbsp;CREATE TABLE Syntax"><code class="literal">CREATE TABLE</code></a> creates a table with
            the given name. You must have the
            <a class="link" href="security.html#priv_create"><code class="literal">CREATE</code></a> privilege for the table.
        </p><p style="color:blue;">创建表创建具有给定名称的表。您必须具有该表的创建权限。</p><p>
            By default, tables are created in the default database, using the
            <a class="link" href="innodb-storage-engine.html" title="Chapter&nbsp;14&nbsp;The InnoDB Storage Engine"><code class="literal">InnoDB</code></a> storage engine. An error
            occurs if the table exists, if there is no default database, or if
            the database does not exist.
        </p><p style="color:blue;">默认情况下，使用innodb存储引擎在默认数据库中创建表。如果表存在，如果没有默认数据库，或者数据库不存在，则会发生错误。</p><a class="indexterm" name="idm140286839403312"></a><a class="indexterm" name="idm140286839401808"></a><p>
            MySQL has no limit on the number of tables. The underlying file
            system may have a limit on the number of files that represent
            tables. Individual storage engines may impose engine-specific
            constraints. <code class="literal">InnoDB</code> permits up to 4 billion
            tables.
        </p><p style="color:blue;">mysql对表的数量没有限制。底层文件系统可能对表示表的文件数有限制。单个存储引擎可能会施加特定于引擎的约束。InnoDB允许多达40亿个表。</p><p>
            For information about the physical representation of a table, see
            <a class="xref" href="sql-syntax.html#create-table-files" title="13.1.18.2&nbsp;Files Created by CREATE TABLE">Section&nbsp;13.1.18.2, “Files Created by CREATE TABLE”</a>.
        </p><p style="color:blue;">有关表的物理表示的信息，请参见第13.1.18.2节“通过创建表创建的文件”。</p><p>
            The original <a class="link" href="sql-syntax.html#create-table" title="13.1.18&nbsp;CREATE TABLE Syntax"><code class="literal">CREATE TABLE</code></a>
            statement, including all specifications and table options are
            stored by MySQL when the table is created. For more information,
            see <a class="xref" href="sql-syntax.html#create-table-statement-retention" title="13.1.18.1&nbsp;CREATE TABLE Statement Retention">Section&nbsp;13.1.18.1, “CREATE TABLE Statement Retention”</a>.
        </p><p style="color:blue;">原始的create table语句（包括所有规范和表选项）在创建表时由mysql存储。有关详细信息，请参阅第13.1.18.1节“创建表语句保留”。</p><p>
            There are several aspects to the <a class="link" href="sql-syntax.html#create-table" title="13.1.18&nbsp;CREATE TABLE Syntax"><code class="literal">CREATE
            TABLE</code></a> statement, described under the following topics in
            this section:
        </p><p style="color:blue;">create table语句有几个方面，在本节的以下主题中进行了描述：</p>
            <div class="itemizedlist">
                <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><a class="xref" href="sql-syntax.html#create-table-name" title="Table Name">Table Name</a></p><p style="color:blue;">表名</p></li><li class="listitem"><p><a class="xref" href="sql-syntax.html#create-table-temporary-tables" title="Temporary Tables">Temporary Tables</a></p><p style="color:blue;">临时表</p></li><li class="listitem"><p><a class="xref" href="sql-syntax.html#create-table-clone-copy" title="Table Cloning and Copying">Table Cloning and Copying</a></p><p style="color:blue;">表克隆和复制</p></li><li class="listitem"><p><a class="xref" href="sql-syntax.html#create-table-types-attributes" title="Column Data Types and Attributes">Column Data Types and Attributes</a></p><p style="color:blue;">列数据类型和属性</p></li><li class="listitem"><p><a class="xref" href="sql-syntax.html#create-table-indexes-keys" title="Indexes and Foreign Keys">Indexes and Foreign Keys</a></p><p style="color:blue;">索引和外键</p></li><li class="listitem"><p><a class="xref" href="sql-syntax.html#create-table-options" title="Table Options">Table Options</a></p><p style="color:blue;">表格选项</p></li><li class="listitem"><p><a class="xref" href="sql-syntax.html#create-table-partitioning" title="Table Partitioning">Table Partitioning</a></p><p style="color:blue;">表分区</p></li></ul>
            </div>
            <h4><a name="create-table-name"></a>Table Name</h4>

            <div class="itemizedlist">
                <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                    <code class="literal"><em class="replaceable"><code>tbl_name</code></em></code>
                </p><p style="color:blue;">待定名称</p><p>
                    The table name can be specified as
                    <em class="replaceable"><code>db_name.tbl_name</code></em> to create the
                    table in a specific database. This works regardless of whether
                    there is a default database, assuming that the database
                    exists. If you use quoted identifiers, quote the database and
                    table names separately. For example, write
                    <code class="literal">`mydb`.`mytbl`</code>, not
                    <code class="literal">`mydb.mytbl`</code>.
                </p><p style="color:blue;">表名可以指定为db_name.tbl_name，以便在特定数据库中创建表。如果数据库存在，则不管是否存在默认数据库，它都工作。如果使用带引号的标识符，请分别引用数据库名和表名。例如，编写“mydb”。“mytbl”，而不是“mydb.mytbl”。</p><p>
                    Rules for permissible table names are given in
                    <a class="xref" href="language-structure.html#identifiers" title="9.2&nbsp;Schema Object Names">Section&nbsp;9.2, “Schema Object Names”</a>.
                </p><p style="color:blue;">第9.2节“模式对象名”给出了允许的表名规则。</p></li><li class="listitem"><p>
                    <code class="literal">IF NOT EXISTS</code>
                </p><p style="color:blue;">如果不存在</p><p>
                    Prevents an error from occurring if the table exists. However,
                    there is no verification that the existing table has a
                    structure identical to that indicated by the
                    <a class="link" href="sql-syntax.html#create-table" title="13.1.18&nbsp;CREATE TABLE Syntax"><code class="literal">CREATE TABLE</code></a> statement.
                </p><p style="color:blue;">如果表存在，则防止发生错误。但是，没有验证现有表具有与CREATETABLE语句所指示的结构相同的结构。</p></li></ul>
            </div>
            <h4><a name="create-table-temporary-tables"></a>Temporary Tables</h4>
            <p>
                You can use the <code class="literal">TEMPORARY</code> keyword when creating
                a table. A <code class="literal">TEMPORARY</code> table is visible only
                within the current session, and is dropped automatically when the
                session is closed. For more information, see
                <a class="xref" href="sql-syntax.html#create-temporary-table" title="13.1.18.3&nbsp;CREATE TEMPORARY TABLE Syntax">Section&nbsp;13.1.18.3, “CREATE TEMPORARY TABLE Syntax”</a>.
            </p><p style="color:blue;">创建表时可以使用临时关键字。临时表仅在当前会话中可见，并在会话关闭时自动删除。有关详细信息，请参阅第13.1.18.3节“创建临时表语法”。</p>
            <h4><a name="create-table-clone-copy"></a>Table Cloning and Copying</h4>
            <div class="itemizedlist">
                <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                    <code class="literal">LIKE</code>
                </p><p style="color:blue;">就像</p><p>
                    Use <code class="literal">CREATE TABLE ... LIKE</code> to create an
                    empty table based on the definition of another table,
                    including any column attributes and indexes defined in the
                    original table:
                </p><p style="color:blue;">使用创建表…类似于基于另一个表的定义创建空表，包括在原始表中定义的任何列属性和索引：</p><pre data-lang="sql" class="programlisting">CREATE TABLE <em class="replaceable"><code>new_tbl</code></em> LIKE <em class="replaceable"><code>orig_tbl</code></em>;
</pre><p>
                    For more information, see <a class="xref" href="sql-syntax.html#create-table-like" title="13.1.18.4&nbsp;CREATE TABLE ... LIKE Syntax">Section&nbsp;13.1.18.4, “CREATE TABLE ... LIKE Syntax”</a>.
                </p><p style="color:blue;">有关详细信息，请参见第13.1.18.4节“创建表…就像语法一样”。</p></li><li class="listitem"><p>
                    <code class="literal">[AS]
                        <em class="replaceable"><code>query_expression</code></em></code>
                </p><p style="color:blue;">[作为]查询表达式</p><p>
                    To create one table from another, add a
                    <a class="link" href="sql-syntax.html#select" title="13.2.9&nbsp;SELECT Syntax"><code class="literal">SELECT</code></a> statement at the end of
                    the <a class="link" href="sql-syntax.html#create-table" title="13.1.18&nbsp;CREATE TABLE Syntax"><code class="literal">CREATE TABLE</code></a> statement:
                </p><p style="color:blue;">要从另一个表创建一个表，请在CREATETABLE语句的末尾添加一个SELECT语句：</p><pre data-lang="sql" class="programlisting">CREATE TABLE <em class="replaceable"><code>new_tbl</code></em> AS SELECT * FROM <em class="replaceable"><code>orig_tbl</code></em>;
</pre><p>
                    For more information, see
                    <a class="xref" href="sql-syntax.html#create-table-select" title="13.1.18.5&nbsp;CREATE TABLE ... SELECT Syntax">Section&nbsp;13.1.18.5, “CREATE TABLE ... SELECT Syntax”</a>.
                </p><p style="color:blue;">有关详细信息，请参见第13.1.18.5节“创建表…选择“语法”。</p></li><li class="listitem"><p>
                    <code class="literal">IGNORE|REPLACE</code>
                </p><p style="color:blue;">忽略替换</p><p>
                    The <code class="literal">IGNORE</code> and <code class="literal">REPLACE</code>
                    options indicate how to handle rows that duplicate unique key
                    values when copying a table using a
                    <a class="link" href="sql-syntax.html#select" title="13.2.9&nbsp;SELECT Syntax"><code class="literal">SELECT</code></a> statement.
                </p><p style="color:blue;">“忽略”和“替换”选项指示如何在使用SELECT语句复制表时处理重复唯一键值的行。</p><p>
                    For more information, see
                    <a class="xref" href="sql-syntax.html#create-table-select" title="13.1.18.5&nbsp;CREATE TABLE ... SELECT Syntax">Section&nbsp;13.1.18.5, “CREATE TABLE ... SELECT Syntax”</a>.
                </p><p style="color:blue;">有关详细信息，请参见第13.1.18.5节“创建表…选择“语法”。</p></li></ul>
            </div>
            <h4><a name="create-table-types-attributes"></a>Column Data Types and Attributes</h4>
            <p>
                There is a hard limit of 4096 columns per table, but the effective
                maximum may be less for a given table and depends on the factors
                discussed in <a class="xref" href="optimization.html#column-count-limit" title="8.4.7&nbsp;Limits on Table Column Count and Row Size">Section&nbsp;8.4.7, “Limits on Table Column Count and Row Size”</a>.
            </p><p style="color:blue;">每个表有4096列的硬限制，但对于一个给定的表，有效的最大值可能要少一些，这取决于在“表列计数和行大小”限制部分中所讨论的因素。</p>
            <div class="itemizedlist">
                <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                    <code class="literal"><em class="replaceable"><code>data_type</code></em></code>
                </p><p style="color:blue;">数据类型</p><p>
                    <em class="replaceable"><code>data_type</code></em> represents the data type
                    in a column definition. For a full description of the syntax
                    available for specifying column data types, as well as
                    information about the properties of each type, see
                    <a class="xref" href="data-types.html" title="Chapter&nbsp;11&nbsp;Data Types">Chapter&nbsp;11, <i>Data Types</i></a>.
                </p><p style="color:blue;">数据类型表示列定义中的数据类型。有关可用于指定列数据类型的语法的完整说明，以及有关每种类型的属性的信息，请参阅第11章，数据类型。</p>
                    <div class="itemizedlist">
                        <ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
                            Some attributes do not apply to all data types.
                            <code class="literal">AUTO_INCREMENT</code> applies only to integer
                            and floating-point types. <code class="literal">DEFAULT</code> does
                            not apply to the <a class="link" href="data-types.html#blob" title="11.4.3&nbsp;The BLOB and TEXT Types"><code class="literal">BLOB</code></a>,
                            <a class="link" href="data-types.html#blob" title="11.4.3&nbsp;The BLOB and TEXT Types"><code class="literal">TEXT</code></a>,
                            <code class="literal">GEOMETRY</code>, and
                            <a class="link" href="data-types.html#json" title="11.6&nbsp;The JSON Data Type"><code class="literal">JSON</code></a> types.
                        </p><p style="color:blue;">有些属性不适用于所有数据类型。自动递增仅适用于整数和浮点类型。默认值不适用于blob、文本、几何体和json类型。</p></li><li class="listitem"><p>
                            Character data types (<a class="link" href="data-types.html#char" title="11.4.1&nbsp;The CHAR and VARCHAR Types"><code class="literal">CHAR</code></a>,
                            <a class="link" href="data-types.html#char" title="11.4.1&nbsp;The CHAR and VARCHAR Types"><code class="literal">VARCHAR</code></a>, the
                            <a class="link" href="data-types.html#blob" title="11.4.3&nbsp;The BLOB and TEXT Types"><code class="literal">TEXT</code></a> types,
                            <a class="link" href="data-types.html#enum" title="11.4.4&nbsp;The ENUM Type"><code class="literal">ENUM</code></a>,
                            <a class="link" href="data-types.html#set" title="11.4.5&nbsp;The SET Type"><code class="literal">SET</code></a>, and any synonyms) can
                            include <code class="literal">CHARACTER SET</code> to specify the
                            character set for the column. <code class="literal">CHARSET</code>
                            is a synonym for <code class="literal">CHARACTER SET</code>. A
                            collation for the character set can be specified with the
                            <code class="literal">COLLATE</code> attribute, along with any other
                            attributes. For details, see <a class="xref" href="charset.html" title="Chapter&nbsp;10&nbsp;Character Sets, Collations, Unicode">Chapter&nbsp;10, <i>Character Sets, Collations, Unicode</i></a>.
                            Example:
                        </p><p style="color:blue;">字符数据类型（char、varchar、文本类型、enum、set和任何同义词）可以包含字符集以指定列的字符集。字符集是字符集的同义词。字符集的排序规则可以与collate属性以及任何其他属性一起指定。有关详细信息，请参阅第10章，字符集，排序规则，Unicode。例子：</p><pre data-lang="sql" class="programlisting">CREATE TABLE t (c CHAR(20) CHARACTER SET utf8 COLLATE utf8_bin);
</pre><p>
                            MySQL 5.7 interprets length specifications in
                            character column definitions in characters. Lengths for
                            <a class="link" href="data-types.html#binary-varbinary" title="11.4.2&nbsp;The BINARY and VARBINARY Types"><code class="literal">BINARY</code></a> and
                            <a class="link" href="data-types.html#binary-varbinary" title="11.4.2&nbsp;The BINARY and VARBINARY Types"><code class="literal">VARBINARY</code></a> are in bytes.
                        </p><p style="color:blue;">mysql 5.7用字符解释字符列定义中的长度规范。binary和varbinary的长度以字节为单位。</p></li><li class="listitem"><p>
                            For <a class="link" href="data-types.html#char" title="11.4.1&nbsp;The CHAR and VARCHAR Types"><code class="literal">CHAR</code></a>,
                            <a class="link" href="data-types.html#char" title="11.4.1&nbsp;The CHAR and VARCHAR Types"><code class="literal">VARCHAR</code></a>,
                            <a class="link" href="data-types.html#binary-varbinary" title="11.4.2&nbsp;The BINARY and VARBINARY Types"><code class="literal">BINARY</code></a>, and
                            <a class="link" href="data-types.html#binary-varbinary" title="11.4.2&nbsp;The BINARY and VARBINARY Types"><code class="literal">VARBINARY</code></a> columns, indexes
                            can be created that use only the leading part of column
                            values, using
                            <code class="literal"><em class="replaceable"><code>col_name</code></em>(<em class="replaceable"><code>length</code></em>)</code>
                            syntax to specify an index prefix length.
                            <a class="link" href="data-types.html#blob" title="11.4.3&nbsp;The BLOB and TEXT Types"><code class="literal">BLOB</code></a> and
                            <a class="link" href="data-types.html#blob" title="11.4.3&nbsp;The BLOB and TEXT Types"><code class="literal">TEXT</code></a> columns also can be
                            indexed, but a prefix length <span class="emphasis"><em>must</em></span> be
                            given. Prefix lengths are given in characters for
                            nonbinary string types and in bytes for binary string
                            types. That is, index entries consist of the first
                            <em class="replaceable"><code>length</code></em> characters of each
                            column value for <a class="link" href="data-types.html#char" title="11.4.1&nbsp;The CHAR and VARCHAR Types"><code class="literal">CHAR</code></a>,
                            <a class="link" href="data-types.html#char" title="11.4.1&nbsp;The CHAR and VARCHAR Types"><code class="literal">VARCHAR</code></a>, and
                            <a class="link" href="data-types.html#blob" title="11.4.3&nbsp;The BLOB and TEXT Types"><code class="literal">TEXT</code></a> columns, and the first
                            <em class="replaceable"><code>length</code></em> bytes of each column
                            value for <a class="link" href="data-types.html#binary-varbinary" title="11.4.2&nbsp;The BINARY and VARBINARY Types"><code class="literal">BINARY</code></a>,
                            <a class="link" href="data-types.html#binary-varbinary" title="11.4.2&nbsp;The BINARY and VARBINARY Types"><code class="literal">VARBINARY</code></a>, and
                            <a class="link" href="data-types.html#blob" title="11.4.3&nbsp;The BLOB and TEXT Types"><code class="literal">BLOB</code></a> columns. Indexing only
                            a prefix of column values like this can make the index
                            file much smaller. For additional information about index
                            prefixes, see <a class="xref" href="sql-syntax.html#create-index" title="13.1.14&nbsp;CREATE INDEX Syntax">Section&nbsp;13.1.14, “CREATE INDEX Syntax”</a>.
                        </p><p style="color:blue;">对于char、varchar、binary和varbinary列，可以创建仅使用列值前导部分的索引，使用col_name（length）语法指定索引前缀长度。blob列和文本列也可以索引，但必须给定前缀长度。前缀长度以字符表示的非二进制字符串类型，以字节表示的二进制字符串类型。也就是说，索引项包含char、varchar和text列的每个列值的第一个长度字符，以及binary、varbinary和blob列的每个列值的第一个长度字节。仅索引这样的列值的前缀可以使索引文件小得多。有关索引前缀的其他信息，请参见第13.1.14节“创建索引语法”。</p><a class="indexterm" name="idm140286839303184"></a><a class="indexterm" name="idm140286839301696"></a><a class="indexterm" name="idm140286839300208"></a><a class="indexterm" name="idm140286839298720"></a><p>
                            Only the <code class="literal">InnoDB</code> and
                            <code class="literal">MyISAM</code> storage engines support indexing
                            on <a class="link" href="data-types.html#blob" title="11.4.3&nbsp;The BLOB and TEXT Types"><code class="literal">BLOB</code></a> and
                            <a class="link" href="data-types.html#blob" title="11.4.3&nbsp;The BLOB and TEXT Types"><code class="literal">TEXT</code></a> columns. For example:
                        </p><p style="color:blue;">只有NYNDB和MyISAM存储引擎支持对BLB和文本列的索引。例如：</p><pre data-lang="sql" class="programlisting">CREATE TABLE test (blob_col BLOB, INDEX(blob_col(10)));
</pre><p>
                            As of MySQL 5.7.17, if a specified index prefix exceeds
                            the maximum column data type size,
                            <a class="link" href="sql-syntax.html#create-table" title="13.1.18&nbsp;CREATE TABLE Syntax"><code class="literal">CREATE TABLE</code></a> handles the
                            index as follows:
                        </p><p style="color:blue;">对于MySQL 5.7.17，如果指定的索引前缀超过最大列数据类型大小，则CREATE表将按如下方式处理索引：</p>
                            <div class="itemizedlist">
                                <ul class="itemizedlist" style="list-style-type: square; "><li class="listitem"><p>
                                    For a nonunique index, either an error occurs (if
                                    strict SQL mode is enabled), or the index length is
                                    reduced to lie within the maximum column data type
                                    size and a warning is produced (if strict SQL mode is
                                    not enabled).
                                </p><p style="color:blue;">对于非唯一索引，要么发生错误（如果启用了严格SQL模式），或者将索引长度减少到最大列数据类型大小内，并产生警告（如果未启用严格SQL模式）。</p></li><li class="listitem"><p>
                                    For a unique index, an error occurs regardless of SQL
                                    mode because reducing the index length might enable
                                    insertion of nonunique entries that do not meet the
                                    specified uniqueness requirement.
                                </p><p style="color:blue;">对于唯一索引，无论SQL模式如何，都会发生错误，因为减小索引长度可能会插入不符合指定唯一性要求的非唯一项。</p></li></ul>
                            </div>
                        </li><li class="listitem"><p>
                            <a class="link" href="data-types.html#json" title="11.6&nbsp;The JSON Data Type"><code class="literal">JSON</code></a> columns cannot be
                            indexed. You can work around this restriction by creating
                            an index on a generated column that extracts a scalar
                            value from the <code class="literal">JSON</code> column. See
                            <a class="xref" href="sql-syntax.html#json-column-indirect-index" title="Indexing a Generated Column to Provide a JSON Column Index">Indexing a Generated Column to Provide a JSON Column Index</a>, for a
                            detailed example.
                        </p><p style="color:blue;">无法索引JSON列。通过在生成的列上创建索引（从json列提取标量值），可以绕过此限制。有关详细示例，请参阅索引生成的列以提供JSON列索引。</p></li></ul>
                    </div>
                </li><li class="listitem"><p>
                    <code class="literal">NOT NULL | NULL</code>
                </p><p style="color:blue;">非空空</p><p>
                    If neither <code class="literal">NULL</code> nor <code class="literal">NOT
                    NULL</code> is specified, the column is treated as though
                    <code class="literal">NULL</code> had been specified.
                </p><p style="color:blue;">如果既没有指定null也没有指定not null，则该列将被视为已指定null。</p><a class="indexterm" name="idm140286839279488"></a><a class="indexterm" name="idm140286839278000"></a><p>
                    In MySQL 5.7, only the <code class="literal">InnoDB</code>,
                    <code class="literal">MyISAM</code>, and <code class="literal">MEMORY</code>
                    storage engines support indexes on columns that can have
                    <code class="literal">NULL</code> values. In other cases, you must
                    declare indexed columns as <code class="literal">NOT NULL</code> or an
                    error results.
                </p><p style="color:blue;">在mysql 5.7中，只有innodb、myisam和内存存储引擎支持对可以有空值的列进行索引。在其他情况下，必须将索引列声明为非空或错误结果。</p></li><li class="listitem"><p>
                    <code class="literal">DEFAULT</code>
                </p><p style="color:blue;">违约</p><a class="indexterm" name="idm140286839270880"></a><a class="indexterm" name="idm140286839269808"></a><p>
                    Specifies a default value for a column. For more information
                    about default value handling, including the case that a column
                    definition includes no explicit <code class="literal">DEFAULT</code>
                    value, see <a class="xref" href="data-types.html#data-type-defaults" title="11.7&nbsp;Data Type Default Values">Section&nbsp;11.7, “Data Type Default Values”</a>.
                </p><p style="color:blue;">指定列的默认值。有关默认值处理的更多信息，包括列定义不包含显式默认值的情况，请参见第11.7节“数据类型默认值”。</p><p>
                    If the <a class="link" href="server-administration.html#sqlmode_no_zero_date"><code class="literal">NO_ZERO_DATE</code></a> or
                    <a class="link" href="server-administration.html#sqlmode_no_zero_in_date"><code class="literal">NO_ZERO_IN_DATE</code></a> SQL mode is
                    enabled and a date-valued default is not correct according to
                    that mode, <a class="link" href="sql-syntax.html#create-table" title="13.1.18&nbsp;CREATE TABLE Syntax"><code class="literal">CREATE TABLE</code></a>
                    produces a warning if strict SQL mode is not enabled and an
                    error if strict mode is enabled. For example, with
                    <a class="link" href="server-administration.html#sqlmode_no_zero_in_date"><code class="literal">NO_ZERO_IN_DATE</code></a> enabled,
                    <code class="literal">c1 DATE DEFAULT '2010-00-00'</code> produces a
                    warning.
                </p><p style="color:blue;">如果在日期SQL模式下启用了“无”零日期或“无”零日期，并且根据该模式，日期值默认值不正确，则CREATE TABLE在未启用严格SQL模式时生成警告，在启用严格模式时生成错误。例如，在启用“日期中没有”0“的情况下，C1日期默认值“2010-00-00”将生成警告。</p></li><li class="listitem"><p>
                    <code class="literal">AUTO_INCREMENT</code>
                </p><p style="color:blue;">自动递增</p><p>
                    An integer or floating-point column can have the additional
                    attribute <code class="literal">AUTO_INCREMENT</code>. When you insert a
                    value of <code class="literal">NULL</code> (recommended) or
                    <code class="literal">0</code> into an indexed
                    <code class="literal">AUTO_INCREMENT</code> column, the column is set to
                    the next sequence value. Typically this is
                    <code class="literal"><em class="replaceable"><code>value</code></em>+1</code>, where
                    <em class="replaceable"><code>value</code></em> is the largest value for the
                    column currently in the table.
                    <code class="literal">AUTO_INCREMENT</code> sequences begin with
                    <code class="literal">1</code>.
                </p><p style="color:blue;">整数列或浮点列可以具有附加属性auto_increment。在索引的自动递增列中插入空值（建议）或0时，该列将设置为下一个序列值。通常这是value+1，其中value是表中当前列的最大值。自动递增序列以1开头。</p><p>
                    To retrieve an <code class="literal">AUTO_INCREMENT</code> value after
                    inserting a row, use the
                    <a class="link" href="functions.html#function_last-insert-id"><code class="literal">LAST_INSERT_ID()</code></a> SQL function
                    or the <a class="link" href="connectors-apis.html#mysql-insert-id" title="27.8.7.38&nbsp;mysql_insert_id()"><code class="literal">mysql_insert_id()</code></a> C API
                    function. See <a class="xref" href="functions.html#information-functions" title="12.15&nbsp;Information Functions">Section&nbsp;12.15, “Information Functions”</a>, and
                    <a class="xref" href="connectors-apis.html#mysql-insert-id" title="27.8.7.38&nbsp;mysql_insert_id()">Section&nbsp;27.8.7.38, “mysql_insert_id()”</a>.
                </p><p style="color:blue;">要在插入行后检索自动增量值，请使用last_insert_id（）sql函数或mysql_insert_id（）c api函数。参见第12.15节“信息函数”和第27.8.7.38节“mysql_insert_id（）”。</p><p>
                    If the <a class="link" href="server-administration.html#sqlmode_no_auto_value_on_zero"><code class="literal">NO_AUTO_VALUE_ON_ZERO</code></a>
                    SQL mode is enabled, you can store <code class="literal">0</code> in
                    <code class="literal">AUTO_INCREMENT</code> columns as
                    <code class="literal">0</code> without generating a new sequence value.
                    See <a class="xref" href="server-administration.html#sql-mode" title="5.1.10&nbsp;Server SQL Modes">Section&nbsp;5.1.10, “Server SQL Modes”</a>.
                </p><p style="color:blue;">如果在“0”SQL模式下启用了“0”自动值，则可以将“0”存储在“0”自动递增列中，而无需生成新的序列值。参见第5.1.10节“服务器SQL模式”。</p><p>
                    There can be only one <code class="literal">AUTO_INCREMENT</code> column
                    per table, it must be indexed, and it cannot have a
                    <code class="literal">DEFAULT</code> value. An
                    <code class="literal">AUTO_INCREMENT</code> column works properly only
                    if it contains only positive values. Inserting a negative
                    number is regarded as inserting a very large positive number.
                    This is done to avoid precision problems when numbers
                    <span class="quote">“<span class="quote">wrap</span>”</span> over from positive to negative and also to
                    ensure that you do not accidentally get an
                    <code class="literal">AUTO_INCREMENT</code> column that contains
                    <code class="literal">0</code>.
                </p><p style="color:blue;">每个表只能有一个自动递增列，它必须被索引，并且不能有默认值。“自动递增”列只有在只包含正值时才能正常工作。插入负数被视为插入一个非常大的正数。这样做是为了避免数字从正数“换行”到负数时出现精度问题，并确保不会意外获得包含0的自动递增列。</p><p>
                    For <code class="literal">MyISAM</code> tables, you can specify an
                    <code class="literal">AUTO_INCREMENT</code> secondary column in a
                    multiple-column key. See
                    <a class="xref" href="tutorial.html#example-auto-increment" title="3.6.9&nbsp;Using AUTO_INCREMENT">Section&nbsp;3.6.9, “Using AUTO_INCREMENT”</a>.
                </p><p style="color:blue;">对于myisam表，可以在多列键中指定自动递增辅助列。见第3.6.9节“使用自动增量”。</p><p>
                    To make MySQL compatible with some ODBC applications, you can
                    find the <code class="literal">AUTO_INCREMENT</code> value for the last
                    inserted row with the following query:
                </p><p style="color:blue;">要使mysql与某些odbc应用程序兼容，可以使用以下查询查找最后插入行的自动增量值：</p><a class="indexterm" name="idm140286839234176"></a><a class="indexterm" name="idm140286839233104"></a><pre data-lang="sql" class="programlisting">SELECT * FROM <em class="replaceable"><code>tbl_name</code></em> WHERE <em class="replaceable"><code>auto_col</code></em> IS NULL
</pre><p>
                    This method requires that
                    <a class="link" href="server-administration.html#sysvar_sql_auto_is_null"><code class="literal">sql_auto_is_null</code></a> variable is
                    not set to 0. See <a class="xref" href="server-administration.html#server-system-variables" title="5.1.7&nbsp;Server System Variables">Section&nbsp;5.1.7, “Server System Variables”</a>.
                </p><p style="color:blue;">此方法要求sql_auto_is_null变量未设置为0。见第5.1.7节“服务器系统变量”。</p><p>
                    For information about <code class="literal">InnoDB</code> and
                    <code class="literal">AUTO_INCREMENT</code>, see
                    <a class="xref" href="innodb-storage-engine.html#innodb-auto-increment-handling" title="14.6.1.4&nbsp;AUTO_INCREMENT Handling in InnoDB">Section&nbsp;14.6.1.4, “AUTO_INCREMENT Handling in InnoDB”</a>. For
                    information about <code class="literal">AUTO_INCREMENT</code> and MySQL
                    Replication, see
                    <a class="xref" href="replication.html#replication-features-auto-increment" title="16.4.1.1&nbsp;Replication and AUTO_INCREMENT">Section&nbsp;16.4.1.1, “Replication and AUTO_INCREMENT”</a>.
                </p><p style="color:blue;">有关InnoDB和自动增量的信息，请参阅第14.6.1.4节“InnoDB中的自动增量处理”。有关自动增量和mysql复制的信息，请参阅第16.4.1.1节“复制和自动增量”。</p></li><li class="listitem"><p>
                    <code class="literal">COMMENT</code>
                </p><p style="color:blue;">评论</p><a class="indexterm" name="idm140286839221856"></a><p>
                    A comment for a column can be specified with the
                    <code class="literal">COMMENT</code> option, up to 1024 characters long.
                    The comment is displayed by the <a class="link" href="sql-syntax.html#show-create-table" title="13.7.5.10&nbsp;SHOW CREATE TABLE Syntax"><code class="literal">SHOW
                    CREATE TABLE</code></a> and
                    <a class="link" href="sql-syntax.html#show-columns" title="13.7.5.5&nbsp;SHOW COLUMNS Syntax"><code class="literal">SHOW FULL
                        COLUMNS</code></a> statements.
                </p><p style="color:blue;">可以使用comment选项指定列的注释，最长可达1024个字符。注释由show create table和show full columns语句显示。</p></li><li class="listitem"><p>
                    <code class="literal">COLUMN_FORMAT</code>
                </p><p style="color:blue;">列格式</p><a class="indexterm" name="idm140286839215632"></a><p>
                    In NDB Cluster, it is also possible to specify a data storage
                    format for individual columns of
                    <a class="link" href="mysql-cluster.html" title="Chapter&nbsp;21&nbsp;MySQL NDB Cluster 7.5 and NDB Cluster 7.6"><code class="literal">NDB</code></a> tables using
                    <code class="literal">COLUMN_FORMAT</code>. Permissible column formats
                    are <code class="literal">FIXED</code>, <code class="literal">DYNAMIC</code>, and
                    <code class="literal">DEFAULT</code>. <code class="literal">FIXED</code> is used
                    to specify fixed-width storage, <code class="literal">DYNAMIC</code>
                    permits the column to be variable-width, and
                    <code class="literal">DEFAULT</code> causes the column to use
                    fixed-width or variable-width storage as determined by the
                    column's data type (possibly overridden by a
                    <code class="literal">ROW_FORMAT</code> specifier).
                </p><p style="color:blue;">在ndb集群中，也可以使用column_格式为ndb表的各个列指定数据存储格式。允许的列格式是固定的、动态的和默认的。fixed用于指定固定宽度存储，dynamic允许列为可变宽度，而default则使列使用由列的数据类型（可能由行格式说明符重写）确定的固定宽度或可变宽度存储。</p><p>
                    Beginning with MySQL NDB Cluster 7.5.4, for
                    <a class="link" href="mysql-cluster.html" title="Chapter&nbsp;21&nbsp;MySQL NDB Cluster 7.5 and NDB Cluster 7.6"><code class="literal">NDB</code></a> tables, the default value for
                    <code class="literal">COLUMN_FORMAT</code> is <code class="literal">FIXED</code>.
                    (The default had been switched to <code class="literal">DYNAMIC</code>
                    in MySQL NDB Cluster 7.5.1, but this change was reverted to
                    maintain backwards compatibility with existing GA release
                    series.) (Bug #24487363)
                </p><p style="color:blue;">从mysql ndb cluster 7.5.4开始，对于ndb表，column_格式的默认值是固定的。（默认情况下，在MySQL NDB集群7.5.1中已切换为动态的，但这种更改被恢复为与现有的GA发布系列保持向后兼容）。</p><p>
                    In NDB Cluster, the maximum possible offset for a column
                    defined with <code class="literal">COLUMN_FORMAT=FIXED</code> is 8188
                    bytes. For more information and possible workarounds, see
                    <a class="xref" href="mysql-cluster.html#mysql-cluster-limitations-database-objects" title="21.1.7.5&nbsp;Limits Associated with Database Objects in NDB Cluster">Section&nbsp;21.1.7.5, “Limits Associated with Database Objects in NDB Cluster”</a>.
                </p><p style="color:blue;">在NDB集群中，用柱状格式定义的列的最大可能偏移量为8188字节。有关更多信息和可能的解决方法，请参阅第21.1.7.5节“与ndb集群中的数据库对象关联的限制”。</p><p>
                    <code class="literal">COLUMN_FORMAT</code> currently has no effect on
                    columns of tables using storage engines other than
                    <a class="link" href="mysql-cluster.html" title="Chapter&nbsp;21&nbsp;MySQL NDB Cluster 7.5 and NDB Cluster 7.6"><code class="literal">NDB</code></a>. In MySQL 5.7
                    and later, <code class="literal">COLUMN_FORMAT</code> is silently
                    ignored.
                </p><p style="color:blue;">column_格式当前对使用ndb以外的存储引擎的表的列没有影响。在mysql 5.7及更高版本中，列的格式被忽略。</p></li><li class="listitem"><p>
                    <code class="literal">STORAGE</code>
                </p><p style="color:blue;">储存</p><a class="indexterm" name="idm140286839196192"></a><p>
                    For <a class="link" href="mysql-cluster.html" title="Chapter&nbsp;21&nbsp;MySQL NDB Cluster 7.5 and NDB Cluster 7.6"><code class="literal">NDB</code></a> tables, it is possible to
                    specify whether the column is stored on disk or in memory by
                    using a <code class="literal">STORAGE</code> clause. <code class="literal">STORAGE
                    DISK</code> causes the column to be stored on disk, and
                    <code class="literal">STORAGE MEMORY</code> causes in-memory storage to
                    be used. The <a class="link" href="sql-syntax.html#create-table" title="13.1.18&nbsp;CREATE TABLE Syntax"><code class="literal">CREATE TABLE</code></a>
                    statement used must still include a
                    <code class="literal">TABLESPACE</code> clause:
                </p><p style="color:blue;">对于ndb表，可以使用存储子句指定列是存储在磁盘上还是存储在内存中。存储磁盘导致列存储在磁盘上，存储内存导致使用内存中的存储。使用的CREATE TABLE语句仍必须包含TABLESPACE子句：</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>CREATE TABLE t1 (</code></strong>
    -&gt;     <strong class="userinput"><code>c1 INT STORAGE DISK,</code></strong>
    -&gt;     <strong class="userinput"><code>c2 INT STORAGE MEMORY</code></strong>
    -&gt; <strong class="userinput"><code>) ENGINE NDB;</code></strong>
<span class="errortext">ERROR 1005 (HY000): Can't create table 'c.t1' (errno: 140)</span>

mysql&gt; <strong class="userinput"><code>CREATE TABLE t1 (</code></strong>
    -&gt;     <strong class="userinput"><code>c1 INT STORAGE DISK,</code></strong>
    -&gt;     <strong class="userinput"><code>c2 INT STORAGE MEMORY</code></strong>
    -&gt; <strong class="userinput"><code>) TABLESPACE ts_1 ENGINE NDB;</code></strong>
Query OK, 0 rows affected (1.06 sec)
</pre><p>
                    For <a class="link" href="mysql-cluster.html" title="Chapter&nbsp;21&nbsp;MySQL NDB Cluster 7.5 and NDB Cluster 7.6"><code class="literal">NDB</code></a> tables, <code class="literal">STORAGE
                    DEFAULT</code> is equivalent to <code class="literal">STORAGE
                    MEMORY</code>.
                </p><p style="color:blue;">对于ndb表，存储默认值相当于存储内存。</p><p>
                    The <code class="literal">STORAGE</code> clause has no effect on tables
                    using storage engines other than
                    <a class="link" href="mysql-cluster.html" title="Chapter&nbsp;21&nbsp;MySQL NDB Cluster 7.5 and NDB Cluster 7.6"><code class="literal">NDB</code></a>. The
                    <code class="literal">STORAGE</code> keyword is supported only in the
                    build of <a class="link" href="programs.html#mysqld" title="4.3.1&nbsp;mysqld — The MySQL Server"><span class="command"><strong>mysqld</strong></span></a> that is supplied with NDB
                    Cluster; it is not recognized in any other version of MySQL,
                    where any attempt to use the <code class="literal">STORAGE</code>
                    keyword causes a syntax error.
                </p><p style="color:blue;">storage子句对使用ndb以外的存储引擎的表没有影响。存储关键字仅在随ndb cluster提供的mysqld版本中受支持；在任何其他版本的mysql中都无法识别该关键字，因为任何尝试使用存储关键字都会导致语法错误。</p></li><li class="listitem"><p>
                    <code class="literal">GENERATED ALWAYS</code>
                </p><p style="color:blue;">始终生成</p><p>
                    Used to specify a generated column expression. For information
                    about <a class="link" href="glossary.html#glos_generated_column" title="generated column">generated
                    columns</a>, see
                    <a class="xref" href="sql-syntax.html#create-table-generated-columns" title="13.1.18.8&nbsp;CREATE TABLE and Generated Columns">Section&nbsp;13.1.18.8, “CREATE TABLE and Generated Columns”</a>.
                </p><p style="color:blue;">用于指定生成的列表达式。有关生成列的信息，请参见第13.1.18.8节“创建表和生成列”。</p><p>
                    <a class="link" href="glossary.html#glos_stored_generated_column" title="stored generated column">Stored generated
                        columns</a> can be indexed. <code class="literal">InnoDB</code>
                    supports secondary indexes on
                    <a class="link" href="glossary.html#glos_virtual_generated_column" title="virtual generated column">virtual
                        generated columns</a>. See
                    <a class="xref" href="sql-syntax.html#create-table-secondary-indexes" title="13.1.18.9&nbsp;Secondary Indexes and Generated Columns">Section&nbsp;13.1.18.9, “Secondary Indexes and Generated Columns”</a>.
                </p><p style="color:blue;">存储的生成列可以被索引。innodb支持虚拟生成列的二级索引。见第13.1.18.9节，“二级索引和生成列”。</p></li></ul>
            </div>
            <h4><a name="create-table-indexes-keys"></a>Indexes and Foreign Keys</h4>
            <p>
                Several keywords apply to creation of indexes and foreign keys.
                For general background in addition to the following descriptions,
                see <a class="xref" href="sql-syntax.html#create-index" title="13.1.14&nbsp;CREATE INDEX Syntax">Section&nbsp;13.1.14, “CREATE INDEX Syntax”</a>, and
                <a class="xref" href="sql-syntax.html#create-table-foreign-keys" title="13.1.18.6&nbsp;Using FOREIGN KEY Constraints">Section&nbsp;13.1.18.6, “Using FOREIGN KEY Constraints”</a>.
            </p><p style="color:blue;">有几个关键字适用于索引和外键的创建。除以下描述外，有关一般背景信息，请参见第13.1.14节“创建索引语法”和第13.1.18.6节“使用外键约束”。</p>
            <div class="itemizedlist">
                <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                    <code class="literal">CONSTRAINT
                        <em class="replaceable"><code>symbol</code></em></code>
                </p><p style="color:blue;">约束符号</p><p>
                    The <code class="literal">CONSTRAINT
                    <em class="replaceable"><code>symbol</code></em></code> clause may be
                    given to name a constraint. If the clause is not given, or a
                    <em class="replaceable"><code>symbol</code></em> is not included following
                    the <code class="literal">CONSTRAINT</code> keyword, MySQL automatically
                    generates a constraint name, with the exception noted below.
                    The <em class="replaceable"><code>symbol</code></em> value, if used, must be
                    unique per schema (database), per constraint type. A duplicate
                    <em class="replaceable"><code>symbol</code></em> results in an error.
                </p><p style="color:blue;">可以给constraint symbol子句命名约束。如果没有给定子句，或者约束关键字后面没有包含符号，mysql将自动生成约束名称，但下面指出的例外情况除外。符号值（如果使用）对于每个架构（数据库）、每个约束类型必须是唯一的。重复的符号会导致错误。</p>
                    <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">

                        <div class="admon-title">
                            Note
                        </div>
                        <p>
                            If the <code class="literal">CONSTRAINT
                            <em class="replaceable"><code>symbol</code></em></code> clause is not
                            given in a foreign key definition, or a
                            <em class="replaceable"><code>symbol</code></em> is not included following
                            the <code class="literal">CONSTRAINT</code> keyword,
                            <a class="link" href="mysql-cluster.html" title="Chapter&nbsp;21&nbsp;MySQL NDB Cluster 7.5 and NDB Cluster 7.6"><code class="literal">NDB</code></a> uses the foreign key index
                            name.
                        </p><p style="color:blue;">如果外键定义中没有给出约束符号子句，或者约束关键字后面没有包含符号，则ndb使用外键索引名。</p>
                    </div>
                    <p>
                        The SQL standard specifies that all types of constraints
                        (primary key, unique index, foreign key, check) belong to the
                        same namespace. In MySQL, each constraint type has its own
                        namespace per schema. Consequently, names for each type of
                        constraint must be unique per schema.
                    </p><p style="color:blue;">SQL标准指定所有类型的约束（主键、唯一索引、外键、检查）都属于同一命名空间。在mysql中，每个约束类型在每个模式中都有自己的命名空间。因此，每种类型的约束的名称对于每个架构都必须是唯一的。</p></li><li class="listitem"><p>
                    <code class="literal">PRIMARY KEY</code>
                </p><p style="color:blue;">主键</p><a class="indexterm" name="idm140286839150624"></a><p>
                    A unique index where all key columns must be defined as
                    <code class="literal">NOT NULL</code>. If they are not explicitly
                    declared as <code class="literal">NOT NULL</code>, MySQL declares them
                    so implicitly (and silently). A table can have only one
                    <code class="literal">PRIMARY KEY</code>. The name of a <code class="literal">PRIMARY
                    KEY</code> is always <code class="literal">PRIMARY</code>, which thus
                    cannot be used as the name for any other kind of index.
                </p><p style="color:blue;">必须将所有键列定义为非空的唯一索引。如果它们没有显式地声明为not null，mysql会隐式地（和静默地）声明它们。一个表只能有一个主键。主键的名称始终是primary，因此不能用作任何其他类型索引的名称。</p><p>
                    If you do not have a <code class="literal">PRIMARY KEY</code> and an
                    application asks for the <code class="literal">PRIMARY KEY</code> in
                    your tables, MySQL returns the first <code class="literal">UNIQUE</code>
                    index that has no <code class="literal">NULL</code> columns as the
                    <code class="literal">PRIMARY KEY</code>.
                </p><p style="color:blue;">如果没有主键，并且应用程序要求表中的主键，mysql将返回第一个没有空列作为主键的唯一索引。</p><p>
                    In <code class="literal">InnoDB</code> tables, keep the <code class="literal">PRIMARY
                    KEY</code> short to minimize storage overhead for secondary
                    indexes. Each secondary index entry contains a copy of the
                    primary key columns for the corresponding row. (See
                    <a class="xref" href="innodb-storage-engine.html#innodb-index-types" title="14.6.2.1&nbsp;Clustered and Secondary Indexes">Section&nbsp;14.6.2.1, “Clustered and Secondary Indexes”</a>.)
                </p><p style="color:blue;">在innodb表中，保持主键较短，以最小化辅助索引的存储开销。每个辅助索引项都包含对应行的主键列的副本。（见第14.6.2.1节，“聚集索引和二级索引”。）</p><p>
                    In the created table, a <code class="literal">PRIMARY KEY</code> is
                    placed first, followed by all <code class="literal">UNIQUE</code>
                    indexes, and then the nonunique indexes. This helps the MySQL
                    optimizer to prioritize which index to use and also more
                    quickly to detect duplicated <code class="literal">UNIQUE</code> keys.
                </p><p style="color:blue;">在创建的表中，首先放置主键，然后放置所有唯一索引，然后放置非唯一索引。这有助于mysql优化器确定要使用哪个索引的优先级，并更快地检测重复的唯一键。</p><p>
                    A <code class="literal">PRIMARY KEY</code> can be a multiple-column
                    index. However, you cannot create a multiple-column index
                    using the <code class="literal">PRIMARY KEY</code> key attribute in a
                    column specification. Doing so only marks that single column
                    as primary. You must use a separate <code class="literal">PRIMARY
                    KEY(<em class="replaceable"><code>key_part</code></em>, ...)</code>
                    clause.
                </p><p style="color:blue;">主键可以是多列索引。但是，不能使用列规范中的主键属性创建多列索引。这样做只会将该列标记为主列。必须使用单独的主键（key_part，…）子句。</p><a class="indexterm" name="idm140286839132416"></a><p>
                    If a table has a <code class="literal">PRIMARY KEY</code> or
                    <code class="literal">UNIQUE NOT NULL</code> index that consists of a
                    single column that has an integer type, you can use
                    <code class="literal">_rowid</code> to refer to the indexed column in
                    <a class="link" href="sql-syntax.html#select" title="13.2.9&nbsp;SELECT Syntax"><code class="literal">SELECT</code></a> statements, as described
                    in <a class="xref" href="sql-syntax.html#create-index-unique" title="Unique Indexes">Unique Indexes</a>.
                </p><p style="color:blue;">如果表具有主键或由整数类型的单个列组成的唯一非空索引，则可以使用rowid引用select语句中的索引列，如unique indexes中所述。</p><p>
                    In MySQL, the name of a <code class="literal">PRIMARY KEY</code> is
                    <code class="literal">PRIMARY</code>. For other indexes, if you do not
                    assign a name, the index is assigned the same name as the
                    first indexed column, with an optional suffix
                    (<code class="literal">_2</code>, <code class="literal">_3</code>,
                    <code class="literal">...</code>) to make it unique. You can see index
                    names for a table using <code class="literal">SHOW INDEX FROM
                    <em class="replaceable"><code>tbl_name</code></em></code>. See
                    <a class="xref" href="sql-syntax.html#show-index" title="13.7.5.22&nbsp;SHOW INDEX Syntax">Section&nbsp;13.7.5.22, “SHOW INDEX Syntax”</a>.
                </p><p style="color:blue;">在mysql中，主键的名称是primary。对于其他索引，如果不指定名称，则将为索引指定与第一个索引列相同的名称，并使用可选后缀（_2，_3，…）使其唯一。可以使用show index from tbl_name查看表的索引名。见第13.7.5.22节“显示索引语法”。</p></li><li class="listitem"><p>
                    <code class="literal">KEY | INDEX</code>
                </p><p style="color:blue;">键索引</p><p>
                    <code class="literal">KEY</code> is normally a synonym for
                    <code class="literal">INDEX</code>. The key attribute <code class="literal">PRIMARY
                    KEY</code> can also be specified as just
                    <code class="literal">KEY</code> when given in a column definition. This
                    was implemented for compatibility with other database systems.
                </p><p style="color:blue;">键通常是索引的同义词。在列定义中给定时，键属性主键也可以指定为just key。这是为了与其他数据库系统兼容而实现的。</p></li><li class="listitem"><p>
                    <code class="literal">UNIQUE</code>
                </p><p style="color:blue;">独特的</p><p>
                    A <code class="literal">UNIQUE</code> index creates a constraint such
                    that all values in the index must be distinct. An error occurs
                    if you try to add a new row with a key value that matches an
                    existing row. For all engines, a <code class="literal">UNIQUE</code>
                    index permits multiple <code class="literal">NULL</code> values for
                    columns that can contain <code class="literal">NULL</code>. If you
                    specify a prefix value for a column in a
                    <code class="literal">UNIQUE</code> index, the column values must be
                    unique within the prefix length.
                </p><p style="color:blue;">唯一索引创建一个约束，使得索引中的所有值都必须是不同的。如果尝试添加具有与现有行匹配的键值的新行，则会发生错误。对于所有引擎，唯一索引允许包含空值的列有多个空值。如果在唯一索引中为列指定前缀值，则列值在前缀长度内必须是唯一的。</p><a class="indexterm" name="idm140286839109728"></a><p>
                    If a table has a <code class="literal">PRIMARY KEY</code> or
                    <code class="literal">UNIQUE NOT NULL</code> index that consists of a
                    single column that has an integer type, you can use
                    <code class="literal">_rowid</code> to refer to the indexed column in
                    <a class="link" href="sql-syntax.html#select" title="13.2.9&nbsp;SELECT Syntax"><code class="literal">SELECT</code></a> statements, as described
                    in <a class="xref" href="sql-syntax.html#create-index-unique" title="Unique Indexes">Unique Indexes</a>.
                </p><p style="color:blue;">如果表具有主键或由整数类型的单个列组成的唯一非空索引，则可以使用rowid引用select语句中的索引列，如unique indexes中所述。</p></li><li class="listitem"><p>
                    <code class="literal">FULLTEXT</code>
                </p><p style="color:blue;">全文</p><p>
                    A <code class="literal">FULLTEXT</code> index is a special type of index
                    used for full-text searches. Only the
                    <a class="link" href="innodb-storage-engine.html" title="Chapter&nbsp;14&nbsp;The InnoDB Storage Engine"><code class="literal">InnoDB</code></a> and
                    <a class="link" href="storage-engines.html#myisam-storage-engine" title="15.2&nbsp;The MyISAM Storage Engine"><code class="literal">MyISAM</code></a> storage engines support
                    <code class="literal">FULLTEXT</code> indexes. They can be created only
                    from <a class="link" href="data-types.html#char" title="11.4.1&nbsp;The CHAR and VARCHAR Types"><code class="literal">CHAR</code></a>,
                    <a class="link" href="data-types.html#char" title="11.4.1&nbsp;The CHAR and VARCHAR Types"><code class="literal">VARCHAR</code></a>, and
                    <a class="link" href="data-types.html#blob" title="11.4.3&nbsp;The BLOB and TEXT Types"><code class="literal">TEXT</code></a> columns. Indexing always
                    happens over the entire column; column prefix indexing is not
                    supported and any prefix length is ignored if specified. See
                    <a class="xref" href="functions.html#fulltext-search" title="12.9&nbsp;Full-Text Search Functions">Section&nbsp;12.9, “Full-Text Search Functions”</a>, for details of operation. A
                    <code class="literal">WITH PARSER</code> clause can be specified as an
                    <em class="replaceable"><code>index_option</code></em> value to associate a
                    parser plugin with the index if full-text indexing and
                    searching operations need special handling. This clause is
                    valid only for <code class="literal">FULLTEXT</code> indexes. Both
                    <a class="link" href="innodb-storage-engine.html" title="Chapter&nbsp;14&nbsp;The InnoDB Storage Engine"><code class="literal">InnoDB</code></a> and
                    <a class="link" href="storage-engines.html#myisam-storage-engine" title="15.2&nbsp;The MyISAM Storage Engine"><code class="literal">MyISAM</code></a> support full-text parser
                    plugins. See <a class="xref" href="extending-mysql.html#full-text-plugin-type" title="Full-Text Parser Plugins">Full-Text Parser Plugins</a> and
                    <a class="xref" href="extending-mysql.html#writing-full-text-plugins" title="28.2.4.4&nbsp;Writing Full-Text Parser Plugins">Section&nbsp;28.2.4.4, “Writing Full-Text Parser Plugins”</a> for more
                    information.
                </p><p style="color:blue;">全文索引是用于全文搜索的特殊索引类型。只有innodb和myisam存储引擎支持全文索引。它们只能从char、varchar和text列创建。索引始终在整个列上发生；不支持列前缀索引，如果指定了任何前缀长度，则忽略。有关操作的详细信息，请参见第12.9节“全文搜索功能”。如果全文索引和搜索操作需要特殊处理，可以将带分析器子句指定为Index选项选项，以将解析器插件与索引关联。此子句仅对全文索引有效。innodb和myisam都支持全文解析器插件。有关详细信息，请参阅全文解析器插件和第28.2.4.4节“编写全文解析器插件”。</p></li><li class="listitem"><p>
                    <code class="literal">SPATIAL</code>
                </p><p style="color:blue;">空间</p><p>
                    You can create <code class="literal">SPATIAL</code> indexes on spatial
                    data types. Spatial types are supported only for
                    <code class="literal">MyISAM</code> and <code class="literal">InnoDB</code>
                    tables, and indexed columns must be declared as <code class="literal">NOT
                    NULL</code>. See <a class="xref" href="data-types.html#spatial-types" title="11.5&nbsp;Spatial Data Types">Section&nbsp;11.5, “Spatial Data Types”</a>.
                </p><p style="color:blue;">可以在空间数据类型上创建空间索引。只有myisam和innodb表才支持空间类型，索引列必须声明为非空。见第11.5节“空间数据类型”。</p></li><li class="listitem"><p>
                    <code class="literal">FOREIGN KEY</code>
                </p><p style="color:blue;">外键</p><p>
                    MySQL supports foreign keys, which let you cross-reference
                    related data across tables, and foreign key constraints, which
                    help keep this spread-out data consistent. For definition and
                    option information, see
                    <a class="link" href="sql-syntax.html#create-table-reference-definition"><em class="replaceable"><code>reference_definition</code></em></a>,
                    and
                    <a class="link" href="sql-syntax.html#create-table-reference-option"><em class="replaceable"><code>reference_option</code></em></a>.
                </p><p style="color:blue;">mysql支持外键，它允许跨表交叉引用相关数据，以及外键约束，这有助于保持这种分散数据的一致性。有关定义和选项信息，请参见参考定义和参考选项。</p><p>
                    Partitioned tables employing the
                    <a class="link" href="innodb-storage-engine.html" title="Chapter&nbsp;14&nbsp;The InnoDB Storage Engine"><code class="literal">InnoDB</code></a> storage engine do not
                    support foreign keys. See
                    <a class="xref" href="partitioning.html#partitioning-limitations" title="22.6&nbsp;Restrictions and Limitations on Partitioning">Section&nbsp;22.6, “Restrictions and Limitations on Partitioning”</a>, for more
                    information.
                </p><p style="color:blue;">使用innodb存储引擎的分区表不支持外键。有关更多信息，请参阅第22.6节“分区限制和限制”。</p></li><li class="listitem"><p>
                    <code class="literal">CHECK</code>
                </p><p style="color:blue;">支票</p><p>
                    The <code class="literal">CHECK</code> clause is parsed but ignored by
                    all storage engines.
                </p><p style="color:blue;">check子句已被分析，但被所有存储引擎忽略。</p></li><li class="listitem"><p>
                    <code class="literal"><em class="replaceable"><code>key_part</code></em></code>
                </p><p style="color:blue;">关键部分</p>
                    <div class="itemizedlist">
                        <ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
                            A <em class="replaceable"><code>key_part</code></em> specification can
                            end with <code class="literal">ASC</code> or
                            <code class="literal">DESC</code>. These keywords are permitted for
                            future extensions for specifying ascending or descending
                            index value storage. Currently, they are parsed but
                            ignored; index values are always stored in ascending
                            order.
                        </p><p style="color:blue;">键部件规范可以以asc或desc结尾。这些关键字可用于将来指定升序或降序索引值存储的扩展。目前，它们被解析但被忽略；索引值总是按升序存储。</p></li><li class="listitem"><p>
                            Prefixes, defined by the <em class="replaceable"><code>length</code></em>
                            attribute, can be up to 767 bytes long for
                            <code class="literal">InnoDB</code> tables or 3072 bytes if the
                            <a class="link" href="innodb-storage-engine.html#sysvar_innodb_large_prefix"><code class="literal">innodb_large_prefix</code></a>
                            option is enabled. For <code class="literal">MyISAM</code> tables,
                            the prefix length limit is 1000 bytes.
                        </p><p style="color:blue;">由length属性定义的前缀对于innodb表可以是767字节长，如果启用innodb_large_prefix选项，则可以是3072字节长。对于myisam表，前缀长度限制为1000字节。</p><p>
                            Prefix <span class="emphasis"><em>limits</em></span> are measured in bytes.
                            However, prefix <span class="emphasis"><em>lengths</em></span> for index
                            specifications in <a class="link" href="sql-syntax.html#create-table" title="13.1.18&nbsp;CREATE TABLE Syntax"><code class="literal">CREATE
                            TABLE</code></a>, <a class="link" href="sql-syntax.html#alter-table" title="13.1.8&nbsp;ALTER TABLE Syntax"><code class="literal">ALTER
                            TABLE</code></a>, and <a class="link" href="sql-syntax.html#create-index" title="13.1.14&nbsp;CREATE INDEX Syntax"><code class="literal">CREATE
                            INDEX</code></a> statements are interpreted as number of
                            characters for nonbinary string types
                            (<a class="link" href="data-types.html#char" title="11.4.1&nbsp;The CHAR and VARCHAR Types"><code class="literal">CHAR</code></a>,
                            <a class="link" href="data-types.html#char" title="11.4.1&nbsp;The CHAR and VARCHAR Types"><code class="literal">VARCHAR</code></a>,
                            <a class="link" href="data-types.html#blob" title="11.4.3&nbsp;The BLOB and TEXT Types"><code class="literal">TEXT</code></a>) and number of bytes
                            for binary string types
                            (<a class="link" href="data-types.html#binary-varbinary" title="11.4.2&nbsp;The BINARY and VARBINARY Types"><code class="literal">BINARY</code></a>,
                            <a class="link" href="data-types.html#binary-varbinary" title="11.4.2&nbsp;The BINARY and VARBINARY Types"><code class="literal">VARBINARY</code></a>,
                            <a class="link" href="data-types.html#blob" title="11.4.3&nbsp;The BLOB and TEXT Types"><code class="literal">BLOB</code></a>). Take this into
                            account when specifying a prefix length for a nonbinary
                            string column that uses a multibyte character set.
                        </p><p style="color:blue;">前缀限制以字节为单位。但是，CREATE TABLE、ALTER TABLE和CREATE INDEX语句中索引规范的前缀长度解释为非二进制字符串类型（char、varchar、text）的字符数和二进制字符串类型（binary、varbinary、blob）的字节数。在为使用多字节字符集的非二进制字符串列指定前缀长度时，请考虑此问题。</p></li></ul>
                    </div>
                </li><li class="listitem"><p>
                    <code class="literal"><em class="replaceable"><code>index_type</code></em></code>
                </p><p style="color:blue;">索引类型</p><p>
                    Some storage engines permit you to specify an index type when
                    creating an index. The syntax for the
                    <em class="replaceable"><code>index_type</code></em> specifier is
                    <code class="literal">USING <em class="replaceable"><code>type_name</code></em></code>.
                </p><p style="color:blue;">某些存储引擎允许您在创建索引时指定索引类型。索引类型说明符的语法使用类型名称。</p><p>
                    Example:
                </p><p style="color:blue;">例子：</p><pre data-lang="sql" class="programlisting">CREATE TABLE lookup
  (id INT, INDEX USING BTREE (id))
  ENGINE = MEMORY;
</pre><p>
                    The preferred position for <code class="literal">USING</code> is after
                    the index column list. It can be given before the column list,
                    but support for use of the option in that position is
                    deprecated and will be removed in a future MySQL release.
                </p><p style="color:blue;">使用的首选位置在索引列列表之后。它可以在列列表之前给出，但不赞成在该位置使用该选项，并且将在以后的mysql版本中删除。</p></li><li class="listitem"><p>
                    <code class="literal"><em class="replaceable"><code>index_option</code></em></code>
                </p><p style="color:blue;">索引选项</p><p>
                    <em class="replaceable"><code>index_option</code></em> values specify
                    additional options for an index.
                </p><p style="color:blue;">索引选项值指定索引的其他选项。</p>
                    <div class="itemizedlist">
                        <ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
                            <code class="literal">KEY_BLOCK_SIZE</code>
                        </p><p style="color:blue;">关键块大小</p><p>
                            For <a class="link" href="storage-engines.html#myisam-storage-engine" title="15.2&nbsp;The MyISAM Storage Engine"><code class="literal">MyISAM</code></a> tables,
                            <code class="literal">KEY_BLOCK_SIZE</code> optionally specifies the
                            size in bytes to use for index key blocks. The value is
                            treated as a hint; a different size could be used if
                            necessary. A <code class="literal">KEY_BLOCK_SIZE</code> value
                            specified for an individual index definition overrides the
                            table-level <code class="literal">KEY_BLOCK_SIZE</code> value.
                        </p><p style="color:blue;">对于myisam表，key-block-size可以选择指定索引键块所用的字节大小。该值被视为提示；如果需要，可以使用不同的大小。为单个索引定义指定的键块大小值将替代表级键块大小值。</p><p>
                            For information about the table-level
                            <code class="literal">KEY_BLOCK_SIZE</code> attribute, see
                            <a class="xref" href="sql-syntax.html#create-table-options" title="Table Options">Table Options</a>.
                        </p><p style="color:blue;">有关表级关键字块大小属性的信息，请参见表选项。</p></li><li class="listitem"><p>
                            <code class="literal">WITH PARSER</code>
                        </p><p style="color:blue;">带解析器</p><p>
                            The <code class="literal">WITH PARSER</code> option can only be used
                            with <code class="literal">FULLTEXT</code> indexes. It associates a
                            parser plugin with the index if full-text indexing and
                            searching operations need special handling. Both
                            <a class="link" href="innodb-storage-engine.html" title="Chapter&nbsp;14&nbsp;The InnoDB Storage Engine"><code class="literal">InnoDB</code></a> and
                            <a class="link" href="storage-engines.html#myisam-storage-engine" title="15.2&nbsp;The MyISAM Storage Engine"><code class="literal">MyISAM</code></a> support full-text
                            parser plugins. If you have a
                            <a class="link" href="storage-engines.html#myisam-storage-engine" title="15.2&nbsp;The MyISAM Storage Engine"><code class="literal">MyISAM</code></a> table with an
                            associated full-text parser plugin, you can convert the
                            table to <code class="literal">InnoDB</code> using <code class="literal">ALTER
                            TABLE</code>.
                        </p><p style="color:blue;">带分析器选项只能与全文索引一起使用。如果全文索引和搜索操作需要特殊处理，则它将解析器插件与索引关联起来。innodb和myisam都支持全文解析器插件。如果您有一个myisam表和一个相关的全文解析器插件，那么可以使用alter table将该表转换为innodb。</p></li><li class="listitem"><p>
                            <code class="literal">COMMENT</code>
                        </p><p style="color:blue;">评论</p><p>
                            In MySQL 5.7, index definitions can include
                            an optional comment of up to 1024 characters.
                        </p><p style="color:blue;">在mysql 5.7中，索引定义可以包含最多1024个字符的可选注释。</p><p>
                            You can set the <code class="literal">InnoDB</code>
                            <code class="literal">MERGE_THRESHOLD</code> value for an individual
                            index using the
                            <code class="literal"><em class="replaceable"><code>index_option</code></em></code>
                            <code class="literal">COMMENT</code> clause. See
                            <a class="xref" href="innodb-storage-engine.html#index-page-merge-threshold" title="14.8.12&nbsp;Configuring the Merge Threshold for Index Pages">Section&nbsp;14.8.12, “Configuring the Merge Threshold for Index Pages”</a>.
                        </p><p style="color:blue;">可以使用index_option comment子句为单个索引设置innodb merge_阈值。参见第14.8.12节“为索引页配置合并阈值”。</p></li></ul>
                    </div>
                    <p>
                        For more information about permissible
                        <em class="replaceable"><code>index_option</code></em> values, see
                        <a class="xref" href="sql-syntax.html#create-index" title="13.1.14&nbsp;CREATE INDEX Syntax">Section&nbsp;13.1.14, “CREATE INDEX Syntax”</a>. For more information about
                        indexes, see <a class="xref" href="optimization.html#mysql-indexes" title="8.3.1&nbsp;How MySQL Uses Indexes">Section&nbsp;8.3.1, “How MySQL Uses Indexes”</a>.
                    </p><p style="color:blue;">有关允许的index_选项值的更多信息，请参见第13.1.14节“创建索引语法”。有关索引的更多信息，请参阅8.3.1节，“MySQL如何使用索引”。</p></li><li class="listitem"><p><a name="create-table-reference-definition"></a>
                    <code class="literal"><em class="replaceable"><code>reference_definition</code></em></code>
                </p><p style="color:blue;">参考定义</p><p>
                    For <em class="replaceable"><code>reference_definition</code></em> syntax
                    details and examples, see
                    <a class="xref" href="sql-syntax.html#create-table-foreign-keys" title="13.1.18.6&nbsp;Using FOREIGN KEY Constraints">Section&nbsp;13.1.18.6, “Using FOREIGN KEY Constraints”</a>. For information
                    specific to foreign keys in <code class="literal">InnoDB</code>, see
                    <a class="xref" href="innodb-storage-engine.html#innodb-foreign-key-constraints" title="14.6.1.5&nbsp;InnoDB and FOREIGN KEY Constraints">Section&nbsp;14.6.1.5, “InnoDB and FOREIGN KEY Constraints”</a>.
                </p><p style="color:blue;">有关参考定义语法的详细信息和示例，请参阅第13.1.18.6节“使用外键约束”。有关innodb中外键的具体信息，请参阅第14.6.1.5节“innodb和外键约束”。</p><p>
                    <a class="link" href="innodb-storage-engine.html" title="Chapter&nbsp;14&nbsp;The InnoDB Storage Engine"><code class="literal">InnoDB</code></a> and
                    <a class="link" href="mysql-cluster.html" title="Chapter&nbsp;21&nbsp;MySQL NDB Cluster 7.5 and NDB Cluster 7.6"><code class="literal">NDB</code></a> tables support checking of
                    foreign key constraints. The columns of the referenced table
                    must always be explicitly named. Both <code class="literal">ON
                    DELETE</code> and <code class="literal">ON UPDATE</code> actions on
                    foreign keys are supported. For more detailed information and
                    examples, see <a class="xref" href="sql-syntax.html#create-table-foreign-keys" title="13.1.18.6&nbsp;Using FOREIGN KEY Constraints">Section&nbsp;13.1.18.6, “Using FOREIGN KEY Constraints”</a>. For
                    information specific to foreign keys in
                    <code class="literal">InnoDB</code>, see
                    <a class="xref" href="innodb-storage-engine.html#innodb-foreign-key-constraints" title="14.6.1.5&nbsp;InnoDB and FOREIGN KEY Constraints">Section&nbsp;14.6.1.5, “InnoDB and FOREIGN KEY Constraints”</a>.
                </p><p style="color:blue;">innodb和ndb表支持检查外键约束。引用表的列必须始终显式命名。支持外键上的on delete和on update操作。有关更多详细信息和示例，请参见第13.1.18.6节“使用外键约束”。有关innodb中外键的具体信息，请参阅第14.6.1.5节“innodb和外键约束”。</p><p>
                    For other storage engines, MySQL Server parses and ignores the
                    <code class="literal">FOREIGN KEY</code> and
                    <code class="literal">REFERENCES</code> syntax in
                    <a class="link" href="sql-syntax.html#create-table" title="13.1.18&nbsp;CREATE TABLE Syntax"><code class="literal">CREATE TABLE</code></a> statements. See
                    <a class="xref" href="introduction.html#ansi-diff-foreign-keys" title="1.8.2.3&nbsp;Foreign Key Differences">Section&nbsp;1.8.2.3, “Foreign Key Differences”</a>.
                </p><p style="color:blue;">对于其他存储引擎，mysql server解析并忽略create table语句中的外键和引用语法。见第1.8.2.3节“外键差异”。</p>
                    <div class="important" style="margin-left: 0.5in; margin-right: 0.5in;">

                        <div class="admon-title">
                            Important
                        </div>
                        <p>
                            For users familiar with the ANSI/ISO SQL Standard, please
                            note that no storage engine, including
                            <code class="literal">InnoDB</code>, recognizes or enforces the
                            <code class="literal">MATCH</code> clause used in referential
                            integrity constraint definitions. Use of an explicit
                            <code class="literal">MATCH</code> clause will not have the specified
                            effect, and also causes <code class="literal">ON DELETE</code> and
                            <code class="literal">ON UPDATE</code> clauses to be ignored. For
                            these reasons, specifying <code class="literal">MATCH</code> should be
                            avoided.
                        </p><p style="color:blue;">对于熟悉ansi/iso sql标准的用户，请注意，任何存储引擎（包括innodb）都无法识别或强制执行引用完整性约束定义中使用的match子句。使用显式match子句将不会产生指定的效果，还会导致忽略on delete和on update子句。由于这些原因，应该避免指定匹配。</p><p>
                        The <code class="literal">MATCH</code> clause in the SQL standard
                        controls how <code class="literal">NULL</code> values in a composite
                        (multiple-column) foreign key are handled when comparing to
                        a primary key. <code class="literal">InnoDB</code> essentially
                        implements the semantics defined by <code class="literal">MATCH
                        SIMPLE</code>, which permit a foreign key to be all or
                        partially <code class="literal">NULL</code>. In that case, the (child
                        table) row containing such a foreign key is permitted to be
                        inserted, and does not match any row in the referenced
                        (parent) table. It is possible to implement other semantics
                        using triggers.
                    </p><p style="color:blue;">sql标准中的match子句控制与主键比较时如何处理组合（多列）外键中的空值。innodb本质上实现了match simple定义的语义，允许外键全部或部分为空。在这种情况下，允许插入包含此类外键的（子表）行，并且与被引用（父）表中的任何行都不匹配。可以使用触发器实现其他语义。</p><p>
                        Additionally, MySQL requires that the referenced columns be
                        indexed for performance. However, <code class="literal">InnoDB</code>
                        does not enforce any requirement that the referenced columns
                        be declared <code class="literal">UNIQUE</code> or <code class="literal">NOT
                        NULL</code>. The handling of foreign key references to
                        nonunique keys or keys that contain <code class="literal">NULL</code>
                        values is not well defined for operations such as
                        <code class="literal">UPDATE</code> or <code class="literal">DELETE
                        CASCADE</code>. You are advised to use foreign keys that
                        reference only keys that are both <code class="literal">UNIQUE</code>
                        (or <code class="literal">PRIMARY</code>) and <code class="literal">NOT
                        NULL</code>.
                    </p><p style="color:blue;">此外，mysql还要求为引用的列编制索引以提高性能。但是，innodb不强制要求被引用的列声明为唯一或不为空。对于诸如update或delete cascade之类的操作，对非唯一键或包含空值的键的外键引用的处理没有很好地定义。建议您使用只引用唯一（或主）且不为空的键的外键。</p><p>
                        MySQL parses but ignores <span class="quote">“<span class="quote">inline
            <code class="literal">REFERENCES</code> specifications</span>”</span> (as
                        defined in the SQL standard) where the references are
                        defined as part of the column specification. MySQL accepts
                        <code class="literal">REFERENCES</code> clauses only when specified as
                        part of a separate <code class="literal">FOREIGN KEY</code>
                        specification.
                    </p><p style="color:blue;">mysql解析但忽略“内联引用规范”（如sql标准中定义的），其中引用被定义为列规范的一部分。mysql仅在作为单独外键规范的一部分指定时才接受references子句。</p>
                    </div>
                </li><li class="listitem"><p><a name="create-table-reference-option"></a>
                    <code class="literal"><em class="replaceable"><code>reference_option</code></em></code>
                </p><p style="color:blue;">参考选项</p><p>
                    For information about the <code class="literal">RESTRICT</code>,
                    <code class="literal">CASCADE</code>, <code class="literal">SET NULL</code>,
                    <code class="literal">NO ACTION</code>, and <code class="literal">SET
                    DEFAULT</code> options, see
                    <a class="xref" href="sql-syntax.html#create-table-foreign-keys" title="13.1.18.6&nbsp;Using FOREIGN KEY Constraints">Section&nbsp;13.1.18.6, “Using FOREIGN KEY Constraints”</a>.
                </p><p style="color:blue;">有关restrict、cascade、set null、no action和set default选项的信息，请参见第13.1.18.6节“使用外键约束”。</p></li></ul>
            </div>
            <h4><a name="create-table-options"></a>Table Options</h4>
            <p>
                Table options are used to optimize the behavior of the table. In
                most cases, you do not have to specify any of them. These options
                apply to all storage engines unless otherwise indicated. Options
                that do not apply to a given storage engine may be accepted and
                remembered as part of the table definition. Such options then
                apply if you later use <a class="link" href="sql-syntax.html#alter-table" title="13.1.8&nbsp;ALTER TABLE Syntax"><code class="literal">ALTER TABLE</code></a>
                to convert the table to use a different storage engine.
            </p><p style="color:blue;">表选项用于优化表的行为。在大多数情况下，不必指定其中任何一个。除非另有说明，否则这些选项适用于所有存储引擎。不适用于给定存储引擎的选项可以作为表定义的一部分接受和记住。如果以后使用alter table将表转换为使用其他存储引擎，则会应用这些选项。</p>
            <div class="itemizedlist">
                <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                    <code class="literal">ENGINE</code>
                </p><p style="color:blue;">发动机</p><p>
                    Specifies the storage engine for the table, using one of the
                    names shown in the following table. The engine name can be
                    unquoted or quoted. The quoted name
                    <code class="literal">'DEFAULT'</code> is recognized but ignored.
                </p><p style="color:blue;">使用下表中显示的名称之一指定表的存储引擎。引擎名可以不加引号或加引号。已识别带引号的名称“default”，但已忽略。</p>
                    <div class="informaltable">
                        <table summary="Storage engine names permitted for the ENGINE table option and a description of each engine."><colgroup><col width="25%"><col width="70%"></colgroup><thead><tr>
                            <th scope="col">Storage Engine</th>
                            <th scope="col">Description</th>
                        </tr></thead><tbody><tr>
                            <td scope="row"><code class="literal">InnoDB</code></td>
                            <td>Transaction-safe tables with row locking and foreign keys. The default
                                storage engine for new tables. See
                                <a class="xref" href="innodb-storage-engine.html" title="Chapter&nbsp;14&nbsp;The InnoDB Storage Engine">Chapter&nbsp;14, <i>The InnoDB Storage Engine</i></a>, and in
                                particular <a class="xref" href="innodb-storage-engine.html#innodb-introduction" title="14.1&nbsp;Introduction to InnoDB">Section&nbsp;14.1, “Introduction to InnoDB”</a> if you
                                have MySQL experience but are new to
                                <code class="literal">InnoDB</code>.</td>
                        </tr><tr>
                            <td scope="row"><code class="literal">MyISAM</code></td>
                            <td>The binary portable storage engine that is primarily used for read-only
                                or read-mostly workloads. See
                                <a class="xref" href="storage-engines.html#myisam-storage-engine" title="15.2&nbsp;The MyISAM Storage Engine">Section&nbsp;15.2, “The MyISAM Storage Engine”</a>.</td>
                        </tr><tr>
                            <td scope="row"><code class="literal">MEMORY</code></td>
                            <td>The data for this storage engine is stored only in memory. See
                                <a class="xref" href="storage-engines.html#memory-storage-engine" title="15.3&nbsp;The MEMORY Storage Engine">Section&nbsp;15.3, “The MEMORY Storage Engine”</a>.</td>
                        </tr><tr>
                            <td scope="row"><code class="literal">CSV</code></td>
                            <td>Tables that store rows in comma-separated values format. See
                                <a class="xref" href="storage-engines.html#csv-storage-engine" title="15.4&nbsp;The CSV Storage Engine">Section&nbsp;15.4, “The CSV Storage Engine”</a>.</td>
                        </tr><tr>
                            <td scope="row"><code class="literal">ARCHIVE</code></td>
                            <td>The archiving storage engine. See
                                <a class="xref" href="storage-engines.html#archive-storage-engine" title="15.5&nbsp;The ARCHIVE Storage Engine">Section&nbsp;15.5, “The ARCHIVE Storage Engine”</a>.</td>
                        </tr><tr>
                            <td scope="row"><code class="literal">EXAMPLE</code></td>
                            <td>An example engine. See <a class="xref" href="storage-engines.html#example-storage-engine" title="15.9&nbsp;The EXAMPLE Storage Engine">Section&nbsp;15.9, “The EXAMPLE Storage Engine”</a>.</td>
                        </tr><tr>
                            <td scope="row"><code class="literal">FEDERATED</code></td>
                            <td>Storage engine that accesses remote tables. See
                                <a class="xref" href="storage-engines.html#federated-storage-engine" title="15.8&nbsp;The FEDERATED Storage Engine">Section&nbsp;15.8, “The FEDERATED Storage Engine”</a>.</td>
                        </tr><tr>
                            <td scope="row"><code class="literal">HEAP</code></td>
                            <td>This is a synonym for <code class="literal">MEMORY</code>.</td>
                        </tr><tr>
                            <td scope="row"><code class="literal">MERGE</code></td>
                            <td>A collection of <code class="literal">MyISAM</code> tables used as one table. Also
                                known as <code class="literal">MRG_MyISAM</code>. See
                                <a class="xref" href="storage-engines.html#merge-storage-engine" title="15.7&nbsp;The MERGE Storage Engine">Section&nbsp;15.7, “The MERGE Storage Engine”</a>.</td>
                        </tr><tr>
                            <td scope="row"><a class="link" href="mysql-cluster.html" title="Chapter&nbsp;21&nbsp;MySQL NDB Cluster 7.5 and NDB Cluster 7.6"><code class="literal">NDB</code></a></td>
                            <td>Clustered, fault-tolerant, memory-based tables, supporting transactions
                                and foreign keys. Also known as
                                <a class="link" href="mysql-cluster.html" title="Chapter&nbsp;21&nbsp;MySQL NDB Cluster 7.5 and NDB Cluster 7.6"><code class="literal">NDBCLUSTER</code></a>. See
                                <a class="xref" href="mysql-cluster.html" title="Chapter&nbsp;21&nbsp;MySQL NDB Cluster 7.5 and NDB Cluster 7.6">Chapter&nbsp;21, <i>MySQL NDB Cluster 7.5 and NDB Cluster 7.6</i></a>.</td>
                        </tr></tbody></table>
                    </div>
                    <p>
                        By default, if a storage engine is specified that is not
                        available, the statement fails with an error. You can override
                        this behavior by removing
                        <a class="link" href="server-administration.html#sqlmode_no_engine_substitution"><code class="literal">NO_ENGINE_SUBSTITUTION</code></a> from
                        the server SQL mode (see <a class="xref" href="server-administration.html#sql-mode" title="5.1.10&nbsp;Server SQL Modes">Section&nbsp;5.1.10, “Server SQL Modes”</a>) so that
                        MySQL allows substitution of the specified engine with the
                        default storage engine instead. Normally in such cases, this
                        is <code class="literal">InnoDB</code>, which is the default value for
                        the <a class="link" href="server-administration.html#sysvar_default_storage_engine"><code class="literal">default_storage_engine</code></a>
                        system variable. When
                        <code class="literal">NO_ENGINE_SUBSTITUTION</code> is disabled, a
                        warning occurs if the storage engine specification is not
                        honored.
                    </p><p style="color:blue;">默认情况下，如果指定的存储引擎不可用，则语句将失败并返回错误。您可以通过从服务器sql模式中删除no_engine_substitution来覆盖此行为（请参阅第5.1.10节“服务器sql模式”），以便mysql允许使用默认存储引擎替换指定的引擎。通常在这种情况下，这是innodb，它是默认存储引擎系统变量的默认值。当禁用“无引擎替换”时，如果不遵守存储引擎规范，则会出现警告。</p></li><li class="listitem"><p>
                    <code class="literal">AUTO_INCREMENT</code>
                </p><p style="color:blue;">自动递增</p><p>
                    The initial <code class="literal">AUTO_INCREMENT</code> value for the
                    table. In MySQL 5.7, this works for
                    <code class="literal">MyISAM</code>, <code class="literal">MEMORY</code>,
                    <code class="literal">InnoDB</code>, and <code class="literal">ARCHIVE</code>
                    tables. To set the first auto-increment value for engines that
                    do not support the <code class="literal">AUTO_INCREMENT</code> table
                    option, insert a <span class="quote">“<span class="quote">dummy</span>”</span> row with a value one
                    less than the desired value after creating the table, and then
                    delete the dummy row.
                </p><p style="color:blue;">表的初始自动增量值。在mysql 5.7中，这适用于myisam、memory、innodb和archive表。要为不支持自动递增表选项的引擎设置第一个自动递增值，请在创建表后插入一个值小于所需值的“伪”行，然后删除该伪行。</p><p>
                    For engines that support the <code class="literal">AUTO_INCREMENT</code>
                    table option in <a class="link" href="sql-syntax.html#create-table" title="13.1.18&nbsp;CREATE TABLE Syntax"><code class="literal">CREATE TABLE</code></a>
                    statements, you can also use <code class="literal">ALTER TABLE
                    <em class="replaceable"><code>tbl_name</code></em> AUTO_INCREMENT =
                    <em class="replaceable"><code>N</code></em></code> to reset the
                    <code class="literal">AUTO_INCREMENT</code> value. The value cannot be
                    set lower than the maximum value currently in the column.
                </p><p style="color:blue;">对于支持create table语句中的auto_increment table选项的引擎，还可以使用alter table tbl_name auto_increment=n重置auto_increment值。不能将该值设置为低于当前列中的最大值。</p></li><li class="listitem"><p>
                    <code class="literal">AVG_ROW_LENGTH</code>
                </p><p style="color:blue;">平均行长度</p><p>
                    An approximation of the average row length for your table. You
                    need to set this only for large tables with variable-size
                    rows.
                </p><p style="color:blue;">表的平均行长度的近似值。您只需要为具有可变大小行的大型表设置此选项。</p><p>
                    When you create a <code class="literal">MyISAM</code> table, MySQL uses
                    the product of the <code class="literal">MAX_ROWS</code> and
                    <code class="literal">AVG_ROW_LENGTH</code> options to decide how big
                    the resulting table is. If you don't specify either option,
                    the maximum size for <code class="literal">MyISAM</code> data and index
                    files is 256TB by default. (If your operating system does not
                    support files that large, table sizes are constrained by the
                    file size limit.) If you want to keep down the pointer sizes
                    to make the index smaller and faster and you don't really need
                    big files, you can decrease the default pointer size by
                    setting the
                    <a class="link" href="server-administration.html#sysvar_myisam_data_pointer_size"><code class="literal">myisam_data_pointer_size</code></a>
                    system variable. (See
                    <a class="xref" href="server-administration.html#server-system-variables" title="5.1.7&nbsp;Server System Variables">Section&nbsp;5.1.7, “Server System Variables”</a>.) If you want all
                    your tables to be able to grow above the default limit and are
                    willing to have your tables slightly slower and larger than
                    necessary, you can increase the default pointer size by
                    setting this variable. Setting the value to 7 permits table
                    sizes up to 65,536TB.
                </p><p style="color:blue;">创建myisam表时，mysql使用max_rows和avg_row_length选项的乘积来决定结果表的大小。如果不指定任何选项，默认情况下MyISAM数据和索引文件的最大大小为256TB。（如果您的操作系统不支持这么大的文件，则表大小受文件大小限制。）如果您希望减小指针大小以使索引越来越小、越来越快，并且实际上不需要大文件，则可以通过设置myisam_data_pointer_size系统变量来减小默认指针大小。（请参阅第5.1.7节“服务器系统变量”。）如果希望所有表都能增长到默认限制以上，并且希望表稍微慢一点并比需要的大一点，则可以通过设置此变量来增加默认指针大小。将该值设置为7允许表大小高达65536tb。</p></li><li class="listitem"><p>
                    <code class="literal">[DEFAULT] CHARACTER SET</code>
                </p><p style="color:blue;">[默认]字符集</p><p>
                    Specifies a default character set for the table.
                    <code class="literal">CHARSET</code> is a synonym for <code class="literal">CHARACTER
                    SET</code>. If the character set name is
                    <code class="literal">DEFAULT</code>, the database character set is
                    used.
                </p><p style="color:blue;">指定表的默认字符集。字符集是字符集的同义词。如果字符集名称为默认值，则使用数据库字符集。</p></li><li class="listitem"><p>
                    <code class="literal">CHECKSUM</code>
                </p><p style="color:blue;">校验和</p><p>
                    Set this to 1 if you want MySQL to maintain a live checksum
                    for all rows (that is, a checksum that MySQL updates
                    automatically as the table changes). This makes the table a
                    little slower to update, but also makes it easier to find
                    corrupted tables. The <a class="link" href="sql-syntax.html#checksum-table" title="13.7.2.3&nbsp;CHECKSUM TABLE Syntax"><code class="literal">CHECKSUM
                    TABLE</code></a> statement reports the checksum.
                    (<code class="literal">MyISAM</code> only.)
                </p><p style="color:blue;">如果希望mysql为所有行维护实时校验和（即，mysql在表更改时自动更新的校验和），请将此值设置为1。这使表的更新速度稍慢，但也使查找损坏的表更容易。校验和表语句报告校验和。（仅限Myisam）</p></li><li class="listitem"><p>
                    <code class="literal">[DEFAULT] COLLATE</code>
                </p><p style="color:blue;">[默认]整理</p><p>
                    Specifies a default collation for the table.
                </p><p style="color:blue;">指定表的默认排序规则。</p></li><li class="listitem"><p>
                    <code class="literal">COMMENT</code>
                </p><p style="color:blue;">评论</p><p>
                    A comment for the table, up to 2048 characters long.
                </p><p style="color:blue;">表的注释，最长2048个字符。</p><p>
                    You can set the <code class="literal">InnoDB</code>
                    <code class="literal">MERGE_THRESHOLD</code> value for a table using the
                    <code class="literal"><em class="replaceable"><code>table_option</code></em></code>
                    <code class="literal">COMMENT</code> clause. See
                    <a class="xref" href="innodb-storage-engine.html#index-page-merge-threshold" title="14.8.12&nbsp;Configuring the Merge Threshold for Index Pages">Section&nbsp;14.8.12, “Configuring the Merge Threshold for Index Pages”</a>.
                </p><p style="color:blue;">可以使用table_option comment子句为表设置innodb merge_阈值。参见第14.8.12节“为索引页配置合并阈值”。</p><p><a name="create-table-comment-ndb-table-options"></a><b>Setting NDB_TABLE options.&nbsp;</b>
                    <a class="indexterm" name="idm140286838877952"></a>

                    In MySQL NDB Cluster 7.5.2 and later, the table comment in a
                    <code class="literal">CREATE TABLE</code> or
                    <a class="link" href="sql-syntax.html#alter-table" title="13.1.8&nbsp;ALTER TABLE Syntax"><code class="literal">ALTER TABLE</code></a> statement can
                    also be used to specify one to four of the
                    <code class="literal">NDB_TABLE</code> options
                    <code class="literal">NOLOGGING</code>,
                    <code class="literal">READ_BACKUP</code>,
                    <code class="literal">PARTITION_BALANCE</code>, or
                    <code class="literal">FULLY_REPLICATED</code> as a set of name-value
                    pairs, separated by commas if need be, immediately following
                    the string <code class="literal">NDB_TABLE=</code> that begins the
                    quoted comment text. An example statement using this syntax
                    is shown here (emphasized text):
                </p><p style="color:blue;">设置ndb_表选项。在MySQL NDB集群7.5.2和更高版本中，创建表或ALTALTABLE语句中的表注释也可用于指定NDBJtable选项中的一个到四个NoCurring、Read备份、分区Type平衡或FulyLy作为一组名称-值对复制，如果需要的话，用逗号分隔，紧跟在字符串ndBytable =开始之后。引用评论文本。使用此语法的示例语句如下所示（强调文本）：</p><pre data-lang="sql" class="programlisting">CREATE TABLE t1 (
    c1 INT NOT NULL AUTO_INCREMENT PRIMARY KEY,
    c2 VARCHAR(100),
    c3 VARCHAR(100) )
ENGINE=NDB
<span class="emphasis"><em>COMMENT="NDB_TABLE=READ_BACKUP=0,PARTITION_BALANCE=FOR_RP_BY_NODE"</em></span>;
</pre><p>
                    Spaces are not permitted within the quoted string. The string
                    is case-insensitive.
                </p><p style="color:blue;">带引号的字符串中不允许有空格。字符串不区分大小写。</p><p>
                    The comment is displayed as part of the ouput of
                    <a class="link" href="sql-syntax.html#show-create-table" title="13.7.5.10&nbsp;SHOW CREATE TABLE Syntax"><code class="literal">SHOW CREATE TABLE</code></a>. The text of
                    the comment is also available as the TABLE_COMMENT column of
                    the MySQL Information Schema
                    <a class="link" href="information-schema.html#tables-table" title="24.25&nbsp;The INFORMATION_SCHEMA TABLES Table"><code class="literal">TABLES</code></a> table.
                </p><p style="color:blue;">注释显示为show create表输出的一部分。注释的文本也可以作为mysql information schema tables表的table_comment列使用。</p><p>
                    This comment syntax is also supported with
                    <a class="link" href="sql-syntax.html#alter-table" title="13.1.8&nbsp;ALTER TABLE Syntax"><code class="literal">ALTER TABLE</code></a> statements for
                    <code class="literal">NDB</code> tables. Keep in mind that a table
                    comment used with <code class="literal">ALTER TABLE</code> replaces any
                    existing comment which the table might have had perviously.
                </p><p style="color:blue;">对于ndb表，alter table语句也支持这种注释语法。请记住，使用ALTH表的表注释替换了表中可能存在的任何现有注释。</p><p>
                    Setting the <code class="literal">MERGE_THRESHOLD</code> option in table
                    comments is not supported for <a class="link" href="mysql-cluster.html" title="Chapter&nbsp;21&nbsp;MySQL NDB Cluster 7.5 and NDB Cluster 7.6"><code class="literal">NDB</code></a>
                    tables (it is ignored).
                </p><p style="color:blue;">ndb表不支持在表注释中设置merge_threshold选项（将忽略该选项）。</p><p>
                    For complete syntax information and examples, see
                    <a class="xref" href="sql-syntax.html#create-table-ndb-table-comment-options" title="13.1.18.10&nbsp;Setting NDB_TABLE Options">Section&nbsp;13.1.18.10, “Setting NDB_TABLE Options”</a>.
                </p><p style="color:blue;">有关完整的语法信息和示例，请参阅第13.1.18.10节“设置ndb_表选项”。</p></li><li class="listitem"><p>
                    <code class="literal">COMPRESSION</code>
                </p><p style="color:blue;">压缩</p><p>
                    The compression algorithm used for page level compression for
                    <code class="literal">InnoDB</code> tables. Supported values include
                    <code class="literal">Zlib</code>, <code class="literal">LZ4</code>, and
                    <code class="literal">None</code>. The <code class="literal">COMPRESSION</code>
                    attribute was introduced with the transparent page compression
                    feature. Page compression is only supported with
                    <code class="literal">InnoDB</code> tables that reside in
                    <a class="link" href="glossary.html#glos_file_per_table" title="file-per-table">file-per-table</a>
                    tablespaces, and is only available on Linux and Windows
                    platforms that support sparse files and hole punching. For
                    more information, see
                    <a class="xref" href="innodb-storage-engine.html#innodb-page-compression" title="14.9.2&nbsp;InnoDB Page Compression">Section&nbsp;14.9.2, “InnoDB Page Compression”</a>.
                </p><p style="color:blue;">用于innodb表的页级压缩的压缩算法。支持的值包括zlib、lz4和none。压缩属性与透明页面压缩特性一起引入。页面压缩仅支持位于文件/表空间中的innodb表，并且仅在支持稀疏文件和穿孔的linux和windows平台上可用。有关更多信息，请参阅14.9.2节，“InnoDB页面压缩”。</p></li><li class="listitem"><p>
                    <code class="literal">CONNECTION</code>
                </p><p style="color:blue;">连接</p><p>
                    The connection string for a <code class="literal">FEDERATED</code>
                    table.
                </p><p style="color:blue;">联合表的连接字符串。</p>
                    <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">

                        <div class="admon-title">
                            Note
                        </div>
                        <p>
                            Older versions of MySQL used a <code class="literal">COMMENT</code>
                            option for the connection string.
                        </p><p style="color:blue;">旧版本的mysql对连接字符串使用了注释选项。</p>
                    </div>
                </li><li class="listitem"><p>
                    <code class="literal">DATA DIRECTORY</code>, <code class="literal">INDEX
                    DIRECTORY</code>
                </p><p style="color:blue;">数据目录，索引目录</p><p>
                    For <code class="literal">InnoDB</code>, the <code class="literal">DATA
                    DIRECTORY='<em class="replaceable"><code>directory</code></em>'</code>
                    clause permits creating a file-per-table tablespace outside of
                    the data directory. The tablespace data file is created in the
                    specified directory, inside a subdirectory with the same name
                    as the schema. The
                    <a class="link" href="innodb-storage-engine.html#sysvar_innodb_file_per_table"><code class="literal">innodb_file_per_table</code></a>
                    variable must be enabled to use the <code class="literal">DATA
                    DIRECTORY</code> clause. The full directory path must be
                    specified. For more information, see
                    <a class="xref" href="innodb-storage-engine.html#tablespace-placing" title="14.6.3.6&nbsp;Creating a Tablespace Outside of the Data Directory">Section&nbsp;14.6.3.6, “Creating a Tablespace Outside of the Data Directory”</a>.
                </p><p style="color:blue;">对于innodb，data directory=“directory”子句允许在数据目录之外为每个表表空间创建一个文件。表空间数据文件是在指定的目录中创建的，该目录位于与模式同名的子目录中。必须启用innodb_file_per_table变量才能使用data directory子句。必须指定完整的目录路径。有关更多信息，请参阅14.6.3.6节，“在数据目录外创建表空间”。</p><p>
                    When creating <code class="literal">MyISAM</code> tables, you can use
                    the <code class="literal">DATA
                    DIRECTORY='<em class="replaceable"><code>directory</code></em>'</code>
                    clause, the <code class="literal">INDEX
                    DIRECTORY='<em class="replaceable"><code>directory</code></em>'</code>
                    clause, or both. They specify where to put a
                    <code class="literal">MyISAM</code> table's data file and index file,
                    respectively. Unlike <code class="literal">InnoDB</code> tables, MySQL
                    does not create subdirectories that correspond to the database
                    name when creating a <code class="literal">MyISAM</code> table with a
                    <code class="literal">DATA DIRECTORY</code> or <code class="literal">INDEX
                    DIRECTORY</code> option. Files are created in the directory
                    that is specified.
                </p><p style="color:blue;">创建myisam表时，可以使用data directory=“directory”子句和/或index directory=“directory”子句。它们分别指定放置myisam表的数据文件和索引文件的位置。与innodb tables不同，mysql在使用data directory或index directory选项创建myisam表时，不会创建与数据库名称对应的子目录。文件是在指定的目录中创建的。</p><p>
                    As of MySQL 5.7.17, you must have the
                    <a class="link" href="security.html#priv_file"><code class="literal">FILE</code></a> privilege to use the
                    <code class="literal">DATA DIRECTORY</code> or <code class="literal">INDEX
                    DIRECTORY</code> table option.
                </p><p style="color:blue;">从mysql 5.7.17开始，您必须具有文件权限才能使用数据目录或索引目录表选项。</p>
                    <div class="important" style="margin-left: 0.5in; margin-right: 0.5in;">

                        <div class="admon-title">
                            Important
                        </div>
                        <p>
                            Table-level <code class="literal">DATA DIRECTORY</code> and
                            <code class="literal">INDEX DIRECTORY</code> options are ignored for
                            partitioned tables. (Bug #32091)
                        </p><p style="color:blue;">对于分区表，将忽略表级数据目录和索引目录选项。（错误32091）</p>
                    </div>
                    <p>
                        These options work only when you are not using the
                        <a class="link" href="server-administration.html#option_mysqld_symbolic-links"><code class="option">--skip-symbolic-links</code></a>
                        option. Your operating system must also have a working,
                        thread-safe <code class="literal">realpath()</code> call. See
                        <a class="xref" href="optimization.html#symbolic-links-to-tables" title="8.12.3.2&nbsp;Using Symbolic Links for MyISAM Tables on Unix">Section&nbsp;8.12.3.2, “Using Symbolic Links for MyISAM Tables on Unix”</a>, for more complete
                        information.
                    </p><p style="color:blue;">只有在不使用--skip符号链接选项时，这些选项才起作用。您的操作系统还必须有一个工作的、线程安全的realpath（）调用。有关更多完整信息，请参阅8.12.3.2节，“在UNIX上使用MyISAM表的符号链接”。</p><p>
                        If a <code class="literal">MyISAM</code> table is created with no
                        <code class="literal">DATA DIRECTORY</code> option, the
                        <code class="filename">.MYD</code> file is created in the database
                        directory. By default, if <code class="literal">MyISAM</code> finds an
                        existing <code class="filename">.MYD</code> file in this case, it
                        overwrites it. The same applies to <code class="filename">.MYI</code>
                        files for tables created with no <code class="literal">INDEX
                        DIRECTORY</code> option. To suppress this behavior, start
                        the server with the
                        <a class="link" href="server-administration.html#sysvar_keep_files_on_create"><code class="option">--keep_files_on_create</code></a> option,
                        in which case <code class="literal">MyISAM</code> will not overwrite
                        existing files and returns an error instead.
                    </p><p style="color:blue;">如果创建的myisam表没有数据目录选项，则在数据库目录中创建.myd文件。默认情况下，如果MyISAM在这种情况下找到一个现有的.Myd文件，它将覆盖它。这同样适用于在没有索引目录选项的情况下创建的表的.myi文件。为了抑制这种行为，用-KePyFielsSunOnCuto选项启动服务器，在这种情况下，MyISAM不会重写现有文件，而是返回一个错误。</p><p>
                        If a <code class="literal">MyISAM</code> table is created with a
                        <code class="literal">DATA DIRECTORY</code> or <code class="literal">INDEX
                        DIRECTORY</code> option and an existing
                        <code class="filename">.MYD</code> or <code class="filename">.MYI</code> file is
                        found, MyISAM always returns an error. It will not overwrite a
                        file in the specified directory.
                    </p><p style="color:blue;">如果使用数据目录或索引目录选项创建MyISAM表，并且找到了现有的.Myd或.MyI文件，MyISAM总是返回错误。它不会覆盖指定目录中的文件。</p>
                    <div class="important" style="margin-left: 0.5in; margin-right: 0.5in;">

                        <div class="admon-title">
                            Important
                        </div>
                        <p>
                            You cannot use path names that contain the MySQL data
                            directory with <code class="literal">DATA DIRECTORY</code> or
                            <code class="literal">INDEX DIRECTORY</code>. This includes
                            partitioned tables and individual table partitions. (See Bug
                            #32167.)
                        </p><p style="color:blue;">不能将包含mysql数据目录的路径名与数据目录或索引目录一起使用。这包括分区表和单独的表分区。（见Bug 32167。）</p>
                    </div>
                </li><li class="listitem"><p>
                    <code class="literal">DELAY_KEY_WRITE</code>
                </p><p style="color:blue;">延迟键写入</p><p>
                    Set this to 1 if you want to delay key updates for the table
                    until the table is closed. See the description of the
                    <a class="link" href="server-administration.html#sysvar_delay_key_write"><code class="literal">delay_key_write</code></a> system
                    variable in <a class="xref" href="server-administration.html#server-system-variables" title="5.1.7&nbsp;Server System Variables">Section&nbsp;5.1.7, “Server System Variables”</a>.
                    (<code class="literal">MyISAM</code> only.)
                </p><p style="color:blue;">如果要将表的密钥更新延迟到表关闭，请将此值设置为1。请参阅第5.1.7节“服务器系统变量”中延迟键写入系统变量的说明。（仅限Myisam）</p></li><li class="listitem"><p>
                    <code class="literal">ENCRYPTION</code>
                </p><p style="color:blue;">加密</p><p>
                    Set the <code class="literal">ENCRYPTION</code> option to
                    <code class="literal">'Y'</code> to enable page-level data encryption
                    for an <code class="literal">InnoDB</code> table created in a
                    <a class="link" href="glossary.html#glos_file_per_table" title="file-per-table">file-per-table</a>
                    tablespace. Option values are not case-sensitive. The
                    <code class="literal">ENCRYPTION</code> option was introduced with the
                    <code class="literal">InnoDB</code> tablespace encryption feature; see
                    <a class="xref" href="innodb-storage-engine.html#innodb-tablespace-encryption" title="14.6.3.8&nbsp;InnoDB Data-at-Rest Encryption">Section&nbsp;14.6.3.8, “InnoDB Data-at-Rest Encryption”</a>. A
                    <code class="literal">keyring</code> plugin must be installed and
                    configured before encryption can be enabled.
                </p><p style="color:blue;">将encryption选项设置为'y'，为在每个表空间的文件中创建的innodb表启用页级数据加密。选项值不区分大小写。加密选项是与innodb tablespace encryption特性一起引入的；参见第14.6.3.8节“innodb data at rest encryption”。在启用加密之前，必须安装并配置密钥环插件。</p></li><li class="listitem"><p>
                    <code class="literal">INSERT_METHOD</code>
                </p><p style="color:blue;">插入法</p><p>
                    If you want to insert data into a <code class="literal">MERGE</code>
                    table, you must specify with <code class="literal">INSERT_METHOD</code>
                    the table into which the row should be inserted.
                    <code class="literal">INSERT_METHOD</code> is an option useful for
                    <code class="literal">MERGE</code> tables only. Use a value of
                    <code class="literal">FIRST</code> or <code class="literal">LAST</code> to have
                    inserts go to the first or last table, or a value of
                    <code class="literal">NO</code> to prevent inserts. See
                    <a class="xref" href="storage-engines.html#merge-storage-engine" title="15.7&nbsp;The MERGE Storage Engine">Section&nbsp;15.7, “The MERGE Storage Engine”</a>.
                </p><p style="color:blue;">如果要将数据插入合并表，则必须使用insert_方法指定行应插入的表。insert_方法仅对合并表有用。使用值first或last将插入转到第一个或最后一个表，或使用值no防止插入。见第15.7节“合并存储引擎”。</p></li><li class="listitem"><p>
                    <code class="literal">KEY_BLOCK_SIZE</code>
                </p><p style="color:blue;">关键块大小</p><p>
                    For <a class="link" href="storage-engines.html#myisam-storage-engine" title="15.2&nbsp;The MyISAM Storage Engine"><code class="literal">MyISAM</code></a> tables,
                    <code class="literal">KEY_BLOCK_SIZE</code> optionally specifies the
                    size in bytes to use for index key blocks. The value is
                    treated as a hint; a different size could be used if
                    necessary. A <code class="literal">KEY_BLOCK_SIZE</code> value specified
                    for an individual index definition overrides the table-level
                    <code class="literal">KEY_BLOCK_SIZE</code> value.
                </p><p style="color:blue;">对于myisam表，key-block-size可以选择指定索引键块所用的字节大小。该值被视为提示；如果需要，可以使用不同的大小。为单个索引定义指定的键块大小值将替代表级键块大小值。</p><p>
                    For <a class="link" href="innodb-storage-engine.html" title="Chapter&nbsp;14&nbsp;The InnoDB Storage Engine"><code class="literal">InnoDB</code></a> tables,
                    <code class="literal">KEY_BLOCK_SIZE</code> specifies the
                    <a class="link" href="glossary.html#glos_page" title="page">page</a> size in kilobytes to use
                    for <a class="link" href="glossary.html#glos_compression" title="compression">compressed</a>
                    <code class="literal">InnoDB</code> tables. The
                    <code class="literal">KEY_BLOCK_SIZE</code> value is treated as a hint;
                    a different size could be used by <code class="literal">InnoDB</code> if
                    necessary. <code class="literal">KEY_BLOCK_SIZE</code> can only be less
                    than or equal to the
                    <a class="link" href="innodb-storage-engine.html#sysvar_innodb_page_size"><code class="literal">innodb_page_size</code></a> value. A
                    value of 0 represents the default compressed page size, which
                    is half of the
                    <a class="link" href="innodb-storage-engine.html#sysvar_innodb_page_size"><code class="literal">innodb_page_size</code></a> value.
                    Depending on
                    <a class="link" href="innodb-storage-engine.html#sysvar_innodb_page_size"><code class="literal">innodb_page_size</code></a>, possible
                    <code class="literal">KEY_BLOCK_SIZE</code> values include 0, 1, 2, 4,
                    8, and 16. See <a class="xref" href="innodb-storage-engine.html#innodb-table-compression" title="14.9.1&nbsp;InnoDB Table Compression">Section&nbsp;14.9.1, “InnoDB Table Compression”</a> for
                    more information.
                </p><p style="color:blue;">对于innodb表，key_block_size指定要用于压缩innodb表的页面大小（以千字节为单位）。key_block_size值被视为提示；如果需要，innodb可以使用不同的大小。key_block_size只能小于或等于innodb_page_size值。值0表示默认的压缩页面大小，它是innodb_page_size值的一半。根据innodb_page_size，可能的key_block_size值包括0、1、2、4、8和16。有关更多信息，请参阅14.9.1节，“innodb table compression”。</p><p>
                    Oracle recommends enabling
                    <a class="link" href="innodb-storage-engine.html#sysvar_innodb_strict_mode"><code class="literal">innodb_strict_mode</code></a> when
                    specifying <code class="literal">KEY_BLOCK_SIZE</code> for
                    <code class="literal">InnoDB</code> tables. When
                    <a class="link" href="innodb-storage-engine.html#sysvar_innodb_strict_mode"><code class="literal">innodb_strict_mode</code></a> is
                    enabled, specifying an invalid
                    <code class="literal">KEY_BLOCK_SIZE</code> value returns an error. If
                    <a class="link" href="innodb-storage-engine.html#sysvar_innodb_strict_mode"><code class="literal">innodb_strict_mode</code></a> is
                    disabled, an invalid <code class="literal">KEY_BLOCK_SIZE</code> value
                    results in a warning, and the
                    <code class="literal">KEY_BLOCK_SIZE</code> option is ignored.
                </p><p style="color:blue;">Oracle建议在为innodb表指定key_block_size时启用innodb_strict_模式。当启用innodb_strict_mode时，指定无效的key_block_size值将返回错误。如果禁用innodb_strict_mode，则无效的key_block_size值将导致警告，并且忽略key_block_size选项。</p><p>
                    The <code class="literal">Create_options</code> column in response to
                    <a class="link" href="sql-syntax.html#show-table-status" title="13.7.5.36&nbsp;SHOW TABLE STATUS Syntax"><code class="literal">SHOW TABLE STATUS</code></a> reports the
                    originally specified <code class="literal">KEY_BLOCK_SIZE</code> option,
                    as does <a class="link" href="sql-syntax.html#show-create-table" title="13.7.5.10&nbsp;SHOW CREATE TABLE Syntax"><code class="literal">SHOW CREATE TABLE</code></a>.
                </p><p style="color:blue;">响应于“显示表状态”的“创建选项”列将报告最初指定的键块大小选项，与“显示创建表”一样。</p><p>
                    <code class="literal">InnoDB</code> only supports
                    <code class="literal">KEY_BLOCK_SIZE</code> at the table level.
                </p><p style="color:blue;">innodb只支持表级的key-block-size。</p><p>
                    <code class="literal">KEY_BLOCK_SIZE</code> is not supported with 32KB
                    and 64KB <a class="link" href="innodb-storage-engine.html#sysvar_innodb_page_size"><code class="literal">innodb_page_size</code></a>
                    values. <code class="literal">InnoDB</code> table compression does not
                    support these pages sizes.
                </p><p style="color:blue;">32kb和64kb innodb_page_size值不支持key_block_size。InnoDB表压缩不支持这些页面大小。</p></li><li class="listitem"><p>
                    <code class="literal">MAX_ROWS</code>
                </p><p style="color:blue;">最大行数</p><p>
                    The maximum number of rows you plan to store in the table.
                    This is not a hard limit, but rather a hint to the storage
                    engine that the table must be able to store at least this many
                    rows.
                </p><p style="color:blue;">您计划在表中存储的最大行数。这不是一个硬限制，而是对存储引擎的提示，即表必须至少能够存储这么多行。</p><a class="indexterm" name="idm140286838750176"></a><a class="indexterm" name="idm140286838748688"></a><a class="indexterm" name="idm140286838747200"></a><a class="indexterm" name="idm140286838745712"></a>
                    <div class="important" style="margin-left: 0.5in; margin-right: 0.5in;">

                        <div class="admon-title">
                            Important
                        </div>
                        <p>
                            The use of <code class="literal">MAX_ROWS</code> with
                            <code class="literal">NDB</code> tables to control the number of table
                            partitions is deprecated as of NDB Cluster 7.5.4. It remains
                            supported in later versions for backward compatibility, but
                            is subject to removal in a future release. Use
                            PARTITION_BALANCE instead; see
                            <a class="xref" href="sql-syntax.html#create-table-comment-ndb-table-options" title="Setting NDB_TABLE options">Setting NDB_TABLE options</a>.
                        </p><p style="color:blue;">从ndb cluster 7.5.4开始，不赞成使用带有ndb表的max_rows来控制表分区的数量。为了向后兼容，它在以后的版本中仍然受支持，但在将来的版本中可能会被删除。相反，使用分区Type平衡；请参见设置NdByTabl选项。</p>
                    </div>
                    <p>
                        The <a class="link" href="mysql-cluster.html" title="Chapter&nbsp;21&nbsp;MySQL NDB Cluster 7.5 and NDB Cluster 7.6"><code class="literal">NDB</code></a> storage engine treats
                        this value as a maximum. If you plan to create very large NDB
                        Cluster tables (containing millions of rows), you should use
                        this option to insure that <a class="link" href="mysql-cluster.html" title="Chapter&nbsp;21&nbsp;MySQL NDB Cluster 7.5 and NDB Cluster 7.6"><code class="literal">NDB</code></a>
                        allocates sufficient number of index slots in the hash table
                        used for storing hashes of the table's primary keys by
                        setting <code class="literal">MAX_ROWS = 2 *
                        <em class="replaceable"><code>rows</code></em></code>, where
                        <em class="replaceable"><code>rows</code></em> is the number of rows that you
                        expect to insert into the table.
                    </p><p style="color:blue;">NDB存储引擎将此值视为最大值。如果计划创建非常大的ndb集群表（包含数百万行），则应使用此选项，通过设置max_rows=2*rows（其中rows是希望插入表中的行数），确保ndb在用于存储表主键哈希的哈希表中分配足够数量的索引槽。</p><p>
                        The maximum <code class="literal">MAX_ROWS</code> value is 4294967295;
                        larger values are truncated to this limit.
                    </p><p style="color:blue;">最大的最大值是4294967295，较大的值被截断到这个极限。</p></li><li class="listitem"><p>
                    <code class="literal">MIN_ROWS</code>
                </p><p style="color:blue;">最小行数</p><p>
                    The minimum number of rows you plan to store in the table. The
                    <a class="link" href="storage-engines.html#memory-storage-engine" title="15.3&nbsp;The MEMORY Storage Engine"><code class="literal">MEMORY</code></a> storage engine uses this
                    option as a hint about memory use.
                </p><p style="color:blue;">计划存储在表中的最小行数。内存存储引擎使用此选项作为有关内存使用的提示。</p></li><li class="listitem"><p>
                    <code class="literal">PACK_KEYS</code>
                </p><p style="color:blue;">组合键</p><p>
                    Takes effect only with <code class="literal">MyISAM</code> tables. Set
                    this option to 1 if you want to have smaller indexes. This
                    usually makes updates slower and reads faster. Setting the
                    option to 0 disables all packing of keys. Setting it to
                    <code class="literal">DEFAULT</code> tells the storage engine to pack
                    only long <a class="link" href="data-types.html#char" title="11.4.1&nbsp;The CHAR and VARCHAR Types"><code class="literal">CHAR</code></a>,
                    <a class="link" href="data-types.html#char" title="11.4.1&nbsp;The CHAR and VARCHAR Types"><code class="literal">VARCHAR</code></a>,
                    <a class="link" href="data-types.html#binary-varbinary" title="11.4.2&nbsp;The BINARY and VARBINARY Types"><code class="literal">BINARY</code></a>, or
                    <a class="link" href="data-types.html#binary-varbinary" title="11.4.2&nbsp;The BINARY and VARBINARY Types"><code class="literal">VARBINARY</code></a> columns.
                </p><p style="color:blue;">仅对myisam表生效。如果希望索引更小，请将此选项设置为1。这通常会使更新速度变慢，读取速度变快。将该选项设置为0将禁用所有密钥打包。将其设置为默认值将告诉存储引擎仅打包长char、varchar、binary或varbinary列。</p><p>
                    If you do not use <code class="literal">PACK_KEYS</code>, the default is
                    to pack strings, but not numbers. If you use
                    <code class="literal">PACK_KEYS=1</code>, numbers are packed as well.
                </p><p style="color:blue;">如果不使用pack_键，则默认值是打包字符串，而不是打包数字。如果使用pack_keys=1，数字也会打包。</p><p>
                    When packing binary number keys, MySQL uses prefix
                    compression:
                </p><p style="color:blue;">打包二进制数字键时，mysql使用前缀压缩：</p>
                    <div class="itemizedlist">
                        <ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
                            Every key needs one extra byte to indicate how many bytes
                            of the previous key are the same for the next key.
                        </p><p style="color:blue;">每个键都需要一个额外的字节来指示下一个键的前一个键的字节数相同。</p></li><li class="listitem"><p>
                            The pointer to the row is stored in high-byte-first order
                            directly after the key, to improve compression.
                        </p><p style="color:blue;">指向行的指针直接存储在键之后的第一个高字节顺序中，以改进压缩。</p></li></ul>
                    </div>
                    <p>
                        This means that if you have many equal keys on two consecutive
                        rows, all following <span class="quote">“<span class="quote">same</span>”</span> keys usually only take
                        two bytes (including the pointer to the row). Compare this to
                        the ordinary case where the following keys takes
                        <code class="literal">storage_size_for_key + pointer_size</code> (where
                        the pointer size is usually 4). Conversely, you get a
                        significant benefit from prefix compression only if you have
                        many numbers that are the same. If all keys are totally
                        different, you use one byte more per key, if the key is not a
                        key that can have <code class="literal">NULL</code> values. (In this
                        case, the packed key length is stored in the same byte that is
                        used to mark if a key is <code class="literal">NULL</code>.)
                    </p><p style="color:blue;">这意味着如果在两个连续的行上有许多相等的键，那么后面所有的“相同”键通常只占用两个字节（包括指向行的指针）。将其与以下键采用存储键+指针大小（指针大小通常为4）的普通情况进行比较。相反，只有当有许多相同的数字时，前缀压缩才有显著的好处。如果所有键完全不同，则每个键多使用一个字节，前提是该键不是可以具有空值的键。（在这种情况下，压缩密钥长度存储在用于标记密钥是否为空的同一字节中。）</p></li><li class="listitem"><p>
                    <code class="literal">PASSWORD</code>
                </p><p style="color:blue;">密码</p><p>
                    This option is unused. If you have a need to scramble your
                    <code class="filename">.frm</code> files and make them unusable to any
                    other MySQL server, please contact our sales department.
                </p><p style="color:blue;">此选项未使用。如果您需要对.frm文件进行加密，使其无法用于任何其他mysql服务器，请与我们的销售部门联系。</p></li><li class="listitem"><p>
                    <code class="literal">ROW_FORMAT</code>
                </p><p style="color:blue;">行格式</p><p>
                    Defines the physical format in which the rows are stored.
                </p><p style="color:blue;">定义存储行的物理格式。</p><p>
                    When executing a <a class="link" href="sql-syntax.html#create-table" title="13.1.18&nbsp;CREATE TABLE Syntax"><code class="literal">CREATE TABLE</code></a>
                    statement with <a class="link" href="glossary.html#glos_strict_mode" title="strict mode">strict
                    mode</a> disabled, if you specify a row format that is not
                    supported by the storage engine that is used for the table,
                    the table is created using that storage engine's default
                    row format. The information reported in the
                    <code class="literal">Row_format</code> column in response to
                    <a class="link" href="sql-syntax.html#show-table-status" title="13.7.5.36&nbsp;SHOW TABLE STATUS Syntax"><code class="literal">SHOW TABLE STATUS</code></a> is the actual
                    row format used. This may differ from the value in the
                    <code class="literal">Create_options</code> column because the original
                    <a class="link" href="sql-syntax.html#create-table" title="13.1.18&nbsp;CREATE TABLE Syntax"><code class="literal">CREATE TABLE</code></a> definition is
                    retained during creation. <a class="link" href="sql-syntax.html#show-create-table" title="13.7.5.10&nbsp;SHOW CREATE TABLE Syntax"><code class="literal">SHOW CREATE
                    TABLE</code></a> also reports the row format used in the
                    original <a class="link" href="sql-syntax.html#create-table" title="13.1.18&nbsp;CREATE TABLE Syntax"><code class="literal">CREATE TABLE</code></a>
                    statement.
                </p><p style="color:blue;">在禁用严格模式的情况下执行CREATE TABLE语句时，如果指定的行格式不受用于该表的存储引擎支持，则使用该存储引擎的默认行格式创建该表。响应show table status在row_format列中报告的信息是实际使用的行格式。这可能与“创建选项”列中的值不同，因为在创建过程中保留了原始的创建表定义。show create table还报告原始create table语句中使用的行格式。</p><p>
                    Row format choices differ depending on the storage engine used
                    for the table.
                </p><p style="color:blue;">行格式的选择因表使用的存储引擎而异。</p><p>
                    For <code class="literal">InnoDB</code> tables:
                </p><p style="color:blue;">对于innodb表：</p>
                    <div class="itemizedlist">
                        <ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
                            The default row format is defined by
                            <a class="link" href="innodb-storage-engine.html#sysvar_innodb_default_row_format"><code class="literal">innodb_default_row_format</code></a>,
                            which has a default setting of <code class="literal">DYNAMIC</code>.
                            The default row format is used when the
                            <code class="literal">ROW_FORMAT</code> option is not defined or
                            when <code class="literal">ROW_FORMAT=DEFAULT</code> is used.
                        </p><p style="color:blue;">默认行格式由innodb_default_row_format定义，该格式的默认设置为dynamic。未定义“行格式”选项或使用“行格式=默认”时，将使用默认行格式。</p><p>
                            If the <code class="literal">ROW_FORMAT</code> option is not
                            defined, or if <code class="literal">ROW_FORMAT=DEFAULT</code> is
                            used, operations that rebuild a table also silently change
                            the row format of the table to the default defined by
                            <a class="link" href="innodb-storage-engine.html#sysvar_innodb_default_row_format"><code class="literal">innodb_default_row_format</code></a>.
                            For more information, see
                            <a class="xref" href="innodb-storage-engine.html#innodb-row-format-defining" title="Defining the Row Format of a Table">Defining the Row Format of a Table</a>.
                        </p><p style="color:blue;">如果没有定义row_format选项，或者使用row_format=default，重建表的操作也会自动将表的行格式更改为innodb_default_row_format定义的默认格式。有关详细信息，请参见定义表格的行格式。</p></li><li class="listitem"><p>
                            For more efficient <code class="literal">InnoDB</code> storage of
                            data types, especially <a class="link" href="data-types.html#blob" title="11.4.3&nbsp;The BLOB and TEXT Types"><code class="literal">BLOB</code></a>
                            types, use the <code class="literal">DYNAMIC</code>. See
                            <a class="xref" href="innodb-storage-engine.html#innodb-row-format-dynamic" title="DYNAMIC Row Format">DYNAMIC Row Format</a> for
                            requirements associated with the
                            <code class="literal">DYNAMIC</code> row format.
                        </p><p style="color:blue;">为了更有效地存储数据类型，特别是blob类型，请使用dynamic。有关与动态行格式关联的要求，请参见动态行格式。</p></li><li class="listitem"><p>
                            To enable compression for <code class="literal">InnoDB</code>
                            tables, specify <code class="literal">ROW_FORMAT=COMPRESSED</code>.
                            See <a class="xref" href="innodb-storage-engine.html#innodb-compression" title="14.9&nbsp;InnoDB Table and Page Compression">Section&nbsp;14.9, “InnoDB Table and Page Compression”</a> for requirements
                            associated with the <code class="literal">COMPRESSED</code> row
                            format.
                        </p><p style="color:blue;">要为innodb表启用压缩，请指定row_format=compressed。有关压缩行格式的要求，请参阅第14.9节“innodb table and page compression”。</p></li><li class="listitem"><p>
                            The row format used in older versions of MySQL can still
                            be requested by specifying the
                            <code class="literal">REDUNDANT</code> row format.
                        </p><p style="color:blue;">旧版本mysql中使用的行格式仍然可以通过指定冗余行格式来请求。</p></li><li class="listitem"><p>
                            When you specify a non-default
                            <code class="literal">ROW_FORMAT</code> clause, consider also
                            enabling the
                            <a class="link" href="innodb-storage-engine.html#sysvar_innodb_strict_mode"><code class="literal">innodb_strict_mode</code></a>
                            configuration option.
                        </p><p style="color:blue;">当您指定一个非默认的row_format子句时，请考虑启用innodb_strict_mode配置选项。</p></li><li class="listitem"><p>
                            <code class="literal">ROW_FORMAT=FIXED</code> is not supported. If
                            <code class="literal">ROW_FORMAT=FIXED</code> is specified while
                            <a class="link" href="innodb-storage-engine.html#sysvar_innodb_strict_mode"><code class="literal">innodb_strict_mode</code></a> is
                            disabled, <code class="literal">InnoDB</code> issues a warning and
                            assumes <code class="literal">ROW_FORMAT=DYNAMIC</code>. If
                            <code class="literal">ROW_FORMAT=FIXED</code> is specified while
                            <a class="link" href="innodb-storage-engine.html#sysvar_innodb_strict_mode"><code class="literal">innodb_strict_mode</code></a> is
                            enabled, which is the default, <code class="literal">InnoDB</code>
                            returns an error.
                        </p><p style="color:blue;">不支持行格式=固定。如果在禁用innodb_strict_mode时指定row_format=fixed，innodb将发出警告并假定row_format=dynamic。如果在启用innodb_strict_mode（默认）时指定row_format=fixed，innodb将返回一个错误。</p></li><li class="listitem"><p>
                            For additional information about <code class="literal">InnoDB</code>
                            row formats, see <a class="xref" href="innodb-storage-engine.html#innodb-row-format" title="14.11&nbsp;InnoDB Row Formats">Section&nbsp;14.11, “InnoDB Row Formats”</a>.
                        </p><p style="color:blue;">有关innodb行格式的更多信息，请参阅第14.11节“innodb行格式”。</p></li></ul>
                    </div>
                    <p>
                        For <code class="literal">MyISAM</code> tables, the option value can be
                        <code class="literal">FIXED</code> or <code class="literal">DYNAMIC</code> for
                        static or variable-length row format.
                        <a class="link" href="programs.html#myisampack" title="4.6.5&nbsp;myisampack — Generate Compressed, Read-Only MyISAM Tables"><span class="command"><strong>myisampack</strong></span></a> sets the type to
                        <code class="literal">COMPRESSED</code>. See
                        <a class="xref" href="storage-engines.html#myisam-table-formats" title="15.2.3&nbsp;MyISAM Table Storage Formats">Section&nbsp;15.2.3, “MyISAM Table Storage Formats”</a>.
                    </p><p style="color:blue;">对于myisam表，对于静态或可变长度的行格式，选项值可以是固定的或动态的。myisampack将类型设置为compressed。见第15.2.3节，“myisam表存储格式”。</p><p>
                        For <a class="link" href="mysql-cluster.html" title="Chapter&nbsp;21&nbsp;MySQL NDB Cluster 7.5 and NDB Cluster 7.6"><code class="literal">NDB</code></a> tables, the default
                        <code class="literal">ROW_FORMAT</code> in MySQL NDB Cluster 7.5.1 and
                        later is <code class="literal">DYNAMIC</code>. (Previously, it was
                        <code class="literal">FIXED</code>.)
                    </p><p style="color:blue;">对于ndb表，mysql ndb cluster 7.5.1及更高版本中的默认行格式是动态的。（之前，它是固定的。）</p></li><li class="listitem"><p>
                    <code class="literal">STATS_AUTO_RECALC</code>
                </p><p style="color:blue;">统计自动重新计算</p><p>
                    Specifies whether to automatically recalculate
                    <a class="link" href="glossary.html#glos_persistent_statistics" title="persistent statistics">persistent
                        statistics</a> for an <code class="literal">InnoDB</code> table. The
                    value <code class="literal">DEFAULT</code> causes the persistent
                    statistics setting for the table to be determined by the
                    <a class="link" href="innodb-storage-engine.html#sysvar_innodb_stats_auto_recalc"><code class="literal">innodb_stats_auto_recalc</code></a>
                    configuration option. The value <code class="literal">1</code> causes
                    statistics to be recalculated when 10% of the data in the
                    table has changed. The value <code class="literal">0</code> prevents
                    automatic recalculation for this table; with this setting,
                    issue an <a class="link" href="sql-syntax.html#analyze-table" title="13.7.2.1&nbsp;ANALYZE TABLE Syntax"><code class="literal">ANALYZE TABLE</code></a>
                    statement to recalculate the statistics after making
                    substantial changes to the table. For more information about
                    the persistent statistics feature, see
                    <a class="xref" href="innodb-storage-engine.html#innodb-persistent-stats" title="14.8.11.1&nbsp;Configuring Persistent Optimizer Statistics Parameters">Section&nbsp;14.8.11.1, “Configuring Persistent Optimizer Statistics Parameters”</a>.
                </p><p style="color:blue;">指定是否自动重新计算innodb表的持久统计信息。默认值使表的持久统计设置由innodb_stats_auto_recalc配置选项确定。当表中10%的数据发生更改时，值1将导致重新计算统计信息。值0阻止自动重新计算此表；使用此设置，在对表进行实质性更改后，发出analyze table语句重新计算统计信息。有关持久统计特性的更多信息，请参阅14.8.11.1节，“配置持久优化器统计参数”。</p></li><li class="listitem"><p>
                    <code class="literal">STATS_PERSISTENT</code>
                </p><p style="color:blue;">持续性统计</p><p>
                    Specifies whether to enable
                    <a class="link" href="glossary.html#glos_persistent_statistics" title="persistent statistics">persistent
                        statistics</a> for an <code class="literal">InnoDB</code> table. The
                    value <code class="literal">DEFAULT</code> causes the persistent
                    statistics setting for the table to be determined by the
                    <a class="link" href="innodb-storage-engine.html#sysvar_innodb_stats_persistent"><code class="literal">innodb_stats_persistent</code></a>
                    configuration option. The value <code class="literal">1</code> enables
                    persistent statistics for the table, while the value
                    <code class="literal">0</code> turns off this feature. After enabling
                    persistent statistics through a <code class="literal">CREATE
                    TABLE</code> or <code class="literal">ALTER TABLE</code> statement,
                    issue an <a class="link" href="sql-syntax.html#analyze-table" title="13.7.2.1&nbsp;ANALYZE TABLE Syntax"><code class="literal">ANALYZE TABLE</code></a>
                    statement to calculate the statistics, after loading
                    representative data into the table. For more information about
                    the persistent statistics feature, see
                    <a class="xref" href="innodb-storage-engine.html#innodb-persistent-stats" title="14.8.11.1&nbsp;Configuring Persistent Optimizer Statistics Parameters">Section&nbsp;14.8.11.1, “Configuring Persistent Optimizer Statistics Parameters”</a>.
                </p><p style="color:blue;">指定是否为innodb表启用持久统计。默认值使表的持久统计设置由innodb_stats_persistent配置选项确定。值1启用表的持久统计信息，而值0关闭此功能。在通过CREATETABLE或ALTERTABLE语句启用持久统计之后，在将代表性数据加载到表中之后，发出ANALYSETTABLE语句来计算统计信息。有关持久统计特性的更多信息，请参阅14.8.11.1节，“配置持久优化器统计参数”。</p></li><li class="listitem"><p>
                    <code class="literal">STATS_SAMPLE_PAGES</code>
                </p><p style="color:blue;">统计样本页</p><p>
                    The number of index pages to sample when estimating
                    cardinality and other statistics for an indexed column, such
                    as those calculated by <a class="link" href="sql-syntax.html#analyze-table" title="13.7.2.1&nbsp;ANALYZE TABLE Syntax"><code class="literal">ANALYZE
                    TABLE</code></a>. For more information, see
                    <a class="xref" href="innodb-storage-engine.html#innodb-persistent-stats" title="14.8.11.1&nbsp;Configuring Persistent Optimizer Statistics Parameters">Section&nbsp;14.8.11.1, “Configuring Persistent Optimizer Statistics Parameters”</a>.
                </p><p style="color:blue;">估计索引列的基数和其他统计信息（如由analyze table计算的统计信息）时要采样的索引页数。有关更多信息，请参阅第14.8.11.1节“配置持久优化器统计参数”。</p></li><li class="listitem"><p>
                    <code class="literal">TABLESPACE</code>
                </p><p style="color:blue;">表空间</p><p>
                    The <code class="literal">TABLESPACE</code> clause can be used to create
                    a table in an existing general tablespace, a file-per-table
                    tablespace, or the system tablespace.
                </p><p style="color:blue;">表空间子句可以用来在现有的通用表空间中创建表，每个表表空间中创建一个表，或者在系统表空间中创建一个表。</p><pre data-lang="sql" class="programlisting">CREATE TABLE <em class="replaceable"><code>tbl_name</code></em> ... TABLESPACE [=] <em class="replaceable"><code>tablespace_name</code></em></pre><p>
                    The general tablespace that you specify must exist prior to
                    using the <code class="literal">TABLESPACE</code> clause. For
                    information about general tablespaces, see
                    <a class="xref" href="innodb-storage-engine.html#general-tablespaces" title="14.6.3.3&nbsp;General Tablespaces">Section&nbsp;14.6.3.3, “General Tablespaces”</a>.
                </p><p style="color:blue;">指定的通用表空间必须在使用表空间子句之前存在。有关通用表空间的信息，请参阅14.6.3.3节“通用表空间”。</p><p>
                    The
                    <code class="literal"><em class="replaceable"><code>tablespace_name</code></em></code>
                    is a case-sensitive identifier. It may be quoted or unquoted.
                    The forward slash character (<span class="quote">“<span class="quote">/</span>”</span>) is not
                    permitted. Names beginning with <span class="quote">“<span class="quote">innodb_</span>”</span> are
                    reserved for special use.
                </p><p style="color:blue;">表空间名称是区分大小写的标识符。它可以被引用也可以不被引用。不允许使用正斜杠字符（“/”）。以“innodb”开头的名称保留作特殊用途。</p><p>
                    To create a table in the system tablespace, specify
                    <code class="literal">innodb_system</code> as the tablespace name.
                </p><p style="color:blue;">要在系统表空间中创建表，请指定innodb_system作为表空间名。</p><pre data-lang="sql" class="programlisting">CREATE TABLE <em class="replaceable"><code>tbl_name</code></em> ... TABLESPACE [=] innodb_system</pre><p>
                    Using <code class="literal">TABLESPACE [=] innodb_system</code>, you can
                    place a table of any uncompressed row format in the system
                    tablespace regardless of the
                    <a class="link" href="innodb-storage-engine.html#sysvar_innodb_file_per_table"><code class="literal">innodb_file_per_table</code></a>
                    setting. For example, you can add a table with
                    <code class="literal">ROW_FORMAT=DYNAMIC</code> to the system tablespace
                    using <code class="literal">TABLESPACE [=] innodb_system</code>.
                </p><p style="color:blue;">使用tablespace[=]innodb_system，您可以在系统表空间中放置任何未压缩行格式的表，而不必考虑innodb_file_per_table设置。例如，可以使用tablespace[=]innodb_system将row_format=dynamic的表添加到系统表空间。</p><p>
                    To create a table in a file-per-table tablespace, specify
                    <code class="literal">innodb_file_per_table</code> as the tablespace
                    name.
                </p><p style="color:blue;">要在每个表空间的文件中创建表，请指定innodb_file_per_table作为表空间名称。</p><pre data-lang="sql" class="programlisting">CREATE TABLE <em class="replaceable"><code>tbl_name</code></em> ... TABLESPACE [=] innodb_file_per_table</pre>
                    <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">

                        <div class="admon-title">
                            Note
                        </div>
                        <p>
                            If <a class="link" href="innodb-storage-engine.html#sysvar_innodb_file_per_table"><code class="literal">innodb_file_per_table</code></a> is
                            enabled, you need not specify
                            <code class="literal">TABLESPACE=innodb_file_per_table</code> to
                            create an <code class="literal">InnoDB</code> file-per-table
                            tablespace. <code class="literal">InnoDB</code> tables are created in
                            file-per-table tablespaces by default when
                            <a class="link" href="innodb-storage-engine.html#sysvar_innodb_file_per_table"><code class="literal">innodb_file_per_table</code></a> is
                            enabled.
                        </p><p style="color:blue;">如果启用了innodb_file_per_table，则无需指定tablespace=innodb_file_per_table即可创建innodb file per table space。默认情况下，当启用innodb_file_per_table时，innodb tables会在file per table spaces中创建。</p>
                    </div>
                    <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">
                        <div class="admon-title">
                            Note
                        </div>
                        <p>
                            Support for creating table partitions in shared
                            <code class="literal">InnoDB</code> tablespaces is deprecated in MySQL
                            5.7.24 and will be removed in a future version of MySQL.
                            Shared tablespaces include the <code class="literal">InnoDB</code>
                            system tablespace and general tablespaces.
                        </p><p style="color:blue;">mysql 5.7.24不支持在共享innodb表空间中创建表分区，并将在mysql的未来版本中删除。共享表空间包括innodb系统表空间和通用表空间。</p>
                    </div>
                    <p>
                        The <code class="literal">DATA DIRECTORY</code> clause is permitted with
                        <code class="literal">CREATE TABLE ...
                            TABLESPACE=innodb_file_per_table</code> but is otherwise
                        not supported for use in combination with the
                        <code class="literal">TABLESPACE</code> option.
                    </p><p style="color:blue;">允许在CREATE TABLE中使用数据目录子句…tablespace=innodb_file_per_table，但不支持与tablespace选项结合使用。</p>
                    <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">

                        <div class="admon-title">
                            Note
                        </div>
                        <p>
                            Support for <code class="literal">TABLESPACE =
                            innodb_file_per_table</code> and <code class="literal">TABLESPACE =
                            innodb_temporary</code> clauses with
                            <a class="link" href="sql-syntax.html#create-table" title="13.1.18&nbsp;CREATE TABLE Syntax"><code class="literal">CREATE
                                TEMPORARY TABLE</code></a> is deprecated as of MySQL 5.7.24
                            and will be removed in a future version of MySQL.
                        </p><p style="color:blue;">从mysql 5.7.24开始，不支持tablespace=innodb_file_per_table和tablespace=innodb_temporary子句以及create temporary table，并将在mysql的未来版本中删除。</p>
                    </div>
                    <p>
                        The <code class="literal">STORAGE</code> table option is employed only
                        with <a class="link" href="mysql-cluster.html" title="Chapter&nbsp;21&nbsp;MySQL NDB Cluster 7.5 and NDB Cluster 7.6"><code class="literal">NDB</code></a> tables.
                        <code class="literal">STORAGE</code> determines the type of storage used
                        (disk or memory), and can be either <code class="literal">DISK</code> or
                        <code class="literal">MEMORY</code>.
                    </p><p style="color:blue;">存储表选项仅用于ndb表。存储决定所使用的存储类型（磁盘或内存），可以是磁盘或内存。</p><p>
                        <code class="literal">TABLESPACE ... STORAGE DISK</code> assigns a table
                        to an NDB Cluster Disk Data tablespace. The tablespace must
                        already have been created using <a class="link" href="sql-syntax.html#create-tablespace" title="13.1.19&nbsp;CREATE TABLESPACE Syntax"><code class="literal">CREATE
                        TABLESPACE</code></a>. See
                        <a class="xref" href="mysql-cluster.html#mysql-cluster-disk-data" title="21.5.13&nbsp;NDB Cluster Disk Data Tables">Section&nbsp;21.5.13, “NDB Cluster Disk Data Tables”</a>, for more
                        information.
                    </p><p style="color:blue;">表空间…存储磁盘将表分配给ndb群集磁盘数据表空间。表空间必须已经使用create tablespace创建。有关详细信息，请参阅21.5.13节“ndb群集磁盘数据表”。</p>
                    <div class="important" style="margin-left: 0.5in; margin-right: 0.5in;">

                        <div class="admon-title">
                            Important
                        </div>
                        <p>
                            A <code class="literal">STORAGE</code> clause cannot be used in a
                            <a class="link" href="sql-syntax.html#create-table" title="13.1.18&nbsp;CREATE TABLE Syntax"><code class="literal">CREATE TABLE</code></a> statement
                            without a <code class="literal">TABLESPACE</code> clause.
                        </p><p style="color:blue;">存储子句不能在没有表空间子句的CREATE TABLE语句中使用。</p>
                    </div>
                </li><li class="listitem"><p>
                    <a class="link" href="sql-syntax.html#union" title="13.2.9.3&nbsp;UNION Syntax"><code class="literal">UNION</code></a>
                </p><p style="color:blue;">工会</p><p>
                    Used to access a collection of identical
                    <code class="literal">MyISAM</code> tables as one. This works only with
                    <code class="literal">MERGE</code> tables. See
                    <a class="xref" href="storage-engines.html#merge-storage-engine" title="15.7&nbsp;The MERGE Storage Engine">Section&nbsp;15.7, “The MERGE Storage Engine”</a>.
                </p><p style="color:blue;">用于作为一个访问相同myisam表的集合。这只适用于合并表。见第15.7节“合并存储引擎”。</p><p>
                    You must have <a class="link" href="security.html#priv_select"><code class="literal">SELECT</code></a>,
                    <a class="link" href="security.html#priv_update"><code class="literal">UPDATE</code></a>, and
                    <a class="link" href="security.html#priv_delete"><code class="literal">DELETE</code></a> privileges for the
                    tables you map to a <code class="literal">MERGE</code> table.
                </p><p style="color:blue;">必须对映射到合并表的表具有选择、更新和删除权限。</p>
                    <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">

                        <div class="admon-title">
                            Note
                        </div>
                        <p>
                            Formerly, all tables used had to be in the same database as
                            the <code class="literal">MERGE</code> table itself. This restriction
                            no longer applies.
                        </p><p style="color:blue;">以前，所有使用的表都必须与合并表本身位于同一数据库中。此限制不再适用。</p>
                    </div>
                </li></ul>
            </div>
            <h4><a name="create-table-partitioning"></a>Table Partitioning</h4>
            <p>
                <em class="replaceable"><code>partition_options</code></em> can be used to
                control partitioning of the table created with
                <a class="link" href="sql-syntax.html#create-table" title="13.1.18&nbsp;CREATE TABLE Syntax"><code class="literal">CREATE TABLE</code></a>.
            </p><p style="color:blue;">partition_选项可用于控制用create table创建的表的分区。</p><p>
            Not all options shown in the syntax for
            <em class="replaceable"><code>partition_options</code></em> at the beginning of
            this section are available for all partitioning types. Please see
            the listings for the following individual types for information
            specific to each type, and see <a class="xref" href="partitioning.html" title="Chapter&nbsp;22&nbsp;Partitioning">Chapter&nbsp;22, <i>Partitioning</i></a>, for
            more complete information about the workings of and uses for
            partitioning in MySQL, as well as additional examples of table
            creation and other statements relating to MySQL partitioning.
        </p><p style="color:blue;">并非本节开头的partition_options语法中显示的所有选项都适用于所有分区类型。有关每种类型的具体信息，请参阅以下各个类型的列表，有关MySQL中分区的工作和使用的更完整信息，请参阅第22章“分区”，以及与MySQL分区相关的表创建和其他语句的附加示例。</p><p>
            Partitions can be modified, merged, added to tables, and dropped
            from tables. For basic information about the MySQL statements to
            accomplish these tasks, see <a class="xref" href="sql-syntax.html#alter-table" title="13.1.8&nbsp;ALTER TABLE Syntax">Section&nbsp;13.1.8, “ALTER TABLE Syntax”</a>. For
            more detailed descriptions and examples, see
            <a class="xref" href="partitioning.html#partitioning-management" title="22.3&nbsp;Partition Management">Section&nbsp;22.3, “Partition Management”</a>.
        </p><p style="color:blue;">分区可以修改、合并、添加到表中以及从表中删除。有关完成这些任务的mysql语句的基本信息，请参阅13.1.8节“alter table syntax”。有关更详细的描述和示例，请参阅第22.3节“分区管理”。</p>
            <div class="itemizedlist">
                <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                    <code class="literal">PARTITION BY</code>
                </p><p style="color:blue;">分区通过</p><p>
                    If used, a <em class="replaceable"><code>partition_options</code></em> clause
                    begins with <code class="literal">PARTITION BY</code>. This clause
                    contains the function that is used to determine the partition;
                    the function returns an integer value ranging from 1 to
                    <em class="replaceable"><code>num</code></em>, where
                    <em class="replaceable"><code>num</code></em> is the number of partitions.
                    (The maximum number of user-defined partitions which a table
                    may contain is 1024; the number of
                    subpartitions—discussed later in this section—is
                    included in this maximum.)
                </p><p style="color:blue;">如果使用，则分区选项选项从分区开始。此子句包含用于确定分区的函数；该函数返回一个从1到num的整数值，其中num是分区数。（表中可能包含的用户定义的分区的最大数目是1024；在本节后面讨论的子分区的数量包含在这个最大值中。）</p>
                    <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">

                        <div class="admon-title">
                            Note
                        </div>
                        <p>
                            The expression (<em class="replaceable"><code>expr</code></em>) used in a
                            <code class="literal">PARTITION BY</code> clause cannot refer to any
                            columns not in the table being created; such references are
                            specifically not permitted and cause the statement to fail
                            with an error. (Bug #29444)
                        </p><p style="color:blue;">分区BY子句中使用的表达式（EXPR）不能引用正在创建的表中的任何列；此类引用是不允许的，并导致语句出现错误而失败。（错误29444）</p>
                    </div>
                </li><li class="listitem"><p>
                    <code class="literal">HASH(<em class="replaceable"><code>expr</code></em>)</code>
                </p><p style="color:blue;">散列（expr）</p><p>
                    Hashes one or more columns to create a key for placing and
                    locating rows. <em class="replaceable"><code>expr</code></em> is an
                    expression using one or more table columns. This can be any
                    valid MySQL expression (including MySQL functions) that yields
                    a single integer value. For example, these are both valid
                    <a class="link" href="sql-syntax.html#create-table" title="13.1.18&nbsp;CREATE TABLE Syntax"><code class="literal">CREATE TABLE</code></a> statements using
                    <code class="literal">PARTITION BY HASH</code>:
                </p><p style="color:blue;">散列一列或多列以创建用于放置和定位行的键。expr是使用一个或多个表列的表达式。这可以是任何有效的mysql表达式（包括mysql函数），它会产生一个整数值。例如，这些都是使用哈希分区的有效创建表语句：</p><pre data-lang="sql" class="programlisting">CREATE TABLE t1 (col1 INT, col2 CHAR(5))
    PARTITION BY HASH(col1);

CREATE TABLE t1 (col1 INT, col2 CHAR(5), col3 DATETIME)
    PARTITION BY HASH ( YEAR(col3) );
</pre><p>
                    You may not use either <code class="literal">VALUES LESS THAN</code> or
                    <code class="literal">VALUES IN</code> clauses with <code class="literal">PARTITION
                    BY HASH</code>.
                </p><p style="color:blue;">您可以不使用小于或小于散列的子句中的值。</p><p>
                    <code class="literal">PARTITION BY HASH</code> uses the remainder of
                    <em class="replaceable"><code>expr</code></em> divided by the number of
                    partitions (that is, the modulus). For examples and additional
                    information, see <a class="xref" href="partitioning.html#partitioning-hash" title="22.2.4&nbsp;HASH Partitioning">Section&nbsp;22.2.4, “HASH Partitioning”</a>.
                </p><p style="color:blue;">通过哈希分区使用EXPR的其余部分除以分区的数目（即，模数）。有关示例和其他信息，请参见第22.2.4节“哈希分区”。</p><p>
                    The <code class="literal">LINEAR</code> keyword entails a somewhat
                    different algorithm. In this case, the number of the partition
                    in which a row is stored is calculated as the result of one or
                    more logical <a class="link" href="functions.html#operator_and"><code class="literal">AND</code></a> operations. For
                    discussion and examples of linear hashing, see
                    <a class="xref" href="partitioning.html#partitioning-linear-hash" title="22.2.4.1&nbsp;LINEAR HASH Partitioning">Section&nbsp;22.2.4.1, “LINEAR HASH Partitioning”</a>.
                </p><p style="color:blue;">线性关键字需要一个稍微不同的算法。在这种情况下，存储行的分区的数目是根据一个或多个逻辑与操作计算出来的。有关线性哈希的讨论和示例，请参见第22.2.4.1节“线性哈希分区”。</p></li><li class="listitem"><p>
                    <code class="literal">KEY(<em class="replaceable"><code>column_list</code></em>)</code>
                </p><p style="color:blue;">键（列列表）</p><p>
                    This is similar to <code class="literal">HASH</code>, except that MySQL
                    supplies the hashing function so as to guarantee an even data
                    distribution. The <em class="replaceable"><code>column_list</code></em>
                    argument is simply a list of 1 or more table columns (maximum:
                    16). This example shows a simple table partitioned by key,
                    with 4 partitions:
                </p><p style="color:blue;">这与hash类似，只是mysql提供了hash函数，以保证数据分布的均匀性。CalpnnLead参数仅仅是1个或多个表列（最大值：16）的列表。此示例显示了一个按键分区的简单表，其中有4个分区：</p><pre data-lang="sql" class="programlisting">CREATE TABLE tk (col1 INT, col2 CHAR(5), col3 DATE)
    PARTITION BY KEY(col3)
    PARTITIONS 4;
</pre><p>
                    For tables that are partitioned by key, you can employ linear
                    partitioning by using the <code class="literal">LINEAR</code> keyword.
                    This has the same effect as with tables that are partitioned
                    by <code class="literal">HASH</code>. That is, the partition number is
                    found using the
                    <a class="link" href="functions.html#operator_bitwise-and"><code class="literal">&amp;</code></a>
                    operator rather than the modulus (see
                    <a class="xref" href="partitioning.html#partitioning-linear-hash" title="22.2.4.1&nbsp;LINEAR HASH Partitioning">Section&nbsp;22.2.4.1, “LINEAR HASH Partitioning”</a>, and
                    <a class="xref" href="partitioning.html#partitioning-key" title="22.2.5&nbsp;KEY Partitioning">Section&nbsp;22.2.5, “KEY Partitioning”</a>, for details). This example
                    uses linear partitioning by key to distribute data between 5
                    partitions:
                </p><p style="color:blue;">对于按键分区的表，可以使用线性关键字进行线性分区。这与使用散列分区的表具有相同的效果。也就是说，分区号是使用&amp;运算符而不是模来找到的（有关详细信息，请参阅第22.2.4.1节“线性哈希分区”和第22.2.5节“密钥分区”）。此示例使用按键线性分区在5个分区之间分发数据：</p><pre data-lang="sql" class="programlisting">CREATE TABLE tk (col1 INT, col2 CHAR(5), col3 DATE)
    PARTITION BY LINEAR KEY(col3)
    PARTITIONS 5;
</pre><p>
                    The <code class="literal">ALGORITHM={1|2}</code> option is supported
                    with <code class="literal">[SUB]PARTITION BY [LINEAR] KEY</code>.
                    <code class="literal">ALGORITHM=1</code> causes the server to use the
                    same key-hashing functions as MySQL 5.1;
                    <code class="literal">ALGORITHM=2</code> means that the server employs
                    the key-hashing functions implemented and used by default for
                    new <code class="literal">KEY</code> partitioned tables in MySQL 5.5 and
                    later. (Partitioned tables created with the key-hashing
                    functions employed in MySQL 5.5 and later cannot be used by a
                    MySQL 5.1 server.) Not specifying the option has the same
                    effect as using <code class="literal">ALGORITHM=2</code>. This option is
                    intended for use chiefly when upgrading or downgrading
                    <code class="literal">[LINEAR] KEY</code> partitioned tables between
                    MySQL 5.1 and later MySQL versions, or for creating tables
                    partitioned by <code class="literal">KEY</code> or <code class="literal">LINEAR
                    KEY</code> on a MySQL 5.5 or later server which can be used
                    on a MySQL 5.1 server. For more information, see
                    <a class="xref" href="sql-syntax.html#alter-table-partition-operations" title="13.1.8.1&nbsp;ALTER TABLE Partition Operations">Section&nbsp;13.1.8.1, “ALTER TABLE Partition Operations”</a>.
                </p><p style="color:blue;">该算法＝{ 1×2 }选项由[SUB]分区由[线性]键支持。algorithm=1导致服务器使用与mysql 5.1相同的密钥散列函数；algorithm=2意味着服务器使用mysql 5.5及更高版本中默认实现并用于新的密钥分区表的密钥散列函数。（使用mysql 5.5及更高版本中使用的键散列函数创建的分区表不能由mysql 5.1服务器使用。）不指定该选项的效果与使用algorithm=2相同。此选项主要用于在mysql 5.1和更高版本之间升级或降级[线性]键分区表，或用于在mysql 5.5或更高版本的服务器上创建可在mysql 5.1服务器上使用的按键或线性键分区的表。有关更多信息，请参阅第13.1.8.1节“更改表分区操作”。</p><p>
                    <a class="link" href="programs.html#mysqldump" title="4.5.4&nbsp;mysqldump — A Database Backup Program"><span class="command"><strong>mysqldump</strong></span></a> in MySQL 5.7 (and later) writes
                    this option encased in versioned comments, like this:
                </p><p style="color:blue;">mysql 5.7（及更高版本）中的mysqldump将此选项写入版本控制的注释中，如下所示：</p><pre data-lang="sql" class="programlisting">CREATE TABLE t1 (a INT)
/*!50100 PARTITION BY KEY */ <span class="emphasis"><em>/*!50611 ALGORITHM = 1 */</em></span> /*!50100 ()
      PARTITIONS 3 */
</pre><p>
                    This causes MySQL 5.6.10 and earlier servers to ignore the
                    option, which would otherwise cause a syntax error in those
                    versions. If you plan to load a dump made on a MySQL 5.7
                    server where you use tables that are partitioned or
                    subpartitioned by <code class="literal">KEY</code> into a MySQL 5.6
                    server previous to version 5.6.11, be sure to consult
                    <a class="ulink" href="https://dev.mysql.com/doc/refman/5.6/en/upgrading-from-previous-series.html" target="_top">Changes in MySQL 5.6</a>,
                    before proceeding. (The information found there also applies
                    if you are loading a dump containing <code class="literal">KEY</code>
                    partitioned or subpartitioned tables made from a MySQL
                    5.7—actually 5.6.11 or later—server into a MySQL
                    5.5.30 or earlier server.)
                </p><p style="color:blue;">这将导致mysql 5.6.10和更早版本的服务器忽略该选项，否则将导致这些版本中的语法错误。如果计划将mysql 5.7服务器上的转储文件加载到5.6.11之前的mysql 5.6服务器中，其中使用了按键分区或子分区的表，请确保在继续之前参考mysql 5.6中的更改。（如果要将包含从mysql 5.7（实际上是5.6.11或更高版本的服务器）生成的键分区表或子分区表的转储加载到mysql 5.5.30或更早版本的服务器，则此处的信息也适用。）</p><p>
                    Also in MySQL 5.6.11 and later, <code class="literal">ALGORITHM=1</code>
                    is shown when necessary in the output of
                    <a class="link" href="sql-syntax.html#show-create-table" title="13.7.5.10&nbsp;SHOW CREATE TABLE Syntax"><code class="literal">SHOW CREATE TABLE</code></a> using
                    versioned comments in the same manner as
                    <a class="link" href="programs.html#mysqldump" title="4.5.4&nbsp;mysqldump — A Database Backup Program"><span class="command"><strong>mysqldump</strong></span></a>. <code class="literal">ALGORITHM=2</code>
                    is always omitted from <code class="literal">SHOW CREATE TABLE</code>
                    output, even if this option was specified when creating the
                    original table.
                </p><p style="color:blue;">同样在mysql 5.6.11及更高版本中，如果需要，将在show create table的输出中显示algorithm=1，使用与mysqldump相同的版本化注释。在show create table输出中始终忽略algorithm=2，即使在创建原始表时指定了此选项。</p><p>
                    You may not use either <code class="literal">VALUES LESS THAN</code> or
                    <code class="literal">VALUES IN</code> clauses with <code class="literal">PARTITION
                    BY KEY</code>.
                </p><p style="color:blue;">您不能在按键分区的子句中使用值小于或值。</p></li><li class="listitem"><p>
                    <code class="literal">RANGE(<em class="replaceable"><code>expr</code></em>)</code>
                </p><p style="color:blue;">范围（expr）</p><p>
                    In this case, <em class="replaceable"><code>expr</code></em> shows a range of
                    values using a set of <code class="literal">VALUES LESS THAN</code>
                    operators. When using range partitioning, you must define at
                    least one partition using <code class="literal">VALUES LESS THAN</code>.
                    You cannot use <code class="literal">VALUES IN</code> with range
                    partitioning.
                </p><p style="color:blue;">在这种情况下，expr使用一组小于运算符的值显示一系列值。使用范围分区时，必须使用小于的值定义至少一个分区。不能将中的值与范围分区一起使用。</p>
                    <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">

                        <div class="admon-title">
                            Note
                        </div>
                        <p>
                            For tables partitioned by <code class="literal">RANGE</code>,
                            <code class="literal">VALUES LESS THAN</code> must be used with either
                            an integer literal value or an expression that evaluates to
                            a single integer value. In MySQL 5.7, you can
                            overcome this limitation in a table that is defined using
                            <code class="literal">PARTITION BY RANGE COLUMNS</code>, as described
                            later in this section.
                        </p><p style="color:blue;">对于按范围划分的表，小于的值必须与整型文字值或计算结果为单个整数值的表达式一起使用。在MySQL 5.7中，您可以克服使用分区分区列定义的表中的限制，如本节后面所述。</p>
                    </div>
                    <p>
                        Suppose that you have a table that you wish to partition on a
                        column containing year values, according to the following
                        scheme.
                    </p><p style="color:blue;">假设您有一个表，希望根据以下方案在包含年份值的列上进行分区。</p>
                    <div class="informaltable">
                        <table summary="A table partitioning scheme based on a column containing year values, as described in the preceding text. The table lists partition numbers and corresponding range of years."><colgroup><col width="40%"><col width="60%"></colgroup><thead><tr>
                            <th scope="col">Partition Number:</th>
                            <th scope="col">Years Range:</th>
                        </tr></thead><tbody><tr>
                            <td scope="row">0</td>
                            <td>1990 and earlier</td>
                        </tr><tr>
                            <td scope="row">1</td>
                            <td>1991 to 1994</td>
                        </tr><tr>
                            <td scope="row">2</td>
                            <td>1995 to 1998</td>
                        </tr><tr>
                            <td scope="row">3</td>
                            <td>1999 to 2002</td>
                        </tr><tr>
                            <td scope="row">4</td>
                            <td>2003 to 2005</td>
                        </tr><tr>
                            <td scope="row">5</td>
                            <td>2006 and later</td>
                        </tr></tbody></table>
                    </div>
                    <p>
                        A table implementing such a partitioning scheme can be
                        realized by the <a class="link" href="sql-syntax.html#create-table" title="13.1.18&nbsp;CREATE TABLE Syntax"><code class="literal">CREATE TABLE</code></a>
                        statement shown here:
                    </p><p style="color:blue;">实现这种分区方案的表可以通过如下所示的create table语句来实现：</p><pre data-lang="sql" class="programlisting">CREATE TABLE t1 (
    year_col  INT,
    some_data INT
)
PARTITION BY RANGE (year_col) (
    PARTITION p0 VALUES LESS THAN (1991),
    PARTITION p1 VALUES LESS THAN (1995),
    PARTITION p2 VALUES LESS THAN (1999),
    PARTITION p3 VALUES LESS THAN (2002),
    PARTITION p4 VALUES LESS THAN (2006),
    PARTITION p5 VALUES LESS THAN MAXVALUE
);
</pre><p>
                        <code class="literal">PARTITION ... VALUES LESS THAN ...</code>
                        statements work in a consecutive fashion. <code class="literal">VALUES LESS
                        THAN MAXVALUE</code> works to specify
                        <span class="quote">“<span class="quote">leftover</span>”</span> values that are greater than the
                        maximum value otherwise specified.
                    </p><p style="color:blue;">分割…值小于…语句以连续的方式工作。小于Max值的值用于指定“剩余”值，该值大于其他指定的最大值。</p><p>
                        <code class="literal">VALUES LESS THAN</code> clauses work sequentially
                        in a manner similar to that of the <code class="literal">case</code>
                        portions of a <code class="literal">switch ... case</code> block (as
                        found in many programming languages such as C, Java, and PHP).
                        That is, the clauses must be arranged in such a way that the
                        upper limit specified in each successive <code class="literal">VALUES LESS
                        THAN</code> is greater than that of the previous one, with
                        the one referencing <code class="literal">MAXVALUE</code> coming last of
                        all in the list.
                    </p><p style="color:blue;">小于子句的值以类似于开关的case部分的方式顺序工作…case块（在许多编程语言中都有，如c、java和php）。也就是说，子句的排列方式必须使在每个小于的连续值中指定的上限大于前一个值的上限，并且引用maxvalue的值在列表中最后。</p></li><li class="listitem"><p>
                    <code class="literal">RANGE
                        COLUMNS(<em class="replaceable"><code>column_list</code></em>)</code>
                </p><p style="color:blue;">范围列（列列表）</p><p>
                    This variant on <code class="literal">RANGE</code> facilitates partition
                    pruning for queries using range conditions on multiple columns
                    (that is, having conditions such as <code class="literal">WHERE a = 1 AND b
                    &lt; 10</code> or <code class="literal">WHERE a = 1 AND b = 10 AND c
                    &lt; 10</code>). It enables you to specify value ranges in
                    multiple columns by using a list of columns in the
                    <code class="literal">COLUMNS</code> clause and a set of column values
                    in each <code class="literal">PARTITION ... VALUES LESS THAN
                    (<em class="replaceable"><code>value_list</code></em>)</code> partition
                    definition clause. (In the simplest case, this set consists of
                    a single column.) The maximum number of columns that can be
                    referenced in the <em class="replaceable"><code>column_list</code></em> and
                    <em class="replaceable"><code>value_list</code></em> is 16.
                </p><p style="color:blue;">范围上的此变量有助于使用多个列上的范围条件（即，具有条件，例如a=1和b&lt;10，或者a=1和b=10和c&lt;10）对查询进行分区修剪。它使您可以通过使用列子句中的列列表和每个分区中的一组列值来指定多个列中的值范围。值小于（value_list）分区定义子句。（在最简单的情况下，这个集合由一个列组成）。在CyrnnListand ValueEx列表中最多可以引用的列数是16。</p><p>
                    The <em class="replaceable"><code>column_list</code></em> used in the
                    <code class="literal">COLUMNS</code> clause may contain only names of
                    columns; each column in the list must be one of the following
                    MySQL data types: the integer types; the string types; and
                    time or date column types. Columns using
                    <code class="literal">BLOB</code>, <code class="literal">TEXT</code>,
                    <code class="literal">SET</code>, <code class="literal">ENUM</code>,
                    <code class="literal">BIT</code>, or spatial data types are not
                    permitted; columns that use floating-point number types are
                    also not permitted. You also may not use functions or
                    arithmetic expressions in the <code class="literal">COLUMNS</code>
                    clause.
                </p><p style="color:blue;">columns子句中使用的column_列表只能包含列的名称；列表中的每一列必须是以下mysql数据类型之一：整数类型、字符串类型以及时间或日期列类型。不允许使用blob、text、set、enum、bit或spatial数据类型的列；也不允许使用浮点数字类型的列。也不能在columns子句中使用函数或算术表达式。</p><p>
                    The <code class="literal">VALUES LESS THAN</code> clause used in a
                    partition definition must specify a literal value for each
                    column that appears in the <code class="literal">COLUMNS()</code>
                    clause; that is, the list of values used for each
                    <code class="literal">VALUES LESS THAN</code> clause must contain the
                    same number of values as there are columns listed in the
                    <code class="literal">COLUMNS</code> clause. An attempt to use more or
                    fewer values in a <code class="literal">VALUES LESS THAN</code> clause
                    than there are in the <code class="literal">COLUMNS</code> clause causes
                    the statement to fail with the error <span class="errortext">Inconsistency
          in usage of column lists for partitioning...</span>. You
                    cannot use <code class="literal">NULL</code> for any value appearing in
                    <code class="literal">VALUES LESS THAN</code>. It is possible to use
                    <code class="literal">MAXVALUE</code> more than once for a given column
                    other than the first, as shown in this example:
                </p><p style="color:blue;">分区定义中使用的values less than子句必须为columns（）子句中出现的每一列指定一个文本值；也就是说，用于每个values less than子句的值列表必须包含与columns子句中列出的列相同数量的值。尝试在values-less子句中使用比columns子句中更多或更少的值会导致语句失败，并在使用列列表进行分区时出现错误不一致…不能对小于的值中出现的任何值使用null。对于除第一列之外的给定列，可以多次使用maxvalue，如本例所示：</p><pre data-lang="sql" class="programlisting">CREATE TABLE rc (
    a INT NOT NULL,
    b INT NOT NULL
)
PARTITION BY RANGE COLUMNS(a,b) (
    PARTITION p0 VALUES LESS THAN (10,5),
    PARTITION p1 VALUES LESS THAN (20,10),
    PARTITION p2 VALUES LESS THAN (50,MAXVALUE),
    PARTITION p3 VALUES LESS THAN (65,MAXVALUE),
    PARTITION p4 VALUES LESS THAN (MAXVALUE,MAXVALUE)
);
</pre><p>
                    Each value used in a <code class="literal">VALUES LESS THAN</code> value
                    list must match the type of the corresponding column exactly;
                    no conversion is made. For example, you cannot use the string
                    <code class="literal">'1'</code> for a value that matches a column that
                    uses an integer type (you must use the numeral
                    <code class="literal">1</code> instead), nor can you use the numeral
                    <code class="literal">1</code> for a value that matches a column that
                    uses a string type (in such a case, you must use a quoted
                    string: <code class="literal">'1'</code>).
                </p><p style="color:blue;">值小于值列表中使用的每个值必须与相应列的类型完全匹配；不进行转换。例如，不能将字符串“1”用于与使用整数类型的列匹配的值（必须改用数字1），也不能将数字1用于与使用字符串类型的列匹配的值（在这种情况下，必须使用带引号的字符串：“1”）。</p><p>
                    For more information, see
                    <a class="xref" href="partitioning.html#partitioning-range" title="22.2.1&nbsp;RANGE Partitioning">Section&nbsp;22.2.1, “RANGE Partitioning”</a>, and
                    <a class="xref" href="partitioning.html#partitioning-pruning" title="22.4&nbsp;Partition Pruning">Section&nbsp;22.4, “Partition Pruning”</a>.
                </p><p style="color:blue;">有关更多信息，请参阅第22.2.1节“范围分区”和第22.4节“分区修剪”。</p></li><li class="listitem"><p>
                    <code class="literal">LIST(<em class="replaceable"><code>expr</code></em>)</code>
                </p><p style="color:blue;">列表（expr）</p><p>
                    This is useful when assigning partitions based on a table
                    column with a restricted set of possible values, such as a
                    state or country code. In such a case, all rows pertaining to
                    a certain state or country can be assigned to a single
                    partition, or a partition can be reserved for a certain set of
                    states or countries. It is similar to
                    <code class="literal">RANGE</code>, except that only <code class="literal">VALUES
                    IN</code> may be used to specify permissible values for
                    each partition.
                </p><p style="color:blue;">这在基于表列分配分区时非常有用，表列具有一组受限制的可能值，例如州或国家代码。在这种情况下，可以将与某个州或国家有关的所有行分配给单个分区，或者将某个分区保留给某组州或国家。它与range类似，只是只能使用中的值为每个分区指定允许的值。</p><p>
                    <code class="literal">VALUES IN</code> is used with a list of values to
                    be matched. For instance, you could create a partitioning
                    scheme such as the following:
                </p><p style="color:blue;">中的值与要匹配的值列表一起使用。例如，可以创建如下分区方案：</p><pre data-lang="sql" class="programlisting">CREATE TABLE client_firms (
    id   INT,
    name VARCHAR(35)
)
PARTITION BY LIST (id) (
    PARTITION r0 VALUES IN (1, 5, 9, 13, 17, 21),
    PARTITION r1 VALUES IN (2, 6, 10, 14, 18, 22),
    PARTITION r2 VALUES IN (3, 7, 11, 15, 19, 23),
    PARTITION r3 VALUES IN (4, 8, 12, 16, 20, 24)
);
</pre><p>
                    When using list partitioning, you must define at least one
                    partition using <code class="literal">VALUES IN</code>. You cannot use
                    <code class="literal">VALUES LESS THAN</code> with <code class="literal">PARTITION BY
                    LIST</code>.
                </p><p style="color:blue;">使用列表分区时，必须使用中的值定义至少一个分区。不能使用按列表分区的值。</p>
                    <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">

                        <div class="admon-title">
                            Note
                        </div>
                        <p>
                            For tables partitioned by <code class="literal">LIST</code>, the value
                            list used with <code class="literal">VALUES IN</code> must consist of
                            integer values only. In MySQL 5.7, you can
                            overcome this limitation using partitioning by <code class="literal">LIST
                            COLUMNS</code>, which is described later in this section.
                        </p><p style="color:blue;">对于按列表分区的表，与中的值一起使用的值列表只能由整数值组成。在mysql 5.7中，您可以使用按列表列进行分区来克服这一限制，本节稍后将对此进行描述。</p>
                    </div>
                </li><li class="listitem"><p>
                    <code class="literal">LIST
                        COLUMNS(<em class="replaceable"><code>column_list</code></em>)</code>
                </p><p style="color:blue;">列表列（列列表）</p><p>
                    This variant on <code class="literal">LIST</code> facilitates partition
                    pruning for queries using comparison conditions on multiple
                    columns (that is, having conditions such as <code class="literal">WHERE a =
                    5 AND b = 5</code> or <code class="literal">WHERE a = 1 AND b = 10 AND c
                    = 5</code>). It enables you to specify values in multiple
                    columns by using a list of columns in the
                    <code class="literal">COLUMNS</code> clause and a set of column values
                    in each <code class="literal">PARTITION ... VALUES IN
                    (<em class="replaceable"><code>value_list</code></em>)</code> partition
                    definition clause.
                </p><p style="color:blue;">列表中的此变量有助于使用多个列上的比较条件（即，具有条件，例如a=5和b=5，或者a=1和b=10和c=5）对查询进行分区修剪。它允许您通过使用列子句中的列列表和每个分区中的一组列值来指定多个列中的值。（value_list）分区定义子句中的值。</p><p>
                    The rules governing regarding data types for the column list
                    used in <code class="literal">LIST
                    COLUMNS(<em class="replaceable"><code>column_list</code></em>)</code> and
                    the value list used in <code class="literal">VALUES
                    IN(<em class="replaceable"><code>value_list</code></em>)</code> are the
                    same as those for the column list used in <code class="literal">RANGE
                    COLUMNS(<em class="replaceable"><code>column_list</code></em>)</code> and
                    the value list used in <code class="literal">VALUES LESS
                    THAN(<em class="replaceable"><code>value_list</code></em>)</code>,
                    respectively, except that in the <code class="literal">VALUES IN</code>
                    clause, <code class="literal">MAXVALUE</code> is not permitted, and you
                    may use <code class="literal">NULL</code>.
                </p><p style="color:blue;">关于列表列（column_list）中使用的列列表和（value_list）中使用的值列表的数据类型的规则，分别与范围列（column_list）中使用的列列表和小于值（value_list）中使用的值列表的规则相同，但在values in子句中除外，不允许使用maxvalue，您可以使用null。</p><p>
                    There is one important difference between the list of values
                    used for <code class="literal">VALUES IN</code> with <code class="literal">PARTITION
                    BY LIST COLUMNS</code> as opposed to when it is used with
                    <code class="literal">PARTITION BY LIST</code>. When used with
                    <code class="literal">PARTITION BY LIST COLUMNS</code>, each element in
                    the <code class="literal">VALUES IN</code> clause must be a
                    <span class="emphasis"><em>set</em></span> of column values; the number of
                    values in each set must be the same as the number of columns
                    used in the <code class="literal">COLUMNS</code> clause, and the data
                    types of these values must match those of the columns (and
                    occur in the same order). In the simplest case, the set
                    consists of a single column. The maximum number of columns
                    that can be used in the <em class="replaceable"><code>column_list</code></em>
                    and in the elements making up the
                    <em class="replaceable"><code>value_list</code></em> is 16.
                </p><p style="color:blue;">列表列分区中使用的值的列表有一个重要的区别，而不是当它与分区按列表一起使用时。当与分区列表列一起使用时，值子句中的每个元素必须是一组列值；每个集合中的值的数量必须与列子句中使用的列的数量相同，并且这些值的数据类型必须与列的那些类型（并且以相同的顺序发生）匹配。在最简单的情况下，集合由一个列组成。可以在CulnNoLIST列表和构成ValueEx列表的元素中使用的最大列数为16。</p><p>
                    The table defined by the following <code class="literal">CREATE
                    TABLE</code> statement provides an example of a table using
                    <code class="literal">LIST COLUMNS</code> partitioning:
                </p><p style="color:blue;">以下CREATE TABLE语句定义的表提供了使用列表列分区的表的示例：</p><pre data-lang="sql" class="programlisting">CREATE TABLE lc (
    a INT NULL,
    b INT NULL
)
PARTITION BY LIST COLUMNS(a,b) (
    PARTITION p0 VALUES IN( (0,0), (NULL,NULL) ),
    PARTITION p1 VALUES IN( (0,1), (0,2), (0,3), (1,1), (1,2) ),
    PARTITION p2 VALUES IN( (1,0), (2,0), (2,1), (3,0), (3,1) ),
    PARTITION p3 VALUES IN( (1,3), (2,2), (2,3), (3,2), (3,3) )
);
</pre></li><li class="listitem"><p>
                    <code class="literal">PARTITIONS <em class="replaceable"><code>num</code></em></code>
                </p><p style="color:blue;">分区num</p><p>
                    The number of partitions may optionally be specified with a
                    <code class="literal">PARTITIONS <em class="replaceable"><code>num</code></em></code>
                    clause, where <em class="replaceable"><code>num</code></em> is the number of
                    partitions. If both this clause <span class="emphasis"><em>and</em></span> any
                    <code class="literal">PARTITION</code> clauses are used,
                    <em class="replaceable"><code>num</code></em> must be equal to the total
                    number of any partitions that are declared using
                    <code class="literal">PARTITION</code> clauses.
                </p><p style="color:blue;">分区的数目可以可选地用分区num子句指定，其中num是分区的数目。如果使用此子句和任何分区子句，则NUM必须等于使用分区子句声明的任何分区的总数。</p>
                    <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">

                        <div class="admon-title">
                            Note
                        </div>
                        <p>
                            Whether or not you use a <code class="literal">PARTITIONS</code>
                            clause in creating a table that is partitioned by
                            <code class="literal">RANGE</code> or <code class="literal">LIST</code>, you
                            must still include at least one <code class="literal">PARTITION
                            VALUES</code> clause in the table definition (see below).
                        </p><p style="color:blue;">在创建由范围或列表分隔的表时，是否使用分区子句，您仍然必须在表定义中至少包含一个分区值子句（见下文）。</p>
                    </div>
                </li><li class="listitem"><p>
                    <code class="literal">SUBPARTITION BY</code>
                </p><p style="color:blue;">被剥夺</p><p>
                    A partition may optionally be divided into a number of
                    subpartitions. This can be indicated by using the optional
                    <code class="literal">SUBPARTITION BY</code> clause. Subpartitioning may
                    be done by <code class="literal">HASH</code> or <code class="literal">KEY</code>.
                    Either of these may be <code class="literal">LINEAR</code>. These work
                    in the same way as previously described for the equivalent
                    partitioning types. (It is not possible to subpartition by
                    <code class="literal">LIST</code> or <code class="literal">RANGE</code>.)
                </p><p style="color:blue;">分区可以选择性地划分为若干子分区。这可以通过使用子句的可选子分区来表示。子分区可以通过散列或键来完成。这两者都可能是线性的。它们的工作方式与前面对等效分区类型的描述相同。（无法按列表或范围细分。）</p><p>
                    The number of subpartitions can be indicated using the
                    <code class="literal">SUBPARTITIONS</code> keyword followed by an
                    integer value.
                </p><p style="color:blue;">子分区的数量可以用子分区关键字来表示，然后用整数值表示。</p></li><li class="listitem"><p>
                    Rigorous checking of the value used in
                    <code class="literal">PARTITIONS</code> or
                    <code class="literal">SUBPARTITIONS</code> clauses is applied and this
                    value must adhere to the following rules:
                </p><p style="color:blue;">对分区或子分区子句中使用的值进行严格检查，并且该值必须遵守以下规则：</p>
                    <div class="itemizedlist">
                        <ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
                            The value must be a positive, nonzero integer.
                        </p><p style="color:blue;">该值必须是正的非零整数。</p></li><li class="listitem"><p>
                            No leading zeros are permitted.
                        </p><p style="color:blue;">不允许前导零。</p></li><li class="listitem"><p>
                            The value must be an integer literal, and cannot not be an
                            expression. For example, <code class="literal">PARTITIONS
                            0.2E+01</code> is not permitted, even though
                            <code class="literal">0.2E+01</code> evaluates to
                            <code class="literal">2</code>. (Bug #15890)
                        </p><p style="color:blue;">该值必须是整数文本，并且不能是表达式。例如，不允许分区0.2E+ 01，即使0.2E+ 01评估为2。（错误15890）</p></li></ul>
                    </div>
                </li><li class="listitem"><p>
                    <code class="literal"><em class="replaceable"><code>partition_definition</code></em></code>
                </p><p style="color:blue;">分区定义</p><p>
                    Each partition may be individually defined using a
                    <em class="replaceable"><code>partition_definition</code></em> clause. The
                    individual parts making up this clause are as follows:
                </p><p style="color:blue;">每个分区可以使用分区定义子句单独定义。构成本条款的各个部分如下：</p>
                    <div class="itemizedlist">
                        <ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
                            <code class="literal">PARTITION
                                <em class="replaceable"><code>partition_name</code></em></code>
                        </p><p style="color:blue;">分区分区</p><p>
                            Specifies a logical name for the partition.
                        </p><p style="color:blue;">指定分区的逻辑名称。</p></li><li class="listitem"><p>
                            <code class="literal">VALUES</code>
                        </p><p style="color:blue;">价值观</p><p>
                            For range partitioning, each partition must include a
                            <code class="literal">VALUES LESS THAN</code> clause; for list
                            partitioning, you must specify a <code class="literal">VALUES
                            IN</code> clause for each partition. This is used to
                            determine which rows are to be stored in this partition.
                            See the discussions of partitioning types in
                            <a class="xref" href="partitioning.html" title="Chapter&nbsp;22&nbsp;Partitioning">Chapter&nbsp;22, <i>Partitioning</i></a>, for syntax examples.
                        </p><p style="color:blue;">对于范围分区，每个分区必须包含一个values less than子句；对于列表分区，必须为每个分区指定一个values in子句。这用于确定要在此分区中存储哪些行。有关语法示例，请参阅第22章“分区”中有关分区类型的讨论。</p></li><li class="listitem"><p>
                            <code class="literal">[STORAGE] ENGINE</code>
                        </p><p style="color:blue;">[存储]引擎</p><p>
                            The partitioning handler accepts a <code class="literal">[STORAGE]
                            ENGINE</code> option for both
                            <code class="literal">PARTITION</code> and
                            <code class="literal">SUBPARTITION</code>. Currently, the only way
                            in which this can be used is to set all partitions or all
                            subpartitions to the same storage engine, and an attempt
                            to set different storage engines for partitions or
                            subpartitions in the same table will give rise to the
                            error <span class="errortext">ERROR 1469 (HY000): The mix of handlers
              in the partitions is not permitted in this version of
              MySQL</span>. We expect to lift this restriction on
                            partitioning in a future MySQL release.
                        </p><p style="color:blue;">分区处理程序接受分区和子节点的[存储引擎]选项。目前，唯一可用的方法是将所有分区或所有子分区设置为同一存储引擎，如果试图为同一表中的分区或子分区设置不同的存储引擎，则会导致错误1469（hy000）：在此版本的mysql中不允许在分区中混合处理程序。我们希望在将来的mysql版本中取消对分区的限制。</p></li><li class="listitem"><p>
                            <code class="literal">COMMENT</code>
                        </p><p style="color:blue;">评论</p><p>
                            An optional <code class="literal">COMMENT</code> clause may be used
                            to specify a string that describes the partition. Example:
                        </p><p style="color:blue;">可选的comment子句可用于指定描述分区的字符串。例子：</p><pre data-lang="sql" class="programlisting">COMMENT = 'Data for the years previous to 1999'
</pre><p>
                            The maximum length for a partition comment is 1024
                            characters.
                        </p><p style="color:blue;">分区注释的最大长度为1024个字符。</p></li><li class="listitem"><p>
                            <code class="literal">DATA DIRECTORY</code> and <code class="literal">INDEX
                            DIRECTORY</code>
                        </p><p style="color:blue;">数据目录和索引目录</p><p>
                            <code class="literal">DATA DIRECTORY</code> and <code class="literal">INDEX
                            DIRECTORY</code> may be used to indicate the directory
                            where, respectively, the data and indexes for this
                            partition are to be stored. Both the
                            <code class="filename"><em class="replaceable"><code>data_dir</code></em></code>
                            and the
                            <code class="filename"><em class="replaceable"><code>index_dir</code></em></code>
                            must be absolute system path names.
                        </p><p style="color:blue;">数据目录和索引目录可用于指示将分别存储此分区的数据和索引的目录。数据目录和索引目录都必须是绝对系统路径名。</p><p>
                            As of MySQL 5.7.17, you must have the
                            <a class="link" href="security.html#priv_file"><code class="literal">FILE</code></a> privilege to use the
                            <code class="literal">DATA DIRECTORY</code> or <code class="literal">INDEX
                            DIRECTORY</code> partition option.
                        </p><p style="color:blue;">从mysql 5.7.17开始，您必须具有文件权限才能使用数据目录或索引目录分区选项。</p><p>
                            Example:
                        </p><p style="color:blue;">例子：</p><pre data-lang="sql" class="programlisting">CREATE TABLE th (id INT, name VARCHAR(30), adate DATE)
PARTITION BY LIST(YEAR(adate))
(
  PARTITION p1999 VALUES IN (1995, 1999, 2003)
    DATA DIRECTORY = '<code class="filename">/var/appdata/95/data</code>'
    INDEX DIRECTORY = '<code class="filename">/var/appdata/95/idx</code>',
  PARTITION p2000 VALUES IN (1996, 2000, 2004)
    DATA DIRECTORY = '<code class="filename">/var/appdata/96/data</code>'
    INDEX DIRECTORY = '<code class="filename">/var/appdata/96/idx</code>',
  PARTITION p2001 VALUES IN (1997, 2001, 2005)
    DATA DIRECTORY = '<code class="filename">/var/appdata/97/data</code>'
    INDEX DIRECTORY = '<code class="filename">/var/appdata/97/idx</code>',
  PARTITION p2002 VALUES IN (1998, 2002, 2006)
    DATA DIRECTORY = '<code class="filename">/var/appdata/98/data</code>'
    INDEX DIRECTORY = '<code class="filename">/var/appdata/98/idx</code>'
);
</pre><p>
                            <code class="literal">DATA DIRECTORY</code> and <code class="literal">INDEX
                            DIRECTORY</code> behave in the same way as in the
                            <a class="link" href="sql-syntax.html#create-table" title="13.1.18&nbsp;CREATE TABLE Syntax"><code class="literal">CREATE TABLE</code></a> statement's
                            <em class="replaceable"><code>table_option</code></em> clause as used for
                            <code class="literal">MyISAM</code> tables.
                        </p><p style="color:blue;">数据目录和索引目录的行为方式与create table语句的table_option子句中用于myisam表的方式相同。</p><p>
                            One data directory and one index directory may be
                            specified per partition. If left unspecified, the data and
                            indexes are stored by default in the table's database
                            directory.
                        </p><p style="color:blue;">每个分区可以指定一个数据目录和一个索引目录。如果未指定，则默认情况下，数据和索引存储在表的数据库目录中。</p><p>
                            On Windows, the <code class="literal">DATA DIRECTORY</code> and
                            <code class="literal">INDEX DIRECTORY</code> options are not
                            supported for individual partitions or subpartitions of
                            <a class="link" href="storage-engines.html#myisam-storage-engine" title="15.2&nbsp;The MyISAM Storage Engine"><code class="literal">MyISAM</code></a> tables, and the
                            <code class="literal">INDEX DIRECTORY</code> option is not supported
                            for individual partitions or subpartitions of
                            <a class="link" href="innodb-storage-engine.html" title="Chapter&nbsp;14&nbsp;The InnoDB Storage Engine"><code class="literal">InnoDB</code></a> tables. These options
                            are ignored on Windows, except that a warning is
                            generated. (Bug #30459)
                        </p><p style="color:blue;">在windows上，myisam表的单个分区或子分区不支持data directory和index directory选项，innodb表的单个分区或子分区不支持index directory选项。这些选项在Windows上被忽略，但会生成警告。（错误30459）</p>
                            <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">

                                <div class="admon-title">
                                    Note
                                </div>
                                <p>
                                    The <code class="literal">DATA DIRECTORY</code> and <code class="literal">INDEX
                                    DIRECTORY</code> options are ignored for creating
                                    partitioned tables if
                                    <a class="link" href="server-administration.html#sqlmode_no_dir_in_create"><code class="literal">NO_DIR_IN_CREATE</code></a> is in
                                    effect. (Bug #24633)
                                </p><p style="color:blue;">如果“创建”中没有有效的“数据目录”和“索引目录”选项，则在创建分区表时将忽略这些选项。（错误24633）</p>
                            </div>
                        </li><li class="listitem"><p>
                            <code class="literal">MAX_ROWS</code> and
                            <code class="literal">MIN_ROWS</code>
                        </p><p style="color:blue;">最大行和最小行</p><p>
                            May be used to specify, respectively, the maximum and
                            minimum number of rows to be stored in the partition. The
                            values for <em class="replaceable"><code>max_number_of_rows</code></em>
                            and <em class="replaceable"><code>min_number_of_rows</code></em> must be
                            positive integers. As with the table-level options with
                            the same names, these act only as
                            <span class="quote">“<span class="quote">suggestions</span>”</span> to the server and are not hard
                            limits.
                        </p><p style="color:blue;">可以用来分别指定要在分区中存储的行的最大和最小数目。max_number_of_rows和min_number_of_rows的值必须为正整数。与具有相同名称的表级选项一样，这些选项仅作为对服务器的“建议”，而不是硬限制。</p></li><li class="listitem"><p>
                            <code class="literal">TABLESPACE</code>
                        </p><p style="color:blue;">表空间</p><p>
                            May be used to designate a tablespace for the partition.
                            Supported by NDB Cluster. For <code class="literal">InnoDB</code>
                            tables, it may be used to designate a file-per-table
                            tablespace for the partition by specifying
                            <code class="literal">TABLESPACE `innodb_file_per_table`</code>. All
                            partitions must belong to the same storage engine.
                        </p><p style="color:blue;">可用于指定分区的表空间。由ndb集群支持。对于innodb tables，可以通过指定tablespace`innodb_file_per_table`来为分区指定每表表空间一个文件。所有分区必须属于同一存储引擎。</p>
                            <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">

                                <div class="admon-title">
                                    Note
                                </div>
                                <p>
                                    Support for placing <code class="literal">InnoDB</code> table
                                    partitions in shared <code class="literal">InnoDB</code>
                                    tablespaces is deprecated in MySQL 5.7.24 and will be
                                    removed in a future MySQL version. Shared tablespaces
                                    include the <code class="literal">InnoDB</code> system tablespace
                                    and general tablespaces.
                                </p><p style="color:blue;">mysql 5.7.24不支持将innodb表分区放在共享innodb表空间中，并将在以后的mysql版本中删除。共享表空间包括innodb系统表空间和通用表空间。</p>
                            </div>
                        </li></ul>
                    </div>
                </li><li class="listitem"><p>
                    <code class="literal"><em class="replaceable"><code>subpartition_definition</code></em></code>
                </p><p style="color:blue;">子部门定义</p><p>
                    The partition definition may optionally contain one or more
                    <em class="replaceable"><code>subpartition_definition</code></em> clauses.
                    Each of these consists at a minimum of the
                    <code class="literal">SUBPARTITION
                        <em class="replaceable"><code>name</code></em></code>, where
                    <em class="replaceable"><code>name</code></em> is an identifier for the
                    subpartition. Except for the replacement of the
                    <code class="literal">PARTITION</code> keyword with
                    <code class="literal">SUBPARTITION</code>, the syntax for a subpartition
                    definition is identical to that for a partition definition.
                </p><p style="color:blue;">分区定义可以选择性地包含一个或多个子分区定义子句。每一个都包含在子分区名称的最小值中，其中name是子分区的标识符。除了用子分区替换分区关键字之外，子分区定义的语法与分区定义的语法相同。</p><p>
                    Subpartitioning must be done by <code class="literal">HASH</code> or
                    <code class="literal">KEY</code>, and can be done only on
                    <code class="literal">RANGE</code> or <code class="literal">LIST</code>
                    partitions. See <a class="xref" href="partitioning.html#partitioning-subpartitions" title="22.2.6&nbsp;Subpartitioning">Section&nbsp;22.2.6, “Subpartitioning”</a>.
                </p><p style="color:blue;">子分区必须通过哈希或键完成，并且只能在范围分区或列表分区上完成。见第22.2.6节“分项”。</p></li></ul>
            </div>
            <p>
                <span class="bold"><strong>Partitioning by Generated Columns</strong></span>
            </p><p style="color:blue;">按生成列分区</p><p>
            Partitioning by generated columns is permitted. For example:
        </p><p style="color:blue;">允许按生成的列进行分区。例如：</p><pre data-lang="sql" class="programlisting">CREATE TABLE t1 (
  s1 INT,
  s2 INT AS (EXP(s1)) STORED
)
PARTITION BY LIST (s2) (
  PARTITION p1 VALUES IN (1)
);
</pre><p>
            Partitioning sees a generated column as a regular column, which
            enables workarounds for limitations on functions that are not
            permitted for partitioning (see
            <a class="xref" href="partitioning.html#partitioning-limitations-functions" title="22.6.3&nbsp;Partitioning Limitations Relating to Functions">Section&nbsp;22.6.3, “Partitioning Limitations Relating to Functions”</a>). The
            preceding example demonstrates this technique:
            <a class="link" href="functions.html#function_exp"><code class="literal">EXP()</code></a> cannot be used directly in
            the <code class="literal">PARTITION BY</code> clause, but a generated column
            defined using <a class="link" href="functions.html#function_exp"><code class="literal">EXP()</code></a> is permitted.
        </p><p style="color:blue;">分区将生成的列视为常规列，这样就可以解决不允许分区的函数限制（请参阅第22.6.3节“与函数相关的分区限制”）。前面的示例演示了该技术：Exchange（）不能直接在分区BY子句中使用，但允许使用ExpEd（）定义生成的列。</p>
            <div class="section">

                <div class="titlepage">
                    <div>
                        <div>
                            <h4 class="title"><a name="create-table-statement-retention"></a>13.1.18.1&nbsp;CREATE TABLE Statement Retention</h4>
                        </div>
                    </div>
                </div>
                <a class="indexterm" name="idm140286838306832"></a><a class="indexterm" name="idm140286838305344"></a><a class="indexterm" name="idm140286838303856"></a><p>
                The original <a class="link" href="sql-syntax.html#create-table" title="13.1.18&nbsp;CREATE TABLE Syntax"><code class="literal">CREATE TABLE</code></a>
                statement, including all specifications and table options are
                stored by MySQL when the table is created. The information is
                retained so that if you change storage engines, collations or
                other settings using an <a class="link" href="sql-syntax.html#alter-table" title="13.1.8&nbsp;ALTER TABLE Syntax"><code class="literal">ALTER
                TABLE</code></a> statement, the original table options specified
                are retained. This enables you to change between
                <a class="link" href="innodb-storage-engine.html" title="Chapter&nbsp;14&nbsp;The InnoDB Storage Engine"><code class="literal">InnoDB</code></a> and
                <a class="link" href="storage-engines.html#myisam-storage-engine" title="15.2&nbsp;The MyISAM Storage Engine"><code class="literal">MyISAM</code></a> table types even though the
                row formats supported by the two engines are different.
            </p><p style="color:blue;">原始的create table语句（包括所有规范和表选项）在创建表时由mysql存储。这些信息将被保留，以便在使用alter table语句更改存储引擎、排序规则或其他设置时，保留指定的原始表选项。这使您能够在innodb和myisam表类型之间进行更改，即使两个引擎支持的行格式不同。</p><p>
                Because the text of the original statement is retained, but due
                to the way that certain values and options may be silently
                reconfigured (such as the <code class="literal">ROW_FORMAT</code>), the
                active table definition (accessible through
                <a class="link" href="sql-syntax.html#describe" title="13.8.1&nbsp;DESCRIBE Syntax"><code class="literal">DESCRIBE</code></a> or with
                <a class="link" href="sql-syntax.html#show-table-status" title="13.7.5.36&nbsp;SHOW TABLE STATUS Syntax"><code class="literal">SHOW TABLE STATUS</code></a>) and the table
                creation string (accessible through <a class="link" href="sql-syntax.html#show-create-table" title="13.7.5.10&nbsp;SHOW CREATE TABLE Syntax"><code class="literal">SHOW
                CREATE TABLE</code></a>) will report different values.
            </p><p style="color:blue;">由于保留了原始语句的文本，但由于某些值和选项可以以静默方式重新配置（如行格式），活动表定义（可通过“描述”或“显示表状态”访问）和表创建字符串（可通过“显示创建表”访问）将报告不同的值。</p>
            </div>
            <div class="section">
                <div class="titlepage">
                    <div>
                        <div>
                            <h4 class="title"><a name="create-table-files"></a>13.1.18.2&nbsp;Files Created by CREATE TABLE</h4>

                        </div>

                    </div>

                </div>
                <a class="indexterm" name="idm140286838290224"></a><a class="indexterm" name="idm140286838288768"></a><a class="indexterm" name="idm140286838287696"></a><a class="indexterm" name="idm140286838286624"></a><a class="indexterm" name="idm140286838285552"></a><a class="indexterm" name="idm140286838284480"></a><p>
                MySQL represents each table by an <code class="filename">.frm</code>
                table format (definition) file in the database directory. The
                storage engine for the table might create other files as well.
            </p><p style="color:blue;">mysql通过数据库目录中的.frm表格式（定义）文件表示每个表。表的存储引擎也可能创建其他文件。</p><p>
                For an <code class="literal">InnoDB</code> table created in a
                file-per-table tablespace or general tablespace, table data and
                associated indexes are stored in a
                <a class="link" href="glossary.html#glos_ibd_file" title=".ibd file">.ibd file</a> in the database
                directory. When an <code class="literal">InnoDB</code> table is created in
                the system tablespace, table data and indexes are stored in the
                <a class="link" href="glossary.html#glos_ibdata_file" title="ibdata file">ibdata* files</a> that
                represent the system tablespace. The
                <a class="link" href="innodb-storage-engine.html#sysvar_innodb_file_per_table"><code class="literal">innodb_file_per_table</code></a> option
                controls whether tables are created in file-per-table
                tablespaces or the system tablespace, by default. The
                <code class="literal">TABLESPACE</code> option can be used to place a
                table in a file-per-table tablespace, general tablespace, or the
                system tablespace, regardless of the
                <a class="link" href="innodb-storage-engine.html#sysvar_innodb_file_per_table"><code class="literal">innodb_file_per_table</code></a> setting.
            </p><p style="color:blue;">对于在每个表空间或常规表空间的文件中创建的innodb表，表数据和相关索引存储在数据库目录的.ibd文件中。在系统表空间中创建innodb表时，表数据和索引存储在表示系统表空间的ibdata*文件中。默认情况下，innodb_file_per_table选项控制表是在file per table spaces中创建还是在系统表空间中创建。tablespace选项可用于将表放在file per table space、general table space或system tables space中，而不管innodb_file_per_table设置如何。</p><p>
                For <code class="literal">MyISAM</code> tables, the storage engine creates
                data and index files. Thus, for each <code class="literal">MyISAM</code>
                table <em class="replaceable"><code>tbl_name</code></em>, there are three disk
                files.
            </p><p style="color:blue;">对于myisam表，存储引擎创建数据和索引文件。因此，对于每个myisam table tbl_name，有三个磁盘文件。</p>
                <div class="informaltable">
                    <table summary="The purpose of MyISAM table tbl_name disk files."><colgroup><col width="30%"><col width="70%"></colgroup><thead><tr>
                        <th scope="col">File</th>
                        <th scope="col">Purpose</th>
                    </tr></thead><tbody><tr>
                        <td scope="row"><code class="filename"><em class="replaceable"><code>tbl_name</code></em>.frm</code></td>
                        <td>Table format (definition) file</td>
                    </tr><tr>
                        <td scope="row"><code class="filename"><em class="replaceable"><code>tbl_name</code></em>.MYD</code></td>
                        <td>Data file</td>
                    </tr><tr>
                        <td scope="row"><code class="filename"><em class="replaceable"><code>tbl_name</code></em>.MYI</code></td>
                        <td>Index file</td>
                    </tr></tbody></table>
                </div>
                <p>
                    <a class="xref" href="storage-engines.html" title="Chapter&nbsp;15&nbsp;Alternative Storage Engines">Chapter&nbsp;15, <i>Alternative Storage Engines</i></a>, describes what files each
                    storage engine creates to represent tables. If a table name
                    contains special characters, the names for the table files
                    contain encoded versions of those characters as described in
                    <a class="xref" href="language-structure.html#identifier-mapping" title="9.2.4&nbsp;Mapping of Identifiers to File Names">Section&nbsp;9.2.4, “Mapping of Identifiers to File Names”</a>.
                </p><p style="color:blue;">第15章，替代存储引擎，描述了每个存储引擎创建哪些文件来表示表。如果表名包含特殊字符，则表文件的名称包含这些字符的编码版本，如第9.2.4节“标识符到文件名的映射”所述。</p>
                <div class="simplesect">

                    <div class="titlepage">
                        <div>

                            <div class="simple">
                                <h5 class="title"><a name="limits-frm-file"></a>Limits Imposed by .frm File Structure</h5>
                            </div>
                        </div>
                    </div>
                    <p>
                        As described previously, each table has an
                        <code class="filename">.frm</code> file that contains the table
                        definition. The server uses the following expression to check
                        some of the table information stored in the file against an
                        upper limit of 64KB:
                    </p><p style="color:blue;">如前所述，每个表都有一个包含表定义的.frm文件。服务器使用以下表达式检查文件中存储的某些表信息，其上限为64KB：</p><pre data-lang="clike" class="programlisting">if (info_length+(ulong) create_fields.elements*FCOMP+288+
    n_length+int_length+com_length &gt; 65535L || int_count &gt; 255)
</pre><p>
                    The portion of the information stored in the
                    <code class="filename">.frm</code> file that is checked against the
                    expression cannot grow beyond the 64KB limit, so if the table
                    definition reaches this size, no more columns can be added.
                </p><p style="color:blue;">存储在.frm文件中的信息中对照表达式检查的部分不能超出64KB的限制，因此，如果表定义达到此大小，则不能再添加列。</p><p>
                    The relevant factors in the expression are:
                </p><p style="color:blue;">表达式中的相关因素有：</p>
                    <div class="itemizedlist">
                        <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                            <code class="literal">info_length</code> is space needed for
                            <span class="quote">“<span class="quote">screens.</span>”</span> This is related to MySQL's Unireg
                            heritage.
                        </p><p style="color:blue;">信息长度是“屏幕”所需的空间。这与MySQL的UniReg传统有关。</p></li><li class="listitem"><p>
                            <code class="literal">create_fields.elements</code> is the number of
                            columns.
                        </p><p style="color:blue;">create_fields.elements是列数。</p></li><li class="listitem"><p>
                            <code class="literal">FCOMP</code> is 17.
                        </p><p style="color:blue;">fcomp是17岁。</p></li><li class="listitem"><p>
                            <code class="literal">n_length</code> is the total length of all
                            column names, including one byte per name as a separator.
                        </p><p style="color:blue;">n_length是所有列名的总长度，包括每个名称一个字节作为分隔符。</p></li><li class="listitem"><p>
                            <code class="literal">int_length</code> is related to the list of
                            values for <a class="link" href="data-types.html#enum" title="11.4.4&nbsp;The ENUM Type"><code class="literal">ENUM</code></a> and
                            <a class="link" href="data-types.html#set" title="11.4.5&nbsp;The SET Type"><code class="literal">SET</code></a> columns. In this
                            context, <span class="quote">“<span class="quote">int</span>”</span> does not mean
                            <span class="quote">“<span class="quote">integer.</span>”</span> It means <span class="quote">“<span class="quote">interval,</span>”</span>
                            a term that refers collectively to
                            <a class="link" href="data-types.html#enum" title="11.4.4&nbsp;The ENUM Type"><code class="literal">ENUM</code></a> and
                            <a class="link" href="data-types.html#set" title="11.4.5&nbsp;The SET Type"><code class="literal">SET</code></a> columns.
                        </p><p style="color:blue;">int_length与枚举列和集合列的值列表相关。在此上下文中，“int”不是“integer”的意思，而是“interval”的意思，这是一个统称为enum和set列的术语。</p></li><li class="listitem"><p>
                            <code class="literal">int_count</code> is the number of unique
                            <a class="link" href="data-types.html#enum" title="11.4.4&nbsp;The ENUM Type"><code class="literal">ENUM</code></a> and
                            <a class="link" href="data-types.html#set" title="11.4.5&nbsp;The SET Type"><code class="literal">SET</code></a> definitions.
                        </p><p style="color:blue;">int_count是唯一枚举和集合定义的数目。</p></li><li class="listitem"><p>
                            <code class="literal">com_length</code> is the total length of
                            column comments.
                        </p><p style="color:blue;">com_length是列注释的总长度。</p></li></ul>
                    </div>
                    <p>
                        The expression just described has several implications for
                        permitted table definitions:
                    </p><p style="color:blue;">刚才描述的表达式对允许的表定义有几个含义：</p>
                    <div class="itemizedlist">
                        <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                            Using long column names can reduce the maximum number of
                            columns, as can the inclusion of
                            <a class="link" href="data-types.html#enum" title="11.4.4&nbsp;The ENUM Type"><code class="literal">ENUM</code></a> or
                            <a class="link" href="data-types.html#set" title="11.4.5&nbsp;The SET Type"><code class="literal">SET</code></a> columns, or use of
                            column comments.
                        </p><p style="color:blue;">使用长列名可以减少列的最大数目，也可以包含枚举或集合列，或者使用列注释。</p></li><li class="listitem"><p>
                            A table can have no more than 255 unique
                            <a class="link" href="data-types.html#enum" title="11.4.4&nbsp;The ENUM Type"><code class="literal">ENUM</code></a> and
                            <a class="link" href="data-types.html#set" title="11.4.5&nbsp;The SET Type"><code class="literal">SET</code></a> definitions. Columns
                            with identical element lists are considered the same
                            against this limt. For example, if a table contains these
                            two columns, they count as one (not two) toward this limit
                            because the definitions are identical:
                        </p><p style="color:blue;">表的唯一枚举和集定义不能超过255个。对于此限制，具有相同元素列表的列被认为是相同的。例如，如果一个表包含这两列，则由于定义相同，因此这两列将被视为一列（而不是两列）：</p><pre data-lang="sql" class="programlisting">e1 ENUM('a','b','c')
e2 ENUM('a','b','c')
</pre></li><li class="listitem"><p>
                            The sum of the length of element names in the unique
                            <a class="link" href="data-types.html#enum" title="11.4.4&nbsp;The ENUM Type"><code class="literal">ENUM</code></a> and
                            <a class="link" href="data-types.html#set" title="11.4.5&nbsp;The SET Type"><code class="literal">SET</code></a> definitions counts
                            toward the 64KB limit, so although the theoretical limit
                            on number of elements in a given
                            <a class="link" href="data-types.html#enum" title="11.4.4&nbsp;The ENUM Type"><code class="literal">ENUM</code></a> column is 65,535, the
                            practical limit is less than 3000.
                        </p><p style="color:blue;">唯一枚举和集合定义中元素名称的长度之和将向64KB限制计数，因此尽管给定枚举列中元素数量的理论限制为65535，但实际限制小于3000。</p></li></ul>
                    </div>

                </div>

            </div>
            <div class="section">
                <div class="titlepage">
                    <div>
                        <div>
                            <h4 class="title"><a name="create-temporary-table"></a>13.1.18.3&nbsp;CREATE TEMPORARY TABLE Syntax</h4>

                        </div>

                    </div>

                </div>
                <a class="indexterm" name="idm140286838214864"></a><a class="indexterm" name="idm140286838213824"></a><p>
                You can use the <code class="literal">TEMPORARY</code> keyword when
                creating a table. A <code class="literal">TEMPORARY</code> table is
                visible only within the current session, and is dropped
                automatically when the session is closed. This means that two
                different sessions can use the same temporary table name without
                conflicting with each other or with an existing
                non-<code class="literal">TEMPORARY</code> table of the same name. (The
                existing table is hidden until the temporary table is dropped.)
            </p><p style="color:blue;">创建表时可以使用临时关键字。临时表仅在当前会话中可见，并在会话关闭时自动删除。这意味着，两个不同的会话可以使用相同的临时表名而不相互冲突，也可以使用同一名称的现有非临时表。（已存在的表被隐藏，直到临时表被删除。）</p><p>
                <a class="link" href="sql-syntax.html#create-table" title="13.1.18&nbsp;CREATE TABLE Syntax"><code class="literal">CREATE TABLE</code></a> causes an implicit
                commit, except when used with the <code class="literal">TEMPORARY</code>
                keyword. See <a class="xref" href="sql-syntax.html#implicit-commit" title="13.3.3&nbsp;Statements That Cause an Implicit Commit">Section&nbsp;13.3.3, “Statements That Cause an Implicit Commit”</a>.
            </p><p style="color:blue;">CREATE TABLE导致隐式提交，但与临时关键字一起使用时除外。参见第13.3.3节，“导致隐式提交的语句”。</p><p>
                <code class="literal">TEMPORARY</code> tables have a very loose
                relationship with databases (schemas). Dropping a database does
                not automatically drop any <code class="literal">TEMPORARY</code> tables
                created within that database. Also, you can create a
                <code class="literal">TEMPORARY</code> table in a nonexistent database if
                you qualify the table name with the database name in the
                <code class="literal">CREATE TABLE</code> statement. In this case, all
                subsequent references to the table must be qualified with the
                database name.
            </p><p style="color:blue;">临时表与数据库（模式）的关系非常松散。删除数据库不会自动删除在该数据库中创建的任何临时表。此外，如果在创建表语句中使用数据库名限定表名，则可以在不存在的数据库中创建临时表。在这种情况下，对表的所有后续引用都必须使用数据库名称进行限定。</p><a class="indexterm" name="idm140286838202640"></a><a class="indexterm" name="idm140286838201152"></a><p>
                To create a temporary table, you must have the
                <a class="link" href="security.html#priv_create-temporary-tables"><code class="literal">CREATE TEMPORARY TABLES</code></a>
                privilege. After a session has created a temporary table, the
                server performs no further privilege checks on the table. The
                creating session can perform any operation on the table, such as
                <a class="link" href="sql-syntax.html#drop-table" title="13.1.29&nbsp;DROP TABLE Syntax"><code class="literal">DROP TABLE</code></a>,
                <a class="link" href="sql-syntax.html#insert" title="13.2.5&nbsp;INSERT Syntax"><code class="literal">INSERT</code></a>,
                <a class="link" href="sql-syntax.html#update" title="13.2.11&nbsp;UPDATE Syntax"><code class="literal">UPDATE</code></a>, or
                <a class="link" href="sql-syntax.html#select" title="13.2.9&nbsp;SELECT Syntax"><code class="literal">SELECT</code></a>.
            </p><p style="color:blue;">若要创建临时表，必须具有“创建临时表”权限。会话创建临时表后，服务器不再对该表执行权限检查。创建会话可以对表执行任何操作，例如删除表、插入、更新或选择。</p><p>
                One implication of this behavior is that a session can
                manipulate its temporary tables even if the current user has no
                privilege to create them. Suppose that the current user does not
                have the <a class="link" href="security.html#priv_create-temporary-tables"><code class="literal">CREATE TEMPORARY TABLES</code></a>
                privilege but is able to execute a definer-context stored
                procedure that executes with the privileges of a user who does
                have <a class="link" href="security.html#priv_create-temporary-tables"><code class="literal">CREATE TEMPORARY TABLES</code></a> and
                that creates a temporary table. While the procedure executes,
                the session uses the privileges of the defining user. After the
                procedure returns, the effective privileges revert to those of
                the current user, which can still see the temporary table and
                perform any operation on it.
            </p><p style="color:blue;">此行为的一个含义是，会话可以操作其临时表，即使当前用户没有创建它们的权限。假设当前用户没有create temporary tables权限，但能够执行definer上下文存储过程，该过程使用具有create temporary tables权限并创建临时表的用户的权限执行。执行过程时，会话使用定义用户的权限。返回过程后，有效权限将还原为当前用户的权限，该用户仍然可以看到临时表并对其执行任何操作。</p>
                <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">

                    <div class="admon-title">
                        Note
                    </div>
                    <p>
                        Support for <code class="literal">TABLESPACE =
                        innodb_file_per_table</code> and <code class="literal">TABLESPACE =
                        innodb_temporary</code> clauses with
                        <a class="link" href="sql-syntax.html#create-table" title="13.1.18&nbsp;CREATE TABLE Syntax"><code class="literal">CREATE TEMPORARY
                            TABLE</code></a> is deprecated as of MySQL 5.7.24 and will be
                        removed in a future version of MySQL.
                    </p><p style="color:blue;">从mysql 5.7.24开始，不支持tablespace=innodb_file_per_table和tablespace=innodb_temporary子句以及create temporary table，并将在mysql的未来版本中删除。</p>
                </div>

            </div>
            <div class="section">
                <div class="titlepage">
                    <div>
                        <div>
                            <h4 class="title"><a name="create-table-like"></a>13.1.18.4&nbsp;CREATE TABLE ... LIKE Syntax</h4>

                        </div>

                    </div>

                </div>
                <a class="indexterm" name="idm140286838184688"></a><a class="indexterm" name="idm140286838183648"></a><p>
                Use <code class="literal">CREATE TABLE ... LIKE</code> to create an empty
                table based on the definition of another table, including any
                column attributes and indexes defined in the original table:
            </p><p style="color:blue;">使用创建表…类似于基于另一个表的定义创建空表，包括在原始表中定义的任何列属性和索引：</p><pre data-lang="sql" class="programlisting">CREATE TABLE <em class="replaceable"><code>new_tbl</code></em> LIKE <em class="replaceable"><code>orig_tbl</code></em>;
</pre><p>
                The copy is created using the same version of the table storage
                format as the original table. The
                <a class="link" href="security.html#priv_select"><code class="literal">SELECT</code></a> privilege is required on
                the original table.
            </p><p style="color:blue;">使用与原始表相同的表存储格式版本创建副本。在原始表上需要选择权限。</p><p>
                <code class="literal">LIKE</code> works only for base tables, not for
                views.
            </p><p style="color:blue;">like只适用于基表，不适用于视图。</p>
                <div class="important" style="margin-left: 0.5in; margin-right: 0.5in;">

                    <div class="admon-title">
                        Important
                    </div>
                    <p>
                        You cannot execute <code class="literal">CREATE TABLE</code> or
                        <code class="literal">CREATE TABLE ... LIKE</code> while a
                        <a class="link" href="sql-syntax.html#lock-tables" title="13.3.5&nbsp;LOCK TABLES and UNLOCK TABLES Syntax"><code class="literal">LOCK TABLES</code></a> statement is in
                        effect.
                    </p><p style="color:blue;">不能执行CREATE TABLE或CREATE TABLE…就像当lock tables语句生效时一样。</p><p>
                    <a class="link" href="sql-syntax.html#create-table" title="13.1.18&nbsp;CREATE TABLE Syntax"><code class="literal">CREATE TABLE ...
                        LIKE</code></a> makes the same checks as
                    <a class="link" href="sql-syntax.html#create-table" title="13.1.18&nbsp;CREATE TABLE Syntax"><code class="literal">CREATE TABLE</code></a> and does not just
                    copy the <code class="filename">.frm</code> file. This means that if
                    the current SQL mode is different from the mode in effect when
                    the original table was created, the table definition might be
                    considered invalid for the new mode and the statement will
                    fail.
                </p><p style="color:blue;">创建表…like执行与create table相同的检查，而不仅仅是复制.frm文件。这意味着，如果当前sql模式与创建原始表时有效的模式不同，则表定义可能被视为对新模式无效，语句将失败。</p>
                </div>
                <p>
                    For <code class="literal">CREATE TABLE ... LIKE</code>, the destination
                    table preserves generated column information from the original
                    table.
                </p><p style="color:blue;">用于创建表…类似地，目标表保留原始表中生成的列信息。</p><p>
                <code class="literal">CREATE TABLE ... LIKE</code> does not preserve any
                <code class="literal">DATA DIRECTORY</code> or <code class="literal">INDEX
                DIRECTORY</code> table options that were specified for the
                original table, or any foreign key definitions.
            </p><p style="color:blue;">创建表…LIKE不保留为原始表指定的任何数据目录或索引目录表选项，也不保留任何外键定义。</p><p>
                If the original table is a <code class="literal">TEMPORARY</code> table,
                <code class="literal">CREATE TABLE ... LIKE</code> does not preserve
                <code class="literal">TEMPORARY</code>. To create a
                <code class="literal">TEMPORARY</code> destination table, use
                <code class="literal">CREATE TEMPORARY TABLE ... LIKE</code>.
            </p><p style="color:blue;">如果原始表是临时表，请创建表…喜欢不是暂时的。若要创建临时目标表，请使用“创建临时表…”就像。</p>
            </div>
            <div class="section">
                <div class="titlepage">
                    <div>
                        <div>
                            <h4 class="title"><a name="create-table-select"></a>13.1.18.5&nbsp;CREATE TABLE ... SELECT Syntax</h4>

                        </div>

                    </div>

                </div>
                <a class="indexterm" name="idm140286838159488"></a><a class="indexterm" name="idm140286838158448"></a><p>
                You can create one table from another by adding a
                <a class="link" href="sql-syntax.html#select" title="13.2.9&nbsp;SELECT Syntax"><code class="literal">SELECT</code></a> statement at the end of
                the <a class="link" href="sql-syntax.html#create-table" title="13.1.18&nbsp;CREATE TABLE Syntax"><code class="literal">CREATE TABLE</code></a> statement:
            </p><p style="color:blue;">通过在CREATE TABLE语句的末尾添加SELECT语句，可以从另一个表创建一个表：</p><pre data-lang="sql" class="programlisting">CREATE TABLE <em class="replaceable"><code>new_tbl</code></em> [AS] SELECT * FROM <em class="replaceable"><code>orig_tbl</code></em>;
</pre><p>
                MySQL creates new columns for all elements in the
                <a class="link" href="sql-syntax.html#select" title="13.2.9&nbsp;SELECT Syntax"><code class="literal">SELECT</code></a>. For example:
            </p><p style="color:blue;">mysql为select中的所有元素创建新列。例如：</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>CREATE TABLE test (a INT NOT NULL AUTO_INCREMENT,</code></strong>
    -&gt;        <strong class="userinput"><code>PRIMARY KEY (a), KEY(b))</code></strong>
    -&gt;        <strong class="userinput"><code>ENGINE=MyISAM SELECT b,c FROM test2;</code></strong>
</pre><p>
                This creates a <a class="link" href="storage-engines.html#myisam-storage-engine" title="15.2&nbsp;The MyISAM Storage Engine"><code class="literal">MyISAM</code></a> table with
                three columns, <code class="literal">a</code>, <code class="literal">b</code>, and
                <code class="literal">c</code>. The <code class="literal">ENGINE</code> option is
                part of the <a class="link" href="sql-syntax.html#create-table" title="13.1.18&nbsp;CREATE TABLE Syntax"><code class="literal">CREATE TABLE</code></a>
                statement, and should not be used following the
                <a class="link" href="sql-syntax.html#select" title="13.2.9&nbsp;SELECT Syntax"><code class="literal">SELECT</code></a>; this would result in a
                syntax error. The same is true for other
                <a class="link" href="sql-syntax.html#create-table" title="13.1.18&nbsp;CREATE TABLE Syntax"><code class="literal">CREATE TABLE</code></a> options such as
                <code class="literal">CHARSET</code>.
            </p><p style="color:blue;">这将创建一个包含三列a、b和c的myisam表。engine选项是create table语句的一部分，不应在select之后使用；这将导致语法错误。其他创建表选项（如charset）也是如此。</p><p>
                Notice that the columns from the
                <a class="link" href="sql-syntax.html#select" title="13.2.9&nbsp;SELECT Syntax"><code class="literal">SELECT</code></a> statement are appended to
                the right side of the table, not overlapped onto it. Take the
                following example:
            </p><p style="color:blue;">请注意，select语句中的列被追加到表的右侧，而不是重叠到表的右侧。举个例子：</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT * FROM foo;</code></strong>
+---+
| n |
+---+
| 1 |
+---+

mysql&gt; <strong class="userinput"><code>CREATE TABLE bar (m INT) SELECT n FROM foo;</code></strong>
Query OK, 1 row affected (0.02 sec)
Records: 1  Duplicates: 0  Warnings: 0

mysql&gt; <strong class="userinput"><code>SELECT * FROM bar;</code></strong>
+------+---+
| m    | n |
+------+---+
| NULL | 1 |
+------+---+
1 row in set (0.00 sec)
</pre><p>
                For each row in table <code class="literal">foo</code>, a row is inserted
                in <code class="literal">bar</code> with the values from
                <code class="literal">foo</code> and default values for the new columns.
            </p><p style="color:blue;">对于表foo中的每一行，在bar中插入一行，其中包含来自foo的值和新列的默认值。</p><p>
                In a table resulting from
                <a class="link" href="sql-syntax.html#create-table" title="13.1.18&nbsp;CREATE TABLE Syntax"><code class="literal">CREATE TABLE ...
                    SELECT</code></a>, columns named only in the
                <a class="link" href="sql-syntax.html#create-table" title="13.1.18&nbsp;CREATE TABLE Syntax"><code class="literal">CREATE TABLE</code></a> part come first.
                Columns named in both parts or only in the
                <a class="link" href="sql-syntax.html#select" title="13.2.9&nbsp;SELECT Syntax"><code class="literal">SELECT</code></a> part come after that. The
                data type of <a class="link" href="sql-syntax.html#select" title="13.2.9&nbsp;SELECT Syntax"><code class="literal">SELECT</code></a> columns can
                be overridden by also specifying the column in the
                <a class="link" href="sql-syntax.html#create-table" title="13.1.18&nbsp;CREATE TABLE Syntax"><code class="literal">CREATE TABLE</code></a> part.
            </p><p style="color:blue;">在由创建表生成的表中…选择，只在“创建表”部分中命名的列优先。在两个部分中或仅在“选择”部分中命名的列位于该部分之后。还可以通过在“创建表”部分中指定列来重写选定列的数据类型。</p><p>
                If any errors occur while copying the data to the table, it is
                automatically dropped and not created.
            </p><p style="color:blue;">如果在将数据复制到表中时发生任何错误，则会自动删除该数据，而不会创建该数据。</p><p>
                You can precede the <a class="link" href="sql-syntax.html#select" title="13.2.9&nbsp;SELECT Syntax"><code class="literal">SELECT</code></a> by
                <code class="literal">IGNORE</code> or <code class="literal">REPLACE</code> to
                indicate how to handle rows that duplicate unique key values.
                With <code class="literal">IGNORE</code>, rows that duplicate an existing
                row on a unique key value are discarded. With
                <code class="literal">REPLACE</code>, new rows replace rows that have the
                same unique key value. If neither <code class="literal">IGNORE</code> nor
                <code class="literal">REPLACE</code> is specified, duplicate unique key
                values result in an error. For more information, see
                <a class="xref" href="server-administration.html#ignore-strict-comparison" title="Comparison of the IGNORE Keyword and Strict SQL Mode">Comparison of the IGNORE Keyword and Strict SQL Mode</a>.
            </p><p style="color:blue;">可以在“忽略选择”或“替换选择”之前指示如何处理重复唯一键值的行。如果忽略，则放弃在唯一键值上复制现有行的行。使用replace，新行替换具有相同唯一键值的行。如果未指定ignore或replace，则重复的唯一键值将导致错误。有关详细信息，请参阅ignore关键字和strict sql模式的比较。</p><p>
                Because the ordering of the rows in the underlying
                <a class="link" href="sql-syntax.html#select" title="13.2.9&nbsp;SELECT Syntax"><code class="literal">SELECT</code></a> statements cannot always
                be determined, <code class="literal">CREATE TABLE ... IGNORE SELECT</code>
                and <code class="literal">CREATE TABLE ... REPLACE SELECT</code>
                statements are flagged as unsafe for statement-based
                replication. Such statements produce a warning in the error log
                when using statement-based mode and are written to the binary
                log using the row-based format when using
                <code class="literal">MIXED</code> mode. See also
                <a class="xref" href="replication.html#replication-sbr-rbr" title="16.2.1.1&nbsp;Advantages and Disadvantages of Statement-Based and Row-Based Replication">Section&nbsp;16.2.1.1, “Advantages and Disadvantages of Statement-Based and Row-Based
                    Replication”</a>.
            </p><p style="color:blue;">由于无法始终确定基础select语句中行的顺序，请创建表…忽略选择并创建表…对于基于语句的复制，replace select语句被标记为不安全。这种语句在使用基于语句的模式时在错误日志中生成警告，在使用混合模式时使用基于行的格式写入二进制日志。另见第16.2.1.1节“基于语句和基于行的复制的优缺点”。</p><p>
                <a class="link" href="sql-syntax.html#create-table" title="13.1.18&nbsp;CREATE TABLE Syntax"><code class="literal">CREATE TABLE ...
                    SELECT</code></a> does not automatically create any indexes for
                you. This is done intentionally to make the statement as
                flexible as possible. If you want to have indexes in the created
                table, you should specify these before the
                <a class="link" href="sql-syntax.html#select" title="13.2.9&nbsp;SELECT Syntax"><code class="literal">SELECT</code></a> statement:
            </p><p style="color:blue;">创建表…select不会自动为您创建任何索引。这是故意的，使陈述尽可能灵活。如果要在创建的表中包含索引，则应在select语句之前指定这些索引：</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>CREATE TABLE bar (UNIQUE (n)) SELECT n FROM foo;</code></strong>
</pre><p>
                For <code class="literal">CREATE TABLE ... SELECT</code>, the destination
                table does not preserve information about whether columns in the
                selected-from table are generated columns. The
                <a class="link" href="sql-syntax.html#select" title="13.2.9&nbsp;SELECT Syntax"><code class="literal">SELECT</code></a> part of the statement
                cannot assign values to generated columns in the destination
                table.
            </p><p style="color:blue;">用于创建表…选择时，目标表不会保留有关“从中选择”表中的列是否生成列的信息。语句的select部分无法将值赋给目标表中生成的列。</p><p>
                Some conversion of data types might occur. For example, the
                <code class="literal">AUTO_INCREMENT</code> attribute is not preserved,
                and <a class="link" href="data-types.html#char" title="11.4.1&nbsp;The CHAR and VARCHAR Types"><code class="literal">VARCHAR</code></a> columns can become
                <a class="link" href="data-types.html#char" title="11.4.1&nbsp;The CHAR and VARCHAR Types"><code class="literal">CHAR</code></a> columns. Retrained
                attributes are <code class="literal">NULL</code> (or <code class="literal">NOT
                NULL</code>) and, for those columns that have them,
                <code class="literal">CHARACTER SET</code>, <code class="literal">COLLATION</code>,
                <code class="literal">COMMENT</code>, and the <code class="literal">DEFAULT</code>
                clause.
            </p><p style="color:blue;">可能会发生数据类型的某些转换。例如，不保留auto_increment属性，varchar列可以变成char列。重新定义的属性为空（或不为空），对于具有这些属性的列，则为字符集、排序规则、注释和默认子句。</p><p>
                When creating a table with
                <a class="link" href="sql-syntax.html#create-table-select" title="13.1.18.5&nbsp;CREATE TABLE ... SELECT Syntax"><code class="literal">CREATE
                    TABLE ... SELECT</code></a>, make sure to alias any function
                calls or expressions in the query. If you do not, the
                <code class="literal">CREATE</code> statement might fail or result in
                undesirable column names.
            </p><p style="color:blue;">使用“创建表”创建表时…选择，确保对查询中的任何函数调用或表达式进行别名。否则，CREATE语句可能会失败或导致不需要的列名。</p><pre data-lang="sql" class="programlisting">CREATE TABLE artists_and_works
  SELECT artist.name, COUNT(work.artist_id) AS number_of_works
  FROM artist LEFT JOIN work ON artist.id = work.artist_id
  GROUP BY artist.id;
</pre><p>
                You can also explicitly specify the data type for a column in
                the created table:
            </p><p style="color:blue;">还可以显式指定已创建表中列的数据类型：</p><pre data-lang="sql" class="programlisting">CREATE TABLE foo (a TINYINT NOT NULL) SELECT b+1 AS a FROM bar;
</pre><p>
                For <a class="link" href="sql-syntax.html#create-table" title="13.1.18&nbsp;CREATE TABLE Syntax"><code class="literal">CREATE TABLE
                ... SELECT</code></a>, if <code class="literal">IF NOT EXISTS</code> is
                given and the target table exists, nothing is inserted into the
                destination table, and the statement is not logged.
            </p><p style="color:blue;">用于创建表…选择，如果不存在，并且目标表存在，则没有任何东西插入到目标表中，并且语句未被记录。</p><p>
                To ensure that the binary log can be used to re-create the
                original tables, MySQL does not permit concurrent inserts during
                <a class="link" href="sql-syntax.html#create-table" title="13.1.18&nbsp;CREATE TABLE Syntax"><code class="literal">CREATE TABLE ...
                    SELECT</code></a>.
            </p><p style="color:blue;">为了确保二进制日志可用于重新创建原始表，mysql不允许在创建表时并发插入…选择。</p><p>
                You cannot use <code class="literal">FOR UPDATE</code> as part of the
                <a class="link" href="sql-syntax.html#select" title="13.2.9&nbsp;SELECT Syntax"><code class="literal">SELECT</code></a> in a statement such as
                <a class="link" href="sql-syntax.html#create-table-select" title="13.1.18.5&nbsp;CREATE TABLE ... SELECT Syntax"><code class="literal">CREATE
                    TABLE <em class="replaceable"><code>new_table</code></em> SELECT ... FROM
                    <em class="replaceable"><code>old_table</code></em> ...</code></a>. If you
                attempt to do so, the statement fails.
            </p><p style="color:blue;">不能在语句（如CREATE TABLE NEW U TABLE SELECT）中将UPDATE用作SELECT的一部分…从旧桌子…如果尝试这样做，则语句将失败。</p>
            </div>
            <div class="section">
                <div class="titlepage">
                    <div>
                        <div>
                            <h4 class="title"><a name="create-table-foreign-keys"></a>13.1.18.6&nbsp;Using FOREIGN KEY Constraints</h4>

                        </div>

                    </div>

                </div>
                <a class="indexterm" name="idm140286838079920"></a><a class="indexterm" name="idm140286838078848"></a><p>
                MySQL supports foreign keys, which let you cross-reference
                related data across tables, and
                <a class="link" href="glossary.html#glos_foreign_key_constraint" title="FOREIGN KEY constraint">foreign key
                    constraints</a>, which help keep this spread-out data
                consistent. The essential syntax for a foreign key constraint
                definition in a <a class="link" href="sql-syntax.html#create-table" title="13.1.18&nbsp;CREATE TABLE Syntax"><code class="literal">CREATE TABLE</code></a> or
                <a class="link" href="sql-syntax.html#alter-table" title="13.1.8&nbsp;ALTER TABLE Syntax"><code class="literal">ALTER TABLE</code></a> statement looks like
                this:
            </p><p style="color:blue;">mysql支持外键，它允许跨表交叉引用相关数据，以及外键约束，这有助于保持这种分散数据的一致性。create table或alter table语句中外键约束定义的基本语法如下：</p><pre data-lang="sql" class="programlisting">[CONSTRAINT [<em class="replaceable"><code>symbol</code></em>]] FOREIGN KEY
    [<em class="replaceable"><code>index_name</code></em>] (<em class="replaceable"><code>col_name</code></em>, ...)
    REFERENCES <em class="replaceable"><code>tbl_name</code></em> (<em class="replaceable"><code>col_name</code></em>,...)
    [ON DELETE <em class="replaceable"><code>reference_option</code></em>]
    [ON UPDATE <em class="replaceable"><code>reference_option</code></em>]

<em class="replaceable"><code>reference_option</code></em>:
    RESTRICT | CASCADE | SET NULL | NO ACTION | SET DEFAULT
</pre><p>
                <em class="replaceable"><code>index_name</code></em> represents a foreign key
                ID. The <em class="replaceable"><code>index_name</code></em> value is ignored
                if there is already an explicitly defined index on the child
                table that can support the foreign key. Otherwise, MySQL
                implicitly creates a foreign key index that is named according
                to the following rules:
            </p><p style="color:blue;">index_name表示外键id。如果子表上已显式定义了可以支持外键的索引，则忽略index_name值。否则，mysql将隐式创建一个外键索引，该索引根据以下规则命名：</p>
                <div class="itemizedlist">
                    <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                        If defined, the <code class="literal">CONSTRAINT</code>
                        <em class="replaceable"><code>symbol</code></em> value is used. Otherwise,
                        the <code class="literal">FOREIGN KEY</code>
                        <em class="replaceable"><code>index_name</code></em> value is used.
                    </p><p style="color:blue;">如果已定义，则使用约束符号值。否则，将使用外键索引名称值。</p></li><li class="listitem"><p>
                        If neither a <code class="literal">CONSTRAINT</code>
                        <em class="replaceable"><code>symbol</code></em> or <code class="literal">FOREIGN
                        KEY</code> <em class="replaceable"><code>index_name</code></em> is
                        defined, the foreign key index name is generated using the
                        name of the referencing foreign key column.
                    </p><p style="color:blue;">如果未定义约束符号或外键索引名，则使用引用外键列的名称生成外键索引名。</p></li></ul>
                </div>
                <p>
                    Foreign keys definitions are subject to the following
                    conditions:
                </p><p style="color:blue;">外键定义受以下条件约束：</p>
                <div class="itemizedlist">
                    <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                        Foreign key relationships involve a
                        <a class="link" href="glossary.html#glos_parent_table" title="parent table">parent table</a> that
                        holds the central data values, and a
                        <a class="link" href="glossary.html#glos_child_table" title="child table">child table</a> with
                        identical values pointing back to its parent. The
                        <code class="literal">FOREIGN KEY</code> clause is specified in the
                        child table. The parent and child tables must use the same
                        storage engine. They must not be
                        <code class="literal">TEMPORARY</code> tables.
                    </p><p style="color:blue;">外键关系包括一个保存中心数据值的父表和一个指向其父表的值相同的子表。外键子句在子表中指定。父表和子表必须使用相同的存储引擎。它们不能是临时表。</p><p>
                        In MySQL 5.7, creation of a foreign key
                        constraint requires the
                        <a class="link" href="security.html#priv_references"><code class="literal">REFERENCES</code></a> privilege for the
                        parent table.
                    </p><p style="color:blue;">在mysql 5.7中，创建外键约束需要父表的references权限。</p></li><li class="listitem"><p>
                        Corresponding columns in the foreign key and the referenced
                        key must have similar data types. <span class="emphasis"><em>The size and
            sign of integer types must be the same</em></span>. The
                        length of string types need not be the same. For nonbinary
                        (character) string columns, the character set and collation
                        must be the same.
                    </p><p style="color:blue;">外键和引用键中的相应列必须具有相似的数据类型。整数类型的大小和符号必须相同。字符串类型的长度不必相同。对于非二进制（字符）字符串列，字符集和排序规则必须相同。</p></li><li class="listitem"><p>
                        When <a class="link" href="server-administration.html#sysvar_foreign_key_checks"><code class="literal">foreign_key_checks</code></a> is
                        enabled, which is the default setting, character set
                        conversion is not permitted on tables that include a
                        character string column used in a foreign key constraint.
                        The workaround is described in
                        <a class="xref" href="sql-syntax.html#alter-table" title="13.1.8&nbsp;ALTER TABLE Syntax">Section&nbsp;13.1.8, “ALTER TABLE Syntax”</a>.
                    </p><p style="color:blue;">如果启用了外键检查（这是默认设置），则不允许在包含外键约束中使用的字符串列的表上进行字符集转换。解决方法在第13.1.8节“更改表语法”中描述。</p></li><li class="listitem"><p>
                        MySQL requires indexes on foreign keys and referenced keys
                        so that foreign key checks can be fast and not require a
                        table scan. In the referencing table, there must be an index
                        where the foreign key columns are listed as the
                        <span class="emphasis"><em>first</em></span> columns in the same order. Such
                        an index is created on the referencing table automatically
                        if it does not exist. This index might be silently dropped
                        later, if you create another index that can be used to
                        enforce the foreign key constraint.
                        <em class="replaceable"><code>index_name</code></em>, if given, is used as
                        described previously.
                    </p><p style="color:blue;">mysql需要外键和引用键的索引，这样外键检查就可以很快，不需要表扫描。在引用表中，必须有一个索引，其中外键列按相同顺序列为第一列。如果引用表不存在，则自动在索引表上创建该索引。如果创建另一个可用于强制外键约束的索引，则稍后可能会自动删除此索引。索引名称（如果给定）如前所述使用。</p></li><li class="listitem"><p>
                        <code class="literal">InnoDB</code> permits a foreign key to reference
                        any index column or group of columns. However, in the
                        referenced table, there must be an index where the
                        referenced columns are the <span class="emphasis"><em>first</em></span>
                        columns in the same order. Hidden columns that
                        <code class="literal">InnoDB</code> adds to an index are also
                        considered (see <a class="xref" href="innodb-storage-engine.html#innodb-index-types" title="14.6.2.1&nbsp;Clustered and Secondary Indexes">Section&nbsp;14.6.2.1, “Clustered and Secondary Indexes”</a>).
                    </p><p style="color:blue;">innodb允许外键引用任何索引列或列组。但是，在被引用表中，必须有一个索引，其中被引用列是同一顺序的第一列。还考虑了innodb添加到索引中的隐藏列（参见14.6.2.1节，“聚集索引和辅助索引”）。</p><p>
                        <code class="literal">NDB</code> requires an explicit unique key (or
                        primary key) on any column referenced as a foreign key.
                    </p><p style="color:blue;">在作为外键引用的任何列上，ndb都需要显式的唯一键（或主键）。</p></li><li class="listitem"><p>
                        Index prefixes on foreign key columns are not supported. One
                        consequence of this is that
                        <a class="link" href="data-types.html#blob" title="11.4.3&nbsp;The BLOB and TEXT Types"><code class="literal">BLOB</code></a> and
                        <a class="link" href="data-types.html#blob" title="11.4.3&nbsp;The BLOB and TEXT Types"><code class="literal">TEXT</code></a> columns cannot be
                        included in a foreign key because indexes on those columns
                        must always include a prefix length.
                    </p><p style="color:blue;">不支持外键列上的索引前缀。这样做的一个结果是，blob列和text列不能包含在外键中，因为这些列上的索引必须始终包含前缀长度。</p></li><li class="listitem"><p>
                        If the <code class="literal">CONSTRAINT
                        <em class="replaceable"><code>symbol</code></em></code> clause is given,
                        the <em class="replaceable"><code>symbol</code></em> value, if used, must
                        be unique in the database. A duplicate
                        <em class="replaceable"><code>symbol</code></em> will result in an error
                        similar to: <span class="errortext">ERROR 1022 (2300): Can't write;
            duplicate key in table '#sql- 464_1'</span>. If the
                        clause is not given, or a <em class="replaceable"><code>symbol</code></em>
                        is not included following the <code class="literal">CONSTRAINT</code>
                        keyword, <a class="link" href="innodb-storage-engine.html" title="Chapter&nbsp;14&nbsp;The InnoDB Storage Engine"><code class="literal">InnoDB</code></a> automatically
                        generates a constraint name, whereas
                        <a class="link" href="mysql-cluster.html" title="Chapter&nbsp;21&nbsp;MySQL NDB Cluster 7.5 and NDB Cluster 7.6"><code class="literal">NDB</code></a> uses the foreign key index
                        name.
                    </p><p style="color:blue;">如果给定了约束符号子句，则符号值（如果使用）在数据库中必须是唯一的。重复的符号将导致类似以下错误：错误1022（2300）：无法写入；表'sql-464_1'中的重复键。如果没有给出子句，或者约束关键字后面没有包含符号，innodb会自动生成一个约束名，而ndb使用外键索引名。</p></li><li class="listitem"><p>
                        <a class="link" href="innodb-storage-engine.html" title="Chapter&nbsp;14&nbsp;The InnoDB Storage Engine"><code class="literal">InnoDB</code></a> does not currently
                        support foreign keys for tables with user-defined
                        partitioning. This includes both parent and child tables.
                    </p><p style="color:blue;">对于具有用户定义分区的表，innodb目前不支持外键。这包括父表和子表。</p><p>
                        This restriction does not apply for
                        <a class="link" href="mysql-cluster.html" title="Chapter&nbsp;21&nbsp;MySQL NDB Cluster 7.5 and NDB Cluster 7.6"><code class="literal">NDB</code></a> tables that are partitioned
                        by <code class="literal">KEY</code> or <code class="literal">LINEAR KEY</code>
                        (the only user partitioning types supported by the
                        <code class="literal">NDB</code> storage engine); these may have
                        foreign key references or be the targets of such references.
                    </p><p style="color:blue;">此限制不适用于按键或线性键（ndb存储引擎支持的唯一用户分区类型）分区的ndb表；这些表可能具有外键引用或是此类引用的目标。</p></li><li class="listitem"><p>
                        For <a class="link" href="mysql-cluster.html" title="Chapter&nbsp;21&nbsp;MySQL NDB Cluster 7.5 and NDB Cluster 7.6"><code class="literal">NDB</code></a> tables, <code class="literal">ON
                        UPDATE CASCADE</code> is not supported where the
                        reference is to the parent table's primary key.
                    </p><p style="color:blue;">对于ndb表，当引用是父表的主键时，不支持on update cascade。</p></li><li class="listitem"><p>
                        As of NDB 7.5.14 and NDB 7.6.10: For
                        <a class="link" href="mysql-cluster.html" title="Chapter&nbsp;21&nbsp;MySQL NDB Cluster 7.5 and NDB Cluster 7.6"><code class="literal">NDB</code></a> tables, <code class="literal">ON DELETE
                        CASCADE</code> is not supported where the child table
                        contains one or more columns of any of the
                        <a class="link" href="data-types.html#blob" title="11.4.3&nbsp;The BLOB and TEXT Types"><code class="literal">TEXT</code></a> or
                        <a class="link" href="data-types.html#blob" title="11.4.3&nbsp;The BLOB and TEXT Types"><code class="literal">BLOB</code></a> types. (Bug #89511, Bug
                        #27484882)
                    </p><p style="color:blue;">自ndb 7.5.14和ndb 7.6.10起：对于ndb表，如果子表包含任何文本或blob类型的一列或多列，则不支持on delete cascade。（错误89511，错误27484882）</p></li></ul>
                </div>
                <p>
                    Additional aspects of <code class="literal">FOREIGN KEY</code> constraint
                    usage are described under the following topics in this section:
                </p><p style="color:blue;">外键约束使用的其他方面将在本节的以下主题中介绍：</p>
                <div class="itemizedlist">
                    <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><a class="xref" href="sql-syntax.html#foreign-keys-referential-actions" title="Referential Actions">Referential Actions</a></p><p style="color:blue;">参照动作</p></li><li class="listitem"><p><a class="xref" href="sql-syntax.html#foreign-keys-examples" title="Examples of Foreign Key Clauses">Examples of Foreign Key Clauses</a></p><p style="color:blue;">外键子句示例</p></li><li class="listitem"><p><a class="xref" href="sql-syntax.html#foreign-keys-adding" title="Adding Foreign Keys">Adding Foreign Keys</a></p><p style="color:blue;">添加外键</p></li><li class="listitem"><p><a class="xref" href="sql-syntax.html#foreign-keys-dropping" title="Dropping Foreign Keys">Dropping Foreign Keys</a></p><p style="color:blue;">删除外键</p></li><li class="listitem"><p><a class="xref" href="sql-syntax.html#foreign-keys-other-statements" title="Foreign Keys and Other MySQL Statements">Foreign Keys and Other MySQL Statements</a></p><p style="color:blue;">外键和其他mysql语句</p></li><li class="listitem"><p><a class="xref" href="sql-syntax.html#foreign-keys-ansi-iso-sql-standard" title="Foreign Keys and the ANSI/ISO SQL Standard">Foreign Keys and the ANSI/ISO SQL Standard</a></p><p style="color:blue;">外键和ansi/iso sql标准</p></li><li class="listitem"><p><a class="xref" href="sql-syntax.html#foreign-key-metadata" title="Foreign Key Metadata">Foreign Key Metadata</a></p><p style="color:blue;">外键元数据</p></li><li class="listitem"><p><a class="xref" href="sql-syntax.html#foreign-key-errors" title="Foreign Key Errors">Foreign Key Errors</a></p><p style="color:blue;">外键错误</p></li></ul>
                </div>

                <div class="simplesect">

                    <div class="titlepage">
                        <div>

                            <div class="simple">
                                <h5 class="title"><a name="foreign-keys-referential-actions"></a>Referential Actions</h5>

                            </div>

                        </div>

                    </div>
                    <p>
                        This section describes how foreign keys help guarantee
                        <a class="link" href="glossary.html#glos_referential_integrity" title="referential integrity">referential
                            integrity</a>.
                    </p><p style="color:blue;">本节描述外键如何帮助保证引用完整性。</p><p>
                    For storage engines supporting foreign keys, MySQL rejects any
                    <a class="link" href="sql-syntax.html#insert" title="13.2.5&nbsp;INSERT Syntax"><code class="literal">INSERT</code></a> or
                    <a class="link" href="sql-syntax.html#update" title="13.2.11&nbsp;UPDATE Syntax"><code class="literal">UPDATE</code></a> operation that attempts
                    to create a foreign key value in a child table if there is no
                    a matching candidate key value in the parent table.
                </p><p style="color:blue;">对于支持外键的存储引擎，如果父表中没有匹配的候选键值，MySQL将拒绝任何试图在子表中创建外键值的插入或更新操作。</p><p>
                    When an <a class="link" href="sql-syntax.html#update" title="13.2.11&nbsp;UPDATE Syntax"><code class="literal">UPDATE</code></a> or
                    <a class="link" href="sql-syntax.html#delete" title="13.2.2&nbsp;DELETE Syntax"><code class="literal">DELETE</code></a> operation affects a key
                    value in the parent table that has matching rows in the child
                    table, the result depends on the <span class="emphasis"><em>referential
          action</em></span> specified using <code class="literal">ON UPDATE</code>
                    and <code class="literal">ON DELETE</code> subclauses of the
                    <code class="literal">FOREIGN KEY</code> clause. MySQL supports five
                    options regarding the action to be taken, listed here:
                </p><p style="color:blue;">当更新或删除操作影响父表中在子表中具有匹配行的键值时，结果取决于使用外键子句的on update和on delete子类指定的引用操作。mysql支持五个关于要采取的操作的选项，如下所示：</p>
                    <div class="itemizedlist">
                        <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                            <code class="literal">CASCADE</code>: Delete or update the row from
                            the parent table, and automatically delete or update the
                            matching rows in the child table. Both <code class="literal">ON DELETE
                            CASCADE</code> and <code class="literal">ON UPDATE CASCADE</code>
                            are supported. Between two tables, do not define several
                            <code class="literal">ON UPDATE CASCADE</code> clauses that act on
                            the same column in the parent table or in the child table.
                        </p><p style="color:blue;">级联：从父表中删除或更新行，并自动删除或更新子表中匹配的行。支持on delete cascade和on update cascade。在两个表之间，不要定义多个作用于父表或子表中同一列的on update cascade子句。</p><p>
                            If a <code class="literal">FOREIGN KEY</code> clause is defined on
                            both tables in a foreign key relationship, making both
                            tables a parent and child, an <code class="literal">ON UPDATE
                            CASCADE</code> or <code class="literal">ON DELETE CASCADE</code>
                            subclause defined for one <code class="literal">FOREIGN KEY</code>
                            clause must be defined for the other in order for
                            cascading operations to succeed. If an <code class="literal">ON UPDATE
                            CASCADE</code> or <code class="literal">ON DELETE CASCADE</code>
                            subclause is only defined for one <code class="literal">FOREIGN
                            KEY</code> clause, cascading operations fail with an
                            error.
                        </p><p style="color:blue;">如果在外键关系中的两个表上都定义了外键子句，使两个表都成为父表和子表，则必须为一个外键子句定义一个更新级联或删除级联子子句，以便级联操作成功。如果仅为一个外键子句定义了on update cascade或on delete cascade子子句，则级联操作将失败并出现错误。</p>
                            <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">

                                <div class="admon-title">
                                    Note
                                </div>
                                <p>
                                    Cascaded foreign key actions do not activate triggers.
                                </p><p style="color:blue;">级联外键操作不会激活触发器。</p>
                            </div>
                        </li><li class="listitem"><p>
                            <code class="literal">SET NULL</code>: Delete or update the row from
                            the parent table, and set the foreign key column or
                            columns in the child table to <code class="literal">NULL</code>.
                            Both <code class="literal">ON DELETE SET NULL</code> and <code class="literal">ON
                            UPDATE SET NULL</code> clauses are supported.
                        </p><p style="color:blue;">设置空：删除或更新父表中的行，并将子表中的外键列设置为空。支持on delete set null和on update set null子句。</p><p>
                            If you specify a <code class="literal">SET NULL</code> action,
                            <span class="emphasis"><em>make sure that you have not declared the columns
              in the child table as <code class="literal">NOT
              NULL</code></em></span>.
                        </p><p style="color:blue;">如果指定SET NULL操作，请确保未将子表中的列声明为NOT NULL。</p></li><li class="listitem"><p>
                            <code class="literal">RESTRICT</code>: Rejects the delete or update
                            operation for the parent table. Specifying
                            <code class="literal">RESTRICT</code> (or <code class="literal">NO
                            ACTION</code>) is the same as omitting the <code class="literal">ON
                            DELETE</code> or <code class="literal">ON UPDATE</code> clause.
                        </p><p style="color:blue;">限制：拒绝父表的删除或更新操作。指定restrict（或no action）与省略on delete或on update子句相同。</p></li><li class="listitem"><p>
                            <code class="literal">NO ACTION</code>: A keyword from standard SQL.
                            In MySQL, equivalent to <code class="literal">RESTRICT</code>. The
                            MySQL Server rejects the delete or update operation for
                            the parent table if there is a related foreign key value
                            in the referenced table. Some database systems have
                            deferred checks, and <code class="literal">NO ACTION</code> is a
                            deferred check. In MySQL, foreign key constraints are
                            checked immediately, so <code class="literal">NO ACTION</code> is
                            the same as <code class="literal">RESTRICT</code>.
                        </p><p style="color:blue;">无操作：标准SQL中的关键字。在mysql中，相当于restrict。如果引用表中有相关外键值，mysql服务器将拒绝父表的删除或更新操作。有些数据库系统有延迟检查，没有操作是延迟检查。在mysql中，会立即检查外键约束，因此没有任何操作与restrict相同。</p></li><li class="listitem"><p>
                            <code class="literal">SET DEFAULT</code>: This action is recognized
                            by the MySQL parser, but both
                            <a class="link" href="innodb-storage-engine.html" title="Chapter&nbsp;14&nbsp;The InnoDB Storage Engine"><code class="literal">InnoDB</code></a> and
                            <a class="link" href="mysql-cluster.html" title="Chapter&nbsp;21&nbsp;MySQL NDB Cluster 7.5 and NDB Cluster 7.6"><code class="literal">NDB</code></a> reject table definitions
                            containing <code class="literal">ON DELETE SET DEFAULT</code> or
                            <code class="literal">ON UPDATE SET DEFAULT</code> clauses.
                        </p><p style="color:blue;">set default：这个动作被mysql解析器识别，但是innodb和ndb都拒绝包含on delete set default或on update set default子句的表定义。</p></li></ul>
                    </div>
                    <p>
                        For an <code class="literal">ON DELETE</code> or <code class="literal">ON
                        UPDATE</code> that is not specified, the default action is
                        always <code class="literal">RESTRICT</code>.
                    </p><p style="color:blue;">对于未指定的on delete或on update，默认操作始终是restrict。</p><p>
                    MySQL supports foreign key references between one column and
                    another within a table. (A column cannot have a foreign key
                    reference to itself.) In these cases, <span class="quote">“<span class="quote">child table
          records</span>”</span> really refers to dependent records within the
                    same table.
                </p><p style="color:blue;">mysql支持表中一列和另一列之间的外键引用。（列不能有对自身的外键引用。）在这些情况下，“子表记录”实际上是指同一表中的依赖记录。</p><p>
                    A foreign key constraint on a stored generated column cannot
                    use <code class="literal">CASCADE</code>, <code class="literal">SET NULL</code>,
                    or <code class="literal">SET DEFAULT</code> as <code class="literal">ON
                    UPDATE</code> referential actions, nor can it use
                    <code class="literal">SET NULL</code> or <code class="literal">SET DEFAULT</code>
                    as <code class="literal">ON DELETE</code> referential actions.
                </p><p style="color:blue;">存储生成列上的外键约束不能在更新引用操作时使用cascade、set null或set default，也不能在删除引用操作时使用set null或set default。</p><p>
                    A foreign key constraint on the base column of a stored
                    generated column cannot use <code class="literal">CASCADE</code>,
                    <code class="literal">SET NULL</code>, or <code class="literal">SET DEFAULT</code>
                    as <code class="literal">ON UPDATE</code> or <code class="literal">ON
                    DELETE</code> referential actions.
                </p><p style="color:blue;">存储的生成列的基列上的外键约束不能使用cascade、set null或set default as on update或on delete引用操作。</p><p>
                    A foreign key constraint cannot reference a virtual generated
                    column.
                </p><p style="color:blue;">外键约束不能引用虚拟生成的列。</p><p>
                    For <code class="literal">InnoDB</code> restrictions related to foreign
                    keys and generated columns, see
                    <a class="xref" href="innodb-storage-engine.html#innodb-foreign-key-constraints" title="14.6.1.5&nbsp;InnoDB and FOREIGN KEY Constraints">Section&nbsp;14.6.1.5, “InnoDB and FOREIGN KEY Constraints”</a>.
                </p><p style="color:blue;">有关与外键和生成列相关的innodb限制，请参阅第14.6.1.5节“innodb和外键限制”。</p>
                </div>
                <div class="simplesect">
                    <div class="titlepage">
                        <div>
                            <div class="simple">
                                <h5 class="title"><a name="foreign-keys-examples"></a>Examples of Foreign Key Clauses</h5>

                            </div>

                        </div>

                    </div>
                    <p>
                        Here is a simple example that relates
                        <code class="literal">parent</code> and <code class="literal">child</code> tables
                        through a single-column foreign key:
                    </p><p style="color:blue;">下面是一个简单的示例，它通过一个列外键将父表和子表关联起来：</p><pre data-lang="sql" class="programlisting">CREATE TABLE parent (
    id INT NOT NULL,
    PRIMARY KEY (id)
) ENGINE=INNODB;

CREATE TABLE child (
    id INT,
    parent_id INT,
    INDEX par_ind (parent_id),
    FOREIGN KEY (parent_id)
        REFERENCES parent(id)
        ON DELETE CASCADE
) ENGINE=INNODB;
</pre><p>
                    A more complex example in which a
                    <code class="literal">product_order</code> table has foreign keys for
                    two other tables. One foreign key references a two-column
                    index in the <code class="literal">product</code> table. The other
                    references a single-column index in the
                    <code class="literal">customer</code> table:
                </p><p style="color:blue;">一个更复杂的例子，其中一个product_order表对另外两个表具有外键。一个外键引用产品表中的两列索引。另一个引用customer表中的单个列索引：</p><pre data-lang="sql" class="programlisting">CREATE TABLE product (
    category INT NOT NULL, id INT NOT NULL,
    price DECIMAL,
    PRIMARY KEY(category, id)
)   ENGINE=INNODB;

CREATE TABLE customer (
    id INT NOT NULL,
    PRIMARY KEY (id)
)   ENGINE=INNODB;

CREATE TABLE product_order (
    no INT NOT NULL AUTO_INCREMENT,
    product_category INT NOT NULL,
    product_id INT NOT NULL,
    customer_id INT NOT NULL,

    PRIMARY KEY(no),
    INDEX (product_category, product_id),
    INDEX (customer_id),

    FOREIGN KEY (product_category, product_id)
      REFERENCES product(category, id)
      ON UPDATE CASCADE ON DELETE RESTRICT,

    FOREIGN KEY (customer_id)
      REFERENCES customer(id)
)   ENGINE=INNODB;
</pre>
                </div>
                <div class="simplesect">
                    <div class="titlepage">
                        <div>
                            <div class="simple">
                                <h5 class="title"><a name="foreign-keys-adding"></a>Adding Foreign Keys</h5>

                            </div>

                        </div>

                    </div>
                    <p>
                        You can add a new foreign key constraint to an existing table
                        by using <a class="link" href="sql-syntax.html#alter-table" title="13.1.8&nbsp;ALTER TABLE Syntax"><code class="literal">ALTER TABLE</code></a>. The
                        syntax relating to foreign keys for this statement is shown
                        here:
                    </p><p style="color:blue;">可以使用ALTE表向现有表添加新的外键约束。与此语句外键相关的语法如下所示：</p><pre data-lang="sql" class="programlisting">ALTER TABLE <em class="replaceable"><code>tbl_name</code></em>
    ADD [CONSTRAINT [<em class="replaceable"><code>symbol</code></em>]] FOREIGN KEY
    [<em class="replaceable"><code>index_name</code></em>] (<em class="replaceable"><code>col_name</code></em>, ...)
    REFERENCES <em class="replaceable"><code>tbl_name</code></em> (<em class="replaceable"><code>col_name</code></em>,...)
    [ON DELETE <em class="replaceable"><code>reference_option</code></em>]
    [ON UPDATE <em class="replaceable"><code>reference_option</code></em>]
</pre><p>
                    The foreign key can be self referential (referring to the same
                    table). When you add a foreign key constraint to a table using
                    <a class="link" href="sql-syntax.html#alter-table" title="13.1.8&nbsp;ALTER TABLE Syntax"><code class="literal">ALTER TABLE</code></a>, <span class="emphasis"><em>remember
          to create the required indexes first.</em></span>
                </p><p style="color:blue;">外键可以是自引用的（引用同一个表）。使用alter table向表添加外键约束时，请记住首先创建所需的索引。</p>
                </div>
                <div class="simplesect">
                    <div class="titlepage">
                        <div>
                            <div class="simple">
                                <h5 class="title"><a name="foreign-keys-dropping"></a>Dropping Foreign Keys</h5>

                            </div>

                        </div>

                    </div>
                    <a class="indexterm" name="idm140286837923536"></a><a class="indexterm" name="idm140286837922464"></a><a class="indexterm" name="idm140286837920976"></a><p>
                    You can also use <a class="link" href="sql-syntax.html#alter-table" title="13.1.8&nbsp;ALTER TABLE Syntax"><code class="literal">ALTER TABLE</code></a> to
                    drop foreign keys, using the syntax shown here:
                </p><p style="color:blue;">还可以使用alter table删除外键，语法如下：</p><pre data-lang="sql" class="programlisting">ALTER TABLE <em class="replaceable"><code>tbl_name</code></em> DROP FOREIGN KEY <em class="replaceable"><code>fk_symbol</code></em>;
</pre><p>
                    If the <code class="literal">FOREIGN KEY</code> clause included a
                    <code class="literal">CONSTRAINT</code> name when you created the
                    foreign key, you can refer to that name to drop the foreign
                    key. Otherwise, the <em class="replaceable"><code>fk_symbol</code></em> value
                    is generated internally when the foreign key is created. To
                    find out the symbol value when you want to drop a foreign key,
                    use a <a class="link" href="sql-syntax.html#show-create-table" title="13.7.5.10&nbsp;SHOW CREATE TABLE Syntax"><code class="literal">SHOW CREATE TABLE</code></a>
                    statement, as shown here:
                </p><p style="color:blue;">如果在创建外键时外键子句包含约束名称，则可以引用该名称来删除外键。否则，在创建外键时会在内部生成fk_符号值。要在要删除外键时查找符号值，请使用show create table语句，如下所示：</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>SHOW CREATE TABLE ibtest11c\G</code></strong>
*************************** 1. row ***************************
       Table: ibtest11c
Create Table: CREATE TABLE `ibtest11c` (
  `A` int(11) NOT NULL auto_increment,
  `D` int(11) NOT NULL default '0',
  `B` varchar(200) NOT NULL default '',
  `C` varchar(175) default NULL,
  PRIMARY KEY  (`A`,`D`,`B`),
  KEY `B` (`B`,`C`),
  KEY `C` (`C`),
  CONSTRAINT `0_38775` FOREIGN KEY (`A`, `D`)
REFERENCES `ibtest11a` (`A`, `D`)
ON DELETE CASCADE ON UPDATE CASCADE,
  CONSTRAINT `0_38776` FOREIGN KEY (`B`, `C`)
REFERENCES `ibtest11a` (`B`, `C`)
ON DELETE CASCADE ON UPDATE CASCADE
) ENGINE=INNODB CHARSET=latin1
1 row in set (0.01 sec)

mysql&gt; <strong class="userinput"><code>ALTER TABLE ibtest11c DROP FOREIGN KEY `0_38775`;</code></strong>
</pre><p>
                    Adding and dropping a foreign key in the same
                    <a class="link" href="sql-syntax.html#alter-table" title="13.1.8&nbsp;ALTER TABLE Syntax"><code class="literal">ALTER TABLE</code></a> statement is
                    supported for
                    <a class="link" href="sql-syntax.html#alter-table" title="13.1.8&nbsp;ALTER TABLE Syntax"><code class="literal">ALTER TABLE ...
                        ALGORITHM=INPLACE</code></a> but remains unsupported for
                    <a class="link" href="sql-syntax.html#alter-table" title="13.1.8&nbsp;ALTER TABLE Syntax"><code class="literal">ALTER TABLE ...
                        ALGORITHM=COPY</code></a>.
                </p><p style="color:blue;">alter table支持在同一alter table语句中添加和删除外键…algorithm=inplace，但仍不支持alter table…算法=复制。</p>
                </div>
                <div class="simplesect">
                    <div class="titlepage">
                        <div>
                            <div class="simple">
                                <h5 class="title"><a name="foreign-keys-other-statements"></a>Foreign Keys and Other MySQL Statements</h5>

                            </div>

                        </div>

                    </div>
                    <p>
                        Table and column identifiers in a <code class="literal">FOREIGN KEY ...
                        REFERENCES ...</code> clause can be quoted within backticks
                        (<code class="literal">`</code>). Alternatively, double quotation marks
                        (<code class="literal">"</code>) can be used if the
                        <a class="link" href="server-administration.html#sqlmode_ansi_quotes"><code class="literal">ANSI_QUOTES</code></a> SQL mode is
                        enabled. The setting of the
                        <a class="link" href="server-administration.html#sysvar_lower_case_table_names"><code class="literal">lower_case_table_names</code></a> system
                        variable is also taken into account.
                    </p><p style="color:blue;">外键中的表和列标识符…参考资料…子句可以在倒勾（`）内引用。或者，如果启用了ansi_quotes sql模式，则可以使用双引号（“）。还考虑了小写字母表名称系统变量的设置。</p><p>
                    You can view a child table's foreign key definitions as
                    part of the output of the <a class="link" href="sql-syntax.html#show-create-table" title="13.7.5.10&nbsp;SHOW CREATE TABLE Syntax"><code class="literal">SHOW CREATE
                    TABLE</code></a> statement:
                </p><p style="color:blue;">可以在show create table语句的输出中查看子表的外键定义：</p><pre data-lang="sql" class="programlisting">SHOW CREATE TABLE <em class="replaceable"><code>tbl_name</code></em>;
</pre><p>
                    You can also obtain information about foreign keys by querying
                    the
                    <a class="link" href="information-schema.html#key-column-usage-table" title="24.12&nbsp;The INFORMATION_SCHEMA KEY_COLUMN_USAGE Table"><code class="literal">INFORMATION_SCHEMA.KEY_COLUMN_USAGE</code></a>
                    table.
                </p><p style="color:blue;">您还可以通过查询information_schema.key_column_usage表来获取有关外键的信息。</p><p>
                    You can find information about foreign keys used by
                    <a class="link" href="innodb-storage-engine.html" title="Chapter&nbsp;14&nbsp;The InnoDB Storage Engine"><code class="literal">InnoDB</code></a> tables in the
                    <a class="link" href="information-schema.html#innodb-sys-foreign-table" title="24.32.19&nbsp;The INFORMATION_SCHEMA INNODB_SYS_FOREIGN Table"><code class="literal">INNODB_SYS_FOREIGN</code></a> and
                    <a class="link" href="information-schema.html#innodb-sys-foreign-cols-table" title="24.32.20&nbsp;The INFORMATION_SCHEMA INNODB_SYS_FOREIGN_COLS Table"><code class="literal">INNODB_SYS_FOREIGN_COLS</code></a> tables,
                    also in the <code class="literal">INFORMATION_SCHEMA</code> database.
                </p><p style="color:blue;">您可以在innodb sys_foreign和innodb sys_foreign_cols表中找到innodb表使用的外键的信息，也可以在information_schema数据库中找到。</p><p>
                    <a class="link" href="programs.html#mysqldump" title="4.5.4&nbsp;mysqldump — A Database Backup Program"><span class="command"><strong>mysqldump</strong></span></a> produces correct definitions of
                    tables in the dump file, including the foreign keys for child
                    tables.
                </p><p style="color:blue;">mysqldump生成转储文件中表的正确定义，包括子表的外键。</p><p>
                    To make it easier to reload dump files for tables that have
                    foreign key relationships, <a class="link" href="programs.html#mysqldump" title="4.5.4&nbsp;mysqldump — A Database Backup Program"><span class="command"><strong>mysqldump</strong></span></a>
                    automatically includes a statement in the dump output to set
                    <a class="link" href="server-administration.html#sysvar_foreign_key_checks"><code class="literal">foreign_key_checks</code></a> to 0. This
                    avoids problems with tables having to be reloaded in a
                    particular order when the dump is reloaded. It is also
                    possible to set this variable manually:
                </p><p style="color:blue;">为了便于为具有外键关系的表重新加载转储文件，mysqldump在转储输出中自动包含一个语句，将外键检查设置为0。这避免了在重新加载转储时必须按特定顺序重新加载表的问题。也可以手动设置此变量：</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>SET foreign_key_checks = 0;</code></strong>
mysql&gt; <strong class="userinput"><code>SOURCE <em class="replaceable"><code>dump_file_name</code></em>;</code></strong>
mysql&gt; <strong class="userinput"><code>SET foreign_key_checks = 1;</code></strong>
</pre><p>
                    This enables you to import the tables in any order if the dump
                    file contains tables that are not correctly ordered for
                    foreign keys. It also speeds up the import operation. Setting
                    <a class="link" href="server-administration.html#sysvar_foreign_key_checks"><code class="literal">foreign_key_checks</code></a> to 0 can
                    also be useful for ignoring foreign key constraints during
                    <a class="link" href="sql-syntax.html#load-data" title="13.2.6&nbsp;LOAD DATA Syntax"><code class="literal">LOAD DATA</code></a> and
                    <a class="link" href="sql-syntax.html#alter-table" title="13.1.8&nbsp;ALTER TABLE Syntax"><code class="literal">ALTER TABLE</code></a> operations.
                    However, even if <a class="link" href="server-administration.html#sysvar_foreign_key_checks"><code class="literal">foreign_key_checks =
                    0</code></a>, MySQL does not permit the creation of a foreign
                    key constraint where a column references a nonmatching column
                    type. Also, if a table has foreign key constraints,
                    <a class="link" href="sql-syntax.html#alter-table" title="13.1.8&nbsp;ALTER TABLE Syntax"><code class="literal">ALTER TABLE</code></a> cannot be used to
                    alter the table to use another storage engine. To change the
                    storage engine, you must drop any foreign key constraints
                    first.
                </p><p style="color:blue;">如果转储文件包含的表对于外键的顺序不正确，则可以按任何顺序导入表。它还加快了导入操作。将外键检查设置为0对于在加载数据和更改表操作期间忽略外键约束也很有用。但是，即使foreign_key_checks=0，mysql也不允许在列引用非匹配列类型的情况下创建外键约束。此外，如果表具有外键约束，则不能使用alter table将表更改为使用其他存储引擎。要更改存储引擎，必须先删除任何外键约束。</p><p>
                    You cannot issue <a class="link" href="sql-syntax.html#drop-table" title="13.1.29&nbsp;DROP TABLE Syntax"><code class="literal">DROP TABLE</code></a> for
                    a table that is referenced by a <code class="literal">FOREIGN KEY</code>
                    constraint, unless you do <code class="literal">SET foreign_key_checks =
                    0</code>. When you drop a table, any constraints that were
                    defined in the statement used to create that table are also
                    dropped.
                </p><p style="color:blue;">不能为被外键约束引用的表发出DROP TABLE，除非您将FOREIGN U KEY U CHECKS设置为0。删除表时，也会删除在用于创建该表的语句中定义的任何约束。</p><p>
                    If you re-create a table that was dropped, it must have a
                    definition that conforms to the foreign key constraints
                    referencing it. It must have the correct column names and
                    types, and it must have indexes on the referenced keys, as
                    stated earlier. If these are not satisfied, MySQL returns
                    Error 1005 and refers to Error 150 in the error message, which
                    means that a foreign key constraint was not correctly formed.
                    Similarly, if an <a class="link" href="sql-syntax.html#alter-table" title="13.1.8&nbsp;ALTER TABLE Syntax"><code class="literal">ALTER TABLE</code></a>
                    fails due to Error 150, this means that a foreign key
                    definition would be incorrectly formed for the altered table.
                </p><p style="color:blue;">如果重新创建已删除的表，则该表必须具有符合引用该表的外键约束的定义。它必须具有正确的列名和类型，并且必须对引用的键具有索引，如前所述。如果不满足这些条件，mysql将返回错误1005，并在错误消息中引用错误150，这意味着外键约束的格式不正确。类似地，如果alter表由于错误150而失败，这意味着将错误地为被修改的表形成外键定义。</p><p>
                    For <code class="literal">InnoDB</code> tables, you can obtain a
                    detailed explanation of the most recent
                    <code class="literal">InnoDB</code> foreign key error in the MySQL
                    Server, by checking the output of
                    <a class="link" href="sql-syntax.html#show-engine" title="13.7.5.15&nbsp;SHOW ENGINE Syntax"><code class="literal">SHOW ENGINE
                        INNODB STATUS</code></a>.
                </p><p style="color:blue;">对于innodb表，可以通过查看show engine innodb status的输出，获得mysql服务器中最近的innodb外键错误的详细解释。</p>
                </div>
                <div class="simplesect">
                    <div class="titlepage">
                        <div>
                            <div class="simple">
                                <h5 class="title"><a name="foreign-keys-ansi-iso-sql-standard"></a>Foreign Keys and the ANSI/ISO SQL Standard</h5>

                            </div>

                        </div>

                    </div>
                    <p>
                        For users familiar with the ANSI/ISO SQL Standard, please note
                        that no storage engine, including <code class="literal">InnoDB</code>,
                        recognizes or enforces the <code class="literal">MATCH</code> clause
                        used in referential-integrity constraint definitions. Use of
                        an explicit <code class="literal">MATCH</code> clause will not have the
                        specified effect, and also causes <code class="literal">ON DELETE</code>
                        and <code class="literal">ON UPDATE</code> clauses to be ignored. For
                        these reasons, specifying <code class="literal">MATCH</code> should be
                        avoided.
                    </p><p style="color:blue;">对于熟悉ansi/iso sql标准的用户，请注意，任何存储引擎（包括innodb）都无法识别或强制执行引用完整性约束定义中使用的match子句。使用显式match子句将不会产生指定的效果，还会导致忽略on delete和on update子句。由于这些原因，应该避免指定匹配。</p><p>
                    The <code class="literal">MATCH</code> clause in the SQL standard
                    controls how <code class="literal">NULL</code> values in a composite
                    (multiple-column) foreign key are handled when comparing to a
                    primary key. MySQL essentially implements the semantics
                    defined by <code class="literal">MATCH SIMPLE</code>, which permit a
                    foreign key to be all or partially <code class="literal">NULL</code>. In
                    that case, the (child table) row containing such a foreign key
                    is permitted to be inserted, and does not match any row in the
                    referenced (parent) table. It is possible to implement other
                    semantics using triggers.
                </p><p style="color:blue;">sql标准中的match子句控制与主键比较时如何处理组合（多列）外键中的空值。mysql本质上实现了match simple定义的语义，它允许外键全部或部分为空。在这种情况下，允许插入包含此类外键的（子表）行，并且与被引用（父）表中的任何行都不匹配。可以使用触发器实现其他语义。</p><p>
                    Additionally, MySQL requires that the referenced columns be
                    indexed for performance reasons. However, the system does not
                    enforce a requirement that the referenced columns be
                    <code class="literal">UNIQUE</code> or be declared <code class="literal">NOT
                    NULL</code>. The handling of foreign key references to
                    nonunique keys or keys that contain <code class="literal">NULL</code>
                    values is not well defined for operations such as
                    <a class="link" href="sql-syntax.html#update" title="13.2.11&nbsp;UPDATE Syntax"><code class="literal">UPDATE</code></a> or <code class="literal">DELETE
                    CASCADE</code>. You are advised to use foreign keys that
                    reference only <code class="literal">UNIQUE</code> (including
                    <code class="literal">PRIMARY</code>) and <code class="literal">NOT NULL</code>
                    keys.
                </p><p style="color:blue;">此外，出于性能原因，mysql要求对引用的列进行索引。但是，系统不强制要求引用列是唯一的或声明为不为空的。对于诸如update或delete cascade之类的操作，对非唯一键或包含空值的键的外键引用的处理没有很好地定义。建议您使用只引用唯一键（包括主键）而不引用空键的外键。</p><p>
                    Furthermore, MySQL parses but ignores <span class="quote">“<span class="quote">inline
          <code class="literal">REFERENCES</code> specifications</span>”</span> (as
                    defined in the SQL standard) where the references are defined
                    as part of the column specification. MySQL accepts
                    <code class="literal">REFERENCES</code> clauses only when specified as
                    part of a separate <code class="literal">FOREIGN KEY</code>
                    specification. For storage engines that do not support foreign
                    keys (such as <a class="link" href="storage-engines.html#myisam-storage-engine" title="15.2&nbsp;The MyISAM Storage Engine"><code class="literal">MyISAM</code></a>), MySQL
                    Server parses and ignores foreign key specifications.
                </p><p style="color:blue;">此外，mysql解析但忽略“内联引用规范”（在sql标准中定义），其中引用被定义为列规范的一部分。mysql仅在作为单独外键规范的一部分指定时才接受references子句。对于不支持外键的存储引擎（如myisam），mysql服务器会解析并忽略外键规范。</p>
                </div>
                <div class="simplesect">
                    <div class="titlepage">
                        <div>
                            <div class="simple">
                                <h5 class="title"><a name="foreign-key-metadata"></a>Foreign Key Metadata</h5>

                            </div>

                        </div>

                    </div>
                    <p>
                        The
                        <a class="link" href="information-schema.html#key-column-usage-table" title="24.12&nbsp;The INFORMATION_SCHEMA KEY_COLUMN_USAGE Table"><code class="literal">INFORMATION_SCHEMA.KEY_COLUMN_USAGE</code></a>
                        table identifies the key columns that have constraints.
                        Metadata specific to <code class="literal">InnoDB</code> foreign keys is
                        found in the <a class="link" href="information-schema.html#innodb-sys-foreign-table" title="24.32.19&nbsp;The INFORMATION_SCHEMA INNODB_SYS_FOREIGN Table"><code class="literal">INNODB_SYS_FOREIGN</code></a>
                        and <a class="link" href="information-schema.html#innodb-sys-foreign-cols-table" title="24.32.20&nbsp;The INFORMATION_SCHEMA INNODB_SYS_FOREIGN_COLS Table"><code class="literal">INNODB_SYS_FOREIGN_COLS</code></a>
                        tables.
                    </p><p style="color:blue;">information_schema.key_column_usage表标识具有约束的键列。在innodb sys_foreign和innodb sys_foreign_cols表中可以找到特定于innodb外键的元数据。</p>
                </div>
                <div class="simplesect">
                    <div class="titlepage">
                        <div>
                            <div class="simple">
                                <h5 class="title"><a name="foreign-key-errors"></a>Foreign Key Errors</h5>

                            </div>

                        </div>

                    </div>
                    <p>
                        In the event of a foreign key error involving
                        <code class="literal">InnoDB</code> tables (usually Error 150 in the
                        MySQL Server), information about the most recent
                        <code class="literal">InnoDB</code> foreign key error can be obtained by
                        checking <a class="link" href="sql-syntax.html#show-engine" title="13.7.5.15&nbsp;SHOW ENGINE Syntax"><code class="literal">SHOW
                        ENGINE INNODB STATUS</code></a> output.
                    </p><p style="color:blue;">如果发生涉及innodb表的外键错误（通常是mysql服务器中的错误150），可以通过检查show engine innodb status output来获取有关最新innodb外键错误的信息。</p>
                    <div class="warning" style="margin-left: 0.5in; margin-right: 0.5in;">

                        <div class="admon-title">
                            Warning
                        </div>
                        <p>
                            <a class="link" href="error-handling.html#error_er_no_referenced_row_2"><code class="literal">ER_NO_REFERENCED_ROW_2</code></a> and
                            <a class="link" href="error-handling.html#error_er_row_is_referenced_2"><code class="literal">ER_ROW_IS_REFERENCED_2</code></a> error
                            messages for foreign key operations expose information about
                            parent tables, even if the user has no parent table access
                            privileges. To hide information about parent tables, include
                            the appropriate condition handlers in application code and
                            stored programs.
                        </p><p style="color:blue;">er_no_referenced_row_2和er_row_is_referenced_2外键操作的错误消息公开有关父表的信息，即使用户没有父表访问权限。要隐藏有关父表的信息，请在应用程序代码和存储的程序中包含适当的条件处理程序。</p>
                    </div>

                </div>

            </div>
            <div class="section">
                <div class="titlepage">
                    <div>
                        <div>
                            <h4 class="title"><a name="silent-column-changes"></a>13.1.18.7&nbsp;Silent Column Specification Changes</h4>

                        </div>

                    </div>

                </div>
                <a class="indexterm" name="idm140286837824832"></a><p>
                In some cases, MySQL silently changes column specifications from
                those given in a <a class="link" href="sql-syntax.html#create-table" title="13.1.18&nbsp;CREATE TABLE Syntax"><code class="literal">CREATE TABLE</code></a> or
                <a class="link" href="sql-syntax.html#alter-table" title="13.1.8&nbsp;ALTER TABLE Syntax"><code class="literal">ALTER TABLE</code></a> statement. These
                might be changes to a data type, to attributes associated with a
                data type, or to an index specification.
            </p><p style="color:blue;">在某些情况下，mysql会自动更改create table或alter table语句中给出的列规范。这些可能是对数据类型、与数据类型关联的属性或索引规范的更改。</p><p>
                All changes are subject to the internal row-size limit of 65,535
                bytes, which may cause some attempts at data type changes to
                fail. See <a class="xref" href="optimization.html#column-count-limit" title="8.4.7&nbsp;Limits on Table Column Count and Row Size">Section&nbsp;8.4.7, “Limits on Table Column Count and Row Size”</a>.
            </p><p style="color:blue;">所有更改都受65535字节的内部行大小限制的限制，这可能会导致某些数据类型更改尝试失败。见第8.4.7节，“表格列数和行大小限制”。</p>
                <div class="itemizedlist">
                    <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                        Columns that are part of a <code class="literal">PRIMARY KEY</code>
                        are made <code class="literal">NOT NULL</code> even if not declared
                        that way.
                    </p><p style="color:blue;">作为主键的一部分的列即使没有以这种方式声明，也不会被设为空。</p></li><li class="listitem"><p>
                        Trailing spaces are automatically deleted from
                        <a class="link" href="data-types.html#enum" title="11.4.4&nbsp;The ENUM Type"><code class="literal">ENUM</code></a> and
                        <a class="link" href="data-types.html#set" title="11.4.5&nbsp;The SET Type"><code class="literal">SET</code></a> member values when the
                        table is created.
                    </p><p style="color:blue;">创建表时，将自动从枚举中删除尾随空格并设置成员值。</p></li><li class="listitem"><p>
                        MySQL maps certain data types used by other SQL database
                        vendors to MySQL types. See
                        <a class="xref" href="data-types.html#other-vendor-data-types" title="11.10&nbsp;Using Data Types from Other Database Engines">Section&nbsp;11.10, “Using Data Types from Other Database Engines”</a>.
                    </p><p style="color:blue;">mysql将其他sql数据库供应商使用的某些数据类型映射到mysql类型。参见第11.10节“使用其他数据库引擎的数据类型”。</p></li><li class="listitem"><p>
                        If you include a <code class="literal">USING</code> clause to specify
                        an index type that is not permitted for a given storage
                        engine, but there is another index type available that the
                        engine can use without affecting query results, the engine
                        uses the available type.
                    </p><p style="color:blue;">如果包含using子句以指定给定存储引擎不允许使用的索引类型，但该引擎可以使用另一个可用的索引类型，而不会影响查询结果，则该引擎将使用该可用类型。</p></li><li class="listitem"><p>
                        If strict SQL mode is not enabled, a
                        <a class="link" href="data-types.html#char" title="11.4.1&nbsp;The CHAR and VARCHAR Types"><code class="literal">VARCHAR</code></a> column with a length
                        specification greater than 65535 is converted to
                        <a class="link" href="data-types.html#blob" title="11.4.3&nbsp;The BLOB and TEXT Types"><code class="literal">TEXT</code></a>, and a
                        <a class="link" href="data-types.html#binary-varbinary" title="11.4.2&nbsp;The BINARY and VARBINARY Types"><code class="literal">VARBINARY</code></a> column with a
                        length specification greater than 65535 is converted to
                        <a class="link" href="data-types.html#blob" title="11.4.3&nbsp;The BLOB and TEXT Types"><code class="literal">BLOB</code></a>. Otherwise, an error
                        occurs in either of these cases.
                    </p><p style="color:blue;">如果未启用严格SQL模式，则长度规格大于65535的varchar列将转换为文本，长度规格大于65535的varbinary列将转换为blob。否则，在这两种情况下都会发生错误。</p></li><li class="listitem"><p>
                        Specifying the <code class="literal">CHARACTER SET binary</code>
                        attribute for a character data type causes the column to be
                        created as the corresponding binary data type:
                        <a class="link" href="data-types.html#char" title="11.4.1&nbsp;The CHAR and VARCHAR Types"><code class="literal">CHAR</code></a> becomes
                        <a class="link" href="data-types.html#binary-varbinary" title="11.4.2&nbsp;The BINARY and VARBINARY Types"><code class="literal">BINARY</code></a>,
                        <a class="link" href="data-types.html#char" title="11.4.1&nbsp;The CHAR and VARCHAR Types"><code class="literal">VARCHAR</code></a> becomes
                        <a class="link" href="data-types.html#binary-varbinary" title="11.4.2&nbsp;The BINARY and VARBINARY Types"><code class="literal">VARBINARY</code></a>, and
                        <a class="link" href="data-types.html#blob" title="11.4.3&nbsp;The BLOB and TEXT Types"><code class="literal">TEXT</code></a> becomes
                        <a class="link" href="data-types.html#blob" title="11.4.3&nbsp;The BLOB and TEXT Types"><code class="literal">BLOB</code></a>. For the
                        <a class="link" href="data-types.html#enum" title="11.4.4&nbsp;The ENUM Type"><code class="literal">ENUM</code></a> and
                        <a class="link" href="data-types.html#set" title="11.4.5&nbsp;The SET Type"><code class="literal">SET</code></a> data types, this does not
                        occur; they are created as declared. Suppose that you
                        specify a table using this definition:
                    </p><p style="color:blue;">为字符数据类型指定字符集binary属性将导致创建列作为相应的二进制数据类型：char变为binary，varchar变为varbinary，text变为blob。对于枚举和集合数据类型，不会发生这种情况；它们是按声明创建的。假设您使用此定义指定一个表：</p><pre data-lang="sql" class="programlisting">CREATE TABLE t
(
  c1 VARCHAR(10) CHARACTER SET binary,
  c2 TEXT CHARACTER SET binary,
  c3 ENUM('a','b','c') CHARACTER SET binary
);
</pre><p>
                        The resulting table has this definition:
                    </p><p style="color:blue;">结果表具有以下定义：</p><pre data-lang="sql" class="programlisting">CREATE TABLE t
(
  c1 VARBINARY(10),
  c2 BLOB,
  c3 ENUM('a','b','c') CHARACTER SET binary
);
</pre></li></ul>
                </div>
                <p>
                    To see whether MySQL used a data type other than the one you
                    specified, issue a <a class="link" href="sql-syntax.html#describe" title="13.8.1&nbsp;DESCRIBE Syntax"><code class="literal">DESCRIBE</code></a> or
                    <a class="link" href="sql-syntax.html#show-create-table" title="13.7.5.10&nbsp;SHOW CREATE TABLE Syntax"><code class="literal">SHOW CREATE TABLE</code></a> statement after
                    creating or altering the table.
                </p><p style="color:blue;">要查看mysql是否使用了您指定的数据类型以外的数据类型，请在创建或更改表后发出describe或show create table语句。</p><a class="indexterm" name="idm140286837786832"></a><p>
                Certain other data type changes can occur if you compress a
                table using <a class="link" href="programs.html#myisampack" title="4.6.5&nbsp;myisampack — Generate Compressed, Read-Only MyISAM Tables"><span class="command"><strong>myisampack</strong></span></a>. See
                <a class="xref" href="storage-engines.html#compressed-format" title="15.2.3.3&nbsp;Compressed Table Characteristics">Section&nbsp;15.2.3.3, “Compressed Table Characteristics”</a>.
            </p><p style="color:blue;">如果使用myisampack压缩表，则可能会发生某些其他数据类型更改。见第15.2.3.3节“压缩表特性”。</p>
            </div>
            <div class="section">
                <div class="titlepage">
                    <div>
                        <div>
                            <h4 class="title"><a name="create-table-generated-columns"></a>13.1.18.8&nbsp;CREATE TABLE and Generated Columns</h4>

                        </div>

                    </div>

                </div>
                <a class="indexterm" name="idm140286837782080"></a><p>
                <a class="link" href="sql-syntax.html#create-table" title="13.1.18&nbsp;CREATE TABLE Syntax"><code class="literal">CREATE TABLE</code></a> supports the
                specification of generated columns. Values of a generated column
                are computed from an expression included in the column
                definition.
            </p><p style="color:blue;">create table支持生成列的规范。生成列的值是根据列定义中包含的表达式计算的。</p><p>
                Generated columns are supported by the
                <a class="link" href="mysql-cluster.html" title="Chapter&nbsp;21&nbsp;MySQL NDB Cluster 7.5 and NDB Cluster 7.6"><code class="literal">NDB</code></a> storage engine beginning with
                MySQL NDB Cluster 7.5.3.
            </p><p style="color:blue;">从mysql ndb cluster 7.5.3开始的ndb存储引擎支持生成的列。</p><p>
                The following simple example shows a table that stores the
                lengths of the sides of right triangles in the
                <code class="literal">sidea</code> and <code class="literal">sideb</code> columns,
                and computes the length of the hypotenuse in
                <code class="literal">sidec</code> (the square root of the sums of the
                squares of the other sides):
            </p><p style="color:blue;">下面的简单示例显示一个表，该表在sidea和sideb列中存储直角三角形的边的长度，并在sidec中计算斜边的长度（其他边的平方和的平方根）：</p><pre data-lang="sql" class="programlisting">CREATE TABLE triangle (
  sidea DOUBLE,
  sideb DOUBLE,
  sidec DOUBLE AS (SQRT(sidea * sidea + sideb * sideb))
);
INSERT INTO triangle (sidea, sideb) VALUES(1,1),(3,4),(6,8);
</pre><p>
                Selecting from the table yields this result:
            </p><p style="color:blue;">从表中选择会产生以下结果：</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT * FROM triangle;</code></strong>
+-------+-------+--------------------+
| sidea | sideb | sidec              |
+-------+-------+--------------------+
|     1 |     1 | 1.4142135623730951 |
|     3 |     4 |                  5 |
|     6 |     8 |                 10 |
+-------+-------+--------------------+
</pre><p>
                Any application that uses the <code class="literal">triangle</code> table
                has access to the hypotenuse values without having to specify
                the expression that calculates them.
            </p><p style="color:blue;">任何使用三角形表的应用程序都可以访问斜边值，而无需指定计算它们的表达式。</p><p>
                Generated column definitions have this syntax:
            </p><p style="color:blue;">生成的列定义具有以下语法：</p><pre data-lang="sql" class="programlisting"><em class="replaceable"><code>col_name</code></em> <em class="replaceable"><code>data_type</code></em> [GENERATED ALWAYS] AS (<em class="replaceable"><code>expr</code></em>)
  [VIRTUAL | STORED] [NOT NULL | NULL]
  [UNIQUE [KEY]] [[PRIMARY] KEY]
  [COMMENT '<em class="replaceable"><code>string</code></em>']
</pre><p>
                <code class="literal">AS (<em class="replaceable"><code>expr</code></em>)</code>
                indicates that the column is generated and defines the
                expression used to compute column values. <code class="literal">AS</code>
                may be preceded by <code class="literal">GENERATED ALWAYS</code> to make
                the generated nature of the column more explicit. Constructs
                that are permitted or prohibited in the expression are discussed
                later.
            </p><p style="color:blue;">as（expr）表示生成列并定义用于计算列值的表达式。前面可以加上generated always，使列的生成性质更加明确。表达式中允许或禁止的构造将在后面讨论。</p><p>
                The <code class="literal">VIRTUAL</code> or <code class="literal">STORED</code>
                keyword indicates how column values are stored, which has
                implications for column use:
            </p><p style="color:blue;">virtual或stored关键字指示如何存储列值，这对列的使用有影响：</p>
                <div class="itemizedlist">
                    <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                        <code class="literal">VIRTUAL</code>: Column values are not stored,
                        but are evaluated when rows are read, immediately after any
                        <code class="literal">BEFORE</code> triggers. A virtual column takes
                        no storage.
                    </p><p style="color:blue;">虚拟：列值不存储，但在读取行时立即在任何before触发器之后计算。虚拟列不占用存储空间。</p><p>
                        <code class="literal">InnoDB</code> supports secondary indexes on
                        virtual columns. See
                        <a class="xref" href="sql-syntax.html#create-table-secondary-indexes" title="13.1.18.9&nbsp;Secondary Indexes and Generated Columns">Section&nbsp;13.1.18.9, “Secondary Indexes and Generated Columns”</a>.
                    </p><p style="color:blue;">innodb支持虚拟列上的辅助索引。见第13.1.18.9节，“二级索引和生成列”。</p></li><li class="listitem"><p>
                        <code class="literal">STORED</code>: Column values are evaluated and
                        stored when rows are inserted or updated. A stored column
                        does require storage space and can be indexed.
                    </p><p style="color:blue;">存储：在插入或更新行时计算和存储列值。存储列确实需要存储空间，并且可以编制索引。</p></li></ul>
                </div>
                <p>
                    The default is <code class="literal">VIRTUAL</code> if neither keyword is
                    specified.
                </p><p style="color:blue;">如果未指定关键字，则默认值为virtual。</p><p>
                It is permitted to mix <code class="literal">VIRTUAL</code> and
                <code class="literal">STORED</code> columns within a table.
            </p><p style="color:blue;">允许在表中混合使用虚拟列和存储列。</p><p>
                Other attributes may be given to indicate whether the column is
                indexed or can be <code class="literal">NULL</code>, or provide a comment.
            </p><p style="color:blue;">还可以提供其他属性来指示列是否已被索引或是否可以为空，或者提供注释。</p><p>
                Generated column expressions must adhere to the following rules.
                An error occurs if an expression contains disallowed constructs.
            </p><p style="color:blue;">生成的列表达式必须遵循以下规则。如果表达式包含不允许的构造，则会发生错误。</p>
                <div class="itemizedlist">
                    <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                        Literals, deterministic built-in functions, and operators
                        are permitted. A function is deterministic if, given the
                        same data in tables, multiple invocations produce the same
                        result, independently of the connected user. Examples of
                        functions that are nondeterministic and fail this
                        definition: <a class="link" href="functions.html#function_connection-id"><code class="literal">CONNECTION_ID()</code></a>,
                        <a class="link" href="functions.html#function_current-user"><code class="literal">CURRENT_USER()</code></a>,
                        <a class="link" href="functions.html#function_now"><code class="literal">NOW()</code></a>.
                    </p><p style="color:blue;">允许使用文本、确定性内置函数和运算符。如果给定表中的相同数据，多个调用独立于连接的用户产生相同的结果，则函数是确定的。不确定且未通过此定义的函数示例：connection_id（）、current_user（）、now（）。</p></li><li class="listitem"><p>
                        Stored functions and user-defined functions are not
                        permitted.
                    </p><p style="color:blue;">不允许使用存储函数和用户定义函数。</p></li><li class="listitem"><p>
                        Stored procedure and function parameters are not permitted.
                    </p><p style="color:blue;">不允许使用存储过程和函数参数。</p></li><li class="listitem"><p>
                        Variables (system variables, user-defined variables, and
                        stored program local variables) are not permitted.
                    </p><p style="color:blue;">不允许变量（系统变量、用户定义变量和存储的程序局部变量）。</p></li><li class="listitem"><p>
                        Subqueries are not permitted.
                    </p><p style="color:blue;">不允许子查询。</p></li><li class="listitem"><p>
                        A generated column definition can refer to other generated
                        columns, but only those occurring earlier in the table
                        definition. A generated column definition can refer to any
                        base (nongenerated) column in the table whether its
                        definition occurs earlier or later.
                    </p><p style="color:blue;">生成的列定义可以引用其他生成的列，但只能引用表定义中较早出现的列。生成的列定义可以引用表中的任何基（非生成）列，无论其定义是早于或晚于此。</p></li><li class="listitem"><p>
                        The <code class="literal">AUTO_INCREMENT</code> attribute cannot be
                        used in a generated column definition.
                    </p><p style="color:blue;">不能在生成的列定义中使用auto_increment属性。</p></li><li class="listitem"><p>
                        An <code class="literal">AUTO_INCREMENT</code> column cannot be used
                        as a base column in a generated column definition.
                    </p><p style="color:blue;">自动递增列不能用作生成的列定义中的基列。</p></li><li class="listitem"><p>
                        As of MySQL 5.7.10, if expression evaluation causes
                        truncation or provides incorrect input to a function, the
                        <a class="link" href="sql-syntax.html#create-table" title="13.1.18&nbsp;CREATE TABLE Syntax"><code class="literal">CREATE TABLE</code></a> statement
                        terminates with an error and the DDL operation is rejected.
                    </p><p style="color:blue;">从mysql 5.7.10开始，如果表达式求值导致截断或向函数提供不正确的输入，则create table语句将以错误终止，并拒绝ddl操作。</p></li></ul>
                </div>
                <p>
                    If the expression evaluates to a data type that differs from the
                    declared column type, implicit coercion to the declared type
                    occurs according to the usual MySQL type-conversion rules. See
                    <a class="xref" href="functions.html#type-conversion" title="12.2&nbsp;Type Conversion in Expression Evaluation">Section&nbsp;12.2, “Type Conversion in Expression Evaluation”</a>.
                </p><p style="color:blue;">如果表达式的计算结果是与声明的列类型不同的数据类型，则会根据常见的mysql类型转换规则隐式强制声明的类型。参见第12.2节“表达式求值中的类型转换”。</p>
                <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">

                    <div class="admon-title">
                        Note
                    </div>
                    <p>
                        If any component of the expression depends on the SQL mode,
                        different results may occur for different uses of the table
                        unless the SQL mode is the same during all uses.
                    </p><p style="color:blue;">如果表达式的任何组件依赖于sql模式，则对于表的不同使用可能会出现不同的结果，除非sql模式在所有使用过程中都相同。</p>
                </div>
                <p>
                    For <a class="link" href="sql-syntax.html#create-table-like" title="13.1.18.4&nbsp;CREATE TABLE ... LIKE Syntax"><code class="literal">CREATE
                    TABLE ... LIKE</code></a>, the destination table preserves
                    generated column information from the original table.
                </p><p style="color:blue;">用于创建表…类似地，目标表保留原始表中生成的列信息。</p><p>
                For <a class="link" href="sql-syntax.html#create-table-select" title="13.1.18.5&nbsp;CREATE TABLE ... SELECT Syntax"><code class="literal">CREATE
                TABLE ... SELECT</code></a>, the destination table does not
                preserve information about whether columns in the selected-from
                table are generated columns. The
                <a class="link" href="sql-syntax.html#select" title="13.2.9&nbsp;SELECT Syntax"><code class="literal">SELECT</code></a> part of the statement
                cannot assign values to generated columns in the destination
                table.
            </p><p style="color:blue;">用于创建表…选择时，目标表不会保留有关“从中选择”表中的列是否生成列的信息。语句的select部分无法将值赋给目标表中生成的列。</p><p>
                Partitioning by generated columns is permitted. See
                <a class="xref" href="sql-syntax.html#create-table-partitioning" title="Table Partitioning">Table Partitioning</a>.
            </p><p style="color:blue;">允许按生成的列进行分区。请参阅表分区。</p><p>
                A foreign key constraint on a stored generated column cannot use
                <code class="literal">CASCADE</code>, <code class="literal">SET NULL</code>, or
                <code class="literal">SET DEFAULT</code> as <code class="literal">ON UPDATE</code>
                referential actions, nor can it use <code class="literal">SET NULL</code>
                or <code class="literal">SET DEFAULT</code> as <code class="literal">ON
                DELETE</code> referential actions.
            </p><p style="color:blue;">存储生成列上的外键约束不能在更新引用操作时使用cascade、set null或set default，也不能在删除引用操作时使用set null或set default。</p><p>
                A foreign key constraint on the base column of a stored
                generated column cannot use <code class="literal">CASCADE</code>,
                <code class="literal">SET NULL</code>, or <code class="literal">SET DEFAULT</code>
                as <code class="literal">ON UPDATE</code> or <code class="literal">ON DELETE</code>
                referential actions.
            </p><p style="color:blue;">存储的生成列的基列上的外键约束不能使用cascade、set null或set default as on update或on delete引用操作。</p><p>
                A foreign key constraint cannot reference a virtual generated
                column.
            </p><p style="color:blue;">外键约束不能引用虚拟生成的列。</p><p>
                For <code class="literal">InnoDB</code> restrictions related to foreign
                keys and generated columns, see
                <a class="xref" href="innodb-storage-engine.html#innodb-foreign-key-constraints" title="14.6.1.5&nbsp;InnoDB and FOREIGN KEY Constraints">Section&nbsp;14.6.1.5, “InnoDB and FOREIGN KEY Constraints”</a>.
            </p><p style="color:blue;">有关与外键和生成列相关的innodb限制，请参阅第14.6.1.5节“innodb和外键限制”。</p><p>
                Triggers cannot use
                <code class="literal">NEW.<em class="replaceable"><code>col_name</code></em></code> or
                use <code class="literal">OLD.<em class="replaceable"><code>col_name</code></em></code>
                to refer to generated columns.
            </p><p style="color:blue;">触发器不能使用new.col_name或使用old.col_name来引用生成的列。</p><p>
                For <a class="link" href="sql-syntax.html#insert" title="13.2.5&nbsp;INSERT Syntax"><code class="literal">INSERT</code></a>,
                <a class="link" href="sql-syntax.html#replace" title="13.2.8&nbsp;REPLACE Syntax"><code class="literal">REPLACE</code></a>, and
                <a class="link" href="sql-syntax.html#update" title="13.2.11&nbsp;UPDATE Syntax"><code class="literal">UPDATE</code></a>, if a generated column is
                inserted into, replaced, or updated explicitly, the only
                permitted value is <code class="literal">DEFAULT</code>.
            </p><p style="color:blue;">对于insert、replace和update，如果生成的列被显式插入、替换或更新，则仅允许使用默认值。</p><p>
                A generated column in a view is considered updatable because it
                is possible to assign to it. However, if such a column is
                updated explicitly, the only permitted value is
                <code class="literal">DEFAULT</code>.
            </p><p style="color:blue;">视图中生成的列被认为是可更新的，因为可以为其赋值。但是，如果显式更新此类列，则唯一允许的值是默认值。</p><p>
                Generated columns have several use cases, such as these:
            </p><p style="color:blue;">生成的列有几个用例，例如：</p>
                <div class="itemizedlist">
                    <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                        Virtual generated columns can be used as a way to simplify
                        and unify queries. A complicated condition can be defined as
                        a generated column and referred to from multiple queries on
                        the table to ensure that all of them use exactly the same
                        condition.
                    </p><p style="color:blue;">虚拟生成的列可以用来简化和统一查询。复杂条件可以定义为生成的列，并从表上的多个查询中引用，以确保所有查询都使用完全相同的条件。</p></li><li class="listitem"><p>
                        Stored generated columns can be used as a materialized cache
                        for complicated conditions that are costly to calculate on
                        the fly.
                    </p><p style="color:blue;">存储生成的列可以用作一个物化缓存，用于复杂的条件，这些条件在运行时计算成本很高。</p></li><li class="listitem"><p>
                        Generated columns can simulate functional indexes: Use a
                        generated column to define a functional expression and index
                        it. This can be useful for working with columns of types
                        that cannot be indexed directly, such as
                        <a class="link" href="data-types.html#json" title="11.6&nbsp;The JSON Data Type"><code class="literal">JSON</code></a> columns; see
                        <a class="xref" href="sql-syntax.html#json-column-indirect-index" title="Indexing a Generated Column to Provide a JSON Column Index">Indexing a Generated Column to Provide a JSON Column Index</a>, for a detailed
                        example.
                    </p><p style="color:blue;">生成的列可以模拟函数索引：使用生成的列定义函数表达式并为其编制索引。这对于处理无法直接索引的列（如JSON列）是有用的；请参阅索引生成的列以提供JSON列索引，用于详细示例。</p><p>
                        For stored generated columns, the disadvantage of this
                        approach is that values are stored twice; once as the value
                        of the generated column and once in the index.
                    </p><p style="color:blue;">对于存储的生成列，这种方法的缺点是存储两次值；一次作为生成列的值，一次作为索引。</p></li><li class="listitem"><p>
                        If a generated column is indexed, the optimizer recognizes
                        query expressions that match the column definition and uses
                        indexes from the column as appropriate during query
                        execution, even if a query does not refer to the column
                        directly by name. For details, see
                        <a class="xref" href="optimization.html#generated-column-index-optimizations" title="8.3.10&nbsp;Optimizer Use of Generated Column Indexes">Section&nbsp;8.3.10, “Optimizer Use of Generated Column Indexes”</a>.
                    </p><p style="color:blue;">如果生成的列已编制索引，优化器将识别与列定义匹配的查询表达式，并在查询执行期间酌情使用该列中的索引，即使查询未直接按名称引用该列。有关详细信息，请参见第8.3.10节“优化器使用生成的列索引”。</p></li></ul>
                </div>
                <p>
                    Example:
                </p><p style="color:blue;">例子：</p><p>
                Suppose that a table <code class="literal">t1</code> contains
                <code class="literal">first_name</code> and <code class="literal">last_name</code>
                columns and that applications frequently construct the full name
                using an expression like this:
            </p><p style="color:blue;">假设表T1包含first_name和last_name列，并且应用程序经常使用如下表达式构造全名：</p><pre data-lang="sql" class="programlisting">SELECT CONCAT(first_name,' ',last_name) AS full_name FROM t1;
</pre><p>
                One way to avoid writing out the expression is to create a view
                <code class="literal">v1</code> on <code class="literal">t1</code>, which simplifies
                applications by enabling them to select
                <code class="literal">full_name</code> directly without using an
                expression:
            </p><p style="color:blue;">避免写出表达式的一种方法是在T1上创建视图v1，这样可以简化应用程序，使它们能够直接选择全名而不使用表达式：</p><pre data-lang="sql" class="programlisting">CREATE VIEW v1 AS
SELECT *, CONCAT(first_name,' ',last_name) AS full_name FROM t1;

SELECT full_name FROM v1;
</pre><p>
                A generated column also enables applications to select
                <code class="literal">full_name</code> directly without the need to define
                a view:
            </p><p style="color:blue;">生成的列还允许应用程序直接选择全名，而无需定义视图：</p><pre data-lang="sql" class="programlisting">CREATE TABLE t1 (
  first_name VARCHAR(10),
  last_name VARCHAR(10),
  full_name VARCHAR(255) AS (CONCAT(first_name,' ',last_name))
);

SELECT full_name FROM t1;
</pre>
            </div>
            <div class="section">
                <div class="titlepage">
                    <div>
                        <div>
                            <h4 class="title"><a name="create-table-secondary-indexes"></a>13.1.18.9&nbsp;Secondary Indexes and Generated Columns</h4>

                        </div>

                    </div>

                </div>
                <a class="indexterm" name="idm140286837685952"></a><p>
                <code class="literal">InnoDB</code> supports secondary indexes on virtual
                generated columns. Other index types are not supported. A
                secondary index defined on a virtual column is sometimes
                referred to as a <span class="quote">“<span class="quote">virtual index</span>”</span>.
            </p><p style="color:blue;">innodb支持虚拟生成列的二级索引。不支持其他索引类型。在虚拟列上定义的辅助索引有时称为“虚拟索引”。</p><p>
                A secondary index may be created on one or more virtual columns
                or on a combination of virtual columns and regular columns or
                stored generated columns. Secondary indexes that include virtual
                columns may be defined as <code class="literal">UNIQUE</code>.
            </p><p style="color:blue;">可以在一个或多个虚拟列上，或者在虚拟列和常规列的组合上，或者在存储的生成列上创建辅助索引。包含虚拟列的辅助索引可以定义为唯一索引。</p><p>
                When a secondary index is created on a virtual generated column,
                generated column values are materialized in the records of the
                index. If the index is a
                <a class="link" href="glossary.html#glos_covering_index" title="covering index">covering index</a> (one
                that includes all the columns retrieved by a query), generated
                column values are retrieved from materialized values in the
                index structure instead of computed <span class="quote">“<span class="quote">on the fly</span>”</span>.
            </p><p style="color:blue;">在虚拟生成列上创建辅助索引时，生成的列值将具体化到索引的记录中。如果索引是覆盖索引（包含查询检索到的所有列的索引），则生成的列值将从索引结构中的物化值检索，而不是“动态”计算。</p><p>
                There are additional write costs to consider when using a
                secondary index on a virtual column due to computation performed
                when materializing virtual column values in secondary index
                records during <a class="link" href="sql-syntax.html#insert" title="13.2.5&nbsp;INSERT Syntax"><code class="literal">INSERT</code></a> and
                <a class="link" href="sql-syntax.html#update" title="13.2.11&nbsp;UPDATE Syntax"><code class="literal">UPDATE</code></a> operations. Even with
                additional write costs, secondary indexes on virtual columns may
                be preferable to generated <span class="emphasis"><em>stored</em></span> columns,
                which are materialized in the clustered index, resulting in
                larger tables that require more disk space and memory. If a
                secondary index is not defined on a virtual column, there are
                additional costs for reads, as virtual column values must be
                computed each time the column's row is examined.
            </p><p style="color:blue;">在虚拟列上使用辅助索引时，需要考虑额外的写入成本，因为在插入和更新操作期间，在辅助索引记录中具体化虚拟列值时会执行计算。即使有额外的写入成本，虚拟列上的辅助索引可能比生成的存储列更可取，这些存储列在聚集索引中具体化，从而生成需要更多磁盘空间和内存的较大表。如果未在虚拟列上定义辅助索引，则读取操作会产生额外成本，因为每次检查该列的行时都必须计算虚拟列值。</p><p>
                Values of an indexed virtual column are MVCC-logged to avoid
                unnecessary recomputation of generated column values during
                rollback or during a purge operation. The data length of logged
                values is limited by the index key limit of 767 bytes for
                <code class="literal">COMPACT</code> and <code class="literal">REDUNDANT</code> row
                formats, and 3072 bytes for <code class="literal">DYNAMIC</code> and
                <code class="literal">COMPRESSED</code> row formats.
            </p><p style="color:blue;">索引虚拟列的值被记录为MVCC，以避免在回滚或清除操作期间不必要地重新计算生成的列值。记录值的数据长度受索引键限制，压缩和冗余行格式为767字节，动态和压缩行格式为3072字节。</p><p>
                Adding or dropping a secondary index on a virtual column is an
                in-place operation.
            </p><p style="color:blue;">在虚拟列上添加或删除辅助索引是就地操作。</p><p>
                Prior to 5.7.16, a foreign key constraint cannot reference a
                secondary index defined on a virtual generated column.
            </p><p style="color:blue;">在5.7.16之前，外键约束不能引用在虚拟生成列上定义的辅助索引。</p><p>
                In MySQL 5.7.13 and earlier, <code class="literal">InnoDB</code> does not
                permit defining a foreign key constraint with a cascading
                referential action on the base column of an indexed generated
                virtual column. This restriction is lifted in MySQL 5.7.14.
            </p><p style="color:blue;">在mysql 5.7.13和更早版本中，innodb不允许在索引生成的虚拟列的基列上使用级联引用操作定义外键约束。在mysql 5.7.14中取消了这个限制。</p>
                <div class="simplesect">

                    <div class="titlepage">
                        <div>

                            <div class="simple">
                                <h5 class="title"><a name="json-column-indirect-index"></a>Indexing a Generated Column to Provide a JSON Column Index</h5>
                            </div>
                        </div>
                    </div>
                    <p>
                        As noted elsewhere, <a class="link" href="data-types.html#json" title="11.6&nbsp;The JSON Data Type"><code class="literal">JSON</code></a>
                        columns cannot be indexed directly. To create an index that
                        references such a column indirectly, you can define a
                        generated column that extracts the information that should be
                        indexed, then create an index on the generated column, as
                        shown in this example:
                    </p><p style="color:blue;">如其他地方所述，json列不能直接索引。要创建间接引用此类列的索引，可以定义一个生成的列，该列提取应编制索引的信息，然后在生成的列上创建索引，如以下示例所示：</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>CREATE TABLE jemp (</code></strong>
    -&gt;     <strong class="userinput"><code>c JSON,</code></strong>
    -&gt;     <strong class="userinput"><code>g INT GENERATED ALWAYS AS (c-&gt;"$.id"),</code></strong>
    -&gt;     <strong class="userinput"><code>INDEX i (g)</code></strong>
    -&gt; <strong class="userinput"><code>);</code></strong>
Query OK, 0 rows affected (0.28 sec)

mysql&gt; <strong class="userinput"><code>INSERT INTO jemp (c) VALUES</code></strong>
     &gt;   <strong class="userinput"><code>('{"id": "1", "name": "Fred"}'), ('{"id": "2", "name": "Wilma"}'),</code></strong>
     &gt;   <strong class="userinput"><code>('{"id": "3", "name": "Barney"}'), ('{"id": "4", "name": "Betty"}');</code></strong>
Query OK, 4 rows affected (0.04 sec)
Records: 4  Duplicates: 0  Warnings: 0

mysql&gt; <strong class="userinput"><code>SELECT c-&gt;&gt;"$.name" AS name</code></strong>
     &gt;     <strong class="userinput"><code>FROM jemp WHERE g &gt; 2;</code></strong>
+--------+
| name   |
+--------+
| Barney |
| Betty  |
+--------+
2 rows in set (0.00 sec)

mysql&gt; <strong class="userinput"><code>EXPLAIN SELECT c-&gt;&gt;"$.name" AS name</code></strong>
     &gt;    <strong class="userinput"><code>FROM jemp WHERE g &gt; 2\G</code></strong>
*************************** 1. row ***************************
           id: 1
  select_type: SIMPLE
        table: jemp
   partitions: NULL
         type: range
possible_keys: i
          key: i
      key_len: 5
          ref: NULL
         rows: 2
     filtered: 100.00
        Extra: Using where
1 row in set, 1 warning (0.00 sec)

mysql&gt; <strong class="userinput"><code>SHOW WARNINGS\G</code></strong>
*************************** 1. row ***************************
  Level: Note
   Code: 1003
Message: /* select#1 */ select json_unquote(json_extract(`test`.`jemp`.`c`,'$.name'))
AS `name` from `test`.`jemp` where (`test`.`jemp`.`g` &gt; 2)
1 row in set (0.00 sec)
</pre><p>
                    (We have wrapped the output from the last statement in this
                    example to fit the viewing area.)
                </p><p style="color:blue;">（我们已将本例中最后一条语句的输出包装为适合查看区域。）</p><p>
                    The
                    <a class="link" href="functions.html#operator_json-column-path"><code class="literal">-&gt;</code></a>
                    operator is supported in MySQL 5.7.9 and later. The
                    <a class="link" href="functions.html#operator_json-inline-path"><code class="literal">-&gt;&gt;</code></a>
                    operator is supported beginning with MySQL 5.7.13.
                </p><p style="color:blue;">mysql 5.7.9及更高版本支持-&gt;运算符。从mysql 5.7.13开始支持-&gt;&gt;运算符。</p><p>
                    When you use <a class="link" href="sql-syntax.html#explain" title="13.8.2&nbsp;EXPLAIN Syntax"><code class="literal">EXPLAIN</code></a> on a
                    <a class="link" href="sql-syntax.html#select" title="13.2.9&nbsp;SELECT Syntax"><code class="literal">SELECT</code></a> or other SQL statement
                    containing one or more expressions that use the
                    <code class="literal">-&gt;</code> or <code class="literal">-&gt;&gt;</code>
                    operator, these expressions are translated into their
                    equivalents using <code class="literal">JSON_EXTRACT()</code> and (if
                    needed) <code class="literal">JSON_UNQUOTE()</code> instead, as shown
                    here in the output from <a class="link" href="sql-syntax.html#show-warnings" title="13.7.5.40&nbsp;SHOW WARNINGS Syntax"><code class="literal">SHOW
                    WARNINGS</code></a> immediately following this
                    <code class="literal">EXPLAIN</code> statement:
                </p><p style="color:blue;">当对包含使用-&gt;或-&gt;&gt;运算符的一个或多个表达式的select或其他sql语句使用explain时，这些表达式将使用json_extract（）和（如果需要）json_unquote（）转换为它们的等价表达式，如此explain语句后面的show warnings的输出所示：</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>EXPLAIN SELECT c-&gt;&gt;"$.name"</code></strong>
     &gt; <strong class="userinput"><code>FROM jemp WHERE g &gt; 2 ORDER BY c-&gt;"$.name"\G</code></strong>
*************************** 1. row ***************************
           id: 1
  select_type: SIMPLE
        table: jemp
   partitions: NULL
         type: range
possible_keys: i
          key: i
      key_len: 5
          ref: NULL
         rows: 2
     filtered: 100.00
        Extra: Using where; Using filesort
1 row in set, 1 warning (0.00 sec)

mysql&gt; <strong class="userinput"><code>SHOW WARNINGS\G</code></strong>
*************************** 1. row ***************************
  Level: Note
   Code: 1003
Message: /* select#1 */ select json_unquote(json_extract(`test`.`jemp`.`c`,'$.name')) AS
`c-&gt;&gt;"$.name"` from `test`.`jemp` where (`test`.`jemp`.`g` &gt; 2) order by
json_extract(`test`.`jemp`.`c`,'$.name')
1 row in set (0.00 sec)
</pre><p>
                    See the descriptions of the
                    <a class="link" href="functions.html#operator_json-column-path"><code class="literal">-&gt;</code></a>
                    and
                    <a class="link" href="functions.html#operator_json-inline-path"><code class="literal">-&gt;&gt;</code></a>
                    operators, as well as those of the
                    <a class="link" href="functions.html#function_json-extract"><code class="literal">JSON_EXTRACT()</code></a> and
                    <a class="link" href="functions.html#function_json-unquote"><code class="literal">JSON_UNQUOTE()</code></a> functions, for
                    additional information and examples.
                </p><p style="color:blue;">有关更多信息和示例，请参阅-&gt;和-&gt;&gt;运算符以及json_extract（）和json_unquote（）函数的说明。</p><p>
                    This technique also can be used to provide indexes that
                    indirectly reference columns of other types that cannot be
                    indexed directly, such as <code class="literal">GEOMETRY</code> columns.
                </p><p style="color:blue;">此技术还可用于提供间接引用其他类型（例如几何列）的列的索引。</p><h6><a name="json-column-indirect-index-mysql-cluster"></a>JSON columns and indirect indexing in NDB Cluster</h6><p>
                    <a class="indexterm" name="idm140286837629968"></a>

                    <a class="indexterm" name="idm140286837628480"></a>

                    <a class="indexterm" name="idm140286837626992"></a>

                    <a class="indexterm" name="idm140286837625504"></a>

                    It is also possible to use indirect indexing of JSON columns
                    in MySQL NDB Cluster 7.5.3 and later, subject to the following
                    conditions:
                </p><p style="color:blue;">还可以在MySQL NDB集群7.5.3和以后使用JSON列的间接索引，条件如下：</p>
                    <div class="orderedlist">
                        <ol class="orderedlist" type="1"><li class="listitem"><p>
                            <a class="link" href="mysql-cluster.html" title="Chapter&nbsp;21&nbsp;MySQL NDB Cluster 7.5 and NDB Cluster 7.6"><code class="literal">NDB</code></a> handles a
                            <a class="link" href="data-types.html#json" title="11.6&nbsp;The JSON Data Type"><code class="literal">JSON</code></a> column value
                            internally as a <a class="link" href="data-types.html#blob" title="11.4.3&nbsp;The BLOB and TEXT Types"><code class="literal">BLOB</code></a>. This
                            means that any <code class="literal">NDB</code> table having one or
                            more JSON columns must have a primary key, else it cannot
                            be recorded in the binary log.
                        </p><p style="color:blue;">ndb作为blob在内部处理json列值。这意味着，任何具有一个或多个json列的ndb表都必须有主键，否则无法将其记录在二进制日志中。</p></li><li class="listitem"><p>
                            The <a class="link" href="mysql-cluster.html" title="Chapter&nbsp;21&nbsp;MySQL NDB Cluster 7.5 and NDB Cluster 7.6"><code class="literal">NDB</code></a> storage engine does
                            not support indexing of virtual columns. Since the default
                            for generated columns is <code class="literal">VIRTUAL</code>, you
                            must specify explicitly the generated column to which to
                            apply the indirect index as <code class="literal">STORED</code>.
                        </p><p style="color:blue;">NDB存储引擎不支持对虚拟列的索引。由于生成列的默认值为virtual，因此必须显式指定要将间接索引应用于其存储的生成列。</p></li></ol>
                    </div>
                    <p>
                        The <strong class="userinput"><code>CREATE TABLE</code></strong> statement
                        used to create the table <code class="literal">jempn</code> shown here
                        is a version of the <code class="literal">jemp</code> table shown
                        previously, with modifications making it compatible with
                        <code class="literal">NDB</code>:
                    </p><p style="color:blue;">这里显示的用于创建表jempn的create table语句是前面显示的jemp表的一个版本，通过修改使其与ndb兼容：</p><pre data-lang="sql" class="programlisting">CREATE TABLE jempn (
  a BIGINT(20) NOT NULL AUTO_INCREMENT PRIMARY KEY,
  c JSON DEFAULT NULL,
  g INT GENERATED ALWAYS AS (c-&gt;"$.name") STORED,
  INDEX i (g)
) ENGINE=NDB;
</pre><p>
                    We can populate this table using the following
                    <a class="link" href="sql-syntax.html#insert" title="13.2.5&nbsp;INSERT Syntax"><code class="literal">INSERT</code></a> statement:
                </p><p style="color:blue;">我们可以使用以下INSERT语句填充此表：</p><pre data-lang="sql" class="programlisting">INSERT INTO jempn (a, c) VALUES
  (NULL, '{"id": "1", "name": "Fred"}'),
  (NULL, '{"id": "2", "name": "Wilma"}'),
  (NULL, '{"id": "3", "name": "Barney"}'),
  (NULL, '{"id": "4", "name": "Betty"}');
</pre><p>
                    Now <code class="literal">NDB</code> can use index <code class="literal">i</code>,
                    as shown here:
                </p><p style="color:blue;">现在ndb可以使用索引i，如下所示：</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>EXPLAIN SELECT c-&gt;&gt;"$.name" AS name
          FROM jempn WHERE g &gt; 2\G</code></strong>
*************************** 1. row ***************************
           id: 1
  select_type: SIMPLE
        table: jempn
   partitions: p0,p1
         type: range
possible_keys: i
          key: i
      key_len: 5
          ref: NULL
         rows: 3
     filtered: 100.00
        Extra: Using where with pushed condition (`test`.`jempn`.`g` &gt; 2)
1 row in set, 1 warning (0.00 sec)

mysql&gt; <strong class="userinput"><code>SHOW WARNINGS\G</code></strong>
*************************** 1. row ***************************
  Level: Note
   Code: 1003
Message: /* select#1 */ select
json_unquote(json_extract(`test`.`jempn`.`c`,'$.name')) AS `name` from
`test`.`jempn` where (`test`.`jempn`.`g` &gt; 2)
1 row in set (0.00 sec)
</pre><p>
                    You should keep in mind that a stored generated column uses
                    <a class="link" href="mysql-cluster.html#ndbparam-ndbd-datamemory"><code class="literal">DataMemory</code></a>, and that
                    an index on such a column uses
                    <a class="link" href="mysql-cluster.html#ndbparam-ndbd-indexmemory"><code class="literal">IndexMemory</code></a>.
                </p><p style="color:blue;">您应该记住，存储的生成列使用datamemory，此类列上的索引使用indexmemory。</p>
                </div>

            </div>
            <div class="section">
                <div class="titlepage">
                    <div>
                        <div>
                            <h4 class="title"><a name="create-table-ndb-table-comment-options"></a>13.1.18.10&nbsp;Setting NDB_TABLE Options</h4>

                        </div>

                    </div>

                </div>
                <p>
                    <a class="indexterm" name="idm140286837595584"></a>

                    <a class="indexterm" name="idm140286837594512"></a>

                    <a class="indexterm" name="idm140286837593024"></a>

                    <a class="indexterm" name="idm140286837591952"></a>

                    <a class="indexterm" name="idm140286837590880"></a>

                    In MySQL NDB Cluster 7.5.2 and later, the table comment in a
                    <code class="literal">CREATE TABLE</code> or <a class="link" href="sql-syntax.html#alter-table" title="13.1.8&nbsp;ALTER TABLE Syntax"><code class="literal">ALTER
                    TABLE</code></a> statement can also be used to specify an
                    <code class="literal">NDB_TABLE</code> option, which consists of one or
                    more name-value pairs, separated by commas if need be, following
                    the string <code class="literal">NDB_TABLE=</code>. Complete syntax for
                    names and values syntax is shown here:
                </p><p style="color:blue;">在mysql ndb cluster 7.5.2及更高版本中，create table或alter table语句中的table注释也可用于指定ndb戋u table选项，该选项由一个或多个名称-值对组成，如果需要，可以用逗号分隔，后面跟着字符串ndb戋u table=。名称和值的完整语法语法如下所示：</p><pre data-lang="sql" class="programlisting">COMMENT="NDB_TABLE=<em class="replaceable"><code>ndb_table_option</code></em>[,<em class="replaceable"><code>ndb_table_option</code></em>[,...]]"

<em class="replaceable"><code>ndb_table_option</code></em>:
    NOLOGGING={1|0}
  | READ_BACKUP={1|0}
  | PARTITION_BALANCE={FOR_RP_BY_NODE|FOR_RA_BY_NODE|FOR_RP_BY_LDM
                      |FOR_RA_BY_LDM|FOR_RA_BY_LDM_X_2
                      |FOR_RA_BY_LDM_X_3|FOR_RA_BY_LDM_X_4}
  | FULLY_REPLICATED={1|0}
</pre><p>
                Spaces are not permitted within the quoted string. The string is
                case-insensitive.
            </p><p style="color:blue;">带引号的字符串中不允许有空格。字符串不区分大小写。</p><p>
                The four <code class="literal">NDB</code> table options that can be set as
                part of a comment in this way are described in more detail in
                the next few paragraphs.
            </p><p style="color:blue;">下面几段将更详细地描述四个ndb表选项，这些选项可以用这种方式设置为注释的一部分。</p><p>
                <a class="indexterm" name="idm140286837581504"></a>

                <a class="indexterm" name="idm140286837580016"></a>

                <code class="literal">NOLOGGING</code>: Using 1 corresponds to having
                <a class="link" href="mysql-cluster.html#sysvar_ndb_table_no_logging"><code class="literal">ndb_table_no_logging</code></a> enabled,
                but has no actual effect. Provided as a placeholder, mostly for
                completeness of <a class="link" href="sql-syntax.html#alter-table" title="13.1.8&nbsp;ALTER TABLE Syntax"><code class="literal">ALTER TABLE</code></a>
                statements.
            </p><p style="color:blue;">不记录：使用1相当于启用了ndb_table_no_记录，但没有实际效果。作为占位符提供，主要是为了alter table语句的完整性。</p><p>
                <a class="indexterm" name="idm140286837574784"></a>

                <a class="indexterm" name="idm140286837573296"></a>

                <a class="indexterm" name="idm140286837571808"></a>

                <code class="literal">READ_BACKUP</code>: Setting this option to 1 has the
                same effect as though
                <a class="link" href="mysql-cluster.html#sysvar_ndb_read_backup"><code class="literal">ndb_read_backup</code></a> were enabled;
                enables reading from any replica. Starting with MySQL NDB
                Cluster 7.5.3, you can set <code class="literal">READ_BACKUP</code> for an
                existing table online (Bug #80858, Bug #23001617), using an
                <code class="literal">ALTER TABLE</code> statement similar to one of those
                shown here:
            </p><p style="color:blue;">read_backup：将此选项设置为1与启用ndb_read_backup具有相同的效果；启用从任何副本读取。从MySQL NDB集群7.5.3开始，可以使用一个ALTALTABLE语句来设置现有表在线的Read备份（Bugα80858，bug 23001617），类似于这里所示的一个：</p><pre data-lang="sql" class="programlisting">ALTER TABLE ... ALGORITHM=INPLACE, COMMENT="NDB_TABLE=READ_BACKUP=1";

ALTER TABLE ... ALGORITHM=INPLACE, COMMENT="NDB_TABLE=READ_BACKUP=0";
</pre><p>
                Prior to MySQL NDB Cluster 7.5.4, setting
                <code class="literal">READ_BACKUP</code> to 1 also caused
                <code class="literal">FRAGMENT_COUNT_TYPE</code> to be set to
                <code class="literal">ONE_PER_LDM_PER_NODE_GROUP</code>.
            </p><p style="color:blue;">在mysql ndb cluster 7.5.4之前，将read_backup设置为1还会导致fragment_count_type设置为one_per_ldm_per_node_group。</p><p>
                For more information about the <code class="literal">ALGORITHM</code>
                option for <code class="literal">ALTER TABLE</code>, see
                <a class="xref" href="mysql-cluster.html#mysql-cluster-online-operations" title="21.5.14&nbsp;Online Operations with ALTER TABLE in NDB Cluster">Section&nbsp;21.5.14, “Online Operations with ALTER TABLE in NDB Cluster”</a>.
            </p><p style="color:blue;">有关alter table的算法选项的更多信息，请参阅21.5.14节，“ndb集群中alter table的联机操作”。</p><p>
                <a class="indexterm" name="idm140286837559920"></a>

                <a class="indexterm" name="idm140286837558464"></a>

                <a class="indexterm" name="idm140286837556960"></a>

                <code class="literal">PARTITION_BALANCE</code>: Provides additional
                control over assignment and placement of partitions. The
                following four schemes are supported:
            </p><p style="color:blue;">分区平衡：对分区的分配和放置提供额外的控制。支持以下四种方案：</p>
                <div class="orderedlist">
                    <ol class="orderedlist" type="1"><li class="listitem"><p>
                        <code class="literal">FOR_RP_BY_NODE</code>: One partition per node.
                    </p><p style="color:blue;">对于每个节点：每个节点一个分区。</p><p>
                        Only one LDM on each node stores a primary partition. Each
                        partition is stored in the same LDM (same ID) on all nodes.
                    </p><p style="color:blue;">每个节点上只有一个ldm存储一个主分区。每个分区存储在所有节点上的同一个ldm（同一id）中。</p></li><li class="listitem"><p>
                        <code class="literal">FOR_RA_BY_NODE</code>: One partition per node
                        group.
                    </p><p style="color:blue;">对于按节点：每个节点组一个分区。</p><p>
                        Each node stores a single partition, which can be either a
                        primary replica or a backup replica. Each partition is
                        stored in the same LDM on all nodes.
                    </p><p style="color:blue;">每个节点存储一个分区，该分区可以是主副本，也可以是备份副本。每个分区存储在所有节点上的同一个ldm中。</p></li><li class="listitem"><p>
                        <code class="literal">FOR_RP_BY_LDM</code>: One partition for each LDM
                        on each node; the default.
                    </p><p style="color:blue;">for_rp_by_ldm：每个节点上每个ldm一个分区；默认值。</p><p>
                        This is the same behavior as prior to MySQL NDB Cluster
                        7.5.2, except for a slightly different mapping of partitions
                        to LDMs, starting with LDM 0 and placing one partition per
                        node group, then moving on to the next LDM.
                    </p><p style="color:blue;">这与mysql ndb cluster 7.5.2之前的行为相同，只是分区到ldm的映射略有不同，从ldm 0开始，每个节点组放置一个分区，然后转到下一个ldm。</p><p>
                        In MySQL NDB Cluster 7.5.4 and later, this is the setting
                        used if <code class="literal">READ_BACKUP</code> is set to 1. (Bug
                        #82634, Bug #24482114)
                    </p><p style="color:blue;">在mysql ndb cluster 7.5.4及更高版本中，如果read_backup设置为1，则使用此设置。（错误82634，错误24482114）</p></li><li class="listitem"><p>
                        <code class="literal">FOR_RA_BY_LDM</code>: One partition per LDM in
                        each node group.
                    </p><p style="color:blue;">对于按ldm的分区：每个节点组中每个ldm一个分区。</p><p>
                        These partitions can be primary or backup partitions.
                    </p><p style="color:blue;">这些分区可以是主分区，也可以是备份分区。</p><p>
                        Prior to MySQL NDB Cluster 7.5.4, this was the setting used
                        if <code class="literal">READ_BACKUP</code> was set to 1.
                    </p><p style="color:blue;">在mysql ndb cluster 7.5.4之前，如果read_backup设置为1，则使用此设置。</p></li><li class="listitem"><p>
                        <code class="literal">FOR_RA_BY_LDM_X_2</code>: Two partitions per LDM
                        in each node group.
                    </p><p style="color:blue;">对于按ldm_x_2的配置：每个节点组中每个ldm有两个分区。</p><p>
                        These partitions can be primary or backup partitions.
                    </p><p style="color:blue;">这些分区可以是主分区，也可以是备份分区。</p><p>
                        This setting was added in NDB 7.5.4.
                    </p><p style="color:blue;">此设置是在ndb 7.5.4中添加的。</p></li><li class="listitem"><p>
                        <code class="literal">FOR_RA_BY_LDM_X_3</code>: Three partitions per
                        LDM in each node group.
                    </p><p style="color:blue;">对于按ldm_x_3的每个ldm：每个节点组中的每个ldm有三个分区。</p><p>
                        These partitions can be primary or backup partitions.
                    </p><p style="color:blue;">这些分区可以是主分区，也可以是备份分区。</p><p>
                        This setting was added in NDB 7.5.4.
                    </p><p style="color:blue;">此设置是在ndb 7.5.4中添加的。</p></li><li class="listitem"><p>
                        <code class="literal">FOR_RA_BY_LDM_X_4</code>: Four partitions per
                        LDM in each node group.
                    </p><p style="color:blue;">对于按ldm_x_4的配置：每个节点组中每个ldm有四个分区。</p><p>
                        These partitions can be primary or backup partitions.
                    </p><p style="color:blue;">这些分区可以是主分区，也可以是备份分区。</p><p>
                        This setting was added in NDB 7.5.4.
                    </p><p style="color:blue;">此设置是在ndb 7.5.4中添加的。</p></li></ol>
                </div>
                <p>
                    Beginning with NDB 7.5.4, <code class="literal">PARTITION_BALANCE</code>
                    is the preferred interface for setting the number of partitions
                    per table. Using <code class="literal">MAX_ROWS</code> to force the number
                    of partitions is deprecated as of NDB 7.5.4, continues to be
                    supported in NDB 7.6 for backward compatibility, but is subject
                    to removal in a future release of MySQL NDB Cluster. (Bug
                    #81759, Bug #23544301)
                </p><p style="color:blue;">从NDB 7.5.4开始，PrimeTyStalk是设置每个表的分区数的首选接口。从ndb 7.5.4开始，不推荐使用max_rows来强制分区的数量，ndb7.6仍然支持向后兼容，但在mysql ndb cluster的未来版本中可能会被删除。（错误81759，错误23544301）</p><p>
                Prior to MySQL NDB Cluster 7.5.4,
                <code class="literal">PARTITION_BALANCE</code> was named
                <code class="literal">FRAGMENT_COUNT_TYPE</code>, and accepted as its
                value one of (in the same order as that of the listing just
                shown) <code class="literal">ONE_PER_NODE</code>,
                <code class="literal">ONE_PER_NODE_GROUP</code>,
                <code class="literal">ONE_PER_LDM_PER_NODE</code>, or
                <code class="literal">ONE_PER_LDM_PER_NODE_GROUP</code>. (Bug #81761, Bug
                #23547525)
            </p><p style="color:blue;">在MySQL NDB集群7.5.4之前，PrimeTyStalk被称为FractMeNo.ToTyType，并接受它的值之一（与刚才列出的列表相同的顺序）OnthPixNo结、OnthPiRoNoDyGROUP组、OnOxPiLLDMyPyl节点或One Piel-LDMyPiRoNoDyNoGROUP。（错误81761，错误23547525）</p><p>
                <a class="indexterm" name="idm140286837527808"></a>

                <a class="indexterm" name="idm140286837526304"></a>

                <code class="literal">FULLY_REPLICATED</code> controls whether the table
                is fully replicated, that is, whether each data node has a
                complete copy of the table. To enable full replication of the
                table, use <code class="literal">FULLY_REPLICATED=1</code>.
            </p><p style="color:blue;">完全复制控制表是否完全复制，即每个数据节点是否有表的完整副本。要启用表的完全复制，请使用fully_replicated=1。</p><p>
                This setting can also be controlled using the
                <code class="literal">ndb_fully_replicated</code> system variable. Setting
                it to <code class="literal">ON</code> enables the option by default for
                all new <code class="literal">NDB</code> tables; the default is
                <code class="literal">OFF</code>, which maintains the previous behavior
                (as in MySQL NDB Cluster 7.5.1 and earlier, before support for
                fully replicated tables was introduced). The
                <a class="link" href="mysql-cluster.html#sysvar_ndb_data_node_neighbour"><code class="literal">ndb_data_node_neighbour</code></a> system
                variable is also used for fully replicated tables, to ensure
                that when a fully replicated table is accessed, we access the
                data node which is local to this MySQL Server.
            </p><p style="color:blue;">也可以使用ndb_fully_replicated系统变量控制此设置。如果将其设置为on，则默认情况下对所有新的ndb表启用该选项；默认值为off，这将保持以前的行为（如mysql ndb cluster 7.5.1和更早版本中，在引入对完全复制表的支持之前）。ndb_data_node_neighbor系统变量也用于完全复制的表，以确保在访问完全复制的表时，我们访问该mysql服务器本地的数据节点。</p><p>
                An example of a <code class="literal">CREATE TABLE</code> statement using
                such a comment when creating an <code class="literal">NDB</code> table is
                shown here:
            </p><p style="color:blue;">创建ndb表时使用此类注释的create table语句示例如下所示：</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>CREATE TABLE t1 (</code></strong>
     &gt;     <strong class="userinput"><code>c1 INT NOT NULL AUTO_INCREMENT PRIMARY KEY,</code></strong>
     &gt;     <strong class="userinput"><code>c2 VARCHAR(100),</code></strong>
     &gt;     <strong class="userinput"><code>c3 VARCHAR(100) )</code></strong>
     &gt; <strong class="userinput"><code>ENGINE=NDB</code></strong>
     &gt;
<strong class="userinput"><code>COMMENT="NDB_TABLE=READ_BACKUP=0,PARTITION_BALANCE=FOR_RP_BY_NODE";</code></strong>
</pre><p>
                The comment is displayed as part of the ouput of
                <a class="link" href="sql-syntax.html#show-create-table" title="13.7.5.10&nbsp;SHOW CREATE TABLE Syntax"><code class="literal">SHOW CREATE TABLE</code></a>. The text of
                the comment is also available from querying the MySQL
                Information Schema <a class="link" href="information-schema.html#tables-table" title="24.25&nbsp;The INFORMATION_SCHEMA TABLES Table"><code class="literal">TABLES</code></a> table, as
                in this example:
            </p><p style="color:blue;">注释显示为show create表输出的一部分。还可以通过查询mysql information schema tables表获得注释文本，如下例所示：</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT TABLE_NAME, TABLE_SCHEMA, TABLE_COMMENT</code></strong>
     &gt; <strong class="userinput"><code>FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_NAME="t1";</code></strong>
+------------+--------------+----------------------------------------------------------+
| TABLE_NAME | TABLE_SCHEMA | TABLE_COMMENT                                            |
+------------+--------------+----------------------------------------------------------+
| t1         | c            | NDB_TABLE=READ_BACKUP=0,PARTITION_BALANCE=FOR_RP_BY_NODE |
| t1         | d            |                                                          |
+------------+--------------+----------------------------------------------------------+
2 rows in set (0.00 sec)
</pre><p>
                This comment syntax is also supported with
                <a class="link" href="sql-syntax.html#alter-table" title="13.1.8&nbsp;ALTER TABLE Syntax"><code class="literal">ALTER TABLE</code></a> statements for
                <code class="literal">NDB</code> tables. Keep in mind that a table comment
                used with <code class="literal">ALTER TABLE</code> replaces any existing
                comment which the table might have.
            </p><p style="color:blue;">对于ndb表，alter table语句也支持这种注释语法。请记住，使用ALTER表的表注释取代了表中可能存在的任何现有注释。</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>ALTER TABLE t1 COMMENT="NDB_TABLE=PARTITION_BALANCE=FOR_RA_BY_NODE";</code></strong>
Query OK, 0 rows affected (0.40 sec)
Records: 0  Duplicates: 0  Warnings: 0

mysql&gt; <strong class="userinput"><code>SELECT TABLE_NAME, TABLE_SCHEMA, TABLE_COMMENT</code></strong>
     &gt; <strong class="userinput"><code>FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_NAME="t1";</code></strong>
+------------+--------------+--------------------------------------------------+
| TABLE_NAME | TABLE_SCHEMA | TABLE_COMMENT                                    |
+------------+--------------+--------------------------------------------------+
| t1         | c            | NDB_TABLE=PARTITION_BALANCE=FOR_RA_BY_NODE       |
| t1         | d            |                                                  |
+------------+--------------+--------------------------------------------------+
2 rows in set (0.01 sec)
</pre><p>
                You can also see the value of the
                <code class="literal">PARTITION_BALANCE</code> option in the output of
                <a class="link" href="mysql-cluster.html#mysql-cluster-programs-ndb-desc" title="21.4.10&nbsp;ndb_desc — Describe NDB Tables"><span class="command"><strong>ndb_desc</strong></span></a>. <a class="link" href="mysql-cluster.html#mysql-cluster-programs-ndb-desc" title="21.4.10&nbsp;ndb_desc — Describe NDB Tables"><span class="command"><strong>ndb_desc</strong></span></a> also
                shows whether the <code class="literal">READ_BACKUP</code> and
                <code class="literal">FULLY_REPLICATED</code> options are set for the
                table. See the description of this program for more information.
            </p><p style="color:blue;">您还可以看到NdByDeSC.No.NdByDESC输出中的分区TythOpTalk选项的值，也显示了为表设置了Read备份和FulyLyRead选项。有关详细信息，请参阅此程序的说明。</p><p>
                Because the <code class="literal">READ_BACKUP</code> value was not carried
                over to the new comment set by the <code class="literal">ALTER
                TABLE</code> statement, there is no longer a way using SQL to
                retrieve the value previously set for it. To keep this from
                happening, it is suggested that you preserve any such values
                from the existing comment string, like this:
            </p><p style="color:blue;">由于read_backup值没有被传递到alter table语句设置的新注释集，因此不再有方法使用sql来检索以前为它设置的值。为了防止这种情况发生，建议您保留来自现有注释字符串的任何此类值，如下所示：</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT TABLE_NAME, TABLE_SCHEMA, TABLE_COMMENT</code></strong>
     &gt; <strong class="userinput"><code>FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_NAME="t1";</code></strong>
+------------+--------------+----------------------------------------------------------+
| TABLE_NAME | TABLE_SCHEMA | TABLE_COMMENT                                            |
+------------+--------------+----------------------------------------------------------+
| t1         | c            | NDB_TABLE=READ_BACKUP=0,PARTITION_BALANCE=FOR_RP_BY_NODE |
| t1         | d            |                                                          |
+------------+--------------+----------------------------------------------------------+
2 rows in set (0.00 sec)

mysql&gt; <strong class="userinput"><code>ALTER TABLE t1 COMMENT="NDB_TABLE=READ_BACKUP=0,PARTITION_BALANCE=FOR_RA_BY_NODE";</code></strong>
Query OK, 0 rows affected (1.56 sec)
Records: 0  Duplicates: 0  Warnings: 0

mysql&gt; <strong class="userinput"><code>SELECT TABLE_NAME, TABLE_SCHEMA, TABLE_COMMENT</code></strong>
     &gt; <strong class="userinput"><code>FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_NAME="t1";</code></strong>
+------------+--------------+----------------------------------------------------------------+
| TABLE_NAME | TABLE_SCHEMA | TABLE_COMMENT                                                  |
+------------+--------------+----------------------------------------------------------------+
| t1         | c            | NDB_TABLE=READ_BACKUP=0,PARTITION_BALANCE=FOR_RA_BY_NODE       |
| t1         | d            |                                                                |
+------------+--------------+----------------------------------------------------------------+
2 rows in set (0.01 sec)
</pre>
            </div>

        </div>
        <div class="section">
            <div class="titlepage">
                <div>
                    <div>
                        <h3 class="title"><a name="create-tablespace"></a>13.1.19&nbsp;CREATE TABLESPACE Syntax</h3>

                    </div>

                </div>

            </div>
            <a class="indexterm" name="idm140286837481552"></a><a class="indexterm" name="idm140286837480512"></a><pre data-lang="sql" class="programlisting">CREATE TABLESPACE <em class="replaceable"><code>tablespace_name</code></em>

  <span class="emphasis"><em>InnoDB and NDB:</em></span>
    ADD DATAFILE '<em class="replaceable"><code>file_name</code></em>'

  <span class="emphasis"><em>InnoDB only:</em></span>
    [FILE_BLOCK_SIZE = value]

  <span class="emphasis"><em>NDB only:</em></span>
    USE LOGFILE GROUP <em class="replaceable"><code>logfile_group</code></em>
    [EXTENT_SIZE [=] <em class="replaceable"><code>extent_size</code></em>]
    [INITIAL_SIZE [=] <em class="replaceable"><code>initial_size</code></em>]
    [AUTOEXTEND_SIZE [=] <em class="replaceable"><code>autoextend_size</code></em>]
    [MAX_SIZE [=] <em class="replaceable"><code>max_size</code></em>]
    [NODEGROUP [=] <em class="replaceable"><code>nodegroup_id</code></em>]
    [WAIT]
    [COMMENT [=] '<em class="replaceable"><code>string</code></em>']

  <span class="emphasis"><em>InnoDB and NDB:</em></span>
    [ENGINE [=] <em class="replaceable"><code>engine_name</code></em>]
</pre><p>
            This statement is used to create a tablespace. The precise syntax
            and semantics depend on the storage engine used. In standard MySQL
            5.7 releases, this is always an
            <a class="link" href="innodb-storage-engine.html" title="Chapter&nbsp;14&nbsp;The InnoDB Storage Engine"><code class="literal">InnoDB</code></a> tablespace. MySQL NDB Cluster
            7.5 also supports tablespaces using the
            <a class="link" href="mysql-cluster.html" title="Chapter&nbsp;21&nbsp;MySQL NDB Cluster 7.5 and NDB Cluster 7.6"><code class="literal">NDB</code></a> storage engine in addition to
            those using <code class="literal">InnoDB</code>.
        </p><p style="color:blue;">此语句用于创建表空间。精确的语法和语义取决于使用的存储引擎。在标准的mysql 5.7版本中，这始终是一个innodb表空间。mysql ndb cluster 7.5除了支持使用innodb的表空间外，还支持使用ndb存储引擎的表空间。</p>
            <div class="itemizedlist">
                <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><a class="xref" href="sql-syntax.html#create-tablespace-innodb" title="Considerations for InnoDB">Considerations for InnoDB</a></p><p style="color:blue;">InnoDB的注意事项</p></li><li class="listitem"><p><a class="xref" href="sql-syntax.html#create-tablespace-ndb" title="Considerations for NDB Cluster">Considerations for NDB Cluster</a></p><p style="color:blue;">ndb集群的考虑</p></li><li class="listitem"><p><a class="xref" href="sql-syntax.html#create-tablespace-options" title="Options">Options</a></p><p style="color:blue;">选项</p></li><li class="listitem"><p><a class="xref" href="sql-syntax.html#create-tablespace-notes" title="Notes">Notes</a></p><p style="color:blue;">笔记</p></li><li class="listitem"><p><a class="xref" href="sql-syntax.html#create-tablespace-innodb-examples" title="InnoDB Examples">InnoDB Examples</a></p><p style="color:blue;">InnoDB示例</p></li><li class="listitem"><p><a class="xref" href="sql-syntax.html#create-tablespace-ndb-examples" title="NDB Example">NDB Example</a></p><p style="color:blue;">ndb示例</p></li></ul>
            </div>
            <h4><a name="create-tablespace-innodb"></a>Considerations for InnoDB</h4>
            <p>
                <a class="link" href="sql-syntax.html#create-tablespace" title="13.1.19&nbsp;CREATE TABLESPACE Syntax"><code class="literal">CREATE TABLESPACE</code></a> syntax is used to
                create general tablespaces. A general tablespace is a shared
                tablespace. It can hold multiple tables, and supports all table
                row formats. General tablespaces can be created in a location
                relative to or independent of the data directory.
            </p><p style="color:blue;">创建表空间语法用于创建常规表空间。一般表空间是共享表空间。它可以容纳多个表，并支持所有表行格式。一般表空间可以在相对于或独立于数据目录的位置创建。</p><p>
            After creating an <code class="literal">InnoDB</code> general tablespace,
            you can use <a class="link" href="sql-syntax.html#create-table" title="13.1.18&nbsp;CREATE TABLE Syntax"><code class="literal">CREATE
            TABLE <em class="replaceable"><code>tbl_name</code></em> ... TABLESPACE [=]
            <em class="replaceable"><code>tablespace_name</code></em></code></a> or
            <a class="link" href="sql-syntax.html#alter-table" title="13.1.8&nbsp;ALTER TABLE Syntax"><code class="literal">ALTER TABLE
                <em class="replaceable"><code>tbl_name</code></em> TABLESPACE [=]
                <em class="replaceable"><code>tablespace_name</code></em></code></a> to add tables
            to the tablespace. For more information, see
            <a class="xref" href="innodb-storage-engine.html#general-tablespaces" title="14.6.3.3&nbsp;General Tablespaces">Section&nbsp;14.6.3.3, “General Tablespaces”</a>.
        </p><p style="color:blue;">创建innodb通用表空间后，可以使用create table tbl_name…tablespace[=]tablespace_name或alter table tbl_name tablespace[=]tablespace_name将表添加到表空间。有关更多信息，请参阅14.6.3.3节“常规表空间”。</p>
            <h4><a name="create-tablespace-ndb"></a>Considerations for NDB Cluster</h4>
            <p>
                This statement is used to create a tablespace, which can contain
                one or more data files, providing storage space for NDB Cluster
                Disk Data tables (see <a class="xref" href="mysql-cluster.html#mysql-cluster-disk-data" title="21.5.13&nbsp;NDB Cluster Disk Data Tables">Section&nbsp;21.5.13, “NDB Cluster Disk Data Tables”</a>).
                One data file is created and added to the tablespace using this
                statement. Additional data files may be added to the tablespace by
                using the <a class="link" href="sql-syntax.html#alter-tablespace" title="13.1.9&nbsp;ALTER TABLESPACE Syntax"><code class="literal">ALTER TABLESPACE</code></a>
                statement (see <a class="xref" href="sql-syntax.html#alter-tablespace" title="13.1.9&nbsp;ALTER TABLESPACE Syntax">Section&nbsp;13.1.9, “ALTER TABLESPACE Syntax”</a>).
            </p><p style="color:blue;">此语句用于创建一个表空间，该表空间可以包含一个或多个数据文件，为ndb群集磁盘数据表提供存储空间（请参阅21.5.13节，“ndb群集磁盘数据表”）。使用此语句创建一个数据文件并将其添加到表空间。可以使用alter tablespace语句将其他数据文件添加到表空间（请参阅13.1.9节，“alter tablespace syntax”）。</p>
            <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">

                <div class="admon-title">
                    Note
                </div>
                <p>
                    All NDB Cluster Disk Data objects share the same namespace. This
                    means that <span class="emphasis"><em>each Disk Data object</em></span> must be
                    uniquely named (and not merely each Disk Data object of a given
                    type). For example, you cannot have a tablespace and a log file
                    group with the same name, or a tablespace and a data file with
                    the same name.
                </p><p style="color:blue;">所有ndb群集磁盘数据对象共享同一命名空间。这意味着每个磁盘数据对象必须有唯一的名称（而不仅仅是给定类型的每个磁盘数据对象）。例如，不能有同名的表空间和日志文件组，也不能有同名的表空间和数据文件。</p>
            </div>
            <p>
                A log file group of one or more <code class="literal">UNDO</code> log files
                must be assigned to the tablespace to be created with the
                <code class="literal">USE LOGFILE GROUP</code> clause.
                <em class="replaceable"><code>logfile_group</code></em> must be an existing log
                file group created with <a class="link" href="sql-syntax.html#create-logfile-group" title="13.1.15&nbsp;CREATE LOGFILE GROUP Syntax"><code class="literal">CREATE LOGFILE
                GROUP</code></a> (see <a class="xref" href="sql-syntax.html#create-logfile-group" title="13.1.15&nbsp;CREATE LOGFILE GROUP Syntax">Section&nbsp;13.1.15, “CREATE LOGFILE GROUP Syntax”</a>).
                Multiple tablespaces may use the same log file group for
                <code class="literal">UNDO</code> logging.
            </p><p style="color:blue;">必须将一个或多个撤消日志文件的日志文件组分配给要使用USE LOGFILE GROUP子句创建的表空间。LogFieleGy组必须是用创建日志文件组创建的现有日志文件组（参见第131.15节，“创建日志文件组语法”）。多个表空间可以使用同一个日志文件组来撤消日志记录。</p><p>
            When setting <code class="literal">EXTENT_SIZE</code> or
            <code class="literal">INITIAL_SIZE</code>, you may optionally follow the
            number with a one-letter abbreviation for an order of magnitude,
            similar to those used in <code class="filename">my.cnf</code>. Generally,
            this is one of the letters <code class="literal">M</code> (for megabytes) or
            <code class="literal">G</code> (for gigabytes).
        </p><p style="color:blue;">在设置范围大小或初始大小时，您可以选择在数字后面加上一个一个字母的数量级缩写，类似于my.cnf中使用的缩写。通常，这是m（兆字节）或g（千兆字节）中的一个字母。</p><p>
            <code class="literal">INITIAL_SIZE</code> and <code class="literal">EXTENT_SIZE</code>
            are subject to rounding as follows:
        </p><p style="color:blue;">初始尺寸和范围尺寸可按如下四舍五入：</p>
            <div class="itemizedlist">
                <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                    <code class="literal">EXTENT_SIZE</code> is rounded up to the nearest
                    whole multiple of 32K.
                </p><p style="color:blue;">区段大小四舍五入到32K的最接近整数倍。</p></li><li class="listitem"><p>
                    <code class="literal">INITIAL_SIZE</code> is rounded
                    <span class="emphasis"><em>down</em></span> to the nearest whole multiple of
                    32K; this result is rounded up to the nearest whole multiple
                    of <code class="literal">EXTENT_SIZE</code> (after any rounding).
                </p><p style="color:blue;">初始_大小向下舍入到32K的最接近整数倍；此结果向上舍入到范围_大小的最接近整数倍（任何舍入之后）。</p></li></ul>
            </div>
            <p>
                The rounding just described is done explicitly, and a warning is
                issued by the MySQL Server when any such rounding is performed.
                The rounded values are also used by the NDB kernel for calculating
                <a class="link" href="information-schema.html#files-table" title="24.9&nbsp;The INFORMATION_SCHEMA FILES Table"><code class="literal">INFORMATION_SCHEMA.FILES</code></a> column
                values and other purposes. However, to avoid an unexpected result,
                we suggest that you always use whole multiples of 32K in
                specifying these options.
            </p><p style="color:blue;">刚才描述的舍入是显式完成的，当执行任何这样的舍入时，mysql服务器都会发出警告。ndb内核还使用舍入值计算information_schema.files列值和其他用途。但是，为了避免意外的结果，我们建议您在指定这些选项时始终使用32K的整数倍。</p><p>
            When <a class="link" href="sql-syntax.html#create-tablespace" title="13.1.19&nbsp;CREATE TABLESPACE Syntax"><code class="literal">CREATE TABLESPACE</code></a> is used with
            <code class="literal">ENGINE [=] NDB</code>, a tablespace and associated
            data file are created on each Cluster data node. You can verify
            that the data files were created and obtain information about them
            by querying the
            <a class="link" href="information-schema.html#files-table" title="24.9&nbsp;The INFORMATION_SCHEMA FILES Table"><code class="literal">INFORMATION_SCHEMA.FILES</code></a> table. (See
            the example later in this section.)
        </p><p style="color:blue;">当create tablespace与engine[=]ndb一起使用时，将在每个集群数据节点上创建一个表空间和相关的数据文件。您可以通过查询information\schema.files表来验证数据文件是否已创建，并获取有关它们的信息。（请参阅本节后面的示例。）</p><p>
            (See <a class="xref" href="information-schema.html#files-table" title="24.9&nbsp;The INFORMATION_SCHEMA FILES Table">Section&nbsp;24.9, “The INFORMATION_SCHEMA FILES Table”</a>.)
        </p><p style="color:blue;">（见第24.9节，“信息架构文件表”。）</p>
            <h4><a name="create-tablespace-options"></a>Options</h4>
            <div class="itemizedlist">
                <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                    <code class="literal">ADD DATAFILE</code>: Defines the name of a
                    tablespace data file; this option is always required. An
                    <code class="literal">InnoDB</code> tablespace supports only a single
                    data file, whose name must include a <code class="literal">.ibd</code>
                    extension. An NDB Cluster tablespace supports multiple data
                    files which can have any legal file names; more data files can
                    be added to an NDB Cluster tablespace following its creation
                    by using an <a class="link" href="sql-syntax.html#alter-tablespace" title="13.1.9&nbsp;ALTER TABLESPACE Syntax"><code class="literal">ALTER TABLESPACE</code></a>
                    statement.
                </p><p style="color:blue;">add data file：定义表空间数据文件的名称；此选项始终是必需的。innodb表空间只支持单个数据文件，其名称必须包含.ibd扩展名。ndb cluster表空间支持多个数据文件，这些文件可以有任何合法的文件名；在ndb cluster表空间创建之后，可以使用alter tablespace语句向其添加更多的数据文件。</p>
                    <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">

                        <div class="admon-title">
                            Note
                        </div>
                        <p>
                            <code class="literal">ALTER TABLESPACE</code> is not supported by
                            <code class="literal">InnoDB</code>.
                        </p><p style="color:blue;">innodb不支持alter tablespace。</p>
                    </div>
                    <p>
                        To place the data file in a location outside of the data
                        directory (<a class="link" href="server-administration.html#sysvar_datadir"><code class="literal">datadir</code></a>), include
                        an absolute directory path or a path relative to the data
                        directory. If you do not specify a path, the tablespace is
                        created in the data directory. An
                        <a class="link" href="glossary.html#glos_isl_file" title=".isl file">isl</a> file is created in
                        the data directory when an <code class="literal">InnoDB</code>
                        tablespace is created outside of the data directory.
                    </p><p style="color:blue;">要将数据文件放置在数据目录（datadir）之外的位置，请包含绝对目录路径或相对于数据目录的路径。如果不指定路径，则在数据目录中创建表空间。在数据目录之外创建innodb表空间时，将在数据目录中创建一个isl文件。</p><p>
                        To avoid conflicts with implicitly created file-per-table
                        tablespaces, creating a general tablespace in a subdirectory
                        under the data directory is not supported. When creating a
                        general tablespace outside of the data directory, the
                        directory must exist prior to creating the tablespace.
                    </p><p style="color:blue;">为了避免与隐式创建的每表文件表空间冲突，不支持在数据目录下的子目录中创建常规表空间。当在数据目录之外创建一个通用表空间时，目录必须在创建表空间之前存在。</p><p>
                        The <code class="literal"><em class="replaceable"><code>file_name</code></em></code>,
                        including any specified path, must be quoted with single or
                        double quotations marks. File names (not counting the file
                        extension) and directory names must be at least one byte in
                        length. Zero length file names and directory names are not
                        supported.
                    </p><p style="color:blue;">文件名（包括任何指定路径）必须用单引号或双引号引起来。文件名（不包括文件扩展名）和目录名的长度必须至少为一个字节。不支持零长度的文件名和目录名。</p></li><li class="listitem"><p>
                    <code class="literal">FILE_BLOCK_SIZE</code>: This option—which is
                    specific to <code class="literal">InnoDB</code>, and is ignored by
                    <code class="literal">NDB</code>—defines the block size for the
                    tablespace data file. Values can be specified in bytes or
                    kilobytes. For example, an 8 kilobyte file block size can be
                    specified as 8192 or 8K. If you do not specify this option,
                    <code class="literal">FILE_BLOCK_SIZE</code> defaults to the
                    <a class="link" href="innodb-storage-engine.html#sysvar_innodb_page_size"><code class="literal">innodb_page_size</code></a> value.
                    <code class="literal">FILE_BLOCK_SIZE</code> is required when you intend
                    to use the tablespace for storing compressed
                    <code class="literal">InnoDB</code> tables
                    (<code class="literal">ROW_FORMAT=COMPRESSED</code>). In this case, you
                    must define the tablespace <code class="literal">FILE_BLOCK_SIZE</code>
                    when creating the tablespace.
                </p><p style="color:blue;">file_block_size：这个选项是innodb特有的，被ndb忽略，它定义表空间数据文件的块大小。值可以指定为字节或千字节。例如，8千字节的文件块大小可以指定为8192或8K。如果不指定此选项，文件块大小默认为innodb页面大小值。当您打算使用表空间存储压缩的innodb表（row_format=compressed）时，需要使用file_block_size。在这种情况下，创建表空间时必须定义表空间文件块大小。</p><p>
                    If <code class="literal">FILE_BLOCK_SIZE</code> is equal the
                    <a class="link" href="innodb-storage-engine.html#sysvar_innodb_page_size"><code class="literal">innodb_page_size</code></a> value, the
                    tablespace can contain only tables having an uncompressed row
                    format (<code class="literal">COMPACT</code>,
                    <code class="literal">REDUNDANT</code>, and <code class="literal">DYNAMIC</code>).
                    Tables with a <code class="literal">COMPRESSED</code> row format have a
                    different physical page size than uncompressed tables.
                    Therefore, compressed tables cannot coexist in the same
                    tablespace as uncompressed tables.
                </p><p style="color:blue;">如果file_block_size等于innodb_page_size值，则表空间只能包含具有未压缩行格式（压缩、冗余和动态）的表。压缩行格式的表与未压缩的表具有不同的物理页大小。因此，压缩表不能与未压缩表在同一表空间中共存。</p><p>
                    For a general tablespace to contain compressed tables,
                    <code class="literal">FILE_BLOCK_SIZE</code> must be specified, and the
                    <code class="literal">FILE_BLOCK_SIZE</code> value must be a valid
                    compressed page size in relation to the
                    <a class="link" href="innodb-storage-engine.html#sysvar_innodb_page_size"><code class="literal">innodb_page_size</code></a> value. Also,
                    the physical page size of the compressed table
                    (<code class="literal">KEY_BLOCK_SIZE</code>) must be equal to
                    <code class="literal">FILE_BLOCK_SIZE/1024</code>. For example, if
                    <a class="link" href="innodb-storage-engine.html#sysvar_innodb_page_size"><code class="literal">innodb_page_size=16K</code></a>, and
                    <code class="literal">FILE_BLOCK_SIZE=8K</code>, the
                    <code class="literal">KEY_BLOCK_SIZE</code> of the table must be 8. For
                    more information, see <a class="xref" href="innodb-storage-engine.html#general-tablespaces" title="14.6.3.3&nbsp;General Tablespaces">Section&nbsp;14.6.3.3, “General Tablespaces”</a>.
                </p><p style="color:blue;">对于包含压缩表的常规表空间，必须指定file_block_size，并且file_block_size值必须是相对于innodb_page_size值的有效压缩页大小。此外，压缩表的物理页大小（key_block_size）必须等于file_block_size/1024。例如，如果innodb_page_size=16k，file_block_size=8k，则表的key_block_size必须为8。有关更多信息，请参阅14.6.3.3节“常规表空间”。</p></li><li class="listitem"><p>
                    <code class="literal">USE LOGFILE GROUP</code>: Required for
                    <code class="literal">NDB</code>, this is the name of a log file group
                    previously created using <a class="link" href="sql-syntax.html#create-logfile-group" title="13.1.15&nbsp;CREATE LOGFILE GROUP Syntax"><code class="literal">CREATE LOGFILE
                    GROUP</code></a>. Not supported for <code class="literal">InnoDB</code>,
                    where it fails with an error.
                </p><p style="color:blue;">使用日志文件组：对于ndb是必需的，这是以前使用create log file group创建的日志文件组的名称。InnoDB不支持，它会因错误而失败。</p></li><li class="listitem"><p>
                    <code class="literal">EXTENT_SIZE</code>: This option is specific to
                    NDB, and is not supported by InnoDB, where it fails with an
                    error. <code class="literal">EXTENT_SIZE</code> sets the size, in bytes,
                    of the extents used by any files belonging to the tablespace.
                    The default value is 1M. The minimum size is 32K, and
                    theoretical maximum is 2G, although the practical maximum size
                    depends on a number of factors. In most cases, changing the
                    extent size does not have any measurable effect on
                    performance, and the default value is recommended for all but
                    the most unusual situations.
                </p><p style="color:blue;">extent_size：这个选项是特定于ndb的，innodb不支持它，它会失败并出现错误。extent_size设置属于表空间的任何文件使用的扩展的大小（字节）。默认值为1m，最小大小为32 K，理论最大值为2G，但实际最大尺寸取决于多个因素。在大多数情况下，更改数据块大小对性能没有任何可测量的影响，除了最不寻常的情况外，建议对所有情况使用默认值。</p><p>
                    An <span class="firstterm">extent</span> is a unit of
                    disk space allocation. One extent is filled with as much data
                    as that extent can contain before another extent is used. In
                    theory, up to 65,535 (64K) extents may used per data file;
                    however, the recommended maximum is 32,768 (32K). The
                    recommended maximum size for a single data file is
                    32G—that is, 32K extents × 1 MB per extent. In
                    addition, once an extent is allocated to a given partition, it
                    cannot be used to store data from a different partition; an
                    extent cannot store data from more than one partition. This
                    means, for example that a tablespace having a single datafile
                    whose <code class="literal">INITIAL_SIZE</code> (described in the
                    following item) is 256 MB and whose
                    <code class="literal">EXTENT_SIZE</code> is 128M has just two extents,
                    and so can be used to store data from at most two different
                    disk data table partitions.
                </p><p style="color:blue;">区段是磁盘空间分配的单位。在使用另一个数据块之前，一个数据块将填充尽可能多的数据。理论上，每个数据文件可以使用多达65535（64K）的扩展；但是，推荐的最大值是32768（32 K）。单个数据文件的推荐最大大小是32克，即每度32 K扩展1×MB。此外，一旦一个区段被分配给一个给定的分区，它就不能用来存储来自不同分区的数据；一个区段不能存储来自多个分区的数据。这意味着，例如，一个表空间有一个数据文件，其初始大小（如下所述）为256 MB，扩展大小为128M，只有两个扩展，因此可以用于存储来自最多两个不同磁盘数据表分区的数据。</p><p>
                    You can see how many extents remain free in a given data file
                    by querying the
                    <a class="link" href="information-schema.html#files-table" title="24.9&nbsp;The INFORMATION_SCHEMA FILES Table"><code class="literal">INFORMATION_SCHEMA.FILES</code></a> table,
                    and so derive an estimate for how much space remains free in
                    the file. For further discussion and examples, see
                    <a class="xref" href="information-schema.html#files-table" title="24.9&nbsp;The INFORMATION_SCHEMA FILES Table">Section&nbsp;24.9, “The INFORMATION_SCHEMA FILES Table”</a>.
                </p><p style="color:blue;">通过查询information_schema.files表，可以看到给定数据文件中有多少区段保持空闲，因此可以得出文件中剩余空闲空间的估计值。有关进一步的讨论和示例，请参阅24.9节，“信息_schema files表”。</p></li><li class="listitem"><p>
                    <code class="literal">INITIAL_SIZE</code>: This option is specific to
                    <code class="literal">NDB</code>, and is not supported by
                    <code class="literal">InnoDB</code>, where it fails with an error.
                </p><p style="color:blue;">初始大小：这个选项是特定于ndb的，innodb不支持它，它会失败并出现错误。</p><p>
                    The <code class="literal">INITIAL_SIZE</code> parameter sets the total
                    size in bytes of the data file that was specific using
                    <code class="literal">ADD DATATFILE</code>. Once this file has been
                    created, its size cannot be changed; however, you can add more
                    data files to the tablespace using
                    <a class="link" href="sql-syntax.html#alter-tablespace" title="13.1.9&nbsp;ALTER TABLESPACE Syntax"><code class="literal">ALTER
                        TABLESPACE ... ADD DATAFILE</code></a>.
                </p><p style="color:blue;">initial_size参数设置使用add datatfile指定的数据文件的总大小（字节）。创建此文件后，无法更改其大小；但是，可以使用alter tablespace向表空间添加更多数据文件…添加数据文件。</p><p>
                    <code class="literal">INITIAL_SIZE</code> is optional; its default value
                    is 134217728 (128 MB).
                </p><p style="color:blue;">初始大小是可选的；其默认值为134217728（128 MB）。</p><p>
                    On 32-bit systems, the maximum supported value for
                    <code class="literal">INITIAL_SIZE</code> is 4294967296 (4 GB).
                </p><p style="color:blue;">在32位系统上，初始值的最大支持值为4294967296（4 GB）。</p></li><li class="listitem"><p>
                    <code class="literal">AUTOEXTEND_SIZE</code>: Currently ignored by
                    MySQL; reserved for possible future use. Has no effect in any
                    release of MySQL 5.7 or MySQL NDB Cluster 7.5, regardless of
                    the storage engine used.
                </p><p style="color:blue;">autoextend_size：mysql当前忽略；保留以备将来使用。在mysql 5.7或mysql ndb cluster 7.5的任何版本中都不起作用，无论使用何种存储引擎。</p></li><li class="listitem"><p>
                    <code class="literal">MAX_SIZE</code>: Currently ignored by MySQL;
                    reserved for possible future use. Has no effect in any release
                    of MySQL 5.7 or MySQL NDB Cluster 7.5, regardless of the
                    storage engine used.
                </p><p style="color:blue;">最大大小：MySQL当前忽略；保留以备将来使用。在mysql 5.7或mysql ndb cluster 7.5的任何版本中都不起作用，无论使用何种存储引擎。</p></li><li class="listitem"><p>
                    <code class="literal">NODEGROUP</code>: Currently ignored by MySQL;
                    reserved for possible future use. Has no effect in any release
                    of MySQL 5.7 or MySQL NDB Cluster 7.5, regardless of the
                    storage engine used.
                </p><p style="color:blue;">nodegroup：当前被mysql忽略；保留以备将来使用。在mysql 5.7或mysql ndb cluster 7.5的任何版本中都不起作用，无论使用何种存储引擎。</p></li><li class="listitem"><p>
                    <code class="literal">WAIT</code>: Currently ignored by MySQL; reserved
                    for possible future use. Has no effect in any release of MySQL
                    5.7 or MySQL NDB Cluster 7.5, regardless of the storage engine
                    used.
                </p><p style="color:blue;">wait：目前被mysql忽略；保留以备将来使用。在mysql 5.7或mysql ndb cluster 7.5的任何版本中都不起作用，无论使用何种存储引擎。</p></li><li class="listitem"><p>
                    <code class="literal">COMMENT</code>: Currently ignored by MySQL;
                    reserved for possible future use. Has no effect in any release
                    of MySQL 5.7 or MySQL NDB Cluster 7.5, regardless of the
                    storage engine used.
                </p><p style="color:blue;">注释：MySQL当前忽略；保留以备将来使用。在mysql 5.7或mysql ndb cluster 7.5的任何版本中都不起作用，无论使用何种存储引擎。</p></li><li class="listitem"><p>
                    <code class="literal">ENGINE</code>: Defines the storage engine which
                    uses the tablespace, where
                    <em class="replaceable"><code>engine_name</code></em> is the name of the
                    storage engine. Currently, only the <code class="literal">InnoDB</code>
                    storage engine is supported by standard MySQL 5.7
                    releases. MySQL NDB Cluster 7.5 supports both
                    <code class="literal">NDB</code> and <code class="literal">InnoDB</code>
                    tablespaces. The value of the
                    <a class="link" href="server-administration.html#sysvar_default_storage_engine"><code class="literal">default_storage_engine</code></a> system
                    variable is used for <code class="literal">ENGINE</code> if the option
                    is not specified.
                </p><p style="color:blue;">引擎：定义使用表空间的存储引擎，其中engine_name是存储引擎的名称。目前，标准的mysql 5.7版本只支持innodb存储引擎。mysql ndb cluster 7.5同时支持ndb和innodb表空间。如果未指定该选项，则默认存储引擎系统变量的值将用于引擎。</p></li></ul>
            </div>
            <h4><a name="create-tablespace-notes"></a>Notes</h4>
            <div class="itemizedlist">
                <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                    For the rules covering the naming of MySQL tablespaces, see
                    <a class="xref" href="language-structure.html#identifiers" title="9.2&nbsp;Schema Object Names">Section&nbsp;9.2, “Schema Object Names”</a>. In addition to these rules, the
                    slash character (<span class="quote">“<span class="quote">/</span>”</span>) is not permitted, nor can
                    you use names beginning with <code class="literal">innodb_</code>, as
                    this prefix is reserved for system use.
                </p><p style="color:blue;">有关mysql表空间命名的规则，请参阅9.2节“模式对象名称”。除这些规则外，不允许使用斜杠字符（“/”），也不能使用以innodb开头的名称，因为此前缀是为系统保留的。</p></li><li class="listitem"><p>
                    Tablespaces do not support temporary tables.
                </p><p style="color:blue;">表空间不支持临时表。</p></li><li class="listitem"><p>
                    <a class="link" href="innodb-storage-engine.html#sysvar_innodb_file_per_table"><code class="literal">innodb_file_per_table</code></a>,
                    <a class="link" href="innodb-storage-engine.html#sysvar_innodb_file_format"><code class="literal">innodb_file_format</code></a>, and
                    <a class="link" href="innodb-storage-engine.html#sysvar_innodb_file_format_max"><code class="literal">innodb_file_format_max</code></a>
                    settings have no influence on <code class="literal">CREATE
                    TABLESPACE</code> operations.
                    <a class="link" href="innodb-storage-engine.html#sysvar_innodb_file_per_table"><code class="literal">innodb_file_per_table</code></a> does
                    not need to be enabled. General tablespaces support all table
                    row formats regardless of file format settings. Likewise,
                    general tablespaces support the addition of tables of any row
                    format using
                    <a class="link" href="sql-syntax.html#create-table" title="13.1.18&nbsp;CREATE TABLE Syntax"><code class="literal">CREATE TABLE ...
                        TABLESPACE</code></a>, regardless of file format settings.
                </p><p style="color:blue;">innodb_file_per_table、innodb_file_format和innodb_file_format_max设置对创建表空间操作没有影响。不需要启用innodb_file_per_表。不管文件格式设置如何，常规表空间都支持所有表行格式。同样，通用表空间支持使用CREATETABLE添加任何行格式的表…表空间，不管文件格式设置如何。</p></li><li class="listitem"><p>
                    <a class="link" href="innodb-storage-engine.html#sysvar_innodb_strict_mode"><code class="literal">innodb_strict_mode</code></a> is not
                    applicable to general tablespaces. Tablespace management rules
                    are strictly enforced independently of
                    <a class="link" href="innodb-storage-engine.html#sysvar_innodb_strict_mode"><code class="literal">innodb_strict_mode</code></a>. If
                    <code class="literal">CREATE TABLESPACE</code> parameters are incorrect
                    or incompatible, the operation fails regardless of the
                    <a class="link" href="innodb-storage-engine.html#sysvar_innodb_strict_mode"><code class="literal">innodb_strict_mode</code></a> setting.
                    When a table is added to a general tablespace using
                    <a class="link" href="sql-syntax.html#create-table" title="13.1.18&nbsp;CREATE TABLE Syntax"><code class="literal">CREATE TABLE ...
                        TABLESPACE</code></a> or
                    <a class="link" href="sql-syntax.html#alter-table" title="13.1.8&nbsp;ALTER TABLE Syntax"><code class="literal">ALTER TABLE ...
                        TABLESPACE</code></a>,
                    <a class="link" href="innodb-storage-engine.html#sysvar_innodb_strict_mode"><code class="literal">innodb_strict_mode</code></a> is ignored
                    but the statement is evaluated as if
                    <a class="link" href="innodb-storage-engine.html#sysvar_innodb_strict_mode"><code class="literal">innodb_strict_mode</code></a> is
                    enabled.
                </p><p style="color:blue;">innodb_strict_mode不适用于一般表空间。严格执行表空间管理规则，独立于innodb_strict_模式。如果create tablespace参数不正确或不兼容，则不管innodb_strict_mode设置如何，操作都将失败。当使用CREATETABLE将表添加到常规表空间时…表空间或更改表…表空间，忽略innodb_strict_mode，但语句的计算方式与启用innodb_strict_mode相同。</p></li><li class="listitem"><p>
                    Use <code class="literal">DROP TABLESPACE</code> to remove a tablespace.
                    All tables must be dropped from a tablespace using
                    <a class="link" href="sql-syntax.html#drop-table" title="13.1.29&nbsp;DROP TABLE Syntax"><code class="literal">DROP TABLE</code></a> prior to dropping
                    the tablespace. Before dropping an NDB Cluster tablespace you
                    must also remove all its data files using one or more
                    <a class="link" href="sql-syntax.html#alter-tablespace" title="13.1.9&nbsp;ALTER TABLESPACE Syntax"><code class="literal">ALTER
                        TABLESPACE ... DROP DATATFILE</code></a> statements. See
                    <a class="xref" href="mysql-cluster.html#mysql-cluster-disk-data-objects" title="21.5.13.1&nbsp;NDB Cluster Disk Data Objects">Section&nbsp;21.5.13.1, “NDB Cluster Disk Data Objects”</a>.
                </p><p style="color:blue;">使用drop tablespace删除表空间。在删除表空间之前，必须使用DROP TABLE从表空间中删除所有表。在删除ndb集群表空间之前，还必须使用一个或多个alter tablespace删除其所有数据文件…删除datatfile语句。见21.5.13.1节，“ndb群集磁盘数据对象”。</p></li><li class="listitem"><p>
                    All parts of an <code class="literal">InnoDB</code> table added to an
                    <code class="literal">InnoDB</code> general tablespace reside in the
                    general tablespace, including indexes and
                    <a class="link" href="data-types.html#blob" title="11.4.3&nbsp;The BLOB and TEXT Types"><code class="literal">BLOB</code></a> pages.
                </p><p style="color:blue;">添加到innodb通用表空间的innodb表的所有部分都位于通用表空间中，包括索引和blob页。</p><p>
                    For an <code class="literal">NDB</code> table assigned to a tablespace,
                    only those columns which are not indexed are stored on disk,
                    and actually use the tablespace data files. Indexes and
                    indexed columns for all <code class="literal">NDB</code> tables are
                    always kept in memory.
                </p><p style="color:blue;">对于分配给表空间的ndb表，只有那些没有索引的列才存储在磁盘上，并实际使用表空间数据文件。所有ndb表的索引和索引列始终保存在内存中。</p></li><li class="listitem"><p>
                    Similar to the system tablespace, truncating or dropping
                    tables stored in a general tablespace creates free space
                    internally in the general tablespace
                    <a class="link" href="glossary.html#glos_ibd_file" title=".ibd file">.ibd data file</a> which can
                    only be used for new <code class="literal">InnoDB</code> data. Space is
                    not released back to the operating system as it is for
                    file-per-table tablespaces.
                </p><p style="color:blue;">与系统表空间类似，截断或删除存储在通用表空间中的表会在通用表空间.ibd数据文件内部创建可用空间，该文件只能用于新的innodb数据。空间不会释放回操作系统，因为它是针对每个表的文件表空间。</p></li><li class="listitem"><p>
                    A general tablespace is not associated with any database or
                    schema.
                </p><p style="color:blue;">常规表空间与任何数据库或架构都没有关联。</p></li><li class="listitem"><p>
                    <a class="link" href="sql-syntax.html#alter-table" title="13.1.8&nbsp;ALTER TABLE Syntax"><code class="literal">ALTER TABLE ...
                        DISCARD TABLESPACE</code></a> and
                    <a class="link" href="sql-syntax.html#alter-table" title="13.1.8&nbsp;ALTER TABLE Syntax"><code class="literal">ALTER TABLE
                        ...IMPORT TABLESPACE</code></a> are not supported for tables
                    that belong to a general tablespace.
                </p><p style="color:blue;">更改表…discard tablespace和alter table…import tablespace不支持属于常规表空间的表。</p></li><li class="listitem"><p>
                    The server uses tablespace-level metadata locking for DDL that
                    references general tablespaces. By comparison, the server uses
                    table-level metadata locking for DDL that references
                    file-per-table tablespaces.
                </p><p style="color:blue;">服务器对引用常规表空间的ddl使用表空间级元数据锁定。相比之下，服务器对ddl使用表级元数据锁，该锁引用每个表表空间的文件。</p></li><li class="listitem"><p>
                    A generated or existing tablespace cannot be changed to a
                    general tablespace.
                </p><p style="color:blue;">生成的或现有的表空间不能更改为通用表空间。</p></li><li class="listitem"><p>
                    Tables stored in a general tablespace can only be opened in
                    MySQL 5.7.6 or later due to the addition of new table flags.
                </p><p style="color:blue;">由于添加了新的表标志，存储在通用表空间中的表只能在mysql 5.7.6或更高版本中打开。</p></li><li class="listitem"><p>
                    There is no conflict between general tablespace names and
                    file-per-table tablespace names. The <span class="quote">“<span class="quote">/</span>”</span>
                    character, which is present in file-per-table tablespace
                    names, is not permitted in general tablespace names.
                </p><p style="color:blue;">常规表空间名和文件/表空间名之间没有冲突。在一般的表空间名称中，每个表空间名的文件中都不允许使用“/”字符。</p></li><li class="listitem"><p>
                    <a class="link" href="programs.html#mysqldump" title="4.5.4&nbsp;mysqldump — A Database Backup Program"><span class="command"><strong>mysqldump</strong></span></a> and <a class="link" href="programs.html#mysqlpump" title="4.5.6&nbsp;mysqlpump — A Database Backup Program"><span class="command"><strong>mysqlpump</strong></span></a>
                    do not dump <code class="literal">InnoDB</code>
                    <a class="link" href="sql-syntax.html#create-tablespace" title="13.1.19&nbsp;CREATE TABLESPACE Syntax"><code class="literal">CREATE TABLESPACE</code></a> statements.
                </p><p style="color:blue;">mysqldump和mysqlpump不转储innodb create tablespace语句。</p></li></ul>
            </div>
            <h4><a name="create-tablespace-innodb-examples"></a>InnoDB Examples</h4>
            <p>
                This example demonstrates creating a general tablespace and adding
                three uncompressed tables of different row formats.
            </p><p style="color:blue;">此示例演示如何创建常规表空间并添加三个不同行格式的未压缩表。</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>CREATE TABLESPACE `ts1` ADD DATAFILE 'ts1.ibd' ENGINE=INNODB;</code></strong>

mysql&gt; <strong class="userinput"><code>CREATE TABLE t1 (c1 INT PRIMARY KEY) TABLESPACE ts1 ROW_FORMAT=REDUNDANT;</code></strong>

mysql&gt; <strong class="userinput"><code>CREATE TABLE t2 (c1 INT PRIMARY KEY) TABLESPACE ts1 ROW_FORMAT=COMPACT;</code></strong>

mysql&gt; <strong class="userinput"><code>CREATE TABLE t3 (c1 INT PRIMARY KEY) TABLESPACE ts1 ROW_FORMAT=DYNAMIC;</code></strong>
</pre><p>
            This example demonstrates creating a general tablespace and adding
            a compressed table. The example assumes a default
            <a class="link" href="innodb-storage-engine.html#sysvar_innodb_page_size"><code class="literal">innodb_page_size</code></a> value of 16K.
            The <code class="literal">FILE_BLOCK_SIZE</code> of 8192 requires that the
            compressed table have a <code class="literal">KEY_BLOCK_SIZE</code> of 8.
        </p><p style="color:blue;">此示例演示如何创建常规表空间和添加压缩表。该示例假定innodb_page_size的默认值为16k。8192的file_block_size要求压缩表的key_block_size为8。</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>CREATE TABLESPACE `ts2` ADD DATAFILE 'ts2.ibd' FILE_BLOCK_SIZE = 8192 Engine=InnoDB;</code></strong>

mysql&gt; <strong class="userinput"><code>CREATE TABLE t4 (c1 INT PRIMARY KEY) TABLESPACE ts2 ROW_FORMAT=COMPRESSED KEY_BLOCK_SIZE=8;</code></strong>
</pre>
            <h4><a name="create-tablespace-ndb-examples"></a>NDB Example</h4>
            <p>
                Suppose that you wish to create an NDB Cluster Disk Data
                tablespace named <code class="literal">myts</code> using a datafile named
                <code class="filename">mydata-1.dat</code>. An <code class="filename">NDB</code>
                tablespace always requires the use of a log file group consisting
                of one or more undo log files. For this example, we first create a
                log file group named <code class="literal">mylg</code> that contains one
                undo long file named <code class="filename">myundo-1.dat</code>, using the
                <a class="link" href="sql-syntax.html#create-logfile-group" title="13.1.15&nbsp;CREATE LOGFILE GROUP Syntax"><code class="literal">CREATE LOGFILE GROUP</code></a> statement
                shown here:
            </p><p style="color:blue;">假设您希望使用名为mydata-1.dat的数据文件创建名为myts的ndb集群磁盘数据表空间。ndb表空间总是需要使用由一个或多个撤消日志文件组成的日志文件组。对于本例，我们首先使用下面显示的create log file group语句创建一个名为mylg的日志文件组，该日志文件组包含一个名为myundo-1.dat的撤消长文件：</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>CREATE LOGFILE GROUP myg1</code></strong>
    -&gt;     <strong class="userinput"><code>ADD UNDOFILE 'myundo-1.dat'</code></strong>
    -&gt;     <strong class="userinput"><code>ENGINE=NDB;</code></strong>
Query OK, 0 rows affected (3.29 sec)
</pre><p>
            Now you can create the tablespace previously described using the
            following statement:
        </p><p style="color:blue;">现在可以使用以下语句创建前面描述的表空间：</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>CREATE TABLESPACE myts</code></strong>
    -&gt;     <strong class="userinput"><code>ADD DATAFILE 'mydata-1.dat'</code></strong>
    -&gt;     <strong class="userinput"><code>USE LOGFILE GROUP mylg</code></strong>
    -&gt;     <strong class="userinput"><code>ENGINE=NDB;</code></strong>
Query OK, 0 rows affected (2.98 sec)
</pre><p>
            You can now create a Disk Data table using a
            <a class="link" href="sql-syntax.html#create-table" title="13.1.18&nbsp;CREATE TABLE Syntax"><code class="literal">CREATE TABLE</code></a> statement with the
            <code class="literal">TABLESPACE</code> and <code class="literal">STORAGE DISK</code>
            options, similar to what is shown here:
        </p><p style="color:blue;">现在，您可以使用带有表空间和存储磁盘选项的CREATE TABLE语句创建磁盘数据表，如下所示：</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>CREATE TABLE mytable (</code></strong>
    -&gt;     <strong class="userinput"><code>id INT UNSIGNED NOT NULL AUTO_INCREMENT PRIMARY KEY,</code></strong>
    -&gt;     <strong class="userinput"><code>lname VARCHAR(50) NOT NULL,</code></strong>
    -&gt;     <strong class="userinput"><code>fname VARCHAR(50) NOT NULL,</code></strong>
    -&gt;     <strong class="userinput"><code>dob DATE NOT NULL,</code></strong>
    -&gt;     <strong class="userinput"><code>joined DATE NOT NULL,</code></strong>
    -&gt;     <strong class="userinput"><code>INDEX(last_name, first_name)</code></strong>
    -&gt; <strong class="userinput"><code>)</code></strong>
    -&gt;     <strong class="userinput"><code>TABLESPACE myts STORAGE DISK</code></strong>
    -&gt;     <strong class="userinput"><code>ENGINE=NDB;</code></strong>
Query OK, 0 rows affected (1.41 sec)
</pre><p>
            It is important to note that only the <code class="literal">dob</code> and
            <code class="literal">joined</code> columns from <code class="literal">mytable</code>
            are actually stored on disk, due to the fact that the
            <code class="literal">id</code>, <code class="literal">lname</code>, and
            <code class="literal">fname</code> columns are all indexed.
        </p><p style="color:blue;">需要注意的是，由于id、lname和fname列都是索引列，因此实际上只有mytable中的dob列和连接列存储在磁盘上。</p><p>
            As mentioned previously, when <code class="literal">CREATE TABLESPACE</code>
            is used with <code class="literal">ENGINE [=] NDB</code>, a tablespace and
            associated data file are created on each NDB Cluster data node.
            You can verify that the data files were created and obtain
            information about them by querying the
            <a class="link" href="information-schema.html#files-table" title="24.9&nbsp;The INFORMATION_SCHEMA FILES Table"><code class="literal">INFORMATION_SCHEMA.FILES</code></a> table, as
            shown here:
        </p><p style="color:blue;">如前所述，当create tablespace与engine[=]ndb一起使用时，将在每个ndb集群数据节点上创建一个表空间和相关的数据文件。您可以通过查询information\schema.files表来验证数据文件是否已创建，并获取有关它们的信息，如下所示：</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT FILE_NAME, FILE_TYPE, LOGFILE_GROUP_NAME, STATUS, EXTRA</code></strong>
    -&gt;     <strong class="userinput"><code>FROM INFORMATION_SCHEMA.FILES</code></strong>
    -&gt;     <strong class="userinput"><code>WHERE TABLESPACE_NAME = 'myts';</code></strong>

+--------------+------------+--------------------+--------+----------------+
| file_name    | file_type  | logfile_group_name | status | extra          |
+--------------+------------+--------------------+--------+----------------+
| mydata-1.dat | DATAFILE   | mylg               | NORMAL | CLUSTER_NODE=5 |
| mydata-1.dat | DATAFILE   | mylg               | NORMAL | CLUSTER_NODE=6 |
| NULL         | TABLESPACE | mylg               | NORMAL | NULL           |
+--------------+------------+--------------------+--------+----------------+
3 rows in set (0.01 sec)
</pre><p>
            For additional information and examples, see
            <a class="xref" href="mysql-cluster.html#mysql-cluster-disk-data-objects" title="21.5.13.1&nbsp;NDB Cluster Disk Data Objects">Section&nbsp;21.5.13.1, “NDB Cluster Disk Data Objects”</a>.
        </p><p style="color:blue;">有关更多信息和示例，请参阅21.5.13.1节“ndb群集磁盘数据对象”。</p>
        </div>
        <div class="section">
            <div class="titlepage">
                <div>
                    <div>
                        <h3 class="title"><a name="create-trigger"></a>13.1.20&nbsp;CREATE TRIGGER Syntax</h3>

                    </div>

                </div>

            </div>
            <a class="indexterm" name="idm140286837242816"></a><a class="indexterm" name="idm140286837241744"></a><pre data-lang="sql" class="programlisting">CREATE
    [DEFINER = <em class="replaceable"><code>user</code></em>]
    TRIGGER <em class="replaceable"><code>trigger_name</code></em>
    <em class="replaceable"><code>trigger_time</code></em> <em class="replaceable"><code>trigger_event</code></em>
    ON <em class="replaceable"><code>tbl_name</code></em> FOR EACH ROW
    [<em class="replaceable"><code>trigger_order</code></em>]
    <em class="replaceable"><code>trigger_body</code></em>

<em class="replaceable"><code>trigger_time</code></em>: { BEFORE | AFTER }

<em class="replaceable"><code>trigger_event</code></em>: { INSERT | UPDATE | DELETE }

<em class="replaceable"><code>trigger_order</code></em>: { FOLLOWS | PRECEDES } <em class="replaceable"><code>other_trigger_name</code></em>
</pre><p>
            This statement creates a new trigger. A trigger is a named
            database object that is associated with a table, and that
            activates when a particular event occurs for the table. The
            trigger becomes associated with the table named
            <em class="replaceable"><code>tbl_name</code></em>, which must refer to a
            permanent table. You cannot associate a trigger with a
            <code class="literal">TEMPORARY</code> table or a view.
        </p><p style="color:blue;">此语句创建一个新触发器。触发器是与表关联的命名数据库对象，在表发生特定事件时激活。触发器与名为tbl_name的表关联，该表必须引用永久表。不能将触发器与临时表或视图关联。</p><p>
            Trigger names exist in the schema namespace, meaning that all
            triggers must have unique names within a schema. Triggers in
            different schemas can have the same name.
        </p><p style="color:blue;">触发器名称存在于架构命名空间中，这意味着所有触发器必须在架构内具有唯一名称。不同架构中的触发器可以具有相同的名称。</p><p>
            This section describes <a class="link" href="sql-syntax.html#create-trigger" title="13.1.20&nbsp;CREATE TRIGGER Syntax"><code class="literal">CREATE
            TRIGGER</code></a> syntax. For additional discussion, see
            <a class="xref" href="stored-objects.html#trigger-syntax" title="23.3.1&nbsp;Trigger Syntax and Examples">Section&nbsp;23.3.1, “Trigger Syntax and Examples”</a>.
        </p><p style="color:blue;">本节介绍创建触发器语法。有关其他讨论，请参见第23.3.1节“触发器语法和示例”。</p><p>
            <a class="link" href="sql-syntax.html#create-trigger" title="13.1.20&nbsp;CREATE TRIGGER Syntax"><code class="literal">CREATE TRIGGER</code></a> requires the
            <a class="link" href="security.html#priv_trigger"><code class="literal">TRIGGER</code></a> privilege for the table
            associated with the trigger. If the <code class="literal">DEFINER</code>
            clause is present, the privileges required depend on the
            <em class="replaceable"><code>user</code></em> value, as discussed in
            <a class="xref" href="stored-objects.html#stored-objects-security" title="23.6&nbsp;Stored Object Access Control">Section&nbsp;23.6, “Stored Object Access Control”</a>. If binary logging is
            enabled, <a class="link" href="sql-syntax.html#create-trigger" title="13.1.20&nbsp;CREATE TRIGGER Syntax"><code class="literal">CREATE TRIGGER</code></a> might
            require the <a class="link" href="security.html#priv_super"><code class="literal">SUPER</code></a> privilege, as
            discussed in <a class="xref" href="stored-objects.html#stored-programs-logging" title="23.7&nbsp;Stored Program Binary Logging">Section&nbsp;23.7, “Stored Program Binary Logging”</a>.
        </p><p style="color:blue;">创建触发器需要与触发器关联的表的触发器特权。如果存在definer子句，则所需的权限取决于用户值，如第23.6节“存储对象访问控制”中所述。如果启用了二进制日志记录，则create触发器可能需要超级权限，如23.7节“存储程序二进制日志记录”中所述。</p><p>
            The <code class="literal">DEFINER</code> clause determines the security
            context to be used when checking access privileges at trigger
            activation time, as described later in this section.
        </p><p style="color:blue;">definer子句确定在触发器激活时检查访问权限时要使用的安全上下文，如本节后面所述。</p><p>
            <em class="replaceable"><code>trigger_time</code></em> is the trigger action
            time. It can be <code class="literal">BEFORE</code> or
            <code class="literal">AFTER</code> to indicate that the trigger activates
            before or after each row to be modified.
        </p><p style="color:blue;">触发器时间是触发器操作时间。它可以是before或after，以指示触发器在要修改的每一行之前或之后激活。</p><p>
            Basic column value checks occur prior to trigger activation, so
            you cannot use <code class="literal">BEFORE</code> triggers to convert
            values inappropriate for the column type to valid values.
        </p><p style="color:blue;">基本列值检查发生在触发器激活之前，因此不能使用before触发器将不适合列类型的值转换为有效值。</p><p>
            <em class="replaceable"><code>trigger_event</code></em> indicates the kind of
            operation that activates the trigger. These
            <em class="replaceable"><code>trigger_event</code></em> values are permitted:
        </p><p style="color:blue;">触发器事件表示激活触发器的操作类型。允许使用以下触发事件值：</p>
            <div class="itemizedlist">
                <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                    <a class="link" href="sql-syntax.html#insert" title="13.2.5&nbsp;INSERT Syntax"><code class="literal">INSERT</code></a>: The trigger activates
                    whenever a new row is inserted into the table (for example,
                    through <a class="link" href="sql-syntax.html#insert" title="13.2.5&nbsp;INSERT Syntax"><code class="literal">INSERT</code></a>,
                    <a class="link" href="sql-syntax.html#load-data" title="13.2.6&nbsp;LOAD DATA Syntax"><code class="literal">LOAD DATA</code></a>, and
                    <a class="link" href="sql-syntax.html#replace" title="13.2.8&nbsp;REPLACE Syntax"><code class="literal">REPLACE</code></a> statements).
                </p><p style="color:blue;">插入：每当向表中插入新行时（例如，通过插入、加载数据和替换语句），触发器就会激活。</p></li><li class="listitem"><p>
                    <a class="link" href="sql-syntax.html#update" title="13.2.11&nbsp;UPDATE Syntax"><code class="literal">UPDATE</code></a>: The trigger activates
                    whenever a row is modified (for example, through
                    <a class="link" href="sql-syntax.html#update" title="13.2.11&nbsp;UPDATE Syntax"><code class="literal">UPDATE</code></a> statements).
                </p><p style="color:blue;">update：每当修改行时（例如，通过update语句），触发器就会激活。</p></li><li class="listitem"><p>
                    <a class="link" href="sql-syntax.html#delete" title="13.2.2&nbsp;DELETE Syntax"><code class="literal">DELETE</code></a>: The trigger activates
                    whenever a row is deleted from the table (for example, through
                    <a class="link" href="sql-syntax.html#delete" title="13.2.2&nbsp;DELETE Syntax"><code class="literal">DELETE</code></a> and
                    <a class="link" href="sql-syntax.html#replace" title="13.2.8&nbsp;REPLACE Syntax"><code class="literal">REPLACE</code></a> statements).
                    <a class="link" href="sql-syntax.html#drop-table" title="13.1.29&nbsp;DROP TABLE Syntax"><code class="literal">DROP TABLE</code></a> and
                    <a class="link" href="sql-syntax.html#truncate-table" title="13.1.34&nbsp;TRUNCATE TABLE Syntax"><code class="literal">TRUNCATE TABLE</code></a> statements on
                    the table do <span class="emphasis"><em>not</em></span> activate this trigger,
                    because they do not use <a class="link" href="sql-syntax.html#delete" title="13.2.2&nbsp;DELETE Syntax"><code class="literal">DELETE</code></a>.
                    Dropping a partition does not activate
                    <a class="link" href="sql-syntax.html#delete" title="13.2.2&nbsp;DELETE Syntax"><code class="literal">DELETE</code></a> triggers, either.
                </p><p style="color:blue;">delete：每当从表中删除行时（例如，通过delete和replace语句），触发器就会激活。表上的drop table和truncate table语句不激活此触发器，因为它们不使用delete。删除分区也不会激活删除触发器。</p></li></ul>
            </div>
            <p>
                The <em class="replaceable"><code>trigger_event</code></em> does not represent a
                literal type of SQL statement that activates the trigger so much
                as it represents a type of table operation. For example, an
                <a class="link" href="sql-syntax.html#insert" title="13.2.5&nbsp;INSERT Syntax"><code class="literal">INSERT</code></a> trigger activates not only
                for <a class="link" href="sql-syntax.html#insert" title="13.2.5&nbsp;INSERT Syntax"><code class="literal">INSERT</code></a> statements but also
                <a class="link" href="sql-syntax.html#load-data" title="13.2.6&nbsp;LOAD DATA Syntax"><code class="literal">LOAD DATA</code></a> statements because both
                statements insert rows into a table.
            </p><p style="color:blue;">触发器事件不表示激活触发器的SQL语句的文本类型，而表示表操作的类型。例如，INSERT触发器不仅为INSERT语句激活，而且还为加载数据语句激活，因为这两个语句都将行插入到表中。</p><p>
            A potentially confusing example of this is the <code class="literal">INSERT
            INTO ... ON DUPLICATE KEY UPDATE ...</code> syntax: a
            <code class="literal">BEFORE INSERT</code> trigger activates for every row,
            followed by either an <code class="literal">AFTER INSERT</code> trigger or
            both the <code class="literal">BEFORE UPDATE</code> and <code class="literal">AFTER
            UPDATE</code> triggers, depending on whether there was a
            duplicate key for the row.
        </p><p style="color:blue;">一个可能令人困惑的例子是插入到…在重复密钥更新时…语法：每行激活一个before-insert触发器，后跟after-insert触发器或before-update和after-update触发器，具体取决于行是否有重复的键。</p>
            <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">

                <div class="admon-title">
                    Note
                </div>
                <p>
                    Cascaded foreign key actions do not activate triggers.
                </p><p style="color:blue;">级联外键操作不会激活触发器。</p>
            </div>
            <p>
                It is possible to define multiple triggers for a given table that
                have the same trigger event and action time. For example, you can
                have two <code class="literal">BEFORE UPDATE</code> triggers for a table. By
                default, triggers that have the same trigger event and action time
                activate in the order they were created. To affect trigger order,
                specify a <em class="replaceable"><code>trigger_order</code></em> clause that
                indicates <code class="literal">FOLLOWS</code> or
                <code class="literal">PRECEDES</code> and the name of an existing trigger
                that also has the same trigger event and action time. With
                <code class="literal">FOLLOWS</code>, the new trigger activates after the
                existing trigger. With <code class="literal">PRECEDES</code>, the new
                trigger activates before the existing trigger.
            </p><p style="color:blue;">可以为具有相同触发器事件和操作时间的给定表定义多个触发器。例如，一个表可以有两个before update触发器。默认情况下，具有相同触发器事件和操作时间的触发器按创建顺序激活。若要影响触发顺序，请指定指示后面或前面的触发器子句，以及现有触发器的名称，该触发器也具有相同的触发器事件和动作时间。接下来，新触发器在现有触发器之后激活。在前面，新触发器在现有触发器之前激活。</p><p>
            <em class="replaceable"><code>trigger_body</code></em> is the statement to
            execute when the trigger activates. To execute multiple
            statements, use the
            <a class="link" href="sql-syntax.html#begin-end" title="13.6.1&nbsp;BEGIN ... END Compound-Statement Syntax"><code class="literal">BEGIN ... END</code></a>
            compound statement construct. This also enables you to use the
            same statements that are permitted within stored routines. See
            <a class="xref" href="sql-syntax.html#begin-end" title="13.6.1&nbsp;BEGIN ... END Compound-Statement Syntax">Section&nbsp;13.6.1, “BEGIN ... END Compound-Statement Syntax”</a>. Some statements are not permitted in
            triggers; see <a class="xref" href="stored-objects.html#stored-program-restrictions" title="23.8&nbsp;Restrictions on Stored Programs">Section&nbsp;23.8, “Restrictions on Stored Programs”</a>.
        </p><p style="color:blue;">trigger_body是触发器激活时要执行的语句。要执行多个语句，请使用BEGIN…结束复合语句构造。这还允许您使用存储例程中允许的相同语句。见第13.6.1节，“开始……结束复合语句语法”。触发器中不允许使用某些语句；请参阅第23.8节“对存储程序的限制”。</p><p>
            Within the trigger body, you can refer to columns in the subject
            table (the table associated with the trigger) by using the aliases
            <code class="literal">OLD</code> and <code class="literal">NEW</code>.
            <code class="literal">OLD.<em class="replaceable"><code>col_name</code></em></code> refers
            to a column of an existing row before it is updated or deleted.
            <code class="literal">NEW.<em class="replaceable"><code>col_name</code></em></code> refers
            to the column of a new row to be inserted or an existing row after
            it is updated.
        </p><p style="color:blue;">在触发器主体中，可以通过使用新旧别名来引用主题表（与触发器关联的表）中的列。OL.COLYNEX是指在更新或删除之前现有行的列。No.CyLNEX引用要插入的新行的列或更新后的现有行。</p><a class="indexterm" name="idm140286837170112"></a><p>
            Triggers cannot use
            <code class="literal">NEW.<em class="replaceable"><code>col_name</code></em></code> or use
            <code class="literal">OLD.<em class="replaceable"><code>col_name</code></em></code> to
            refer to generated columns. For information about generated
            columns, see <a class="xref" href="sql-syntax.html#create-table-generated-columns" title="13.1.18.8&nbsp;CREATE TABLE and Generated Columns">Section&nbsp;13.1.18.8, “CREATE TABLE and Generated Columns”</a>.
        </p><p style="color:blue;">触发器不能使用new.col_name或使用old.col_name来引用生成的列。有关生成列的信息，请参见第13.1.18.8节“创建表和生成列”。</p><p>
            MySQL stores the <a class="link" href="server-administration.html#sysvar_sql_mode"><code class="literal">sql_mode</code></a> system
            variable setting in effect when a trigger is created, and always
            executes the trigger body with this setting in force,
            <span class="emphasis"><em>regardless of the current server SQL mode when the
      trigger begins executing</em></span>.
        </p><p style="color:blue;">mysql在创建触发器时存储有效的sql_mode系统变量设置，并始终在该设置有效时执行触发器主体，而不管触发器开始执行时的当前服务器sql模式如何。</p><p>
            The <code class="literal">DEFINER</code> clause specifies the MySQL account
            to be used when checking access privileges at trigger activation
            time. If the <code class="literal">DEFINER</code> clause is present, the
            <em class="replaceable"><code>user</code></em> value should be a MySQL account
            specified as
            <code class="literal">'<em class="replaceable"><code>user_name</code></em>'@'<em class="replaceable"><code>host_name</code></em>'</code>,
            <a class="link" href="functions.html#function_current-user"><code class="literal">CURRENT_USER</code></a>, or
            <a class="link" href="functions.html#function_current-user"><code class="literal">CURRENT_USER()</code></a>. The permitted
            <em class="replaceable"><code>user</code></em> values depend on the privileges
            you hold, as discussed in
            <a class="xref" href="stored-objects.html#stored-objects-security" title="23.6&nbsp;Stored Object Access Control">Section&nbsp;23.6, “Stored Object Access Control”</a>. Also see that section
            for additional information about trigger security.
        </p><p style="color:blue;">definer子句指定在触发器激活时检查访问权限时要使用的mysql帐户。如果存在definer子句，则用户值应为mysql帐户，指定为“user_name”@“host_name”、current_user或current_user（）。允许的用户值取决于您所拥有的特权，如第23.6节“存储对象访问控制”中所述。有关触发器安全性的其他信息，请参见该部分。</p><p>
            If the <code class="literal">DEFINER</code> clause is omitted, the default
            definer is the user who executes the <a class="link" href="sql-syntax.html#create-trigger" title="13.1.20&nbsp;CREATE TRIGGER Syntax"><code class="literal">CREATE
            TRIGGER</code></a> statement. This is the same as specifying
            <code class="literal">DEFINER = CURRENT_USER</code> explicitly.
        </p><p style="color:blue;">如果省略definer子句，则默认的definer是执行create trigger语句的用户。这与显式指定definer=current_user相同。</p><p>
            MySQL takes the <code class="literal">DEFINER</code> user into account when
            checking trigger privileges as follows:
        </p><p style="color:blue;">mysql在检查触发器权限时考虑了definer用户，如下所示：</p>
            <div class="itemizedlist">
                <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                    At <a class="link" href="sql-syntax.html#create-trigger" title="13.1.20&nbsp;CREATE TRIGGER Syntax"><code class="literal">CREATE TRIGGER</code></a> time, the
                    user who issues the statement must have the
                    <a class="link" href="security.html#priv_trigger"><code class="literal">TRIGGER</code></a> privilege.
                </p><p style="color:blue;">在创建触发器时，发出语句的用户必须具有触发器权限。</p></li><li class="listitem"><p>
                    At trigger activation time, privileges are checked against the
                    <code class="literal">DEFINER</code> user. This user must have these
                    privileges:
                </p><p style="color:blue;">在触发器激活时，将针对定义用户检查权限。此用户必须具有以下权限：</p>
                    <div class="itemizedlist">
                        <ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
                            The <a class="link" href="security.html#priv_trigger"><code class="literal">TRIGGER</code></a> privilege for
                            the subject table.
                        </p><p style="color:blue;">主题表的触发器特权。</p></li><li class="listitem"><p>
                            The <a class="link" href="security.html#priv_select"><code class="literal">SELECT</code></a> privilege for
                            the subject table if references to table columns occur
                            using
                            <code class="literal">OLD.<em class="replaceable"><code>col_name</code></em></code>
                            or
                            <code class="literal">NEW.<em class="replaceable"><code>col_name</code></em></code>
                            in the trigger body.
                        </p><p style="color:blue;">如果在触发器正文中使用old.col_name或new.col_name引用表列，则主题表的选择权限。</p></li><li class="listitem"><p>
                            The <a class="link" href="security.html#priv_update"><code class="literal">UPDATE</code></a> privilege for
                            the subject table if table columns are targets of
                            <code class="literal">SET NEW.<em class="replaceable"><code>col_name</code></em> =
                                <em class="replaceable"><code>value</code></em></code> assignments in
                            the trigger body.
                        </p><p style="color:blue;">如果表列是触发器正文中set new.col_name=value赋值的目标，则主题表的更新权限。</p></li><li class="listitem"><p>
                            Whatever other privileges normally are required for the
                            statements executed by the trigger.
                        </p><p style="color:blue;">触发器执行的语句通常需要的任何其他特权。</p></li></ul>
                    </div>
                </li></ul>
            </div>
            <p>
                Within a trigger body, the
                <a class="link" href="functions.html#function_current-user"><code class="literal">CURRENT_USER</code></a> function returns the
                account used to check privileges at trigger activation time. This
                is the <code class="literal">DEFINER</code> user, not the user whose actions
                caused the trigger to be activated. For information about user
                auditing within triggers, see
                <a class="xref" href="security.html#account-activity-auditing" title="6.2.18&nbsp;SQL-Based Account Activity Auditing">Section&nbsp;6.2.18, “SQL-Based Account Activity Auditing”</a>.
            </p><p style="color:blue;">在触发器体中，当前用户函数返回用于在触发器激活时检查权限的帐户。这是定义用户，而不是其操作导致触发器被激活的用户。有关触发器内用户审核的信息，请参阅第6.2.18节“基于SQL的帐户活动审核”。</p><p>
            If you use <a class="link" href="sql-syntax.html#lock-tables" title="13.3.5&nbsp;LOCK TABLES and UNLOCK TABLES Syntax"><code class="literal">LOCK TABLES</code></a> to lock a
            table that has triggers, the tables used within the trigger are
            also locked, as described in
            <a class="xref" href="sql-syntax.html#lock-tables-and-triggers" title="LOCK TABLES and Triggers">LOCK TABLES and Triggers</a>.
        </p><p style="color:blue;">如果使用锁定表锁定具有触发器的表，则触发器中使用的表也将被锁定，如锁定表和触发器中所述。</p><p>
            For additional discussion of trigger use, see
            <a class="xref" href="stored-objects.html#trigger-syntax" title="23.3.1&nbsp;Trigger Syntax and Examples">Section&nbsp;23.3.1, “Trigger Syntax and Examples”</a>.
        </p><p style="color:blue;">有关触发器使用的更多讨论，请参见第23.3.1节“触发器语法和示例”。</p>
        </div>
        <div class="section">
            <div class="titlepage">
                <div>
                    <div>
                        <h3 class="title"><a name="create-view"></a>13.1.21&nbsp;CREATE VIEW Syntax</h3>

                    </div>

                </div>

            </div>
            <a class="indexterm" name="idm140286837126256"></a><a class="indexterm" name="idm140286837125184"></a><a class="indexterm" name="idm140286837123696"></a><pre data-lang="sql" class="programlisting">CREATE
    [OR REPLACE]
    [ALGORITHM = {UNDEFINED | MERGE | TEMPTABLE}]
    [DEFINER = <em class="replaceable"><code>user</code></em>]
    [SQL SECURITY { DEFINER | INVOKER }]
    VIEW <em class="replaceable"><code>view_name</code></em> [(<em class="replaceable"><code>column_list</code></em>)]
    AS <em class="replaceable"><code>select_statement</code></em>
    [WITH [CASCADED | LOCAL] CHECK OPTION]
</pre><p>
            The <a class="link" href="sql-syntax.html#create-view" title="13.1.21&nbsp;CREATE VIEW Syntax"><code class="literal">CREATE VIEW</code></a> statement creates a
            new view, or replaces an existing view if the <code class="literal">OR
            REPLACE</code> clause is given. If the view does not exist,
            <a class="link" href="sql-syntax.html#create-view" title="13.1.21&nbsp;CREATE VIEW Syntax"><code class="literal">CREATE OR REPLACE
                VIEW</code></a> is the same as <a class="link" href="sql-syntax.html#create-view" title="13.1.21&nbsp;CREATE VIEW Syntax"><code class="literal">CREATE
            VIEW</code></a>. If the view does exist,
            <a class="link" href="sql-syntax.html#create-view" title="13.1.21&nbsp;CREATE VIEW Syntax"><code class="literal">CREATE OR REPLACE
                VIEW</code></a> replaces it.
        </p><p style="color:blue;">CREATEVIEW语句创建一个新视图，或者在给定OR替换子句时替换现有视图。如果视图不存在，则创建或替换视图与创建视图相同。如果视图确实存在，则创建或替换视图替换它。</p><p>
            For information about restrictions on view use, see
            <a class="xref" href="stored-objects.html#view-restrictions" title="23.9&nbsp;Restrictions on Views">Section&nbsp;23.9, “Restrictions on Views”</a>.
        </p><p style="color:blue;">有关视图使用限制的信息，请参见第23.9节“视图限制”。</p><p>
            The <em class="replaceable"><code>select_statement</code></em> is a
            <a class="link" href="sql-syntax.html#select" title="13.2.9&nbsp;SELECT Syntax"><code class="literal">SELECT</code></a> statement that provides the
            definition of the view. (Selecting from the view selects, in
            effect, using the <a class="link" href="sql-syntax.html#select" title="13.2.9&nbsp;SELECT Syntax"><code class="literal">SELECT</code></a>
            statement.) The <em class="replaceable"><code>select_statement</code></em> can
            select from base tables or other views.
        </p><p style="color:blue;">select_语句是提供视图定义的select语句。（从视图中选择实际上是使用select语句选择。）select_语句可以从基表或其他视图中选择。</p><p>
            The view definition is <span class="quote">“<span class="quote">frozen</span>”</span> at creation time and
            is not affected by subsequent changes to the definitions of the
            underlying tables. For example, if a view is defined as
            <code class="literal">SELECT *</code> on a table, new columns added to the
            table later do not become part of the view, and columns dropped
            from the table will result in an error when selecting from the
            view.
        </p><p style="color:blue;">视图定义在创建时被“冻结”，并且不受基础表定义的后续更改的影响。例如，如果视图在表上定义为select*，则以后添加到表中的新列不会成为视图的一部分，并且从表中删除的列将导致从视图中选择时出错。</p><p>
            The <code class="literal">ALGORITHM</code> clause affects how MySQL
            processes the view. The <code class="literal">DEFINER</code> and
            <code class="literal">SQL SECURITY</code> clauses specify the security
            context to be used when checking access privileges at view
            invocation time. The <code class="literal">WITH CHECK OPTION</code> clause
            can be given to constrain inserts or updates to rows in tables
            referenced by the view. These clauses are described later in this
            section.
        </p><p style="color:blue;">algorithm子句影响mysql处理视图的方式。definer和sql安全子句指定在视图调用时检查访问权限时要使用的安全上下文。可以使用WITHCHECK OPTION子句将插入或更新约束到视图引用的表中的行。本节后面将介绍这些条款。</p><p>
            The <a class="link" href="sql-syntax.html#create-view" title="13.1.21&nbsp;CREATE VIEW Syntax"><code class="literal">CREATE VIEW</code></a> statement requires
            the <a class="link" href="security.html#priv_create-view"><code class="literal">CREATE VIEW</code></a> privilege for the
            view, and some privilege for each column selected by the
            <a class="link" href="sql-syntax.html#select" title="13.2.9&nbsp;SELECT Syntax"><code class="literal">SELECT</code></a> statement. For columns used
            elsewhere in the <a class="link" href="sql-syntax.html#select" title="13.2.9&nbsp;SELECT Syntax"><code class="literal">SELECT</code></a> statement,
            you must have the <a class="link" href="security.html#priv_select"><code class="literal">SELECT</code></a> privilege.
            If the <code class="literal">OR REPLACE</code> clause is present, you must
            also have the <a class="link" href="security.html#priv_drop"><code class="literal">DROP</code></a> privilege for
            the view. If the <code class="literal">DEFINER</code> clause is present, the
            privileges required depend on the <em class="replaceable"><code>user</code></em>
            value, as discussed in <a class="xref" href="stored-objects.html#stored-objects-security" title="23.6&nbsp;Stored Object Access Control">Section&nbsp;23.6, “Stored Object Access Control”</a>.
        </p><p style="color:blue;">CREATEVIEW语句需要视图的CREATEVIEW特权，以及SELECT语句选择的每一列的某些特权。对于select语句中其他地方使用的列，必须具有select权限。如果存在or replace子句，则还必须具有该视图的drop权限。如果存在definer子句，则所需的权限取决于用户值，如第23.6节“存储对象访问控制”中所述。</p><p>
            When a view is referenced, privilege checking occurs as described
            later in this section.
        </p><p style="color:blue;">引用视图时，将按照本节后面的说明进行权限检查。</p><p>
            A view belongs to a database. By default, a new view is created in
            the default database. To create the view explicitly in a given
            database, use <em class="replaceable"><code>db_name.view_name</code></em> syntax
            to qualify the view name with the database name:
        </p><p style="color:blue;">视图属于数据库。默认情况下，将在默认数据库中创建新视图。若要在给定数据库中显式创建视图，请使用db_name.view_name语法将视图名称限定为数据库名称：</p><pre data-lang="sql" class="programlisting">CREATE VIEW test.v AS SELECT * FROM t;
</pre><p>
            Unqualified table or view names in the
            <a class="link" href="sql-syntax.html#select" title="13.2.9&nbsp;SELECT Syntax"><code class="literal">SELECT</code></a> statement are also
            interpreted with respect to the default database. A view can refer
            to tables or views in other databases by qualifying the table or
            view name with the appropriate database name.
        </p><p style="color:blue;">select语句中的非限定表或视图名称也会根据默认数据库进行解释。视图可以通过使用适当的数据库名称限定表或视图名称来引用其他数据库中的表或视图。</p><p>
            Within a database, base tables and views share the same namespace,
            so a base table and a view cannot have the same name.
        </p><p style="color:blue;">在数据库中，基表和视图共享相同的命名空间，因此基表和视图不能具有相同的名称。</p><p>
            Columns retrieved by the <a class="link" href="sql-syntax.html#select" title="13.2.9&nbsp;SELECT Syntax"><code class="literal">SELECT</code></a>
            statement can be simple references to table columns, or
            expressions that use functions, constant values, operators, and so
            forth.
        </p><p style="color:blue;">select语句检索的列可以是对表列的简单引用，也可以是使用函数、常量值、运算符等的表达式。</p><p>
            A view must have unique column names with no duplicates, just like
            a base table. By default, the names of the columns retrieved by
            the <a class="link" href="sql-syntax.html#select" title="13.2.9&nbsp;SELECT Syntax"><code class="literal">SELECT</code></a> statement are used for
            the view column names. To define explicit names for the view
            columns, specify the optional
            <em class="replaceable"><code>column_list</code></em> clause as a list of
            comma-separated identifiers. The number of names in
            <em class="replaceable"><code>column_list</code></em> must be the same as the
            number of columns retrieved by the
            <a class="link" href="sql-syntax.html#select" title="13.2.9&nbsp;SELECT Syntax"><code class="literal">SELECT</code></a> statement.
        </p><p style="color:blue;">视图必须具有唯一的列名，并且不能重复，就像基表一样。默认情况下，select语句检索到的列的名称将用于视图列名。要为视图列定义显式名称，请将可选的column_list子句指定为逗号分隔的标识符列表。列列表中的名称数必须与select语句检索到的列数相同。</p><p>
            A view can be created from many kinds of
            <a class="link" href="sql-syntax.html#select" title="13.2.9&nbsp;SELECT Syntax"><code class="literal">SELECT</code></a> statements. It can refer to
            base tables or other views. It can use joins,
            <a class="link" href="sql-syntax.html#union" title="13.2.9.3&nbsp;UNION Syntax"><code class="literal">UNION</code></a>, and subqueries. The
            <a class="link" href="sql-syntax.html#select" title="13.2.9&nbsp;SELECT Syntax"><code class="literal">SELECT</code></a> need not even refer to any
            tables:
        </p><p style="color:blue;">可以从多种select语句创建视图。它可以引用基表或其他视图。它可以使用联接、并集和子查询。select甚至不需要引用任何表：</p><pre data-lang="sql" class="programlisting">CREATE VIEW v_today (today) AS SELECT CURRENT_DATE;
</pre><p>
            The following example defines a view that selects two columns from
            another table as well as an expression calculated from those
            columns:
        </p><p style="color:blue;">以下示例定义了一个视图，该视图从另一个表中选择两列以及从这些列计算的表达式：</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>CREATE TABLE t (qty INT, price INT);</code></strong>
mysql&gt; <strong class="userinput"><code>INSERT INTO t VALUES(3, 50);</code></strong>
mysql&gt; <strong class="userinput"><code>CREATE VIEW v AS SELECT qty, price, qty*price AS value FROM t;</code></strong>
mysql&gt; <strong class="userinput"><code>SELECT * FROM v;</code></strong>
+------+-------+-------+
| qty  | price | value |
+------+-------+-------+
|    3 |    50 |   150 |
+------+-------+-------+
</pre><p>
            A view definition is subject to the following restrictions:
        </p><p style="color:blue;">视图定义受以下限制：</p>
            <div class="itemizedlist">
                <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                    The <a class="link" href="sql-syntax.html#select" title="13.2.9&nbsp;SELECT Syntax"><code class="literal">SELECT</code></a> statement cannot
                    refer to system variables or user-defined variables.
                </p><p style="color:blue;">select语句不能引用系统变量或用户定义的变量。</p></li><li class="listitem"><p>
                    Within a stored program, the
                    <a class="link" href="sql-syntax.html#select" title="13.2.9&nbsp;SELECT Syntax"><code class="literal">SELECT</code></a> statement cannot refer
                    to program parameters or local variables.
                </p><p style="color:blue;">在存储的程序中，select语句不能引用程序参数或局部变量。</p></li><li class="listitem"><p>
                    The <a class="link" href="sql-syntax.html#select" title="13.2.9&nbsp;SELECT Syntax"><code class="literal">SELECT</code></a> statement cannot
                    refer to prepared statement parameters.
                </p><p style="color:blue;">select语句不能引用准备好的语句参数。</p></li><li class="listitem"><p>
                    Any table or view referred to in the definition must exist.
                    If, after the view has been created, a table or view that the
                    definition refers to is dropped, use of the view results in an
                    error. To check a view definition for problems of this kind,
                    use the <a class="link" href="sql-syntax.html#check-table" title="13.7.2.2&nbsp;CHECK TABLE Syntax"><code class="literal">CHECK TABLE</code></a> statement.
                </p><p style="color:blue;">定义中引用的任何表或视图都必须存在。如果在创建视图之后，删除了定义所引用的表或视图，则使用该视图将导致错误。要检查视图定义中是否存在此类问题，请使用check table语句。</p></li><li class="listitem"><p>
                    The definition cannot refer to a <code class="literal">TEMPORARY</code>
                    table, and you cannot create a <code class="literal">TEMPORARY</code>
                    view.
                </p><p style="color:blue;">定义不能引用临时表，也不能创建临时视图。</p></li><li class="listitem"><p>
                    You cannot associate a trigger with a view.
                </p><p style="color:blue;">不能将触发器与视图关联。</p></li><li class="listitem"><p>
                    Aliases for column names in the
                    <a class="link" href="sql-syntax.html#select" title="13.2.9&nbsp;SELECT Syntax"><code class="literal">SELECT</code></a> statement are checked
                    against the maximum column length of 64 characters (not the
                    maximum alias length of 256 characters).
                </p><p style="color:blue;">针对SELECT语句中的列名的别名，针对64个字符的最大列长度（不是256个字符的最大别名长度）进行检查。</p></li></ul>
            </div>
            <p>
                <code class="literal">ORDER BY</code> is permitted in a view definition, but
                it is ignored if you select from a view using a statement that has
                its own <code class="literal">ORDER BY</code>.
            </p><p style="color:blue;">视图定义中允许使用ORDERBY，但如果使用具有自己ORDERBY的语句从视图中进行选择，则会忽略ORDERBY。</p><p>
            For other options or clauses in the definition, they are added to
            the options or clauses of the statement that references the view,
            but the effect is undefined. For example, if a view definition
            includes a <code class="literal">LIMIT</code> clause, and you select from
            the view using a statement that has its own
            <code class="literal">LIMIT</code> clause, it is undefined which limit
            applies. This same principle applies to options such as
            <code class="literal">ALL</code>, <code class="literal">DISTINCT</code>, or
            <code class="literal">SQL_SMALL_RESULT</code> that follow the
            <a class="link" href="sql-syntax.html#select" title="13.2.9&nbsp;SELECT Syntax"><code class="literal">SELECT</code></a> keyword, and to clauses such
            as <code class="literal">INTO</code>, <code class="literal">FOR UPDATE</code>,
            <code class="literal">LOCK IN SHARE MODE</code>, and
            <code class="literal">PROCEDURE</code>.
        </p><p style="color:blue;">对于定义中的其他选项或子句，它们将添加到引用视图的语句的选项或子句中，但效果未定义。例如，如果视图定义包含一个LIMIT子句，并且您使用一个具有自己的LIMIT子句的语句从视图中进行选择，则应用哪个LIMIT子句是未定义的。同样的原则也适用于select关键字后面的all、distinct或sql_small_result等选项，以及in to、for update、lock in share mode和procedure等子句。</p><p>
            The results obtained from a view may be affected if you change the
            query processing environment by changing system variables:
        </p><p style="color:blue;">如果通过更改系统变量更改查询处理环境，则从视图获取的结果可能会受到影响：</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>CREATE VIEW v (mycol) AS SELECT 'abc';</code></strong>
Query OK, 0 rows affected (0.01 sec)

mysql&gt; <strong class="userinput"><code>SET sql_mode = '';</code></strong>
Query OK, 0 rows affected (0.00 sec)

mysql&gt; <strong class="userinput"><code>SELECT "mycol" FROM v;</code></strong>
+-------+
| mycol |
+-------+
| mycol |
+-------+
1 row in set (0.01 sec)

mysql&gt; <strong class="userinput"><code>SET sql_mode = 'ANSI_QUOTES';</code></strong>
Query OK, 0 rows affected (0.00 sec)

mysql&gt; <strong class="userinput"><code>SELECT "mycol" FROM v;</code></strong>
+-------+
| mycol |
+-------+
| abc   |
+-------+
1 row in set (0.00 sec)
</pre><p>
            The <code class="literal">DEFINER</code> and <code class="literal">SQL SECURITY</code>
            clauses determine which MySQL account to use when checking access
            privileges for the view when a statement is executed that
            references the view. The valid <code class="literal">SQL SECURITY</code>
            characteristic values are <code class="literal">DEFINER</code> (the default)
            and <code class="literal">INVOKER</code>. These indicate that the required
            privileges must be held by the user who defined or invoked the
            view, respectively.
        </p><p style="color:blue;">definer和sql security子句决定在执行引用视图的语句时检查视图的访问权限时使用哪个mysql帐户。有效的sql安全特性值是definer（默认值）和invoker。这表示所需的特权必须分别由定义或调用视图的用户持有。</p><p>
            If the <code class="literal">DEFINER</code> clause is present, the
            <em class="replaceable"><code>user</code></em> value should be a MySQL account
            specified as
            <code class="literal">'<em class="replaceable"><code>user_name</code></em>'@'<em class="replaceable"><code>host_name</code></em>'</code>,
            <a class="link" href="functions.html#function_current-user"><code class="literal">CURRENT_USER</code></a>, or
            <a class="link" href="functions.html#function_current-user"><code class="literal">CURRENT_USER()</code></a>. The permitted
            <em class="replaceable"><code>user</code></em> values depend on the privileges
            you hold, as discussed in
            <a class="xref" href="stored-objects.html#stored-objects-security" title="23.6&nbsp;Stored Object Access Control">Section&nbsp;23.6, “Stored Object Access Control”</a>. Also see that section
            for additional information about view security.
        </p><p style="color:blue;">如果存在definer子句，则用户值应为mysql帐户，指定为“user_name”@“host_name”、current_user或current_user（）。允许的用户值取决于您所拥有的特权，如第23.6节“存储对象访问控制”中所述。有关视图安全性的其他信息，请参见该部分。</p><p>
            If the <code class="literal">DEFINER</code> clause is omitted, the default
            definer is the user who executes the <a class="link" href="sql-syntax.html#create-view" title="13.1.21&nbsp;CREATE VIEW Syntax"><code class="literal">CREATE
            VIEW</code></a> statement. This is the same as specifying
            <code class="literal">DEFINER = CURRENT_USER</code> explicitly.
        </p><p style="color:blue;">如果省略definer子句，则默认的definer是执行create view语句的用户。这与显式指定definer=current_user相同。</p><p>
            Within a view definition, the
            <a class="link" href="functions.html#function_current-user"><code class="literal">CURRENT_USER</code></a> function returns the
            view's <code class="literal">DEFINER</code> value by default. For views
            defined with the <code class="literal">SQL SECURITY INVOKER</code>
            characteristic, <a class="link" href="functions.html#function_current-user"><code class="literal">CURRENT_USER</code></a>
            returns the account for the view's invoker. For information about
            user auditing within views, see
            <a class="xref" href="security.html#account-activity-auditing" title="6.2.18&nbsp;SQL-Based Account Activity Auditing">Section&nbsp;6.2.18, “SQL-Based Account Activity Auditing”</a>.
        </p><p style="color:blue;">在视图定义中，默认情况下，current_user函数返回视图的definer值。对于使用SQL安全调用程序特性定义的视图，当前用户返回视图调用程序的帐户。有关视图中用户审核的信息，请参阅第6.2.18节“基于SQL的帐户活动审核”。</p><p>
            Within a stored routine that is defined with the <code class="literal">SQL
            SECURITY DEFINER</code> characteristic,
            <a class="link" href="functions.html#function_current-user"><code class="literal">CURRENT_USER</code></a> returns the routine's
            <code class="literal">DEFINER</code> value. This also affects a view defined
            within such a routine, if the view definition contains a
            <code class="literal">DEFINER</code> value of
            <a class="link" href="functions.html#function_current-user"><code class="literal">CURRENT_USER</code></a>.
        </p><p style="color:blue;">在用sql security definer特性定义的存储例程中，current_user返回例程的definer值。如果视图定义包含当前用户的定义值，则这也会影响在此类例程中定义的视图。</p><p>
            MySQL checks view privileges like this:
        </p><p style="color:blue;">mysql检查如下视图权限：</p>
            <div class="itemizedlist">
                <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                    At view definition time, the view creator must have the
                    privileges needed to use the top-level objects accessed by the
                    view. For example, if the view definition refers to table
                    columns, the creator must have some privilege for each column
                    in the select list of the definition, and the
                    <a class="link" href="security.html#priv_select"><code class="literal">SELECT</code></a> privilege for each
                    column used elsewhere in the definition. If the definition
                    refers to a stored function, only the privileges needed to
                    invoke the function can be checked. The privileges required at
                    function invocation time can be checked only as it executes:
                    For different invocations, different execution paths within
                    the function might be taken.
                </p><p style="color:blue;">在视图定义时，视图创建者必须具有使用视图访问的顶级对象所需的权限。例如，如果视图定义引用表列，则创建者必须对定义的“选择”列表中的每一列具有某些权限，并对定义中其他地方使用的每一列具有“选择”权限。如果定义引用存储函数，则只能检查调用该函数所需的权限。只能在函数调用时检查它执行时所需的特权：对于不同的调用，可能会在函数中采用不同的执行路径。</p></li><li class="listitem"><p>
                    The user who references a view must have appropriate
                    privileges to access it (<a class="link" href="security.html#priv_select"><code class="literal">SELECT</code></a>
                    to select from it, <a class="link" href="security.html#priv_insert"><code class="literal">INSERT</code></a> to
                    insert into it, and so forth.)
                </p><p style="color:blue;">引用视图的用户必须具有访问该视图的适当权限（选择以从中进行选择，插入以插入到其中，等等）。</p></li><li class="listitem"><p>
                    When a view has been referenced, privileges for objects
                    accessed by the view are checked against the privileges held
                    by the view <code class="literal">DEFINER</code> account or invoker,
                    depending on whether the <code class="literal">SQL SECURITY</code>
                    characteristic is <code class="literal">DEFINER</code> or
                    <code class="literal">INVOKER</code>, respectively.
                </p><p style="color:blue;">当一个视图被引用时，将根据视图定义者帐户或调用者所拥有的权限来检查该视图访问的对象的权限，这取决于sql安全特性分别是definer还是invoker。</p></li><li class="listitem"><p>
                    If reference to a view causes execution of a stored function,
                    privilege checking for statements executed within the function
                    depend on whether the function <code class="literal">SQL SECURITY</code>
                    characteristic is <code class="literal">DEFINER</code> or
                    <code class="literal">INVOKER</code>. If the security characteristic is
                    <code class="literal">DEFINER</code>, the function runs with the
                    privileges of the <code class="literal">DEFINER</code> account. If the
                    characteristic is <code class="literal">INVOKER</code>, the function
                    runs with the privileges determined by the view's <code class="literal">SQL
                    SECURITY</code> characteristic.
                </p><p style="color:blue;">如果对视图的引用导致存储函数的执行，则对函数内执行的语句的权限检查取决于函数sql安全特性是definer还是invoker。如果安全特性是definer，则函数以definer帐户的权限运行。如果特性是invoker，则函数以视图的sql安全特性所确定的权限运行。</p></li></ul>
            </div>
            <p>
                Example: A view might depend on a stored function, and that
                function might invoke other stored routines. For example, the
                following view invokes a stored function <code class="literal">f()</code>:
            </p><p style="color:blue;">示例：视图可能依赖于存储函数，该函数可能调用其他存储例程。例如，以下视图调用存储函数f（）：</p><pre data-lang="sql" class="programlisting">CREATE VIEW v AS SELECT * FROM t WHERE t.id = f(t.name);
</pre><p>
            Suppose that <code class="literal">f()</code> contains a statement such as
            this:
        </p><p style="color:blue;">假设f（）包含如下语句：</p><pre data-lang="sql" class="programlisting">IF name IS NULL then
  CALL p1();
ELSE
  CALL p2();
END IF;
</pre><p>
            The privileges required for executing statements within
            <code class="literal">f()</code> need to be checked when
            <code class="literal">f()</code> executes. This might mean that privileges
            are needed for <code class="literal">p1()</code> or <code class="literal">p2()</code>,
            depending on the execution path within <code class="literal">f()</code>.
            Those privileges must be checked at runtime, and the user who must
            possess the privileges is determined by the <code class="literal">SQL
            SECURITY</code> values of the view <code class="literal">v</code> and the
            function <code class="literal">f()</code>.
        </p><p style="color:blue;">执行f（）时，需要检查在f（）中执行语句所需的权限。这可能意味着p1（）或p2（）需要特权，具体取决于f（）中的执行路径。必须在运行时检查这些权限，并且必须拥有这些权限的用户由视图v和函数f（）的sql安全值决定。</p><p>
            The <code class="literal">DEFINER</code> and <code class="literal">SQL SECURITY</code>
            clauses for views are extensions to standard SQL. In standard SQL,
            views are handled using the rules for <code class="literal">SQL SECURITY
            DEFINER</code>. The standard says that the definer of the view,
            which is the same as the owner of the view's schema, gets
            applicable privileges on the view (for example,
            <a class="link" href="security.html#priv_select"><code class="literal">SELECT</code></a>) and may grant them. MySQL
            has no concept of a schema <span class="quote">“<span class="quote">owner</span>”</span>, so MySQL adds a
            clause to identify the definer. The <code class="literal">DEFINER</code>
            clause is an extension where the intent is to have what the
            standard has; that is, a permanent record of who defined the view.
            This is why the default <code class="literal">DEFINER</code> value is the
            account of the view creator.
        </p><p style="color:blue;">视图的definer和sql security子句是标准sql的扩展。在标准sql中，视图是使用sql安全定义器的规则处理的。该标准规定，视图的定义者（与视图架构的所有者相同）可以获得视图的适用权限（例如，select），并可以授予这些权限。mysql没有模式“owner”的概念，所以mysql添加了一个子句来标识定义者。definer子句是一个扩展，其目的是获得标准所具有的内容；也就是说，定义视图的人的永久记录。这就是为什么默认的definer值是视图创建者的帐户。</p><p>
            The optional <code class="literal">ALGORITHM</code> clause is a MySQL
            extension to standard SQL. It affects how MySQL processes the
            view. <code class="literal">ALGORITHM</code> takes three values:
            <code class="literal">MERGE</code>, <code class="literal">TEMPTABLE</code>, or
            <code class="literal">UNDEFINED</code>. For more information, see
            <a class="xref" href="stored-objects.html#view-algorithms" title="23.5.2&nbsp;View Processing Algorithms">Section&nbsp;23.5.2, “View Processing Algorithms”</a>, as well as
            <a class="xref" href="optimization.html#derived-table-optimization" title="8.2.2.4&nbsp;Optimizing Derived Tables and View References with Merging or Materialization">Section&nbsp;8.2.2.4, “Optimizing Derived Tables and View References with Merging or
                Materialization”</a>.
        </p><p style="color:blue;">可选的algorithm子句是标准sql的mysql扩展。它影响mysql处理视图的方式。算法接受三个值：合并、可试探或未定义。有关详细信息，请参阅第23.5.2节“视图处理算法”，以及第8.2.2.4节“使用合并或物化优化派生表和视图引用”。</p><p>
            Some views are updatable. That is, you can use them in statements
            such as <a class="link" href="sql-syntax.html#update" title="13.2.11&nbsp;UPDATE Syntax"><code class="literal">UPDATE</code></a>,
            <a class="link" href="sql-syntax.html#delete" title="13.2.2&nbsp;DELETE Syntax"><code class="literal">DELETE</code></a>, or
            <a class="link" href="sql-syntax.html#insert" title="13.2.5&nbsp;INSERT Syntax"><code class="literal">INSERT</code></a> to update the contents of
            the underlying table. For a view to be updatable, there must be a
            one-to-one relationship between the rows in the view and the rows
            in the underlying table. There are also certain other constructs
            that make a view nonupdatable.
        </p><p style="color:blue;">有些视图是可更新的。也就是说，可以在update、delete或insert等语句中使用它们来更新基础表的内容。要使视图可更新，视图中的行和基础表中的行之间必须存在一对一关系。还有一些其他构造使视图不可更新。</p><a class="indexterm" name="idm140286836969424"></a><p>
            A generated column in a view is considered updatable because it is
            possible to assign to it. However, if such a column is updated
            explicitly, the only permitted value is
            <code class="literal">DEFAULT</code>. For information about generated
            columns, see <a class="xref" href="sql-syntax.html#create-table-generated-columns" title="13.1.18.8&nbsp;CREATE TABLE and Generated Columns">Section&nbsp;13.1.18.8, “CREATE TABLE and Generated Columns”</a>.
        </p><p style="color:blue;">视图中生成的列被认为是可更新的，因为可以为其赋值。但是，如果显式更新此类列，则唯一允许的值是默认值。有关生成列的信息，请参见第13.1.18.8节“创建表和生成列”。</p><p>
            The <code class="literal">WITH CHECK OPTION</code> clause can be given for
            an updatable view to prevent inserts or updates to rows except
            those for which the <code class="literal">WHERE</code> clause in the
            <em class="replaceable"><code>select_statement</code></em> is true.
        </p><p style="color:blue;">可以为可更新视图提供WITH CHECK OPTION子句，以防止插入或更新除select_语句中的WHERE子句为真的行以外的行。</p><p>
            In a <code class="literal">WITH CHECK OPTION</code> clause for an updatable
            view, the <code class="literal">LOCAL</code> and <code class="literal">CASCADED</code>
            keywords determine the scope of check testing when the view is
            defined in terms of another view. The <code class="literal">LOCAL</code>
            keyword restricts the <code class="literal">CHECK OPTION</code> only to the
            view being defined. <code class="literal">CASCADED</code> causes the checks
            for underlying views to be evaluated as well. When neither keyword
            is given, the default is <code class="literal">CASCADED</code>.
        </p><p style="color:blue;">在可更新视图的WITHCHECK OPTION子句中，当视图是根据另一个视图定义的时，本地关键字和级联关键字确定检查测试的范围。local关键字仅将check选项限制为正在定义的视图。级联也会导致对底层视图的检查被评估。当两个关键字都没有给定时，默认值是级联的。</p><p>
            For more information about updatable views and the <code class="literal">WITH
            CHECK OPTION</code> clause, see
            <a class="xref" href="stored-objects.html#view-updatability" title="23.5.3&nbsp;Updatable and Insertable Views">Section&nbsp;23.5.3, “Updatable and Insertable Views”</a>, and
            <a class="xref" href="stored-objects.html#view-check-option" title="23.5.4&nbsp;The View WITH CHECK OPTION Clause">Section&nbsp;23.5.4, “The View WITH CHECK OPTION Clause”</a>.
        </p><p style="color:blue;">有关可更新视图和WITH CHECK OPTION子句的详细信息，请参见第23.5.3节“可更新和可插入视图”和第23.5.4节“WITH CHECK OPTION子句视图”。</p><p>
            Views created before MySQL 5.7.3 containing <code class="literal">ORDER BY
            <em class="replaceable"><code>integer</code></em></code> can result in errors
            at view evaluation time. Consider these view definitions, which
            use <code class="literal">ORDER BY</code> with an ordinal number:
        </p><p style="color:blue;">在mysql 5.7.3之前创建的视图包含按整数排序，可能会在视图求值时导致错误。请考虑这些视图定义，它们将order by与序号一起使用：</p><pre data-lang="sql" class="programlisting">CREATE VIEW v1 AS SELECT x, y, z FROM t ORDER BY 2;
CREATE VIEW v2 AS SELECT x, 1, z FROM t ORDER BY 2;
</pre><p>
            In the first case, <code class="literal">ORDER BY 2</code> refers to a named
            column <code class="literal">y</code>. In the second case, it refers to a
            constant 1. For queries that select from either view fewer than 2
            columns (the number named in the <code class="literal">ORDER BY</code>
            clause), an error occurs if the server evaluates the view using
            the MERGE algorithm. Examples:
        </p><p style="color:blue;">在第一种情况下，order by 2表示命名列y。在第二种情况下，order by 2表示常量1。对于从任一视图中选择少于2列（ORDER BY子句中命名的数字）的查询，如果服务器使用合并算法计算视图，则会发生错误。实例：</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT x FROM v1;</code></strong>
ERROR 1054 (42S22): Unknown column '2' in 'order clause'
mysql&gt; <strong class="userinput"><code>SELECT x FROM v2;</code></strong>
ERROR 1054 (42S22): Unknown column '2' in 'order clause'
</pre><p>
            As of MySQL 5.7.3, to handle view definitions like this, the
            server writes them differently into the <code class="filename">.frm</code>
            file that stores the view definition. This difference is visible
            with <a class="link" href="sql-syntax.html#show-create-view" title="13.7.5.13&nbsp;SHOW CREATE VIEW Syntax"><code class="literal">SHOW CREATE VIEW</code></a>. Previously,
            the <code class="filename">.frm</code> file contained this for the
            <code class="literal">ORDER BY 2</code> clause:
        </p><p style="color:blue;">从mysql 5.7.3开始，为了处理这样的视图定义，服务器将它们以不同的方式写入存储视图定义的.frm文件。这种差异在show create视图中是可见的。以前，.frm文件包含了order by 2子句：</p><pre data-lang="none" class="programlisting">For v1: ORDER BY 2
For v2: ORDER BY 2
</pre><p>
            As of 5.7.3, the <code class="filename">.frm</code> file contains this:
        </p><p style="color:blue;">从5.7.3开始，.frm文件包含以下内容：</p><pre data-lang="none" class="programlisting">For v1: ORDER BY `t`.`y`
For v2: ORDER BY ''
</pre><p>
            That is, for <code class="literal">v1</code>, 2 is replaced by a reference
            to the name of the column referred to. For <code class="literal">v2</code>,
            2 is replaced by a constant string expression (ordering by a
            constant has no effect, so ordering by any constant will do).
        </p><p style="color:blue;">也就是说，对于v1，2替换为对所引用列的名称的引用。对于v2，2被一个常量字符串表达式替换（由常量排序没有效果，因此由任何常量排序都可以）。</p><p>
            If you experience view-evaluation errors such as just described,
            drop and recreate the view so that the <code class="filename">.frm</code>
            file contains the updated view representation. Alternatively, for
            views like <code class="literal">v2</code> that order by a constant value,
            drop and recreate the view with no <code class="literal">ORDER BY</code>
            clause.
        </p><p style="color:blue;">如果遇到如前所述的视图求值错误，请删除并重新创建视图，以便.frm文件包含更新的视图表示形式。或者，对于v2这样的按常量值排序的视图，删除并重新创建不带ORDERBY子句的视图。</p>
        </div>
        <div class="section">
            <div class="titlepage">
                <div>
                    <div>
                        <h3 class="title"><a name="drop-database"></a>13.1.22&nbsp;DROP DATABASE Syntax</h3>

                    </div>

                </div>

            </div>
            <a class="indexterm" name="idm140286836932528"></a><a class="indexterm" name="idm140286836931456"></a><a class="indexterm" name="idm140286836930384"></a><a class="indexterm" name="idm140286836928896"></a><a class="indexterm" name="idm140286836927408"></a><a class="indexterm" name="idm140286836925920"></a><pre data-lang="sql" class="programlisting">DROP {DATABASE | SCHEMA} [IF EXISTS] <em class="replaceable"><code>db_name</code></em>
</pre><p>
            <a class="link" href="sql-syntax.html#drop-database" title="13.1.22&nbsp;DROP DATABASE Syntax"><code class="literal">DROP DATABASE</code></a> drops all tables in
            the database and deletes the database. Be
            <span class="emphasis"><em>very</em></span> careful with this statement! To use
            <a class="link" href="sql-syntax.html#drop-database" title="13.1.22&nbsp;DROP DATABASE Syntax"><code class="literal">DROP DATABASE</code></a>, you need the
            <a class="link" href="security.html#priv_drop"><code class="literal">DROP</code></a> privilege on the database.
            <a class="link" href="sql-syntax.html#drop-database" title="13.1.22&nbsp;DROP DATABASE Syntax"><code class="literal">DROP
                SCHEMA</code></a> is a synonym for <a class="link" href="sql-syntax.html#drop-database" title="13.1.22&nbsp;DROP DATABASE Syntax"><code class="literal">DROP
            DATABASE</code></a>.
        </p><p style="color:blue;">删除数据库删除数据库中的所有表并删除数据库。这句话要小心！要使用drop database，需要数据库的drop权限。drop schema是drop database的同义词。</p>
            <div class="important" style="margin-left: 0.5in; margin-right: 0.5in;">

                <div class="admon-title">
                    Important
                </div>
                <p>
                    When a database is dropped, privileges granted specifically for
                    the database are <span class="emphasis"><em>not</em></span> automatically dropped.
                    They must be dropped manually. See <a class="xref" href="sql-syntax.html#grant" title="13.7.1.4&nbsp;GRANT Syntax">Section&nbsp;13.7.1.4, “GRANT Syntax”</a>.
                </p><p style="color:blue;">删除数据库时，不会自动删除专门为该数据库授予的权限。必须手动放下。见第13.7.1.4节“授权语法”。</p>
            </div>
            <p>
                <code class="literal">IF EXISTS</code> is used to prevent an error from
                occurring if the database does not exist.
            </p><p style="color:blue;">如果存在，则用于防止数据库不存在时发生错误。</p><p>
            If the default database is dropped, the default database is unset
            (the <a class="link" href="functions.html#function_database"><code class="literal">DATABASE()</code></a> function returns
            <code class="literal">NULL</code>).
        </p><p style="color:blue;">如果删除默认数据库，则默认数据库为unset（database（）函数返回null）。</p><p>
            If you use <a class="link" href="sql-syntax.html#drop-database" title="13.1.22&nbsp;DROP DATABASE Syntax"><code class="literal">DROP DATABASE</code></a> on a
            symbolically linked database, both the link and the original
            database are deleted.
        </p><p style="color:blue;">如果在符号链接的数据库上使用drop database，则链接和原始数据库都将被删除。</p><p>
            <a class="link" href="sql-syntax.html#drop-database" title="13.1.22&nbsp;DROP DATABASE Syntax"><code class="literal">DROP DATABASE</code></a> returns the number of
            tables that were removed. This corresponds to the number of
            <code class="filename">.frm</code> files removed.
        </p><p style="color:blue;">drop database返回删除的表数。这与删除的.frm文件数相对应。</p><p>
            The <a class="link" href="sql-syntax.html#drop-database" title="13.1.22&nbsp;DROP DATABASE Syntax"><code class="literal">DROP DATABASE</code></a> statement removes
            from the given database directory those files and directories that
            MySQL itself may create during normal operation:
        </p><p style="color:blue;">drop database语句从给定的数据库目录中删除mysql本身在正常操作期间可能创建的文件和目录：</p>
            <div class="itemizedlist">
                <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                    All files with the following extensions:
                </p><p style="color:blue;">具有以下扩展名的所有文件：</p>
                    <div class="itemizedlist">
                        <ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
                            <code class="filename">.BAK</code>
                        </p><p style="color:blue;">.bak公司</p></li><li class="listitem"><p>
                            <code class="filename">.DAT</code>
                        </p><p style="color:blue;">.日期</p></li><li class="listitem"><p>
                            <code class="filename">.HSH</code>
                        </p><p style="color:blue;">.hsh号</p></li><li class="listitem"><p>
                            <code class="filename">.MRG</code>
                        </p><p style="color:blue;">.mrg公司</p></li><li class="listitem"><p>
                            <code class="filename">.MYD</code>
                        </p><p style="color:blue;">.myd年</p></li><li class="listitem"><p>
                            <code class="filename">.MYI</code>
                        </p><p style="color:blue;">.myi公司</p></li><li class="listitem"><p>
                            <code class="filename">.TRG</code>
                        </p><p style="color:blue;">.trg公司</p></li><li class="listitem"><p>
                            <code class="filename">.TRN</code>
                        </p><p style="color:blue;">.trn号</p></li><li class="listitem"><p>
                            <code class="filename">.cfg</code>
                        </p><p style="color:blue;">.cfg文件</p></li><li class="listitem"><p>
                            <code class="filename">.db</code>
                        </p><p style="color:blue;">.db数据库</p></li><li class="listitem"><p>
                            <code class="filename">.frm</code>
                        </p><p style="color:blue;">.frm公司</p></li><li class="listitem"><p>
                            <code class="filename">.ibd</code>
                        </p><p style="color:blue;">.IBD公司</p></li><li class="listitem"><p>
                            <code class="filename">.ndb</code>
                        </p><p style="color:blue;">.ndb文件</p></li><li class="listitem"><p>
                            <code class="filename">.par</code>
                        </p><p style="color:blue;">.标准件</p></li></ul>
                    </div>
                </li><li class="listitem"><p>
                    The <code class="filename">db.opt</code> file, if it exists.
                </p><p style="color:blue;">如果存在，则为.dopt文件。</p></li></ul>
            </div>
            <p>
                If other files or directories remain in the database directory
                after MySQL removes those just listed, the database directory
                cannot be removed. In this case, you must remove any remaining
                files or directories manually and issue the
                <a class="link" href="sql-syntax.html#drop-database" title="13.1.22&nbsp;DROP DATABASE Syntax"><code class="literal">DROP DATABASE</code></a> statement again.
            </p><p style="color:blue;">如果在mysql删除刚才列出的文件或目录后，其他文件或目录仍保留在数据库目录中，则无法删除数据库目录。在这种情况下，必须手动删除所有剩余的文件或目录，然后再次发出DROP数据库语句。</p><p>
            Dropping a database does not remove any
            <code class="literal">TEMPORARY</code> tables that were created in that
            database. <code class="literal">TEMPORARY</code> tables are automatically
            removed when the session that created them ends. See
            <a class="xref" href="sql-syntax.html#create-temporary-table" title="13.1.18.3&nbsp;CREATE TEMPORARY TABLE Syntax">Section&nbsp;13.1.18.3, “CREATE TEMPORARY TABLE Syntax”</a>.
        </p><p style="color:blue;">删除数据库不会删除在该数据库中创建的任何临时表。临时表在创建它们的会话结束时自动删除。参见第13.1.18.3节“创建临时表语法”。</p><a class="indexterm" name="idm140286836872384"></a><p>
            You can also drop databases with <a class="link" href="programs.html#mysqladmin" title="4.5.2&nbsp;mysqladmin — Client for Administering a MySQL Server"><span class="command"><strong>mysqladmin</strong></span></a>.
            See <a class="xref" href="programs.html#mysqladmin" title="4.5.2&nbsp;mysqladmin — Client for Administering a MySQL Server">Section&nbsp;4.5.2, “<span class="command"><strong>mysqladmin</strong></span> — Client for Administering a MySQL Server”</a>.
        </p><p style="color:blue;">您还可以使用mysqladmin删除数据库。请参阅4.5.2节，“mysqladmin-用于管理mysql服务器的客户端”。</p>
        </div>
        <div class="section">
            <div class="titlepage">
                <div>
                    <div>
                        <h3 class="title"><a name="drop-event"></a>13.1.23&nbsp;DROP EVENT Syntax</h3>

                    </div>

                </div>

            </div>
            <a class="indexterm" name="idm140286836867680"></a><a class="indexterm" name="idm140286836866608"></a><a class="indexterm" name="idm140286836865120"></a><pre data-lang="sql" class="programlisting">DROP EVENT [IF EXISTS] <em class="replaceable"><code>event_name</code></em>
</pre><p>
            This statement drops the event named
            <em class="replaceable"><code>event_name</code></em>. The event immediately
            ceases being active, and is deleted completely from the server.
        </p><p style="color:blue;">此语句将删除名为event_name的事件。事件立即停止活动，并从服务器中完全删除。</p><p>
            If the event does not exist, the error <span class="errortext">ERROR 1517
      (HY000): Unknown event
      '<em class="replaceable"><code>event_name</code></em>'</span> results. You
            can override this and cause the statement to generate a warning
            for nonexistent events instead using <code class="literal">IF EXISTS</code>.
        </p><p style="color:blue;">如果事件不存在，则错误错误1517（HY000）：未知事件“事件名称”的结果。您可以重写这一点，并使语句生成不存在事件的警告，而不是使用if存在。</p><p>
            This statement requires the <a class="link" href="security.html#priv_event"><code class="literal">EVENT</code></a>
            privilege for the schema to which the event to be dropped belongs.
        </p><p style="color:blue;">此语句要求要删除的事件所属的架构具有事件特权。</p>
        </div>
        <div class="section">
            <div class="titlepage">
                <div>
                    <div>
                        <h3 class="title"><a name="drop-function"></a>13.1.24&nbsp;DROP FUNCTION Syntax</h3>

                    </div>

                </div>

            </div>
            <p>
                The <a class="link" href="sql-syntax.html#drop-function" title="13.1.24&nbsp;DROP FUNCTION Syntax"><code class="literal">DROP FUNCTION</code></a> statement is used
                to drop stored functions and user-defined functions (UDFs):
            </p><p style="color:blue;">DROP FUNCTION语句用于删除存储函数和用户定义函数（UDF）：</p>
            <div class="itemizedlist">
                <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                    For information about dropping stored functions, see
                    <a class="xref" href="sql-syntax.html#drop-procedure" title="13.1.27&nbsp;DROP PROCEDURE and DROP FUNCTION Syntax">Section&nbsp;13.1.27, “DROP PROCEDURE and DROP FUNCTION Syntax”</a>.
                </p><p style="color:blue;">有关删除存储函数的信息，请参阅第13.1.27节“删除过程和删除函数语法”。</p></li><li class="listitem"><p>
                    For information about dropping user-defined functions, see
                    <a class="xref" href="sql-syntax.html#drop-function-udf" title="13.7.3.2&nbsp;DROP FUNCTION Syntax">Section&nbsp;13.7.3.2, “DROP FUNCTION Syntax”</a>.
                </p><p style="color:blue;">有关删除用户定义函数的信息，请参阅第13.7.3.2节“删除函数语法”。</p></li></ul>
            </div>

        </div>
        <div class="section">
            <div class="titlepage">
                <div>
                    <div>
                        <h3 class="title"><a name="drop-index"></a>13.1.25&nbsp;DROP INDEX Syntax</h3>

                    </div>

                </div>

            </div>
            <a class="indexterm" name="idm140286836845936"></a><a class="indexterm" name="idm140286836844864"></a><a class="indexterm" name="idm140286836843376"></a><pre data-lang="sql" class="programlisting">DROP INDEX <em class="replaceable"><code>index_name</code></em> ON <em class="replaceable"><code>tbl_name</code></em>
    [<em class="replaceable"><code>algorithm_option</code></em> | <em class="replaceable"><code>lock_option</code></em>] ...

<em class="replaceable"><code>algorithm_option</code></em>:
    ALGORITHM [=] {DEFAULT|INPLACE|COPY}

<em class="replaceable"><code>lock_option</code></em>:
    LOCK [=] {DEFAULT|NONE|SHARED|EXCLUSIVE}
</pre><p>
            <a class="link" href="sql-syntax.html#drop-index" title="13.1.25&nbsp;DROP INDEX Syntax"><code class="literal">DROP INDEX</code></a> drops the index named
            <em class="replaceable"><code>index_name</code></em> from the table
            <em class="replaceable"><code>tbl_name</code></em>. This statement is mapped to
            an <a class="link" href="sql-syntax.html#alter-table" title="13.1.8&nbsp;ALTER TABLE Syntax"><code class="literal">ALTER TABLE</code></a> statement to drop
            the index. See <a class="xref" href="sql-syntax.html#alter-table" title="13.1.8&nbsp;ALTER TABLE Syntax">Section&nbsp;13.1.8, “ALTER TABLE Syntax”</a>.
        </p><p style="color:blue;">DROP INDEX从表tbl_name中删除名为index_name的索引。此语句映射到alter table语句以删除索引。见第13.1.8节“更改表语法”。</p><p>
            To drop a primary key, the index name is always
            <code class="literal">PRIMARY</code>, which must be specified as a quoted
            identifier because <code class="literal">PRIMARY</code> is a reserved word:
        </p><p style="color:blue;">若要删除主键，索引名称始终为primary，必须将其指定为带引号的标识符，因为primary是保留字：</p><pre data-lang="sql" class="programlisting">DROP INDEX `PRIMARY` ON t;
</pre><p>
            Indexes on variable-width columns of
            <a class="link" href="mysql-cluster.html" title="Chapter&nbsp;21&nbsp;MySQL NDB Cluster 7.5 and NDB Cluster 7.6"><code class="literal">NDB</code></a> tables are dropped online; that
            is, without any table copying. The table is not locked against
            access from other NDB Cluster API nodes, although it is locked
            against other operations on the <span class="emphasis"><em>same</em></span> API node
            for the duration of the operation. This is done automatically by
            the server whenever it determines that it is possible to do so;
            you do not have to use any special SQL syntax or server options to
            cause it to happen.
        </p><p style="color:blue;">ndb表的可变宽度列上的索引将联机删除，即不复制任何表。该表没有被锁定，不允许从其他ndb集群api节点进行访问，尽管在操作期间它被锁定，不允许在同一api节点上执行其他操作。只要服务器确定可以这样做，它就会自动执行此操作；您不必使用任何特殊的SQL语法或服务器选项来执行此操作。</p><p>
            <code class="literal">ALGORITHM</code> and <code class="literal">LOCK</code> clauses
            may be given to influence the table copying method and level of
            concurrency for reading and writing the table while its indexes
            are being modified. They have the same meaning as for the
            <a class="link" href="sql-syntax.html#alter-table" title="13.1.8&nbsp;ALTER TABLE Syntax"><code class="literal">ALTER TABLE</code></a> statement. For more
            information, see <a class="xref" href="sql-syntax.html#alter-table" title="13.1.8&nbsp;ALTER TABLE Syntax">Section&nbsp;13.1.8, “ALTER TABLE Syntax”</a>
        </p><p style="color:blue;">在修改表的索引时，可以使用算法和锁子句来影响表的复制方法和读写并发级别。它们的含义与alter table语句相同。有关详细信息，请参见第13.1.8节“更改表语法”</p><p>
            NDB Cluster formerly supported online <code class="literal">DROP
            INDEX</code> operations using the <code class="literal">ONLINE</code> and
            <code class="literal">OFFLINE</code> keywords. These keywords are no longer
            supported in MySQL NDB Cluster 7.5 and later, and their use causes
            a syntax error. Instead, MySQL NDB Cluster 7.5 and later support
            online operations using the same
            <code class="literal">ALGORITHM=INPLACE</code> syntax used with the standard
            MySQL Server. See
            <a class="xref" href="mysql-cluster.html#mysql-cluster-online-operations" title="21.5.14&nbsp;Online Operations with ALTER TABLE in NDB Cluster">Section&nbsp;21.5.14, “Online Operations with ALTER TABLE in NDB Cluster”</a>, for more
            information.
        </p><p style="color:blue;">ndb集群以前支持使用联机和脱机关键字的联机删除索引操作。mysql ndb cluster 7.5及更高版本不再支持这些关键字，它们的使用会导致语法错误。相反，mysql ndb cluster 7.5和更高版本使用与标准mysql服务器相同的algorithm=inplace语法支持在线操作。有关更多信息，请参阅21.5.14节，“使用ndb集群中的alter table进行联机操作”。</p>
        </div>
        <div class="section">
            <div class="titlepage">
                <div>
                    <div>
                        <h3 class="title"><a name="drop-logfile-group"></a>13.1.26&nbsp;DROP LOGFILE GROUP Syntax</h3>

                    </div>

                </div>

            </div>
            <a class="indexterm" name="idm140286836815680"></a><pre data-lang="sql" class="programlisting">DROP LOGFILE GROUP <em class="replaceable"><code>logfile_group</code></em>
    ENGINE [=] <em class="replaceable"><code>engine_name</code></em>
</pre><p>
            This statement drops the log file group named
            <em class="replaceable"><code>logfile_group</code></em>. The log file group must
            already exist or an error results. (For information on creating
            log file groups, see <a class="xref" href="sql-syntax.html#create-logfile-group" title="13.1.15&nbsp;CREATE LOGFILE GROUP Syntax">Section&nbsp;13.1.15, “CREATE LOGFILE GROUP Syntax”</a>.)
        </p><p style="color:blue;">此语句将删除名为log file\u group的日志文件组。日志文件组必须已经存在或出现错误。（有关创建日志文件组的信息，请参阅13.1.15节，“创建日志文件组语法”。）</p>
            <div class="important" style="margin-left: 0.5in; margin-right: 0.5in;">

                <div class="admon-title">
                    Important
                </div>
                <p>
                    Before dropping a log file group, you must drop all tablespaces
                    that use that log file group for <code class="literal">UNDO</code>
                    logging.
                </p><p style="color:blue;">在删除日志文件组之前，必须删除使用该日志文件组进行撤消日志记录的所有表空间。</p>
            </div>
            <p>
                The required <code class="literal">ENGINE</code> clause provides the name of
                the storage engine used by the log file group to be dropped.
                Currently, the only permitted values for
                <em class="replaceable"><code>engine_name</code></em> are
                <a class="link" href="mysql-cluster.html" title="Chapter&nbsp;21&nbsp;MySQL NDB Cluster 7.5 and NDB Cluster 7.6"><code class="literal">NDB</code></a> and
                <a class="link" href="mysql-cluster.html" title="Chapter&nbsp;21&nbsp;MySQL NDB Cluster 7.5 and NDB Cluster 7.6"><code class="literal">NDBCLUSTER</code></a>.
            </p><p style="color:blue;">required engine子句提供要删除的日志文件组使用的存储引擎的名称。目前，引擎名的唯一允许值是ndb和ndbcluster。</p><p>
            <a class="link" href="sql-syntax.html#drop-logfile-group" title="13.1.26&nbsp;DROP LOGFILE GROUP Syntax"><code class="literal">DROP LOGFILE GROUP</code></a> is useful only
            with Disk Data storage for NDB Cluster. See
            <a class="xref" href="mysql-cluster.html#mysql-cluster-disk-data" title="21.5.13&nbsp;NDB Cluster Disk Data Tables">Section&nbsp;21.5.13, “NDB Cluster Disk Data Tables”</a>.
        </p><p style="color:blue;">drop logfile group仅对ndb集群的磁盘数据存储有用。见21.5.13节，“ndb群集磁盘数据表”。</p>
        </div>
        <div class="section">
            <div class="titlepage">
                <div>
                    <div>
                        <h3 class="title"><a name="drop-procedure"></a>13.1.27&nbsp;DROP PROCEDURE and DROP FUNCTION Syntax</h3>

                    </div>

                </div>

            </div>
            <a class="indexterm" name="idm140286836801200"></a><a class="indexterm" name="idm140286836800160"></a><pre data-lang="sql" class="programlisting">DROP {PROCEDURE | FUNCTION} [IF EXISTS] <em class="replaceable"><code>sp_name</code></em>
</pre><p>
            This statement is used to drop a stored procedure or function.
            That is, the specified routine is removed from the server. You
            must have the <a class="link" href="security.html#priv_alter-routine"><code class="literal">ALTER ROUTINE</code></a>
            privilege for the routine. (If the
            <code class="literal">automatic_sp_privileges</code> system variable is
            enabled, that privilege and <a class="link" href="security.html#priv_execute"><code class="literal">EXECUTE</code></a>
            are granted automatically to the routine creator when the routine
            is created and dropped from the creator when the routine is
            dropped. See <a class="xref" href="stored-objects.html#stored-routines-privileges" title="23.2.2&nbsp;Stored Routines and MySQL Privileges">Section&nbsp;23.2.2, “Stored Routines and MySQL Privileges”</a>.)
        </p><p style="color:blue;">此语句用于删除存储过程或函数。也就是说，将从服务器中删除指定的例程。您必须具有该例程的alter例程特权。（如果启用了automatic_sp_privileges系统变量，则在创建例程时将该权限和执行自动授予例程创建者，在删除例程时将其从创建者中删除。参见23.2.2节，“存储例程和mysql特权”。）</p><p>
            The <code class="literal">IF EXISTS</code> clause is a MySQL extension. It
            prevents an error from occurring if the procedure or function does
            not exist. A warning is produced that can be viewed with
            <a class="link" href="sql-syntax.html#show-warnings" title="13.7.5.40&nbsp;SHOW WARNINGS Syntax"><code class="literal">SHOW WARNINGS</code></a>.
        </p><p style="color:blue;">if exists子句是mysql扩展。如果过程或函数不存在，则防止发生错误。将生成一个警告，可以使用“显示警告”查看该警告。</p><p>
            <a class="link" href="sql-syntax.html#drop-function" title="13.1.24&nbsp;DROP FUNCTION Syntax"><code class="literal">DROP FUNCTION</code></a> is also used to drop
            user-defined functions (see <a class="xref" href="sql-syntax.html#drop-function-udf" title="13.7.3.2&nbsp;DROP FUNCTION Syntax">Section&nbsp;13.7.3.2, “DROP FUNCTION Syntax”</a>).
        </p><p style="color:blue;">drop函数还用于删除用户定义的函数（请参阅13.7.3.2节，“drop函数语法”）。</p>
        </div>
        <div class="section">
            <div class="titlepage">
                <div>
                    <div>
                        <h3 class="title"><a name="drop-server"></a>13.1.28&nbsp;DROP SERVER Syntax</h3>

                    </div>

                </div>

            </div>
            <a class="indexterm" name="idm140286836783072"></a><pre data-lang="sql" class="programlisting">DROP SERVER [ IF EXISTS ] <em class="replaceable"><code>server_name</code></em>
</pre><p>
            Drops the server definition for the server named
            <code class="literal"><em class="replaceable"><code>server_name</code></em></code>. The
            corresponding row in the <code class="literal">mysql.servers</code> table is
            deleted. This statement requires the
            <a class="link" href="security.html#priv_super"><code class="literal">SUPER</code></a> privilege.
        </p><p style="color:blue;">删除名为server_name的服务器的服务器定义。将删除mysql.servers表中的相应行。此语句需要超级特权。</p><p>
            Dropping a server for a table does not affect any
            <code class="literal">FEDERATED</code> tables that used this connection
            information when they were created. See
            <a class="xref" href="sql-syntax.html#create-server" title="13.1.17&nbsp;CREATE SERVER Syntax">Section&nbsp;13.1.17, “CREATE SERVER Syntax”</a>.
        </p><p style="color:blue;">删除表的服务器不会影响创建时使用此连接信息的任何联合表。参见第13.1.17节“创建服务器语法”。</p><p>
            <code class="literal">DROP SERVER</code> causes an implicit commit. See
            <a class="xref" href="sql-syntax.html#implicit-commit" title="13.3.3&nbsp;Statements That Cause an Implicit Commit">Section&nbsp;13.3.3, “Statements That Cause an Implicit Commit”</a>.
        </p><p style="color:blue;">drop server导致隐式提交。参见第13.3.3节，“导致隐式提交的语句”。</p><p>
            <code class="literal">DROP SERVER</code> is not written to the binary log,
            regardless of the logging format that is in use.
        </p><p style="color:blue;">不管使用何种日志格式，drop server都不会写入二进制日志。</p>
        </div>
        <div class="section">
            <div class="titlepage">
                <div>
                    <div>
                        <h3 class="title"><a name="drop-table"></a>13.1.29&nbsp;DROP TABLE Syntax</h3>

                    </div>

                </div>

            </div>
            <a class="indexterm" name="idm140286836768096"></a><a class="indexterm" name="idm140286836767024"></a><a class="indexterm" name="idm140286836765536"></a><pre data-lang="sql" class="programlisting">DROP [TEMPORARY] TABLE [IF EXISTS]
    <em class="replaceable"><code>tbl_name</code></em> [, <em class="replaceable"><code>tbl_name</code></em>] ...
    [RESTRICT | CASCADE]
</pre><p>
            <a class="link" href="sql-syntax.html#drop-table" title="13.1.29&nbsp;DROP TABLE Syntax"><code class="literal">DROP TABLE</code></a> removes one or more
            tables. You must have the <a class="link" href="security.html#priv_drop"><code class="literal">DROP</code></a>
            privilege for each table.
        </p><p style="color:blue;">删除表将删除一个或多个表。您必须拥有每个表的删除权限。</p><p>
            <span class="emphasis"><em>Be careful</em></span> with this statement! For each
            table, it removes the table definition and all table data. If the
            table is partitioned, the statement removes the table definition,
            all its partitions, all data stored in those partitions, and all
            partition definitions associated with the dropped table.
        </p><p style="color:blue;">小心这句话！对于每个表，它将删除表定义和所有表数据。如果表已分区，则语句将删除表定义、所有分区、存储在这些分区中的所有数据以及与删除的表关联的所有分区定义。</p><p>
            Dropping a table also drops any triggers for the table.
        </p><p style="color:blue;">删除表也会删除表的任何触发器。</p><p>
            <a class="link" href="sql-syntax.html#drop-table" title="13.1.29&nbsp;DROP TABLE Syntax"><code class="literal">DROP TABLE</code></a> causes an implicit
            commit, except when used with the <code class="literal">TEMPORARY</code>
            keyword. See <a class="xref" href="sql-syntax.html#implicit-commit" title="13.3.3&nbsp;Statements That Cause an Implicit Commit">Section&nbsp;13.3.3, “Statements That Cause an Implicit Commit”</a>.
        </p><p style="color:blue;">除了与临时关键字一起使用时，DROP TABLE会导致隐式提交。参见第13.3.3节，“导致隐式提交的语句”。</p>
            <div class="important" style="margin-left: 0.5in; margin-right: 0.5in;">

                <div class="admon-title">
                    Important
                </div>
                <p>
                    When a table is dropped, privileges granted specifically for the
                    table are <span class="emphasis"><em>not</em></span> automatically dropped. They
                    must be dropped manually. See <a class="xref" href="sql-syntax.html#grant" title="13.7.1.4&nbsp;GRANT Syntax">Section&nbsp;13.7.1.4, “GRANT Syntax”</a>.
                </p><p style="color:blue;">删除表时，不会自动删除专门为该表授予的权限。必须手动放下。见第13.7.1.4节“授权语法”。</p>
            </div>
            <p>
                If any tables named in the argument list do not exist,
                <a class="link" href="sql-syntax.html#drop-table" title="13.1.29&nbsp;DROP TABLE Syntax"><code class="literal">DROP TABLE</code></a> behavior depends on
                whether the <code class="literal">IF EXISTS</code> clause is given:
            </p><p style="color:blue;">如果在参数列表中列出的任何表不存在，则DROP表行为取决于是否给出IF存在子句：</p>
            <div class="itemizedlist">
                <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                    Without <code class="literal">IF EXISTS</code>, the statement drops all
                    named tables that do exist, and returns an error indicating
                    which nonexisting tables it was unable to drop.
                </p><p style="color:blue;">如果不存在，语句将删除所有确实存在的命名表，并返回一个错误，指出哪些表是无法删除的表。</p></li><li class="listitem"><p>
                    With <code class="literal">IF EXISTS</code>, no error occurs for
                    nonexisting tables. The statement drops all named tables that
                    do exist, and generates a <code class="literal">NOTE</code> diagnostic
                    for each nonexistent table. These notes can be displayed with
                    <a class="link" href="sql-syntax.html#show-warnings" title="13.7.5.40&nbsp;SHOW WARNINGS Syntax"><code class="literal">SHOW WARNINGS</code></a>. See
                    <a class="xref" href="sql-syntax.html#show-warnings" title="13.7.5.40&nbsp;SHOW WARNINGS Syntax">Section&nbsp;13.7.5.40, “SHOW WARNINGS Syntax”</a>.
                </p><p style="color:blue;">如果存在，则不存在不存在表的错误。语句删除所有确实存在的命名表，并为每个不存在的表生成注释诊断。这些注释可以显示并显示警告。见第13.7.5.40节“显示警告语法”。</p></li></ul>
            </div>
            <p>
                <code class="literal">IF EXISTS</code> can also be useful for dropping
                tables in unusual circumstances under which there is an
                <code class="filename">.frm</code> file but no table managed by the storage
                engine. (For example, if an abnormal server exit occurs after
                removal of the table from the storage engine but before
                <code class="filename">.frm</code> file removal.)
            </p><p style="color:blue;">if exists对于在存在.frm文件但没有由存储引擎管理的表的异常情况下删除表也很有用。（例如，如果在从存储引擎中删除表但在FRM文件移除之前出现异常服务器退出）。</p><p>
            The <code class="literal">TEMPORARY</code> keyword has the following
            effects:
        </p><p style="color:blue;">临时关键字具有以下效果：</p>
            <div class="itemizedlist">
                <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                    The statement drops only <code class="literal">TEMPORARY</code> tables.
                </p><p style="color:blue;">语句只删除临时表。</p></li><li class="listitem"><p>
                    The statement does not cause an implicit commit.
                </p><p style="color:blue;">语句不会导致隐式提交。</p></li><li class="listitem"><p>
                    No access rights are checked. A <code class="literal">TEMPORARY</code>
                    table is visible only with the session that created it, so no
                    check is necessary.
                </p><p style="color:blue;">未检查访问权限。临时表只在创建它的会话中可见，因此不需要检查。</p></li></ul>
            </div>
            <p>
                Including the <code class="literal">TEMPORARY</code> keyword is a good way
                to prevent accidentally dropping non-<code class="literal">TEMPORARY</code>
                tables.
            </p><p style="color:blue;">包含临时关键字是防止意外删除非临时表的好方法。</p><p>
            The <code class="literal">RESTRICT</code> and <code class="literal">CASCADE</code>
            keywords do nothing. They are permitted to make porting easier
            from other database systems.
        </p><p style="color:blue;">restrict和cascade关键字不起作用。允许它们简化从其他数据库系统的移植。</p><p>
            <a class="link" href="sql-syntax.html#drop-table" title="13.1.29&nbsp;DROP TABLE Syntax"><code class="literal">DROP TABLE</code></a> is not supported with
            all <a class="link" href="innodb-storage-engine.html#sysvar_innodb_force_recovery"><code class="literal">innodb_force_recovery</code></a>
            settings. See <a class="xref" href="innodb-storage-engine.html#forcing-innodb-recovery" title="14.21.2&nbsp;Forcing InnoDB Recovery">Section&nbsp;14.21.2, “Forcing InnoDB Recovery”</a>.
        </p><p style="color:blue;">所有innodb_force_recovery设置都不支持drop table。参见第14.21.2节“强制InnoDB恢复”。</p><a class="indexterm" name="idm140286836725408"></a>
        </div>
        <div class="section">
            <div class="titlepage">
                <div>
                    <div>
                        <h3 class="title"><a name="drop-tablespace"></a>13.1.30&nbsp;DROP TABLESPACE Syntax</h3>

                    </div>

                </div>

            </div>
            <a class="indexterm" name="idm140286836722208"></a><a class="indexterm" name="idm140286836721136"></a><pre data-lang="sql" class="programlisting">DROP TABLESPACE <em class="replaceable"><code>tablespace_name</code></em>
    [ENGINE [=] <em class="replaceable"><code>engine_name</code></em>]
</pre><p>
            This statement drops a tablespace that was previously created
            using <a class="link" href="sql-syntax.html#create-tablespace" title="13.1.19&nbsp;CREATE TABLESPACE Syntax"><code class="literal">CREATE TABLESPACE</code></a>. It is
            supported with all MySQL NDB Cluster 7.5 releases, and with
            <code class="literal">InnoDB</code> in the standard MySQL Server as well.
        </p><p style="color:blue;">此语句将删除以前使用create tablespace创建的表空间。所有mysql ndb cluster 7.5版本都支持它，标准mysql服务器中也支持innodb。</p><p>
            <code class="literal">ENGINE</code> sets the storage engine that uses the
            tablespace, where <em class="replaceable"><code>engine_name</code></em> is the
            name of the storage engine. Currently, the values
            <code class="literal">InnoDB</code> and <code class="literal">NDB</code> are
            supported. If not set, the value of
            <a class="link" href="server-administration.html#sysvar_default_storage_engine"><code class="literal">default_storage_engine</code></a> is used.
            If it is not the same as the storage engine used to create the
            tablespace, the <code class="literal">DROP TABLESPACE</code> statement
            fails.
        </p><p style="color:blue;">引擎设置使用表空间的存储引擎，其中engine_name是存储引擎的名称。目前支持innodb和ndb值。如果未设置，则使用默认存储引擎的值。如果与用于创建表空间的存储引擎不同，DROP TABLESPACE语句将失败。</p><p>
            For an <code class="literal">InnoDB</code> tablespace, all tables must be
            dropped from the tablespace prior to a <code class="literal">DROP
            TABLESPACE</code> operation. If the tablespace is not empty,
            <code class="literal">DROP TABLESPACE</code> returns an error.
        </p><p style="color:blue;">对于innodb表空间，在执行drop tablespace操作之前，必须从表空间中删除所有表。如果表空间不是空的，DROP TABLESPACE将返回一个错误。</p><p>
            As with the <code class="literal">InnoDB</code> system tablespace,
            truncating or dropping <code class="literal">InnoDB</code> tables stored in
            a general tablespace creates free space in the tablespace
            <a class="link" href="glossary.html#glos_ibd_file" title=".ibd file">.ibd data file</a>, which can
            only be used for new <code class="literal">InnoDB</code> data. Space is not
            released back to the operating system by such operations as it is
            for file-per-table tablespaces.
        </p><p style="color:blue;">与innodb系统表空间一样，截断或删除存储在通用表空间中的innodb表会在tablespace.ibd数据文件中创建可用空间，该文件只能用于新的innodb数据。这种操作不会将空间释放回操作系统，因为它是针对每个表的文件表空间的。</p><p>
            An <code class="literal">NDB</code> tablespace to be dropped must not
            contain any data files; in other words, before you can drop an
            <code class="literal">NDB</code> tablespace, you must first drop each of its
            data files using
            <a class="link" href="sql-syntax.html#alter-tablespace" title="13.1.9&nbsp;ALTER TABLESPACE Syntax"><code class="literal">ALTER TABLESPACE
                ... DROP DATAFILE</code></a>.
        </p><p style="color:blue;">要删除的ndb表空间不能包含任何数据文件；换句话说，在删除ndb表空间之前，必须首先使用alter tablespace删除其每个数据文件…删除数据文件。</p>
            <h4><a name="idm140286836698064"></a>Notes</h4>
            <div class="itemizedlist">
                <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                    Tablespaces are not deleted automatically. A tablespace must
                    be dropped explicitly using <code class="literal">DROP
                    TABLESPACE</code>. <a class="link" href="sql-syntax.html#drop-database" title="13.1.22&nbsp;DROP DATABASE Syntax"><code class="literal">DROP
                    DATABASE</code></a> has no effect in this regard, even if the
                    operation drops all tables belonging to the tablespace.
                </p><p style="color:blue;">表空间不会自动删除。必须使用drop tablespace显式删除表空间。drop database在这方面不起作用，即使该操作删除属于表空间的所有表。</p></li><li class="listitem"><p>
                    A <a class="link" href="sql-syntax.html#drop-database" title="13.1.22&nbsp;DROP DATABASE Syntax"><code class="literal">DROP DATABASE</code></a> operation can
                    drop tables that belong to a general tablespace but it cannot
                    drop the tablespace, even if the operation drops all tables
                    that belong to the tablespace. The tablespace must be dropped
                    explicitly using <code class="literal">DROP TABLESPACE
                    <em class="replaceable"><code>tablespace_name</code></em></code>.
                </p><p style="color:blue;">删除数据库操作可以删除属于常规表空间的表，但不能删除表空间，即使该操作删除了属于该表空间的所有表。必须使用drop tablespace tablespace\u name显式删除表空间。</p></li><li class="listitem"><p>
                    Similar to the system tablespace, truncating or dropping
                    tables stored in a general tablespace creates free space
                    internally in the general tablespace
                    <a class="link" href="glossary.html#glos_ibd_file" title=".ibd file">.ibd data file</a> which can
                    only be used for new <code class="literal">InnoDB</code> data. Space is
                    not released back to the operating system as it is for
                    file-per-table tablespaces.
                </p><p style="color:blue;">与系统表空间类似，截断或删除存储在通用表空间中的表会在通用表空间.ibd数据文件内部创建可用空间，该文件只能用于新的innodb数据。空间不会释放回操作系统，因为它是针对每个表的文件表空间。</p></li></ul>
            </div>
            <h4><a name="idm140286836688096"></a>InnoDB Example</h4>
            <p>
                This example demonstrates how to drop an <code class="literal">InnoDB</code>
                general tablespace. The general tablespace <code class="literal">ts1</code>
                is created with a single table. Before dropping the tablespace,
                the table must be dropped.
            </p><p style="color:blue;">这个例子演示了如何删除innodb通用表空间。一般表空间ts1是用一个表创建的。在删除表空间之前，必须先删除表。</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>CREATE TABLESPACE `ts1` ADD DATAFILE 'ts1.ibd' Engine=InnoDB;</code></strong>

mysql&gt; <strong class="userinput"><code>CREATE TABLE t1 (c1 INT PRIMARY KEY) TABLESPACE ts10 Engine=InnoDB;</code></strong>

mysql&gt; <strong class="userinput"><code>DROP TABLE t1;</code></strong>

mysql&gt; <strong class="userinput"><code>DROP TABLESPACE ts1;</code></strong>
</pre>
            <h4><a name="idm140286836681536"></a>NDB Example</h4>
            <p>
                This example shows how to drop an <code class="literal">NDB</code>
                tablespace <code class="literal">myts</code> having a data file named
                <code class="filename">mydata-1.dat</code> after first creating the
                tablespace, and assumes the existence of a log file group named
                <code class="literal">mylg</code> (see
                <a class="xref" href="sql-syntax.html#create-logfile-group" title="13.1.15&nbsp;CREATE LOGFILE GROUP Syntax">Section&nbsp;13.1.15, “CREATE LOGFILE GROUP Syntax”</a>).
            </p><p style="color:blue;">此示例演示如何在创建表空间之后，删除具有名为MyDATA1.DAT的数据文件的NDB表空间Myt，并假定存在名为MyLG的日志文件组（参见节131.15，“创建Logfile组语法”）。</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>CREATE TABLESPACE myts</code></strong>
    -&gt;     <strong class="userinput"><code>ADD DATAFILE 'mydata-1.dat'</code></strong>
    -&gt;     <strong class="userinput"><code>USE LOGFILE GROUP mylg</code></strong>
    -&gt;     <strong class="userinput"><code>ENGINE=NDB;</code></strong>
</pre><p>
            You must remove all data files from the tablespace using
            <a class="link" href="sql-syntax.html#alter-tablespace" title="13.1.9&nbsp;ALTER TABLESPACE Syntax"><code class="literal">ALTER TABLESPACE</code></a>, as shown here,
            before it can be dropped:
        </p><p style="color:blue;">必须使用alter tablespace从表空间中删除所有数据文件，如下所示，然后才能删除：</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>ALTER TABLESPACE myts</code></strong>
    -&gt;     <strong class="userinput"><code>DROP DATAFILE 'mydata-1.dat'</code></strong>
    -&gt;     <strong class="userinput"><code>ENGINE=NDB;</code></strong>

mysql&gt; <strong class="userinput"><code>DROP TABLESPACE myts;</code></strong>
</pre>
        </div>
        <div class="section">
            <div class="titlepage">
                <div>
                    <div>
                        <h3 class="title"><a name="drop-trigger"></a>13.1.31&nbsp;DROP TRIGGER Syntax</h3>

                    </div>

                </div>

            </div>
            <a class="indexterm" name="idm140286836665712"></a><a class="indexterm" name="idm140286836664640"></a><pre data-lang="sql" class="programlisting">DROP TRIGGER [IF EXISTS] [<em class="replaceable"><code>schema_name</code></em>.]<em class="replaceable"><code>trigger_name</code></em>
</pre><p>
            This statement drops a trigger. The schema (database) name is
            optional. If the schema is omitted, the trigger is dropped from
            the default schema. <a class="link" href="sql-syntax.html#drop-trigger" title="13.1.31&nbsp;DROP TRIGGER Syntax"><code class="literal">DROP TRIGGER</code></a>
            requires the <a class="link" href="security.html#priv_trigger"><code class="literal">TRIGGER</code></a> privilege for
            the table associated with the trigger.
        </p><p style="color:blue;">这句话扣下了一个扳机。架构（数据库）名称是可选的。如果省略架构，则触发器将从默认架构中删除。DROP触发器要求与触发器关联的表具有触发器特权。</p><p>
            Use <code class="literal">IF EXISTS</code> to prevent an error from
            occurring for a trigger that does not exist. A
            <code class="literal">NOTE</code> is generated for a nonexistent trigger
            when using <code class="literal">IF EXISTS</code>. See
            <a class="xref" href="sql-syntax.html#show-warnings" title="13.7.5.40&nbsp;SHOW WARNINGS Syntax">Section&nbsp;13.7.5.40, “SHOW WARNINGS Syntax”</a>.
        </p><p style="color:blue;">如果存在，以防止不存在触发器的错误发生。当使用IF时，为不存在的触发器生成注释。见第13.7.5.40节“显示警告语法”。</p><p>
            Triggers for a table are also dropped if you drop the table.
        </p><p style="color:blue;">如果删除表，则还会删除表的触发器。</p>
        </div>
        <div class="section">
            <div class="titlepage">
                <div>
                    <div>
                        <h3 class="title"><a name="drop-view"></a>13.1.32&nbsp;DROP VIEW Syntax</h3>

                    </div>

                </div>

            </div>
            <a class="indexterm" name="idm140286836650464"></a><pre data-lang="sql" class="programlisting">DROP VIEW [IF EXISTS]
    <em class="replaceable"><code>view_name</code></em> [, <em class="replaceable"><code>view_name</code></em>] ...
    [RESTRICT | CASCADE]
</pre><p>
            <a class="link" href="sql-syntax.html#drop-view" title="13.1.32&nbsp;DROP VIEW Syntax"><code class="literal">DROP VIEW</code></a> removes one or more
            views. You must have the <a class="link" href="security.html#priv_drop"><code class="literal">DROP</code></a>
            privilege for each view.
        </p><p style="color:blue;">“放置视图”将删除一个或多个视图。每个视图都必须具有删除权限。</p><p>
            If any views named in the argument list do not exist, the
            statement returns an error indicating by name which nonexisting
            views it was unable to drop, but also drops all views in the list
            that do exist.
        </p><p style="color:blue;">如果在参数列表中命名的任何视图不存在，则语句返回一个错误，该错误以名称指示其无法删除的不存在视图，但也会删除存在的列表中的所有视图。</p>
            <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">

                <div class="admon-title">
                    Note
                </div>
                <p>
                    In MySQL 8.0, <a class="link" href="sql-syntax.html#drop-view" title="13.1.32&nbsp;DROP VIEW Syntax"><code class="literal">DROP VIEW</code></a>
                    fails if any views named in the argument list do not exist. Due
                    to the change in behavior, a partially completed
                    <a class="link" href="sql-syntax.html#drop-view" title="13.1.32&nbsp;DROP VIEW Syntax"><code class="literal">DROP VIEW</code></a> operation on a MySQL
                    5.7 master fails when replicated to a MySQL
                    8.0 slave. To avoid this failure scenario, use
                    <code class="literal">IF EXISTS</code> syntax in <a class="link" href="sql-syntax.html#drop-view" title="13.1.32&nbsp;DROP VIEW Syntax"><code class="literal">DROP
                    VIEW</code></a> statements to prevent an error from occurring for
                    views that do not exist. For more information, see
                    <a class="ulink" href="https://dev.mysql.com/doc/refman/8.0/en/atomic-ddl.html" target="_top">Atomic Data Definition Statement Support</a>.
                </p><p style="color:blue;">在MySQL 8中，如果在参数列表中命名的视图不存在，则删除视图失败。由于行为的改变，当复制到mysql 8.0从机时，mysql 5.7主机上部分完成的drop view操作失败。若要避免此失败情况，请使用Delp视图语句中存在的语法来防止不存在的视图发生错误。有关详细信息，请参阅原子数据定义语句支持。</p>
            </div>
            <p>
                The <code class="literal">IF EXISTS</code> clause prevents an error from
                occurring for views that don't exist. When this clause is given, a
                <code class="literal">NOTE</code> is generated for each nonexistent view.
                See <a class="xref" href="sql-syntax.html#show-warnings" title="13.7.5.40&nbsp;SHOW WARNINGS Syntax">Section&nbsp;13.7.5.40, “SHOW WARNINGS Syntax”</a>.
            </p><p style="color:blue;">if存在子句防止不存在的视图发生错误。当给定此子句时，为每个不存在的视图生成注释。见第13.7.5.40节“显示警告语法”。</p><p>
            <code class="literal">RESTRICT</code> and <code class="literal">CASCADE</code>, if
            given, are parsed and ignored.
        </p><p style="color:blue;">restrict和cascade（如果给定）被解析并忽略。</p>
        </div>
        <div class="section">
            <div class="titlepage">
                <div>
                    <div>
                        <h3 class="title"><a name="rename-table"></a>13.1.33&nbsp;RENAME TABLE Syntax</h3>

                    </div>

                </div>

            </div>
            <a class="indexterm" name="idm140286836628672"></a><pre data-lang="sql" class="programlisting">RENAME TABLE
    <em class="replaceable"><code>tbl_name</code></em> TO <em class="replaceable"><code>new_tbl_name</code></em>
    [, <em class="replaceable"><code>tbl_name2</code></em> TO <em class="replaceable"><code>new_tbl_name2</code></em>] ...
</pre><p>
            <a class="link" href="sql-syntax.html#rename-table" title="13.1.33&nbsp;RENAME TABLE Syntax"><code class="literal">RENAME TABLE</code></a> renames one or more
            tables. You must have <a class="link" href="security.html#priv_alter"><code class="literal">ALTER</code></a> and
            <a class="link" href="security.html#priv_drop"><code class="literal">DROP</code></a> privileges for the original
            table, and <a class="link" href="security.html#priv_create"><code class="literal">CREATE</code></a> and
            <a class="link" href="security.html#priv_insert"><code class="literal">INSERT</code></a> privileges for the new
            table.
        </p><p style="color:blue;">重命名表重命名一个或多个表。您必须对原始表具有alter和drop权限，并对新表具有create和insert权限。</p><p>
            For example, to rename a table named <code class="literal">old_table</code>
            to <code class="literal">new_table</code>, use this statement:
        </p><p style="color:blue;">例如，要将名为old_table的表重命名为new_table，请使用以下语句：</p><pre data-lang="sql" class="programlisting">RENAME TABLE old_table TO new_table;
</pre><p>
            That statement is equivalent to the following
            <a class="link" href="sql-syntax.html#alter-table" title="13.1.8&nbsp;ALTER TABLE Syntax"><code class="literal">ALTER TABLE</code></a> statement:
        </p><p style="color:blue;">该语句相当于以下alter table语句：</p><pre data-lang="sql" class="programlisting">ALTER TABLE old_table RENAME new_table;
</pre><p>
            <code class="literal">RENAME TABLE</code>, unlike <a class="link" href="sql-syntax.html#alter-table" title="13.1.8&nbsp;ALTER TABLE Syntax"><code class="literal">ALTER
            TABLE</code></a>, can rename multiple tables within a single
            statement:
        </p><p style="color:blue;">rename table与alter table不同，它可以在一条语句中重命名多个表：</p><pre data-lang="sql" class="programlisting">RENAME TABLE old_table1 TO new_table1,
             old_table2 TO new_table2,
             old_table3 TO new_table3;
</pre><p>
            Renaming operations are performed left to right. Thus, to swap two
            table names, do this (assuming that a table with the intermediary
            name <code class="literal">tmp_table</code> does not already exist):
        </p><p style="color:blue;">重命名操作从左到右执行。因此，若要交换两个表名，请执行此操作（假设具有中间名TMPX表的表尚未存在）：</p><pre data-lang="sql" class="programlisting">RENAME TABLE old_table TO tmp_table,
             new_table TO old_table,
             tmp_table TO new_table;
</pre><p>
            Metadata locks on tables are acquired in name order, which in some
            cases can make a difference in operation outcome when multiple
            transactions execute concurrently. See
            <a class="xref" href="optimization.html#metadata-locking" title="8.11.4&nbsp;Metadata Locking">Section&nbsp;8.11.4, “Metadata Locking”</a>.
        </p><p style="color:blue;">表上的元数据锁是按名称顺序获取的，在某些情况下，当多个事务同时执行时，这会对操作结果产生影响。见第8.11.4节“元数据锁定”。</p><p>
            To execute <code class="literal">RENAME TABLE</code>, there must be no
            active transactions or tables locked with <code class="literal">LOCK
            TABLES</code>. With the transaction table locking conditions
            satisfied, the rename operation is done atomically; no other
            session can access any of the tables while the rename is in
            progress.
        </p><p style="color:blue;">要执行重命名表，不能有活动事务或用锁定表锁定的表。在满足事务表锁定条件的情况下，重命名操作以原子方式完成；在重命名过程中，没有其他会话可以访问任何表。</p><p>
            If any errors occur during a <code class="literal">RENAME TABLE</code>, the
            statement fails and no changes are made.
        </p><p style="color:blue;">如果在重命名表期间发生任何错误，则语句将失败，并且不会进行任何更改。</p><p>
            You can use <code class="literal">RENAME TABLE</code> to move a table from
            one database to another:
        </p><p style="color:blue;">可以使用“重命名表”将表从一个数据库移动到另一个数据库：</p><pre data-lang="sql" class="programlisting">RENAME TABLE <em class="replaceable"><code>current_db.tbl_name</code></em> TO <em class="replaceable"><code>other_db.tbl_name;</code></em>
</pre><a class="indexterm" name="idm140286836596912"></a><a class="indexterm" name="idm140286836595424"></a><p>
            Using this method to move all tables from one database to a
            different one in effect renames the database (an operation for
            which MySQL has no single statement), except that the original
            database continues to exist, albeit with no tables.
        </p><p style="color:blue;">使用此方法将所有表从一个数据库移动到另一个数据库实际上是重命名数据库（MySQL没有单个语句的操作），除了原始数据库继续存在外，尽管没有表。</p><p>
            Like <code class="literal">RENAME TABLE</code>, <code class="literal">ALTER TABLE ...
            RENAME</code> can also be used to move a table to a different
            database. Regardless of the statement used, if the rename
            operation would move the table to a database located on a
            different file system, the success of the outcome is platform
            specific and depends on the underlying operating system calls used
            to move table files.
        </p><p style="color:blue;">像重命名表，改变表…重命名还可用于将表移动到其他数据库。无论使用何种语句，如果重命名操作将表移动到位于不同文件系统上的数据库中，则结果的成功与平台相关，并取决于用于移动表文件的底层操作系统调用。</p><p>
            If a table has triggers, attempts to rename the table into a
            different database fail with a <span class="errortext">Trigger in wrong
      schema</span>
            (<a class="link" href="error-handling.html#error_er_trg_in_wrong_schema"><code class="literal">ER_TRG_IN_WRONG_SCHEMA</code></a>) error.
        </p><p style="color:blue;">如果一个表有触发器，尝试将该表重命名为另一个数据库时失败，并出现触发器处于错误架构（er_trg_in_wrong_schema）错误。</p><a class="indexterm" name="idm140286836589040"></a><p>
            To rename <code class="literal">TEMPORARY</code> tables, <code class="literal">RENAME
            TABLE</code> does not work. Use <a class="link" href="sql-syntax.html#alter-table" title="13.1.8&nbsp;ALTER TABLE Syntax"><code class="literal">ALTER
            TABLE</code></a> instead.
        </p><p style="color:blue;">要重命名临时表，重命名表不起作用。改为使用alter table。</p><p>
            <code class="literal">RENAME TABLE</code> works for views, except that views
            cannot be renamed into a different database.
        </p><p style="color:blue;">重命名表适用于视图，但不能将视图重命名为其他数据库。</p><p>
            Any privileges granted specifically for a renamed table or view
            are not migrated to the new name. They must be changed manually.
        </p><p style="color:blue;">专门为重命名的表或视图授予的任何特权都不会迁移到新名称。必须手动更改它们。</p><p>
            <code class="literal">RENAME TABLE <em class="replaceable"><code>tbl_name</code></em> TO
                <em class="replaceable"><code>new_tbl_name</code></em></code> changes
            internally generated foreign key constraint names and user-defined
            foreign key constraint names that begin with the string
            <span class="quote">“<span class="quote"><em class="replaceable"><code>tbl_name</code></em>_ibfk_</span>”</span> to
            reflect the new table name. <code class="literal">InnoDB</code> interprets
            foreign key constraint names that begin with the string
            <span class="quote">“<span class="quote"><em class="replaceable"><code>tbl_name</code></em>_ibfk_</span>”</span> as
            internally generated names.
        </p><p style="color:blue;">将表tbl_name重命名为new_tbl_name将更改内部生成的外键约束名称和以字符串“tbl_name_ibfk_”开头的用户定义的外键约束名称，以反映新表名。innodb将以字符串“tbl_name_ibfk_u”开头的外键约束名称解释为内部生成的名称。</p><p>
            Foreign key constraint names that point to the renamed table are
            automatically updated unless there is a conflict, in which case
            the statement fails with an error. A conflict occurs if the
            renamed constraint name already exists. In such cases, you must
            drop and re-create the foreign keys for them to function properly.
        </p><p style="color:blue;">指向重命名表的外键约束名称将自动更新，除非发生冲突，在这种情况下，语句将失败并出现错误。如果重命名的约束名已经存在，则会发生冲突。在这种情况下，您必须删除并重新创建外键，以便它们正常工作。</p>
        </div>
        <div class="section">
            <div class="titlepage">
                <div>
                    <div>
                        <h3 class="title"><a name="truncate-table"></a>13.1.34&nbsp;TRUNCATE TABLE Syntax</h3>

                    </div>

                </div>

            </div>
            <a class="indexterm" name="idm140286836576000"></a><pre data-lang="sql" class="programlisting">TRUNCATE [TABLE] <em class="replaceable"><code>tbl_name</code></em>
</pre><p>
            <a class="link" href="sql-syntax.html#truncate-table" title="13.1.34&nbsp;TRUNCATE TABLE Syntax"><code class="literal">TRUNCATE TABLE</code></a> empties a table
            completely. It requires the <a class="link" href="security.html#priv_drop"><code class="literal">DROP</code></a>
            privilege.
        </p><p style="color:blue;">truncate table完全清空表。它需要删除权限。</p><p>
            Logically, <a class="link" href="sql-syntax.html#truncate-table" title="13.1.34&nbsp;TRUNCATE TABLE Syntax"><code class="literal">TRUNCATE TABLE</code></a> is
            similar to a <a class="link" href="sql-syntax.html#delete" title="13.2.2&nbsp;DELETE Syntax"><code class="literal">DELETE</code></a> statement that
            deletes all rows, or a sequence of <a class="link" href="sql-syntax.html#drop-table" title="13.1.29&nbsp;DROP TABLE Syntax"><code class="literal">DROP
            TABLE</code></a> and <a class="link" href="sql-syntax.html#create-table" title="13.1.18&nbsp;CREATE TABLE Syntax"><code class="literal">CREATE TABLE</code></a>
            statements. To achieve high performance, it bypasses the DML
            method of deleting data. Thus, it cannot be rolled back, it does
            not cause <code class="literal">ON DELETE</code> triggers to fire, and it
            cannot be performed for <code class="literal">InnoDB</code> tables with
            parent-child foreign key relationships.
        </p><p style="color:blue;">在逻辑上，truncate table类似于删除所有行的delete语句，或drop table和create table语句的序列。为了获得高性能，它绕过了删除数据的dml方法。因此，它不能回滚，不会触发on delete触发器，也不能对具有父子外键关系的innodb表执行。</p><p>
            Although <a class="link" href="sql-syntax.html#truncate-table" title="13.1.34&nbsp;TRUNCATE TABLE Syntax"><code class="literal">TRUNCATE TABLE</code></a> is similar
            to <a class="link" href="sql-syntax.html#delete" title="13.2.2&nbsp;DELETE Syntax"><code class="literal">DELETE</code></a>, it is classified as a
            DDL statement rather than a DML statement. It differs from
            <a class="link" href="sql-syntax.html#delete" title="13.2.2&nbsp;DELETE Syntax"><code class="literal">DELETE</code></a> in the following ways:
        </p><p style="color:blue;">尽管truncate table类似于delete，但它被分类为ddl语句而不是dml语句。它与delete的不同之处在于：</p>
            <div class="itemizedlist">
                <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                    Truncate operations drop and re-create the table, which is
                    much faster than deleting rows one by one, particularly for
                    large tables.
                </p><p style="color:blue;">truncate操作删除并重新创建表，这比逐个删除行快得多，特别是对于大型表。</p></li><li class="listitem"><p>
                    Truncate operations cause an implicit commit, and so cannot be
                    rolled back. See <a class="xref" href="sql-syntax.html#implicit-commit" title="13.3.3&nbsp;Statements That Cause an Implicit Commit">Section&nbsp;13.3.3, “Statements That Cause an Implicit Commit”</a>.
                </p><p style="color:blue;">截断操作导致隐式提交，因此无法回滚。参见第13.3.3节，“导致隐式提交的语句”。</p></li><li class="listitem"><p>
                    Truncation operations cannot be performed if the session holds
                    an active table lock.
                </p><p style="color:blue;">如果会话持有活动表锁，则无法执行截断操作。</p></li><li class="listitem"><p>
                    <a class="link" href="sql-syntax.html#truncate-table" title="13.1.34&nbsp;TRUNCATE TABLE Syntax"><code class="literal">TRUNCATE TABLE</code></a> fails for an
                    <code class="literal">InnoDB</code> table or
                    <a class="link" href="mysql-cluster.html" title="Chapter&nbsp;21&nbsp;MySQL NDB Cluster 7.5 and NDB Cluster 7.6"><code class="literal">NDB</code></a> table if there are any
                    <code class="literal">FOREIGN KEY</code> constraints from other tables
                    that reference the table. Foreign key constraints between
                    columns of the same table are permitted.
                </p><p style="color:blue;">对于innodb表或ndb表，如果有来自引用该表的其他表的外键约束，则truncate table失败。允许在同一表的列之间使用外键约束。</p></li><li class="listitem"><p>
                    Truncation operations do not return a meaningful value for the
                    number of deleted rows. The usual result is <span class="quote">“<span class="quote">0 rows
          affected,</span>”</span> which should be interpreted as <span class="quote">“<span class="quote">no
          information.</span>”</span>
                </p><p style="color:blue;">截断操作不返回已删除行数的有意义值。通常的结果是“0行受影响”，应该解释为“无信息”。</p></li><li class="listitem"><p>
                    As long as the table format file
                    <code class="filename"><em class="replaceable"><code>tbl_name</code></em>.frm</code>
                    is valid, the table can be re-created as an empty table with
                    <a class="link" href="sql-syntax.html#truncate-table" title="13.1.34&nbsp;TRUNCATE TABLE Syntax"><code class="literal">TRUNCATE TABLE</code></a>, even if the
                    data or index files have become corrupted.
                </p><p style="color:blue;">只要表格式文件tbl_name.frm有效，就可以用truncate table将表重新创建为空表，即使数据或索引文件已损坏。</p></li><li class="listitem"><p>
                    Any <code class="literal">AUTO_INCREMENT</code> value is reset to its
                    start value. This is true even for <code class="literal">MyISAM</code>
                    and <code class="literal">InnoDB</code>, which normally do not reuse
                    sequence values.
                </p><p style="color:blue;">任何自动增量值都将重置为其起始值。即使对于myisam和innodb也是如此，它们通常不重用序列值。</p></li><li class="listitem"><p>
                    When used with partitioned tables,
                    <a class="link" href="sql-syntax.html#truncate-table" title="13.1.34&nbsp;TRUNCATE TABLE Syntax"><code class="literal">TRUNCATE TABLE</code></a> preserves the
                    partitioning; that is, the data and index files are dropped
                    and re-created, while the partition definitions
                    (<code class="filename">.par</code>) file is unaffected.
                </p><p style="color:blue;">当与分区表一起使用时，truncate table保留分区；也就是说，数据和索引文件将被删除并重新创建，而分区定义（.par）文件不受影响。</p></li><li class="listitem"><p>
                    The <a class="link" href="sql-syntax.html#truncate-table" title="13.1.34&nbsp;TRUNCATE TABLE Syntax"><code class="literal">TRUNCATE TABLE</code></a> statement
                    does not invoke <code class="literal">ON DELETE</code> triggers.
                </p><p style="color:blue;">truncate table语句不在delete触发器上调用。</p></li></ul>
            </div>
            <p>
                <a class="link" href="sql-syntax.html#truncate-table" title="13.1.34&nbsp;TRUNCATE TABLE Syntax"><code class="literal">TRUNCATE TABLE</code></a> for a table closes
                all handlers for the table that were opened with
                <a class="link" href="sql-syntax.html#handler" title="13.2.4&nbsp;HANDLER Syntax"><code class="literal">HANDLER OPEN</code></a>.
            </p><p style="color:blue;">truncate table for a table关闭在处理程序打开时打开的表的所有处理程序。</p><p>
            <a class="link" href="sql-syntax.html#truncate-table" title="13.1.34&nbsp;TRUNCATE TABLE Syntax"><code class="literal">TRUNCATE TABLE</code></a> is treated for
            purposes of binary logging and replication as
            <a class="link" href="sql-syntax.html#drop-table" title="13.1.29&nbsp;DROP TABLE Syntax"><code class="literal">DROP TABLE</code></a> followed by
            <a class="link" href="sql-syntax.html#create-table" title="13.1.18&nbsp;CREATE TABLE Syntax"><code class="literal">CREATE TABLE</code></a>—that is, as DDL
            rather than DML. This is due to the fact that, when using
            <a class="link" href="innodb-storage-engine.html" title="Chapter&nbsp;14&nbsp;The InnoDB Storage Engine"><code class="literal">InnoDB</code></a> and other transactional
            storage engines where the transaction isolation level does not
            permit statement-based logging (<a class="link" href="innodb-storage-engine.html#isolevel_read-committed"><code class="literal">READ
            COMMITTED</code></a> or <a class="link" href="innodb-storage-engine.html#isolevel_read-uncommitted"><code class="literal">READ
            UNCOMMITTED</code></a>), the statement was not logged and
            replicated when using <code class="literal">STATEMENT</code> or
            <code class="literal">MIXED</code> logging mode. (Bug #36763) However, it is
            still applied on replication slaves using
            <a class="link" href="innodb-storage-engine.html" title="Chapter&nbsp;14&nbsp;The InnoDB Storage Engine"><code class="literal">InnoDB</code></a> in the manner described
            previously.
        </p><p style="color:blue;">为了二进制日志记录和复制的目的，truncate table被视为drop table，然后是create table，即ddl，而不是dml。这是因为，当使用innodb和其他事务存储引擎时，如果事务隔离级别不允许基于语句的日志记录（read committed或read uncommitted），则在使用语句或混合日志记录模式时，不会记录和复制该语句。（bug 36763）但是，它仍然以前面描述的方式应用于使用innodb的复制从机。</p><p>
            On a system with a large <code class="literal">InnoDB</code> buffer pool and
            <a class="link" href="innodb-storage-engine.html#sysvar_innodb_adaptive_hash_index"><code class="literal">innodb_adaptive_hash_index</code></a>
            enabled, <code class="literal">TRUNCATE TABLE</code> operations may cause a
            temporary drop in system performance due to an LRU scan that
            occurs when removing an <code class="literal">InnoDB</code> table's adaptive
            hash index entries. The problem was addressed for
            <a class="link" href="sql-syntax.html#drop-table" title="13.1.29&nbsp;DROP TABLE Syntax"><code class="literal">DROP TABLE</code></a> in MySQL 5.5.23 (Bug
            #13704145, Bug #64284) but remains a known issue for
            <code class="literal">TRUNCATE TABLE</code> (Bug #68184).
        </p><p style="color:blue;">在启用了大型innodb缓冲池和innodb_adaptive_hash_index的系统上，由于删除innodb表的自适应哈希索引项时发生lru扫描，截断表操作可能会导致系统性能暂时下降。这个问题是针对mysql 5.5.23中的drop table解决的（bug 13704145，bug 64284），但是对于truncate table（bug 68184）来说仍然是一个已知的问题。</p><p>
            <a class="link" href="sql-syntax.html#truncate-table" title="13.1.34&nbsp;TRUNCATE TABLE Syntax"><code class="literal">TRUNCATE TABLE</code></a> can be used with
            Performance Schema summary tables, but the effect is to reset the
            summary columns to 0 or <code class="literal">NULL</code>, not to remove
            rows. See <a class="xref" href="performance-schema.html#performance-schema-summary-tables" title="25.12.15&nbsp;Performance Schema Summary Tables">Section&nbsp;25.12.15, “Performance Schema Summary Tables”</a>.
        </p><p style="color:blue;">truncate table可用于性能架构摘要表，但其效果是将摘要列重置为0或空，而不是删除行。见第25.12.15节“性能模式汇总表”。</p>
        </div>

    </div>

    <div class="section">

        <div class="titlepage">
            <div>
                <div>
                    <h2 class="title" style="clear: both"><a name="sql-syntax-data-manipulation"></a>13.2&nbsp;Data Manipulation Statements</h2>

                </div>

            </div>

        </div>

        <div class="toc">
            <dl class="toc"><dt><span class="section"><a href="sql-syntax.html#call">13.2.1 CALL Syntax</a></span></dt><dt><span class="section"><a href="sql-syntax.html#delete">13.2.2 DELETE Syntax</a></span></dt><dt><span class="section"><a href="sql-syntax.html#do">13.2.3 DO Syntax</a></span></dt><dt><span class="section"><a href="sql-syntax.html#handler">13.2.4 HANDLER Syntax</a></span></dt><dt><span class="section"><a href="sql-syntax.html#insert">13.2.5 INSERT Syntax</a></span></dt><dt><span class="section"><a href="sql-syntax.html#load-data">13.2.6 LOAD DATA Syntax</a></span></dt><dt><span class="section"><a href="sql-syntax.html#load-xml">13.2.7 LOAD XML Syntax</a></span></dt><dt><span class="section"><a href="sql-syntax.html#replace">13.2.8 REPLACE Syntax</a></span></dt><dt><span class="section"><a href="sql-syntax.html#select">13.2.9 SELECT Syntax</a></span></dt><dt><span class="section"><a href="sql-syntax.html#subqueries">13.2.10 Subquery Syntax</a></span></dt><dt><span class="section"><a href="sql-syntax.html#update">13.2.11 UPDATE Syntax</a></span></dt></dl>
        </div>
        <a class="indexterm" name="idm140286836508512"></a>
        <div class="section">

            <div class="titlepage">
                <div>
                    <div>
                        <h3 class="title"><a name="call"></a>13.2.1&nbsp;CALL Syntax</h3>

                    </div>

                </div>

            </div>
            <a class="indexterm" name="idm140286836506384"></a><pre data-lang="sql" class="programlisting">CALL <em class="replaceable"><code>sp_name</code></em>([<em class="replaceable"><code>parameter</code></em>[,...]])
CALL <em class="replaceable"><code>sp_name</code></em>[()]
</pre><p>
            The <a class="link" href="sql-syntax.html#call" title="13.2.1&nbsp;CALL Syntax"><code class="literal">CALL</code></a> statement invokes a stored
            procedure that was defined previously with
            <a class="link" href="sql-syntax.html#create-procedure" title="13.1.16&nbsp;CREATE PROCEDURE and CREATE FUNCTION Syntax"><code class="literal">CREATE PROCEDURE</code></a>.
        </p><p style="color:blue;">call语句调用先前用create procedure定义的存储过程。</p><p>
            Stored procedures that take no arguments can be invoked without
            parentheses. That is, <code class="literal">CALL p()</code> and
            <code class="literal">CALL p</code> are equivalent.
        </p><p style="color:blue;">不带参数的存储过程可以在没有括号的情况下调用。也就是说，call p（）和call p是等价的。</p><p>
            <a class="link" href="sql-syntax.html#call" title="13.2.1&nbsp;CALL Syntax"><code class="literal">CALL</code></a> can pass back values to its
            caller using parameters that are declared as
            <code class="literal">OUT</code> or <code class="literal">INOUT</code> parameters.
            When the procedure returns, a client program can also obtain the
            number of rows affected for the final statement executed within
            the routine: At the SQL level, call the
            <a class="link" href="functions.html#function_row-count"><code class="literal">ROW_COUNT()</code></a> function; from the C
            API, call the
            <a class="link" href="connectors-apis.html#mysql-affected-rows" title="27.8.7.1&nbsp;mysql_affected_rows()"><code class="literal">mysql_affected_rows()</code></a> function.
        </p><p style="color:blue;">调用可以使用声明为out或inout参数的参数将值传回其调用方。当过程返回时，客户端程序还可以获得在例程中执行的最后一条语句的受影响行数：在SQL级别，调用row_count（）函数；在C API中，调用mysql_infected_rows（）函数。</p><p>
            For information about the effect of unhandled conditions on
            procedure parameters, see
            <a class="xref" href="sql-syntax.html#conditions-and-parameters" title="13.6.7.8&nbsp;Condition Handling and OUT or INOUT Parameters">Section&nbsp;13.6.7.8, “Condition Handling and OUT or INOUT Parameters”</a>.
        </p><p style="color:blue;">有关未处理条件对过程参数的影响的信息，请参阅第13.6.7.8节“条件处理和输出或输入输出参数”。</p><p>
            To get back a value from a procedure using an
            <code class="literal">OUT</code> or <code class="literal">INOUT</code> parameter, pass
            the parameter by means of a user variable, and then check the
            value of the variable after the procedure returns. (If you are
            calling the procedure from within another stored procedure or
            function, you can also pass a routine parameter or local routine
            variable as an <code class="literal">IN</code> or <code class="literal">INOUT</code>
            parameter.) For an <code class="literal">INOUT</code> parameter, initialize
            its value before passing it to the procedure. The following
            procedure has an <code class="literal">OUT</code> parameter that the
            procedure sets to the current server version, and an
            <code class="literal">INOUT</code> value that the procedure increments by
            one from its current value:
        </p><p style="color:blue;">要使用out或inout参数从过程中获取值，请通过用户变量传递该参数，然后在过程返回后检查该变量的值。（如果从另一个存储过程或函数中调用过程，也可以将例程参数或局部例程变量作为in或inout参数传递。）对于inout参数，在将其传递给过程之前初始化其值。以下过程有一个out参数，该参数由过程设置为当前服务器版本，还有一个inout值，该值由过程的当前值递增一：</p><pre data-lang="sql" class="programlisting">CREATE PROCEDURE p (OUT ver_param VARCHAR(25), INOUT incr_param INT)
BEGIN
  # Set value of OUT parameter
  SELECT VERSION() INTO ver_param;
  # Increment value of INOUT parameter
  SET incr_param = incr_param + 1;
END;
</pre><p>
            Before calling the procedure, initialize the variable to be passed
            as the <code class="literal">INOUT</code> parameter. After calling the
            procedure, the values of the two variables will have been set or
            modified:
        </p><p style="color:blue;">在调用过程之前，初始化要作为inout参数传递的变量。调用过程后，将设置或修改两个变量的值：</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>SET @increment = 10;</code></strong>
mysql&gt; <strong class="userinput"><code>CALL p(@version, @increment);</code></strong>
mysql&gt; <strong class="userinput"><code>SELECT @version, @increment;</code></strong>
+------------------+------------+
| @version         | @increment |
+------------------+------------+
| 5.7.20-debug-log |         11 |
+------------------+------------+
</pre><p>
            In prepared <a class="link" href="sql-syntax.html#call" title="13.2.1&nbsp;CALL Syntax"><code class="literal">CALL</code></a> statements used
            with <a class="link" href="sql-syntax.html#prepare" title="13.5.1&nbsp;PREPARE Syntax"><code class="literal">PREPARE</code></a> and
            <a class="link" href="sql-syntax.html#execute" title="13.5.2&nbsp;EXECUTE Syntax"><code class="literal">EXECUTE</code></a>, placeholders can be used
            for <code class="literal">IN</code> parameters, <code class="literal">OUT</code>, and
            <code class="literal">INOUT</code> parameters. These types of parameters can
            be used as follows:
        </p><p style="color:blue;">在准备和执行中使用的准备调用语句中，占位符可用于In参数、OUT和IOUT参数。这些类型的参数可以使用如下：</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>SET @increment = 10;</code></strong>
mysql&gt; <strong class="userinput"><code>PREPARE s FROM 'CALL p(?, ?)';</code></strong>
mysql&gt; <strong class="userinput"><code>EXECUTE s USING @version, @increment;</code></strong>
mysql&gt; <strong class="userinput"><code>SELECT @version, @increment;</code></strong>
+------------------+------------+
| @version         | @increment |
+------------------+------------+
| 5.7.20-debug-log |         11 |
+------------------+------------+
</pre><p>
            To write C programs that use the
            <a class="link" href="sql-syntax.html#call" title="13.2.1&nbsp;CALL Syntax"><code class="literal">CALL</code></a> SQL statement to execute
            stored procedures that produce result sets, the
            <code class="literal">CLIENT_MULTI_RESULTS</code> flag must be enabled. This
            is because each <a class="link" href="sql-syntax.html#call" title="13.2.1&nbsp;CALL Syntax"><code class="literal">CALL</code></a> returns a
            result to indicate the call status, in addition to any result sets
            that might be returned by statements executed within the
            procedure. <code class="literal">CLIENT_MULTI_RESULTS</code> must also be
            enabled if <a class="link" href="sql-syntax.html#call" title="13.2.1&nbsp;CALL Syntax"><code class="literal">CALL</code></a> is used to execute
            any stored procedure that contains prepared statements. It cannot
            be determined when such a procedure is loaded whether those
            statements will produce result sets, so it is necessary to assume
            that they will.
        </p><p style="color:blue;">要编写使用call sql语句执行生成结果集的存储过程的c程序，必须启用client_multi_results标志。这是因为除了过程中执行的语句可能返回的任何结果集之外，每个调用都返回一个结果来指示调用状态。如果调用用于执行包含准备好的语句的任何存储过程，则还必须启用client_multi_results。当加载这样的过程时，无法确定这些语句是否会生成结果集，因此有必要假设它们会生成结果集。</p><p>
            <code class="literal">CLIENT_MULTI_RESULTS</code> can be enabled when you
            call <a class="link" href="connectors-apis.html#mysql-real-connect" title="27.8.7.54&nbsp;mysql_real_connect()"><code class="literal">mysql_real_connect()</code></a>, either
            explicitly by passing the <code class="literal">CLIENT_MULTI_RESULTS</code>
            flag itself, or implicitly by passing
            <code class="literal">CLIENT_MULTI_STATEMENTS</code> (which also enables
            <code class="literal">CLIENT_MULTI_RESULTS</code>).
            <code class="literal">CLIENT_MULTI_RESULTS</code> is enabled by default.
        </p><p style="color:blue;">当调用mysql_real_connect（）时，可以启用client_multi_results，可以显式地传递client_multi_results标志本身，也可以隐式地传递client_multi_语句（这也可以启用client_multi_results）。默认情况下，启用客户端多个结果。</p><p>
            To process the result of a <a class="link" href="sql-syntax.html#call" title="13.2.1&nbsp;CALL Syntax"><code class="literal">CALL</code></a>
            statement executed using
            <a class="link" href="connectors-apis.html#mysql-query" title="27.8.7.53&nbsp;mysql_query()"><code class="literal">mysql_query()</code></a> or
            <a class="link" href="connectors-apis.html#mysql-real-query" title="27.8.7.57&nbsp;mysql_real_query()"><code class="literal">mysql_real_query()</code></a>, use a loop
            that calls <a class="link" href="connectors-apis.html#mysql-next-result" title="27.8.7.47&nbsp;mysql_next_result()"><code class="literal">mysql_next_result()</code></a> to
            determine whether there are more results. For an example, see
            <a class="xref" href="connectors-apis.html#c-api-multiple-queries" title="27.8.16&nbsp;C API Multiple Statement Execution Support">Section&nbsp;27.8.16, “C API Multiple Statement Execution Support”</a>.
        </p><p style="color:blue;">要处理使用mysql_query（）或mysql_real_query（）执行的调用语句的结果，请使用调用mysql_next_result（）的循环来确定是否有更多结果。例如，请参阅第27.8.16节“C API多语句执行支持”。</p><p>
            C programs can use the prepared-statement interface to execute
            <a class="link" href="sql-syntax.html#call" title="13.2.1&nbsp;CALL Syntax"><code class="literal">CALL</code></a> statements and access
            <code class="literal">OUT</code> and <code class="literal">INOUT</code> parameters.
            This is done by processing the result of a
            <a class="link" href="sql-syntax.html#call" title="13.2.1&nbsp;CALL Syntax"><code class="literal">CALL</code></a> statement using a loop that
            calls <a class="link" href="connectors-apis.html#mysql-stmt-next-result" title="27.8.11.17&nbsp;mysql_stmt_next_result()"><code class="literal">mysql_stmt_next_result()</code></a> to
            determine whether there are more results. For an example, see
            <a class="xref" href="connectors-apis.html#c-api-prepared-call-statements" title="27.8.18&nbsp;C API Prepared CALL Statement Support">Section&nbsp;27.8.18, “C API Prepared CALL Statement Support”</a>. Languages that
            provide a MySQL interface can use prepared
            <a class="link" href="sql-syntax.html#call" title="13.2.1&nbsp;CALL Syntax"><code class="literal">CALL</code></a> statements to directly
            retrieve <code class="literal">OUT</code> and <code class="literal">INOUT</code>
            procedure parameters.
        </p><p style="color:blue;">c程序可以使用准备好的语句接口执行call语句并访问out和inout参数。这是通过使用调用mysql_stmt_next_result（）的循环来处理call语句的结果，以确定是否有更多的结果来完成的。例如，请参见第27.8.18节“C API准备的调用语句支持”。提供mysql接口的语言可以使用准备好的call语句直接检索out和inout过程参数。</p><p>
            Metadata changes to objects referred to by stored programs are
            detected and cause automatic reparsing of the affected statements
            when the program is next executed. For more information, see
            <a class="xref" href="optimization.html#statement-caching" title="8.10.4&nbsp;Caching of Prepared Statements and Stored Programs">Section&nbsp;8.10.4, “Caching of Prepared Statements and Stored Programs”</a>.
        </p><p style="color:blue;">检测到对存储程序引用的对象的元数据更改，并在下次执行程序时自动重新分析受影响的语句。有关更多信息，请参阅8.10.4节，“准备好的语句和存储程序的缓存”。</p>
        </div>
        <div class="section">
            <div class="titlepage">
                <div>
                    <div>
                        <h3 class="title"><a name="delete"></a>13.2.2&nbsp;DELETE Syntax</h3>

                    </div>

                </div>

            </div>
            <a class="indexterm" name="idm140286836436048"></a><a class="indexterm" name="idm140286836434976"></a><p>
            <a class="link" href="sql-syntax.html#delete" title="13.2.2&nbsp;DELETE Syntax"><code class="literal">DELETE</code></a> is a DML statement that
            removes rows from a table.
        </p><p style="color:blue;">delete是从表中删除行的dml语句。</p>
            <h4><a name="idm140286836429776"></a>Single-Table Syntax</h4>
            <pre data-lang="sql" class="programlisting">DELETE [LOW_PRIORITY] [QUICK] [IGNORE] FROM <em class="replaceable"><code>tbl_name</code></em>
    [PARTITION (<em class="replaceable"><code>partition_name</code></em> [, <em class="replaceable"><code>partition_name</code></em>] ...)]
    [WHERE <em class="replaceable"><code>where_condition</code></em>]
    [ORDER BY ...]
    [LIMIT <em class="replaceable"><code>row_count</code></em>]
</pre><p>
            The <code class="literal">DELETE</code> statement deletes rows from
            <em class="replaceable"><code>tbl_name</code></em> and returns the number of
            deleted rows. To check the number of deleted rows, call the
            <a class="link" href="functions.html#function_row-count"><code class="literal">ROW_COUNT()</code></a> function described in
            <a class="xref" href="functions.html#information-functions" title="12.15&nbsp;Information Functions">Section&nbsp;12.15, “Information Functions”</a>.
        </p><p style="color:blue;">delete语句从tbl_name中删除行并返回已删除的行数。要检查删除的行数，请调用第12.15节“信息函数”中描述的row_count（）函数。</p>
            <h4><a name="idm140286836422304"></a>Main Clauses</h4>
            <p>
                The conditions in the optional <code class="literal">WHERE</code> clause
                identify which rows to delete. With no <code class="literal">WHERE</code>
                clause, all rows are deleted.
            </p><p style="color:blue;">可选where子句中的条件标识要删除的行。如果没有where子句，则删除所有行。</p><p>
            <em class="replaceable"><code>where_condition</code></em> is an expression that
            evaluates to true for each row to be deleted. It is specified as
            described in <a class="xref" href="sql-syntax.html#select" title="13.2.9&nbsp;SELECT Syntax">Section&nbsp;13.2.9, “SELECT Syntax”</a>.
        </p><p style="color:blue;">其中，条件是对要删除的每一行求值为true的表达式。如13.2.9节“选择语法”所述。</p><p>
            If the <code class="literal">ORDER BY</code> clause is specified, the rows
            are deleted in the order that is specified. The
            <code class="literal">LIMIT</code> clause places a limit on the number of
            rows that can be deleted. These clauses apply to single-table
            deletes, but not multi-table deletes.
        </p><p style="color:blue;">如果指定了ORDERBY子句，则按指定的顺序删除行。LIMIT子句限制可以删除的行数。这些子句适用于单表删除，但不适用于多表删除。</p>
            <h4><a name="idm140286836416000"></a>Multiple-Table Syntax</h4>
            <pre data-lang="sql" class="programlisting">DELETE [LOW_PRIORITY] [QUICK] [IGNORE]
    <em class="replaceable"><code>tbl_name</code></em>[.*] [, <em class="replaceable"><code>tbl_name</code></em>[.*]] ...
    FROM <em class="replaceable"><code>table_references</code></em>
    [WHERE <em class="replaceable"><code>where_condition</code></em>]

DELETE [LOW_PRIORITY] [QUICK] [IGNORE]
    FROM <em class="replaceable"><code>tbl_name</code></em>[.*] [, <em class="replaceable"><code>tbl_name</code></em>[.*]] ...
    USING <em class="replaceable"><code>table_references</code></em>
    [WHERE <em class="replaceable"><code>where_condition</code></em>]
</pre>
            <h4><a name="idm140286836409712"></a>Privileges</h4>
            <p>
                You need the <a class="link" href="security.html#priv_delete"><code class="literal">DELETE</code></a> privilege on a
                table to delete rows from it. You need only the
                <a class="link" href="security.html#priv_select"><code class="literal">SELECT</code></a> privilege for any columns
                that are only read, such as those named in the
                <code class="literal">WHERE</code> clause.
            </p><p style="color:blue;">您需要表的“删除”权限才能从中删除行。对于任何只读取的列，例如在where子句中命名的列，您只需要select特权。</p>
            <h4><a name="idm140286836405296"></a>Performance</h4>
            <p>
                When you do not need to know the number of deleted rows, the
                <a class="link" href="sql-syntax.html#truncate-table" title="13.1.34&nbsp;TRUNCATE TABLE Syntax"><code class="literal">TRUNCATE TABLE</code></a> statement is a
                faster way to empty a table than a
                <a class="link" href="sql-syntax.html#delete" title="13.2.2&nbsp;DELETE Syntax"><code class="literal">DELETE</code></a> statement with no
                <code class="literal">WHERE</code> clause. Unlike
                <a class="link" href="sql-syntax.html#delete" title="13.2.2&nbsp;DELETE Syntax"><code class="literal">DELETE</code></a>,
                <a class="link" href="sql-syntax.html#truncate-table" title="13.1.34&nbsp;TRUNCATE TABLE Syntax"><code class="literal">TRUNCATE TABLE</code></a> cannot be used
                within a transaction or if you have a lock on the table. See
                <a class="xref" href="sql-syntax.html#truncate-table" title="13.1.34&nbsp;TRUNCATE TABLE Syntax">Section&nbsp;13.1.34, “TRUNCATE TABLE Syntax”</a> and
                <a class="xref" href="sql-syntax.html#lock-tables" title="13.3.5&nbsp;LOCK TABLES and UNLOCK TABLES Syntax">Section&nbsp;13.3.5, “LOCK TABLES and UNLOCK TABLES Syntax”</a>.
            </p><p style="color:blue;">当您不需要知道删除行的数量时，truncate table语句比没有where子句的delete语句更快地清空表。与delete不同，truncate table不能在事务中使用，也不能在表上有锁的情况下使用。参见第13.1.34节“截断表语法”和第13.3.5节“锁定表和解锁表语法”。</p><p>
            The speed of delete operations may also be affected by factors
            discussed in <a class="xref" href="optimization.html#delete-optimization" title="8.2.4.3&nbsp;Optimizing DELETE Statements">Section&nbsp;8.2.4.3, “Optimizing DELETE Statements”</a>.
        </p><p style="color:blue;">删除操作的速度也可能受到第8.2.4.3节“优化删除语句”中讨论的因素的影响。</p><p>
            To ensure that a given <a class="link" href="sql-syntax.html#delete" title="13.2.2&nbsp;DELETE Syntax"><code class="literal">DELETE</code></a>
            statement does not take too much time, the MySQL-specific
            <code class="literal">LIMIT <em class="replaceable"><code>row_count</code></em></code>
            clause for <a class="link" href="sql-syntax.html#delete" title="13.2.2&nbsp;DELETE Syntax"><code class="literal">DELETE</code></a> specifies the
            maximum number of rows to be deleted. If the number of rows to
            delete is larger than the limit, repeat the
            <code class="literal">DELETE</code> statement until the number of affected
            rows is less than the <code class="literal">LIMIT</code> value.
        </p><p style="color:blue;">为了确保给定的DELATE语句不占用太多时间，MySQL特定的限制ROWIONCOUNT子句用于删除指定要删除的最大行数。如果要删除的行数大于限制，请重复DELETE语句，直到受影响的行数小于限制值。</p>
            <h4><a name="idm140286836390128"></a>Subqueries</h4>
            <p>
                You cannot delete from a table and select from the same table in a
                subquery.
            </p><p style="color:blue;">不能从表中删除并从子查询中的同一表中进行选择。</p>
            <h4><a name="idm140286836388944"></a>Partitioned Table Support</h4>
            <p>
                <code class="literal">DELETE</code> supports explicit partition selection
                using the <code class="literal">PARTITION</code> option, which takes a list
                of the comma-separated names of one or more partitions or
                subpartitions (or both) from which to select rows to be dropped.
                Partitions not included in the list are ignored. Given a
                partitioned table <code class="literal">t</code> with a partition named
                <code class="literal">p0</code>, executing the statement <code class="literal">DELETE
                FROM t PARTITION (p0)</code> has the same effect on the table
                as executing <a class="link" href="sql-syntax.html#alter-table" title="13.1.8&nbsp;ALTER TABLE Syntax"><code class="literal">ALTER
                TABLE t TRUNCATE PARTITION (p0)</code></a>; in both cases, all rows
                in partition <code class="literal">p0</code> are dropped.
            </p><p style="color:blue;">DELETE使用分区选项支持显式分区选择，该分区选择一个或多个分区或子分区（或两者）的逗号分隔的列表，从中选择要丢弃的行。列表中未包含的分区将被忽略。给定一个分区表T和一个名为P0的分区，从T分区执行语句删除（P0）与执行ALTE表T截断分区（P0）的表具有相同的效果；在这两种情况下，分区P0中的所有行都被删除。</p><p>
            <code class="literal">PARTITION</code> can be used along with a
            <code class="literal">WHERE</code> condition, in which case the condition is
            tested only on rows in the listed partitions. For example,
            <code class="literal">DELETE FROM t PARTITION (p0) WHERE c &lt; 5</code>
            deletes rows only from partition <code class="literal">p0</code> for which
            the condition <code class="literal">c &lt; 5</code> is true; rows in any
            other partitions are not checked and thus not affected by the
            <code class="literal">DELETE</code>.
        </p><p style="color:blue;">分区可以与WHERE条件一起使用，在这种情况下，只对列出分区中的行进行条件测试。例如，从T分区中删除（P0），其中C＜5只从条件Pc0为5的分区P0中删除行；在任何其他分区中的行不被检查，因此不受删除的影响。</p><p>
            The <code class="literal">PARTITION</code> option can also be used in
            multiple-table <code class="literal">DELETE</code> statements. You can use
            up to one such option per table named in the
            <code class="literal">FROM</code> option.
        </p><p style="color:blue;">分区选项也可以用于多个表删除语句。对于在from选项中命名的每个表，最多可以使用一个这样的选项。</p><p>
            For more information and examples, see
            <a class="xref" href="partitioning.html#partitioning-selection" title="22.5&nbsp;Partition Selection">Section&nbsp;22.5, “Partition Selection”</a>.
        </p><p style="color:blue;">有关更多信息和示例，请参见第22.5节“分区选择”。</p>
            <h4><a name="idm140286836372496"></a>Auto-Increment Columns</h4>
            <p>
                If you delete the row containing the maximum value for an
                <code class="literal">AUTO_INCREMENT</code> column, the value is not reused
                for a <code class="literal">MyISAM</code> or <code class="literal">InnoDB</code>
                table. If you delete all rows in the table with <code class="literal">DELETE
                FROM <em class="replaceable"><code>tbl_name</code></em></code> (without a
                <code class="literal">WHERE</code> clause) in
                <a class="link" href="server-administration.html#sysvar_autocommit"><code class="literal">autocommit</code></a> mode, the sequence
                starts over for all storage engines except
                <code class="literal">InnoDB</code> and <code class="literal">MyISAM</code>. There are
                some exceptions to this behavior for <code class="literal">InnoDB</code>
                tables, as discussed in
                <a class="xref" href="innodb-storage-engine.html#innodb-auto-increment-handling" title="14.6.1.4&nbsp;AUTO_INCREMENT Handling in InnoDB">Section&nbsp;14.6.1.4, “AUTO_INCREMENT Handling in InnoDB”</a>.
            </p><p style="color:blue;">如果删除包含一个子列的最大值的行，则该值不会重用为一个或多个表。如果在autocommit模式下使用delete from tbl_name（不带where子句）删除表中的所有行，则除innodb和myisam之外的所有存储引擎的序列都将重新开始。innodb表的这种行为有一些例外，如第14.6.1.4节“innodb中的自动增量处理”所述。</p><p>
            For <code class="literal">MyISAM</code> tables, you can specify an
            <code class="literal">AUTO_INCREMENT</code> secondary column in a
            multiple-column key. In this case, reuse of values deleted from
            the top of the sequence occurs even for <code class="literal">MyISAM</code>
            tables. See <a class="xref" href="tutorial.html#example-auto-increment" title="3.6.9&nbsp;Using AUTO_INCREMENT">Section&nbsp;3.6.9, “Using AUTO_INCREMENT”</a>.
        </p><p style="color:blue;">对于myisam表，可以在多列键中指定自动递增辅助列。在这种情况下，即使对于myisam表，也会重复使用从序列顶部删除的值。见第3.6.9节“使用自动增量”。</p>
            <h4><a name="idm140286836359792"></a>Modifiers</h4>
            <p>
                The <a class="link" href="sql-syntax.html#delete" title="13.2.2&nbsp;DELETE Syntax"><code class="literal">DELETE</code></a> statement supports the
                following modifiers:
            </p><p style="color:blue;">delete语句支持以下修饰符：</p>
            <div class="itemizedlist">
                <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                    If you specify the <code class="literal">LOW_PRIORITY</code> modifier,
                    the server delays execution of the
                    <a class="link" href="sql-syntax.html#delete" title="13.2.2&nbsp;DELETE Syntax"><code class="literal">DELETE</code></a> until no other clients
                    are reading from the table. This affects only storage engines
                    that use only table-level locking (such as
                    <code class="literal">MyISAM</code>, <code class="literal">MEMORY</code>, and
                    <code class="literal">MERGE</code>).
                </p><p style="color:blue;">如果指定low_priority修饰符，服务器将延迟删除的执行，直到没有其他客户端从表中读取数据。这只影响只使用表级锁定的存储引擎（例如myisam、内存和合并）。</p><a class="indexterm" name="idm140286836352208"></a></li><li class="listitem"><p>
                    For <code class="literal">MyISAM</code> tables, if you use the
                    <code class="literal">QUICK</code> modifier, the storage engine does not
                    merge index leaves during delete, which may speed up some
                    kinds of delete operations.
                </p><p style="color:blue;">对于myisam表，如果使用快速修饰符，则存储引擎不会在删除期间合并索引叶，这可能会加快某些类型的删除操作。</p><a class="indexterm" name="idm140286836348320"></a></li><li class="listitem"><p>
                    The <code class="literal">IGNORE</code> modifier causes MySQL to ignore
                    errors during the process of deleting rows. (Errors
                    encountered during the parsing stage are processed in the
                    usual manner.) Errors that are ignored due to the use of
                    <code class="literal">IGNORE</code> are returned as warnings. For more
                    information, see <a class="xref" href="server-administration.html#ignore-strict-comparison" title="Comparison of the IGNORE Keyword and Strict SQL Mode">Comparison of the IGNORE Keyword and Strict SQL Mode</a>.
                </p><p style="color:blue;">ignore修饰符使mysql在删除行的过程中忽略错误。（在解析阶段遇到的错误以通常的方式处理。）由于使用ignore而忽略的错误将作为警告返回。有关详细信息，请参阅ignore关键字和strict sql模式的比较。</p><a class="indexterm" name="idm140286836343568"></a></li></ul>
            </div>
            <h4><a name="idm140286836341824"></a>Order of Deletion</h4>
            <p>
                If the <a class="link" href="sql-syntax.html#delete" title="13.2.2&nbsp;DELETE Syntax"><code class="literal">DELETE</code></a> statement includes an
                <code class="literal">ORDER BY</code> clause, rows are deleted in the order
                specified by the clause. This is useful primarily in conjunction
                with <code class="literal">LIMIT</code>. For example, the following
                statement finds rows matching the <code class="literal">WHERE</code> clause,
                sorts them by <code class="literal">timestamp_column</code>, and deletes the
                first (oldest) one:
            </p><p style="color:blue;">如果DELETE语句包含ORDERBY子句，则按该子句指定的顺序删除行。这主要与limit结合使用。例如，以下语句查找与where子句匹配的行，按timestamp_列对其排序，并删除第一个（最旧的）行：</p><pre data-lang="sql" class="programlisting">DELETE FROM somelog WHERE user = 'jcole'
ORDER BY timestamp_column LIMIT 1;
</pre><p>
            <code class="literal">ORDER BY</code> also helps to delete rows in an order
            required to avoid referential integrity violations.
        </p><p style="color:blue;">order by还有助于按避免引用完整性冲突所需的顺序删除行。</p>
            <h4><a name="idm140286836334256"></a>InnoDB Tables</h4>
            <p>
                If you are deleting many rows from a large table, you may exceed
                the lock table size for an <code class="literal">InnoDB</code> table. To
                avoid this problem, or simply to minimize the time that the table
                remains locked, the following strategy (which does not use
                <a class="link" href="sql-syntax.html#delete" title="13.2.2&nbsp;DELETE Syntax"><code class="literal">DELETE</code></a> at all) might be helpful:
            </p><p style="color:blue;">如果要从一个大表中删除许多行，可能会超过innodb表的锁表大小。为了避免这个问题，或者仅仅为了最小化表保持锁定的时间，下面的策略（根本不使用delete）可能会有帮助：</p>
            <div class="orderedlist">
                <ol class="orderedlist" type="1"><li class="listitem"><p>
                    Select the rows <span class="emphasis"><em>not</em></span> to be deleted into an
                    empty table that has the same structure as the original table:
                </p><p style="color:blue;">选择不删除到与原始表具有相同结构的空表中的行：</p><pre data-lang="sql" class="programlisting">INSERT INTO t_copy SELECT * FROM t WHERE ... ;
</pre></li><li class="listitem"><p>
                    Use <a class="link" href="sql-syntax.html#rename-table" title="13.1.33&nbsp;RENAME TABLE Syntax"><code class="literal">RENAME TABLE</code></a> to atomically
                    move the original table out of the way and rename the copy to
                    the original name:
                </p><p style="color:blue;">使用rename table以原子方式移动原始表，并将副本重命名为原始名称：</p><pre data-lang="sql" class="programlisting">RENAME TABLE t TO t_old, t_copy TO t;
</pre></li><li class="listitem"><p>
                    Drop the original table:
                </p><p style="color:blue;">删除原始表：</p><pre data-lang="sql" class="programlisting">DROP TABLE t_old;
</pre></li></ol>
            </div>
            <p>
                No other sessions can access the tables involved while
                <a class="link" href="sql-syntax.html#rename-table" title="13.1.33&nbsp;RENAME TABLE Syntax"><code class="literal">RENAME TABLE</code></a> executes, so the
                rename operation is not subject to concurrency problems. See
                <a class="xref" href="sql-syntax.html#rename-table" title="13.1.33&nbsp;RENAME TABLE Syntax">Section&nbsp;13.1.33, “RENAME TABLE Syntax”</a>.
            </p><p style="color:blue;">在执行rename table时，没有其他会话可以访问所涉及的表，因此rename操作不受并发问题的影响。见第13.1.33节，“重命名表语法”。</p>
            <h4><a name="idm140286836320384"></a>MyISAM Tables</h4>
            <p>
                In <code class="literal">MyISAM</code> tables, deleted rows are maintained
                in a linked list and subsequent
                <a class="link" href="sql-syntax.html#insert" title="13.2.5&nbsp;INSERT Syntax"><code class="literal">INSERT</code></a> operations reuse old row
                positions. To reclaim unused space and reduce file sizes, use the
                <a class="link" href="sql-syntax.html#optimize-table" title="13.7.2.4&nbsp;OPTIMIZE TABLE Syntax"><code class="literal">OPTIMIZE TABLE</code></a> statement or the
                <a class="link" href="programs.html#myisamchk" title="4.6.3&nbsp;myisamchk — MyISAM Table-Maintenance Utility"><span class="command"><strong>myisamchk</strong></span></a> utility to reorganize tables.
                <a class="link" href="sql-syntax.html#optimize-table" title="13.7.2.4&nbsp;OPTIMIZE TABLE Syntax"><code class="literal">OPTIMIZE TABLE</code></a> is easier to use,
                but <a class="link" href="programs.html#myisamchk" title="4.6.3&nbsp;myisamchk — MyISAM Table-Maintenance Utility"><span class="command"><strong>myisamchk</strong></span></a> is faster. See
                <a class="xref" href="sql-syntax.html#optimize-table" title="13.7.2.4&nbsp;OPTIMIZE TABLE Syntax">Section&nbsp;13.7.2.4, “OPTIMIZE TABLE Syntax”</a>, and <a class="xref" href="programs.html#myisamchk" title="4.6.3&nbsp;myisamchk — MyISAM Table-Maintenance Utility">Section&nbsp;4.6.3, “<span class="command"><strong>myisamchk</strong></span> — MyISAM Table-Maintenance Utility”</a>.
            </p><p style="color:blue;">在myisam表中，被删除的行被维护在一个链表中，随后的插入操作重用旧的行位置。要回收未使用的空间并减小文件大小，请使用optimize table语句或myisamchk实用程序重新组织表。优化表更容易使用，但myisamchk更快。参见第13.7.2.4节“优化表语法”和第4.6.3节“myisamchk-myisam表维护实用程序”。</p><p>
            The <code class="literal">QUICK</code> modifier affects whether index leaves
            are merged for delete operations. <code class="literal">DELETE QUICK</code>
            is most useful for applications where index values for deleted
            rows are replaced by similar index values from rows inserted
            later. In this case, the holes left by deleted values are reused.
        </p><p style="color:blue;">快速修改器影响是否合并索引叶以执行删除操作。对于那些已删除行的索引值被稍后插入的行中的类似索引值替换的应用程序，delete quick非常有用。在这种情况下，删除的值留下的孔将被重用。</p><p>
            <code class="literal">DELETE QUICK</code> is not useful when deleted values
            lead to underfilled index blocks spanning a range of index values
            for which new inserts occur again. In this case, use of
            <code class="literal">QUICK</code> can lead to wasted space in the index
            that remains unreclaimed. Here is an example of such a scenario:
        </p><p style="color:blue;">当删除的值导致索引块的填充不足，而该索引块的索引值范围又出现新的插入时，“快速删除”将不起作用。在这种情况下，使用quick可能会导致索引中浪费空间，而这些空间仍然没有被声明。下面是这样一个场景的示例：</p>
            <div class="orderedlist">
                <ol class="orderedlist" type="1"><li class="listitem"><p>
                    Create a table that contains an indexed
                    <code class="literal">AUTO_INCREMENT</code> column.
                </p><p style="color:blue;">创建包含索引自动递增列的表。</p><a class="indexterm" name="idm140286836304416"></a></li><li class="listitem"><p>
                    Insert many rows into the table. Each insert results in an
                    index value that is added to the high end of the index.
                </p><p style="color:blue;">在表中插入许多行。每次插入都会产生一个添加到索引高端的索引值。</p><a class="indexterm" name="idm140286836302000"></a></li><li class="listitem"><p>
                    Delete a block of rows at the low end of the column range
                    using <code class="literal">DELETE QUICK</code>.
                </p><p style="color:blue;">使用“快速删除”删除列范围低端的行块。</p></li></ol>
            </div>
            <p>
                In this scenario, the index blocks associated with the deleted
                index values become underfilled but are not merged with other
                index blocks due to the use of <code class="literal">QUICK</code>. They
                remain underfilled when new inserts occur, because new rows do not
                have index values in the deleted range. Furthermore, they remain
                underfilled even if you later use
                <a class="link" href="sql-syntax.html#delete" title="13.2.2&nbsp;DELETE Syntax"><code class="literal">DELETE</code></a> without
                <code class="literal">QUICK</code>, unless some of the deleted index values
                happen to lie in index blocks within or adjacent to the
                underfilled blocks. To reclaim unused index space under these
                circumstances, use <a class="link" href="sql-syntax.html#optimize-table" title="13.7.2.4&nbsp;OPTIMIZE TABLE Syntax"><code class="literal">OPTIMIZE TABLE</code></a>.
            </p><p style="color:blue;">在这种情况下，与已删除索引值关联的索引块将变为填充不足，但由于使用quick，不会与其他索引块合并。当发生新插入时，它们仍然填充不足，因为新行在已删除的范围内没有索引值。此外，即使以后不使用quick而使用delete，它们也会保持填充不足，除非某些已删除的索引值碰巧位于填充不足的块内或附近的索引块中。要在这种情况下回收未使用的索引空间，请使用optimize table。</p><p>
            If you are going to delete many rows from a table, it might be
            faster to use <code class="literal">DELETE QUICK</code> followed by
            <a class="link" href="sql-syntax.html#optimize-table" title="13.7.2.4&nbsp;OPTIMIZE TABLE Syntax"><code class="literal">OPTIMIZE TABLE</code></a>. This rebuilds the
            index rather than performing many index block merge operations.
        </p><p style="color:blue;">如果要从表中删除许多行，则使用delete quick和optimize table可能会更快。这将重建索引，而不是执行许多索引块合并操作。</p>
            <h4><a name="idm140286836291312"></a>Multi-Table Deletes</h4>
            <p>
                You can specify multiple tables in a
                <a class="link" href="sql-syntax.html#delete" title="13.2.2&nbsp;DELETE Syntax"><code class="literal">DELETE</code></a> statement to delete rows
                from one or more tables depending on the condition in the
                <code class="literal">WHERE</code> clause. You cannot use <code class="literal">ORDER
                BY</code> or <code class="literal">LIMIT</code> in a multiple-table
                <code class="literal">DELETE</code>. The
                <em class="replaceable"><code>table_references</code></em> clause lists the
                tables involved in the join, as described in
                <a class="xref" href="sql-syntax.html#join" title="13.2.9.2&nbsp;JOIN Syntax">Section&nbsp;13.2.9.2, “JOIN Syntax”</a>.
            </p><p style="color:blue;">根据where子句中的条件，可以在delete语句中指定多个表以从一个或多个表中删除行。不能在多表删除中使用ORDER BY或LIMIT。table_references子句列出了连接中涉及的表，如第13.2.9.2节“连接语法”中所述。</p><p>
            For the first multiple-table syntax, only matching rows from the
            tables listed before the <code class="literal">FROM</code> clause are
            deleted. For the second multiple-table syntax, only matching rows
            from the tables listed in the <code class="literal">FROM</code> clause
            (before the <code class="literal">USING</code> clause) are deleted. The
            effect is that you can delete rows from many tables at the same
            time and have additional tables that are used only for searching:
        </p><p style="color:blue;">对于第一个多表语法，只删除from子句之前列出的表中的匹配行。对于第二个多表语法，只删除from子句（using子句之前）中列出的表中的匹配行。其效果是，您可以同时从多个表中删除行，并具有仅用于搜索的其他表：</p><pre data-lang="sql" class="programlisting">DELETE t1, t2 FROM t1 INNER JOIN t2 INNER JOIN t3
WHERE t1.id=t2.id AND t2.id=t3.id;
</pre><p>
            Or:
        </p><p style="color:blue;">或：</p><pre data-lang="sql" class="programlisting">DELETE FROM t1, t2 USING t1 INNER JOIN t2 INNER JOIN t3
WHERE t1.id=t2.id AND t2.id=t3.id;
</pre><p>
            These statements use all three tables when searching for rows to
            delete, but delete matching rows only from tables
            <code class="literal">t1</code> and <code class="literal">t2</code>.
        </p><p style="color:blue;">这些语句在搜索要删除的行时使用这三个表，但只从表T1和T2中删除匹配的行。</p><p>
            The preceding examples use <code class="literal">INNER JOIN</code>, but
            multiple-table <a class="link" href="sql-syntax.html#delete" title="13.2.2&nbsp;DELETE Syntax"><code class="literal">DELETE</code></a> statements
            can use other types of join permitted in
            <a class="link" href="sql-syntax.html#select" title="13.2.9&nbsp;SELECT Syntax"><code class="literal">SELECT</code></a> statements, such as
            <code class="literal">LEFT JOIN</code>. For example, to delete rows that
            exist in <code class="literal">t1</code> that have no match in
            <code class="literal">t2</code>, use a <code class="literal">LEFT JOIN</code>:
        </p><p style="color:blue;">前面的示例使用内部联接，但是多个表delete语句可以使用select语句中允许的其他类型的联接，例如left join。例如，为了删除T1中没有T2匹配的行，请使用左连接：</p><pre data-lang="sql" class="programlisting">DELETE t1 FROM t1 LEFT JOIN t2 ON t1.id=t2.id WHERE t2.id IS NULL;
</pre><p>
            The syntax permits <code class="literal">.*</code> after each
            <em class="replaceable"><code>tbl_name</code></em> for compatibility with
            <span class="command"><strong>Access</strong></span>.
        </p><p style="color:blue;">为了与access兼容，语法允许在每个tbl_名称后面加*号。</p><p>
            If you use a multiple-table <a class="link" href="sql-syntax.html#delete" title="13.2.2&nbsp;DELETE Syntax"><code class="literal">DELETE</code></a>
            statement involving <code class="literal">InnoDB</code> tables for which
            there are foreign key constraints, the MySQL optimizer might
            process tables in an order that differs from that of their
            parent/child relationship. In this case, the statement fails and
            rolls back. Instead, you should delete from a single table and
            rely on the <code class="literal">ON DELETE</code> capabilities that
            <code class="literal">InnoDB</code> provides to cause the other tables to be
            modified accordingly.
        </p><p style="color:blue;">如果使用涉及innodb表的多表delete语句，并且该语句有外键约束，那么mysql优化器可能会按照不同于其父/子关系的顺序处理表。在这种情况下，语句失败并回滚。相反，您应该从单个表中删除，并依赖于innodb提供的on-delete功能来相应地修改其他表。</p>
            <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">

                <div class="admon-title">
                    Note
                </div>
                <p>
                    If you declare an alias for a table, you must use the alias when
                    referring to the table:
                </p><p style="color:blue;">如果为表声明别名，则在引用表时必须使用该别名：</p><pre data-lang="sql" class="programlisting">DELETE t1 FROM test AS t1, test2 WHERE ...
</pre>
            </div>
            <p>
                Table aliases in a multiple-table
                <a class="link" href="sql-syntax.html#delete" title="13.2.2&nbsp;DELETE Syntax"><code class="literal">DELETE</code></a> should be declared only in
                the <em class="replaceable"><code>table_references</code></em> part of the
                statement. Elsewhere, alias references are permitted but not alias
                declarations.
            </p><p style="color:blue;">多表删除中的表别名应仅在语句的表引用部分声明。在其他地方，允许别名引用，但不允许别名声明。</p><p>
            Correct:
        </p><p style="color:blue;">对的：</p><pre data-lang="sql" class="programlisting">DELETE a1, a2 FROM t1 AS a1 INNER JOIN t2 AS a2
WHERE a1.id=a2.id;

DELETE FROM a1, a2 USING t1 AS a1 INNER JOIN t2 AS a2
WHERE a1.id=a2.id;
</pre><p>
            Incorrect:
        </p><p style="color:blue;">不正确：</p><pre data-lang="sql" class="programlisting">DELETE t1 AS a1, t2 AS a2 FROM t1 INNER JOIN t2
WHERE a1.id=a2.id;

DELETE FROM t1 AS a1, t2 AS a2 USING t1 INNER JOIN t2
WHERE a1.id=a2.id;
</pre>
        </div>
        <div class="section">
            <div class="titlepage">
                <div>
                    <div>
                        <h3 class="title"><a name="do"></a>13.2.3&nbsp;DO Syntax</h3>

                    </div>

                </div>

            </div>
            <a class="indexterm" name="idm140286836255216"></a><pre data-lang="sql" class="programlisting">DO <em class="replaceable"><code>expr</code></em> [, <em class="replaceable"><code>expr</code></em>] ...
</pre><p>
            <a class="link" href="sql-syntax.html#do" title="13.2.3&nbsp;DO Syntax"><code class="literal">DO</code></a> executes the expressions but
            does not return any results. In most respects,
            <a class="link" href="sql-syntax.html#do" title="13.2.3&nbsp;DO Syntax"><code class="literal">DO</code></a> is shorthand for <code class="literal">SELECT
            <em class="replaceable"><code>expr</code></em>, ...</code>, but has the
            advantage that it is slightly faster when you do not care about
            the result.
        </p><p style="color:blue;">执行表达式，但不返回任何结果。在大多数情况下，do是select expr的简写，…，但它的优点是，当您不关心结果时，它会稍微快一些。</p><p>
            <a class="link" href="sql-syntax.html#do" title="13.2.3&nbsp;DO Syntax"><code class="literal">DO</code></a> is useful primarily with
            functions that have side effects, such as
            <a class="link" href="functions.html#function_release-lock"><code class="literal">RELEASE_LOCK()</code></a>.
        </p><p style="color:blue;">do主要用于有副作用的函数，如release_lock（）。</p><p>
            Example: This <a class="link" href="sql-syntax.html#select" title="13.2.9&nbsp;SELECT Syntax"><code class="literal">SELECT</code></a> statement
            pauses, but also produces a result set:
        </p><p style="color:blue;">示例：此select语句暂停，但也会生成一个结果集：</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT SLEEP(5);</code></strong>
+----------+
| SLEEP(5) |
+----------+
|        0 |
+----------+
1 row in set (5.02 sec)
</pre><p>
            <a class="link" href="sql-syntax.html#do" title="13.2.3&nbsp;DO Syntax"><code class="literal">DO</code></a>, on the other hand, pauses
            without producing a result set.:
        </p><p style="color:blue;">另一方面，在不产生结果集的情况下暂停。</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>DO SLEEP(5);</code></strong>
Query OK, 0 rows affected (4.99 sec)
</pre><p>
            This could be useful, for example in a stored function or trigger,
            which prohibit statements that produce result sets.
        </p><p style="color:blue;">这可能很有用，例如在存储函数或触发器中，它禁止生成结果集的语句。</p><p>
            <a class="link" href="sql-syntax.html#do" title="13.2.3&nbsp;DO Syntax"><code class="literal">DO</code></a> only executes expressions. It
            cannot be used in all cases where <code class="literal">SELECT</code> can be
            used. For example, <code class="literal">DO id FROM t1</code> is invalid
            because it references a table.
        </p><p style="color:blue;">只执行表达式。它不能在所有可以使用select的情况下使用。例如，T1中的do id无效，因为它引用了一个表。</p>
        </div>
        <div class="section">
            <div class="titlepage">
                <div>
                    <div>
                        <h3 class="title"><a name="handler"></a>13.2.4&nbsp;HANDLER Syntax</h3>

                    </div>

                </div>

            </div>
            <a class="indexterm" name="idm140286836230848"></a><pre data-lang="sql" class="programlisting">HANDLER <em class="replaceable"><code>tbl_name</code></em> OPEN [ [AS] <em class="replaceable"><code>alias</code></em>]

HANDLER <em class="replaceable"><code>tbl_name</code></em> READ <em class="replaceable"><code>index_name</code></em> { = | &lt;= | &gt;= | &lt; | &gt; } (<em class="replaceable"><code>value1</code></em>,<em class="replaceable"><code>value2</code></em>,...)
    [ WHERE <em class="replaceable"><code>where_condition</code></em> ] [LIMIT ... ]
HANDLER <em class="replaceable"><code>tbl_name</code></em> READ <em class="replaceable"><code>index_name</code></em> { FIRST | NEXT | PREV | LAST }
    [ WHERE <em class="replaceable"><code>where_condition</code></em> ] [LIMIT ... ]
HANDLER <em class="replaceable"><code>tbl_name</code></em> READ { FIRST | NEXT }
    [ WHERE <em class="replaceable"><code>where_condition</code></em> ] [LIMIT ... ]

HANDLER <em class="replaceable"><code>tbl_name</code></em> CLOSE
</pre><p>
            The <code class="literal">HANDLER</code> statement provides direct access to
            table storage engine interfaces. It is available for
            <code class="literal">InnoDB</code> and <code class="literal">MyISAM</code> tables.
        </p><p style="color:blue;">handler语句提供对表存储引擎接口的直接访问。它可用于innodb和myisam表。</p><p>
            The <code class="literal">HANDLER ... OPEN</code> statement opens a table,
            making it accessible using subsequent <code class="literal">HANDLER ...
            READ</code> statements. This table object is not shared by
            other sessions and is not closed until the session calls
            <code class="literal">HANDLER ... CLOSE</code> or the session terminates.
        </p><p style="color:blue;">处理程序…open语句打开一个表，使它可以使用后续处理程序访问…阅读陈述。此表对象不由其他会话共享，并且在会话调用处理程序之前不会关闭…关闭或会话终止。</p><p>
            If you open the table using an alias, further references to the
            open table with other <code class="literal">HANDLER</code> statements must
            use the alias rather than the table name. If you do not use an
            alias, but open the table using a table name qualified by the
            database name, further references must use the unqualified table
            name. For example, for a table opened using
            <code class="literal">mydb.mytable</code>, further references must use
            <code class="literal">mytable</code>.
        </p><p style="color:blue;">如果使用别名打开表，则使用其他处理程序语句对打开表的进一步引用必须使用别名，而不是表名。如果不使用别名，但使用由数据库名称限定的表名称打开表，则进一步的引用必须使用不限定的表名称。例如，对于使用mydb.mytable打开的表，进一步的引用必须使用mytable。</p><p>
            The first <code class="literal">HANDLER ... READ</code> syntax fetches a row
            where the index specified satisfies the given values and the
            <code class="literal">WHERE</code> condition is met. If you have a
            multiple-column index, specify the index column values as a
            comma-separated list. Either specify values for all the columns in
            the index, or specify values for a leftmost prefix of the index
            columns. Suppose that an index <code class="literal">my_idx</code> includes
            three columns named <code class="literal">col_a</code>,
            <code class="literal">col_b</code>, and <code class="literal">col_c</code>, in that
            order. The <code class="literal">HANDLER</code> statement can specify values
            for all three columns in the index, or for the columns in a
            leftmost prefix. For example:
        </p><p style="color:blue;">第一个处理者…读取语法获取指定索引满足给定值且满足where条件的行。如果有多列索引，请将索引列值指定为逗号分隔的列表。为索引中的所有列指定值，或为索引列的最左边前缀指定值。假设一个索引my_idx按顺序包含三列，分别名为col_a、col_b和col_c。handler语句可以为索引中的所有三列或最左边前缀中的列指定值。例如：</p><pre data-lang="sql" class="programlisting">HANDLER ... READ my_idx = (col_a_val,col_b_val,col_c_val) ...
HANDLER ... READ my_idx = (col_a_val,col_b_val) ...
HANDLER ... READ my_idx = (col_a_val) ...
</pre><p>
            To employ the <code class="literal">HANDLER</code> interface to refer to a
            table's <code class="literal">PRIMARY KEY</code>, use the quoted identifier
            <code class="literal">`PRIMARY`</code>:
        </p><p style="color:blue;">要使用handler接口引用表的主键，请使用带引号的标识符“primary”：</p><pre data-lang="sql" class="programlisting">HANDLER <em class="replaceable"><code>tbl_name</code></em> READ `PRIMARY` ...
</pre><p>
            The second <code class="literal">HANDLER ... READ</code> syntax fetches a
            row from the table in index order that matches the
            <code class="literal">WHERE</code> condition.
        </p><p style="color:blue;">第二个处理程序…读取语法按与where条件匹配的索引顺序从表中获取行。</p><p>
            The third <code class="literal">HANDLER ... READ</code> syntax fetches a row
            from the table in natural row order that matches the
            <code class="literal">WHERE</code> condition. It is faster than
            <code class="literal">HANDLER <em class="replaceable"><code>tbl_name</code></em> READ
                <em class="replaceable"><code>index_name</code></em></code> when a full table
            scan is desired. Natural row order is the order in which rows are
            stored in a <code class="literal">MyISAM</code> table data file. This
            statement works for <code class="literal">InnoDB</code> tables as well, but
            there is no such concept because there is no separate data file.
        </p><p style="color:blue;">第三个处理程序…读取语法按与where条件匹配的自然行顺序从表中获取行。当需要全表扫描时，它比处理程序tbl_name read index_name快。自然行顺序是行存储在myisam表数据文件中的顺序。这个语句也适用于innodb表，但是没有这样的概念，因为没有单独的数据文件。</p><p>
            Without a <code class="literal">LIMIT</code> clause, all forms of
            <code class="literal">HANDLER ... READ</code> fetch a single row if one is
            available. To return a specific number of rows, include a
            <code class="literal">LIMIT</code> clause. It has the same syntax as for the
            <a class="link" href="sql-syntax.html#select" title="13.2.9&nbsp;SELECT Syntax"><code class="literal">SELECT</code></a> statement. See
            <a class="xref" href="sql-syntax.html#select" title="13.2.9&nbsp;SELECT Syntax">Section&nbsp;13.2.9, “SELECT Syntax”</a>.
        </p><p style="color:blue;">没有限制子句，所有形式的处理程序…读取获取一行（如果有）。要返回特定数量的行，请包含LIMIT子句。它的语法与select语句相同。参见第13.2.9节“选择语法”。</p><p>
            <code class="literal">HANDLER ... CLOSE</code> closes a table that was
            opened with <code class="literal">HANDLER ... OPEN</code>.
        </p><p style="color:blue;">处理器…关闭关闭用处理程序打开的表…打开。</p><p>
            There are several reasons to use the <code class="literal">HANDLER</code>
            interface instead of normal <a class="link" href="sql-syntax.html#select" title="13.2.9&nbsp;SELECT Syntax"><code class="literal">SELECT</code></a>
            statements:
        </p><p style="color:blue;">使用handler接口而不是普通的select语句有几个原因：</p>
            <div class="itemizedlist">
                <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                    <code class="literal">HANDLER</code> is faster than
                    <a class="link" href="sql-syntax.html#select" title="13.2.9&nbsp;SELECT Syntax"><code class="literal">SELECT</code></a>:
                </p><p style="color:blue;">处理程序比选择更快：</p>
                    <div class="itemizedlist">
                        <ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
                            A designated storage engine handler object is allocated
                            for the <code class="literal">HANDLER ... OPEN</code>. The object is
                            reused for subsequent <code class="literal">HANDLER</code>
                            statements for that table; it need not be reinitialized
                            for each one.
                        </p><p style="color:blue;">为处理程序分配了指定的存储引擎处理程序对象…打开。该对象将被重新用于该表的后续处理程序语句；不必为每个处理程序语句重新初始化。</p></li><li class="listitem"><p>
                            There is less parsing involved.
                        </p><p style="color:blue;">所涉及的解析更少。</p></li><li class="listitem"><p>
                            There is no optimizer or query-checking overhead.
                        </p><p style="color:blue;">没有优化器或查询检查开销。</p></li><li class="listitem"><p>
                            The handler interface does not have to provide a
                            consistent look of the data (for example,
                            <a class="link" href="glossary.html#glos_dirty_read" title="dirty read">dirty reads</a> are
                            permitted), so the storage engine can use optimizations
                            that <a class="link" href="sql-syntax.html#select" title="13.2.9&nbsp;SELECT Syntax"><code class="literal">SELECT</code></a> does not
                            normally permit.
                        </p><p style="color:blue;">处理程序接口不必提供数据的一致外观（例如，允许脏读），因此存储引擎可以使用select通常不允许的优化。</p></li></ul>
                    </div>
                </li><li class="listitem"><p>
                    <code class="literal">HANDLER</code> makes it easier to port to MySQL
                    applications that use a low-level <code class="literal">ISAM</code>-like
                    interface. (See <a class="xref" href="innodb-storage-engine.html#innodb-memcached" title="14.20&nbsp;InnoDB memcached Plugin">Section&nbsp;14.20, “InnoDB memcached Plugin”</a> for an
                    alternative way to adapt applications that use the key-value
                    store paradigm.)
                </p><p style="color:blue;">处理程序使使用低级类isam接口的mysql应用程序的端口更加容易。（请参阅第14.20节“innodb memcached plugin”，了解使用键值存储范式的应用程序的另一种调整方法。）</p></li><li class="listitem"><p>
                    <code class="literal">HANDLER</code> enables you to traverse a database
                    in a manner that is difficult (or even impossible) to
                    accomplish with <a class="link" href="sql-syntax.html#select" title="13.2.9&nbsp;SELECT Syntax"><code class="literal">SELECT</code></a>. The
                    <code class="literal">HANDLER</code> interface is a more natural way to
                    look at data when working with applications that provide an
                    interactive user interface to the database.
                </p><p style="color:blue;">处理程序使您能够以使用select难以（甚至不可能）完成的方式遍历数据库。处理程序接口是在处理为数据库提供交互式用户界面的应用程序时更自然地查看数据的方式。</p></li></ul>
            </div>
            <p>
                <code class="literal">HANDLER</code> is a somewhat low-level statement. For
                example, it does not provide consistency. That is,
                <code class="literal">HANDLER ... OPEN</code> does <span class="emphasis"><em>not</em></span>
                take a snapshot of the table, and does <span class="emphasis"><em>not</em></span>
                lock the table. This means that after a <code class="literal">HANDLER ...
                OPEN</code> statement is issued, table data can be modified (by
                the current session or other sessions) and these modifications
                might be only partially visible to <code class="literal">HANDLER ...
                NEXT</code> or <code class="literal">HANDLER ... PREV</code> scans.
            </p><p style="color:blue;">handler是一个有点低级的语句。例如，它不提供一致性。也就是说，汉德勒…open不获取表的快照，也不锁定表。这意味着在处理程序之后…open语句被发出，表数据可以被修改（由当前会话或其他会话修改），并且这些修改可能只对处理程序部分可见…下一个或处理程序…前一次扫描。</p><p>
            An open handler can be closed and marked for reopen, in which case
            the handler loses its position in the table. This occurs when both
            of the following circumstances are true:
        </p><p style="color:blue;">打开的处理程序可以关闭并标记为重新打开，在这种情况下，处理程序将失去在表中的位置。当以下两种情况都是真的时，就会发生这种情况：</p>
            <div class="itemizedlist">
                <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                    Any session executes <a class="link" href="sql-syntax.html#flush-tables"><code class="literal">FLUSH
                    TABLES</code></a> or DDL statements on the handler's table.
                </p><p style="color:blue;">任何会话都在处理程序的表上执行flush table s或ddl语句。</p></li><li class="listitem"><p>
                    The session in which the handler is open executes
                    non-<code class="literal">HANDLER</code> statements that use tables.
                </p><p style="color:blue;">打开处理程序的会话执行使用表的非处理程序语句。</p></li></ul>
            </div>
            <p>
                <a class="link" href="sql-syntax.html#truncate-table" title="13.1.34&nbsp;TRUNCATE TABLE Syntax"><code class="literal">TRUNCATE TABLE</code></a> for a table closes
                all handlers for the table that were opened with
                <a class="link" href="sql-syntax.html#handler" title="13.2.4&nbsp;HANDLER Syntax"><code class="literal">HANDLER OPEN</code></a>.
            </p><p style="color:blue;">truncate table for a table关闭在处理程序打开时打开的表的所有处理程序。</p><p>
            If a table is flushed with
            <a class="link" href="sql-syntax.html#flush-tables-with-read-lock-with-list"><code class="literal">FLUSH
                TABLES <em class="replaceable"><code>tbl_name</code></em> WITH READ
                LOCK</code></a> was opened with <code class="literal">HANDLER</code>, the
            handler is implicitly flushed and loses its position.
        </p><p style="color:blue;">如果使用flush tables刷新表tbl_name with read lock was opened with handler，则处理程序将隐式刷新并丢失其位置。</p>
        </div>
        <div class="section">
            <div class="titlepage">
                <div>
                    <div>
                        <h3 class="title"><a name="insert"></a>13.2.5&nbsp;INSERT Syntax</h3>

                    </div>

                </div>

            </div>
            <div class="toc">
                <dl class="toc"><dt><span class="section"><a href="sql-syntax.html#insert-select">13.2.5.1 INSERT ... SELECT Syntax</a></span></dt><dt><span class="section"><a href="sql-syntax.html#insert-on-duplicate">13.2.5.2 INSERT ... ON DUPLICATE KEY UPDATE Syntax</a></span></dt><dt><span class="section"><a href="sql-syntax.html#insert-delayed">13.2.5.3 INSERT DELAYED Syntax</a></span></dt></dl>
            </div>
            <a class="indexterm" name="idm140286836149776"></a><a class="indexterm" name="idm140286836148704"></a><a class="indexterm" name="idm140286836147632"></a><pre data-lang="sql" class="programlisting">INSERT [LOW_PRIORITY | DELAYED | HIGH_PRIORITY] [IGNORE]
    [INTO] <em class="replaceable"><code>tbl_name</code></em>
    [PARTITION (<em class="replaceable"><code>partition_name</code></em> [, <em class="replaceable"><code>partition_name</code></em>] ...)]
    [(<em class="replaceable"><code>col_name</code></em> [, <em class="replaceable"><code>col_name</code></em>] ...)]
    {VALUES | VALUE} (<em class="replaceable"><code>value_list</code></em>) [, (<em class="replaceable"><code>value_list</code></em>)] ...
    [ON DUPLICATE KEY UPDATE <em class="replaceable"><code>assignment_list</code></em>]

INSERT [LOW_PRIORITY | DELAYED | HIGH_PRIORITY] [IGNORE]
    [INTO] <em class="replaceable"><code>tbl_name</code></em>
    [PARTITION (<em class="replaceable"><code>partition_name</code></em> [, <em class="replaceable"><code>partition_name</code></em>] ...)]
    SET <em class="replaceable"><code>assignment_list</code></em>
    [ON DUPLICATE KEY UPDATE <em class="replaceable"><code>assignment_list</code></em>]

INSERT [LOW_PRIORITY | HIGH_PRIORITY] [IGNORE]
    [INTO] <em class="replaceable"><code>tbl_name</code></em>
    [PARTITION (<em class="replaceable"><code>partition_name</code></em> [, <em class="replaceable"><code>partition_name</code></em>] ...)]
    [(<em class="replaceable"><code>col_name</code></em> [, <em class="replaceable"><code>col_name</code></em>] ...)]
    SELECT ...
    [ON DUPLICATE KEY UPDATE <em class="replaceable"><code>assignment_list</code></em>]

<em class="replaceable"><code>value</code></em>:
    {<em class="replaceable"><code>expr</code></em> | DEFAULT}

<em class="replaceable"><code>value_list</code></em>:
    <em class="replaceable"><code>value</code></em> [, <em class="replaceable"><code>value</code></em>] ...

<em class="replaceable"><code>assignment</code></em>:
    <em class="replaceable"><code>col_name</code></em> = <em class="replaceable"><code>value</code></em>

<em class="replaceable"><code>assignment_list</code></em>:
    <em class="replaceable"><code>assignment</code></em> [, <em class="replaceable"><code>assignment</code></em>] ...
</pre><p>
            <a class="link" href="sql-syntax.html#insert" title="13.2.5&nbsp;INSERT Syntax"><code class="literal">INSERT</code></a> inserts new rows into an
            existing table. The <a class="link" href="sql-syntax.html#insert" title="13.2.5&nbsp;INSERT Syntax"><code class="literal">INSERT
            ... VALUES</code></a> and
            <a class="link" href="sql-syntax.html#insert" title="13.2.5&nbsp;INSERT Syntax"><code class="literal">INSERT ... SET</code></a>
            forms of the statement insert rows based on explicitly specified
            values. The <a class="link" href="sql-syntax.html#insert-select" title="13.2.5.1&nbsp;INSERT ... SELECT Syntax"><code class="literal">INSERT
            ... SELECT</code></a> form inserts rows selected from another table
            or tables. <a class="link" href="sql-syntax.html#insert" title="13.2.5&nbsp;INSERT Syntax"><code class="literal">INSERT</code></a> with an
            <code class="literal">ON DUPLICATE KEY UPDATE</code> clause enables existing
            rows to be updated if a row to be inserted would cause a duplicate
            value in a <code class="literal">UNIQUE</code> index or <code class="literal">PRIMARY
            KEY</code>.
        </p><p style="color:blue;">将新行插入到现有表中。插入…值和插入…根据显式指定的值设置语句插入行的形式。插入…选择窗体插入从另一个或多个表中选择的行。插入一个ON重复密钥更新子句，如果要插入的行将在唯一索引或主键中造成重复值，则可以更新现有行。</p><p>
            For additional information about
            <a class="link" href="sql-syntax.html#insert-select" title="13.2.5.1&nbsp;INSERT ... SELECT Syntax"><code class="literal">INSERT ...
                SELECT</code></a> and
            <a class="link" href="sql-syntax.html#insert-on-duplicate" title="13.2.5.2&nbsp;INSERT ... ON DUPLICATE KEY UPDATE Syntax"><code class="literal">INSERT ... ON
                DUPLICATE KEY UPDATE</code></a>, see
            <a class="xref" href="sql-syntax.html#insert-select" title="13.2.5.1&nbsp;INSERT ... SELECT Syntax">Section&nbsp;13.2.5.1, “INSERT ... SELECT Syntax”</a>, and
            <a class="xref" href="sql-syntax.html#insert-on-duplicate" title="13.2.5.2&nbsp;INSERT ... ON DUPLICATE KEY UPDATE Syntax">Section&nbsp;13.2.5.2, “INSERT ... ON DUPLICATE KEY UPDATE Syntax”</a>.
        </p><p style="color:blue;">有关插入的其他信息…选择并插入…在重复密钥更新时，请参见第13.2.5.1节“插入…选择“语法”，然后选择“插入…”13.2.5.2节。关于重复的密钥更新语法”。</p><p>
            In MySQL 5.7, the <code class="literal">DELAYED</code> keyword
            is accepted but ignored by the server. For the reasons for this,
            see <a class="xref" href="sql-syntax.html#insert-delayed" title="13.2.5.3&nbsp;INSERT DELAYED Syntax">Section&nbsp;13.2.5.3, “INSERT DELAYED Syntax”</a>,
        </p><p style="color:blue;">在mysql 5.7中，服务器接受delayed关键字，但忽略它。为此，请参阅第13.2.5.3节“插入延迟语法”，</p><p>
            Inserting into a table requires the
            <a class="link" href="security.html#priv_insert"><code class="literal">INSERT</code></a> privilege for the table. If
            the <code class="literal">ON DUPLICATE KEY UPDATE</code> clause is used and
            a duplicate key causes an <a class="link" href="sql-syntax.html#update" title="13.2.11&nbsp;UPDATE Syntax"><code class="literal">UPDATE</code></a> to
            be performed instead, the statement requires the
            <a class="link" href="security.html#priv_update"><code class="literal">UPDATE</code></a> privilege for the columns to
            be updated. For columns that are read but not modified you need
            only the <a class="link" href="security.html#priv_select"><code class="literal">SELECT</code></a> privilege (such as
            for a column referenced only on the right hand side of an
            <em class="replaceable"><code>col_name</code></em>=<em class="replaceable"><code>expr</code></em>
            assignment in an <code class="literal">ON DUPLICATE KEY UPDATE</code>
            clause).
        </p><p style="color:blue;">插入表需要表的插入权限。如果使用了on duplicate key update子句，而重复的键导致执行更新，则该语句要求更新列的update权限。对于已读取但未修改的列，您只需要select特权（例如，对于仅在重复键更新子句中col_name=expr赋值右侧引用的列）。</p><p>
            When inserting into a partitioned table, you can control which
            partitions and subpartitions accept new rows. The
            <code class="literal">PARTITION</code> option takes a list of the
            comma-separated names of one or more partitions or subpartitions
            (or both) of the table. If any of the rows to be inserted by a
            given <a class="link" href="sql-syntax.html#insert" title="13.2.5&nbsp;INSERT Syntax"><code class="literal">INSERT</code></a> statement do not match
            one of the partitions listed, the
            <a class="link" href="sql-syntax.html#insert" title="13.2.5&nbsp;INSERT Syntax"><code class="literal">INSERT</code></a> statement fails with the
            error <span class="errortext">Found a row not matching the given partition
      set</span>. For more information and examples, see
            <a class="xref" href="partitioning.html#partitioning-selection" title="22.5&nbsp;Partition Selection">Section&nbsp;22.5, “Partition Selection”</a>.
        </p><p style="color:blue;">插入分区表时，可以控制哪些分区和子分区接受新行。分区选项采取表的一个或多个分区或子分区（或两者）的逗号分隔名称的列表。如果给定insert语句要插入的任何行与列出的某个分区不匹配，insert语句将失败，并出现错误found a row not matching the given partition set。有关更多信息和示例，请参见第22.5节“分区选择”。</p><p>
            You can use <a class="link" href="sql-syntax.html#replace" title="13.2.8&nbsp;REPLACE Syntax"><code class="literal">REPLACE</code></a> instead of
            <a class="link" href="sql-syntax.html#insert" title="13.2.5&nbsp;INSERT Syntax"><code class="literal">INSERT</code></a> to overwrite old rows.
            <a class="link" href="sql-syntax.html#replace" title="13.2.8&nbsp;REPLACE Syntax"><code class="literal">REPLACE</code></a> is the counterpart to
            <a class="link" href="sql-syntax.html#insert" title="13.2.5&nbsp;INSERT Syntax"><code class="literal">INSERT IGNORE</code></a> in
            the treatment of new rows that contain unique key values that
            duplicate old rows: The new rows replace the old rows rather than
            being discarded. See <a class="xref" href="sql-syntax.html#replace" title="13.2.8&nbsp;REPLACE Syntax">Section&nbsp;13.2.8, “REPLACE Syntax”</a>.
        </p><p style="color:blue;">可以使用“替换”而不是“插入”覆盖旧行。replace是在处理包含重复旧行的唯一键值的新行时插入ignore的对应项：新行替换旧行，而不是被丢弃。见第13.2.8节“替换语法”。</p><p>
            <em class="replaceable"><code>tbl_name</code></em> is the table into which rows
            should be inserted. Specify the columns for which the statement
            provides values as follows:
        </p><p style="color:blue;">tbl_name是应该插入行的表。指定语句为其提供值的列，如下所示：</p>
            <div class="itemizedlist">
                <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                    Provide a parenthesized list of comma-separated column names
                    following the table name. In this case, a value for each named
                    column must be provided by the <code class="literal">VALUES</code> list
                    or the <a class="link" href="sql-syntax.html#select" title="13.2.9&nbsp;SELECT Syntax"><code class="literal">SELECT</code></a> statement.
                </p><p style="color:blue;">在表名之后提供逗号分隔列名的带圆括号列表。在这种情况下，必须通过values列表或select语句为每个命名列提供一个值。</p></li><li class="listitem"><p>
                    If you do not specify a list of column names for
                    <a class="link" href="sql-syntax.html#insert" title="13.2.5&nbsp;INSERT Syntax"><code class="literal">INSERT ...
                        VALUES</code></a> or
                    <a class="link" href="sql-syntax.html#insert-select" title="13.2.5.1&nbsp;INSERT ... SELECT Syntax"><code class="literal">INSERT ...
                        SELECT</code></a>, values for every column in the table must be
                    provided by the <code class="literal">VALUES</code> list or the
                    <a class="link" href="sql-syntax.html#select" title="13.2.9&nbsp;SELECT Syntax"><code class="literal">SELECT</code></a> statement. If you do not
                    know the order of the columns in the table, use
                    <code class="literal">DESCRIBE
                        <em class="replaceable"><code>tbl_name</code></em></code> to find out.
                </p><p style="color:blue;">如果不指定要插入的列名列表…值或插入…select，表中每列的值必须由values列表或select语句提供。如果不知道表中列的顺序，请使用describe tbl_name查找。</p></li><li class="listitem"><p>
                    A <code class="literal">SET</code> clause indicates columns explicitly
                    by name, together with the value to assign each one.
                </p><p style="color:blue;">set子句按名称显式地指示列，以及每个列要分配的值。</p></li></ul>
            </div>
            <p>
                Column values can be given in several ways:
            </p><p style="color:blue;">列值可以通过几种方式给出：</p>
            <div class="itemizedlist">
                <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                    If strict SQL mode is not enabled, any column not explicitly
                    given a value is set to its default (explicit or implicit)
                    value. For example, if you specify a column list that does not
                    name all the columns in the table, unnamed columns are set to
                    their default values. Default value assignment is described in
                    <a class="xref" href="data-types.html#data-type-defaults" title="11.7&nbsp;Data Type Default Values">Section&nbsp;11.7, “Data Type Default Values”</a>. See also
                    <a class="xref" href="introduction.html#constraint-invalid-data" title="1.8.3.3&nbsp;Constraints on Invalid Data">Section&nbsp;1.8.3.3, “Constraints on Invalid Data”</a>.
                </p><p style="color:blue;">如果未启用严格SQL模式，则未显式给定值的任何列都将设置为其默认值（显式或隐式）。例如，如果指定的列列表未命名表中的所有列，则未命名列将设置为其默认值。默认值分配在第11.7节“数据类型默认值”中描述。另见第1.8.3.3节“对无效数据的限制”。</p><a class="indexterm" name="idm140286836077936"></a><p>
                    If strict SQL mode is enabled, an
                    <a class="link" href="sql-syntax.html#insert" title="13.2.5&nbsp;INSERT Syntax"><code class="literal">INSERT</code></a> statement generates an
                    error if it does not specify an explicit value for every
                    column that has no default value. See
                    <a class="xref" href="server-administration.html#sql-mode" title="5.1.10&nbsp;Server SQL Modes">Section&nbsp;5.1.10, “Server SQL Modes”</a>.
                </p><p style="color:blue;">如果启用了strict sql模式，那么如果insert语句没有为没有默认值的每一列指定显式值，那么它将生成一个错误。参见第5.1.10节“服务器SQL模式”。</p></li><li class="listitem"><p>
                    If both the column list and the <code class="literal">VALUES</code> list
                    are empty, <a class="link" href="sql-syntax.html#insert" title="13.2.5&nbsp;INSERT Syntax"><code class="literal">INSERT</code></a> creates a row
                    with each column set to its default value:
                </p><p style="color:blue;">如果列列表和值列表都为空，则insert将创建一行，并将每列设置为其默认值：</p><pre data-lang="sql" class="programlisting">INSERT INTO <em class="replaceable"><code>tbl_name</code></em> () VALUES();
</pre><p>
                    If strict mode is not enabled, MySQL uses the implicit default
                    value for any column that has no explicitly defined default.
                    If strict mode is enabled, an error occurs if any column has
                    no default value.
                </p><p style="color:blue;">如果没有启用strict模式，mysql将对任何没有显式定义的默认值的列使用隐式默认值。如果启用了严格模式，则如果任何列没有默认值，则会发生错误。</p></li><li class="listitem"><p>
                    Use the keyword <code class="literal">DEFAULT</code> to set a column
                    explicitly to its default value. This makes it easier to write
                    <a class="link" href="sql-syntax.html#insert" title="13.2.5&nbsp;INSERT Syntax"><code class="literal">INSERT</code></a> statements that assign
                    values to all but a few columns, because it enables you to
                    avoid writing an incomplete <code class="literal">VALUES</code> list
                    that does not include a value for each column in the table.
                    Otherwise, you must provide the list of column names
                    corresponding to each value in the <code class="literal">VALUES</code>
                    list.
                </p><p style="color:blue;">使用关键字default将列显式设置为其默认值。这使得编写INSERT语句更容易，这些语句将值赋给除少数列以外的所有列，因为这样可以避免编写不完整的值列表，该列表不包括表中每列的值。否则，必须提供与“值”列表中的每个值对应的列名列表。</p></li><li class="listitem"><p>
                    If a generated column is inserted into explicitly, the only
                    permitted value is <code class="literal">DEFAULT</code>. For information
                    about generated columns, see
                    <a class="xref" href="sql-syntax.html#create-table-generated-columns" title="13.1.18.8&nbsp;CREATE TABLE and Generated Columns">Section&nbsp;13.1.18.8, “CREATE TABLE and Generated Columns”</a>.
                </p><p style="color:blue;">如果显式地将生成的列插入，则唯一允许的值是默认值。有关生成列的信息，请参见第13.1.18.8节“创建表和生成列”。</p><a class="indexterm" name="idm140286836062496"></a></li><li class="listitem"><p>
                    In expressions, you can use
                    <a class="link" href="functions.html#function_default"><code class="literal">DEFAULT(<em class="replaceable"><code>col_name</code></em>)</code></a>
                    to produce the default value for column
                    <em class="replaceable"><code>col_name</code></em>.
                </p><p style="color:blue;">在表达式中，可以使用默认值（col_name）生成col_name列的默认值。</p></li><li class="listitem"><p>
                    Type conversion of an expression
                    <em class="replaceable"><code>expr</code></em> that provides a column value
                    might occur if the expression data type does not match the
                    column data type. Conversion of a given value can result in
                    different inserted values depending on the column type. For
                    example, inserting the string <code class="literal">'1999.0e-2'</code>
                    into an <a class="link" href="data-types.html#integer-types" title="11.2.1&nbsp;Integer Types (Exact Value) - INTEGER, INT, SMALLINT, TINYINT, MEDIUMINT, BIGINT"><code class="literal">INT</code></a>,
                    <a class="link" href="data-types.html#floating-point-types" title="11.2.3&nbsp;Floating-Point Types (Approximate Value) - FLOAT, DOUBLE"><code class="literal">FLOAT</code></a>,
                    <a class="link" href="data-types.html#fixed-point-types" title="11.2.2&nbsp;Fixed-Point Types (Exact Value) - DECIMAL, NUMERIC"><code class="literal">DECIMAL(10,6)</code></a>, or
                    <a class="link" href="data-types.html#year" title="11.3.3&nbsp;The YEAR Type"><code class="literal">YEAR</code></a> column inserts the value
                    <code class="literal">1999</code>, <code class="literal">19.9921</code>,
                    <code class="literal">19.992100</code>, or <code class="literal">1999</code>,
                    respectively. The value stored in the
                    <a class="link" href="data-types.html#integer-types" title="11.2.1&nbsp;Integer Types (Exact Value) - INTEGER, INT, SMALLINT, TINYINT, MEDIUMINT, BIGINT"><code class="literal">INT</code></a> and
                    <a class="link" href="data-types.html#year" title="11.3.3&nbsp;The YEAR Type"><code class="literal">YEAR</code></a> columns is
                    <code class="literal">1999</code> because the string-to-number
                    conversion looks only at as much of the initial part of the
                    string as may be considered a valid integer or year. For the
                    <a class="link" href="data-types.html#floating-point-types" title="11.2.3&nbsp;Floating-Point Types (Approximate Value) - FLOAT, DOUBLE"><code class="literal">FLOAT</code></a> and
                    <a class="link" href="data-types.html#fixed-point-types" title="11.2.2&nbsp;Fixed-Point Types (Exact Value) - DECIMAL, NUMERIC"><code class="literal">DECIMAL</code></a> columns, the
                    string-to-number conversion considers the entire string a
                    valid numeric value.
                </p><p style="color:blue;">如果表达式数据类型与列数据类型不匹配，则可能发生提供列值的表达式表达式的类型转换。根据列类型的不同，对给定值的转换可能导致不同的插入值。例如，在int、float、decimal（10,6）或year列中插入字符串'1999.0e-2'，将分别插入值1999、19.9921、19.992100或1999。存储在int和year列中的值是1999，因为字符串到数字的转换只查看字符串的初始部分，这可能被视为有效的整数或年份。对于float和decimal列，字符串到数字的转换将整个字符串视为有效的数值。</p></li><li class="listitem"><p>
                    An expression <em class="replaceable"><code>expr</code></em> can refer to any
                    column that was set earlier in a value list. For example, you
                    can do this because the value for <code class="literal">col2</code>
                    refers to <code class="literal">col1</code>, which has previously been
                    assigned:
                </p><p style="color:blue;">表达式表达式可以引用先前在值列表中设置的任何列。例如，可以执行此操作，因为col2的值引用了col1，该值以前已分配给：</p><pre data-lang="sql" class="programlisting">INSERT INTO <em class="replaceable"><code>tbl_name</code></em> (col1,col2) VALUES(15,col1*2);
</pre><p>
                    But the following is not legal, because the value for
                    <code class="literal">col1</code> refers to <code class="literal">col2</code>,
                    which is assigned after <code class="literal">col1</code>:
                </p><p style="color:blue;">但以下内容不合法，因为col1的值是指col2，它是在col1之后分配的：</p><pre data-lang="sql" class="programlisting">INSERT INTO <em class="replaceable"><code>tbl_name</code></em> (col1,col2) VALUES(col2*2,15);
</pre><p>
                    An exception occurs for columns that contain
                    <code class="literal">AUTO_INCREMENT</code> values. Because
                    <code class="literal">AUTO_INCREMENT</code> values are generated after
                    other value assignments, any reference to an
                    <code class="literal">AUTO_INCREMENT</code> column in the assignment
                    returns a <code class="literal">0</code>.
                </p><p style="color:blue;">包含自动递增值的列发生异常。由于自动增量值是在其他值赋值之后生成的，因此对赋值中自动增量列的任何引用都将返回0。</p></li></ul>
            </div>
            <p>
                <a class="link" href="sql-syntax.html#insert" title="13.2.5&nbsp;INSERT Syntax"><code class="literal">INSERT</code></a> statements that use
                <code class="literal">VALUES</code> syntax can insert multiple rows. To do
                this, include multiple lists of comma-separated column values,
                with lists enclosed within parentheses and separated by commas.
                Example:
            </p><p style="color:blue;">使用值语法的INSERT语句可以插入多行。为此，请包含多个以逗号分隔的列值列表，列表用括号括起来并用逗号分隔。例子：</p><pre data-lang="sql" class="programlisting">INSERT INTO <em class="replaceable"><code>tbl_name</code></em> (a,b,c) VALUES(1,2,3),(4,5,6),(7,8,9);
</pre><p>
            Each values list must contain exactly as many values as are to be
            inserted per row. The following statement is invalid because it
            contains one list of nine values, rather than three lists of three
            values each:
        </p><p style="color:blue;">每个值列表必须包含与每行要插入的值完全相同的值。以下语句无效，因为它包含一个包含九个值的列表，而不是每个值包含三个值的三个列表：</p><pre data-lang="sql" class="programlisting">INSERT INTO <em class="replaceable"><code>tbl_name</code></em> (a,b,c) VALUES(1,2,3,4,5,6,7,8,9);
</pre><p>
            <code class="literal">VALUE</code> is a synonym for
            <code class="literal">VALUES</code> in this context. Neither implies
            anything about the number of values lists, nor about the number of
            values per list. Either may be used whether there is a single
            values list or multiple lists, and regardless of the number of
            values per list.
        </p><p style="color:blue;">值是此上下文中值的同义词。既不表示值列表的数量，也不表示每个列表的值的数量。无论是单个值列表还是多个列表，也无论每个列表的值数如何，都可以使用这两种方法。</p><p>
            The affected-rows value for an
            <a class="link" href="sql-syntax.html#insert" title="13.2.5&nbsp;INSERT Syntax"><code class="literal">INSERT</code></a> can be obtained using the
            <a class="link" href="functions.html#function_row-count"><code class="literal">ROW_COUNT()</code></a> SQL function or the
            <a class="link" href="connectors-apis.html#mysql-affected-rows" title="27.8.7.1&nbsp;mysql_affected_rows()"><code class="literal">mysql_affected_rows()</code></a> C API
            function. See <a class="xref" href="functions.html#information-functions" title="12.15&nbsp;Information Functions">Section&nbsp;12.15, “Information Functions”</a>, and
            <a class="xref" href="connectors-apis.html#mysql-affected-rows" title="27.8.7.1&nbsp;mysql_affected_rows()">Section&nbsp;27.8.7.1, “mysql_affected_rows()”</a>.
        </p><p style="color:blue;">可以使用row_count（）sql函数或mysql_effected_rows（）c api函数获取insert的受影响行值。参见第12.15节“信息函数”和第27.8.7.1节“mysql受影响的行”。</p><p>
            If you use an <a class="link" href="sql-syntax.html#insert" title="13.2.5&nbsp;INSERT Syntax"><code class="literal">INSERT ...
            VALUES</code></a> statement with multiple value lists or
            <a class="link" href="sql-syntax.html#insert-select" title="13.2.5.1&nbsp;INSERT ... SELECT Syntax"><code class="literal">INSERT ...
                SELECT</code></a>, the statement returns an information string in
            this format:
        </p><p style="color:blue;">如果你使用插入…包含多个值列表或插入的值语句…select，语句返回以下格式的信息字符串：</p><pre data-lang="none" class="programlisting">Records: <em class="replaceable"><code>N1</code></em> Duplicates: <em class="replaceable"><code>N2</code></em> Warnings: <em class="replaceable"><code>N3</code></em>
</pre><a class="indexterm" name="idm140286836011376"></a><p>
            If you are using the C API, the information string can be obtained
            by invoking the <a class="link" href="connectors-apis.html#mysql-info" title="27.8.7.36&nbsp;mysql_info()"><code class="literal">mysql_info()</code></a>
            function. See <a class="xref" href="connectors-apis.html#mysql-info" title="27.8.7.36&nbsp;mysql_info()">Section&nbsp;27.8.7.36, “mysql_info()”</a>.
        </p><p style="color:blue;">如果使用的是C API，则可以通过调用mysql_info（）函数来获取信息字符串。见27.8.7.36节，“mysql_info（）”。</p><p>
            <code class="literal">Records</code> indicates the number of rows processed
            by the statement. (This is not necessarily the number of rows
            actually inserted because <code class="literal">Duplicates</code> can be
            nonzero.) <code class="literal">Duplicates</code> indicates the number of
            rows that could not be inserted because they would duplicate some
            existing unique index value. <code class="literal">Warnings</code> indicates
            the number of attempts to insert column values that were
            problematic in some way. Warnings can occur under any of the
            following conditions:
        </p><p style="color:blue;">记录指示语句处理的行数。（这不一定是实际插入的行数，因为重复项可以是非零）。重复表示无法插入的行数，因为它们将复制一些现有的唯一索引值。警告指示以某种方式插入有问题的列值的尝试次数。在下列任何情况下都可能出现警告：</p>
            <div class="itemizedlist">
                <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                    Inserting <code class="literal">NULL</code> into a column that has been
                    declared <code class="literal">NOT NULL</code>. For multiple-row
                    <a class="link" href="sql-syntax.html#insert" title="13.2.5&nbsp;INSERT Syntax"><code class="literal">INSERT</code></a> statements or
                    <a class="link" href="sql-syntax.html#insert-select" title="13.2.5.1&nbsp;INSERT ... SELECT Syntax"><code class="literal">INSERT INTO ...
                        SELECT</code></a> statements, the column is set to the implicit
                    default value for the column data type. This is
                    <code class="literal">0</code> for numeric types, the empty string
                    (<code class="literal">''</code>) for string types, and the
                    <span class="quote">“<span class="quote">zero</span>”</span> value for date and time types.
                    <a class="link" href="sql-syntax.html#insert-select" title="13.2.5.1&nbsp;INSERT ... SELECT Syntax"><code class="literal">INSERT INTO ...
                        SELECT</code></a> statements are handled the same way as
                    multiple-row inserts because the server does not examine the
                    result set from the <a class="link" href="sql-syntax.html#select" title="13.2.9&nbsp;SELECT Syntax"><code class="literal">SELECT</code></a> to
                    see whether it returns a single row. (For a single-row
                    <a class="link" href="sql-syntax.html#insert" title="13.2.5&nbsp;INSERT Syntax"><code class="literal">INSERT</code></a>, no warning occurs when
                    <code class="literal">NULL</code> is inserted into a <code class="literal">NOT
                    NULL</code> column. Instead, the statement fails with an
                    error.)
                </p><p style="color:blue;">将null插入已声明为非null的列中。对于多行插入语句或插入到…select语句中，列被设置为列数据类型的隐式默认值。数字类型为0，字符串类型为空字符串（''），日期和时间类型为“0”值。插入到…select语句的处理方式与多行插入相同，因为服务器不会检查select中的结果集以查看它是否返回一行。（对于单行插入，如果将null插入到非null列中，则不会出现警告。相反，语句失败，出现错误。）</p></li><li class="listitem"><p>
                    Setting a numeric column to a value that lies outside the
                    column's range. The value is clipped to the closest endpoint
                    of the range.
                </p><p style="color:blue;">将数值列设置为超出该列范围的值。该值将剪裁到范围的最近端点。</p></li><li class="listitem"><p>
                    Assigning a value such as <code class="literal">'10.34 a'</code> to a
                    numeric column. The trailing nonnumeric text is stripped off
                    and the remaining numeric part is inserted. If the string
                    value has no leading numeric part, the column is set to
                    <code class="literal">0</code>.
                </p><p style="color:blue;">将值（如“10.34 A”）分配给数值列。后面的非数字文本将被删除，其余的数字部分将被插入。如果字符串值没有前导数字部分，则该列设置为0。</p></li><li class="listitem"><p>
                    Inserting a string into a string column
                    (<a class="link" href="data-types.html#char" title="11.4.1&nbsp;The CHAR and VARCHAR Types"><code class="literal">CHAR</code></a>,
                    <a class="link" href="data-types.html#char" title="11.4.1&nbsp;The CHAR and VARCHAR Types"><code class="literal">VARCHAR</code></a>,
                    <a class="link" href="data-types.html#blob" title="11.4.3&nbsp;The BLOB and TEXT Types"><code class="literal">TEXT</code></a>, or
                    <a class="link" href="data-types.html#blob" title="11.4.3&nbsp;The BLOB and TEXT Types"><code class="literal">BLOB</code></a>) that exceeds the column's
                    maximum length. The value is truncated to the column's maximum
                    length.
                </p><p style="color:blue;">将字符串插入到超过列最大长度的字符串列（CHAR、VARCHAR、文本或BLUB）中。该值被截断到列的最大长度。</p></li><li class="listitem"><p>
                    Inserting a value into a date or time column that is illegal
                    for the data type. The column is set to the appropriate zero
                    value for the type.
                </p><p style="color:blue;">在数据类型非法的日期或时间列中插入值。列被设置为类型的适当零值。</p></li><li class="listitem"><p>
                    For <a class="link" href="sql-syntax.html#insert" title="13.2.5&nbsp;INSERT Syntax"><code class="literal">INSERT</code></a> examples involving
                    <code class="literal">AUTO_INCREMET</code> column values, see
                    <a class="xref" href="tutorial.html#example-auto-increment" title="3.6.9&nbsp;Using AUTO_INCREMENT">Section&nbsp;3.6.9, “Using AUTO_INCREMENT”</a>.
                </p><p style="color:blue;">有关自动递增列值的插入示例，请参见第3.6.9节“使用自动递增”。</p><a class="indexterm" name="idm140286835978192"></a><a class="indexterm" name="idm140286835977120"></a><p>
                    If <a class="link" href="sql-syntax.html#insert" title="13.2.5&nbsp;INSERT Syntax"><code class="literal">INSERT</code></a> inserts a row into a
                    table that has an <code class="literal">AUTO_INCREMENT</code> column,
                    you can find the value used for that column by using the
                    <a class="link" href="functions.html#function_last-insert-id"><code class="literal">LAST_INSERT_ID()</code></a> SQL function
                    or the <a class="link" href="connectors-apis.html#mysql-insert-id" title="27.8.7.38&nbsp;mysql_insert_id()"><code class="literal">mysql_insert_id()</code></a> C API
                    function.
                </p><p style="color:blue;">如果INSERT将行插入到具有自动递增列的表中，则可以使用最后一个INSERT_id（）SQL函数或mysql_insert_id（）C API函数查找该列使用的值。</p>
                    <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">

                        <div class="admon-title">
                            Note
                        </div>
                        <p>
                            These two functions do not always behave identically. The
                            behavior of <a class="link" href="sql-syntax.html#insert" title="13.2.5&nbsp;INSERT Syntax"><code class="literal">INSERT</code></a> statements
                            with respect to <code class="literal">AUTO_INCREMENT</code> columns is
                            discussed further in
                            <a class="xref" href="functions.html#information-functions" title="12.15&nbsp;Information Functions">Section&nbsp;12.15, “Information Functions”</a>, and
                            <a class="xref" href="connectors-apis.html#mysql-insert-id" title="27.8.7.38&nbsp;mysql_insert_id()">Section&nbsp;27.8.7.38, “mysql_insert_id()”</a>.
                        </p><p style="color:blue;">这两个函数的行为并不总是相同的。INSERT语句关于自动递增列的行为在12.15节“信息函数”和27.8.7.38节“mysql_insert_id（）”中作了进一步讨论。</p>
                    </div>
                </li></ul>
            </div>
            <p>
                The <a class="link" href="sql-syntax.html#insert" title="13.2.5&nbsp;INSERT Syntax"><code class="literal">INSERT</code></a> statement supports the
                following modifiers:
            </p><p style="color:blue;">INSERT语句支持以下修饰符：</p>
            <div class="itemizedlist">
                <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                    If you use the <code class="literal">LOW_PRIORITY</code> modifier,
                    execution of the <a class="link" href="sql-syntax.html#insert" title="13.2.5&nbsp;INSERT Syntax"><code class="literal">INSERT</code></a> is
                    delayed until no other clients are reading from the table.
                    This includes other clients that began reading while existing
                    clients are reading, and while the <code class="literal">INSERT
                    LOW_PRIORITY</code> statement is waiting. It is possible,
                    therefore, for a client that issues an <code class="literal">INSERT
                    LOW_PRIORITY</code> statement to wait for a very long time.
                </p><p style="color:blue;">如果使用low_priority修饰符，则插入的执行将延迟，直到没有其他客户机从表中读取。这包括在现有客户端正在读取时开始读取的其他客户端，而INSERT LoWORY优先级语句正在等待。因此，对于发出insert low_priority语句的客户机，有可能等待很长时间。</p><a class="indexterm" name="idm140286835960224"></a><p>
                    <code class="literal">LOW_PRIORITY</code> affects only storage engines
                    that use only table-level locking (such as
                    <code class="literal">MyISAM</code>, <code class="literal">MEMORY</code>, and
                    <code class="literal">MERGE</code>).
                </p><p style="color:blue;">低优先级仅影响仅使用表级锁定（如myisam、内存和合并）的存储引擎。</p>
                    <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">

                        <div class="admon-title">
                            Note
                        </div>
                        <p>
                            <code class="literal">LOW_PRIORITY</code> should normally not be used
                            with <code class="literal">MyISAM</code> tables because doing so
                            disables concurrent inserts. See
                            <a class="xref" href="optimization.html#concurrent-inserts" title="8.11.3&nbsp;Concurrent Inserts">Section&nbsp;8.11.3, “Concurrent Inserts”</a>.
                        </p><p style="color:blue;">低优先级通常不应与myisam表一起使用，因为这样做会禁用并发插入。见第8.11.3节“并发插入”。</p>
                    </div>
                </li><li class="listitem"><p>
                    If you specify <code class="literal">HIGH_PRIORITY</code>, it overrides
                    the effect of the
                    <a class="link" href="server-administration.html#sysvar_low_priority_updates"><code class="option">--low-priority-updates</code></a> option
                    if the server was started with that option. It also causes
                    concurrent inserts not to be used. See
                    <a class="xref" href="optimization.html#concurrent-inserts" title="8.11.3&nbsp;Concurrent Inserts">Section&nbsp;8.11.3, “Concurrent Inserts”</a>.
                </p><p style="color:blue;">如果指定high_priority，则当服务器使用该选项启动时，它将覆盖--low priority updates选项的效果。它还导致不使用并发插入。见第8.11.3节“并发插入”。</p><a class="indexterm" name="idm140286835949088"></a><p>
                    <code class="literal">HIGH_PRIORITY</code> affects only storage engines
                    that use only table-level locking (such as
                    <code class="literal">MyISAM</code>, <code class="literal">MEMORY</code>, and
                    <code class="literal">MERGE</code>).
                </p><p style="color:blue;">高优先级只影响只使用表级锁定（如myisam、内存和合并）的存储引擎。</p></li><li class="listitem"><p>
                    If you use the <code class="literal">IGNORE</code> modifier, errors that
                    occur while executing the
                    <a class="link" href="sql-syntax.html#insert" title="13.2.5&nbsp;INSERT Syntax"><code class="literal">INSERT</code></a> statement are ignored.
                    For example, without <code class="literal">IGNORE</code>, a row that
                    duplicates an existing <code class="literal">UNIQUE</code> index or
                    <code class="literal">PRIMARY KEY</code> value in the table causes a
                    duplicate-key error and the statement is aborted. With
                    <code class="literal">IGNORE</code>, the row is discarded and no error
                    occurs. Ignored errors generate warnings instead.
                </p><p style="color:blue;">如果使用ignore修饰符，执行insert语句时发生的错误将被忽略。例如，在不忽略的情况下，重复表中现有的唯一索引或主键值的行会导致重复的键错误，并且语句被中止。使用ignore，将丢弃行，并且不会发生错误。忽略的错误会生成警告。</p><a class="indexterm" name="idm140286835938336"></a><p>
                    <a class="indexterm" name="idm140286835936592"></a>

                    <code class="literal">IGNORE</code> has a similar effect on inserts into
                    partitioned tables where no partition matching a given value
                    is found. Without <code class="literal">IGNORE</code>, such
                    <a class="link" href="sql-syntax.html#insert" title="13.2.5&nbsp;INSERT Syntax"><code class="literal">INSERT</code></a> statements are aborted
                    with an error. When
                    <a class="link" href="sql-syntax.html#insert" title="13.2.5&nbsp;INSERT Syntax"><code class="literal">INSERT
                        IGNORE</code></a> is used, the insert operation fails silently
                    for rows containing the unmatched value, but inserts rows that
                    are matched. For an example, see
                    <a class="xref" href="partitioning.html#partitioning-list" title="22.2.2&nbsp;LIST Partitioning">Section&nbsp;22.2.2, “LIST Partitioning”</a>.
                </p><p style="color:blue;">ignore对于插入到分区表中没有找到与给定值匹配的分区也有类似的效果。在不忽略的情况下，这样的插入语句会因错误而中止。使用insert ignore时，对于包含不匹配值的行，insert操作会自动失败，但会插入匹配的行。例如，请参见第22.2.2节“列表分区”。</p><p>
                    Data conversions that would trigger errors abort the statement
                    if <code class="literal">IGNORE</code> is not specified. With
                    <code class="literal">IGNORE</code>, invalid values are adjusted to the
                    closest values and inserted; warnings are produced but the
                    statement does not abort. You can determine with the
                    <a class="link" href="connectors-apis.html#mysql-info" title="27.8.7.36&nbsp;mysql_info()"><code class="literal">mysql_info()</code></a> C API function
                    how many rows were actually inserted into the table.
                </p><p style="color:blue;">如果未指定ignore，则会触发错误的数据转换将中止语句。使用ignore，将无效值调整为最接近的值并插入；将生成警告，但语句不会中止。您可以使用mysql_info（）c api函数确定实际插入表中的行数。</p><p>
                    For more information, see
                    <a class="xref" href="server-administration.html#ignore-strict-comparison" title="Comparison of the IGNORE Keyword and Strict SQL Mode">Comparison of the IGNORE Keyword and Strict SQL Mode</a>.
                </p><p style="color:blue;">有关详细信息，请参阅ignore关键字和strict sql模式的比较。</p></li><li class="listitem"><p>
                    If you specify <code class="literal">ON DUPLICATE KEY UPDATE</code>, and
                    a row is inserted that would cause a duplicate value in a
                    <code class="literal">UNIQUE</code> index or <code class="literal">PRIMARY
                    KEY</code>, an <a class="link" href="sql-syntax.html#update" title="13.2.11&nbsp;UPDATE Syntax"><code class="literal">UPDATE</code></a> of the
                    old row occurs. The affected-rows value per row is 1 if the
                    row is inserted as a new row, 2 if an existing row is updated,
                    and 0 if an existing row is set to its current values. If you
                    specify the <code class="literal">CLIENT_FOUND_ROWS</code> flag to the
                    <a class="link" href="connectors-apis.html#mysql-real-connect" title="27.8.7.54&nbsp;mysql_real_connect()"><code class="literal">mysql_real_connect()</code></a> C API
                    function when connecting to <a class="link" href="programs.html#mysqld" title="4.3.1&nbsp;mysqld — The MySQL Server"><span class="command"><strong>mysqld</strong></span></a>, the
                    affected-rows value is 1 (not 0) if an existing row is set to
                    its current values. See <a class="xref" href="sql-syntax.html#insert-on-duplicate" title="13.2.5.2&nbsp;INSERT ... ON DUPLICATE KEY UPDATE Syntax">Section&nbsp;13.2.5.2, “INSERT ... ON DUPLICATE KEY UPDATE Syntax”</a>.
                </p><p style="color:blue;">如果在重复键更新时指定，并且插入的行会导致唯一索引或主键中的值重复，则会更新旧行。如果行被插入为新行，则行每行的受影响行值为1，如果更新现有行，则为2，如果现有行设置为其当前值，则为0。如果在连接到mySQL时，将MySqLFrimeLink（）C API函数指定CeleTyNavigyLoad标志，如果现有行设置为其当前值，受影响的行值为1（不是0）。见第13.2.5.2节，“插入……关于重复的密钥更新语法”。</p><a class="indexterm" name="idm140286835916864"></a></li><li class="listitem"><p>
                    <a class="link" href="sql-syntax.html#insert-delayed" title="13.2.5.3&nbsp;INSERT DELAYED Syntax"><code class="literal">INSERT DELAYED</code></a> was deprecated
                    in MySQL 5.6, and is scheduled for eventual removal. In MySQL
                    5.7, the <code class="literal">DELAYED</code> modifier is
                    accepted but ignored. Use <code class="literal">INSERT</code> (without
                    <code class="literal">DELAYED</code>) instead. See
                    <a class="xref" href="sql-syntax.html#insert-delayed" title="13.2.5.3&nbsp;INSERT DELAYED Syntax">Section&nbsp;13.2.5.3, “INSERT DELAYED Syntax”</a>.
                </p><p style="color:blue;">在mysql 5.6中，insert delayed被弃用，并计划最终删除。在mysql 5.7中，延迟修饰符被接受，但被忽略。改为使用insert（不延迟）。见第13.2.5.3节“插入延迟语法”。</p><a class="indexterm" name="idm140286835910400"></a></li></ul>
            </div>
            <p>
                An <code class="literal">INSERT</code> statement affecting a partitioned
                table using a storage engine such as
                <a class="link" href="storage-engines.html#myisam-storage-engine" title="15.2&nbsp;The MyISAM Storage Engine"><code class="literal">MyISAM</code></a> that employs table-level locks
                locks only those partitions into which rows are actually inserted.
                (For storage engines such as <a class="link" href="innodb-storage-engine.html" title="Chapter&nbsp;14&nbsp;The InnoDB Storage Engine"><code class="literal">InnoDB</code></a>
                that employ row-level locking, no locking of partitions takes
                place.) For more information, see
                <a class="xref" href="partitioning.html#partitioning-limitations-locking" title="22.6.4&nbsp;Partitioning and Locking">Section&nbsp;22.6.4, “Partitioning and Locking”</a>.
            </p><p style="color:blue;">使用存储引擎（如myisam，它使用表级锁）影响分区表的insert语句只锁定实际插入行的分区。（对于使用行级锁定的存储引擎，如innodb，不会发生分区锁定。）有关更多信息，请参阅第22.6.4节“分区和锁定”。</p>
            <div class="section">

                <div class="titlepage">
                    <div>
                        <div>
                            <h4 class="title"><a name="insert-select"></a>13.2.5.1&nbsp;INSERT ... SELECT Syntax</h4>
                        </div>
                    </div>
                </div>
                <a class="indexterm" name="idm140286835902912"></a><pre data-lang="sql" class="programlisting">INSERT [LOW_PRIORITY | HIGH_PRIORITY] [IGNORE]
    [INTO] <em class="replaceable"><code>tbl_name</code></em>
    [PARTITION (<em class="replaceable"><code>partition_name</code></em> [, <em class="replaceable"><code>partition_name</code></em>] ...)]
    [(<em class="replaceable"><code>col_name</code></em> [, <em class="replaceable"><code>col_name</code></em>] ...)]
    SELECT ...
    [ON DUPLICATE KEY UPDATE <em class="replaceable"><code>assignment_list</code></em>]

<em class="replaceable"><code>value</code></em>:
    {<em class="replaceable"><code>expr</code></em> | DEFAULT}

<em class="replaceable"><code>assignment</code></em>:
    <em class="replaceable"><code>col_name</code></em> = <em class="replaceable"><code>value</code></em>

<em class="replaceable"><code>assignment_list</code></em>:
    <em class="replaceable"><code>assignment</code></em> [, <em class="replaceable"><code>assignment</code></em>] ...
</pre><p>
                With <a class="link" href="sql-syntax.html#insert-select" title="13.2.5.1&nbsp;INSERT ... SELECT Syntax"><code class="literal">INSERT ...
                SELECT</code></a>, you can quickly insert many rows into a table
                from the result of a <a class="link" href="sql-syntax.html#select" title="13.2.9&nbsp;SELECT Syntax"><code class="literal">SELECT</code></a>
                statement, which can select from one or many tables. For
                example:
            </p><p style="color:blue;">插入…select，您可以从select语句的结果中快速向表中插入多行，该语句可以从一个或多个表中进行选择。例如：</p><pre data-lang="sql" class="programlisting">INSERT INTO tbl_temp2 (fld_id)
  SELECT tbl_temp1.fld_order_id
  FROM tbl_temp1 WHERE tbl_temp1.fld_order_id &gt; 100;
</pre><p>
                The following conditions hold for
                <a class="link" href="sql-syntax.html#insert-select" title="13.2.5.1&nbsp;INSERT ... SELECT Syntax"><code class="literal">INSERT ...
                    SELECT</code></a> statements:
            </p><p style="color:blue;">以下条件适用于插入…选择语句：</p>
                <div class="itemizedlist">
                    <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                        Specify <code class="literal">IGNORE</code> to ignore rows that would
                        cause duplicate-key violations.
                    </p><p style="color:blue;">指定ignore可忽略会导致重复键冲突的行。</p></li><li class="listitem"><p>
                        The target table of the
                        <a class="link" href="sql-syntax.html#insert" title="13.2.5&nbsp;INSERT Syntax"><code class="literal">INSERT</code></a> statement may appear
                        in the <code class="literal">FROM</code> clause of the
                        <a class="link" href="sql-syntax.html#select" title="13.2.9&nbsp;SELECT Syntax"><code class="literal">SELECT</code></a> part of the query.
                        However, you cannot insert into a table and select from the
                        same table in a subquery.
                    </p><p style="color:blue;">insert语句的目标表可能出现在查询的select部分的from子句中。但是，不能在子查询中插入表并从同一表中进行选择。</p><p>
                        When selecting from and inserting into the same table, MySQL
                        creates an internal temporary table to hold the rows from
                        the <a class="link" href="sql-syntax.html#select" title="13.2.9&nbsp;SELECT Syntax"><code class="literal">SELECT</code></a> and then inserts
                        those rows into the target table. However, you cannot use
                        <code class="literal">INSERT INTO t ... SELECT ... FROM t</code> when
                        <code class="literal">t</code> is a <code class="literal">TEMPORARY</code>
                        table, because <code class="literal">TEMPORARY</code> tables cannot be
                        referred to twice in the same statement. See
                        <a class="xref" href="optimization.html#internal-temporary-tables" title="8.4.4&nbsp;Internal Temporary Table Use in MySQL">Section&nbsp;8.4.4, “Internal Temporary Table Use in MySQL”</a>, and
                        <a class="xref" href="error-handling.html#temporary-table-problems" title="B.4.6.2&nbsp;TEMPORARY Table Problems">Section&nbsp;B.4.6.2, “TEMPORARY Table Problems”</a>.
                    </p><p style="color:blue;">当从同一个表中选择并插入时，mysql创建一个内部临时表来保存select中的行，然后将这些行插入到目标表中。但是，不能使用insert into t…选择…当t是临时表时从t开始，因为临时表不能在同一语句中被引用两次。参见第8.4.4节“MySQL中的内部临时表使用”和第B.4.6.2节“临时表问题”。</p></li><li class="listitem"><p>
                        <code class="literal">AUTO_INCREMENT</code> columns work as usual.
                    </p><p style="color:blue;">自动递增列正常工作。</p></li><li class="listitem"><p>
                        To ensure that the binary log can be used to re-create the
                        original tables, MySQL does not permit concurrent inserts
                        for <a class="link" href="sql-syntax.html#insert-select" title="13.2.5.1&nbsp;INSERT ... SELECT Syntax"><code class="literal">INSERT
                        ... SELECT</code></a> statements (see
                        <a class="xref" href="optimization.html#concurrent-inserts" title="8.11.3&nbsp;Concurrent Inserts">Section&nbsp;8.11.3, “Concurrent Inserts”</a>).
                    </p><p style="color:blue;">为了确保二进制日志可用于重新创建原始表，mysql不允许对insert进行并发插入…select语句（参见第8.11.3节“并发插入”）。</p></li><li class="listitem"><p>
                        To avoid ambiguous column reference problems when the
                        <a class="link" href="sql-syntax.html#select" title="13.2.9&nbsp;SELECT Syntax"><code class="literal">SELECT</code></a> and the
                        <a class="link" href="sql-syntax.html#insert" title="13.2.5&nbsp;INSERT Syntax"><code class="literal">INSERT</code></a> refer to the same
                        table, provide a unique alias for each table used in the
                        <a class="link" href="sql-syntax.html#select" title="13.2.9&nbsp;SELECT Syntax"><code class="literal">SELECT</code></a> part, and qualify
                        column names in that part with the appropriate alias.
                    </p><p style="color:blue;">为了避免在select和insert引用同一表时出现不明确的列引用问题，请为select部分中使用的每个表提供唯一的别名，并使用适当的别名限定该部分中的列名。</p></li></ul>
                </div>
                <p>
                    You can explicitly select which partitions or subpartitions (or
                    both) of the source or target table (or both) are to be used
                    with a <code class="literal">PARTITION</code> option following the name of
                    the table. When <code class="literal">PARTITION</code> is used with the
                    name of the source table in the
                    <a class="link" href="sql-syntax.html#select" title="13.2.9&nbsp;SELECT Syntax"><code class="literal">SELECT</code></a> portion of the statement,
                    rows are selected only from the partitions or subpartitions
                    named in its partition list. When <code class="literal">PARTITION</code>
                    is used with the name of the target table for the
                    <a class="link" href="sql-syntax.html#insert" title="13.2.5&nbsp;INSERT Syntax"><code class="literal">INSERT</code></a> portion of the statement,
                    it must be possible to insert all rows selected into the
                    partitions or subpartitions named in the partition list
                    following the option. Otherwise, the <code class="literal">INSERT ...
                    SELECT</code> statement fails. For more information and
                    examples, see <a class="xref" href="partitioning.html#partitioning-selection" title="22.5&nbsp;Partition Selection">Section&nbsp;22.5, “Partition Selection”</a>.
                </p><p style="color:blue;">您可以显式地选择源或目标表（或两者）的分区或子分区（或两者）与表名称后面的分区选项一起使用。当分区与语句的SELECT部分中的源表的名称一起使用时，只从分区列表中命名的分区或子分区来选择行。当分区与语句的INSERT部分的目标表的名称一起使用时，必须将所有选择的行插入到分区列表中，或者在选项后面的分区列表中命名为。否则，插入…select语句失败。有关更多信息和示例，请参见第22.5节“分区选择”。</p><p>
                For <a class="link" href="sql-syntax.html#insert-on-duplicate" title="13.2.5.2&nbsp;INSERT ... ON DUPLICATE KEY UPDATE Syntax"><code class="literal">INSERT
                ... SELECT</code></a> statements, see
                <a class="xref" href="sql-syntax.html#insert-on-duplicate" title="13.2.5.2&nbsp;INSERT ... ON DUPLICATE KEY UPDATE Syntax">Section&nbsp;13.2.5.2, “INSERT ... ON DUPLICATE KEY UPDATE Syntax”</a> for conditions under which
                the <a class="link" href="sql-syntax.html#select" title="13.2.9&nbsp;SELECT Syntax"><code class="literal">SELECT</code></a> columns can be
                referred to in an <code class="literal">ON DUPLICATE KEY UPDATE</code>
                clause.
            </p><p style="color:blue;">对于插入…选择语句，见第13.2.5.2节“插入…“on duplicate key update syntax”用于在on duplicate key update子句中引用select列的条件。</p><p>
                The order in which a <a class="link" href="sql-syntax.html#select" title="13.2.9&nbsp;SELECT Syntax"><code class="literal">SELECT</code></a>
                statement with no <code class="literal">ORDER BY</code> clause returns
                rows is nondeterministic. This means that, when using
                replication, there is no guarantee that such a
                <a class="link" href="sql-syntax.html#select" title="13.2.9&nbsp;SELECT Syntax"><code class="literal">SELECT</code></a> returns rows in the same
                order on the master and the slave, which can lead to
                inconsistencies between them. To prevent this from occurring,
                always write <code class="literal">INSERT ... SELECT</code> statements
                that are to be replicated using an <code class="literal">ORDER BY</code>
                clause that produces the same row order on the master and the
                slave. See also <a class="xref" href="replication.html#replication-features-limit" title="16.4.1.17&nbsp;Replication and LIMIT">Section&nbsp;16.4.1.17, “Replication and LIMIT”</a>.
            </p><p style="color:blue;">没有ORDERBY子句的SELECT语句返回行的顺序是不确定的。这意味着，在使用复制时，不能保证这样一个select返回的行在master和slave上的顺序相同，这可能导致它们之间的不一致。为了防止这种情况发生，请始终写入insert…使用ORDERBY子句复制的SELECT语句，该子句在主控和从控上生成相同的行顺序。另见第16.4.1.17节“复制和限制”。</p><p>
                Due to this issue,
                <a class="link" href="sql-syntax.html#insert-on-duplicate" title="13.2.5.2&nbsp;INSERT ... ON DUPLICATE KEY UPDATE Syntax"><code class="literal">INSERT ...
                    SELECT ON DUPLICATE KEY UPDATE</code></a> and
                <a class="link" href="sql-syntax.html#insert-select" title="13.2.5.1&nbsp;INSERT ... SELECT Syntax"><code class="literal">INSERT IGNORE ...
                    SELECT</code></a> statements are flagged as unsafe for
                statement-based replication. Such statements produce a warning
                in the error log when using statement-based mode and are written
                to the binary log using the row-based format when using
                <code class="literal">MIXED</code> mode. (Bug #11758262, Bug #50439)
            </p><p style="color:blue;">由于此问题，请插入…在重复密钥更新时选择并插入忽略…对于基于语句的复制，select语句被标记为不安全。这种语句在使用基于语句的模式时在错误日志中生成警告，在使用混合模式时使用基于行的格式写入二进制日志。（错误11758262，错误50439）</p><p>
                See also <a class="xref" href="replication.html#replication-sbr-rbr" title="16.2.1.1&nbsp;Advantages and Disadvantages of Statement-Based and Row-Based Replication">Section&nbsp;16.2.1.1, “Advantages and Disadvantages of Statement-Based and Row-Based
                Replication”</a>.
            </p><p style="color:blue;">另见第16.2.1.1节“基于语句和基于行的复制的优缺点”。</p><p>
                An <code class="literal">INSERT ... SELECT</code> statement affecting
                partitioned tables using a storage engine such as
                <a class="link" href="storage-engines.html#myisam-storage-engine" title="15.2&nbsp;The MyISAM Storage Engine"><code class="literal">MyISAM</code></a> that employs table-level
                locks locks all partitions of the target table; however, only
                those partitions that are actually read from the source table
                are locked. (This does not occur with tables using storage
                engines such as <a class="link" href="innodb-storage-engine.html" title="Chapter&nbsp;14&nbsp;The InnoDB Storage Engine"><code class="literal">InnoDB</code></a> that employ
                row-level locking.) For more information, see
                <a class="xref" href="partitioning.html#partitioning-limitations-locking" title="22.6.4&nbsp;Partitioning and Locking">Section&nbsp;22.6.4, “Partitioning and Locking”</a>.
            </p><p style="color:blue;">插入…使用存储引擎（如使用表级锁的myisam）影响分区表的select语句锁定目标表的所有分区；但是，只有那些实际从源表读取的分区才会被锁定。（使用存储引擎（如使用行级锁定的innodb）的表不会出现这种情况。）有关更多信息，请参阅22.6.4节“分区和锁定”。</p>
            </div>
            <div class="section">
                <div class="titlepage">
                    <div>
                        <div>
                            <h4 class="title"><a name="insert-on-duplicate"></a>13.2.5.2&nbsp;INSERT ... ON DUPLICATE KEY UPDATE Syntax</h4>

                        </div>

                    </div>

                </div>
                <p>
                    If you specify an <code class="literal">ON DUPLICATE KEY UPDATE</code>
                    clause and a row to be inserted would cause a duplicate value in
                    a <code class="literal">UNIQUE</code> index or <code class="literal">PRIMARY
                    KEY</code>, an <a class="link" href="sql-syntax.html#update" title="13.2.11&nbsp;UPDATE Syntax"><code class="literal">UPDATE</code></a> of the
                    old row occurs. For example, if column <code class="literal">a</code> is
                    declared as <code class="literal">UNIQUE</code> and contains the value
                    <code class="literal">1</code>, the following two statements have similar
                    effect:
                </p><p style="color:blue;">如果指定了on duplicate key update子句，并且要插入的行将导致唯一索引或主键中的值重复，则会更新旧行。例如，如果列A声明为唯一并包含值1，则以下两条语句具有类似的效果：</p><pre data-lang="sql" class="programlisting">INSERT INTO t1 (a,b,c) VALUES (1,2,3)
  ON DUPLICATE KEY UPDATE c=c+1;

UPDATE t1 SET c=c+1 WHERE a=1;
</pre><p>
                (The effects are not identical for an <code class="literal">InnoDB</code>
                table where <code class="literal">a</code> is an auto-increment column.
                With an auto-increment column, an <code class="literal">INSERT</code>
                statement increases the auto-increment value but
                <code class="literal">UPDATE</code> does not.)
            </p><p style="color:blue;">（对于innodb表，其效果不同，其中a是自动递增列。对于自动递增列，INSERT语句会增加自动递增值，但UPDATE不会。）</p><p>
                If column <code class="literal">b</code> is also unique, the
                <a class="link" href="sql-syntax.html#insert" title="13.2.5&nbsp;INSERT Syntax"><code class="literal">INSERT</code></a> is equivalent to this
                <a class="link" href="sql-syntax.html#update" title="13.2.11&nbsp;UPDATE Syntax"><code class="literal">UPDATE</code></a> statement instead:
            </p><p style="color:blue;">如果B列也是唯一的，则插入与此UPDATE语句等效：</p><pre data-lang="sql" class="programlisting">UPDATE t1 SET c=c+1 WHERE a=1 OR b=2 LIMIT 1;
</pre><p>
                If <code class="literal">a=1 OR b=2</code> matches several rows, only
                <span class="emphasis"><em>one</em></span> row is updated. In general, you should
                try to avoid using an <code class="literal">ON DUPLICATE KEY UPDATE</code>
                clause on tables with multiple unique indexes.
            </p><p style="color:blue;">如果a=1或b=2匹配多行，则只更新一行。通常，应该尽量避免对具有多个唯一索引的表使用on duplicate key update子句。</p><p>
                With <code class="literal">ON DUPLICATE KEY UPDATE</code>, the
                affected-rows value per row is 1 if the row is inserted as a new
                row, 2 if an existing row is updated, and 0 if an existing row
                is set to its current values. If you specify the
                <code class="literal">CLIENT_FOUND_ROWS</code> flag to the
                <a class="link" href="connectors-apis.html#mysql-real-connect" title="27.8.7.54&nbsp;mysql_real_connect()"><code class="literal">mysql_real_connect()</code></a> C API
                function when connecting to <a class="link" href="programs.html#mysqld" title="4.3.1&nbsp;mysqld — The MySQL Server"><span class="command"><strong>mysqld</strong></span></a>, the
                affected-rows value is 1 (not 0) if an existing row is set to
                its current values.
            </p><p style="color:blue;">对于重复的密钥更新，如果行被插入为新行，则行每行的受影响行值为1，如果更新现有行，则为2，如果现有行被设置为其当前值，则为0。如果在连接到mySQL时，将MySqLFrimeLink（）C API函数指定CeleTyNavigyLoad标志，如果现有行设置为其当前值，受影响的行值为1（不是0）。</p><p>
                If a table contains an <code class="literal">AUTO_INCREMENT</code> column
                and <a class="link" href="sql-syntax.html#insert-on-duplicate" title="13.2.5.2&nbsp;INSERT ... ON DUPLICATE KEY UPDATE Syntax"><code class="literal">INSERT
                ... ON DUPLICATE KEY UPDATE</code></a> inserts or updates a row,
                the <a class="link" href="functions.html#function_last-insert-id"><code class="literal">LAST_INSERT_ID()</code></a> function
                returns the <code class="literal">AUTO_INCREMENT</code> value.
            </p><p style="color:blue;">如果表格包含自动递增列并插入…在重复的键更新插入或更新行时，最后一个insert_id（）函数返回自动递增值。</p><p>
                The <code class="literal">ON DUPLICATE KEY UPDATE</code> clause can
                contain multiple column assignments, separated by commas.
            </p><p style="color:blue;">on duplicate key update子句可以包含多个列分配，以逗号分隔。</p><p>
                In assignment value expressions in the <code class="literal">ON DUPLICATE KEY
                UPDATE</code> clause, you can use the
                <a class="link" href="functions.html#function_values"><code class="literal">VALUES(<em class="replaceable"><code>col_name</code></em>)</code></a>
                function to refer to column values from the
                <a class="link" href="sql-syntax.html#insert" title="13.2.5&nbsp;INSERT Syntax"><code class="literal">INSERT</code></a> portion of the
                <a class="link" href="sql-syntax.html#insert-on-duplicate" title="13.2.5.2&nbsp;INSERT ... ON DUPLICATE KEY UPDATE Syntax"><code class="literal">INSERT ...
                    ON DUPLICATE KEY UPDATE</code></a> statement. In other words,
                <a class="link" href="functions.html#function_values"><code class="literal">VALUES(<em class="replaceable"><code>col_name</code></em>)</code></a>
                in the <code class="literal">ON DUPLICATE KEY UPDATE</code> clause refers
                to the value of <em class="replaceable"><code>col_name</code></em> that would
                be inserted, had no duplicate-key conflict occurred. This
                function is especially useful in multiple-row inserts. The
                <a class="link" href="functions.html#function_values"><code class="literal">VALUES()</code></a> function is meaningful
                only in the <code class="literal">ON DUPLICATE KEY UPDATE</code> clause or
                <a class="link" href="sql-syntax.html#insert" title="13.2.5&nbsp;INSERT Syntax"><code class="literal">INSERT</code></a> statements and returns
                <code class="literal">NULL</code> otherwise. Example:
            </p><p style="color:blue;">在on duplicate key update子句中的赋值表达式中，可以使用values（col_name）函数引用insert的insert部分中的列值…在重复的密钥更新语句中。换言之，on duplicate key update子句中的值（col_name）是指在没有发生重复密钥冲突的情况下将要插入的col_name的值。此函数在多行插入中特别有用。values（）函数仅在on duplicate key update子句或insert语句中有意义，否则返回null。例子：</p><pre data-lang="sql" class="programlisting">INSERT INTO t1 (a,b,c) VALUES (1,2,3),(4,5,6)
  ON DUPLICATE KEY UPDATE c=VALUES(a)+VALUES(b);
</pre><p>
                That statement is identical to the following two statements:
            </p><p style="color:blue;">该声明与以下两个声明相同：</p><pre data-lang="sql" class="programlisting">INSERT INTO t1 (a,b,c) VALUES (1,2,3)
  ON DUPLICATE KEY UPDATE c=3;
INSERT INTO t1 (a,b,c) VALUES (4,5,6)
  ON DUPLICATE KEY UPDATE c=9;
</pre><p>
                For <a class="link" href="sql-syntax.html#insert-on-duplicate" title="13.2.5.2&nbsp;INSERT ... ON DUPLICATE KEY UPDATE Syntax"><code class="literal">INSERT
                ... SELECT</code></a> statements, these rules apply regarding
                acceptable forms of <code class="literal">SELECT</code> query expressions
                that you can refer to in an <code class="literal">ON DUPLICATE KEY
                UPDATE</code> clause:
            </p><p style="color:blue;">对于插入…select语句，这些规则适用于可以在on duplicate key update子句中引用的select查询表达式的可接受格式：</p>
                <div class="itemizedlist">
                    <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                        References to columns from queries on a single table, which
                        may be a derived table.
                    </p><p style="color:blue;">对单个表（可能是派生表）上查询的列的引用。</p></li><li class="listitem"><p>
                        References to columns from queries on a join over multiple
                        tables.
                    </p><p style="color:blue;">对多个表上的联接查询中的列的引用。</p></li><li class="listitem"><p>
                        References to columns from <code class="literal">DISTINCT</code>
                        queries.
                    </p><p style="color:blue;">对不同查询中的列的引用。</p></li><li class="listitem"><p>
                        References to columns in other tables, as long as the
                        <a class="link" href="sql-syntax.html#select" title="13.2.9&nbsp;SELECT Syntax"><code class="literal">SELECT</code></a> does not use
                        <code class="literal">GROUP BY</code>. One side effect is that you
                        must qualify references to nonunique column names.
                    </p><p style="color:blue;">对其他表中列的引用，只要select不使用group by。一个副作用是必须限定对非唯一列名的引用。</p></li></ul>
                </div>
                <p>
                    References to columns from a
                    <a class="link" href="sql-syntax.html#union" title="13.2.9.3&nbsp;UNION Syntax"><code class="literal">UNION</code></a> do not work reliably. To
                    work around this restriction, rewrite the
                    <a class="link" href="sql-syntax.html#union" title="13.2.9.3&nbsp;UNION Syntax"><code class="literal">UNION</code></a> as a derived table so that
                    its rows can be treated as a single-table result set. For
                    example, this statement can produce incorrect results:
                </p><p style="color:blue;">对联合中的列的引用不可靠。若要解决此限制，请将联合重写为派生表，以便将其行视为单个表结果集。例如，此语句可能会产生不正确的结果：</p><pre data-lang="sql" class="programlisting">INSERT INTO t1 (a, b)
  SELECT c, d FROM t2
  UNION
  SELECT e, f FROM t3
ON DUPLICATE KEY UPDATE b = b + c;
</pre><p>
                Instead, use an equivalent statement that rewrites the
                <a class="link" href="sql-syntax.html#union" title="13.2.9.3&nbsp;UNION Syntax"><code class="literal">UNION</code></a> as a derived table:
            </p><p style="color:blue;">相反，请使用等效语句将联合重写为派生表：</p><pre data-lang="sql" class="programlisting">INSERT INTO t1 (a, b)
SELECT * FROM
  (SELECT c, d FROM t2
   UNION
   SELECT e, f FROM t3) AS dt
ON DUPLICATE KEY UPDATE b = b + c;
</pre><p>
                The technique of rewriting a query as a derived table also
                enables references to columns from <code class="literal">GROUP BY</code>
                queries.
            </p><p style="color:blue;">将查询重写为派生表的技术还允许从GROUPBY查询中引用列。</p><p>
                Because the results of
                <a class="link" href="sql-syntax.html#insert-select" title="13.2.5.1&nbsp;INSERT ... SELECT Syntax"><code class="literal">INSERT ...
                    SELECT</code></a> statements depend on the ordering of rows from
                the <a class="link" href="sql-syntax.html#select" title="13.2.9&nbsp;SELECT Syntax"><code class="literal">SELECT</code></a> and this order cannot
                always be guaranteed, it is possible when logging
                <a class="link" href="sql-syntax.html#insert-on-duplicate" title="13.2.5.2&nbsp;INSERT ... ON DUPLICATE KEY UPDATE Syntax"><code class="literal">INSERT ...
                    SELECT ON DUPLICATE KEY UPDATE</code></a> statements for the
                master and the slave to diverge. Thus,
                <a class="link" href="sql-syntax.html#insert-on-duplicate" title="13.2.5.2&nbsp;INSERT ... ON DUPLICATE KEY UPDATE Syntax"><code class="literal">INSERT ...
                    SELECT ON DUPLICATE KEY UPDATE</code></a> statements are flagged
                as unsafe for statement-based replication. Such statements
                produce a warning in the error log when using statement-based
                mode and are written to the binary log using the row-based
                format when using <code class="literal">MIXED</code> mode. An
                <a class="link" href="sql-syntax.html#insert-on-duplicate" title="13.2.5.2&nbsp;INSERT ... ON DUPLICATE KEY UPDATE Syntax"><code class="literal">INSERT ...
                    ON DUPLICATE KEY UPDATE</code></a> statement against a table
                having more than one unique or primary key is also marked as
                unsafe. (Bug #11765650, Bug #58637)
            </p><p style="color:blue;">因为插入的结果…select语句取决于select中的行的顺序，并且不能总是保证这个顺序，当记录insert…为要发散的主从机选择重复的密钥更新语句。因此，插入…对于基于语句的复制，重复密钥更新语句上的“选择”标记为不安全。这种语句在使用基于语句的模式时在错误日志中生成警告，在使用混合模式时使用基于行的格式写入二进制日志。插入…对于具有多个唯一键或主键的表的on duplicate key update语句也标记为不安全。（错误11765650，错误58637）</p><p>
                See also <a class="xref" href="replication.html#replication-sbr-rbr" title="16.2.1.1&nbsp;Advantages and Disadvantages of Statement-Based and Row-Based Replication">Section&nbsp;16.2.1.1, “Advantages and Disadvantages of Statement-Based and Row-Based
                Replication”</a>.
            </p><p style="color:blue;">另见第16.2.1.1节“基于语句和基于行的复制的优缺点”。</p><p>
                An <code class="literal">INSERT ... ON DUPLICATE KEY UPDATE</code> on a
                partitioned table using a storage engine such as
                <a class="link" href="storage-engines.html#myisam-storage-engine" title="15.2&nbsp;The MyISAM Storage Engine"><code class="literal">MyISAM</code></a> that employs table-level
                locks locks any partitions of the table in which a partitioning
                key column is updated. (This does not occur with tables using
                storage engines such as <a class="link" href="innodb-storage-engine.html" title="Chapter&nbsp;14&nbsp;The InnoDB Storage Engine"><code class="literal">InnoDB</code></a> that
                employ row-level locking.) For more information, see
                <a class="xref" href="partitioning.html#partitioning-limitations-locking" title="22.6.4&nbsp;Partitioning and Locking">Section&nbsp;22.6.4, “Partitioning and Locking”</a>.
            </p><p style="color:blue;">插入…使用存储引擎（如myisam，它使用表级锁）对分区表进行重复密钥更新时，会锁定更新分区键列的表的任何分区。（使用存储引擎（如使用行级锁定的innodb）的表不会出现这种情况。）有关更多信息，请参阅22.6.4节“分区和锁定”。</p>
            </div>
            <div class="section">
                <div class="titlepage">
                    <div>
                        <div>
                            <h4 class="title"><a name="insert-delayed"></a>13.2.5.3&nbsp;INSERT DELAYED Syntax</h4>

                        </div>

                    </div>

                </div>
                <a class="indexterm" name="idm140286835759664"></a><a class="indexterm" name="idm140286835758592"></a><a class="indexterm" name="idm140286835757520"></a><pre data-lang="sql" class="programlisting">INSERT DELAYED ...
</pre><p>
                The <code class="literal">DELAYED</code> option for the
                <a class="link" href="sql-syntax.html#insert" title="13.2.5&nbsp;INSERT Syntax"><code class="literal">INSERT</code></a> statement is a MySQL
                extension to standard SQL. In previous versions of MySQL, it can
                be used for certain kinds of tables (such as
                <code class="literal">MyISAM</code>), such that when a client uses
                <a class="link" href="sql-syntax.html#insert-delayed" title="13.2.5.3&nbsp;INSERT DELAYED Syntax"><code class="literal">INSERT DELAYED</code></a>, it gets an okay
                from the server at once, and the row is queued to be inserted
                when the table is not in use by any other thread.
            </p><p style="color:blue;">insert语句的延迟选项是标准sql的mysql扩展。在以前的mysql版本中，它可以用于某些类型的表（比如myisam），这样当客户机使用insert delayed时，它会立即从服务器获得ok，当其他线程不使用该表时，该行将排队等待插入。</p><p>
                <code class="literal">DELAYED</code> inserts and replaces were deprecated
                in MySQL 5.6. In MySQL 5.7,
                <code class="literal">DELAYED</code> is not supported. The server
                recognizes but ignores the <code class="literal">DELAYED</code> keyword,
                handles the insert as a nondelayed insert, and generates an
                <code class="literal">ER_WARN_LEGACY_SYNTAX_CONVERTED</code> warning
                (<span class="quote">“<span class="quote">INSERT DELAYED is no longer supported. The statement was
        converted to INSERT</span>”</span>). The <code class="literal">DELAYED</code>
                keyword is scheduled for removal in a future release.
            </p><p style="color:blue;">mysql 5.6中不推荐使用延迟插入和替换。在mysql 5.7中，不支持延迟。服务器识别但忽略delayed关键字，将insert作为非delayed insert处理，并生成er_warn_legacy_syntax_converted warning（“不再支持insert delayed。语句被转换为insert”）。delayed关键字计划在以后的版本中删除。</p>
            </div>

        </div>
        <div class="section">
            <div class="titlepage">
                <div>
                    <div>
                        <h3 class="title"><a name="load-data"></a>13.2.6&nbsp;LOAD DATA Syntax</h3>

                    </div>

                </div>

            </div>
            <a class="indexterm" name="idm140286835741728"></a><a class="indexterm" name="idm140286835740656"></a><pre data-lang="sql" class="programlisting">LOAD DATA
    [LOW_PRIORITY | CONCURRENT] [LOCAL]
    INFILE '<em class="replaceable"><code>file_name</code></em>'
    [REPLACE | IGNORE]
    INTO TABLE <em class="replaceable"><code>tbl_name</code></em>
    [PARTITION (<em class="replaceable"><code>partition_name</code></em> [, <em class="replaceable"><code>partition_name</code></em>] ...)]
    [CHARACTER SET <em class="replaceable"><code>charset_name</code></em>]
    [{FIELDS | COLUMNS}
        [TERMINATED BY '<em class="replaceable"><code>string</code></em>']
        [[OPTIONALLY] ENCLOSED BY '<em class="replaceable"><code>char</code></em>']
        [ESCAPED BY '<em class="replaceable"><code>char</code></em>']
    ]
    [LINES
        [STARTING BY '<em class="replaceable"><code>string</code></em>']
        [TERMINATED BY '<em class="replaceable"><code>string</code></em>']
    ]
    [IGNORE <em class="replaceable"><code>number</code></em> {LINES | ROWS}]
    [(<em class="replaceable"><code>col_name_or_user_var</code></em>
        [, <em class="replaceable"><code>col_name_or_user_var</code></em>] ...)]
    [SET <em class="replaceable"><code>col_name</code></em>={<em class="replaceable"><code>expr</code></em> | DEFAULT},
        [, <em class="replaceable"><code>col_name</code></em>={<em class="replaceable"><code>expr</code></em> | DEFAULT}] ...]
</pre><p>
            The <a class="link" href="sql-syntax.html#load-data" title="13.2.6&nbsp;LOAD DATA Syntax"><code class="literal">LOAD DATA</code></a> statement reads rows
            from a text file into a table at a very high speed.
            <a class="link" href="sql-syntax.html#load-data" title="13.2.6&nbsp;LOAD DATA Syntax"><code class="literal">LOAD DATA</code></a> is the complement of
            <a class="link" href="sql-syntax.html#select-into" title="13.2.9.1&nbsp;SELECT ... INTO Syntax"><code class="literal">SELECT ... INTO
                OUTFILE</code></a>. (See <a class="xref" href="sql-syntax.html#select-into" title="13.2.9.1&nbsp;SELECT ... INTO Syntax">Section&nbsp;13.2.9.1, “SELECT ... INTO Syntax”</a>.) To write
            data from a table to a file, use
            <a class="link" href="sql-syntax.html#select-into" title="13.2.9.1&nbsp;SELECT ... INTO Syntax"><code class="literal">SELECT ... INTO
                OUTFILE</code></a>. To read the file back into a table, use
            <a class="link" href="sql-syntax.html#load-data" title="13.2.6&nbsp;LOAD DATA Syntax"><code class="literal">LOAD DATA</code></a>. The syntax of the
            <code class="literal">FIELDS</code> and <code class="literal">LINES</code> clauses is
            the same for both statements.
        </p><p style="color:blue;">LOADDATA语句以非常高的速度将文本文件中的行读取到表中。加载数据是选择的补充…进入外岛。（见第13.2.9.1节，“选择……语法为“）要将数据从表写入文件，请使用select…进入外岛。若要将文件读回表中，请使用“加载数据”。fields和lines子句的语法对于这两个语句都是相同的。</p><a class="indexterm" name="idm140286835718768"></a><p>
            You can also load data files by using the
            <a class="link" href="programs.html#mysqlimport" title="4.5.5&nbsp;mysqlimport — A Data Import Program"><span class="command"><strong>mysqlimport</strong></span></a> utility; see
            <a class="xref" href="programs.html#mysqlimport" title="4.5.5&nbsp;mysqlimport — A Data Import Program">Section&nbsp;4.5.5, “<span class="command"><strong>mysqlimport</strong></span> — A Data Import Program”</a>. <a class="link" href="programs.html#mysqlimport" title="4.5.5&nbsp;mysqlimport — A Data Import Program"><span class="command"><strong>mysqlimport</strong></span></a>
            operates by sending a <a class="link" href="sql-syntax.html#load-data" title="13.2.6&nbsp;LOAD DATA Syntax"><code class="literal">LOAD DATA</code></a>
            statement to the server.
        </p><p style="color:blue;">您还可以使用mysqlimport实用程序加载数据文件；请参阅4.5.5节，“mysqlimport-数据导入程序”。mysqlimport通过向服务器发送加载数据语句来操作。</p><p>
            For more information about the efficiency of
            <a class="link" href="sql-syntax.html#insert" title="13.2.5&nbsp;INSERT Syntax"><code class="literal">INSERT</code></a> versus
            <a class="link" href="sql-syntax.html#load-data" title="13.2.6&nbsp;LOAD DATA Syntax"><code class="literal">LOAD DATA</code></a> and speeding up
            <a class="link" href="sql-syntax.html#load-data" title="13.2.6&nbsp;LOAD DATA Syntax"><code class="literal">LOAD DATA</code></a>, see
            <a class="xref" href="optimization.html#insert-optimization" title="8.2.4.1&nbsp;Optimizing INSERT Statements">Section&nbsp;8.2.4.1, “Optimizing INSERT Statements”</a>.
        </p><p style="color:blue;">有关插入与加载数据的效率以及加快加载数据速度的更多信息，请参阅8.2.4.1节“优化插入语句”。</p>
            <div class="itemizedlist">
                <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><a class="xref" href="sql-syntax.html#load-data-partitioning-support" title="Partitioned Table Support">Partitioned Table Support</a></p><p style="color:blue;">分区表支持</p></li><li class="listitem"><p><a class="xref" href="sql-syntax.html#load-data-input-file" title="Input File Name, Location, and Content Interpretation">Input File Name, Location, and Content Interpretation</a></p><p style="color:blue;">输入文件名、位置和内容解释</p></li><li class="listitem"><p><a class="xref" href="sql-syntax.html#load-data-concurrency" title="Concurrency Considerations">Concurrency Considerations</a></p><p style="color:blue;">并发性考虑</p></li><li class="listitem"><p><a class="xref" href="sql-syntax.html#load-data-duplicate-key-handling" title="Duplicate-Key Handling">Duplicate-Key Handling</a></p><p style="color:blue;">重复密钥处理</p></li><li class="listitem"><p><a class="xref" href="sql-syntax.html#load-data-index-handling" title="Index Handling">Index Handling</a></p><p style="color:blue;">索引处理</p></li><li class="listitem"><p><a class="xref" href="sql-syntax.html#load-data-field-line-handling" title="Field and Line Handling">Field and Line Handling</a></p><p style="color:blue;">现场和线路处理</p></li><li class="listitem"><p><a class="xref" href="sql-syntax.html#load-data-column-list" title="Column List Specification">Column List Specification</a></p><p style="color:blue;">列列表规范</p></li><li class="listitem"><p><a class="xref" href="sql-syntax.html#load-data-input-preprocessing" title="Input Preprocessing">Input Preprocessing</a></p><p style="color:blue;">输入预处理</p></li><li class="listitem"><p><a class="xref" href="sql-syntax.html#load-data-statement-result-information" title="Statement Result Information">Statement Result Information</a></p><p style="color:blue;">报表结果信息</p></li><li class="listitem"><p><a class="xref" href="sql-syntax.html#load-data-miscellaneous" title="Miscellaneous Topics">Miscellaneous Topics</a></p><p style="color:blue;">其他主题</p></li></ul>
            </div>

            <div class="simplesect">

                <div class="titlepage">
                    <div>

                        <div class="simple">
                            <h4 class="title"><a name="load-data-partitioning-support"></a>Partitioned Table Support</h4>

                        </div>

                    </div>

                </div>
                <p>
                    <a class="link" href="sql-syntax.html#load-data" title="13.2.6&nbsp;LOAD DATA Syntax"><code class="literal">LOAD DATA</code></a> supports explicit
                    partition selection using the <code class="literal">PARTITION</code>
                    option with a list of one or more comma-separated names of
                    partitions, subpartitions, or both. When this option is used, if
                    any rows from the file cannot be inserted into any of the
                    partitions or subpartitions named in the list, the statement
                    fails with the error <span class="errortext">Found a row not matching the
        given partition set</span>. For more information and
                    examples, see <a class="xref" href="partitioning.html#partitioning-selection" title="22.5&nbsp;Partition Selection">Section&nbsp;22.5, “Partition Selection”</a>.
                </p><p style="color:blue;">加载数据使用分区选项支持显式分区选择，其中包含一个或多个逗号分隔的分区、子分区或两者的名称。使用此选项时，如果无法将文件中的任何行插入到列表中指定的任何分区或子分区中，则语句将失败，错误是找到与给定分区集不匹配的行。有关更多信息和示例，请参见第22.5节“分区选择”。</p><p>
                For partitioned tables using storage engines that employ table
                locks, such as <a class="link" href="storage-engines.html#myisam-storage-engine" title="15.2&nbsp;The MyISAM Storage Engine"><code class="literal">MyISAM</code></a>,
                <a class="link" href="sql-syntax.html#load-data" title="13.2.6&nbsp;LOAD DATA Syntax"><code class="literal">LOAD DATA</code></a> cannot prune any
                partition locks. This does not apply to tables using storage
                engines that employ row-level locking, such as
                <a class="link" href="innodb-storage-engine.html" title="Chapter&nbsp;14&nbsp;The InnoDB Storage Engine"><code class="literal">InnoDB</code></a>. For more information, see
                <a class="xref" href="partitioning.html#partitioning-limitations-locking" title="22.6.4&nbsp;Partitioning and Locking">Section&nbsp;22.6.4, “Partitioning and Locking”</a>.
            </p><p style="color:blue;">对于使用使用表锁的存储引擎（如myisam）的分区表，加载数据无法修剪任何分区锁。这不适用于使用使用行级锁定的存储引擎（如innodb）的表。有关更多信息，请参见第22.6.4节“分区和锁定”。</p>
            </div>
            <div class="simplesect">
                <div class="titlepage">
                    <div>
                        <div class="simple">
                            <h4 class="title"><a name="load-data-input-file"></a>Input File Name, Location, and Content Interpretation</h4>

                        </div>

                    </div>

                </div>
                <p>
                    The file name must be given as a literal string. On Windows,
                    specify backslashes in path names as forward slashes or doubled
                    backslashes. The
                    <a class="link" href="server-administration.html#sysvar_character_set_filesystem"><code class="literal">character_set_filesystem</code></a> system
                    variable controls the interpretation of the file name character
                    set.
                </p><p style="color:blue;">文件名必须以文本字符串形式给出。在Windows上，将路径名中的反斜杠指定为正斜杠或双反斜杠。字符集文件系统变量控制文件名字符集的解释。</p><p>
                The server uses the character set indicated by the
                <a class="link" href="server-administration.html#sysvar_character_set_database"><code class="literal">character_set_database</code></a> system
                variable to interpret the information in the file.
                <a class="link" href="sql-syntax.html#set-names" title="13.7.4.3&nbsp;SET NAMES Syntax"><code class="literal">SET NAMES</code></a> and the setting of
                <a class="link" href="server-administration.html#sysvar_character_set_client"><code class="literal">character_set_client</code></a> do not
                affect interpretation of input. If the contents of the input
                file use a character set that differs from the default, it is
                usually preferable to specify the character set of the file by
                using the <code class="literal">CHARACTER SET</code> clause. A character
                set of <code class="literal">binary</code> specifies <span class="quote">“<span class="quote">no
        conversion.</span>”</span>
            </p><p style="color:blue;">服务器使用字符集数据库系统变量所指示的字符集来解释文件中的信息。设置名称和字符集客户端的设置不影响输入的解释。如果输入文件的内容使用与默认值不同的字符集，通常最好使用character set子句指定文件的字符集。二进制字符集指定“不转换”。</p><p>
                <a class="link" href="sql-syntax.html#load-data" title="13.2.6&nbsp;LOAD DATA Syntax"><code class="literal">LOAD DATA</code></a> interprets all fields
                in the file as having the same character set, regardless of the
                data types of the columns into which field values are loaded.
                For proper interpretation of file contents, you must ensure that
                it was written with the correct character set. For example, if
                you write a data file with <a class="link" href="programs.html#mysqldump" title="4.5.4&nbsp;mysqldump — A Database Backup Program"><span class="command"><strong>mysqldump -T</strong></span></a> or by
                issuing a <a class="link" href="sql-syntax.html#select-into" title="13.2.9.1&nbsp;SELECT ... INTO Syntax"><code class="literal">SELECT
                ... INTO OUTFILE</code></a> statement in
                <a class="link" href="programs.html#mysql" title="4.5.1&nbsp;mysql — The MySQL Command-Line Client"><span class="command"><strong>mysql</strong></span></a>, be sure to use a
                <code class="option">--default-character-set</code> option so that output
                is written in the character set to be used when the file is
                loaded with <a class="link" href="sql-syntax.html#load-data" title="13.2.6&nbsp;LOAD DATA Syntax"><code class="literal">LOAD DATA</code></a>.
            </p><p style="color:blue;">加载数据将文件中的所有字段解释为具有相同的字符集，而不考虑加载字段值的列的数据类型。要正确解释文件内容，必须确保使用正确的字符集编写。例如，如果使用mysqldump-t或通过发出select命令来编写数据文件…在mysql的outfile语句中，请确保使用--default字符集选项，以便将输出写入加载数据时要使用的字符集中。</p>
                <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">

                    <div class="admon-title">
                        Note
                    </div>
                    <p>
                        It is not possible to load data files that use the
                        <code class="literal">ucs2</code>, <code class="literal">utf16</code>,
                        <code class="literal">utf16le</code>, or <code class="literal">utf32</code>
                        character set.
                    </p><p style="color:blue;">无法加载使用ucs2、utf16、utf16le或utf32字符集的数据文件。</p>
                </div>

            </div>
            <div class="simplesect">
                <div class="titlepage">
                    <div>
                        <div class="simple">
                            <h4 class="title"><a name="load-data-concurrency"></a>Concurrency Considerations</h4>

                        </div>

                    </div>

                </div>
                <p>
                    If you use the <code class="literal">LOW_PRIORITY</code> modifier,
                    execution of the <a class="link" href="sql-syntax.html#load-data" title="13.2.6&nbsp;LOAD DATA Syntax"><code class="literal">LOAD DATA</code></a>
                    statement is delayed until no other clients are reading from the
                    table. This affects only storage engines that use only
                    table-level locking (such as <code class="literal">MyISAM</code>,
                    <code class="literal">MEMORY</code>, and <code class="literal">MERGE</code>).
                </p><p style="color:blue;">如果使用low_priority修饰符，则load data语句的执行将被延迟，直到没有其他客户端从表中读取数据为止。这只影响只使用表级锁定的存储引擎（例如myisam、内存和合并）。</p><p>
                If you specify the <code class="literal">CONCURRENT</code> modifier with a
                <code class="literal">MyISAM</code> table that satisfies the condition for
                concurrent inserts (that is, it contains no free blocks in the
                middle), other threads can retrieve data from the table while
                <a class="link" href="sql-syntax.html#load-data" title="13.2.6&nbsp;LOAD DATA Syntax"><code class="literal">LOAD DATA</code></a> is executing. This
                modifier affects the performance of <a class="link" href="sql-syntax.html#load-data" title="13.2.6&nbsp;LOAD DATA Syntax"><code class="literal">LOAD
                DATA</code></a> a bit, even if no other thread is using the table
                at the same time.
            </p><p style="color:blue;">如果使用满足并发插入条件的myisam表指定concurrent修饰符（即中间不包含空闲块），则其他线程可以在执行load data时从表中检索数据。即使没有其他线程同时使用表，此修饰符也会稍微影响加载数据的性能。</p><p>
                For information about <a class="link" href="sql-syntax.html#load-data" title="13.2.6&nbsp;LOAD DATA Syntax"><code class="literal">LOAD DATA</code></a>
                in relation to replication, see
                <a class="xref" href="replication.html#replication-features-load-data" title="16.4.1.18&nbsp;Replication and LOAD DATA">Section&nbsp;16.4.1.18, “Replication and LOAD DATA”</a>.
            </p><p style="color:blue;">有关与复制相关的加载数据的信息，请参阅第16.4.1.18节“复制和加载数据”。</p><p>
                The <code class="literal">LOCAL</code> modifier affects expected location
                of the file and error handling, as described later.
                <code class="literal">LOCAL</code> works only if your server and your
                client both have been configured to permit it. For example, if
                <a class="link" href="programs.html#mysqld" title="4.3.1&nbsp;mysqld — The MySQL Server"><span class="command"><strong>mysqld</strong></span></a> was started with the
                <a class="link" href="server-administration.html#sysvar_local_infile"><code class="literal">local_infile</code></a> system variable
                disabled, <code class="literal">LOCAL</code> does not work. See
                <a class="xref" href="security.html#load-data-local" title="6.1.6&nbsp;Security Issues with LOAD DATA LOCAL">Section&nbsp;6.1.6, “Security Issues with LOAD DATA LOCAL”</a>.
            </p><p style="color:blue;">局部修饰符影响文件的预期位置和错误处理，如后文所述。只有当您的服务器和客户机都配置为允许时，本地才起作用。例如，如果mysqld在启动时禁用了local_infile系统变量，则local不起作用。见第6.1.6节“本地加载数据的安全问题”。</p><p>
                The <code class="literal">LOCAL</code> modifier affects where the file is
                expected to be found:
            </p><p style="color:blue;">本地修饰符影响文件的预期位置：</p>
                <div class="itemizedlist">
                    <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                        If <code class="literal">LOCAL</code> is specified, the file is read
                        by the client program on the client host and sent to the
                        server. The file can be given as a full path name to specify
                        its exact location. If given as a relative path name, the
                        name is interpreted relative to the directory in which the
                        client program was started.
                    </p><p style="color:blue;">如果指定了local，则客户端主机上的客户端程序将读取该文件并将其发送到服务器。文件可以作为完整路径名来指定其确切位置。如果指定为相对路径名，则该名称将相对于启动客户端程序的目录进行解释。</p><p>
                        When using <code class="literal">LOCAL</code> with
                        <a class="link" href="sql-syntax.html#load-data" title="13.2.6&nbsp;LOAD DATA Syntax"><code class="literal">LOAD DATA</code></a>, a copy of the file
                        is created in the directory where the MySQL server stores
                        temporary files. See <a class="xref" href="error-handling.html#temporary-files" title="B.4.3.5&nbsp;Where MySQL Stores Temporary Files">Section&nbsp;B.4.3.5, “Where MySQL Stores Temporary Files”</a>. Lack
                        of sufficient space for the copy in this directory can cause
                        the <a class="link" href="sql-syntax.html#load-data" title="13.2.6&nbsp;LOAD DATA Syntax"><code class="literal">LOAD DATA
                        LOCAL</code></a> statement to fail.
                    </p><p style="color:blue;">使用本地加载数据时，将在mysql服务器存储临时文件的目录中创建文件的副本。参见第B.4.3.5节，“MySQL存储临时文件的位置”。此目录中没有足够的空间用于复制，可能会导致LOAD DATA LOCAL语句失败。</p></li><li class="listitem"><p>
                        If <code class="literal">LOCAL</code> is not specified, the file must
                        be located on the server host and is read directly by the
                        server. The server uses the following rules to locate the
                        file:
                    </p><p style="color:blue;">如果未指定local，则文件必须位于服务器主机上，并由服务器直接读取。服务器使用以下规则来定位文件：</p>
                        <div class="itemizedlist">
                            <ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
                                If the file name is an absolute path name, the server
                                uses it as given.
                            </p><p style="color:blue;">如果文件名是绝对路径名，服务器将按给定方式使用它。</p></li><li class="listitem"><p>
                                If the file name is a relative path name with one or
                                more leading components, the server searches for the
                                file relative to the server's data directory.
                            </p><p style="color:blue;">如果文件名是具有一个或多个前导组件的相对路径名，则服务器将搜索相对于服务器数据目录的文件。</p></li><li class="listitem"><p>
                                If a file name with no leading components is given, the
                                server looks for the file in the database directory of
                                the default database.
                            </p><p style="color:blue;">如果给定的文件名没有前导组件，服务器将在默认数据库的数据库目录中查找该文件。</p></li></ul>
                        </div>
                    </li></ul>
                </div>
                <p>
                    In the non-<code class="literal">LOCAL</code> case, these rules mean that
                    a file named as <code class="filename">./myfile.txt</code> is read from
                    the server's data directory, whereas the file named as
                    <code class="filename">myfile.txt</code> is read from the database
                    directory of the default database. For example, if
                    <code class="literal">db1</code> is the default database, the following
                    <a class="link" href="sql-syntax.html#load-data" title="13.2.6&nbsp;LOAD DATA Syntax"><code class="literal">LOAD DATA</code></a> statement reads the
                    file <code class="filename">data.txt</code> from the database directory
                    for <code class="literal">db1</code>, even though the statement explicitly
                    loads the file into a table in the <code class="literal">db2</code>
                    database:
                </p><p style="color:blue;">在非本地情况下，这些规则意味着从服务器的数据目录中读取名为./myfile.txt的文件，而从默认数据库的数据库目录中读取名为myfile.txt的文件。例如，如果db1是默认数据库，那么下面的load data语句将从db1的数据库目录中读取data.txt文件，即使该语句显式地将该文件加载到db2数据库的表中：</p><pre data-lang="sql" class="programlisting">LOAD DATA INFILE 'data.txt' INTO TABLE db2.my_table;
</pre><p>
                Non-<code class="literal">LOCAL</code> load operations read text files
                located on the server. For security reasons, such operations
                require that you have the <a class="link" href="security.html#priv_file"><code class="literal">FILE</code></a>
                privilege. See <a class="xref" href="security.html#privileges-provided" title="6.2.2&nbsp;Privileges Provided by MySQL">Section&nbsp;6.2.2, “Privileges Provided by MySQL”</a>. Also,
                non-<code class="literal">LOCAL</code> load operations are subject to the
                <a class="link" href="server-administration.html#sysvar_secure_file_priv"><code class="literal">secure_file_priv</code></a> system
                variable setting. If the variable value is a nonempty directory
                name, the file to be loaded must be located in that directory.
                If the variable value is empty (which is insecure), the file
                need only be readable by the server.
            </p><p style="color:blue;">非本地加载操作读取服务器上的文本文件。出于安全原因，此类操作要求您具有文件权限。见第6.2.2节“MySQL提供的特权”。此外，非本地加载操作受secure_file_priv系统变量设置的约束。如果变量值是非空目录名，则要加载的文件必须位于该目录中。如果变量值为空（这是不安全的），则服务器只需要读取该文件。</p><p>
                Using <code class="literal">LOCAL</code> is a bit slower than letting the
                server access the files directly, because the file contents must
                be sent over the connection by the client to the server. On the
                other hand, you do not need the
                <a class="link" href="security.html#priv_file"><code class="literal">FILE</code></a> privilege to load local
                files.
            </p><p style="color:blue;">使用本地比让服务器直接访问文件慢一点，因为客户端必须通过连接将文件内容发送到服务器。另一方面，您不需要文件特权来加载本地文件。</p><p>
                <code class="literal">LOCAL</code> also affects error handling:
            </p><p style="color:blue;">本地也会影响错误处理：</p>
                <div class="itemizedlist">
                    <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                        With <a class="link" href="sql-syntax.html#load-data" title="13.2.6&nbsp;LOAD DATA Syntax"><code class="literal">LOAD DATA</code></a>,
                        data-interpretation and duplicate-key errors terminate the
                        operation.
                    </p><p style="color:blue;">在加载数据时，数据解释和重复键错误会终止操作。</p></li><li class="listitem"><p>
                        With <a class="link" href="sql-syntax.html#load-data" title="13.2.6&nbsp;LOAD DATA Syntax"><code class="literal">LOAD DATA
                        LOCAL</code></a>, data-interpretation and duplicate-key
                        errors become warnings and the operation continues because
                        the server has no way to stop transmission of the file in
                        the middle of the operation. For duplicate-key errors, this
                        is the same as if <code class="literal">IGNORE</code> is specified.
                        <code class="literal">IGNORE</code> is explained further later in this
                        section.
                    </p><p style="color:blue;">在本地加载数据的情况下，由于服务器无法在操作过程中停止文件传输，数据解释和重复密钥错误将成为警告，并且操作将继续。对于重复键错误，这与指定ignore相同。忽略将在本节后面进一步解释。</p></li></ul>
                </div>

            </div>
            <div class="simplesect">
                <div class="titlepage">
                    <div>
                        <div class="simple">
                            <h4 class="title"><a name="load-data-duplicate-key-handling"></a>Duplicate-Key Handling</h4>

                        </div>

                    </div>

                </div>
                <p>
                    The <code class="literal">REPLACE</code> and <code class="literal">IGNORE</code>
                    modifiers control handling of input rows that duplicate existing
                    rows on unique key values:
                </p><p style="color:blue;">替换和忽略修饰符控制对在唯一键值上复制现有行的输入行的处理：</p>
                <div class="itemizedlist">
                    <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                        If you specify <code class="literal">REPLACE</code>, input rows
                        replace existing rows. In other words, rows that have the
                        same value for a primary key or unique index as an existing
                        row. See <a class="xref" href="sql-syntax.html#replace" title="13.2.8&nbsp;REPLACE Syntax">Section&nbsp;13.2.8, “REPLACE Syntax”</a>.
                    </p><p style="color:blue;">如果指定替换，输入行替换现有行。换句话说，对于主键或唯一索引具有相同值的行作为现有行。见第13.2.8节“替换语法”。</p></li><li class="listitem"><p>
                        If you specify <code class="literal">IGNORE</code>, rows that
                        duplicate an existing row on a unique key value are
                        discarded. For more information, see
                        <a class="xref" href="server-administration.html#ignore-strict-comparison" title="Comparison of the IGNORE Keyword and Strict SQL Mode">Comparison of the IGNORE Keyword and Strict SQL Mode</a>.
                    </p><p style="color:blue;">如果指定“忽略”，则丢弃在唯一键值上复制现有行的行。有关详细信息，请参阅ignore关键字和strict sql模式的比较。</p><a class="indexterm" name="idm140286835602064"></a></li><li class="listitem"><p>
                        If you do not specify either modifier, the behavior depends
                        on whether the <code class="literal">LOCAL</code> modifier is
                        specified. Without <code class="literal">LOCAL</code>, an error occurs
                        when a duplicate key value is found, and the rest of the
                        text file is ignored. With <code class="literal">LOCAL</code>, the
                        default behavior is the same as if <code class="literal">IGNORE</code>
                        is specified; this is because the server has no way to stop
                        transmission of the file in the middle of the operation.
                    </p><p style="color:blue;">如果未指定任何一个修饰符，则行为取决于是否指定了本地修饰符。如果不使用local，则在找到重复的键值时出错，并且忽略文本文件的其余部分。对于local，默认行为与指定ignore相同；这是因为服务器无法在操作过程中停止文件的传输。</p></li></ul>
                </div>

            </div>
            <div class="simplesect">
                <div class="titlepage">
                    <div>
                        <div class="simple">
                            <h4 class="title"><a name="load-data-index-handling"></a>Index Handling</h4>

                        </div>

                    </div>

                </div>
                <p>
                    To ignore foreign key constraints during the load operation,
                    execute a <code class="literal">SET foreign_key_checks = 0</code>
                    statement before executing <a class="link" href="sql-syntax.html#load-data" title="13.2.6&nbsp;LOAD DATA Syntax"><code class="literal">LOAD
                    DATA</code></a>.
                </p><p style="color:blue;">若要在加载操作期间忽略外键约束，请在执行加载数据之前执行set foreign_key_checks=0语句。</p><p>
                If you use <a class="link" href="sql-syntax.html#load-data" title="13.2.6&nbsp;LOAD DATA Syntax"><code class="literal">LOAD DATA</code></a> on an empty
                <code class="literal">MyISAM</code> table, all nonunique indexes are
                created in a separate batch (as for <a class="link" href="sql-syntax.html#repair-table" title="13.7.2.5&nbsp;REPAIR TABLE Syntax"><code class="literal">REPAIR
                TABLE</code></a>). Normally, this makes <a class="link" href="sql-syntax.html#load-data" title="13.2.6&nbsp;LOAD DATA Syntax"><code class="literal">LOAD
                DATA</code></a> much faster when you have many indexes. In some
                extreme cases, you can create the indexes even faster by turning
                them off with <a class="link" href="sql-syntax.html#alter-table" title="13.1.8&nbsp;ALTER TABLE Syntax"><code class="literal">ALTER
                TABLE ... DISABLE KEYS</code></a> before loading the file into
                the table and using
                <a class="link" href="sql-syntax.html#alter-table" title="13.1.8&nbsp;ALTER TABLE Syntax"><code class="literal">ALTER TABLE ...
                    ENABLE KEYS</code></a> to re-create the indexes after loading the
                file. See <a class="xref" href="optimization.html#insert-optimization" title="8.2.4.1&nbsp;Optimizing INSERT Statements">Section&nbsp;8.2.4.1, “Optimizing INSERT Statements”</a>.
            </p><p style="color:blue;">如果对空的myisam表使用加载数据，则所有非唯一索引都将在单独的批处理中创建（对于修复表）。通常，当您有许多索引时，这会使加载数据更快。在某些极端情况下，可以通过使用alter table关闭索引来更快地创建索引…在将文件加载到表中并使用alter table之前禁用键…启用密钥以在加载文件后重新创建索引。见第8.2.4.1节“优化插入语句”。</p>
            </div>
            <div class="simplesect">
                <div class="titlepage">
                    <div>
                        <div class="simple">
                            <h4 class="title"><a name="load-data-field-line-handling"></a>Field and Line Handling</h4>

                        </div>

                    </div>

                </div>
                <p>
                    For both the <a class="link" href="sql-syntax.html#load-data" title="13.2.6&nbsp;LOAD DATA Syntax"><code class="literal">LOAD DATA</code></a> and
                    <a class="link" href="sql-syntax.html#select-into" title="13.2.9.1&nbsp;SELECT ... INTO Syntax"><code class="literal">SELECT ... INTO
                        OUTFILE</code></a> statements, the syntax of the
                    <code class="literal">FIELDS</code> and <code class="literal">LINES</code> clauses
                    is the same. Both clauses are optional, but
                    <code class="literal">FIELDS</code> must precede <code class="literal">LINES</code>
                    if both are specified.
                </p><p style="color:blue;">对于加载数据和选择…在outfile语句中，fields和lines子句的语法是相同的。这两个子句都是可选的，但如果同时指定了这两个子句，则字段必须位于行之前。</p><p>
                If you specify a <code class="literal">FIELDS</code> clause, each of its
                subclauses (<code class="literal">TERMINATED BY</code>,
                <code class="literal">[OPTIONALLY] ENCLOSED BY</code>, and
                <code class="literal">ESCAPED BY</code>) is also optional, except that you
                must specify at least one of them. Arguments to these clauses
                are permitted to contain only ASCII characters.
            </p><p style="color:blue;">如果指定了fields子句，则它的每个子子句（以[可选]结尾，由括起来，由转义）也是可选的，但必须至少指定其中一个。这些子句的参数只允许包含ascii字符。</p><p>
                If you specify no <code class="literal">FIELDS</code> or
                <code class="literal">LINES</code> clause, the defaults are the same as if
                you had written this:
            </p><p style="color:blue;">如果未指定字段或行子句，则默认值与编写此语句时相同：</p><pre data-lang="sql" class="programlisting">FIELDS TERMINATED BY '\t' ENCLOSED BY '' ESCAPED BY '\\'
LINES TERMINATED BY '\n' STARTING BY ''
</pre><p>
                Backslash is the MySQL escape character within strings in SQL
                statements. Thus, to specify a literal backslash, you must
                specify two backslashes for the value to be interpreted as a
                single backslash. The escape sequences <code class="literal">'\t'</code>
                and <code class="literal">'\n'</code> specify tab and newline characters,
                respectively.
            </p><p style="color:blue;">反斜杠是sql语句字符串中的mysql转义字符。因此，要指定文字反斜杠，必须指定两个反斜杠才能将值解释为单个反斜杠。转义序列'\t'和'\n'分别指定制表符和换行符。</p><p>
                In other words, the defaults cause <a class="link" href="sql-syntax.html#load-data" title="13.2.6&nbsp;LOAD DATA Syntax"><code class="literal">LOAD
                DATA</code></a> to act as follows when reading input:
            </p><p style="color:blue;">换言之，默认值使加载数据在读取输入时按如下方式工作：</p>
                <div class="itemizedlist">
                    <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                        Look for line boundaries at newlines.
                    </p><p style="color:blue;">在换行符处查找行边界。</p></li><li class="listitem"><p>
                        Do not skip any line prefix.
                    </p><p style="color:blue;">不要跳过任何行前缀。</p></li><li class="listitem"><p>
                        Break lines into fields at tabs.
                    </p><p style="color:blue;">在制表符处将行拆分为字段。</p></li><li class="listitem"><p>
                        Do not expect fields to be enclosed within any quoting
                        characters.
                    </p><p style="color:blue;">不要期望字段包含在任何引用字符中。</p></li><li class="listitem"><p>
                        Interpret characters preceded by the escape character
                        <code class="literal">\</code> as escape sequences. For example,
                        <code class="literal">\t</code>, <code class="literal">\n</code>, and
                        <code class="literal">\\</code> signify tab, newline, and backslash,
                        respectively. See the discussion of <code class="literal">FIELDS ESCAPED
                        BY</code> later for the full list of escape sequences.
                    </p><p style="color:blue;">将转义字符前面的字符解释为转义序列。例如，分别表示制表符、换行符和反斜杠。有关转义序列的完整列表，请参阅稍后转义字段的讨论。</p></li></ul>
                </div>
                <p>
                    Conversely, the defaults cause
                    <a class="link" href="sql-syntax.html#select-into" title="13.2.9.1&nbsp;SELECT ... INTO Syntax"><code class="literal">SELECT ... INTO
                        OUTFILE</code></a> to act as follows when writing output:
                </p><p style="color:blue;">相反，默认值导致选择…写入输出文件时执行以下操作：</p>
                <div class="itemizedlist">
                    <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                        Write tabs between fields.
                    </p><p style="color:blue;">在字段之间写制表符。</p></li><li class="listitem"><p>
                        Do not enclose fields within any quoting characters.
                    </p><p style="color:blue;">不要将字段括在任何引号内。</p></li><li class="listitem"><p>
                        Use <code class="literal">\</code> to escape instances of tab,
                        newline, or <code class="literal">\</code> that occur within field
                        values.
                    </p><p style="color:blue;">使用\转义出现在字段值中的制表符、换行符或\的实例。</p></li><li class="listitem"><p>
                        Write newlines at the ends of lines.
                    </p><p style="color:blue;">在每行的末尾写新行。</p></li></ul>
                </div>
                <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">
                    <div class="admon-title">
                        Note
                    </div>
                    <p>
                        For a text file generated on a Windows system, proper file
                        reading might require <code class="literal">LINES TERMINATED BY
                        '\r\n'</code> because Windows programs typically use two
                        characters as a line terminator. Some programs, such as
                        <span class="command"><strong>WordPad</strong></span>, might use <code class="literal">\r</code> as
                        a line terminator when writing files. To read such files, use
                        <code class="literal">LINES TERMINATED BY '\r'</code>.
                    </p><p style="color:blue;">对于在Windows系统上生成的文本文件，正确的文件读取可能需要以“\r\n”结尾的行，因为Windows程序通常使用两个字符作为行结束符。某些程序（如写字板）在写入文件时可能会将\r用作行结束符。若要读取此类文件，请使用以“\r”结尾的行。</p>
                </div>
                <p>
                    If all the input lines have a common prefix that you want to
                    ignore, you can use <code class="literal">LINES STARTING BY
                    '<em class="replaceable"><code>prefix_string</code></em>'</code> to skip the
                    prefix <span class="emphasis"><em>and anything before it</em></span>. If a line
                    does not include the prefix, the entire line is skipped. Suppose
                    that you issue the following statement:
                </p><p style="color:blue;">如果所有输入行都有一个要忽略的公共前缀，则可以使用以“prefix_string”开头的行跳过前缀及其前面的任何内容。如果一行不包含前缀，则跳过整行。假设您发出以下语句：</p><pre data-lang="sql" class="programlisting">LOAD DATA INFILE '/tmp/test.txt' INTO TABLE test
  FIELDS TERMINATED BY ','  LINES STARTING BY 'xxx';
</pre><p>
                If the data file looks like this:
            </p><p style="color:blue;">如果数据文件如下所示：</p><pre data-lang="none" class="programlisting">xxx"abc",1
something xxx"def",2
"ghi",3
</pre><p>
                The resulting rows will be <code class="literal">("abc",1)</code> and
                <code class="literal">("def",2)</code>. The third row in the file is
                skipped because it does not contain the prefix.
            </p><p style="color:blue;">结果行将是（“abc”，1）和（“def”，2）。文件中的第三行被跳过，因为它不包含前缀。</p><p>
                The <code class="literal">IGNORE <em class="replaceable"><code>number</code></em>
                LINES</code> option can be used to ignore lines at the start
                of the file. For example, you can use <code class="literal">IGNORE 1
                LINES</code> to skip an initial header line containing column
                names:
            </p><p style="color:blue;">“忽略数字行”选项可用于忽略文件开头的行。例如，可以使用“忽略1行”跳过包含列名的初始标题行：</p><pre data-lang="sql" class="programlisting">LOAD DATA INFILE '/tmp/test.txt' INTO TABLE test IGNORE 1 LINES;
</pre><p>
                When you use <a class="link" href="sql-syntax.html#select-into" title="13.2.9.1&nbsp;SELECT ... INTO Syntax"><code class="literal">SELECT
                ... INTO OUTFILE</code></a> in tandem with
                <a class="link" href="sql-syntax.html#load-data" title="13.2.6&nbsp;LOAD DATA Syntax"><code class="literal">LOAD DATA</code></a> to write data from a
                database into a file and then read the file back into the
                database later, the field- and line-handling options for both
                statements must match. Otherwise, <a class="link" href="sql-syntax.html#load-data" title="13.2.6&nbsp;LOAD DATA Syntax"><code class="literal">LOAD
                DATA</code></a> will not interpret the contents of the file
                properly. Suppose that you use
                <a class="link" href="sql-syntax.html#select-into" title="13.2.9.1&nbsp;SELECT ... INTO Syntax"><code class="literal">SELECT ... INTO
                    OUTFILE</code></a> to write a file with fields delimited by
                commas:
            </p><p style="color:blue;">当你使用选择…in to outfile与load data一起将数据从数据库写入文件，然后稍后将文件读回数据库，这两个语句的字段和行处理选项必须匹配。否则，加载数据将无法正确解释文件的内容。假设您使用select…写入outfile以逗号分隔字段的文件：</p><pre data-lang="sql" class="programlisting">SELECT * INTO OUTFILE 'data.txt'
  FIELDS TERMINATED BY ','
  FROM table2;
</pre><p>
                To read the comma-delimited file, the correct statement would
                be:
            </p><p style="color:blue;">要读取逗号分隔的文件，正确的语句是：</p><pre data-lang="sql" class="programlisting">LOAD DATA INFILE 'data.txt' INTO TABLE table2
  FIELDS TERMINATED BY ',';
</pre><p>
                If instead you tried to read the file with the statement shown
                following, it wouldn't work because it instructs
                <a class="link" href="sql-syntax.html#load-data" title="13.2.6&nbsp;LOAD DATA Syntax"><code class="literal">LOAD DATA</code></a> to look for tabs
                between fields:
            </p><p style="color:blue;">如果您试图使用下面显示的语句读取文件，它将不起作用，因为它指示加载数据在字段之间查找制表符：</p><pre data-lang="sql" class="programlisting">LOAD DATA INFILE 'data.txt' INTO TABLE table2
  FIELDS TERMINATED BY '\t';
</pre><p>
                The likely result is that each input line would be interpreted
                as a single field.
            </p><p style="color:blue;">可能的结果是，每个输入行将被解释为单个字段。</p><a class="indexterm" name="idm140286835526160"></a><a class="indexterm" name="idm140286835525088"></a><p>
                <a class="link" href="sql-syntax.html#load-data" title="13.2.6&nbsp;LOAD DATA Syntax"><code class="literal">LOAD DATA</code></a> can be used to read
                files obtained from external sources. For example, many programs
                can export data in comma-separated values (CSV) format, such
                that lines have fields separated by commas and enclosed within
                double quotation marks, with an initial line of column names. If
                the lines in such a file are terminated by carriage
                return/newline pairs, the statement shown here illustrates the
                field- and line-handling options you would use to load the file:
            </p><p style="color:blue;">加载数据可用于读取从外部源获取的文件。例如，许多程序可以以逗号分隔值（CSV）格式导出数据，这样行中的字段就用逗号分隔，并用双引号括起来，并带有列名的初始行。如果此类文件中的行由回车/换行符对终止，则此处显示的语句演示了用于加载文件的字段和行处理选项：</p><pre data-lang="sql" class="programlisting">LOAD DATA INFILE 'data.txt' INTO TABLE <em class="replaceable"><code>tbl_name</code></em>
  FIELDS TERMINATED BY ',' ENCLOSED BY '"'
  LINES TERMINATED BY '\r\n'
  IGNORE 1 LINES;
</pre><p>
                If the input values are not necessarily enclosed within
                quotation marks, use <code class="literal">OPTIONALLY</code> before the
                <code class="literal">ENCLOSED BY</code> option.
            </p><p style="color:blue;">如果输入值不必括在引号中，请在“括起方式”选项之前选择使用。</p><p>
                Any of the field- or line-handling options can specify an empty
                string (<code class="literal">''</code>). If not empty, the
                <code class="literal">FIELDS [OPTIONALLY] ENCLOSED BY</code> and
                <code class="literal">FIELDS ESCAPED BY</code> values must be a single
                character. The <code class="literal">FIELDS TERMINATED BY</code>,
                <code class="literal">LINES STARTING BY</code>, and <code class="literal">LINES
                TERMINATED BY</code> values can be more than one character.
                For example, to write lines that are terminated by carriage
                return/linefeed pairs, or to read a file containing such lines,
                specify a <code class="literal">LINES TERMINATED BY '\r\n'</code> clause.
            </p><p style="color:blue;">任何字段或行处理选项都可以指定空字符串（''）。如果不为空，由值括起的字段[可选]和由值转义的字段必须是单个字符。以值结尾的字段、以值开头的行和以值结尾的行可以是多个字符。例如，若要写入由回车/换行符对终止的行，或读取包含此类行的文件，请指定由“\r\n”子句终止的行。</p><p>
                To read a file containing jokes that are separated by lines
                consisting of <code class="literal">%%</code>, you can do this
            </p><p style="color:blue;">要读取一个包含笑话的文件，笑话之间用由百分数组成的行分隔，可以执行以下操作</p><pre data-lang="sql" class="programlisting">CREATE TABLE jokes
  (a INT NOT NULL AUTO_INCREMENT PRIMARY KEY,
  joke TEXT NOT NULL);
LOAD DATA INFILE '/tmp/jokes.txt' INTO TABLE jokes
  FIELDS TERMINATED BY ''
  LINES TERMINATED BY '\n%%\n' (joke);
</pre><p>
                <code class="literal">FIELDS [OPTIONALLY] ENCLOSED BY</code> controls
                quoting of fields. For output
                (<a class="link" href="sql-syntax.html#select-into" title="13.2.9.1&nbsp;SELECT ... INTO Syntax"><code class="literal">SELECT ... INTO
                OUTFILE</code></a>), if you omit the word
                <code class="literal">OPTIONALLY</code>, all fields are enclosed by the
                <code class="literal">ENCLOSED BY</code> character. An example of such
                output (using a comma as the field delimiter) is shown here:
            </p><p style="color:blue;">字段[可选]由引用字段的控件括起。对于输出（选择…如果您有选择地省略该单词，则所有字段都将由字符括起。这样的输出示例（使用逗号作为字段分隔符）如下所示：</p><pre data-lang="none" class="programlisting">"1","a string","100.20"
"2","a string containing a , comma","102.20"
"3","a string containing a \" quote","102.20"
"4","a string containing a \", quote and comma","102.20"
</pre><p>
                If you specify <code class="literal">OPTIONALLY</code>, the
                <code class="literal">ENCLOSED BY</code> character is used only to enclose
                values from columns that have a string data type (such as
                <a class="link" href="data-types.html#char" title="11.4.1&nbsp;The CHAR and VARCHAR Types"><code class="literal">CHAR</code></a>,
                <a class="link" href="data-types.html#binary-varbinary" title="11.4.2&nbsp;The BINARY and VARBINARY Types"><code class="literal">BINARY</code></a>,
                <a class="link" href="data-types.html#blob" title="11.4.3&nbsp;The BLOB and TEXT Types"><code class="literal">TEXT</code></a>, or
                <a class="link" href="data-types.html#enum" title="11.4.4&nbsp;The ENUM Type"><code class="literal">ENUM</code></a>):
            </p><p style="color:blue;">如果可以选择指定，则“由字符括起”仅用于括起具有字符串数据类型（例如char、binary、text或enum）的列中的值：</p><pre data-lang="none" class="programlisting">1,"a string",100.20
2,"a string containing a , comma",102.20
3,"a string containing a \" quote",102.20
4,"a string containing a \", quote and comma",102.20
</pre><p>
                Occurrences of the <code class="literal">ENCLOSED BY</code> character
                within a field value are escaped by prefixing them with the
                <code class="literal">ESCAPED BY</code> character. Also, if you specify an
                empty <code class="literal">ESCAPED BY</code> value, it is possible to
                inadvertently generate output that cannot be read properly by
                <a class="link" href="sql-syntax.html#load-data" title="13.2.6&nbsp;LOAD DATA Syntax"><code class="literal">LOAD DATA</code></a>. For example, the
                preceding output just shown would appear as follows if the
                escape character is empty. Observe that the second field in the
                fourth line contains a comma following the quote, which
                (erroneously) appears to terminate the field:
            </p><p style="color:blue;">在字段值中用字符包围的发生是通过用FILE字符预先修复它们来实现的。此外，如果指定空的按值转义，则可能会无意中生成加载数据无法正确读取的输出。例如，如果转义符为空，刚才显示的前面的输出将如下所示。请注意，第四行的第二个字段在引号后面包含一个逗号，该逗号（错误地）似乎终止了该字段：</p><pre data-lang="none" class="programlisting">1,"a string",100.20
2,"a string containing a , comma",102.20
3,"a string containing a " quote",102.20
4,"a string containing a ", quote and comma",102.20
</pre><p>
                For input, the <code class="literal">ENCLOSED BY</code> character, if
                present, is stripped from the ends of field values. (This is
                true regardless of whether <code class="literal">OPTIONALLY</code> is
                specified; <code class="literal">OPTIONALLY</code> has no effect on input
                interpretation.) Occurrences of the <code class="literal">ENCLOSED
                BY</code> character preceded by the <code class="literal">ESCAPED
                BY</code> character are interpreted as part of the current
                field value.
            </p><p style="color:blue;">对于输入，由字符括起的（如果存在）将从字段值的末尾剥离。（无论是否指定了可选，这都是正确的；可选地对输入解释没有影响。）出现的前接转义字符的被包围字符将被解释为当前字段值的一部分。</p><p>
                If the field begins with the <code class="literal">ENCLOSED BY</code>
                character, instances of that character are recognized as
                terminating a field value only if followed by the field or line
                <code class="literal">TERMINATED BY</code> sequence. To avoid ambiguity,
                occurrences of the <code class="literal">ENCLOSED BY</code> character
                within a field value can be doubled and are interpreted as a
                single instance of the character. For example, if
                <code class="literal">ENCLOSED BY '"'</code> is specified, quotation marks
                are handled as shown here:
            </p><p style="color:blue;">如果字段以由字符括起的开头，则只有在后跟由序列终止的字段或行时，该字符的实例才会被识别为终止字段值。为了避免歧义，可以将字段值中出现的由字符括起的事件加倍，并将其解释为字符的单个实例。例如，如果指定了由“”括起，则按如下所示处理引号：</p><pre data-lang="none" class="programlisting">"The ""BIG"" boss"  -&gt; The "BIG" boss
The "BIG" boss      -&gt; The "BIG" boss
The ""BIG"" boss    -&gt; The ""BIG"" boss
</pre><p>
                <code class="literal">FIELDS ESCAPED BY</code> controls how to read or
                write special characters:
            </p><p style="color:blue;">由控件转义的字段如何读取或写入特殊字符：</p>
                <div class="itemizedlist">
                    <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                        For input, if the <code class="literal">FIELDS ESCAPED BY</code>
                        character is not empty, occurrences of that character are
                        stripped and the following character is taken literally as
                        part of a field value. Some two-character sequences that are
                        exceptions, where the first character is the escape
                        character. These sequences are shown in the following table
                        (using <code class="literal">\</code> for the escape character). The
                        rules for <code class="literal">NULL</code> handling are described
                        later in this section.
                    </p><p style="color:blue;">对于输入，如果按字符转义的字段不为空，则将删除该字符的出现，并按字面意义将以下字符作为字段值的一部分。一些两个字符的序列是例外，其中第一个字符是转义字符。下表显示了这些序列（使用\作为转义字符）。本节稍后将介绍空处理的规则。</p>
                        <div class="informaltable">
                            <table summary="Two-character sequences for which the first character (a \) is the escape character."><colgroup><col width="15%"><col width="85%"></colgroup><thead><tr>
                                <th scope="col">Character</th>
                                <th scope="col">Escape Sequence</th>
                            </tr></thead><tbody><tr>
                                <td scope="row"><code class="literal">\0</code><a class="indexterm" name="idm140286835471152"></a><a class="indexterm" name="idm140286835470208"></a></td>
                                <td>An ASCII NUL (<code class="literal">X'00'</code>) character</td>
                            </tr><tr>
                                <td scope="row"><code class="literal">\b</code><a class="indexterm" name="idm140286835465792"></a><a class="indexterm" name="idm140286835464848"></a></td>
                                <td>A backspace character</td>
                            </tr><tr>
                                <td scope="row"><code class="literal">\n</code><a class="indexterm" name="idm140286835461120"></a><a class="indexterm" name="idm140286835460176"></a><a class="indexterm" name="idm140286835459232"></a><a class="indexterm" name="idm140286835458288"></a></td>
                                <td>A newline (linefeed) character</td>
                            </tr><tr>
                                <td scope="row"><code class="literal">\r</code><a class="indexterm" name="idm140286835454544"></a><a class="indexterm" name="idm140286835453600"></a><a class="indexterm" name="idm140286835452656"></a></td>
                                <td>A carriage return character</td>
                            </tr><tr>
                                <td scope="row"><code class="literal">\t</code><a class="indexterm" name="idm140286835448912"></a><a class="indexterm" name="idm140286835447968"></a></td>
                                <td>A tab character.</td>
                            </tr><tr>
                                <td scope="row"><code class="literal">\Z</code><a class="indexterm" name="idm140286835444240"></a><a class="indexterm" name="idm140286835443296"></a></td>
                                <td>ASCII 26 (Control+Z)</td>
                            </tr><tr>
                                <td scope="row"><code class="literal">\N</code><a class="indexterm" name="idm140286835439568"></a></td>
                                <td>NULL</td>
                            </tr></tbody></table>
                        </div>
                        <p>
                            For more information about <code class="literal">\</code>-escape
                            syntax, see <a class="xref" href="language-structure.html#string-literals" title="9.1.1&nbsp;String Literals">Section&nbsp;9.1.1, “String Literals”</a>.
                        </p><p style="color:blue;">有关\-escape语法的详细信息，请参见第9.1.1节“字符串文本”。</p><p>
                            If the <code class="literal">FIELDS ESCAPED BY</code> character is
                            empty, escape-sequence interpretation does not occur.
                        </p><p style="color:blue;">如果按字符转义的字段为空，则不进行转义序列解释。</p></li><li class="listitem"><p>
                        For output, if the <code class="literal">FIELDS ESCAPED BY</code>
                        character is not empty, it is used to prefix the following
                        characters on output:
                    </p><p style="color:blue;">对于输出，如果按字符转义的字段不为空，则用于在输出时为以下字符加前缀：</p>
                        <div class="itemizedlist">
                            <ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
                                The <code class="literal">FIELDS ESCAPED BY</code> character.
                            </p><p style="color:blue;">字段按字符转义。</p></li><li class="listitem"><p>
                                The <code class="literal">FIELDS [OPTIONALLY] ENCLOSED BY</code>
                                character.
                            </p><p style="color:blue;">字符[可选]包围的字段。</p></li><li class="listitem"><p>
                                The first character of the <code class="literal">FIELDS TERMINATED
                                BY</code> and <code class="literal">LINES TERMINATED BY</code>
                                values, if the <code class="literal">ENCLOSED BY</code> character
                                is empty or unspecified.
                            </p><p style="color:blue;">如果所包含的字符为空或未指定，则以值结尾的字段和以值结尾的行的第一个字符。</p></li><li class="listitem"><p>
                                ASCII <code class="literal">0</code> (what is actually written
                                following the escape character is ASCII
                                <code class="literal">0</code>, not a zero-valued byte).
                            </p><p style="color:blue;">ascii 0（转义字符后面实际写的是ascii0，而不是一个零值字节）。</p></li></ul>
                        </div>
                        <p>
                            If the <code class="literal">FIELDS ESCAPED BY</code> character is
                            empty, no characters are escaped and <code class="literal">NULL</code>
                            is output as <code class="literal">NULL</code>, not
                            <code class="literal">\N</code>. It is probably not a good idea to
                            specify an empty escape character, particularly if field
                            values in your data contain any of the characters in the
                            list just given.
                        </p><p style="color:blue;">如果按字符转义的字段为空，则不转义任何字符，并将空输出为空，而不是。指定空转义字符可能不是一个好主意，特别是如果数据中的字段值包含刚才给出的列表中的任何字符。</p></li></ul>
                </div>
                <p>
                    In certain cases, field- and line-handling options interact:
                </p><p style="color:blue;">在某些情况下，字段和行处理选项相互作用：</p>
                <div class="itemizedlist">
                    <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                        If <code class="literal">LINES TERMINATED BY</code> is an empty string
                        and <code class="literal">FIELDS TERMINATED BY</code> is nonempty,
                        lines are also terminated with <code class="literal">FIELDS TERMINATED
                        BY</code>.
                    </p><p style="color:blue;">如果以结尾的行是空字符串，并且以结尾的字段不是空的，则行也将以以结尾的字段结尾。</p></li><li class="listitem"><p>
                        If the <code class="literal">FIELDS TERMINATED BY</code> and
                        <code class="literal">FIELDS ENCLOSED BY</code> values are both empty
                        (<code class="literal">''</code>), a fixed-row (nondelimited) format
                        is used. With fixed-row format, no delimiters are used
                        between fields (but you can still have a line terminator).
                        Instead, column values are read and written using a field
                        width wide enough to hold all values in the field. For
                        <a class="link" href="data-types.html#integer-types" title="11.2.1&nbsp;Integer Types (Exact Value) - INTEGER, INT, SMALLINT, TINYINT, MEDIUMINT, BIGINT"><code class="literal">TINYINT</code></a>,
                        <a class="link" href="data-types.html#integer-types" title="11.2.1&nbsp;Integer Types (Exact Value) - INTEGER, INT, SMALLINT, TINYINT, MEDIUMINT, BIGINT"><code class="literal">SMALLINT</code></a>,
                        <a class="link" href="data-types.html#integer-types" title="11.2.1&nbsp;Integer Types (Exact Value) - INTEGER, INT, SMALLINT, TINYINT, MEDIUMINT, BIGINT"><code class="literal">MEDIUMINT</code></a>,
                        <a class="link" href="data-types.html#integer-types" title="11.2.1&nbsp;Integer Types (Exact Value) - INTEGER, INT, SMALLINT, TINYINT, MEDIUMINT, BIGINT"><code class="literal">INT</code></a>, and
                        <a class="link" href="data-types.html#integer-types" title="11.2.1&nbsp;Integer Types (Exact Value) - INTEGER, INT, SMALLINT, TINYINT, MEDIUMINT, BIGINT"><code class="literal">BIGINT</code></a>, the field widths are
                        4, 6, 8, 11, and 20, respectively, no matter what the
                        declared display width is.
                    </p><p style="color:blue;">如果以值结尾的字段和由值括起的字段都为空（''），则使用固定行（不可传递）格式。对于固定行格式，字段之间不使用分隔符（但仍可以使用行结束符）。相反，使用足够宽的字段宽度读取和写入列值，该宽度足以容纳字段中的所有值。对于tinyint、smallint、mediumint、int和bigint，无论声明的显示宽度是多少，字段宽度分别为4、6、8、11和20。</p><p>
                        <code class="literal">LINES TERMINATED BY</code> is still used to
                        separate lines. If a line does not contain all fields, the
                        rest of the columns are set to their default values. If you
                        do not have a line terminator, you should set this to
                        <code class="literal">''</code>. In this case, the text file must
                        contain all fields for each row.
                    </p><p style="color:blue;">终止于的行仍用于分隔行。如果一行不包含所有字段，则其余列将设置为其默认值。如果没有行终止符，则应将其设置为“”。在这种情况下，文本文件必须包含每行的所有字段。</p><p>
                        Fixed-row format also affects handling of
                        <code class="literal">NULL</code> values, as described later.
                    </p><p style="color:blue;">固定行格式也会影响空值的处理，如后文所述。</p>
                        <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">

                            <div class="admon-title">
                                Note
                            </div>
                            <p>
                                Fixed-size format does not work if you are using a
                                multibyte character set.
                            </p><p style="color:blue;">如果使用多字节字符集，则固定大小格式不起作用。</p>
                        </div>
                    </li></ul>
                </div>
                <p>
                    Handling of <code class="literal">NULL</code> values varies according to
                    the <code class="literal">FIELDS</code> and <code class="literal">LINES</code>
                    options in use:
                </p><p style="color:blue;">根据使用的字段和行选项，对空值的处理会有所不同：</p>
                <div class="itemizedlist">
                    <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                        For the default <code class="literal">FIELDS</code> and
                        <code class="literal">LINES</code> values, <code class="literal">NULL</code> is
                        written as a field value of <code class="literal">\N</code> for
                        output, and a field value of <code class="literal">\N</code> is read
                        as <code class="literal">NULL</code> for input (assuming that the
                        <code class="literal">ESCAPED BY</code> character is
                        <code class="literal">\</code>).
                    </p><p style="color:blue;">对于默认的字段和行值，将空值作为字段值写入输出，将字段值读取为空值作为输入（假设转义的字符为）。</p></li><li class="listitem"><p>
                        If <code class="literal">FIELDS ENCLOSED BY</code> is not empty, a
                        field containing the literal word <code class="literal">NULL</code> as
                        its value is read as a <code class="literal">NULL</code> value. This
                        differs from the word <code class="literal">NULL</code> enclosed
                        within <code class="literal">FIELDS ENCLOSED BY</code> characters,
                        which is read as the string <code class="literal">'NULL'</code>.
                    </p><p style="color:blue;">如果由括起的字段不为空，则将包含文本字null作为其值的字段读取为空值。这与用字符括起来的字段中的null不同，后者被读取为字符串“null”。</p></li><li class="listitem"><p>
                        If <code class="literal">FIELDS ESCAPED BY</code> is empty,
                        <code class="literal">NULL</code> is written as the word
                        <code class="literal">NULL</code>.
                    </p><p style="color:blue;">如果转义的字段为空，则将空写为空。</p></li><li class="listitem"><p>
                        With fixed-row format (which is used when <code class="literal">FIELDS
                        TERMINATED BY</code> and <code class="literal">FIELDS ENCLOSED
                        BY</code> are both empty), <code class="literal">NULL</code> is
                        written as an empty string. This causes both
                        <code class="literal">NULL</code> values and empty strings in the
                        table to be indistinguishable when written to the file
                        because both are written as empty strings. If you need to be
                        able to tell the two apart when reading the file back in,
                        you should not use fixed-row format.
                    </p><p style="color:blue;">对于固定行格式（当以结尾的字段和由括起的字段均为空时使用），空将作为空字符串写入。这会导致表中的空值和空字符串在写入文件时无法区分，因为它们都是作为空字符串写入的。如果在读回文件时需要区分这两者，则不应使用固定行格式。</p></li></ul>
                </div>
                <p>
                    An attempt to load <code class="literal">NULL</code> into a <code class="literal">NOT
                    NULL</code> column causes assignment of the implicit default
                    value for the column's data type and a warning, or an error in
                    strict SQL mode. Implicit default values are discussed in
                    <a class="xref" href="data-types.html#data-type-defaults" title="11.7&nbsp;Data Type Default Values">Section&nbsp;11.7, “Data Type Default Values”</a>.
                </p><p style="color:blue;">尝试将null加载到not null列中会导致为该列的数据类型和警告分配隐式默认值，或者在strict sql模式下出现错误。隐含默认值在第11.7节“数据类型默认值”中讨论。</p><p>
                Some cases are not supported by <a class="link" href="sql-syntax.html#load-data" title="13.2.6&nbsp;LOAD DATA Syntax"><code class="literal">LOAD
                DATA</code></a>:
            </p><p style="color:blue;">加载数据不支持某些情况：</p>
                <div class="itemizedlist">
                    <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                        Fixed-size rows (<code class="literal">FIELDS TERMINATED BY</code> and
                        <code class="literal">FIELDS ENCLOSED BY</code> both empty) and
                        <a class="link" href="data-types.html#blob" title="11.4.3&nbsp;The BLOB and TEXT Types"><code class="literal">BLOB</code></a> or
                        <a class="link" href="data-types.html#blob" title="11.4.3&nbsp;The BLOB and TEXT Types"><code class="literal">TEXT</code></a> columns.
                    </p><p style="color:blue;">固定大小的行（以空结尾的字段和以空括起的字段）和blob或文本列。</p></li><li class="listitem"><p>
                        If you specify one separator that is the same as or a prefix
                        of another, <a class="link" href="sql-syntax.html#load-data" title="13.2.6&nbsp;LOAD DATA Syntax"><code class="literal">LOAD DATA</code></a> cannot
                        interpret the input properly. For example, the following
                        <code class="literal">FIELDS</code> clause would cause problems:
                    </p><p style="color:blue;">如果指定一个与另一个分隔符相同的分隔符或另一个分隔符的前缀，则加载数据无法正确解释输入。例如，下面的fields子句将导致问题：</p><pre data-lang="sql" class="programlisting">FIELDS TERMINATED BY '"' ENCLOSED BY '"'
</pre></li><li class="listitem"><p>
                        If <code class="literal">FIELDS ESCAPED BY</code> is empty, a field
                        value that contains an occurrence of <code class="literal">FIELDS
                        ENCLOSED BY</code> or <code class="literal">LINES TERMINATED
                        BY</code> followed by the <code class="literal">FIELDS TERMINATED
                        BY</code> value causes <a class="link" href="sql-syntax.html#load-data" title="13.2.6&nbsp;LOAD DATA Syntax"><code class="literal">LOAD
                        DATA</code></a> to stop reading a field or line too early.
                        This happens because <a class="link" href="sql-syntax.html#load-data" title="13.2.6&nbsp;LOAD DATA Syntax"><code class="literal">LOAD
                        DATA</code></a> cannot properly determine where the field or
                        line value ends.
                    </p><p style="color:blue;">如果字段转义为空，则包含由值结束的字段包围的字段或后跟值结束的字段的行的出现的字段值将导致加载数据过早停止读取字段或行。发生这种情况是因为加载数据无法正确确定字段或行值的结束位置。</p></li></ul>
                </div>

            </div>
            <div class="simplesect">
                <div class="titlepage">
                    <div>
                        <div class="simple">
                            <h4 class="title"><a name="load-data-column-list"></a>Column List Specification</h4>

                        </div>

                    </div>

                </div>
                <p>
                    The following example loads all columns of the
                    <code class="literal">persondata</code> table:
                </p><p style="color:blue;">以下示例加载persondata表的所有列：</p><pre data-lang="sql" class="programlisting">LOAD DATA INFILE 'persondata.txt' INTO TABLE persondata;
</pre><p>
                By default, when no column list is provided at the end of the
                <a class="link" href="sql-syntax.html#load-data" title="13.2.6&nbsp;LOAD DATA Syntax"><code class="literal">LOAD DATA</code></a> statement, input lines
                are expected to contain a field for each table column. If you
                want to load only some of a table's columns, specify a column
                list:
            </p><p style="color:blue;">默认情况下，如果在LOAD DATA语句的末尾未提供列列表，则输入行应包含每个表列的字段。如果只想加载表的某些列，请指定列列表：</p><pre data-lang="sql" class="programlisting">LOAD DATA INFILE 'persondata.txt' INTO TABLE persondata
(<em class="replaceable"><code>col_name_or_user_var</code></em> [, <em class="replaceable"><code>col_name_or_user_var</code></em>] ...);
</pre><p>
                You must also specify a column list if the order of the fields
                in the input file differs from the order of the columns in the
                table. Otherwise, MySQL cannot tell how to match input fields
                with table columns.
            </p><p style="color:blue;">如果输入文件中字段的顺序与表中列的顺序不同，则还必须指定列列表。否则，mysql无法告诉如何将输入字段与表列匹配。</p>
            </div>
            <div class="simplesect">
                <div class="titlepage">
                    <div>
                        <div class="simple">
                            <h4 class="title"><a name="load-data-input-preprocessing"></a>Input Preprocessing</h4>

                        </div>

                    </div>

                </div>
                <p>
                    Each <em class="replaceable"><code>col_name_or_user_var</code></em> value is
                    either a column name or a user variable. With user variables,
                    the <code class="literal">SET</code> clause enables you to perform
                    preprocessing transformations on their values before assigning
                    the result to columns.
                </p><p style="color:blue;">每个col_name_或_user_var值都是列名或用户变量。对于用户变量，set子句允许您在将结果分配给列之前对其值执行预处理转换。</p><p>
                User variables in the <code class="literal">SET</code> clause can be used
                in several ways. The following example uses the first input
                column directly for the value of <code class="literal">t1.column1</code>,
                and assigns the second input column to a user variable that is
                subjected to a division operation before being used for the
                value of <code class="literal">t1.column2</code>:
            </p><p style="color:blue;">set子句中的用户变量可以通过多种方式使用。以下示例将第一个输入列直接用于t1.column1的值，并将第二个输入列分配给在用于t1.column2的值之前要进行除法运算的用户变量：</p><pre data-lang="sql" class="programlisting">LOAD DATA INFILE 'file.txt'
  INTO TABLE t1
  (column1, @var1)
  SET column2 = @var1/100;
</pre><p>
                The <code class="literal">SET</code> clause can be used to supply values
                not derived from the input file. The following statement sets
                <code class="literal">column3</code> to the current date and time:
            </p><p style="color:blue;">set子句可用于提供不是从输入文件派生的值。以下语句将column3设置为当前日期和时间：</p><pre data-lang="sql" class="programlisting">LOAD DATA INFILE 'file.txt'
  INTO TABLE t1
  (column1, column2)
  SET column3 = CURRENT_TIMESTAMP;
</pre><p>
                You can also discard an input value by assigning it to a user
                variable and not assigning the variable to a table column:
            </p><p style="color:blue;">也可以通过将输入值分配给用户变量而不将该变量分配给表列来放弃输入值：</p><pre data-lang="sql" class="programlisting">LOAD DATA INFILE 'file.txt'
  INTO TABLE t1
  (column1, @dummy, column2, @dummy, column3);
</pre><p>
                Use of the column/variable list and <code class="literal">SET</code>
                clause is subject to the following restrictions:
            </p><p style="color:blue;">使用column/variable list and set子句受以下限制：</p>
                <div class="itemizedlist">
                    <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                        Assignments in the <code class="literal">SET</code> clause should have
                        only column names on the left hand side of assignment
                        operators.
                    </p><p style="color:blue;">set子句中的赋值只能在赋值运算符的左侧有列名。</p></li><li class="listitem"><p>
                        You can use subqueries in the right hand side of
                        <code class="literal">SET</code> assignments. A subquery that returns
                        a value to be assigned to a column may be a scalar subquery
                        only. Also, you cannot use a subquery to select from the
                        table that is being loaded.
                    </p><p style="color:blue;">可以使用集合指定右侧的子查询。返回要分配给列的值的子查询只能是标量子查询。此外，不能使用子查询从正在加载的表中进行选择。</p></li><li class="listitem"><p>
                        Lines ignored by an <code class="literal">IGNORE</code> clause are not
                        processed for the column/variable list or
                        <code class="literal">SET</code> clause.
                    </p><p style="color:blue;">对于列/变量列表或集合子句，不处理被忽略子句忽略的行。</p></li><li class="listitem"><p>
                        User variables cannot be used when loading data with
                        fixed-row format because user variables do not have a
                        display width.
                    </p><p style="color:blue;">加载固定行格式的数据时不能使用用户变量，因为用户变量没有显示宽度。</p></li></ul>
                </div>
                <p>
                    When processing an input line, <a class="link" href="sql-syntax.html#load-data" title="13.2.6&nbsp;LOAD DATA Syntax"><code class="literal">LOAD
                    DATA</code></a> splits it into fields and uses the values
                    according to the column/variable list and the
                    <code class="literal">SET</code> clause, if they are present. Then the
                    resulting row is inserted into the table. If there are
                    <code class="literal">BEFORE INSERT</code> or <code class="literal">AFTER
                    INSERT</code> triggers for the table, they are activated
                    before or after inserting the row, respectively.
                </p><p style="color:blue;">在处理输入行时，LOAD DATA将其拆分为字段，并根据列/变量列表和SET子句（如果存在）使用值。然后将结果行插入表中。如果表有before insert或after insert触发器，则分别在插入行之前或之后激活它们。</p><p>
                If an input line has too many fields, the extra fields are
                ignored and the number of warnings is incremented.
            </p><p style="color:blue;">如果一个输入行有太多的字段，多余的字段将被忽略，警告的数量将增加。</p><p>
                If an input line has too few fields, the table columns for which
                input fields are missing are set to their default values.
                Default value assignment is described in
                <a class="xref" href="data-types.html#data-type-defaults" title="11.7&nbsp;Data Type Default Values">Section&nbsp;11.7, “Data Type Default Values”</a>.
            </p><p style="color:blue;">如果输入行的字段太少，则缺少输入字段的表列将设置为其默认值。默认值分配在第11.7节“数据类型默认值”中描述。</p><p>
                An empty field value is interpreted different from a missing
                field:
            </p><p style="color:blue;">空字段值的解释与缺少的字段不同：</p>
                <div class="itemizedlist">
                    <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                        For string types, the column is set to the empty string.
                    </p><p style="color:blue;">对于字符串类型，列设置为空字符串。</p></li><li class="listitem"><p>
                        For numeric types, the column is set to
                        <code class="literal">0</code>.
                    </p><p style="color:blue;">对于数值类型，列设置为0。</p></li><li class="listitem"><p>
                        For date and time types, the column is set to the
                        appropriate <span class="quote">“<span class="quote">zero</span>”</span> value for the type. See
                        <a class="xref" href="data-types.html#date-and-time-types" title="11.3&nbsp;Date and Time Types">Section&nbsp;11.3, “Date and Time Types”</a>.
                    </p><p style="color:blue;">对于日期和时间类型，该列被设置为该类型的适当“零”值。见第11.3节“日期和时间类型”。</p></li></ul>
                </div>
                <p>
                    These are the same values that result if you assign an empty
                    string explicitly to a string, numeric, or date or time type
                    explicitly in an <a class="link" href="sql-syntax.html#insert" title="13.2.5&nbsp;INSERT Syntax"><code class="literal">INSERT</code></a> or
                    <a class="link" href="sql-syntax.html#update" title="13.2.11&nbsp;UPDATE Syntax"><code class="literal">UPDATE</code></a> statement.
                </p><p style="color:blue;">如果在INSERT或UPDATE语句中将空字符串显式赋给字符串、数字或日期或时间类型，则这些值与结果相同。</p><p>
                Treatment of empty or incorrect field values differs from that
                just described if the SQL mode is set to a restrictive value.
                For example, if <a class="link" href="server-administration.html#sysvar_sql_mode"><code class="literal">sql_mode</code></a> is set
                to <a class="link" href="server-administration.html#sqlmode_traditional"><code class="literal">TRADITIONAL</code></a>, conversion of
                an empty value or a value such as <code class="literal">'x'</code> for a
                numeric column results in an error, not conversion to 0. (With
                <code class="literal">LOCAL</code> or <code class="literal">IGNORE</code>, warnings
                occur rather than errors, even with a restrictive
                <a class="link" href="server-administration.html#sysvar_sql_mode"><code class="literal">sql_mode</code></a> value, and the row is
                inserted using the same closest-value behavior used for
                nonrestrictive SQL modes. This occurs because the server has no
                way to stop transmission of the file in the middle of the
                operation.)
            </p><p style="color:blue;">如果将sql模式设置为限制性值，则对空字段值或不正确字段值的处理与刚才描述的不同。例如，如果将sql_mode设置为traditional，则转换空值或数值列的值（如“x”）将导致错误，而不是转换为0。（使用local或ignore时，即使使用限制性的sql_mode值，也会出现警告而不是错误，并且使用与非限制性sql模式相同的最近值行为插入行。这是因为服务器无法在操作过程中停止文件的传输。）</p><p>
                <a class="link" href="data-types.html#datetime" title="11.3.1&nbsp;The DATE, DATETIME, and TIMESTAMP Types"><code class="literal">TIMESTAMP</code></a> columns are set to the
                current date and time only if there is a <code class="literal">NULL</code>
                value for the column (that is, <code class="literal">\N</code>) and the
                column is not declared to permit <code class="literal">NULL</code> values,
                or if the <a class="link" href="data-types.html#datetime" title="11.3.1&nbsp;The DATE, DATETIME, and TIMESTAMP Types"><code class="literal">TIMESTAMP</code></a> column's
                default value is the current timestamp and it is omitted from
                the field list when a field list is specified.
            </p><p style="color:blue;">只有当列有空值（即，该列未声明为允许空值）时，或者如果时间戳列的默认值是当前时间戳，并且在指定字段列表时从字段列表中忽略它，则时间戳列才会设置为当前日期和时间。</p><p>
                <a class="link" href="sql-syntax.html#load-data" title="13.2.6&nbsp;LOAD DATA Syntax"><code class="literal">LOAD DATA</code></a> regards all input as
                strings, so you cannot use numeric values for
                <a class="link" href="data-types.html#enum" title="11.4.4&nbsp;The ENUM Type"><code class="literal">ENUM</code></a> or
                <a class="link" href="data-types.html#set" title="11.4.5&nbsp;The SET Type"><code class="literal">SET</code></a> columns the way you can with
                <a class="link" href="sql-syntax.html#insert" title="13.2.5&nbsp;INSERT Syntax"><code class="literal">INSERT</code></a> statements. All
                <a class="link" href="data-types.html#enum" title="11.4.4&nbsp;The ENUM Type"><code class="literal">ENUM</code></a> and
                <a class="link" href="data-types.html#set" title="11.4.5&nbsp;The SET Type"><code class="literal">SET</code></a> values must be specified as
                strings.
            </p><p style="color:blue;">LOAD DATA将所有输入视为字符串，因此不能像INSERT语句那样对枚举或列使用数值。所有枚举和设置值都必须指定为字符串。</p><p>
                <a class="link" href="data-types.html#bit-type" title="11.2.4&nbsp;Bit-Value Type - BIT"><code class="literal">BIT</code></a> values cannot be loaded
                directly using binary notation (for example,
                <code class="literal">b'011010'</code>). To work around this, use the
                <code class="literal">SET</code> clause to strip off the leading
                <code class="literal">b'</code> and trailing <code class="literal">'</code> and
                perform a base-2 to base-10 conversion so that MySQL loads the
                values into the <a class="link" href="data-types.html#bit-type" title="11.2.4&nbsp;Bit-Value Type - BIT"><code class="literal">BIT</code></a> column
                properly:
            </p><p style="color:blue;">不能使用二进制表示法（例如，B'011010'）直接加载位值。要解决此问题，请使用set子句去掉前导b'和尾随b'并执行base-2到base-10转换，以便mysql将值正确加载到bit列中：</p><pre data-lang="terminal" class="programlisting">shell&gt; <strong class="userinput"><code>cat /tmp/bit_test.txt</code></strong>
b'10'
b'1111111'
shell&gt; <strong class="userinput"><code>mysql test</code></strong>
mysql&gt; <strong class="userinput"><code>LOAD DATA INFILE '/tmp/bit_test.txt'</code></strong>
       <strong class="userinput"><code>INTO TABLE bit_test (@var1)</code></strong>
       <strong class="userinput"><code>SET b = CAST(CONV(MID(@var1, 3, LENGTH(@var1)-3), 2, 10) AS UNSIGNED);</code></strong>
Query OK, 2 rows affected (0.00 sec)
Records: 2  Deleted: 0  Skipped: 0  Warnings: 0

mysql&gt; <strong class="userinput"><code>SELECT BIN(b+0) FROM bit_test;</code></strong>
+----------+
| BIN(b+0) |
+----------+
| 10       |
| 1111111  |
+----------+
2 rows in set (0.00 sec)
</pre><p>
                For <a class="link" href="data-types.html#bit-type" title="11.2.4&nbsp;Bit-Value Type - BIT"><code class="literal">BIT</code></a> values in
                <code class="literal">0b</code> binary notation (for example,
                <code class="literal">0b011010</code>), use this <code class="literal">SET</code>
                clause instead to strip off the leading <code class="literal">0b</code>:
            </p><p style="color:blue;">对于0b二进制表示法中的位值（例如，0b011010），请使用此set子句来去掉前导0b：</p><pre data-lang="sql" class="programlisting">SET b = CAST(CONV(MID(@var1, 3, LENGTH(@var1)-2), 2, 10) AS UNSIGNED)
</pre>
            </div>
            <div class="simplesect">
                <div class="titlepage">
                    <div>
                        <div class="simple">
                            <h4 class="title"><a name="load-data-statement-result-information"></a>Statement Result Information</h4>

                        </div>

                    </div>

                </div>
                <p>
                    When the <a class="link" href="sql-syntax.html#load-data" title="13.2.6&nbsp;LOAD DATA Syntax"><code class="literal">LOAD DATA</code></a> statement
                    finishes, it returns an information string in the following
                    format:
                </p><p style="color:blue;">LOAD DATA语句完成后，将以以下格式返回信息字符串：</p><pre data-lang="none" class="programlisting">Records: 1  Deleted: 0  Skipped: 0  Warnings: 0
</pre><p>
                Warnings occur under the same circumstances as when values are
                inserted using the <a class="link" href="sql-syntax.html#insert" title="13.2.5&nbsp;INSERT Syntax"><code class="literal">INSERT</code></a>
                statement (see <a class="xref" href="sql-syntax.html#insert" title="13.2.5&nbsp;INSERT Syntax">Section&nbsp;13.2.5, “INSERT Syntax”</a>), except that
                <a class="link" href="sql-syntax.html#load-data" title="13.2.6&nbsp;LOAD DATA Syntax"><code class="literal">LOAD DATA</code></a> also generates warnings
                when there are too few or too many fields in the input row.
            </p><p style="color:blue;">警告出现的情况与使用INSERT语句插入值时的情况相同（请参见第13.2.5节“插入语法”），只是当输入行中的字段太少或太多时，加载数据也会生成警告。</p><p>
                You can use <a class="link" href="sql-syntax.html#show-warnings" title="13.7.5.40&nbsp;SHOW WARNINGS Syntax"><code class="literal">SHOW WARNINGS</code></a> to get
                a list of the first
                <a class="link" href="server-administration.html#sysvar_max_error_count"><code class="literal">max_error_count</code></a> warnings as
                information about what went wrong. See
                <a class="xref" href="sql-syntax.html#show-warnings" title="13.7.5.40&nbsp;SHOW WARNINGS Syntax">Section&nbsp;13.7.5.40, “SHOW WARNINGS Syntax”</a>.
            </p><p style="color:blue;">您可以使用show warnings来获取第一个max_error_count警告的列表，作为出错的信息。见第13.7.5.40节“显示警告语法”。</p><a class="indexterm" name="idm140286835271120"></a><p>
                If you are using the C API, you can get information about the
                statement by calling the
                <a class="link" href="connectors-apis.html#mysql-info" title="27.8.7.36&nbsp;mysql_info()"><code class="literal">mysql_info()</code></a> function. See
                <a class="xref" href="connectors-apis.html#mysql-info" title="27.8.7.36&nbsp;mysql_info()">Section&nbsp;27.8.7.36, “mysql_info()”</a>.
            </p><p style="color:blue;">如果使用的是C API，则可以通过调用mysql_info（）函数来获取有关该语句的信息。见27.8.7.36节，“mysql_info（）”。</p>
            </div>
            <div class="simplesect">
                <div class="titlepage">
                    <div>
                        <div class="simple">
                            <h4 class="title"><a name="load-data-miscellaneous"></a>Miscellaneous Topics</h4>

                        </div>

                    </div>

                </div>
                <p>
                    On Unix, if you need <a class="link" href="sql-syntax.html#load-data" title="13.2.6&nbsp;LOAD DATA Syntax"><code class="literal">LOAD DATA</code></a> to
                    read from a pipe, you can use the following technique (the
                    example loads a listing of the <code class="filename">/</code> directory
                    into the table <code class="literal">db1.t1</code>):
                </p><p style="color:blue;">在UNIX上，如果需要从管道中读取加载数据，可以使用以下技术（示例将/目录的列表加载到表DB1.T1中）：</p><pre data-lang="terminal" class="programlisting">mkfifo /mysql/data/db1/ls.dat
chmod 666 /mysql/data/db1/ls.dat
find / -ls &gt; /mysql/data/db1/ls.dat &amp;
mysql -e "LOAD DATA INFILE 'ls.dat' INTO TABLE t1" db1
</pre><p>
                Here you must run the command that generates the data to be
                loaded and the <a class="link" href="programs.html#mysql" title="4.5.1&nbsp;mysql — The MySQL Command-Line Client"><span class="command"><strong>mysql</strong></span></a> commands either on
                separate terminals, or run the data generation process in the
                background (as shown in the preceding example). If you do not do
                this, the pipe will block until data is read by the
                <a class="link" href="programs.html#mysql" title="4.5.1&nbsp;mysql — The MySQL Command-Line Client"><span class="command"><strong>mysql</strong></span></a> process.
            </p><p style="color:blue;">在这里，您必须在单独的终端上运行生成要加载的数据的命令和mysql命令，或者在后台运行数据生成过程（如前一个示例所示）。如果不这样做，管道将阻塞，直到mysql进程读取数据。</p>
            </div>

        </div>
        <div class="section">
            <div class="titlepage">
                <div>
                    <div>
                        <h3 class="title"><a name="load-xml"></a>13.2.7&nbsp;LOAD XML Syntax</h3>

                    </div>

                </div>

            </div>
            <a class="indexterm" name="idm140286835257392"></a><pre data-lang="sql" class="programlisting">LOAD XML
    [LOW_PRIORITY | CONCURRENT] [LOCAL]
    INFILE '<em class="replaceable"><code>file_name</code></em>'
    [REPLACE | IGNORE]
    INTO TABLE [<em class="replaceable"><code>db_name</code></em>.]<em class="replaceable"><code>tbl_name</code></em>
    [CHARACTER SET <em class="replaceable"><code>charset_name</code></em>]
    [ROWS IDENTIFIED BY '&lt;<em class="replaceable"><code>tagname</code></em>&gt;']
    [IGNORE <em class="replaceable"><code>number</code></em> {LINES | ROWS}]
    [(<em class="replaceable"><code>field_name_or_user_var</code></em>
        [, <em class="replaceable"><code>field_name_or_user_var</code></em>] ...)]
    [SET <em class="replaceable"><code>col_name</code></em>={<em class="replaceable"><code>expr</code></em> | DEFAULT},
        [, <em class="replaceable"><code>col_name</code></em>={<em class="replaceable"><code>expr</code></em> | DEFAULT}] ...]
</pre><p>
            The <a class="link" href="sql-syntax.html#load-xml" title="13.2.7&nbsp;LOAD XML Syntax"><code class="literal">LOAD XML</code></a> statement reads data
            from an XML file into a table. The
            <em class="replaceable"><code>file_name</code></em> must be given as a literal
            string. The <em class="replaceable"><code>tagname</code></em> in the optional
            <code class="literal">ROWS IDENTIFIED BY</code> clause must also be given as
            a literal string, and must be surrounded by angle brackets
            (<code class="literal">&lt;</code> and <code class="literal">&gt;</code>).
        </p><p style="color:blue;">LOADXML语句将数据从XML文件读取到表中。文件名必须以文本字符串形式给出。子句标识的可选行中的标记名也必须指定为文本字符串，并且必须由尖括号（&lt;和&gt;）包围。</p><p>
            <a class="link" href="sql-syntax.html#load-xml" title="13.2.7&nbsp;LOAD XML Syntax"><code class="literal">LOAD XML</code></a> acts as the complement of
            running the <a class="link" href="programs.html#mysql" title="4.5.1&nbsp;mysql — The MySQL Command-Line Client"><span class="command"><strong>mysql</strong></span></a> client in XML output mode
            (that is, starting the client with the
            <a class="link" href="programs.html#option_mysql_xml"><code class="option">--xml</code></a> option). To write data from a
            table to an XML file, you can invoke the <a class="link" href="programs.html#mysql" title="4.5.1&nbsp;mysql — The MySQL Command-Line Client"><span class="command"><strong>mysql</strong></span></a>
            client with the <a class="link" href="programs.html#option_mysql_xml"><code class="option">--xml</code></a> and
            <a class="link" href="programs.html#option_mysql_execute"><code class="option">-e</code></a> options from
            the system shell, as shown here:
        </p><p style="color:blue;">加载XML作为以XML输出模式运行MySQL客户机的补充（即，使用--xml选项启动客户机）。要将表中的数据写入XML文件，可以使用系统shell中的--xml和-e选项调用MySQL客户机，如下所示：</p><pre data-lang="terminal" class="programlisting">shell&gt; <strong class="userinput"><code>mysql --xml -e 'SELECT * FROM mydb.mytable' &gt; file.xml</code></strong>
</pre><p>
            To read the file back into a table, use <a class="link" href="sql-syntax.html#load-xml" title="13.2.7&nbsp;LOAD XML Syntax"><code class="literal">LOAD
            XML</code></a>. By default, the <code class="literal">&lt;row&gt;</code>
            element is considered to be the equivalent of a database table
            row; this can be changed using the <code class="literal">ROWS IDENTIFIED
            BY</code> clause.
        </p><p style="color:blue;">要将文件读回表中，请使用load xml。默认情况下，<row>元素被视为等同于数据库表行；这可以使用由子句标识的行进行更改。</row></p><p>
            This statement supports three different XML formats:
        </p><p style="color:blue;">此语句支持三种不同的XML格式：</p>
            <div class="itemizedlist">
                <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                    Column names as attributes and column values as attribute
                    values:
                </p><p style="color:blue;">列名作为属性，列值作为属性值：</p><pre data-lang="xml" class="programlisting">&lt;<em class="replaceable"><code>row</code></em> <em class="replaceable"><code>column1</code></em>="<em class="replaceable"><code>value1</code></em>" <em class="replaceable"><code>column2</code></em>="<em class="replaceable"><code>value2</code></em>" .../&gt;
</pre></li><li class="listitem"><p>
                    Column names as tags and column values as the content of these
                    tags:
                </p><p style="color:blue;">列名作为标记，列值作为这些标记的内容：</p><pre data-lang="xml" class="programlisting">&lt;<em class="replaceable"><code>row</code></em>&gt;
  &lt;<em class="replaceable"><code>column1</code></em>&gt;<em class="replaceable"><code>value1</code></em>&lt;/<em class="replaceable"><code>column1</code></em>&gt;
  &lt;<em class="replaceable"><code>column2</code></em>&gt;<em class="replaceable"><code>value2</code></em>&lt;/<em class="replaceable"><code>column2</code></em>&gt;
&lt;/<em class="replaceable"><code>row</code></em>&gt;
</pre></li><li class="listitem"><p>
                    Column names are the <code class="literal">name</code> attributes of
                    <code class="literal">&lt;field&gt;</code> tags, and values are the
                    contents of these tags:
                </p><p style="color:blue;">列名是<field>标记的名称属性，值是这些标记的内容：</field></p><pre data-lang="xml" class="programlisting">&lt;row&gt;
  &lt;field name='<em class="replaceable"><code>column1</code></em>'&gt;<em class="replaceable"><code>value1</code></em>&lt;/field&gt;
  &lt;field name='<em class="replaceable"><code>column2</code></em>'&gt;<em class="replaceable"><code>value2</code></em>&lt;/field&gt;
&lt;/row&gt;
</pre><p>
                    This is the format used by other MySQL tools, such as
                    <a class="link" href="programs.html#mysqldump" title="4.5.4&nbsp;mysqldump — A Database Backup Program"><span class="command"><strong>mysqldump</strong></span></a>.
                </p><p style="color:blue;">这是其他mysql工具（如mysqldump）使用的格式。</p><a class="indexterm" name="idm140286835213184"></a></li></ul>
            </div>
            <p>
                All three formats can be used in the same XML file; the import
                routine automatically detects the format for each row and
                interprets it correctly. Tags are matched based on the tag or
                attribute name and the column name.
            </p><p style="color:blue;">这三种格式都可以在同一个xml文件中使用；导入例程自动检测每一行的格式并正确解释它。根据标记或属性名和列名匹配标记。</p><p>
            The following clauses work essentially the same way for
            <a class="link" href="sql-syntax.html#load-xml" title="13.2.7&nbsp;LOAD XML Syntax"><code class="literal">LOAD XML</code></a> as they do for
            <a class="link" href="sql-syntax.html#load-data" title="13.2.6&nbsp;LOAD DATA Syntax"><code class="literal">LOAD DATA</code></a>:
        </p><p style="color:blue;">以下子句在加载XML时的工作方式与在加载数据时的工作方式基本相同：</p>
            <div class="itemizedlist">
                <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                    <code class="literal">LOW_PRIORITY</code> or
                    <code class="literal">CONCURRENT</code>
                </p><p style="color:blue;">低优先级或并发</p></li><li class="listitem"><p>
                    <code class="literal">LOCAL</code>
                </p><p style="color:blue;">本地的</p></li><li class="listitem"><p>
                    <code class="literal">REPLACE</code> or <code class="literal">IGNORE</code>
                </p><p style="color:blue;">替换或忽略</p></li><li class="listitem"><p>
                    <code class="literal">CHARACTER SET</code>
                </p><p style="color:blue;">字符集</p></li><li class="listitem"><p>
                    <code class="literal">SET</code>
                </p><p style="color:blue;">套</p></li></ul>
            </div>
            <p>
                See <a class="xref" href="sql-syntax.html#load-data" title="13.2.6&nbsp;LOAD DATA Syntax">Section&nbsp;13.2.6, “LOAD DATA Syntax”</a>, for more information about these
                clauses.
            </p><p style="color:blue;">有关这些子句的更多信息，请参见第13.2.6节“加载数据语法”。</p><p>
            <code class="literal">(<em class="replaceable"><code>field_name_or_user_var</code></em>,
                ...)</code> is a list of one or more comma-separated XML fields
            or user variables. The name of a user variable used for this
            purpose must match the name of a field from the XML file, prefixed
            with <code class="literal">@</code>. You can use field names to select only
            desired fields. User variables can be employed to store the
            corresponding field values for subsequent re-use.
        </p><p style="color:blue;">（field_name_或_user_var，…）是一个或多个逗号分隔的XML字段或用户变量的列表。用于此目的的用户变量的名称必须与XML文件中以@为前缀的字段的名称匹配。可以使用字段名仅选择所需字段。用户变量可以用来存储相应的字段值，以便以后重用。</p><p>
            The <code class="literal">IGNORE <em class="replaceable"><code>number</code></em>
            LINES</code> or <code class="literal">IGNORE
            <em class="replaceable"><code>number</code></em> ROWS</code> clause causes the
            first <em class="replaceable"><code>number</code></em> rows in the XML file to be
            skipped. It is analogous to the <a class="link" href="sql-syntax.html#load-data" title="13.2.6&nbsp;LOAD DATA Syntax"><code class="literal">LOAD
            DATA</code></a> statement's <code class="literal">IGNORE ... LINES</code>
            clause.
        </p><p style="color:blue;">ignore number lines或ignore number rows子句导致跳过xml文件中的第一个数字行。它类似于load data语句的ignore…行条款。</p><p>
            Suppose that we have a table named <code class="literal">person</code>,
            created as shown here:
        </p><p style="color:blue;">假设我们创建了一个名为person的表，如下所示：</p><pre data-lang="sql" class="programlisting">USE test;

CREATE TABLE person (
    person_id INT NOT NULL PRIMARY KEY,
    fname VARCHAR(40) NULL,
    lname VARCHAR(40) NULL,
    created TIMESTAMP
);
</pre><p>
            Suppose further that this table is initially empty.
        </p><p style="color:blue;">进一步假设这个表最初是空的。</p><p>
            Now suppose that we have a simple XML file
            <code class="filename">person.xml</code>, whose contents are as shown here:
        </p><p style="color:blue;">现在假设我们有一个简单的xml文件person.xml，其内容如下所示：</p><pre data-lang="xml" class="programlisting">&lt;list&gt;
  &lt;person person_id="1" fname="Kapek" lname="Sainnouine"/&gt;
  &lt;person person_id="2" fname="Sajon" lname="Rondela"/&gt;
  &lt;person person_id="3"&gt;&lt;fname&gt;Likame&lt;/fname&gt;&lt;lname&gt;Örrtmons&lt;/lname&gt;&lt;/person&gt;
  &lt;person person_id="4"&gt;&lt;fname&gt;Slar&lt;/fname&gt;&lt;lname&gt;Manlanth&lt;/lname&gt;&lt;/person&gt;
  &lt;person&gt;&lt;field name="person_id"&gt;5&lt;/field&gt;&lt;field name="fname"&gt;Stoma&lt;/field&gt;
    &lt;field name="lname"&gt;Milu&lt;/field&gt;&lt;/person&gt;
  &lt;person&gt;&lt;field name="person_id"&gt;6&lt;/field&gt;&lt;field name="fname"&gt;Nirtam&lt;/field&gt;
    &lt;field name="lname"&gt;Sklöd&lt;/field&gt;&lt;/person&gt;
  &lt;person person_id="7"&gt;&lt;fname&gt;Sungam&lt;/fname&gt;&lt;lname&gt;Dulbåd&lt;/lname&gt;&lt;/person&gt;
  &lt;person person_id="8" fname="Sraref" lname="Encmelt"/&gt;
&lt;/list&gt;
</pre><p>
            Each of the permissible XML formats discussed previously is
            represented in this example file.
        </p><p style="color:blue;">前面讨论的每个允许的XML格式都在这个示例文件中表示。</p><p>
            To import the data in <code class="filename">person.xml</code> into the
            <code class="literal">person</code> table, you can use this statement:
        </p><p style="color:blue;">要将person.xml中的数据导入person表，可以使用以下语句：</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>LOAD XML LOCAL INFILE 'person.xml'</code></strong>
    -&gt;   <strong class="userinput"><code>INTO TABLE person</code></strong>
    -&gt;   <strong class="userinput"><code>ROWS IDENTIFIED BY '&lt;person&gt;';</code></strong>

Query OK, 8 rows affected (0.00 sec)
Records: 8  Deleted: 0  Skipped: 0  Warnings: 0
</pre><p>
            Here, we assume that <code class="filename">person.xml</code> is located in
            the MySQL data directory. If the file cannot be found, the
            following error results:
        </p><p style="color:blue;">在这里，我们假设person.xml位于mysql数据目录中。如果找不到文件，将导致以下错误：</p><pre data-lang="none" class="programlisting"><span class="errortext">ERROR 2 (HY000): File '/person.xml' not found (Errcode: 2)</span>
</pre><p>
            The <code class="literal">ROWS IDENTIFIED BY '&lt;person&gt;'</code> clause
            means that each <code class="literal">&lt;person&gt;</code> element in the
            XML file is considered equivalent to a row in the table into which
            the data is to be imported. In this case, this is the
            <code class="literal">person</code> table in the <code class="literal">test</code>
            database.
        </p><p style="color:blue;">由“<person>子句”标识的行意味着XML文件中的每个<person>元素都被视为等同于表中要导入数据的行。在本例中，这是测试数据库中的person表。</person></person></p><p>
            As can be seen by the response from the server, 8 rows were
            imported into the <code class="literal">test.person</code> table. This can
            be verified by a simple <a class="link" href="sql-syntax.html#select" title="13.2.9&nbsp;SELECT Syntax"><code class="literal">SELECT</code></a>
            statement:
        </p><p style="color:blue;">从服务器的响应可以看出，有8行被导入test.person表。这可以通过一个简单的select语句来验证：</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT * FROM person;</code></strong>
+-----------+--------+------------+---------------------+
| person_id | fname  | lname      | created             |
+-----------+--------+------------+---------------------+
|         1 | Kapek  | Sainnouine | 2007-07-13 16:18:47 |
|         2 | Sajon  | Rondela    | 2007-07-13 16:18:47 |
|         3 | Likame | Örrtmons   | 2007-07-13 16:18:47 |
|         4 | Slar   | Manlanth   | 2007-07-13 16:18:47 |
|         5 | Stoma  | Nilu       | 2007-07-13 16:18:47 |
|         6 | Nirtam | Sklöd      | 2007-07-13 16:18:47 |
|         7 | Sungam | Dulbåd     | 2007-07-13 16:18:47 |
|         8 | Sreraf | Encmelt    | 2007-07-13 16:18:47 |
+-----------+--------+------------+---------------------+
8 rows in set (0.00 sec)
</pre><p>
            This shows, as stated earlier in this section, that any or all of
            the 3 permitted XML formats may appear in a single file and be
            read using <a class="link" href="sql-syntax.html#load-xml" title="13.2.7&nbsp;LOAD XML Syntax"><code class="literal">LOAD XML</code></a>.
        </p><p style="color:blue;">这表明，如本节前面所述，3种允许的xml格式中的任何一种或全部可能出现在单个文件中，并使用loadxml读取。</p><p>
            The inverse of the import operation just shown—that is,
            dumping MySQL table data into an XML file—can be
            accomplished using the <a class="link" href="programs.html#mysql" title="4.5.1&nbsp;mysql — The MySQL Command-Line Client"><span class="command"><strong>mysql</strong></span></a> client from the
            system shell, as shown here:
        </p><p style="color:blue;">与导入操作相反的是，可以使用系统shell中的mysql客户机将mysql表数据转储到xml文件中，如下所示：</p><pre data-lang="terminal" class="programlisting">shell&gt; <strong class="userinput"><code>mysql --xml -e "SELECT * FROM test.person" &gt; person-dump.xml</code></strong>
shell&gt; <strong class="userinput"><code>cat person-dump.xml</code></strong>
&lt;?xml version="1.0"?&gt;

&lt;resultset statement="SELECT * FROM test.person" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"&gt;
  &lt;row&gt;
	&lt;field name="person_id"&gt;1&lt;/field&gt;
	&lt;field name="fname"&gt;Kapek&lt;/field&gt;
	&lt;field name="lname"&gt;Sainnouine&lt;/field&gt;
  &lt;/row&gt;

  &lt;row&gt;
	&lt;field name="person_id"&gt;2&lt;/field&gt;
	&lt;field name="fname"&gt;Sajon&lt;/field&gt;
	&lt;field name="lname"&gt;Rondela&lt;/field&gt;
  &lt;/row&gt;

  &lt;row&gt;
	&lt;field name="person_id"&gt;3&lt;/field&gt;
	&lt;field name="fname"&gt;Likema&lt;/field&gt;
	&lt;field name="lname"&gt;Örrtmons&lt;/field&gt;
  &lt;/row&gt;

  &lt;row&gt;
	&lt;field name="person_id"&gt;4&lt;/field&gt;
	&lt;field name="fname"&gt;Slar&lt;/field&gt;
	&lt;field name="lname"&gt;Manlanth&lt;/field&gt;
  &lt;/row&gt;

  &lt;row&gt;
	&lt;field name="person_id"&gt;5&lt;/field&gt;
	&lt;field name="fname"&gt;Stoma&lt;/field&gt;
	&lt;field name="lname"&gt;Nilu&lt;/field&gt;
  &lt;/row&gt;

  &lt;row&gt;
	&lt;field name="person_id"&gt;6&lt;/field&gt;
	&lt;field name="fname"&gt;Nirtam&lt;/field&gt;
	&lt;field name="lname"&gt;Sklöd&lt;/field&gt;
  &lt;/row&gt;

  &lt;row&gt;
	&lt;field name="person_id"&gt;7&lt;/field&gt;
	&lt;field name="fname"&gt;Sungam&lt;/field&gt;
	&lt;field name="lname"&gt;Dulbåd&lt;/field&gt;
  &lt;/row&gt;

  &lt;row&gt;
	&lt;field name="person_id"&gt;8&lt;/field&gt;
	&lt;field name="fname"&gt;Sreraf&lt;/field&gt;
	&lt;field name="lname"&gt;Encmelt&lt;/field&gt;
  &lt;/row&gt;
&lt;/resultset&gt;
</pre>
            <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">

                <div class="admon-title">
                    Note
                </div>
                <p>
                    The <a class="link" href="programs.html#option_mysql_xml"><code class="option">--xml</code></a> option causes the
                    <a class="link" href="programs.html#mysql" title="4.5.1&nbsp;mysql — The MySQL Command-Line Client"><span class="command"><strong>mysql</strong></span></a> client to use XML formatting for its
                    output; the <a class="link" href="programs.html#option_mysql_execute"><code class="option">-e</code></a>
                    option causes the client to execute the SQL statement
                    immediately following the option. See <a class="xref" href="programs.html#mysql" title="4.5.1&nbsp;mysql — The MySQL Command-Line Client">Section&nbsp;4.5.1, “<span class="command"><strong>mysql</strong></span> — The MySQL Command-Line Client”</a>.
                </p><p style="color:blue;">--xml选项使mysql客户机对其输出使用xml格式；-e选项使客户机紧跟在该选项之后执行sql语句。参见4.5.1节，“mysql-mysql命令行客户端”。</p>
            </div>
            <p>
                You can verify that the dump is valid by creating a copy of the
                <code class="literal">person</code> table and importing the dump file into
                the new table, like this:
            </p><p style="color:blue;">可以通过创建person表的副本并将转储文件导入新表来验证转储是否有效，如下所示：</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>USE test;</code></strong>
mysql&gt; <strong class="userinput"><code>CREATE TABLE person2 LIKE person;</code></strong>
Query OK, 0 rows affected (0.00 sec)

mysql&gt; <strong class="userinput"><code>LOAD XML LOCAL INFILE 'person-dump.xml'</code></strong>
    -&gt;   <strong class="userinput"><code>INTO TABLE person2;</code></strong>
Query OK, 8 rows affected (0.01 sec)
Records: 8  Deleted: 0  Skipped: 0  Warnings: 0

mysql&gt; <strong class="userinput"><code>SELECT * FROM person2;</code></strong>
+-----------+--------+------------+---------------------+
| person_id | fname  | lname      | created             |
+-----------+--------+------------+---------------------+
|         1 | Kapek  | Sainnouine | 2007-07-13 16:18:47 |
|         2 | Sajon  | Rondela    | 2007-07-13 16:18:47 |
|         3 | Likema | Örrtmons   | 2007-07-13 16:18:47 |
|         4 | Slar   | Manlanth   | 2007-07-13 16:18:47 |
|         5 | Stoma  | Nilu       | 2007-07-13 16:18:47 |
|         6 | Nirtam | Sklöd      | 2007-07-13 16:18:47 |
|         7 | Sungam | Dulbåd     | 2007-07-13 16:18:47 |
|         8 | Sreraf | Encmelt    | 2007-07-13 16:18:47 |
+-----------+--------+------------+---------------------+
8 rows in set (0.00 sec)
</pre><p>
            There is no requirement that every field in the XML file be
            matched with a column in the corresponding table. Fields which
            have no corresponding columns are skipped. You can see this by
            first emptying the <code class="literal">person2</code> table and dropping
            the <code class="literal">created</code> column, then using the same
            <a class="link" href="sql-syntax.html#load-xml" title="13.2.7&nbsp;LOAD XML Syntax"><code class="literal">LOAD XML</code></a> statement we just employed
            previously, like this:
        </p><p style="color:blue;">不要求XML文件中的每个字段都与对应表中的列匹配。将跳过没有相应列的字段。首先清空person2表并删除已创建的列，然后使用我们刚才使用的相同的load xml语句，如下所示：</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>TRUNCATE person2;</code></strong>
Query OK, 8 rows affected (0.26 sec)

mysql&gt; <strong class="userinput"><code>ALTER TABLE person2 DROP COLUMN created;</code></strong>
Query OK, 0 rows affected (0.52 sec)
Records: 0  Duplicates: 0  Warnings: 0

mysql&gt; <strong class="userinput"><code>SHOW CREATE TABLE person2\G</code></strong>
*************************** 1. row ***************************
       Table: person2
Create Table: CREATE TABLE `person2` (
  `person_id` int(11) NOT NULL,
  `fname` varchar(40) DEFAULT NULL,
  `lname` varchar(40) DEFAULT NULL,
  PRIMARY KEY (`person_id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8
1 row in set (0.00 sec)

mysql&gt; <strong class="userinput"><code>LOAD XML LOCAL INFILE 'person-dump.xml'</code></strong>
    -&gt;   <strong class="userinput"><code>INTO TABLE person2;</code></strong>
Query OK, 8 rows affected (0.01 sec)
Records: 8  Deleted: 0  Skipped: 0  Warnings: 0

mysql&gt; <strong class="userinput"><code>SELECT * FROM person2;</code></strong>
+-----------+--------+------------+
| person_id | fname  | lname      |
+-----------+--------+------------+
|         1 | Kapek  | Sainnouine |
|         2 | Sajon  | Rondela    |
|         3 | Likema | Örrtmons   |
|         4 | Slar   | Manlanth   |
|         5 | Stoma  | Nilu       |
|         6 | Nirtam | Sklöd      |
|         7 | Sungam | Dulbåd     |
|         8 | Sreraf | Encmelt    |
+-----------+--------+------------+
8 rows in set (0.00 sec)
</pre><p>
            The order in which the fields are given within each row of the XML
            file does not affect the operation of <a class="link" href="sql-syntax.html#load-xml" title="13.2.7&nbsp;LOAD XML Syntax"><code class="literal">LOAD
            XML</code></a>; the field order can vary from row to row, and is
            not required to be in the same order as the corresponding columns
            in the table.
        </p><p style="color:blue;">在XML文件的每一行中给定字段的顺序不影响加载XML的操作；字段顺序可以随行而变化，并且不要求与表中相应列的顺序相同。</p><p>
            As mentioned previously, you can use a
            <code class="literal">(<em class="replaceable"><code>field_name_or_user_var</code></em>,
                ...)</code> list of one or more XML fields (to select desired
            fields only) or user variables (to store the corresponding field
            values for later use). User variables can be especially useful
            when you want to insert data from an XML file into table columns
            whose names do not match those of the XML fields. To see how this
            works, we first create a table named <code class="literal">individual</code>
            whose structure matches that of the <code class="literal">person</code>
            table, but whose columns are named differently:
        </p><p style="color:blue;">如前所述，您可以使用一个或多个XML字段的（field_name_或_user_var，…）列表（仅用于选择所需字段）或用户变量（存储相应的字段值以供以后使用）。当您希望将XML文件中的数据插入名称与XML字段名称不匹配的表列时，用户变量尤其有用。为了了解其工作原理，我们首先创建一个名为individual的表，该表的结构与person表的结构匹配，但其列的名称不同：</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>CREATE TABLE individual (</code></strong>
    -&gt;     <strong class="userinput"><code>individual_id INT NOT NULL PRIMARY KEY,</code></strong>
    -&gt;     <strong class="userinput"><code>name1 VARCHAR(40) NULL,</code></strong>
    -&gt;     <strong class="userinput"><code>name2 VARCHAR(40) NULL,</code></strong>
    -&gt;     <strong class="userinput"><code>made TIMESTAMP</code></strong>
    -&gt; );
Query OK, 0 rows affected (0.42 sec)
</pre><p>
            In this case, you cannot simply load the XML file directly into
            the table, because the field and column names do not match:
        </p><p style="color:blue;">在这种情况下，不能简单地将XML文件直接加载到表中，因为字段名和列名不匹配：</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>LOAD XML INFILE '../bin/person-dump.xml' INTO TABLE test.individual;</code></strong>
ERROR 1263 (22004): Column set to default value; NULL supplied to NOT NULL column 'individual_id' at row 1
</pre><p>
            This happens because the MySQL server looks for field names
            matching the column names of the target table. You can work around
            this problem by selecting the field values into user variables,
            then setting the target table's columns equal to the values
            of those variables using <code class="literal">SET</code>. You can perform
            both of these operations in a single statement, as shown here:
        </p><p style="color:blue;">这是因为mysql服务器查找与目标表的列名匹配的字段名。可以通过在用户变量中选择字段值，然后使用set将目标表的列设置为这些变量的值来解决此问题。您可以在一个语句中执行这两个操作，如下所示：</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>LOAD XML INFILE '../bin/person-dump.xml'</code></strong>
    -&gt;     <strong class="userinput"><code>INTO TABLE test.individual (@person_id, @fname, @lname, @created)</code></strong>
    -&gt;     <strong class="userinput"><code>SET individual_id=@person_id, name1=@fname, name2=@lname, made=@created;</code></strong>
Query OK, 8 rows affected (0.05 sec)
Records: 8  Deleted: 0  Skipped: 0  Warnings: 0

mysql&gt; <strong class="userinput"><code>SELECT * FROM individual;</code></strong>
+---------------+--------+------------+---------------------+
| individual_id | name1  | name2      | made                |
+---------------+--------+------------+---------------------+
|             1 | Kapek  | Sainnouine | 2007-07-13 16:18:47 |
|             2 | Sajon  | Rondela    | 2007-07-13 16:18:47 |
|             3 | Likema | Örrtmons   | 2007-07-13 16:18:47 |
|             4 | Slar   | Manlanth   | 2007-07-13 16:18:47 |
|             5 | Stoma  | Nilu       | 2007-07-13 16:18:47 |
|             6 | Nirtam | Sklöd      | 2007-07-13 16:18:47 |
|             7 | Sungam | Dulbåd     | 2007-07-13 16:18:47 |
|             8 | Srraf  | Encmelt    | 2007-07-13 16:18:47 |
+---------------+--------+------------+---------------------+
8 rows in set (0.00 sec)
</pre><p>
            The names of the user variables <span class="emphasis"><em>must</em></span> match
            those of the corresponding fields from the XML file, with the
            addition of the required <code class="literal">@</code> prefix to indicate
            that they are variables. The user variables need not be listed or
            assigned in the same order as the corresponding fields.
        </p><p style="color:blue;">用户变量的名称必须与XML文件中相应字段的名称匹配，并添加必需的@前缀以指示它们是变量。用户变量不必按照与相应字段相同的顺序列出或分配。</p><p>
            Using a <code class="literal">ROWS IDENTIFIED BY
            '&lt;<em class="replaceable"><code>tagname</code></em>&gt;'</code> clause, it
            is possible to import data from the same XML file into database
            tables with different definitions. For this example, suppose that
            you have a file named <code class="filename">address.xml</code> which
            contains the following XML:
        </p><p style="color:blue;">使用由“<tagname>”子句标识的行，可以将同一XML文件中的数据导入具有不同定义的数据库表。对于本例，假设您有一个名为address.xml的文件，其中包含以下XML：</tagname></p><pre data-lang="xml" class="programlisting">&lt;?xml version="1.0"?&gt;

&lt;list&gt;
  &lt;person person_id="1"&gt;
    &lt;fname&gt;Robert&lt;/fname&gt;
    &lt;lname&gt;Jones&lt;/lname&gt;
    &lt;address address_id="1" street="Mill Creek Road" zip="45365" city="Sidney"/&gt;
    &lt;address address_id="2" street="Main Street" zip="28681" city="Taylorsville"/&gt;
  &lt;/person&gt;

  &lt;person person_id="2"&gt;
    &lt;fname&gt;Mary&lt;/fname&gt;
    &lt;lname&gt;Smith&lt;/lname&gt;
    &lt;address address_id="3" street="River Road" zip="80239" city="Denver"/&gt;
    &lt;!-- &lt;address address_id="4" street="North Street" zip="37920" city="Knoxville"/&gt; --&gt;
  &lt;/person&gt;

&lt;/list&gt;
</pre><p>
            You can again use the <code class="literal">test.person</code> table as
            defined previously in this section, after clearing all the
            existing records from the table and then showing its structure as
            shown here:
        </p><p style="color:blue;">在清除表中所有现有记录之后，可以再次使用在本节中定义的表，然后显示其结构，如下所示：</p><pre data-lang="sql" class="programlisting">mysql&lt; <strong class="userinput"><code>TRUNCATE person;</code></strong>
Query OK, 0 rows affected (0.04 sec)

mysql&lt; <strong class="userinput"><code>SHOW CREATE TABLE person\G</code></strong>
*************************** 1. row ***************************
       Table: person
Create Table: CREATE TABLE `person` (
  `person_id` int(11) NOT NULL,
  `fname` varchar(40) DEFAULT NULL,
  `lname` varchar(40) DEFAULT NULL,
  `created` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
  PRIMARY KEY (`person_id`)
) ENGINE=MyISAM DEFAULT CHARSET=latin1
1 row in set (0.00 sec)
</pre><p>
            Now create an <code class="literal">address</code> table in the
            <code class="literal">test</code> database using the following
            <a class="link" href="sql-syntax.html#create-table" title="13.1.18&nbsp;CREATE TABLE Syntax"><code class="literal">CREATE TABLE</code></a> statement:
        </p><p style="color:blue;">现在使用以下create table语句在测试数据库中创建一个地址表：</p><pre data-lang="sql" class="programlisting">CREATE TABLE address (
    address_id INT NOT NULL PRIMARY KEY,
    person_id INT NULL,
    street VARCHAR(40) NULL,
    zip INT NULL,
    city VARCHAR(40) NULL,
    created TIMESTAMP
);
</pre><p>
            To import the data from the XML file into the
            <code class="literal">person</code> table, execute the following
            <a class="link" href="sql-syntax.html#load-xml" title="13.2.7&nbsp;LOAD XML Syntax"><code class="literal">LOAD XML</code></a> statement, which specifies
            that rows are to be specified by the
            <code class="literal">&lt;person&gt;</code> element, as shown here;
        </p><p style="color:blue;">要将xml文件中的数据导入person表，请执行以下loadxml语句，该语句指定由<person>元素指定行，如下所示；</person></p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>LOAD XML LOCAL INFILE 'address.xml'</code></strong>
    -&gt;   <strong class="userinput"><code>INTO TABLE person</code></strong>
    -&gt;   <strong class="userinput"><code>ROWS IDENTIFIED BY '&lt;person&gt;';</code></strong>
Query OK, 2 rows affected (0.00 sec)
Records: 2  Deleted: 0  Skipped: 0  Warnings: 0
</pre><p>
            You can verify that the records were imported using a
            <a class="link" href="sql-syntax.html#select" title="13.2.9&nbsp;SELECT Syntax"><code class="literal">SELECT</code></a> statement:
        </p><p style="color:blue;">您可以使用select语句验证记录是否已导入：</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT * FROM person;</code></strong>
+-----------+--------+-------+---------------------+
| person_id | fname  | lname | created             |
+-----------+--------+-------+---------------------+
|         1 | Robert | Jones | 2007-07-24 17:37:06 |
|         2 | Mary   | Smith | 2007-07-24 17:37:06 |
+-----------+--------+-------+---------------------+
2 rows in set (0.00 sec)
</pre><p>
            Since the <code class="literal">&lt;address&gt;</code> elements in the XML
            file have no corresponding columns in the
            <code class="literal">person</code> table, they are skipped.
        </p><p style="color:blue;">由于xml文件中的</p><address>元素在person表中没有对应的列，因此将跳过它们。</address><p>
            To import the data from the <code class="literal">&lt;address&gt;</code>
            elements into the <code class="literal">address</code> table, use the
            <a class="link" href="sql-syntax.html#load-xml" title="13.2.7&nbsp;LOAD XML Syntax"><code class="literal">LOAD XML</code></a> statement shown here:
        </p><p style="color:blue;">要将数据从</p><address>元素导入address表，请使用如下所示的load xml语句：</address><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>LOAD XML LOCAL INFILE 'address.xml'</code></strong>
    -&gt;   <strong class="userinput"><code>INTO TABLE address</code></strong>
    -&gt;   <strong class="userinput"><code>ROWS IDENTIFIED BY '&lt;address&gt;';</code></strong>
Query OK, 3 rows affected (0.00 sec)
Records: 3  Deleted: 0  Skipped: 0  Warnings: 0
</pre><p>
            You can see that the data was imported using a
            <a class="link" href="sql-syntax.html#select" title="13.2.9&nbsp;SELECT Syntax"><code class="literal">SELECT</code></a> statement such as this one:
        </p><p style="color:blue;">您可以看到，数据是使用select语句导入的，例如：</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT * FROM address;</code></strong>
+------------+-----------+-----------------+-------+--------------+---------------------+
| address_id | person_id | street          | zip   | city         | created             |
+------------+-----------+-----------------+-------+--------------+---------------------+
|          1 |         1 | Mill Creek Road | 45365 | Sidney       | 2007-07-24 17:37:37 |
|          2 |         1 | Main Street     | 28681 | Taylorsville | 2007-07-24 17:37:37 |
|          3 |         2 | River Road      | 80239 | Denver       | 2007-07-24 17:37:37 |
+------------+-----------+-----------------+-------+--------------+---------------------+
3 rows in set (0.00 sec)
</pre><p>
            The data from the <code class="literal">&lt;address&gt;</code> element that
            is enclosed in XML comments is not imported. However, since there
            is a <code class="literal">person_id</code> column in the
            <code class="literal">address</code> table, the value of the
            <code class="literal">person_id</code> attribute from the parent
            <code class="literal">&lt;person&gt;</code> element for each
            <code class="literal">&lt;address&gt;</code> <span class="emphasis"><em>is</em></span>
            imported into the <code class="literal">address</code> table.
        </p><p style="color:blue;">不会导入包含在xml注释中的</p><address>元素中的数据。但是，由于地址表中有一个person_id列，因此每个<address>的parent<person>元素中person_id属性的值将导入到地址表中。</person></address></address><p><b>Security Considerations.&nbsp;</b>
            As with the <a class="link" href="sql-syntax.html#load-data" title="13.2.6&nbsp;LOAD DATA Syntax"><code class="literal">LOAD DATA</code></a> statement,
            the transfer of the XML file from the client host to the server
            host is initiated by the MySQL server. In theory, a patched
            server could be built that would tell the client program to
            transfer a file of the server's choosing rather than the file
            named by the client in the <a class="link" href="sql-syntax.html#load-xml" title="13.2.7&nbsp;LOAD XML Syntax"><code class="literal">LOAD
                XML</code></a> statement. Such a server could access any file on
            the client host to which the client user has read access.
        </p><p style="color:blue;">安全考虑。与load data语句一样，xml文件从客户机主机到服务器主机的传输由mysql服务器启动。理论上，可以构建一个修补服务器，告诉客户机程序传输服务器选择的文件，而不是客户机在load xml语句中命名的文件。这样的服务器可以访问客户机主机上客户机用户具有读取权限的任何文件。</p><p>
            In a Web environment, clients usually connect to MySQL from a Web
            server. A user that can run any command against the MySQL server
            can use <a class="link" href="sql-syntax.html#load-xml" title="13.2.7&nbsp;LOAD XML Syntax"><code class="literal">LOAD XML
            LOCAL</code></a> to read any files to which the Web server process
            has read access. In this environment, the client with respect to
            the MySQL server is actually the Web server, not the remote
            program being run by the user who connects to the Web server.
        </p><p style="color:blue;">在web环境中，客户机通常从web服务器连接到mysql。可以对mysql服务器运行任何命令的用户可以使用load xml local读取web服务器进程具有读取权限的任何文件。在这个环境中，mysql服务器的客户端实际上是web服务器，而不是连接到web服务器的用户运行的远程程序。</p><p>
            You can disable loading of XML files from clients by starting the
            server with <a class="link" href="server-administration.html#sysvar_local_infile"><code class="literal">--local-infile=0</code></a> or
            <a class="link" href="server-administration.html#sysvar_local_infile"><code class="literal">--local-infile=OFF</code></a>. This option
            can also be used when starting the <a class="link" href="programs.html#mysql" title="4.5.1&nbsp;mysql — The MySQL Command-Line Client"><span class="command"><strong>mysql</strong></span></a> client
            to disable <a class="link" href="sql-syntax.html#load-xml" title="13.2.7&nbsp;LOAD XML Syntax"><code class="literal">LOAD XML</code></a> for the
            duration of the client session.
        </p><p style="color:blue;">通过使用--local infile=0或--local infile=off启动服务器，可以禁用从客户端加载XML文件。启动mysql客户端时，也可以使用此选项在客户端会话期间禁用加载xml。</p><p>
            To prevent a client from loading XML files from the server, do not
            grant the <a class="link" href="security.html#priv_file"><code class="literal">FILE</code></a> privilege to the
            corresponding MySQL user account, or revoke this privilege if the
            client user account already has it.
        </p><p style="color:blue;">若要阻止客户端从服务器加载XML文件，请不要向相应的MySQL用户帐户授予文件权限，或者如果客户端用户帐户已经拥有此权限，则取消此权限。</p>
            <div class="important" style="margin-left: 0.5in; margin-right: 0.5in;">

                <div class="admon-title">
                    Important
                </div>
                <p>
                    Revoking the <a class="link" href="security.html#priv_file"><code class="literal">FILE</code></a> privilege (or
                    not granting it in the first place) keeps the user only from
                    executing the <a class="link" href="sql-syntax.html#load-xml" title="13.2.7&nbsp;LOAD XML Syntax"><code class="literal">LOAD XML</code></a> statement
                    (as well as the <a class="link" href="functions.html#function_load-file"><code class="literal">LOAD_FILE()</code></a>
                    function; it does <span class="emphasis"><em>not</em></span> prevent the user from
                    executing <a class="link" href="sql-syntax.html#load-xml" title="13.2.7&nbsp;LOAD XML Syntax"><code class="literal">LOAD XML
                    LOCAL</code></a>. To disallow this statement, you must start the
                    server or the client with <code class="option">--local-infile=OFF</code>.
                </p><p style="color:blue;">取消文件特权（或者不首先授予它）只会让用户无法执行LOAD XML语句（以及LOAD U FILE（）函数）；它不会阻止用户执行LOAD XML local。若要禁止此语句，必须使用--local infile=off启动服务器或客户端。</p><p>
                In other words, the <a class="link" href="security.html#priv_file"><code class="literal">FILE</code></a>
                privilege affects only whether the client can read files on the
                server; it has no bearing on whether the client can read files
                on the local file system.
            </p><p style="color:blue;">换句话说，文件特权只影响客户端是否可以读取服务器上的文件；它与客户端是否可以读取本地文件系统上的文件无关。</p>
            </div>
            <p>
                For partitioned tables using storage engines that employ table
                locks, such as <a class="link" href="storage-engines.html#myisam-storage-engine" title="15.2&nbsp;The MyISAM Storage Engine"><code class="literal">MyISAM</code></a>, any locks
                caused by <a class="link" href="sql-syntax.html#load-xml" title="13.2.7&nbsp;LOAD XML Syntax"><code class="literal">LOAD XML</code></a> perform locks on
                all partitions of the table. This does not apply to tables using
                storage engines which employ row-level locking, such as
                <a class="link" href="innodb-storage-engine.html" title="Chapter&nbsp;14&nbsp;The InnoDB Storage Engine"><code class="literal">InnoDB</code></a>. For more information, see
                <a class="xref" href="partitioning.html#partitioning-limitations-locking" title="22.6.4&nbsp;Partitioning and Locking">Section&nbsp;22.6.4, “Partitioning and Locking”</a>.
            </p><p style="color:blue;">对于使用使用表锁的存储引擎（如myisam）的分区表，由load xml引起的任何锁都会对表的所有分区执行锁。这不适用于使用使用行级锁定的存储引擎（如innodb）的表。有关更多信息，请参见第22.6.4节“分区和锁定”。</p>
        </div>
        <div class="section">
            <div class="titlepage">
                <div>
                    <div>
                        <h3 class="title"><a name="replace"></a>13.2.8&nbsp;REPLACE Syntax</h3>

                    </div>

                </div>

            </div>
            <a class="indexterm" name="idm140286835044736"></a><pre data-lang="sql" class="programlisting">REPLACE [LOW_PRIORITY | DELAYED]
    [INTO] <em class="replaceable"><code>tbl_name</code></em>
    [PARTITION (<em class="replaceable"><code>partition_name</code></em> [, <em class="replaceable"><code>partition_name</code></em>] ...)]
    [(<em class="replaceable"><code>col_name</code></em> [, <em class="replaceable"><code>col_name</code></em>] ...)]
    {VALUES | VALUE} (<em class="replaceable"><code>value_list</code></em>) [, (<em class="replaceable"><code>value_list</code></em>)] ...

REPLACE [LOW_PRIORITY | DELAYED]
    [INTO] <em class="replaceable"><code>tbl_name</code></em>
    [PARTITION (<em class="replaceable"><code>partition_name</code></em> [, <em class="replaceable"><code>partition_name</code></em>] ...)]
    SET <em class="replaceable"><code>assignment_list</code></em>

REPLACE [LOW_PRIORITY | DELAYED]
    [INTO] <em class="replaceable"><code>tbl_name</code></em>
    [PARTITION (<em class="replaceable"><code>partition_name</code></em> [, <em class="replaceable"><code>partition_name</code></em>] ...)]
    [(<em class="replaceable"><code>col_name</code></em> [, <em class="replaceable"><code>col_name</code></em>] ...)]
    SELECT ...

<em class="replaceable"><code>value</code></em>:
    {<em class="replaceable"><code>expr</code></em> | DEFAULT}

<em class="replaceable"><code>value_list</code></em>:
    <em class="replaceable"><code>value</code></em> [, <em class="replaceable"><code>value</code></em>] ...

<em class="replaceable"><code>assignment</code></em>:
    <em class="replaceable"><code>col_name</code></em> = <em class="replaceable"><code>value</code></em>

<em class="replaceable"><code>assignment_list</code></em>:
    <em class="replaceable"><code>assignment</code></em> [, <em class="replaceable"><code>assignment</code></em>] ...
</pre><p>
            <a class="link" href="sql-syntax.html#replace" title="13.2.8&nbsp;REPLACE Syntax"><code class="literal">REPLACE</code></a> works exactly like
            <a class="link" href="sql-syntax.html#insert" title="13.2.5&nbsp;INSERT Syntax"><code class="literal">INSERT</code></a>, except that if an old row
            in the table has the same value as a new row for a
            <code class="literal">PRIMARY KEY</code> or a <code class="literal">UNIQUE</code>
            index, the old row is deleted before the new row is inserted. See
            <a class="xref" href="sql-syntax.html#insert" title="13.2.5&nbsp;INSERT Syntax">Section&nbsp;13.2.5, “INSERT Syntax”</a>.
        </p><p style="color:blue;">replace的工作方式与insert完全相同，只是如果表中的旧行与主键或唯一索引的新行具有相同的值，则在插入新行之前会删除旧行。见第13.2.5节“插入语法”。</p><p>
            <a class="link" href="sql-syntax.html#replace" title="13.2.8&nbsp;REPLACE Syntax"><code class="literal">REPLACE</code></a> is a MySQL extension to the
            SQL standard. It either inserts, or <span class="emphasis"><em>deletes</em></span>
            and inserts. For another MySQL extension to standard
            SQL—that either inserts or
            <span class="emphasis"><em>updates</em></span>—see
            <a class="xref" href="sql-syntax.html#insert-on-duplicate" title="13.2.5.2&nbsp;INSERT ... ON DUPLICATE KEY UPDATE Syntax">Section&nbsp;13.2.5.2, “INSERT ... ON DUPLICATE KEY UPDATE Syntax”</a>.
        </p><p style="color:blue;">replace是sql标准的mysql扩展。它要么插入，要么删除并插入。有关插入或更新标准sql的另一个mysql扩展，请参见13.2.5.2节“插入…”。关于重复的密钥更新语法”。</p><p>
            <code class="literal">DELAYED</code> inserts and replaces were deprecated in
            MySQL 5.6. In MySQL 5.7, <code class="literal">DELAYED</code>
            is not supported. The server recognizes but ignores the
            <code class="literal">DELAYED</code> keyword, handles the replace as a
            nondelayed replace, and generates an
            <code class="literal">ER_WARN_LEGACY_SYNTAX_CONVERTED</code> warning.
            (<span class="quote">“<span class="quote">REPLACE DELAYED is no longer supported. The statement was
      converted to REPLACE.</span>”</span>) The <code class="literal">DELAYED</code>
            keyword will be removed in a future release.
        </p><p style="color:blue;">mysql 5.6中不推荐使用延迟插入和替换。在mysql 5.7中，不支持延迟。服务器识别但忽略delayed关键字，将replace作为非delayed replace处理，并生成er_warn_legacy_syntax_converted警告。（“不再支持延迟替换。语句已转换为replace。“）延迟的关键字将在以后的版本中删除。</p>
            <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">

                <div class="admon-title">
                    Note
                </div>
                <p>
                    <a class="link" href="sql-syntax.html#replace" title="13.2.8&nbsp;REPLACE Syntax"><code class="literal">REPLACE</code></a> makes sense only if a
                    table has a <code class="literal">PRIMARY KEY</code> or
                    <code class="literal">UNIQUE</code> index. Otherwise, it becomes
                    equivalent to <a class="link" href="sql-syntax.html#insert" title="13.2.5&nbsp;INSERT Syntax"><code class="literal">INSERT</code></a>, because
                    there is no index to be used to determine whether a new row
                    duplicates another.
                </p><p style="color:blue;">只有当表具有主键或唯一索引时，“替换”才有意义。否则，它就相当于insert，因为没有用于确定新行是否与另一行重复的索引。</p>
            </div>
            <p>
                Values for all columns are taken from the values specified in the
                <a class="link" href="sql-syntax.html#replace" title="13.2.8&nbsp;REPLACE Syntax"><code class="literal">REPLACE</code></a> statement. Any missing
                columns are set to their default values, just as happens for
                <a class="link" href="sql-syntax.html#insert" title="13.2.5&nbsp;INSERT Syntax"><code class="literal">INSERT</code></a>. You cannot refer to values
                from the current row and use them in the new row. If you use an
                assignment such as <code class="literal">SET
                <em class="replaceable"><code>col_name</code></em> =
                <em class="replaceable"><code>col_name</code></em> + 1</code>, the reference
                to the column name on the right hand side is treated as
                <a class="link" href="functions.html#function_default"><code class="literal">DEFAULT(<em class="replaceable"><code>col_name</code></em>)</code></a>,
                so the assignment is equivalent to <code class="literal">SET
                <em class="replaceable"><code>col_name</code></em> =
                DEFAULT(<em class="replaceable"><code>col_name</code></em>) + 1</code>.
            </p><p style="color:blue;">所有列的值都取自replace语句中指定的值。任何缺少的列都将设置为其默认值，就像insert一样。不能引用当前行中的值并在新行中使用它们。如果使用set col_name=col_name+1这样的赋值，则对右侧列名的引用将被视为默认值（col_name），因此该赋值等效于set col_name=default（col_name）+1。</p><p>
            To use <a class="link" href="sql-syntax.html#replace" title="13.2.8&nbsp;REPLACE Syntax"><code class="literal">REPLACE</code></a>, you must have both
            the <a class="link" href="security.html#priv_insert"><code class="literal">INSERT</code></a> and
            <a class="link" href="security.html#priv_delete"><code class="literal">DELETE</code></a> privileges for the table.
        </p><p style="color:blue;">若要使用REPLACE，您必须同时具有表的INSERT和DELETE权限。</p><a class="indexterm" name="idm140286834997104"></a><p>
            If a generated column is replaced explicitly, the only permitted
            value is <code class="literal">DEFAULT</code>. For information about
            generated columns, see
            <a class="xref" href="sql-syntax.html#create-table-generated-columns" title="13.1.18.8&nbsp;CREATE TABLE and Generated Columns">Section&nbsp;13.1.18.8, “CREATE TABLE and Generated Columns”</a>.
        </p><p style="color:blue;">如果显式替换生成的列，则唯一允许的值是默认值。有关生成列的信息，请参见第13.1.18.8节“创建表和生成列”。</p><p>
            <code class="literal">REPLACE</code> supports explicit partition selection
            using the <code class="literal">PARTITION</code> keyword with a list of
            comma-separated names of partitions, subpartitions, or both. As
            with <a class="link" href="sql-syntax.html#insert" title="13.2.5&nbsp;INSERT Syntax"><code class="literal">INSERT</code></a>, if it is not possible
            to insert the new row into any of these partitions or
            subpartitions, the <code class="literal">REPLACE</code> statement fails with
            the error <span class="errortext">Found a row not matching the given partition
      set</span>. For more information and examples, see
            <a class="xref" href="partitioning.html#partitioning-selection" title="22.5&nbsp;Partition Selection">Section&nbsp;22.5, “Partition Selection”</a>.
        </p><p style="color:blue;">Advices使用分区关键字、分区、子分区或两者的逗号分隔的名称来支持显式分区选择。与insert一样，如果无法将新行插入这些分区或子分区中的任何一个分区或子分区，则replace语句将失败，并出现错误found a row not matching the given partition set。有关更多信息和示例，请参见第22.5节“分区选择”。</p><p>
            The <a class="link" href="sql-syntax.html#replace" title="13.2.8&nbsp;REPLACE Syntax"><code class="literal">REPLACE</code></a> statement returns a
            count to indicate the number of rows affected. This is the sum of
            the rows deleted and inserted. If the count is 1 for a single-row
            <a class="link" href="sql-syntax.html#replace" title="13.2.8&nbsp;REPLACE Syntax"><code class="literal">REPLACE</code></a>, a row was inserted and no
            rows were deleted. If the count is greater than 1, one or more old
            rows were deleted before the new row was inserted. It is possible
            for a single row to replace more than one old row if the table
            contains multiple unique indexes and the new row duplicates values
            for different old rows in different unique indexes.
        </p><p style="color:blue;">replace语句返回一个计数以指示受影响的行数。这是删除和插入的行的总和。如果单个行替换的计数为1，则表示插入了一行，但未删除任何行。如果计数大于1，则在插入新行之前删除一个或多个旧行。如果表包含多个唯一索引，并且新行在不同的唯一索引中为不同的旧行复制值，则一行可以替换多个旧行。</p><p>
            The affected-rows count makes it easy to determine whether
            <a class="link" href="sql-syntax.html#replace" title="13.2.8&nbsp;REPLACE Syntax"><code class="literal">REPLACE</code></a> only added a row or whether
            it also replaced any rows: Check whether the count is 1 (added) or
            greater (replaced).
        </p><p style="color:blue;">受影响的行计数使确定replace是否只添加了一行或它是否还替换了任何行变得容易：检查该计数是1（已添加）还是更大（已替换）。</p><p>
            If you are using the C API, the affected-rows count can be
            obtained using the
            <a class="link" href="connectors-apis.html#mysql-affected-rows" title="27.8.7.1&nbsp;mysql_affected_rows()"><code class="literal">mysql_affected_rows()</code></a> function.
        </p><p style="color:blue;">如果使用的是C API，则可以使用mysql_infected_rows（）函数获取受影响的行数。</p><p>
            You cannot replace into a table and select from the same table in
            a subquery.
        </p><p style="color:blue;">不能替换为表并从子查询中的同一表中进行选择。</p><p>
            MySQL uses the following algorithm for
            <a class="link" href="sql-syntax.html#replace" title="13.2.8&nbsp;REPLACE Syntax"><code class="literal">REPLACE</code></a> (and
            <a class="link" href="sql-syntax.html#load-data" title="13.2.6&nbsp;LOAD DATA Syntax"><code class="literal">LOAD DATA ...
                REPLACE</code></a>):
        </p><p style="color:blue;">MySQL使用以下算法替换（和加载数据…替换）：</p>
            <div class="orderedlist">
                <ol class="orderedlist" type="1"><li class="listitem"><p>
                    Try to insert the new row into the table
                </p><p style="color:blue;">尝试将新行插入表中</p></li><li class="listitem"><p>
                    While the insertion fails because a duplicate-key error occurs
                    for a primary key or unique index:
                </p><p style="color:blue;">当插入失败时，因为主键或唯一索引出现重复键错误：</p>
                    <div class="orderedlist">
                        <ol class="orderedlist" type="a"><li class="listitem"><p>
                            Delete from the table the conflicting row that has the
                            duplicate key value
                        </p><p style="color:blue;">从表中删除具有重复键值的冲突行</p></li><li class="listitem"><p>
                            Try again to insert the new row into the table
                        </p><p style="color:blue;">再次尝试将新行插入表中</p></li></ol>
                    </div>
                </li></ol>
            </div>
            <p>
                It is possible that in the case of a duplicate-key error, a
                storage engine may perform the <code class="literal">REPLACE</code> as an
                update rather than a delete plus insert, but the semantics are the
                same. There are no user-visible effects other than a possible
                difference in how the storage engine increments
                <code class="literal">Handler_<em class="replaceable"><code>xxx</code></em></code> status
                variables.
            </p><p style="color:blue;">在出现重复密钥错误的情况下，存储引擎可能会将replace作为更新而不是delete-plus-insert来执行，但语义是相同的。除了存储引擎增加handler_xxx状态变量的方式可能不同之外，没有其他用户可见的效果。</p><p>
            Because the results of <code class="literal">REPLACE ... SELECT</code>
            statements depend on the ordering of rows from the
            <a class="link" href="sql-syntax.html#select" title="13.2.9&nbsp;SELECT Syntax"><code class="literal">SELECT</code></a> and this order cannot always
            be guaranteed, it is possible when logging these statements for
            the master and the slave to diverge. For this reason,
            <code class="literal">REPLACE ... SELECT</code> statements are flagged as
            unsafe for statement-based replication. such statements produce a
            warning in the error log when using statement-based mode and are
            written to the binary log using the row-based format when using
            <code class="literal">MIXED</code> mode. See also
            <a class="xref" href="replication.html#replication-sbr-rbr" title="16.2.1.1&nbsp;Advantages and Disadvantages of Statement-Based and Row-Based Replication">Section&nbsp;16.2.1.1, “Advantages and Disadvantages of Statement-Based and Row-Based
                Replication”</a>.
        </p><p style="color:blue;">因为替换的结果…select语句取决于select中的行的顺序，并且不能总是保证这个顺序，当记录这些语句时，主和从语句可能会发生偏离。因此，替换…对于基于语句的复制，select语句被标记为不安全。这种语句在使用基于语句的模式时在错误日志中生成警告，在使用混合模式时使用基于行的格式写入二进制日志。另见第16.2.1.1节“基于语句和基于行的复制的优缺点”。</p><p>
            When modifying an existing table that is not partitioned to
            accommodate partitioning, or, when modifying the partitioning of
            an already partitioned table, you may consider altering the
            table's primary key (see
            <a class="xref" href="partitioning.html#partitioning-limitations-partitioning-keys-unique-keys" title="22.6.1&nbsp;Partitioning Keys, Primary Keys, and Unique Keys">Section&nbsp;22.6.1, “Partitioning Keys, Primary Keys, and Unique Keys”</a>).
            You should be aware that, if you do this, the results of
            <code class="literal">REPLACE</code> statements may be affected, just as
            they would be if you modified the primary key of a nonpartitioned
            table. Consider the table created by the following
            <a class="link" href="sql-syntax.html#create-table" title="13.1.18&nbsp;CREATE TABLE Syntax"><code class="literal">CREATE TABLE</code></a> statement:
        </p><p style="color:blue;">在修改未分区的现有表以适应分区时，或者，当修改已分区表的分区时，可以考虑更改表的主键（参见第22.6节、“分区键、主键和Unique Keys”）。您应该知道，如果这样做，replace语句的结果可能会受到影响，就像修改非分区表的主键一样。考虑由以下create table语句创建的表：</p><pre data-lang="sql" class="programlisting">CREATE TABLE test (
  id INT UNSIGNED NOT NULL AUTO_INCREMENT,
  data VARCHAR(64) DEFAULT NULL,
  ts TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
  PRIMARY KEY (id)
);
</pre><p>
            When we create this table and run the statements shown in the
            mysql client, the result is as follows:
        </p><p style="color:blue;">当我们创建这个表并运行mysql客户机中显示的语句时，结果如下：</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>REPLACE INTO test VALUES (1, 'Old', '2014-08-20 18:47:00');</code></strong>
Query OK, 1 row affected (0.04 sec)

mysql&gt; <strong class="userinput"><code>REPLACE INTO test VALUES (1, 'New', '2014-08-20 18:47:42');</code></strong>
Query OK, 2 rows affected (0.04 sec)

mysql&gt; <strong class="userinput"><code>SELECT * FROM test;</code></strong>
+----+------+---------------------+
| id | data | ts                  |
+----+------+---------------------+
|  1 | New  | 2014-08-20 18:47:42 |
+----+------+---------------------+
1 row in set (0.00 sec)
</pre><p>
            Now we create a second table almost identical to the first, except
            that the primary key now covers 2 columns, as shown here
            (emphasized text):
        </p><p style="color:blue;">现在我们创建的第二个表与第一个表几乎相同，只是主键现在覆盖了两列，如下所示（强调文本）：</p><pre data-lang="sql" class="programlisting">CREATE TABLE test2 (
  id INT UNSIGNED NOT NULL AUTO_INCREMENT,
  data VARCHAR(64) DEFAULT NULL,
  ts TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
  <span class="emphasis"><em>PRIMARY KEY (id, ts)</em></span>
);
</pre><p>
            When we run on <code class="literal">test2</code> the same two
            <code class="literal">REPLACE</code> statements as we did on the original
            <code class="literal">test</code> table, we obtain a different result:
        </p><p style="color:blue;">当我们在test2上运行与在原始测试表上相同的两个replace语句时，会得到不同的结果：</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>REPLACE INTO test2 VALUES (1, 'Old', '2014-08-20 18:47:00');</code></strong>
Query OK, 1 row affected (0.05 sec)

mysql&gt; <strong class="userinput"><code>REPLACE INTO test2 VALUES (1, 'New', '2014-08-20 18:47:42');</code></strong>
Query OK, 1 row affected (0.06 sec)

mysql&gt; <strong class="userinput"><code>SELECT * FROM test2;</code></strong>
+----+------+---------------------+
| id | data | ts                  |
+----+------+---------------------+
|  1 | Old  | 2014-08-20 18:47:00 |
|  1 | New  | 2014-08-20 18:47:42 |
+----+------+---------------------+
2 rows in set (0.00 sec)
</pre><p>
            This is due to the fact that, when run on
            <code class="literal">test2</code>, both the <code class="literal">id</code> and
            <code class="literal">ts</code> column values must match those of an
            existing row for the row to be replaced; otherwise, a row is
            inserted.
        </p><p style="color:blue;">这是因为当在Test2上运行时，ID和TS列值必须匹配要替换的行的现有行的那些值；否则，插入行。</p><p>
            A <code class="literal">REPLACE</code> statement affecting a partitioned
            table using a storage engine such as
            <a class="link" href="storage-engines.html#myisam-storage-engine" title="15.2&nbsp;The MyISAM Storage Engine"><code class="literal">MyISAM</code></a> that employs table-level locks
            locks only those partitions containing rows that match the
            <code class="literal">REPLACE</code> statement <code class="literal">WHERE</code>
            clause, as long as none of the table partitioning columns are
            updated; otherwise the entire table is locked. (For storage
            engines such as <a class="link" href="innodb-storage-engine.html" title="Chapter&nbsp;14&nbsp;The InnoDB Storage Engine"><code class="literal">InnoDB</code></a> that employ
            row-level locking, no locking of partitions takes place.) For more
            information, see
            <a class="xref" href="partitioning.html#partitioning-limitations-locking" title="22.6.4&nbsp;Partitioning and Locking">Section&nbsp;22.6.4, “Partitioning and Locking”</a>.
        </p><p style="color:blue;">使用存储引擎（如使用表级锁的myisam）影响分区表的replace语句只锁定那些包含与replace语句where子句匹配的行的分区，只要没有更新表分区列；否则将锁定整个表。（对于使用行级锁定的存储引擎，如innodb，不会发生分区锁定。）有关更多信息，请参阅第22.6.4节“分区和锁定”。</p>
        </div>
        <div class="section">
            <div class="titlepage">
                <div>
                    <div>
                        <h3 class="title"><a name="select"></a>13.2.9&nbsp;SELECT Syntax</h3>

                    </div>

                </div>

            </div>
            <div class="toc">
                <dl class="toc"><dt><span class="section"><a href="sql-syntax.html#select-into">13.2.9.1 SELECT ... INTO Syntax</a></span></dt><dt><span class="section"><a href="sql-syntax.html#join">13.2.9.2 JOIN Syntax</a></span></dt><dt><span class="section"><a href="sql-syntax.html#union">13.2.9.3 UNION Syntax</a></span></dt></dl>
            </div>
            <a class="indexterm" name="idm140286834937776"></a><pre data-lang="sql" class="programlisting">SELECT
    [ALL | DISTINCT | DISTINCTROW ]
      [HIGH_PRIORITY]
      [STRAIGHT_JOIN]
      [SQL_SMALL_RESULT] [SQL_BIG_RESULT] [SQL_BUFFER_RESULT]
      [SQL_CACHE | SQL_NO_CACHE] [SQL_CALC_FOUND_ROWS]
    <em class="replaceable"><code>select_expr</code></em> [, <em class="replaceable"><code>select_expr</code></em> ...]
    [FROM <em class="replaceable"><code>table_references</code></em>
      [PARTITION <em class="replaceable"><code>partition_list</code></em>]
    [WHERE <em class="replaceable"><code>where_condition</code></em>]
    [GROUP BY {<em class="replaceable"><code>col_name</code></em> | <em class="replaceable"><code>expr</code></em> | <em class="replaceable"><code>position</code></em>}
      [ASC | DESC], ... [WITH ROLLUP]]
    [HAVING <em class="replaceable"><code>where_condition</code></em>]
    [ORDER BY {<em class="replaceable"><code>col_name</code></em> | <em class="replaceable"><code>expr</code></em> | <em class="replaceable"><code>position</code></em>}
      [ASC | DESC], ...]
    [LIMIT {[<em class="replaceable"><code>offset</code></em>,] <em class="replaceable"><code>row_count</code></em> | <em class="replaceable"><code>row_count</code></em> OFFSET <em class="replaceable"><code>offset</code></em>}]
    [PROCEDURE <em class="replaceable"><code>procedure_name</code></em>(<em class="replaceable"><code>argument_list</code></em>)]
    [INTO OUTFILE '<em class="replaceable"><code>file_name</code></em>'
        [CHARACTER SET <em class="replaceable"><code>charset_name</code></em>]
        <em class="replaceable"><code>export_options</code></em>
      | INTO DUMPFILE '<em class="replaceable"><code>file_name</code></em>'
      | INTO <em class="replaceable"><code>var_name</code></em> [, <em class="replaceable"><code>var_name</code></em>]]
    [FOR UPDATE | LOCK IN SHARE MODE]]
</pre><p>
            <a class="link" href="sql-syntax.html#select" title="13.2.9&nbsp;SELECT Syntax"><code class="literal">SELECT</code></a> is used to retrieve rows
            selected from one or more tables, and can include
            <a class="link" href="sql-syntax.html#union" title="13.2.9.3&nbsp;UNION Syntax"><code class="literal">UNION</code></a> statements and subqueries.
            See <a class="xref" href="sql-syntax.html#union" title="13.2.9.3&nbsp;UNION Syntax">Section&nbsp;13.2.9.3, “UNION Syntax”</a>, and <a class="xref" href="sql-syntax.html#subqueries" title="13.2.10&nbsp;Subquery Syntax">Section&nbsp;13.2.10, “Subquery Syntax”</a>.
        </p><p style="color:blue;">select用于检索从一个或多个表中选择的行，并且可以包括union语句和子查询。参见第13.2.9.3节“联合语法”和第13.2.10节“子查询语法”。</p><p>
            The most commonly used clauses of
            <a class="link" href="sql-syntax.html#select" title="13.2.9&nbsp;SELECT Syntax"><code class="literal">SELECT</code></a> statements are these:
        </p><p style="color:blue;">select语句最常用的子句如下：</p>
            <div class="itemizedlist">
                <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                    Each <em class="replaceable"><code>select_expr</code></em> indicates a column
                    that you want to retrieve. There must be at least one
                    <em class="replaceable"><code>select_expr</code></em>.
                </p><p style="color:blue;">每个select-expr表示要检索的列。必须至少有一个选择表达式。</p></li><li class="listitem"><p>
                    <em class="replaceable"><code>table_references</code></em> indicates the
                    table or tables from which to retrieve rows. Its syntax is
                    described in <a class="xref" href="sql-syntax.html#join" title="13.2.9.2&nbsp;JOIN Syntax">Section&nbsp;13.2.9.2, “JOIN Syntax”</a>.
                </p><p style="color:blue;">table_references表示要从中检索行的一个或多个表。其语法在第13.2.9.2节“连接语法”中进行了描述。</p></li><li class="listitem"><p>
                    <code class="literal">SELECT</code> supports explicit partition
                    selection using the <code class="literal">PARTITION</code> with a list
                    of partitions or subpartitions (or both) following the name of
                    the table in a <em class="replaceable"><code>table_reference</code></em> (see
                    <a class="xref" href="sql-syntax.html#join" title="13.2.9.2&nbsp;JOIN Syntax">Section&nbsp;13.2.9.2, “JOIN Syntax”</a>). In this case, rows are selected only
                    from the partitions listed, and any other partitions of the
                    table are ignored. For more information and examples, see
                    <a class="xref" href="partitioning.html#partitioning-selection" title="22.5&nbsp;Partition Selection">Section&nbsp;22.5, “Partition Selection”</a>.
                </p><p style="color:blue;">选择使用分区列表或分区（或两者）的分区来支持显式分区选择，在表引用中遵循表的名称（参见第132.2.2节，“连接语法”）。在这种情况下，只从列出的分区中选择行，而忽略表的任何其他分区。有关更多信息和示例，请参见第22.5节“分区选择”。</p><a class="indexterm" name="idm140286834907440"></a><p>
                    <code class="literal">SELECT ... PARTITION</code> from tables using
                    storage engines such as <a class="link" href="storage-engines.html#myisam-storage-engine" title="15.2&nbsp;The MyISAM Storage Engine"><code class="literal">MyISAM</code></a>
                    that perform table-level locks (and thus partition locks) lock
                    only the partitions or subpartitions named by the
                    <code class="literal">PARTITION</code> option.
                </p><p style="color:blue;">选择…使用MyISAM的存储引擎从表进行分区，执行表级锁（因此分区锁）只锁定分区选项命名的分区或子分区。</p><p>
                    For more information, see
                    <a class="xref" href="partitioning.html#partitioning-limitations-locking" title="22.6.4&nbsp;Partitioning and Locking">Section&nbsp;22.6.4, “Partitioning and Locking”</a>.
                </p><p style="color:blue;">有关更多信息，请参见第22.6.4节“分区和锁定”。</p></li><li class="listitem"><p>
                    The <code class="literal">WHERE</code> clause, if given, indicates the
                    condition or conditions that rows must satisfy to be selected.
                    <em class="replaceable"><code>where_condition</code></em> is an expression
                    that evaluates to true for each row to be selected. The
                    statement selects all rows if there is no
                    <code class="literal">WHERE</code> clause.
                </p><p style="color:blue;">where子句（如果给定）指示要选择行必须满足的一个或多个条件。其中，条件是对要选择的每一行求值为true的表达式。如果没有where子句，语句将选择所有行。</p><a class="indexterm" name="idm140286834898624"></a><p>
                    In the <code class="literal">WHERE</code> expression, you can use any of
                    the functions and operators that MySQL supports, except for
                    aggregate (summary) functions. See
                    <a class="xref" href="language-structure.html#expressions" title="9.5&nbsp;Expressions">Section&nbsp;9.5, “Expressions”</a>, and
                    <a class="xref" href="functions.html" title="Chapter&nbsp;12&nbsp;Functions and Operators">Chapter&nbsp;12, <i>Functions and Operators</i></a>.
                </p><p style="color:blue;">在where表达式中，可以使用mysql支持的任何函数和运算符，聚合（摘要）函数除外。见第9.5节“表达式”和第12章“函数和运算符”。</p><a class="indexterm" name="idm140286834894368"></a></li></ul>
            </div>
            <p>
                <a class="link" href="sql-syntax.html#select" title="13.2.9&nbsp;SELECT Syntax"><code class="literal">SELECT</code></a> can also be used to retrieve
                rows computed without reference to any table.
            </p><p style="color:blue;">select还可用于检索不引用任何表而计算的行。</p><p>
            For example:
        </p><p style="color:blue;">例如：</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT 1 + 1;</code></strong>
        -&gt; 2
</pre><p>
            <a class="indexterm" name="idm140286834886064"></a>

            You are permitted to specify <code class="literal">DUAL</code> as a dummy
            table name in situations where no tables are referenced:
        </p><p style="color:blue;">在没有引用表的情况下，允许指定dual作为伪表名：</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT 1 + 1 FROM DUAL;</code></strong>
        -&gt; 2
</pre><p>
            <code class="literal">DUAL</code> is purely for the convenience of people
            who require that all <a class="link" href="sql-syntax.html#select" title="13.2.9&nbsp;SELECT Syntax"><code class="literal">SELECT</code></a>
            statements should have <code class="literal">FROM</code> and possibly other
            clauses. MySQL may ignore the clauses. MySQL does not require
            <code class="literal">FROM DUAL</code> if no tables are referenced.
        </p><p style="color:blue;">dual纯粹是为了方便那些要求所有select语句都应该包含from和其他子句的人。mysql可能会忽略这些子句。如果没有引用表，mysql不需要来自dual。</p><p>
            In general, clauses used must be given in exactly the order shown
            in the syntax description. For example, a
            <code class="literal">HAVING</code> clause must come after any
            <code class="literal">GROUP BY</code> clause and before any <code class="literal">ORDER
            BY</code> clause. The exception is that the
            <code class="literal">INTO</code> clause can appear either as shown in the
            syntax description or immediately following the
            <em class="replaceable"><code>select_expr</code></em> list. For more information
            about <code class="literal">INTO</code>, see <a class="xref" href="sql-syntax.html#select-into" title="13.2.9.1&nbsp;SELECT ... INTO Syntax">Section&nbsp;13.2.9.1, “SELECT ... INTO Syntax”</a>.
        </p><p style="color:blue;">一般来说，使用的子句必须完全按照语法描述中显示的顺序给出。例如，HAVING子句必须在GROUP BY子句之后和ORDER BY子句之前。例外情况是into子句可以显示在语法描述中，也可以紧跟在select-expr列表之后。有关Into的更多信息，请参见第13.2.9.1节“选择…进入语法”。</p><p>
            The list of <em class="replaceable"><code>select_expr</code></em> terms comprises
            the select list that indicates which columns to retrieve. Terms
            specify a column or expression or can use
            <code class="literal">*</code>-shorthand:
        </p><p style="color:blue;">select-expr术语的列表包含选择列表，该列表指示要检索哪些列。术语指定列或表达式，或者可以使用*简写：</p>
            <div class="itemizedlist">
                <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                    A select list consisting only of a single unqualified
                    <code class="literal">*</code> can be used as shorthand to select all
                    columns from all tables:
                </p><p style="color:blue;">仅由一个不合格*组成的选择列表可用作从所有表中选择所有列的速记：</p><pre data-lang="sql" class="programlisting">SELECT * FROM t1 INNER JOIN t2 ...
</pre></li><li class="listitem"><p>
                    <code class="literal"><em class="replaceable"><code>tbl_name</code></em>.*</code> can
                    be used as a qualified shorthand to select all columns from
                    the named table:
                </p><p style="color:blue;">tbl_name.*可用作从命名表中选择所有列的限定速记：</p><pre data-lang="sql" class="programlisting">SELECT t1.*, t2.* FROM t1 INNER JOIN t2 ...
</pre></li><li class="listitem"><p>
                    Use of an unqualified <code class="literal">*</code> with other items in
                    the select list may produce a parse error. To avoid this
                    problem, use a qualified
                    <code class="literal"><em class="replaceable"><code>tbl_name</code></em>.*</code>
                    reference
                </p><p style="color:blue;">将不合格*与选择列表中的其他项一起使用可能会产生分析错误。若要避免此问题，请使用限定的tbl_name.*引用</p><pre data-lang="sql" class="programlisting">SELECT AVG(score), t1.* FROM t1 ...
</pre></li></ul>
            </div>
            <p>
                The following list provides additional information about other
                <code class="literal">SELECT</code> clauses:
            </p><p style="color:blue;">以下列表提供了有关其他select子句的其他信息：</p>
            <div class="itemizedlist">
                <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                    <a class="indexterm" name="idm140286834859568"></a>

                    <a class="indexterm" name="idm140286834858080"></a>

                    A <em class="replaceable"><code>select_expr</code></em> can be given an alias
                    using <code class="literal">AS
                    <em class="replaceable"><code>alias_name</code></em></code>. The alias is
                    used as the expression's column name and can be used in
                    <code class="literal">GROUP BY</code>, <code class="literal">ORDER BY</code>, or
                    <code class="literal">HAVING</code> clauses. For example:
                </p><p style="color:blue;">一个select-expr可以被赋予一个别名作为别名。别名用作表达式的列名，可以在GROUP BY、ORDER BY或HAVING子句中使用。例如：</p><pre data-lang="sql" class="programlisting">SELECT CONCAT(last_name,', ',first_name) AS full_name
  FROM mytable ORDER BY full_name;
</pre><p>
                    The <code class="literal">AS</code> keyword is optional when aliasing a
                    <em class="replaceable"><code>select_expr</code></em> with an identifier. The
                    preceding example could have been written like this:
                </p><p style="color:blue;">使用标识符为select-expr别名时，as关键字是可选的。前面的例子可以这样写：</p><pre data-lang="sql" class="programlisting">SELECT CONCAT(last_name,', ',first_name) full_name
  FROM mytable ORDER BY full_name;
</pre><p>
                    However, because the <code class="literal">AS</code> is optional, a
                    subtle problem can occur if you forget the comma between two
                    <em class="replaceable"><code>select_expr</code></em> expressions: MySQL
                    interprets the second as an alias name. For example, in the
                    following statement, <code class="literal">columnb</code> is treated as
                    an alias name:
                </p><p style="color:blue;">但是，由于as是可选的，如果忘记两个select-expr表达式之间的逗号，可能会出现一个微妙的问题：mysql将第二个表达式解释为别名。例如，在以下语句中，columnb被视为别名：</p><pre data-lang="sql" class="programlisting">SELECT columna columnb FROM mytable;
</pre><p>
                    For this reason, it is good practice to be in the habit of
                    using <code class="literal">AS</code> explicitly when specifying column
                    aliases.
                </p><p style="color:blue;">因此，在指定列别名时，最好养成显式使用的习惯。</p><p>
                    It is not permissible to refer to a column alias in a
                    <code class="literal">WHERE</code> clause, because the column value
                    might not yet be determined when the <code class="literal">WHERE</code>
                    clause is executed. See <a class="xref" href="error-handling.html#problems-with-alias" title="B.4.4.4&nbsp;Problems with Column Aliases">Section&nbsp;B.4.4.4, “Problems with Column Aliases”</a>.
                </p><p style="color:blue;">不允许在where子句中引用列别名，因为在执行where子句时可能尚未确定列值。见第B.4.4.4节，“列别名问题”。</p></li><li class="listitem"><p>
                    <a class="indexterm" name="idm140286834841328"></a>

                    <a class="indexterm" name="idm140286834840256"></a>

                    The <code class="literal">FROM
                    <em class="replaceable"><code>table_references</code></em></code> clause
                    indicates the table or tables from which to retrieve rows. If
                    you name more than one table, you are performing a join. For
                    information on join syntax, see <a class="xref" href="sql-syntax.html#join" title="13.2.9.2&nbsp;JOIN Syntax">Section&nbsp;13.2.9.2, “JOIN Syntax”</a>. For
                    each table specified, you can optionally specify an alias.
                </p><p style="color:blue;">from table_references子句指示要从中检索行的一个或多个表。如果命名了多个表，则表示正在执行联接。有关联接语法的信息，请参见第13.2.9.2节“联接语法”。对于指定的每个表，可以选择指定别名。</p><pre data-lang="sql" class="programlisting"><em class="replaceable"><code>tbl_name</code></em> [[AS] <em class="replaceable"><code>alias</code></em>] [<em class="replaceable"><code>index_hint</code></em>]
</pre><a class="indexterm" name="idm140286834834960"></a><a class="indexterm" name="idm140286834833888"></a><p>
                    The use of index hints provides the optimizer with information
                    about how to choose indexes during query processing. For a
                    description of the syntax for specifying these hints, see
                    <a class="xref" href="optimization.html#index-hints" title="8.9.4&nbsp;Index Hints">Section&nbsp;8.9.4, “Index Hints”</a>.
                </p><p style="color:blue;">索引提示的使用为优化器提供了有关如何在查询处理期间选择索引的信息。有关指定这些提示的语法说明，请参阅8.9.4节“索引提示”。</p><p>
                    You can use <code class="literal">SET
                    max_seeks_for_key=<em class="replaceable"><code>value</code></em></code>
                    as an alternative way to force MySQL to prefer key scans
                    instead of table scans. See
                    <a class="xref" href="server-administration.html#server-system-variables" title="5.1.7&nbsp;Server System Variables">Section&nbsp;5.1.7, “Server System Variables”</a>.
                </p><p style="color:blue;">您可以使用set max_seeks_for_key=value作为另一种强制mysql选择键扫描而不是表扫描的方法。见第5.1.7节“服务器系统变量”。</p></li><li class="listitem"><p>
                    You can refer to a table within the default database as
                    <em class="replaceable"><code>tbl_name</code></em>, or as
                    <em class="replaceable"><code>db_name</code></em>.<em class="replaceable"><code>tbl_name</code></em>
                    to specify a database explicitly. You can refer to a column as
                    <em class="replaceable"><code>col_name</code></em>,
                    <em class="replaceable"><code>tbl_name</code></em>.<em class="replaceable"><code>col_name</code></em>,
                    or
                    <em class="replaceable"><code>db_name</code></em>.<em class="replaceable"><code>tbl_name</code></em>.<em class="replaceable"><code>col_name</code></em>.
                    You need not specify a <em class="replaceable"><code>tbl_name</code></em> or
                    <em class="replaceable"><code>db_name</code></em>.<em class="replaceable"><code>tbl_name</code></em>
                    prefix for a column reference unless the reference would be
                    ambiguous. See <a class="xref" href="language-structure.html#identifier-qualifiers" title="9.2.2&nbsp;Identifier Qualifiers">Section&nbsp;9.2.2, “Identifier Qualifiers”</a>, for
                    examples of ambiguity that require the more explicit column
                    reference forms.
                </p><p style="color:blue;">可以将默认数据库中的表引用为tbl_name，或引用为db_name.tbl_name以显式指定数据库。可以将列引用为col_name、tbl_name.col_name或db_name.tbl_name.col_name。不需要为列引用指定tbl_name或db_name.tbl_name前缀，除非引用不明确。参见第9.2.2节“标识符限定符”，了解需要更明确的列引用形式的歧义示例。</p></li><li class="listitem"><p>
                    <a class="indexterm" name="idm140286834821072"></a>

                    <a class="indexterm" name="idm140286834819616"></a>

                    A table reference can be aliased using
                    <code class="literal"><em class="replaceable"><code>tbl_name</code></em> AS
                        <em class="replaceable"><code>alias_name</code></em></code> or
                    <em class="replaceable"><code>tbl_name alias_name</code></em>. These
                    statements are equivalent:
                </p><p style="color:blue;">表引用可以使用tbl_name作为别名或tbl_name alias_name作为别名。这些陈述相当于：</p><pre data-lang="sql" class="programlisting">SELECT t1.name, t2.salary FROM employee AS t1, info AS t2
  WHERE t1.name = t2.name;

SELECT t1.name, t2.salary FROM employee t1, info t2
  WHERE t1.name = t2.name;
</pre></li><li class="listitem"><p>
                    <a class="indexterm" name="idm140286834814848"></a>

                    Columns selected for output can be referred to in
                    <code class="literal">ORDER BY</code> and <code class="literal">GROUP BY</code>
                    clauses using column names, column aliases, or column
                    positions. Column positions are integers and begin with 1:
                </p><p style="color:blue;">为输出选择的列可以使用列名、列别名或列位置引用ORDER BY和GROUP BY子句。列位置是整数，以1开头：</p><pre data-lang="sql" class="programlisting">SELECT college, region, seed FROM tournament
  ORDER BY region, seed;

SELECT college, region AS r, seed AS s FROM tournament
  ORDER BY r, s;

SELECT college, region, seed FROM tournament
  ORDER BY 2, 3;
</pre><p>
                    To sort in reverse order, add the <code class="literal">DESC</code>
                    (descending) keyword to the name of the column in the
                    <code class="literal">ORDER BY</code> clause that you are sorting by.
                    The default is ascending order; this can be specified
                    explicitly using the <code class="literal">ASC</code> keyword.
                </p><p style="color:blue;">若要按相反顺序排序，请将DESC（降序）关键字添加到排序依据的ORDER BY子句中列的名称中。默认值是升序；这可以使用asc关键字显式指定。</p><p>
                    If <code class="literal">ORDER BY</code> occurs within a subquery and
                    also is applied in the outer query, the outermost
                    <code class="literal">ORDER BY</code> takes precedence. For example,
                    results for the following statement are sorted in descending
                    order, not ascending order:
                </p><p style="color:blue;">如果ORDER BY出现在子查询中并且也应用于外部查询，则最外部的ORDER BY优先。例如，以下语句的结果按降序排序，而不是按升序排序：</p><pre data-lang="sql" class="programlisting">(SELECT ... ORDER BY a) ORDER BY a DESC;
</pre><p>
                    Use of column positions is deprecated because the syntax has
                    been removed from the SQL standard.
                </p><p style="color:blue;">不赞成使用列位置，因为该语法已从SQL标准中删除。</p></li><li class="listitem"><p>
                    <a class="indexterm" name="idm140286834803920"></a>

                    MySQL extends the <code class="literal">GROUP BY</code> clause so that
                    you can also specify <code class="literal">ASC</code> and
                    <code class="literal">DESC</code> after columns named in the clause.
                    However, this syntax is deprecated. To produce a given sort
                    order, provide an <code class="literal">ORDER BY</code> clause.
                </p><p style="color:blue;">mysql扩展了group by子句，因此您还可以在子句中命名的列之后指定asc和desc。但是，此语法已被弃用。要生成给定的排序顺序，请提供ORDERBY子句。</p></li><li class="listitem"><p>
                    <a class="indexterm" name="idm140286834798608"></a>

                    <a class="indexterm" name="idm140286834797120"></a>

                    If you use <code class="literal">GROUP BY</code>, output rows are sorted
                    according to the <code class="literal">GROUP BY</code> columns as if you
                    had an <code class="literal">ORDER BY</code> for the same columns. To
                    avoid the overhead of sorting that <code class="literal">GROUP BY</code>
                    produces, add <code class="literal">ORDER BY NULL</code>:
                </p><p style="color:blue;">如果使用GROUPBY，则输出行将根据GROUPBY列进行排序，就像对同一列有ORDERBY一样。若要避免按生成的组进行排序的开销，请添加ORDER BY NULL：</p><pre data-lang="sql" class="programlisting">SELECT a, COUNT(b) FROM test_table GROUP BY a ORDER BY NULL;
</pre><p>
                    Relying on implicit <code class="literal">GROUP BY</code> sorting (that
                    is, sorting in the absence of <code class="literal">ASC</code> or
                    <code class="literal">DESC</code> designators) or explicit sorting for
                    <code class="literal">GROUP BY</code> (that is, by using explicit
                    <code class="literal">ASC</code> or <code class="literal">DESC</code> designators
                    for <code class="literal">GROUP BY</code> columns) is deprecated. To
                    produce a given sort order, provide an <code class="literal">ORDER
                    BY</code> clause.
                </p><p style="color:blue;">不赞成使用按排序的隐式分组（即，在没有ASC或DESC指示符的情况下进行排序）或按分组的显式排序（即，对按列分组使用显式ASC或DESC指示符）。要生成给定的排序顺序，请提供ORDERBY子句。</p></li><li class="listitem"><p>
                    <a class="indexterm" name="idm140286834783856"></a>

                    <a class="indexterm" name="idm140286834782368"></a>

                    When you use <code class="literal">ORDER BY</code> or <code class="literal">GROUP
                    BY</code> to sort a column in a
                    <a class="link" href="sql-syntax.html#select" title="13.2.9&nbsp;SELECT Syntax"><code class="literal">SELECT</code></a>, the server sorts values
                    using only the initial number of bytes indicated by the
                    <a class="link" href="server-administration.html#sysvar_max_sort_length"><code class="literal">max_sort_length</code></a> system
                    variable.
                </p><p style="color:blue;">使用ORDER BY或GROUP BY对选定内容中的列进行排序时，服务器仅使用由MAX SORT LENGTH系统变量指示的初始字节数对值进行排序。</p></li><li class="listitem"><p>
                    MySQL extends the use of <code class="literal">GROUP BY</code> to permit
                    selecting fields that are not mentioned in the <code class="literal">GROUP
                    BY</code> clause. If you are not getting the results that
                    you expect from your query, please read the description of
                    <code class="literal">GROUP BY</code> found in
                    <a class="xref" href="functions.html#group-by-functions-and-modifiers" title="12.20&nbsp;Aggregate (GROUP BY) Functions">Section&nbsp;12.20, “Aggregate (GROUP BY) Functions”</a>.
                </p><p style="color:blue;">mysql扩展了group by的使用，允许选择groupby子句中没有提到的字段。如果您没有从查询中获得预期的结果，请阅读第12.20节“聚合（分组）函数”中的分组依据说明。</p></li><li class="listitem"><p>
                    <code class="literal">GROUP BY</code> permits a <code class="literal">WITH
                    ROLLUP</code> modifier. See
                    <a class="xref" href="functions.html#group-by-modifiers" title="12.20.2&nbsp;GROUP BY Modifiers">Section&nbsp;12.20.2, “GROUP BY Modifiers”</a>.
                </p><p style="color:blue;">GROUPBY允许使用WITH ROLLUP修饰符。见第12.20.2节“按修饰语分组”。</p></li><li class="listitem"><p>
                    <a class="indexterm" name="idm140286834769184"></a>

                    The <code class="literal">HAVING</code> clause is applied nearly last,
                    just before items are sent to the client, with no
                    optimization. (<code class="literal">LIMIT</code> is applied after
                    <code class="literal">HAVING</code>.)
                </p><p style="color:blue;">having子句几乎最后一次应用，就在将项目发送到客户端之前，没有优化。（限值在之后应用。）</p><p>
                    The SQL standard requires that <code class="literal">HAVING</code> must
                    reference only columns in the <code class="literal">GROUP BY</code>
                    clause or columns used in aggregate functions. However, MySQL
                    supports an extension to this behavior, and permits
                    <code class="literal">HAVING</code> to refer to columns in the
                    <a class="link" href="sql-syntax.html#select" title="13.2.9&nbsp;SELECT Syntax"><code class="literal">SELECT</code></a> list and columns in
                    outer subqueries as well.
                </p><p style="color:blue;">sql标准要求having必须只引用group by子句中的列或聚合函数中使用的列。但是，mysql支持这种行为的扩展，并且允许必须引用select列表中的列和外部子查询中的列。</p><p>
                    If the <code class="literal">HAVING</code> clause refers to a column
                    that is ambiguous, a warning occurs. In the following
                    statement, <code class="literal">col2</code> is ambiguous because it is
                    used as both an alias and a column name:
                </p><p style="color:blue;">如果having子句引用不明确的列，则会出现警告。在以下语句中，COL2不明确，因为它同时用作别名和列名：</p><pre data-lang="sql" class="programlisting">SELECT COUNT(col1) AS col2 FROM t GROUP BY col2 HAVING col2 = 2;
</pre><p>
                    Preference is given to standard SQL behavior, so if a
                    <code class="literal">HAVING</code> column name is used both in
                    <code class="literal">GROUP BY</code> and as an aliased column in the
                    output column list, preference is given to the column in the
                    <code class="literal">GROUP BY</code> column.
                </p><p style="color:blue;">首选项是标准SQL行为，因此，如果在“分组依据”中使用having列名，并且在“输出列”列表中将having列名用作别名列，则首选项是“分组依据”列中的列。</p></li><li class="listitem"><p>
                    Do not use <code class="literal">HAVING</code> for items that should be
                    in the <code class="literal">WHERE</code> clause. For example, do not
                    write the following:
                </p><p style="color:blue;">不要对应该在where子句中的项使用having。例如，不要写以下内容：</p><pre data-lang="sql" class="programlisting">SELECT <em class="replaceable"><code>col_name</code></em> FROM <em class="replaceable"><code>tbl_name</code></em> HAVING <em class="replaceable"><code>col_name</code></em> &gt; 0;
</pre><p>
                    Write this instead:
                </p><p style="color:blue;">请改为：</p><pre data-lang="sql" class="programlisting">SELECT <em class="replaceable"><code>col_name</code></em> FROM <em class="replaceable"><code>tbl_name</code></em> WHERE <em class="replaceable"><code>col_name</code></em> &gt; 0;
</pre></li><li class="listitem"><p>
                    The <code class="literal">HAVING</code> clause can refer to aggregate
                    functions, which the <code class="literal">WHERE</code> clause cannot:
                </p><p style="color:blue;">having子句可以引用聚合函数，where子句不能：</p><pre data-lang="sql" class="programlisting">SELECT user, MAX(salary) FROM users
  GROUP BY user HAVING MAX(salary) &gt; 10;
</pre><p>
                    (This did not work in some older versions of MySQL.)
                </p><p style="color:blue;">（这在一些旧版本的mysql中不起作用。）</p></li><li class="listitem"><p>
                    MySQL permits duplicate column names. That is, there can be
                    more than one <em class="replaceable"><code>select_expr</code></em> with the
                    same name. This is an extension to standard SQL. Because MySQL
                    also permits <code class="literal">GROUP BY</code> and
                    <code class="literal">HAVING</code> to refer to
                    <em class="replaceable"><code>select_expr</code></em> values, this can result
                    in an ambiguity:
                </p><p style="color:blue;">mysql允许重复的列名。也就是说，可以有多个同名的select-expr。这是标准sql的扩展。由于mysql还允许group by，并且必须引用select-expr值，这可能会导致歧义：</p><pre data-lang="sql" class="programlisting">SELECT 12 AS a, a FROM t GROUP BY a;
</pre><p>
                    In that statement, both columns have the name
                    <code class="literal">a</code>. To ensure that the correct column is
                    used for grouping, use different names for each
                    <em class="replaceable"><code>select_expr</code></em>.
                </p><p style="color:blue;">在该语句中，两列都有名称A。为了确保使用正确的列进行分组，请为每个select-expr使用不同的名称。</p></li><li class="listitem"><p>
                    MySQL resolves unqualified column or alias references in
                    <code class="literal">ORDER BY</code> clauses by searching in the
                    <em class="replaceable"><code>select_expr</code></em> values, then in the
                    columns of the tables in the <code class="literal">FROM</code> clause.
                    For <code class="literal">GROUP BY</code> or <code class="literal">HAVING</code>
                    clauses, it searches the <code class="literal">FROM</code> clause before
                    searching in the <em class="replaceable"><code>select_expr</code></em>
                    values. (For <code class="literal">GROUP BY</code> and
                    <code class="literal">HAVING</code>, this differs from the pre-MySQL 5.0
                    behavior that used the same rules as for <code class="literal">ORDER
                    BY</code>.)
                </p><p style="color:blue;">mysql通过在select-expr值中搜索，然后在from子句中的表列中搜索，从而按order-by子句解析非限定列或别名引用。对于GROUP BY或HAVING子句，它在搜索SELECT EXPR值之前搜索FROM子句。（对于group by和having，这与mysql 5.0之前的行为不同，后者使用与orderby相同的规则。）</p></li><li class="listitem"><p>
                    <a class="indexterm" name="idm140286834730368"></a>

                    The <code class="literal">LIMIT</code> clause can be used to constrain
                    the number of rows returned by the
                    <a class="link" href="sql-syntax.html#select" title="13.2.9&nbsp;SELECT Syntax"><code class="literal">SELECT</code></a> statement.
                    <code class="literal">LIMIT</code> takes one or two numeric arguments,
                    which must both be nonnegative integer constants, with these
                    exceptions:
                </p><p style="color:blue;">limit子句可用于约束select语句返回的行数。LIMIT接受一个或两个数值参数，这两个参数都必须是非负整数常量，但以下情况除外：</p>
                    <div class="itemizedlist">
                        <ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
                            Within prepared statements, <code class="literal">LIMIT</code>
                            parameters can be specified using <code class="literal">?</code>
                            placeholder markers.
                        </p><p style="color:blue;">在准备好的语句中，可以使用？占位符标记。</p></li><li class="listitem"><p>
                            Within stored programs, <code class="literal">LIMIT</code>
                            parameters can be specified using integer-valued routine
                            parameters or local variables.
                        </p><p style="color:blue;">在存储程序中，可以使用整数值例程参数或局部变量指定限制参数。</p></li></ul>
                    </div>
                    <p>
                        With two arguments, the first argument specifies the offset of
                        the first row to return, and the second specifies the maximum
                        number of rows to return. The offset of the initial row is 0
                        (not 1):
                    </p><p style="color:blue;">使用两个参数，第一个参数指定要返回的第一行的偏移量，第二个参数指定要返回的最大行数。初始行的偏移量为0（不是1）：</p><pre data-lang="sql" class="programlisting">SELECT * FROM tbl LIMIT 5,10;  # Retrieve rows 6-15
</pre><p>
                        To retrieve all rows from a certain offset up to the end of
                        the result set, you can use some large number for the second
                        parameter. This statement retrieves all rows from the 96th row
                        to the last:
                    </p><p style="color:blue;">要从某个偏移量检索到结果集末尾的所有行，可以对第二个参数使用一些大数值。此语句检索从第96行到最后一行的所有行：</p><pre data-lang="sql" class="programlisting">SELECT * FROM tbl LIMIT 95,18446744073709551615;
</pre><p>
                        With one argument, the value specifies the number of rows to
                        return from the beginning of the result set:
                    </p><p style="color:blue;">对于一个参数，该值指定从结果集开头返回的行数：</p><pre data-lang="sql" class="programlisting">SELECT * FROM tbl LIMIT 5;     # Retrieve first 5 rows
</pre><p>
                        In other words, <code class="literal">LIMIT
                        <em class="replaceable"><code>row_count</code></em></code> is equivalent
                        to <code class="literal">LIMIT 0,
                        <em class="replaceable"><code>row_count</code></em></code>.
                    </p><p style="color:blue;">换句话说，限制行计数等于限制0，行计数。</p><p>
                        For prepared statements, you can use placeholders. The
                        following statements will return one row from the
                        <code class="literal">tbl</code> table:
                    </p><p style="color:blue;">对于准备好的语句，可以使用占位符。以下语句将从tbl表返回一行：</p><pre data-lang="sql" class="programlisting">SET @a=1;
PREPARE STMT FROM 'SELECT * FROM tbl LIMIT ?';
EXECUTE STMT USING @a;
</pre><p>
                        The following statements will return the second to sixth row
                        from the <code class="literal">tbl</code> table:
                    </p><p style="color:blue;">以下语句将返回tbl表中的第二行到第六行：</p><pre data-lang="sql" class="programlisting">SET @skip=1; SET @numrows=5;
PREPARE STMT FROM 'SELECT * FROM tbl LIMIT ?, ?';
EXECUTE STMT USING @skip, @numrows;
</pre><p>
                        For compatibility with PostgreSQL, MySQL also supports the
                        <code class="literal">LIMIT <em class="replaceable"><code>row_count</code></em> OFFSET
                            <em class="replaceable"><code>offset</code></em></code> syntax.
                    </p><p style="color:blue;">为了与postgresql兼容，mysql还支持限制行计数偏移量语法。</p><p>
                        If <code class="literal">LIMIT</code> occurs within a subquery and also
                        is applied in the outer query, the outermost
                        <code class="literal">LIMIT</code> takes precedence. For example, the
                        following statement produces two rows, not one:
                    </p><p style="color:blue;">如果限制发生在子查询中并且也应用于外部查询，则最外部的限制优先。例如，以下语句生成两行，而不是一行：</p><pre data-lang="sql" class="programlisting">(SELECT ... LIMIT 1) LIMIT 2;
</pre></li><li class="listitem"><p>
                    <a class="indexterm" name="idm140286834704736"></a>

                    A <code class="literal">PROCEDURE</code> clause names a procedure that
                    should process the data in the result set. For an example, see
                    <a class="xref" href="optimization.html#procedure-analyse" title="8.4.2.4&nbsp;Using PROCEDURE ANALYSE">Section&nbsp;8.4.2.4, “Using PROCEDURE ANALYSE”</a>, which describes
                    <code class="literal">ANALYSE</code>, a procedure that can be used to
                    obtain suggestions for optimal column data types that may help
                    reduce table sizes.
                </p><p style="color:blue;">procedure子句指定应处理结果集中数据的过程。例如，请参阅第8.4.2.4节“使用过程分析”，该节描述了分析，该过程可用于获得可能有助于减小表大小的最佳列数据类型的建议。</p><p>
                    A <code class="literal">PROCEDURE</code> clause is not permitted in a
                    <a class="link" href="sql-syntax.html#union" title="13.2.9.3&nbsp;UNION Syntax"><code class="literal">UNION</code></a> statement.
                </p><p style="color:blue;">union语句中不允许使用过程子句。</p>
                    <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">

                        <div class="admon-title">
                            Note
                        </div>
                        <p>
                            <code class="literal">PROCEDURE</code> syntax is deprecated as of
                            MySQL 5.7.18, and is removed in MySQL 8.0.
                        </p><p style="color:blue;">从mysql 5.7.18开始，过程语法就被弃用了，并在mysql 8.0中被删除。</p>
                    </div>
                </li><li class="listitem"><p>
                    The <a class="link" href="sql-syntax.html#select-into" title="13.2.9.1&nbsp;SELECT ... INTO Syntax"><code class="literal">SELECT ...
                    INTO</code></a> form of <a class="link" href="sql-syntax.html#select" title="13.2.9&nbsp;SELECT Syntax"><code class="literal">SELECT</code></a>
                    enables the query result to be written to a file or stored in
                    variables. For more information, see
                    <a class="xref" href="sql-syntax.html#select-into" title="13.2.9.1&nbsp;SELECT ... INTO Syntax">Section&nbsp;13.2.9.1, “SELECT ... INTO Syntax”</a>.
                </p><p style="color:blue;">选择…in to form of select允许将查询结果写入文件或存储在变量中。有关详细信息，请参见第13.2.9.1节“选择…进入语法”。</p></li><li class="listitem"><p>
                    <a class="indexterm" name="idm140286834692480"></a>

                    <a class="indexterm" name="idm140286834691408"></a>

                    If you use <code class="literal">FOR UPDATE</code> with a storage engine
                    that uses page or row locks, rows examined by the query are
                    write-locked until the end of the current transaction. Using
                    <code class="literal">LOCK IN SHARE MODE</code> sets a shared lock that
                    permits other transactions to read the examined rows but not
                    to update or delete them. See
                    <a class="xref" href="innodb-storage-engine.html#innodb-locking-reads" title="14.7.2.4&nbsp;Locking Reads">Section&nbsp;14.7.2.4, “Locking Reads”</a>.
                </p><p style="color:blue;">如果使用使用页锁或行锁的存储引擎进行更新，则查询检查的行将被写锁定，直到当前事务结束。在共享模式下使用锁将设置一个共享锁，允许其他事务读取检查的行，但不更新或删除它们。见第14.7.2.4节“锁定读数”。</p><p>
                    In addition, you cannot use <code class="literal">FOR UPDATE</code> as
                    part of the <a class="link" href="sql-syntax.html#select" title="13.2.9&nbsp;SELECT Syntax"><code class="literal">SELECT</code></a> in a
                    statement such as
                    <a class="link" href="sql-syntax.html#create-table-select" title="13.1.18.5&nbsp;CREATE TABLE ... SELECT Syntax"><code class="literal">CREATE
                        TABLE <em class="replaceable"><code>new_table</code></em> SELECT ... FROM
                        <em class="replaceable"><code>old_table</code></em> ...</code></a>. (If you
                    attempt to do so, the statement is rejected with the error
                    <span class="errortext">Can't update table
          '<em class="replaceable"><code>old_table</code></em>' while
          '<em class="replaceable"><code>new_table</code></em>' is being
          created</span>.) This is a change in behavior from MySQL
                    5.5 and earlier, which permitted
                    <a class="link" href="sql-syntax.html#create-table-select" title="13.1.18.5&nbsp;CREATE TABLE ... SELECT Syntax"><code class="literal">CREATE
                        TABLE ... SELECT</code></a> statements to make changes in
                    tables other than the table being created.
                </p><p style="color:blue;">此外，不能在诸如CREATE TABLE NEW U TABLE SELECT之类的语句中将UPDATE用作SELECT的一部分…从旧桌子…（如果尝试执行此操作，则语句将被拒绝，错误是在创建“new_table”时无法更新表“old_table”。）这是MySQL 5.5及更早版本的行为更改，该版本允许创建表…选择语句以在正在创建的表以外的表中进行更改。</p></li></ul>
            </div>
            <p>
                Following the <a class="link" href="sql-syntax.html#select" title="13.2.9&nbsp;SELECT Syntax"><code class="literal">SELECT</code></a> keyword, you
                can use a number of modifiers that affect the operation of the
                statement. <code class="literal">HIGH_PRIORITY</code>,
                <code class="literal">STRAIGHT_JOIN</code>, and modifiers beginning with
                <code class="literal">SQL_</code> are MySQL extensions to standard SQL.
            </p><p style="color:blue;">在select关键字之后，可以使用许多影响语句操作的修饰符。高优先级、直接连接和以sql开头的修饰符是标准sql的mysql扩展。</p>
            <div class="itemizedlist">
                <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                    The <code class="literal">ALL</code> and <code class="literal">DISTINCT</code>
                    modifiers specify whether duplicate rows should be returned.
                    <code class="literal">ALL</code> (the default) specifies that all
                    matching rows should be returned, including duplicates.
                    <code class="literal">DISTINCT</code> specifies removal of duplicate
                    rows from the result set. It is an error to specify both
                    modifiers. <code class="literal">DISTINCTROW</code> is a synonym for
                    <code class="literal">DISTINCT</code>.
                </p><p style="color:blue;">all和distinct修饰符指定是否应返回重复的行。all（默认值）指定应返回所有匹配行，包括重复行。DISTINCT指定从结果集中删除重复行。指定这两个修饰符是错误的。distinctrow是distinct的同义词。</p><a class="indexterm" name="idm140286834670496"></a><a class="indexterm" name="idm140286834669040"></a><a class="indexterm" name="idm140286834667552"></a></li><li class="listitem"><p>
                    <code class="literal">HIGH_PRIORITY</code> gives the
                    <a class="link" href="sql-syntax.html#select" title="13.2.9&nbsp;SELECT Syntax"><code class="literal">SELECT</code></a> higher priority than a
                    statement that updates a table. You should use this only for
                    queries that are very fast and must be done at once. A
                    <code class="literal">SELECT HIGH_PRIORITY</code> query that is issued
                    while the table is locked for reading runs even if there is an
                    update statement waiting for the table to be free. This
                    affects only storage engines that use only table-level locking
                    (such as <code class="literal">MyISAM</code>, <code class="literal">MEMORY</code>,
                    and <code class="literal">MERGE</code>).
                </p><p style="color:blue;">high_priority赋予select比更新表的语句更高的优先级。您应该仅对速度非常快且必须立即完成的查询使用此选项。在锁定表以供读取时发出的select high_priority查询即使有update语句等待表空闲也会运行。这只影响只使用表级锁定的存储引擎（例如myisam、内存和合并）。</p><a class="indexterm" name="idm140286834660096"></a><p>
                    <code class="literal">HIGH_PRIORITY</code> cannot be used with
                    <a class="link" href="sql-syntax.html#select" title="13.2.9&nbsp;SELECT Syntax"><code class="literal">SELECT</code></a> statements that are part
                    of a <a class="link" href="sql-syntax.html#union" title="13.2.9.3&nbsp;UNION Syntax"><code class="literal">UNION</code></a>.
                </p><p style="color:blue;">高优先级不能与属于联合的select语句一起使用。</p></li><li class="listitem"><p>
                    <code class="literal">STRAIGHT_JOIN</code> forces the optimizer to join
                    the tables in the order in which they are listed in the
                    <code class="literal">FROM</code> clause. You can use this to speed up a
                    query if the optimizer joins the tables in nonoptimal order.
                    <code class="literal">STRAIGHT_JOIN</code> also can be used in the
                    <em class="replaceable"><code>table_references</code></em> list. See
                    <a class="xref" href="sql-syntax.html#join" title="13.2.9.2&nbsp;JOIN Syntax">Section&nbsp;13.2.9.2, “JOIN Syntax”</a>.
                </p><p style="color:blue;">直线连接强制优化器按照from子句中列出的顺序连接表。如果优化器以非最佳顺序联接表，则可以使用此选项加快查询速度。直接连接也可用于表引用列表中。参见第13.2.9.2节“连接语法”。</p><a class="indexterm" name="idm140286834650720"></a><a class="indexterm" name="idm140286834649232"></a><a class="indexterm" name="idm140286834647744"></a><p>
                    <code class="literal">STRAIGHT_JOIN</code> does not apply to any table
                    that the optimizer treats as a
                    <a class="link" href="optimization.html#jointype_const"><code class="literal">const</code></a> or
                    <a class="link" href="optimization.html#jointype_system"><code class="literal">system</code></a> table. Such a table
                    produces a single row, is read during the optimization phase
                    of query execution, and references to its columns are replaced
                    with the appropriate column values before query execution
                    proceeds. These tables will appear first in the query plan
                    displayed by <a class="link" href="sql-syntax.html#explain" title="13.8.2&nbsp;EXPLAIN Syntax"><code class="literal">EXPLAIN</code></a>. See
                    <a class="xref" href="optimization.html#using-explain" title="8.8.1&nbsp;Optimizing Queries with EXPLAIN">Section&nbsp;8.8.1, “Optimizing Queries with EXPLAIN”</a>. This exception may not apply
                    to <a class="link" href="optimization.html#jointype_const"><code class="literal">const</code></a> or
                    <a class="link" href="optimization.html#jointype_system"><code class="literal">system</code></a> tables that are used
                    on the <code class="literal">NULL</code>-complemented side of an outer
                    join (that is, the right-side table of a <code class="literal">LEFT
                    JOIN</code> or the left-side table of a <code class="literal">RIGHT
                    JOIN</code>.
                </p><p style="color:blue;">直联接不适用于优化器视为常量或系统表的任何表。这样的表生成一行，在查询执行的优化阶段读取，并且在执行查询之前，对其列的引用将替换为相应的列值。这些表将首先出现在explain显示的查询计划中。参见第8.8.1节“使用解释优化查询”。此异常可能不适用于外部联接（即，左联接的右侧表或右联接的左侧表）的空补边上使用的常量表或系统表。</p></li><li class="listitem"><p>
                    <code class="literal">SQL_BIG_RESULT</code> or
                    <code class="literal">SQL_SMALL_RESULT</code> can be used with
                    <code class="literal">GROUP BY</code> or <code class="literal">DISTINCT</code> to
                    tell the optimizer that the result set has many rows or is
                    small, respectively. For <code class="literal">SQL_BIG_RESULT</code>,
                    MySQL directly uses disk-based temporary tables if they are
                    created, and prefers sorting to using a temporary table with a
                    key on the <code class="literal">GROUP BY</code> elements. For
                    <code class="literal">SQL_SMALL_RESULT</code>, MySQL uses in-memory
                    temporary tables to store the resulting table instead of using
                    sorting. This should not normally be needed.
                </p><p style="color:blue;">sql_big_result或sql_small_result可以与group by或distinct一起使用，以告诉优化器结果集分别具有多行或较小的行。对于sql_big_result，如果创建了基于磁盘的临时表，mysql会直接使用这些表，并且比起使用在group by元素上带有键的临时表，mysql更喜欢排序。对于sql_small_result，mysql使用内存中的临时表来存储结果表，而不是使用排序。这通常是不需要的。</p><a class="indexterm" name="idm140286834629440"></a><a class="indexterm" name="idm140286834627952"></a></li><li class="listitem"><p>
                    <code class="literal">SQL_BUFFER_RESULT</code> forces the result to be
                    put into a temporary table. This helps MySQL free the table
                    locks early and helps in cases where it takes a long time to
                    send the result set to the client. This modifier can be used
                    only for top-level <a class="link" href="sql-syntax.html#select" title="13.2.9&nbsp;SELECT Syntax"><code class="literal">SELECT</code></a>
                    statements, not for subqueries or following
                    <a class="link" href="sql-syntax.html#union" title="13.2.9.3&nbsp;UNION Syntax"><code class="literal">UNION</code></a>.
                </p><p style="color:blue;">sql_buffer_result强制将结果放入临时表中。这有助于mysql尽早释放表锁，并在将结果集发送到客户端需要很长时间的情况下提供帮助。此修饰符只能用于顶级select语句，不能用于子查询或后续union。</p><a class="indexterm" name="idm140286834622208"></a></li><li class="listitem"><p>
                    <code class="literal">SQL_CALC_FOUND_ROWS</code> tells MySQL to
                    calculate how many rows there would be in the result set,
                    disregarding any <code class="literal">LIMIT</code> clause. The number
                    of rows can then be retrieved with <code class="literal">SELECT
                    FOUND_ROWS()</code>. See
                    <a class="xref" href="functions.html#information-functions" title="12.15&nbsp;Information Functions">Section&nbsp;12.15, “Information Functions”</a>.
                </p><p style="color:blue;">sql_calc_found_rows告诉mysql计算结果集中有多少行，而不考虑任何limit子句。然后可以使用select found_rows（）检索行数。见第12.15节“信息功能”。</p><a class="indexterm" name="idm140286834616960"></a></li><li class="listitem"><p>
                    The <code class="literal">SQL_CACHE</code> and
                    <code class="literal">SQL_NO_CACHE</code> modifiers affect caching of
                    query results in the query cache (see
                    <a class="xref" href="optimization.html#query-cache" title="8.10.3&nbsp;The MySQL Query Cache">Section&nbsp;8.10.3, “The MySQL Query Cache”</a>). <code class="literal">SQL_CACHE</code>
                    tells MySQL to store the result in the query cache if it is
                    cacheable and the value of the
                    <a class="link" href="server-administration.html#sysvar_query_cache_type"><code class="literal">query_cache_type</code></a> system
                    variable is <code class="literal">2</code> or <code class="literal">DEMAND</code>.
                    With <code class="literal">SQL_NO_CACHE</code>, the server does not use
                    the query cache. It neither checks the query cache to see
                    whether the result is already cached, nor does it cache the
                    query result.
                </p><p style="color:blue;">sql_cache和sql_no_cache修饰符会影响查询缓存中查询结果的缓存（请参阅第8.10.3节“mysql查询缓存”）。sql_cache告诉mysql，如果结果是可缓存的，并且query_cache_type系统变量的值是2或demand，则将结果存储在查询缓存中。对于SQL无缓存，服务器不使用查询缓存。它既不检查查询缓存以查看结果是否已缓存，也不缓存查询结果。</p><a class="indexterm" name="idm140286834608144"></a><a class="indexterm" name="idm140286834606656"></a><p>
                    These two modifiers are mutually exclusive and an error occurs
                    if they are both specified. Also, these modifiers are not
                    permitted in subqueries (including subqueries in the
                    <code class="literal">FROM</code> clause), and
                    <a class="link" href="sql-syntax.html#select" title="13.2.9&nbsp;SELECT Syntax"><code class="literal">SELECT</code></a> statements in unions
                    other than the first <a class="link" href="sql-syntax.html#select" title="13.2.9&nbsp;SELECT Syntax"><code class="literal">SELECT</code></a>.
                </p><p style="color:blue;">这两个修饰符是互斥的，如果它们都被指定，则会发生错误。此外，这些修饰符在子查询（包括from子句中的子查询）和除第一个select之外的联合中不允许使用。</p><p>
                    For views, <code class="literal">SQL_NO_CACHE</code> applies if it
                    appears in any <a class="link" href="sql-syntax.html#select" title="13.2.9&nbsp;SELECT Syntax"><code class="literal">SELECT</code></a> in the
                    query. For a cacheable query, <code class="literal">SQL_CACHE</code>
                    applies if it appears in the first
                    <a class="link" href="sql-syntax.html#select" title="13.2.9&nbsp;SELECT Syntax"><code class="literal">SELECT</code></a> of a view referred to by
                    the query.
                </p><p style="color:blue;">对于视图，如果sql_no_cache出现在查询中的任何select中，则它将应用。对于可缓存查询，如果它出现在查询所引用的视图的第一个选择中，则会应用SQL缓存。</p>
                    <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">

                        <div class="admon-title">
                            Note
                        </div>
                        <p>
                            The query cache is deprecated as of MySQL 5.7.20, and is
                            removed in MySQL 8.0. Deprecation includes
                            <code class="literal">SQL_CACHE</code> and
                            <code class="literal">SQL_NO_CACHE</code>.
                        </p><p style="color:blue;">从mysql 5.7.20开始，查询缓存已被弃用，并在mysql 8.0中被删除。不推荐使用的缓存包括sql_cache和sql_no_cache。</p>
                    </div>
                </li></ul>
            </div>
            <p>
                A <code class="literal">SELECT</code> from a partitioned table using a
                storage engine such as <a class="link" href="storage-engines.html#myisam-storage-engine" title="15.2&nbsp;The MyISAM Storage Engine"><code class="literal">MyISAM</code></a> that
                employs table-level locks locks only those partitions containing
                rows that match the <code class="literal">SELECT</code> statement
                <code class="literal">WHERE</code> clause. (This does not occur with storage
                engines such as <a class="link" href="innodb-storage-engine.html" title="Chapter&nbsp;14&nbsp;The InnoDB Storage Engine"><code class="literal">InnoDB</code></a> that employ
                row-level locking.) For more information, see
                <a class="xref" href="partitioning.html#partitioning-limitations-locking" title="22.6.4&nbsp;Partitioning and Locking">Section&nbsp;22.6.4, “Partitioning and Locking”</a>.
            </p><p style="color:blue;">使用存储引擎（如使用表级锁的myisam）的分区表中的select只锁定那些包含与select语句where子句匹配的行的分区。（这在使用行级锁定的innodb等存储引擎中不会发生）有关更多信息，请参阅22.6.4节“分区和锁定”。</p>
            <div class="section">

                <div class="titlepage">
                    <div>
                        <div>
                            <h4 class="title"><a name="select-into"></a>13.2.9.1&nbsp;SELECT ... INTO Syntax</h4>
                        </div>
                    </div>
                </div>
                <a class="indexterm" name="idm140286834587184"></a><a class="indexterm" name="idm140286834585696"></a><p>
                The <a class="link" href="sql-syntax.html#select-into" title="13.2.9.1&nbsp;SELECT ... INTO Syntax"><code class="literal">SELECT ...
                INTO</code></a> form of <a class="link" href="sql-syntax.html#select" title="13.2.9&nbsp;SELECT Syntax"><code class="literal">SELECT</code></a>
                enables a query result to be stored in variables or written to a
                file:
            </p><p style="color:blue;">选择…in to form of select允许将查询结果存储在变量中或写入文件：</p>
                <div class="itemizedlist">
                    <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                        <code class="literal">SELECT ... INTO
                            <em class="replaceable"><code>var_list</code></em></code> selects column
                        values and stores them into variables.
                    </p><p style="color:blue;">选择…into var_list选择列值并将它们存储到变量中。</p></li><li class="listitem"><p>
                        <code class="literal">SELECT ... INTO OUTFILE</code> writes the
                        selected rows to a file. Column and line terminators can be
                        specified to produce a specific output format.
                    </p><p style="color:blue;">选择…into outfile将所选行写入文件。可以指定列和行终止符以生成特定的输出格式。</p></li><li class="listitem"><p>
                        <code class="literal">SELECT ... INTO DUMPFILE</code> writes a single
                        row to a file without any formatting.
                    </p><p style="color:blue;">选择…在转储文件中写入一行到一个文件，不带任何格式。</p></li></ul>
                </div>
                <p>
                    The <a class="link" href="sql-syntax.html#select" title="13.2.9&nbsp;SELECT Syntax"><code class="literal">SELECT</code></a> syntax description
                    (see <a class="xref" href="sql-syntax.html#select" title="13.2.9&nbsp;SELECT Syntax">Section&nbsp;13.2.9, “SELECT Syntax”</a>) shows the <code class="literal">INTO</code>
                    clause near the end of the statement. It is also possible to use
                    <code class="literal">INTO</code> immediately following the
                    <em class="replaceable"><code>select_expr</code></em> list.
                </p><p style="color:blue;">select语法描述（参见第13.2.9节“select语法”）在语句末尾附近显示了into子句。也可以直接在select-expr列表后面使用into。</p><p>
                An <code class="literal">INTO</code> clause should not be used in a nested
                <a class="link" href="sql-syntax.html#select" title="13.2.9&nbsp;SELECT Syntax"><code class="literal">SELECT</code></a> because such a
                <a class="link" href="sql-syntax.html#select" title="13.2.9&nbsp;SELECT Syntax"><code class="literal">SELECT</code></a> must return its result to
                the outer context.
            </p><p style="color:blue;">不应在嵌套的select中使用in to子句，因为这样的select必须将其结果返回到外部上下文。</p><p>
                The <code class="literal">INTO</code> clause can name a list of one or
                more variables, which can be user-defined variables, stored
                procedure or function parameters, or stored program local
                variables. (Within a prepared <code class="literal">SELECT ... INTO
                OUTFILE</code> statement, only user-defined variables are
                permitted;see <a class="xref" href="sql-syntax.html#local-variable-scope" title="13.6.4.2&nbsp;Local Variable Scope and Resolution">Section&nbsp;13.6.4.2, “Local Variable Scope and Resolution”</a>.)
            </p><p style="color:blue;">into子句可以命名一个或多个变量的列表，这些变量可以是用户定义的变量、存储过程或函数参数，也可以是存储程序局部变量。（在准备好的选择中…在outfile语句中，只允许用户定义变量；请参阅第13.6.4.2节“局部变量范围和分辨率”。）</p><p>
                The selected values are assigned to the variables. The number of
                variables must match the number of columns. The query should
                return a single row. If the query returns no rows, a warning
                with error code 1329 occurs (<code class="literal">No data</code>), and
                the variable values remain unchanged. If the query returns
                multiple rows, error 1172 occurs (<code class="literal">Result consisted of
                more than one row</code>). If it is possible that the
                statement may retrieve multiple rows, you can use <code class="literal">LIMIT
                1</code> to limit the result set to a single row.
            </p><p style="color:blue;">选定的值将分配给变量。变量数必须与列数匹配。查询应返回一行。如果查询未返回任何行，则会出现错误代码1329（无数据）的警告，并且变量值保持不变。如果查询返回多行，则会发生错误1172（结果由多行组成）。如果语句可能检索多行，则可以使用LIMIT 1将结果集限制为一行。</p><pre data-lang="sql" class="programlisting">SELECT id, data INTO @x, @y FROM test.t1 LIMIT 1;
</pre><p>
                User variable names are not case-sensitive. See
                <a class="xref" href="language-structure.html#user-variables" title="9.4&nbsp;User-Defined Variables">Section&nbsp;9.4, “User-Defined Variables”</a>.
            </p><p style="color:blue;">用户变量名不区分大小写。见第9.4节“用户定义变量”。</p><a class="indexterm" name="idm140286834559856"></a><a class="indexterm" name="idm140286834558784"></a><p>
                The <a class="link" href="sql-syntax.html#select-into" title="13.2.9.1&nbsp;SELECT ... INTO Syntax"><code class="literal">SELECT ... INTO
                OUTFILE '<em class="replaceable"><code>file_name</code></em>'</code></a> form of
                <a class="link" href="sql-syntax.html#select" title="13.2.9&nbsp;SELECT Syntax"><code class="literal">SELECT</code></a> writes the selected rows
                to a file. The file is created on the server host, so you must
                have the <a class="link" href="security.html#priv_file"><code class="literal">FILE</code></a> privilege to use
                this syntax. <em class="replaceable"><code>file_name</code></em> cannot be an
                existing file, which among other things prevents files such as
                <code class="filename">/etc/passwd</code> and database tables from being
                destroyed. The
                <a class="link" href="server-administration.html#sysvar_character_set_filesystem"><code class="literal">character_set_filesystem</code></a> system
                variable controls the interpretation of the file name.
            </p><p style="color:blue;">选择…select的outfile'file_name'表单将所选行写入文件。文件是在服务器主机上创建的，因此您必须具有文件权限才能使用此语法。文件名不能是一个现有文件，它防止其他文件，例如/ETC/PASSWD和数据库表被破坏。字符集文件系统变量控制文件名的解释。</p><p>
                The <a class="link" href="sql-syntax.html#select-into" title="13.2.9.1&nbsp;SELECT ... INTO Syntax"><code class="literal">SELECT ... INTO
                OUTFILE</code></a> statement is intended primarily to let you
                very quickly dump a table to a text file on the server machine.
                If you want to create the resulting file on some other host than
                the server host, you normally cannot use
                <a class="link" href="sql-syntax.html#select-into" title="13.2.9.1&nbsp;SELECT ... INTO Syntax"><code class="literal">SELECT ... INTO
                    OUTFILE</code></a> since there is no way to write a path to the
                file relative to the server host's file system.
            </p><p style="color:blue;">选择…into outfile语句的主要目的是让您能够非常快速地将表转储到服务器计算机上的文本文件中。如果要在服务器主机以外的其他主机上创建结果文件，通常不能使用select…进入outfile，因为无法写入相对于服务器主机的文件系统的文件路径。</p><p>
                However, if the MySQL client software is installed on the remote
                machine, you can instead use a client command such as
                <code class="literal">mysql -e "SELECT ..." &gt;
                    <em class="replaceable"><code>file_name</code></em></code> to generate the
                file on the client host.
            </p><p style="color:blue;">但是，如果mysql客户端软件安装在远程计算机上，则可以使用mysql-e“select…”&gt;file_name等客户端命令在客户端主机上生成文件。</p><p>
                It is also possible to create the resulting file on a different
                host other than the server host, if the location of the file on
                the remote host can be accessed using a network-mapped path on
                the server's file system. In this case, the presence of
                <a class="link" href="programs.html#mysql" title="4.5.1&nbsp;mysql — The MySQL Command-Line Client"><span class="command"><strong>mysql</strong></span></a> (or some other MySQL client program) is
                not required on the target host.
            </p><p style="color:blue;">如果可以使用服务器文件系统上的网络映射路径访问远程主机上的文件位置，也可以在服务器主机以外的其他主机上创建结果文件。在这种情况下，目标主机上不需要存在mysql（或其他mysql客户端程序）。</p><p>
                <a class="link" href="sql-syntax.html#select-into" title="13.2.9.1&nbsp;SELECT ... INTO Syntax"><code class="literal">SELECT ... INTO
                    OUTFILE</code></a> is the complement of <a class="link" href="sql-syntax.html#load-data" title="13.2.6&nbsp;LOAD DATA Syntax"><code class="literal">LOAD
                DATA</code></a>. Column values are written converted to the
                character set specified in the <code class="literal">CHARACTER SET</code>
                clause. If no such clause is present, values are dumped using
                the <code class="literal">binary</code> character set. In effect, there is
                no character set conversion. If a result set contains columns in
                several character sets, the output data file will as well and
                you may not be able to reload the file correctly.
            </p><p style="color:blue;">选择…into outfile是加载数据的补充。列值被转换为character set子句中指定的字符集。如果不存在这样的子句，则使用二进制字符集转储值。实际上，没有字符集转换。如果结果集在多个字符集中包含列，则输出数据文件也将包含列，并且您可能无法正确重新加载该文件。</p><p>
                The syntax for the <em class="replaceable"><code>export_options</code></em>
                part of the statement consists of the same
                <code class="literal">FIELDS</code> and <code class="literal">LINES</code> clauses
                that are used with the <a class="link" href="sql-syntax.html#load-data" title="13.2.6&nbsp;LOAD DATA Syntax"><code class="literal">LOAD DATA</code></a>
                statement. See <a class="xref" href="sql-syntax.html#load-data" title="13.2.6&nbsp;LOAD DATA Syntax">Section&nbsp;13.2.6, “LOAD DATA Syntax”</a>, for information
                about the <code class="literal">FIELDS</code> and <code class="literal">LINES</code>
                clauses, including their default values and permissible values.
            </p><p style="color:blue;">语句的export_options部分的语法由与load data语句一起使用的字段和行子句组成。有关fields和lines子句的信息，包括它们的默认值和允许值，请参见第13.2.6节“加载数据语法”。</p><p>
                <code class="literal">FIELDS ESCAPED BY</code> controls how to write
                special characters. If the <code class="literal">FIELDS ESCAPED BY</code>
                character is not empty, it is used when necessary to avoid
                ambiguity as a prefix that precedes following characters on
                output:
            </p><p style="color:blue;">由控件转义的字段如何写入特殊字符。如果按字符转义的字段不为空，则在必要时使用该字段，以避免在输出时作为下列字符前面的前缀出现歧义：</p>
                <div class="itemizedlist">
                    <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                        The <code class="literal">FIELDS ESCAPED BY</code> character
                    </p><p style="color:blue;">按字符转义的字段</p></li><li class="listitem"><p>
                        The <code class="literal">FIELDS [OPTIONALLY] ENCLOSED BY</code>
                        character
                    </p><p style="color:blue;">由字符[可选]括起来的字段</p></li><li class="listitem"><p>
                        The first character of the <code class="literal">FIELDS TERMINATED
                        BY</code> and <code class="literal">LINES TERMINATED BY</code>
                        values
                    </p><p style="color:blue;">以值结尾的字段和行的第一个字符</p></li><li class="listitem"><p>
                        ASCII <code class="literal">NUL</code> (the zero-valued byte; what is
                        actually written following the escape character is ASCII
                        <code class="literal">0</code>, not a zero-valued byte)
                    </p><p style="color:blue;">ascii nul（零值字节；转义字符后面实际写的是ascii 0，而不是零值字节）</p></li></ul>
                </div>
                <p>
                    The <code class="literal">FIELDS TERMINATED BY</code>, <code class="literal">ENCLOSED
                    BY</code>, <code class="literal">ESCAPED BY</code>, or <code class="literal">LINES
                    TERMINATED BY</code> characters <span class="emphasis"><em>must</em></span> be
                    escaped so that you can read the file back in reliably. ASCII
                    <code class="literal">NUL</code> is escaped to make it easier to view with
                    some pagers.
                </p><p style="color:blue;">必须对以字符结尾的字段、以字符括起的字段、以字符转义的字段或以字符结尾的行进行转义，以便您能够可靠地将文件读回。ascii nul被转义，以便于使用某些寻呼机查看。</p><p>
                The resulting file does not have to conform to SQL syntax, so
                nothing else need be escaped.
            </p><p style="color:blue;">生成的文件不必符合sql语法，因此无需转义其他文件。</p><p>
                If the <code class="literal">FIELDS ESCAPED BY</code> character is empty,
                no characters are escaped and <code class="literal">NULL</code> is output
                as <code class="literal">NULL</code>, not <code class="literal">\N</code>. It is
                probably not a good idea to specify an empty escape character,
                particularly if field values in your data contain any of the
                characters in the list just given.
            </p><p style="color:blue;">如果按字符转义的字段为空，则不转义任何字符，并将空输出为空，而不是。指定空转义字符可能不是一个好主意，特别是如果数据中的字段值包含刚才给出的列表中的任何字符。</p><a class="indexterm" name="idm140286834514496"></a><a class="indexterm" name="idm140286834513424"></a><p>
                Here is an example that produces a file in the comma-separated
                values (CSV) format used by many programs:
            </p><p style="color:blue;">下面是一个示例，它生成一个由许多程序使用的逗号分隔值（CSV）格式的文件：</p><pre data-lang="sql" class="programlisting">SELECT a,b,a+b INTO OUTFILE '/tmp/result.txt'
  FIELDS TERMINATED BY ',' OPTIONALLY ENCLOSED BY '"'
  LINES TERMINATED BY '\n'
  FROM test_table;
</pre><a class="indexterm" name="idm140286834510752"></a><p>
                If you use <code class="literal">INTO DUMPFILE</code> instead of
                <code class="literal">INTO OUTFILE</code>, MySQL writes only one row into
                the file, without any column or line termination and without
                performing any escape processing. This is useful if you want to
                store a <a class="link" href="data-types.html#blob" title="11.4.3&nbsp;The BLOB and TEXT Types"><code class="literal">BLOB</code></a> value in a file.
            </p><p style="color:blue;">如果使用into dumpfile而不是outfile，mysql只向文件中写入一行，没有任何列或行终止，也没有执行任何转义处理。如果要在文件中存储blob值，这很有用。</p>
                <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">

                    <div class="admon-title">
                        Note
                    </div>
                    <p>
                        Any file created by <code class="literal">INTO OUTFILE</code> or
                        <code class="literal">INTO DUMPFILE</code> is writable by all users on
                        the server host. The reason for this is that the MySQL server
                        cannot create a file that is owned by anyone other than the
                        user under whose account it is running. (You should
                        <span class="emphasis"><em>never</em></span> run <a class="link" href="programs.html#mysqld" title="4.3.1&nbsp;mysqld — The MySQL Server"><span class="command"><strong>mysqld</strong></span></a> as
                        <code class="literal">root</code> for this and other reasons.) The file
                        thus must be world-writable so that you can manipulate its
                        contents.
                    </p><p style="color:blue;">由into outfile或into dumpfile创建的任何文件都可由服务器主机上的所有用户写入。原因是mysql服务器无法创建一个文件，该文件由运行该文件的用户以外的任何人拥有。（出于这个和其他原因，您不应该以根用户身份运行mysqld。）因此，该文件必须是全局可写的，以便您可以操作其内容。</p><p>
                    If the <a class="link" href="server-administration.html#sysvar_secure_file_priv"><code class="literal">secure_file_priv</code></a>
                    system variable is set to a nonempty directory name, the file
                    to be written must be located in that directory.
                </p><p style="color:blue;">如果secure_file_priv系统变量设置为非空目录名，则要写入的文件必须位于该目录中。</p>
                </div>
                <p>
                    In the context of
                    <a class="link" href="sql-syntax.html#select-into" title="13.2.9.1&nbsp;SELECT ... INTO Syntax"><code class="literal">SELECT ...
                        INTO</code></a> statements that occur as part of events executed
                    by the Event Scheduler, diagnostics messages (not only errors,
                    but also warnings) are written to the error log, and, on
                    Windows, to the application event log. For additional
                    information, see <a class="xref" href="stored-objects.html#events-status-info" title="23.4.5&nbsp;Event Scheduler Status">Section&nbsp;23.4.5, “Event Scheduler Status”</a>.
                </p><p style="color:blue;">在选择的上下文中…在作为事件调度程序执行的事件的一部分出现的语句中，诊断消息（不仅是错误，而且是警告）会写入错误日志，在Windows中，还会写入应用程序事件日志。有关更多信息，请参阅第23.4.5节“事件计划程序状态”。</p>
            </div>
            <div class="section">
                <div class="titlepage">
                    <div>
                        <div>
                            <h4 class="title"><a name="join"></a>13.2.9.2&nbsp;JOIN Syntax</h4>

                        </div>

                    </div>

                </div>
                <a class="indexterm" name="idm140286834495792"></a><a class="indexterm" name="idm140286834494720"></a><a class="indexterm" name="idm140286834493648"></a><a class="indexterm" name="idm140286834492576"></a><a class="indexterm" name="idm140286834491504"></a><a class="indexterm" name="idm140286834490432"></a><a class="indexterm" name="idm140286834489360"></a><a class="indexterm" name="idm140286834488288"></a><a class="indexterm" name="idm140286834487216"></a><a class="indexterm" name="idm140286834486144"></a><a class="indexterm" name="idm140286834485072"></a><a class="indexterm" name="idm140286834484000"></a><a class="indexterm" name="idm140286834482912"></a><a class="indexterm" name="idm140286834481840"></a><p>
                MySQL supports the following <code class="literal">JOIN</code> syntax for
                the <em class="replaceable"><code>table_references</code></em> part of
                <a class="link" href="sql-syntax.html#select" title="13.2.9&nbsp;SELECT Syntax"><code class="literal">SELECT</code></a> statements and
                multiple-table <a class="link" href="sql-syntax.html#delete" title="13.2.2&nbsp;DELETE Syntax"><code class="literal">DELETE</code></a> and
                <a class="link" href="sql-syntax.html#update" title="13.2.11&nbsp;UPDATE Syntax"><code class="literal">UPDATE</code></a> statements:
            </p><p style="color:blue;">对于select语句的table_references部分和多个table delete和update语句，mysql支持以下连接语法：</p><pre data-lang="sql" class="programlisting"><em class="replaceable"><code>table_references:</code></em>
    <em class="replaceable"><code>escaped_table_reference</code></em> [, <em class="replaceable"><code>escaped_table_reference</code></em>] ...

<em class="replaceable"><code>escaped_table_reference</code></em>:
    <em class="replaceable"><code>table_reference</code></em>
  | { OJ <em class="replaceable"><code>table_reference</code></em> }

<em class="replaceable"><code>table_reference</code></em>:
    <em class="replaceable"><code>table_factor</code></em>
  | <em class="replaceable"><code>joined_table</code></em>

<em class="replaceable"><code>table_factor</code></em>:
    <em class="replaceable"><code>tbl_name</code></em> [PARTITION (<em class="replaceable"><code>partition_names</code></em>)]
        [[AS] <em class="replaceable"><code>alias</code></em>] [<em class="replaceable"><code>index_hint_list</code></em>]
  | <em class="replaceable"><code>table_subquery</code></em> [AS] <em class="replaceable"><code>alias</code></em>
  | ( <em class="replaceable"><code>table_references</code></em> )

<em class="replaceable"><code>joined_table</code></em>:
    <em class="replaceable"><code>table_reference</code></em> [INNER | CROSS] JOIN <em class="replaceable"><code>table_factor</code></em> [<em class="replaceable"><code>join_specification</code></em>]
  | <em class="replaceable"><code>table_reference</code></em> STRAIGHT_JOIN <em class="replaceable"><code>table_factor</code></em>
  | <em class="replaceable"><code>table_reference</code></em> STRAIGHT_JOIN <em class="replaceable"><code>table_factor</code></em> ON <em class="replaceable"><code>search_condition</code></em>
  | <em class="replaceable"><code>table_reference</code></em> {LEFT|RIGHT} [OUTER] JOIN <em class="replaceable"><code>table_reference</code></em> <em class="replaceable"><code>join_specification</code></em>
  | <em class="replaceable"><code>table_reference</code></em> NATURAL [{LEFT|RIGHT} [OUTER]] JOIN <em class="replaceable"><code>table_factor</code></em>

<em class="replaceable"><code>join_specification</code></em>:
    ON <em class="replaceable"><code>search_condition</code></em>
  | USING (<em class="replaceable"><code>join_column_list</code></em>)

<em class="replaceable"><code>join_column_list</code></em>:
    <em class="replaceable"><code>column_name</code></em> [, <em class="replaceable"><code>column_name</code></em>] ...

<em class="replaceable"><code>index_hint_list</code></em>:
    <em class="replaceable"><code>index_hint</code></em> [, <em class="replaceable"><code>index_hint</code></em>] ...

<em class="replaceable"><code>index_hint</code></em>:
    USE {INDEX|KEY}
      [FOR {JOIN|ORDER BY|GROUP BY}] ([<em class="replaceable"><code>index_list</code></em>])
  | {IGNORE|FORCE} {INDEX|KEY}
      [FOR {JOIN|ORDER BY|GROUP BY}] (<em class="replaceable"><code>index_list</code></em>)

<em class="replaceable"><code>index_list</code></em>:
    <em class="replaceable"><code>index_name</code></em> [, <em class="replaceable"><code>index_name</code></em>] ...
</pre><p>
                A table reference is also known as a join expression.
            </p><p style="color:blue;">表引用也称为联接表达式。</p><p>
                A table reference (when it refers to a partitioned table) may
                contain a <code class="literal">PARTITION</code> option, including a list
                of comma-separated partitions, subpartitions, or both. This
                option follows the name of the table and precedes any alias
                declaration. The effect of this option is that rows are selected
                only from the listed partitions or subpartitions. Any partitions
                or subpartitions not named in the list are ignored. For more
                information and examples, see
                <a class="xref" href="partitioning.html#partitioning-selection" title="22.5&nbsp;Partition Selection">Section&nbsp;22.5, “Partition Selection”</a>.
            </p><p style="color:blue;">表引用（当引用分区表时）可以包含分区选项，包括逗号分隔的分区、子分区或两者。此选项紧跟表的名称，位于任何别名声明之前。此选项的效果是仅从列出的分区或子分区中选择行。忽略列表中未命名的任何分区或子分区。有关更多信息和示例，请参见第22.5节“分区选择”。</p><p>
                The syntax of <em class="replaceable"><code>table_factor</code></em> is
                extended in MySQL in comparison with standard SQL. The standard
                accepts only <em class="replaceable"><code>table_reference</code></em>, not a
                list of them inside a pair of parentheses.
            </p><p style="color:blue;">与标准sql相比，mysql扩展了表因子的语法。标准只接受table_引用，而不接受一对圆括号内的一组引用。</p><p>
                This is a conservative extension if each comma in a list of
                <em class="replaceable"><code>table_reference</code></em> items is considered
                as equivalent to an inner join. For example:
            </p><p style="color:blue;">如果表引用项列表中的每个逗号都被视为等同于内部联接，则这是一个保守的扩展。例如：</p><pre data-lang="sql" class="programlisting">SELECT * FROM t1 LEFT JOIN (t2, t3, t4)
                 ON (t2.a = t1.a AND t3.b = t1.b AND t4.c = t1.c)
</pre><p>
                is equivalent to:
            </p><p style="color:blue;">相当于：</p><pre data-lang="sql" class="programlisting">SELECT * FROM t1 LEFT JOIN (t2 CROSS JOIN t3 CROSS JOIN t4)
                 ON (t2.a = t1.a AND t3.b = t1.b AND t4.c = t1.c)
</pre><p>
                In MySQL, <code class="literal">JOIN</code>, <code class="literal">CROSS
                JOIN</code>, and <code class="literal">INNER JOIN</code> are syntactic
                equivalents (they can replace each other). In standard SQL, they
                are not equivalent. <code class="literal">INNER JOIN</code> is used with
                an <code class="literal">ON</code> clause, <code class="literal">CROSS JOIN</code>
                is used otherwise.
            </p><p style="color:blue;">在mysql中，join、cross join和inner join是语法等价物（它们可以相互替换）。在标准sql中，它们是不等价的。内部连接与on子句一起使用，否则使用交叉连接。</p><p>
                In general, parentheses can be ignored in join expressions
                containing only inner join operations. MySQL also supports
                nested joins. See <a class="xref" href="optimization.html#nested-join-optimization" title="8.2.1.7&nbsp;Nested Join Optimization">Section&nbsp;8.2.1.7, “Nested Join Optimization”</a>.
            </p><p style="color:blue;">通常，在只包含内部联接操作的联接表达式中，可以忽略圆括号。mysql还支持嵌套连接。参见第8.2.1.7节“嵌套连接优化”。</p><p>
                Index hints can be specified to affect how the MySQL optimizer
                makes use of indexes. For more information, see
                <a class="xref" href="optimization.html#index-hints" title="8.9.4&nbsp;Index Hints">Section&nbsp;8.9.4, “Index Hints”</a>. Optimizer hints and the
                <code class="literal">optimizer_switch</code> system variable are other
                ways to influence optimizer use of indexes. See
                <a class="xref" href="optimization.html#optimizer-hints" title="8.9.3&nbsp;Optimizer Hints">Section&nbsp;8.9.3, “Optimizer Hints”</a>, and
                <a class="xref" href="optimization.html#switchable-optimizations" title="8.9.2&nbsp;Switchable Optimizations">Section&nbsp;8.9.2, “Switchable Optimizations”</a>.
            </p><p style="color:blue;">可以指定索引提示来影响mysql优化器如何使用索引。有关更多信息，请参见第8.9.4节“索引提示”。优化器提示和优化器开关系统变量是影响优化器使用索引的其他方式。参见第8.9.3节“优化器提示”和第8.9.2节“可切换优化”。</p><p>
                The following list describes general factors to take into
                account when writing joins:
            </p><p style="color:blue;">以下列表描述了编写联接时要考虑的一般因素：</p>
                <div class="itemizedlist">
                    <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                        A table reference can be aliased using
                        <code class="literal"><em class="replaceable"><code>tbl_name</code></em> AS
                            <em class="replaceable"><code>alias_name</code></em></code> or
                        <em class="replaceable"><code>tbl_name alias_name</code></em>:
                    </p><p style="color:blue;">表引用可以使用tbl_name作为别名或tbl_name alias_name作为别名：</p><pre data-lang="sql" class="programlisting">SELECT t1.name, t2.salary
  FROM employee AS t1 INNER JOIN info AS t2 ON t1.name = t2.name;

SELECT t1.name, t2.salary
  FROM employee t1 INNER JOIN info t2 ON t1.name = t2.name;
</pre></li><li class="listitem"><p>
                        A <em class="replaceable"><code>table_subquery</code></em> is also known as
                        a derived table or subquery in the <code class="literal">FROM</code>
                        clause. See <a class="xref" href="sql-syntax.html#derived-tables" title="13.2.10.8&nbsp;Derived Tables">Section&nbsp;13.2.10.8, “Derived Tables”</a>. Such
                        subqueries <span class="emphasis"><em>must</em></span> include an alias to
                        give the subquery result a table name. A trivial example
                        follows:
                    </p><p style="color:blue;">在from子句中，table_子查询也称为派生表或子查询。见第13.2.10.8节“派生表”。这样的子查询必须包含一个别名，以便为子查询结果提供一个表名。下面是一个简单的例子：</p><pre data-lang="sql" class="programlisting">SELECT * FROM (SELECT 1, 2, 3) AS t1;
</pre></li><li class="listitem"><p>
                        The maximum number of tables that can be referenced in a
                        single join is 61. This includes a join handled by merging
                        derived tables and views in the <code class="literal">FROM</code>
                        clause into the outer query block (see
                        <a class="xref" href="optimization.html#derived-table-optimization" title="8.2.2.4&nbsp;Optimizing Derived Tables and View References with Merging or Materialization">Section&nbsp;8.2.2.4, “Optimizing Derived Tables and View References with Merging or
                            Materialization”</a>).
                    </p><p style="color:blue;">单个连接中可以引用的最大表数为61。这包括通过将from子句中的派生表和视图合并到外部查询块中来处理的连接（请参见第8.2.2.4节“使用合并或物化优化派生表和视图引用”）。</p><a class="indexterm" name="idm140286834423104"></a><a class="indexterm" name="idm140286834421616"></a></li><li class="listitem"><p>
                        <code class="literal">INNER JOIN</code> and <code class="literal">,</code>
                        (comma) are semantically equivalent in the absence of a join
                        condition: both produce a Cartesian product between the
                        specified tables (that is, each and every row in the first
                        table is joined to each and every row in the second table).
                    </p><p style="color:blue;">在没有联接条件的情况下，内部联接和（逗号）在语义上是等价的：它们都在指定表之间生成笛卡尔积（即，第一个表中的每一行都联接到第二个表中的每一行）。</p><p>
                        However, the precedence of the comma operator is less than
                        that of <code class="literal">INNER JOIN</code>, <code class="literal">CROSS
                        JOIN</code>, <code class="literal">LEFT JOIN</code>, and so on. If
                        you mix comma joins with the other join types when there is
                        a join condition, an error of the form <code class="literal">Unknown
                        column '<em class="replaceable"><code>col_name</code></em>' in 'on
                        clause'</code> may occur. Information about dealing with
                        this problem is given later in this section.
                    </p><p style="color:blue;">但是，逗号运算符的优先级小于内部联接、交叉联接、左联接等。如果在存在联接条件时将逗号联接与其他联接类型混合，则可能会出现“on子句”中未知列“col_name”的格式错误。有关处理此问题的信息将在本节后面给出。</p></li><li class="listitem"><p>
                        The <em class="replaceable"><code>search_condition</code></em> used with
                        <code class="literal">ON</code> is any conditional expression of the
                        form that can be used in a <code class="literal">WHERE</code> clause.
                        Generally, the <code class="literal">ON</code> clause serves for
                        conditions that specify how to join tables, and the
                        <code class="literal">WHERE</code> clause restricts which rows to
                        include in the result set.
                    </p><p style="color:blue;">与on一起使用的search_条件是可以在where子句中使用的任何形式的条件表达式。通常，on子句用于指定如何联接表的条件，where子句限制结果集中包含哪些行。</p></li><li class="listitem"><p>
                        If there is no matching row for the right table in the
                        <code class="literal">ON</code> or <code class="literal">USING</code> part in a
                        <code class="literal">LEFT JOIN</code>, a row with all columns set to
                        <code class="literal">NULL</code> is used for the right table. You can
                        use this fact to find rows in a table that have no
                        counterpart in another table:
                    </p><p style="color:blue;">如果在左联接的on或using部分中没有右表的匹配行，则右表将使用所有列都设置为空的行。可以使用此事实在表中查找在其他表中没有对应项的行：</p><pre data-lang="sql" class="programlisting">SELECT left_tbl.*
  FROM left_tbl LEFT JOIN right_tbl ON left_tbl.id = right_tbl.id
  WHERE right_tbl.id IS NULL;
</pre><p>
                        This example finds all rows in <code class="literal">left_tbl</code>
                        with an <code class="literal">id</code> value that is not present in
                        <code class="literal">right_tbl</code> (that is, all rows in
                        <code class="literal">left_tbl</code> with no corresponding row in
                        <code class="literal">right_tbl</code>). See
                        <a class="xref" href="optimization.html#outer-join-optimization" title="8.2.1.8&nbsp;Outer Join Optimization">Section&nbsp;8.2.1.8, “Outer Join Optimization”</a>.
                    </p><p style="color:blue;">此示例查找左tbl中具有右tbl中不存在的id值的所有行（即，左tbl中没有相应行的所有行）。见第8.2.1.8节“外部连接优化”。</p></li><li class="listitem"><p>
                        The
                        <code class="literal">USING(<em class="replaceable"><code>join_column_list</code></em>)</code>
                        clause names a list of columns that must exist in both
                        tables. If tables <code class="literal">a</code> and
                        <code class="literal">b</code> both contain columns
                        <code class="literal">c1</code>, <code class="literal">c2</code>, and
                        <code class="literal">c3</code>, the following join compares
                        corresponding columns from the two tables:
                    </p><p style="color:blue;">使用（CuangixCulnNoLIST）子句命名两个表中必须存在的列的列表。如果表A和B都包含列C1、C2和C3，则以下联接将比较两个表中的相应列：</p><pre data-lang="sql" class="programlisting">a LEFT JOIN b USING (c1, c2, c3)
</pre></li><li class="listitem"><p>
                        The <code class="literal">NATURAL [LEFT] JOIN</code> of two tables is
                        defined to be semantically equivalent to an <code class="literal">INNER
                        JOIN</code> or a <code class="literal">LEFT JOIN</code> with a
                        <code class="literal">USING</code> clause that names all columns that
                        exist in both tables.
                    </p><p style="color:blue;">两个表的自然[左]连接定义为语义上等同于内部联接或左联接，其中使用一个使用子句来命名两个表中存在的所有列。</p></li><li class="listitem"><p>
                        <code class="literal">RIGHT JOIN</code> works analogously to
                        <code class="literal">LEFT JOIN</code>. To keep code portable across
                        databases, it is recommended that you use <code class="literal">LEFT
                        JOIN</code> instead of <code class="literal">RIGHT JOIN</code>.
                    </p><p style="color:blue;">right join的工作方式类似于left join。为了保持代码跨数据库的可移植性，建议您使用左连接而不是右连接。</p></li><li class="listitem"><p>
                        <a class="indexterm" name="idm140286834384496"></a>

                        <a class="indexterm" name="idm140286834383424"></a>

                        The <code class="literal">{ OJ ... }</code> syntax shown in the join
                        syntax description exists only for compatibility with ODBC.
                        The curly braces in the syntax should be written literally;
                        they are not metasyntax as used elsewhere in syntax
                        descriptions.
                    </p><p style="color:blue;">{oj…}连接语法描述中显示的语法仅用于与ODBC兼容。语法中的花括号应该按字面意思写；它们不是语法描述中其他地方使用的元语法。</p><pre data-lang="sql" class="programlisting">SELECT left_tbl.*
    FROM { OJ left_tbl LEFT OUTER JOIN right_tbl
           ON left_tbl.id = right_tbl.id }
    WHERE right_tbl.id IS NULL;
</pre><p>
                        You can use other types of joins within <code class="literal">{ OJ ...
                        }</code>, such as <code class="literal">INNER JOIN</code> or
                        <code class="literal">RIGHT OUTER JOIN</code>. This helps with
                        compatibility with some third-party applications, but is not
                        official ODBC syntax.
                    </p><p style="color:blue;">您可以在{oj…}，例如内部连接或右外部连接。这有助于与某些第三方应用程序兼容，但不是官方的odbc语法。</p></li><li class="listitem"><p>
                        <code class="literal">STRAIGHT_JOIN</code> is similar to
                        <code class="literal">JOIN</code>, except that the left table is
                        always read before the right table. This can be used for
                        those (few) cases for which the join optimizer processes the
                        tables in a suboptimal order.
                    </p><p style="color:blue;">直连接与连接类似，只是左表总是在右表之前读取。这可用于联接优化器按次优顺序处理表的（少数）情况。</p></li></ul>
                </div>
                <p>
                    Some join examples:
                </p><p style="color:blue;">一些连接示例：</p><pre data-lang="sql" class="programlisting">SELECT * FROM table1, table2;

SELECT * FROM table1 INNER JOIN table2 ON table1.id = table2.id;

SELECT * FROM table1 LEFT JOIN table2 ON table1.id = table2.id;

SELECT * FROM table1 LEFT JOIN table2 USING (id);

SELECT * FROM table1 LEFT JOIN table2 ON table1.id = table2.id
  LEFT JOIN table3 ON table2.id = table3.id;
</pre><p>
                Natural joins and joins with <code class="literal">USING</code>, including
                outer join variants, are processed according to the SQL:2003
                standard:
            </p><p style="color:blue;">使用的自然连接和连接（包括外部连接变体）根据SQL:2003标准进行处理：</p>
                <div class="itemizedlist">
                    <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                        Redundant columns of a <code class="literal">NATURAL</code> join do
                        not appear. Consider this set of statements:
                    </p><p style="color:blue;">自然连接的冗余列不会出现。考虑这一组声明：</p><pre data-lang="sql" class="programlisting">CREATE TABLE t1 (i INT, j INT);
CREATE TABLE t2 (k INT, j INT);
INSERT INTO t1 VALUES(1, 1);
INSERT INTO t2 VALUES(1, 1);
SELECT * FROM t1 NATURAL JOIN t2;
SELECT * FROM t1 JOIN t2 USING (j);
</pre><p>
                        In the first <a class="link" href="sql-syntax.html#select" title="13.2.9&nbsp;SELECT Syntax"><code class="literal">SELECT</code></a>
                        statement, column <code class="literal">j</code> appears in both
                        tables and thus becomes a join column, so, according to
                        standard SQL, it should appear only once in the output, not
                        twice. Similarly, in the second SELECT statement, column
                        <code class="literal">j</code> is named in the
                        <code class="literal">USING</code> clause and should appear only once
                        in the output, not twice.
                    </p><p style="color:blue;">在第一个select语句中，列j出现在两个表中，因此成为连接列，因此根据标准sql，它应该只出现在输出中一次，而不是两次。类似地，在第二个select语句中，列j在using子句中命名，并且应该只在输出中出现一次，而不是两次。</p><p>
                        Thus, the statements produce this output:
                    </p><p style="color:blue;">因此，这些语句产生以下输出：</p><pre data-lang="none" class="programlisting">+------+------+------+
| j    | i    | k    |
+------+------+------+
|    1 |    1 |    1 |
+------+------+------+
+------+------+------+
| j    | i    | k    |
+------+------+------+
|    1 |    1 |    1 |
+------+------+------+
</pre><p>
                        Redundant column elimination and column ordering occurs
                        according to standard SQL, producing this display order:
                    </p><p style="color:blue;">根据标准SQL进行冗余列消除和列排序，生成此显示顺序：</p>
                        <div class="itemizedlist">
                            <ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
                                First, coalesced common columns of the two joined
                                tables, in the order in which they occur in the first
                                table
                            </p><p style="color:blue;">首先，合并两个联接表的公共列，按照它们在第一个表中出现的顺序</p></li><li class="listitem"><p>
                                Second, columns unique to the first table, in order in
                                which they occur in that table
                            </p><p style="color:blue;">第二，第一个表所特有的列，按它们在该表中出现的顺序排列</p></li><li class="listitem"><p>
                                Third, columns unique to the second table, in order in
                                which they occur in that table
                            </p><p style="color:blue;">第三，第二个表所特有的列，按它们在该表中出现的顺序排列</p></li></ul>
                        </div>
                        <p>
                            The single result column that replaces two common columns is
                            defined using the coalesce operation. That is, for two
                            <code class="literal">t1.a</code> and <code class="literal">t2.a</code> the
                            resulting single join column <code class="literal">a</code> is defined
                            as <code class="literal">a = COALESCE(t1.a, t2.a)</code>, where:
                        </p><p style="color:blue;">替换两个公共列的单个结果列是使用合并操作定义的。也就是说，对于两个t1.a和t2.a，得到的单个连接列a被定义为a=coalesce（t1.a，t2.a），其中：</p><pre data-lang="sql" class="programlisting">COALESCE(x, y) = (CASE WHEN x IS NOT NULL THEN x ELSE y END)
</pre><p>
                            If the join operation is any other join, the result columns
                            of the join consist of the concatenation of all columns of
                            the joined tables.
                        </p><p style="color:blue;">如果联接操作是任何其他联接，则联接的结果列由联接表的所有列的连接组成。</p><p>
                            A consequence of the definition of coalesced columns is
                            that, for outer joins, the coalesced column contains the
                            value of the non-<code class="literal">NULL</code> column if one of
                            the two columns is always <code class="literal">NULL</code>. If
                            neither or both columns are <code class="literal">NULL</code>, both
                            common columns have the same value, so it doesn't matter
                            which one is chosen as the value of the coalesced column. A
                            simple way to interpret this is to consider that a coalesced
                            column of an outer join is represented by the common column
                            of the inner table of a <code class="literal">JOIN</code>. Suppose
                            that the tables <code class="literal">t1(a, b)</code> and
                            <code class="literal">t2(a, c)</code> have the following contents:
                        </p><p style="color:blue;">合并列定义的一个结果是，对于外部联接，如果两列之一始终为空，则合并列包含非空列的值。如果两列都不为空，则两个公共列都具有相同的值，因此选择哪一列作为合并列的值并不重要。解释这一点的一个简单方法是考虑外部联接的合并列由联接的内部表的公共列表示。假设表T1（A，B）和T2（A，C）具有以下内容：</p><pre data-lang="none" class="programlisting">t1    t2
----  ----
1 x   2 z
2 y   3 w
</pre><p>
                            Then, for this join, column <code class="literal">a</code> contains
                            the values of <code class="literal">t1.a</code>:
                        </p><p style="color:blue;">然后，对于此联接，A列包含T1.A的值：</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT * FROM t1 NATURAL LEFT JOIN t2;</code></strong>
+------+------+------+
| a    | b    | c    |
+------+------+------+
|    1 | x    | NULL |
|    2 | y    | z    |
+------+------+------+
</pre><p>
                            By contrast, for this join, column <code class="literal">a</code>
                            contains the values of <code class="literal">t2.a</code>.
                        </p><p style="color:blue;">相比之下，对于这个连接，A列包含T2.A的值。</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT * FROM t1 NATURAL RIGHT JOIN t2;</code></strong>
+------+------+------+
| a    | c    | b    |
+------+------+------+
|    2 | z    | y    |
|    3 | w    | NULL |
+------+------+------+
</pre><p>
                            Compare those results to the otherwise equivalent queries
                            with <code class="literal">JOIN ... ON</code>:
                        </p><p style="color:blue;">将这些结果与其他具有join的等价查询进行比较…日期：</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT * FROM t1 LEFT JOIN t2 ON (t1.a = t2.a);</code></strong>
+------+------+------+------+
| a    | b    | a    | c    |
+------+------+------+------+
|    1 | x    | NULL | NULL |
|    2 | y    |    2 | z    |
+------+------+------+------+
</pre><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT * FROM t1 RIGHT JOIN t2 ON (t1.a = t2.a);</code></strong>
+------+------+------+------+
| a    | b    | a    | c    |
+------+------+------+------+
|    2 | y    |    2 | z    |
| NULL | NULL |    3 | w    |
+------+------+------+------+
</pre></li><li class="listitem"><p>
                        A <code class="literal">USING</code> clause can be rewritten as an
                        <code class="literal">ON</code> clause that compares corresponding
                        columns. However, although <code class="literal">USING</code> and
                        <code class="literal">ON</code> are similar, they are not quite the
                        same. Consider the following two queries:
                    </p><p style="color:blue;">using子句可以重写为比较相应列的on子句。然而，虽然使用和on是相似的，但它们并不完全相同。考虑以下两个问题：</p><a class="indexterm" name="idm140286834331792"></a><a class="indexterm" name="idm140286834330304"></a><a class="indexterm" name="idm140286834328816"></a><pre data-lang="sql" class="programlisting">a LEFT JOIN b USING (c1, c2, c3)
a LEFT JOIN b ON a.c1 = b.c1 AND a.c2 = b.c2 AND a.c3 = b.c3
</pre><p>
                        With respect to determining which rows satisfy the join
                        condition, both joins are semantically identical.
                    </p><p style="color:blue;">关于确定哪些行满足联接条件，这两个联接在语义上是相同的。</p><p>
                        With respect to determining which columns to display for
                        <code class="literal">SELECT *</code> expansion, the two joins are not
                        semantically identical. The <code class="literal">USING</code> join
                        selects the coalesced value of corresponding columns,
                        whereas the <code class="literal">ON</code> join selects all columns
                        from all tables. For the <code class="literal">USING</code> join,
                        <code class="literal">SELECT *</code> selects these values:
                    </p><p style="color:blue;">关于确定要为select*扩展显示哪些列，这两个连接在语义上不完全相同。using连接选择对应列的合并值，而on连接从所有表中选择所有列。对于using join，select*选择以下值：</p><pre data-lang="sql" class="programlisting">COALESCE(a.c1, b.c1), COALESCE(a.c2, b.c2), COALESCE(a.c3, b.c3)
</pre><p>
                        For the <code class="literal">ON</code> join, <code class="literal">SELECT
                        *</code> selects these values:
                    </p><p style="color:blue;">对于on join，select*选择以下值：</p><pre data-lang="none" class="programlisting">a.c1, a.c2, a.c3, b.c1, b.c2, b.c3
</pre><p>
                        With an inner join, <a class="link" href="functions.html#function_coalesce"><code class="literal">COALESCE(a.c1,
                        b.c1)</code></a> is the same as either
                        <code class="literal">a.c1</code> or <code class="literal">b.c1</code> because
                        both columns will have the same value. With an outer join
                        (such as <code class="literal">LEFT JOIN</code>), one of the two
                        columns can be <code class="literal">NULL</code>. That column is
                        omitted from the result.
                    </p><p style="color:blue;">对于内部联接，coalesce（a.c1，b.c1）与a.c1或b.c1相同，因为两列的值都相同。对于外部联接（如左联接），两列中的一列可以为空。结果中省略了该列。</p></li><li class="listitem"><p>
                        An <code class="literal">ON</code> clause can refer only to its
                        operands.
                    </p><p style="color:blue;">on子句只能引用其操作数。</p><p>
                        Example:
                    </p><p style="color:blue;">例子：</p><pre data-lang="sql" class="programlisting">CREATE TABLE t1 (i1 INT);
CREATE TABLE t2 (i2 INT);
CREATE TABLE t3 (i3 INT);
SELECT * FROM t1 JOIN t2 ON (i1 = i3) JOIN t3;
</pre><p>
                        The statement fails with an <code class="literal">Unknown column 'i3' in
                        'on clause'</code> error because <code class="literal">i3</code> is
                        a column in <code class="literal">t3</code>, which is not an operand
                        of the <code class="literal">ON</code> clause. To enable the join to
                        be processed, rewrite the statement as follows:
                    </p><p style="color:blue;">语句失败，出现“on子句”错误中的未知列“i3”，因为i3是t3中的列，而t3不是on子句的操作数。若要启用要处理的联接，请按如下方式重写语句：</p><a class="indexterm" name="idm140286834306544"></a><pre data-lang="sql" class="programlisting">SELECT * FROM t1 JOIN t2 JOIN t3 ON (i1 = i3);
</pre></li><li class="listitem"><p>
                        <code class="literal">JOIN</code> has higher precedence than the comma
                        operator (<code class="literal">,</code>), so the join expression
                        <code class="literal">t1, t2 JOIN t3</code> is interpreted as
                        <code class="literal">(t1, (t2 JOIN t3))</code>, not as <code class="literal">((t1,
                        t2) JOIN t3)</code>. This affects statements that use an
                        <code class="literal">ON</code> clause because that clause can refer
                        only to columns in the operands of the join, and the
                        precedence affects interpretation of what those operands
                        are.
                    </p><p style="color:blue;">连接的优先级高于逗号运算符（，），因此连接表达式t1，t2 join t3被解释为（t1，（t2 join t3）），而不是（（t1，t2）join t3）。这会影响使用on子句的语句，因为该子句只能引用联接操作数中的列，并且优先级会影响对这些操作数的解释。</p><p>
                        Example:
                    </p><p style="color:blue;">例子：</p><pre data-lang="sql" class="programlisting">CREATE TABLE t1 (i1 INT, j1 INT);
CREATE TABLE t2 (i2 INT, j2 INT);
CREATE TABLE t3 (i3 INT, j3 INT);
INSERT INTO t1 VALUES(1, 1);
INSERT INTO t2 VALUES(1, 1);
INSERT INTO t3 VALUES(1, 1);
SELECT * FROM t1, t2 JOIN t3 ON (t1.i1 = t3.i3);
</pre><p>
                        The <code class="literal">JOIN</code> takes precedence over the comma
                        operator, so the operands for the <code class="literal">ON</code>
                        clause are <code class="literal">t2</code> and <code class="literal">t3</code>.
                        Because <code class="literal">t1.i1</code> is not a column in either
                        of the operands, the result is an <code class="literal">Unknown column
                        't1.i1' in 'on clause'</code> error.
                    </p><p style="color:blue;">连接优先于逗号运算符，因此on子句的操作数是t2和t3。因为T1.I1不是两个操作数中的列，所以结果是“on子句”错误中的未知列“T1.I1”。</p><a class="indexterm" name="idm140286834292768"></a><p>
                        To enable the join to be processed, use either of these
                        strategies:
                    </p><p style="color:blue;">要使联接能够被处理，请使用以下任一策略：</p>
                        <div class="itemizedlist">
                            <ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
                                Group the first two tables explicitly with parentheses
                                so that the operands for the <code class="literal">ON</code>
                                clause are <code class="literal">(t1, t2)</code> and
                                <code class="literal">t3</code>:
                            </p><p style="color:blue;">用括号显式地将前两个表分组，以便ON子句的操作数为（T1，T2）和T3:</p><pre data-lang="sql" class="programlisting">SELECT * FROM (t1, t2) JOIN t3 ON (t1.i1 = t3.i3);
</pre></li><li class="listitem"><p>
                                Avoid the use of the comma operator and use
                                <code class="literal">JOIN</code> instead:
                            </p><p style="color:blue;">避免使用逗号运算符，而是使用join：</p><pre data-lang="sql" class="programlisting">SELECT * FROM t1 JOIN t2 JOIN t3 ON (t1.i1 = t3.i3);
</pre></li></ul>
                        </div>
                        <p>
                            The same precedence interpretation also applies to
                            statements that mix the comma operator with <code class="literal">INNER
                            JOIN</code>, <code class="literal">CROSS JOIN</code>, <code class="literal">LEFT
                            JOIN</code>, and <code class="literal">RIGHT JOIN</code>, all of
                            which have higher precedence than the comma operator.
                        </p><p style="color:blue;">同样的优先级解释也适用于将逗号运算符与内部联接、交叉联接、左联接和右联接混合使用的语句，所有这些语句的优先级都高于逗号运算符。</p></li><li class="listitem"><p>
                        A MySQL extension compared to the SQL:2003 standard is that
                        MySQL permits you to qualify the common (coalesced) columns
                        of <code class="literal">NATURAL</code> or <code class="literal">USING</code>
                        joins, whereas the standard disallows that.
                    </p><p style="color:blue;">与sql:2003标准相比，mysql的一个扩展是mysql允许您限定自然连接或使用连接的公共（合并）列，而标准不允许这样做。</p></li></ul>
                </div>

            </div>
            <div class="section">
                <div class="titlepage">
                    <div>
                        <div>
                            <h4 class="title"><a name="union"></a>13.2.9.3&nbsp;UNION Syntax</h4>

                        </div>

                    </div>

                </div>
                <a class="indexterm" name="idm140286834276944"></a><pre data-lang="sql" class="programlisting">SELECT ...
UNION [ALL | DISTINCT] SELECT ...
[UNION [ALL | DISTINCT] SELECT ...]
</pre><p>
                <a class="link" href="sql-syntax.html#union" title="13.2.9.3&nbsp;UNION Syntax"><code class="literal">UNION</code></a> is used to combine the
                result from multiple <a class="link" href="sql-syntax.html#select" title="13.2.9&nbsp;SELECT Syntax"><code class="literal">SELECT</code></a>
                statements into a single result set.
            </p><p style="color:blue;">union用于将多个select语句的结果合并到单个结果集中。</p><p>
                The column names from the first
                <a class="link" href="sql-syntax.html#select" title="13.2.9&nbsp;SELECT Syntax"><code class="literal">SELECT</code></a> statement are used as the
                column names for the results returned. Selected columns listed
                in corresponding positions of each
                <a class="link" href="sql-syntax.html#select" title="13.2.9&nbsp;SELECT Syntax"><code class="literal">SELECT</code></a> statement should have the
                same data type. (For example, the first column selected by the
                first statement should have the same type as the first column
                selected by the other statements.)
            </p><p style="color:blue;">第一个select语句中的列名用作返回结果的列名。在每个select语句的相应位置列出的选定列应具有相同的数据类型。（例如，第一条语句选择的第一列的类型应与其他语句选择的第一列的类型相同。）</p><p>
                If the data types of corresponding
                <a class="link" href="sql-syntax.html#select" title="13.2.9&nbsp;SELECT Syntax"><code class="literal">SELECT</code></a> columns do not match, the
                types and lengths of the columns in the
                <a class="link" href="sql-syntax.html#union" title="13.2.9.3&nbsp;UNION Syntax"><code class="literal">UNION</code></a> result take into account
                the values retrieved by all of the
                <a class="link" href="sql-syntax.html#select" title="13.2.9&nbsp;SELECT Syntax"><code class="literal">SELECT</code></a> statements. For example,
                consider the following:
            </p><p style="color:blue;">如果对应的select列的数据类型不匹配，则union结果中列的类型和长度将考虑所有select语句检索到的值。例如，请考虑以下内容：</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT REPEAT('a',1) UNION SELECT REPEAT('b',10);</code></strong>
+---------------+
| REPEAT('a',1) |
+---------------+
| a             |
| bbbbbbbbbb    |
+---------------+
</pre><p>
                The <a class="link" href="sql-syntax.html#select" title="13.2.9&nbsp;SELECT Syntax"><code class="literal">SELECT</code></a> statements are normal
                select statements, but with the following restrictions:
            </p><p style="color:blue;">select语句是普通的select语句，但有以下限制：</p>
                <div class="itemizedlist">
                    <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                        Only the last <a class="link" href="sql-syntax.html#select" title="13.2.9&nbsp;SELECT Syntax"><code class="literal">SELECT</code></a>
                        statement can use <code class="literal">INTO OUTFILE</code>. (However,
                        the entire <a class="link" href="sql-syntax.html#union" title="13.2.9.3&nbsp;UNION Syntax"><code class="literal">UNION</code></a> result is
                        written to the file.)
                    </p><p style="color:blue;">只有最后一个select语句才能用于outfile。（但是，整个联合结果将写入文件。）</p></li><li class="listitem"><p>
                        <code class="literal">HIGH_PRIORITY</code> cannot be used with
                        <a class="link" href="sql-syntax.html#select" title="13.2.9&nbsp;SELECT Syntax"><code class="literal">SELECT</code></a> statements that are
                        part of a <a class="link" href="sql-syntax.html#union" title="13.2.9.3&nbsp;UNION Syntax"><code class="literal">UNION</code></a>. If you
                        specify it for the first
                        <a class="link" href="sql-syntax.html#select" title="13.2.9&nbsp;SELECT Syntax"><code class="literal">SELECT</code></a>, it has no effect. If
                        you specify it for any subsequent
                        <a class="link" href="sql-syntax.html#select" title="13.2.9&nbsp;SELECT Syntax"><code class="literal">SELECT</code></a> statements, a syntax
                        error results.
                    </p><p style="color:blue;">高优先级不能与属于联合的select语句一起使用。如果为第一次选择指定它，则它没有效果。如果为任何后续的select语句指定它，将导致语法错误。</p></li></ul>
                </div>
                <p>
                    The default behavior for <a class="link" href="sql-syntax.html#union" title="13.2.9.3&nbsp;UNION Syntax"><code class="literal">UNION</code></a> is
                    that duplicate rows are removed from the result. The optional
                    <code class="literal">DISTINCT</code> keyword has no effect other than the
                    default because it also specifies duplicate-row removal. With
                    the optional <code class="literal">ALL</code> keyword, duplicate-row
                    removal does not occur and the result includes all matching rows
                    from all the <a class="link" href="sql-syntax.html#select" title="13.2.9&nbsp;SELECT Syntax"><code class="literal">SELECT</code></a> statements.
                </p><p style="color:blue;">联合的默认行为是从结果中删除重复行。可选的DISTINCT关键字除了默认关键字外没有其他效果，因为它还指定了重复行删除。对于可选的all关键字，不会删除重复行，结果包括所有select语句中的所有匹配行。</p><p>
                You can mix <a class="link" href="sql-syntax.html#union" title="13.2.9.3&nbsp;UNION Syntax"><code class="literal">UNION
                ALL</code></a> and <a class="link" href="sql-syntax.html#union" title="13.2.9.3&nbsp;UNION Syntax"><code class="literal">UNION
                DISTINCT</code></a> in the same query. Mixed
                <a class="link" href="sql-syntax.html#union" title="13.2.9.3&nbsp;UNION Syntax"><code class="literal">UNION</code></a> types are treated such that
                a <code class="literal">DISTINCT</code> union overrides any
                <code class="literal">ALL</code> union to its left. A
                <code class="literal">DISTINCT</code> union can be produced explicitly by
                using <a class="link" href="sql-syntax.html#union" title="13.2.9.3&nbsp;UNION Syntax"><code class="literal">UNION
                DISTINCT</code></a> or implicitly by using
                <a class="link" href="sql-syntax.html#union" title="13.2.9.3&nbsp;UNION Syntax"><code class="literal">UNION</code></a> with no following
                <code class="literal">DISTINCT</code> or <code class="literal">ALL</code> keyword.
            </p><p style="color:blue;">可以在同一查询中混合union all和union distinct。混合联合类型的处理方式是，一个不同的联合重写其左侧的所有联合。使用union distinct可以显式地生成一个distinct联合，或者使用union隐式地生成一个不带以下distinct或all关键字的union。</p><p>
                To apply <code class="literal">ORDER BY</code> or <code class="literal">LIMIT</code>
                to an individual <a class="link" href="sql-syntax.html#select" title="13.2.9&nbsp;SELECT Syntax"><code class="literal">SELECT</code></a>, place
                the clause inside the parentheses that enclose the
                <a class="link" href="sql-syntax.html#select" title="13.2.9&nbsp;SELECT Syntax"><code class="literal">SELECT</code></a>:
            </p><p style="color:blue;">要对单个select应用order by或limit，请将子句放在包含select的括号内：</p><pre data-lang="sql" class="programlisting">(SELECT a FROM t1 WHERE a=10 AND B=1 ORDER BY a LIMIT 10)
UNION
(SELECT a FROM t2 WHERE a=11 AND B=2 ORDER BY a LIMIT 10);
</pre>
                <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">

                    <div class="admon-title">
                        Note
                    </div>
                    <p>
                        Previous versions of MySQL may permit such statements without
                        parentheses. In MySQL 5.7, the requirement for
                        parentheses is enforced.
                    </p><p style="color:blue;">以前版本的mysql可能允许这样的语句不带括号。在mysql 5.7中，对括号的要求是强制的。</p>
                </div>
                <p>
                    Use of <code class="literal">ORDER BY</code> for individual
                    <a class="link" href="sql-syntax.html#select" title="13.2.9&nbsp;SELECT Syntax"><code class="literal">SELECT</code></a> statements implies nothing
                    about the order in which the rows appear in the final result
                    because <a class="link" href="sql-syntax.html#union" title="13.2.9.3&nbsp;UNION Syntax"><code class="literal">UNION</code></a> by default produces
                    an unordered set of rows. Therefore, the use of <code class="literal">ORDER
                    BY</code> in this context is typically in conjunction with
                    <code class="literal">LIMIT</code>, so that it is used to determine the
                    subset of the selected rows to retrieve for the
                    <a class="link" href="sql-syntax.html#select" title="13.2.9&nbsp;SELECT Syntax"><code class="literal">SELECT</code></a>, even though it does not
                    necessarily affect the order of those rows in the final
                    <a class="link" href="sql-syntax.html#union" title="13.2.9.3&nbsp;UNION Syntax"><code class="literal">UNION</code></a> result. If <code class="literal">ORDER
                    BY</code> appears without <code class="literal">LIMIT</code> in a
                    <a class="link" href="sql-syntax.html#select" title="13.2.9&nbsp;SELECT Syntax"><code class="literal">SELECT</code></a>, it is optimized away
                    because it will have no effect anyway.
                </p><p style="color:blue;">对单个select语句使用order by并不意味着行在最终结果中的显示顺序，因为union在默认情况下生成一组无序的行。因此，在此上下文中使用ORDER BY通常与LIMIT结合使用，以便用于确定要为选择检索的选定行的子集，即使它不一定影响最终联合结果中这些行的顺序。如果order by在select中无限制地出现，它将被优化掉，因为它无论如何都不会有任何效果。</p><p>
                To use an <code class="literal">ORDER BY</code> or
                <code class="literal">LIMIT</code> clause to sort or limit the entire
                <a class="link" href="sql-syntax.html#union" title="13.2.9.3&nbsp;UNION Syntax"><code class="literal">UNION</code></a> result, parenthesize the
                individual <a class="link" href="sql-syntax.html#select" title="13.2.9&nbsp;SELECT Syntax"><code class="literal">SELECT</code></a> statements and
                place the <code class="literal">ORDER BY</code> or
                <code class="literal">LIMIT</code> after the last one. The following
                example uses both clauses:
            </p><p style="color:blue;">若要使用ORDERBY或LIMIT子句对整个联合结果进行排序或限制，请将各个SELECT语句括起来，并将ORDERBY或LIMIT放在最后一个语句之后。以下示例同时使用这两个子句：</p><pre data-lang="sql" class="programlisting">(SELECT a FROM t1 WHERE a=10 AND B=1)
UNION
(SELECT a FROM t2 WHERE a=11 AND B=2)
ORDER BY a LIMIT 10;
</pre><p>
                A statement without parentheses is equivalent to one
                parenthesized as just shown.
            </p><p style="color:blue;">如图所示，不带括号的语句相当于带括号的语句。</p><p>
                This kind of <code class="literal">ORDER BY</code> cannot use column
                references that include a table name (that is, names in
                <em class="replaceable"><code>tbl_name</code></em>.<em class="replaceable"><code>col_name</code></em>
                format). Instead, provide a column alias in the first
                <a class="link" href="sql-syntax.html#select" title="13.2.9&nbsp;SELECT Syntax"><code class="literal">SELECT</code></a> statement and refer to the
                alias in the <code class="literal">ORDER BY</code>. (Alternatively, refer
                to the column in the <code class="literal">ORDER BY</code> using its
                column position. However, use of column positions is
                deprecated.)
            </p><p style="color:blue;">这种ORDER BY不能使用包含表名的列引用（即tbl_name.col_name格式的名称）。相反，在第一个select语句中提供一个列别名，并在order by中引用该别名。（或者，使用列位置按顺序引用列。但是，不赞成使用列位置。）</p><p>
                Also, if a column to be sorted is aliased, the <code class="literal">ORDER
                BY</code> clause <span class="emphasis"><em>must</em></span> refer to the
                alias, not the column name. The first of the following
                statements will work, but the second will fail with an
                <code class="literal">Unknown column 'a' in 'order clause'</code> error:
            </p><p style="color:blue;">另外，如果要排序的列有别名，ORDERBY子句必须引用别名，而不是列名。下列语句中的第一个将起作用，但第二个语句将失败，出现“order子句”中的未知列“a”错误：</p><pre data-lang="sql" class="programlisting">(SELECT a AS b FROM t) UNION (SELECT ...) ORDER BY b;
(SELECT a AS b FROM t) UNION (SELECT ...) ORDER BY a;
</pre><p>
                To cause rows in a <a class="link" href="sql-syntax.html#union" title="13.2.9.3&nbsp;UNION Syntax"><code class="literal">UNION</code></a> result
                to consist of the sets of rows retrieved by each
                <a class="link" href="sql-syntax.html#select" title="13.2.9&nbsp;SELECT Syntax"><code class="literal">SELECT</code></a> one after the other,
                select an additional column in each
                <a class="link" href="sql-syntax.html#select" title="13.2.9&nbsp;SELECT Syntax"><code class="literal">SELECT</code></a> to use as a sort column
                and add an <code class="literal">ORDER BY</code> following the last
                <a class="link" href="sql-syntax.html#select" title="13.2.9&nbsp;SELECT Syntax"><code class="literal">SELECT</code></a>:
            </p><p style="color:blue;">若要使联合结果中的行由每个select一个接一个检索到的行集合组成，请在每个select中选择一个附加列用作排序列，并按照最后一个select添加顺序：</p><pre data-lang="sql" class="programlisting">(SELECT 1 AS sort_col, col1a, col1b, ... FROM t1)
UNION
(SELECT 2, col2a, col2b, ... FROM t2) ORDER BY sort_col;
</pre><p>
                To additionally maintain sort order within individual
                <a class="link" href="sql-syntax.html#select" title="13.2.9&nbsp;SELECT Syntax"><code class="literal">SELECT</code></a> results, add a secondary
                column to the <code class="literal">ORDER BY</code> clause:
            </p><p style="color:blue;">要在单个select结果中另外维护排序顺序，请在order by子句中添加一个辅助列：</p><pre data-lang="sql" class="programlisting">(SELECT 1 AS sort_col, col1a, col1b, ... FROM t1)
UNION
(SELECT 2, col2a, col2b, ... FROM t2) ORDER BY sort_col, col1a;
</pre><p>
                Use of an additional column also enables you to determine which
                <a class="link" href="sql-syntax.html#select" title="13.2.9&nbsp;SELECT Syntax"><code class="literal">SELECT</code></a> each row comes from. Extra
                columns can provide other identifying information as well, such
                as a string that indicates a table name.
            </p><p style="color:blue;">使用附加列还可以确定每行来自哪个select。额外的列还可以提供其他标识信息，例如指示表名的字符串。</p><p>
                <a class="link" href="sql-syntax.html#union" title="13.2.9.3&nbsp;UNION Syntax"><code class="literal">UNION</code></a> queries with an aggregate
                function in an <code class="literal">ORDER BY</code> clause are rejected
                with an
                <a class="link" href="error-handling.html#error_er_aggregate_order_for_union"><code class="literal">ER_AGGREGATE_ORDER_FOR_UNION</code></a>
                error. Example:
            </p><p style="color:blue;">ORDER BY子句中具有聚合函数的UNION查询将因ER U AGGRATE U ORDER U FOR U UNION错误而被拒绝。例子：</p><pre data-lang="sql" class="programlisting">SELECT 1 AS foo UNION SELECT 2 ORDER BY MAX(1);
</pre>
            </div>

        </div>
        <div class="section">
            <div class="titlepage">
                <div>
                    <div>
                        <h3 class="title"><a name="subqueries"></a>13.2.10&nbsp;Subquery Syntax</h3>

                    </div>

                </div>

            </div>
            <div class="toc">
                <dl class="toc"><dt><span class="section"><a href="sql-syntax.html#scalar-subqueries">13.2.10.1 The Subquery as Scalar Operand</a></span></dt><dt><span class="section"><a href="sql-syntax.html#comparisons-using-subqueries">13.2.10.2 Comparisons Using Subqueries</a></span></dt><dt><span class="section"><a href="sql-syntax.html#any-in-some-subqueries">13.2.10.3 Subqueries with ANY, IN, or SOME</a></span></dt><dt><span class="section"><a href="sql-syntax.html#all-subqueries">13.2.10.4 Subqueries with ALL</a></span></dt><dt><span class="section"><a href="sql-syntax.html#row-subqueries">13.2.10.5 Row Subqueries</a></span></dt><dt><span class="section"><a href="sql-syntax.html#exists-and-not-exists-subqueries">13.2.10.6 Subqueries with EXISTS or NOT EXISTS</a></span></dt><dt><span class="section"><a href="sql-syntax.html#correlated-subqueries">13.2.10.7 Correlated Subqueries</a></span></dt><dt><span class="section"><a href="sql-syntax.html#derived-tables">13.2.10.8 Derived Tables</a></span></dt><dt><span class="section"><a href="sql-syntax.html#subquery-errors">13.2.10.9 Subquery Errors</a></span></dt><dt><span class="section"><a href="sql-syntax.html#optimizing-subqueries">13.2.10.10 Optimizing Subqueries</a></span></dt><dt><span class="section"><a href="sql-syntax.html#rewriting-subqueries">13.2.10.11 Rewriting Subqueries as Joins</a></span></dt><dt><span class="section"><a href="sql-syntax.html#subquery-restrictions">13.2.10.12 Restrictions on Subqueries</a></span></dt></dl>
            </div>
            <a class="indexterm" name="idm140286834180176"></a><a class="indexterm" name="idm140286834179104"></a><a class="indexterm" name="idm140286834178032"></a><a class="indexterm" name="idm140286834176544"></a><p>
            A subquery is a <a class="link" href="sql-syntax.html#select" title="13.2.9&nbsp;SELECT Syntax"><code class="literal">SELECT</code></a> statement
            within another statement.
        </p><p style="color:blue;">子查询是另一个语句中的select语句。</p><p>
            All subquery forms and operations that the SQL standard requires
            are supported, as well as a few features that are MySQL-specific.
        </p><p style="color:blue;">支持sql标准要求的所有子查询表单和操作，以及一些特定于mysql的特性。</p><p>
            Here is an example of a subquery:
        </p><p style="color:blue;">下面是子查询的示例：</p><pre data-lang="sql" class="programlisting">SELECT * FROM t1 WHERE column1 = (SELECT column1 FROM t2);
</pre><p>
            In this example, <code class="literal">SELECT * FROM t1 ...</code> is the
            <span class="emphasis"><em>outer query</em></span> (or <span class="emphasis"><em>outer
      statement</em></span>), and <code class="literal">(SELECT column1 FROM
            t2)</code> is the <span class="emphasis"><em>subquery</em></span>. We say that
            the subquery is <span class="emphasis"><em>nested</em></span> within the outer
            query, and in fact it is possible to nest subqueries within other
            subqueries, to a considerable depth. A subquery must always appear
            within parentheses.
        </p><p style="color:blue;">在本例中，从T1中选择*。是外部查询（或外部语句），并且（从t2中选择column1）是子查询。我们说子查询嵌套在外部查询中，实际上可以将子查询嵌套在其他子查询中，嵌套的深度相当大。子查询必须始终出现在括号内。</p><p>
            The main advantages of subqueries are:
        </p><p style="color:blue;">子查询的主要优点是：</p>
            <div class="itemizedlist">
                <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                    They allow queries that are <span class="emphasis"><em>structured</em></span> so
                    that it is possible to isolate each part of a statement.
                </p><p style="color:blue;">它们允许结构化的查询，以便能够隔离语句的每个部分。</p></li><li class="listitem"><p>
                    They provide alternative ways to perform operations that would
                    otherwise require complex joins and unions.
                </p><p style="color:blue;">它们提供了执行操作的替代方法，否则将需要复杂的联接和联合。</p></li><li class="listitem"><p>
                    Many people find subqueries more readable than complex joins
                    or unions. Indeed, it was the innovation of subqueries that
                    gave people the original idea of calling the early SQL
                    <span class="quote">“<span class="quote">Structured Query Language.</span>”</span>
                </p><p style="color:blue;">许多人发现子查询比复杂的连接或联合更具可读性。实际上，正是子查询的创新，让人们有了将早期sql称为“结构化查询语言”的最初想法。</p><a class="indexterm" name="idm140286834163680"></a></li></ul>
            </div>
            <p>
                Here is an example statement that shows the major points about
                subquery syntax as specified by the SQL standard and supported in
                MySQL:
            </p><p style="color:blue;">下面是一个示例语句，它显示了sql标准指定的、mysql支持的子查询语法的要点：</p><pre data-lang="sql" class="programlisting">DELETE FROM t1
WHERE s11 &gt; ANY
 (SELECT COUNT(*) /* no hint */ FROM t2
  WHERE NOT EXISTS
   (SELECT * FROM t3
    WHERE ROW(5*t2.s1,77)=
     (SELECT 50,11*s1 FROM t4 UNION SELECT 50,77 FROM
      (SELECT * FROM t5) AS t5)));
</pre><p>
            A subquery can return a scalar (a single value), a single row, a
            single column, or a table (one or more rows of one or more
            columns). These are called scalar, column, row, and table
            subqueries. Subqueries that return a particular kind of result
            often can be used only in certain contexts, as described in the
            following sections.
        </p><p style="color:blue;">子查询可以返回标量（单个值）、单个行、单个列或表（一列或多列中的一行或多行）。这些子查询称为标量、列、行和表子查询。返回特定类型结果的子查询通常只能在某些上下文中使用，如以下各节所述。</p><p>
            There are few restrictions on the type of statements in which
            subqueries can be used. A subquery can contain many of the
            keywords or clauses that an ordinary
            <a class="link" href="sql-syntax.html#select" title="13.2.9&nbsp;SELECT Syntax"><code class="literal">SELECT</code></a> can contain:
            <code class="literal">DISTINCT</code>, <code class="literal">GROUP BY</code>,
            <code class="literal">ORDER BY</code>, <code class="literal">LIMIT</code>, joins,
            index hints, <a class="link" href="sql-syntax.html#union" title="13.2.9.3&nbsp;UNION Syntax"><code class="literal">UNION</code></a> constructs,
            comments, functions, and so on.
        </p><p style="color:blue;">对子查询可以使用的语句类型几乎没有限制。子查询可以包含普通select可以包含的许多关键字或子句：distinct、group by、order by、limit、joins、索引提示、union构造、注释、函数等。</p><p>
            A subquery's outer statement can be any one of:
            <a class="link" href="sql-syntax.html#select" title="13.2.9&nbsp;SELECT Syntax"><code class="literal">SELECT</code></a>,
            <a class="link" href="sql-syntax.html#insert" title="13.2.5&nbsp;INSERT Syntax"><code class="literal">INSERT</code></a>,
            <a class="link" href="sql-syntax.html#update" title="13.2.11&nbsp;UPDATE Syntax"><code class="literal">UPDATE</code></a>,
            <a class="link" href="sql-syntax.html#delete" title="13.2.2&nbsp;DELETE Syntax"><code class="literal">DELETE</code></a>,
            <a class="link" href="sql-syntax.html#set-variable" title="13.7.4.1&nbsp;SET Syntax for Variable Assignment"><code class="literal">SET</code></a>, or
            <a class="link" href="sql-syntax.html#do" title="13.2.3&nbsp;DO Syntax"><code class="literal">DO</code></a>.
        </p><p style="color:blue;">子查询的外部语句可以是以下任一语句：select、insert、update、delete、set或do。</p><p>
            In MySQL, you cannot modify a table and select from the same table
            in a subquery. This applies to statements such as
            <a class="link" href="sql-syntax.html#delete" title="13.2.2&nbsp;DELETE Syntax"><code class="literal">DELETE</code></a>,
            <a class="link" href="sql-syntax.html#insert" title="13.2.5&nbsp;INSERT Syntax"><code class="literal">INSERT</code></a>,
            <a class="link" href="sql-syntax.html#replace" title="13.2.8&nbsp;REPLACE Syntax"><code class="literal">REPLACE</code></a>,
            <a class="link" href="sql-syntax.html#update" title="13.2.11&nbsp;UPDATE Syntax"><code class="literal">UPDATE</code></a>, and (because subqueries can
            be used in the <code class="literal">SET</code> clause)
            <a class="link" href="sql-syntax.html#load-data" title="13.2.6&nbsp;LOAD DATA Syntax"><code class="literal">LOAD DATA</code></a>.
        </p><p style="color:blue;">在mysql中，不能修改表并从子查询中的同一个表中进行选择。这适用于delete、insert、replace、update和（因为子查询可以在set子句中使用）load data等语句。</p><p>
            For information about how the optimizer handles subqueries, see
            <a class="xref" href="optimization.html#subquery-optimization" title="8.2.2&nbsp;Optimizing Subqueries, Derived Tables, and View References">Section&nbsp;8.2.2, “Optimizing Subqueries, Derived Tables, and View References”</a>. For a discussion of
            restrictions on subquery use, including performance issues for
            certain forms of subquery syntax, see
            <a class="xref" href="sql-syntax.html#subquery-restrictions" title="13.2.10.12&nbsp;Restrictions on Subqueries">Section&nbsp;13.2.10.12, “Restrictions on Subqueries”</a>.
        </p><p style="color:blue;">有关优化器如何处理子查询的信息，请参阅第8.2.2节“优化子查询、派生表和视图引用”。有关子查询使用限制（包括某些形式的子查询语法的性能问题）的讨论，请参阅第13.2.10.12节“子查询限制”。</p>
            <div class="section">

                <div class="titlepage">
                    <div>
                        <div>
                            <h4 class="title"><a name="scalar-subqueries"></a>13.2.10.1&nbsp;The Subquery as Scalar Operand</h4>
                        </div>
                    </div>
                </div>
                <p>
                    In its simplest form, a subquery is a scalar subquery that
                    returns a single value. A scalar subquery is a simple operand,
                    and you can use it almost anywhere a single column value or
                    literal is legal, and you can expect it to have those
                    characteristics that all operands have: a data type, a length,
                    an indication that it can be <code class="literal">NULL</code>, and so on.
                    For example:
                </p><p style="color:blue;">在最简单的形式中，子查询是返回单个值的标量子查询。标量子查询是一个简单的操作数，您几乎可以在任何合法的单列值或文字处使用它，并且您可以期望它具有所有操作数所具有的特性：数据类型、长度、可以为空的指示等等。例如：</p><pre data-lang="sql" class="programlisting">CREATE TABLE t1 (s1 INT, s2 CHAR(5) NOT NULL);
INSERT INTO t1 VALUES(100, 'abcde');
SELECT (SELECT s2 FROM t1);
</pre><p>
                The subquery in this <a class="link" href="sql-syntax.html#select" title="13.2.9&nbsp;SELECT Syntax"><code class="literal">SELECT</code></a>
                returns a single value (<code class="literal">'abcde'</code>) that has a
                data type of <a class="link" href="data-types.html#char" title="11.4.1&nbsp;The CHAR and VARCHAR Types"><code class="literal">CHAR</code></a>, a length of 5,
                a character set and collation equal to the defaults in effect at
                <a class="link" href="sql-syntax.html#create-table" title="13.1.18&nbsp;CREATE TABLE Syntax"><code class="literal">CREATE TABLE</code></a> time, and an
                indication that the value in the column can be
                <code class="literal">NULL</code>. Nullability of the value selected by a
                scalar subquery is not copied because if the subquery result is
                empty, the result is <code class="literal">NULL</code>. For the subquery
                just shown, if <code class="literal">t1</code> were empty, the result
                would be <code class="literal">NULL</code> even though
                <code class="literal">s2</code> is <code class="literal">NOT NULL</code>.
            </p><p style="color:blue;">此选择中的子查询返回一个值（“abcde”），该值的数据类型为char，长度为5，字符集和排序规则等于创建表时生效的默认值，并且指示列中的值可以为空。不会复制标量子查询所选值的可空性，因为如果子查询结果为空，则结果为空。对于刚刚显示的子查询，如果T1为空，那么即使S2不为空，结果也将为空。</p><p>
                There are a few contexts in which a scalar subquery cannot be
                used. If a statement permits only a literal value, you cannot
                use a subquery. For example, <code class="literal">LIMIT</code> requires
                literal integer arguments, and <a class="link" href="sql-syntax.html#load-data" title="13.2.6&nbsp;LOAD DATA Syntax"><code class="literal">LOAD
                DATA</code></a> requires a literal string file name. You cannot
                use subqueries to supply these values.
            </p><p style="color:blue;">有些上下文中不能使用标量子查询。如果语句只允许文本值，则不能使用子查询。例如，limit需要文本整型参数，而load data需要文本字符串文件名。不能使用子查询提供这些值。</p><p>
                When you see examples in the following sections that contain the
                rather spartan construct <code class="literal">(SELECT column1 FROM
                t1)</code>, imagine that your own code contains much more
                diverse and complex constructions.
            </p><p style="color:blue;">当您在下面的小节中看到包含相当斯巴达式构造（从T1中选择Column1）的示例时，假设您自己的代码包含的构造更加多样和复杂。</p><p>
                Suppose that we make two tables:
            </p><p style="color:blue;">假设我们做了两张桌子：</p><pre data-lang="sql" class="programlisting">CREATE TABLE t1 (s1 INT);
INSERT INTO t1 VALUES (1);
CREATE TABLE t2 (s1 INT);
INSERT INTO t2 VALUES (2);
</pre><p>
                Then perform a <a class="link" href="sql-syntax.html#select" title="13.2.9&nbsp;SELECT Syntax"><code class="literal">SELECT</code></a>:
            </p><p style="color:blue;">然后执行选择：</p><pre data-lang="sql" class="programlisting">SELECT (SELECT s1 FROM t2) FROM t1;
</pre><p>
                The result is <code class="literal">2</code> because there is a row in
                <code class="literal">t2</code> containing a column <code class="literal">s1</code>
                that has a value of <code class="literal">2</code>.
            </p><p style="color:blue;">结果是2，因为t2中有一行包含值为2的列s1。</p><p>
                A scalar subquery can be part of an expression, but remember the
                parentheses, even if the subquery is an operand that provides an
                argument for a function. For example:
            </p><p style="color:blue;">标量子查询可以是表达式的一部分，但请记住括号，即使子查询是为函数提供参数的操作数。例如：</p><pre data-lang="sql" class="programlisting">SELECT UPPER((SELECT s1 FROM t1)) FROM t2;
</pre>
            </div>
            <div class="section">
                <div class="titlepage">
                    <div>
                        <div>
                            <h4 class="title"><a name="comparisons-using-subqueries"></a>13.2.10.2&nbsp;Comparisons Using Subqueries</h4>

                        </div>

                    </div>

                </div>
                <p>
                    The most common use of a subquery is in the form:
                </p><p style="color:blue;">子查询最常用的形式是：</p><pre data-lang="sql" class="programlisting"><em class="replaceable"><code>non_subquery_operand</code></em> <em class="replaceable"><code>comparison_operator</code></em> (<em class="replaceable"><code>subquery</code></em>)
</pre><p>
                Where <em class="replaceable"><code>comparison_operator</code></em> is one of
                these operators:
            </p><p style="color:blue;">其中比较运算符是这些运算符之一：</p><pre data-lang="sql" class="programlisting">=  &gt;  &lt;  &gt;=  &lt;=  &lt;&gt;  !=  &lt;=&gt;
</pre><p>
                For example:
            </p><p style="color:blue;">例如：</p><pre data-lang="sql" class="programlisting">... WHERE 'a' = (SELECT column1 FROM t1)
</pre><p>
                MySQL also permits this construct:
            </p><p style="color:blue;">mysql还允许此构造：</p><pre data-lang="sql" class="programlisting"><em class="replaceable"><code>non_subquery_operand</code></em> LIKE (<em class="replaceable"><code>subquery</code></em>)
</pre><p>
                At one time the only legal place for a subquery was on the right
                side of a comparison, and you might still find some old DBMSs
                that insist on this.
            </p><p style="color:blue;">曾经，子查询的唯一合法位置是在比较的右侧，您可能仍然会发现一些旧的dbms坚持这样做。</p><p>
                Here is an example of a common-form subquery comparison that you
                cannot do with a join. It finds all the rows in table
                <code class="literal">t1</code> for which the <code class="literal">column1</code>
                value is equal to a maximum value in table
                <code class="literal">t2</code>:
            </p><p style="color:blue;">下面是一个公共表单子查询比较的示例，您不能使用联接进行该比较。它查找表T1中的所有行，其中CalnN1值等于表T2中的最大值：</p><pre data-lang="sql" class="programlisting">SELECT * FROM t1
  WHERE column1 = (SELECT MAX(column2) FROM t2);
</pre><p>
                Here is another example, which again is impossible with a join
                because it involves aggregating for one of the tables. It finds
                all rows in table <code class="literal">t1</code> containing a value that
                occurs twice in a given column:
            </p><p style="color:blue;">这里是另一个例子，使用join同样是不可能的，因为它涉及到一个表的聚合。它查找表T1中包含给定列中出现两次的值的所有行：</p><pre data-lang="sql" class="programlisting">SELECT * FROM t1 AS t
  WHERE 2 = (SELECT COUNT(*) FROM t1 WHERE t1.id = t.id);
</pre><p>
                For a comparison of the subquery to a scalar, the subquery must
                return a scalar. For a comparison of the subquery to a row
                constructor, the subquery must be a row subquery that returns a
                row with the same number of values as the row constructor. See
                <a class="xref" href="sql-syntax.html#row-subqueries" title="13.2.10.5&nbsp;Row Subqueries">Section&nbsp;13.2.10.5, “Row Subqueries”</a>.
            </p><p style="color:blue;">要将子查询与标量进行比较，子查询必须返回标量。要将子查询与行构造函数进行比较，子查询必须是行子查询，该行子查询返回的行的值数与行构造函数的值数相同。见第13.2.10.5节“行子查询”。</p>
            </div>
            <div class="section">
                <div class="titlepage">
                    <div>
                        <div>
                            <h4 class="title"><a name="any-in-some-subqueries"></a>13.2.10.3&nbsp;Subqueries with ANY, IN, or SOME</h4>

                        </div>

                    </div>

                </div>
                <a class="indexterm" name="idm140286834091424"></a><a class="indexterm" name="idm140286834089968"></a><a class="indexterm" name="idm140286834088928"></a><a class="indexterm" name="idm140286834087888"></a><p>
                Syntax:
            </p><p style="color:blue;">语法：</p><pre data-lang="sql" class="programlisting"><em class="replaceable"><code>operand</code></em> <em class="replaceable"><code>comparison_operator</code></em> ANY (<em class="replaceable"><code>subquery</code></em>)
<em class="replaceable"><code>operand</code></em> IN (<em class="replaceable"><code>subquery</code></em>)
<em class="replaceable"><code>operand</code></em> <em class="replaceable"><code>comparison_operator</code></em> SOME (<em class="replaceable"><code>subquery</code></em>)
</pre><p>
                Where <em class="replaceable"><code>comparison_operator</code></em> is one of
                these operators:
            </p><p style="color:blue;">其中比较运算符是这些运算符之一：</p><pre data-lang="sql" class="programlisting">=  &gt;  &lt;  &gt;=  &lt;=  &lt;&gt;  !=
</pre><p>
                The <code class="literal">ANY</code> keyword, which must follow a
                comparison operator, means <span class="quote">“<span class="quote">return <code class="literal">TRUE</code>
        if the comparison is <code class="literal">TRUE</code> for
        <code class="literal">ANY</code> of the values in the column that the
        subquery returns.</span>”</span> For example:
            </p><p style="color:blue;">any关键字必须跟在比较运算符后面，表示“如果子查询返回的列中的任何值的比较为true，则返回true”。例如：</p><pre data-lang="sql" class="programlisting">SELECT s1 FROM t1 WHERE s1 &gt; ANY (SELECT s1 FROM t2);
</pre><p>
                Suppose that there is a row in table <code class="literal">t1</code>
                containing <code class="literal">(10)</code>. The expression is
                <code class="literal">TRUE</code> if table <code class="literal">t2</code> contains
                <code class="literal">(21,14,7)</code> because there is a value
                <code class="literal">7</code> in <code class="literal">t2</code> that is less than
                <code class="literal">10</code>. The expression is
                <code class="literal">FALSE</code> if table <code class="literal">t2</code> contains
                <code class="literal">(20,10)</code>, or if table <code class="literal">t2</code> is
                empty. The expression is <span class="emphasis"><em>unknown</em></span> (that is,
                <code class="literal">NULL</code>) if table <code class="literal">t2</code> contains
                <code class="literal">(NULL,NULL,NULL)</code>.
            </p><p style="color:blue;">假设表T1中有一行包含（10）。如果表t2包含（21,14,7），则表达式为true，因为t2中有一个小于10的值7。如果表t2包含（20,10），或者表t2为空，则表达式为false。如果表t2包含（null，null，null），则表达式未知（即，null）。</p><p>
                When used with a subquery, the word <code class="literal">IN</code> is an
                alias for <code class="literal">= ANY</code>. Thus, these two statements
                are the same:
            </p><p style="color:blue;">与子查询一起使用时，in是=any的别名。因此，这两种说法是相同的：</p><pre data-lang="sql" class="programlisting">SELECT s1 FROM t1 WHERE s1 = ANY (SELECT s1 FROM t2);
SELECT s1 FROM t1 WHERE s1 IN    (SELECT s1 FROM t2);
</pre><p>
                <code class="literal">IN</code> and <code class="literal">= ANY</code> are not
                synonyms when used with an expression list.
                <code class="literal">IN</code> can take an expression list, but
                <code class="literal">= ANY</code> cannot. See
                <a class="xref" href="functions.html#comparison-operators" title="12.3.2&nbsp;Comparison Functions and Operators">Section&nbsp;12.3.2, “Comparison Functions and Operators”</a>.
            </p><p style="color:blue;">与表达式列表一起使用时，in和=any不是同义词。in可以接受表达式列表，但=any不能。见第12.3.2节“比较函数和运算符”。</p><p>
                <code class="literal">NOT IN</code> is not an alias for <code class="literal">&lt;&gt;
                ANY</code>, but for <code class="literal">&lt;&gt; ALL</code>. See
                <a class="xref" href="sql-syntax.html#all-subqueries" title="13.2.10.4&nbsp;Subqueries with ALL">Section&nbsp;13.2.10.4, “Subqueries with ALL”</a>.
            </p><p style="color:blue;">not in不是&lt;&gt;any的别名，而是&lt;&gt;all的别名。见第13.2.10.4节“所有子查询”。</p><p>
                The word <code class="literal">SOME</code> is an alias for
                <code class="literal">ANY</code>. Thus, these two statements are the same:
            </p><p style="color:blue;">some这个词是any的别名。因此，这两种说法是相同的：</p><pre data-lang="sql" class="programlisting">SELECT s1 FROM t1 WHERE s1 &lt;&gt; ANY  (SELECT s1 FROM t2);
SELECT s1 FROM t1 WHERE s1 &lt;&gt; SOME (SELECT s1 FROM t2);
</pre><p>
                Use of the word <code class="literal">SOME</code> is rare, but this
                example shows why it might be useful. To most people, the
                English phrase <span class="quote">“<span class="quote">a is not equal to any b</span>”</span> means
                <span class="quote">“<span class="quote">there is no b which is equal to a,</span>”</span> but that is
                not what is meant by the SQL syntax. The syntax means
                <span class="quote">“<span class="quote">there is some b to which a is not equal.</span>”</span> Using
                <code class="literal">&lt;&gt; SOME</code> instead helps ensure that
                everyone understands the true meaning of the query.
            </p><p style="color:blue;">使用some这个词是很少见的，但是这个例子说明了为什么它可能是有用的。对大多数人来说，英语短语“a不等于任何b”意味着“没有b等于a”，但这不是sql语法的意思。语法的意思是“有一些b与a不相等”。使用&lt;&gt;some可帮助确保每个人都理解查询的真正含义。</p>
            </div>
            <div class="section">
                <div class="titlepage">
                    <div>
                        <div>
                            <h4 class="title"><a name="all-subqueries"></a>13.2.10.4&nbsp;Subqueries with ALL</h4>

                        </div>

                    </div>

                </div>
                <a class="indexterm" name="idm140286834045776"></a><a class="indexterm" name="idm140286834044288"></a><p>
                Syntax:
            </p><p style="color:blue;">语法：</p><pre data-lang="sql" class="programlisting"><em class="replaceable"><code>operand</code></em> <em class="replaceable"><code>comparison_operator</code></em> ALL (<em class="replaceable"><code>subquery</code></em>)
</pre><p>
                The word <code class="literal">ALL</code>, which must follow a comparison
                operator, means <span class="quote">“<span class="quote">return <code class="literal">TRUE</code> if the
        comparison is <code class="literal">TRUE</code> for <code class="literal">ALL</code>
        of the values in the column that the subquery returns.</span>”</span>
                For example:
            </p><p style="color:blue;">单词all必须跟在比较运算符后面，表示“如果子查询返回的列中的所有值的比较为true，则返回true”。例如：</p><pre data-lang="sql" class="programlisting">SELECT s1 FROM t1 WHERE s1 &gt; ALL (SELECT s1 FROM t2);
</pre><p>
                Suppose that there is a row in table <code class="literal">t1</code>
                containing <code class="literal">(10)</code>. The expression is
                <code class="literal">TRUE</code> if table <code class="literal">t2</code> contains
                <code class="literal">(-5,0,+5)</code> because <code class="literal">10</code> is
                greater than all three values in <code class="literal">t2</code>. The
                expression is <code class="literal">FALSE</code> if table
                <code class="literal">t2</code> contains
                <code class="literal">(12,6,NULL,-100)</code> because there is a single
                value <code class="literal">12</code> in table <code class="literal">t2</code> that
                is greater than <code class="literal">10</code>. The expression is
                <span class="emphasis"><em>unknown</em></span> (that is, <code class="literal">NULL</code>)
                if table <code class="literal">t2</code> contains
                <code class="literal">(0,NULL,1)</code>.
            </p><p style="color:blue;">假设表T1中有一行包含（10）。如果表t2包含（-5,0，+5），则表达式为true，因为10大于t2中的所有三个值。如果表t2包含（12,6，null，-100），则表达式为false，因为表t2中有一个值12大于10。如果表t2包含（0，null，1），则表达式未知（即，null）。</p><p>
                Finally, the expression is <code class="literal">TRUE</code> if table
                <code class="literal">t2</code> is empty. So, the following expression is
                <code class="literal">TRUE</code> when table <code class="literal">t2</code> is
                empty:
            </p><p style="color:blue;">最后，如果表t2为空，则表达式为true。因此，当表t2为空时，以下表达式为真：</p><pre data-lang="sql" class="programlisting">SELECT * FROM t1 WHERE 1 &gt; ALL (SELECT s1 FROM t2);
</pre><p>
                But this expression is <code class="literal">NULL</code> when table
                <code class="literal">t2</code> is empty:
            </p><p style="color:blue;">但当表t2为空时，此表达式为空：</p><pre data-lang="sql" class="programlisting">SELECT * FROM t1 WHERE 1 &gt; (SELECT s1 FROM t2);
</pre><p>
                In addition, the following expression is <code class="literal">NULL</code>
                when table <code class="literal">t2</code> is empty:
            </p><p style="color:blue;">此外，当表t2为空时，以下表达式为空：</p><pre data-lang="sql" class="programlisting">SELECT * FROM t1 WHERE 1 &gt; ALL (SELECT MAX(s1) FROM t2);
</pre><p>
                In general, <span class="emphasis"><em>tables containing <code class="literal">NULL</code>
        values</em></span> and <span class="emphasis"><em>empty tables</em></span> are
                <span class="quote">“<span class="quote">edge cases.</span>”</span> When writing subqueries, always
                consider whether you have taken those two possibilities into
                account.
            </p><p style="color:blue;">一般来说，包含空值和空表的表是“边案例”。在编写子查询时，请始终考虑是否考虑了这两种可能性。</p><p>
                <code class="literal">NOT IN</code> is an alias for <code class="literal">&lt;&gt;
                ALL</code>. Thus, these two statements are the same:
            </p><p style="color:blue;">not in是&lt;&gt;all的别名。因此，这两种说法是相同的：</p><pre data-lang="sql" class="programlisting">SELECT s1 FROM t1 WHERE s1 &lt;&gt; ALL (SELECT s1 FROM t2);
SELECT s1 FROM t1 WHERE s1 NOT IN (SELECT s1 FROM t2);
</pre>
            </div>
            <div class="section">
                <div class="titlepage">
                    <div>
                        <div>
                            <h4 class="title"><a name="row-subqueries"></a>13.2.10.5&nbsp;Row Subqueries</h4>

                        </div>

                    </div>

                </div>
                <a class="indexterm" name="idm140286834006720"></a><a class="indexterm" name="idm140286834005648"></a><a class="indexterm" name="idm140286834004608"></a><a class="indexterm" name="idm140286834003536"></a><p>
                Scalar or column subqueries return a single value or a column of
                values. A <span class="emphasis"><em>row subquery</em></span> is a subquery
                variant that returns a single row and can thus return more than
                one column value. Legal operators for row subquery comparisons
                are:
            </p><p style="color:blue;">标量或列子查询返回单个值或一列值。行子查询是返回一行的子查询变量，因此可以返回多个列值。行子查询比较的合法运算符为：</p><pre data-lang="sql" class="programlisting">=  &gt;  &lt;  &gt;=  &lt;=  &lt;&gt;  !=  &lt;=&gt;
</pre><p>
                Here are two examples:
            </p><p style="color:blue;">下面是两个例子：</p><pre data-lang="sql" class="programlisting">SELECT * FROM t1
  WHERE (col1,col2) = (SELECT col3, col4 FROM t2 WHERE id = 10);
SELECT * FROM t1
  WHERE ROW(col1,col2) = (SELECT col3, col4 FROM t2 WHERE id = 10);
</pre><p>
                For both queries, if the table <code class="literal">t2</code> contains a
                single row with <code class="literal">id = 10</code>, the subquery returns
                a single row. If this row has <code class="literal">col3</code> and
                <code class="literal">col4</code> values equal to the
                <code class="literal">col1</code> and <code class="literal">col2</code> values of
                any rows in <code class="literal">t1</code>, the <code class="literal">WHERE</code>
                expression is <code class="literal">TRUE</code> and each query returns
                those <code class="literal">t1</code> rows. If the <code class="literal">t2</code>
                row <code class="literal">col3</code> and <code class="literal">col4</code> values
                are not equal the <code class="literal">col1</code> and
                <code class="literal">col2</code> values of any <code class="literal">t1</code> row,
                the expression is <code class="literal">FALSE</code> and the query returns
                an empty result set. The expression is
                <span class="emphasis"><em>unknown</em></span> (that is, <code class="literal">NULL</code>)
                if the subquery produces no rows. An error occurs if the
                subquery produces multiple rows because a row subquery can
                return at most one row.
            </p><p style="color:blue;">对于这两个查询，如果表t2包含id=10的单行，则子查询返回单行。如果此行的col3和col4值等于t1中任何行的col1和col2值，则where表达式为true，每个查询都返回这些t1行。如果t2行col3和col4值不等于任何t1行的col1和col2值，则表达式为false，查询返回空结果集。如果子查询不生成行，则表达式未知（即空）。如果子查询生成多行，则会发生错误，因为行子查询最多只能返回一行。</p><p>
                For information about how each operator works for row
                comparisons, see <a class="xref" href="functions.html#comparison-operators" title="12.3.2&nbsp;Comparison Functions and Operators">Section&nbsp;12.3.2, “Comparison Functions and Operators”</a>.
            </p><p style="color:blue;">有关每个运算符如何用于行比较的信息，请参阅第12.3.2节“比较函数和运算符”。</p><p>
                The expressions <code class="literal">(1,2)</code> and
                <code class="literal">ROW(1,2)</code> are sometimes called
                <span class="firstterm">row constructors</span>. The two
                are equivalent. The row constructor and the row returned by the
                subquery must contain the same number of values.
            </p><p style="color:blue;">表达式（1,2）和行（1,2）有时称为行构造函数。两者相当。行构造函数和子查询返回的行必须包含相同数量的值。</p><p>
                A row constructor is used for comparisons with subqueries that
                return two or more columns. When a subquery returns a single
                column, this is regarded as a scalar value and not as a row, so
                a row constructor cannot be used with a subquery that does not
                return at least two columns. Thus, the following query fails
                with a syntax error:
            </p><p style="color:blue;">行构造函数用于与返回两列或多列的子查询进行比较。当子查询返回单个列时，这将被视为标量值而不是行，因此行构造函数不能与不返回至少两列的子查询一起使用。因此，以下查询失败，并出现语法错误：</p><pre data-lang="sql" class="programlisting">SELECT * FROM t1 WHERE ROW(1) = (SELECT column1 FROM t2)
</pre><p>
                Row constructors are legal in other contexts. For example, the
                following two statements are semantically equivalent (and are
                handled in the same way by the optimizer):
            </p><p style="color:blue;">行构造函数在其他上下文中是合法的。例如，以下两个语句在语义上等价（优化器以相同的方式处理）：</p><pre data-lang="sql" class="programlisting">SELECT * FROM t1 WHERE (column1,column2) = (1,1);
SELECT * FROM t1 WHERE column1 = 1 AND column2 = 1;
</pre><p>
                The following query answers the request, <span class="quote">“<span class="quote">find all rows in
        table <code class="literal">t1</code> that also exist in table
        <code class="literal">t2</code></span>”</span>:
            </p><p style="color:blue;">下面的查询回答请求：“查找表T1中还存在的表T1中的所有行”：</p><pre data-lang="sql" class="programlisting">SELECT column1,column2,column3
  FROM t1
  WHERE (column1,column2,column3) IN
         (SELECT column1,column2,column3 FROM t2);
</pre><p>
                For more information about the optimizer and row constructors,
                see <a class="xref" href="optimization.html#row-constructor-optimization" title="8.2.1.19&nbsp;Row Constructor Expression Optimization">Section&nbsp;8.2.1.19, “Row Constructor Expression Optimization”</a>
            </p><p style="color:blue;">有关优化器和行构造函数的更多信息，请参阅8.2.1.19节，“行构造函数表达式优化”</p>
            </div>
            <div class="section">
                <div class="titlepage">
                    <div>
                        <div>
                            <h4 class="title"><a name="exists-and-not-exists-subqueries"></a>13.2.10.6&nbsp;Subqueries with EXISTS or NOT EXISTS</h4>

                        </div>

                    </div>

                </div>
                <a class="indexterm" name="idm140286833971456"></a><a class="indexterm" name="idm140286833969968"></a><a class="indexterm" name="idm140286833968480"></a><a class="indexterm" name="idm140286833966992"></a><p>
                If a subquery returns any rows at all, <code class="literal">EXISTS
                <em class="replaceable"><code>subquery</code></em></code> is
                <code class="literal">TRUE</code>, and <code class="literal">NOT EXISTS
                <em class="replaceable"><code>subquery</code></em></code> is
                <code class="literal">FALSE</code>. For example:
            </p><p style="color:blue;">如果子查询返回任何行，则exists子查询为true，not exists子查询为false。例如：</p><pre data-lang="sql" class="programlisting">SELECT column1 FROM t1 WHERE EXISTS (SELECT * FROM t2);
</pre><p>
                Traditionally, an <code class="literal">EXISTS</code> subquery starts with
                <code class="literal">SELECT *</code>, but it could begin with
                <code class="literal">SELECT 5</code> or <code class="literal">SELECT column1</code>
                or anything at all. MySQL ignores the
                <a class="link" href="sql-syntax.html#select" title="13.2.9&nbsp;SELECT Syntax"><code class="literal">SELECT</code></a> list in such a subquery,
                so it makes no difference.
            </p><p style="color:blue;">传统上，exists子查询以select*开头，但它可以以select 5或select column1开头，或者任何形式。mysql忽略了这样一个子查询中的select列表，因此没有区别。</p><p>
                For the preceding example, if <code class="literal">t2</code> contains any
                rows, even rows with nothing but <code class="literal">NULL</code> values,
                the <code class="literal">EXISTS</code> condition is
                <code class="literal">TRUE</code>. This is actually an unlikely example
                because a <code class="literal">[NOT] EXISTS</code> subquery almost always
                contains correlations. Here are some more realistic examples:
            </p><p style="color:blue;">在前面的例子中，如果t2包含任何行，即使只有空值的行，exists条件也是true。这实际上是一个不太可能的例子，因为[不]存在的子查询几乎总是包含相关性。下面是一些更现实的例子：</p>
                <div class="itemizedlist">
                    <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                        What kind of store is present in one or more cities?
                    </p><p style="color:blue;">在一个或多个城市有什么样的商店？</p><pre data-lang="sql" class="programlisting">SELECT DISTINCT store_type FROM stores
  WHERE EXISTS (SELECT * FROM cities_stores
                WHERE cities_stores.store_type = stores.store_type);
</pre></li><li class="listitem"><p>
                        What kind of store is present in no cities?
                    </p><p style="color:blue;">没有城市有什么样的商店？</p><pre data-lang="sql" class="programlisting">SELECT DISTINCT store_type FROM stores
  WHERE NOT EXISTS (SELECT * FROM cities_stores
                    WHERE cities_stores.store_type = stores.store_type);
</pre></li><li class="listitem"><p>
                        What kind of store is present in all cities?
                    </p><p style="color:blue;">所有城市都有什么样的商店？</p><pre data-lang="sql" class="programlisting">SELECT DISTINCT store_type FROM stores s1
  WHERE NOT EXISTS (
    SELECT * FROM cities WHERE NOT EXISTS (
      SELECT * FROM cities_stores
       WHERE cities_stores.city = cities.city
       AND cities_stores.store_type = stores.store_type));
</pre></li></ul>
                </div>
                <p>
                    The last example is a double-nested <code class="literal">NOT
                    EXISTS</code> query. That is, it has a <code class="literal">NOT
                    EXISTS</code> clause within a <code class="literal">NOT EXISTS</code>
                    clause. Formally, it answers the question <span class="quote">“<span class="quote">does a city
        exist with a store that is not in
        <code class="literal">Stores</code></span>”</span>? But it is easier to say that
                    a nested <code class="literal">NOT EXISTS</code> answers the question
                    <span class="quote">“<span class="quote">is <em class="replaceable"><code>x</code></em> <code class="literal">TRUE</code>
        for all <em class="replaceable"><code>y</code></em>?</span>”</span>
                </p><p style="color:blue;">最后一个例子是一个双嵌套的不存在查询。也就是说，它在不存在子句中有一个不存在子句。正式地，它回答了一个问题：“一个城市是否存在一个不在商店里的商店”？但更容易说嵌套不存在回答了“x对所有y是真的吗？”“。”</p>
            </div>
            <div class="section">
                <div class="titlepage">
                    <div>
                        <div>
                            <h4 class="title"><a name="correlated-subqueries"></a>13.2.10.7&nbsp;Correlated Subqueries</h4>

                        </div>

                    </div>

                </div>
                <a class="indexterm" name="idm140286833937936"></a><a class="indexterm" name="idm140286833936864"></a><p>
                A <span class="emphasis"><em>correlated subquery</em></span> is a subquery that
                contains a reference to a table that also appears in the outer
                query. For example:
            </p><p style="color:blue;">关联子查询是一个子查询，它包含对外部查询中也出现的表的引用。例如：</p><pre data-lang="sql" class="programlisting">SELECT * FROM t1
  WHERE column1 = ANY (SELECT column1 FROM t2
                       WHERE t2.column2 = t1.column2);
</pre><p>
                Notice that the subquery contains a reference to a column of
                <code class="literal">t1</code>, even though the subquery's
                <code class="literal">FROM</code> clause does not mention a table
                <code class="literal">t1</code>. So, MySQL looks outside the subquery, and
                finds <code class="literal">t1</code> in the outer query.
            </p><p style="color:blue;">注意，子查询包含对T1列的引用，即使子查询的FROM子句没有提到表T1。所以，mysql在子查询外部查找，并在外部查询中找到t1。</p><p>
                Suppose that table <code class="literal">t1</code> contains a row where
                <code class="literal">column1 = 5</code> and <code class="literal">column2 =
                6</code>; meanwhile, table <code class="literal">t2</code> contains a
                row where <code class="literal">column1 = 5</code> and <code class="literal">column2 =
                7</code>. The simple expression <code class="literal">... WHERE column1 =
                ANY (SELECT column1 FROM t2)</code> would be
                <code class="literal">TRUE</code>, but in this example, the
                <code class="literal">WHERE</code> clause within the subquery is
                <code class="literal">FALSE</code> (because <code class="literal">(5,6)</code> is
                not equal to <code class="literal">(5,7)</code>), so the expression as a
                whole is <code class="literal">FALSE</code>.
            </p><p style="color:blue;">假设表T1包含Column1=5和Column2=6的行；同时，表T2包含Column1=5和Column2=7的行。简单的表达…where column1=any（从t2中选择column1）将为true，但在本例中，子查询中的where子句为false（因为（5,6）不等于（5,7）），因此整个表达式为false。</p><p>
                <span class="bold"><strong>Scoping rule:</strong></span> MySQL evaluates
                from inside to outside. For example:
            </p><p style="color:blue;">作用域规则：mysql从内到外进行计算。例如：</p><pre data-lang="sql" class="programlisting">SELECT column1 FROM t1 AS x
  WHERE x.column1 = (SELECT column1 FROM t2 AS x
    WHERE x.column1 = (SELECT column1 FROM t3
      WHERE x.column2 = t3.column1));
</pre><p>
                In this statement, <code class="literal">x.column2</code> must be a column
                in table <code class="literal">t2</code> because <code class="literal">SELECT column1
                FROM t2 AS x ...</code> renames <code class="literal">t2</code>. It is
                not a column in table <code class="literal">t1</code> because
                <code class="literal">SELECT column1 FROM t1 ...</code> is an outer query
                that is <span class="emphasis"><em>farther out</em></span>.
            </p><p style="color:blue;">在此语句中，x.column2必须是表t2中的列，因为从t2中选择column1作为x…重命名T2。它不是表T1中的列，因为从T1中选择Column1…是一个更远的外部查询。</p><p>
                For subqueries in <code class="literal">HAVING</code> or <code class="literal">ORDER
                BY</code> clauses, MySQL also looks for column names in the
                outer select list.
            </p><p style="color:blue;">对于having或order by子句中的子查询，mysql还在外部选择列表中查找列名。</p><p>
                For certain cases, a correlated subquery is optimized. For
                example:
            </p><p style="color:blue;">对于某些情况，优化了相关子查询。例如：</p><pre data-lang="sql" class="programlisting"><em class="replaceable"><code>val</code></em> IN (SELECT <em class="replaceable"><code>key_val</code></em> FROM <em class="replaceable"><code>tbl_name</code></em> WHERE <em class="replaceable"><code>correlated_condition</code></em>)
</pre><p>
                Otherwise, they are inefficient and likely to be slow. Rewriting
                the query as a join might improve performance.
            </p><p style="color:blue;">否则，它们效率低下，而且可能很慢。将查询重写为联接可能会提高性能。</p><p>
                Aggregate functions in correlated subqueries may contain outer
                references, provided the function contains nothing but outer
                references, and provided the function is not contained in
                another function or expression.
            </p><p style="color:blue;">关联子查询中的聚合函数可以包含外部引用，前提是该函数只包含外部引用，并且该函数不包含在其他函数或表达式中。</p>
            </div>
            <div class="section">
                <div class="titlepage">
                    <div>
                        <div>
                            <h4 class="title"><a name="derived-tables"></a>13.2.10.8&nbsp;Derived Tables</h4>

                        </div>

                    </div>

                </div>
                <a class="indexterm" name="idm140286833905216"></a><a class="indexterm" name="idm140286833904144"></a><a class="indexterm" name="idm140286833902240"></a><p>
                A derived table is an expression that generates a table within
                the scope of a query <code class="literal">FROM</code> clause. For
                example, a subquery in a <a class="link" href="sql-syntax.html#select" title="13.2.9&nbsp;SELECT Syntax"><code class="literal">SELECT</code></a>
                statement <code class="literal">FROM</code> clause is a derived table:
            </p><p style="color:blue;">派生表是在查询from子句的范围内生成表的表达式。例如，select语句from子句中的子查询是派生表：</p><pre data-lang="sql" class="programlisting">SELECT ... FROM (<em class="replaceable"><code>subquery</code></em>) [AS] <em class="replaceable"><code>tbl_name</code></em> ...
</pre><p>
                The <code class="literal">[AS] <em class="replaceable"><code>tbl_name</code></em></code>
                clause is mandatory because every table in a
                <code class="literal">FROM</code> clause must have a name. Any columns in
                the derived table must have unique names.
            </p><p style="color:blue;">因为from子句中的每个表都必须有一个名称，[as]tbl_name子句是必需的。派生表中的任何列都必须具有唯一的名称。</p><p>
                For the sake of illustration, assume that you have this table:
            </p><p style="color:blue;">为了便于说明，假设您有这个表：</p><pre data-lang="sql" class="programlisting">CREATE TABLE t1 (s1 INT, s2 CHAR(5), s3 FLOAT);
</pre><p>
                Here is how to use a subquery in the <code class="literal">FROM</code>
                clause, using the example table:
            </p><p style="color:blue;">下面是如何在from子句中使用子查询的示例表：</p><pre data-lang="sql" class="programlisting">INSERT INTO t1 VALUES (1,'1',1.0);
INSERT INTO t1 VALUES (2,'2',2.0);
SELECT sb1,sb2,sb3
  FROM (SELECT s1 AS sb1, s2 AS sb2, s3*2 AS sb3 FROM t1) AS sb
  WHERE sb1 &gt; 1;
</pre><p>
                Result:
            </p><p style="color:blue;">结果：</p><pre data-lang="none" class="programlisting">+------+------+------+
| sb1  | sb2  | sb3  |
+------+------+------+
|    2 | 2    |    4 |
+------+------+------+
</pre><p>
                Here is another example: Suppose that you want to know the
                average of a set of sums for a grouped table. This does not
                work:
            </p><p style="color:blue;">下面是另一个例子：假设您想知道分组表的一组和的平均值。这不起作用：</p><pre data-lang="sql" class="programlisting">SELECT AVG(SUM(column1)) FROM t1 GROUP BY column1;
</pre><p>
                However, this query provides the desired information:
            </p><p style="color:blue;">但是，此查询提供了所需的信息：</p><pre data-lang="sql" class="programlisting">SELECT AVG(sum_column1)
  FROM (SELECT SUM(column1) AS sum_column1
        FROM t1 GROUP BY column1) AS t1;
</pre><p>
                Notice that the column name used within the subquery
                (<code class="literal">sum_column1</code>) is recognized in the outer
                query.
            </p><p style="color:blue;">请注意，在外部查询中可以识别子查询（sum_column1）中使用的列名。</p><p>
                A derived table can return a scalar, column, row, or table.
            </p><p style="color:blue;">派生表可以返回标量、列、行或表。</p><p>
                Derived tables are subject to these restrictions:
            </p><p style="color:blue;">派生表受以下限制：</p>
                <div class="itemizedlist">
                    <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                        A derived table cannot be a correlated subquery.
                    </p><p style="color:blue;">派生表不能是相关子查询。</p></li><li class="listitem"><p>
                        A derived table cannot contain references to other tables of
                        the same <a class="link" href="sql-syntax.html#select" title="13.2.9&nbsp;SELECT Syntax"><code class="literal">SELECT</code></a>.
                    </p><p style="color:blue;">派生表不能包含对同一选择的其他表的引用。</p></li><li class="listitem"><p>
                        A derived table cannot contain outer references. This is a
                        MySQL restriction, not a restriction of the SQL standard.
                    </p><p style="color:blue;">派生表不能包含外部引用。这是一个mysql限制，而不是sql标准的限制。</p></li></ul>
                </div>
                <p>
                    The optimizer determines information about derived tables in
                    such a way that <a class="link" href="sql-syntax.html#explain" title="13.8.2&nbsp;EXPLAIN Syntax"><code class="literal">EXPLAIN</code></a> does not
                    need to materialize them. See
                    <a class="xref" href="optimization.html#derived-table-optimization" title="8.2.2.4&nbsp;Optimizing Derived Tables and View References with Merging or Materialization">Section&nbsp;8.2.2.4, “Optimizing Derived Tables and View References with Merging or
                        Materialization”</a>.
                </p><p style="color:blue;">优化器确定有关派生表的信息的方式不需要具体化explain。参见第8.2.2.4节“使用合并或物化优化派生表和视图引用”。</p><p>
                It is possible under certain circumstances that using
                <a class="link" href="sql-syntax.html#explain" title="13.8.2&nbsp;EXPLAIN Syntax"><code class="literal">EXPLAIN
                    SELECT</code></a> will modify table data. This can occur if the
                outer query accesses any tables and an inner query invokes a
                stored function that changes one or more rows of a table.
                Suppose that there are two tables <code class="literal">t1</code> and
                <code class="literal">t2</code> in database <code class="literal">d1</code>, and a
                stored function <code class="literal">f1</code> that modifies
                <code class="literal">t2</code>, created as shown here:
            </p><p style="color:blue;">在某些情况下，使用explain select可以修改表数据。如果外部查询访问任何表，而内部查询调用更改表的一行或多行的存储函数，则可能发生这种情况。假设数据库d1中有两个表t1和t2，以及一个修改t2的存储函数f1，如下所示：</p><pre data-lang="sql" class="programlisting">CREATE DATABASE d1;
USE d1;
CREATE TABLE t1 (c1 INT);
CREATE TABLE t2 (c1 INT);
CREATE FUNCTION f1(p1 INT) RETURNS INT
  BEGIN
    INSERT INTO t2 VALUES (p1);
    RETURN p1;
  END;
</pre><p>
                Referencing the function directly in an
                <a class="link" href="sql-syntax.html#explain" title="13.8.2&nbsp;EXPLAIN Syntax"><code class="literal">EXPLAIN
                    SELECT</code></a> has no effect on <code class="literal">t2</code>, as
                shown here:
            </p><p style="color:blue;">在explain select中直接引用函数对t2没有影响，如下所示：</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT * FROM t2;</code></strong>
Empty set (0.02 sec)

mysql&gt; <strong class="userinput"><code>EXPLAIN SELECT f1(5)\G</code></strong>
*************************** 1. row ***************************
           id: 1
  select_type: SIMPLE
        table: NULL
   partitions: NULL
         type: NULL
possible_keys: NULL
          key: NULL
      key_len: NULL
          ref: NULL
         rows: NULL
     filtered: NULL
        Extra: No tables used
1 row in set (0.01 sec)

mysql&gt; <strong class="userinput"><code>SELECT * FROM t2;</code></strong>
Empty set (0.01 sec)
</pre><p>
                This is because the <a class="link" href="sql-syntax.html#select" title="13.2.9&nbsp;SELECT Syntax"><code class="literal">SELECT</code></a>
                statement did not reference any tables, as can be seen in the
                <code class="literal">table</code> and <code class="literal">Extra</code> columns of
                the output. This is also true of the following nested
                <a class="link" href="sql-syntax.html#select" title="13.2.9&nbsp;SELECT Syntax"><code class="literal">SELECT</code></a>:
            </p><p style="color:blue;">这是因为select语句没有引用任何表，这可以在表和输出的额外列中看到。以下嵌套选择也是如此：</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>EXPLAIN SELECT NOW() AS a1, (SELECT f1(5)) AS a2\G</code></strong>
*************************** 1. row ***************************
           id: 1
  select_type: SIMPLE
        table: NULL
         type: NULL
possible_keys: NULL
          key: NULL
      key_len: NULL
          ref: NULL
         rows: NULL
     filtered: NULL
        Extra: No tables used
1 row in set, 1 warning (0.00 sec)

mysql&gt; <strong class="userinput"><code>SHOW WARNINGS;</code></strong>
+-------+------+------------------------------------------+
| Level | Code | Message                                  |
+-------+------+------------------------------------------+
| Note  | 1249 | Select 2 was reduced during optimization |
+-------+------+------------------------------------------+
1 row in set (0.00 sec)

mysql&gt; <strong class="userinput"><code>SELECT * FROM t2;</code></strong>
Empty set (0.00 sec)
</pre><p>
                However, if the outer <a class="link" href="sql-syntax.html#select" title="13.2.9&nbsp;SELECT Syntax"><code class="literal">SELECT</code></a>
                references any tables, the optimizer executes the statement in
                the subquery as well, with the result that <code class="literal">t2</code>
                is modified:
            </p><p style="color:blue;">但是，如果外部select引用任何表，优化器也会执行子查询中的语句，结果是t2被修改：</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>EXPLAIN SELECT * FROM t1 AS a1, (SELECT f1(5)) AS a2\G</code></strong>
*************************** 1. row ***************************
           id: 1
  select_type: PRIMARY
        table: &lt;derived2&gt;
   partitions: NULL
         type: system
possible_keys: NULL
          key: NULL
      key_len: NULL
          ref: NULL
         rows: 1
     filtered: 100.00
        Extra: NULL
*************************** 2. row ***************************
           id: 1
  select_type: PRIMARY
        table: a1
   partitions: NULL
         type: ALL
possible_keys: NULL
          key: NULL
      key_len: NULL
          ref: NULL
         rows: 1
     filtered: 100.00
        Extra: NULL
*************************** 3. row ***************************
           id: 2
  select_type: DERIVED
        table: NULL
   partitions: NULL
         type: NULL
possible_keys: NULL
          key: NULL
      key_len: NULL
          ref: NULL
         rows: NULL
     filtered: NULL
        Extra: No tables used
3 rows in set (0.00 sec)

mysql&gt; <strong class="userinput"><code>SELECT * FROM t2;</code></strong>
+------+
| c1   |
+------+
|    5 |
+------+
1 row in set (0.00 sec)
</pre><p>
                This also means that an
                <a class="link" href="sql-syntax.html#explain" title="13.8.2&nbsp;EXPLAIN Syntax"><code class="literal">EXPLAIN
                    SELECT</code></a> statement such as the one shown here may take a
                long time to execute because the
                <a class="link" href="functions.html#function_benchmark"><code class="literal">BENCHMARK()</code></a> function is executed
                once for each row in <code class="literal">t1</code>:
            </p><p style="color:blue;">这也意味着explain-select语句（如这里所示）可能需要很长时间才能执行，因为在T1中每行执行一次benchmark（）函数：</p><pre data-lang="sql" class="programlisting">EXPLAIN SELECT * FROM t1 AS a1, (SELECT BENCHMARK(1000000, MD5(NOW())));
</pre>
            </div>
            <div class="section">
                <div class="titlepage">
                    <div>
                        <div>
                            <h4 class="title"><a name="subquery-errors"></a>13.2.10.9&nbsp;Subquery Errors</h4>

                        </div>

                    </div>

                </div>
                <a class="indexterm" name="idm140286833841904"></a><a class="indexterm" name="idm140286833840416"></a><p>
                There are some errors that apply only to subqueries. This
                section describes them.
            </p><p style="color:blue;">有些错误仅适用于子查询。本节介绍它们。</p>
                <div class="itemizedlist">
                    <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                        Unsupported subquery syntax:
                    </p><p style="color:blue;">不支持的子查询语法：</p><pre data-lang="none" class="programlisting">ERROR 1235 (ER_NOT_SUPPORTED_YET)
SQLSTATE = 42000
Message = "This version of MySQL doesn't yet support
'LIMIT &amp; IN/ALL/ANY/SOME subquery'"
</pre><p>
                        This means that MySQL does not support statements of the
                        following form:
                    </p><p style="color:blue;">这意味着mysql不支持以下形式的语句：</p><pre data-lang="sql" class="programlisting">SELECT * FROM t1 WHERE s1 IN (SELECT s2 FROM t2 ORDER BY s1 LIMIT 1)
</pre></li><li class="listitem"><p>
                        Incorrect number of columns from subquery:
                    </p><p style="color:blue;">子查询中的列数不正确：</p><pre data-lang="none" class="programlisting">ERROR 1241 (ER_OPERAND_COL)
SQLSTATE = 21000
Message = "Operand should contain 1 column(s)"
</pre><p>
                        This error occurs in cases like this:
                    </p><p style="color:blue;">在以下情况下会发生此错误：</p><pre data-lang="sql" class="programlisting">SELECT (SELECT column1, column2 FROM t2) FROM t1;
</pre><p>
                        You may use a subquery that returns multiple columns, if the
                        purpose is row comparison. In other contexts, the subquery
                        must be a scalar operand. See
                        <a class="xref" href="sql-syntax.html#row-subqueries" title="13.2.10.5&nbsp;Row Subqueries">Section&nbsp;13.2.10.5, “Row Subqueries”</a>.
                    </p><p style="color:blue;">如果目的是行比较，则可以使用返回多列的子查询。在其他上下文中，子查询必须是标量操作数。见第13.2.10.5节“行子查询”。</p></li><li class="listitem"><p>
                        Incorrect number of rows from subquery:
                    </p><p style="color:blue;">子查询中的行数不正确：</p><pre data-lang="none" class="programlisting">ERROR 1242 (ER_SUBSELECT_NO_1_ROW)
SQLSTATE = 21000
Message = "Subquery returns more than 1 row"
</pre><p>
                        This error occurs for statements where the subquery must
                        return at most one row but returns multiple rows. Consider
                        the following example:
                    </p><p style="color:blue;">对于子查询必须最多返回一行但返回多行的语句，会发生此错误。请考虑以下示例：</p><pre data-lang="sql" class="programlisting">SELECT * FROM t1 WHERE column1 = (SELECT column1 FROM t2);
</pre><p>
                        If <code class="literal">SELECT column1 FROM t2</code> returns just
                        one row, the previous query will work. If the subquery
                        returns more than one row, error 1242 will occur. In that
                        case, the query should be rewritten as:
                    </p><p style="color:blue;">如果从t2选择column1只返回一行，则上一个查询将工作。如果子查询返回多行，则将发生错误1242。在这种情况下，查询应重写为：</p><pre data-lang="sql" class="programlisting">SELECT * FROM t1 WHERE column1 = ANY (SELECT column1 FROM t2);
</pre></li><li class="listitem"><p>
                        Incorrectly used table in subquery:
                    </p><p style="color:blue;">子查询中使用不正确的表：</p><pre data-lang="none" class="programlisting">Error 1093 (ER_UPDATE_TABLE_USED)
SQLSTATE = HY000
Message = "You can't specify target table 'x'
for update in FROM clause"
</pre><p>
                        This error occurs in cases such as the following, which
                        attempts to modify a table and select from the same table in
                        the subquery:
                    </p><p style="color:blue;">在以下情况下会发生此错误，这些情况试图修改表并从子查询中的同一表中进行选择：</p><pre data-lang="sql" class="programlisting">UPDATE t1 SET column2 = (SELECT MAX(column1) FROM t1);
</pre><p>
                        You can use a subquery for assignment within an
                        <a class="link" href="sql-syntax.html#update" title="13.2.11&nbsp;UPDATE Syntax"><code class="literal">UPDATE</code></a> statement because
                        subqueries are legal in
                        <a class="link" href="sql-syntax.html#update" title="13.2.11&nbsp;UPDATE Syntax"><code class="literal">UPDATE</code></a> and
                        <a class="link" href="sql-syntax.html#delete" title="13.2.2&nbsp;DELETE Syntax"><code class="literal">DELETE</code></a> statements as well as
                        in <a class="link" href="sql-syntax.html#select" title="13.2.9&nbsp;SELECT Syntax"><code class="literal">SELECT</code></a> statements.
                        However, you cannot use the same table (in this case, table
                        <code class="literal">t1</code>) for both the subquery
                        <code class="literal">FROM</code> clause and the update target.
                    </p><p style="color:blue;">您可以在update语句中使用子查询进行赋值，因为子查询在update和delete语句以及select语句中都是合法的。但是，不能对子查询from子句和update目标同时使用同一个表（在本例中是表t1）。</p></li></ul>
                </div>
                <p>
                    For transactional storage engines, the failure of a subquery
                    causes the entire statement to fail. For nontransactional
                    storage engines, data modifications made before the error was
                    encountered are preserved.
                </p><p style="color:blue;">对于事务性存储引擎，子查询的失败会导致整个语句失败。对于非事务性存储引擎，将保留在遇到错误之前所做的数据修改。</p>
            </div>
            <div class="section">
                <div class="titlepage">
                    <div>
                        <div>
                            <h4 class="title"><a name="optimizing-subqueries"></a>13.2.10.10&nbsp;Optimizing Subqueries</h4>

                        </div>

                    </div>

                </div>
                <p>
                    Development is ongoing, so no optimization tip is reliable for
                    the long term. The following list provides some interesting
                    tricks that you might want to play with. See also
                    <a class="xref" href="optimization.html#subquery-optimization" title="8.2.2&nbsp;Optimizing Subqueries, Derived Tables, and View References">Section&nbsp;8.2.2, “Optimizing Subqueries, Derived Tables, and View References”</a>.
                </p><p style="color:blue;">开发正在进行中，因此没有任何优化技巧是长期可靠的。下面的列表提供了一些您可能想玩的有趣的技巧。另请参见第8.2.2节“优化子查询、派生表和视图引用”。</p>
                <div class="itemizedlist">
                    <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                        Use subquery clauses that affect the number or order of the
                        rows in the subquery. For example:
                    </p><p style="color:blue;">使用影响子查询中行的数目或顺序的子查询子句。例如：</p><pre data-lang="sql" class="programlisting">SELECT * FROM t1 WHERE t1.column1 IN
  (SELECT column1 FROM t2 ORDER BY column1);
SELECT * FROM t1 WHERE t1.column1 IN
  (SELECT DISTINCT column1 FROM t2);
SELECT * FROM t1 WHERE EXISTS
  (SELECT * FROM t2 LIMIT 1);
</pre></li><li class="listitem"><p>
                        Replace a join with a subquery. For example, try this:
                    </p><p style="color:blue;">用子查询替换联接。例如，尝试以下操作：</p><pre data-lang="sql" class="programlisting">SELECT DISTINCT column1 FROM t1 WHERE t1.column1 IN (
  SELECT column1 FROM t2);
</pre><p>
                        Instead of this:
                    </p><p style="color:blue;">而不是这个：</p><pre data-lang="sql" class="programlisting">SELECT DISTINCT t1.column1 FROM t1, t2
  WHERE t1.column1 = t2.column1;
</pre></li><li class="listitem"><p>
                        Some subqueries can be transformed to joins for
                        compatibility with older versions of MySQL that do not
                        support subqueries. However, in some cases, converting a
                        subquery to a join may improve performance. See
                        <a class="xref" href="sql-syntax.html#rewriting-subqueries" title="13.2.10.11&nbsp;Rewriting Subqueries as Joins">Section&nbsp;13.2.10.11, “Rewriting Subqueries as Joins”</a>.
                    </p><p style="color:blue;">为了与不支持子查询的旧版本mysql兼容，可以将某些子查询转换为联接。但是，在某些情况下，将子查询转换为联接可能会提高性能。参见第13.2.10.11节“将子查询重写为联接”。</p></li><li class="listitem"><p>
                        Move clauses from outside to inside the subquery. For
                        example, use this query:
                    </p><p style="color:blue;">将子句从子查询的外部移到内部。例如，使用此查询：</p><pre data-lang="sql" class="programlisting">SELECT * FROM t1
  WHERE s1 IN (SELECT s1 FROM t1 UNION ALL SELECT s1 FROM t2);
</pre><p>
                        Instead of this query:
                    </p><p style="color:blue;">而不是此查询：</p><pre data-lang="sql" class="programlisting">SELECT * FROM t1
  WHERE s1 IN (SELECT s1 FROM t1) OR s1 IN (SELECT s1 FROM t2);
</pre><p>
                        For another example, use this query:
                    </p><p style="color:blue;">例如，使用以下查询：</p><pre data-lang="sql" class="programlisting">SELECT (SELECT column1 + 5 FROM t1) FROM t2;
</pre><p>
                        Instead of this query:
                    </p><p style="color:blue;">而不是此查询：</p><pre data-lang="sql" class="programlisting">SELECT (SELECT column1 FROM t1) + 5 FROM t2;
</pre></li><li class="listitem"><p>
                        Use a row subquery instead of a correlated subquery. For
                        example, use this query:
                    </p><p style="color:blue;">使用行子查询而不是相关子查询。例如，使用此查询：</p><pre data-lang="sql" class="programlisting">SELECT * FROM t1
  WHERE (column1,column2) IN (SELECT column1,column2 FROM t2);
</pre><p>
                        Instead of this query:
                    </p><p style="color:blue;">而不是此查询：</p><pre data-lang="sql" class="programlisting">SELECT * FROM t1
  WHERE EXISTS (SELECT * FROM t2 WHERE t2.column1=t1.column1
                AND t2.column2=t1.column2);
</pre></li><li class="listitem"><p>
                        Use <code class="literal">NOT (a = ANY (...))</code> rather than
                        <code class="literal">a &lt;&gt; ALL (...)</code>.
                    </p><p style="color:blue;">不要使用（a=any（…））而不要使用a&lt;&gt;all（…）。</p></li><li class="listitem"><p>
                        Use <code class="literal">x = ANY (<em class="replaceable"><code>table containing
                        (1,2)</code></em>)</code> rather than <code class="literal">x=1 OR
                        x=2</code>.
                    </p><p style="color:blue;">使用x=any（包含（1,2）的表），而不是x=1或x=2。</p></li><li class="listitem"><p>
                        Use <code class="literal">= ANY</code> rather than
                        <code class="literal">EXISTS</code>.
                    </p><p style="color:blue;">使用=任何而不是存在。</p></li><li class="listitem"><p>
                        For uncorrelated subqueries that always return one row,
                        <code class="literal">IN</code> is always slower than
                        <code class="literal">=</code>. For example, use this query:
                    </p><p style="color:blue;">对于总是返回一行的不相关子查询，in总是慢于=。例如，使用此查询：</p><pre data-lang="sql" class="programlisting">SELECT * FROM t1
  WHERE t1.<em class="replaceable"><code>col_name</code></em> = (SELECT a FROM t2 WHERE b = <em class="replaceable"><code>some_const</code></em>);
</pre><p>
                        Instead of this query:
                    </p><p style="color:blue;">而不是此查询：</p><pre data-lang="sql" class="programlisting">SELECT * FROM t1
  WHERE t1.<em class="replaceable"><code>col_name</code></em> IN (SELECT a FROM t2 WHERE b = <em class="replaceable"><code>some_const</code></em>);
</pre></li></ul>
                </div>
                <p>
                    These tricks might cause programs to go faster or slower. Using
                    MySQL facilities like the
                    <a class="link" href="functions.html#function_benchmark"><code class="literal">BENCHMARK()</code></a> function, you can get
                    an idea about what helps in your own situation. See
                    <a class="xref" href="functions.html#information-functions" title="12.15&nbsp;Information Functions">Section&nbsp;12.15, “Information Functions”</a>.
                </p><p style="color:blue;">这些技巧可能会导致程序运行得更快或更慢。使用诸如benchmark（）函数之类的mysql工具，您可以了解在您自己的情况下有什么帮助。见第12.15节“信息功能”。</p><p>
                Some optimizations that MySQL itself makes are:
            </p><p style="color:blue;">mysql本身进行的一些优化包括：</p>
                <div class="itemizedlist">
                    <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                        MySQL executes uncorrelated subqueries only once. Use
                        <a class="link" href="sql-syntax.html#explain" title="13.8.2&nbsp;EXPLAIN Syntax"><code class="literal">EXPLAIN</code></a> to make sure that a
                        given subquery really is uncorrelated.
                    </p><p style="color:blue;">mysql只执行一次不相关的子查询。使用explain确保给定的子查询确实不相关。</p></li><li class="listitem"><p>
                        MySQL rewrites <code class="literal">IN</code>,
                        <code class="literal">ALL</code>, <code class="literal">ANY</code>, and
                        <code class="literal">SOME</code> subqueries in an attempt to take
                        advantage of the possibility that the select-list columns in
                        the subquery are indexed.
                    </p><p style="color:blue;">mysql重写了、all、any和一些子查询，试图利用子查询中的select列表列被编入索引的可能性。</p></li><li class="listitem"><p>
                        MySQL replaces subqueries of the following form with an
                        index-lookup function, which
                        <a class="link" href="sql-syntax.html#explain" title="13.8.2&nbsp;EXPLAIN Syntax"><code class="literal">EXPLAIN</code></a> describes as a
                        special join type
                        (<a class="link" href="optimization.html#jointype_unique_subquery"><code class="literal">unique_subquery</code></a> or
                        <a class="link" href="optimization.html#jointype_index_subquery"><code class="literal">index_subquery</code></a>):
                    </p><p style="color:blue;">mysql用一个索引查找函数替换以下形式的子查询，该函数解释为一种特殊的连接类型（unique_subquery或index_subquery）：</p><pre data-lang="sql" class="programlisting">... IN (SELECT <em class="replaceable"><code>indexed_column</code></em> FROM <em class="replaceable"><code>single_table</code></em> ...)
</pre></li><li class="listitem"><p>
                        MySQL enhances expressions of the following form with an
                        expression involving <a class="link" href="functions.html#function_min"><code class="literal">MIN()</code></a> or
                        <a class="link" href="functions.html#function_max"><code class="literal">MAX()</code></a>, unless
                        <code class="literal">NULL</code> values or empty sets are involved:
                    </p><p style="color:blue;">MySQL使用包含min（）或max（）的表达式增强以下形式的表达式，除非涉及空值或空集：</p><pre data-lang="sql" class="programlisting"><em class="replaceable"><code>value</code></em> {ALL|ANY|SOME} {&gt; | &lt; | &gt;= | &lt;=} (<em class="replaceable"><code>uncorrelated subquery</code></em>)
</pre><p>
                        For example, this <code class="literal">WHERE</code> clause:
                    </p><p style="color:blue;">例如，此where子句：</p><pre data-lang="sql" class="programlisting">WHERE 5 &gt; ALL (SELECT x FROM t)
</pre><p>
                        might be treated by the optimizer like this:
                    </p><p style="color:blue;">优化器可能会这样处理：</p><pre data-lang="sql" class="programlisting">WHERE 5 &gt; (SELECT MAX(x) FROM t)
</pre></li></ul>
                </div>
                <p>
                    See also
                    <a class="ulink" href="https://dev.mysql.com/doc/internals/en/transformations.html" target="_top">MySQL
                        Internals: How MySQL Transforms Subqueries</a>.
                </p><p style="color:blue;">另请参见mysql内部：mysql如何转换子查询。</p>
            </div>
            <div class="section">
                <div class="titlepage">
                    <div>
                        <div>
                            <h4 class="title"><a name="rewriting-subqueries"></a>13.2.10.11&nbsp;Rewriting Subqueries as Joins</h4>

                        </div>

                    </div>

                </div>
                <a class="indexterm" name="idm140286833752016"></a><p>
                Sometimes there are other ways to test membership in a set of
                values than by using a subquery. Also, on some occasions, it is
                not only possible to rewrite a query without a subquery, but it
                can be more efficient to make use of some of these techniques
                rather than to use subqueries. One of these is the
                <code class="literal">IN()</code> construct:
            </p><p style="color:blue;">有时，除了使用子查询之外，还有其他方法来测试一组值中的成员身份。此外，在某些情况下，不仅可以在不使用子查询的情况下重写查询，而且可以更有效地使用其中的一些技术，而不是使用子查询。其中之一是in（）构造：</p><p>
                For example, this query:
            </p><p style="color:blue;">例如，此查询：</p><pre data-lang="sql" class="programlisting">SELECT * FROM t1 WHERE id IN (SELECT id FROM t2);
</pre><p>
                Can be rewritten as:
            </p><p style="color:blue;">可以重写为：</p><pre data-lang="sql" class="programlisting">SELECT DISTINCT t1.* FROM t1, t2 WHERE t1.id=t2.id;
</pre><p>
                The queries:
            </p><p style="color:blue;">询问：</p><pre data-lang="sql" class="programlisting">SELECT * FROM t1 WHERE id NOT IN (SELECT id FROM t2);
SELECT * FROM t1 WHERE NOT EXISTS (SELECT id FROM t2 WHERE t1.id=t2.id);
</pre><p>
                Can be rewritten as:
            </p><p style="color:blue;">可以重写为：</p><pre data-lang="sql" class="programlisting">SELECT table1.*
  FROM table1 LEFT JOIN table2 ON table1.id=table2.id
  WHERE table2.id IS NULL;
</pre><p>
                A <code class="literal">LEFT [OUTER] JOIN</code> can be faster than an
                equivalent subquery because the server might be able to optimize
                it better—a fact that is not specific to MySQL Server
                alone. Prior to SQL-92, outer joins did not exist, so subqueries
                were the only way to do certain things. Today, MySQL Server and
                many other modern database systems offer a wide range of outer
                join types.
            </p><p style="color:blue;">左[外]连接可能比等价的子查询更快，因为服务器可能能够更好地优化它—这不是mysql服务器独有的事实。在SQL -92之前，外部连接不存在，因此子查询是完成某些事情的唯一途径。今天，mysql服务器和许多其他现代数据库系统提供了广泛的外部连接类型。</p><p>
                MySQL Server supports multiple-table
                <a class="link" href="sql-syntax.html#delete" title="13.2.2&nbsp;DELETE Syntax"><code class="literal">DELETE</code></a> statements that can be
                used to efficiently delete rows based on information from one
                table or even from many tables at the same time. Multiple-table
                <a class="link" href="sql-syntax.html#update" title="13.2.11&nbsp;UPDATE Syntax"><code class="literal">UPDATE</code></a> statements are also
                supported. See <a class="xref" href="sql-syntax.html#delete" title="13.2.2&nbsp;DELETE Syntax">Section&nbsp;13.2.2, “DELETE Syntax”</a>, and
                <a class="xref" href="sql-syntax.html#update" title="13.2.11&nbsp;UPDATE Syntax">Section&nbsp;13.2.11, “UPDATE Syntax”</a>.
            </p><p style="color:blue;">mysql服务器支持多个表删除语句，这些语句可以根据一个表中的信息，甚至同时从多个表中有效地删除行。还支持多个表更新语句。参见第13.2.2节“删除语法”和第13.2.11节“更新语法”。</p>
            </div>

            <div class="section">

                <div class="titlepage">
                    <div>
                        <div>
                            <h4 class="title"><a name="subquery-restrictions"></a>13.2.10.12&nbsp;Restrictions on Subqueries</h4>

                        </div>

                    </div>

                </div>
                <a class="indexterm" name="idm140286833735728"></a><a class="indexterm" name="idm140286833734272"></a>
                <div class="itemizedlist">
                    <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                        In general, you cannot modify a table and select from the
                        same table in a subquery. For example, this limitation
                        applies to statements of the following forms:
                    </p><p style="color:blue;">通常，不能修改表并从子查询中的同一表中进行选择。例如，这一限制适用于下列形式的陈述：</p><pre data-lang="sql" class="programlisting">DELETE FROM t WHERE ... (SELECT ... FROM t ...);
UPDATE t ... WHERE col = (SELECT ... FROM t ...);
{INSERT|REPLACE} INTO t (SELECT ... FROM t ...);
</pre><p>
                        Exception: The preceding prohibition does not apply if for
                        the modified table you are using a derived table and that
                        derived table is materialized rather than merged into the
                        outer query. (See
                        <a class="xref" href="optimization.html#derived-table-optimization" title="8.2.2.4&nbsp;Optimizing Derived Tables and View References with Merging or Materialization">Section&nbsp;8.2.2.4, “Optimizing Derived Tables and View References with Merging or
                            Materialization”</a>.) Example:
                    </p><p style="color:blue;">异常：如果您使用的是派生表，并且该派生表是具体化的，而不是合并到外部查询中，则上述禁止不适用。（参见第8.2.2.4节，“使用合并或物化优化派生表和视图引用”。）示例：</p><pre data-lang="sql" class="programlisting">UPDATE t ... WHERE col = (SELECT * FROM (SELECT ... FROM t...) AS dt ...);
</pre><p>
                        Here the result from the derived table is materialized as a
                        temporary table, so the relevant rows in
                        <code class="literal">t</code> have already been selected by the time
                        the update to <code class="literal">t</code> takes place.
                    </p><p style="color:blue;">在这里，派生表的结果被具体化为一个临时表，因此t中的相关行在t更新时已经被选中。</p></li><li class="listitem"><p>
                        Row comparison operations are only partially supported:
                    </p><p style="color:blue;">仅部分支持行比较操作：</p>
                        <div class="itemizedlist">
                            <ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
                                For <code class="literal"><em class="replaceable"><code>expr</code></em> [NOT] IN
                                <em class="replaceable"><code>subquery</code></em></code>,
                                <em class="replaceable"><code>expr</code></em> can be an
                                <em class="replaceable"><code>n</code></em>-tuple (specified using row
                                constructor syntax) and the subquery can return rows of
                                <em class="replaceable"><code>n</code></em>-tuples. The permitted
                                syntax is therefore more specifically expressed as
                                <code class="literal"><em class="replaceable"><code>row_constructor</code></em>
                                    [NOT] IN
                                    <em class="replaceable"><code>table_subquery</code></em></code>
                            </p><p style="color:blue;">对于子查询中的expr[not]，expr可以是n元组（使用行构造函数语法指定），子查询可以返回n元组的行。因此，允许的语法在table_子查询中更具体地表示为row_constructor[非]</p></li><li class="listitem"><p>
                                For <code class="literal"><em class="replaceable"><code>expr</code></em>
                                <em class="replaceable"><code>op</code></em> {ALL|ANY|SOME}
                                <em class="replaceable"><code>subquery</code></em></code>,
                                <em class="replaceable"><code>expr</code></em> must be a scalar value
                                and the subquery must be a column subquery; it cannot
                                return multiple-column rows.
                            </p><p style="color:blue;">对于expr op{all any some}子查询，expr必须是标量值，子查询必须是列子查询；它不能返回多个列行。</p></li></ul>
                        </div>
                        <p>
                            In other words, for a subquery that returns rows of
                            <em class="replaceable"><code>n</code></em>-tuples, this is supported:
                        </p><p style="color:blue;">换句话说，对于返回n元组行的子查询，支持：</p><pre data-lang="sql" class="programlisting">(<em class="replaceable"><code>expr_1</code></em>, ..., <em class="replaceable"><code>expr_n</code></em>) [NOT] IN <em class="replaceable"><code>table_subquery</code></em>
</pre><p>
                            But this is not supported:
                        </p><p style="color:blue;">但这是不受支持的：</p><pre data-lang="sql" class="programlisting">(<em class="replaceable"><code>expr_1</code></em>, ..., <em class="replaceable"><code>expr_n</code></em>) <em class="replaceable"><code>op</code></em> {ALL|ANY|SOME} <em class="replaceable"><code>subquery</code></em>
</pre><p>
                            The reason for supporting row comparisons for
                            <code class="literal">IN</code> but not for the others is that
                            <code class="literal">IN</code> is implemented by rewriting it as a
                            sequence of <a class="link" href="functions.html#operator_equal"><code class="literal">=</code></a>
                            comparisons and <a class="link" href="functions.html#operator_and"><code class="literal">AND</code></a> operations.
                            This approach cannot be used for <code class="literal">ALL</code>,
                            <code class="literal">ANY</code>, or <code class="literal">SOME</code>.
                        </p><p style="color:blue;">支持in的行比较而不支持其他行比较的原因是，in是通过将其重写为一个=comparison and and操作序列来实现的。这种方法不能用于所有人、任何人或某些人。</p></li><li class="listitem"><p>
                        Subqueries in the <code class="literal">FROM</code> clause cannot be
                        correlated subqueries. They are materialized in whole
                        (evaluated to produce a result set) during query execution,
                        so they cannot be evaluated per row of the outer query. The
                        optimizer delays materialization until the result is needed,
                        which may permit materialization to be avoided. See
                        <a class="xref" href="optimization.html#derived-table-optimization" title="8.2.2.4&nbsp;Optimizing Derived Tables and View References with Merging or Materialization">Section&nbsp;8.2.2.4, “Optimizing Derived Tables and View References with Merging or
                            Materialization”</a>.
                    </p><p style="color:blue;">FROM子句中的子查询不能是关联的子查询。在查询执行期间，它们被整体物化（计算以生成结果集），因此不能对外部查询的每一行进行计算。优化器将物化延迟到需要结果时，这可能会避免物化。参见第8.2.2.4节“使用合并或物化优化派生表和视图引用”。</p></li><li class="listitem"><p>
                        MySQL does not support <code class="literal">LIMIT</code> in
                        subqueries for certain subquery operators:
                    </p><p style="color:blue;">MySQL不支持某些子查询运算符的子查询限制：</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT * FROM t1</code></strong>
       <strong class="userinput"><code>WHERE s1 IN (SELECT s2 FROM t2 ORDER BY s1 LIMIT 1);</code></strong>
ERROR 1235 (42000): This version of MySQL doesn't yet support
 'LIMIT &amp; IN/ALL/ANY/SOME subquery'
</pre></li><li class="listitem"><p>
                        MySQL permits a subquery to refer to a stored function that
                        has data-modifying side effects such as inserting rows into
                        a table. For example, if <code class="literal">f()</code> inserts
                        rows, the following query can modify data:
                    </p><p style="color:blue;">mysql允许子查询引用具有数据修改副作用（如将行插入表中）的存储函数。例如，如果f（）插入行，则以下查询可以修改数据：</p><pre data-lang="sql" class="programlisting">SELECT ... WHERE x IN (SELECT f() ...);
</pre><p>
                        This behavior is an extension to the SQL standard. In MySQL,
                        it can produce nondeterministic results because
                        <code class="literal">f()</code> might be executed a different number
                        of times for different executions of a given query depending
                        on how the optimizer chooses to handle it.
                    </p><p style="color:blue;">此行为是SQL标准的扩展。在mysql中，它可以产生不确定的结果，因为对于给定查询的不同执行，f（）可能会被执行不同的次数，这取决于优化器选择如何处理它。</p><p>
                        For statement-based or mixed-format replication, one
                        implication of this indeterminism is that such a query can
                        produce different results on the master and its slaves.
                    </p><p style="color:blue;">对于基于语句或混合格式的复制，这种不确定性的一个含义是这样的查询可以在主服务器及其从服务器上产生不同的结果。</p></li></ul>
                </div>

            </div>

        </div>
        <div class="section">
            <div class="titlepage">
                <div>
                    <div>
                        <h3 class="title"><a name="update"></a>13.2.11&nbsp;UPDATE Syntax</h3>

                    </div>

                </div>

            </div>
            <a class="indexterm" name="idm140286833691376"></a><a class="indexterm" name="idm140286833690304"></a><p>
            <a class="link" href="sql-syntax.html#update" title="13.2.11&nbsp;UPDATE Syntax"><code class="literal">UPDATE</code></a> is a DML statement that
            modifies rows in a table.
        </p><p style="color:blue;">UPDATE是一个DML语句，用于修改表中的行。</p><p>
            Single-table syntax:
        </p><p style="color:blue;">单表语法：</p><pre data-lang="sql" class="programlisting">UPDATE [LOW_PRIORITY] [IGNORE] <em class="replaceable"><code>table_reference</code></em>
    SET <em class="replaceable"><code>assignment_list</code></em>
    [WHERE <em class="replaceable"><code>where_condition</code></em>]
    [ORDER BY ...]
    [LIMIT <em class="replaceable"><code>row_count</code></em>]

<em class="replaceable"><code>value</code></em>:
    {<em class="replaceable"><code>expr</code></em> | DEFAULT}

<em class="replaceable"><code>assignment</code></em>:
    <em class="replaceable"><code>col_name</code></em> = <em class="replaceable"><code>value</code></em>

<em class="replaceable"><code>assignment_list</code></em>:
    <em class="replaceable"><code>assignment</code></em> [, <em class="replaceable"><code>assignment</code></em>] ...
</pre><p>
            Multiple-table syntax:
        </p><p style="color:blue;">多表语法：</p><pre data-lang="sql" class="programlisting">UPDATE [LOW_PRIORITY] [IGNORE] <em class="replaceable"><code>table_references</code></em>
    SET <em class="replaceable"><code>assignment_list</code></em>
    [WHERE <em class="replaceable"><code>where_condition</code></em>]
</pre><p>
            For the single-table syntax, the
            <a class="link" href="sql-syntax.html#update" title="13.2.11&nbsp;UPDATE Syntax"><code class="literal">UPDATE</code></a> statement updates columns of
            existing rows in the named table with new values. The
            <code class="literal">SET</code> clause indicates which columns to modify
            and the values they should be given. Each value can be given as an
            expression, or the keyword <code class="literal">DEFAULT</code> to set a
            column explicitly to its default value. The
            <code class="literal">WHERE</code> clause, if given, specifies the
            conditions that identify which rows to update. With no
            <code class="literal">WHERE</code> clause, all rows are updated. If the
            <code class="literal">ORDER BY</code> clause is specified, the rows are
            updated in the order that is specified. The
            <code class="literal">LIMIT</code> clause places a limit on the number of
            rows that can be updated.
        </p><p style="color:blue;">对于单表语法，UPDATE语句用新值更新命名表中现有行的列。set子句指示要修改哪些列以及应给它们的值。每个值都可以作为表达式给定，或者使用关键字default将列显式设置为其默认值。where子句（如果给定）指定标识要更新哪些行的条件。如果没有where子句，则更新所有行。如果指定了ORDERBY子句，则按指定的顺序更新行。LIMIT子句对可以更新的行数进行限制。</p><p>
            For the multiple-table syntax,
            <a class="link" href="sql-syntax.html#update" title="13.2.11&nbsp;UPDATE Syntax"><code class="literal">UPDATE</code></a> updates rows in each table
            named in <em class="replaceable"><code>table_references</code></em> that satisfy
            the conditions. Each matching row is updated once, even if it
            matches the conditions multiple times. For multiple-table syntax,
            <code class="literal">ORDER BY</code> and <code class="literal">LIMIT</code> cannot be
            used.
        </p><p style="color:blue;">对于多表语法，update更新满足条件的表中名为in table_references的每个表中的行。每个匹配行只更新一次，即使它多次匹配条件。对于多表语法，不能使用ORDER BY和LIMIT。</p><p>
            For partitioned tables, both the single-single and multiple-table
            forms of this statement support the use of a
            <code class="literal">PARTITION</code> option as part of a table reference.
            This option takes a list of one or more partitions or
            subpartitions (or both). Only the partitions (or subpartitions)
            listed are checked for matches, and a row that is not in any of
            these partitions or subpartitions is not updated, whether it
            satisfies the <em class="replaceable"><code>where_condition</code></em> or not.
        </p><p style="color:blue;">对于分区表，此语句的单个单表和多表形式都支持使用分区选项作为表引用的一部分。此选项接受一个或多个分区或子分区（或两者）的列表。只检查列出的分区（或子分区）是否匹配，不在这些分区或子分区中的行不会更新，无论它是否满足where_条件。</p>
            <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">

                <div class="admon-title">
                    Note
                </div>
                <p>
                    Unlike the case when using <code class="literal">PARTITION</code> with an
                    <a class="link" href="sql-syntax.html#insert" title="13.2.5&nbsp;INSERT Syntax"><code class="literal">INSERT</code></a> or
                    <a class="link" href="sql-syntax.html#replace" title="13.2.8&nbsp;REPLACE Syntax"><code class="literal">REPLACE</code></a> statement, an otherwise
                    valid <code class="literal">UPDATE ... PARTITION</code> statement is
                    considered successful even if no rows in the listed partitions
                    (or subpartitions) match the
                    <em class="replaceable"><code>where_condition</code></em>.
                </p><p style="color:blue;">与使用INSERT或INSERT语句分区时的情况不同，其他有效的更新…分区语句被认为是成功的，即使列出的分区（或子分区）中没有行与NoTIAL条件匹配。</p>
            </div>
            <p>
                For more information and examples, see
                <a class="xref" href="partitioning.html#partitioning-selection" title="22.5&nbsp;Partition Selection">Section&nbsp;22.5, “Partition Selection”</a>.
            </p><p style="color:blue;">有关更多信息和示例，请参见第22.5节“分区选择”。</p><p>
            <em class="replaceable"><code>where_condition</code></em> is an expression that
            evaluates to true for each row to be updated. For expression
            syntax, see <a class="xref" href="language-structure.html#expressions" title="9.5&nbsp;Expressions">Section&nbsp;9.5, “Expressions”</a>.
        </p><p style="color:blue;">其中，条件是对要更新的每一行求值为true的表达式。有关表达式语法，请参见第9.5节“表达式”。</p><p>
            <em class="replaceable"><code>table_references</code></em> and
            <em class="replaceable"><code>where_condition</code></em> are specified as
            described in <a class="xref" href="sql-syntax.html#select" title="13.2.9&nbsp;SELECT Syntax">Section&nbsp;13.2.9, “SELECT Syntax”</a>.
        </p><p style="color:blue;">表_references和where _condition如13.2.9节“选择语法”所述指定。</p><p>
            You need the <a class="link" href="security.html#priv_update"><code class="literal">UPDATE</code></a> privilege only
            for columns referenced in an <a class="link" href="sql-syntax.html#update" title="13.2.11&nbsp;UPDATE Syntax"><code class="literal">UPDATE</code></a>
            that are actually updated. You need only the
            <a class="link" href="security.html#priv_select"><code class="literal">SELECT</code></a> privilege for any columns
            that are read but not modified.
        </p><p style="color:blue;">您只需要在实际更新的更新中引用的列的更新权限。对于任何已读但未修改的列，您只需要select特权。</p><p>
            The <a class="link" href="sql-syntax.html#update" title="13.2.11&nbsp;UPDATE Syntax"><code class="literal">UPDATE</code></a> statement supports the
            following modifiers:
        </p><p style="color:blue;">update语句支持以下修饰符：</p>
            <div class="itemizedlist">
                <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                    With the <code class="literal">LOW_PRIORITY</code> modifier, execution
                    of the <a class="link" href="sql-syntax.html#update" title="13.2.11&nbsp;UPDATE Syntax"><code class="literal">UPDATE</code></a> is delayed until
                    no other clients are reading from the table. This affects only
                    storage engines that use only table-level locking (such as
                    <code class="literal">MyISAM</code>, <code class="literal">MEMORY</code>, and
                    <code class="literal">MERGE</code>).
                </p><p style="color:blue;">使用low_priority修饰符，更新的执行会延迟，直到没有其他客户机从表中读取数据。这只影响只使用表级锁定的存储引擎（例如myisam、内存和合并）。</p><a class="indexterm" name="idm140286833641376"></a></li><li class="listitem"><p>
                    With the <code class="literal">IGNORE</code> modifier, the update
                    statement does not abort even if errors occur during the
                    update. Rows for which duplicate-key conflicts occur on a
                    unique key value are not updated. Rows updated to values that
                    would cause data conversion errors are updated to the closest
                    valid values instead. For more information, see
                    <a class="xref" href="server-administration.html#ignore-strict-comparison" title="Comparison of the IGNORE Keyword and Strict SQL Mode">Comparison of the IGNORE Keyword and Strict SQL Mode</a>.
                </p><p style="color:blue;">使用ignore修饰符，即使在更新期间发生错误，update语句也不会中止。在唯一键值上发生重复键值冲突的行不会更新。更新为可能导致数据转换错误的值的行将更新为最接近的有效值。有关详细信息，请参阅ignore关键字和strict sql模式的比较。</p><a class="indexterm" name="idm140286833637264"></a></li></ul>
            </div>
            <p>
                <a class="link" href="sql-syntax.html#update" title="13.2.11&nbsp;UPDATE Syntax"><code class="literal">UPDATE IGNORE</code></a>
                statements, including those having an <code class="literal">ORDER BY</code>
                clause, are flagged as unsafe for statement-based replication.
                (This is because the order in which the rows are updated
                determines which rows are ignored.) Such statements produce a
                warning in the error log when using statement-based mode and are
                written to the binary log using the row-based format when using
                <code class="literal">MIXED</code> mode. (Bug #11758262, Bug #50439) See
                <a class="xref" href="replication.html#replication-rbr-safe-unsafe" title="16.2.1.3&nbsp;Determination of Safe and Unsafe Statements in Binary Logging">Section&nbsp;16.2.1.3, “Determination of Safe and Unsafe Statements in Binary Logging”</a>, for more
                information.
            </p><p style="color:blue;">对于基于语句的复制，update ignore语句（包括具有order by子句的语句）被标记为不安全。（这是因为行的更新顺序决定了忽略哪些行。）使用基于语句的模式时，此类语句在错误日志中生成警告，使用混合模式时，则使用基于行的格式写入二进制日志。（bug 11758262，bug 50439）有关详细信息，请参阅第16.2.1.3节“二进制日志中安全和不安全语句的确定”。</p><p>
            If you access a column from the table to be updated in an
            expression, <a class="link" href="sql-syntax.html#update" title="13.2.11&nbsp;UPDATE Syntax"><code class="literal">UPDATE</code></a> uses the current
            value of the column. For example, the following statement sets
            <code class="literal">col1</code> to one more than its current value:
        </p><p style="color:blue;">如果访问要在表达式中更新的表中的列，则update将使用该列的当前值。例如，以下语句将col1设置为比其当前值多一个：</p><pre data-lang="sql" class="programlisting">UPDATE t1 SET col1 = col1 + 1;
</pre><p>
            The second assignment in the following statement sets
            <code class="literal">col2</code> to the current (updated)
            <code class="literal">col1</code> value, not the original
            <code class="literal">col1</code> value. The result is that
            <code class="literal">col1</code> and <code class="literal">col2</code> have the same
            value. This behavior differs from standard SQL.
        </p><p style="color:blue;">下面语句中的第二个赋值将col2设置为当前（更新的）col1值，而不是原始col1值。结果是col1和col2具有相同的值。此行为与标准SQL不同。</p><pre data-lang="sql" class="programlisting">UPDATE t1 SET col1 = col1 + 1, col2 = col1;
</pre><p>
            Single-table <a class="link" href="sql-syntax.html#update" title="13.2.11&nbsp;UPDATE Syntax"><code class="literal">UPDATE</code></a> assignments are
            generally evaluated from left to right. For multiple-table
            updates, there is no guarantee that assignments are carried out in
            any particular order.
        </p><p style="color:blue;">单表更新分配通常从左到右进行计算。对于多个表更新，不能保证以任何特定顺序执行分配。</p><p>
            If you set a column to the value it currently has, MySQL notices
            this and does not update it.
        </p><p style="color:blue;">如果将列设置为当前的值，mysql会注意到这一点，不会更新它。</p><p>
            If you update a column that has been declared <code class="literal">NOT
            NULL</code> by setting to <code class="literal">NULL</code>, an error
            occurs if strict SQL mode is enabled; otherwise, the column is set
            to the implicit default value for the column data type and the
            warning count is incremented. The implicit default value is
            <code class="literal">0</code> for numeric types, the empty string
            (<code class="literal">''</code>) for string types, and the
            <span class="quote">“<span class="quote">zero</span>”</span> value for date and time types. See
            <a class="xref" href="data-types.html#data-type-defaults" title="11.7&nbsp;Data Type Default Values">Section&nbsp;11.7, “Data Type Default Values”</a>.
        </p><p style="color:blue;">如果更新通过设置为空而声明为不为空的列，则如果启用了严格SQL模式，则会发生错误；否则，该列将设置为列数据类型的隐式默认值，并且警告计数将递增。对于数值类型，隐式默认值为0；对于字符串类型，隐式默认值为空字符串（''）；对于日期和时间类型，隐式默认值为“0”。见第11.7节“数据类型默认值”。</p><a class="indexterm" name="idm140286833615040"></a><p>
            If a generated column is updated explicitly, the only permitted
            value is <code class="literal">DEFAULT</code>. For information about
            generated columns, see
            <a class="xref" href="sql-syntax.html#create-table-generated-columns" title="13.1.18.8&nbsp;CREATE TABLE and Generated Columns">Section&nbsp;13.1.18.8, “CREATE TABLE and Generated Columns”</a>.
        </p><p style="color:blue;">如果显式更新生成的列，则唯一允许的值为默认值。有关生成列的信息，请参见第13.1.18.8节“创建表和生成列”。</p><a class="indexterm" name="idm140286833611552"></a><p>
            <a class="link" href="sql-syntax.html#update" title="13.2.11&nbsp;UPDATE Syntax"><code class="literal">UPDATE</code></a> returns the number of rows
            that were actually changed. The
            <a class="link" href="connectors-apis.html#mysql-info" title="27.8.7.36&nbsp;mysql_info()"><code class="literal">mysql_info()</code></a> C API function
            returns the number of rows that were matched and updated and the
            number of warnings that occurred during the
            <a class="link" href="sql-syntax.html#update" title="13.2.11&nbsp;UPDATE Syntax"><code class="literal">UPDATE</code></a>.
        </p><p style="color:blue;">update返回实际更改的行数。mysql_info（）c api函数返回匹配和更新的行数以及更新期间出现的警告数。</p><p>
            You can use <code class="literal">LIMIT
            <em class="replaceable"><code>row_count</code></em></code> to restrict the
            scope of the <a class="link" href="sql-syntax.html#update" title="13.2.11&nbsp;UPDATE Syntax"><code class="literal">UPDATE</code></a>. A
            <code class="literal">LIMIT</code> clause is a rows-matched restriction. The
            statement stops as soon as it has found
            <em class="replaceable"><code>row_count</code></em> rows that satisfy the
            <code class="literal">WHERE</code> clause, whether or not they actually were
            changed.
        </p><p style="color:blue;">您可以使用限制行计数来限制更新的范围。LIMIT子句是行匹配限制。语句在找到满足where子句的行计数行后立即停止，无论这些行是否已实际更改。</p><p>
            If an <a class="link" href="sql-syntax.html#update" title="13.2.11&nbsp;UPDATE Syntax"><code class="literal">UPDATE</code></a> statement includes an
            <code class="literal">ORDER BY</code> clause, the rows are updated in the
            order specified by the clause. This can be useful in certain
            situations that might otherwise result in an error. Suppose that a
            table <code class="literal">t</code> contains a column <code class="literal">id</code>
            that has a unique index. The following statement could fail with a
            duplicate-key error, depending on the order in which rows are
            updated:
        </p><p style="color:blue;">如果UPDATE语句包含ORDER BY子句，则按该子句指定的顺序更新行。这在某些可能导致错误的情况下非常有用。假设表t包含具有唯一索引的列id。根据行的更新顺序，以下语句可能会因重复键错误而失败：</p><pre data-lang="sql" class="programlisting">UPDATE t SET id = id + 1;
</pre><p>
            For example, if the table contains 1 and 2 in the
            <code class="literal">id</code> column and 1 is updated to 2 before 2 is
            updated to 3, an error occurs. To avoid this problem, add an
            <code class="literal">ORDER BY</code> clause to cause the rows with larger
            <code class="literal">id</code> values to be updated before those with
            smaller values:
        </p><p style="color:blue;">例如，如果表在id列中包含1和2，并且1在2更新为3之前更新为2，则会发生错误。要避免此问题，请添加ORDER BY子句，使具有较大ID值的行在具有较小ID值的行之前更新：</p><pre data-lang="sql" class="programlisting">UPDATE t SET id = id + 1 ORDER BY id DESC;
</pre><p>
            You can also perform <a class="link" href="sql-syntax.html#update" title="13.2.11&nbsp;UPDATE Syntax"><code class="literal">UPDATE</code></a>
            operations covering multiple tables. However, you cannot use
            <code class="literal">ORDER BY</code> or <code class="literal">LIMIT</code> with a
            multiple-table <a class="link" href="sql-syntax.html#update" title="13.2.11&nbsp;UPDATE Syntax"><code class="literal">UPDATE</code></a>. The
            <em class="replaceable"><code>table_references</code></em> clause lists the
            tables involved in the join. Its syntax is described in
            <a class="xref" href="sql-syntax.html#join" title="13.2.9.2&nbsp;JOIN Syntax">Section&nbsp;13.2.9.2, “JOIN Syntax”</a>. Here is an example:
        </p><p style="color:blue;">您还可以执行覆盖多个表的更新操作。但是，不能对多表更新使用ORDER BY或LIMIT。table_references子句列出连接中涉及的表。其语法在第13.2.9.2节“连接语法”中进行了描述。下面是一个例子：</p><pre data-lang="sql" class="programlisting">UPDATE items,month SET items.price=month.price
WHERE items.id=month.id;
</pre><p>
            The preceding example shows an inner join that uses the comma
            operator, but multiple-table <a class="link" href="sql-syntax.html#update" title="13.2.11&nbsp;UPDATE Syntax"><code class="literal">UPDATE</code></a>
            statements can use any type of join permitted in
            <a class="link" href="sql-syntax.html#select" title="13.2.9&nbsp;SELECT Syntax"><code class="literal">SELECT</code></a> statements, such as
            <code class="literal">LEFT JOIN</code>.
        </p><p style="color:blue;">前面的示例显示了使用逗号运算符的内部联接，但是多个表更新语句可以使用select语句中允许的任何类型的联接，例如左联接。</p><p>
            If you use a multiple-table <a class="link" href="sql-syntax.html#update" title="13.2.11&nbsp;UPDATE Syntax"><code class="literal">UPDATE</code></a>
            statement involving <code class="literal">InnoDB</code> tables for which
            there are foreign key constraints, the MySQL optimizer might
            process tables in an order that differs from that of their
            parent/child relationship. In this case, the statement fails and
            rolls back. Instead, update a single table and rely on the
            <code class="literal">ON UPDATE</code> capabilities that
            <code class="literal">InnoDB</code> provides to cause the other tables to be
            modified accordingly. See
            <a class="xref" href="innodb-storage-engine.html#innodb-foreign-key-constraints" title="14.6.1.5&nbsp;InnoDB and FOREIGN KEY Constraints">Section&nbsp;14.6.1.5, “InnoDB and FOREIGN KEY Constraints”</a>.
        </p><p style="color:blue;">如果使用包含innodb表的多表update语句，其中有外键约束，那么mysql优化器可能会按照与父/子关系不同的顺序处理表。在这种情况下，语句失败并回滚。相反，更新一个表并依赖于innodb提供的on-update功能来相应地修改其他表。见第14.6.1.5节，“InnoDB和外键约束”。</p><p>
            You cannot update a table and select from the same table in a
            subquery.
        </p><p style="color:blue;">不能更新表并从子查询中的同一表中进行选择。</p><p>
            An <code class="literal">UPDATE</code> on a partitioned table using a
            storage engine such as <a class="link" href="storage-engines.html#myisam-storage-engine" title="15.2&nbsp;The MyISAM Storage Engine"><code class="literal">MyISAM</code></a> that
            employs table-level locks locks only those partitions containing
            rows that match the <code class="literal">UPDATE</code> statement
            <code class="literal">WHERE</code> clause, as long as none of the table
            partitioning columns are updated. (For storage engines such as
            <a class="link" href="innodb-storage-engine.html" title="Chapter&nbsp;14&nbsp;The InnoDB Storage Engine"><code class="literal">InnoDB</code></a> that employ row-level locking,
            no locking of partitions takes place.) For more information, see
            <a class="xref" href="partitioning.html#partitioning-limitations-locking" title="22.6.4&nbsp;Partitioning and Locking">Section&nbsp;22.6.4, “Partitioning and Locking”</a>.
        </p><p style="color:blue;">使用存储引擎（如使用表级锁的myisam）对分区表进行更新时，只要没有更新表分区列，只锁定包含与update语句where子句匹配的行的分区。（对于使用行级锁定的存储引擎，如innodb，不会发生分区锁定。）有关更多信息，请参阅第22.6.4节“分区和锁定”。</p>
        </div>

    </div>
    <div class="section">
        <div class="titlepage">
            <div>
                <div>
                    <h2 class="title" style="clear: both"><a name="sql-syntax-transactions"></a>13.3&nbsp;Transactional and Locking Statements</h2>

                </div>

            </div>

        </div>
        <div class="toc">
            <dl class="toc"><dt><span class="section"><a href="sql-syntax.html#commit">13.3.1 START TRANSACTION, COMMIT, and ROLLBACK Syntax</a></span></dt><dt><span class="section"><a href="sql-syntax.html#cannot-roll-back">13.3.2 Statements That Cannot Be Rolled Back</a></span></dt><dt><span class="section"><a href="sql-syntax.html#implicit-commit">13.3.3 Statements That Cause an Implicit Commit</a></span></dt><dt><span class="section"><a href="sql-syntax.html#savepoint">13.3.4 SAVEPOINT, ROLLBACK TO SAVEPOINT, and RELEASE SAVEPOINT Syntax</a></span></dt><dt><span class="section"><a href="sql-syntax.html#lock-tables">13.3.5 LOCK TABLES and UNLOCK TABLES Syntax</a></span></dt><dt><span class="section"><a href="sql-syntax.html#set-transaction">13.3.6 SET TRANSACTION Syntax</a></span></dt><dt><span class="section"><a href="sql-syntax.html#xa">13.3.7 XA Transactions</a></span></dt></dl>
        </div>
        <p>
            MySQL supports local transactions (within a given client session)
            through statements such as
            <a class="link" href="sql-syntax.html#commit" title="13.3.1&nbsp;START TRANSACTION, COMMIT, and ROLLBACK Syntax"><code class="literal">SET autocommit</code></a>,
            <a class="link" href="sql-syntax.html#commit" title="13.3.1&nbsp;START TRANSACTION, COMMIT, and ROLLBACK Syntax"><code class="literal">START TRANSACTION</code></a>,
            <a class="link" href="sql-syntax.html#commit" title="13.3.1&nbsp;START TRANSACTION, COMMIT, and ROLLBACK Syntax"><code class="literal">COMMIT</code></a>, and
            <a class="link" href="sql-syntax.html#commit" title="13.3.1&nbsp;START TRANSACTION, COMMIT, and ROLLBACK Syntax"><code class="literal">ROLLBACK</code></a>. See
            <a class="xref" href="sql-syntax.html#commit" title="13.3.1&nbsp;START TRANSACTION, COMMIT, and ROLLBACK Syntax">Section&nbsp;13.3.1, “START TRANSACTION, COMMIT, and ROLLBACK Syntax”</a>. XA transaction support enables MySQL to
            participate in distributed transactions as well. See
            <a class="xref" href="sql-syntax.html#xa" title="13.3.7&nbsp;XA Transactions">Section&nbsp;13.3.7, “XA Transactions”</a>.
        </p><p style="color:blue;">mysql通过set autocommit、start transaction、commit和rollback等语句支持本地事务（在给定的客户端会话中）。参见第13.3.1节“启动事务、提交和回滚语法”。xa事务支持也使mysql能够参与分布式事务。见第13.3.7节“XA交易”。</p>
        <div class="section">

            <div class="titlepage">
                <div>
                    <div>
                        <h3 class="title"><a name="commit"></a>13.3.1&nbsp;START TRANSACTION, COMMIT, and ROLLBACK Syntax</h3>
                    </div>
                </div>
            </div>
            <a class="indexterm" name="idm140286833560784"></a><a class="indexterm" name="idm140286833559744"></a><a class="indexterm" name="idm140286833558672"></a><a class="indexterm" name="idm140286833557600"></a><pre data-lang="sql" class="programlisting">START TRANSACTION
    [<em class="replaceable"><code>transaction_characteristic</code></em> [, <em class="replaceable"><code>transaction_characteristic</code></em>] ...]

<em class="replaceable"><code>transaction_characteristic</code></em>: {
    WITH CONSISTENT SNAPSHOT
  | READ WRITE
  | READ ONLY
}

BEGIN [WORK]
COMMIT [WORK] [AND [NO] CHAIN] [[NO] RELEASE]
ROLLBACK [WORK] [AND [NO] CHAIN] [[NO] RELEASE]
SET autocommit = {0 | 1}
</pre><p>
            These statements provide control over use of
            <a class="link" href="glossary.html#glos_transaction" title="transaction">transactions</a>:
        </p><p style="color:blue;">这些报表提供了对交易使用的控制：</p>
            <div class="itemizedlist">
                <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                    <code class="literal">START TRANSACTION</code> or
                    <code class="literal">BEGIN</code> start a new transaction.
                </p><p style="color:blue;">启动事务或开始启动新事务。</p></li><li class="listitem"><p>
                    <code class="literal">COMMIT</code> commits the current transaction,
                    making its changes permanent.
                </p><p style="color:blue;">提交提交当前事务，使其更改永久。</p></li><li class="listitem"><p>
                    <code class="literal">ROLLBACK</code> rolls back the current
                    transaction, canceling its changes.
                </p><p style="color:blue;">回滚回滚当前事务，取消其更改。</p></li><li class="listitem"><p>
                    <code class="literal">SET autocommit</code> disables or enables the
                    default autocommit mode for the current session.
                </p><p style="color:blue;">set autocommit禁用或启用当前会话的默认自动提交模式。</p></li></ul>
            </div>
            <p>
                By default, MySQL runs with
                <a class="link" href="glossary.html#glos_autocommit" title="autocommit">autocommit</a> mode enabled.
                This means that, when not otherwise inside a transaction, each
                statement is atomic, as if it were surrounded by <code class="literal">START
                TRANSACTION</code> and <code class="literal">COMMIT</code>. You cannot
                use <code class="literal">ROLLBACK</code> to undo the effect; however, if an
                error occurs during statement execution, the statement is rolled
                back.
            </p><p style="color:blue;">默认情况下，mysql运行时启用自动提交模式。这意味着，如果不是在事务内部，则每个语句都是原子的，就像它被start transaction和commit包围一样。不能使用rollback撤消该效果；但是，如果在语句执行期间发生错误，则会回滚该语句。</p><p>
            To disable autocommit mode implicitly for a single series of
            statements, use the <code class="literal">START TRANSACTION</code>
            statement:
        </p><p style="color:blue;">要隐式禁用单系列语句的自动提交模式，请使用start transaction语句：</p><pre data-lang="sql" class="programlisting">START TRANSACTION;
SELECT @A:=SUM(salary) FROM table1 WHERE type=1;
UPDATE table2 SET summary=@A WHERE type=1;
COMMIT;
</pre><p>
            With <code class="literal">START TRANSACTION</code>, autocommit remains
            disabled until you end the transaction with
            <code class="literal">COMMIT</code> or <code class="literal">ROLLBACK</code>. The
            autocommit mode then reverts to its previous state.
        </p><p style="color:blue;">使用start transaction，autocommit将保持禁用状态，直到使用commit或rollback结束事务。然后，自动提交模式将恢复到以前的状态。</p><p>
            <code class="literal">START TRANSACTION</code> permits several modifiers
            that control transaction characteristics. To specify multiple
            modifiers, separate them by commas.
        </p><p style="color:blue;">start transaction允许使用多个修饰符来控制事务特性。要指定多个修饰符，请用逗号分隔它们。</p>
            <div class="itemizedlist">
                <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                    The <code class="literal">WITH CONSISTENT SNAPSHOT</code> modifier
                    starts a <a class="link" href="glossary.html#glos_consistent_read" title="consistent read">consistent
                    read</a> for storage engines that are capable of it. This
                    applies only to <code class="literal">InnoDB</code>. The effect is the
                    same as issuing a <code class="literal">START TRANSACTION</code>
                    followed by a <a class="link" href="sql-syntax.html#select" title="13.2.9&nbsp;SELECT Syntax"><code class="literal">SELECT</code></a> from any
                    <code class="literal">InnoDB</code> table. See
                    <a class="xref" href="innodb-storage-engine.html#innodb-consistent-read" title="14.7.2.3&nbsp;Consistent Nonlocking Reads">Section&nbsp;14.7.2.3, “Consistent Nonlocking Reads”</a>. The <code class="literal">WITH
                    CONSISTENT SNAPSHOT</code> modifier does not change the
                    current transaction
                    <a class="link" href="glossary.html#glos_isolation_level" title="isolation level">isolation level</a>,
                    so it provides a consistent snapshot only if the current
                    isolation level is one that permits a consistent read. The
                    only isolation level that permits a consistent read is
                    <a class="link" href="innodb-storage-engine.html#isolevel_repeatable-read"><code class="literal">REPEATABLE READ</code></a>. For all
                    other isolation levels, the <code class="literal">WITH CONSISTENT
                    SNAPSHOT</code> clause is ignored. As of MySQL 5.7.2, a
                    warning is generated when the <code class="literal">WITH CONSISTENT
                    SNAPSHOT</code> clause is ignored.
                </p><p style="color:blue;">with consistent snapshot修饰符为能够执行此操作的存储引擎启动一致读取。这只适用于InnoDB。其效果与在任何innodb表中发出一个start事务，然后是一个select相同。见第14.7.2.3节，“一致非锁定读数”。with consistent snapshot修饰符不会更改当前事务隔离级别，因此仅当当前隔离级别允许一致读取时，它才提供一致的快照。唯一允许一致读取的隔离级别是可重复读取。对于所有其他隔离级别，将忽略WITH CONSTANCT SNAPSHOT子句。从mysql 5.7.2开始，当忽略with consistent snapshot子句时将生成警告。</p></li><li class="listitem"><p>
                    The <code class="literal">READ WRITE</code> and <code class="literal">READ
                    ONLY</code> modifiers set the transaction access mode. They
                    permit or prohibit changes to tables used in the transaction.
                    The <code class="literal">READ ONLY</code> restriction prevents the
                    transaction from modifying or locking both transactional and
                    nontransactional tables that are visible to other
                    transactions; the transaction can still modify or lock
                    temporary tables.
                </p><p style="color:blue;">读写和只读修饰符设置事务访问模式。它们允许或禁止更改事务中使用的表。只读限制防止事务修改或锁定其他事务可见的事务表和非事务表；事务仍然可以修改或锁定临时表。</p><p>
                    MySQL enables extra optimizations for queries on
                    <code class="literal">InnoDB</code> tables when the transaction is known
                    to be read-only. Specifying <code class="literal">READ ONLY</code>
                    ensures these optimizations are applied in cases where the
                    read-only status cannot be determined automatically. See
                    <a class="xref" href="optimization.html#innodb-performance-ro-txn" title="8.5.3&nbsp;Optimizing InnoDB Read-Only Transactions">Section&nbsp;8.5.3, “Optimizing InnoDB Read-Only Transactions”</a> for more
                    information.
                </p><p style="color:blue;">当事务已知为只读时，mysql可以对innodb表上的查询进行额外的优化。指定只读可确保在无法自动确定只读状态的情况下应用这些优化。有关更多信息，请参阅第8.5.3节“优化InnoDB只读事务”。</p><p>
                    If no access mode is specified, the default mode applies.
                    Unless the default has been changed, it is read/write. It is
                    not permitted to specify both <code class="literal">READ WRITE</code>
                    and <code class="literal">READ ONLY</code> in the same statement.
                </p><p style="color:blue;">如果未指定访问模式，则应用默认模式。除非已更改默认值，否则为读/写。不允许在同一语句中同时指定读写和只读。</p><p>
                    In read-only mode, it remains possible to change tables
                    created with the <code class="literal">TEMPORARY</code> keyword using
                    DML statements. Changes made with DDL statements are not
                    permitted, just as with permanent tables.
                </p><p style="color:blue;">在只读模式下，仍然可以使用DML语句更改使用临时关键字创建的表。与永久表一样，不允许使用DDL语句进行更改。</p><p>
                    For additional information about transaction access mode,
                    including ways to change the default mode, see
                    <a class="xref" href="sql-syntax.html#set-transaction" title="13.3.6&nbsp;SET TRANSACTION Syntax">Section&nbsp;13.3.6, “SET TRANSACTION Syntax”</a>.
                </p><p style="color:blue;">有关事务访问模式的其他信息，包括更改默认模式的方法，请参阅第13.3.6节“设置事务语法”。</p><p>
                    If the <a class="link" href="server-administration.html#sysvar_read_only"><code class="literal">read_only</code></a> system
                    variable is enabled, explicitly starting a transaction with
                    <code class="literal">START TRANSACTION READ WRITE</code> requires the
                    <a class="link" href="security.html#priv_super"><code class="literal">SUPER</code></a> privilege.
                </p><p style="color:blue;">如果启用了只读系统变量，则显式启动具有START TRANSACTION READ WRITE的事务需要超级权限。</p></li></ul>
            </div>
            <div class="important" style="margin-left: 0.5in; margin-right: 0.5in;">
                <div class="admon-title">
                    Important
                </div>
                <p>
                    Many APIs used for writing MySQL client applications (such as
                    JDBC) provide their own methods for starting transactions that
                    can (and sometimes should) be used instead of sending a
                    <code class="literal">START TRANSACTION</code> statement from the client.
                    See <a class="xref" href="connectors-apis.html" title="Chapter&nbsp;27&nbsp;Connectors and APIs">Chapter&nbsp;27, <i>Connectors and APIs</i></a>, or the documentation for
                    your API, for more information.
                </p><p style="color:blue;">许多用于编写mysql客户机应用程序（如jdbc）的api提供了自己的方法来启动事务，这些方法可以（有时应该）使用，而不是从客户机发送start transaction语句。有关更多信息，请参阅第27章，连接器和api或api文档。</p>
            </div>
            <p>
                To disable autocommit mode explicitly, use the following
                statement:
            </p><p style="color:blue;">要显式禁用自动提交模式，请使用以下语句：</p><pre data-lang="sql" class="programlisting">SET autocommit=0;
</pre><p>
            After disabling autocommit mode by setting the
            <a class="link" href="server-administration.html#sysvar_autocommit"><code class="literal">autocommit</code></a> variable to zero,
            changes to transaction-safe tables (such as those for
            <a class="link" href="innodb-storage-engine.html" title="Chapter&nbsp;14&nbsp;The InnoDB Storage Engine"><code class="literal">InnoDB</code></a> or
            <a class="link" href="mysql-cluster.html" title="Chapter&nbsp;21&nbsp;MySQL NDB Cluster 7.5 and NDB Cluster 7.6"><code class="literal">NDB</code></a>) are not made permanent
            immediately. You must use <a class="link" href="sql-syntax.html#commit" title="13.3.1&nbsp;START TRANSACTION, COMMIT, and ROLLBACK Syntax"><code class="literal">COMMIT</code></a> to
            store your changes to disk or <code class="literal">ROLLBACK</code> to
            ignore the changes.
        </p><p style="color:blue;">通过将autocommit变量设置为零来禁用autocommit模式后，对事务安全表（如对innodb或ndb的表）的更改不会立即永久化。必须使用commit将更改存储到磁盘，或使用rollback忽略更改。</p><p>
            <a class="link" href="server-administration.html#sysvar_autocommit"><code class="literal">autocommit</code></a> is a session variable
            and must be set for each session. To disable autocommit mode for
            each new connection, see the description of the
            <a class="link" href="server-administration.html#sysvar_autocommit"><code class="literal">autocommit</code></a> system variable at
            <a class="xref" href="server-administration.html#server-system-variables" title="5.1.7&nbsp;Server System Variables">Section&nbsp;5.1.7, “Server System Variables”</a>.
        </p><p style="color:blue;">autocommit是会话变量，必须为每个会话设置。要为每个新连接禁用autocommit模式，请参阅第5.1.7节“服务器系统变量”中autocommit系统变量的说明。</p><p>
            <code class="literal">BEGIN</code> and <code class="literal">BEGIN WORK</code> are
            supported as aliases of <code class="literal">START TRANSACTION</code> for
            initiating a transaction. <code class="literal">START TRANSACTION</code> is
            standard SQL syntax, is the recommended way to start an ad-hoc
            transaction, and permits modifiers that <code class="literal">BEGIN</code>
            does not.
        </p><p style="color:blue;">“开始”和“开始工作”支持作为启动事务的“开始事务”别名。start transaction是标准的sql语法，是启动特别事务的推荐方法，并且允许begin不允许使用修饰符。</p><p>
            The <code class="literal">BEGIN</code> statement differs from the use of the
            <code class="literal">BEGIN</code> keyword that starts a
            <a class="link" href="sql-syntax.html#begin-end" title="13.6.1&nbsp;BEGIN ... END Compound-Statement Syntax"><code class="literal">BEGIN ... END</code></a>
            compound statement. The latter does not begin a transaction. See
            <a class="xref" href="sql-syntax.html#begin-end" title="13.6.1&nbsp;BEGIN ... END Compound-Statement Syntax">Section&nbsp;13.6.1, “BEGIN ... END Compound-Statement Syntax”</a>.
        </p><p style="color:blue;">BEGIN语句不同于BEGIN关键字的使用，BEGIN关键字用于启动BEGIN…结束复合语句。后者不开始事务。见第13.6.1节，“开始……结束复合语句语法”。</p>
            <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">

                <div class="admon-title">
                    Note
                </div>
                <p>
                    Within all stored programs (stored procedures and functions,
                    triggers, and events), the parser treats <code class="literal">BEGIN
                    [WORK]</code> as the beginning of a
                    <a class="link" href="sql-syntax.html#begin-end" title="13.6.1&nbsp;BEGIN ... END Compound-Statement Syntax"><code class="literal">BEGIN ...
                        END</code></a> block. Begin a transaction in this context with
                    <a class="link" href="sql-syntax.html#commit" title="13.3.1&nbsp;START TRANSACTION, COMMIT, and ROLLBACK Syntax"><code class="literal">START
                        TRANSACTION</code></a> instead.
                </p><p style="color:blue;">在所有存储程序（存储过程和函数、触发器和事件）中，解析器将begin[工作]视为begin的开始…端块。在此上下文中以start transaction开始事务。</p>
            </div>
            <p>
                The optional <code class="literal">WORK</code> keyword is supported for
                <code class="literal">COMMIT</code> and <code class="literal">ROLLBACK</code>, as are
                the <code class="literal">CHAIN</code> and <code class="literal">RELEASE</code>
                clauses. <code class="literal">CHAIN</code> and <code class="literal">RELEASE</code>
                can be used for additional control over transaction completion.
                The value of the <a class="link" href="server-administration.html#sysvar_completion_type"><code class="literal">completion_type</code></a>
                system variable determines the default completion behavior. See
                <a class="xref" href="server-administration.html#server-system-variables" title="5.1.7&nbsp;Server System Variables">Section&nbsp;5.1.7, “Server System Variables”</a>.
            </p><p style="color:blue;">commit和rollback支持可选的work关键字，chain和release子句也是如此。链和释放可用于对事务完成的附加控制。completion_type系统变量的值决定默认的完成行为。见第5.1.7节“服务器系统变量”。</p><p>
            The <code class="literal">AND CHAIN</code> clause causes a new transaction
            to begin as soon as the current one ends, and the new transaction
            has the same isolation level as the just-terminated transaction.
            The new transaction also uses the same access mode (<code class="literal">READ
            WRITE</code> or <code class="literal">READ ONLY</code>) as the
            just-terminated transaction. The <code class="literal">RELEASE</code> clause
            causes the server to disconnect the current client session after
            terminating the current transaction. Including the
            <code class="literal">NO</code> keyword suppresses <code class="literal">CHAIN</code>
            or <code class="literal">RELEASE</code> completion, which can be useful if
            the <a class="link" href="server-administration.html#sysvar_completion_type"><code class="literal">completion_type</code></a> system
            variable is set to cause chaining or release completion by
            default.
        </p><p style="color:blue;">and chain子句使新事务在当前事务结束时立即开始，并且新事务具有与刚刚终止的事务相同的隔离级别。新事务还使用与刚刚终止的事务相同的访问模式（读写或只读）。release子句使服务器在终止当前事务后断开当前客户端会话的连接。如果completion_type系统变量默认设置为导致链接或发布完成，则包含no关键字将禁止执行chain或release completion。</p><p>
            Beginning a transaction causes any pending transaction to be
            committed. See <a class="xref" href="sql-syntax.html#implicit-commit" title="13.3.3&nbsp;Statements That Cause an Implicit Commit">Section&nbsp;13.3.3, “Statements That Cause an Implicit Commit”</a>, for more
            information.
        </p><p style="color:blue;">开始事务会导致提交任何挂起的事务。有关详细信息，请参阅第13.3.3节“导致隐式提交的语句”。</p><p>
            Beginning a transaction also causes table locks acquired with
            <a class="link" href="sql-syntax.html#lock-tables" title="13.3.5&nbsp;LOCK TABLES and UNLOCK TABLES Syntax"><code class="literal">LOCK TABLES</code></a> to be released, as
            though you had executed
            <a class="link" href="sql-syntax.html#lock-tables" title="13.3.5&nbsp;LOCK TABLES and UNLOCK TABLES Syntax"><code class="literal">UNLOCK
                TABLES</code></a>. Beginning a transaction does not release a
            global read lock acquired with <a class="link" href="sql-syntax.html#flush-tables-with-read-lock"><code class="literal">FLUSH TABLES
            WITH READ LOCK</code></a>.
        </p><p style="color:blue;">开始一个事务也会导致用锁表获取的表锁被释放，就像您已经执行了unlock tables一样。开始事务不会释放使用带有读取锁的刷新表获取的全局读取锁。</p><p>
            For best results, transactions should be performed using only
            tables managed by a single transaction-safe storage engine.
            Otherwise, the following problems can occur:
        </p><p style="color:blue;">为了获得最佳结果，应仅使用由单个事务安全存储引擎管理的表来执行事务。否则，可能会出现以下问题：</p>
            <div class="itemizedlist">
                <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                    If you use tables from more than one transaction-safe storage
                    engine (such as <code class="literal">InnoDB</code>), and the
                    transaction isolation level is not
                    <a class="link" href="innodb-storage-engine.html#isolevel_serializable"><code class="literal">SERIALIZABLE</code></a>, it is
                    possible that when one transaction commits, another ongoing
                    transaction that uses the same tables will see only some of
                    the changes made by the first transaction. That is, the
                    atomicity of transactions is not guaranteed with mixed engines
                    and inconsistencies can result. (If mixed-engine transactions
                    are infrequent, you can use
                    <a class="link" href="sql-syntax.html#set-transaction" title="13.3.6&nbsp;SET TRANSACTION Syntax"><code class="literal">SET
                        TRANSACTION ISOLATION LEVEL</code></a> to set the isolation
                    level to <a class="link" href="innodb-storage-engine.html#isolevel_serializable"><code class="literal">SERIALIZABLE</code></a> on a
                    per-transaction basis as necessary.)
                </p><p style="color:blue;">如果使用多个事务安全存储引擎（如innodb）中的表，并且事务隔离级别不可序列化，则可能在一个事务提交时，使用相同表的另一个正在进行的事务将只看到第一个事务所做的一些更改。也就是说，混合引擎不能保证事务的原子性，可能会导致不一致。（如果混合引擎事务很少发生，则可以根据需要使用set transaction isolation level将隔离级别设置为每个事务可序列化。）</p></li><li class="listitem"><p>
                    If you use tables that are not transaction-safe within a
                    transaction, changes to those tables are stored at once,
                    regardless of the status of autocommit mode.
                </p><p style="color:blue;">如果在事务中使用非事务安全的表，则对这些表的更改将立即存储，而不管自动提交模式的状态如何。</p></li><li class="listitem"><p>
                    If you issue a
                    <a class="link" href="sql-syntax.html#commit" title="13.3.1&nbsp;START TRANSACTION, COMMIT, and ROLLBACK Syntax"><code class="literal">ROLLBACK</code></a>
                    statement after updating a nontransactional table within a
                    transaction, an
                    <a class="link" href="error-handling.html#error_er_warning_not_complete_rollback"><code class="literal">ER_WARNING_NOT_COMPLETE_ROLLBACK</code></a>
                    warning occurs. Changes to transaction-safe tables are rolled
                    back, but not changes to nontransaction-safe tables.
                </p><p style="color:blue;">如果在更新事务中的非事务表后发出ROLLBACK语句，则会出现ER U WARNING U NOT U COMPLETE U ROLLBACK警告。对事务安全表的更改将回滚，但不回滚对非事务安全表的更改。</p></li></ul>
            </div>
            <p>
                Each transaction is stored in the binary log in one chunk, upon
                <a class="link" href="sql-syntax.html#commit" title="13.3.1&nbsp;START TRANSACTION, COMMIT, and ROLLBACK Syntax"><code class="literal">COMMIT</code></a>. Transactions that are
                rolled back are not logged.
                (<span class="bold"><strong>Exception</strong></span>: Modifications to
                nontransactional tables cannot be rolled back. If a transaction
                that is rolled back includes modifications to nontransactional
                tables, the entire transaction is logged with a
                <a class="link" href="sql-syntax.html#commit" title="13.3.1&nbsp;START TRANSACTION, COMMIT, and ROLLBACK Syntax"><code class="literal">ROLLBACK</code></a>
                statement at the end to ensure that modifications to the
                nontransactional tables are replicated.) See
                <a class="xref" href="server-administration.html#binary-log" title="5.4.4&nbsp;The Binary Log">Section&nbsp;5.4.4, “The Binary Log”</a>.
            </p><p style="color:blue;">提交时，每个事务都存储在二进制日志的一个块中。不会记录回滚的事务。（异常：无法回滚对非事务表的修改。如果回滚的事务包含对非事务表的修改，则整个事务将在末尾用rollback语句进行记录，以确保对非事务表的修改被复制。）请参阅第5.4.4节“二进制日志”。</p><p>
            You can change the isolation level or access mode for transactions
            with the <a class="link" href="sql-syntax.html#set-transaction" title="13.3.6&nbsp;SET TRANSACTION Syntax"><code class="literal">SET TRANSACTION</code></a> statement.
            See <a class="xref" href="sql-syntax.html#set-transaction" title="13.3.6&nbsp;SET TRANSACTION Syntax">Section&nbsp;13.3.6, “SET TRANSACTION Syntax”</a>.
        </p><p style="color:blue;">您可以使用SET TRANSACTION语句更改事务的隔离级别或访问模式。参见第13.3.6节“设置事务语法”。</p><p>
            Rolling back can be a slow operation that may occur implicitly
            without the user having explicitly asked for it (for example, when
            an error occurs). Because of this, <a class="link" href="sql-syntax.html#show-processlist" title="13.7.5.29&nbsp;SHOW PROCESSLIST Syntax"><code class="literal">SHOW
            PROCESSLIST</code></a> displays <code class="literal">Rolling back</code> in
            the <code class="literal">State</code> column for the session, not only for
            explicit rollbacks performed with the
            <a class="link" href="sql-syntax.html#commit" title="13.3.1&nbsp;START TRANSACTION, COMMIT, and ROLLBACK Syntax"><code class="literal">ROLLBACK</code></a>
            statement but also for implicit rollbacks.
        </p><p style="color:blue;">回滚可能是一个缓慢的操作，在用户没有显式请求的情况下（例如，当发生错误时），可能会隐式发生。因此，show processlist在会话的state列中显示回滚，不仅用于使用rollback语句执行的显式回滚，还用于隐式回滚。</p>
            <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">

                <div class="admon-title">
                    Note
                </div>
                <p>
                    In MySQL 5.7, <code class="literal">BEGIN</code>,
                    <code class="literal">COMMIT</code>, and <code class="literal">ROLLBACK</code> are
                    not affected by <a class="link" href="replication.html#option_mysqld_replicate-do-db"><code class="option">--replicate-do-db</code></a>
                    or <a class="link" href="replication.html#option_mysqld_replicate-ignore-db"><code class="option">--replicate-ignore-db</code></a> rules.
                </p><p style="color:blue;">在mysql 5.7中，begin、commit和rollback不受--replicate do db或--replicate ignore db规则的影响。</p>
            </div>

        </div>
        <div class="section">
            <div class="titlepage">
                <div>
                    <div>
                        <h3 class="title"><a name="cannot-roll-back"></a>13.3.2&nbsp;Statements That Cannot Be Rolled Back</h3>

                    </div>

                </div>

            </div>
            <p>
                Some statements cannot be rolled back. In general, these include
                data definition language (DDL) statements, such as those that
                create or drop databases, those that create, drop, or alter tables
                or stored routines.
            </p><p style="color:blue;">有些语句不能回滚。通常，这些语句包括数据定义语言（DDL）语句，例如创建或删除数据库的语句，创建、删除或更改表或存储例程的语句。</p><p>
            You should design your transactions not to include such
            statements. If you issue a statement early in a transaction that
            cannot be rolled back, and then another statement later fails, the
            full effect of the transaction cannot be rolled back in such cases
            by issuing a
            <a class="link" href="sql-syntax.html#commit" title="13.3.1&nbsp;START TRANSACTION, COMMIT, and ROLLBACK Syntax"><code class="literal">ROLLBACK</code></a>
            statement.
        </p><p style="color:blue;">你应该设计你的交易不包括这样的声明。如果在事务的早期发出一条不能回滚的语句，而随后另一条语句失败，则在这种情况下，不能通过发出回滚语句来回滚事务的全部效果。</p>
        </div>
        <div class="section">
            <div class="titlepage">
                <div>
                    <div>
                        <h3 class="title"><a name="implicit-commit"></a>13.3.3&nbsp;Statements That Cause an Implicit Commit</h3>

                    </div>

                </div>

            </div>
            <p>
                The statements listed in this section (and any synonyms for them)
                implicitly end any transaction active in the current session, as
                if you had done a <a class="link" href="sql-syntax.html#commit" title="13.3.1&nbsp;START TRANSACTION, COMMIT, and ROLLBACK Syntax"><code class="literal">COMMIT</code></a> before
                executing the statement.
            </p><p style="color:blue;">本节中列出的语句（以及它们的任何同义词）隐式地结束当前会话中活动的任何事务，就像在执行语句之前执行了提交一样。</p><p>
            Most of these statements also cause an implicit commit after
            executing. The intent is to handle each such statement in its own
            special transaction because it cannot be rolled back anyway.
            Transaction-control and locking statements are exceptions: If an
            implicit commit occurs before execution, another does not occur
            after.
        </p><p style="color:blue;">大多数这些语句在执行后也会导致隐式提交。其目的是在自己的特殊事务中处理每个这样的语句，因为无论如何都不能回滚它。事务控制和锁定语句是例外：如果隐式提交发生在执行之前，则另一个提交不会发生在执行之后。</p>
            <div class="itemizedlist">
                <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          <span class="bold"><strong>Data definition language (DDL)
          statements that define or modify database objects.</strong></span>
                    <a class="link" href="sql-syntax.html#alter-database" title="13.1.1&nbsp;ALTER DATABASE Syntax"><code class="literal">ALTER DATABASE
                        ... UPGRADE DATA DIRECTORY NAME</code></a>,
                    <a class="link" href="sql-syntax.html#alter-event" title="13.1.2&nbsp;ALTER EVENT Syntax"><code class="literal">ALTER EVENT</code></a>,
                    <a class="link" href="sql-syntax.html#alter-procedure" title="13.1.6&nbsp;ALTER PROCEDURE Syntax"><code class="literal">ALTER PROCEDURE</code></a>,
                    <a class="link" href="sql-syntax.html#alter-server" title="13.1.7&nbsp;ALTER SERVER Syntax"><code class="literal">ALTER SERVER</code></a>,
                    <a class="link" href="sql-syntax.html#alter-table" title="13.1.8&nbsp;ALTER TABLE Syntax"><code class="literal">ALTER TABLE</code></a>,
                    <a class="link" href="sql-syntax.html#alter-view" title="13.1.10&nbsp;ALTER VIEW Syntax"><code class="literal">ALTER VIEW</code></a>,
                    <a class="link" href="sql-syntax.html#create-database" title="13.1.11&nbsp;CREATE DATABASE Syntax"><code class="literal">CREATE DATABASE</code></a>,
                    <a class="link" href="sql-syntax.html#create-event" title="13.1.12&nbsp;CREATE EVENT Syntax"><code class="literal">CREATE EVENT</code></a>,
                    <a class="link" href="sql-syntax.html#create-index" title="13.1.14&nbsp;CREATE INDEX Syntax"><code class="literal">CREATE INDEX</code></a>,
                    <a class="link" href="sql-syntax.html#create-procedure" title="13.1.16&nbsp;CREATE PROCEDURE and CREATE FUNCTION Syntax"><code class="literal">CREATE PROCEDURE</code></a>,
                    <a class="link" href="sql-syntax.html#create-server" title="13.1.17&nbsp;CREATE SERVER Syntax"><code class="literal">CREATE SERVER</code></a>,
                    <a class="link" href="sql-syntax.html#create-table" title="13.1.18&nbsp;CREATE TABLE Syntax"><code class="literal">CREATE TABLE</code></a>,
                    <a class="link" href="sql-syntax.html#create-trigger" title="13.1.20&nbsp;CREATE TRIGGER Syntax"><code class="literal">CREATE TRIGGER</code></a>,
                    <a class="link" href="sql-syntax.html#create-view" title="13.1.21&nbsp;CREATE VIEW Syntax"><code class="literal">CREATE VIEW</code></a>,
                    <a class="link" href="sql-syntax.html#drop-database" title="13.1.22&nbsp;DROP DATABASE Syntax"><code class="literal">DROP DATABASE</code></a>,
                    <a class="link" href="sql-syntax.html#drop-event" title="13.1.23&nbsp;DROP EVENT Syntax"><code class="literal">DROP EVENT</code></a>,
                    <a class="link" href="sql-syntax.html#drop-index" title="13.1.25&nbsp;DROP INDEX Syntax"><code class="literal">DROP INDEX</code></a>,
                    <a class="link" href="sql-syntax.html#drop-procedure" title="13.1.27&nbsp;DROP PROCEDURE and DROP FUNCTION Syntax"><code class="literal">DROP PROCEDURE</code></a>,
                    <a class="link" href="sql-syntax.html#drop-server" title="13.1.28&nbsp;DROP SERVER Syntax"><code class="literal">DROP SERVER</code></a>,
                    <a class="link" href="sql-syntax.html#drop-table" title="13.1.29&nbsp;DROP TABLE Syntax"><code class="literal">DROP TABLE</code></a>,
                    <a class="link" href="sql-syntax.html#drop-trigger" title="13.1.31&nbsp;DROP TRIGGER Syntax"><code class="literal">DROP TRIGGER</code></a>,
                    <a class="link" href="sql-syntax.html#drop-view" title="13.1.32&nbsp;DROP VIEW Syntax"><code class="literal">DROP VIEW</code></a>,
                    <a class="link" href="sql-syntax.html#install-plugin" title="13.7.3.3&nbsp;INSTALL PLUGIN Syntax"><code class="literal">INSTALL PLUGIN</code></a>,
                    <a class="link" href="sql-syntax.html#rename-table" title="13.1.33&nbsp;RENAME TABLE Syntax"><code class="literal">RENAME TABLE</code></a>,
                    <a class="link" href="sql-syntax.html#truncate-table" title="13.1.34&nbsp;TRUNCATE TABLE Syntax"><code class="literal">TRUNCATE TABLE</code></a>,
                    <a class="link" href="sql-syntax.html#uninstall-plugin" title="13.7.3.4&nbsp;UNINSTALL PLUGIN Syntax"><code class="literal">UNINSTALL PLUGIN</code></a>.
                </p><p style="color:blue;">定义或修改数据库对象的数据定义语言（DDL）语句。更改数据库…升级数据目录名、alter event、alter procedure、alter server、alter table、alter view、create database、create event、create index、create procedure、create server、create table、create trigger、create view、drop database、drop event、drop index、drop procedure、drop server、drop table、drop trigger、drop view、install plugin，重命名表，截断表，卸载插件。</p><p>
                    <a class="link" href="sql-syntax.html#alter-function" title="13.1.3&nbsp;ALTER FUNCTION Syntax"><code class="literal">ALTER FUNCTION</code></a>,
                    <a class="link" href="sql-syntax.html#create-function" title="13.1.13&nbsp;CREATE FUNCTION Syntax"><code class="literal">CREATE FUNCTION</code></a> and
                    <a class="link" href="sql-syntax.html#drop-function" title="13.1.24&nbsp;DROP FUNCTION Syntax"><code class="literal">DROP FUNCTION</code></a> also cause an
                    implicit commit when used with stored functions, but not with
                    user-defined functions. (<a class="link" href="sql-syntax.html#alter-function" title="13.1.3&nbsp;ALTER FUNCTION Syntax"><code class="literal">ALTER
                    FUNCTION</code></a> can only be used with stored functions.)
                </p><p style="color:blue;">alter function、create function和drop function在与存储函数一起使用时也会导致隐式提交，但不与用户定义的函数一起使用。（alter函数只能与存储的函数一起使用。）</p><p>
                    <a class="link" href="sql-syntax.html#create-table" title="13.1.18&nbsp;CREATE TABLE Syntax"><code class="literal">CREATE TABLE</code></a> and
                    <a class="link" href="sql-syntax.html#drop-table" title="13.1.29&nbsp;DROP TABLE Syntax"><code class="literal">DROP TABLE</code></a> statements do not
                    commit a transaction if the <code class="literal">TEMPORARY</code>
                    keyword is used. (This does not apply to other operations on
                    temporary tables such as <a class="link" href="sql-syntax.html#alter-table" title="13.1.8&nbsp;ALTER TABLE Syntax"><code class="literal">ALTER
                    TABLE</code></a> and <a class="link" href="sql-syntax.html#create-index" title="13.1.14&nbsp;CREATE INDEX Syntax"><code class="literal">CREATE
                    INDEX</code></a>, which do cause a commit.) However, although
                    no implicit commit occurs, neither can the statement be rolled
                    back, which means that the use of such statements causes
                    transactional atomicity to be violated. For example, if you
                    use <a class="link" href="sql-syntax.html#create-table" title="13.1.18&nbsp;CREATE TABLE Syntax"><code class="literal">CREATE
                    TEMPORARY TABLE</code></a> and then roll back the transaction,
                    the table remains in existence.
                </p><p style="color:blue;">如果使用临时关键字，则CREATE TABLE和DROP TABLE语句不提交事务。（这不适用于对临时表（如alter table和create index）的其他操作，这些操作确实会导致提交。）但是，尽管没有发生隐式提交，但也不能回滚该语句，这意味着使用这些语句会导致违反事务原子性。例如，如果使用创建临时表，然后回滚事务，表仍然存在。</p><p>
                    The <a class="link" href="sql-syntax.html#create-table" title="13.1.18&nbsp;CREATE TABLE Syntax"><code class="literal">CREATE TABLE</code></a> statement in
                    <code class="literal">InnoDB</code> is processed as a single
                    transaction. This means that a
                    <a class="link" href="sql-syntax.html#commit" title="13.3.1&nbsp;START TRANSACTION, COMMIT, and ROLLBACK Syntax"><code class="literal">ROLLBACK</code></a>
                    from the user does not undo <a class="link" href="sql-syntax.html#create-table" title="13.1.18&nbsp;CREATE TABLE Syntax"><code class="literal">CREATE
                    TABLE</code></a> statements the user made during that
                    transaction.
                </p><p style="color:blue;">innodb中的create table语句作为单个事务处理。这意味着来自用户的回滚不会撤消用户在该事务期间所做的CREATE TABLE语句。</p><p>
                    <a class="link" href="sql-syntax.html#create-table" title="13.1.18&nbsp;CREATE TABLE Syntax"><code class="literal">CREATE TABLE ...
                        SELECT</code></a> causes an implicit commit before and after
                    the statement is executed when you are creating nontemporary
                    tables. (No commit occurs for <code class="literal">CREATE TEMPORARY TABLE
                    ... SELECT</code>.)
                </p><p style="color:blue;">创建表…在创建非临时表时，select会在执行语句之前和之后导致隐式提交。（创建临时表时不进行提交…选择。）</p></li><li class="listitem"><p>
          <span class="bold"><strong>Statements that implicitly use or modify
          tables in the <code class="literal">mysql</code> database.</strong></span>
                    <a class="link" href="sql-syntax.html#alter-user" title="13.7.1.1&nbsp;ALTER USER Syntax"><code class="literal">ALTER USER</code></a>,
                    <a class="link" href="sql-syntax.html#create-user" title="13.7.1.2&nbsp;CREATE USER Syntax"><code class="literal">CREATE USER</code></a>,
                    <a class="link" href="sql-syntax.html#drop-user" title="13.7.1.3&nbsp;DROP USER Syntax"><code class="literal">DROP USER</code></a>,
                    <a class="link" href="sql-syntax.html#grant" title="13.7.1.4&nbsp;GRANT Syntax"><code class="literal">GRANT</code></a>,
                    <a class="link" href="sql-syntax.html#rename-user" title="13.7.1.5&nbsp;RENAME USER Syntax"><code class="literal">RENAME USER</code></a>,
                    <a class="link" href="sql-syntax.html#revoke" title="13.7.1.6&nbsp;REVOKE Syntax"><code class="literal">REVOKE</code></a>,
                    <a class="link" href="sql-syntax.html#set-password" title="13.7.1.7&nbsp;SET PASSWORD Syntax"><code class="literal">SET PASSWORD</code></a>.
                </p><p style="color:blue;">隐式使用或修改mysql数据库中的表的语句。更改用户、创建用户、删除用户、授予、重命名用户、撤消、设置密码。</p></li><li class="listitem"><p>
          <span class="bold"><strong>Transaction-control and locking
          statements.</strong></span>
                    <a class="link" href="sql-syntax.html#commit" title="13.3.1&nbsp;START TRANSACTION, COMMIT, and ROLLBACK Syntax"><code class="literal">BEGIN</code></a>,
                    <a class="link" href="sql-syntax.html#lock-tables" title="13.3.5&nbsp;LOCK TABLES and UNLOCK TABLES Syntax"><code class="literal">LOCK TABLES</code></a>, <code class="literal">SET
                    autocommit = 1</code> (if the value is not already 1),
                    <a class="link" href="sql-syntax.html#commit" title="13.3.1&nbsp;START TRANSACTION, COMMIT, and ROLLBACK Syntax"><code class="literal">START
                        TRANSACTION</code></a>,
                    <a class="link" href="sql-syntax.html#lock-tables" title="13.3.5&nbsp;LOCK TABLES and UNLOCK TABLES Syntax"><code class="literal">UNLOCK
                        TABLES</code></a>.
                </p><p style="color:blue;">事务控制和锁定语句。开始，锁定表，设置autocommit=1（如果值还不是1），开始事务，解锁表。</p><p>
                    <a class="link" href="sql-syntax.html#lock-tables" title="13.3.5&nbsp;LOCK TABLES and UNLOCK TABLES Syntax"><code class="literal">UNLOCK
                        TABLES</code></a> commits a transaction only if any tables
                    currently have been locked with <a class="link" href="sql-syntax.html#lock-tables" title="13.3.5&nbsp;LOCK TABLES and UNLOCK TABLES Syntax"><code class="literal">LOCK
                    TABLES</code></a> to acquire nontransactional table locks. A
                    commit does not occur for
                    <a class="link" href="sql-syntax.html#lock-tables" title="13.3.5&nbsp;LOCK TABLES and UNLOCK TABLES Syntax"><code class="literal">UNLOCK
                        TABLES</code></a> following <a class="link" href="sql-syntax.html#flush-tables-with-read-lock"><code class="literal">FLUSH TABLES
                    WITH READ LOCK</code></a> because the latter statement does not
                    acquire table-level locks.
                </p><p style="color:blue;">unlock tables只在当前使用锁表锁定任何表以获取非事务表锁时提交事务。由于后面的语句不获取表级锁，所以在使用read lock刷新表之后，对unlock表不进行提交。</p><p>
                    Transactions cannot be nested. This is a consequence of the
                    implicit commit performed for any current transaction when you
                    issue a <a class="link" href="sql-syntax.html#commit" title="13.3.1&nbsp;START TRANSACTION, COMMIT, and ROLLBACK Syntax"><code class="literal">START
                    TRANSACTION</code></a> statement or one of its synonyms.
                </p><p style="color:blue;">事务不能嵌套。这是在发出start transaction语句或其同义词之一时对任何当前事务执行隐式提交的结果。</p><p>
                    Statements that cause an implicit commit cannot be used in an
                    XA transaction while the transaction is in an
                    <code class="literal">ACTIVE</code> state.
                </p><p style="color:blue;">当事务处于活动状态时，不能在xa事务中使用导致隐式提交的语句。</p><p>
                    The <a class="link" href="sql-syntax.html#commit" title="13.3.1&nbsp;START TRANSACTION, COMMIT, and ROLLBACK Syntax"><code class="literal">BEGIN</code></a>
                    statement differs from the use of the <code class="literal">BEGIN</code>
                    keyword that starts a
                    <a class="link" href="sql-syntax.html#begin-end" title="13.6.1&nbsp;BEGIN ... END Compound-Statement Syntax"><code class="literal">BEGIN ...
                        END</code></a> compound statement. The latter does not cause an
                    implicit commit. See <a class="xref" href="sql-syntax.html#begin-end" title="13.6.1&nbsp;BEGIN ... END Compound-Statement Syntax">Section&nbsp;13.6.1, “BEGIN ... END Compound-Statement Syntax”</a>.
                </p><p style="color:blue;">BEGIN语句不同于BEGIN关键字的使用，BEGIN关键字用于启动BEGIN…结束复合语句。后者不会导致隐式提交。见第13.6.1节，“开始……结束复合语句语法”。</p></li><li class="listitem"><p>
                    <span class="bold"><strong>Data loading statements.</strong></span>
                    <a class="link" href="sql-syntax.html#load-data" title="13.2.6&nbsp;LOAD DATA Syntax"><code class="literal">LOAD DATA</code></a>.
                    <a class="link" href="sql-syntax.html#load-data" title="13.2.6&nbsp;LOAD DATA Syntax"><code class="literal">LOAD DATA</code></a> causes an implicit
                    commit only for tables using the
                    <a class="link" href="mysql-cluster.html" title="Chapter&nbsp;21&nbsp;MySQL NDB Cluster 7.5 and NDB Cluster 7.6"><code class="literal">NDB</code></a> storage engine.
                </p><p style="color:blue;">数据加载语句。加载数据。加载数据只对使用ndb存储引擎的表执行隐式提交。</p></li><li class="listitem"><p>
                    <span class="bold"><strong>Administrative statements.</strong></span>
                    <a class="link" href="sql-syntax.html#analyze-table" title="13.7.2.1&nbsp;ANALYZE TABLE Syntax"><code class="literal">ANALYZE TABLE</code></a>,
                    <a class="link" href="sql-syntax.html#cache-index" title="13.7.6.2&nbsp;CACHE INDEX Syntax"><code class="literal">CACHE INDEX</code></a>,
                    <a class="link" href="sql-syntax.html#check-table" title="13.7.2.2&nbsp;CHECK TABLE Syntax"><code class="literal">CHECK TABLE</code></a>,
                    <a class="link" href="sql-syntax.html#flush" title="13.7.6.3&nbsp;FLUSH Syntax"><code class="literal">FLUSH</code></a>,
                    <a class="link" href="sql-syntax.html#load-index" title="13.7.6.5&nbsp;LOAD INDEX INTO CACHE Syntax"><code class="literal">LOAD INDEX INTO
                        CACHE</code></a>, <a class="link" href="sql-syntax.html#optimize-table" title="13.7.2.4&nbsp;OPTIMIZE TABLE Syntax"><code class="literal">OPTIMIZE
                    TABLE</code></a>, <a class="link" href="sql-syntax.html#repair-table" title="13.7.2.5&nbsp;REPAIR TABLE Syntax"><code class="literal">REPAIR TABLE</code></a>,
                    <a class="link" href="sql-syntax.html#reset" title="13.7.6.6&nbsp;RESET Syntax"><code class="literal">RESET</code></a>.
                </p><p style="color:blue;">行政声明。分析表、缓存索引、检查表、刷新、将索引加载到缓存中、优化表、修复表、重置。</p></li><li class="listitem"><p>
          <span class="bold"><strong>Replication control
          statements</strong></span>. <a class="link" href="sql-syntax.html#start-slave" title="13.4.2.6&nbsp;START SLAVE Syntax"><code class="literal">START
                    SLAVE</code></a>, <a class="link" href="sql-syntax.html#stop-slave" title="13.4.2.7&nbsp;STOP SLAVE Syntax"><code class="literal">STOP SLAVE</code></a>,
                    <a class="link" href="sql-syntax.html#reset-slave" title="13.4.2.4&nbsp;RESET SLAVE Syntax"><code class="literal">RESET SLAVE</code></a>,
                    <a class="link" href="sql-syntax.html#change-master-to" title="13.4.2.1&nbsp;CHANGE MASTER TO Syntax"><code class="literal">CHANGE MASTER TO</code></a>.
                </p><p style="color:blue;">复制控制语句。启动从机，停止从机，重置从机，将主机更改为。</p></li></ul>
            </div>

        </div>
        <div class="section">
            <div class="titlepage">
                <div>
                    <div>
                        <h3 class="title"><a name="savepoint"></a>13.3.4&nbsp;SAVEPOINT, ROLLBACK TO SAVEPOINT, and RELEASE SAVEPOINT Syntax</h3>

                    </div>

                </div>

            </div>
            <a class="indexterm" name="idm140286833310960"></a><a class="indexterm" name="idm140286833309920"></a><a class="indexterm" name="idm140286833308848"></a><pre data-lang="sql" class="programlisting">SAVEPOINT <em class="replaceable"><code>identifier</code></em>
ROLLBACK [WORK] TO [SAVEPOINT] <em class="replaceable"><code>identifier</code></em>
RELEASE SAVEPOINT <em class="replaceable"><code>identifier</code></em>
</pre><p>
            <code class="literal">InnoDB</code> supports the SQL statements
            <a class="link" href="sql-syntax.html#savepoint" title="13.3.4&nbsp;SAVEPOINT, ROLLBACK TO SAVEPOINT, and RELEASE SAVEPOINT Syntax"><code class="literal">SAVEPOINT</code></a>,
            <a class="link" href="sql-syntax.html#savepoint" title="13.3.4&nbsp;SAVEPOINT, ROLLBACK TO SAVEPOINT, and RELEASE SAVEPOINT Syntax"><code class="literal">ROLLBACK TO
                SAVEPOINT</code></a>,
            <a class="link" href="sql-syntax.html#savepoint" title="13.3.4&nbsp;SAVEPOINT, ROLLBACK TO SAVEPOINT, and RELEASE SAVEPOINT Syntax"><code class="literal">RELEASE
                SAVEPOINT</code></a> and the optional <code class="literal">WORK</code>
            keyword for
            <a class="link" href="sql-syntax.html#commit" title="13.3.1&nbsp;START TRANSACTION, COMMIT, and ROLLBACK Syntax"><code class="literal">ROLLBACK</code></a>.
        </p><p style="color:blue;">innodb支持sql语句savepoint、rollback to savepoint、release savepoint和rollback的可选work关键字。</p><p>
            The <a class="link" href="sql-syntax.html#savepoint" title="13.3.4&nbsp;SAVEPOINT, ROLLBACK TO SAVEPOINT, and RELEASE SAVEPOINT Syntax"><code class="literal">SAVEPOINT</code></a> statement sets a
            named transaction savepoint with a name of
            <em class="replaceable"><code>identifier</code></em>. If the current transaction
            has a savepoint with the same name, the old savepoint is deleted
            and a new one is set.
        </p><p style="color:blue;">savepoint语句设置一个名为identifier的命名事务保存点。如果当前事务具有同名的保存点，则会删除旧的保存点并设置新的保存点。</p><p>
            The <a class="link" href="sql-syntax.html#savepoint" title="13.3.4&nbsp;SAVEPOINT, ROLLBACK TO SAVEPOINT, and RELEASE SAVEPOINT Syntax"><code class="literal">ROLLBACK TO
            SAVEPOINT</code></a> statement rolls back a transaction to the
            named savepoint without terminating the transaction. Modifications
            that the current transaction made to rows after the savepoint was
            set are undone in the rollback, but <code class="literal">InnoDB</code> does
            <span class="emphasis"><em>not</em></span> release the row locks that were stored in
            memory after the savepoint. (For a new inserted row, the lock
            information is carried by the transaction ID stored in the row;
            the lock is not separately stored in memory. In this case, the row
            lock is released in the undo.) Savepoints that were set at a later
            time than the named savepoint are deleted.
        </p><p style="color:blue;">rollback to savepoint语句将事务回滚到指定的保存点，而不终止该事务。当前事务在保存点设置之后对行所做的修改将在回滚中撤消，但innodb不会释放保存点之后存储在内存中的行锁。（对于新插入的行，锁信息由存储在该行中的事务id携带；锁不单独存储在内存中。在这种情况下，行锁将在撤消中释放。）将删除在指定保存点之后设置的保存点。</p><p>
            If the <a class="link" href="sql-syntax.html#savepoint" title="13.3.4&nbsp;SAVEPOINT, ROLLBACK TO SAVEPOINT, and RELEASE SAVEPOINT Syntax"><code class="literal">ROLLBACK TO
            SAVEPOINT</code></a> statement returns the following error, it
            means that no savepoint with the specified name exists:
        </p><p style="color:blue;">如果回滚到SavePoT语句返回以下错误，则意味着没有指定名称的保存点存在：</p><pre data-lang="none" class="programlisting">ERROR 1305 (42000): SAVEPOINT <em class="replaceable"><code>identifier</code></em> does not exist
</pre><p>
            The <a class="link" href="sql-syntax.html#savepoint" title="13.3.4&nbsp;SAVEPOINT, ROLLBACK TO SAVEPOINT, and RELEASE SAVEPOINT Syntax"><code class="literal">RELEASE
            SAVEPOINT</code></a> statement removes the named savepoint from the
            set of savepoints of the current transaction. No commit or
            rollback occurs. It is an error if the savepoint does not exist.
        </p><p style="color:blue;">release savepoint语句从当前事务的保存点集中删除命名的保存点。不会发生提交或回滚。如果保存点不存在，则为错误。</p><p>
            All savepoints of the current transaction are deleted if you
            execute a <a class="link" href="sql-syntax.html#commit" title="13.3.1&nbsp;START TRANSACTION, COMMIT, and ROLLBACK Syntax"><code class="literal">COMMIT</code></a>, or a
            <a class="link" href="sql-syntax.html#commit" title="13.3.1&nbsp;START TRANSACTION, COMMIT, and ROLLBACK Syntax"><code class="literal">ROLLBACK</code></a> that
            does not name a savepoint.
        </p><p style="color:blue;">如果执行提交或不命名保存点的回滚，则将删除当前事务的所有保存点。</p><p>
            A new savepoint level is created when a stored function is invoked
            or a trigger is activated. The savepoints on previous levels
            become unavailable and thus do not conflict with savepoints on the
            new level. When the function or trigger terminates, any savepoints
            it created are released and the previous savepoint level is
            restored.
        </p><p style="color:blue;">当调用存储函数或激活触发器时，将创建新的保存点级别。以前级别上的保存点将不可用，因此不会与新级别上的保存点冲突。当函数或触发器终止时，它创建的任何保存点都将被释放，并还原上一个保存点级别。</p>
        </div>
        <div class="section">
            <div class="titlepage">
                <div>
                    <div>
                        <h3 class="title"><a name="lock-tables"></a>13.3.5&nbsp;LOCK TABLES and UNLOCK TABLES Syntax</h3>

                    </div>

                </div>

            </div>
            <a class="indexterm" name="idm140286833277408"></a><a class="indexterm" name="idm140286833276368"></a><pre data-lang="sql" class="programlisting">LOCK TABLES
    <em class="replaceable"><code>tbl_name</code></em> [[AS] <em class="replaceable"><code>alias</code></em>] <em class="replaceable"><code>lock_type</code></em>
    [, <em class="replaceable"><code>tbl_name</code></em> [[AS] <em class="replaceable"><code>alias</code></em>] <em class="replaceable"><code>lock_type</code></em>] ...

<em class="replaceable"><code>lock_type</code></em>: {
    READ [LOCAL]
  | [LOW_PRIORITY] WRITE
}

UNLOCK TABLES
</pre><p>
            MySQL enables client sessions to acquire table locks explicitly
            for the purpose of cooperating with other sessions for access to
            tables, or to prevent other sessions from modifying tables during
            periods when a session requires exclusive access to them. A
            session can acquire or release locks only for itself. One session
            cannot acquire locks for another session or release locks held by
            another session.
        </p><p style="color:blue;">mysql允许客户端会话显式地获取表锁，以便与其他会话协作访问表，或者防止其他会话在会话需要独占访问表时修改表。会话只能为自己获取或释放锁。一个会话无法获取另一个会话的锁或释放另一个会话持有的锁。</p><p>
            Locks may be used to emulate transactions or to get more speed
            when updating tables. This is explained in more detail in
            <a class="xref" href="sql-syntax.html#lock-tables-restrictions" title="Table-Locking Restrictions and Conditions">Table-Locking Restrictions and Conditions</a>.
        </p><p style="color:blue;">锁可用于模拟事务或在更新表时获得更快的速度。这在表锁定限制和条件中有更详细的解释。</p><p>
            <a class="link" href="sql-syntax.html#lock-tables" title="13.3.5&nbsp;LOCK TABLES and UNLOCK TABLES Syntax"><code class="literal">LOCK TABLES</code></a> explicitly acquires
            table locks for the current client session. Table locks can be
            acquired for base tables or views. You must have the
            <a class="link" href="security.html#priv_lock-tables"><code class="literal">LOCK TABLES</code></a> privilege, and the
            <a class="link" href="security.html#priv_select"><code class="literal">SELECT</code></a> privilege for each object to
            be locked.
        </p><p style="color:blue;">锁表显式获取当前客户端会话的表锁。可以为基表或视图获取表锁。必须具有要锁定的每个对象的“锁定表”权限和“选择”权限。</p><p>
            For view locking, <a class="link" href="sql-syntax.html#lock-tables" title="13.3.5&nbsp;LOCK TABLES and UNLOCK TABLES Syntax"><code class="literal">LOCK TABLES</code></a> adds
            all base tables used in the view to the set of tables to be locked
            and locks them automatically. If you lock a table explicitly with
            <a class="link" href="sql-syntax.html#lock-tables" title="13.3.5&nbsp;LOCK TABLES and UNLOCK TABLES Syntax"><code class="literal">LOCK TABLES</code></a>, any tables used in
            triggers are also locked implicitly, as described in
            <a class="xref" href="sql-syntax.html#lock-tables-and-triggers" title="LOCK TABLES and Triggers">LOCK TABLES and Triggers</a>.
        </p><p style="color:blue;">对于视图锁定，锁定表将视图中使用的所有基表添加到要锁定的表集中，并自动锁定它们。如果使用锁定表显式锁定表，则触发器中使用的任何表也将被隐式锁定，如锁定表和触发器中所述。</p><p>
            <a class="link" href="sql-syntax.html#lock-tables" title="13.3.5&nbsp;LOCK TABLES and UNLOCK TABLES Syntax"><code class="literal">UNLOCK
                TABLES</code></a> explicitly releases any table locks held by the
            current session. <a class="link" href="sql-syntax.html#lock-tables" title="13.3.5&nbsp;LOCK TABLES and UNLOCK TABLES Syntax"><code class="literal">LOCK TABLES</code></a>
            implicitly releases any table locks held by the current session
            before acquiring new locks.
        </p><p style="color:blue;">unlock tables显式释放当前会话持有的任何表锁。在获取新锁之前，锁表隐式释放当前会话持有的任何表锁。</p><p>
            Another use for
            <a class="link" href="sql-syntax.html#lock-tables" title="13.3.5&nbsp;LOCK TABLES and UNLOCK TABLES Syntax"><code class="literal">UNLOCK
                TABLES</code></a> is to release the global read lock acquired with
            the <a class="link" href="sql-syntax.html#flush-tables-with-read-lock"><code class="literal">FLUSH TABLES WITH READ LOCK</code></a>
            statement, which enables you to lock all tables in all databases.
            See <a class="xref" href="sql-syntax.html#flush" title="13.7.6.3&nbsp;FLUSH Syntax">Section&nbsp;13.7.6.3, “FLUSH Syntax”</a>. (This is a very convenient way to get
            backups if you have a file system such as Veritas that can take
            snapshots in time.)
        </p><p style="color:blue;">解锁表的另一个用途是释放使用带有read lock语句的flush tables获取的全局读锁，这使您能够锁定所有数据库中的所有表。见第13.7.6.3节“刷新语法”。（如果您的文件系统（如Veritas）可以及时拍摄快照，则这是获取备份的非常方便的方法。）</p><p>
            A table lock protects only against inappropriate reads or writes
            by other sessions. A session holding a <code class="literal">WRITE</code>
            lock can perform table-level operations such as
            <a class="link" href="sql-syntax.html#drop-table" title="13.1.29&nbsp;DROP TABLE Syntax"><code class="literal">DROP TABLE</code></a> or
            <a class="link" href="sql-syntax.html#truncate-table" title="13.1.34&nbsp;TRUNCATE TABLE Syntax"><code class="literal">TRUNCATE TABLE</code></a>. For sessions
            holding a <code class="literal">READ</code> lock, <a class="link" href="sql-syntax.html#drop-table" title="13.1.29&nbsp;DROP TABLE Syntax"><code class="literal">DROP
            TABLE</code></a> and <a class="link" href="sql-syntax.html#truncate-table" title="13.1.34&nbsp;TRUNCATE TABLE Syntax"><code class="literal">TRUNCATE TABLE</code></a>
            operations are not permitted.
        </p><p style="color:blue;">表锁只能防止其他会话进行不适当的读写操作。持有写锁的会话可以执行表级操作，如删除表或截断表。对于持有读取锁的会话，不允许删除表和截断表操作。</p><p>
            The following discussion applies only to
            non-<code class="literal">TEMPORARY</code> tables. <a class="link" href="sql-syntax.html#lock-tables" title="13.3.5&nbsp;LOCK TABLES and UNLOCK TABLES Syntax"><code class="literal">LOCK
            TABLES</code></a> is permitted (but ignored) for a
            <code class="literal">TEMPORARY</code> table. The table can be accessed
            freely by the session within which it was created, regardless of
            what other locking may be in effect. No lock is necessary because
            no other session can see the table.
        </p><p style="color:blue;">以下讨论仅适用于非临时表。对于临时表，允许（但忽略）锁定表。创建表的会话可以自由地访问该表，而不必考虑可能生效的其他锁。不需要锁，因为没有其他会话可以看到表。</p>
            <div class="itemizedlist">
                <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><a class="xref" href="sql-syntax.html#table-lock-acquisition" title="Table Lock Acquisition">Table Lock Acquisition</a></p><p style="color:blue;">表锁获取</p></li><li class="listitem"><p><a class="xref" href="sql-syntax.html#table-lock-release" title="Table Lock Release">Table Lock Release</a></p><p style="color:blue;">桌锁释放</p></li><li class="listitem"><p><a class="xref" href="sql-syntax.html#lock-tables-and-transactions" title="Interaction of Table Locking and Transactions">Interaction of Table Locking and Transactions</a></p><p style="color:blue;">表锁定与事务的交互</p></li><li class="listitem"><p><a class="xref" href="sql-syntax.html#lock-tables-and-triggers" title="LOCK TABLES and Triggers">LOCK TABLES and Triggers</a></p><p style="color:blue;">锁定表和触发器</p></li><li class="listitem"><p><a class="xref" href="sql-syntax.html#lock-tables-restrictions" title="Table-Locking Restrictions and Conditions">Table-Locking Restrictions and Conditions</a></p><p style="color:blue;">表锁定限制和条件</p></li></ul>
            </div>

            <div class="simplesect">

                <div class="titlepage">
                    <div>

                        <div class="simple">
                            <h4 class="title"><a name="table-lock-acquisition"></a>Table Lock Acquisition</h4>

                        </div>

                    </div>

                </div>
                <p>
                    To acquire table locks within the current session, use the
                    <a class="link" href="sql-syntax.html#lock-tables" title="13.3.5&nbsp;LOCK TABLES and UNLOCK TABLES Syntax"><code class="literal">LOCK TABLES</code></a> statement, which
                    acquires metadata locks (see
                    <a class="xref" href="optimization.html#metadata-locking" title="8.11.4&nbsp;Metadata Locking">Section&nbsp;8.11.4, “Metadata Locking”</a>).
                </p><p style="color:blue;">要在当前会话中获取表锁，请使用lock tables语句，该语句获取元数据锁（请参阅第8.11.4节“元数据锁”）。</p><p>
                The following lock types are available:
            </p><p style="color:blue;">以下锁类型可用：</p><p>
                <code class="literal">READ [LOCAL]</code> lock:
            </p><p style="color:blue;">读取[本地]锁定：</p>
                <div class="itemizedlist">
                    <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                        The session that holds the lock can read the table (but not
                        write it).
                    </p><p style="color:blue;">持有锁的会话可以读取表（但不能写入表）。</p></li><li class="listitem"><p>
                        Multiple sessions can acquire a <code class="literal">READ</code> lock
                        for the table at the same time.
                    </p><p style="color:blue;">多个会话可以同时获取表的读锁。</p></li><li class="listitem"><p>
                        Other sessions can read the table without explicitly
                        acquiring a <code class="literal">READ</code> lock.
                    </p><p style="color:blue;">其他会话可以在不显式获取读锁的情况下读取表。</p></li><li class="listitem"><p>
                        The <code class="literal">LOCAL</code> modifier enables nonconflicting
                        <a class="link" href="sql-syntax.html#insert" title="13.2.5&nbsp;INSERT Syntax"><code class="literal">INSERT</code></a> statements (concurrent
                        inserts) by other sessions to execute while the lock is
                        held. (See <a class="xref" href="optimization.html#concurrent-inserts" title="8.11.3&nbsp;Concurrent Inserts">Section&nbsp;8.11.3, “Concurrent Inserts”</a>.) However,
                        <code class="literal">READ LOCAL</code> cannot be used if you are
                        going to manipulate the database using processes external to
                        the server while you hold the lock. For
                        <code class="literal">InnoDB</code> tables, <code class="literal">READ
                        LOCAL</code> is the same as <code class="literal">READ</code>.
                    </p><p style="color:blue;">本地修饰符允许其他会话在保持锁的同时执行非冲突插入语句（并发插入）。（请参阅第8.11.3节“并发插入”。）但是，如果要在保持锁的同时使用服务器外部的进程操作数据库，则不能使用read local。对于innodb表，read local与read相同。</p></li></ul>
                </div>
                <p>
                    <code class="literal">[LOW_PRIORITY] WRITE</code> lock:
                </p><p style="color:blue;">[低优先级]写入锁定：</p>
                <div class="itemizedlist">
                    <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                        The session that holds the lock can read and write the
                        table.
                    </p><p style="color:blue;">持有锁的会话可以读写表。</p></li><li class="listitem"><p>
                        Only the session that holds the lock can access the table.
                        No other session can access it until the lock is released.
                    </p><p style="color:blue;">只有持有锁的会话才能访问表。在释放锁之前，其他会话无法访问它。</p></li><li class="listitem"><p>
                        Lock requests for the table by other sessions block while
                        the <code class="literal">WRITE</code> lock is held.
                    </p><p style="color:blue;">当保持写锁时，其他会话对表的锁请求被阻塞。</p></li><li class="listitem"><p>
                        The <code class="literal">LOW_PRIORITY</code> modifier has no effect.
                        In previous versions of MySQL, it affected locking behavior,
                        but this is no longer true. It is now deprecated and its use
                        produces a warning. Use <code class="literal">WRITE</code> without
                        <code class="literal">LOW_PRIORITY</code> instead.
                    </p><p style="color:blue;">低优先级修改器无效。在以前的mysql版本中，它影响了锁定行为，但现在已经不是这样了。现在不推荐使用它，它的使用会产生一个警告。使用无低优先级的写入。</p></li></ul>
                </div>
                <p>
                    <code class="literal">WRITE</code> locks normally have higher priority
                    than <code class="literal">READ</code> locks to ensure that updates are
                    processed as soon as possible. This means that if one session
                    obtains a <code class="literal">READ</code> lock and then another session
                    requests a <code class="literal">WRITE</code> lock, subsequent
                    <code class="literal">READ</code> lock requests wait until the session
                    that requested the <code class="literal">WRITE</code> lock has obtained
                    the lock and released it. (An exception to this policy can occur
                    for small values of the
                    <a class="link" href="server-administration.html#sysvar_max_write_lock_count"><code class="literal">max_write_lock_count</code></a> system
                    variable; see <a class="xref" href="optimization.html#metadata-locking" title="8.11.4&nbsp;Metadata Locking">Section&nbsp;8.11.4, “Metadata Locking”</a>.)
                </p><p style="color:blue;">写锁通常比读锁具有更高的优先级，以确保尽快处理更新。这意味着，如果一个会话获得读锁，然后另一个会话请求写锁，则后续的读锁请求将等待请求写锁的会话获得锁并释放它。（对于max_write_lock_count系统变量的小值，此策略可能会发生异常；请参阅第8.11.4节“元数据锁定”。）</p><p>
                If the <a class="link" href="sql-syntax.html#lock-tables" title="13.3.5&nbsp;LOCK TABLES and UNLOCK TABLES Syntax"><code class="literal">LOCK TABLES</code></a> statement must
                wait due to locks held by other sessions on any of the tables,
                it blocks until all locks can be acquired.
            </p><p style="color:blue;">如果lock tables语句由于任何表上的其他会话持有锁而必须等待，则它将阻塞，直到可以获取所有锁为止。</p><p>
                A session that requires locks must acquire all the locks that it
                needs in a single <a class="link" href="sql-syntax.html#lock-tables" title="13.3.5&nbsp;LOCK TABLES and UNLOCK TABLES Syntax"><code class="literal">LOCK TABLES</code></a>
                statement. While the locks thus obtained are held, the session
                can access only the locked tables. For example, in the following
                sequence of statements, an error occurs for the attempt to
                access <code class="literal">t2</code> because it was not locked in the
                <a class="link" href="sql-syntax.html#lock-tables" title="13.3.5&nbsp;LOCK TABLES and UNLOCK TABLES Syntax"><code class="literal">LOCK TABLES</code></a> statement:
            </p><p style="color:blue;">需要锁的会话必须在单个lock tables语句中获取所需的所有锁。当这样获得的锁被保持时，会话只能访问被锁定的表。例如，在以下语句序列中，尝试访问t2时出错，因为它未在lock tables语句中锁定：</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>LOCK TABLES t1 READ;</code></strong>
mysql&gt; <strong class="userinput"><code>SELECT COUNT(*) FROM t1;</code></strong>
+----------+
| COUNT(*) |
+----------+
|        3 |
+----------+
mysql&gt; <strong class="userinput"><code>SELECT COUNT(*) FROM t2;</code></strong>
ERROR 1100 (HY000): Table 't2' was not locked with LOCK TABLES
</pre><p>
                Tables in the <code class="literal">INFORMATION_SCHEMA</code> database are
                an exception. They can be accessed without being locked
                explicitly even while a session holds table locks obtained with
                <a class="link" href="sql-syntax.html#lock-tables" title="13.3.5&nbsp;LOCK TABLES and UNLOCK TABLES Syntax"><code class="literal">LOCK TABLES</code></a>.
            </p><p style="color:blue;">信息架构数据库中的表是一个例外。即使会话持有通过锁表获得的表锁，也可以在不显式锁定的情况下访问它们。</p><p>
                You cannot refer to a locked table multiple times in a single
                query using the same name. Use aliases instead, and obtain a
                separate lock for the table and each alias:
            </p><p style="color:blue;">不能使用同一名称在单个查询中多次引用锁定的表。请改用别名，并为表和每个别名获取单独的锁：</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>LOCK TABLE t WRITE, t AS t1 READ;</code></strong>
mysql&gt; <strong class="userinput"><code>INSERT INTO t SELECT * FROM t;</code></strong>
ERROR 1100: Table 't' was not locked with LOCK TABLES
mysql&gt; <strong class="userinput"><code>INSERT INTO t SELECT * FROM t AS t1;</code></strong>
</pre><p>
                The error occurs for the first
                <a class="link" href="sql-syntax.html#insert" title="13.2.5&nbsp;INSERT Syntax"><code class="literal">INSERT</code></a> because there are two
                references to the same name for a locked table. The second
                <a class="link" href="sql-syntax.html#insert" title="13.2.5&nbsp;INSERT Syntax"><code class="literal">INSERT</code></a> succeeds because the
                references to the table use different names.
            </p><p style="color:blue;">第一次插入时出错，因为锁定表有两个对同一名称的引用。第二次插入成功，因为对表的引用使用不同的名称。</p><p>
                If your statements refer to a table by means of an alias, you
                must lock the table using that same alias. It does not work to
                lock the table without specifying the alias:
            </p><p style="color:blue;">如果语句通过别名引用表，则必须使用相同的别名锁定该表。在不指定别名的情况下锁定表不起作用：</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>LOCK TABLE t READ;</code></strong>
mysql&gt; <strong class="userinput"><code>SELECT * FROM t AS myalias;</code></strong>
ERROR 1100: Table 'myalias' was not locked with LOCK TABLES
</pre><p>
                Conversely, if you lock a table using an alias, you must refer
                to it in your statements using that alias:
            </p><p style="color:blue;">相反，如果使用别名锁定表，则必须在使用该别名的语句中引用该表：</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>LOCK TABLE t AS myalias READ;</code></strong>
mysql&gt; <strong class="userinput"><code>SELECT * FROM t;</code></strong>
ERROR 1100: Table 't' was not locked with LOCK TABLES
mysql&gt; <strong class="userinput"><code>SELECT * FROM t AS myalias;</code></strong>
</pre>
                <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">

                    <div class="admon-title">
                        Note
                    </div>
                    <p>
                        <code class="literal">LOCK TABLES</code> or <code class="literal">UNLOCK
                        TABLES</code>, when applied to a partitioned table, always
                        locks or unlocks the entire table; these statements do not
                        support partition lock pruning. See
                        <a class="xref" href="partitioning.html#partitioning-limitations-locking" title="22.6.4&nbsp;Partitioning and Locking">Section&nbsp;22.6.4, “Partitioning and Locking”</a>.
                    </p><p style="color:blue;">当应用于分区表时，锁定表或解除锁定表总是锁定或解除锁定整个表；这些语句不支持分区锁定修剪。见第22.6.4节“隔离和锁定”。</p>
                </div>

            </div>
            <div class="simplesect">
                <div class="titlepage">
                    <div>
                        <div class="simple">
                            <h4 class="title"><a name="table-lock-release"></a>Table Lock Release</h4>

                        </div>

                    </div>

                </div>
                <p>
                    When the table locks held by a session are released, they are
                    all released at the same time. A session can release its locks
                    explicitly, or locks may be released implicitly under certain
                    conditions.
                </p><p style="color:blue;">当一个会话持有的表锁被释放时，它们都会同时被释放。会话可以显式释放其锁，或者在某些条件下隐式释放锁。</p>
                <div class="itemizedlist">
                    <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                        A session can release its locks explicitly with
                        <a class="link" href="sql-syntax.html#lock-tables" title="13.3.5&nbsp;LOCK TABLES and UNLOCK TABLES Syntax"><code class="literal">UNLOCK
                            TABLES</code></a>.
                    </p><p style="color:blue;">会话可以使用解锁表显式释放其锁。</p></li><li class="listitem"><p>
                        If a session issues a <a class="link" href="sql-syntax.html#lock-tables" title="13.3.5&nbsp;LOCK TABLES and UNLOCK TABLES Syntax"><code class="literal">LOCK
                        TABLES</code></a> statement to acquire a lock while already
                        holding locks, its existing locks are released implicitly
                        before the new locks are granted.
                    </p><p style="color:blue;">如果会话发出锁表语句以获取锁，而锁已经持有锁，则其现有的锁在新的锁被授予之前隐式释放。</p></li><li class="listitem"><p>
                        If a session begins a transaction (for example, with
                        <a class="link" href="sql-syntax.html#commit" title="13.3.1&nbsp;START TRANSACTION, COMMIT, and ROLLBACK Syntax"><code class="literal">START
                            TRANSACTION</code></a>), an implicit
                        <a class="link" href="sql-syntax.html#lock-tables" title="13.3.5&nbsp;LOCK TABLES and UNLOCK TABLES Syntax"><code class="literal">UNLOCK
                            TABLES</code></a> is performed, which causes existing locks
                        to be released. (For additional information about the
                        interaction between table locking and transactions, see
                        <a class="xref" href="sql-syntax.html#lock-tables-and-transactions" title="Interaction of Table Locking and Transactions">Interaction of Table Locking and Transactions</a>.)
                    </p><p style="color:blue;">如果会话开始事务（例如，带有启动事务），则执行隐式解锁表，这会导致现有锁被释放。（有关表锁定和事务之间的交互的其他信息，请参阅表锁定和事务的交互。）</p></li></ul>
                </div>
                <p>
                    If the connection for a client session terminates, whether
                    normally or abnormally, the server implicitly releases all table
                    locks held by the session (transactional and nontransactional).
                    If the client reconnects, the locks will no longer be in effect.
                    In addition, if the client had an active transaction, the server
                    rolls back the transaction upon disconnect, and if reconnect
                    occurs, the new session begins with autocommit enabled. For this
                    reason, clients may wish to disable auto-reconnect. With
                    auto-reconnect in effect, the client is not notified if
                    reconnect occurs but any table locks or current transaction will
                    have been lost. With auto-reconnect disabled, if the connection
                    drops, an error occurs for the next statement issued. The client
                    can detect the error and take appropriate action such as
                    reacquiring the locks or redoing the transaction. See
                    <a class="xref" href="connectors-apis.html#c-api-auto-reconnect" title="27.8.20&nbsp;C API Automatic Reconnection Control">Section&nbsp;27.8.20, “C API Automatic Reconnection Control”</a>.
                </p><p style="color:blue;">如果客户端会话的连接正常或异常终止，服务器将隐式释放会话持有的所有表锁（事务性和非事务性）。如果客户端重新连接，锁将不再有效。此外，如果客户端有一个活动事务，则服务器在断开连接时回滚该事务，如果发生重新连接，则新会话将以启用自动提交开始。因此，客户端可能希望禁用自动重新连接。自动重新连接生效后，如果发生重新连接，则不会通知客户端，但任何表锁或当前事务都将丢失。禁用自动重新连接后，如果连接断开，则发出的下一条语句将出错。客户端可以检测错误并采取适当的操作，例如重新获取锁或重做事务。见27.8.20节，“C API自动重新连接控制”。</p>
                <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">

                    <div class="admon-title">
                        Note
                    </div>
                    <p>
                        If you use <a class="link" href="sql-syntax.html#alter-table" title="13.1.8&nbsp;ALTER TABLE Syntax"><code class="literal">ALTER TABLE</code></a> on a
                        locked table, it may become unlocked. For example, if you
                        attempt a second <a class="link" href="sql-syntax.html#alter-table" title="13.1.8&nbsp;ALTER TABLE Syntax"><code class="literal">ALTER TABLE</code></a>
                        operation, the result may be an error <code class="literal">Table
                        '<em class="replaceable"><code>tbl_name</code></em>' was not locked with LOCK
                        TABLES</code>. To handle this, lock the table again prior
                        to the second alteration. See also
                        <a class="xref" href="error-handling.html#alter-table-problems" title="B.4.6.1&nbsp;Problems with ALTER TABLE">Section&nbsp;B.4.6.1, “Problems with ALTER TABLE”</a>.
                    </p><p style="color:blue;">如果在锁定的表上使用alter table，它可能会变为未锁定。例如，如果尝试第二个alter table操作，结果可能是错误表“tbl_name”未用锁表锁定。要处理此问题，请在第二次更改之前再次锁定表。另请参见第B.4.6.1节“alter table的问题”。</p>
                </div>

            </div>
            <div class="simplesect">
                <div class="titlepage">
                    <div>
                        <div class="simple">
                            <h4 class="title"><a name="lock-tables-and-transactions"></a>Interaction of Table Locking and Transactions</h4>

                        </div>

                    </div>

                </div>
                <a class="indexterm" name="idm140286833155920"></a><p>
                <a class="link" href="sql-syntax.html#lock-tables" title="13.3.5&nbsp;LOCK TABLES and UNLOCK TABLES Syntax"><code class="literal">LOCK TABLES</code></a> and
                <a class="link" href="sql-syntax.html#lock-tables" title="13.3.5&nbsp;LOCK TABLES and UNLOCK TABLES Syntax"><code class="literal">UNLOCK
                    TABLES</code></a> interact with the use of transactions as
                follows:
            </p><p style="color:blue;">锁定表和解锁表与事务的使用交互如下：</p>
                <div class="itemizedlist">
                    <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                        <a class="link" href="sql-syntax.html#lock-tables" title="13.3.5&nbsp;LOCK TABLES and UNLOCK TABLES Syntax"><code class="literal">LOCK TABLES</code></a> is not
                        transaction-safe and implicitly commits any active
                        transaction before attempting to lock the tables.
                    </p><p style="color:blue;">锁定表不是事务安全的，在尝试锁定表之前隐式提交任何活动事务。</p></li><li class="listitem"><p>
                        <a class="link" href="sql-syntax.html#lock-tables" title="13.3.5&nbsp;LOCK TABLES and UNLOCK TABLES Syntax"><code class="literal">UNLOCK
                            TABLES</code></a> implicitly commits any active transaction,
                        but only if <a class="link" href="sql-syntax.html#lock-tables" title="13.3.5&nbsp;LOCK TABLES and UNLOCK TABLES Syntax"><code class="literal">LOCK TABLES</code></a> has
                        been used to acquire table locks. For example, in the
                        following set of statements,
                        <a class="link" href="sql-syntax.html#lock-tables" title="13.3.5&nbsp;LOCK TABLES and UNLOCK TABLES Syntax"><code class="literal">UNLOCK
                            TABLES</code></a> releases the global read lock but does not
                        commit the transaction because no table locks are in effect:
                    </p><p style="color:blue;">unlock tables隐式提交任何活动事务，但前提是锁表已用于获取表锁。例如，在以下语句集中，unlock tables释放全局读取锁，但不提交事务，因为没有有效的表锁：</p><pre data-lang="sql" class="programlisting">FLUSH TABLES WITH READ LOCK;
START TRANSACTION;
SELECT ... ;
UNLOCK TABLES;
</pre></li><li class="listitem"><p>
                        Beginning a transaction (for example, with
                        <a class="link" href="sql-syntax.html#commit" title="13.3.1&nbsp;START TRANSACTION, COMMIT, and ROLLBACK Syntax"><code class="literal">START
                            TRANSACTION</code></a>) implicitly commits any current
                        transaction and releases existing table locks.
                    </p><p style="color:blue;">开始事务（例如，带有启动事务）隐式地提交任何当前事务并释放现有表锁。</p></li><li class="listitem"><p>
                        <a class="link" href="sql-syntax.html#flush-tables-with-read-lock"><code class="literal">FLUSH TABLES WITH READ LOCK</code></a>
                        acquires a global read lock and not table locks, so it is
                        not subject to the same behavior as
                        <a class="link" href="sql-syntax.html#lock-tables" title="13.3.5&nbsp;LOCK TABLES and UNLOCK TABLES Syntax"><code class="literal">LOCK TABLES</code></a> and
                        <a class="link" href="sql-syntax.html#lock-tables" title="13.3.5&nbsp;LOCK TABLES and UNLOCK TABLES Syntax"><code class="literal">UNLOCK
                            TABLES</code></a> with respect to table locking and implicit
                        commits. For example,
                        <a class="link" href="sql-syntax.html#commit" title="13.3.1&nbsp;START TRANSACTION, COMMIT, and ROLLBACK Syntax"><code class="literal">START
                            TRANSACTION</code></a> does not release the global read lock.
                        See <a class="xref" href="sql-syntax.html#flush" title="13.7.6.3&nbsp;FLUSH Syntax">Section&nbsp;13.7.6.3, “FLUSH Syntax”</a>.
                    </p><p style="color:blue;">带读锁的flush tables获取全局读锁而不是表锁，因此它在表锁和隐式提交方面不受锁表和解锁表的相同行为的影响。例如，start transaction不释放全局读取锁。见第13.7.6.3节“刷新语法”。</p></li><li class="listitem"><p>
                        Other statements that implicitly cause transactions to be
                        committed do not release existing table locks. For a list of
                        such statements, see <a class="xref" href="sql-syntax.html#implicit-commit" title="13.3.3&nbsp;Statements That Cause an Implicit Commit">Section&nbsp;13.3.3, “Statements That Cause an Implicit Commit”</a>.
                    </p><p style="color:blue;">隐式地导致事务提交的其他语句不释放现有的表锁。有关此类语句的列表，请参见第13.3.3节“导致隐式提交的语句”。</p></li><li class="listitem"><p>
                        The correct way to use <a class="link" href="sql-syntax.html#lock-tables" title="13.3.5&nbsp;LOCK TABLES and UNLOCK TABLES Syntax"><code class="literal">LOCK
                        TABLES</code></a> and
                        <a class="link" href="sql-syntax.html#lock-tables" title="13.3.5&nbsp;LOCK TABLES and UNLOCK TABLES Syntax"><code class="literal">UNLOCK
                            TABLES</code></a> with transactional tables, such as
                        <code class="literal">InnoDB</code> tables, is to begin a transaction
                        with <code class="literal">SET autocommit = 0</code> (not
                        <a class="link" href="sql-syntax.html#commit" title="13.3.1&nbsp;START TRANSACTION, COMMIT, and ROLLBACK Syntax"><code class="literal">START
                            TRANSACTION</code></a>) followed by <a class="link" href="sql-syntax.html#lock-tables" title="13.3.5&nbsp;LOCK TABLES and UNLOCK TABLES Syntax"><code class="literal">LOCK
                        TABLES</code></a>, and to not call
                        <a class="link" href="sql-syntax.html#lock-tables" title="13.3.5&nbsp;LOCK TABLES and UNLOCK TABLES Syntax"><code class="literal">UNLOCK
                            TABLES</code></a> until you commit the transaction
                        explicitly. For example, if you need to write to table
                        <code class="literal">t1</code> and read from table
                        <code class="literal">t2</code>, you can do this:
                    </p><p style="color:blue;">对事务表（如innodb tables）使用lock tables和unlock tables的正确方法是，以set autocommit=0（不是start transaction）后跟lock tables开始事务，并且在显式提交事务之前不调用unlock tables。例如，如果需要写入表T1并读取表T2，可以执行以下操作：</p><pre data-lang="sql" class="programlisting">SET autocommit=0;
LOCK TABLES t1 WRITE, t2 READ, ...;
<em class="replaceable"><code>... do something with tables t1 and t2 here ...</code></em>
COMMIT;
UNLOCK TABLES;
</pre><p>
                        When you call <a class="link" href="sql-syntax.html#lock-tables" title="13.3.5&nbsp;LOCK TABLES and UNLOCK TABLES Syntax"><code class="literal">LOCK TABLES</code></a>,
                        <code class="literal">InnoDB</code> internally takes its own table
                        lock, and MySQL takes its own table lock.
                        <code class="literal">InnoDB</code> releases its internal table lock
                        at the next commit, but for MySQL to release its table lock,
                        you have to call
                        <a class="link" href="sql-syntax.html#lock-tables" title="13.3.5&nbsp;LOCK TABLES and UNLOCK TABLES Syntax"><code class="literal">UNLOCK
                            TABLES</code></a>. You should not have
                        <a class="link" href="server-administration.html#sysvar_autocommit"><code class="literal">autocommit = 1</code></a>, because
                        then <code class="literal">InnoDB</code> releases its internal table
                        lock immediately after the call of <a class="link" href="sql-syntax.html#lock-tables" title="13.3.5&nbsp;LOCK TABLES and UNLOCK TABLES Syntax"><code class="literal">LOCK
                        TABLES</code></a>, and deadlocks can very easily happen.
                        <code class="literal">InnoDB</code> does not acquire the internal
                        table lock at all if <a class="link" href="server-administration.html#sysvar_autocommit"><code class="literal">autocommit =
                        1</code></a>, to help old applications avoid unnecessary
                        deadlocks.
                    </p><p style="color:blue;">调用锁表时，innodb在内部使用自己的表锁，mysql使用自己的表锁。innodb在下一次提交时释放它的内部表锁，但是为了让mysql释放它的表锁，您必须调用unlock tables。您不应该让autocommit=1，因为在调用锁表之后，innodb会立即释放它的内部表锁，并且死锁很容易发生。如果autocommit=1，innodb根本不获取内部表锁，以帮助旧应用程序避免不必要的死锁。</p></li><li class="listitem"><p>
                        <a class="link" href="sql-syntax.html#commit" title="13.3.1&nbsp;START TRANSACTION, COMMIT, and ROLLBACK Syntax"><code class="literal">ROLLBACK</code></a>
                        does not release table locks.
                    </p><p style="color:blue;">回滚不会释放表锁。</p></li></ul>
                </div>

            </div>
            <div class="simplesect">
                <div class="titlepage">
                    <div>
                        <div class="simple">
                            <h4 class="title"><a name="lock-tables-and-triggers"></a>LOCK TABLES and Triggers</h4>

                        </div>

                    </div>

                </div>
                <p>
                    If you lock a table explicitly with <a class="link" href="sql-syntax.html#lock-tables" title="13.3.5&nbsp;LOCK TABLES and UNLOCK TABLES Syntax"><code class="literal">LOCK
                    TABLES</code></a>, any tables used in triggers are also locked
                    implicitly:
                </p><p style="color:blue;">如果使用锁定表显式锁定表，则触发器中使用的任何表也将隐式锁定：</p>
                <div class="itemizedlist">
                    <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                        The locks are taken as the same time as those acquired
                        explicitly with the <a class="link" href="sql-syntax.html#lock-tables" title="13.3.5&nbsp;LOCK TABLES and UNLOCK TABLES Syntax"><code class="literal">LOCK
                        TABLES</code></a> statement.
                    </p><p style="color:blue;">这些锁与用lock tables语句显式获取的锁的时间相同。</p></li><li class="listitem"><p>
                        The lock on a table used in a trigger depends on whether the
                        table is used only for reading. If so, a read lock suffices.
                        Otherwise, a write lock is used.
                    </p><p style="color:blue;">触发器中使用的表的锁取决于该表是否仅用于读取。如果是，读锁就足够了。否则，将使用写锁。</p></li><li class="listitem"><p>
                        If a table is locked explicitly for reading with
                        <a class="link" href="sql-syntax.html#lock-tables" title="13.3.5&nbsp;LOCK TABLES and UNLOCK TABLES Syntax"><code class="literal">LOCK TABLES</code></a>, but needs to be
                        locked for writing because it might be modified within a
                        trigger, a write lock is taken rather than a read lock.
                        (That is, an implicit write lock needed due to the table's
                        appearance within a trigger causes an explicit read lock
                        request for the table to be converted to a write lock
                        request.)
                    </p><p style="color:blue;">如果表是显式锁定以使用锁表进行读取的，但由于可能在触发器中修改而需要锁定以进行写入，则将采用写锁而不是读锁。（也就是说，由于表出现在触发器中而需要隐式写锁，这会导致表的显式读锁请求转换为写锁请求。）</p></li></ul>
                </div>
                <p>
                    Suppose that you lock two tables, <code class="literal">t1</code> and
                    <code class="literal">t2</code>, using this statement:
                </p><p style="color:blue;">假设使用以下语句锁定两个表T1和T2：</p><pre data-lang="sql" class="programlisting">LOCK TABLES t1 WRITE, t2 READ;
</pre><p>
                If <code class="literal">t1</code> or <code class="literal">t2</code> have any
                triggers, tables used within the triggers will also be locked.
                Suppose that <code class="literal">t1</code> has a trigger defined like
                this:
            </p><p style="color:blue;">如果T1或T2有任何触发器，触发器中使用的表也将被锁定。假设T1有这样定义的触发器：</p><pre data-lang="sql" class="programlisting">CREATE TRIGGER t1_a_ins AFTER INSERT ON t1 FOR EACH ROW
BEGIN
  UPDATE t4 SET count = count+1
      WHERE id = NEW.id AND EXISTS (SELECT a FROM t3);
  INSERT INTO t2 VALUES(1, 2);
END;
</pre><p>
                The result of the <a class="link" href="sql-syntax.html#lock-tables" title="13.3.5&nbsp;LOCK TABLES and UNLOCK TABLES Syntax"><code class="literal">LOCK TABLES</code></a>
                statement is that <code class="literal">t1</code> and
                <code class="literal">t2</code> are locked because they appear in the
                statement, and <code class="literal">t3</code> and <code class="literal">t4</code>
                are locked because they are used within the trigger:
            </p><p style="color:blue;">lock tables语句的结果是，T1和T2由于出现在语句中而被锁定，T3和T4由于在触发器中使用而被锁定：</p>
                <div class="itemizedlist">
                    <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                        <code class="literal">t1</code> is locked for writing per the
                        <code class="literal">WRITE</code> lock request.
                    </p><p style="color:blue;">T1被锁定，以便根据写入锁定请求进行写入。</p></li><li class="listitem"><p>
                        <code class="literal">t2</code> is locked for writing, even though the
                        request is for a <code class="literal">READ</code> lock. This occurs
                        because <code class="literal">t2</code> is inserted into within the
                        trigger, so the <code class="literal">READ</code> request is converted
                        to a <code class="literal">WRITE</code> request.
                    </p><p style="color:blue;">t2被锁定用于写入，即使请求是读取锁定。之所以会发生这种情况，是因为t2被插入触发器中，所以读请求被转换为写请求。</p></li><li class="listitem"><p>
                        <code class="literal">t3</code> is locked for reading because it is
                        only read from within the trigger.
                    </p><p style="color:blue;">t3被锁定以供读取，因为它只从触发器内读取。</p></li><li class="listitem"><p>
                        <code class="literal">t4</code> is locked for writing because it might
                        be updated within the trigger.
                    </p><p style="color:blue;">t4被锁定以进行写入，因为它可能在触发器中被更新。</p></li></ul>
                </div>

            </div>
            <div class="simplesect">
                <div class="titlepage">
                    <div>
                        <div class="simple">
                            <h4 class="title"><a name="lock-tables-restrictions"></a>Table-Locking Restrictions and Conditions</h4>

                        </div>

                    </div>

                </div>
                <p>
                    You can safely use <a class="link" href="sql-syntax.html#kill" title="13.7.6.4&nbsp;KILL Syntax"><code class="literal">KILL</code></a> to
                    terminate a session that is waiting for a table lock. See
                    <a class="xref" href="sql-syntax.html#kill" title="13.7.6.4&nbsp;KILL Syntax">Section&nbsp;13.7.6.4, “KILL Syntax”</a>.
                </p><p style="color:blue;">可以安全地使用kill终止等待表锁的会话。见第13.7.6.4节“终止语法”。</p><p>
                <a class="link" href="sql-syntax.html#lock-tables" title="13.3.5&nbsp;LOCK TABLES and UNLOCK TABLES Syntax"><code class="literal">LOCK TABLES</code></a> and
                <a class="link" href="sql-syntax.html#lock-tables" title="13.3.5&nbsp;LOCK TABLES and UNLOCK TABLES Syntax"><code class="literal">UNLOCK
                    TABLES</code></a> cannot be used within stored programs.
            </p><p style="color:blue;">锁定表和解锁表不能在存储的程序中使用。</p><p>
                Tables in the <code class="literal">performance_schema</code> database
                cannot be locked with <a class="link" href="sql-syntax.html#lock-tables" title="13.3.5&nbsp;LOCK TABLES and UNLOCK TABLES Syntax"><code class="literal">LOCK
                TABLES</code></a>, except the
                <code class="literal">setup_<em class="replaceable"><code>xxx</code></em></code> tables.
            </p><p style="color:blue;">性能架构数据库中的表不能用锁定表锁定，安装程序表除外。</p><p>
                The following statements are prohibited while a
                <a class="link" href="sql-syntax.html#lock-tables" title="13.3.5&nbsp;LOCK TABLES and UNLOCK TABLES Syntax"><code class="literal">LOCK TABLES</code></a> statement is in
                effect: <a class="link" href="sql-syntax.html#create-table" title="13.1.18&nbsp;CREATE TABLE Syntax"><code class="literal">CREATE TABLE</code></a>,
                <a class="link" href="sql-syntax.html#create-table" title="13.1.18&nbsp;CREATE TABLE Syntax"><code class="literal">CREATE TABLE ...
                    LIKE</code></a>, <a class="link" href="sql-syntax.html#create-view" title="13.1.21&nbsp;CREATE VIEW Syntax"><code class="literal">CREATE VIEW</code></a>,
                <a class="link" href="sql-syntax.html#drop-view" title="13.1.32&nbsp;DROP VIEW Syntax"><code class="literal">DROP VIEW</code></a>, and DDL statements on
                stored functions and procedures and events.
            </p><p style="color:blue;">当lock tables语句生效时，禁止使用以下语句：create table，create table…例如，创建视图、删除视图和关于存储函数、过程和事件的ddl语句。</p><p>
                For some operations, system tables in the
                <code class="literal">mysql</code> database must be accessed. For example,
                the <a class="link" href="sql-syntax.html#help" title="13.8.3&nbsp;HELP Syntax"><code class="literal">HELP</code></a> statement requires the
                contents of the server-side help tables, and
                <a class="link" href="functions.html#function_convert-tz"><code class="literal">CONVERT_TZ()</code></a> might need to read
                the time zone tables. The server implicitly locks the system
                tables for reading as necessary so that you need not lock them
                explicitly. These tables are treated as just described:
            </p><p style="color:blue;">对于某些操作，必须访问mysql数据库中的系统表。例如，help语句需要服务器端帮助表的内容，convert_tz（）可能需要读取时区表。服务器根据需要隐式锁定系统表以供读取，这样您就不必显式锁定它们。这些表格的处理方式如下所述：</p><pre data-lang="none" class="programlisting">mysql.help_category
mysql.help_keyword
mysql.help_relation
mysql.help_topic
mysql.proc
mysql.time_zone
mysql.time_zone_leap_second
mysql.time_zone_name
mysql.time_zone_transition
mysql.time_zone_transition_type
</pre><p>
                If you want to explicitly place a <code class="literal">WRITE</code> lock
                on any of those tables with a <a class="link" href="sql-syntax.html#lock-tables" title="13.3.5&nbsp;LOCK TABLES and UNLOCK TABLES Syntax"><code class="literal">LOCK
                TABLES</code></a> statement, the table must be the only one
                locked; no other table can be locked with the same statement.
            </p><p style="color:blue;">如果要用lock tables语句显式地对这些表中的任何表放置写锁，则该表必须是唯一锁定的表；不能用同一语句锁定其他表。</p><p>
                Normally, you do not need to lock tables, because all single
                <a class="link" href="sql-syntax.html#update" title="13.2.11&nbsp;UPDATE Syntax"><code class="literal">UPDATE</code></a> statements are atomic; no
                other session can interfere with any other currently executing
                SQL statement. However, there are a few cases when locking
                tables may provide an advantage:
            </p><p style="color:blue;">通常，您不需要锁定表，因为所有单个update语句都是原子的；没有其他会话可以干扰任何其他当前正在执行的sql语句。但是，在某些情况下，锁定表可能会提供一个优势：</p>
                <div class="itemizedlist">
                    <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                        If you are going to run many operations on a set of
                        <code class="literal">MyISAM</code> tables, it is much faster to lock
                        the tables you are going to use. Locking
                        <code class="literal">MyISAM</code> tables speeds up inserting,
                        updating, or deleting on them because MySQL does not flush
                        the key cache for the locked tables until
                        <a class="link" href="sql-syntax.html#lock-tables" title="13.3.5&nbsp;LOCK TABLES and UNLOCK TABLES Syntax"><code class="literal">UNLOCK
                            TABLES</code></a> is called. Normally, the key cache is
                        flushed after each SQL statement.
                    </p><p style="color:blue;">如果要在一组myisam表上运行许多操作，那么锁定要使用的表要快得多。锁定myisam表可以加速对它们的插入、更新或删除，因为在调用unlock tables之前，mysql不会刷新锁定表的密钥缓存。通常，在每个sql语句之后都会刷新密钥缓存。</p><p>
                        The downside to locking the tables is that no session can
                        update a <code class="literal">READ</code>-locked table (including the
                        one holding the lock) and no session can access a
                        <code class="literal">WRITE</code>-locked table other than the one
                        holding the lock.
                    </p><p style="color:blue;">锁定表的缺点是，没有会话可以更新已读锁定的表（包括持有锁的表），并且除了持有锁的表之外，没有会话可以访问已写锁定的表。</p></li><li class="listitem"><p>
                        If you are using tables for a nontransactional storage
                        engine, you must use <a class="link" href="sql-syntax.html#lock-tables" title="13.3.5&nbsp;LOCK TABLES and UNLOCK TABLES Syntax"><code class="literal">LOCK
                        TABLES</code></a> if you want to ensure that no other session
                        modifies the tables between a
                        <a class="link" href="sql-syntax.html#select" title="13.2.9&nbsp;SELECT Syntax"><code class="literal">SELECT</code></a> and an
                        <a class="link" href="sql-syntax.html#update" title="13.2.11&nbsp;UPDATE Syntax"><code class="literal">UPDATE</code></a>. The example shown
                        here requires <a class="link" href="sql-syntax.html#lock-tables" title="13.3.5&nbsp;LOCK TABLES and UNLOCK TABLES Syntax"><code class="literal">LOCK TABLES</code></a> to
                        execute safely:
                    </p><p style="color:blue;">如果要将表用于非事务性存储引擎，则如果要确保没有其他会话修改select和update之间的表，则必须使用锁表。此处显示的示例要求锁表安全执行：</p><pre data-lang="sql" class="programlisting">LOCK TABLES trans READ, customer WRITE;
SELECT SUM(value) FROM trans WHERE customer_id=<em class="replaceable"><code>some_id</code></em>;
UPDATE customer
  SET total_value=<em class="replaceable"><code>sum_from_previous_statement</code></em>
  WHERE customer_id=<em class="replaceable"><code>some_id</code></em>;
UNLOCK TABLES;
</pre><p>
                        Without <a class="link" href="sql-syntax.html#lock-tables" title="13.3.5&nbsp;LOCK TABLES and UNLOCK TABLES Syntax"><code class="literal">LOCK TABLES</code></a>, it is
                        possible that another session might insert a new row in the
                        <code class="literal">trans</code> table between execution of the
                        <a class="link" href="sql-syntax.html#select" title="13.2.9&nbsp;SELECT Syntax"><code class="literal">SELECT</code></a> and
                        <a class="link" href="sql-syntax.html#update" title="13.2.11&nbsp;UPDATE Syntax"><code class="literal">UPDATE</code></a> statements.
                    </p><p style="color:blue;">如果没有锁表，则另一个会话可能会在执行select和update语句之间的trans表中插入新行。</p></li></ul>
                </div>
                <p>
                    You can avoid using <a class="link" href="sql-syntax.html#lock-tables" title="13.3.5&nbsp;LOCK TABLES and UNLOCK TABLES Syntax"><code class="literal">LOCK TABLES</code></a>
                    in many cases by using relative updates (<code class="literal">UPDATE
                    customer SET
                    <em class="replaceable"><code>value</code></em>=<em class="replaceable"><code>value</code></em>+<em class="replaceable"><code>new_value</code></em></code>)
                    or the <a class="link" href="functions.html#function_last-insert-id"><code class="literal">LAST_INSERT_ID()</code></a> function.
                </p><p style="color:blue;">在许多情况下，可以通过使用相对更新（update customer set value=value+new_value）或last_insert_id（）函数来避免使用锁表。</p><p>
                You can also avoid locking tables in some cases by using the
                user-level advisory lock functions
                <a class="link" href="functions.html#function_get-lock"><code class="literal">GET_LOCK()</code></a> and
                <a class="link" href="functions.html#function_release-lock"><code class="literal">RELEASE_LOCK()</code></a>. These locks are
                saved in a hash table in the server and implemented with
                <code class="literal">pthread_mutex_lock()</code> and
                <code class="literal">pthread_mutex_unlock()</code> for high speed. See
                <a class="xref" href="functions.html#locking-functions" title="12.14&nbsp;Locking Functions">Section&nbsp;12.14, “Locking Functions”</a>.
            </p><p style="color:blue;">在某些情况下，还可以使用用户级的咨询锁函数get_lock（）和release_lock（）来避免锁定表。这些锁保存在服务器的哈希表中，并使用pthread_mutex_lock（）和pthread_mutex_unlock（）实现，以获得高速。见第12.14节“锁定功能”。</p><p>
                See <a class="xref" href="optimization.html#internal-locking" title="8.11.1&nbsp;Internal Locking Methods">Section&nbsp;8.11.1, “Internal Locking Methods”</a>, for more information on
                locking policy.
            </p><p style="color:blue;">有关锁定策略的更多信息，请参见第8.11.1节“内部锁定方法”。</p>
            </div>

        </div>
        <div class="section">
            <div class="titlepage">
                <div>
                    <div>
                        <h3 class="title"><a name="set-transaction"></a>13.3.6&nbsp;SET TRANSACTION Syntax</h3>

                    </div>

                </div>

            </div>
            <a class="indexterm" name="idm140286833021376"></a><a class="indexterm" name="idm140286833020288"></a><a class="indexterm" name="idm140286833019216"></a><a class="indexterm" name="idm140286833018144"></a><pre data-lang="sql" class="programlisting">SET [GLOBAL | SESSION] TRANSACTION
    <em class="replaceable"><code>transaction_characteristic</code></em> [, <em class="replaceable"><code>transaction_characteristic</code></em>] ...

<em class="replaceable"><code>transaction_characteristic</code></em>: {
    ISOLATION LEVEL <em class="replaceable"><code>level</code></em>
  | <em class="replaceable"><code>access_mode</code></em>
}

<em class="replaceable"><code>level</code></em>: {
     REPEATABLE READ
   | READ COMMITTED
   | READ UNCOMMITTED
   | SERIALIZABLE
}

<em class="replaceable"><code>access_mode</code></em>: {
     READ WRITE
   | READ ONLY
}
</pre><p>
            This statement specifies
            <a class="link" href="glossary.html#glos_transaction" title="transaction">transaction</a>
            characteristics. It takes a list of one or more characteristic
            values separated by commas. Each characteristic value sets the
            transaction <a class="link" href="glossary.html#glos_isolation_level" title="isolation level">isolation
            level</a> or access mode. The isolation level is used for
            operations on <a class="link" href="innodb-storage-engine.html" title="Chapter&nbsp;14&nbsp;The InnoDB Storage Engine"><code class="literal">InnoDB</code></a> tables. The
            access mode specifies whether transactions operate in read/write
            or read-only mode.
        </p><p style="color:blue;">此语句指定事务特性。它接受一个或多个由逗号分隔的特征值的列表。每个特征值设置事务隔离级别或访问模式。隔离级别用于对innodb表的操作。访问模式指定事务是以读/写模式还是只读模式运行。</p><p>
            In addition, <a class="link" href="sql-syntax.html#set-transaction" title="13.3.6&nbsp;SET TRANSACTION Syntax"><code class="literal">SET TRANSACTION</code></a> can
            include an optional <code class="literal">GLOBAL</code> or
            <code class="literal">SESSION</code> keyword to indicate the scope of the
            statement.
        </p><p style="color:blue;">此外，set transaction可以包含一个可选的全局或会话关键字来指示语句的范围。</p>
            <div class="itemizedlist">
                <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><a class="xref" href="sql-syntax.html#set-transaction-isolation-level" title="Transaction Isolation Levels">Transaction Isolation Levels</a></p><p style="color:blue;">事务隔离级别</p></li><li class="listitem"><p><a class="xref" href="sql-syntax.html#set-transaction-access-mode" title="Transaction Access Mode">Transaction Access Mode</a></p><p style="color:blue;">事务访问模式</p></li><li class="listitem"><p><a class="xref" href="sql-syntax.html#set-transaction-scope" title="Transaction Characteristic Scope">Transaction Characteristic Scope</a></p><p style="color:blue;">交易特征范围</p></li></ul>
            </div>

            <div class="simplesect">

                <div class="titlepage">
                    <div>

                        <div class="simple">
                            <h4 class="title"><a name="set-transaction-isolation-level"></a>Transaction Isolation Levels</h4>

                        </div>

                    </div>

                </div>
                <p>
                    To set the transaction isolation level, use an
                    <code class="literal">ISOLATION LEVEL
                        <em class="replaceable"><code>level</code></em></code> clause. It is not
                    permitted to specify multiple <code class="literal">ISOLATION LEVEL</code>
                    clauses in the same <a class="link" href="sql-syntax.html#set-transaction" title="13.3.6&nbsp;SET TRANSACTION Syntax"><code class="literal">SET
                    TRANSACTION</code></a> statement.
                </p><p style="color:blue;">要设置事务隔离级别，请使用隔离级别子句。不允许在同一set transaction语句中指定多个隔离级别子句。</p><p>
                The default isolation level is
                <a class="link" href="innodb-storage-engine.html#isolevel_repeatable-read"><code class="literal">REPEATABLE READ</code></a>. Other
                permitted values are <a class="link" href="innodb-storage-engine.html#isolevel_read-committed"><code class="literal">READ
                COMMITTED</code></a>, <a class="link" href="innodb-storage-engine.html#isolevel_read-uncommitted"><code class="literal">READ
                UNCOMMITTED</code></a>, and
                <a class="link" href="innodb-storage-engine.html#isolevel_serializable"><code class="literal">SERIALIZABLE</code></a>. For information
                about these isolation levels, see
                <a class="xref" href="innodb-storage-engine.html#innodb-transaction-isolation-levels" title="14.7.2.1&nbsp;Transaction Isolation Levels">Section&nbsp;14.7.2.1, “Transaction Isolation Levels”</a>.
            </p><p style="color:blue;">默认隔离级别为可重复读取。其他允许的值包括read committed、read uncommitted和serializable。有关这些隔离级别的信息，请参阅第14.7.2.1节“事务隔离级别”。</p>
            </div>
            <div class="simplesect">
                <div class="titlepage">
                    <div>
                        <div class="simple">
                            <h4 class="title"><a name="set-transaction-access-mode"></a>Transaction Access Mode</h4>

                        </div>

                    </div>

                </div>
                <p>
                    To set the transaction access mode, use a <code class="literal">READ
                    WRITE</code> or <code class="literal">READ ONLY</code> clause. It is
                    not permitted to specify multiple access-mode clauses in the
                    same <a class="link" href="sql-syntax.html#set-transaction" title="13.3.6&nbsp;SET TRANSACTION Syntax"><code class="literal">SET TRANSACTION</code></a> statement.
                </p><p style="color:blue;">要设置事务访问模式，请使用读写或只读子句。不允许在同一set transaction语句中指定多个访问模式子句。</p><p>
                By default, a transaction takes place in read/write mode, with
                both reads and writes permitted to tables used in the
                transaction. This mode may be specified explicitly using
                <a class="link" href="sql-syntax.html#set-transaction" title="13.3.6&nbsp;SET TRANSACTION Syntax"><code class="literal">SET TRANSACTION</code></a> with an access
                mode of <code class="literal">READ WRITE</code>.
            </p><p style="color:blue;">默认情况下，事务以读/写模式进行，允许对事务中使用的表进行读写操作。此模式可以使用具有读写访问模式的set transaction显式指定。</p><p>
                If the transaction access mode is set to <code class="literal">READ
                ONLY</code>, changes to tables are prohibited. This may
                enable storage engines to make performance improvements that are
                possible when writes are not permitted.
            </p><p style="color:blue;">如果事务访问模式设置为只读，则禁止更改表。这可能使存储引擎能够在不允许写入时进行性能改进。</p><p>
                In read-only mode, it remains possible to change tables created
                with the <code class="literal">TEMPORARY</code> keyword using DML
                statements. Changes made with DDL statements are not permitted,
                just as with permanent tables.
            </p><p style="color:blue;">在只读模式下，仍然可以使用DML语句更改使用临时关键字创建的表。与永久表一样，不允许使用DDL语句进行更改。</p><p>
                The <code class="literal">READ WRITE</code> and <code class="literal">READ
                ONLY</code> access modes also may be specified for an
                individual transaction using the
                <a class="link" href="sql-syntax.html#commit" title="13.3.1&nbsp;START TRANSACTION, COMMIT, and ROLLBACK Syntax"><code class="literal">START
                    TRANSACTION</code></a> statement.
            </p><p style="color:blue;">也可以使用start transaction语句为单个事务指定读写和只读访问模式。</p>
            </div>
            <div class="simplesect">
                <div class="titlepage">
                    <div>
                        <div class="simple">
                            <h4 class="title"><a name="set-transaction-scope"></a>Transaction Characteristic Scope</h4>

                        </div>

                    </div>

                </div>
                <p>
                    You can set transaction characteristics globally, for the
                    current session, or for the next transaction only:
                </p><p style="color:blue;">您可以为当前会话或仅为下一个事务全局设置事务特征：</p>
                <div class="itemizedlist">
                    <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                        With the <code class="literal">GLOBAL</code> keyword:
                    </p><p style="color:blue;">使用全局关键字：</p>
                        <div class="itemizedlist">
                            <ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
                                The statement applies globally for all subsequent
                                sessions.
                            </p><p style="color:blue;">该语句适用于所有后续会话。</p></li><li class="listitem"><p>
                                Existing sessions are unaffected.
                            </p><p style="color:blue;">现有会话不受影响。</p></li></ul>
                        </div>
                    </li><li class="listitem"><p>
                        With the <code class="literal">SESSION</code> keyword:
                    </p><p style="color:blue;">使用会话关键字：</p>
                        <div class="itemizedlist">
                            <ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
                                The statement applies to all subsequent transactions
                                performed within the current session.
                            </p><p style="color:blue;">该语句适用于当前会话中执行的所有后续事务。</p></li><li class="listitem"><p>
                                The statement is permitted within transactions, but does
                                not affect the current ongoing transaction.
                            </p><p style="color:blue;">该报表允许在交易中使用，但不影响当前正在进行的交易。</p></li><li class="listitem"><p>
                                If executed between transactions, the statement
                                overrides any preceding statement that sets the
                                next-transaction value of the named characteristics.
                            </p><p style="color:blue;">如果在事务之间执行，则该语句将重写设置命名特征的下一个事务值的任何前一个语句。</p></li></ul>
                        </div>
                    </li><li class="listitem"><p>
                        Without any <code class="literal">SESSION</code> or
                        <code class="literal">GLOBAL</code> keyword:
                    </p><p style="color:blue;">没有任何会话或全局关键字：</p>
                        <div class="itemizedlist">
                            <ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
                                The statement applies only to the next single
                                transaction performed within the session.
                            </p><p style="color:blue;">该语句仅适用于会话中执行的下一个事务。</p></li><li class="listitem"><p>
                                Subsequent transactions revert to using the session
                                value of the named characteristics.
                            </p><p style="color:blue;">后续事务将恢复为使用命名特征的会话值。</p></li><li class="listitem"><p>
                                The statement is not permitted within transactions:
                            </p><p style="color:blue;">在以下交易中不允许使用该报表：</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>START TRANSACTION;</code></strong>
Query OK, 0 rows affected (0.02 sec)

mysql&gt; <strong class="userinput"><code>SET TRANSACTION ISOLATION LEVEL SERIALIZABLE;</code></strong>
ERROR 1568 (25001): Transaction characteristics can't be changed
while a transaction is in progress
</pre></li></ul>
                        </div>
                    </li></ul>
                </div>
                <p>
                    A change to global transaction characteristics requires the
                    <a class="link" href="security.html#priv_super"><code class="literal">SUPER</code></a> privilege. Any session is
                    free to change its session characteristics (even in the middle
                    of a transaction), or the characteristics for its next
                    transaction (prior to the start of that transaction).
                </p><p style="color:blue;">更改全局事务特性需要超级权限。任何会话都可以自由更改其会话特征（即使在事务的中间）或下一个事务的特征（在该事务开始之前）。</p><p>
                To set the global isolation level at server startup, use the
                <a class="link" href="server-administration.html#option_mysqld_transaction-isolation"><code class="option">--transaction-isolation=<em class="replaceable"><code>level</code></em></code></a>
                option on the command line or in an option file. Values of
                <em class="replaceable"><code>level</code></em> for this option use dashes
                rather than spaces, so the permissible values are
                <a class="link" href="innodb-storage-engine.html#isolevel_read-uncommitted"><code class="literal">READ-UNCOMMITTED</code></a>,
                <a class="link" href="innodb-storage-engine.html#isolevel_read-committed"><code class="literal">READ-COMMITTED</code></a>,
                <a class="link" href="innodb-storage-engine.html#isolevel_repeatable-read"><code class="literal">REPEATABLE-READ</code></a>, or
                <a class="link" href="innodb-storage-engine.html#isolevel_serializable"><code class="literal">SERIALIZABLE</code></a>.
            </p><p style="color:blue;">要在服务器启动时设置全局隔离级别，请在命令行或选项文件中使用--transaction isolation=level选项。此选项的level值使用破折号而不是空格，因此允许的值为read-uncommitted、read-committed、repeatable-read或serializable。</p><p>
                Similarly, to set the global transaction access mode at server
                startup, use the
                <a class="link" href="server-administration.html#option_mysqld_transaction-read-only"><code class="option">--transaction-read-only</code></a> option.
                The default is <code class="literal">OFF</code> (read/write mode) but the
                value can be set to <code class="literal">ON</code> for a mode of read
                only.
            </p><p style="color:blue;">类似地，要在服务器启动时设置全局事务访问模式，请使用--transaction read-only选项。默认值为关闭（读/写模式），但对于只读模式，可以将该值设置为打开。</p><p>
                For example, to set the isolation level to
                <a class="link" href="innodb-storage-engine.html#isolevel_repeatable-read"><code class="literal">REPEATABLE READ</code></a> and the
                access mode to <code class="literal">READ WRITE</code>, use these lines in
                the <code class="literal">[mysqld]</code> section of an option file:
            </p><p style="color:blue;">例如，要将隔离级别设置为可重复读取，并将访问模式设置为读写，请在选项文件的[mysqld]部分中使用以下行：</p><pre data-lang="ini" class="programlisting">[mysqld]
transaction-isolation = REPEATABLE-READ
transaction-read-only = OFF
</pre><p>
                At runtime, characteristics at the global, session, and
                next-transaction scope levels can be set indirectly using the
                <a class="link" href="sql-syntax.html#set-transaction" title="13.3.6&nbsp;SET TRANSACTION Syntax"><code class="literal">SET TRANSACTION</code></a> statement, as
                described previously. They can also be set directly using the
                <a class="link" href="sql-syntax.html#set-variable" title="13.7.4.1&nbsp;SET Syntax for Variable Assignment"><code class="literal">SET</code></a>
                statement to assign values to the
                <a class="link" href="server-administration.html#sysvar_transaction_isolation"><code class="literal">transaction_isolation</code></a> and
                <a class="link" href="server-administration.html#sysvar_transaction_read_only"><code class="literal">transaction_read_only</code></a> system
                variables:
            </p><p style="color:blue;">在运行时，可以使用set transaction语句间接地设置全局、会话和下一个事务范围级别的特性，如前所述。也可以使用SET语句直接设置它们，为事务隔离和事务只读系统变量赋值：</p>
                <div class="itemizedlist">
                    <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                        <a class="link" href="sql-syntax.html#set-transaction" title="13.3.6&nbsp;SET TRANSACTION Syntax"><code class="literal">SET TRANSACTION</code></a> permits
                        optional <code class="literal">GLOBAL</code> and
                        <code class="literal">SESSION</code> keywords for setting transaction
                        characteristics at different scope levels.
                    </p><p style="color:blue;">set transaction允许在不同的作用域级别设置可选的全局和会话关键字。</p></li><li class="listitem"><p>
                        The
                        <a class="link" href="sql-syntax.html#set-variable" title="13.7.4.1&nbsp;SET Syntax for Variable Assignment"><code class="literal">SET</code></a>
                        statement for assigning values to the
                        <a class="link" href="server-administration.html#sysvar_transaction_isolation"><code class="literal">transaction_isolation</code></a> and
                        <a class="link" href="server-administration.html#sysvar_transaction_read_only"><code class="literal">transaction_read_only</code></a>
                        system variables has syntaxes for setting these variables at
                        different scope levels.
                    </p><p style="color:blue;">用于将值分配给transaction_isolation和transaction_read_only系统变量的set语句具有用于在不同范围级别设置这些变量的语法。</p></li></ul>
                </div>
                <p>
                    The following tables show the characteristic scope level set by
                    each <a class="link" href="sql-syntax.html#set-transaction" title="13.3.6&nbsp;SET TRANSACTION Syntax"><code class="literal">SET TRANSACTION</code></a> and
                    variable-assignment syntax.
                </p><p style="color:blue;">下表显示了由每个集合事务和变量分配语法设置的特征作用域级别。</p>
                <div class="table">
                    <a name="set-transaction-characteristic-syntax"></a><p class="title"><b>Table&nbsp;13.6&nbsp;SET TRANSACTION Syntax for Transaction Characteristics</b></p><p style="color:blue;">表13.6设置事务特征的事务语法</p>
                    <div class="table-contents">
                        <table summary="Syntax for setting transaction characteristics using SET TRANSACTION and affected scope."><colgroup><col width="60*"><col width="40*"></colgroup><thead><tr>
                            <th scope="col">Syntax</th>
                            <th scope="col">Affected Characteristic Scope</th>
                        </tr></thead><tbody><tr>
                            <td scope="row"><code class="literal">SET GLOBAL TRANSACTION
                                <em class="replaceable"><code>transaction_characteristic</code></em></code></td>
                            <td>Global</td>
                        </tr><tr>
                            <td scope="row"><code class="literal">SET SESSION TRANSACTION
                                <em class="replaceable"><code>transaction_characteristic</code></em></code></td>
                            <td>Session</td>
                        </tr><tr>
                            <td scope="row"><code class="literal">SET TRANSACTION
                                <em class="replaceable"><code>transaction_characteristic</code></em></code></td>
                            <td>Next transaction only</td>
                        </tr></tbody></table>
                    </div>

                </div>
                <br class="table-break">
                <div class="table">
                    <a name="set-variable-characteristic-syntax"></a><p class="title"><b>Table&nbsp;13.7&nbsp;SET Syntax for Transaction Characteristics</b></p><p style="color:blue;">表13.7设置事务特征的语法</p>
                    <div class="table-contents">
                        <table summary="Syntax for setting transaction characteristics using SET and affected scope."><colgroup><col width="60*"><col width="40*"></colgroup><thead><tr>
                            <th scope="col">Syntax</th>
                            <th scope="col">Affected Characteristic Scope</th>
                        </tr></thead><tbody><tr>
                            <td scope="row"><code class="literal">SET GLOBAL <em class="replaceable"><code>var_name</code></em> =
                                <em class="replaceable"><code>value</code></em></code></td>
                            <td>Global</td>
                        </tr><tr>
                            <td scope="row"><code class="literal">SET @@GLOBAL.<em class="replaceable"><code>var_name</code></em> =
                                <em class="replaceable"><code>value</code></em></code></td>
                            <td>Global</td>
                        </tr><tr>
                            <td scope="row"><code class="literal">SET SESSION <em class="replaceable"><code>var_name</code></em> =
                                <em class="replaceable"><code>value</code></em></code></td>
                            <td>Session</td>
                        </tr><tr>
                            <td scope="row"><code class="literal">SET @@SESSION.<em class="replaceable"><code>var_name</code></em> =
                                <em class="replaceable"><code>value</code></em></code></td>
                            <td>Session</td>
                        </tr><tr>
                            <td scope="row"><code class="literal">SET <em class="replaceable"><code>var_name</code></em> =
                                <em class="replaceable"><code>value</code></em></code></td>
                            <td>Session</td>
                        </tr><tr>
                            <td scope="row"><code class="literal">SET @@<em class="replaceable"><code>var_name</code></em> =
                                <em class="replaceable"><code>value</code></em></code></td>
                            <td>Next transaction only</td>
                        </tr></tbody></table>
                    </div>

                </div>
                <br class="table-break"><p>
                It is possible to check the global and session values of
                transaction characteristics at runtime:
            </p><p style="color:blue;">可以在运行时检查事务特性的全局值和会话值：</p><pre data-lang="sql" class="programlisting">SELECT @@GLOBAL.transaction_isolation, @@GLOBAL.transaction_read_only;
SELECT @@SESSION.transaction_isolation, @@SESSION.transaction_read_only;
</pre><p>
                Prior to MySQL 5.7.20, use
                <a class="link" href="server-administration.html#sysvar_tx_isolation"><code class="literal">tx_isolation</code></a> and
                <a class="link" href="server-administration.html#sysvar_tx_read_only"><code class="literal">tx_read_only</code></a> rather than
                <a class="link" href="server-administration.html#sysvar_transaction_isolation"><code class="literal">transaction_isolation</code></a> and
                <a class="link" href="server-administration.html#sysvar_transaction_read_only"><code class="literal">transaction_read_only</code></a>.
            </p><p style="color:blue;">在mysql 5.7.20之前，请使用tx_isolation和tx_read_only，而不是transaction_isolation和transaction_read_only。</p>
            </div>

        </div>
        <div class="section">
            <div class="titlepage">
                <div>
                    <div>
                        <h3 class="title"><a name="xa"></a>13.3.7&nbsp;XA Transactions</h3>

                    </div>

                </div>

            </div>
            <div class="toc">
                <dl class="toc"><dt><span class="section"><a href="sql-syntax.html#xa-statements">13.3.7.1 XA Transaction SQL Syntax</a></span></dt><dt><span class="section"><a href="sql-syntax.html#xa-states">13.3.7.2 XA Transaction States</a></span></dt><dt><span class="section"><a href="sql-syntax.html#xa-restrictions">13.3.7.3 Restrictions on XA Transactions</a></span></dt></dl>
            </div>
            <a class="indexterm" name="idm140286832872208"></a><p>
            Support for <a class="link" href="glossary.html#glos_xa" title="XA">XA</a> transactions is
            available for the <a class="link" href="innodb-storage-engine.html" title="Chapter&nbsp;14&nbsp;The InnoDB Storage Engine"><code class="literal">InnoDB</code></a> storage
            engine. The MySQL XA implementation is based on the X/Open CAE
            document <em class="citetitle">Distributed Transaction Processing: The XA
            Specification</em>. This document is published by The Open
            Group and available at
            <a class="ulink" href="http://www.opengroup.org/public/pubs/catalog/c193.htm" target="_top">http://www.opengroup.org/public/pubs/catalog/c193.htm</a>.
            Limitations of the current XA implementation are described in
            <a class="xref" href="sql-syntax.html#xa-restrictions" title="13.3.7.3&nbsp;Restrictions on XA Transactions">Section&nbsp;13.3.7.3, “Restrictions on XA Transactions”</a>.
        </p><p style="color:blue;">innodb存储引擎支持xa事务。mysql xa实现基于x/open cae文档分布式事务处理：xa规范。本文件由开放小组出版，可在http://www.open group.org/public/pubs/catalog/c193.htm上查阅。当前xa实现的限制在第13.3.7.3节“xa事务的限制”中进行了描述。</p><p>
            On the client side, there are no special requirements. The XA
            interface to a MySQL server consists of SQL statements that begin
            with the <code class="literal">XA</code> keyword. MySQL client programs must
            be able to send SQL statements and to understand the semantics of
            the XA statement interface. They do not need be linked against a
            recent client library. Older client libraries also will work.
        </p><p style="color:blue;">在客户端，没有特殊要求。mysql服务器的xa接口由以xa关键字开头的sql语句组成。mysql客户端程序必须能够发送sql语句并理解xa语句接口的语义。它们不需要链接到最近的客户端库。旧的客户端库也可以工作。</p><p>
            Among the MySQL Connectors, MySQL Connector/J 5.0.0 and higher
            supports XA directly, by means of a class interface that handles
            the XA SQL statement interface for you.
        </p><p style="color:blue;">在mysql连接器中，mysql connector/j 5.0.0及更高版本通过一个为您处理xa sql语句接口的类接口直接支持xa。</p><p>
            XA supports distributed transactions, that is, the ability to
            permit multiple separate transactional resources to participate in
            a global transaction. Transactional resources often are RDBMSs but
            may be other kinds of resources.
        </p><p style="color:blue;">xa支持分布式事务，即允许多个独立的事务资源参与全局事务的能力。事务性资源通常是rdbms，但也可能是其他类型的资源。</p><p>
            A global transaction involves several actions that are
            transactional in themselves, but that all must either complete
            successfully as a group, or all be rolled back as a group. In
            essence, this extends ACID properties <span class="quote">“<span class="quote">up a level</span>”</span> so
            that multiple ACID transactions can be executed in concert as
            components of a global operation that also has ACID properties.
            (As with nondistributed transactions,
            <a class="link" href="innodb-storage-engine.html#isolevel_serializable"><code class="literal">SERIALIZABLE</code></a> may be preferred
            if your applications are sensitive to read phenomena.
            <a class="link" href="innodb-storage-engine.html#isolevel_repeatable-read"><code class="literal">REPEATABLE READ</code></a> may not be
            sufficient for distributed transactions.)
        </p><p style="color:blue;">一个全局事务包含几个本身是事务性的操作，但这些操作要么作为一个组成功完成，要么作为一个组回滚。本质上，这将acid属性“扩展到一个级别”，以便多个acid事务可以作为同时具有acid属性的全局操作的组件一起执行。（与非分布式事务一样，如果应用程序对读取现象敏感，则可能首选可序列化的事务。对于分布式事务，可重复读取可能不够。）</p><p>
            Some examples of distributed transactions:
        </p><p style="color:blue;">分布式事务的一些示例：</p>
            <div class="itemizedlist">
                <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                    An application may act as an integration tool that combines a
                    messaging service with an RDBMS. The application makes sure
                    that transactions dealing with message sending, retrieval, and
                    processing that also involve a transactional database all
                    happen in a global transaction. You can think of this as
                    <span class="quote">“<span class="quote">transactional email.</span>”</span>
                </p><p style="color:blue;">应用程序可以充当集成工具，将消息传递服务与rdbms结合起来。应用程序确保处理消息发送、检索和处理的事务（也涉及事务数据库）都发生在全局事务中。你可以把它看作是“事务性电子邮件”。</p></li><li class="listitem"><p>
                    An application performs actions that involve different
                    database servers, such as a MySQL server and an Oracle server
                    (or multiple MySQL servers), where actions that involve
                    multiple servers must happen as part of a global transaction,
                    rather than as separate transactions local to each server.
                </p><p style="color:blue;">应用程序执行涉及不同数据库服务器的操作，例如mysql服务器和oracle服务器（或多个mysql服务器），其中涉及多个服务器的操作必须作为全局事务的一部分发生，而不是作为每个服务器本地的单独事务发生。</p></li><li class="listitem"><p>
                    A bank keeps account information in an RDBMS and distributes
                    and receives money through automated teller machines (ATMs).
                    It is necessary to ensure that ATM actions are correctly
                    reflected in the accounts, but this cannot be done with the
                    RDBMS alone. A global transaction manager integrates the ATM
                    and database resources to ensure overall consistency of
                    financial transactions.
                </p><p style="color:blue;">银行将账户信息保存在关系数据库中，并通过自动取款机（ATM）分配和接收资金。有必要确保ATM操作正确反映在帐户中，但这不能仅用RDBMS来完成。全局事务管理器集成ATM和数据库资源，以确保金融事务的总体一致性。</p></li></ul>
            </div>
            <p>
                Applications that use global transactions involve one or more
                Resource Managers and a Transaction Manager:
            </p><p style="color:blue;">使用全局事务的应用程序涉及一个或多个资源管理器和一个事务管理器：</p>
            <div class="itemizedlist">
                <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                    A Resource Manager (RM) provides access to transactional
                    resources. A database server is one kind of resource manager.
                    It must be possible to either commit or roll back transactions
                    managed by the RM.
                </p><p style="color:blue;">资源管理器（rm）提供对事务性资源的访问。数据库服务器是一种资源管理器。必须能够提交或回滚由rm管理的事务。</p></li><li class="listitem"><p>
                    A Transaction Manager (TM) coordinates the transactions that
                    are part of a global transaction. It communicates with the RMs
                    that handle each of these transactions. The individual
                    transactions within a global transaction are
                    <span class="quote">“<span class="quote">branches</span>”</span> of the global transaction. Global
                    transactions and their branches are identified by a naming
                    scheme described later.
                </p><p style="color:blue;">事务管理器（TM）协调作为全局事务一部分的事务。它与处理这些事务的rms通信。全局事务中的单个事务是全局事务的“分支”。全局事务及其分支由后面描述的命名方案标识。</p></li></ul>
            </div>
            <p>
                The MySQL implementation of XA enables a MySQL server to act as a
                Resource Manager that handles XA transactions within a global
                transaction. A client program that connects to the MySQL server
                acts as the Transaction Manager.
            </p><p style="color:blue;">xa的mysql实现允许mysql服务器充当处理全局事务中xa事务的资源管理器。连接到mysql服务器的客户端程序充当事务管理器。</p><p>
            To carry out a global transaction, it is necessary to know which
            components are involved, and bring each component to a point when
            it can be committed or rolled back. Depending on what each
            component reports about its ability to succeed, they must all
            commit or roll back as an atomic group. That is, either all
            components must commit, or all components must roll back. To
            manage a global transaction, it is necessary to take into account
            that any component or the connecting network might fail.
        </p><p style="color:blue;">要执行全局事务，必须知道涉及哪些组件，并使每个组件达到可以提交或回滚的程度。根据每个组件报告的成功能力，它们必须作为一个原子组提交或回滚。也就是说，要么所有组件都必须提交，要么所有组件都必须回滚。要管理全局事务，必须考虑到任何组件或连接网络都可能失败。</p><p>
            The process for executing a global transaction uses two-phase
            commit (2PC). This takes place after the actions performed by the
            branches of the global transaction have been executed.
        </p><p style="color:blue;">执行全局事务的过程使用两阶段提交（2pc）。这发生在执行了全局事务分支执行的操作之后。</p>
            <div class="orderedlist">
                <ol class="orderedlist" type="1"><li class="listitem"><p>
                    In the first phase, all branches are prepared. That is, they
                    are told by the TM to get ready to commit. Typically, this
                    means each RM that manages a branch records the actions for
                    the branch in stable storage. The branches indicate whether
                    they are able to do this, and these results are used for the
                    second phase.
                </p><p style="color:blue;">在第一阶段，所有分支都准备好了。也就是说，TM告诉他们要做好承诺的准备。通常，这意味着管理分支的每个rm都会在稳定存储中记录分支的操作。分支指示它们是否能够做到这一点，这些结果用于第二阶段。</p></li><li class="listitem"><p>
                    In the second phase, the TM tells the RMs whether to commit or
                    roll back. If all branches indicated when they were prepared
                    that they will be able to commit, all branches are told to
                    commit. If any branch indicated when it was prepared that it
                    will not be able to commit, all branches are told to roll
                    back.
                </p><p style="color:blue;">在第二阶段，TM告诉rms是提交还是回滚。如果所有分支在准备就绪时都指示可以提交，则所有分支都将被告知提交。如果任何分支在准备时指示它将无法提交，则通知所有分支回滚。</p></li></ol>
            </div>
            <p>
                In some cases, a global transaction might use one-phase commit
                (1PC). For example, when a Transaction Manager finds that a global
                transaction consists of only one transactional resource (that is,
                a single branch), that resource can be told to prepare and commit
                at the same time.
            </p><p style="color:blue;">在某些情况下，全局事务可能使用一阶段提交（1pc）。例如，当事务管理器发现全局事务仅由一个事务资源（即单个分支）组成时，可以告诉该资源同时准备和提交。</p>
            <div class="section">

                <div class="titlepage">
                    <div>
                        <div>
                            <h4 class="title"><a name="xa-statements"></a>13.3.7.1&nbsp;XA Transaction SQL Syntax</h4>
                        </div>
                    </div>
                </div>
                <a class="indexterm" name="idm140286832843776"></a><a class="indexterm" name="idm140286832842736"></a><a class="indexterm" name="idm140286832841248"></a><a class="indexterm" name="idm140286832840176"></a><a class="indexterm" name="idm140286832838688"></a><a class="indexterm" name="idm140286832837616"></a><a class="indexterm" name="idm140286832836128"></a><a class="indexterm" name="idm140286832835056"></a><a class="indexterm" name="idm140286832833568"></a><a class="indexterm" name="idm140286832832496"></a><a class="indexterm" name="idm140286832831008"></a><a class="indexterm" name="idm140286832829936"></a><a class="indexterm" name="idm140286832828448"></a><a class="indexterm" name="idm140286832826976"></a><p>
                To perform XA transactions in MySQL, use the following
                statements:
            </p><p style="color:blue;">要在mysql中执行xa事务，请使用以下语句：</p><pre data-lang="sql" class="programlisting">XA {START|BEGIN} <em class="replaceable"><code>xid</code></em> [JOIN|RESUME]

XA END <em class="replaceable"><code>xid</code></em> [SUSPEND [FOR MIGRATE]]

XA PREPARE <em class="replaceable"><code>xid</code></em>

XA COMMIT <em class="replaceable"><code>xid</code></em> [ONE PHASE]

XA ROLLBACK <em class="replaceable"><code>xid</code></em>

XA RECOVER [CONVERT XID]
</pre><p>
                For <a class="link" href="sql-syntax.html#xa-statements" title="13.3.7.1&nbsp;XA Transaction SQL Syntax"><code class="literal">XA
                START</code></a>, the <code class="literal">JOIN</code> and
                <code class="literal">RESUME</code> clauses are recognized but have no
                effect.
            </p><p style="color:blue;">对于xa start，join和resume子句被识别，但不起作用。</p><p>
                For <a class="link" href="sql-syntax.html#xa-statements" title="13.3.7.1&nbsp;XA Transaction SQL Syntax"><code class="literal">XA
                END</code></a> the <code class="literal">SUSPEND [FOR MIGRATE]</code>
                clause is recognized but has no effect.
            </p><p style="color:blue;">对于xa end，suspend[for migrate]子句已被识别，但没有任何效果。</p><p>
                Each XA statement begins with the <code class="literal">XA</code> keyword,
                and most of them require an <em class="replaceable"><code>xid</code></em>
                value. An <em class="replaceable"><code>xid</code></em> is an XA transaction
                identifier. It indicates which transaction the statement applies
                to. <em class="replaceable"><code>xid</code></em> values are supplied by the
                client, or generated by the MySQL server. An
                <em class="replaceable"><code>xid</code></em> value has from one to three
                parts:
            </p><p style="color:blue;">每个XA语句都以XA关键字开始，并且大多数都需要XID值。XID是XA事务标识符。它指示语句应用于哪个事务。XID值由客户端提供，或由MySQL服务器生成。XID值有一至三个部分：</p><pre data-lang="none" class="programlisting"><em class="replaceable"><code>xid</code></em>: <em class="replaceable"><code>gtrid</code></em> [, <em class="replaceable"><code>bqual</code></em> [, <em class="replaceable"><code>formatID</code></em> ]]
</pre><p>
                <em class="replaceable"><code>gtrid</code></em> is a global transaction
                identifier, <em class="replaceable"><code>bqual</code></em> is a branch
                qualifier, and <em class="replaceable"><code>formatID</code></em> is a number
                that identifies the format used by the
                <em class="replaceable"><code>gtrid</code></em> and
                <em class="replaceable"><code>bqual</code></em> values. As indicated by the
                syntax, <em class="replaceable"><code>bqual</code></em> and
                <em class="replaceable"><code>formatID</code></em> are optional. The default
                <em class="replaceable"><code>bqual</code></em> value is <code class="literal">''</code>
                if not given. The default <em class="replaceable"><code>formatID</code></em>
                value is 1 if not given.
            </p><p style="color:blue;">gtrid是全局事务标识符，bqual是分支限定符，formatid是标识gtrid和bqual值使用的格式的数字。如语法所示，bqual和formatid是可选的。如果未给定，则默认bqual值为''。如果未给定，则默认formatid值为1。</p><p>
                <em class="replaceable"><code>gtrid</code></em> and
                <em class="replaceable"><code>bqual</code></em> must be string literals, each
                up to 64 bytes (not characters) long.
                <em class="replaceable"><code>gtrid</code></em> and
                <em class="replaceable"><code>bqual</code></em> can be specified in several
                ways. You can use a quoted string (<code class="literal">'ab'</code>), hex
                string (<code class="literal">X'6162'</code>, <code class="literal">0x6162</code>),
                or bit value
                (<code class="literal">b'<em class="replaceable"><code>nnnn</code></em>'</code>).
            </p><p style="color:blue;">gtrid和bqual必须是字符串文本，每个文本最长为64字节（不是字符）。gtrid和bqual可以通过多种方式指定。可以使用带引号的字符串（“a b”）、十六进制字符串（x'6162'，0x 6162）或位值（b'nnnn'）。</p><p>
                <em class="replaceable"><code>formatID</code></em> is an unsigned integer.
            </p><p style="color:blue;">formatID是一个无符号整数。</p><p>
                The <em class="replaceable"><code>gtrid</code></em> and
                <em class="replaceable"><code>bqual</code></em> values are interpreted in bytes
                by the MySQL server's underlying XA support routines. However,
                while an SQL statement containing an XA statement is being
                parsed, the server works with some specific character set. To be
                safe, write <em class="replaceable"><code>gtrid</code></em> and
                <em class="replaceable"><code>bqual</code></em> as hex strings.
            </p><p style="color:blue;">gtrid和bqual值由mysql服务器的底层xa支持例程以字节为单位进行解释。但是，在分析包含xa语句的sql语句时，服务器使用一些特定的字符集。为了安全起见，将gtrid和bqual写成十六进制字符串。</p><p>
                <em class="replaceable"><code>xid</code></em> values typically are generated by
                the Transaction Manager. Values generated by one TM must be
                different from values generated by other TMs. A given TM must be
                able to recognize its own <em class="replaceable"><code>xid</code></em> values
                in a list of values returned by the
                <a class="link" href="sql-syntax.html#xa-statements" title="13.3.7.1&nbsp;XA Transaction SQL Syntax"><code class="literal">XA
                    RECOVER</code></a> statement.
            </p><p style="color:blue;">XID值通常由事务管理器生成。一个TM生成的值必须与其他TM生成的值不同。给定的TM必须能够在XA Rebug语句返回的值列表中识别其自己的XID值。</p><p>
                <a class="link" href="sql-syntax.html#xa-statements" title="13.3.7.1&nbsp;XA Transaction SQL Syntax"><code class="literal">XA START
                    <em class="replaceable"><code>xid</code></em></code></a> starts an XA
                transaction with the given <em class="replaceable"><code>xid</code></em> value.
                Each XA transaction must have a unique
                <em class="replaceable"><code>xid</code></em> value, so the value must not
                currently be used by another XA transaction. Uniqueness is
                assessed using the <em class="replaceable"><code>gtrid</code></em> and
                <em class="replaceable"><code>bqual</code></em> values. All following XA
                statements for the XA transaction must be specified using the
                same <em class="replaceable"><code>xid</code></em> value as that given in the
                <a class="link" href="sql-syntax.html#xa-statements" title="13.3.7.1&nbsp;XA Transaction SQL Syntax"><code class="literal">XA
                    START</code></a> statement. If you use any of those statements
                but specify an <em class="replaceable"><code>xid</code></em> value that does
                not correspond to some existing XA transaction, an error occurs.
            </p><p style="color:blue;">XA start XID使用给定的XID值启动XA事务。每个XA事务必须具有唯一的XID值，所以该值当前不能被另一个XA事务使用。使用gtrid和bqual值评估唯一性。XA事务的所有后续XA语句必须使用与XA开始语句中给出的相同的XID值来指定。如果使用这些语句中的任何一个，但指定与现有XA事务不对应的XID值，则会发生错误。</p><p>
                One or more XA transactions can be part of the same global
                transaction. All XA transactions within a given global
                transaction must use the same <em class="replaceable"><code>gtrid</code></em>
                value in the <em class="replaceable"><code>xid</code></em> value. For this
                reason, <em class="replaceable"><code>gtrid</code></em> values must be globally
                unique so that there is no ambiguity about which global
                transaction a given XA transaction is part of. The
                <em class="replaceable"><code>bqual</code></em> part of the
                <em class="replaceable"><code>xid</code></em> value must be different for each
                XA transaction within a global transaction. (The requirement
                that <em class="replaceable"><code>bqual</code></em> values be different is a
                limitation of the current MySQL XA implementation. It is not
                part of the XA specification.)
            </p><p style="color:blue;">一个或多个xa事务可以是同一全局事务的一部分。给定的全局事务中的所有XA事务都必须在XID值中使用相同的GTRID值。因此，gtrid值必须是全局唯一的，这样给定的xa事务所属的全局事务就不会有歧义。XID值的BQUAL部分对于全局事务中的每个XA事务必须是不同的。（要求bqual值不同是当前mysql xa实现的一个限制。它不是xa规范的一部分。）</p><p>
                The <a class="link" href="sql-syntax.html#xa-statements" title="13.3.7.1&nbsp;XA Transaction SQL Syntax"><code class="literal">XA
                RECOVER</code></a> statement returns information for those XA
                transactions on the MySQL server that are in the
                <code class="literal">PREPARED</code> state. (See
                <a class="xref" href="sql-syntax.html#xa-states" title="13.3.7.2&nbsp;XA Transaction States">Section&nbsp;13.3.7.2, “XA Transaction States”</a>.) The output includes a row for each
                such XA transaction on the server, regardless of which client
                started it.
            </p><p style="color:blue;">XA恢复语句返回在准备状态的MySQL服务器上的那些XA事务的信息。（见第13.3.7.2节，“xa事务状态”）输出包括服务器上每个此类xa事务的一行，而不管是哪个客户端启动的。</p><p>
                <a class="link" href="sql-syntax.html#xa-statements" title="13.3.7.1&nbsp;XA Transaction SQL Syntax"><code class="literal">XA
                    RECOVER</code></a> output rows look like this (for an example
                <em class="replaceable"><code>xid</code></em> value consisting of the parts
                <code class="literal">'abc'</code>, <code class="literal">'def'</code>, and
                <code class="literal">7</code>):
            </p><p style="color:blue;">XA恢复输出行，如下所示（例如一个包含部分“ABC”、“DEF”和7）的值：</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>XA RECOVER;</code></strong>
+----------+--------------+--------------+--------+
| formatID | gtrid_length | bqual_length | data   |
+----------+--------------+--------------+--------+
|        7 |            3 |            3 | abcdef |
+----------+--------------+--------------+--------+
</pre><p>
                The output columns have the following meanings:
            </p><p style="color:blue;">输出列具有以下含义：</p>
                <div class="itemizedlist">
                    <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                        <code class="literal">formatID</code> is the
                        <em class="replaceable"><code>formatID</code></em> part of the transaction
                        <em class="replaceable"><code>xid</code></em>
                    </p><p style="color:blue;">格式是交易XID的组成部分。</p></li><li class="listitem"><p>
                        <code class="literal">gtrid_length</code> is the length in bytes of
                        the <em class="replaceable"><code>gtrid</code></em> part of the
                        <em class="replaceable"><code>xid</code></em>
                    </p><p style="color:blue;">GTIDIDL长度是XID的GRID部分的字节长度。</p></li><li class="listitem"><p>
                        <code class="literal">bqual_length</code> is the length in bytes of
                        the <em class="replaceable"><code>bqual</code></em> part of the
                        <em class="replaceable"><code>xid</code></em>
                    </p><p style="color:blue;">BQualthLead是XID的BQUAL部分的字节长度。</p></li><li class="listitem"><p>
                        <code class="literal">data</code> is the concatenation of the
                        <em class="replaceable"><code>gtrid</code></em> and
                        <em class="replaceable"><code>bqual</code></em> parts of the
                        <em class="replaceable"><code>xid</code></em>
                    </p><p style="color:blue;">数据是XID的GTRID和BQUAL部分的级联。</p></li></ul>
                </div>
                <p>
                    XID values may contain nonprintable characters. As of MySQL
                    5.7.5, <a class="link" href="sql-syntax.html#xa-statements" title="13.3.7.1&nbsp;XA Transaction SQL Syntax"><code class="literal">XA
                    RECOVER</code></a> permits an optional <code class="literal">CONVERT
                    XID</code> clause so that clients can request XID values in
                    hexadecimal.
                </p><p style="color:blue;">xid值可能包含不可打印的字符。从mysql 5.7.5开始，xa recover允许一个可选的convert xid子句，以便客户机可以十六进制形式请求xid值。</p>
            </div>
            <div class="section">
                <div class="titlepage">
                    <div>
                        <div>
                            <h4 class="title"><a name="xa-states"></a>13.3.7.2&nbsp;XA Transaction States</h4>

                        </div>

                    </div>

                </div>
                <p>
                    An XA transaction progresses through the following states:
                </p><p style="color:blue;">xa事务通过以下状态进行：</p>
                <div class="orderedlist">
                    <ol class="orderedlist" type="1"><li class="listitem"><p>
                        Use <a class="link" href="sql-syntax.html#xa-statements" title="13.3.7.1&nbsp;XA Transaction SQL Syntax"><code class="literal">XA
                        START</code></a> to start an XA transaction and put it in the
                        <code class="literal">ACTIVE</code> state.
                    </p><p style="color:blue;">使用xa start启动xa事务并将其置于活动状态。</p></li><li class="listitem"><p>
                        For an <code class="literal">ACTIVE</code> XA transaction, issue the
                        SQL statements that make up the transaction, and then issue
                        an <a class="link" href="sql-syntax.html#xa-statements" title="13.3.7.1&nbsp;XA Transaction SQL Syntax"><code class="literal">XA
                        END</code></a> statement.
                        <a class="link" href="sql-syntax.html#xa-statements" title="13.3.7.1&nbsp;XA Transaction SQL Syntax"><code class="literal">XA
                            END</code></a> puts the transaction in the
                        <code class="literal">IDLE</code> state.
                    </p><p style="color:blue;">对于活动的xa事务，发出组成该事务的sql语句，然后发出xa end语句。xa end将事务置于空闲状态。</p></li><li class="listitem"><p>
                        For an <code class="literal">IDLE</code> XA transaction, you can issue
                        either an <a class="link" href="sql-syntax.html#xa-statements" title="13.3.7.1&nbsp;XA Transaction SQL Syntax"><code class="literal">XA
                        PREPARE</code></a> statement or an <code class="literal">XA COMMIT ... ONE
                        PHASE</code> statement:
                    </p><p style="color:blue;">对于空闲的XA事务，可以发布XA准备语句或XA提交…一期声明：</p>
                        <div class="itemizedlist">
                            <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                                <a class="link" href="sql-syntax.html#xa-statements" title="13.3.7.1&nbsp;XA Transaction SQL Syntax"><code class="literal">XA
                                    PREPARE</code></a> puts the transaction in the
                                <code class="literal">PREPARED</code> state. An
                                <a class="link" href="sql-syntax.html#xa-statements" title="13.3.7.1&nbsp;XA Transaction SQL Syntax"><code class="literal">XA
                                    RECOVER</code></a> statement at this point will include
                                the transaction's <em class="replaceable"><code>xid</code></em> value
                                in its output, because
                                <a class="link" href="sql-syntax.html#xa-statements" title="13.3.7.1&nbsp;XA Transaction SQL Syntax"><code class="literal">XA
                                    RECOVER</code></a> lists all XA transactions that are in
                                the <code class="literal">PREPARED</code> state.
                            </p><p style="color:blue;">XA准备将事务置于准备状态。此时的XA恢复语句将包括事务在其输出中的XID值，因为XA Read列出了处于准备状态的所有XA事务。</p></li><li class="listitem"><p>
                                <code class="literal">XA COMMIT ... ONE PHASE</code> prepares and
                                commits the transaction. The
                                <em class="replaceable"><code>xid</code></em> value will not be listed
                                by <a class="link" href="sql-syntax.html#xa-statements" title="13.3.7.1&nbsp;XA Transaction SQL Syntax"><code class="literal">XA
                                RECOVER</code></a> because the transaction terminates.
                            </p><p style="color:blue;">xa提交…一个阶段准备并提交事务。由于事务终止，XID值不会被XA Read列出。</p></li></ul>
                        </div>
                    </li><li class="listitem"><p>
                        For a <code class="literal">PREPARED</code> XA transaction, you can
                        issue an <a class="link" href="sql-syntax.html#xa-statements" title="13.3.7.1&nbsp;XA Transaction SQL Syntax"><code class="literal">XA
                        COMMIT</code></a> statement to commit and terminate the
                        transaction, or
                        <a class="link" href="sql-syntax.html#xa-statements" title="13.3.7.1&nbsp;XA Transaction SQL Syntax"><code class="literal">XA
                            ROLLBACK</code></a> to roll back and terminate the
                        transaction.
                    </p><p style="color:blue;">对于已准备好的XA事务，可以发出XA提交语句来提交和终止事务，或XA回滚回滚和终止事务。</p></li></ol>
                </div>
                <p>
                    Here is a simple XA transaction that inserts a row into a table
                    as part of a global transaction:
                </p><p style="color:blue;">下面是一个简单的xa事务，它将一行作为全局事务的一部分插入到表中：</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>XA START 'xatest';</code></strong>
Query OK, 0 rows affected (0.00 sec)

mysql&gt; <strong class="userinput"><code>INSERT INTO mytable (i) VALUES(10);</code></strong>
Query OK, 1 row affected (0.04 sec)

mysql&gt; <strong class="userinput"><code>XA END 'xatest';</code></strong>
Query OK, 0 rows affected (0.00 sec)

mysql&gt; <strong class="userinput"><code>XA PREPARE 'xatest';</code></strong>
Query OK, 0 rows affected (0.00 sec)

mysql&gt; <strong class="userinput"><code>XA COMMIT 'xatest';</code></strong>
Query OK, 0 rows affected (0.00 sec)
</pre><p>
                Within the context of a given client connection, XA transactions
                and local (non-XA) transactions are mutually exclusive. For
                example, if <a class="link" href="sql-syntax.html#xa-statements" title="13.3.7.1&nbsp;XA Transaction SQL Syntax"><code class="literal">XA
                START</code></a> has been issued to begin an XA transaction, a
                local transaction cannot be started until the XA transaction has
                been committed or rolled back. Conversely, if a local
                transaction has been started with
                <a class="link" href="sql-syntax.html#commit" title="13.3.1&nbsp;START TRANSACTION, COMMIT, and ROLLBACK Syntax"><code class="literal">START
                    TRANSACTION</code></a>, no XA statements can be used until the
                transaction has been committed or rolled back.
            </p><p style="color:blue;">在给定客户机连接的上下文中，xa事务和本地（非xa）事务是互斥的。例如，如果已发出xa start以开始xa事务，则在提交或回滚xa事务之前，无法启动本地事务。相反，如果本地事务是用start transaction启动的，则在提交或回滚事务之前，不能使用xa语句。</p><p>
                If an XA transaction is in the <code class="literal">ACTIVE</code> state,
                you cannot issue any statements that cause an implicit commit.
                That would violate the XA contract because you could not roll
                back the XA transaction. You will receive the following error if
                you try to execute such a statement:
            </p><p style="color:blue;">如果xa事务处于活动状态，则不能发出任何导致隐式提交的语句。这将违反xa契约，因为您无法回滚xa事务。如果您尝试执行这样的语句，将收到以下错误：</p><pre data-lang="none" class="programlisting">ERROR 1399 (XAE07): XAER_RMFAIL: The command cannot be executed
when global transaction is in the ACTIVE state
</pre><p>
                Statements to which the preceding remark applies are listed at
                <a class="xref" href="sql-syntax.html#implicit-commit" title="13.3.3&nbsp;Statements That Cause an Implicit Commit">Section&nbsp;13.3.3, “Statements That Cause an Implicit Commit”</a>.
            </p><p style="color:blue;">上文所述适用的语句列在第13.3.3节“导致隐式提交的语句”中。</p>
            </div>
            <div class="section">
                <div class="titlepage">
                    <div>
                        <div>
                            <h4 class="title"><a name="xa-restrictions"></a>13.3.7.3&nbsp;Restrictions on XA Transactions</h4>

                        </div>

                    </div>

                </div>
                <a class="indexterm" name="idm140286832715712"></a><a class="indexterm" name="idm140286832714256"></a><p>
                XA transaction support is limited to the
                <code class="literal">InnoDB</code> storage engine.
            </p><p style="color:blue;">xa事务支持仅限于innodb存储引擎。</p><p>
                For <span class="quote">“<span class="quote">external XA,</span>”</span> a MySQL server acts as a
                Resource Manager and client programs act as Transaction
                Managers. For <span class="quote">“<span class="quote">Internal XA</span>”</span>, storage engines within
                a MySQL server act as RMs, and the server itself acts as a TM.
                Internal XA support is limited by the capabilities of individual
                storage engines. Internal XA is required for handling XA
                transactions that involve more than one storage engine. The
                implementation of internal XA requires that a storage engine
                support two-phase commit at the table handler level, and
                currently this is true only for <code class="literal">InnoDB</code>.
            </p><p style="color:blue;">对于“外部xa”，mysql服务器充当资源管理器，客户机程序充当事务管理器。对于“内部xa”，mysql服务器中的存储引擎充当rms，服务器本身充当tm。内部xa支持受到单个存储引擎功能的限制。处理涉及多个存储引擎的xa事务需要内部xa。内部xa的实现要求存储引擎在表处理程序级别支持两阶段提交，目前这只适用于innodb。</p><p>
                For <a class="link" href="sql-syntax.html#xa-statements" title="13.3.7.1&nbsp;XA Transaction SQL Syntax"><code class="literal">XA
                START</code></a>, the <code class="literal">JOIN</code> and
                <code class="literal">RESUME</code> clauses are recognized but have no
                effect.
            </p><p style="color:blue;">对于xa start，join和resume子句被识别，但不起作用。</p><p>
                For <a class="link" href="sql-syntax.html#xa-statements" title="13.3.7.1&nbsp;XA Transaction SQL Syntax"><code class="literal">XA
                END</code></a> the <code class="literal">SUSPEND [FOR MIGRATE]</code>
                clause is recognized but has no effect.
            </p><p style="color:blue;">对于xa end，suspend[for migrate]子句已被识别，但没有任何效果。</p><p>
                The requirement that the <em class="replaceable"><code>bqual</code></em> part
                of the <em class="replaceable"><code>xid</code></em> value be different for
                each XA transaction within a global transaction is a limitation
                of the current MySQL XA implementation. It is not part of the XA
                specification.
            </p><p style="color:blue;">XID值的BQUAL部分对于全局事务中的每个XA事务不同的要求是当前MySQL XA实现的限制。它不是xa规范的一部分。</p><p>
                Prior to MySQL 5.7.7, XA transactions were not compatible with
                replication. This was because an XA transaction that was in
                <code class="literal">PREPARED</code> state would be rolled back on clean
                server shutdown or client disconnect. Similarly, an XA
                transaction that was in <code class="literal">PREPARED</code> state would
                still exist in <code class="literal">PREPARED</code> state in case the
                server was shutdown abnormally and then started again, but the
                contents of the transaction could not be written to the binary
                log. In both of these situations the XA transaction could not be
                replicated correctly.
            </p><p style="color:blue;">在mysql 5.7.7之前，xa事务与复制不兼容。这是因为处于准备状态的XA事务将被回滚到干净服务器关机或客户端断开连接上。类似地，准备状态下的XA事务仍然存在于准备状态中，以防止服务器异常关闭，然后再次启动，但事务的内容不能写入二进制日志。在这两种情况下，都无法正确复制xa事务。</p><p>
                In MySQL 5.7.7 and later, there is a change in behavior and an
                XA transaction is written to the binary log in two parts. When
                <code class="literal">XA PREPARE </code> is issued, the first part of the
                transaction up to <code class="literal">XA PREPARE</code> is written using
                an initial GTID. A <code class="literal">XA_prepare_log_event</code> is
                used to identify such transactions in the binary log. When
                <code class="literal">XA COMMIT</code> or <code class="literal">XA ROLLBACK</code>
                is issued, a second part of the transaction containing only the
                <code class="literal">XA COMMIT</code> or <code class="literal">XA ROLLBACK</code>
                statement is written using a second GTID. Note that the initial
                part of the transaction, identified by
                <code class="literal">XA_prepare_log_event</code>, is not necessarily
                followed by its <code class="literal">XA COMMIT</code> or <code class="literal">XA
                ROLLBACK</code>, which can cause interleaved binary logging
                of any two XA transactions. The two parts of the XA transaction
                can even appear in different binary log files. This means that
                an XA transaction in <code class="literal">PREPARED</code> state is now
                persistent until an explicit <code class="literal">XA COMMIT</code> or
                <code class="literal">XA ROLLBACK</code> statement is issued, ensuring
                that XA transactions are compatible with replication.
            </p><p style="color:blue;">在mysql 5.7.7及更高版本中，行为发生了变化，xa事务分两部分写入二进制日志。当发出XA准备时，使用初始GTID写入到XA准备的事务的第一部分。xa_prepare_log_事件用于在二进制日志中标识此类事务。当发出xa commit或xa rollback时，使用第二个gtid编写事务的第二部分，其中只包含xa commit或xa rollback语句。请注意，由xa_prepare_log_事件标识的事务的初始部分不一定后跟其xa commit或xa rollback，这可能会导致任意两个xa事务的交错二进制日志记录。xa事务的两部分甚至可以出现在不同的二进制日志文件中。这意味着在准备状态下的XA事务现在是持久的，直到发出明确的XA提交或XA回滚语句为止，确保XA事务与复制兼容。</p><p>
                On a replication slave, immediately after the XA transaction is
                prepared, it is detached from the slave applier thread, and can
                be committed or rolled back by any thread on the slave. This
                means that the same XA transaction can appear in the
                <a class="link" href="performance-schema.html#events-transactions-current-table" title="25.12.7.1&nbsp;The events_transactions_current Table"><code class="literal">events_transactions_current</code></a> table
                with different states on different threads. The
                <a class="link" href="performance-schema.html#events-transactions-current-table" title="25.12.7.1&nbsp;The events_transactions_current Table"><code class="literal">events_transactions_current</code></a> table
                displays the current status of the most recent monitored
                transaction event on the thread, and does not update this status
                when the thread is idle. So the XA transaction can still be
                displayed in the <code class="literal">PREPARED</code> state for the
                original applier thread, after it has been processed by another
                thread. To positively identify XA transactions that are still in
                the <code class="literal">PREPARED</code> state and need to be recovered,
                use the <a class="link" href="sql-syntax.html#xa-statements" title="13.3.7.1&nbsp;XA Transaction SQL Syntax"><code class="literal">XA
                RECOVER</code></a> statement rather than the Performance Schema
                transaction tables.
            </p><p style="color:blue;">在复制从机上，在准备好xa事务之后，它会立即从从机applier线程中分离出来，并且可以由从机上的任何线程提交或回滚。这意味着同一个xa事务可以出现在events_transactions_current表中，在不同的线程上具有不同的状态。events_transactions_current表显示线程上最近监视的事务事件的当前状态，并且在线程空闲时不更新此状态。因此，XA事务仍然可以在准备好的状态下为原始的应用程序线程显示，在它被另一个线程处理之后。若要积极识别仍处于准备状态且需要恢复的XA事务，请使用XA Rebug语句，而不使用性能模式事务表。</p><p>
                The following restrictions exist for using XA transactions in
                MySQL 5.7.7 and later:
            </p><p style="color:blue;">在MySQL 5.7.7和以后使用XA事务存在以下限制：</p>
                <div class="itemizedlist">
                    <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                        XA transactions are not fully resilient to an unexpected
                        halt with respect to the binary log. If there is an
                        unexpected halt while the server is in the middle of
                        executing an <code class="literal">XA PREPARE</code>, <code class="literal">XA
                        COMMIT</code>, <code class="literal">XA ROLLBACK</code>, or
                        <code class="literal">XA COMMIT ... ONE PHASE</code> statement, the
                        server might not be able to recover to a correct state,
                        leaving the server and the binary log in an inconsistent
                        state. In this situation, the binary log might either
                        contain extra XA transactions that are not applied, or miss
                        XA transactions that are applied. Also, if GTIDs are
                        enabled, after recovery
                        <code class="literal">@@GLOBAL.GTID_EXECUTED</code> might not
                        correctly describe the transactions that have been applied.
                        Note that if an unexpected halt occurs before <code class="literal">XA
                        PREPARE</code>, between <code class="literal">XA PREPARE</code> and
                        <code class="literal">XA COMMIT</code> (or <code class="literal">XA
                        ROLLBACK</code>), or after <code class="literal">XA COMMIT</code>
                        (or <code class="literal">XA ROLLBACK</code>), the server and binary
                        log are correctly recovered and taken to a consistent state.
                    </p><p style="color:blue;">xa事务不能完全适应二进制日志的意外停止。如果服务器正在执行XA准备、XA提交、XA回滚或XA提交的过程中出现意外停机，那么…一个阶段语句，服务器可能无法恢复到正确的状态，从而使服务器和二进制日志处于不一致的状态。在这种情况下，二进制日志可能包含未应用的额外xa事务，或者未应用的xa事务。此外，如果启用了gtid，则在执行recovery@global.gtid后，可能无法正确描述已应用的事务。注意，如果在XA准备之前、XA准备和XA提交（或XA回滚）之间或XA提交（或XA回滚）之后出现意外停机，服务器和二进制日志被正确地恢复并被带到一致的状态。</p></li><li class="listitem"><p>
                        The use of replication filters or binary log filters in
                        combination with XA transactions is not supported. Filtering
                        of tables could cause an XA transaction to be empty on a
                        replication slave, and empty XA transactions are not
                        supported. Also, with the settings
                        <a class="link" href="replication.html#sysvar_master_info_repository"><code class="literal">master_info_repository=TABLE</code></a>
                        and
                        <a class="link" href="replication.html#sysvar_relay_log_info_repository"><code class="literal">relay_log_info_repository=TABLE</code></a>
                        on a replication slave, which became the defaults in MySQL
                        8.0, the internal state of the data engine transaction is
                        changed following a filtered XA transaction, and can become
                        inconsistent with the replication transaction context state.
                    </p><p style="color:blue;">不支持将复制筛选器或二进制日志筛选器与xa事务结合使用。筛选表可能导致复制从机上的xa事务为空，并且不支持空的xa事务。此外，在复制从服务器上设置master_info_repository=table和relay_log_info_repository=table（这在mysql 8.0中已成为默认设置）时，数据引擎事务的内部状态将在筛选的xa事务之后更改，并且可能与复制事务上下文状态不一致。</p><p>
                        The error
                        <a class="link" href="error-handling.html#error_er_xa_replication_filters"><code class="literal">ER_XA_REPLICATION_FILTERS</code></a> is
                        logged whenever an XA transaction is impacted by a
                        replication filter, whether or not the transaction was empty
                        as a result. If the transaction is not empty, the
                        replication slave is able to continue running, but you
                        should take steps to discontinue the use of replication
                        filters with XA transactions in order to avoid potential
                        issues. If the transaction is empty, the replication slave
                        stops. In that event, the replication slave might be in an
                        undetermined state in which the consistency of the
                        replication process might be compromised. In particular, the
                        <code class="literal">gtid_executed</code> set on a slave of the slave
                        might be inconsistent with that on the master. To resolve
                        this situation, isolate the master and stop all replication,
                        then check GTID consistency across the replication topology.
                        Undo the XA transaction that generated the error message,
                        then restart replication.
                    </p><p style="color:blue;">每当一个xa事务受到复制筛选器的影响时，无论该事务是否因此为空，都会记录error er_xa_replication_filters。如果事务不是空的，复制从机可以继续运行，但是您应该采取步骤停止对xa事务使用复制筛选器，以避免潜在的问题。如果事务为空，则复制从机停止。在这种情况下，复制从机可能处于不确定状态，在这种状态下，复制过程的一致性可能会受到损害。特别是，在从机的从机上执行的gtid_可能与在主机上执行的gtid_不一致。要解决此情况，请隔离主服务器并停止所有复制，然后检查复制拓扑中的gtid一致性。撤消生成错误消息的xa事务，然后重新启动复制。</p></li><li class="listitem"><p>
                        Prior to MySQL 5.7.19, <a class="link" href="sql-syntax.html#flush-tables-with-read-lock"><code class="literal">FLUSH TABLES
                        WITH READ LOCK</code></a> is not compatible with XA
                        transactions.
                    </p><p style="color:blue;">在mysql 5.7.19之前，带有读锁的flush表与xa事务不兼容。</p></li><li class="listitem"><p>
                        XA transactions are considered unsafe for statement-based
                        replication. If two XA transactions committed in parallel on
                        the master are being prepared on the slave in the inverse
                        order, locking dependencies can occur that cannot be safely
                        resolved, and it is possible for replication to fail with
                        deadlock on the slave. This situation can occur for a
                        single-threaded or multithreaded replication slave. When
                        <a class="link" href="replication.html#sysvar_binlog_format"><code class="literal">binlog_format=STATEMENT</code></a> is
                        set, a warning is issued for DML statements inside XA
                        transactions. When
                        <a class="link" href="replication.html#sysvar_binlog_format"><code class="literal">binlog_format=MIXED</code></a> or
                        <a class="link" href="replication.html#sysvar_binlog_format"><code class="literal">binlog_format=ROW</code></a> is set,
                        DML statements inside XA transactions are logged using
                        row-based replication, and the potential issue is not
                        present.
                    </p><p style="color:blue;">对于基于语句的复制，xa事务被认为是不安全的。如果在主服务器上并行提交的两个xa事务正以相反的顺序在从服务器上准备，则可能会发生无法安全解决的锁定依赖关系，并且复制可能会在从服务器上死锁的情况下失败。这种情况可能发生在单线程或多线程复制从机上。当设置binlog_format=语句时，将对xa事务中的dml语句发出警告。当设置binlog_format=mixed或binlog_format=row时，使用基于行的复制记录xa事务中的dml语句，并且不存在潜在的问题。</p></li></ul>
                </div>

            </div>

        </div>

    </div>
    <div class="section">
        <div class="titlepage">
            <div>
                <div>
                    <h2 class="title" style="clear: both"><a name="sql-syntax-replication"></a>13.4&nbsp;Replication Statements</h2>

                </div>

            </div>

        </div>
        <div class="toc">
            <dl class="toc"><dt><span class="section"><a href="sql-syntax.html#replication-master-sql">13.4.1 SQL Statements for Controlling Master Servers</a></span></dt><dt><span class="section"><a href="sql-syntax.html#replication-slave-sql">13.4.2 SQL Statements for Controlling Slave Servers</a></span></dt><dt><span class="section"><a href="sql-syntax.html#replication-group-sql">13.4.3 SQL Statements for Controlling Group Replication</a></span></dt></dl>
        </div>
        <p>
            Replication can be controlled through the SQL interface using the
            statements described in this section. Statements are split into a
            group which controls master servers, a group which controls slave
            servers, and a group which can be applied to any replication
            servers.
        </p><p style="color:blue;">可以使用本节中描述的语句通过sql接口控制复制。语句分为控制主服务器的组、控制从服务器的组和可应用于任何复制服务器的组。</p>
        <div class="section">

            <div class="titlepage">
                <div>
                    <div>
                        <h3 class="title"><a name="replication-master-sql"></a>13.4.1&nbsp;SQL Statements for Controlling Master Servers</h3>

                    </div>

                </div>

            </div>

            <div class="toc">
                <dl class="toc"><dt><span class="section"><a href="sql-syntax.html#purge-binary-logs">13.4.1.1 PURGE BINARY LOGS Syntax</a></span></dt><dt><span class="section"><a href="sql-syntax.html#reset-master">13.4.1.2 RESET MASTER Syntax</a></span></dt><dt><span class="section"><a href="sql-syntax.html#set-sql-log-bin">13.4.1.3 SET sql_log_bin Syntax</a></span></dt></dl>
            </div>
            <a class="indexterm" name="idm140286832651536"></a><a class="indexterm" name="idm140286832650080"></a><a class="indexterm" name="idm140286832648592"></a><p>
            This section discusses statements for managing master replication
            servers. <a class="xref" href="sql-syntax.html#replication-slave-sql" title="13.4.2&nbsp;SQL Statements for Controlling Slave Servers">Section&nbsp;13.4.2, “SQL Statements for Controlling Slave Servers”</a>, discusses
            statements for managing slave servers.
        </p><p style="color:blue;">本节讨论用于管理主复制服务器的语句。第13.4.2节“用于控制从属服务器的SQL语句”讨论了用于管理从属服务器的语句。</p><p>
            In addition to the statements described here, the following
            <a class="link" href="sql-syntax.html#show" title="13.7.5&nbsp;SHOW Syntax"><code class="literal">SHOW</code></a> statements are used with
            master servers in replication. For information about these
            statements, see <a class="xref" href="sql-syntax.html#show" title="13.7.5&nbsp;SHOW Syntax">Section&nbsp;13.7.5, “SHOW Syntax”</a>.
        </p><p style="color:blue;">除了这里描述的语句之外，以下show语句还用于复制中的主服务器。有关这些语句的信息，请参见第13.7.5节“显示语法”。</p>
            <div class="itemizedlist">
                <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                    <a class="link" href="sql-syntax.html#show-binary-logs" title="13.7.5.1&nbsp;SHOW BINARY LOGS Syntax"><code class="literal">SHOW BINARY LOGS</code></a>
                </p><p style="color:blue;">显示二进制日志</p></li><li class="listitem"><p>
                    <a class="link" href="sql-syntax.html#show-binlog-events" title="13.7.5.2&nbsp;SHOW BINLOG EVENTS Syntax"><code class="literal">SHOW BINLOG EVENTS</code></a>
                </p><p style="color:blue;">显示binlog事件</p></li><li class="listitem"><p>
                    <a class="link" href="sql-syntax.html#show-master-status" title="13.7.5.23&nbsp;SHOW MASTER STATUS Syntax"><code class="literal">SHOW MASTER STATUS</code></a>
                </p><p style="color:blue;">显示主状态</p></li><li class="listitem"><p>
                    <a class="link" href="sql-syntax.html#show-slave-hosts" title="13.7.5.33&nbsp;SHOW SLAVE HOSTS Syntax"><code class="literal">SHOW SLAVE HOSTS</code></a>
                </p><p style="color:blue;">显示从属主机</p></li></ul>
            </div>
            <div class="section">
                <div class="titlepage">
                    <div>
                        <div>
                            <h4 class="title"><a name="purge-binary-logs"></a>13.4.1.1&nbsp;PURGE BINARY LOGS Syntax</h4>

                        </div>

                    </div>

                </div>
                <a class="indexterm" name="idm140286832633888"></a><a class="indexterm" name="idm140286832632848"></a><pre data-lang="sql" class="programlisting">PURGE { BINARY | MASTER } LOGS {
    TO '<em class="replaceable"><code>log_name</code></em>'
  | BEFORE <em class="replaceable"><code>datetime_expr</code></em>
}
</pre><p>
                The binary log is a set of files that contain information about
                data modifications made by the MySQL server. The log consists of
                a set of binary log files, plus an index file (see
                <a class="xref" href="server-administration.html#binary-log" title="5.4.4&nbsp;The Binary Log">Section&nbsp;5.4.4, “The Binary Log”</a>).
            </p><p style="color:blue;">二进制日志是一组文件，其中包含有关mysql服务器所做数据修改的信息。日志由一组二进制日志文件和一个索引文件组成（参见第5.4.4节“二进制日志”）。</p><p>
                The <a class="link" href="sql-syntax.html#purge-binary-logs" title="13.4.1.1&nbsp;PURGE BINARY LOGS Syntax"><code class="literal">PURGE BINARY LOGS</code></a> statement
                deletes all the binary log files listed in the log index file
                prior to the specified log file name or date.
                <code class="literal">BINARY</code> and <code class="literal">MASTER</code> are
                synonyms. Deleted log files also are removed from the list
                recorded in the index file, so that the given log file becomes
                the first in the list.
            </p><p style="color:blue;">清除二进制日志语句删除指定日志文件名或日期之前日志索引文件中列出的所有二进制日志文件。二进制和master是同义词。删除的日志文件也将从索引文件中记录的列表中删除，以便给定的日志文件成为列表中的第一个。</p><p>
                <a class="link" href="sql-syntax.html#purge-binary-logs" title="13.4.1.1&nbsp;PURGE BINARY LOGS Syntax"><code class="literal">PURGE BINARY LOGS</code></a> requires the
                <a class="ulink" href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_binlog-admin" target="_top"><code class="literal">BINLOG_ADMIN</code></a> privilege. This
                statement has no effect if the server was not started with the
                <a class="link" href="replication.html#option_mysqld_log-bin"><code class="option">--log-bin</code></a> option to enable binary
                logging.
            </p><p style="color:blue;">清除二进制日志需要binlog_管理权限。如果服务器不是用--log bin选项启动的，则此语句不起作用，以启用二进制日志记录。</p><p>
                Examples:
            </p><p style="color:blue;">示例：</p><pre data-lang="sql" class="programlisting">PURGE BINARY LOGS TO 'mysql-bin.010';
PURGE BINARY LOGS BEFORE '2019-04-02 22:46:26';
</pre><p>
                The <code class="literal">BEFORE</code> variant's
                <em class="replaceable"><code>datetime_expr</code></em> argument should
                evaluate to a <a class="link" href="data-types.html#datetime" title="11.3.1&nbsp;The DATE, DATETIME, and TIMESTAMP Types"><code class="literal">DATETIME</code></a> value (a
                value in <code class="literal">'YYYY-MM-DD hh:mm:ss'</code> format).
            </p><p style="color:blue;">before变量的datetime_expr参数的计算结果应为datetime值（“yyyy-mm-dd hh:mm:s s”格式的值）。</p><p>
                This statement is safe to run while slaves are replicating. You
                need not stop them. If you have an active slave that currently
                is reading one of the log files you are trying to delete, this
                statement does not delete the log file that is in use or any log
                files later than that one, but it deletes any earlier log files.
                A warning message is issued in this situation. However, if a
                slave is not connected and you happen to purge one of the log
                files it has yet to read, the slave will be unable to replicate
                after it reconnects.
            </p><p style="color:blue;">当从机正在复制时，此语句可以安全运行。你不必阻止他们。如果您有一个活动的从机当前正在读取您试图删除的某个日志文件，则此语句不会删除正在使用的日志文件或该文件之后的任何日志文件，但会删除任何以前的日志文件。在这种情况下会发出警告消息。但是，如果一个从属服务器没有连接，并且您碰巧清除了它尚未读取的一个日志文件，那么在它重新连接之后，该从属服务器将无法进行复制。</p><p>
                To safely purge binary log files, follow this procedure:
            </p><p style="color:blue;">要安全清除二进制日志文件，请执行以下过程：</p>
                <div class="orderedlist">
                    <ol class="orderedlist" type="1"><li class="listitem"><p>
                        On each slave server, use <a class="link" href="sql-syntax.html#show-slave-status" title="13.7.5.34&nbsp;SHOW SLAVE STATUS Syntax"><code class="literal">SHOW SLAVE
                        STATUS</code></a> to check which log file it is reading.
                    </p><p style="color:blue;">在每个从属服务器上，使用show slave status检查它正在读取的日志文件。</p></li><li class="listitem"><p>
                        Obtain a listing of the binary log files on the master
                        server with <a class="link" href="sql-syntax.html#show-binary-logs" title="13.7.5.1&nbsp;SHOW BINARY LOGS Syntax"><code class="literal">SHOW BINARY LOGS</code></a>.
                    </p><p style="color:blue;">使用show binary logs获取主服务器上的二进制日志文件列表。</p></li><li class="listitem"><p>
                        Determine the earliest log file among all the slaves. This
                        is the target file. If all the slaves are up to date, this
                        is the last log file on the list.
                    </p><p style="color:blue;">确定所有从机中最早的日志文件。这是目标文件。如果所有从服务器都是最新的，则这是列表中的最后一个日志文件。</p></li><li class="listitem"><p>
                        Make a backup of all the log files you are about to delete.
                        (This step is optional, but always advisable.)
                    </p><p style="color:blue;">备份要删除的所有日志文件。（此步骤是可选的，但始终是可取的。）</p></li><li class="listitem"><p>
                        Purge all log files up to but not including the target file.
                    </p><p style="color:blue;">清除目标文件之前的所有日志文件，但不包括目标文件。</p></li></ol>
                </div>
                <p>
                    You can also set the
                    <a class="link" href="replication.html#sysvar_expire_logs_days"><code class="literal">expire_logs_days</code></a> system
                    variable to expire binary log files automatically after a given
                    number of days (see <a class="xref" href="server-administration.html#server-system-variables" title="5.1.7&nbsp;Server System Variables">Section&nbsp;5.1.7, “Server System Variables”</a>).
                    If you are using replication, you should set the variable no
                    lower than the maximum number of days your slaves might lag
                    behind the master.
                </p><p style="color:blue;">您还可以设置expire_logs_days系统变量，使二进制日志文件在给定的天数后自动过期（请参阅第5.1.7节“服务器系统变量”）。如果使用复制，则应将变量设置为不低于奴隶可能落后于主机的最大天数。</p><p>
                <code class="literal">PURGE BINARY LOGS TO</code> and <code class="literal">PURGE
                BINARY LOGS BEFORE</code> both fail with an error when binary
                log files listed in the <code class="filename">.index</code> file had
                been removed from the system by some other means (such as using
                <span class="command"><strong>rm</strong></span> on Linux). (Bug #18199, Bug #18453) To
                handle such errors, edit the <code class="filename">.index</code> file
                (which is a simple text file) manually to ensure that it lists
                only the binary log files that are actually present, then run
                again the <a class="link" href="sql-syntax.html#purge-binary-logs" title="13.4.1.1&nbsp;PURGE BINARY LOGS Syntax"><code class="literal">PURGE BINARY LOGS</code></a>
                statement that failed.
            </p><p style="color:blue;">当.index文件中列出的二进制日志文件已通过某些其他方式（例如在Linux上使用RM）从系统中删除时，在两个操作失败之前清除二进制日志并清除它们，但都会出现错误。（bug 18199，bug 18453）要处理此类错误，请手动编辑.index文件（这是一个简单的文本文件）以确保它只列出实际存在的二进制日志文件，然后再次运行失败的purge binary logs语句。</p>
            </div>
            <div class="section">
                <div class="titlepage">
                    <div>
                        <div>
                            <h4 class="title"><a name="reset-master"></a>13.4.1.2&nbsp;RESET MASTER Syntax</h4>

                        </div>

                    </div>

                </div>
                <a class="indexterm" name="idm140286832592576"></a><pre data-lang="sql" class="programlisting">RESET MASTER
</pre>
                <div class="warning" style="margin-left: 0.5in; margin-right: 0.5in;">

                    <div class="admon-title">
                        Warning
                    </div>
                    <p>
                        Use this statement with caution to ensure you do not lose any
                        wanted binary log file data and GTID execution history.
                    </p><p style="color:blue;">请谨慎使用此语句，以确保不会丢失任何所需的二进制日志文件数据和gtid执行历史记录。</p>
                </div>
                <p>
                    <a class="link" href="sql-syntax.html#reset-master" title="13.4.1.2&nbsp;RESET MASTER Syntax"><code class="literal">RESET MASTER</code></a> requires the
                    <a class="link" href="security.html#priv_reload"><code class="literal">RELOAD</code></a> privilege.
                </p><p style="color:blue;">重置主机需要重新加载权限。</p><p>
                For a server where binary logging is enabled
                (<a class="link" href="replication.html#sysvar_log_bin"><code class="literal">log_bin</code></a> is
                <code class="literal">ON</code>), <code class="literal">RESET MASTER</code> deletes
                all existing binary log files and resets the binary log index
                file, resetting the server to its state before binary logging
                was started. A new empty binary log file is created so that
                binary logging can be restarted.
            </p><p style="color:blue;">对于启用二进制日志记录的服务器（LogyBin是ON），Read MeST删除所有现有的二进制日志文件并重置二进制日志索引文件，在二进制日志开始之前将服务器重置为其状态。将创建一个新的空二进制日志文件，以便可以重新启动二进制日志记录。</p><p>
                For a server where GTIDs are in use
                (<a class="link" href="replication.html#sysvar_gtid_mode"><code class="literal">gtid_mode</code></a> is
                <code class="literal">ON</code>), issuing <code class="literal">RESET MASTER</code>
                resets the GTID execution history. The value of the
                <a class="link" href="replication.html#sysvar_gtid_purged"><code class="literal">gtid_purged</code></a> system variable is
                set to an empty string (<code class="literal">''</code>), the global value
                (but not the session value) of the
                <a class="link" href="replication.html#sysvar_gtid_executed"><code class="literal">gtid_executed</code></a> system variable
                is set to an empty string, and the
                <code class="literal">mysql.gtid_executed</code> table is cleared (see
                <a class="xref" href="replication.html#replication-gtids-gtid-executed-table" title="mysql.gtid_executed Table">mysql.gtid_executed Table</a>). If the
                GTID-enabled server has binary logging enabled,
                <a class="link" href="sql-syntax.html#reset-master" title="13.4.1.2&nbsp;RESET MASTER Syntax"><code class="literal">RESET MASTER</code></a> also resets the
                binary log as described above. Note that
                <a class="link" href="sql-syntax.html#reset-master" title="13.4.1.2&nbsp;RESET MASTER Syntax"><code class="literal">RESET MASTER</code></a> is the method to
                reset the GTID execution history even if the GTID-enabled server
                is a replication slave where binary logging is disabled;
                <a class="link" href="sql-syntax.html#reset-slave" title="13.4.2.4&nbsp;RESET SLAVE Syntax"><code class="literal">RESET SLAVE</code></a> has no effect on the
                GTID execution history. For more information on resetting the
                GTID execution history, see
                <a class="xref" href="replication.html#replication-gtids-execution-history" title="Resetting the GTID Execution History">Resetting the GTID Execution History</a>.
            </p><p style="color:blue;">对于正在使用gtid的服务器（gtid_模式为on），发出reset master将重置gtid执行历史记录。gtid_清除的系统变量的值设置为空字符串（''），gtid_executed系统变量的全局值（而不是会话值）设置为空字符串，并且清除mysql.gtid_executed表（请参阅mysql.gtid_executed表）。如果启用gtid的服务器启用了二进制日志记录，reset master也会按上述方式重置二进制日志。请注意，reset master是重置gtid执行历史记录的方法，即使启用gtid的服务器是禁用二进制日志记录的复制从属服务器；reset slave对gtid执行历史记录没有影响。有关重置gtid执行历史的更多信息，请参阅重置gtid执行历史。</p>
                <div class="important" style="margin-left: 0.5in; margin-right: 0.5in;">

                    <div class="admon-title">
                        Important
                    </div>
                    <p>
                        The effects of <a class="link" href="sql-syntax.html#reset-master" title="13.4.1.2&nbsp;RESET MASTER Syntax"><code class="literal">RESET MASTER</code></a>
                        differ from those of <a class="link" href="sql-syntax.html#purge-binary-logs" title="13.4.1.1&nbsp;PURGE BINARY LOGS Syntax"><code class="literal">PURGE BINARY
                        LOGS</code></a> in 2 key ways:
                    </p><p style="color:blue;">reset master的效果与清除二进制日志的效果在两个关键方面有所不同：</p>
                    <div class="orderedlist">
                        <ol class="orderedlist" type="1"><li class="listitem"><p>
                            <a class="link" href="sql-syntax.html#reset-master" title="13.4.1.2&nbsp;RESET MASTER Syntax"><code class="literal">RESET MASTER</code></a> removes
                            <span class="emphasis"><em>all</em></span> binary log files that are listed
                            in the index file, leaving only a single, empty binary log
                            file with a numeric suffix of <code class="literal">.000001</code>,
                            whereas the numbering is not reset by
                            <a class="link" href="sql-syntax.html#purge-binary-logs" title="13.4.1.1&nbsp;PURGE BINARY LOGS Syntax"><code class="literal">PURGE BINARY LOGS</code></a>.
                        </p><p style="color:blue;">reset master删除索引文件中列出的所有二进制日志文件，只留下一个数字后缀为.000001的空二进制日志文件，而不通过清除二进制日志重置编号。</p></li><li class="listitem"><p>
                            <a class="link" href="sql-syntax.html#reset-master" title="13.4.1.2&nbsp;RESET MASTER Syntax"><code class="literal">RESET MASTER</code></a> is
                            <span class="emphasis"><em>not</em></span> intended to be used while any
                            replication slaves are running. The behavior of
                            <a class="link" href="sql-syntax.html#reset-master" title="13.4.1.2&nbsp;RESET MASTER Syntax"><code class="literal">RESET MASTER</code></a> when used
                            while slaves are running is undefined (and thus
                            unsupported), whereas <a class="link" href="sql-syntax.html#purge-binary-logs" title="13.4.1.1&nbsp;PURGE BINARY LOGS Syntax"><code class="literal">PURGE BINARY
                            LOGS</code></a> may be safely used while replication slaves
                            are running.
                        </p><p style="color:blue;">在任何复制从属服务器运行时，都不打算使用重置主服务器。在从机运行时使用reset master的行为未定义（因此不受支持），而在复制从机运行时可以安全地使用清除二进制日志。</p></li></ol>
                    </div>
                    <p>
                        See also <a class="xref" href="sql-syntax.html#purge-binary-logs" title="13.4.1.1&nbsp;PURGE BINARY LOGS Syntax">Section&nbsp;13.4.1.1, “PURGE BINARY LOGS Syntax”</a>.
                    </p><p style="color:blue;">另见第13.4.1.1节“清除二进制日志语法”。</p>
                </div>
                <p>
                    <a class="link" href="sql-syntax.html#reset-master" title="13.4.1.2&nbsp;RESET MASTER Syntax"><code class="literal">RESET MASTER</code></a> can prove useful
                    when you first set up the master and the slave, so that you can
                    verify the setup as follows:
                </p><p style="color:blue;">当您第一次设置主设备和从设备时，“重置主设备”会被证明是有用的，因此您可以按如下方式验证设置：</p>
                <div class="orderedlist">
                    <ol class="orderedlist" type="1"><li class="listitem"><p>
                        Start the master and slave, and start replication (see
                        <a class="xref" href="replication.html#replication-howto" title="16.1.2&nbsp;Setting Up Binary Log File Position Based Replication">Section&nbsp;16.1.2, “Setting Up Binary Log File Position Based Replication”</a>).
                    </p><p style="color:blue;">启动主机和从机，并启动复制（请参阅16.1.2节，“设置基于二进制日志文件位置的复制”）。</p></li><li class="listitem"><p>
                        Execute a few test queries on the master.
                    </p><p style="color:blue;">在主机上执行一些测试查询。</p></li><li class="listitem"><p>
                        Check that the queries were replicated to the slave.
                    </p><p style="color:blue;">检查查询是否已复制到从属服务器。</p></li><li class="listitem"><p>
                        When replication is running correctly, issue
                        <a class="link" href="sql-syntax.html#stop-slave" title="13.4.2.7&nbsp;STOP SLAVE Syntax"><code class="literal">STOP SLAVE</code></a> followed by
                        <a class="link" href="sql-syntax.html#reset-slave" title="13.4.2.4&nbsp;RESET SLAVE Syntax"><code class="literal">RESET SLAVE</code></a> on the slave,
                        then verify that any unwanted data no longer exists on the
                        slave.
                    </p><p style="color:blue;">当复制正确运行时，发出从站跟随从奴隶上复位的奴隶，然后验证在奴隶上不再存在任何不想要的数据。</p></li><li class="listitem"><p>
                        Issue <a class="link" href="sql-syntax.html#reset-master" title="13.4.1.2&nbsp;RESET MASTER Syntax"><code class="literal">RESET MASTER</code></a> on the
                        master to clean up the test queries.
                    </p><p style="color:blue;">在master上发出reset master以清理测试查询。</p></li></ol>
                </div>
                <p>
                    After verifying the setup, resetting the master and slave and
                    ensuring that no unwanted data or binary log files generated by
                    testing remain on master or slave, you can start the slave and
                    begin replicating.
                </p><p style="color:blue;">在验证设置、重置主服务器和从服务器并确保测试生成的不需要的数据或二进制日志文件不会保留在主服务器或从服务器上之后，可以启动从服务器并开始复制。</p>
            </div>
            <div class="section">
                <div class="titlepage">
                    <div>
                        <div>
                            <h4 class="title"><a name="set-sql-log-bin"></a>13.4.1.3&nbsp;SET sql_log_bin Syntax</h4>

                        </div>

                    </div>

                </div>
                <a class="indexterm" name="idm140286832539056"></a><pre data-lang="sql" class="programlisting">SET sql_log_bin = {OFF|ON}
</pre><p>
                The <a class="link" href="replication.html#sysvar_sql_log_bin"><code class="literal">sql_log_bin</code></a> variable
                controls whether logging to the binary log is enabled for the
                current session (assuming that the binary log itself is
                enabled). The default value is <code class="literal">ON</code>. To disable
                or enable binary logging for the current session, set the
                session <a class="link" href="replication.html#sysvar_sql_log_bin"><code class="literal">sql_log_bin</code></a> variable to
                <code class="literal">OFF</code> or <code class="literal">ON</code>.
            </p><p style="color:blue;">sql_log_bin变量控制是否为当前会话启用到二进制日志的日志记录（假设启用了二进制日志本身）。默认值为“开”。要禁用或启用当前会话的二进制日志记录，请将session sql_log_bin变量设置为off或on。</p><p>
                Set this variable to <code class="literal">OFF</code> for a session to
                temporarily disable binary logging while making changes to the
                master you do not want replicated to the slave.
            </p><p style="color:blue;">将此变量设置为“关”，以便会话在更改不希望复制到从属服务器的主服务器时临时禁用二进制日志记录。</p><p>
                Setting the session value of this system variable is a
                restricted operation. The session user must have privileges
                sufficient to set restricted session variables. See
                <a class="xref" href="server-administration.html#system-variable-privileges" title="5.1.8.1&nbsp;System Variable Privileges">Section&nbsp;5.1.8.1, “System Variable Privileges”</a>.
            </p><p style="color:blue;">设置此系统变量的会话值是受限制的操作。会话用户必须具有足够的权限来设置受限制的会话变量。见第5.1.8.1节“系统变量特权”。</p><p>
                It is not possible to set the session value of
                <a class="link" href="replication.html#sysvar_sql_log_bin"><code class="literal">sql_log_bin</code></a> within a
                transaction or subquery.
            </p><p style="color:blue;">无法在事务或子查询中设置SQL日志的会话值。</p><p>
        <span class="emphasis"><em>Setting this variable to <code class="literal">OFF</code>
        prevents GTIDs from being assigned to transactions in the binary
        log</em></span>. If you are using GTIDs for replication, this
                means that even when binary logging is later enabled again, the
                GTIDs written into the log from this point do not account for
                any transactions that occurred in the meantime, so in effect
                those transactions are lost.
            </p><p style="color:blue;">将此变量设置为off可防止将gtid分配给二进制日志中的事务。如果您使用gtid进行复制，这意味着即使稍后再次启用二进制日志记录，从此点写入日志的gtid也不会考虑在此期间发生的任何事务，因此实际上这些事务都会丢失。</p><p>
                The global <a class="link" href="replication.html#sysvar_sql_log_bin"><code class="literal">sql_log_bin</code></a> variable
                is read only and cannot be modified. The global scope is
                deprecated and will be removed in a future MySQL release.
            </p><p style="color:blue;">全局sql_log_bin变量是只读的，不能修改。全局作用域已弃用，将在以后的mysql版本中删除。</p>
            </div>

        </div>
        <div class="section">
            <div class="titlepage">
                <div>
                    <div>
                        <h3 class="title"><a name="replication-slave-sql"></a>13.4.2&nbsp;SQL Statements for Controlling Slave Servers</h3>

                    </div>

                </div>

            </div>
            <div class="toc">
                <dl class="toc"><dt><span class="section"><a href="sql-syntax.html#change-master-to">13.4.2.1 CHANGE MASTER TO Syntax</a></span></dt><dt><span class="section"><a href="sql-syntax.html#change-replication-filter">13.4.2.2 CHANGE REPLICATION FILTER Syntax</a></span></dt><dt><span class="section"><a href="sql-syntax.html#master-pos-wait">13.4.2.3 MASTER_POS_WAIT() Syntax</a></span></dt><dt><span class="section"><a href="sql-syntax.html#reset-slave">13.4.2.4 RESET SLAVE Syntax</a></span></dt><dt><span class="section"><a href="sql-syntax.html#set-global-sql-slave-skip-counter">13.4.2.5 SET GLOBAL sql_slave_skip_counter Syntax</a></span></dt><dt><span class="section"><a href="sql-syntax.html#start-slave">13.4.2.6 START SLAVE Syntax</a></span></dt><dt><span class="section"><a href="sql-syntax.html#stop-slave">13.4.2.7 STOP SLAVE Syntax</a></span></dt></dl>
            </div>
            <a class="indexterm" name="idm140286832519392"></a><a class="indexterm" name="idm140286832517936"></a><a class="indexterm" name="idm140286832516448"></a><p>
            This section discusses statements for managing slave replication
            servers. <a class="xref" href="sql-syntax.html#replication-master-sql" title="13.4.1&nbsp;SQL Statements for Controlling Master Servers">Section&nbsp;13.4.1, “SQL Statements for Controlling Master Servers”</a>, discusses
            statements for managing master servers.
        </p><p style="color:blue;">本节讨论用于管理从属复制服务器的语句。第13.4.1节“控制主服务器的SQL语句”讨论了管理主服务器的语句。</p><p>
            In addition to the statements described here,
            <a class="link" href="sql-syntax.html#show-slave-status" title="13.7.5.34&nbsp;SHOW SLAVE STATUS Syntax"><code class="literal">SHOW SLAVE STATUS</code></a> and
            <a class="link" href="sql-syntax.html#show-relaylog-events" title="13.7.5.32&nbsp;SHOW RELAYLOG EVENTS Syntax"><code class="literal">SHOW RELAYLOG EVENTS</code></a> are also used
            with replication slaves. For information about these statements,
            see <a class="xref" href="sql-syntax.html#show-slave-status" title="13.7.5.34&nbsp;SHOW SLAVE STATUS Syntax">Section&nbsp;13.7.5.34, “SHOW SLAVE STATUS Syntax”</a>, and
            <a class="xref" href="sql-syntax.html#show-relaylog-events" title="13.7.5.32&nbsp;SHOW RELAYLOG EVENTS Syntax">Section&nbsp;13.7.5.32, “SHOW RELAYLOG EVENTS Syntax”</a>.
        </p><p style="color:blue;">除了这里描述的语句之外，show slave status和show relaylog事件也用于复制从机。有关这些语句的信息，请参阅第13.7.5.34节“显示从属状态语法”和第13.7.5.32节“显示relaylog事件语法”。</p>
            <div class="section">

                <div class="titlepage">
                    <div>
                        <div>
                            <h4 class="title"><a name="change-master-to"></a>13.4.2.1&nbsp;CHANGE MASTER TO Syntax</h4>
                        </div>
                    </div>
                </div>
                <a class="indexterm" name="idm140286832508176"></a><pre data-lang="sql" class="programlisting">CHANGE MASTER TO <em class="replaceable"><code>option</code></em> [, <em class="replaceable"><code>option</code></em>] ... [ <em class="replaceable"><code>channel_option</code></em> ]

<em class="replaceable"><code>option</code></em>:
    MASTER_BIND = '<em class="replaceable"><code>interface_name</code></em>'
  | MASTER_HOST = '<em class="replaceable"><code>host_name</code></em>'
  | MASTER_USER = '<em class="replaceable"><code>user_name</code></em>'
  | MASTER_PASSWORD = '<em class="replaceable"><code>password</code></em>'
  | MASTER_PORT = <em class="replaceable"><code>port_num</code></em>
  | MASTER_CONNECT_RETRY = <em class="replaceable"><code>interval</code></em>
  | MASTER_RETRY_COUNT = <em class="replaceable"><code>count</code></em>
  | MASTER_DELAY = <em class="replaceable"><code>interval</code></em>
  | MASTER_HEARTBEAT_PERIOD = <em class="replaceable"><code>interval</code></em>
  | MASTER_LOG_FILE = '<em class="replaceable"><code>master_log_name</code></em>'
  | MASTER_LOG_POS = <em class="replaceable"><code>master_log_pos</code></em>
  | MASTER_AUTO_POSITION = {0|1}
  | RELAY_LOG_FILE = '<em class="replaceable"><code>relay_log_name</code></em>'
  | RELAY_LOG_POS = <em class="replaceable"><code>relay_log_pos</code></em>
  | MASTER_SSL = {0|1}
  | MASTER_SSL_CA = '<em class="replaceable"><code>ca_file_name</code></em>'
  | MASTER_SSL_CAPATH = '<em class="replaceable"><code>ca_directory_name</code></em>'
  | MASTER_SSL_CERT = '<em class="replaceable"><code>cert_file_name</code></em>'
  | MASTER_SSL_CRL = '<em class="replaceable"><code>crl_file_name</code></em>'
  | MASTER_SSL_CRLPATH = '<em class="replaceable"><code>crl_directory_name</code></em>'
  | MASTER_SSL_KEY = '<em class="replaceable"><code>key_file_name</code></em>'
  | MASTER_SSL_CIPHER = '<em class="replaceable"><code>cipher_list</code></em>'
  | MASTER_SSL_VERIFY_SERVER_CERT = {0|1}
  | MASTER_TLS_VERSION = '<em class="replaceable"><code>protocol_list</code></em>'
  | IGNORE_SERVER_IDS = (<em class="replaceable"><code>server_id_list</code></em>)

<em class="replaceable"><code>channel_option</code></em>:
    FOR CHANNEL <em class="replaceable"><code>channel</code></em>

<em class="replaceable"><code>server_id_list</code></em>:
    [<em class="replaceable"><code>server_id</code></em> [, <em class="replaceable"><code>server_id</code></em>] ... ]
</pre><p>
                <a class="link" href="sql-syntax.html#change-master-to" title="13.4.2.1&nbsp;CHANGE MASTER TO Syntax"><code class="literal">CHANGE MASTER TO</code></a> changes the
                parameters that the slave server uses for connecting to the
                master server, for reading the master binary log, and reading
                the slave relay log. It also updates the contents of the master
                info and relay log info repositories (see
                <a class="xref" href="replication.html#slave-logs" title="16.2.4&nbsp;Replication Relay and Status Logs">Section&nbsp;16.2.4, “Replication Relay and Status Logs”</a>). <a class="link" href="sql-syntax.html#change-master-to" title="13.4.2.1&nbsp;CHANGE MASTER TO Syntax"><code class="literal">CHANGE
                MASTER TO</code></a> requires the
                <a class="link" href="security.html#priv_super"><code class="literal">SUPER</code></a> privilege.
            </p><p style="color:blue;">change master更改从属服务器用于连接到主服务器、读取主二进制日志和读取从属中继日志的参数。它还更新主信息和中继日志信息存储库的内容（请参阅第16.2.4节“复制中继和状态日志”）。将master更改为需要超级特权。</p><p>
                Prior to MySQL 5.7.4, the slave replication threads must be
                stopped, using <a class="link" href="sql-syntax.html#stop-slave" title="13.4.2.7&nbsp;STOP SLAVE Syntax"><code class="literal">STOP SLAVE</code></a> if
                necessary, before issuing this statement. In MySQL 5.7.4 and
                later, you can issue <code class="literal">CHANGE MASTER TO</code>
                statements on a running slave without doing this, depending on
                the states of the slave SQL thread and slave I/O thread. The
                rules governing such use are provided later in this section.
            </p><p style="color:blue;">在mysql 5.7.4之前，在发出此语句之前，必须停止从复制线程，必要时使用stop slave。在mysql 5.7.4及更高版本中，您可以根据从sql线程和从i/o线程的状态，在运行的从机上发出change master to语句，而无需执行此操作。有关此类使用的规则将在本节后面提供。</p><p>
                When using a multithreaded slave (in other words
                <a class="link" href="replication.html#sysvar_slave_parallel_workers"><code class="literal">slave_parallel_workers</code></a> is
                greater than 0), stopping the slave can cause
                <span class="quote">“<span class="quote">gaps</span>”</span> in the sequence of transactions that have
                been executed from the relay log, regardless of whether the
                slave was stopped intentionally or otherwise. When such gaps
                exist, issuing <a class="link" href="sql-syntax.html#change-master-to" title="13.4.2.1&nbsp;CHANGE MASTER TO Syntax"><code class="literal">CHANGE MASTER TO</code></a>
                fails. The solution in this situation is to issue
                <a class="link" href="sql-syntax.html#start-slave" title="13.4.2.6&nbsp;START SLAVE Syntax"><code class="literal">START SLAVE UNTIL
                    SQL_AFTER_MTS_GAPS</code></a> which ensures that the gaps are
                closed.
            </p><p style="color:blue;">当使用多线程从机（换句话说，从机并行工作机大于0）时，停止从机可能会在从中继日志执行的事务序列中造成“间隙”，而不管从机是故意停止还是以其他方式停止。当存在这样的间隙时，发出更改主机失败。在这种情况下，解决方案是发出start slave直到sql_after_mts_gaps，以确保这些gaps是闭合的。</p><p>
                The optional <code class="literal">FOR CHANNEL
                <em class="replaceable"><code>channel</code></em></code> clause enables you
                to name which replication channel the statement applies to.
                Providing a <code class="literal">FOR CHANNEL
                <em class="replaceable"><code>channel</code></em></code> clause applies the
                <code class="literal">CHANGE MASTER TO</code> statement to a specific
                replication channel, and is used to add a new channel or modify
                an existing channel. For example, to add a new channel called
                channel2:
            </p><p style="color:blue;">可选的for channel channel子句允许您命名该语句应用于哪个复制通道。提供通道通道子句将更改主机应用到语句到特定的复制通道，并用于添加新的通道或修改现有的通道。例如，要添加名为channel2的新频道：</p><pre data-lang="sql" class="programlisting">CHANGE MASTER TO MASTER_HOST=host1, MASTER_PORT=3002 FOR CHANNEL 'channel2'</pre><p>
                If no clause is named and no extra channels exist, the statement
                applies to the default channel.
            </p><p style="color:blue;">如果不命名子句，并且不存在额外的信道，则该语句应用于默认信道。</p><p>
                When using multiple replication channels, if a <code class="literal">CHANGE
                MASTER TO</code> statement does not name a channel using a
                <code class="literal">FOR CHANNEL
                    <em class="replaceable"><code>channel</code></em></code> clause, an error
                occurs. See <a class="xref" href="replication.html#replication-channels" title="16.2.3&nbsp;Replication Channels">Section&nbsp;16.2.3, “Replication Channels”</a> for more
                information.
            </p><p style="color:blue;">使用多个复制通道时，如果change master to语句没有使用for channel channel子句命名通道，则会发生错误。有关更多信息，请参阅第16.2.3节“复制通道”。</p><p>
                Options not specified retain their value, except as indicated in
                the following discussion. Thus, in most cases, there is no need
                to specify options that do not change. For example, if the
                password to connect to your MySQL master has changed, issue this
                statement to tell the slave about the new password:
            </p><p style="color:blue;">未指定的选项保留其值，除非在下面的讨论中指出。因此，在大多数情况下，不需要指定不更改的选项。例如，如果连接到mysql主服务器的密码已更改，则发出以下语句将新密码告知从服务器：</p><pre data-lang="sql" class="programlisting">CHANGE MASTER TO MASTER_PASSWORD='new3cret';
</pre><p>
                <code class="literal">MASTER_HOST</code>, <code class="literal">MASTER_USER</code>,
                <code class="literal">MASTER_PASSWORD</code>, and
                <code class="literal">MASTER_PORT</code> provide information to the slave
                about how to connect to its master:
            </p><p style="color:blue;">主机、主机用户、主机密码和主机端口向从机提供有关如何连接到其主机的信息：</p>
                <div class="itemizedlist">
                    <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                        <code class="literal">MASTER_HOST</code> and
                        <code class="literal">MASTER_PORT</code> are the host name (or IP
                        address) of the master host and its TCP/IP port.
                    </p><p style="color:blue;">主机和主机端口是主机及其TCP/IP端口的主机名（或IP地址）。</p>
                        <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">

                            <div class="admon-title">
                                Note
                            </div>
                            <p>
                                Replication cannot use Unix socket files. You must be able
                                to connect to the master MySQL server using TCP/IP.
                            </p><p style="color:blue;">复制不能使用unix套接字文件。您必须能够使用TCP/IP连接到主MySQL服务器。</p>
                        </div>
                        <p>
                            If you specify the <code class="literal">MASTER_HOST</code> or
                            <code class="literal">MASTER_PORT</code> option, the slave assumes
                            that the master server is different from before (even if the
                            option value is the same as its current value.) In this
                            case, the old values for the master binary log file name and
                            position are considered no longer applicable, so if you do
                            not specify <code class="literal">MASTER_LOG_FILE</code> and
                            <code class="literal">MASTER_LOG_POS</code> in the statement,
                            <code class="literal">MASTER_LOG_FILE=''</code> and
                            <code class="literal">MASTER_LOG_POS=4</code> are silently appended to
                            it.
                        </p><p style="color:blue;">如果指定master_host或master_port选项，从服务器将假定主服务器与以前不同（即使选项值与当前值相同）。在这种情况下，主二进制日志文件名和位置的旧值将不再适用，因此，如果未在语句中指定master_log_file和master_log_pos，则master_log_file=''和master_log_pos=4将自动附加到该语句中。</p><p>
                            Setting <code class="literal">MASTER_HOST=''</code> (that is, setting
                            its value explicitly to an empty string) is
                            <span class="emphasis"><em>not</em></span> the same as not setting
                            <code class="literal">MASTER_HOST</code> at all. Beginning with MySQL
                            5.5, trying to set <code class="literal">MASTER_HOST</code> to an
                            empty string fails with an error. Previously, setting
                            <code class="literal">MASTER_HOST</code> to an empty string caused
                            <a class="link" href="sql-syntax.html#start-slave" title="13.4.2.6&nbsp;START SLAVE Syntax"><code class="literal">START SLAVE</code></a> subsequently to
                            fail. (Bug #28796)
                        </p><p style="color:blue;">设置master_host=''（即显式地将其值设置为空字符串）与根本不设置master_host不同。从mysql 5.5开始，尝试将master_host设置为空字符串失败，并出现错误。以前，将master_host设置为空字符串会导致start slave随后失败。（错误28796）</p><p>
                            Values used for <code class="literal">MASTER_HOST</code> and other
                            <code class="literal">CHANGE MASTER TO</code> options are checked for
                            linefeed (<code class="literal">\n</code> or <code class="literal">0x0A</code>)
                            characters; the presence of such characters in these values
                            causes the statement to fail with
                            <a class="link" href="error-handling.html#error_er_master_info"><code class="literal">ER_MASTER_INFO</code></a>. (Bug
                            #11758581, Bug #50801)
                        </p><p style="color:blue;">对于换行（\n或0x0a）字符，将检查用于master_host和其他change master to options的值；这些值中存在此类字符将导致语句失败，并显示er_master_info。（错误11758581，错误50801）</p></li><li class="listitem"><p>
                        <code class="literal">MASTER_USER</code> and
                        <code class="literal">MASTER_PASSWORD</code> are the user name and
                        password of the account to use for connecting to the master.
                    </p><p style="color:blue;">master_user和master_password是用于连接到master的帐户的用户名和密码。</p><p>
                        <code class="literal">MASTER_USER</code> cannot be made empty; setting
                        <code class="literal">MASTER_USER = ''</code> or leaving it unset when
                        setting a value for <code class="literal">MASTER_PASSWORD</code>
                        causes an error (Bug #13427949).
                    </p><p style="color:blue;">master_user不能为空；设置master_user=''或在设置master_password的值时不设置它会导致错误（错误13427949）。</p><p>
                        The password used for a MySQL Replication slave account in a
                        <code class="literal">CHANGE MASTER TO</code> statement is limited to
                        32 characters in length; prior to MySQL 5.7.5, if the
                        password was longer, the statement succeeded, but any excess
                        characters were silently truncated. In MySQL 5.7.5 and
                        later, trying to use a password of more than 32 characters
                        causes <code class="literal">CHANGE MASTER TO</code> to fail. (Bug
                        #11752299, Bug #43439)
                    </p><p style="color:blue;">在change master to语句中，mysql复制从帐户使用的密码长度限制为32个字符；在mysql 5.7.5之前，如果密码较长，则语句成功，但任何多余的字符都会被自动截断。在mysql 5.7.5及更高版本中，尝试使用超过32个字符的密码会导致change master失败。（错误1175229，错误43439）</p><p>
                        The text of a running <a class="link" href="sql-syntax.html#change-master-to" title="13.4.2.1&nbsp;CHANGE MASTER TO Syntax"><code class="literal">CHANGE MASTER
                        TO</code></a> statement, including values for
                        <code class="literal">MASTER_USER</code> and
                        <code class="literal">MASTER_PASSWORD</code>, can be seen in the
                        output of a concurrent <a class="link" href="sql-syntax.html#show-processlist" title="13.7.5.29&nbsp;SHOW PROCESSLIST Syntax"><code class="literal">SHOW
                        PROCESSLIST</code></a> statement. (The complete text of a
                        <a class="link" href="sql-syntax.html#start-slave" title="13.4.2.6&nbsp;START SLAVE Syntax"><code class="literal">START SLAVE</code></a> statement is also
                        visible to <a class="link" href="sql-syntax.html#show-processlist" title="13.7.5.29&nbsp;SHOW PROCESSLIST Syntax"><code class="literal">SHOW PROCESSLIST</code></a>.)
                    </p><p style="color:blue;">在并发show processlist语句的输出中可以看到正在运行的change master to语句的文本，包括master_user和master_password的值。（start slave语句的完整文本也可以显示processlist。）</p></li></ul>
                </div>
                <p>
                    The <code class="literal">MASTER_SSL_<em class="replaceable"><code>xxx</code></em></code>
                    options and the <code class="literal">MASTER_TLS_VERSION</code> option
                    specify how the slave uses encryption and ciphers to secure the
                    replication connection. These options can be changed even on
                    slaves that are compiled without SSL support. They are saved to
                    the master info repository, but are ignored if the slave does
                    not have SSL support enabled. The
                    <code class="literal">MASTER_SSL_<em class="replaceable"><code>xxx</code></em></code> and
                    <code class="literal">MASTER_TLS_VERSION</code> options perform the same
                    functions as the
                    <code class="literal">--ssl-<em class="replaceable"><code>xxx</code></em></code> and
                    <code class="literal">--tls-version</code> client options described in
                    <a class="xref" href="programs.html#encrypted-connection-options" title="Command Options for Encrypted Connections">Command Options for Encrypted Connections</a>. The
                    correspondence between the two sets of options, and the use of
                    the <code class="literal">MASTER_SSL_<em class="replaceable"><code>xxx</code></em></code>
                    and <code class="literal">MASTER_TLS_VERSION</code> options to set up a
                    secure connection, is explained in
                    <a class="xref" href="replication.html#replication-solutions-encrypted-connections" title="16.3.8&nbsp;Setting Up Replication to Use Encrypted Connections">Section&nbsp;16.3.8, “Setting Up Replication to Use Encrypted Connections”</a>.
                </p><p style="color:blue;">master_ssl_xxx选项和master_tls_version选项指定从机如何使用加密和密码来保护复制连接。即使在没有ssl支持的情况下编译的从机上，也可以更改这些选项。它们将保存到主信息存储库中，但如果从机未启用ssl支持，则会被忽略。master_ssl_xxx和master_tls_version选项执行的功能与用于加密连接的命令选项中描述的--ssl xxx和--tls version客户端选项相同。在第16.3.8节“设置复制以使用加密连接”中解释了两组选项之间的对应关系，以及使用master_ssl_xxx和master_tls_版本选项来设置安全连接。</p><p>
                As of MySQL 5.7.3, setting <code class="literal">MASTER_SSL=1</code> means
                that the slave connection to the master must use SSL, or the
                connection attempt fails. Before 5.7.3, the use of an SSL
                connection by the slave was not enforced with
                <code class="literal">MASTER_SSL=1</code>. This is analogous to the
                client-side meaning of the <a class="link" href="programs.html#option_general_ssl"><code class="option">--ssl</code></a>
                command-line option; see
                <a class="xref" href="programs.html#encrypted-connection-options" title="Command Options for Encrypted Connections">Command Options for Encrypted Connections</a>.
            </p><p style="color:blue;">从mysql 5.7.3开始，设置master_ssl=1意味着到master的从机连接必须使用ssl，否则连接尝试失败。在5.7.3之前，在master_ssl=1的情况下，没有强制从机使用ssl连接。这类似于--ssl命令行选项的客户端含义；请参见加密连接的命令选项。</p><p>
                The <code class="literal">MASTER_HEARTBEAT_PERIOD</code>,
                <code class="literal">MASTER_CONNECT_RETRY</code>, and
                <code class="literal">MASTER_RETRY_COUNT</code> options control how the
                slave recognizes that the connection to the master has been lost
                and makes attempts to reconnect.
            </p><p style="color:blue;">master_heartbeat_period、master_connect_retry和master_retry_count选项控制从设备如何识别到主设备的连接已丢失并尝试重新连接。</p>
                <div class="itemizedlist">
                    <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                        The <a class="link" href="replication.html#sysvar_slave_net_timeout"><code class="literal">slave_net_timeout</code></a>
                        system variable specifies the number of seconds that the
                        slave waits for either more data or a heartbeat signal from
                        the master, before the slave considers the connection
                        broken, aborts the read, and tries to reconnect. The default
                        value is 60 seconds (one minute). Prior to MySQL 5.7.7, the
                        default was 3600 seconds (one hour).
                    </p><p style="color:blue;">slave_net_timeout系统变量指定在从机认为连接断开、中止读取并尝试重新连接之前，从机等待来自主机的更多数据或心跳信号的秒数。默认值为60秒（1分钟）。在mysql 5.7.7之前，默认值是3600秒（1小时）。</p></li><li class="listitem"><p>
                        The heartbeat interval, which stops the connection timeout
                        occurring in the absence of data if the connection is still
                        good, is controlled by the
                        <code class="literal">MASTER_HEARTBEAT_PERIOD</code> option. A
                        heartbeat signal is sent to the slave after that number of
                        seconds, and the waiting period is reset whenever the
                        master's binary log is updated with an event. Heartbeats are
                        therefore sent by the master only if there are no unsent
                        events in the binary log file for a period longer than this.
                        The heartbeat interval <em class="replaceable"><code>interval</code></em>
                        is a decimal value having the range 0 to 4294967 seconds and
                        a resolution in milliseconds; the smallest nonzero value is
                        0.001. Setting <em class="replaceable"><code>interval</code></em> to 0
                        disables heartbeats altogether. The heartbeat interval
                        defaults to half the value of the
                        <a class="link" href="replication.html#sysvar_slave_net_timeout"><code class="literal">slave_net_timeout</code></a> system
                        variable. It is recorded in the master info log and shown in
                        the
                        <a class="link" href="performance-schema.html#replication-connection-configuration-table" title="25.12.11.1&nbsp;The replication_connection_configuration Table"><code class="literal">replication_connection_configuration</code></a>
                        Performance Schema table. Issuing <a class="link" href="sql-syntax.html#reset-slave" title="13.4.2.4&nbsp;RESET SLAVE Syntax"><code class="literal">RESET
                        SLAVE</code></a> resets the heartbeat interval to the default
                        value.
                    </p><p style="color:blue;">heartbeat interval由master_heartbeat_period选项控制，如果连接仍然良好，它将停止在没有数据的情况下发生的连接超时。在该秒数之后，心跳信号被发送到从机，并且每当用事件更新主机的二进制日志时，等待周期被重置。因此，只有在二进制日志文件中没有超过此时间段的未发送事件时，主服务器才会发送心跳信号。心跳间隔间隔是一个十进制值，范围为0到4294967秒，分辨率为毫秒；最小的非零值为0.001。将interval设置为0将完全禁用心跳。heartbeat interval默认为slave_net_timeout系统变量值的一半。它记录在主信息日志中，并显示在复制连接性能架构表中。发出reset slave将心跳间隔重置为默认值。</p></li><li class="listitem"><p>
                        Prior to MySQL 5.7.4, not including
                        <code class="literal">MASTER_HEARTBEAT_PERIOD</code> caused
                        <code class="literal">CHANGE MASTER TO</code> to reset the heartbeat
                        interval to the default (half the value of the
                        <a class="link" href="replication.html#sysvar_slave_net_timeout"><code class="literal">slave_net_timeout</code></a> system
                        variable), and
                        <a class="link" href="server-administration.html#statvar_Slave_received_heartbeats"><code class="literal">Slave_received_heartbeats</code></a>
                        to 0. The heartbeat interval is now not reset except by
                        <a class="link" href="sql-syntax.html#reset-slave" title="13.4.2.4&nbsp;RESET SLAVE Syntax"><code class="literal">RESET SLAVE</code></a>. (Bug #18185490)
                    </p><p style="color:blue;">在mysql 5.7.4之前，不包括master_heartbeat_period导致change master将heartbeat interval重置为默认值（slave_net_timeout系统变量值的一半），slave_received_heartbeats重置为0。心跳间隔现在不会被重置，除非通过重置从设备。（错误18185490）</p></li><li class="listitem"><p>
                        Note that a change to the value or default setting of
                        <a class="link" href="replication.html#sysvar_slave_net_timeout"><code class="literal">slave_net_timeout</code></a> does not
                        automatically change the heartbeat interval, whether that
                        has been set explicitly or is using a previously calculated
                        default. A warning is issued if you set
                        <code class="literal">@@GLOBAL.slave_net_timeout</code> to a value
                        less than that of the current heartbeat interval. If
                        <a class="link" href="replication.html#sysvar_slave_net_timeout"><code class="literal">slave_net_timeout</code></a> is
                        changed, you must also issue <a class="link" href="sql-syntax.html#change-master-to" title="13.4.2.1&nbsp;CHANGE MASTER TO Syntax"><code class="literal">CHANGE
                        MASTER TO</code></a> to adjust the heartbeat interval to an
                        appropriate value so that the heartbeat signal occurs before
                        the connection timeout. If you do not do this, the heartbeat
                        signal has no effect, and if no data is received from the
                        master, the slave can make repeated reconnection attempts,
                        creating zombie dump threads.
                    </p><p style="color:blue;">请注意，对slave_net_timeout的值或默认设置的更改不会自动更改心跳间隔，无论是显式设置还是使用先前计算的默认值。如果将@global.slave_net_timeout设置为小于当前心跳间隔的值，则会发出警告。如果slave_net_timeout已更改，则还必须发出change master以将心跳间隔调整为适当的值，以便在连接超时之前发生心跳信号。如果不这样做，心跳信号就没有效果，如果没有从主服务器接收到数据，从服务器就可以重复重新连接，从而创建僵尸转储线程。</p></li><li class="listitem"><p>
                        If the slave does need to reconnect, the first retry occurs
                        immediately after the timeout.
                        <code class="literal">MASTER_CONNECT_RETRY</code> specifies the
                        interval between reconnection attempts, and
                        <code class="literal">MASTER_RETRY_COUNT</code> limits the number of
                        reconnection attempts. If both the default settings are
                        used, the slave waits 60 seconds between reconnection
                        attempts (<code class="literal">MASTER_CONNECT_RETRY=60</code>), and
                        keeps attempting to reconnect at this rate for 60 days
                        (<code class="literal">MASTER_RETRY_COUNT=86400</code>). These values
                        are recorded in the master info log and shown in the
                        <a class="link" href="performance-schema.html#replication-connection-configuration-table" title="25.12.11.1&nbsp;The replication_connection_configuration Table"><code class="literal">replication_connection_configuration</code></a>
                        Performance Schema table.
                        <code class="literal">MASTER_RETRY_COUNT</code> supersedes the
                        <a class="link" href="replication.html#option_mysqld_master-retry-count"><code class="option">--master-retry-count</code></a> server
                        startup option.
                    </p><p style="color:blue;">如果从属服务器确实需要重新连接，则第一次重试将在超时后立即发生。master_connect_retry指定重新连接尝试之间的间隔，master_retry_count限制重新连接尝试的次数。如果同时使用这两个默认设置，则从机在重新连接尝试之间等待60秒（master_connect_retry=60），并以此速率尝试重新连接60天（master_retry_count=86400）。这些值记录在主信息日志中，并显示在复制连接性能架构表中。master_retry_count取代--master retry count服务器启动选项。</p></li></ul>
                </div>
                <p>
                    <code class="literal">MASTER_DELAY</code> specifies how many seconds
                    behind the master the slave must lag. An event received from the
                    master is not executed until at least
                    <em class="replaceable"><code>interval</code></em> seconds later than its
                    execution on the master. The default is 0. An error occurs if
                    <em class="replaceable"><code>interval</code></em> is not a nonnegative integer
                    in the range from 0 to 2<sup>31</sup>−1.
                    For more information, see <a class="xref" href="replication.html#replication-delayed" title="16.3.10&nbsp;Delayed Replication">Section&nbsp;16.3.10, “Delayed Replication”</a>.
                </p><p style="color:blue;">master_delay指定从机必须滞后于主机多少秒。从主服务器接收到的事件在其在主服务器上执行之后至少间隔秒才会执行。默认值为0。如果间隔不是0到231-1范围内的非负整数，则会发生错误。有关更多信息，请参阅第16.3.10节“延迟复制”。</p><p>
                From MySQL 5.7, a <code class="literal">CHANGE MASTER TO</code> statement
                employing the <code class="literal">MASTER_DELAY</code> option can be
                executed on a running slave when the slave SQL thread is
                stopped.
            </p><p style="color:blue;">在mysql 5.7中，当从sql线程停止时，可以在正在运行的从机上执行使用master_delay选项的change master to语句。</p><p>
                <code class="literal">MASTER_BIND</code> is for use on replication slaves
                having multiple network interfaces, and determines which of the
                slave's network interfaces is chosen for connecting to the
                master.
            </p><p style="color:blue;">master_bind用于具有多个网络接口的复制从机，并确定选择哪个从机的网络接口连接到主机。</p><p>
                The address configured with this option, if any, can be seen in
                the <code class="literal">Master_Bind</code> column of the output from
                <a class="link" href="sql-syntax.html#show-slave-status" title="13.7.5.34&nbsp;SHOW SLAVE STATUS Syntax"><code class="literal">SHOW SLAVE STATUS</code></a>. If you are
                using slave status log tables (server started with
                <a class="link" href="replication.html#option_mysqld_master-info-repository"><code class="option">--master-info-repository=TABLE</code></a>),
                the value can also be seen as the <code class="literal">Master_bind</code>
                column of the <code class="literal">mysql.slave_master_info</code> table.
            </p><p style="color:blue;">使用此选项配置的地址（如果有）可以在“显示从属状态”输出的“主绑定”列中看到。如果您使用的是从机状态日志表（服务器以--master info repository=table启动），则该值也可以看作mysql.slave_master_info表的master_bind列。</p><p>
                The ability to bind a replication slave to a specific network
                interface is also supported by NDB Cluster.
            </p><p style="color:blue;">ndb集群还支持将复制从属服务器绑定到特定网络接口的功能。</p><p>
                <code class="literal">MASTER_LOG_FILE</code> and
                <code class="literal">MASTER_LOG_POS</code> are the coordinates at which
                the slave I/O thread should begin reading from the master the
                next time the thread starts. <code class="literal">RELAY_LOG_FILE</code>
                and <code class="literal">RELAY_LOG_POS</code> are the coordinates at
                which the slave SQL thread should begin reading from the relay
                log the next time the thread starts. If you specify either of
                <code class="literal">MASTER_LOG_FILE</code> or
                <code class="literal">MASTER_LOG_POS</code>, you cannot specify
                <code class="literal">RELAY_LOG_FILE</code> or
                <code class="literal">RELAY_LOG_POS</code>. If you specify either of
                <code class="literal">MASTER_LOG_FILE</code> or
                <code class="literal">MASTER_LOG_POS</code>, you also cannot specify
                <code class="literal">MASTER_AUTO_POSITION = 1</code> (described later in
                this section). If neither of <code class="literal">MASTER_LOG_FILE</code>
                or <code class="literal">MASTER_LOG_POS</code> is specified, the slave
                uses the last coordinates of the <span class="emphasis"><em>slave SQL
        thread</em></span> before <a class="link" href="sql-syntax.html#change-master-to" title="13.4.2.1&nbsp;CHANGE MASTER TO Syntax"><code class="literal">CHANGE MASTER
                TO</code></a> was issued. This ensures that there is no
                discontinuity in replication, even if the slave SQL thread was
                late compared to the slave I/O thread, when you merely want to
                change, say, the password to use.
            </p><p style="color:blue;">master_log_file和master_log_pos是下次线程启动时从I/O线程应开始从主线程读取的坐标。relay_log_file和relay_log_pos是从属sql线程下次启动时应开始从中继日志读取的坐标。如果指定主日志文件或主日志位置，则不能指定中继日志文件或中继日志位置。如果指定主日志文件或主日志位置，则也不能指定主自动位置=1（本节稍后介绍）。如果未指定master_log_文件或master_log_pos，则slave将使用发出change master to之前的slave sql线程的最后一个坐标。这可以确保复制过程中不会出现中断，即使与从机I/O线程相比，从机SQL线程延迟了，但您只需要更改要使用的密码。</p><p>
                From MySQL 5.7, a <code class="literal">CHANGE MASTER TO</code> statement
                employing <code class="literal">RELAY_LOG_FILE</code>,
                <code class="literal">RELAY_LOG_POS</code>, or both options can be
                executed on a running slave when the slave SQL thread is
                stopped. Prior to MySQL 5.7.4, <code class="literal">CHANGE MASTER
                TO</code> deletes all relay log files and starts a new one,
                unless you specify <code class="literal">RELAY_LOG_FILE</code> or
                <code class="literal">RELAY_LOG_POS</code>. In that case, relay log files
                are kept; the <a class="link" href="replication.html#sysvar_relay_log_purge"><code class="literal">relay_log_purge</code></a>
                global variable is set silently to 0. In MySQL 5.7.4 and later,
                relay logs are preserved if at least one of the slave SQL thread
                and the slave I/O thread is running; if both threads are
                stopped, all relay log files are deleted unless at least one of
                <code class="literal">RELAY_LOG_FILE</code> or
                <code class="literal">RELAY_LOG_POS</code> is specified.
            </p><p style="color:blue;">在mysql 5.7中，当从sql线程停止时，可以在运行的从机上执行使用relay_log_file、relay_log_pos或这两个选项的change master to语句。在mysql 5.7.4之前，将master更改为删除所有中继日志文件并启动新的中继日志文件，除非指定了中继日志文件或中继日志位置。在这种情况下，将保留中继日志文件；中继日志清除全局变量将静默设置为0。在mysql 5.7.4及更高版本中，如果至少有一个从sql线程和从i/o线程正在运行，则保留中继日志；如果两个线程都已停止，则删除所有中继日志文件，除非至少指定了一个中继日志文件或中继日志位置。</p><p>
                <code class="literal">RELAY_LOG_FILE</code> can use either an absolute or
                relative path, and uses the same base name as
                <code class="literal">MASTER_LOG_FILE</code>. (Bug #12190)
            </p><p style="color:blue;">中继日志文件可以使用绝对路径或相对路径，并且使用与主日志文件相同的基名。（错误12190）</p><p>
                When <code class="literal">MASTER_AUTO_POSITION = 1</code> is used with
                <code class="literal">CHANGE MASTER TO</code>, the slave attempts to
                connect to the master using the GTID-based replication protocol.
                From MySQL 5.7, this option can be employed by <code class="literal">CHANGE
                MASTER TO</code> only if both the slave SQL and slave I/O
                threads are stopped. Both the slave and the master must have
                GTIDs enabled (<a class="link" href="replication.html#sysvar_gtid_mode"><code class="literal">GTID_MODE=ON</code></a>,
                <code class="literal">ON_PERMISSIVE,</code> or
                <code class="literal">OFF_PERMISSIVE</code> on the slave, and
                <a class="link" href="replication.html#sysvar_gtid_mode"><code class="literal">GTID_MODE=ON</code></a> on the master).
                Auto-positioning is used for the connection, so the coordinates
                represented by <code class="literal">MASTER_LOG_FILE</code> and
                <code class="literal">MASTER_LOG_POS</code> are not used, and the use of
                either or both of these options together with
                <code class="literal">MASTER_AUTO_POSITION = 1</code> causes an error. If
                multi-source replication is enabled on the slave, you need to
                set the <code class="literal">MASTER_AUTO_POSITION = 1</code> option for
                each applicable replication channel.
            </p><p style="color:blue;">当master_auto_position=1与change master to一起使用时，从机尝试使用基于gtid的复制协议连接到主机。从mysql 5.7开始，只有当从sql和从i/o线程都停止时，这个选项才能被change master使用。从机和主机都必须启用GTID（从机上的GTID_mode=on，on_permissive，or off_permissive，主机上的GTID_mode=on）。自动定位用于连接，因此不使用由master_log_文件和master_log_pos表示的坐标，使用其中一个或两个选项以及master_auto_position=1会导致错误。如果在从机上启用了多源复制，则需要为每个适用的复制通道设置master_auto_position=1选项。</p><p>
                With <code class="literal">MASTER_AUTO_POSITION = 1</code> set, in the
                initial connection handshake, the slave sends a GTID set
                containing the transactions that it has already received,
                committed, or both. The master responds by sending all
                transactions recorded in its binary log whose GTID is not
                included in the GTID set sent by the slave. This exchange
                ensures that the master only sends the transactions with a GTID
                that the slave has not already recorded or committed. If the
                slave receives transactions from more than one master, as in the
                case of a diamond topology, the auto-skip function ensures that
                the transactions are not applied twice. For details of how the
                GTID set sent by the slave is computed, see
                <a class="xref" href="replication.html#replication-gtids-auto-positioning" title="16.1.3.3&nbsp;GTID Auto-Positioning">Section&nbsp;16.1.3.3, “GTID Auto-Positioning”</a>.
            </p><p style="color:blue;">在设置master_auto_position=1的情况下，在初始连接握手中，从机发送一个gtid集，其中包含它已经接收、提交或同时接收到的事务。主服务器通过发送记录在其二进制日志中的所有事务进行响应，这些事务的gtid不包括在从服务器发送的gtid集中。此交换确保主服务器只发送带有从服务器尚未记录或提交的gtid的事务。如果从机从多个主机接收事务，如菱形拓扑，则自动跳过功能确保事务不会应用两次。有关如何计算从机发送的gtid集的详细信息，请参见第16.1.3.3节“gtid自动定位”。</p><p>
                If any of the transactions that should be sent by the master
                have been purged from the master's binary log, or added to the
                set of GTIDs in the <a class="link" href="replication.html#sysvar_gtid_purged"><code class="literal">gtid_purged</code></a>
                system variable by another method, the master sends the error
                <span class="errorname">ER_MASTER_HAS_PURGED_REQUIRED_GTIDS</span> to
                the slave, and replication does not start. Also, if during the
                exchange of transactions it is found that the slave has recorded
                or committed transactions with the master's UUID in the GTID,
                but the master itself has not committed them, the master sends
                the error
                <span class="errorname">ER_SLAVE_HAS_MORE_GTIDS_THAN_MASTER</span> to
                the slave and replication does not start. For information on how
                to handle these situations, see
                <a class="xref" href="replication.html#replication-gtids-auto-positioning" title="16.1.3.3&nbsp;GTID Auto-Positioning">Section&nbsp;16.1.3.3, “GTID Auto-Positioning”</a>.
            </p><p style="color:blue;">如果主服务器应发送的任何事务已从主服务器的二进制日志中清除，或通过另一种方法添加到GTID清除的系统变量中的GTID集合中，则主服务器将错误ERU MASTER清除的GTID发送到从服务器，并且复制不会启动。此外，如果在事务交换期间发现从机在gtid中记录或提交了与主机uuid的事务，但主机本身没有提交这些事务，则主机向从机发送错误er_slave_比u master有更多的gtid，并且复制不会启动。有关如何处理这些情况的信息，请参阅第16.1.3.3节“GTID自动定位”。</p><p>
                You can see whether replication is running with auto-positioning
                enabled by checking the Performance Schema
                <a class="link" href="performance-schema.html#replication-connection-status-table" title="25.12.11.2&nbsp;The replication_connection_status Table"><code class="literal">replication_connection_status</code></a> table
                or the output of <a class="link" href="sql-syntax.html#show-slave-status" title="13.7.5.34&nbsp;SHOW SLAVE STATUS Syntax"><code class="literal">SHOW SLAVE
                STATUS</code></a>. Disabling the
                <code class="literal">MASTER_AUTO_POSITION</code> option again makes the
                slave revert to file-based replication, in which case you must
                also specify one or both of the
                <code class="literal">MASTER_LOG_FILE</code> or
                <code class="literal">MASTER_LOG_POS</code> options.
            </p><p style="color:blue;">通过检查performance schema replication_connection_status表或show slave status的输出，可以查看复制是否在启用自动定位的情况下运行。再次禁用master_auto_position选项将使从机还原为基于文件的复制，在这种情况下，还必须指定一个或两个master_log_file或master_log_pos选项。</p><p>
                <code class="literal">IGNORE_SERVER_IDS</code> takes a comma-separated
                list of 0 or more server IDs. Events originating from the
                corresponding servers are ignored, with the exception of log
                rotation and deletion events, which are still recorded in the
                relay log.
            </p><p style="color:blue;">ignore_server_ids采用0个或多个服务器id的逗号分隔列表。将忽略来自相应服务器的事件，但日志旋转和删除事件除外，这些事件仍记录在中继日志中。</p><p>
                In circular replication, the originating server normally acts as
                the terminator of its own events, so that they are not applied
                more than once. Thus, this option is useful in circular
                replication when one of the servers in the circle is removed.
                Suppose that you have a circular replication setup with 4
                servers, having server IDs 1, 2, 3, and 4, and server 3 fails.
                When bridging the gap by starting replication from server 2 to
                server 4, you can include <code class="literal">IGNORE_SERVER_IDS =
                (3)</code> in the <a class="link" href="sql-syntax.html#change-master-to" title="13.4.2.1&nbsp;CHANGE MASTER TO Syntax"><code class="literal">CHANGE MASTER
                TO</code></a> statement that you issue on server 4 to tell it to
                use server 2 as its master instead of server 3. Doing so causes
                it to ignore and not to propagate any statements that originated
                with the server that is no longer in use.
            </p><p style="color:blue;">在循环复制中，原始服务器通常充当自身事件的终结器，因此它们不会应用多次。因此，当循环中的某个服务器被删除时，此选项在循环复制中非常有用。假设您有一个带有4个服务器的循环复制设置，服务器ID为1、2、3和4，服务器3失败。当通过启动从服务器2到服务器4的复制来弥合这一差距时，可以在服务器4上发出的“将主服务器更改为”语句中包括ignore_server_ids=（3），该语句指示服务器2用作其主服务器，而不是服务器3。这样做会导致它忽略并且不会传播任何源自不再使用的服务器的语句。</p><p>
                If a <a class="link" href="sql-syntax.html#change-master-to" title="13.4.2.1&nbsp;CHANGE MASTER TO Syntax"><code class="literal">CHANGE MASTER TO</code></a> statement
                is issued without any <code class="literal">IGNORE_SERVER_IDS</code>
                option, any existing list is preserved. To clear the list of
                ignored servers, it is necessary to use the option with an empty
                list:
            </p><p style="color:blue;">如果没有任何IGRORIONServILIDS选项发布更改主机到语句，则保留任何现有列表。要清除被忽略服务器的列表，必须对空列表使用该选项：</p><pre data-lang="sql" class="programlisting">CHANGE MASTER TO IGNORE_SERVER_IDS = ();
</pre><p>
                Prior to MySQL 5.7.5,
                <a class="link" href="sql-syntax.html#reset-slave" title="13.4.2.4&nbsp;RESET SLAVE Syntax"><code class="literal">RESET SLAVE
                    ALL</code></a> has no effect on the server ID list. In MySQL
                5.7.5 and later, <code class="literal">RESET SLAVE ALL</code> clears
                <code class="literal">IGNORE_SERVER_IDS</code>. (Bug #18816897)
            </p><p style="color:blue;">在mysql 5.7.5之前，reset slave all对服务器id列表没有影响。在mysql 5.7.5及更高版本中，reset slave all清除ignore_server_id。（错误18816897）</p><p>
                If <code class="literal">IGNORE_SERVER_IDS</code> contains the
                server's own ID and the server was started with the
                <a class="link" href="replication.html#option_mysqld_replicate-same-server-id"><code class="option">--replicate-same-server-id</code></a> option
                enabled, an error results.
            </p><p style="color:blue;">如果ignore_server_id s包含服务器自己的id，并且服务器是在启用--replicate same server id选项的情况下启动的，则会导致错误。</p><p>
                The master info repository and the output of
                <a class="link" href="sql-syntax.html#show-slave-status" title="13.7.5.34&nbsp;SHOW SLAVE STATUS Syntax"><code class="literal">SHOW SLAVE STATUS</code></a> provide the
                list of servers that are currently ignored. For more
                information, see <a class="xref" href="replication.html#slave-logs-status" title="16.2.4.2&nbsp;Slave Status Logs">Section&nbsp;16.2.4.2, “Slave Status Logs”</a>, and
                <a class="xref" href="sql-syntax.html#show-slave-status" title="13.7.5.34&nbsp;SHOW SLAVE STATUS Syntax">Section&nbsp;13.7.5.34, “SHOW SLAVE STATUS Syntax”</a>.
            </p><p style="color:blue;">主信息存储库和show slave status的输出提供了当前被忽略的服务器列表。有关更多信息，请参阅第16.2.4.2节“从属状态日志”和第13.7.5.34节“显示从属状态语法”。</p><p>
                Invoking <a class="link" href="sql-syntax.html#change-master-to" title="13.4.2.1&nbsp;CHANGE MASTER TO Syntax"><code class="literal">CHANGE MASTER TO</code></a> causes
                the previous values for <code class="literal">MASTER_HOST</code>,
                <code class="literal">MASTER_PORT</code>,
                <code class="literal">MASTER_LOG_FILE</code>, and
                <code class="literal">MASTER_LOG_POS</code> to be written to the error
                log, along with other information about the slave's state
                prior to execution.
            </p><p style="color:blue;">调用change master将导致master_host、master_port、master_log_file和master_log_pos的先前值写入错误日志，以及有关在执行之前从机状态的其他信息。</p><p>
                <code class="literal">CHANGE MASTER TO</code> causes an implicit commit of
                an ongoing transaction. See <a class="xref" href="sql-syntax.html#implicit-commit" title="13.3.3&nbsp;Statements That Cause an Implicit Commit">Section&nbsp;13.3.3, “Statements That Cause an Implicit Commit”</a>.
            </p><p style="color:blue;">将master更改为导致正在进行的事务的隐式提交。参见第13.3.3节，“导致隐式提交的语句”。</p><p>
                In MySQL 5.7.4 and later, the strict requirement to execute
                <a class="link" href="sql-syntax.html#stop-slave" title="13.4.2.7&nbsp;STOP SLAVE Syntax"><code class="literal">STOP SLAVE</code></a> prior to issuing any
                <a class="link" href="sql-syntax.html#change-master-to" title="13.4.2.1&nbsp;CHANGE MASTER TO Syntax"><code class="literal">CHANGE MASTER TO</code></a> statement (and
                <a class="link" href="sql-syntax.html#start-slave" title="13.4.2.6&nbsp;START SLAVE Syntax"><code class="literal">START SLAVE</code></a> afterward) is
                removed. Instead of depending on whether the slave is stopped,
                the behavior of <code class="literal">CHANGE MASTER TO</code> depends (in
                MySQL 5.7.4 and later) on the states of the slave SQL thread and
                slave I/O threads; which of these threads is stopped or running
                now determines the options that can or cannot be used with a
                <code class="literal">CHANGE MASTER TO</code> statement at a given point
                in time. The rules for making this determination are listed
                here:
            </p><p style="color:blue;">在mysql 5.7.4及更高版本中，删除了在发出任何change master to语句之前执行stop slave（以及之后启动slave）的严格要求。更改master to的行为（在mysql 5.7.4及更高版本中）不是取决于从机是否已停止，而是取决于从机sql线程和从机i/o线程的状态；这些线程中的哪一个已停止或正在运行现在决定了在给定时间点可以或不能与change master to语句一起使用的选项。作出这一决定的规则如下：</p>
                <div class="itemizedlist">
                    <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                        If the SQL thread is stopped, you can execute
                        <code class="literal">CHANGE MASTER TO</code> using any combination
                        that is otherwise allowed of
                        <code class="literal">RELAY_LOG_FILE</code>,
                        <code class="literal">RELAY_LOG_POS</code>, and
                        <code class="literal">MASTER_DELAY</code> options, even if the slave
                        I/O thread is running. No other options may be used with
                        this statement when the I/O thread is running.
                    </p><p style="color:blue;">如果SQL线程已停止，则可以使用中继日志文件、中继日志位置和主延迟选项允许的任何组合来执行更改主线程，即使从I/O线程正在运行。当I/O线程运行时，此语句不能使用其他选项。</p></li><li class="listitem"><p>
                        If the I/O thread is stopped, you can execute
                        <code class="literal">CHANGE MASTER TO</code> using any of the options
                        for this statement (in any allowed combination)
                        <span class="emphasis"><em>except</em></span>
                        <code class="literal">RELAY_LOG_FILE</code>,
                        <code class="literal">RELAY_LOG_POS</code>,
                        <code class="literal">MASTER_DELAY</code>, or
                        <code class="literal">MASTER_AUTO_POSITION = 1</code> even when the
                        SQL thread is running.
                    </p><p style="color:blue;">如果I/O线程已停止，则可以使用此语句的任何选项（在任何允许的组合中）执行change master，除了relay_log_file、relay_log_pos、master_delay或master_auto_position=1，即使SQL线程正在运行。</p></li><li class="listitem"><p>
                        Both the SQL thread and the I/O thread must be stopped
                        before issuing a <code class="literal">CHANGE MASTER TO</code>
                        statement that employs <code class="literal">MASTER_AUTO_POSITION =
                        1</code>.
                    </p><p style="color:blue;">在发出使用master_auto_position=1的change master to语句之前，必须停止sql线程和i/o线程。</p></li></ul>
                </div>
                <p>
                    You can check the current state of the slave SQL and I/O threads
                    using <a class="link" href="sql-syntax.html#show-slave-status" title="13.7.5.34&nbsp;SHOW SLAVE STATUS Syntax"><code class="literal">SHOW SLAVE STATUS</code></a>.
                </p><p style="color:blue;">可以使用show slave status检查从属sql和i/o线程的当前状态。</p><p>
                For more information, see
                <a class="xref" href="replication.html#replication-solutions-switch" title="16.3.7&nbsp;Switching Masters During Failover">Section&nbsp;16.3.7, “Switching Masters During Failover”</a>.
            </p><p style="color:blue;">有关更多信息，请参阅16.3.7节“故障转移期间切换主机”。</p><p>
                If you are using statement-based replication and temporary
                tables, it is possible for a <code class="literal">CHANGE MASTER TO</code>
                statement following a <code class="literal">STOP SLAVE</code> statement to
                leave behind temporary tables on the slave. From MySQL 5.7, a
                warning
                (<a class="link" href="error-handling.html#error_er_warn_open_temp_tables_must_be_zero"><code class="literal">ER_WARN_OPEN_TEMP_TABLES_MUST_BE_ZERO</code></a>)
                is issued whenever this occurs. You can avoid this in such cases
                by making sure that the value of the
                <a class="link" href="server-administration.html#statvar_Slave_open_temp_tables"><code class="literal">Slave_open_temp_tables</code></a>
                system status variable is equal to 0 prior to executing such a
                <code class="literal">CHANGE MASTER TO</code> statement.
            </p><p style="color:blue;">如果使用基于语句的复制和临时表，则在stop slave语句之后的change master to语句可能会在slave上留下临时表。在mysql 5.7中，每当发生这种情况时，都会发出警告（er_warn_open_temp_tables_must_be_zero）。在这种情况下，可以通过在执行这样的change master to语句之前确保slave_open_temp_tables系统状态变量的值等于0来避免这种情况。</p><p>
                <a class="link" href="sql-syntax.html#change-master-to" title="13.4.2.1&nbsp;CHANGE MASTER TO Syntax"><code class="literal">CHANGE MASTER TO</code></a> is useful for
                setting up a slave when you have the snapshot of the master and
                have recorded the master binary log coordinates corresponding to
                the time of the snapshot. After loading the snapshot into the
                slave to synchronize it with the master, you can run
                <code class="literal">CHANGE MASTER TO
                    MASTER_LOG_FILE='<em class="replaceable"><code>log_name</code></em>',
                    MASTER_LOG_POS=<em class="replaceable"><code>log_pos</code></em></code> on
                the slave to specify the coordinates at which the slave should
                begin reading the master binary log.
            </p><p style="color:blue;">将master更改为对于在拥有主快照并已记录与快照时间对应的主二进制日志坐标时设置从机非常有用。将快照加载到从服务器以使其与主服务器同步后，可以在从服务器上运行change master to master_log_file='log_name'，master_log_pos=log_pos以指定从服务器开始读取主二进制日志的坐标。</p><p>
                The following example changes the master server the slave uses
                and establishes the master binary log coordinates from which the
                slave begins reading. This is used when you want to set up the
                slave to replicate the master:
            </p><p style="color:blue;">以下示例更改从服务器使用的主服务器，并建立从服务器开始读取的主二进制日志坐标。如果要设置从机以复制主机，则使用此选项：</p><pre data-lang="sql" class="programlisting">CHANGE MASTER TO
  MASTER_HOST='master2.example.com',
  MASTER_USER='replication',
  MASTER_PASSWORD='<em class="replaceable"><code>password</code></em>',
  MASTER_PORT=3306,
  MASTER_LOG_FILE='master2-bin.001',
  MASTER_LOG_POS=4,
  MASTER_CONNECT_RETRY=10;
</pre><p>
                The next example shows an operation that is less frequently
                employed. It is used when the slave has relay log files that you
                want it to execute again for some reason. To do this, the master
                need not be reachable. You need only use
                <a class="link" href="sql-syntax.html#change-master-to" title="13.4.2.1&nbsp;CHANGE MASTER TO Syntax"><code class="literal">CHANGE MASTER TO</code></a> and start the
                SQL thread (<code class="literal">START SLAVE SQL_THREAD</code>):
            </p><p style="color:blue;">下一个例子展示了一个使用频率较低的操作。当从机具有中继日志文件时，由于某种原因需要再次执行该文件时，将使用该命令。要做到这一点，主人不必是可达的。您只需要使用change master来启动sql线程（start slave sql_thread）：</p><pre data-lang="sql" class="programlisting">CHANGE MASTER TO
  RELAY_LOG_FILE='slave-relay-bin.006',
  RELAY_LOG_POS=4025;
</pre><p>
                The following table shows the maximum permissible length for the
                string-valued options.
            </p><p style="color:blue;">下表显示了字符串值选项的最大允许长度。</p>
                <div class="informaltable">
                    <table summary="The maximum permissible length for CHANGE MASTER TO string-valued options."><colgroup><col width="50%"><col width="50%"></colgroup><thead><tr>
                        <th scope="col">Option</th>
                        <th scope="col">Maximum Length</th>
                    </tr></thead><tbody><tr>
                        <td scope="row"><code class="literal">MASTER_HOST</code></td>
                        <td>60</td>
                    </tr><tr>
                        <td scope="row"><code class="literal">MASTER_USER</code></td>
                        <td>96</td>
                    </tr><tr>
                        <td scope="row"><code class="literal">MASTER_PASSWORD</code></td>
                        <td>32</td>
                    </tr><tr>
                        <td scope="row"><code class="literal">MASTER_LOG_FILE</code></td>
                        <td>511</td>
                    </tr><tr>
                        <td scope="row"><code class="literal">RELAY_LOG_FILE</code></td>
                        <td>511</td>
                    </tr><tr>
                        <td scope="row"><code class="literal">MASTER_SSL_CA</code></td>
                        <td>511</td>
                    </tr><tr>
                        <td scope="row"><code class="literal">MASTER_SSL_CAPATH</code></td>
                        <td>511</td>
                    </tr><tr>
                        <td scope="row"><code class="literal">MASTER_SSL_CERT</code></td>
                        <td>511</td>
                    </tr><tr>
                        <td scope="row"><code class="literal">MASTER_SSL_CRL</code></td>
                        <td>511</td>
                    </tr><tr>
                        <td scope="row"><code class="literal">MASTER_SSL_CRLPATH</code></td>
                        <td>511</td>
                    </tr><tr>
                        <td scope="row"><code class="literal">MASTER_SSL_KEY</code></td>
                        <td>511</td>
                    </tr><tr>
                        <td scope="row"><code class="literal">MASTER_SSL_CIPHER</code></td>
                        <td>511</td>
                    </tr><tr>
                        <td scope="row"><code class="literal">MASTER_TLS_VERSION</code></td>
                        <td>511</td>
                    </tr></tbody></table>
                </div>

            </div>
            <div class="section">
                <div class="titlepage">
                    <div>
                        <div>
                            <h4 class="title"><a name="change-replication-filter"></a>13.4.2.2&nbsp;CHANGE REPLICATION FILTER Syntax</h4>

                        </div>

                    </div>

                </div>
                <a class="indexterm" name="idm140286832225472"></a><pre data-lang="sql" class="programlisting">CHANGE REPLICATION FILTER <em class="replaceable"><code>filter</code></em>[, <em class="replaceable"><code>filter</code></em>][, ...]

<em class="replaceable"><code>filter</code></em>:
    REPLICATE_DO_DB = (<em class="replaceable"><code>db_list</code></em>)
  | REPLICATE_IGNORE_DB = (<em class="replaceable"><code>db_list</code></em>)
  | REPLICATE_DO_TABLE = (<em class="replaceable"><code>tbl_list</code></em>)
  | REPLICATE_IGNORE_TABLE = (<em class="replaceable"><code>tbl_list</code></em>)
  | REPLICATE_WILD_DO_TABLE = (<em class="replaceable"><code>wild_tbl_list</code></em>)
  | REPLICATE_WILD_IGNORE_TABLE = (<em class="replaceable"><code>wild_tbl_list</code></em>)
  | REPLICATE_REWRITE_DB = (<em class="replaceable"><code>db_pair_list</code></em>)

<em class="replaceable"><code>db_list</code></em>:
    <em class="replaceable"><code>db_name</code></em>[, <em class="replaceable"><code>db_name</code></em>][, ...]

<em class="replaceable"><code>tbl_list</code></em>:
    <em class="replaceable"><code>db_name.table_name</code></em>[, <em class="replaceable"><code>db_table_name</code></em>][, ...]
<em class="replaceable"><code>wild_tbl_list</code></em>:
    '<em class="replaceable"><code>db_pattern.table_pattern</code></em>'[, '<em class="replaceable"><code>db_pattern.table_pattern</code></em>'][, ...]

<em class="replaceable"><code>db_pair_list</code></em>:
    (<em class="replaceable"><code>db_pair</code></em>)[, (<em class="replaceable"><code>db_pair</code></em>)][, ...]

<em class="replaceable"><code>db_pair</code></em>:
    <em class="replaceable"><code>from_db</code></em>, <em class="replaceable"><code>to_db</code></em>
</pre><p>
                <code class="literal">CHANGE REPLICATION FILTER</code> sets one or more
                replication filtering rules on the slave in the same way as
                starting the slave <a class="link" href="programs.html#mysqld" title="4.3.1&nbsp;mysqld — The MySQL Server"><span class="command"><strong>mysqld</strong></span></a> with replication
                filtering options such as
                <a class="link" href="replication.html#option_mysqld_replicate-do-db"><code class="option">--replicate-do-db</code></a> or
                <a class="link" href="replication.html#option_mysqld_replicate-wild-ignore-table"><code class="option">--replicate-wild-ignore-table</code></a>.
                Unlike the case with the server options, this statement does not
                require restarting the server to take effect, only that the
                slave SQL thread be stopped using
                <a class="link" href="sql-syntax.html#stop-slave" title="13.4.2.7&nbsp;STOP SLAVE Syntax"><code class="literal">STOP SLAVE
                    SQL_THREAD</code></a> first (and restarted with
                <a class="link" href="sql-syntax.html#start-slave" title="13.4.2.6&nbsp;START SLAVE Syntax"><code class="literal">START SLAVE
                    SQL_THREAD</code></a> afterwards). <a class="link" href="sql-syntax.html#change-replication-filter" title="13.4.2.2&nbsp;CHANGE REPLICATION FILTER Syntax"><code class="literal">CHANGE
                REPLICATION FILTER</code></a> requires the
                <a class="link" href="security.html#priv_super"><code class="literal">SUPER</code></a> privilege.
            </p><p style="color:blue;">change replication filter使用复制筛选选项（如--replicate do db或--replicate wild ignore table）启动从mysqld时，在从机上设置一个或多个复制筛选规则。与服务器选项不同，此语句不需要重新启动服务器才能生效，只需要先使用stop slave sql_thread停止从属sql线程（然后使用start slave sql_thread重新启动）。更改复制筛选器需要超级权限。</p><p>
            </p>
                <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">

                    <div class="admon-title">
                        Note
                    </div>
                    <p>
                        Replication filters cannot be set on a MySQL server instance
                        that is configured for Group Replication, because filtering
                        transactions on some servers would make the group unable to
                        reach agreement on a consistent state.
                    </p><p style="color:blue;">无法在为组复制配置的MySQL服务器实例上设置复制筛选器，因为在某些服务器上筛选事务将使组无法就一致状态达成一致。</p>
                </div>
                <p>
                </p><p>
                The following list shows the <code class="literal">CHANGE REPLICATION
                FILTER</code> options and how they relate to
                <code class="option">--replicate-*</code> server options:
            </p><p style="color:blue;">下表显示了更改复制筛选器选项及其与--replicate-*服务器选项的关系：</p>
                <div class="itemizedlist">
                    <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                        <code class="literal">REPLICATE_DO_DB</code>: Include updates based on
                        database name. Equivalent to
                        <a class="link" href="replication.html#option_mysqld_replicate-do-db"><code class="option">--replicate-do-db</code></a>.
                    </p><p style="color:blue;">复制数据库：包括基于数据库名称的更新。相当于--replicate do db。</p></li><li class="listitem"><p>
                        <code class="literal">REPLICATE_IGNORE_DB</code>: Exclude updates
                        based on database name. Equivalent to
                        <a class="link" href="replication.html#option_mysqld_replicate-ignore-db"><code class="option">--replicate-ignore-db</code></a>.
                    </p><p style="color:blue;">replicate_ignore_db:根据数据库名称排除更新。相当于--replicate ignore db。</p></li><li class="listitem"><p>
                        <code class="literal">REPLICATE_DO_TABLE</code>: Include updates based
                        on table name. Equivalent to
                        <a class="link" href="replication.html#option_mysqld_replicate-do-table"><code class="option">--replicate-do-table</code></a>.
                    </p><p style="color:blue;">复制表：包括基于表名的更新。相当于--replicate do table。</p></li><li class="listitem"><p>
                        <code class="literal">REPLICATE_IGNORE_TABLE</code>: Exclude updates
                        based on table name. Equivalent to
                        <a class="link" href="replication.html#option_mysqld_replicate-ignore-table"><code class="option">--replicate-ignore-table</code></a>.
                    </p><p style="color:blue;">replicate_ignore_table：根据表名排除更新。等价于--replicate ignore table。</p></li><li class="listitem"><p>
                        <code class="literal">REPLICATE_WILD_DO_TABLE</code>: Include updates
                        based on wildcard pattern matching table name. Equivalent to
                        <a class="link" href="replication.html#option_mysqld_replicate-wild-do-table"><code class="option">--replicate-wild-do-table</code></a>.
                    </p><p style="color:blue;">replicate_wild_do_table：包含基于与表名匹配的通配符模式的更新。相当于--复制野生do表。</p></li><li class="listitem"><p>
                        <code class="literal">REPLICATE_WILD_IGNORE_TABLE</code>: Exclude
                        updates based on wildcard pattern matching table name.
                        Equivalent to
                        <a class="link" href="replication.html#option_mysqld_replicate-wild-ignore-table"><code class="option">--replicate-wild-ignore-table</code></a>.
                    </p><p style="color:blue;">replicate_wild_ignore_table：根据与表名匹配的通配符模式排除更新。相当于--replicate wild ignore table。</p></li><li class="listitem"><p>
                        <code class="literal">REPLICATE_REWRITE_DB</code>: Perform updates on
                        slave after substituting new name on slave for specified
                        database on master. Equivalent to
                        <a class="link" href="replication.html#option_mysqld_replicate-rewrite-db"><code class="option">--replicate-rewrite-db</code></a>.
                    </p><p style="color:blue;">replicate_rewrite_db：将从机上的新名称替换为主机上的指定数据库后，对从机执行更新。相当于--replicate rewrite db。</p></li></ul>
                </div>
                <p>
                    The precise effects of <code class="literal">REPLICATE_DO_DB</code> and
                    <code class="literal">REPLICATE_IGNORE_DB</code> filters are dependent on
                    whether statement-based or row-based replication is in effect.
                    See <a class="xref" href="replication.html#replication-rules" title="16.2.5&nbsp;How Servers Evaluate Replication Filtering Rules">Section&nbsp;16.2.5, “How Servers Evaluate Replication Filtering Rules”</a>, for more information.
                </p><p style="color:blue;">replicate_do_db和replicate_ignore_db过滤器的精确效果取决于基于语句的复制还是基于行的复制是否有效。有关详细信息，请参阅第16.2.5节“服务器如何评估复制筛选规则”。</p><p>
                Multiple replication filtering rules can be created in a single
                <code class="literal">CHANGE REPLICATION FILTER</code> statement by
                separating the rules with commas, as shown here:
            </p><p style="color:blue;">通过用逗号分隔规则，可以在单个更改复制筛选器语句中创建多个复制筛选规则，如下所示：</p><pre data-lang="sql" class="programlisting">CHANGE REPLICATION FILTER
    REPLICATE_DO_DB = (d1), REPLICATE_IGNORE_DB = (d2);
</pre><p>
                Issuing the statement just shown is equivalent to starting the
                slave <a class="link" href="programs.html#mysqld" title="4.3.1&nbsp;mysqld — The MySQL Server"><span class="command"><strong>mysqld</strong></span></a> with the options
                <a class="link" href="replication.html#option_mysqld_replicate-do-db"><code class="option">--replicate-do-db=d1</code></a>
                <a class="link" href="replication.html#option_mysqld_replicate-ignore-db"><code class="option">--replicate-ignore-db=d2</code></a>.
            </p><p style="color:blue;">发出刚才显示的语句相当于使用选项--replicate do db=d1--replicate ignore db=d2启动从mysqld。</p><p>
                If the same filtering rule is specified multiple times, only the
                <span class="emphasis"><em>last</em></span> such rule is actually used. For
                example, the two statements shown here have exactly the same
                effect, because the first <code class="literal">REPLICATE_DO_DB</code>
                rule in the first statement is ignored:
            </p><p style="color:blue;">如果多次指定同一筛选规则，则仅实际使用最后一个这样的规则。例如，这里显示的两个语句具有完全相同的效果，因为第一个语句中的第一个replicate_do_db规则被忽略：</p><pre data-lang="sql" class="programlisting">CHANGE REPLICATION FILTER
    REPLICATE_DO_DB = (db1, db2), REPLICATE_DO_DB = (db3, db4);

CHANGE REPLICATION FILTER
    REPLICATE_DO_DB = (db3,db4);
</pre>
                <div class="caution" style="margin-left: 0.5in; margin-right: 0.5in;">

                    <div class="admon-title">
                        Caution
                    </div>
                    <p>
                        This behavior differs from that of the
                        <code class="option">--replicate-*</code> filter options where specifying
                        the same option multiple times causes the creation of multiple
                        filter rules.
                    </p><p style="color:blue;">此行为与--replicate-*筛选选项的行为不同，在这些选项中多次指定同一个选项会导致创建多个筛选规则。</p>
                </div>
                <p>
                    Names of tables and database not containing any special
                    characters need not be quoted. Values used with
                    <code class="literal">REPLICATION_WILD_TABLE</code> and
                    <code class="literal">REPLICATION_WILD_IGNORE_TABLE</code> are string
                    expressions, possibly containing (special) wildcard characters,
                    and so must be quoted. This is shown in the following example
                    statements:
                </p><p style="color:blue;">不需要引用不包含任何特殊字符的表和数据库的名称。与replication_wild_table和replication_wild_ignore_table一起使用的值是字符串表达式，可能包含（特殊）通配符，因此必须引用。这在下面的示例语句中显示：</p><pre data-lang="sql" class="programlisting">CHANGE REPLICATION FILTER
    REPLICATE_WILD_DO_TABLE = ('db1.old%');

CHANGE REPLICATION FILTER
    REPLICATE_WILD_IGNORE_TABLE = ('db1.new%', 'db2.new%');
</pre><p>
                Values used with <code class="literal">REPLICATE_REWRITE_DB</code>
                represent <span class="emphasis"><em>pairs</em></span> of database names; each
                such value must be enclosed in parentheses. The following
                statement rewrites statements occurring on database
                <code class="literal">db1</code> on the master to database
                <code class="literal">db2</code> on the slave:
            </p><p style="color:blue;">与replicate_rewrite_db一起使用的值表示数据库名称对；每个此类值都必须括在括号中。以下语句将发生在主数据库db1上的语句重写为从数据库db2上的语句：</p><pre data-lang="sql" class="programlisting">CHANGE REPLICATION FILTER REPLICATE_REWRITE_DB = ((db1, db2));
</pre><p>
                The statement just shown contains two sets of parentheses, one
                enclosing the pair of database names, and the other enclosing
                the entire list. This is perhap more easily seen in the
                following example, which creates two
                <code class="literal">rewrite-db</code> rules, one rewriting database
                <code class="literal">dbA</code> to <code class="literal">dbB</code>, and one
                rewriting database <code class="literal">dbC</code> to
                <code class="literal">dbD</code>:
            </p><p style="color:blue;">刚才显示的语句包含两组括号，一组括数据库名，另一组括整个列表。下面的示例更容易看到这一点，它创建了两个重写数据库规则，一个将数据库dba重写为dbb，另一个将数据库dbc重写为dbd：</p><pre data-lang="sql" class="programlisting">CHANGE REPLICATION FILTER
  REPLICATE_REWRITE_DB = ((dbA, dbB), (dbC, dbD));
</pre><p>
                This statement leaves any existing replication filtering rules
                unchanged; to unset all filters of a given type, set the
                filter's value to an explicitly empty list, as shown in
                this example, which removes all existing
                <code class="literal">REPLICATE_DO_DB</code> and
                <code class="literal">REPLICATE_IGNORE_DB</code> rules:
            </p><p style="color:blue;">此语句使任何现有的复制过滤规则不变；为了取消给定类型的所有筛选器，将筛选器的值设置为显式空列表，如本示例中所示，它删除了所有现有的复制副本-dodoB和复制副本IGORNORYDB规则：</p><pre data-lang="sql" class="programlisting">CHANGE REPLICATION FILTER
    REPLICATE_DO_DB = (), REPLICATE_IGNORE_DB = ();
</pre><p>
                Setting a filter to empty in this way removes all existing
                rules, does not create any new ones, and does not restore any
                rules set at mysqld startup using <code class="option">--replicate-*</code>
                options on the command line or in the configuration file.
            </p><p style="color:blue;">以这种方式设置一个空的过滤器将删除所有现有的规则，不创建任何新的规则，并且不使用在命令行或配置文件中使用复制-*选项来恢复在MySQL启动时设置的任何规则。</p><p>
                Values employed with <code class="literal">REPLICATE_WILD_DO_TABLE</code>
                and <code class="literal">REPLICATE_WILD_IGNORE_TABLE</code> must be in
                the format
                <code class="literal"><em class="replaceable"><code>db_name</code></em>.<em class="replaceable"><code>tbl_name</code></em></code>.
                Prior to MySQL 5.7.5, this was not strictly enforced, although
                using nonconforming values with these options could lead to
                erroneous results (Bug #18095449).
            </p><p style="color:blue;">replicate_wild_do_table和replicate_wild_ignore_table使用的值必须采用db_name.tbl_name格式。在mysql 5.7.5之前，这并不是严格执行的，尽管对这些选项使用不一致的值可能会导致错误的结果（错误18095449）。</p><p>
                For more information, see <a class="xref" href="replication.html#replication-rules" title="16.2.5&nbsp;How Servers Evaluate Replication Filtering Rules">Section&nbsp;16.2.5, “How Servers Evaluate Replication Filtering Rules”</a>.
            </p><p style="color:blue;">有关更多信息，请参阅第16.2.5节“服务器如何评估复制筛选规则”。</p>
            </div>
            <div class="section">
                <div class="titlepage">
                    <div>
                        <div>
                            <h4 class="title"><a name="master-pos-wait"></a>13.4.2.3&nbsp;MASTER_POS_WAIT() Syntax</h4>

                        </div>

                    </div>

                </div>
                <a class="indexterm" name="idm140286832140704"></a><pre data-lang="sql" class="programlisting">SELECT MASTER_POS_WAIT('<em class="replaceable"><code>master_log_file</code></em>', <em class="replaceable"><code>master_log_pos</code></em> [, <em class="replaceable"><code>timeout</code></em>][, <em class="replaceable"><code>channel</code></em>])
</pre><p>
                This is actually a function, not a statement. It is used to
                ensure that the slave has read and executed events up to a given
                position in the master's binary log. See
                <a class="xref" href="functions.html#miscellaneous-functions" title="12.21&nbsp;Miscellaneous Functions">Section&nbsp;12.21, “Miscellaneous Functions”</a>, for a full
                description.
            </p><p style="color:blue;">这实际上是一个函数，而不是一个语句。它用于确保从机在主机二进制日志中的给定位置读取并执行事件。详细说明见第12.21节“其他功能”。</p>
            </div>
            <div class="section">
                <div class="titlepage">
                    <div>
                        <div>
                            <h4 class="title"><a name="reset-slave"></a>13.4.2.4&nbsp;RESET SLAVE Syntax</h4>

                        </div>

                    </div>

                </div>
                <a class="indexterm" name="idm140286832134416"></a><a class="indexterm" name="idm140286832133344"></a><pre data-lang="sql" class="programlisting">RESET SLAVE [ALL] [<em class="replaceable"><code>channel_option</code></em>]

<em class="replaceable"><code>channel_option</code></em>:
    FOR CHANNEL <em class="replaceable"><code>channel</code></em>
</pre><p>
                <a class="link" href="sql-syntax.html#reset-slave" title="13.4.2.4&nbsp;RESET SLAVE Syntax"><code class="literal">RESET SLAVE</code></a> makes the slave
                forget its replication position in the master's binary log. This
                statement is meant to be used for a clean start: It clears the
                master info and relay log info repositories, deletes all the
                relay log files, and starts a new relay log file. It also resets
                to 0 the replication delay specified with the
                <code class="literal">MASTER_DELAY</code> option to <code class="literal">CHANGE MASTER
                TO</code>.
            </p><p style="color:blue;">重置从机使从机忘记其在主机二进制日志中的复制位置。此语句用于干净启动：它清除主信息和中继日志信息存储库，删除所有中继日志文件，并启动新的中继日志文件。它还将使用要将master更改为的master_delay选项指定的复制延迟重置为0。</p>
                <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">

                    <div class="admon-title">
                        Note
                    </div>
                    <p>
                        All relay log files are deleted, even if they have not been
                        completely executed by the slave SQL thread. (This is a
                        condition likely to exist on a replication slave if you have
                        issued a <a class="link" href="sql-syntax.html#stop-slave" title="13.4.2.7&nbsp;STOP SLAVE Syntax"><code class="literal">STOP SLAVE</code></a> statement
                        or if the slave is highly loaded.)
                    </p><p style="color:blue;">所有中继日志文件都将被删除，即使它们尚未完全由从属SQL线程执行。（这是一个可能在复制奴隶上存在的条件，如果您已经发布了一个停止从属语句，或者如果从属服务器是高负载的。）</p>
                </div>
                <p>
                    For a server where GTIDs are in use
                    (<a class="link" href="replication.html#sysvar_gtid_mode"><code class="literal">gtid_mode</code></a> is
                    <code class="literal">ON</code>), issuing <a class="link" href="sql-syntax.html#reset-slave" title="13.4.2.4&nbsp;RESET SLAVE Syntax"><code class="literal">RESET
                    SLAVE</code></a> has no effect on the GTID execution history. The
                    statement does not change the values of
                    <code class="literal">gtid_executed</code> or
                    <code class="literal">gtid_purged</code>, or the
                    <code class="literal">mysql.gtid_executed</code> table. If you need to
                    reset the GTID execution history, use <a class="link" href="sql-syntax.html#reset-master" title="13.4.1.2&nbsp;RESET MASTER Syntax"><code class="literal">RESET
                    MASTER</code></a>, even if the GTID-enabled server is a
                    replication slave where binary logging is disabled.
                </p><p style="color:blue;">对于正在使用gtid的服务器（gtid_mode为on），发出reset slave对gtid执行历史没有影响。语句不会更改gtid_executed或gtid_purged的值，也不会更改mysql.gtid_executed表的值。如果需要重置gtid执行历史记录，请使用reset master，即使启用gtid的服务器是禁用二进制日志记录的复制从属服务器。</p><p>
                <a class="link" href="sql-syntax.html#reset-slave" title="13.4.2.4&nbsp;RESET SLAVE Syntax"><code class="literal">RESET SLAVE</code></a> requires the
                <a class="link" href="security.html#priv_reload"><code class="literal">RELOAD</code></a> privilege.
            </p><p style="color:blue;">重置从机需要重新加载权限。</p><p>
                To use <a class="link" href="sql-syntax.html#reset-slave" title="13.4.2.4&nbsp;RESET SLAVE Syntax"><code class="literal">RESET SLAVE</code></a>, the slave
                replication threads must be stopped, so on a running slave use
                <a class="link" href="sql-syntax.html#stop-slave" title="13.4.2.7&nbsp;STOP SLAVE Syntax"><code class="literal">STOP SLAVE</code></a> before issuing
                <a class="link" href="sql-syntax.html#reset-slave" title="13.4.2.4&nbsp;RESET SLAVE Syntax"><code class="literal">RESET SLAVE</code></a>. To use
                <a class="link" href="sql-syntax.html#reset-slave" title="13.4.2.4&nbsp;RESET SLAVE Syntax"><code class="literal">RESET SLAVE</code></a> on a Group
                Replication group member, the member status must be
                <code class="literal">OFFLINE</code>, meaning that the plugin is loaded
                but the member does not currently belong to any group. A group
                member can be taken offline by using a <a class="link" href="sql-syntax.html#stop-group-replication" title="13.4.3.2&nbsp;STOP GROUP_REPLICATION Syntax"><code class="literal">STOP
                GROUP REPLICATION</code></a> statement.
            </p><p style="color:blue;">要使用reset slave，必须停止从机复制线程，因此在发出reset slave之前，正在运行的从机使用stop slave。要在组复制组成员上使用reset slave，成员状态必须为offline，这意味着插件已加载，但该成员当前不属于任何组。可以使用stop group replication语句使组成员脱机。</p><p>
                The optional <code class="literal">FOR CHANNEL
                <em class="replaceable"><code>channel</code></em></code> clause enables you
                to name which replication channel the statement applies to.
                Providing a <code class="literal">FOR CHANNEL
                <em class="replaceable"><code>channel</code></em></code> clause applies the
                <code class="literal">RESET SLAVE</code> statement to a specific
                replication channel. Combining a <code class="literal">FOR CHANNEL
                <em class="replaceable"><code>channel</code></em></code> clause with the
                <code class="literal">ALL</code> option deletes the specified channel. If
                no channel is named and no extra channels exist, the statement
                applies to the default channel. Issuing a
                <a class="link" href="sql-syntax.html#reset-slave" title="13.4.2.4&nbsp;RESET SLAVE Syntax"><code class="literal">RESET SLAVE
                    ALL</code></a> statement without a <code class="literal">FOR CHANNEL
                <em class="replaceable"><code>channel</code></em></code> clause when
                multiple replication channels exist deletes
                <span class="emphasis"><em>all</em></span> replication channels and recreates only
                the default channel. See <a class="xref" href="replication.html#replication-channels" title="16.2.3&nbsp;Replication Channels">Section&nbsp;16.2.3, “Replication Channels”</a>
                for more information.
            </p><p style="color:blue;">可选的for channel channel子句允许您命名该语句应用于哪个复制通道。提供for channel channel子句将reset slave语句应用于特定的复制通道。将for channel channel子句与all选项组合使用将删除指定的通道。如果没有指定信道，并且没有额外的信道存在，则该语句应用于默认信道。在存在多个复制信道时，不使用AF信道信道子句发出复位从属所有语句，删除所有复制信道，只重建默认信道。有关更多信息，请参阅第16.2.3节“复制通道”。</p><p>
                <a class="link" href="sql-syntax.html#reset-slave" title="13.4.2.4&nbsp;RESET SLAVE Syntax"><code class="literal">RESET SLAVE</code></a> does not change any
                replication connection parameters such as master host, master
                port, master user, or master password.
            </p><p style="color:blue;">reset slave不会更改任何复制连接参数，如主主机、主端口、主用户或主密码。</p>
                <div class="itemizedlist">
                    <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                        From MySQL 5.7.24, when
                        <a class="link" href="replication.html#sysvar_master_info_repository"><code class="literal">master_info_repository=TABLE</code></a>
                        is set on the server, replication connection parameters are
                        preserved in the crash-safe <code class="literal">InnoDB</code> table
                        <code class="literal">mysql.slave_master_info</code> as part of the
                        <a class="link" href="sql-syntax.html#reset-slave" title="13.4.2.4&nbsp;RESET SLAVE Syntax"><code class="literal">RESET SLAVE</code></a> operation. They
                        are also retained in memory. In the event of a server crash
                        or deliberate restart after issuing
                        <a class="link" href="sql-syntax.html#reset-slave" title="13.4.2.4&nbsp;RESET SLAVE Syntax"><code class="literal">RESET SLAVE</code></a> but before
                        issuing <a class="link" href="sql-syntax.html#start-slave" title="13.4.2.6&nbsp;START SLAVE Syntax"><code class="literal">START SLAVE</code></a>, the
                        replication connection parameters are retrieved from the
                        table and reused for the new connection.
                    </p><p style="color:blue;">从mysql 5.7.24开始，当在服务器上设置master_info_repository=table时，复制连接参数作为重置从操作的一部分保存在崩溃安全的innodb table mysql.slave_master_info中。它们也保留在记忆中。如果在发出reset slave之后但在发出start slave之前发生服务器崩溃或故意重新启动，则从表中检索复制连接参数并将其重新用于新连接。</p></li><li class="listitem"><p>
                        When
                        <a class="link" href="replication.html#sysvar_master_info_repository"><code class="literal">master_info_repository=FILE</code></a>
                        is set on the server (which is the default in MySQL 5.7),
                        replication connection parameters are only retained in
                        memory. If the slave <a class="link" href="programs.html#mysqld" title="4.3.1&nbsp;mysqld — The MySQL Server"><span class="command"><strong>mysqld</strong></span></a> is restarted
                        immediately after issuing <a class="link" href="sql-syntax.html#reset-slave" title="13.4.2.4&nbsp;RESET SLAVE Syntax"><code class="literal">RESET
                        SLAVE</code></a> due to a server crash or deliberate restart,
                        the connection parameters are lost. In that case, you must
                        issue a <a class="link" href="sql-syntax.html#change-master-to" title="13.4.2.1&nbsp;CHANGE MASTER TO Syntax"><code class="literal">CHANGE MASTER TO</code></a>
                        statement after the server start to respecify the connection
                        parameters before issuing <a class="link" href="sql-syntax.html#start-slave" title="13.4.2.6&nbsp;START SLAVE Syntax"><code class="literal">START
                        SLAVE</code></a>.
                    </p><p style="color:blue;">当在服务器上设置master_info_repository=file（这是mysql 5.7中的默认设置）时，复制连接参数只保留在内存中。如果由于服务器崩溃或故意重新启动而在发出reset slave后立即重新启动slave mysqld，则连接参数将丢失。在这种情况下，必须在服务器启动后发出change master to语句，以便在发出start slave之前重新指定连接参数。</p></li></ul>
                </div>
                <p>
                    If you want to reset the connection parameters intentionally,
                    you need to use
                    <a class="link" href="sql-syntax.html#reset-slave" title="13.4.2.4&nbsp;RESET SLAVE Syntax"><code class="literal">RESET SLAVE
                        ALL</code></a>, which clears the connection parameters. In that
                    case, you must issue a <a class="link" href="sql-syntax.html#change-master-to" title="13.4.2.1&nbsp;CHANGE MASTER TO Syntax"><code class="literal">CHANGE MASTER
                    TO</code></a> statement after the server start to specify the new
                    connection parameters.
                </p><p style="color:blue;">如果要有意重置连接参数，则需要使用reset slave all来清除连接参数。在这种情况下，必须在服务器启动后发出change master to语句来指定新的连接参数。</p><p>
                <code class="literal">RESET SLAVE</code> causes an implicit commit of an
                ongoing transaction. See <a class="xref" href="sql-syntax.html#implicit-commit" title="13.3.3&nbsp;Statements That Cause an Implicit Commit">Section&nbsp;13.3.3, “Statements That Cause an Implicit Commit”</a>.
            </p><p style="color:blue;">reset slave导致正在进行的事务的隐式提交。参见第13.3.3节，“导致隐式提交的语句”。</p><p>
                If the slave SQL thread was in the middle of replicating
                temporary tables when it was stopped, and
                <a class="link" href="sql-syntax.html#reset-slave" title="13.4.2.4&nbsp;RESET SLAVE Syntax"><code class="literal">RESET SLAVE</code></a> is issued, these
                replicated temporary tables are deleted on the slave.
            </p><p style="color:blue;">如果从sql线程在停止时正在复制临时表，并且发出reset slave，则这些复制的临时表将在从机上删除。</p><p>
                Prior to MySQL 5.7.5, <code class="literal">RESET SLAVE</code> also had
                the effect of resetting both the heartbeat period
                (<a class="link" href="server-administration.html#statvar_Slave_heartbeat_period"><code class="literal">Slave_heartbeat_period</code></a>) and
                <code class="literal">SSL_VERIFY_SERVER_CERT</code>. This issue is fixed
                in MySQL 5.7.5 and later. (Bug #18777899, Bug #18778485)
            </p><p style="color:blue;">在mysql 5.7.5之前，reset slave还具有重置heartbeat period（slave_heartbeat_period）和ssl_verify_server_cert的效果，这个问题在mysql 5.7.5和更高版本中已经修复。（错误18777899，错误18778485）</p><p>
                Prior to MySQL 5.7.5, <code class="literal">RESET SLAVE ALL</code> did not
                clear the <code class="literal">IGNORE_SERVER_IDS</code> list set by
                <a class="link" href="sql-syntax.html#change-master-to" title="13.4.2.1&nbsp;CHANGE MASTER TO Syntax"><code class="literal">CHANGE MASTER TO</code></a>. In MySQL 5.7.5
                and later, the statement clears the list. (Bug #18816897)
            </p><p style="color:blue;">在mysql 5.7.5之前，reset slave all没有清除由change master to设置的ignore_server_ids列表。在mysql 5.7.5及更高版本中，该语句清除列表。（错误18816897）</p>
                <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">

                    <div class="admon-title">
                        Note
                    </div>
                    <p>
                        When used on an NDB Cluster replication slave SQL node,
                        <code class="literal">RESET SLAVE</code> clears the
                        <code class="literal">mysql.ndb_apply_status</code> table. You should
                        keep in mind when using this statement that
                        <code class="literal">ndb_apply_status</code> uses the
                        <a class="link" href="mysql-cluster.html" title="Chapter&nbsp;21&nbsp;MySQL NDB Cluster 7.5 and NDB Cluster 7.6"><code class="literal">NDB</code></a> storage engine and so is
                        shared by all SQL nodes attached to the slave cluster.
                    </p><p style="color:blue;">当在ndb cluster replication slave sql节点上使用时，reset slave将清除mysql.ndb_apply_状态表。在使用此语句时，应记住ndb_apply_status使用ndb存储引擎，因此由连接到从属群集的所有sql节点共享。</p><p>
                    You can override this behavior by issuing
                    <a class="link" href="sql-syntax.html#set-variable" title="13.7.4.1&nbsp;SET Syntax for Variable Assignment"><code class="literal">SET</code></a>
                    <code class="literal">GLOBAL
                        @@</code><a class="link" href="mysql-cluster.html#sysvar_ndb_clear_apply_status"><code class="literal">ndb_clear_apply_status=OFF</code></a>
                    prior to executing <code class="literal">RESET SLAVE</code>, which keeps
                    the slave from purging the <code class="literal">ndb_apply_status</code>
                    table in such cases.
                </p><p style="color:blue;">您可以通过在执行reset slave之前发出set global@ndb_clear_apply_status=off来覆盖此行为，这样在这种情况下，slave就不会清除ndb_apply_status表。</p>
                </div>

            </div>
            <div class="section">
                <div class="titlepage">
                    <div>
                        <div>
                            <h4 class="title"><a name="set-global-sql-slave-skip-counter"></a>13.4.2.5&nbsp;SET GLOBAL sql_slave_skip_counter Syntax</h4>

                        </div>

                    </div>

                </div>
                <a class="indexterm" name="idm140286832053696"></a><a class="indexterm" name="idm140286832052656"></a><a class="indexterm" name="idm140286832051584"></a><a class="indexterm" name="idm140286832050512"></a><pre data-lang="sql" class="programlisting">SET GLOBAL sql_slave_skip_counter = <em class="replaceable"><code>N</code></em>
</pre><p>
                This statement skips the next <em class="replaceable"><code>N</code></em>
                events from the master. This is useful for recovering from
                replication stops caused by a statement.
            </p><p style="color:blue;">此语句跳过主节点的下一个n事件。这对于从语句引起的复制停止恢复非常有用。</p><p>
                This statement is valid only when the slave threads are not
                running. Otherwise, it produces an error.
            </p><p style="color:blue;">此语句仅在从属线程未运行时有效。否则，会产生错误。</p><p>
                When using this statement, it is important to understand that
                the binary log is actually organized as a sequence of groups
                known as <span class="firstterm">event groups</span>.
                Each event group consists of a sequence of events.
            </p><p style="color:blue;">使用此语句时，必须了解二进制日志实际上是按称为事件组的组序列组织的。每个事件组由一系列事件组成。</p>
                <div class="itemizedlist">
                    <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                        For transactional tables, an event group corresponds to a
                        transaction.
                    </p><p style="color:blue;">对于事务表，事件组对应于事务。</p></li><li class="listitem"><p>
                        For nontransactional tables, an event group corresponds to a
                        single SQL statement.
                    </p><p style="color:blue;">对于非事务表，事件组对应于单个SQL语句。</p></li></ul>
                </div>
                <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">
                    <div class="admon-title">
                        Note
                    </div>
                    <p>
                        A single transaction can contain changes to both transactional
                        and nontransactional tables.
                    </p><p style="color:blue;">单个事务可以包含对事务表和非事务表的更改。</p>
                </div>
                <p>
                    When you use <a class="link" href="sql-syntax.html#set-global-sql-slave-skip-counter" title="13.4.2.5&nbsp;SET GLOBAL sql_slave_skip_counter Syntax"><code class="literal">SET GLOBAL
                    sql_slave_skip_counter</code></a> to skip events and the result
                    is in the middle of a group, the slave continues to skip events
                    until it reaches the end of the group. Execution then starts
                    with the next event group.
                </p><p style="color:blue;">当您使用set global sql_slave_skip_counter跳过事件并且结果位于组的中间时，从服务器将继续跳过事件，直到它到达组的末尾。然后从下一个事件组开始执行。</p>
            </div>
            <div class="section">
                <div class="titlepage">
                    <div>
                        <div>
                            <h4 class="title"><a name="start-slave"></a>13.4.2.6&nbsp;START SLAVE Syntax</h4>

                        </div>

                    </div>

                </div>
                <a class="indexterm" name="idm140286832035424"></a><pre data-lang="sql" class="programlisting">START SLAVE [<em class="replaceable"><code>thread_types</code></em>] [<em class="replaceable"><code>until_option</code></em>] [<em class="replaceable"><code>connection_options</code></em>] [<em class="replaceable"><code>channel_option</code></em>]

<em class="replaceable"><code>thread_types</code></em>:
    [<em class="replaceable"><code>thread_type</code></em> [, <em class="replaceable"><code>thread_type</code></em>] ... ]

<em class="replaceable"><code>thread_type</code></em>:
    IO_THREAD | SQL_THREAD

<em class="replaceable"><code>until_option</code></em>:
    UNTIL {   {SQL_BEFORE_GTIDS | SQL_AFTER_GTIDS} = <em class="replaceable"><code>gtid_set</code></em>
          |   MASTER_LOG_FILE = '<em class="replaceable"><code>log_name</code></em>', MASTER_LOG_POS = <em class="replaceable"><code>log_pos</code></em>
          |   RELAY_LOG_FILE = '<em class="replaceable"><code>log_name</code></em>', RELAY_LOG_POS = <em class="replaceable"><code>log_pos</code></em>
          |   SQL_AFTER_MTS_GAPS  }

<em class="replaceable"><code>connection_options</code></em>:
    [USER='<em class="replaceable"><code>user_name</code></em>'] [PASSWORD='<em class="replaceable"><code>user_pass</code></em>'] [DEFAULT_AUTH='<em class="replaceable"><code>plugin_name</code></em>'] [PLUGIN_DIR='<em class="replaceable"><code>plugin_dir</code></em>']


<em class="replaceable"><code>channel_option</code></em>:
    FOR CHANNEL <em class="replaceable"><code>channel</code></em>

<em class="replaceable"><code>gtid_set</code></em>:
    <em class="replaceable"><code>uuid_set</code></em> [, <em class="replaceable"><code>uuid_set</code></em>] ...
    | ''

<em class="replaceable"><code>uuid_set</code></em>:
    <em class="replaceable"><code>uuid</code></em>:<em class="replaceable"><code>interval</code></em>[:<em class="replaceable"><code>interval</code></em>]...

<em class="replaceable"><code>uuid</code></em>:
    <em class="replaceable"><code>hhhhhhhh</code></em>-<em class="replaceable"><code>hhhh</code></em>-<em class="replaceable"><code>hhhh</code></em>-<em class="replaceable"><code>hhhh</code></em>-<em class="replaceable"><code>hhhhhhhhhhhh</code></em>

<em class="replaceable"><code>h</code></em>:
    [0-9,A-F]

<em class="replaceable"><code>interval</code></em>:
    <em class="replaceable"><code>n</code></em>[-<em class="replaceable"><code>n</code></em>]

    (<em class="replaceable"><code>n</code></em> &gt;= 1)
</pre><p>
                <a class="link" href="sql-syntax.html#start-slave" title="13.4.2.6&nbsp;START SLAVE Syntax"><code class="literal">START SLAVE</code></a> with no
                <em class="replaceable"><code>thread_type</code></em> options starts both of
                the slave threads. The I/O thread reads events from the master
                server and stores them in the relay log. The SQL thread reads
                events from the relay log and executes them.
                <a class="link" href="sql-syntax.html#start-slave" title="13.4.2.6&nbsp;START SLAVE Syntax"><code class="literal">START SLAVE</code></a> requires the
                <a class="ulink" href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_replication-slave-admin" target="_top"><code class="literal">REPLICATION_SLAVE_ADMIN</code></a> or
                <a class="link" href="security.html#priv_super"><code class="literal">SUPER</code></a> privilege.
            </p><p style="color:blue;">不带thread_type选项的start slave启动两个从线程。I/O线程从主服务器读取事件并将其存储在中继日志中。sql线程从中继日志中读取事件并执行它们。启动从机需要复制从机管理或超级权限。</p><p>
                If <a class="link" href="sql-syntax.html#start-slave" title="13.4.2.6&nbsp;START SLAVE Syntax"><code class="literal">START SLAVE</code></a> succeeds in
                starting the slave threads, it returns without any error.
                However, even in that case, it might be that the slave threads
                start and then later stop (for example, because they do not
                manage to connect to the master or read its binary log, or some
                other problem). <a class="link" href="sql-syntax.html#start-slave" title="13.4.2.6&nbsp;START SLAVE Syntax"><code class="literal">START SLAVE</code></a> does
                not warn you about this. You must check the slave's error log
                for error messages generated by the slave threads, or check that
                they are running satisfactorily with <a class="link" href="sql-syntax.html#show-slave-status" title="13.7.5.34&nbsp;SHOW SLAVE STATUS Syntax"><code class="literal">SHOW
                SLAVE STATUS</code></a>.
            </p><p style="color:blue;">如果start slave成功启动从线程，则返回时不会出现任何错误。然而，即使在这种情况下，也可能是从线程开始，然后停止（例如，因为它们无法连接到主线程或读取其二进制日志，或其他一些问题）。start slave不会警告您这一点。您必须检查从属线程的错误日志，以查看从属线程生成的错误消息，或者检查它们是否以show slave status正常运行。</p><p>
                In MySQL 5.7, <code class="literal">START SLAVE</code> causes
                an implicit commit of an ongoing transaction. See
                <a class="xref" href="sql-syntax.html#implicit-commit" title="13.3.3&nbsp;Statements That Cause an Implicit Commit">Section&nbsp;13.3.3, “Statements That Cause an Implicit Commit”</a>.
            </p><p style="color:blue;">在mysql 5.7中，start slave导致正在进行的事务的隐式提交。参见第13.3.3节，“导致隐式提交的语句”。</p><p>
                <a class="link" href="replication.html#sysvar_gtid_next"><code class="literal">gtid_next</code></a> must be set to
                <code class="literal">AUTOMATIC</code> before issuing this statement.
            </p><p style="color:blue;">在发出此语句之前，必须将gtid_next设置为automatic。</p><p>
                The optional <code class="literal">FOR CHANNEL
                <em class="replaceable"><code>channel</code></em></code> clause enables you
                to name which replication channel the statement applies to.
                Providing a <code class="literal">FOR CHANNEL
                <em class="replaceable"><code>channel</code></em></code> clause applies the
                <code class="literal">START SLAVE</code> statement to a specific
                replication channel. If no clause is named and no extra channels
                exist, the statement applies to the default channel. If a
                <code class="literal">START SLAVE</code> statement does not have a channel
                defined when using multiple channels, this statement starts the
                specified threads for all channels. This statement is disallowed
                for the <code class="literal">group_replication_recovery</code> channel.
                See <a class="xref" href="replication.html#replication-channels" title="16.2.3&nbsp;Replication Channels">Section&nbsp;16.2.3, “Replication Channels”</a> for more information.
            </p><p style="color:blue;">可选的for channel channel子句允许您命名该语句应用于哪个复制通道。提供for channel channel子句将start slave语句应用于特定的复制通道。如果不命名子句，并且不存在额外的信道，则该语句应用于默认信道。如果在使用多个通道时，start slave语句没有定义通道，则此语句将为所有通道启动指定的线程。此语句不允许用于组复制恢复通道。有关更多信息，请参阅第16.2.3节“复制通道”。</p><p>
                MySQL supports pluggable user-password authentication with
                <code class="literal">START SLAVE</code> with the <code class="literal">USER</code>,
                <code class="literal">PASSWORD</code>, <code class="literal">DEFAULT_AUTH</code> and
                <code class="literal">PLUGIN_DIR</code> options, as described in the
                following list:
            </p><p style="color:blue;">MySQL支持可插入的用户密码验证，使用“用户”、“密码”、“默认身份验证”和“插件目录”选项从启动，如下表所示：</p>
                <div class="itemizedlist">
                    <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                        <code class="literal">USER</code>: User name. Cannot be set to an
                        empty or null string, or left unset if
                        <code class="literal">PASSWORD</code> is used.
                    </p><p style="color:blue;">user:用户名。不能设置为空字符串或空字符串，或者在使用密码时不设置。</p></li><li class="listitem"><p>
                        <code class="literal">PASSWORD</code>: Password.
                    </p><p style="color:blue;">密码：密码。</p></li><li class="listitem"><p>
                        <code class="literal">DEFAULT_AUTH</code>: Name of plugin; default is
                        MySQL native authentication.
                    </p><p style="color:blue;">default_auth：插件名称；默认为mysql本机身份验证。</p></li><li class="listitem"><p>
                        <code class="literal">PLUGIN_DIR</code>: Location of plugin.
                    </p><p style="color:blue;">plugin_dir：插件的位置。</p></li></ul>
                </div>
                <p>
                    You cannot use the <code class="literal">SQL_THREAD</code> option when
                    specifying any of <code class="literal">USER</code>,
                    <code class="literal">PASSWORD</code>, <code class="literal">DEFAULT_AUTH</code>, or
                    <code class="literal">PLUGIN_DIR</code>, unless the
                    <code class="literal">IO_THREAD</code> option is also provided.
                </p><p style="color:blue;">在指定用户、密码、默认身份验证或插件目录时，不能使用sql_thread选项，除非还提供了io_thread选项。</p><p>
                See <a class="xref" href="security.html#pluggable-authentication" title="6.2.13&nbsp;Pluggable Authentication">Section&nbsp;6.2.13, “Pluggable Authentication”</a>, for more
                information.
            </p><p style="color:blue;">有关更多信息，请参阅第6.2.13节“可插入身份验证”。</p><p>
                If an insecure connection is used with any these options, the
                server issues the warning <span class="errortext">Sending passwords in plain
        text without SSL/TLS is extremely insecure</span>.
            </p><p style="color:blue;">如果将不安全连接与任何这些选项一起使用，服务器将发出警告：在没有ssl/tls的情况下以纯文本发送密码是非常不安全的。</p><p>
                <code class="literal">START SLAVE ... UNTIL</code> supports two additional
                options for use with global transaction identifiers (GTIDs) (see
                <a class="xref" href="replication.html#replication-gtids" title="16.1.3&nbsp;Replication with Global Transaction Identifiers">Section&nbsp;16.1.3, “Replication with Global Transaction Identifiers”</a>). Each of these takes a set
                of one or more global transaction identifiers
                <em class="replaceable"><code>gtid_set</code></em> as an argument (see
                <a class="xref" href="replication.html#replication-gtids-concepts-gtid-sets" title="GTID Sets">GTID Sets</a>, for more
                information).
            </p><p style="color:blue;">启动从属…until支持两个用于全局事务标识符（gtid）的附加选项（请参阅第16.1.3节“使用全局事务标识符复制”）。其中每一个都将一个或多个全局事务标识符gtid_set作为参数集（有关更多信息，请参阅gtid set）。</p><p>
                When no <em class="replaceable"><code>thread_type</code></em> is specified,
                <code class="literal">START SLAVE UNTIL SQL_BEFORE_GTIDS</code> causes the
                slave SQL thread to process transactions until it has reached
                the <span class="emphasis"><em>first</em></span> transaction whose GTID is listed
                in the <em class="replaceable"><code>gtid_set</code></em>. <code class="literal">START SLAVE
                UNTIL SQL_AFTER_GTIDS</code> causes the slave threads to
                process all transactions until the
                <em class="replaceable"><code>last</code></em> transaction in the
                <em class="replaceable"><code>gtid_set</code></em> has been processed by both
                threads. In other words, <code class="literal">START SLAVE UNTIL
                SQL_BEFORE_GTIDS</code> causes the slave SQL thread to
                process all transactions occurring before the first GTID in the
                <em class="replaceable"><code>gtid_set</code></em> is reached, and
                <code class="literal">START SLAVE UNTIL SQL_AFTER_GTIDS</code> causes the
                slave threads to handle all transactions, including those whose
                GTIDs are found in <em class="replaceable"><code>gtid_set</code></em>, until
                each has encountered a transaction whose GTID is not part of the
                set. <code class="literal">SQL_BEFORE_GTIDS</code> and
                <code class="literal">SQL_AFTER_GTIDS</code> each support the
                <code class="literal">SQL_THREAD</code> and <code class="literal">IO_THREAD</code>
                options, although using <code class="literal">IO_THREAD</code> with them
                currently has no effect.
            </p><p style="color:blue;">当没有指定线程类型时，在gtids之前启动slave直到sql导致slave sql线程处理事务，直到它到达gtid列在gtid集中的第一个事务为止。启动slave直到sql_after_gtids导致从线程处理所有事务，直到gtid_集中的最后一个事务被两个线程处理为止。换言之，启动slave直到到达gtid集合中的第一个gtid之前，使从属sql线程处理发生的所有事务；启动slave直到到达gtid集合中的第一个gtid之前，使从属sql线程处理所有事务，包括在gtid集合中找到gtid的事务，直到每一个都遇到事务其gtid不属于集合的一部分。sql_-before_gtid和sql_-after_gtid都支持sql_线程和io_线程选项，尽管对它们使用io_线程目前没有效果。</p><p>
                For example, <code class="literal">START SLAVE SQL_THREAD UNTIL
                SQL_BEFORE_GTIDS =
                3E11FA47-71CA-11E1-9E33-C80AA9429562:11-56</code> causes the
                slave SQL thread to process all transactions originating from
                the master whose <a class="link" href="replication.html#sysvar_server_uuid"><code class="literal">server_uuid</code></a> is
                <code class="literal">3E11FA47-71CA-11E1-9E33-C80AA9429562</code> until it
                encounters the transaction having sequence number 11; it then
                stops without processing this transaction. In other words, all
                transactions up to and including the transaction with sequence
                number 10 are processed. Executing <code class="literal">START SLAVE
                SQL_THREAD UNTIL SQL_AFTER_GTIDS =
                3E11FA47-71CA-11E1-9E33-C80AA9429562:11-56</code>, on the
                other hand, would cause the slave SQL thread to obtain all
                transactions just mentioned from the master, including all of
                the transactions having the sequence numbers 11 through 56, and
                then to stop without processing any additional transactions;
                that is, the transaction having sequence number 56 would be the
                last transaction fetched by the slave SQL thread.
            </p><p style="color:blue;">例如，启动slave sql_thread，直到sql_before_gtids=3e11fa47-71ca-11e1-9e33-c80aa9429562:11-56使slave sql线程处理来自服务器_uuid为3e11fa47-71ca-11e1-9e33-c80aa9429562的主服务器的所有事务，直到它遇到序列号为11的事务；然后它停止而不处理此事务。换言之，处理序列号为10的所有事务，包括序列号为10的事务。另一方面，在gtids=3e11fa47-71ca-11e1-9e33-c80aa9429562:11-56之后执行start slave sql_thread，会导致slave sql线程从主线程获取刚才提到的所有事务，包括序列号为11到56的所有事务，然后停止而不处理任何其他事务；也就是说，序列号为56的事务将是从SQL线程获取的最后一个事务。</p><p>
                Prior to MySQL 5.7.3, <code class="literal">SQL_AFTER_GTIDS</code> did not
                stop the slave once the indicated transaction was completed, but
                waited until another GTID event was received (Bug #14767986).
            </p><p style="color:blue;">在mysql 5.7.3之前，在gtids之后的sql不会在指定的事务完成后停止从机，而是等待收到另一个gtid事件（bug 14767986）。</p><p>
                When using a multithreaded slave, there is a chance of gaps in
                the sequence of transactions that have been executed from the
                relay log in the following cases:
            </p><p style="color:blue;">当使用多线程从机时，在以下情况下，从中继日志执行的事务序列可能会出现间隙：</p>
                <div class="itemizedlist">
                    <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                        killing the coordinator thread
                    </p><p style="color:blue;">终止协调线程</p></li><li class="listitem"><p>
                        after an error occurs in the worker threads
                    </p><p style="color:blue;">在工作线程中发生错误后</p></li><li class="listitem"><p>
                        <a class="link" href="programs.html#mysqld" title="4.3.1&nbsp;mysqld — The MySQL Server"><span class="command"><strong>mysqld</strong></span></a> shuts down unexpectedly
                    </p><p style="color:blue;">mysqld意外关闭</p></li></ul>
                </div>
                <p>
                    Use the <a class="link" href="sql-syntax.html#start-slave" title="13.4.2.6&nbsp;START SLAVE Syntax"><code class="literal">START SLAVE
                    UNTIL SQL_AFTER_MTS_GAPS</code></a> statement to cause a
                    multithreaded slave's worker threads to only run until no
                    more gaps are found in the relay log, and then to stop. This
                    statement can take an <code class="literal">SQL_THREAD</code> option, but
                    the effects of the statement remain unchanged. It has no effect
                    on the slave I/O thread (and cannot be used with the
                    <code class="literal">IO_THREAD</code> option).
                </p><p style="color:blue;">使用start slave until sql_after_mts_gaps语句使多线程从线程的工作线程只运行到在中继日志中找不到更多的间隙，然后停止。此语句可以采用sql_thread选项，但语句的效果保持不变。它对从I/O线程没有影响（并且不能与IO U线程选项一起使用）。</p><p>
                Issuing <a class="link" href="sql-syntax.html#start-slave" title="13.4.2.6&nbsp;START SLAVE Syntax"><code class="literal">START SLAVE</code></a> on a
                multithreaded slave with gaps in the sequence of transactions
                executed from the relay log generates a warning. In such a
                situation, the solution is to use
                <a class="link" href="sql-syntax.html#start-slave" title="13.4.2.6&nbsp;START SLAVE Syntax"><code class="literal">START SLAVE UNTIL
                    SQL_AFTER_MTS_GAPS</code></a>, then issue
                <a class="link" href="sql-syntax.html#reset-slave" title="13.4.2.4&nbsp;RESET SLAVE Syntax"><code class="literal">RESET SLAVE</code></a> to remove any
                remaining relay logs. See
                <a class="xref" href="replication.html#replication-features-transaction-inconsistencies" title="16.4.1.32&nbsp;Replication and Transaction Inconsistencies">Section&nbsp;16.4.1.32, “Replication and Transaction Inconsistencies”</a>
                for more information.
            </p><p style="color:blue;">在多线程从机上发出start slave时，如果从中继日志执行的事务序列中存在间隙，则会生成警告。在这种情况下，解决方案是使用start slave直到sql_在mts_间隙之后，然后发出reset slave以删除任何剩余的中继日志。有关更多信息，请参阅第16.4.1.32节“复制和事务不一致”。</p><p>
                To change a failed multithreaded slave to single-threaded mode,
                you can issue the following series of statements, in the order
                shown:
            </p><p style="color:blue;">要将失败的多线程从属服务器更改为单线程模式，可以按所示顺序发出以下一系列语句：</p><pre data-lang="sql" class="programlisting">START SLAVE UNTIL SQL_AFTER_MTS_GAPS;

SET @@GLOBAL.slave_parallel_workers = 0;

START SLAVE SQL_THREAD;
</pre>
                <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">

                    <div class="admon-title">
                        Note
                    </div>
                    <p>
                        It is possible to view the entire text of a running
                        <code class="literal">START SLAVE ...</code> statement, including any
                        <code class="literal">USER</code> or <code class="literal">PASSWORD</code> values
                        used, in the output of <a class="link" href="sql-syntax.html#show-processlist" title="13.7.5.29&nbsp;SHOW PROCESSLIST Syntax"><code class="literal">SHOW
                        PROCESSLIST</code></a>. This is also true for the text of a
                        running <a class="link" href="sql-syntax.html#change-master-to" title="13.4.2.1&nbsp;CHANGE MASTER TO Syntax"><code class="literal">CHANGE MASTER TO</code></a>
                        statement, including any values it employs for
                        <code class="literal">MASTER_USER</code> or
                        <code class="literal">MASTER_PASSWORD</code>.
                    </p><p style="color:blue;">可以查看正在运行的启动从属服务器的整个文本…语句，包括在show processlist的输出中使用的任何用户或密码值。对于正在运行的change master to语句的文本也是如此，包括它为master_用户或master_密码使用的任何值。</p>
                </div>
                <p>
                    <a class="link" href="sql-syntax.html#start-slave" title="13.4.2.6&nbsp;START SLAVE Syntax"><code class="literal">START SLAVE</code></a> sends an
                    acknowledgment to the user after both the I/O thread and the SQL
                    thread have started. However, the I/O thread may not yet have
                    connected. For this reason, a successful
                    <a class="link" href="sql-syntax.html#start-slave" title="13.4.2.6&nbsp;START SLAVE Syntax"><code class="literal">START SLAVE</code></a> causes
                    <a class="link" href="sql-syntax.html#show-slave-status" title="13.7.5.34&nbsp;SHOW SLAVE STATUS Syntax"><code class="literal">SHOW SLAVE STATUS</code></a> to show
                    <code class="literal">Slave_SQL_Running=Yes</code>, but this does not
                    guarantee that <code class="literal">Slave_IO_Running=Yes</code> (because
                    <code class="literal">Slave_IO_Running=Yes</code> only if the I/O thread
                    is running <span class="emphasis"><em>and connected</em></span>). For more
                    information, see <a class="xref" href="sql-syntax.html#show-slave-status" title="13.7.5.34&nbsp;SHOW SLAVE STATUS Syntax">Section&nbsp;13.7.5.34, “SHOW SLAVE STATUS Syntax”</a>, and
                    <a class="xref" href="replication.html#replication-administration-status" title="16.1.7.1&nbsp;Checking Replication Status">Section&nbsp;16.1.7.1, “Checking Replication Status”</a>.
                </p><p style="color:blue;">start slave在i/o线程和sql线程都启动之后向用户发送一个确认。但是，I/O线程可能尚未连接。因此，一个成功的启动从机会导致show slave status显示slave_sql_running=yes，但这不能保证slave_i o_running=yes（因为slave_io_running=yes仅在I/O线程正在运行和连接时）。有关更多信息，请参阅第13.7.5.34节“显示从属状态语法”和第16.1.7.1节“检查复制状态”。</p><p>
                You can add <code class="literal">IO_THREAD</code> and
                <code class="literal">SQL_THREAD</code> options to the statement to name
                which of the threads to start. The <code class="literal">SQL_THREAD</code>
                option is disallowed when specifying any of
                <code class="literal">USER</code>, <code class="literal">PASSWORD</code>,
                <code class="literal">DEFAULT_AUTH</code>, or
                <code class="literal">PLUGIN_DIR</code>, unless the
                <code class="literal">IO_THREAD</code> option is also provided.
            </p><p style="color:blue;">可以向语句中添加io_thread和sql_thread选项，以命名要启动的线程。在指定用户、密码、默认身份验证或插件目录时，不允许使用sql_thread选项，除非还提供了io_thread选项。</p><p>
                An <code class="literal">UNTIL</code> clause
                (<em class="replaceable"><code>until_option</code></em>, in the preceding
                grammar) may be added to specify that the slave should start and
                run until the SQL thread reaches a given point in the master
                binary log, specified by the <code class="literal">MASTER_LOG_POS</code>
                and MASTER_LOG_FILE options, or a given point in the slave relay
                log, indicated with the <code class="literal">RELAY_LOG_POS</code> and
                <code class="literal">RELAY_LOG_FILE</code> options. When the SQL thread
                reaches the point specified, it stops. If the
                <code class="literal">SQL_THREAD</code> option is specified in the
                statement, it starts only the SQL thread. Otherwise, it starts
                both slave threads. If the SQL thread is running, the
                <code class="literal">UNTIL</code> clause is ignored and a warning is
                issued. You cannot use an <code class="literal">UNTIL</code> clause with
                the <code class="literal">IO_THREAD</code> option.
            </p><p style="color:blue;">可以添加一个until子句（在前面的语法中，until_选项）来指定在SQL线程到达主二进制日志中的给定点（由主日志和主日志文件选项指定）或从中继日志中的给定点（由中继日志和中继日志文件选项指示）之前，从服务器应该启动并运行。当sql线程到达指定的点时，它将停止。如果在语句中指定了sql_thread选项，则它只启动sql线程。否则，它将启动两个从线程。如果sql线程正在运行，则忽略until子句并发出警告。不能将until子句与io_thread选项一起使用。</p><p>
                It is also possible with <code class="literal">START SLAVE UNTIL</code> to
                specify a stop point relative to a given GTID or set of GTIDs
                using one of the options <code class="literal">SQL_BEFORE_GTIDS</code> or
                <code class="literal">SQL_AFTER_GTIDS</code>, as explained previously in
                this section. When using one of these options, you can specify
                <code class="literal">SQL_THREAD</code>, <code class="literal">IO_THREAD</code>,
                both of these, or neither of them. If you specify only
                <code class="literal">SQL_THREAD</code>, then only the slave SQL thread is
                affected by the statement; if only <code class="literal">IO_THREAD</code>
                is used, then only the slave I/O is affected. If both
                <code class="literal">SQL_THREAD</code> and <code class="literal">IO_THREAD</code>
                are used, or if neither of them is used, then both the SQL and
                I/O threads are affected by the statement.
            </p><p style="color:blue;">使用start slave until还可以使用选项之一指定相对于给定gtid或gtid集的停止点，如本节前面所述。使用其中一个选项时，可以指定sql_thread、io_thread，这两个选项都可以指定，或者都不指定。如果只指定sql_线程，则语句只影响从sql线程；如果只使用i o_线程，则只影响从i/o。如果同时使用了sql_线程和i o_线程，或者两者都没有使用，那么sql和i/o线程都会受到该语句的影响。</p><p>
                For an <code class="literal">UNTIL</code> clause, you must specify any one
                of the following:
            </p><p style="color:blue;">对于until子句，必须指定以下任意一项：</p>
                <div class="itemizedlist">
                    <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                        <span class="emphasis"><em>Both</em></span> a log file name and a position in
                        that file
                    </p><p style="color:blue;">日志文件名和该文件中的位置</p></li><li class="listitem"><p>
                        <span class="emphasis"><em>Either</em></span> of
                        <code class="literal">SQL_BEFORE_GTIDS</code> or
                        <code class="literal">SQL_AFTER_GTIDS</code>
                    </p><p style="color:blue;">在gtids之前的sql或在gtids之后的sql</p></li><li class="listitem"><p>
                        <code class="literal">SQL_AFTER_MTS_GAPS</code>
                    </p><p style="color:blue;">一个接一个的间隔</p></li></ul>
                </div>
                <p>
                    Do not mix master and relay log options. Do not mix log file
                    options with GTID options.
                </p><p style="color:blue;">不要混合使用主日志和中继日志选项。不要将日志文件选项与gtid选项混合使用。</p><p>
                The <code class="literal">UNTIL</code> clause is not supported for
                multithreaded slaves except when also using
                <a class="link" href="sql-syntax.html#start-slave" title="13.4.2.6&nbsp;START SLAVE Syntax"><code class="literal">SQL_AFTER_MTS_GAPS</code></a>.
                If <code class="literal">UNTIL</code> is used on a multithreaded slave
                without
                <a class="link" href="sql-syntax.html#start-slave" title="13.4.2.6&nbsp;START SLAVE Syntax"><code class="literal">SQL_AFTER_MTS_GAPS</code></a>,
                the slave operates in single-threaded (sequential) mode for
                replication until the point specified by the
                <code class="literal">UNTIL</code> clause is reached.
            </p><p style="color:blue;">多线程从属服务器不支持until子句，除非同时使用sql_after_mts_gaps。如果until用于无sql_after_mts_gaps的多线程从机，则该从机以单线程（顺序）模式进行复制，直到达到until子句指定的点为止。</p><p>
                Any <code class="literal">UNTIL</code> condition is reset by a subsequent
                <a class="link" href="sql-syntax.html#stop-slave" title="13.4.2.7&nbsp;STOP SLAVE Syntax"><code class="literal">STOP SLAVE</code></a> statement, a
                <a class="link" href="sql-syntax.html#start-slave" title="13.4.2.6&nbsp;START SLAVE Syntax"><code class="literal">START SLAVE</code></a> statement that
                includes no <code class="literal">UNTIL</code> clause, or a server
                restart.
            </p><p style="color:blue;">任何until条件都由后续的stop slave语句、包含no until子句的start slave语句或服务器重启重置。</p><p>
                When specifying a log file and position, you can use the
                <code class="literal">IO_THREAD</code> option with <code class="literal">START SLAVE
                ... UNTIL</code> even though only the SQL thread is affected
                by this statement. The <code class="literal">IO_THREAD</code> option is
                ignored in such cases. The preceding restriction does not apply
                when using one of the GTID options
                (<code class="literal">SQL_BEFORE_GTIDS</code> and
                <code class="literal">SQL_AFTER_GTIDS</code>); the GTID options support
                both <code class="literal">SQL_THREAD</code> and
                <code class="literal">IO_THREAD</code>, as explained previously in this
                section.
            </p><p style="color:blue;">当指定一个日志文件和位置时，您可以将IO U线程选项与START SLAVE一起使用…即使只有sql线程受此语句影响。在这种情况下会忽略IO U线程选项。使用其中一个gtid选项（gtid之前的sql_和gtid之后的sql_）时，上述限制不适用；gtid选项支持sql_线程和io_线程，如本节前面所述。</p><p>
                The <code class="literal">UNTIL</code> clause can be useful for debugging
                replication, or to cause replication to proceed until just
                before the point where you want to avoid having the slave
                replicate an event. For example, if an unwise
                <a class="link" href="sql-syntax.html#drop-table" title="13.1.29&nbsp;DROP TABLE Syntax"><code class="literal">DROP TABLE</code></a> statement was executed
                on the master, you can use <code class="literal">UNTIL</code> to tell the
                slave to execute up to that point but no farther. To find what
                the event is, use <a class="link" href="programs.html#mysqlbinlog" title="4.6.7&nbsp;mysqlbinlog — Utility for Processing Binary Log Files"><span class="command"><strong>mysqlbinlog</strong></span></a> with the master
                binary log or slave relay log, or by using a
                <a class="link" href="sql-syntax.html#show-binlog-events" title="13.7.5.2&nbsp;SHOW BINLOG EVENTS Syntax"><code class="literal">SHOW BINLOG EVENTS</code></a> statement.
            </p><p style="color:blue;">until子句可用于调试复制，或使复制在您希望避免从机复制事件之前继续进行。例如，如果在主节点上执行了unwise drop table语句，则可以使用until命令从节点执行到该点，但不能再执行。要查找事件，请将mysqlbinlog与主二进制日志或从中继日志一起使用，或者使用show binlog events语句。</p><p>
                If you are using <code class="literal">UNTIL</code> to have the slave
                process replicated queries in sections, it is recommended that
                you start the slave with the
                <a class="link" href="replication.html#option_mysqld_skip-slave-start"><code class="option">--skip-slave-start</code></a> option to
                prevent the SQL thread from running when the slave server
                starts. It is probably best to use this option in an option file
                rather than on the command line, so that an unexpected server
                restart does not cause it to be forgotten.
            </p><p style="color:blue;">如果使用until在节中复制从进程查询，建议使用--skip slave start选项启动从进程，以防止在从服务器启动时运行sql线程。最好在选项文件中而不是在命令行中使用此选项，以便意外的服务器重新启动不会导致忘记它。</p><p>
                The <a class="link" href="sql-syntax.html#show-slave-status" title="13.7.5.34&nbsp;SHOW SLAVE STATUS Syntax"><code class="literal">SHOW SLAVE STATUS</code></a> statement
                includes output fields that display the current values of the
                <code class="literal">UNTIL</code> condition.
            </p><p style="color:blue;">show slave status语句包含显示截止条件的当前值的输出字段。</p><p>
                Prior to MySQL 5.7.5, the failure of this statement caused the
                slave heartbeat period to be reset. This issue is fixed in MySQL
                5.7.5 and later. (Bug #18791604)
            </p><p style="color:blue;">在mysql 5.7.5之前，此语句的失败导致从心跳周期被重置。这个问题在mysql 5.7.5及更高版本中已经修复。（错误18791604）</p><p>
                In very old versions of MySQL (before 4.0.5), this statement was
                called <code class="literal">SLAVE START</code>. That syntax now produces
                an error.
            </p><p style="color:blue;">在非常旧的mysql版本（4.0.5之前）中，这个语句被称为slave start。该语法现在会产生一个错误。</p>
            </div>
            <div class="section">
                <div class="titlepage">
                    <div>
                        <div>
                            <h4 class="title"><a name="stop-slave"></a>13.4.2.7&nbsp;STOP SLAVE Syntax</h4>

                        </div>

                    </div>

                </div>
                <a class="indexterm" name="idm140286831866352"></a><pre data-lang="sql" class="programlisting">STOP SLAVE [<em class="replaceable"><code>thread_types</code></em>] [<em class="replaceable"><code>channel_option</code></em>]

<em class="replaceable"><code>thread_types</code></em>:
    [<em class="replaceable"><code>thread_type</code></em> [, <em class="replaceable"><code>thread_type</code></em>] ... ]

<em class="replaceable"><code>thread_type</code></em>: IO_THREAD | SQL_THREAD

<em class="replaceable"><code>channel_option</code></em>:
    FOR CHANNEL <em class="replaceable"><code>channel</code></em>

</pre><p>
                Stops the slave threads. <a class="link" href="sql-syntax.html#stop-slave" title="13.4.2.7&nbsp;STOP SLAVE Syntax"><code class="literal">STOP
                SLAVE</code></a> requires the
                <a class="ulink" href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_replication-slave-admin" target="_top"><code class="literal">REPLICATION_SLAVE_ADMIN</code></a> or
                <a class="link" href="security.html#priv_super"><code class="literal">SUPER</code></a> privilege. Recommended best
                practice is to execute <code class="literal">STOP SLAVE</code> on the
                slave before stopping the slave server (see
                <a class="xref" href="server-administration.html#server-shutdown" title="5.1.16&nbsp;The Server Shutdown Process">Section&nbsp;5.1.16, “The Server Shutdown Process”</a>, for more information).
            </p><p style="color:blue;">停止从线程。Stop Slave需要复制从属管理或超级权限。建议的最佳实践是在停止从属服务器之前在从属服务器上执行stop slave（有关详细信息，请参阅第5.1.16节“服务器关闭过程”）。</p><p>
                <span class="emphasis"><em>When using the row-based logging format</em></span>:
                You should execute <code class="literal">STOP SLAVE</code> or
                <code class="literal">STOP SLAVE SQL_THREAD</code> on the slave prior to
                shutting down the slave server if you are replicating any tables
                that use a nontransactional storage engine (see the
                <em class="citetitle">Note</em> later in this section).
            </p><p style="color:blue;">使用基于行的日志记录格式时：如果要复制使用非事务存储引擎的任何表，则应在关闭从属服务器之前在从属服务器上执行stop slave或stop slave sql_线程（请参阅本节后面的说明）。</p><p>
                Like <a class="link" href="sql-syntax.html#start-slave" title="13.4.2.6&nbsp;START SLAVE Syntax"><code class="literal">START SLAVE</code></a>, this statement
                may be used with the <code class="literal">IO_THREAD</code> and
                <code class="literal">SQL_THREAD</code> options to name the thread or
                threads to be stopped.
            </p><p style="color:blue;">与start slave类似，此语句可以与io_thread和sql_thread选项一起使用，以命名要停止的一个或多个线程。</p><p>
                <code class="literal">STOP SLAVE</code> causes an implicit commit of an
                ongoing transaction. See <a class="xref" href="sql-syntax.html#implicit-commit" title="13.3.3&nbsp;Statements That Cause an Implicit Commit">Section&nbsp;13.3.3, “Statements That Cause an Implicit Commit”</a>.
            </p><p style="color:blue;">stop slave导致正在进行的事务的隐式提交。参见第13.3.3节，“导致隐式提交的语句”。</p><p>
                From MySQL 5.7, <a class="link" href="replication.html#sysvar_gtid_next"><code class="literal">gtid_next</code></a> must
                be set to <code class="literal">AUTOMATIC</code> before issuing this
                statement (Bug #16062608).
            </p><p style="color:blue;">在mysql 5.7中，在发出此语句之前，必须将gtid_u next设置为automatic（bug_16062608）。</p><p>
                From MySQL 5.7, you can control how long <code class="literal">STOP
                SLAVE</code> waits before timing out by setting the
                <a class="link" href="replication.html#sysvar_rpl_stop_slave_timeout"><code class="literal">rpl_stop_slave_timeout</code></a>
                system variable. This can be used to avoid deadlocks between
                <code class="literal">STOP SLAVE</code> and other slave SQL statements
                using different client connections to the slave. When the
                timeout value is reached, the issuing client returns an error
                message and stops waiting, but the <code class="literal">STOP SLAVE</code>
                instruction remains in effect. Once the slave threads are no
                longer busy, the <code class="literal">STOP SLAVE</code> statement is
                executed and the slave stops. (Bug #16856735)
            </p><p style="color:blue;">在mysql 5.7中，可以通过设置rpl_stop_slave_timeout系统变量来控制stop slave在超时之前等待的时间。这可以用来避免stop slave和其他slave sql语句之间的死锁，这些语句使用到slave的不同客户端连接。当达到超时值时，发出的客户机返回一条错误消息并停止等待，但是stop slave指令仍然有效。一旦从线程不再繁忙，就执行stop slave语句并停止从线程。（错误16856735）</p><p>
                Some <code class="literal">CHANGE MASTER TO</code> statements are allowed
                while the slave is running, depending on the states of the slave
                SQL and I/O threads. However, using <code class="literal">STOP
                SLAVE</code> prior to executing <code class="literal">CHANGE MASTER
                TO</code> in such cases is still supported. See
                <a class="xref" href="sql-syntax.html#change-master-to" title="13.4.2.1&nbsp;CHANGE MASTER TO Syntax">Section&nbsp;13.4.2.1, “CHANGE MASTER TO Syntax”</a>, and
                <a class="xref" href="replication.html#replication-solutions-switch" title="16.3.7&nbsp;Switching Masters During Failover">Section&nbsp;16.3.7, “Switching Masters During Failover”</a>, for more
                information.
            </p><p style="color:blue;">在从机运行时，根据从机sql和i/o线程的状态，允许一些将master更改为语句。但是，在这种情况下，仍然支持在执行change master to之前使用stop slave。有关详细信息，请参阅第13.4.2.1节“将主机更改为语法”和第16.3.7节“在故障转移期间切换主机”。</p><p>
                The optional <code class="literal">FOR CHANNEL
                <em class="replaceable"><code>channel</code></em></code> clause enables you
                to name which replication channel the statement applies to.
                Providing a <code class="literal">FOR CHANNEL
                <em class="replaceable"><code>channel</code></em></code> clause applies the
                <code class="literal">STOP SLAVE</code> statement to a specific
                replication channel. If no channel is named and no extra
                channels exist, the statement applies to the default channel. If
                a <code class="literal">STOP SLAVE</code> statement does not name a
                channel when using multiple channels, this statement stops the
                specified threads for all channels. This statement cannot be
                used with the <code class="literal">group_replication_recovery</code>
                channel. See <a class="xref" href="replication.html#replication-channels" title="16.2.3&nbsp;Replication Channels">Section&nbsp;16.2.3, “Replication Channels”</a> for more
                information.
            </p><p style="color:blue;">可选的for channel channel子句允许您命名该语句应用于哪个复制通道。提供for channel channel子句将stop slave语句应用于特定的复制通道。如果没有指定信道，并且没有额外的信道存在，则该语句应用于默认信道。如果stop slave语句在使用多个通道时未命名通道，则此语句将停止所有通道的指定线程。此语句不能与组复制恢复通道一起使用。有关更多信息，请参阅第16.2.3节“复制通道”。</p><p>
                <span class="emphasis"><em>When using statement-based replication</em></span>:
                changing the master while it has open temporary tables is
                potentially unsafe. This is one of the reasons why
                statement-based replication of temporary tables is not
                recommended. You can find out whether there are any temporary
                tables on the slave by checking the value of
                <a class="link" href="server-administration.html#statvar_Slave_open_temp_tables"><code class="literal">Slave_open_temp_tables</code></a>; when
                using statement-based replication, this value should be 0 before
                executing <code class="literal">CHANGE MASTER TO</code>. If there are any
                temporary tables open on the slave, issuing a <code class="literal">CHANGE
                MASTER TO</code> statement after issuing a <code class="literal">STOP
                SLAVE</code> causes an
                <a class="link" href="error-handling.html#error_er_warn_open_temp_tables_must_be_zero"><code class="literal">ER_WARN_OPEN_TEMP_TABLES_MUST_BE_ZERO</code></a>
                warning.
            </p><p style="color:blue;">使用基于语句的复制时：在主服务器有打开的临时表时更改它可能是不安全的。这就是为什么不建议对临时表进行基于语句的复制的原因之一。您可以通过检查slave_open_temp_tables的值来确定slave上是否有任何临时表；在使用基于语句的复制时，在执行change master to之前，该值应为0。如果从机上有任何打开的临时表，则在发出stop slave后发出change master to语句将导致er_warn_open_temp_tables_must_be_zero警告。</p><p>
                When using a multithreaded slave
                (<a class="link" href="replication.html#sysvar_slave_parallel_workers"><code class="literal">slave_parallel_workers</code></a> is a
                nonzero value), any gaps in the sequence of transactions
                executed from the relay log are closed as part of stopping the
                worker threads. If the slave is stopped unexpectedly (for
                example due to an error in a worker thread, or another thread
                issuing <a class="link" href="sql-syntax.html#kill" title="13.7.6.4&nbsp;KILL Syntax"><code class="literal">KILL</code></a>) while a
                <a class="link" href="sql-syntax.html#stop-slave" title="13.4.2.7&nbsp;STOP SLAVE Syntax"><code class="literal">STOP SLAVE</code></a> statement is
                executing, the sequence of executed transactions from the relay
                log may become inconsistent. See
                <a class="xref" href="replication.html#replication-features-transaction-inconsistencies" title="16.4.1.32&nbsp;Replication and Transaction Inconsistencies">Section&nbsp;16.4.1.32, “Replication and Transaction Inconsistencies”</a>,
                for more information.
            </p><p style="color:blue;">当使用多线程从机（slave_parallel_workers是一个非零值）时，从中继日志执行的事务序列中的任何间隙都将作为停止工作线程的一部分关闭。如果在执行stop slave语句时意外停止从机（例如，由于工作线程中的错误或发出kill的另一个线程），则来自中继日志的已执行事务序列可能会变得不一致。有关更多信息，请参阅第16.4.1.32节“复制和事务不一致”。</p><p>
                If the current replication event group has modified one or more
                nontransactional tables, STOP SLAVE waits for up to 60 seconds
                for the event group to complete, unless you issue a
                <a class="link" href="sql-syntax.html#kill" title="13.7.6.4&nbsp;KILL Syntax"><code class="literal">KILL QUERY</code></a> or
                <a class="link" href="sql-syntax.html#kill" title="13.7.6.4&nbsp;KILL Syntax"><code class="literal">KILL CONNECTION</code></a>
                statement for the slave SQL thread. If the event group remains
                incomplete after the timeout, an error message is logged.
            </p><p style="color:blue;">如果当前复制事件组修改了一个或多个非事务表，则stop slave将等待事件组完成最多60秒，除非您为从属sql线程发出kill查询或kill连接语句。如果事件组在超时后仍然不完整，则会记录一条错误消息。</p>
            </div>

        </div>
        <div class="section">
            <div class="titlepage">
                <div>
                    <div>
                        <h3 class="title"><a name="replication-group-sql"></a>13.4.3&nbsp;SQL Statements for Controlling Group Replication</h3>

                    </div>

                </div>

            </div>
            <div class="toc">
                <dl class="toc"><dt><span class="section"><a href="sql-syntax.html#start-group-replication">13.4.3.1 START GROUP_REPLICATION Syntax</a></span></dt><dt><span class="section"><a href="sql-syntax.html#stop-group-replication">13.4.3.2 STOP GROUP_REPLICATION Syntax</a></span></dt></dl>
            </div>
            <a class="indexterm" name="idm140286831810720"></a><a class="indexterm" name="idm140286831809264"></a><a class="indexterm" name="idm140286831807776"></a><p>
            This section provides information about the statements used to
            control servers running the MySQL Group Replication plugin. See
            <a class="xref" href="group-replication.html" title="Chapter&nbsp;17&nbsp;Group Replication">Chapter&nbsp;17, <i>Group Replication</i></a> for more information.
        </p><p style="color:blue;">本节提供有关用于控制运行mysql组复制插件的服务器的语句的信息。有关更多信息，请参阅第17章，组复制。</p>
            <div class="section">

                <div class="titlepage">
                    <div>
                        <div>
                            <h4 class="title"><a name="start-group-replication"></a>13.4.3.1&nbsp;START GROUP_REPLICATION Syntax</h4>
                        </div>
                    </div>
                </div>
                <a class="indexterm" name="idm140286831803904"></a><pre data-lang="sql" class="programlisting">START GROUP_REPLICATION</pre><p>
                Starts Group Replication on this server instance. This statement
                requires the <a class="link" href="security.html#priv_super"><code class="literal">SUPER</code></a> privilege. If
                <a class="link" href="server-administration.html#sysvar_super_read_only"><code class="literal">super_read_only=ON</code></a> and the
                member should join as a primary,
                <a class="link" href="server-administration.html#sysvar_super_read_only"><code class="literal">super_read_only</code></a> is set to
                <code class="literal">OFF</code> once Group Replication successfully
                starts.
            </p><p style="color:blue;">在此服务器实例上启动组复制。此语句需要超级特权。如果super_read_only=on且成员应作为主成员加入，则一旦组复制成功启动，super_read_only将设置为off。</p>
            </div>
            <div class="section">
                <div class="titlepage">
                    <div>
                        <div>
                            <h4 class="title"><a name="stop-group-replication"></a>13.4.3.2&nbsp;STOP GROUP_REPLICATION Syntax</h4>

                        </div>

                    </div>

                </div>
                <a class="indexterm" name="idm140286831795680"></a><pre data-lang="sql" class="programlisting">STOP GROUP_REPLICATION</pre><p>
                Stops Group Replication. This statement requires the
                <a class="ulink" href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_group-replication-admin" target="_top"><code class="literal">GROUP_REPLICATION_ADMIN</code></a> or
                <a class="link" href="security.html#priv_super"><code class="literal">SUPER</code></a> privilege. As soon as you
                issue <a class="link" href="sql-syntax.html#stop-group-replication" title="13.4.3.2&nbsp;STOP GROUP_REPLICATION Syntax"><code class="literal">STOP GROUP_REPLICATION</code></a> the
                member is set to
                <a class="link" href="server-administration.html#sysvar_super_read_only"><code class="literal">super_read_only=ON</code></a>, which
                ensures that no writes can be made to the member while Group
                Replication stops. Any other replication channels running on the
                member are also stopped.
            </p><p style="color:blue;">停止组复制。此语句需要组复制管理员或超级权限。一旦发出stop group_replication，成员就被设置为super_read_only=on，这将确保在组复制停止时不会对成员进行写入。成员上运行的任何其他复制通道也将停止。</p>
                <div class="warning" style="margin-left: 0.5in; margin-right: 0.5in;">

                    <div class="admon-title">
                        Warning
                    </div>
                    <p>
                        Use this statement with extreme caution because it removes the
                        server instance from the group, meaning it is no longer
                        protected by Group Replication's consistency guarantee
                        mechanisms. To be completely safe, ensure that your
                        applications can no longer connect to the instance before
                        issuing this statement to avoid any chance of stale reads.
                    </p><p style="color:blue;">使用此语句时要格外小心，因为它会从组中删除服务器实例，这意味着它不再受组复制的一致性保证机制的保护。为了完全安全，请确保应用程序在发出此语句之前不能再连接到实例，以避免出现任何过时的读取。</p>
                </div>

            </div>

        </div>

    </div>
    <div class="section">
        <div class="titlepage">
            <div>
                <div>
                    <h2 class="title" style="clear: both"><a name="sql-syntax-prepared-statements"></a>13.5&nbsp;Prepared SQL Statement Syntax</h2>

                </div>

            </div>

        </div>
        <div class="toc">
            <dl class="toc"><dt><span class="section"><a href="sql-syntax.html#prepare">13.5.1 PREPARE Syntax</a></span></dt><dt><span class="section"><a href="sql-syntax.html#execute">13.5.2 EXECUTE Syntax</a></span></dt><dt><span class="section"><a href="sql-syntax.html#deallocate-prepare">13.5.3 DEALLOCATE PREPARE Syntax</a></span></dt></dl>
        </div>
        <a class="indexterm" name="idm140286831785392"></a><a class="indexterm" name="idm140286831784320"></a><a class="indexterm" name="idm140286831783248"></a><a class="indexterm" name="idm140286831782176"></a><p>
        MySQL 5.7 provides support for server-side prepared
        statements. This support takes advantage of the efficient
        client/server binary protocol. Using prepared statements with
        placeholders for parameter values has the following benefits:
    </p><p style="color:blue;">mysql 5.7支持服务器端准备的语句。这种支持利用了高效的客户机/服务器二进制协议。将准备好的语句与参数值的占位符一起使用有以下好处：</p>
        <div class="itemizedlist">
            <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                Less overhead for parsing the statement each time it is
                executed. Typically, database applications process large volumes
                of almost-identical statements, with only changes to literal or
                variable values in clauses such as <code class="literal">WHERE</code> for
                queries and deletes, <code class="literal">SET</code> for updates, and
                <code class="literal">VALUES</code> for inserts.
            </p><p style="color:blue;">每次执行语句时分析该语句的开销更少。通常，数据库应用程序处理大量几乎相同的语句，只更改查询和删除的where、更新的set和插入的value等子句中的文本值或变量值。</p></li><li class="listitem"><p>
                Protection against SQL injection attacks. The parameter values
                can contain unescaped SQL quote and delimiter characters.
            </p><p style="color:blue;">防止SQL注入攻击。参数值可以包含未转换的SQL引号和分隔符字符。</p></li></ul>
        </div>
        <h3><a name="idm140286831775936"></a>Prepared Statements in Application Programs</h3>
        <p>
            You can use server-side prepared statements through client
            programming interfaces, including the <a class="link" href="connectors-apis.html#c-api" title="27.8&nbsp;MySQL C API">MySQL C
            API client library</a> or <a class="ulink" href="https://dev.mysql.com/doc/connector-c/en/" target="_top">MySQL
            Connector/C</a> for C programs,
            <a class="ulink" href="https://dev.mysql.com/doc/connector-j/5.1/en/" target="_top">MySQL Connector/J</a> for Java
            programs, and <a class="ulink" href="https://dev.mysql.com/doc/connector-net/en/" target="_top">MySQL Connector/NET</a> for
            programs using .NET technologies. For example, the C API provides a
            set of function calls that make up its prepared statement API. See
            <a class="xref" href="connectors-apis.html#c-api-prepared-statements" title="27.8.8&nbsp;C API Prepared Statements">Section&nbsp;27.8.8, “C API Prepared Statements”</a>. Other language
            interfaces can provide support for prepared statements that use the
            binary protocol by linking in the C client library, one example
            being the
            <a class="ulink" href="http://php.net/mysqli" target="_top"><code class="literal">mysqli</code>
                extension</a>, available in PHP 5.0 and later.
        </p><p style="color:blue;">您可以通过客户端编程接口使用服务器端准备的语句，包括mysql c api客户端库或mysql connector/c for c programs、mysql connector/j for java programs和mysql connector/net for programs using.net technologies。例如，C API提供了一组函数调用，这些函数调用构成了它准备好的语句API。见27.8.8节，“C API准备的声明”。其他语言接口可以通过链接c客户机库（一个例子是php 5.0和更高版本中提供的mysqli扩展）为使用二进制协议的准备好的语句提供支持。</p>
        <h3><a name="idm140286831769072"></a>Prepared Statements in SQL Scripts</h3>
        <p>
            An alternative SQL interface to prepared statements is available.
            This interface is not as efficient as using the binary protocol
            through a prepared statement API, but requires no programming
            because it is available directly at the SQL level:
        </p><p style="color:blue;">可以使用准备好的语句的另一个sql接口。此接口的效率不如通过准备好的语句API使用二进制协议，但不需要编程，因为它在SQL级别直接可用：</p>
        <div class="itemizedlist">
            <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                You can use it when no programming interface is available to
                you.
            </p><p style="color:blue;">当没有可用的编程接口时，您可以使用它。</p></li><li class="listitem"><p>
                You can use it from any program that can send SQL statements to
                the server to be executed, such as the <a class="link" href="programs.html#mysql" title="4.5.1&nbsp;mysql — The MySQL Command-Line Client"><span class="command"><strong>mysql</strong></span></a>
                client program.
            </p><p style="color:blue;">您可以从任何可以将sql语句发送到要执行的服务器的程序（例如mysql客户机程序）中使用它。</p></li><li class="listitem"><p>
                You can use it even if the client is using an old version of the
                client library, as long as you connect to a server running MySQL
                4.1 or higher.
            </p><p style="color:blue;">只要连接到运行mysql 4.1或更高版本的服务器，即使客户端使用的是旧版本的客户端库，也可以使用它。</p></li></ul>
        </div>
        <p>
            SQL syntax for prepared statements is intended to be used for
            situations such as these:
        </p><p style="color:blue;">准备好的语句的SQL语法用于以下情况：</p>
        <div class="itemizedlist">
            <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                To test how prepared statements work in your application before
                coding it.
            </p><p style="color:blue;">在编写应用程序之前测试准备好的语句在应用程序中的工作方式。</p></li><li class="listitem"><p>
                To use prepared statements when you do not have access to a
                programming API that supports them.
            </p><p style="color:blue;">在无法访问支持语句的编程API时使用准备好的语句。</p></li><li class="listitem"><p>
                To interactively troubleshoot application issues with prepared
                statements.
            </p><p style="color:blue;">使用准备好的语句交互式地解决应用程序问题。</p></li><li class="listitem"><p>
                To create a test case that reproduces a problem with prepared
                statements, so that you can file a bug report.
            </p><p style="color:blue;">创建一个测试用例，用准备好的语句再现一个问题，以便您可以提交一个错误报告。</p></li></ul>
        </div>
        <h3><a name="idm140286831758864"></a>PREPARE, EXECUTE, and DEALLOCATE PREPARE Statements</h3>
        <p>
            SQL syntax for prepared statements is based on three SQL statements:
        </p><p style="color:blue;">准备好的语句的SQL语法基于三个SQL语句：</p>
        <div class="itemizedlist">
            <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                <a class="link" href="sql-syntax.html#prepare" title="13.5.1&nbsp;PREPARE Syntax"><code class="literal">PREPARE</code></a> prepares a statement for
                execution (see <a class="xref" href="sql-syntax.html#prepare" title="13.5.1&nbsp;PREPARE Syntax">Section&nbsp;13.5.1, “PREPARE Syntax”</a>).
            </p><p style="color:blue;">准备一个执行语句（参见第135.1节，“准备语法”）。</p></li><li class="listitem"><p>
                <a class="link" href="sql-syntax.html#execute" title="13.5.2&nbsp;EXECUTE Syntax"><code class="literal">EXECUTE</code></a> executes a prepared
                statement (see <a class="xref" href="sql-syntax.html#execute" title="13.5.2&nbsp;EXECUTE Syntax">Section&nbsp;13.5.2, “EXECUTE Syntax”</a>).
            </p><p style="color:blue;">execute执行准备好的语句（参见第13.5.2节“execute syntax”）。</p></li><li class="listitem"><p>
                <a class="link" href="sql-syntax.html#deallocate-prepare" title="13.5.3&nbsp;DEALLOCATE PREPARE Syntax"><code class="literal">DEALLOCATE PREPARE</code></a> releases a
                prepared statement (see <a class="xref" href="sql-syntax.html#deallocate-prepare" title="13.5.3&nbsp;DEALLOCATE PREPARE Syntax">Section&nbsp;13.5.3, “DEALLOCATE PREPARE Syntax”</a>).
            </p><p style="color:blue;">Debug准备准备发布一个准备好的语句（参见第135.3节，“DeloDebug准备语法”）。</p></li></ul>
        </div>
        <p>
            The following examples show two equivalent ways of preparing a
            statement that computes the hypotenuse of a triangle given the
            lengths of the two sides.
        </p><p style="color:blue;">下面的例子展示了两种准备语句的等效方法，即在给定三角形两边长度的情况下计算三角形的斜边。</p><p>
        The first example shows how to create a prepared statement by using
        a string literal to supply the text of the statement:
    </p><p style="color:blue;">第一个示例演示如何通过使用字符串文本提供语句文本来创建准备好的语句：</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>PREPARE stmt1 FROM 'SELECT SQRT(POW(?,2) + POW(?,2)) AS hypotenuse';</code></strong>
mysql&gt; <strong class="userinput"><code>SET @a = 3;</code></strong>
mysql&gt; <strong class="userinput"><code>SET @b = 4;</code></strong>
mysql&gt; <strong class="userinput"><code>EXECUTE stmt1 USING @a, @b;</code></strong>
+------------+
| hypotenuse |
+------------+
|          5 |
+------------+
mysql&gt; <strong class="userinput"><code>DEALLOCATE PREPARE stmt1;</code></strong>
</pre><p>
        The second example is similar, but supplies the text of the
        statement as a user variable:
    </p><p style="color:blue;">第二个示例与此类似，但将语句的文本作为用户变量提供：</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>SET @s = 'SELECT SQRT(POW(?,2) + POW(?,2)) AS hypotenuse';</code></strong>
mysql&gt; <strong class="userinput"><code>PREPARE stmt2 FROM @s;</code></strong>
mysql&gt; <strong class="userinput"><code>SET @a = 6;</code></strong>
mysql&gt; <strong class="userinput"><code>SET @b = 8;</code></strong>
mysql&gt; <strong class="userinput"><code>EXECUTE stmt2 USING @a, @b;</code></strong>
+------------+
| hypotenuse |
+------------+
|         10 |
+------------+
mysql&gt; <strong class="userinput"><code>DEALLOCATE PREPARE stmt2;</code></strong>
</pre><p>
        Here is an additional example that demonstrates how to choose the
        table on which to perform a query at runtime, by storing the name of
        the table as a user variable:
    </p><p style="color:blue;">下面是一个附加的示例，演示如何通过将表的名称存储为用户变量来选择在运行时执行查询的表：</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>USE test;</code></strong>
mysql&gt; <strong class="userinput"><code>CREATE TABLE t1 (a INT NOT NULL);</code></strong>
mysql&gt; <strong class="userinput"><code>INSERT INTO t1 VALUES (4), (8), (11), (32), (80);</code></strong>

mysql&gt; <strong class="userinput"><code>SET @table = 't1';</code></strong>
mysql&gt; <strong class="userinput"><code>SET @s = CONCAT('SELECT * FROM ', @table);</code></strong>

mysql&gt; <strong class="userinput"><code>PREPARE stmt3 FROM @s;</code></strong>
mysql&gt; <strong class="userinput"><code>EXECUTE stmt3;</code></strong>
+----+
| a  |
+----+
|  4 |
|  8 |
| 11 |
| 32 |
| 80 |
+----+

mysql&gt; <strong class="userinput"><code>DEALLOCATE PREPARE stmt3;</code></strong>
</pre><p>
        A prepared statement is specific to the session in which it was
        created. If you terminate a session without deallocating a
        previously prepared statement, the server deallocates it
        automatically.
    </p><p style="color:blue;">准备好的语句特定于创建它的会话。如果在终止会话时未释放先前准备好的语句，服务器将自动释放该语句。</p><p>
        A prepared statement is also global to the session. If you create a
        prepared statement within a stored routine, it is not deallocated
        when the stored routine ends.
    </p><p style="color:blue;">准备好的发言对本届会议也是全球性的。如果在存储例程中创建准备好的语句，则在存储例程结束时不会释放该语句。</p><p>
        To guard against too many prepared statements being created
        simultaneously, set the
        <a class="link" href="server-administration.html#sysvar_max_prepared_stmt_count"><code class="literal">max_prepared_stmt_count</code></a> system
        variable. To prevent the use of prepared statements, set the value
        to 0.
    </p><p style="color:blue;">要防止同时创建过多的已准备语句，请设置max_prepared_stmt_count系统变量。若要防止使用准备好的语句，请将该值设置为0。</p>
        <h3><a name="idm140286831726864"></a>SQL Syntax Allowed in Prepared Statements</h3>
        <p>
            The following SQL statements can be used as prepared statements:
        </p><p style="color:blue;">以下SQL语句可用作准备语句：</p><pre data-lang="sql" class="programlisting">ALTER TABLE
ALTER USER
ANALYZE TABLE
CACHE INDEX
CALL
CHANGE MASTER
CHECKSUM {TABLE | TABLES}
COMMIT
{CREATE | DROP} INDEX
{CREATE | RENAME | DROP} DATABASE
{CREATE | DROP} TABLE
{CREATE | RENAME | DROP} USER
{CREATE | DROP} VIEW
DELETE
DO
FLUSH {TABLE | TABLES | TABLES WITH READ LOCK | HOSTS | PRIVILEGES
  | LOGS | STATUS | MASTER | SLAVE | DES_KEY_FILE | USER_RESOURCES}
GRANT
INSERT
INSTALL PLUGIN
KILL
LOAD INDEX INTO CACHE
OPTIMIZE TABLE
RENAME TABLE
REPAIR TABLE
REPLACE
RESET {MASTER | SLAVE | QUERY CACHE}
REVOKE
SELECT
SET
SHOW {WARNINGS | ERRORS}
SHOW BINLOG EVENTS
SHOW CREATE {PROCEDURE | FUNCTION | EVENT | TABLE | VIEW}
SHOW {MASTER | BINARY} LOGS
SHOW {MASTER | SLAVE} STATUS
SLAVE {START | STOP}
TRUNCATE TABLE
UNINSTALL PLUGIN
UPDATE
</pre><p>
        As of MySQL 5.7.2, for compliance with the SQL standard, which
        states that diagnostics statements are not preparable, MySQL does
        not support the following as prepared statements:
    </p><p style="color:blue;">从mysql 5.7.2开始，为了符合sql标准，即诊断语句是不可准备的，mysql不支持以下的as-prepared语句：</p>
        <div class="itemizedlist">
            <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                <code class="literal">SHOW WARNINGS</code>, <code class="literal">SHOW COUNT(*)
                WARNINGS</code>
            </p><p style="color:blue;">显示警告，显示计数（*）警告</p></li><li class="listitem"><p>
                <code class="literal">SHOW ERRORS</code>, <code class="literal">SHOW COUNT(*)
                ERRORS</code>
            </p><p style="color:blue;">显示错误，显示计数（*）错误</p></li><li class="listitem"><p>
                Statements containing any reference to the
                <a class="link" href="server-administration.html#sysvar_warning_count"><code class="literal">warning_count</code></a> or
                <a class="link" href="server-administration.html#sysvar_error_count"><code class="literal">error_count</code></a> system variable.
            </p><p style="color:blue;">包含对warning_count或error_count系统变量的任何引用的语句。</p></li></ul>
        </div>
        <p>
            Other statements are not supported in MySQL 5.7.
        </p><p style="color:blue;">mysql 5.7不支持其他语句。</p><p>
        Generally, statements not permitted in SQL prepared statements are
        also not permitted in stored programs. Exceptions are noted in
        <a class="xref" href="stored-objects.html#stored-program-restrictions" title="23.8&nbsp;Restrictions on Stored Programs">Section&nbsp;23.8, “Restrictions on Stored Programs”</a>.
    </p><p style="color:blue;">通常，SQL准备的语句中不允许的语句在存储程序中也不允许。例外情况见第23.8节“存储程序的限制”。</p><p>
        Metadata changes to tables or views referred to by prepared
        statements are detected and cause automatic repreparation of the
        statement when it is next executed. For more information, see
        <a class="xref" href="optimization.html#statement-caching" title="8.10.4&nbsp;Caching of Prepared Statements and Stored Programs">Section&nbsp;8.10.4, “Caching of Prepared Statements and Stored Programs”</a>.
    </p><p style="color:blue;">将检测到对准备好的语句所引用的表或视图的元数据更改，并在下次执行该语句时自动重新编写该语句。有关更多信息，请参阅8.10.4节，“准备好的语句和存储程序的缓存”。</p><p>
        Placeholders can be used for the arguments of the
        <code class="literal">LIMIT</code> clause when using prepared statements. See
        <a class="xref" href="sql-syntax.html#select" title="13.2.9&nbsp;SELECT Syntax">Section&nbsp;13.2.9, “SELECT Syntax”</a>.
    </p><p style="color:blue;">使用准备好的语句时，占位符可用于LIMIT子句的参数。参见第13.2.9节“选择语法”。</p><p>
        In prepared <a class="link" href="sql-syntax.html#call" title="13.2.1&nbsp;CALL Syntax"><code class="literal">CALL</code></a> statements used with
        <a class="link" href="sql-syntax.html#prepare" title="13.5.1&nbsp;PREPARE Syntax"><code class="literal">PREPARE</code></a> and
        <a class="link" href="sql-syntax.html#execute" title="13.5.2&nbsp;EXECUTE Syntax"><code class="literal">EXECUTE</code></a>, placeholder support for
        <code class="literal">OUT</code> and <code class="literal">INOUT</code> parameters is
        available beginning with MySQL 5.7. See
        <a class="xref" href="sql-syntax.html#call" title="13.2.1&nbsp;CALL Syntax">Section&nbsp;13.2.1, “CALL Syntax”</a>, for an example and a workaround for earlier
        versions. Placeholders can be used for <code class="literal">IN</code>
        parameters regardless of version.
    </p><p style="color:blue;">在准备和执行中使用的准备调用语句中，从MySQL 5.7开始可用占位符支持OUT和IOUT参数。参见第13.2.1节“调用语法”，了解早期版本的示例和解决方法。占位符可用于in参数，而不管版本如何。</p><p>
        SQL syntax for prepared statements cannot be used in nested fashion.
        That is, a statement passed to
        <a class="link" href="sql-syntax.html#prepare" title="13.5.1&nbsp;PREPARE Syntax"><code class="literal">PREPARE</code></a> cannot itself be a
        <a class="link" href="sql-syntax.html#prepare" title="13.5.1&nbsp;PREPARE Syntax"><code class="literal">PREPARE</code></a>,
        <a class="link" href="sql-syntax.html#execute" title="13.5.2&nbsp;EXECUTE Syntax"><code class="literal">EXECUTE</code></a>, or
        <a class="link" href="sql-syntax.html#deallocate-prepare" title="13.5.3&nbsp;DEALLOCATE PREPARE Syntax"><code class="literal">DEALLOCATE PREPARE</code></a> statement.
    </p><p style="color:blue;">准备好的语句的SQL语法不能以嵌套方式使用。也就是说，传递给准备的语句本身不能是准备、执行或解除准备语句。</p><p>
        SQL syntax for prepared statements is distinct from using prepared
        statement API calls. For example, you cannot use the
        <a class="link" href="connectors-apis.html#mysql-stmt-prepare" title="27.8.11.21&nbsp;mysql_stmt_prepare()"><code class="literal">mysql_stmt_prepare()</code></a> C API function
        to prepare a <a class="link" href="sql-syntax.html#prepare" title="13.5.1&nbsp;PREPARE Syntax"><code class="literal">PREPARE</code></a>,
        <a class="link" href="sql-syntax.html#execute" title="13.5.2&nbsp;EXECUTE Syntax"><code class="literal">EXECUTE</code></a>, or
        <a class="link" href="sql-syntax.html#deallocate-prepare" title="13.5.3&nbsp;DEALLOCATE PREPARE Syntax"><code class="literal">DEALLOCATE PREPARE</code></a> statement.
    </p><p style="color:blue;">准备语句的sql语法与使用准备语句api调用不同。例如，您不能使用MySqLyStMyPayReAube（）C API函数来准备准备、执行或释放准备语句。</p><p>
        SQL syntax for prepared statements can be used within stored
        procedures, but not in stored functions or triggers. However, a
        cursor cannot be used for a dynamic statement that is prepared and
        executed with <a class="link" href="sql-syntax.html#prepare" title="13.5.1&nbsp;PREPARE Syntax"><code class="literal">PREPARE</code></a> and
        <a class="link" href="sql-syntax.html#execute" title="13.5.2&nbsp;EXECUTE Syntax"><code class="literal">EXECUTE</code></a>. The statement for a cursor
        is checked at cursor creation time, so the statement cannot be
        dynamic.
    </p><p style="color:blue;">准备好的语句的SQL语法可以在存储过程中使用，但不能在存储函数或触发器中使用。但是，游标不能用于准备和执行准备和执行的动态语句。游标的语句在游标创建时被选中，因此该语句不能是动态的。</p><p>
        SQL syntax for prepared statements does not support multi-statements
        (that is, multiple statements within a single string separated by
        <code class="literal">;</code> characters).
    </p><p style="color:blue;">准备好的语句的SQL语法不支持多个语句（即，单个字符串中由；字符分隔的多个语句）。</p><p>
        Prepared statements use the query cache under the conditions
        described in <a class="xref" href="optimization.html#query-cache-operation" title="8.10.3.1&nbsp;How the Query Cache Operates">Section&nbsp;8.10.3.1, “How the Query Cache Operates”</a>.
    </p><p style="color:blue;">准备好的语句在8.10.3.1节“查询缓存如何操作”中描述的条件下使用查询缓存。</p><p>
        To write C programs that use the <a class="link" href="sql-syntax.html#call" title="13.2.1&nbsp;CALL Syntax"><code class="literal">CALL</code></a>
        SQL statement to execute stored procedures that contain prepared
        statements, the <code class="literal">CLIENT_MULTI_RESULTS</code> flag must be
        enabled. This is because each <a class="link" href="sql-syntax.html#call" title="13.2.1&nbsp;CALL Syntax"><code class="literal">CALL</code></a>
        returns a result to indicate the call status, in addition to any
        result sets that might be returned by statements executed within the
        procedure.
    </p><p style="color:blue;">要编写使用CALL SQL语句执行包含准备好的语句的存储过程的C程序，必须启用CLIENT U MULTI U RESULTS标志。这是因为除了过程中执行的语句可能返回的任何结果集之外，每个调用都返回一个结果来指示调用状态。</p><p>
        <code class="literal">CLIENT_MULTI_RESULTS</code> can be enabled when you call
        <a class="link" href="connectors-apis.html#mysql-real-connect" title="27.8.7.54&nbsp;mysql_real_connect()"><code class="literal">mysql_real_connect()</code></a>, either
        explicitly by passing the <code class="literal">CLIENT_MULTI_RESULTS</code>
        flag itself, or implicitly by passing
        <code class="literal">CLIENT_MULTI_STATEMENTS</code> (which also enables
        <code class="literal">CLIENT_MULTI_RESULTS</code>). For additional
        information, see <a class="xref" href="sql-syntax.html#call" title="13.2.1&nbsp;CALL Syntax">Section&nbsp;13.2.1, “CALL Syntax”</a>.
    </p><p style="color:blue;">当调用mysql_real_connect（）时，可以启用client_multi_results，可以显式地传递client_multi_results标志本身，也可以隐式地传递client_multi_语句（这也可以启用client_multi_results）。有关更多信息，请参见第13.2.1节“调用语法”。</p>
        <div class="section">

            <div class="titlepage">
                <div>
                    <div>
                        <h3 class="title"><a name="prepare"></a>13.5.1&nbsp;PREPARE Syntax</h3>
                    </div>
                </div>
            </div>
            <a class="indexterm" name="idm140286831676704"></a><a class="indexterm" name="idm140286831675632"></a><pre data-lang="sql" class="programlisting">PREPARE <em class="replaceable"><code>stmt_name</code></em> FROM <em class="replaceable"><code>preparable_stmt</code></em>
</pre><p>
            The <a class="link" href="sql-syntax.html#prepare" title="13.5.1&nbsp;PREPARE Syntax"><code class="literal">PREPARE</code></a> statement prepares a
            SQL statement and assigns it a name,
            <em class="replaceable"><code>stmt_name</code></em>, by which to refer to the
            statement later. The prepared statement is executed with
            <a class="link" href="sql-syntax.html#execute" title="13.5.2&nbsp;EXECUTE Syntax"><code class="literal">EXECUTE</code></a> and released with
            <a class="link" href="sql-syntax.html#deallocate-prepare" title="13.5.3&nbsp;DEALLOCATE PREPARE Syntax"><code class="literal">DEALLOCATE PREPARE</code></a>. For examples,
            see <a class="xref" href="sql-syntax.html#sql-syntax-prepared-statements" title="13.5&nbsp;Prepared SQL Statement Syntax">Section&nbsp;13.5, “Prepared SQL Statement Syntax”</a>.
        </p><p style="color:blue;">准备语句准备一个SQL语句，并给它指派一个名为STMTINEX，通过它来引用后面的语句。准备好的语句用Excel执行并释放。例如，请参阅第13.5节“准备的SQL语句语法”。</p><p>
            Statement names are not case-sensitive.
            <em class="replaceable"><code>preparable_stmt</code></em> is either a string
            literal or a user variable that contains the text of the SQL
            statement. The text must represent a single statement, not
            multiple statements. Within the statement, <code class="literal">?</code>
            characters can be used as parameter markers to indicate where data
            values are to be bound to the query later when you execute it. The
            <code class="literal">?</code> characters should not be enclosed within
            quotation marks, even if you intend to bind them to string values.
            Parameter markers can be used only where data values should
            appear, not for SQL keywords, identifiers, and so forth.
        </p><p style="color:blue;">语句名称不区分大小写。preparable_stmt是字符串文本或包含sql语句文本的用户变量。文本必须表示单个语句，而不是多个语句。在声明中，？字符可以用作参数标记，以指示稍后执行查询时数据值将绑定到的位置。这个？即使要将字符绑定到字符串值，也不应将字符括在引号中。参数标记只能在数据值应该出现的地方使用，不能用于sql关键字、标识符等。</p><p>
            If a prepared statement with the given name already exists, it is
            deallocated implicitly before the new statement is prepared. This
            means that if the new statement contains an error and cannot be
            prepared, an error is returned and no statement with the given
            name exists.
        </p><p style="color:blue;">如果具有给定名称的已准备语句已经存在，则在准备新语句之前隐式释放该语句。这意味着，如果新语句包含错误且无法准备，则返回一个错误，并且不存在给定名称的语句。</p><p>
            The scope of a prepared statement is the session within which it
            is created, which as several implications:
        </p><p style="color:blue;">准备好的声明的范围是在其中创建它的会话，它有几个含义：</p>
            <div class="itemizedlist">
                <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                    A prepared statement created in one session is not available
                    to other sessions.
                </p><p style="color:blue;">在一个会话中创建的准备好的语句对其他会话不可用。</p></li><li class="listitem"><p>
                    When a session ends, whether normally or abnormally, its
                    prepared statements no longer exist. If auto-reconnect is
                    enabled, the client is not notified that the connection was
                    lost. For this reason, clients may wish to disable
                    auto-reconnect. See <a class="xref" href="connectors-apis.html#c-api-auto-reconnect" title="27.8.20&nbsp;C API Automatic Reconnection Control">Section&nbsp;27.8.20, “C API Automatic Reconnection Control”</a>.
                </p><p style="color:blue;">当会话结束时，不管是正常的还是异常的，其准备的语句不再存在。如果启用了自动重新连接，则不会通知客户端连接已丢失。因此，客户端可能希望禁用自动重新连接。见27.8.20节，“C API自动重新连接控制”。</p></li><li class="listitem"><p>
                    A prepared statement created within a stored program continues
                    to exist after the program finishes executing and can be
                    executed outside the program later.
                </p><p style="color:blue;">在程序完成后，在存储程序中创建的准备语句继续存在，并且可以在程序之后执行。</p></li><li class="listitem"><p>
                    A statement prepared in stored program context cannot refer to
                    stored procedure or function parameters or local variables
                    because they go out of scope when the program ends and would
                    be unavailable were the statement to be executed later outside
                    the program. As a workaround, refer instead to user-defined
                    variables, which also have session scope; see
                    <a class="xref" href="language-structure.html#user-variables" title="9.4&nbsp;User-Defined Variables">Section&nbsp;9.4, “User-Defined Variables”</a>.
                </p><p style="color:blue;">在存储程序上下文中准备的语句不能引用存储过程、函数参数或局部变量，因为它们在程序结束时超出范围，如果稍后在程序外部执行的语句将不可用。作为解决方法，请参考用户定义的变量，这些变量也具有会话范围；请参见第9.4节“用户定义的变量”。</p></li></ul>
            </div>

        </div>
        <div class="section">
            <div class="titlepage">
                <div>
                    <div>
                        <h3 class="title"><a name="execute"></a>13.5.2&nbsp;EXECUTE Syntax</h3>

                    </div>

                </div>

            </div>
            <a class="indexterm" name="idm140286831652544"></a><a class="indexterm" name="idm140286831651472"></a><pre data-lang="sql" class="programlisting">EXECUTE <em class="replaceable"><code>stmt_name</code></em>
    [USING @<em class="replaceable"><code>var_name</code></em> [, @<em class="replaceable"><code>var_name</code></em>] ...]
</pre><p>
            After preparing a statement with
            <a class="link" href="sql-syntax.html#prepare" title="13.5.1&nbsp;PREPARE Syntax"><code class="literal">PREPARE</code></a>, you execute it with an
            <a class="link" href="sql-syntax.html#execute" title="13.5.2&nbsp;EXECUTE Syntax"><code class="literal">EXECUTE</code></a> statement that refers to
            the prepared statement name. If the prepared statement contains
            any parameter markers, you must supply a <code class="literal">USING</code>
            clause that lists user variables containing the values to be bound
            to the parameters. Parameter values can be supplied only by user
            variables, and the <code class="literal">USING</code> clause must name
            exactly as many variables as the number of parameter markers in
            the statement.
        </p><p style="color:blue;">准备好一个语句之后，用执行语句来执行它，该语句引用准备好的语句名。如果准备好的语句包含任何参数标记，则必须提供using子句，该子句列出包含要绑定到参数的值的用户变量。参数值只能由用户变量提供，并且using子句必须与语句中参数标记的数目完全相同。</p><p>
            You can execute a given prepared statement multiple times, passing
            different variables to it or setting the variables to different
            values before each execution.
        </p><p style="color:blue;">可以多次执行给定的准备好的语句，在每次执行之前向它传递不同的变量或将变量设置为不同的值。</p><p>
            For examples, see
            <a class="xref" href="sql-syntax.html#sql-syntax-prepared-statements" title="13.5&nbsp;Prepared SQL Statement Syntax">Section&nbsp;13.5, “Prepared SQL Statement Syntax”</a>.
        </p><p style="color:blue;">例如，请参阅第13.5节“准备的SQL语句语法”。</p>
        </div>
        <div class="section">
            <div class="titlepage">
                <div>
                    <div>
                        <h3 class="title"><a name="deallocate-prepare"></a>13.5.3&nbsp;DEALLOCATE PREPARE Syntax</h3>

                    </div>

                </div>

            </div>
            <a class="indexterm" name="idm140286831636752"></a><a class="indexterm" name="idm140286831635712"></a><a class="indexterm" name="idm140286831634640"></a><pre data-lang="sql" class="programlisting">{DEALLOCATE | DROP} PREPARE <em class="replaceable"><code>stmt_name</code></em>
</pre><p>
            To deallocate a prepared statement produced with
            <a class="link" href="sql-syntax.html#prepare" title="13.5.1&nbsp;PREPARE Syntax"><code class="literal">PREPARE</code></a>, use a
            <a class="link" href="sql-syntax.html#deallocate-prepare" title="13.5.3&nbsp;DEALLOCATE PREPARE Syntax"><code class="literal">DEALLOCATE PREPARE</code></a> statement that
            refers to the prepared statement name. Attempting to execute a
            prepared statement after deallocating it results in an error. If
            too many prepared statements are created and not deallocated by
            either the <code class="literal">DEALLOCATE PREPARE</code> statement or the
            end of the session, you might encounter the upper limit enforced
            by the <a class="link" href="server-administration.html#sysvar_max_prepared_stmt_count"><code class="literal">max_prepared_stmt_count</code></a>
            system variable.
        </p><p style="color:blue;">若要释放准备好的准备好的语句，请使用一个引用准备好的语句名的Debug定位准备语句。试图在释放准备好的语句后执行该语句将导致错误。如果创建了太多准备好的语句，而不是由DeloPoFor准备语句或会话结束进行重新分配，则可能遇到由Max准备PraseDyStMTyCurt系统变量强制执行的上限。</p><p>
            For examples, see
            <a class="xref" href="sql-syntax.html#sql-syntax-prepared-statements" title="13.5&nbsp;Prepared SQL Statement Syntax">Section&nbsp;13.5, “Prepared SQL Statement Syntax”</a>.
        </p><p style="color:blue;">例如，请参阅第13.5节“准备的SQL语句语法”。</p>
        </div>

    </div>
    <div class="section">
        <div class="titlepage">
            <div>
                <div>
                    <h2 class="title" style="clear: both"><a name="sql-syntax-compound-statements"></a>13.6&nbsp;Compound-Statement Syntax</h2>

                </div>

            </div>

        </div>
        <div class="toc">
            <dl class="toc"><dt><span class="section"><a href="sql-syntax.html#begin-end">13.6.1 BEGIN ... END Compound-Statement Syntax</a></span></dt><dt><span class="section"><a href="sql-syntax.html#statement-labels">13.6.2 Statement Label Syntax</a></span></dt><dt><span class="section"><a href="sql-syntax.html#declare">13.6.3 DECLARE Syntax</a></span></dt><dt><span class="section"><a href="sql-syntax.html#stored-program-variables">13.6.4 Variables in Stored Programs</a></span></dt><dt><span class="section"><a href="sql-syntax.html#flow-control-statements">13.6.5 Flow Control Statements</a></span></dt><dt><span class="section"><a href="sql-syntax.html#cursors">13.6.6 Cursors</a></span></dt><dt><span class="section"><a href="sql-syntax.html#condition-handling">13.6.7 Condition Handling</a></span></dt></dl>
        </div>
        <a class="indexterm" name="idm140286831620080"></a><a class="indexterm" name="idm140286831619008"></a><a class="indexterm" name="idm140286831617520"></a><a class="indexterm" name="idm140286831616448"></a><p>
        This section describes the syntax for the
        <a class="link" href="sql-syntax.html#begin-end" title="13.6.1&nbsp;BEGIN ... END Compound-Statement Syntax"><code class="literal">BEGIN ... END</code></a>
        compound statement and other statements that can be used in the body
        of stored programs: Stored procedures and functions, triggers, and
        events. These objects are defined in terms of SQL code that is
        stored on the server for later invocation (see
        <a class="xref" href="stored-objects.html" title="Chapter&nbsp;23&nbsp;Stored Objects">Chapter&nbsp;23, <i>Stored Objects</i></a>).
    </p><p style="color:blue;">本节描述开始的语法…结束复合语句和可用于存储程序主体的其他语句：存储过程和函数、触发器和事件。这些对象是根据存储在服务器上供以后调用的sql代码定义的（参见第23章，存储对象）。</p><p>
        A compound statement is a block that can contain other blocks;
        declarations for variables, condition handlers, and cursors; and
        flow control constructs such as loops and conditional tests.
    </p><p style="color:blue;">复合语句是可以包含其他块的块；变量、条件处理程序和游标的声明；以及循环和条件测试等流控制构造。</p>
        <div class="section">

            <div class="titlepage">
                <div>
                    <div>
                        <h3 class="title"><a name="begin-end"></a>13.6.1&nbsp;BEGIN ... END Compound-Statement Syntax</h3>
                    </div>
                </div>
            </div>
            <a class="indexterm" name="idm140286831609664"></a><a class="indexterm" name="idm140286831608624"></a><pre data-lang="sql" class="programlisting">[<em class="replaceable"><code>begin_label</code></em>:] BEGIN
    [<em class="replaceable"><code>statement_list</code></em>]
END [<em class="replaceable"><code>end_label</code></em>]
</pre><p>
            <a class="link" href="sql-syntax.html#begin-end" title="13.6.1&nbsp;BEGIN ... END Compound-Statement Syntax"><code class="literal">BEGIN ... END</code></a>
            syntax is used for writing compound statements, which can appear
            within stored programs (stored procedures and functions, triggers,
            and events). A compound statement can contain multiple statements,
            enclosed by the <code class="literal">BEGIN</code> and
            <code class="literal">END</code> keywords.
            <em class="replaceable"><code>statement_list</code></em> represents a list of one
            or more statements, each terminated by a semicolon
            (<code class="literal">;</code>) statement delimiter. The
            <em class="replaceable"><code>statement_list</code></em> itself is optional, so
            the empty compound statement (<code class="literal">BEGIN END</code>) is
            legal.
        </p><p style="color:blue;">开始…结束语法用于编写复合语句，可以出现在存储程序（存储过程和函数、触发器和事件）中。复合语句可以包含多个语句，由begin和end关键字括起来。statement_list表示一个或多个语句的列表，每个语句以分号（；）语句分隔符结尾。语句列表本身是可选的，因此空的复合语句（begin-end）是合法的。</p><p>
            <a class="link" href="sql-syntax.html#begin-end" title="13.6.1&nbsp;BEGIN ... END Compound-Statement Syntax"><code class="literal">BEGIN ... END</code></a>
            blocks can be nested.
        </p><p style="color:blue;">开始…可以嵌套结束块。</p><p>
            Use of multiple statements requires that a client is able to send
            statement strings containing the <code class="literal">;</code> statement
            delimiter. In the <a class="link" href="programs.html#mysql" title="4.5.1&nbsp;mysql — The MySQL Command-Line Client"><span class="command"><strong>mysql</strong></span></a> command-line client,
            this is handled with the <code class="literal">delimiter</code> command.
            Changing the <code class="literal">;</code> end-of-statement delimiter (for
            example, to <code class="literal">//</code>) permit <code class="literal">;</code> to
            be used in a program body. For an example, see
            <a class="xref" href="stored-objects.html#stored-programs-defining" title="23.1&nbsp;Defining Stored Programs">Section&nbsp;23.1, “Defining Stored Programs”</a>.
        </p><p style="color:blue;">使用多个语句要求客户端能够发送包含；语句分隔符的语句字符串。在mysql命令行客户机中，这是用delimiter命令处理的。将；语句结尾分隔符（例如，改为//）允许；在程序体中使用。例如，请参见第23.1节“定义存储程序”。</p><p>
            A <a class="link" href="sql-syntax.html#begin-end" title="13.6.1&nbsp;BEGIN ... END Compound-Statement Syntax"><code class="literal">BEGIN ...
            END</code></a> block can be labeled. See
            <a class="xref" href="sql-syntax.html#statement-labels" title="13.6.2&nbsp;Statement Label Syntax">Section&nbsp;13.6.2, “Statement Label Syntax”</a>.
        </p><p style="color:blue;">开始…可以标记结束块。见第13.6.2节“语句标签语法”。</p><p>
            The optional <code class="literal">[NOT] ATOMIC</code> clause is not
            supported. This means that no transactional savepoint is set at
            the start of the instruction block and the
            <code class="literal">BEGIN</code> clause used in this context has no effect
            on the current transaction.
        </p><p style="color:blue;">不支持可选的[非]原子子句。这意味着在指令块的开头没有设置事务性保存点，并且在此上下文中使用的BEGIN子句对当前事务没有影响。</p>
            <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">

                <div class="admon-title">
                    Note
                </div>
                <p>
                    Within all stored programs, the parser treats
                    <a class="link" href="sql-syntax.html#commit" title="13.3.1&nbsp;START TRANSACTION, COMMIT, and ROLLBACK Syntax"><code class="literal">BEGIN [WORK]</code></a>
                    as the beginning of a
                    <a class="link" href="sql-syntax.html#begin-end" title="13.6.1&nbsp;BEGIN ... END Compound-Statement Syntax"><code class="literal">BEGIN ...
                        END</code></a> block. To begin a transaction in this context, use
                    <a class="link" href="sql-syntax.html#commit" title="13.3.1&nbsp;START TRANSACTION, COMMIT, and ROLLBACK Syntax"><code class="literal">START
                        TRANSACTION</code></a> instead.
                </p><p style="color:blue;">在所有存储的程序中，解析器将begin[work]视为begin的开始…端块。要在此上下文中开始事务，请改用start transaction。</p>
            </div>

        </div>
        <div class="section">
            <div class="titlepage">
                <div>
                    <div>
                        <h3 class="title"><a name="statement-labels"></a>13.6.2&nbsp;Statement Label Syntax</h3>

                    </div>

                </div>

            </div>
            <a class="indexterm" name="idm140286831578496"></a><a class="indexterm" name="idm140286831577008"></a><a class="indexterm" name="idm140286831575520"></a><a class="indexterm" name="idm140286831574032"></a><a class="indexterm" name="idm140286831572544"></a><pre data-lang="sql" class="programlisting">[<em class="replaceable"><code>begin_label</code></em>:] BEGIN
    [<em class="replaceable"><code>statement_list</code></em>]
END [<em class="replaceable"><code>end_label</code></em>]

[<em class="replaceable"><code>begin_label</code></em>:] LOOP
    <em class="replaceable"><code>statement_list</code></em>
END LOOP [<em class="replaceable"><code>end_label</code></em>]

[<em class="replaceable"><code>begin_label</code></em>:] REPEAT
    <em class="replaceable"><code>statement_list</code></em>
UNTIL <em class="replaceable"><code>search_condition</code></em>
END REPEAT [<em class="replaceable"><code>end_label</code></em>]

[<em class="replaceable"><code>begin_label</code></em>:] WHILE <em class="replaceable"><code>search_condition</code></em> DO
    <em class="replaceable"><code>statement_list</code></em>
END WHILE [<em class="replaceable"><code>end_label</code></em>]
</pre><p>
            Labels are permitted for
            <a class="link" href="sql-syntax.html#begin-end" title="13.6.1&nbsp;BEGIN ... END Compound-Statement Syntax"><code class="literal">BEGIN ... END</code></a>
            blocks and for the <a class="link" href="sql-syntax.html#loop" title="13.6.5.5&nbsp;LOOP Syntax"><code class="literal">LOOP</code></a>,
            <a class="link" href="sql-syntax.html#repeat" title="13.6.5.6&nbsp;REPEAT Syntax"><code class="literal">REPEAT</code></a>, and
            <a class="link" href="sql-syntax.html#while" title="13.6.5.8&nbsp;WHILE Syntax"><code class="literal">WHILE</code></a> statements. Label use for
            those statements follows these rules:
        </p><p style="color:blue;">允许开始使用标签…结束块，对于循环，重复和while语句。这些语句的标签使用遵循以下规则：</p>
            <div class="itemizedlist">
                <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                    <em class="replaceable"><code>begin_label</code></em> must be followed by a
                    colon.
                </p><p style="color:blue;">“开始”标签后面必须跟一个冒号。</p></li><li class="listitem"><p>
                    <em class="replaceable"><code>begin_label</code></em> can be given without
                    <em class="replaceable"><code>end_label</code></em>. If
                    <em class="replaceable"><code>end_label</code></em> is present, it must be
                    the same as <em class="replaceable"><code>begin_label</code></em>.
                </p><p style="color:blue;">开始标签可以不带结束标签。如果存在结束标签，则它必须与开始标签相同。</p></li><li class="listitem"><p>
                    <em class="replaceable"><code>end_label</code></em> cannot be given without
                    <em class="replaceable"><code>begin_label</code></em>.
                </p><p style="color:blue;">如果没有开始标签，则不能给出结束标签。</p></li><li class="listitem"><p>
                    Labels at the same nesting level must be distinct.
                </p><p style="color:blue;">同一嵌套级别的标签必须是不同的。</p></li><li class="listitem"><p>
                    Labels can be up to 16 characters long.
                </p><p style="color:blue;">标签最长可达16个字符。</p></li></ul>
            </div>
            <p>
                To refer to a label within the labeled construct, use an
                <a class="link" href="sql-syntax.html#iterate" title="13.6.5.3&nbsp;ITERATE Syntax"><code class="literal">ITERATE</code></a> or
                <a class="link" href="sql-syntax.html#leave" title="13.6.5.4&nbsp;LEAVE Syntax"><code class="literal">LEAVE</code></a> statement. The following
                example uses those statements to continue iterating or terminate
                the loop:
            </p><p style="color:blue;">要引用标签构造中的标签，请使用iterate或leave语句。以下示例使用这些语句继续迭代或终止循环：</p><pre data-lang="sql" class="programlisting">CREATE PROCEDURE doiterate(p1 INT)
BEGIN
  label1: LOOP
    SET p1 = p1 + 1;
    IF p1 &lt; 10 THEN ITERATE label1; END IF;
    LEAVE label1;
  END LOOP label1;
END;
</pre><p>
            The scope of a block label does not include the code for handlers
            declared within the block. For details, see
            <a class="xref" href="sql-syntax.html#declare-handler" title="13.6.7.2&nbsp;DECLARE ... HANDLER Syntax">Section&nbsp;13.6.7.2, “DECLARE ... HANDLER Syntax”</a>.
        </p><p style="color:blue;">块标签的作用域不包括块内声明的处理程序的代码。有关详细信息，请参见第13.6.7.2节“声明……处理程序语法”。</p>
        </div>
        <div class="section">
            <div class="titlepage">
                <div>
                    <div>
                        <h3 class="title"><a name="declare"></a>13.6.3&nbsp;DECLARE Syntax</h3>

                    </div>

                </div>

            </div>
            <a class="indexterm" name="idm140286831540928"></a><p>
            The <a class="link" href="sql-syntax.html#declare" title="13.6.3&nbsp;DECLARE Syntax"><code class="literal">DECLARE</code></a> statement is used to
            define various items local to a program:
        </p><p style="color:blue;">declare语句用于定义程序本地的各种项：</p>
            <div class="itemizedlist">
                <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                    Local variables. See
                    <a class="xref" href="sql-syntax.html#stored-program-variables" title="13.6.4&nbsp;Variables in Stored Programs">Section&nbsp;13.6.4, “Variables in Stored Programs”</a>.
                </p><p style="color:blue;">局部变量。参见第13.6.4节“存储程序中的变量”。</p></li><li class="listitem"><p>
                    Conditions and handlers. See
                    <a class="xref" href="sql-syntax.html#condition-handling" title="13.6.7&nbsp;Condition Handling">Section&nbsp;13.6.7, “Condition Handling”</a>.
                </p><p style="color:blue;">条件和处理程序。见第13.6.7节“条件处理”。</p></li><li class="listitem"><p>
                    Cursors. See <a class="xref" href="sql-syntax.html#cursors" title="13.6.6&nbsp;Cursors">Section&nbsp;13.6.6, “Cursors”</a>.
                </p><p style="color:blue;">诅咒者。见第13.6.6节“光标”。</p></li></ul>
            </div>
            <p>
                <a class="link" href="sql-syntax.html#declare" title="13.6.3&nbsp;DECLARE Syntax"><code class="literal">DECLARE</code></a> is permitted only inside a
                <a class="link" href="sql-syntax.html#begin-end" title="13.6.1&nbsp;BEGIN ... END Compound-Statement Syntax"><code class="literal">BEGIN ... END</code></a>
                compound statement and must be at its start, before any other
                statements.
            </p><p style="color:blue;">声明只允许在开始…结束复合语句，并且必须在其开始处，在任何其他语句之前。</p><p>
            Declarations must follow a certain order. Cursor declarations must
            appear before handler declarations. Variable and condition
            declarations must appear before cursor or handler declarations.
        </p><p style="color:blue;">声明必须遵循一定的顺序。游标声明必须出现在处理程序声明之前。变量和条件声明必须出现在游标或处理程序声明之前。</p>
        </div>
        <div class="section">
            <div class="titlepage">
                <div>
                    <div>
                        <h3 class="title"><a name="stored-program-variables"></a>13.6.4&nbsp;Variables in Stored Programs</h3>

                    </div>

                </div>

            </div>
            <div class="toc">
                <dl class="toc"><dt><span class="section"><a href="sql-syntax.html#declare-local-variable">13.6.4.1 Local Variable DECLARE Syntax</a></span></dt><dt><span class="section"><a href="sql-syntax.html#local-variable-scope">13.6.4.2 Local Variable Scope and Resolution</a></span></dt></dl>
            </div>
            <p>
                System variables and user-defined variables can be used in stored
                programs, just as they can be used outside stored-program context.
                In addition, stored programs can use <code class="literal">DECLARE</code> to
                define local variables, and stored routines (procedures and
                functions) can be declared to take parameters that communicate
                values between the routine and its caller.
            </p><p style="color:blue;">系统变量和用户定义的变量可以在存储程序中使用，就像它们可以在存储程序上下文之外使用一样。此外，存储程序可以使用declare定义局部变量，存储例程（过程和函数）可以声明为获取在例程及其调用方之间传递值的参数。</p>
            <div class="itemizedlist">
                <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                    To declare local variables, use the
                    <a class="link" href="sql-syntax.html#declare-local-variable" title="13.6.4.1&nbsp;Local Variable DECLARE Syntax"><code class="literal">DECLARE</code></a>
                    statement, as described in
                    <a class="xref" href="sql-syntax.html#declare-local-variable" title="13.6.4.1&nbsp;Local Variable DECLARE Syntax">Section&nbsp;13.6.4.1, “Local Variable DECLARE Syntax”</a>.
                </p><p style="color:blue;">要声明局部变量，请使用declare语句，如第13.6.4.1节“局部变量声明语法”所述。</p></li><li class="listitem"><p>
                    Variables can be set directly with the
                    <a class="link" href="sql-syntax.html#set-variable" title="13.7.4.1&nbsp;SET Syntax for Variable Assignment"><code class="literal">SET</code></a>
                    statement. See <a class="xref" href="sql-syntax.html#set-variable" title="13.7.4.1&nbsp;SET Syntax for Variable Assignment">Section&nbsp;13.7.4.1, “SET Syntax for Variable Assignment”</a>.
                </p><p style="color:blue;">变量可以直接用set语句设置。见第13.7.4.1节“变量赋值的设置语法”。</p></li><li class="listitem"><p>
                    Results from queries can be retrieved into local variables
                    using <a class="link" href="sql-syntax.html#select-into" title="13.2.9.1&nbsp;SELECT ... INTO Syntax"><code class="literal">SELECT ...
                    INTO <em class="replaceable"><code>var_list</code></em></code></a> or by
                    opening a cursor and using
                    <a class="link" href="sql-syntax.html#fetch" title="13.6.6.3&nbsp;Cursor FETCH Syntax"><code class="literal">FETCH ... INTO
                        <em class="replaceable"><code>var_list</code></em></code></a>. See
                    <a class="xref" href="sql-syntax.html#select-into" title="13.2.9.1&nbsp;SELECT ... INTO Syntax">Section&nbsp;13.2.9.1, “SELECT ... INTO Syntax”</a>, and <a class="xref" href="sql-syntax.html#cursors" title="13.6.6&nbsp;Cursors">Section&nbsp;13.6.6, “Cursors”</a>.
                </p><p style="color:blue;">查询的结果可以使用select检索到局部变量中…或者打开一个光标并使用fetch…在变量列表中。见第13.2.9.1节，“选择……“语法”和第13.6.6节“游标”。</p></li></ul>
            </div>
            <p>
                For information about the scope of local variables and how MySQL
                resolves ambiguous names, see
                <a class="xref" href="sql-syntax.html#local-variable-scope" title="13.6.4.2&nbsp;Local Variable Scope and Resolution">Section&nbsp;13.6.4.2, “Local Variable Scope and Resolution”</a>.
            </p><p style="color:blue;">有关局部变量的作用域以及mysql如何解析不明确名称的信息，请参阅13.6.4.2节“局部变量作用域和解析”。</p><p>
            It is not permitted to assign the value <code class="literal">DEFAULT</code>
            to stored procedure or function parameters or stored program local
            variables (for example with a <code class="literal">SET
            <em class="replaceable"><code>var_name</code></em> = DEFAULT</code>
            statement). In MySQL 5.7, this results in a syntax
            error.
        </p><p style="color:blue;">不允许将默认值分配给存储过程或函数参数或存储程序局部变量（例如，使用set var_name=default语句）。在mysql 5.7中，这会导致语法错误。</p>
            <div class="section">

                <div class="titlepage">
                    <div>
                        <div>
                            <h4 class="title"><a name="declare-local-variable"></a>13.6.4.1&nbsp;Local Variable DECLARE Syntax</h4>
                        </div>
                    </div>
                </div>
                <pre data-lang="sql" class="programlisting">DECLARE <em class="replaceable"><code>var_name</code></em> [, <em class="replaceable"><code>var_name</code></em>] ... <em class="replaceable"><code>type</code></em> [DEFAULT <em class="replaceable"><code>value</code></em>]
</pre><p>
                This statement declares local variables within stored programs.
                To provide a default value for a variable, include a
                <code class="literal">DEFAULT</code> clause. The value can be specified as
                an expression; it need not be a constant. If the
                <code class="literal">DEFAULT</code> clause is missing, the initial value
                is <code class="literal">NULL</code>.
            </p><p style="color:blue;">此语句在存储程序中声明局部变量。要为变量提供默认值，请包含default子句。该值可以指定为表达式；它不必是常量。如果缺少默认子句，则初始值为空。</p><p>
                Local variables are treated like stored routine parameters with
                respect to data type and overflow checking. See
                <a class="xref" href="sql-syntax.html#create-procedure" title="13.1.16&nbsp;CREATE PROCEDURE and CREATE FUNCTION Syntax">Section&nbsp;13.1.16, “CREATE PROCEDURE and CREATE FUNCTION Syntax”</a>.
            </p><p style="color:blue;">对于数据类型和溢出检查，局部变量被视为存储的例程参数。见第13.1.16节，“创建过程和创建函数语法”。</p><p>
                Variable declarations must appear before cursor or handler
                declarations.
            </p><p style="color:blue;">变量声明必须出现在游标或处理程序声明之前。</p><p>
                Local variable names are not case-sensitive. Permissible
                characters and quoting rules are the same as for other
                identifiers, as described in <a class="xref" href="language-structure.html#identifiers" title="9.2&nbsp;Schema Object Names">Section&nbsp;9.2, “Schema Object Names”</a>.
            </p><p style="color:blue;">局部变量名不区分大小写。如第9.2节“模式对象名称”所述，允许的字符和引用规则与其他标识符相同。</p><p>
                The scope of a local variable is the
                <a class="link" href="sql-syntax.html#begin-end" title="13.6.1&nbsp;BEGIN ... END Compound-Statement Syntax"><code class="literal">BEGIN ...
                    END</code></a> block within which it is declared. The variable
                can be referred to in blocks nested within the declaring block,
                except those blocks that declare a variable with the same name.
            </p><p style="color:blue;">局部变量的作用域是…在其中声明它的结束块。变量可以在嵌套在声明块中的块中引用，但声明同名变量的块除外。</p><p>
                For examples of variable declarations, see
                <a class="xref" href="sql-syntax.html#local-variable-scope" title="13.6.4.2&nbsp;Local Variable Scope and Resolution">Section&nbsp;13.6.4.2, “Local Variable Scope and Resolution”</a>.
            </p><p style="color:blue;">有关变量声明的示例，请参见第13.6.4.2节“局部变量范围和分辨率”。</p>
            </div>
            <div class="section">
                <div class="titlepage">
                    <div>
                        <div>
                            <h4 class="title"><a name="local-variable-scope"></a>13.6.4.2&nbsp;Local Variable Scope and Resolution</h4>

                        </div>

                    </div>

                </div>
                <p>
                    The scope of a local variable is the
                    <a class="link" href="sql-syntax.html#begin-end" title="13.6.1&nbsp;BEGIN ... END Compound-Statement Syntax"><code class="literal">BEGIN ...
                        END</code></a> block within which it is declared. The variable
                    can be referred to in blocks nested within the declaring block,
                    except those blocks that declare a variable with the same name.
                </p><p style="color:blue;">局部变量的作用域是…在其中声明它的结束块。变量可以在嵌套在声明块中的块中引用，但声明同名变量的块除外。</p><p>
                Because local variables are in scope only during stored program
                execution, references to them are not permitted in prepared
                statements created within a stored program. Prepared statement
                scope is the current session, not the stored program, so the
                statement could be executed after the program ends, at which
                point the variables would no longer be in scope. For example,
                <code class="literal">SELECT ... INTO
                    <em class="replaceable"><code>local_var</code></em></code> cannot be used as
                a prepared statement. This restriction also applies to stored
                procedure and function parameters. See
                <a class="xref" href="sql-syntax.html#prepare" title="13.5.1&nbsp;PREPARE Syntax">Section&nbsp;13.5.1, “PREPARE Syntax”</a>.
            </p><p style="color:blue;">因为局部变量只在存储程序执行期间才在作用域中，所以在存储程序中创建的已准备好的语句中不允许引用它们。prepared statement scope是当前会话，而不是存储程序，因此语句可以在程序结束后执行，此时变量将不再在scope中。例如，选择…into local_var不能用作准备好的语句。此限制也适用于存储过程和函数参数。请参阅第135.1节，“准备语法”。</p><p>
                A local variable should not have the same name as a table
                column. If an SQL statement, such as a
                <a class="link" href="sql-syntax.html#select" title="13.2.9&nbsp;SELECT Syntax"><code class="literal">SELECT ...
                    INTO</code></a> statement, contains a reference to a column and a
                declared local variable with the same name, MySQL currently
                interprets the reference as the name of a variable. Consider the
                following procedure definition:
            </p><p style="color:blue;">局部变量不应与表列同名。如果一个sql语句，比如select…into语句包含对列的引用和一个同名的已声明局部变量，mysql当前将该引用解释为变量名。考虑以下过程定义：</p><pre data-lang="sql" class="programlisting">CREATE PROCEDURE sp1 (x VARCHAR(5))
BEGIN
  DECLARE xname VARCHAR(5) DEFAULT 'bob';
  DECLARE newname VARCHAR(5);
  DECLARE xid INT;

  SELECT xname, id INTO newname, xid
    FROM table1 WHERE xname = xname;
  SELECT newname;
END;
</pre><p>
                MySQL interprets <code class="literal">xname</code> in the
                <a class="link" href="sql-syntax.html#select" title="13.2.9&nbsp;SELECT Syntax"><code class="literal">SELECT</code></a> statement as a reference
                to the <code class="literal">xname</code> <span class="emphasis"><em>variable</em></span>
                rather than the <code class="literal">xname</code>
                <span class="emphasis"><em>column</em></span>. Consequently, when the procedure
                <code class="literal">sp1()</code>is called, the
                <code class="literal">newname</code> variable returns the value
                <code class="literal">'bob'</code> regardless of the value of the
                <code class="literal">table1.xname</code> column.
            </p><p style="color:blue;">mysql将select语句中的xname解释为对xname变量的引用，而不是对xname列的引用。因此，当调用过程sp1（）时，newname变量返回值“bob”，而不考虑table1.xname列的值。</p><p>
                Similarly, the cursor definition in the following procedure
                contains a <a class="link" href="sql-syntax.html#select" title="13.2.9&nbsp;SELECT Syntax"><code class="literal">SELECT</code></a> statement that
                refers to <code class="literal">xname</code>. MySQL interprets this as a
                reference to the variable of that name rather than a column
                reference.
            </p><p style="color:blue;">类似地，以下过程中的游标定义包含一个引用xname的select语句。mysql将其解释为对该名称的变量的引用，而不是列引用。</p><pre data-lang="sql" class="programlisting">CREATE PROCEDURE sp2 (x VARCHAR(5))
BEGIN
  DECLARE xname VARCHAR(5) DEFAULT 'bob';
  DECLARE newname VARCHAR(5);
  DECLARE xid INT;
  DECLARE done TINYINT DEFAULT 0;
  DECLARE cur1 CURSOR FOR SELECT xname, id FROM table1;
  DECLARE CONTINUE HANDLER FOR NOT FOUND SET done = 1;

  OPEN cur1;
  read_loop: LOOP
    FETCH FROM cur1 INTO newname, xid;
    IF done THEN LEAVE read_loop; END IF;
    SELECT newname;
  END LOOP;
  CLOSE cur1;
END;
</pre><p>
                See also <a class="xref" href="stored-objects.html#stored-program-restrictions" title="23.8&nbsp;Restrictions on Stored Programs">Section&nbsp;23.8, “Restrictions on Stored Programs”</a>.
            </p><p style="color:blue;">另请参见第23.8节“对存储程序的限制”。</p>
            </div>

        </div>
        <div class="section">
            <div class="titlepage">
                <div>
                    <div>
                        <h3 class="title"><a name="flow-control-statements"></a>13.6.5&nbsp;Flow Control Statements</h3>

                    </div>

                </div>

            </div>
            <div class="toc">
                <dl class="toc"><dt><span class="section"><a href="sql-syntax.html#case">13.6.5.1 CASE Syntax</a></span></dt><dt><span class="section"><a href="sql-syntax.html#if">13.6.5.2 IF Syntax</a></span></dt><dt><span class="section"><a href="sql-syntax.html#iterate">13.6.5.3 ITERATE Syntax</a></span></dt><dt><span class="section"><a href="sql-syntax.html#leave">13.6.5.4 LEAVE Syntax</a></span></dt><dt><span class="section"><a href="sql-syntax.html#loop">13.6.5.5 LOOP Syntax</a></span></dt><dt><span class="section"><a href="sql-syntax.html#repeat">13.6.5.6 REPEAT Syntax</a></span></dt><dt><span class="section"><a href="sql-syntax.html#return">13.6.5.7 RETURN Syntax</a></span></dt><dt><span class="section"><a href="sql-syntax.html#while">13.6.5.8 WHILE Syntax</a></span></dt></dl>
            </div>
            <p>
                MySQL supports the <a class="link" href="sql-syntax.html#if" title="13.6.5.2&nbsp;IF Syntax"><code class="literal">IF</code></a>,
                <a class="link" href="sql-syntax.html#case" title="13.6.5.1&nbsp;CASE Syntax"><code class="literal">CASE</code></a>,
                <a class="link" href="sql-syntax.html#iterate" title="13.6.5.3&nbsp;ITERATE Syntax"><code class="literal">ITERATE</code></a>,
                <a class="link" href="sql-syntax.html#leave" title="13.6.5.4&nbsp;LEAVE Syntax"><code class="literal">LEAVE</code></a>
                <a class="link" href="sql-syntax.html#loop" title="13.6.5.5&nbsp;LOOP Syntax"><code class="literal">LOOP</code></a>,
                <a class="link" href="sql-syntax.html#while" title="13.6.5.8&nbsp;WHILE Syntax"><code class="literal">WHILE</code></a>, and
                <a class="link" href="sql-syntax.html#repeat" title="13.6.5.6&nbsp;REPEAT Syntax"><code class="literal">REPEAT</code></a> constructs for flow control
                within stored programs. It also supports
                <a class="link" href="sql-syntax.html#return" title="13.6.5.7&nbsp;RETURN Syntax"><code class="literal">RETURN</code></a> within stored functions.
            </p><p style="color:blue;">mysql支持if、case、iterate、leave loop、while和repeat结构，用于存储程序中的流控制。它还支持存储函数中的返回。</p><p>
            Many of these constructs contain other statements, as indicated by
            the grammar specifications in the following sections. Such
            constructs may be nested. For example, an
            <a class="link" href="sql-syntax.html#if" title="13.6.5.2&nbsp;IF Syntax"><code class="literal">IF</code></a> statement might contain a
            <a class="link" href="sql-syntax.html#while" title="13.6.5.8&nbsp;WHILE Syntax"><code class="literal">WHILE</code></a> loop, which itself contains a
            <a class="link" href="sql-syntax.html#case" title="13.6.5.1&nbsp;CASE Syntax"><code class="literal">CASE</code></a> statement.
        </p><p style="color:blue;">这些结构中有许多包含其他语句，如以下各节中的语法规范所示。这样的构造可以嵌套。例如，if语句可能包含while循环，而while循环本身包含case语句。</p><p>
            MySQL does not support <code class="literal">FOR</code> loops.
        </p><p style="color:blue;">mysql不支持循环。</p>
            <div class="section">

                <div class="titlepage">
                    <div>
                        <div>
                            <h4 class="title"><a name="case"></a>13.6.5.1&nbsp;CASE Syntax</h4>
                        </div>
                    </div>
                </div>
                <a class="indexterm" name="idm140286831456112"></a><pre data-lang="sql" class="programlisting">CASE <em class="replaceable"><code>case_value</code></em>
    WHEN <em class="replaceable"><code>when_value</code></em> THEN <em class="replaceable"><code>statement_list</code></em>
    [WHEN <em class="replaceable"><code>when_value</code></em> THEN <em class="replaceable"><code>statement_list</code></em>] ...
    [ELSE <em class="replaceable"><code>statement_list</code></em>]
END CASE
</pre><p>
                Or:
            </p><p style="color:blue;">或：</p><pre data-lang="sql" class="programlisting">CASE
    WHEN <em class="replaceable"><code>search_condition</code></em> THEN <em class="replaceable"><code>statement_list</code></em>
    [WHEN <em class="replaceable"><code>search_condition</code></em> THEN <em class="replaceable"><code>statement_list</code></em>] ...
    [ELSE <em class="replaceable"><code>statement_list</code></em>]
END CASE
</pre><p>
                The <a class="link" href="sql-syntax.html#case" title="13.6.5.1&nbsp;CASE Syntax"><code class="literal">CASE</code></a> statement for stored
                programs implements a complex conditional construct.
            </p><p style="color:blue;">存储程序的case语句实现了一个复杂的条件构造。</p>
                <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">

                    <div class="admon-title">
                        Note
                    </div>
                    <p>
                        There is also a <a class="link" href="functions.html#operator_case"><code class="literal">CASE</code></a>
                        <span class="emphasis"><em>expr</em></span>, which differs from the
                        <a class="link" href="sql-syntax.html#case" title="13.6.5.1&nbsp;CASE Syntax"><code class="literal">CASE</code></a>
                        <span class="emphasis"><em>statement</em></span> described here. See
                        <a class="xref" href="functions.html#control-flow-functions" title="12.4&nbsp;Control Flow Functions">Section&nbsp;12.4, “Control Flow Functions”</a>. The
                        <a class="link" href="sql-syntax.html#case" title="13.6.5.1&nbsp;CASE Syntax"><code class="literal">CASE</code></a> statement cannot have an
                        <code class="literal">ELSE NULL</code> clause, and it is terminated with
                        <code class="literal">END CASE</code> instead of <code class="literal">END</code>.
                    </p><p style="color:blue;">还有一个case expr，它与这里描述的case语句不同。见第12.4节“控制流功能”。case语句不能有else空子句，它以end case而不是end结束。</p>
                </div>
                <p>
                    For the first syntax, <em class="replaceable"><code>case_value</code></em> is
                    an expression. This value is compared to the
                    <em class="replaceable"><code>when_value</code></em> expression in each
                    <code class="literal">WHEN</code> clause until one of them is equal. When
                    an equal <em class="replaceable"><code>when_value</code></em> is found, the
                    corresponding <code class="literal">THEN</code> clause
                    <em class="replaceable"><code>statement_list</code></em> executes. If no
                    <em class="replaceable"><code>when_value</code></em> is equal, the
                    <code class="literal">ELSE</code> clause
                    <em class="replaceable"><code>statement_list</code></em> executes, if there is
                    one.
                </p><p style="color:blue;">对于第一种语法，case_value是一个表达式。此值将与每个when子句中的when_值表达式进行比较，直到其中一个相等为止。当找到相等的when_值时，将执行相应的then子句语句_list。如果“否”的值等于，则执行else子句列表（如果有）。</p><p>
                This syntax cannot be used to test for equality with
                <code class="literal">NULL</code> because <code class="literal">NULL = NULL</code>
                is false. See <a class="xref" href="tutorial.html#working-with-null" title="3.3.4.6&nbsp;Working with NULL Values">Section&nbsp;3.3.4.6, “Working with NULL Values”</a>.
            </p><p style="color:blue;">此语法不能用于测试null是否相等，因为null=null为false。见第3.3.4.6节“使用空值”。</p><p>
                For the second syntax, each <code class="literal">WHEN</code> clause
                <em class="replaceable"><code>search_condition</code></em> expression is
                evaluated until one is true, at which point its corresponding
                <code class="literal">THEN</code> clause
                <em class="replaceable"><code>statement_list</code></em> executes. If no
                <em class="replaceable"><code>search_condition</code></em> is equal, the
                <code class="literal">ELSE</code> clause
                <em class="replaceable"><code>statement_list</code></em> executes, if there is
                one.
            </p><p style="color:blue;">对于第二种语法，每个when子句search_condition表达式都将被求值，直到其中一个表达式为true，此时将执行其相应的then子句语句_list。如果没有搜索条件等于，则执行else子句列表（如果有）。</p><p>
                If no <em class="replaceable"><code>when_value</code></em> or
                <em class="replaceable"><code>search_condition</code></em> matches the value
                tested and the <a class="link" href="sql-syntax.html#case" title="13.6.5.1&nbsp;CASE Syntax"><code class="literal">CASE</code></a> statement
                contains no <code class="literal">ELSE</code> clause, a <span class="errortext">Case
        not found for CASE statement</span> error results.
            </p><p style="color:blue;">如果when_value或search_条件与测试的值匹配且case语句不包含else子句，则case语句错误结果将找不到case。</p><p>
                Each <em class="replaceable"><code>statement_list</code></em> consists of one
                or more SQL statements; an empty
                <em class="replaceable"><code>statement_list</code></em> is not permitted.
            </p><p style="color:blue;">每个语句列表由一个或多个SQL语句组成；不允许使用空语句列表。</p><p>
                To handle situations where no value is matched by any
                <code class="literal">WHEN</code> clause, use an <code class="literal">ELSE</code>
                containing an empty
                <a class="link" href="sql-syntax.html#begin-end" title="13.6.1&nbsp;BEGIN ... END Compound-Statement Syntax"><code class="literal">BEGIN ...
                    END</code></a> block, as shown in this example. (The indentation
                used here in the <code class="literal">ELSE</code> clause is for purposes
                of clarity only, and is not otherwise significant.)
            </p><p style="color:blue;">若要处理任何when子句都不匹配任何值的情况，请使用包含空开头的else…结束块，如本例所示。（else子句中此处使用的缩进仅用于澄清目的，在其他方面不重要。）</p><pre data-lang="sql" class="programlisting">DELIMITER |

CREATE PROCEDURE p()
  BEGIN
    DECLARE v INT DEFAULT 1;

    CASE v
      WHEN 2 THEN SELECT v;
      WHEN 3 THEN SELECT 0;
      ELSE
        BEGIN
        END;
    END CASE;
  END;
  |
</pre>
            </div>
            <div class="section">
                <div class="titlepage">
                    <div>
                        <div>
                            <h4 class="title"><a name="if"></a>13.6.5.2&nbsp;IF Syntax</h4>

                        </div>

                    </div>

                </div>
                <a class="indexterm" name="idm140286831410224"></a><pre data-lang="sql" class="programlisting">IF <em class="replaceable"><code>search_condition</code></em> THEN <em class="replaceable"><code>statement_list</code></em>
    [ELSEIF <em class="replaceable"><code>search_condition</code></em> THEN <em class="replaceable"><code>statement_list</code></em>] ...
    [ELSE <em class="replaceable"><code>statement_list</code></em>]
END IF
</pre><p>
                The <a class="link" href="sql-syntax.html#if" title="13.6.5.2&nbsp;IF Syntax"><code class="literal">IF</code></a> statement for stored
                programs implements a basic conditional construct.
            </p><p style="color:blue;">存储程序的if语句实现一个基本的条件构造。</p>
                <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">

                    <div class="admon-title">
                        Note
                    </div>
                    <p>
                        There is also an <a class="link" href="functions.html#function_if"><code class="literal">IF()</code></a>
                        <span class="emphasis"><em>function</em></span>, which differs from the
                        <a class="link" href="sql-syntax.html#if" title="13.6.5.2&nbsp;IF Syntax"><code class="literal">IF</code></a>
                        <span class="emphasis"><em>statement</em></span> described here. See
                        <a class="xref" href="functions.html#control-flow-functions" title="12.4&nbsp;Control Flow Functions">Section&nbsp;12.4, “Control Flow Functions”</a>. The
                        <a class="link" href="sql-syntax.html#if" title="13.6.5.2&nbsp;IF Syntax"><code class="literal">IF</code></a> statement can have
                        <code class="literal">THEN</code>, <code class="literal">ELSE</code>, and
                        <code class="literal">ELSEIF</code> clauses, and it is terminated with
                        <code class="literal">END IF</code>.
                    </p><p style="color:blue;">还有一个if（）函数，它与这里描述的if语句不同。见第12.4节“控制流功能”。if语句可以有then、else和elseif子句，并以endif结尾。</p>
                </div>
                <p>
                    If a given <em class="replaceable"><code>search_condition</code></em> evaluates
                    to true, the corresponding <code class="literal">THEN</code> or
                    <code class="literal">ELSEIF</code> clause
                    <em class="replaceable"><code>statement_list</code></em> executes. If no
                    <em class="replaceable"><code>search_condition</code></em> matches, the
                    <code class="literal">ELSE</code> clause
                    <em class="replaceable"><code>statement_list</code></em> executes.
                </p><p style="color:blue;">如果给定的搜索条件计算结果为true，则执行相应的then或elseif子句列表。如果没有匹配的搜索条件，则执行else子句列表。</p><p>
                Each <em class="replaceable"><code>statement_list</code></em> consists of one
                or more SQL statements; an empty
                <em class="replaceable"><code>statement_list</code></em> is not permitted.
            </p><p style="color:blue;">每个语句列表由一个或多个SQL语句组成；不允许使用空语句列表。</p><p>
                An <code class="literal">IF ... END IF</code> block, like all other
                flow-control blocks used within stored programs, must be
                terminated with a semicolon, as shown in this example:
            </p><p style="color:blue;">如果…End If块与存储程序中使用的所有其他流控制块一样，必须以分号结尾，如本例所示：</p><pre data-lang="sql" class="programlisting">DELIMITER //

CREATE FUNCTION SimpleCompare(n INT, m INT)
  RETURNS VARCHAR(20)

  BEGIN
    DECLARE s VARCHAR(20);

    IF n &gt; m THEN SET s = '&gt;';
    ELSEIF n = m THEN SET s = '=';
    ELSE SET s = '&lt;';
    END IF;

    SET s = CONCAT(n, ' ', s, ' ', m);

    RETURN s;
  END //

DELIMITER ;
</pre><p>
                As with other flow-control constructs, <code class="literal">IF ... END
                IF</code> blocks may be nested within other flow-control
                constructs, including other <a class="link" href="sql-syntax.html#if" title="13.6.5.2&nbsp;IF Syntax"><code class="literal">IF</code></a>
                statements. Each <a class="link" href="sql-syntax.html#if" title="13.6.5.2&nbsp;IF Syntax"><code class="literal">IF</code></a> must be
                terminated by its own <code class="literal">END IF</code> followed by a
                semicolon. You can use indentation to make nested flow-control
                blocks more easily readable by humans (although this is not
                required by MySQL), as shown here:
            </p><p style="color:blue;">与其他流控制构造一样，如果…end if块可以嵌套在其他流控制构造中，包括其他if语句。如果每个if后面跟一个分号，则必须以它自己的结尾结束。您可以使用缩进使嵌套的流控制块更易于人类阅读（尽管mysql不需要这样做），如下所示：</p><pre data-lang="sql" class="programlisting">DELIMITER //

CREATE FUNCTION VerboseCompare (n INT, m INT)
  RETURNS VARCHAR(50)

  BEGIN
    DECLARE s VARCHAR(50);

    IF n = m THEN SET s = 'equals';
    ELSE
      IF n &gt; m THEN SET s = 'greater';
      ELSE SET s = 'less';
      END IF;

      SET s = CONCAT('is ', s, ' than');
    END IF;

    SET s = CONCAT(n, ' ', s, ' ', m, '.');

    RETURN s;
  END //

DELIMITER ;
</pre><p>
                In this example, the inner <a class="link" href="sql-syntax.html#if" title="13.6.5.2&nbsp;IF Syntax"><code class="literal">IF</code></a> is
                evaluated only if <code class="literal">n</code> is not equal to
                <code class="literal">m</code>.
            </p><p style="color:blue;">在本例中，仅当n不等于m时才计算内部if。</p>
            </div>
            <div class="section">
                <div class="titlepage">
                    <div>
                        <div>
                            <h4 class="title"><a name="iterate"></a>13.6.5.3&nbsp;ITERATE Syntax</h4>

                        </div>

                    </div>

                </div>
                <a class="indexterm" name="idm140286831372992"></a><pre data-lang="sql" class="programlisting">ITERATE <em class="replaceable"><code>label</code></em>
</pre><p>
                <a class="link" href="sql-syntax.html#iterate" title="13.6.5.3&nbsp;ITERATE Syntax"><code class="literal">ITERATE</code></a> can appear only within
                <a class="link" href="sql-syntax.html#loop" title="13.6.5.5&nbsp;LOOP Syntax"><code class="literal">LOOP</code></a>,
                <a class="link" href="sql-syntax.html#repeat" title="13.6.5.6&nbsp;REPEAT Syntax"><code class="literal">REPEAT</code></a>, and
                <a class="link" href="sql-syntax.html#while" title="13.6.5.8&nbsp;WHILE Syntax"><code class="literal">WHILE</code></a> statements.
                <a class="link" href="sql-syntax.html#iterate" title="13.6.5.3&nbsp;ITERATE Syntax"><code class="literal">ITERATE</code></a> means <span class="quote">“<span class="quote">start the
        loop again.</span>”</span>
            </p><p style="color:blue;">iterate只能出现在loop、repeat和while语句中。迭代意味着“重新开始循环”。</p><p>
                For an example, see <a class="xref" href="sql-syntax.html#loop" title="13.6.5.5&nbsp;LOOP Syntax">Section&nbsp;13.6.5.5, “LOOP Syntax”</a>.
            </p><p style="color:blue;">例如，请参见第13.6.5.5节“循环语法”。</p>
            </div>
            <div class="section">
                <div class="titlepage">
                    <div>
                        <div>
                            <h4 class="title"><a name="leave"></a>13.6.5.4&nbsp;LEAVE Syntax</h4>

                        </div>

                    </div>

                </div>
                <a class="indexterm" name="idm140286831358176"></a><pre data-lang="sql" class="programlisting">LEAVE <em class="replaceable"><code>label</code></em>
</pre><p>
                This statement is used to exit the flow control construct that
                has the given label. If the label is for the outermost stored
                program block, <a class="link" href="sql-syntax.html#leave" title="13.6.5.4&nbsp;LEAVE Syntax"><code class="literal">LEAVE</code></a> exits the
                program.
            </p><p style="color:blue;">此语句用于退出具有给定标签的流控制结构。如果标签是针对最外存储的程序块，则退出程序。</p><p>
                <a class="link" href="sql-syntax.html#leave" title="13.6.5.4&nbsp;LEAVE Syntax"><code class="literal">LEAVE</code></a> can be used within
                <a class="link" href="sql-syntax.html#begin-end" title="13.6.1&nbsp;BEGIN ... END Compound-Statement Syntax"><code class="literal">BEGIN ...
                    END</code></a> or loop constructs
                (<a class="link" href="sql-syntax.html#loop" title="13.6.5.5&nbsp;LOOP Syntax"><code class="literal">LOOP</code></a>,
                <a class="link" href="sql-syntax.html#repeat" title="13.6.5.6&nbsp;REPEAT Syntax"><code class="literal">REPEAT</code></a>,
                <a class="link" href="sql-syntax.html#while" title="13.6.5.8&nbsp;WHILE Syntax"><code class="literal">WHILE</code></a>).
            </p><p style="color:blue;">请假可以在开始…结束或循环构造（循环、重复、while）。</p><p>
                For an example, see <a class="xref" href="sql-syntax.html#loop" title="13.6.5.5&nbsp;LOOP Syntax">Section&nbsp;13.6.5.5, “LOOP Syntax”</a>.
            </p><p style="color:blue;">例如，请参见第13.6.5.5节“循环语法”。</p>
            </div>
            <div class="section">
                <div class="titlepage">
                    <div>
                        <div>
                            <h4 class="title"><a name="loop"></a>13.6.5.5&nbsp;LOOP Syntax</h4>

                        </div>

                    </div>

                </div>
                <a class="indexterm" name="idm140286831341968"></a><pre data-lang="sql" class="programlisting">[<em class="replaceable"><code>begin_label</code></em>:] LOOP
    <em class="replaceable"><code>statement_list</code></em>
END LOOP [<em class="replaceable"><code>end_label</code></em>]
</pre><p>
                <a class="link" href="sql-syntax.html#loop" title="13.6.5.5&nbsp;LOOP Syntax"><code class="literal">LOOP</code></a> implements a simple loop
                construct, enabling repeated execution of the statement list,
                which consists of one or more statements, each terminated by a
                semicolon (<code class="literal">;</code>) statement delimiter. The
                statements within the loop are repeated until the loop is
                terminated. Usually, this is accomplished with a
                <a class="link" href="sql-syntax.html#leave" title="13.6.5.4&nbsp;LEAVE Syntax"><code class="literal">LEAVE</code></a> statement. Within a stored
                function, <a class="link" href="sql-syntax.html#return" title="13.6.5.7&nbsp;RETURN Syntax"><code class="literal">RETURN</code></a> can also be
                used, which exits the function entirely.
            </p><p style="color:blue;">循环实现了一个简单的循环构造，允许重复执行语句列表，语句列表由一个或多个语句组成，每个语句以分号（；）语句分隔符结尾。循环中的语句将重复，直到循环终止。通常，这是通过休假声明来完成的。在存储函数中，还可以使用返回，它完全退出函数。</p><p>
                Neglecting to include a loop-termination statement results in an
                infinite loop.
            </p><p style="color:blue;">忽略包含循环终止语句将导致无限循环。</p><p>
                A <a class="link" href="sql-syntax.html#loop" title="13.6.5.5&nbsp;LOOP Syntax"><code class="literal">LOOP</code></a> statement can be labeled.
                For the rules regarding label use, see
                <a class="xref" href="sql-syntax.html#statement-labels" title="13.6.2&nbsp;Statement Label Syntax">Section&nbsp;13.6.2, “Statement Label Syntax”</a>.
            </p><p style="color:blue;">可以标记循环语句。有关标签使用的规则，请参见第13.6.2节“语句标签语法”。</p><p>
                Example:
            </p><p style="color:blue;">例子：</p><pre data-lang="sql" class="programlisting">CREATE PROCEDURE doiterate(p1 INT)
BEGIN
  label1: LOOP
    SET p1 = p1 + 1;
    IF p1 &lt; 10 THEN
      ITERATE label1;
    END IF;
    LEAVE label1;
  END LOOP label1;
  SET @x = p1;
END;
</pre>
            </div>
            <div class="section">
                <div class="titlepage">
                    <div>
                        <div>
                            <h4 class="title"><a name="repeat"></a>13.6.5.6&nbsp;REPEAT Syntax</h4>

                        </div>

                    </div>

                </div>
                <a class="indexterm" name="idm140286831323360"></a><a class="indexterm" name="idm140286831322288"></a><pre data-lang="sql" class="programlisting">[<em class="replaceable"><code>begin_label</code></em>:] REPEAT
    <em class="replaceable"><code>statement_list</code></em>
UNTIL <em class="replaceable"><code>search_condition</code></em>
END REPEAT [<em class="replaceable"><code>end_label</code></em>]
</pre><p>
                The statement list within a
                <a class="link" href="sql-syntax.html#repeat" title="13.6.5.6&nbsp;REPEAT Syntax"><code class="literal">REPEAT</code></a> statement is repeated
                until the <em class="replaceable"><code>search_condition</code></em> expression
                is true. Thus, a <a class="link" href="sql-syntax.html#repeat" title="13.6.5.6&nbsp;REPEAT Syntax"><code class="literal">REPEAT</code></a> always
                enters the loop at least once.
                <em class="replaceable"><code>statement_list</code></em> consists of one or
                more statements, each terminated by a semicolon
                (<code class="literal">;</code>) statement delimiter.
            </p><p style="color:blue;">重复语句中的语句列表将重复，直到搜索条件表达式为true。因此，重复总是至少进入一次循环。语句列表由一个或多个语句组成，每个语句以分号（；）语句分隔符结尾。</p><p>
                A <a class="link" href="sql-syntax.html#repeat" title="13.6.5.6&nbsp;REPEAT Syntax"><code class="literal">REPEAT</code></a> statement can be
                labeled. For the rules regarding label use, see
                <a class="xref" href="sql-syntax.html#statement-labels" title="13.6.2&nbsp;Statement Label Syntax">Section&nbsp;13.6.2, “Statement Label Syntax”</a>.
            </p><p style="color:blue;">可以标记重复语句。有关标签使用的规则，请参见第13.6.2节“语句标签语法”。</p><p>
                Example:
            </p><p style="color:blue;">例子：</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>delimiter //</code></strong>

mysql&gt; <strong class="userinput"><code>CREATE PROCEDURE dorepeat(p1 INT)</code></strong>
       <strong class="userinput"><code>BEGIN</code></strong>
         <strong class="userinput"><code>SET @x = 0;</code></strong>
         <strong class="userinput"><code>REPEAT</code></strong>
           <strong class="userinput"><code>SET @x = @x + 1;</code></strong>
         <strong class="userinput"><code>UNTIL @x &gt; p1 END REPEAT;</code></strong>
       <strong class="userinput"><code>END</code></strong>
       <strong class="userinput"><code>//</code></strong>
Query OK, 0 rows affected (0.00 sec)

mysql&gt; <strong class="userinput"><code>CALL dorepeat(1000)//</code></strong>
Query OK, 0 rows affected (0.00 sec)

mysql&gt; <strong class="userinput"><code>SELECT @x//</code></strong>
+------+
| @x   |
+------+
| 1001 |
+------+
1 row in set (0.00 sec)
</pre>
            </div>
            <div class="section">
                <div class="titlepage">
                    <div>
                        <div>
                            <h4 class="title"><a name="return"></a>13.6.5.7&nbsp;RETURN Syntax</h4>

                        </div>

                    </div>

                </div>
                <a class="indexterm" name="idm140286831296864"></a><pre data-lang="sql" class="programlisting">RETURN <em class="replaceable"><code>expr</code></em>
</pre><p>
                The <a class="link" href="sql-syntax.html#return" title="13.6.5.7&nbsp;RETURN Syntax"><code class="literal">RETURN</code></a> statement terminates
                execution of a stored function and returns the value
                <em class="replaceable"><code>expr</code></em> to the function caller. There
                must be at least one <a class="link" href="sql-syntax.html#return" title="13.6.5.7&nbsp;RETURN Syntax"><code class="literal">RETURN</code></a>
                statement in a stored function. There may be more than one if
                the function has multiple exit points.
            </p><p style="color:blue;">return语句终止存储函数的执行，并将值expr返回给函数调用方。存储函数中必须至少有一个返回语句。如果该函数有多个退出点，则可能不止一个。</p><p>
                This statement is not used in stored procedures, triggers, or
                events. The <a class="link" href="sql-syntax.html#leave" title="13.6.5.4&nbsp;LEAVE Syntax"><code class="literal">LEAVE</code></a> statement can
                be used to exit a stored program of those types.
            </p><p style="color:blue;">此语句不用于存储过程、触发器或事件。Lead语句可用于退出这些类型的存储程序。</p>
            </div>
            <div class="section">
                <div class="titlepage">
                    <div>
                        <div>
                            <h4 class="title"><a name="while"></a>13.6.5.8&nbsp;WHILE Syntax</h4>

                        </div>

                    </div>

                </div>
                <a class="indexterm" name="idm140286831284784"></a><pre data-lang="sql" class="programlisting">[<em class="replaceable"><code>begin_label</code></em>:] WHILE <em class="replaceable"><code>search_condition</code></em> DO
    <em class="replaceable"><code>statement_list</code></em>
END WHILE [<em class="replaceable"><code>end_label</code></em>]
</pre><p>
                The statement list within a <a class="link" href="sql-syntax.html#while" title="13.6.5.8&nbsp;WHILE Syntax"><code class="literal">WHILE</code></a>
                statement is repeated as long as the
                <em class="replaceable"><code>search_condition</code></em> expression is true.
                <em class="replaceable"><code>statement_list</code></em> consists of one or
                more SQL statements, each terminated by a semicolon
                (<code class="literal">;</code>) statement delimiter.
            </p><p style="color:blue;">只要搜索条件表达式为true，while语句中的语句列表就会重复。语句列表由一个或多个SQL语句组成，每个语句以分号（；）语句分隔符结尾。</p><p>
                A <a class="link" href="sql-syntax.html#while" title="13.6.5.8&nbsp;WHILE Syntax"><code class="literal">WHILE</code></a> statement can be labeled.
                For the rules regarding label use, see
                <a class="xref" href="sql-syntax.html#statement-labels" title="13.6.2&nbsp;Statement Label Syntax">Section&nbsp;13.6.2, “Statement Label Syntax”</a>.
            </p><p style="color:blue;">可以标记while语句。有关标签使用的规则，请参见第13.6.2节“语句标签语法”。</p><p>
                Example:
            </p><p style="color:blue;">例子：</p><pre data-lang="sql" class="programlisting">CREATE PROCEDURE dowhile()
BEGIN
  DECLARE v1 INT DEFAULT 5;

  WHILE v1 &gt; 0 DO
    ...
    SET v1 = v1 - 1;
  END WHILE;
END;
</pre>
            </div>

        </div>
        <div class="section">
            <div class="titlepage">
                <div>
                    <div>
                        <h3 class="title"><a name="cursors"></a>13.6.6&nbsp;Cursors</h3>

                    </div>

                </div>

            </div>
            <div class="toc">
                <dl class="toc"><dt><span class="section"><a href="sql-syntax.html#close">13.6.6.1 Cursor CLOSE Syntax</a></span></dt><dt><span class="section"><a href="sql-syntax.html#declare-cursor">13.6.6.2 Cursor DECLARE Syntax</a></span></dt><dt><span class="section"><a href="sql-syntax.html#fetch">13.6.6.3 Cursor FETCH Syntax</a></span></dt><dt><span class="section"><a href="sql-syntax.html#open">13.6.6.4 Cursor OPEN Syntax</a></span></dt><dt><span class="section"><a href="sql-syntax.html#cursor-restrictions">13.6.6.5 Restrictions on Server-Side Cursors</a></span></dt></dl>
            </div>
            <a class="indexterm" name="idm140286831268288"></a><p>
            MySQL supports cursors inside stored programs. The syntax is as in
            embedded SQL. Cursors have these properties:
        </p><p style="color:blue;">mysql支持存储程序中的游标。语法与嵌入式sql相同。游标具有以下属性：</p>
            <div class="itemizedlist">
                <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                    Asensitive: The server may or may not make a copy of its
                    result table
                </p><p style="color:blue;">asensitive：服务器可以复制或不复制其结果表</p></li><li class="listitem"><p>
                    Read only: Not updatable
                </p><p style="color:blue;">只读：不可更新</p></li><li class="listitem"><p>
                    Nonscrollable: Can be traversed only in one direction and
                    cannot skip rows
                </p><p style="color:blue;">不可滚动：只能在一个方向上遍历，不能跳过行</p></li></ul>
            </div>
            <p>
                Cursor declarations must appear before handler declarations and
                after variable and condition declarations.
            </p><p style="color:blue;">游标声明必须出现在处理程序声明之前以及变量和条件声明之后。</p><p>
            Example:
        </p><p style="color:blue;">例子：</p><pre data-lang="sql" class="programlisting">CREATE PROCEDURE curdemo()
BEGIN
  DECLARE done INT DEFAULT FALSE;
  DECLARE a CHAR(16);
  DECLARE b, c INT;
  DECLARE cur1 CURSOR FOR SELECT id,data FROM test.t1;
  DECLARE cur2 CURSOR FOR SELECT i FROM test.t2;
  DECLARE CONTINUE HANDLER FOR NOT FOUND SET done = TRUE;

  OPEN cur1;
  OPEN cur2;

  read_loop: LOOP
    FETCH cur1 INTO a, b;
    FETCH cur2 INTO c;
    IF done THEN
      LEAVE read_loop;
    END IF;
    IF b &lt; c THEN
      INSERT INTO test.t3 VALUES (a,b);
    ELSE
      INSERT INTO test.t3 VALUES (a,c);
    END IF;
  END LOOP;

  CLOSE cur1;
  CLOSE cur2;
END;
</pre>
            <div class="section">

                <div class="titlepage">
                    <div>
                        <div>
                            <h4 class="title"><a name="close"></a>13.6.6.1&nbsp;Cursor CLOSE Syntax</h4>
                        </div>
                    </div>
                </div>
                <a class="indexterm" name="idm140286831259824"></a><pre data-lang="sql" class="programlisting">CLOSE <em class="replaceable"><code>cursor_name</code></em>
</pre><p>
                This statement closes a previously opened cursor. For an
                example, see <a class="xref" href="sql-syntax.html#cursors" title="13.6.6&nbsp;Cursors">Section&nbsp;13.6.6, “Cursors”</a>.
            </p><p style="color:blue;">此语句关闭以前打开的游标。例如，见第13.6.6节“光标”。</p><p>
                An error occurs if the cursor is not open.
            </p><p style="color:blue;">如果光标未打开，则会发生错误。</p><p>
                If not closed explicitly, a cursor is closed at the end of the
                <a class="link" href="sql-syntax.html#begin-end" title="13.6.1&nbsp;BEGIN ... END Compound-Statement Syntax"><code class="literal">BEGIN ...
                    END</code></a> block in which it was declared.
            </p><p style="color:blue;">如果未显式关闭，则光标将在开始处结束时关闭…在其中声明它的结束块。</p>
            </div>
            <div class="section">
                <div class="titlepage">
                    <div>
                        <div>
                            <h4 class="title"><a name="declare-cursor"></a>13.6.6.2&nbsp;Cursor DECLARE Syntax</h4>

                        </div>

                    </div>

                </div>
                <pre data-lang="sql" class="programlisting">DECLARE <em class="replaceable"><code>cursor_name</code></em> CURSOR FOR <em class="replaceable"><code>select_statement</code></em>
</pre><p>
                This statement declares a cursor and associates it with a
                <a class="link" href="sql-syntax.html#select" title="13.2.9&nbsp;SELECT Syntax"><code class="literal">SELECT</code></a> statement that retrieves
                the rows to be traversed by the cursor. To fetch the rows later,
                use a <a class="link" href="sql-syntax.html#fetch" title="13.6.6.3&nbsp;Cursor FETCH Syntax"><code class="literal">FETCH</code></a> statement. The number
                of columns retrieved by the
                <a class="link" href="sql-syntax.html#select" title="13.2.9&nbsp;SELECT Syntax"><code class="literal">SELECT</code></a> statement must match the
                number of output variables specified in the
                <a class="link" href="sql-syntax.html#fetch" title="13.6.6.3&nbsp;Cursor FETCH Syntax"><code class="literal">FETCH</code></a> statement.
            </p><p style="color:blue;">此语句声明一个游标，并将其与检索游标要遍历的行的select语句相关联。要稍后提取行，请使用FETCH语句。select语句检索的列数必须与fetch语句中指定的输出变量数匹配。</p><p>
                The <a class="link" href="sql-syntax.html#select" title="13.2.9&nbsp;SELECT Syntax"><code class="literal">SELECT</code></a> statement cannot have
                an <code class="literal">INTO</code> clause.
            </p><p style="color:blue;">select语句不能有into子句。</p><p>
                Cursor declarations must appear before handler declarations and
                after variable and condition declarations.
            </p><p style="color:blue;">游标声明必须出现在处理程序声明之前以及变量和条件声明之后。</p><p>
                A stored program may contain multiple cursor declarations, but
                each cursor declared in a given block must have a unique name.
                For an example, see <a class="xref" href="sql-syntax.html#cursors" title="13.6.6&nbsp;Cursors">Section&nbsp;13.6.6, “Cursors”</a>.
            </p><p style="color:blue;">存储程序可以包含多个游标声明，但在给定块中声明的每个游标必须具有唯一的名称。例如，见第13.6.6节“光标”。</p><p>
                For information available through
                <a class="link" href="sql-syntax.html#show" title="13.7.5&nbsp;SHOW Syntax"><code class="literal">SHOW</code></a> statements, it is possible
                in many cases to obtain equivalent information by using a cursor
                with an <code class="literal">INFORMATION_SCHEMA</code> table.
            </p><p style="color:blue;">对于通过show语句提供的信息，在许多情况下，可以通过使用带有information\u schema表的游标来获得等效的信息。</p>
            </div>
            <div class="section">
                <div class="titlepage">
                    <div>
                        <div>
                            <h4 class="title"><a name="fetch"></a>13.6.6.3&nbsp;Cursor FETCH Syntax</h4>

                        </div>

                    </div>

                </div>
                <a class="indexterm" name="idm140286831231328"></a><pre data-lang="sql" class="programlisting">FETCH [[NEXT] FROM] <em class="replaceable"><code>cursor_name</code></em> INTO <em class="replaceable"><code>var_name</code></em> [, <em class="replaceable"><code>var_name</code></em>] ...
</pre><p>
                This statement fetches the next row for the
                <a class="link" href="sql-syntax.html#select" title="13.2.9&nbsp;SELECT Syntax"><code class="literal">SELECT</code></a> statement associated with
                the specified cursor (which must be open), and advances the
                cursor pointer. If a row exists, the fetched columns are stored
                in the named variables. The number of columns retrieved by the
                <a class="link" href="sql-syntax.html#select" title="13.2.9&nbsp;SELECT Syntax"><code class="literal">SELECT</code></a> statement must match the
                number of output variables specified in the
                <a class="link" href="sql-syntax.html#fetch" title="13.6.6.3&nbsp;Cursor FETCH Syntax"><code class="literal">FETCH</code></a> statement.
            </p><p style="color:blue;">此语句获取与指定游标（必须打开）关联的select语句的下一行，并前进光标指针。如果存在行，则将获取的列存储在命名变量中。select语句检索的列数必须与fetch语句中指定的输出变量数匹配。</p><p>
                If no more rows are available, a No Data condition occurs with
                SQLSTATE value <code class="literal">'02000'</code>. To detect this
                condition, you can set up a handler for it (or for a
                <code class="literal">NOT FOUND</code> condition). For an example, see
                <a class="xref" href="sql-syntax.html#cursors" title="13.6.6&nbsp;Cursors">Section&nbsp;13.6.6, “Cursors”</a>.
            </p><p style="color:blue;">如果没有更多的行可用，则会出现sqlstate值为“02000”的“无数据”条件。要检测此条件，可以为其设置处理程序（或为未找到的条件设置处理程序）。例如，见第13.6.6节“光标”。</p><p>
                Be aware that another operation, such as a
                <code class="literal">SELECT</code> or another <code class="literal">FETCH</code>,
                may also cause the handler to execute by raising the same
                condition. If it is necessary to distinguish which operation
                raised the condition, place the operation within its own
                <a class="link" href="sql-syntax.html#begin-end" title="13.6.1&nbsp;BEGIN ... END Compound-Statement Syntax"><code class="literal">BEGIN ...
                    END</code></a> block so that it can be associated with its own
                handler.
            </p><p style="color:blue;">请注意，另一个操作（例如select或另一个fetch）也可能通过引发相同的条件来导致处理程序执行。如果有必要区分是哪种操作引起了这种情况，请将操作放在它自己的开始范围内…结束块，以便它可以与其自己的处理程序关联。</p>
            </div>
            <div class="section">
                <div class="titlepage">
                    <div>
                        <div>
                            <h4 class="title"><a name="open"></a>13.6.6.4&nbsp;Cursor OPEN Syntax</h4>

                        </div>

                    </div>

                </div>
                <a class="indexterm" name="idm140286831213136"></a><pre data-lang="sql" class="programlisting">OPEN <em class="replaceable"><code>cursor_name</code></em>
</pre><p>
                This statement opens a previously declared cursor. For an
                example, see <a class="xref" href="sql-syntax.html#cursors" title="13.6.6&nbsp;Cursors">Section&nbsp;13.6.6, “Cursors”</a>.
            </p><p style="color:blue;">此语句打开先前声明的游标。例如，见第13.6.6节“光标”。</p>
            </div>
            <div class="section">
                <div class="titlepage">
                    <div>
                        <div>
                            <h4 class="title"><a name="cursor-restrictions"></a>13.6.6.5&nbsp;Restrictions on Server-Side Cursors</h4>

                        </div>

                    </div>

                </div>
                <a class="indexterm" name="idm140286831205152"></a><a class="indexterm" name="idm140286831203696"></a><p>
                Server-side cursors are implemented in the C API using the
                <a class="link" href="connectors-apis.html#mysql-stmt-attr-set" title="27.8.11.3&nbsp;mysql_stmt_attr_set()"><code class="literal">mysql_stmt_attr_set()</code></a> function.
                The same implementation is used for cursors in stored routines.
                A server-side cursor enables a result set to be generated on the
                server side, but not transferred to the client except for those
                rows that the client requests. For example, if a client executes
                a query but is only interested in the first row, the remaining
                rows are not transferred.
            </p><p style="color:blue;">服务器端游标在C API中使用mysql_stmt_attr_set（）函数实现。存储例程中的游标也使用相同的实现。服务器端游标允许在服务器端生成结果集，但除了客户端请求的行之外，不会将结果集传输到客户端。例如，如果客户机执行查询，但只对第一行感兴趣，则不会传输其余行。</p><p>
                In MySQL, a server-side cursor is materialized into an internal
                temporary table. Initially, this is a <code class="literal">MEMORY</code>
                table, but is converted to a <code class="literal">MyISAM</code> table
                when its size exceeds the minimum value of the
                <a class="link" href="server-administration.html#sysvar_max_heap_table_size"><code class="literal">max_heap_table_size</code></a> and
                <a class="link" href="server-administration.html#sysvar_tmp_table_size"><code class="literal">tmp_table_size</code></a> system
                variables. The same restrictions apply to internal temporary
                tables created to hold the result set for a cursor as for other
                uses of internal temporary tables. See
                <a class="xref" href="optimization.html#internal-temporary-tables" title="8.4.4&nbsp;Internal Temporary Table Use in MySQL">Section&nbsp;8.4.4, “Internal Temporary Table Use in MySQL”</a>. One limitation of
                the implementation is that for a large result set, retrieving
                its rows through a cursor might be slow.
            </p><p style="color:blue;">在mysql中，服务器端游标被具体化为一个内部临时表。最初，这是一个内存表，但当其大小超过max_heap_table_size和tmp_table_size系统变量的最小值时，它会转换为myisam表。对于为保存游标结果集而创建的内部临时表，与内部临时表的其他用途一样，也有相同的限制。见8.4.4节，“MySQL中的内部临时表使用”。实现的一个限制是，对于大型结果集，通过游标检索其行可能会很慢。</p><p>
                Cursors are read only; you cannot use a cursor to update rows.
            </p><p style="color:blue;">游标是只读的；不能使用游标更新行。</p><p>
                <code class="literal">UPDATE WHERE CURRENT OF</code> and <code class="literal">DELETE
                WHERE CURRENT OF</code> are not implemented, because
                updatable cursors are not supported.
            </p><p style="color:blue;">未实现update where current of和delete where current of，因为不支持可更新的游标。</p><p>
                Cursors are nonholdable (not held open after a commit).
            </p><p style="color:blue;">游标是不可保持的（提交后不保持打开状态）。</p><p>
                Cursors are asensitive.
            </p><p style="color:blue;">游标是非敏感的。</p><p>
                Cursors are nonscrollable.
            </p><p style="color:blue;">游标是不可滚动的。</p><p>
                Cursors are not named. The statement handler acts as the cursor
                ID.
            </p><p style="color:blue;">游标不命名。语句处理程序充当游标id。</p><p>
                You can have open only a single cursor per prepared statement.
                If you need several cursors, you must prepare several
                statements.
            </p><p style="color:blue;">每个准备好的语句只能打开一个游标。如果需要多个游标，则必须准备多个语句。</p><p>
                You cannot use a cursor for a statement that generates a result
                set if the statement is not supported in prepared mode. This
                includes statements such as <a class="link" href="sql-syntax.html#check-table" title="13.7.2.2&nbsp;CHECK TABLE Syntax"><code class="literal">CHECK
                TABLE</code></a>, <code class="literal">HANDLER READ</code>, and
                <a class="link" href="sql-syntax.html#show-binlog-events" title="13.7.5.2&nbsp;SHOW BINLOG EVENTS Syntax"><code class="literal">SHOW BINLOG EVENTS</code></a>.
            </p><p style="color:blue;">如果在准备模式下不支持生成结果集的语句，则不能对该语句使用游标。这包括check table、handler read和show binlog事件等语句。</p>
            </div>

        </div>
        <div class="section">
            <div class="titlepage">
                <div>
                    <div>
                        <h3 class="title"><a name="condition-handling"></a>13.6.7&nbsp;Condition Handling</h3>

                    </div>

                </div>

            </div>
            <div class="toc">
                <dl class="toc"><dt><span class="section"><a href="sql-syntax.html#declare-condition">13.6.7.1 DECLARE ... CONDITION Syntax</a></span></dt><dt><span class="section"><a href="sql-syntax.html#declare-handler">13.6.7.2 DECLARE ... HANDLER Syntax</a></span></dt><dt><span class="section"><a href="sql-syntax.html#get-diagnostics">13.6.7.3 GET DIAGNOSTICS Syntax</a></span></dt><dt><span class="section"><a href="sql-syntax.html#resignal">13.6.7.4 RESIGNAL Syntax</a></span></dt><dt><span class="section"><a href="sql-syntax.html#signal">13.6.7.5 SIGNAL Syntax</a></span></dt><dt><span class="section"><a href="sql-syntax.html#handler-scope">13.6.7.6 Scope Rules for Handlers</a></span></dt><dt><span class="section"><a href="sql-syntax.html#diagnostics-area">13.6.7.7 The MySQL Diagnostics Area</a></span></dt><dt><span class="section"><a href="sql-syntax.html#conditions-and-parameters">13.6.7.8 Condition Handling and OUT or INOUT Parameters</a></span></dt><dt><span class="section"><a href="sql-syntax.html#condition-handling-restrictions">13.6.7.9 Restrictions on Condition Handling</a></span></dt></dl>
            </div>
            <p>
                Conditions may arise during stored program execution that require
                special handling, such as exiting the current program block or
                continuing execution. Handlers can be defined for general
                conditions such as warnings or exceptions, or for specific
                conditions such as a particular error code. Specific conditions
                can be assigned names and referred to that way in handlers.
            </p><p style="color:blue;">在需要特殊处理的存储程序执行过程中可能出现条件，例如退出当前程序块或继续执行。可以为一般条件（如警告或异常）或特定条件（如特定错误代码）定义处理程序。可以在处理程序中为特定条件分配名称并以这种方式引用。</p><p>
            To name a condition, use the
            <a class="link" href="sql-syntax.html#declare-condition" title="13.6.7.1&nbsp;DECLARE ... CONDITION Syntax"><code class="literal">DECLARE ...
                CONDITION</code></a> statement. To declare a handler, use the
            <a class="link" href="sql-syntax.html#declare-handler" title="13.6.7.2&nbsp;DECLARE ... HANDLER Syntax"><code class="literal">DECLARE ...
                HANDLER</code></a> statement. See
            <a class="xref" href="sql-syntax.html#declare-condition" title="13.6.7.1&nbsp;DECLARE ... CONDITION Syntax">Section&nbsp;13.6.7.1, “DECLARE ... CONDITION Syntax”</a>, and
            <a class="xref" href="sql-syntax.html#declare-handler" title="13.6.7.2&nbsp;DECLARE ... HANDLER Syntax">Section&nbsp;13.6.7.2, “DECLARE ... HANDLER Syntax”</a>. For information about how the
            server chooses handlers when a condition occurs, see
            <a class="xref" href="sql-syntax.html#handler-scope" title="13.6.7.6&nbsp;Scope Rules for Handlers">Section&nbsp;13.6.7.6, “Scope Rules for Handlers”</a>.
        </p><p style="color:blue;">要命名条件，请使用声明…条件声明。要声明处理程序，请使用声明…处理程序语句。见第13.6.7.1节，“声明……条件语法”和第13.6.7.2节“声明…处理程序语法”。有关发生条件时服务器如何选择处理程序的信息，请参阅第13.6.7.6节“处理程序的作用域规则”。</p><p>
            To raise a condition, use the
            <a class="link" href="sql-syntax.html#signal" title="13.6.7.5&nbsp;SIGNAL Syntax"><code class="literal">SIGNAL</code></a> statement. To modify
            condition information within a condition handler, use
            <a class="link" href="sql-syntax.html#resignal" title="13.6.7.4&nbsp;RESIGNAL Syntax"><code class="literal">RESIGNAL</code></a>. See
            <a class="xref" href="sql-syntax.html#declare-condition" title="13.6.7.1&nbsp;DECLARE ... CONDITION Syntax">Section&nbsp;13.6.7.1, “DECLARE ... CONDITION Syntax”</a>, and
            <a class="xref" href="sql-syntax.html#declare-handler" title="13.6.7.2&nbsp;DECLARE ... HANDLER Syntax">Section&nbsp;13.6.7.2, “DECLARE ... HANDLER Syntax”</a>.
        </p><p style="color:blue;">要提出条件，请使用signal语句。要修改条件处理程序中的条件信息，请使用resignal。见第13.6.7.1节，“声明……条件语法”和第13.6.7.2节“声明…处理程序语法”。</p><p>
            To retrieve information from the diagnostics area, use the
            <a class="link" href="sql-syntax.html#get-diagnostics" title="13.6.7.3&nbsp;GET DIAGNOSTICS Syntax"><code class="literal">GET DIAGNOSTICS</code></a> statement (see
            <a class="xref" href="sql-syntax.html#get-diagnostics" title="13.6.7.3&nbsp;GET DIAGNOSTICS Syntax">Section&nbsp;13.6.7.3, “GET DIAGNOSTICS Syntax”</a>). For information about the
            diagnostics area, see <a class="xref" href="sql-syntax.html#diagnostics-area" title="13.6.7.7&nbsp;The MySQL Diagnostics Area">Section&nbsp;13.6.7.7, “The MySQL Diagnostics Area”</a>.
        </p><p style="color:blue;">要从诊断区域检索信息，请使用get diagnostics语句（请参阅第13.6.7.3节“get diagnostics syntax”）。有关诊断区域的信息，请参阅第13.6.7.7节“MySQL诊断区域”。</p>
            <div class="section">

                <div class="titlepage">
                    <div>
                        <div>
                            <h4 class="title"><a name="declare-condition"></a>13.6.7.1&nbsp;DECLARE ... CONDITION Syntax</h4>
                        </div>
                    </div>
                </div>
                <a class="indexterm" name="idm140286831169504"></a><pre data-lang="sql" class="programlisting">DECLARE <em class="replaceable"><code>condition_name</code></em> CONDITION FOR <em class="replaceable"><code>condition_value</code></em>

<em class="replaceable"><code>condition_value</code></em>: {
    <em class="replaceable"><code>mysql_error_code</code></em>
  | SQLSTATE [VALUE] <em class="replaceable"><code>sqlstate_value</code></em>
}
</pre><p>
                The <a class="link" href="sql-syntax.html#declare-condition" title="13.6.7.1&nbsp;DECLARE ... CONDITION Syntax"><code class="literal">DECLARE
                ... CONDITION</code></a> statement declares a named error
                condition, associating a name with a condition that needs
                specific handling. The name can be referred to in a subsequent
                <a class="link" href="sql-syntax.html#declare-handler" title="13.6.7.2&nbsp;DECLARE ... HANDLER Syntax"><code class="literal">DECLARE ...
                    HANDLER</code></a> statement (see
                <a class="xref" href="sql-syntax.html#declare-handler" title="13.6.7.2&nbsp;DECLARE ... HANDLER Syntax">Section&nbsp;13.6.7.2, “DECLARE ... HANDLER Syntax”</a>).
            </p><p style="color:blue;">声明…条件语句声明命名错误条件，将名称与需要特定处理的条件相关联。该名称可以在随后的声明中引用…处理程序语句（见第13.6.7.2节“声明…”处理程序语法”）。</p><p>
                Condition declarations must appear before cursor or handler
                declarations.
            </p><p style="color:blue;">条件声明必须出现在游标或处理程序声明之前。</p><p>
                The <em class="replaceable"><code>condition_value</code></em> for
                <a class="link" href="sql-syntax.html#declare-condition" title="13.6.7.1&nbsp;DECLARE ... CONDITION Syntax"><code class="literal">DECLARE ...
                    CONDITION</code></a> indicates the specific condition or class of
                conditions to associate with the condition name. It can take the
                following forms:
            </p><p style="color:blue;">声明的条件值…条件指示要与条件名称关联的特定条件或条件类。它可以采取以下形式：</p>
                <div class="itemizedlist">
                    <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                        <em class="replaceable"><code>mysql_error_code</code></em>: An integer
                        literal indicating a MySQL error code.
                    </p><p style="color:blue;">mysql_error_code：表示mysql错误代码的整数文本。</p><p>
                        Do not use MySQL error code 0 because that indicates success
                        rather than an error condition. For a list of MySQL error
                        codes, see <a class="xref" href="error-handling.html#server-error-reference" title="B.3.1&nbsp;Server Error Message Reference">Section&nbsp;B.3.1, “Server Error Message Reference”</a>.
                    </p><p style="color:blue;">不要使用mysql错误代码0，因为这表示成功，而不是错误条件。有关MySQL错误代码的列表，请参阅B.3.1节“服务器错误消息参考”。</p></li><li class="listitem"><p>
                        SQLSTATE [VALUE] <em class="replaceable"><code>sqlstate_value</code></em>:
                        A 5-character string literal indicating an SQLSTATE value.
                    </p><p style="color:blue;">sqlstate[value]sqlstate_value：表示sqlstate值的5个字符的字符串文本。</p><p>
                        Do not use SQLSTATE values that begin with
                        <code class="literal">'00'</code> because those indicate success
                        rather than an error condition. For a list of SQLSTATE
                        values, see <a class="xref" href="error-handling.html#server-error-reference" title="B.3.1&nbsp;Server Error Message Reference">Section&nbsp;B.3.1, “Server Error Message Reference”</a>.
                    </p><p style="color:blue;">不要使用以“00”开头的sqlstate值，因为这些值表示成功，而不是错误条件。有关sqlstate值的列表，请参阅B.3.1节“服务器错误消息参考”。</p></li></ul>
                </div>
                <p>
                    Condition names referred to in
                    <a class="link" href="sql-syntax.html#signal" title="13.6.7.5&nbsp;SIGNAL Syntax"><code class="literal">SIGNAL</code></a> or use
                    <a class="link" href="sql-syntax.html#resignal" title="13.6.7.4&nbsp;RESIGNAL Syntax"><code class="literal">RESIGNAL</code></a> statements must be
                    associated with SQLSTATE values, not MySQL error codes.
                </p><p style="color:blue;">在signal或use resignal语句中引用的条件名称必须与sqlstate值关联，而不是与mysql错误代码关联。</p><p>
                Using names for conditions can help make stored program code
                clearer. For example, this handler applies to attempts to drop a
                nonexistent table, but that is apparent only if you know that
                1051 is the MySQL error code for <span class="quote">“<span class="quote">unknown table</span>”</span>:
            </p><p style="color:blue;">对条件使用名称有助于使存储的程序代码更清晰。例如，这个处理程序应用于删除一个不存在的表的尝试，但是只有当您知道1051是“未知表”的MySQL错误代码时，这才是显而易见的：</p><pre data-lang="sql" class="programlisting">DECLARE CONTINUE HANDLER FOR 1051
  BEGIN
    -- body of handler
  END;
</pre><p>
                By declaring a name for the condition, the purpose of the
                handler is more readily seen:
            </p><p style="color:blue;">通过声明条件的名称，更容易看出处理程序的用途：</p><pre data-lang="sql" class="programlisting">DECLARE no_such_table CONDITION FOR 1051;
DECLARE CONTINUE HANDLER FOR no_such_table
  BEGIN
    -- body of handler
  END;
</pre><p>
                Here is a named condition for the same condition, but based on
                the corresponding SQLSTATE value rather than the MySQL error
                code:
            </p><p style="color:blue;">下面是同一条件的命名条件，但基于相应的sqlstate值而不是mysql错误代码：</p><pre data-lang="sql" class="programlisting">DECLARE no_such_table CONDITION FOR SQLSTATE '42S02';
DECLARE CONTINUE HANDLER FOR no_such_table
  BEGIN
    -- body of handler
  END;
</pre>
            </div>
            <div class="section">
                <div class="titlepage">
                    <div>
                        <div>
                            <h4 class="title"><a name="declare-handler"></a>13.6.7.2&nbsp;DECLARE ... HANDLER Syntax</h4>

                        </div>

                    </div>

                </div>
                <a class="indexterm" name="idm140286831140112"></a><pre data-lang="sql" class="programlisting">DECLARE <em class="replaceable"><code>handler_action</code></em> HANDLER
    FOR <em class="replaceable"><code>condition_value</code></em> [, <em class="replaceable"><code>condition_value</code></em>] ...
    <em class="replaceable"><code>statement</code></em>

<em class="replaceable"><code>handler_action</code></em>: {
    CONTINUE
  | EXIT
  | UNDO
}

<em class="replaceable"><code>condition_value</code></em>: {
    <em class="replaceable"><code>mysql_error_code</code></em>
  | SQLSTATE [VALUE] <em class="replaceable"><code>sqlstate_value</code></em>
  | <em class="replaceable"><code>condition_name</code></em>
  | SQLWARNING
  | NOT FOUND
  | SQLEXCEPTION
}
</pre><p>
                The <a class="link" href="sql-syntax.html#declare-handler" title="13.6.7.2&nbsp;DECLARE ... HANDLER Syntax"><code class="literal">DECLARE ...
                HANDLER</code></a> statement specifies a handler that deals with
                one or more conditions. If one of these conditions occurs, the
                specified <em class="replaceable"><code>statement</code></em> executes.
                <em class="replaceable"><code>statement</code></em> can be a simple statement
                such as <code class="literal">SET <em class="replaceable"><code>var_name</code></em> =
                <em class="replaceable"><code>value</code></em></code>, or a compound
                statement written using <code class="literal">BEGIN</code> and
                <code class="literal">END</code> (see <a class="xref" href="sql-syntax.html#begin-end" title="13.6.1&nbsp;BEGIN ... END Compound-Statement Syntax">Section&nbsp;13.6.1, “BEGIN ... END Compound-Statement Syntax”</a>).
            </p><p style="color:blue;">声明…handler语句指定处理一个或多个条件的处理程序。如果出现这些条件之一，则执行指定的语句。语句可以是一个简单的语句，如set var_name=value，也可以是一个使用begin和end编写的复合语句（参见第13.6.1节“begin…”）。结束复合语句语法”）。</p><p>
                Handler declarations must appear after variable or condition
                declarations.
            </p><p style="color:blue;">处理程序声明必须出现在变量或条件声明之后。</p><p>
                The <em class="replaceable"><code>handler_action</code></em> value indicates
                what action the handler takes after execution of the handler
                statement:
            </p><p style="color:blue;">handler_action值指示处理程序在执行handler语句后执行的操作：</p>
                <div class="itemizedlist">
                    <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                        <code class="literal">CONTINUE</code>: Execution of the current
                        program continues.
                    </p><p style="color:blue;">继续：继续执行当前程序。</p></li><li class="listitem"><p>
                        <code class="literal">EXIT</code>: Execution terminates for the
                        <a class="link" href="sql-syntax.html#begin-end" title="13.6.1&nbsp;BEGIN ... END Compound-Statement Syntax"><code class="literal">BEGIN ...
                            END</code></a> compound statement in which the handler is
                        declared. This is true even if the condition occurs in an
                        inner block.
                    </p><p style="color:blue;">退出：开始时执行终止…声明处理程序的结束复合语句。即使条件发生在内部块中，也是如此。</p></li><li class="listitem"><p>
                        <code class="literal">UNDO</code>: Not supported.
                    </p><p style="color:blue;">撤消：不支持。</p></li></ul>
                </div>
                <p>
                    The <em class="replaceable"><code>condition_value</code></em> for
                    <a class="link" href="sql-syntax.html#declare-handler" title="13.6.7.2&nbsp;DECLARE ... HANDLER Syntax"><code class="literal">DECLARE ...
                        HANDLER</code></a> indicates the specific condition or class of
                    conditions that activates the handler. It can take the following
                    forms:
                </p><p style="color:blue;">声明的条件值…处理程序指示激活处理程序的特定条件或条件类。它可以采取以下形式：</p>
                <div class="itemizedlist">
                    <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                        <em class="replaceable"><code>mysql_error_code</code></em>: An integer
                        literal indicating a MySQL error code, such as 1051 to
                        specify <span class="quote">“<span class="quote">unknown table</span>”</span>:
                    </p><p style="color:blue;">mysql_error_code：表示mysql错误代码的整数文本，如1051指定“未知表”：</p><pre data-lang="sql" class="programlisting">DECLARE CONTINUE HANDLER FOR 1051
  BEGIN
    -- body of handler
  END;
</pre><p>
                        Do not use MySQL error code 0 because that indicates success
                        rather than an error condition. For a list of MySQL error
                        codes, see <a class="xref" href="error-handling.html#server-error-reference" title="B.3.1&nbsp;Server Error Message Reference">Section&nbsp;B.3.1, “Server Error Message Reference”</a>.
                    </p><p style="color:blue;">不要使用mysql错误代码0，因为这表示成功，而不是错误条件。有关MySQL错误代码的列表，请参阅B.3.1节“服务器错误消息参考”。</p></li><li class="listitem"><p>
                        SQLSTATE [VALUE] <em class="replaceable"><code>sqlstate_value</code></em>:
                        A 5-character string literal indicating an SQLSTATE value,
                        such as <code class="literal">'42S01'</code> to specify <span class="quote">“<span class="quote">unknown
            table</span>”</span>:
                    </p><p style="color:blue;">sqlstate[value]sqlstate_value：表示sqlstate值的5个字符的字符串文字，例如'42s01'以指定“未知表”：</p><pre data-lang="sql" class="programlisting">DECLARE CONTINUE HANDLER FOR SQLSTATE '42S02'
  BEGIN
    -- body of handler
  END;
</pre><p>
                        Do not use SQLSTATE values that begin with
                        <code class="literal">'00'</code> because those indicate success
                        rather than an error condition. For a list of SQLSTATE
                        values, see <a class="xref" href="error-handling.html#server-error-reference" title="B.3.1&nbsp;Server Error Message Reference">Section&nbsp;B.3.1, “Server Error Message Reference”</a>.
                    </p><p style="color:blue;">不要使用以“00”开头的sqlstate值，因为这些值表示成功，而不是错误条件。有关sqlstate值的列表，请参阅B.3.1节“服务器错误消息参考”。</p></li><li class="listitem"><p>
                        <em class="replaceable"><code>condition_name</code></em>: A condition name
                        previously specified with
                        <a class="link" href="sql-syntax.html#declare-condition" title="13.6.7.1&nbsp;DECLARE ... CONDITION Syntax"><code class="literal">DECLARE
                            ... CONDITION</code></a>. A condition name can be associated
                        with a MySQL error code or SQLSTATE value. See
                        <a class="xref" href="sql-syntax.html#declare-condition" title="13.6.7.1&nbsp;DECLARE ... CONDITION Syntax">Section&nbsp;13.6.7.1, “DECLARE ... CONDITION Syntax”</a>.
                    </p><p style="color:blue;">条件名称：以前用declare指定的条件名称…条件。条件名称可以与mysql错误代码或sqlstate值关联。见第13.6.7.1节，“声明……条件语法”。</p></li><li class="listitem"><p>
                        <code class="literal">SQLWARNING</code>: Shorthand for the class of
                        SQLSTATE values that begin with <code class="literal">'01'</code>.
                    </p><p style="color:blue;">sqlwarning：以“01”开头的sqlstate值类的简写。</p><pre data-lang="sql" class="programlisting">DECLARE CONTINUE HANDLER FOR SQLWARNING
  BEGIN
    -- body of handler
  END;
</pre></li><li class="listitem"><p>
                        <code class="literal">NOT FOUND</code>: Shorthand for the class of
                        SQLSTATE values that begin with <code class="literal">'02'</code>.
                        This is relevant within the context of cursors and is used
                        to control what happens when a cursor reaches the end of a
                        data set. If no more rows are available, a No Data condition
                        occurs with SQLSTATE value <code class="literal">'02000'</code>. To
                        detect this condition, you can set up a handler for it or
                        for a <code class="literal">NOT FOUND</code> condition.
                    </p><p style="color:blue;">找不到：以“02”开头的sqlstate值类的简写。这与游标上下文相关，用于控制游标到达数据集末尾时发生的情况。如果没有更多的行可用，则会出现sqlstate值为“02000”的“无数据”条件。要检测此条件，可以为其或未找到的条件设置处理程序。</p><pre data-lang="sql" class="programlisting">DECLARE CONTINUE HANDLER FOR NOT FOUND
  BEGIN
    -- body of handler
  END;
</pre><p>
                        For another example, see <a class="xref" href="sql-syntax.html#cursors" title="13.6.6&nbsp;Cursors">Section&nbsp;13.6.6, “Cursors”</a>. The
                        <code class="literal">NOT FOUND</code> condition also occurs for
                        <code class="literal">SELECT ... INTO
                            <em class="replaceable"><code>var_list</code></em></code> statements
                        that retrieve no rows.
                    </p><p style="color:blue;">另一个例子见第13.6.6节“光标”。对于select，也会出现not found条件…进入不检索行的var_list语句。</p></li><li class="listitem"><p>
                        <code class="literal">SQLEXCEPTION</code>: Shorthand for the class of
                        SQLSTATE values that do not begin with
                        <code class="literal">'00'</code>, <code class="literal">'01'</code>, or
                        <code class="literal">'02'</code>.
                    </p><p style="color:blue;">SqlException：不以“00”、“01”或“02”开头的SqlState值类的简写。</p><pre data-lang="sql" class="programlisting">DECLARE CONTINUE HANDLER FOR SQLEXCEPTION
  BEGIN
    -- body of handler
  END;
</pre></li></ul>
                </div>
                <p>
                    For information about how the server chooses handlers when a
                    condition occurs, see <a class="xref" href="sql-syntax.html#handler-scope" title="13.6.7.6&nbsp;Scope Rules for Handlers">Section&nbsp;13.6.7.6, “Scope Rules for Handlers”</a>.
                </p><p style="color:blue;">有关发生条件时服务器如何选择处理程序的信息，请参阅第13.6.7.6节“处理程序的作用域规则”。</p><p>
                If a condition occurs for which no handler has been declared,
                the action taken depends on the condition class:
            </p><p style="color:blue;">如果发生未声明处理程序的条件，则采取的操作取决于条件类：</p>
                <div class="itemizedlist">
                    <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                        For <code class="literal">SQLEXCEPTION</code> conditions, the stored
                        program terminates at the statement that raised the
                        condition, as if there were an <code class="literal">EXIT</code>
                        handler. If the program was called by another stored
                        program, the calling program handles the condition using the
                        handler selection rules applied to its own handlers.
                    </p><p style="color:blue;">对于SqlException条件，存储程序在引发该条件的语句处终止，就像存在一个退出处理程序一样。如果程序被另一个存储程序调用，则调用程序使用应用于其自身处理程序的处理程序选择规则来处理条件。</p></li><li class="listitem"><p>
                        For <code class="literal">SQLWARNING</code> conditions, the program
                        continues executing, as if there were a
                        <code class="literal">CONTINUE</code> handler.
                    </p><p style="color:blue;">对于sqlwarning条件，程序继续执行，就像有一个continue处理程序一样。</p></li><li class="listitem"><p>
                        For <code class="literal">NOT FOUND</code> conditions, if the
                        condition was raised normally, the action is
                        <code class="literal">CONTINUE</code>. If it was raised by
                        <a class="link" href="sql-syntax.html#signal" title="13.6.7.5&nbsp;SIGNAL Syntax"><code class="literal">SIGNAL</code></a> or
                        <a class="link" href="sql-syntax.html#resignal" title="13.6.7.4&nbsp;RESIGNAL Syntax"><code class="literal">RESIGNAL</code></a>, the action is
                        <code class="literal">EXIT</code>.
                    </p><p style="color:blue;">对于未找到的条件，如果条件正常引发，则操作将继续。如果它是由信号或resignal引起的，则操作是exit。</p></li></ul>
                </div>
                <p>
                    The following example uses a handler for <code class="literal">SQLSTATE
                    '23000'</code>, which occurs for a duplicate-key error:
                </p><p style="color:blue;">以下示例使用sqlstate“23000”的处理程序，该处理程序发生重复密钥错误：</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>CREATE TABLE test.t (s1 INT, PRIMARY KEY (s1));</code></strong>
Query OK, 0 rows affected (0.00 sec)

mysql&gt; <strong class="userinput"><code>delimiter //</code></strong>

mysql&gt; <strong class="userinput"><code>CREATE PROCEDURE handlerdemo ()</code></strong>
       <strong class="userinput"><code>BEGIN</code></strong>
         <strong class="userinput"><code>DECLARE CONTINUE HANDLER FOR SQLSTATE '23000' SET @x2 = 1;</code></strong>
         <strong class="userinput"><code>SET @x = 1;</code></strong>
         <strong class="userinput"><code>INSERT INTO test.t VALUES (1);</code></strong>
         <strong class="userinput"><code>SET @x = 2;</code></strong>
         <strong class="userinput"><code>INSERT INTO test.t VALUES (1);</code></strong>
         <strong class="userinput"><code>SET @x = 3;</code></strong>
       <strong class="userinput"><code>END;</code></strong>
       <strong class="userinput"><code>//</code></strong>
Query OK, 0 rows affected (0.00 sec)

mysql&gt; <strong class="userinput"><code>CALL handlerdemo()//</code></strong>
Query OK, 0 rows affected (0.00 sec)

mysql&gt; <strong class="userinput"><code>SELECT @x//</code></strong>
    +------+
    | @x   |
    +------+
    | 3    |
    +------+
    1 row in set (0.00 sec)
</pre><p>
                Notice that <code class="literal">@x</code> is <code class="literal">3</code> after
                the procedure executes, which shows that execution continued to
                the end of the procedure after the error occurred. If the
                <a class="link" href="sql-syntax.html#declare-handler" title="13.6.7.2&nbsp;DECLARE ... HANDLER Syntax"><code class="literal">DECLARE ...
                    HANDLER</code></a> statement had not been present, MySQL would
                have taken the default action (<code class="literal">EXIT</code>) after
                the second <a class="link" href="sql-syntax.html#insert" title="13.2.5&nbsp;INSERT Syntax"><code class="literal">INSERT</code></a> failed due to
                the <code class="literal">PRIMARY KEY</code> constraint, and
                <code class="literal">SELECT @x</code> would have returned
                <code class="literal">2</code>.
            </p><p style="color:blue;">注意@x在过程执行之后是3，这表明在错误发生之后，执行一直持续到过程的末尾。如果申报…handler语句不存在，mysql将在第二次插入由于主键约束而失败后执行默认操作（exit），select@x将返回2。</p><p>
                To ignore a condition, declare a <code class="literal">CONTINUE</code>
                handler for it and associate it with an empty block. For
                example:
            </p><p style="color:blue;">若要忽略条件，请为其声明一个继续处理程序，并将其与空块关联。例如：</p><pre data-lang="sql" class="programlisting">DECLARE CONTINUE HANDLER FOR SQLWARNING BEGIN END;
</pre><p>
                The scope of a block label does not include the code for
                handlers declared within the block. Therefore, the statement
                associated with a handler cannot use
                <a class="link" href="sql-syntax.html#iterate" title="13.6.5.3&nbsp;ITERATE Syntax"><code class="literal">ITERATE</code></a> or
                <a class="link" href="sql-syntax.html#leave" title="13.6.5.4&nbsp;LEAVE Syntax"><code class="literal">LEAVE</code></a> to refer to labels for
                blocks that enclose the handler declaration. Consider the
                following example, where the
                <a class="link" href="sql-syntax.html#repeat" title="13.6.5.6&nbsp;REPEAT Syntax"><code class="literal">REPEAT</code></a> block has a label of
                <code class="literal">retry</code>:
            </p><p style="color:blue;">块标签的作用域不包括块内声明的处理程序的代码。因此，与处理程序关联的语句不能使用iterate或leave来引用包含处理程序声明的块的标签。请考虑以下示例，其中repeat块具有retry标签：</p><pre data-lang="sql" class="programlisting">CREATE PROCEDURE p ()
BEGIN
  DECLARE i INT DEFAULT 3;
  retry:
    REPEAT
      BEGIN
        DECLARE CONTINUE HANDLER FOR SQLWARNING
          BEGIN
            ITERATE retry;    # illegal
          END;
        IF i &lt; 0 THEN
          LEAVE retry;        # legal
        END IF;
        SET i = i - 1;
      END;
    UNTIL FALSE END REPEAT;
END;
</pre><p>
                The <code class="literal">retry</code> label is in scope for the
                <a class="link" href="sql-syntax.html#if" title="13.6.5.2&nbsp;IF Syntax"><code class="literal">IF</code></a> statement within the block. It
                is not in scope for the <code class="literal">CONTINUE</code> handler, so
                the reference there is invalid and results in an error:
            </p><p style="color:blue;">重试标签在块内if语句的作用域中。它不在continue处理程序的作用域中，因此那里的引用无效并导致错误：</p><pre data-lang="none" class="programlisting">ERROR 1308 (42000): LEAVE with no matching label: retry
</pre><p>
                To avoid references to outer labels in handlers, use one of
                these strategies:
            </p><p style="color:blue;">要避免在处理程序中引用外部标签，请使用以下策略之一：</p>
                <div class="itemizedlist">
                    <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                        To leave the block, use an <code class="literal">EXIT</code> handler.
                        If no block cleanup is required, the
                        <a class="link" href="sql-syntax.html#begin-end" title="13.6.1&nbsp;BEGIN ... END Compound-Statement Syntax"><code class="literal">BEGIN ...
                            END</code></a> handler body can be empty:
                    </p><p style="color:blue;">要离开块，请使用退出处理程序。如果不需要块清理，则开始…结束处理程序正文可以为空：</p><pre data-lang="sql" class="programlisting">DECLARE EXIT HANDLER FOR SQLWARNING BEGIN END;
</pre><p>
                        Otherwise, put the cleanup statements in the handler body:
                    </p><p style="color:blue;">否则，请将清除语句放入处理程序体中：</p><pre data-lang="sql" class="programlisting">DECLARE EXIT HANDLER FOR SQLWARNING
  BEGIN
    <em class="replaceable"><code>block cleanup statements</code></em>
  END;
</pre></li><li class="listitem"><p>
                        To continue execution, set a status variable in a
                        <code class="literal">CONTINUE</code> handler that can be checked in
                        the enclosing block to determine whether the handler was
                        invoked. The following example uses the variable
                        <code class="literal">done</code> for this purpose:
                    </p><p style="color:blue;">若要继续执行，请在可在封闭块中检查的继续处理程序中设置状态变量，以确定是否调用了该处理程序。以下示例使用为此目的而完成的变量：</p><pre data-lang="sql" class="programlisting">CREATE PROCEDURE p ()
BEGIN
  DECLARE i INT DEFAULT 3;
  DECLARE done INT DEFAULT FALSE;
  retry:
    REPEAT
      BEGIN
        DECLARE CONTINUE HANDLER FOR SQLWARNING
          BEGIN
            SET done = TRUE;
          END;
        IF done OR i &lt; 0 THEN
          LEAVE retry;
        END IF;
        SET i = i - 1;
      END;
    UNTIL FALSE END REPEAT;
END;
</pre></li></ul>
                </div>

            </div>
            <div class="section">
                <div class="titlepage">
                    <div>
                        <div>
                            <h4 class="title"><a name="get-diagnostics"></a>13.6.7.3&nbsp;GET DIAGNOSTICS Syntax</h4>

                        </div>

                    </div>

                </div>
                <a class="indexterm" name="idm140286831027744"></a><pre data-lang="sql" class="programlisting">GET [CURRENT | STACKED] DIAGNOSTICS
{
    <em class="replaceable"><code>statement_information_item</code></em>
    [, <em class="replaceable"><code>statement_information_item</code></em>] ...
  | CONDITION <em class="replaceable"><code>condition_number</code></em>
    <em class="replaceable"><code>condition_information_item</code></em>
    [, <em class="replaceable"><code>condition_information_item</code></em>] ...
}

<em class="replaceable"><code>statement_information_item</code></em>:
    <em class="replaceable"><code>target</code></em> = <em class="replaceable"><code>statement_information_item_name</code></em>

<em class="replaceable"><code>condition_information_item</code></em>:
    <em class="replaceable"><code>target</code></em> = <em class="replaceable"><code>condition_information_item_name</code></em>

<em class="replaceable"><code>statement_information_item_name</code></em>:
    NUMBER
  | ROW_COUNT

<em class="replaceable"><code>condition_information_item_name</code></em>: {
    CLASS_ORIGIN
  | SUBCLASS_ORIGIN
  | RETURNED_SQLSTATE
  | MESSAGE_TEXT
  | MYSQL_ERRNO
  | CONSTRAINT_CATALOG
  | CONSTRAINT_SCHEMA
  | CONSTRAINT_NAME
  | CATALOG_NAME
  | SCHEMA_NAME
  | TABLE_NAME
  | COLUMN_NAME
  | CURSOR_NAME
}

<em class="replaceable"><code>condition_number</code></em>, <em class="replaceable"><code>target</code></em>:
    (see following discussion)
</pre><p>
                SQL statements produce diagnostic information that populates the
                diagnostics area. The <a class="link" href="sql-syntax.html#get-diagnostics" title="13.6.7.3&nbsp;GET DIAGNOSTICS Syntax"><code class="literal">GET
                DIAGNOSTICS</code></a> statement enables applications to inspect
                this information. (You can also use <a class="link" href="sql-syntax.html#show-warnings" title="13.7.5.40&nbsp;SHOW WARNINGS Syntax"><code class="literal">SHOW
                WARNINGS</code></a> or <a class="link" href="sql-syntax.html#show-errors" title="13.7.5.17&nbsp;SHOW ERRORS Syntax"><code class="literal">SHOW ERRORS</code></a>
                to see conditions or errors.)
            </p><p style="color:blue;">SQL语句生成填充诊断区域的诊断信息。get diagnostics语句使应用程序能够检查此信息。（也可以使用“显示警告”或“显示错误”来查看条件或错误。）</p><p>
                No special privileges are required to execute
                <a class="link" href="sql-syntax.html#get-diagnostics" title="13.6.7.3&nbsp;GET DIAGNOSTICS Syntax"><code class="literal">GET DIAGNOSTICS</code></a>.
            </p><p style="color:blue;">执行get diagnostics不需要特殊权限。</p><p>
                The keyword <code class="literal">CURRENT</code> means to retrieve
                information from the current diagnostics area. The keyword
                <code class="literal">STACKED</code> means to retrieve information from
                the second diagnostics area, which is available only if the
                current context is a condition handler. If neither keyword is
                given, the default is to use the current diagnostics area.
            </p><p style="color:blue;">关键字current意味着从当前诊断区域检索信息。关键字stacked意味着从第二个诊断区域检索信息，该区域仅在当前上下文是条件处理程序时可用。如果两个关键字都没有给定，则默认使用当前诊断区域。</p><p>
                The <a class="link" href="sql-syntax.html#get-diagnostics" title="13.6.7.3&nbsp;GET DIAGNOSTICS Syntax"><code class="literal">GET DIAGNOSTICS</code></a> statement is
                typically used in a handler within a stored program. It is a
                MySQL extension that
                <a class="link" href="sql-syntax.html#get-diagnostics" title="13.6.7.3&nbsp;GET DIAGNOSTICS Syntax"><code class="literal">GET [CURRENT]
                    DIAGNOSTICS</code></a> is permitted outside handler context to
                check the execution of any SQL statement. For example, if you
                invoke the <a class="link" href="programs.html#mysql" title="4.5.1&nbsp;mysql — The MySQL Command-Line Client"><span class="command"><strong>mysql</strong></span></a> client program, you can
                enter these statements at the prompt:
            </p><p style="color:blue;">get diagnostics语句通常用于存储程序中的处理程序中。它是一个mysql扩展，允许在处理程序上下文外部获取[current]诊断来检查任何sql语句的执行。例如，如果调用mysql客户端程序，可以在提示下输入以下语句：</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>DROP TABLE test.no_such_table;</code></strong>
ERROR 1051 (42S02): Unknown table 'test.no_such_table'
mysql&gt; <strong class="userinput"><code>GET DIAGNOSTICS CONDITION 1</code></strong>
         <strong class="userinput"><code>@p1 = RETURNED_SQLSTATE, @p2 = MESSAGE_TEXT;</code></strong>
mysql&gt; <strong class="userinput"><code>SELECT @p1, @p2;</code></strong>
+-------+------------------------------------+
| @p1   | @p2                                |
+-------+------------------------------------+
| 42S02 | Unknown table 'test.no_such_table' |
+-------+------------------------------------+
</pre><p>
                This extension applies only to the current diagnostics area. It
                does not apply to the second diagnostics area because
                <code class="literal">GET STACKED DIAGNOSTICS</code> is permitted only if
                the current context is a condition handler. If that is not the
                case, a <code class="literal">GET STACKED DIAGNOSTICS when handler not
                active</code> error occurs.
            </p><p style="color:blue;">此扩展仅适用于当前诊断区域。它不适用于第二个诊断区域，因为仅当当前上下文是条件处理程序时才允许使用“获取堆栈诊断”。如果不是这样，则会发生“处理程序未激活时获取堆栈诊断”错误。</p><p>
                For a description of the diagnostics area, see
                <a class="xref" href="sql-syntax.html#diagnostics-area" title="13.6.7.7&nbsp;The MySQL Diagnostics Area">Section&nbsp;13.6.7.7, “The MySQL Diagnostics Area”</a>. Briefly, it contains two
                kinds of information:
            </p><p style="color:blue;">有关诊断区域的说明，请参阅第13.6.7.7节“MySQL诊断区域”。简而言之，它包含两种信息：</p>
                <div class="itemizedlist">
                    <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                        Statement information, such as the number of conditions that
                        occurred or the affected-rows count.
                    </p><p style="color:blue;">语句信息，例如发生的条件数或受影响的行数。</p></li><li class="listitem"><p>
                        Condition information, such as the error code and message.
                        If a statement raises multiple conditions, this part of the
                        diagnostics area has a condition area for each one. If a
                        statement raises no conditions, this part of the diagnostics
                        area is empty.
                    </p><p style="color:blue;">条件信息，如错误代码和消息。如果一个语句引发多个条件，则诊断区域的这一部分对每个条件都有一个条件区域。如果语句不引发任何条件，则诊断区域的此部分为空。</p></li></ul>
                </div>
                <p>
                    For a statement that produces three conditions, the diagnostics
                    area contains statement and condition information like this:
                </p><p style="color:blue;">对于生成三个条件的语句，诊断区域包含如下语句和条件信息：</p><pre data-lang="none" class="programlisting">Statement information:
  row count
  ... other statement information items ...
Condition area list:
  Condition area 1:
    error code for condition 1
    error message for condition 1
    ... other condition information items ...
  Condition area 2:
    error code for condition 2:
    error message for condition 2
    ... other condition information items ...
  Condition area 3:
    error code for condition 3
    error message for condition 3
    ... other condition information items ...
</pre><p>
                <a class="link" href="sql-syntax.html#get-diagnostics" title="13.6.7.3&nbsp;GET DIAGNOSTICS Syntax"><code class="literal">GET DIAGNOSTICS</code></a> can obtain either
                statement or condition information, but not both in the same
                statement:
            </p><p style="color:blue;">get diagnostics可以获取语句或条件信息，但不能在同一语句中同时获取这两者：</p>
                <div class="itemizedlist">
                    <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                        To obtain statement information, retrieve the desired
                        statement items into target variables. This instance of
                        <a class="link" href="sql-syntax.html#get-diagnostics" title="13.6.7.3&nbsp;GET DIAGNOSTICS Syntax"><code class="literal">GET DIAGNOSTICS</code></a> assigns the
                        number of available conditions and the rows-affected count
                        to the user variables <code class="literal">@p1</code> and
                        <code class="literal">@p2</code>:
                    </p><p style="color:blue;">要获取语句信息，请将所需的语句项检索到目标变量中。这个get diagnostics实例将可用条件的数量和受影响的行数分配给用户变量@p1和@p2：</p><pre data-lang="sql" class="programlisting">GET DIAGNOSTICS @p1 = NUMBER, @p2 = ROW_COUNT;
</pre></li><li class="listitem"><p>
                        To obtain condition information, specify the condition
                        number and retrieve the desired condition items into target
                        variables. This instance of <a class="link" href="sql-syntax.html#get-diagnostics" title="13.6.7.3&nbsp;GET DIAGNOSTICS Syntax"><code class="literal">GET
                        DIAGNOSTICS</code></a> assigns the SQLSTATE value and error
                        message to the user variables <code class="literal">@p3</code> and
                        <code class="literal">@p4</code>:
                    </p><p style="color:blue;">要获取条件信息，请指定条件编号并将所需条件项检索到目标变量中。这个get diagnostics实例将sqlstate值和错误消息分配给用户变量@p3和@p4：</p><pre data-lang="sql" class="programlisting">GET DIAGNOSTICS CONDITION 1
  @p3 = RETURNED_SQLSTATE, @p4 = MESSAGE_TEXT;
</pre></li></ul>
                </div>
                <p>
                    The retrieval list specifies one or more
                    <code class="literal"><em class="replaceable"><code>target</code></em> =
                        <em class="replaceable"><code>item_name</code></em></code> assignments,
                    separated by commas. Each assignment names a target variable and
                    either a
                    <em class="replaceable"><code>statement_information_item_name</code></em> or
                    <em class="replaceable"><code>condition_information_item_name</code></em>
                    designator, depending on whether the statement retrieves
                    statement or condition information.
                </p><p style="color:blue;">检索列表指定一个或多个target=item_名称分配，用逗号分隔。每个赋值指定一个目标变量和一个statement_information_item_name或condition_information_item_name指示符，具体取决于语句是检索语句还是条件信息。</p><p>
                Valid <em class="replaceable"><code>target</code></em> designators for storing
                item information can be stored procedure or function parameters,
                stored program local variables declared with
                <a class="link" href="sql-syntax.html#declare" title="13.6.3&nbsp;DECLARE Syntax"><code class="literal">DECLARE</code></a>, or user-defined
                variables.
            </p><p style="color:blue;">用于存储项信息的有效目标指示符可以是存储过程或函数参数、用declare声明的存储程序局部变量或用户定义的变量。</p><p>
                Valid <em class="replaceable"><code>condition_number</code></em> designators
                can be stored procedure or function parameters, stored program
                local variables declared with
                <a class="link" href="sql-syntax.html#declare" title="13.6.3&nbsp;DECLARE Syntax"><code class="literal">DECLARE</code></a>, user-defined variables,
                system variables, or literals. A character literal may include a
                <em class="replaceable"><code>_charset</code></em> introducer. A warning occurs
                if the condition number is not in the range from 1 to the number
                of condition areas that have information. In this case, the
                warning is added to the diagnostics area without clearing it.
            </p><p style="color:blue;">有效的条件号指示符可以是存储过程或函数参数、用declare声明的存储程序局部变量、用户定义的变量、系统变量或文本。字符文字可以包括字符集介绍人。如果条件编号不在1到包含信息的条件区域数的范围内，则会出现警告。在这种情况下，警告将添加到诊断区域而不清除它。</p><p>
                When a condition occurs, MySQL does not populate all condition
                items recognized by <a class="link" href="sql-syntax.html#get-diagnostics" title="13.6.7.3&nbsp;GET DIAGNOSTICS Syntax"><code class="literal">GET
                DIAGNOSTICS</code></a>. For example:
            </p><p style="color:blue;">当条件发生时，mysql不会填充get diagnostics识别的所有条件项。例如：</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>GET DIAGNOSTICS CONDITION 1</code></strong>
         <strong class="userinput"><code>@p5 = SCHEMA_NAME, @p6 = TABLE_NAME;</code></strong>
mysql&gt; <strong class="userinput"><code>SELECT @p5, @p6;</code></strong>
+------+------+
| @p5  | @p6  |
+------+------+
|      |      |
+------+------+
</pre><p>
                In standard SQL, if there are multiple conditions, the first
                condition relates to the <code class="literal">SQLSTATE</code> value
                returned for the previous SQL statement. In MySQL, this is not
                guaranteed. To get the main error, you cannot do this:
            </p><p style="color:blue;">在标准sql中，如果有多个条件，则第一个条件与前一个sql语句返回的sqlstate值相关。在mysql中，这是不能保证的。要获取主错误，您不能执行以下操作：</p><pre data-lang="sql" class="programlisting">GET DIAGNOSTICS CONDITION 1 @errno = MYSQL_ERRNO;
</pre><p>
                Instead, retrieve the condition count first, then use it to
                specify which condition number to inspect:
            </p><p style="color:blue;">相反，首先检索条件计数，然后使用它指定要检查的条件编号：</p><pre data-lang="sql" class="programlisting">GET DIAGNOSTICS @cno = NUMBER;
GET DIAGNOSTICS CONDITION @cno @errno = MYSQL_ERRNO;
</pre><p>
                For information about permissible statement and condition
                information items, and which ones are populated when a condition
                occurs, see
                <a class="xref" href="sql-syntax.html#diagnostics-area-information-items" title="Diagnostics Area Information Items">Diagnostics Area Information Items</a>.
            </p><p style="color:blue;">有关允许的语句和条件信息项以及发生条件时填充哪些语句和条件信息项的信息，请参阅诊断区域信息项。</p><p>
                Here is an example that uses <a class="link" href="sql-syntax.html#get-diagnostics" title="13.6.7.3&nbsp;GET DIAGNOSTICS Syntax"><code class="literal">GET
                DIAGNOSTICS</code></a> and an exception handler in stored
                procedure context to assess the outcome of an insert operation.
                If the insert was successful, the procedure uses
                <a class="link" href="sql-syntax.html#get-diagnostics" title="13.6.7.3&nbsp;GET DIAGNOSTICS Syntax"><code class="literal">GET DIAGNOSTICS</code></a> to get the
                rows-affected count. This shows that you can use
                <a class="link" href="sql-syntax.html#get-diagnostics" title="13.6.7.3&nbsp;GET DIAGNOSTICS Syntax"><code class="literal">GET DIAGNOSTICS</code></a> multiple times to
                retrieve information about a statement as long as the current
                diagnostics area has not been cleared.
            </p><p style="color:blue;">下面是一个示例，它使用get diagnostics和存储过程上下文中的异常处理程序来评估插入操作的结果。如果插入成功，则过程使用get diagnostics获取受影响的行数。这表明，只要当前诊断区域尚未清除，就可以多次使用get diagnostics来检索有关语句的信息。</p><pre data-lang="sql" class="programlisting">CREATE PROCEDURE do_insert(value INT)
BEGIN
  -- Declare variables to hold diagnostics area information
  DECLARE code CHAR(5) DEFAULT '00000';
  DECLARE msg TEXT;
  DECLARE rows INT;
  DECLARE result TEXT;
  -- Declare exception handler for failed insert
  DECLARE CONTINUE HANDLER FOR SQLEXCEPTION
    BEGIN
      GET DIAGNOSTICS CONDITION 1
        code = RETURNED_SQLSTATE, msg = MESSAGE_TEXT;
    END;

  -- Perform the insert
  INSERT INTO t1 (int_col) VALUES(value);
  -- Check whether the insert was successful
  IF code = '00000' THEN
    GET DIAGNOSTICS rows = ROW_COUNT;
    SET result = CONCAT('insert succeeded, row count = ',rows);
  ELSE
    SET result = CONCAT('insert failed, error = ',code,', message = ',msg);
  END IF;
  -- Say what happened
  SELECT result;
END;
</pre><p>
                Suppose that <code class="literal">t1.int_col</code> is an integer column
                that is declared as <code class="literal">NOT NULL</code>. The procedure
                produces these results when invoked to insert
                non-<code class="literal">NULL</code> and <code class="literal">NULL</code> values,
                respectively:
            </p><p style="color:blue;">假设t1.int_col是一个声明为非空的整数列。调用该过程以分别插入非空值和空值时，将生成以下结果：</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>CALL do_insert(1);</code></strong>
+---------------------------------+
| result                          |
+---------------------------------+
| insert succeeded, row count = 1 |
+---------------------------------+

mysql&gt; <strong class="userinput"><code>CALL do_insert(NULL);</code></strong>
+-------------------------------------------------------------------------+
| result                                                                  |
+-------------------------------------------------------------------------+
| insert failed, error = 23000, message = Column 'int_col' cannot be null |
+-------------------------------------------------------------------------+
</pre><p>
                When a condition handler activates, a push to the diagnostics
                area stack occurs:
            </p><p style="color:blue;">当条件处理程序激活时，将向诊断区域堆栈推送：</p>
                <div class="itemizedlist">
                    <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                        The first (current) diagnostics area becomes the second
                        (stacked) diagnostics area and a new current diagnostics
                        area is created as a copy of it.
                    </p><p style="color:blue;">第一个（当前）诊断区域变为第二个（堆叠）诊断区域，并创建一个新的当前诊断区域作为其副本。</p></li><li class="listitem"><p>
                        <a class="link" href="sql-syntax.html#get-diagnostics" title="13.6.7.3&nbsp;GET DIAGNOSTICS Syntax"><code class="literal">GET
                            [CURRENT] DIAGNOSTICS</code></a> and
                        <a class="link" href="sql-syntax.html#get-diagnostics" title="13.6.7.3&nbsp;GET DIAGNOSTICS Syntax"><code class="literal">GET STACKED
                            DIAGNOSTICS</code></a> can be used within the handler to
                        access the contents of the current and stacked diagnostics
                        areas.
                    </p><p style="color:blue;">get[当前]诊断和get stacked diagnostics可在处理程序中用于访问当前和堆栈诊断区域的内容。</p></li><li class="listitem"><p>
                        Initially, both diagnostics areas return the same result, so
                        it is possible to get information from the current
                        diagnostics area about the condition that activated the
                        handler, <span class="emphasis"><em>as long as</em></span> you execute no
                        statements within the handler that change its current
                        diagnostics area.
                    </p><p style="color:blue;">最初，两个诊断区域返回相同的结果，因此只要在处理程序中不执行更改其当前诊断区域的语句，就可以从当前诊断区域获取有关激活处理程序的条件的信息。</p></li><li class="listitem"><p>
                        However, statements executing within the handler can modify
                        the current diagnostics area, clearing and setting its
                        contents according to the normal rules (see
                        <a class="xref" href="sql-syntax.html#diagnostics-area-populating" title="How the Diagnostics Area is Cleared and Populated">How the Diagnostics Area is Cleared and Populated</a>).
                    </p><p style="color:blue;">但是，在处理程序内执行的语句可以修改当前诊断区域，根据正常规则清除和设置其内容（请参阅如何清除和填充诊断区域）。</p><p>
                        A more reliable way to obtain information about the
                        handler-activating condition is to use the stacked
                        diagnostics area, which cannot be modified by statements
                        executing within the handler except
                        <a class="link" href="sql-syntax.html#resignal" title="13.6.7.4&nbsp;RESIGNAL Syntax"><code class="literal">RESIGNAL</code></a>. For information
                        about when the current diagnostics area is set and cleared,
                        see <a class="xref" href="sql-syntax.html#diagnostics-area" title="13.6.7.7&nbsp;The MySQL Diagnostics Area">Section&nbsp;13.6.7.7, “The MySQL Diagnostics Area”</a>.
                    </p><p style="color:blue;">获取有关处理程序激活条件的信息的更可靠的方法是使用堆栈诊断区域，除了resignal之外，在处理程序内执行的语句无法修改该区域。有关当前诊断区域的设置和清除时间的信息，请参阅第13.6.7.7节“MySQL诊断区域”。</p></li></ul>
                </div>
                <p>
                    The next example shows how <code class="literal">GET STACKED
                    DIAGNOSTICS</code> can be used within a handler to obtain
                    information about the handled exception, even after the current
                    diagnostics area has been modified by handler statements.
                </p><p style="color:blue;">下一个示例显示如何在处理程序中使用get stacked diagnostics来获取有关已处理异常的信息，即使在处理程序语句修改了当前诊断区域之后也是如此。</p><p>
                Within a stored procedure <code class="literal">p()</code>, we attempt to
                insert two values into a table that contains a <code class="literal">TEXT NOT
                NULL</code> column. The first value is a
                non-<code class="literal">NULL</code> string and the second is
                <code class="literal">NULL</code>. The column prohibits
                <code class="literal">NULL</code> values, so the first insert succeeds but
                the second causes an exception. The procedure includes an
                exception handler that maps attempts to insert
                <code class="literal">NULL</code> into inserts of the empty string:
            </p><p style="color:blue;">在存储过程p（）中，我们尝试将两个值插入到包含text not null列的表中。第一个值是非空字符串，第二个为空。列禁止空值，因此第一次插入成功，但第二次插入导致异常。该过程包括一个异常处理程序，该处理程序将尝试插入空字符串的空字符串映射为：</p><pre data-lang="sql" class="programlisting">DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (c1 TEXT NOT NULL);
DROP PROCEDURE IF EXISTS p;
delimiter //
CREATE PROCEDURE p ()
BEGIN
  -- Declare variables to hold diagnostics area information
  DECLARE errcount INT;
  DECLARE errno INT;
  DECLARE msg TEXT;
  DECLARE EXIT HANDLER FOR SQLEXCEPTION
  BEGIN
    -- Here the current DA is nonempty because no prior statements
    -- executing within the handler have cleared it
    GET CURRENT DIAGNOSTICS CONDITION 1
      errno = MYSQL_ERRNO, msg = MESSAGE_TEXT;
    SELECT 'current DA before mapped insert' AS op, errno, msg;
    GET STACKED DIAGNOSTICS CONDITION 1
      errno = MYSQL_ERRNO, msg = MESSAGE_TEXT;
    SELECT 'stacked DA before mapped insert' AS op, errno, msg;

    -- Map attempted NULL insert to empty string insert
    INSERT INTO t1 (c1) VALUES('');

    -- Here the current DA should be empty (if the INSERT succeeded),
    -- so check whether there are conditions before attempting to
    -- obtain condition information
    GET CURRENT DIAGNOSTICS errcount = NUMBER;
    IF errcount = 0
    THEN
      SELECT 'mapped insert succeeded, current DA is empty' AS op;
    ELSE
      GET CURRENT DIAGNOSTICS CONDITION 1
        errno = MYSQL_ERRNO, msg = MESSAGE_TEXT;
      SELECT 'current DA after mapped insert' AS op, errno, msg;
    END IF ;
    GET STACKED DIAGNOSTICS CONDITION 1
      errno = MYSQL_ERRNO, msg = MESSAGE_TEXT;
    SELECT 'stacked DA after mapped insert' AS op, errno, msg;
  END;
  INSERT INTO t1 (c1) VALUES('string 1');
  INSERT INTO t1 (c1) VALUES(NULL);
END;
//
delimiter ;
CALL p();
SELECT * FROM t1;
</pre><p>
                When the handler activates, a copy of the current diagnostics
                area is pushed to the diagnostics area stack. The handler first
                displays the contents of the current and stacked diagnostics
                areas, which are both the same initially:
            </p><p style="color:blue;">当处理程序激活时，当前诊断区域的副本被推送到诊断区域堆栈。处理程序首先显示当前诊断区域和堆叠诊断区域的内容，它们最初都相同：</p><pre data-lang="none" class="programlisting">+---------------------------------+-------+----------------------------+
| op                              | errno | msg                        |
+---------------------------------+-------+----------------------------+
| current DA before mapped insert |  1048 | Column 'c1' cannot be null |
+---------------------------------+-------+----------------------------+

+---------------------------------+-------+----------------------------+
| op                              | errno | msg                        |
+---------------------------------+-------+----------------------------+
| stacked DA before mapped insert |  1048 | Column 'c1' cannot be null |
+---------------------------------+-------+----------------------------+
</pre><p>
                Statements executing after the <a class="link" href="sql-syntax.html#get-diagnostics" title="13.6.7.3&nbsp;GET DIAGNOSTICS Syntax"><code class="literal">GET
                DIAGNOSTICS</code></a> statements may reset the current
                diagnostics area. statements may reset the current diagnostics
                area. For example, the handler maps the <code class="literal">NULL</code>
                insert to an empty-string insert and displays the result. The
                new insert succeeds and clears the current diagnostics area, but
                the stacked diagnostics area remains unchanged and still
                contains information about the condition that activated the
                handler:
            </p><p style="color:blue;">在get diagnostics语句之后执行的语句可能会重置当前诊断区域。语句可能会重置当前诊断区域。例如，处理程序将空插入映射到空字符串插入并显示结果。新插入成功并清除当前诊断区域，但堆叠的诊断区域保持不变，仍包含有关激活处理程序的条件的信息：</p><pre data-lang="none" class="programlisting">+----------------------------------------------+
| op                                           |
+----------------------------------------------+
| mapped insert succeeded, current DA is empty |
+----------------------------------------------+

+--------------------------------+-------+----------------------------+
| op                             | errno | msg                        |
+--------------------------------+-------+----------------------------+
| stacked DA after mapped insert |  1048 | Column 'c1' cannot be null |
+--------------------------------+-------+----------------------------+
</pre><p>
                When the condition handler ends, its current diagnostics area is
                popped from the stack and the stacked diagnostics area becomes
                the current diagnostics area in the stored procedure.
            </p><p style="color:blue;">当条件处理程序结束时，其当前诊断区域将从堆栈中弹出，并且堆栈诊断区域将成为存储过程中的当前诊断区域。</p><p>
                After the procedure returns, the table contains two rows. The
                empty row results from the attempt to insert
                <code class="literal">NULL</code> that was mapped to an empty-string
                insert:
            </p><p style="color:blue;">在过程返回后，表包含两行。尝试插入映射到空字符串插入的空行导致：</p><pre data-lang="none" class="programlisting">+----------+
| c1       |
+----------+
| string 1 |
|          |
+----------+
</pre><p>
                In the preceding example, the first two <a class="link" href="sql-syntax.html#get-diagnostics" title="13.6.7.3&nbsp;GET DIAGNOSTICS Syntax"><code class="literal">GET
                DIAGNOSTICS</code></a> statements within the condition handler
                that retrieve information from the current and stacked
                diagnostics areas return the same values. This will not be the
                case if statements that reset the current diagnostics area
                execute earlier within the handler. Suppose that
                <code class="literal">p()</code> is rewritten to place the
                <a class="link" href="sql-syntax.html#declare" title="13.6.3&nbsp;DECLARE Syntax"><code class="literal">DECLARE</code></a> statements within the
                handler definition rather than preceding it:
            </p><p style="color:blue;">在前面的示例中，条件处理程序中的前两个get diagnostics语句（从当前和堆栈诊断区域检索信息）返回相同的值。如果重置当前诊断区域的语句早些时候在处理程序中执行，则不会出现这种情况。假设重写p（）以将declare语句放在处理程序定义中，而不是放在它之前：</p><pre data-lang="sql" class="programlisting">CREATE PROCEDURE p ()
BEGIN
  DECLARE EXIT HANDLER FOR SQLEXCEPTION
  BEGIN
    -- Declare variables to hold diagnostics area information
    DECLARE errcount INT;
    DECLARE errno INT;
    DECLARE msg TEXT;
    GET CURRENT DIAGNOSTICS CONDITION 1
      errno = MYSQL_ERRNO, msg = MESSAGE_TEXT;
    SELECT 'current DA before mapped insert' AS op, errno, msg;
    GET STACKED DIAGNOSTICS CONDITION 1
      errno = MYSQL_ERRNO, msg = MESSAGE_TEXT;
    SELECT 'stacked DA before mapped insert' AS op, errno, msg;
...
</pre><p>
                In this case, the result is version dependent:
            </p><p style="color:blue;">在这种情况下，结果取决于版本：</p>
                <div class="itemizedlist">
                    <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                        Before MySQL 5.7.2, <a class="link" href="sql-syntax.html#declare" title="13.6.3&nbsp;DECLARE Syntax"><code class="literal">DECLARE</code></a>
                        does not change the current diagnostics area, so the first
                        two <a class="link" href="sql-syntax.html#get-diagnostics" title="13.6.7.3&nbsp;GET DIAGNOSTICS Syntax"><code class="literal">GET DIAGNOSTICS</code></a>
                        statements return the same result, just as in the original
                        version of <code class="literal">p()</code>.
                    </p><p style="color:blue;">在mysql 5.7.2之前，declare不会更改当前的诊断区域，因此前两个get diagnostics语句返回的结果与原始版本的p（）相同。</p><p>
                        In MySQL 5.7.2, work was done to ensure that all
                        nondiagnostic statements populate the diagnostics area, per
                        the SQL standard. <a class="link" href="sql-syntax.html#declare" title="13.6.3&nbsp;DECLARE Syntax"><code class="literal">DECLARE</code></a> is
                        one of them, so in 5.7.2 and higher,
                        <a class="link" href="sql-syntax.html#declare" title="13.6.3&nbsp;DECLARE Syntax"><code class="literal">DECLARE</code></a> statements executing
                        at the beginning of the handler clear the current
                        diagnostics area and the <a class="link" href="sql-syntax.html#get-diagnostics" title="13.6.7.3&nbsp;GET DIAGNOSTICS Syntax"><code class="literal">GET
                        DIAGNOSTICS</code></a> statements produce different results:
                    </p><p style="color:blue;">在mysql 5.7.2中，已经按照sql标准完成了确保所有非诊断语句填充诊断区域的工作。declare是其中之一，因此在5.7.2及更高版本中，在处理程序开头执行的declare语句清除当前诊断区域，get diagnostics语句将产生不同的结果：</p><pre data-lang="none" class="programlisting">+---------------------------------+-------+------+
| op                              | errno | msg  |
+---------------------------------+-------+------+
| current DA before mapped insert |  NULL | NULL |
+---------------------------------+-------+------+

+---------------------------------+-------+----------------------------+
| op                              | errno | msg                        |
+---------------------------------+-------+----------------------------+
| stacked DA before mapped insert |  1048 | Column 'c1' cannot be null |
+---------------------------------+-------+----------------------------+
</pre></li></ul>
                </div>
                <p>
                    To avoid this issue within a condition handler when seeking to
                    obtain information about the condition that activated the
                    handler, be sure to access the stacked diagnostics area, not the
                    current diagnostics area.
                </p><p style="color:blue;">要在条件处理程序中避免此问题，请确保访问堆栈诊断区域，而不是当前诊断区域。</p>
            </div>
            <div class="section">
                <div class="titlepage">
                    <div>
                        <div>
                            <h4 class="title"><a name="resignal"></a>13.6.7.4&nbsp;RESIGNAL Syntax</h4>

                        </div>

                    </div>

                </div>
                <a class="indexterm" name="idm140286830898400"></a><pre data-lang="sql" class="programlisting">RESIGNAL [<em class="replaceable"><code>condition_value</code></em>]
    [SET <em class="replaceable"><code>signal_information_item</code></em>
    [, <em class="replaceable"><code>signal_information_item</code></em>] ...]

<em class="replaceable"><code>condition_value</code></em>: {
    SQLSTATE [VALUE] <em class="replaceable"><code>sqlstate_value</code></em>
  | <em class="replaceable"><code>condition_name</code></em>
}

<em class="replaceable"><code>signal_information_item</code></em>:
    <em class="replaceable"><code>condition_information_item_name</code></em> = <em class="replaceable"><code>simple_value_specification</code></em>

<em class="replaceable"><code>condition_information_item_name</code></em>: {
    CLASS_ORIGIN
  | SUBCLASS_ORIGIN
  | MESSAGE_TEXT
  | MYSQL_ERRNO
  | CONSTRAINT_CATALOG
  | CONSTRAINT_SCHEMA
  | CONSTRAINT_NAME
  | CATALOG_NAME
  | SCHEMA_NAME
  | TABLE_NAME
  | COLUMN_NAME
  | CURSOR_NAME
}

<em class="replaceable"><code>condition_name</code></em>, <em class="replaceable"><code>simple_value_specification</code></em>:
    (see following discussion)
</pre><p>
                <a class="link" href="sql-syntax.html#resignal" title="13.6.7.4&nbsp;RESIGNAL Syntax"><code class="literal">RESIGNAL</code></a> passes on the error
                condition information that is available during execution of a
                condition handler within a compound statement inside a stored
                procedure or function, trigger, or event.
                <a class="link" href="sql-syntax.html#resignal" title="13.6.7.4&nbsp;RESIGNAL Syntax"><code class="literal">RESIGNAL</code></a> may change some or all
                information before passing it on.
                <a class="link" href="sql-syntax.html#resignal" title="13.6.7.4&nbsp;RESIGNAL Syntax"><code class="literal">RESIGNAL</code></a> is related to
                <a class="link" href="sql-syntax.html#signal" title="13.6.7.5&nbsp;SIGNAL Syntax"><code class="literal">SIGNAL</code></a>, but instead of
                originating a condition as <a class="link" href="sql-syntax.html#signal" title="13.6.7.5&nbsp;SIGNAL Syntax"><code class="literal">SIGNAL</code></a>
                does, <a class="link" href="sql-syntax.html#resignal" title="13.6.7.4&nbsp;RESIGNAL Syntax"><code class="literal">RESIGNAL</code></a> relays existing
                condition information, possibly after modifying it.
            </p><p style="color:blue;">resignal传递在存储过程或函数、触发器或事件中的复合语句中执行条件处理程序时可用的错误条件信息。resignal可能会在传递信息之前更改部分或全部信息。辞职与信号有关，但不是作为信号来源的条件，辞职中继现有的条件信息，可能是修改后。</p><p>
                <a class="link" href="sql-syntax.html#resignal" title="13.6.7.4&nbsp;RESIGNAL Syntax"><code class="literal">RESIGNAL</code></a> makes it possible to
                both handle an error and return the error information.
                Otherwise, by executing an SQL statement within the handler,
                information that caused the handler's activation is destroyed.
                <a class="link" href="sql-syntax.html#resignal" title="13.6.7.4&nbsp;RESIGNAL Syntax"><code class="literal">RESIGNAL</code></a> also can make some
                procedures shorter if a given handler can handle part of a
                situation, then pass the condition <span class="quote">“<span class="quote">up the line</span>”</span> to
                another handler.
            </p><p style="color:blue;">resignal使处理错误和返回错误信息成为可能。否则，通过在处理程序中执行sql语句，导致处理程序激活的信息将被销毁。resignal还可以缩短一些过程，如果给定的处理程序可以处理一部分情况，然后将条件“向上”传递给另一个处理程序。</p><p>
                No privileges are required to execute the
                <a class="link" href="sql-syntax.html#resignal" title="13.6.7.4&nbsp;RESIGNAL Syntax"><code class="literal">RESIGNAL</code></a> statement.
            </p><p style="color:blue;">执行resignal语句不需要特权。</p><p>
                All forms of <a class="link" href="sql-syntax.html#resignal" title="13.6.7.4&nbsp;RESIGNAL Syntax"><code class="literal">RESIGNAL</code></a> require
                that the current context be a condition handler. Otherwise,
                <a class="link" href="sql-syntax.html#resignal" title="13.6.7.4&nbsp;RESIGNAL Syntax"><code class="literal">RESIGNAL</code></a> is illegal and a
                <code class="literal">RESIGNAL when handler not active</code> error
                occurs.
            </p><p style="color:blue;">所有形式的resignal都要求当前上下文是条件处理程序。否则，resignal是非法的，并在处理程序未激活时发生resignal错误。</p><p>
                To retrieve information from the diagnostics area, use the
                <a class="link" href="sql-syntax.html#get-diagnostics" title="13.6.7.3&nbsp;GET DIAGNOSTICS Syntax"><code class="literal">GET DIAGNOSTICS</code></a> statement (see
                <a class="xref" href="sql-syntax.html#get-diagnostics" title="13.6.7.3&nbsp;GET DIAGNOSTICS Syntax">Section&nbsp;13.6.7.3, “GET DIAGNOSTICS Syntax”</a>). For information about the
                diagnostics area, see <a class="xref" href="sql-syntax.html#diagnostics-area" title="13.6.7.7&nbsp;The MySQL Diagnostics Area">Section&nbsp;13.6.7.7, “The MySQL Diagnostics Area”</a>.
            </p><p style="color:blue;">要从诊断区域检索信息，请使用get diagnostics语句（请参阅第13.6.7.3节“get diagnostics syntax”）。有关诊断区域的信息，请参阅第13.6.7.7节“MySQL诊断区域”。</p>
                <div class="itemizedlist">
                    <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><a class="xref" href="sql-syntax.html#resignal-overview" title="RESIGNAL Overview">RESIGNAL Overview</a></p><p style="color:blue;">辞职概述</p></li><li class="listitem"><p><a class="xref" href="sql-syntax.html#resignal-alone" title="RESIGNAL Alone">RESIGNAL Alone</a></p><p style="color:blue;">单独辞职</p></li><li class="listitem"><p><a class="xref" href="sql-syntax.html#resignal-with-new-signal" title="RESIGNAL with New Signal Information">RESIGNAL with New Signal Information</a></p><p style="color:blue;">用新的信号信息重新签名</p></li><li class="listitem"><p><a class="xref" href="sql-syntax.html#resignal-with-condition" title="RESIGNAL with a Condition Value and Optional New Signal Information">RESIGNAL with a Condition Value and Optional New Signal Information</a></p><p style="color:blue;">使用条件值和可选的新信号信息重新签名</p></li><li class="listitem"><p><a class="xref" href="sql-syntax.html#resignal-handler" title="RESIGNAL Requires Condition Handler Context">RESIGNAL Requires Condition Handler Context</a></p><p style="color:blue;">resignal需要条件处理程序上下文</p></li></ul>
                </div>

                <div class="simplesect">

                    <div class="titlepage">
                        <div>

                            <div class="simple">
                                <h5 class="title"><a name="resignal-overview"></a>RESIGNAL Overview</h5>

                            </div>

                        </div>

                    </div>
                    <p>
                        For <em class="replaceable"><code>condition_value</code></em> and
                        <em class="replaceable"><code>signal_information_item</code></em>, the
                        definitions and rules are the same for
                        <a class="link" href="sql-syntax.html#resignal" title="13.6.7.4&nbsp;RESIGNAL Syntax"><code class="literal">RESIGNAL</code></a> as for
                        <a class="link" href="sql-syntax.html#signal" title="13.6.7.5&nbsp;SIGNAL Syntax"><code class="literal">SIGNAL</code></a>. For example, the
                        <em class="replaceable"><code>condition_value</code></em> can be an
                        <code class="literal">SQLSTATE</code> value, and the value can indicate
                        errors, warnings, or <span class="quote">“<span class="quote">not found.</span>”</span> For additional
                        information, see <a class="xref" href="sql-syntax.html#signal" title="13.6.7.5&nbsp;SIGNAL Syntax">Section&nbsp;13.6.7.5, “SIGNAL Syntax”</a>.
                    </p><p style="color:blue;">对于条件值和信号信息项，resignal和signal的定义和规则相同。例如，条件值可以是sqlstate值，该值可以指示错误、警告或“未找到”。有关更多信息，请参阅第13.6.7.5节“信号语法”。</p><p>
                    The <a class="link" href="sql-syntax.html#resignal" title="13.6.7.4&nbsp;RESIGNAL Syntax"><code class="literal">RESIGNAL</code></a> statement takes
                    <em class="replaceable"><code>condition_value</code></em> and
                    <code class="literal">SET</code> clauses, both of which are optional.
                    This leads to several possible uses:
                </p><p style="color:blue;">resignal语句接受条件值和set子句，这两个子句都是可选的。这导致了几种可能的用途：</p>
                    <div class="itemizedlist">
                        <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                            <a class="link" href="sql-syntax.html#resignal" title="13.6.7.4&nbsp;RESIGNAL Syntax"><code class="literal">RESIGNAL</code></a> alone:
                        </p><p style="color:blue;">单独辞职：</p><pre data-lang="sql" class="programlisting">RESIGNAL;
</pre></li><li class="listitem"><p>
                            <a class="link" href="sql-syntax.html#resignal" title="13.6.7.4&nbsp;RESIGNAL Syntax"><code class="literal">RESIGNAL</code></a> with new signal
                            information:
                        </p><p style="color:blue;">使用新信号信息重新签名：</p><pre data-lang="sql" class="programlisting">RESIGNAL SET <em class="replaceable"><code>signal_information_item</code></em> [, <em class="replaceable"><code>signal_information_item</code></em>] ...;
</pre></li><li class="listitem"><p>
                            <a class="link" href="sql-syntax.html#resignal" title="13.6.7.4&nbsp;RESIGNAL Syntax"><code class="literal">RESIGNAL</code></a> with a condition
                            value and possibly new signal information:
                        </p><p style="color:blue;">使用条件值和可能的新信号信息重新签名：</p><pre data-lang="sql" class="programlisting">RESIGNAL <em class="replaceable"><code>condition_value</code></em>
    [SET <em class="replaceable"><code>signal_information_item</code></em> [, <em class="replaceable"><code>signal_information_item</code></em>] ...];
</pre></li></ul>
                    </div>
                    <p>
                        These use cases all cause changes to the diagnostics and
                        condition areas:
                    </p><p style="color:blue;">这些用例都会导致诊断和条件区域的更改：</p>
                    <div class="itemizedlist">
                        <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                            A diagnostics area contains one or more condition areas.
                        </p><p style="color:blue;">诊断区域包含一个或多个条件区域。</p></li><li class="listitem"><p>
                            A condition area contains condition information items,
                            such as the <code class="literal">SQLSTATE</code> value,
                            <code class="literal">MYSQL_ERRNO</code>, or
                            <code class="literal">MESSAGE_TEXT</code>.
                        </p><p style="color:blue;">条件区域包含条件信息项，例如sqlstate值、mysql错误号或消息文本。</p></li></ul>
                    </div>
                    <p>
                        There is a stack of diagnostics areas. When a handler takes
                        control, it pushes a diagnostics area to the top of the stack,
                        so there are two diagnostics areas during handler execution:
                    </p><p style="color:blue;">有一堆诊断区域。当处理程序取得控制权时，它会将诊断区域推送到堆栈的顶部，因此在处理程序执行期间有两个诊断区域：</p>
                    <div class="itemizedlist">
                        <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                            The first (current) diagnostics area, which starts as a
                            copy of the last diagnostics area, but will be overwritten
                            by the first statement in the handler that changes the
                            current diagnostics area.
                        </p><p style="color:blue;">第一个（当前）诊断区域，开始时是最后一个诊断区域的副本，但将被更改当前诊断区域的处理程序中的第一条语句覆盖。</p></li><li class="listitem"><p>
                            The last (stacked) diagnostics area, which has the
                            condition areas that were set up before the handler took
                            control.
                        </p><p style="color:blue;">最后一个（堆叠的）诊断区域，其中包含在处理程序控制之前设置的条件区域。</p></li></ul>
                    </div>
                    <p>
                        The maximum number of condition areas in a diagnostics area is
                        determined by the value of the
                        <a class="link" href="server-administration.html#sysvar_max_error_count"><code class="literal">max_error_count</code></a> system
                        variable. See
                        <a class="xref" href="sql-syntax.html#diagnostics-area-system-variables" title="Diagnostics Area-Related System Variables">Diagnostics Area-Related System Variables</a>.
                    </p><p style="color:blue;">诊断区域中的条件区域的最大数目由Max GyrRoRoSoCurt系统变量的值决定。请参阅诊断区域相关系统变量。</p>
                </div>
                <div class="simplesect">
                    <div class="titlepage">
                        <div>
                            <div class="simple">
                                <h5 class="title"><a name="resignal-alone"></a>RESIGNAL Alone</h5>

                            </div>

                        </div>

                    </div>
                    <p>
                        A simple <a class="link" href="sql-syntax.html#resignal" title="13.6.7.4&nbsp;RESIGNAL Syntax"><code class="literal">RESIGNAL</code></a> alone means
                        <span class="quote">“<span class="quote">pass on the error with no change.</span>”</span> It restores
                        the last diagnostics area and makes it the current diagnostics
                        area. That is, it <span class="quote">“<span class="quote">pops</span>”</span> the diagnostics area
                        stack.
                    </p><p style="color:blue;">一个简单的resignal就意味着“无变化地传递错误”。它恢复最后一个诊断区域，并使其成为当前的诊断区域。也就是说，它“弹出”诊断区域堆栈。</p><p>
                    Within a condition handler that catches a condition, one use
                    for <a class="link" href="sql-syntax.html#resignal" title="13.6.7.4&nbsp;RESIGNAL Syntax"><code class="literal">RESIGNAL</code></a> alone is to
                    perform some other actions, and then pass on without change
                    the original condition information (the information that
                    existed before entry into the handler).
                </p><p style="color:blue;">在捕获条件的条件处理程序中，一个单独用于辞职的使用是执行一些其他动作，然后在不改变原始条件信息的情况下传递（在进入处理程序之前存在的信息）。</p><p>
                    Example:
                </p><p style="color:blue;">例子：</p><pre data-lang="sql" class="programlisting">DROP TABLE IF EXISTS xx;
delimiter //
CREATE PROCEDURE p ()
BEGIN
  DECLARE EXIT HANDLER FOR SQLEXCEPTION
  BEGIN
    SET @error_count = @error_count + 1;
    IF @a = 0 THEN RESIGNAL; END IF;
  END;
  DROP TABLE xx;
END//
delimiter ;
SET @error_count = 0;
SET @a = 0;
CALL p();
</pre><p>
                    Suppose that the <code class="literal">DROP TABLE xx</code> statement
                    fails. The diagnostics area stack looks like this:
                </p><p style="color:blue;">假设drop table xx语句失败。诊断区域堆栈如下所示：</p><pre data-lang="none" class="programlisting">DA 1. ERROR 1051 (42S02): Unknown table 'xx'
</pre><p>
                    Then execution enters the <code class="literal">EXIT</code> handler. It
                    starts by pushing a diagnostics area to the top of the stack,
                    which now looks like this:
                </p><p style="color:blue;">然后执行进入退出处理程序。它首先将诊断区域推到堆栈的顶部，现在看起来如下：</p><pre data-lang="none" class="programlisting">DA 1. ERROR 1051 (42S02): Unknown table 'xx'
DA 2. ERROR 1051 (42S02): Unknown table 'xx'
</pre><p>
                    At this point, the contents of the first (current) and second
                    (stacked) diagnostics areas are the same. The first
                    diagnostics area may be modified by statements executing
                    subsequently within the handler.
                </p><p style="color:blue;">此时，第一个（当前）和第二个（堆叠）诊断区域的内容相同。第一个诊断区域可以由随后在处理程序中执行的语句修改。</p><p>
                    Usually a procedure statement clears the first diagnostics
                    area. <code class="literal">BEGIN</code> is an exception, it does not
                    clear, it does nothing. <code class="literal">SET</code> is not an
                    exception, it clears, performs the operation, and produces a
                    result of <span class="quote">“<span class="quote">success.</span>”</span> The diagnostics area stack
                    now looks like this:
                </p><p style="color:blue;">通常，过程语句会清除第一个诊断区域。开始是个例外，它不清楚，它什么也不做。set不是异常，它会清除、执行操作并生成“success”结果。诊断区域堆栈现在如下所示：</p><pre data-lang="none" class="programlisting">DA 1. ERROR 0000 (00000): Successful operation
DA 2. ERROR 1051 (42S02): Unknown table 'xx'
</pre><p>
                    At this point, if <code class="literal">@a = 0</code>,
                    <a class="link" href="sql-syntax.html#resignal" title="13.6.7.4&nbsp;RESIGNAL Syntax"><code class="literal">RESIGNAL</code></a> pops the diagnostics
                    area stack, which now looks like this:
                </p><p style="color:blue;">此时，如果@a=0，resignal将弹出诊断区域堆栈，现在看起来如下：</p><pre data-lang="none" class="programlisting">DA 1. ERROR 1051 (42S02): Unknown table 'xx'
</pre><p>
                    And that is what the caller sees.
                </p><p style="color:blue;">这就是打电话的人看到的。</p><p>
                    If <code class="literal">@a</code> is not 0, the handler simply ends,
                    which means that there is no more use for the current
                    diagnostics area (it has been <span class="quote">“<span class="quote">handled</span>”</span>), so it
                    can be thrown away, causing the stacked diagnostics area to
                    become the current diagnostics area again. The diagnostics
                    area stack looks like this:
                </p><p style="color:blue;">如果@a不为0，则处理程序只会结束，这意味着当前诊断区域不再使用（它已被“处理”），因此可以将其丢弃，从而使堆叠的诊断区域再次成为当前诊断区域。诊断区域堆栈如下所示：</p><pre data-lang="none" class="programlisting">DA 1. ERROR 0000 (00000): Successful operation
</pre><p>
                    The details make it look complex, but the end result is quite
                    useful: Handlers can execute without destroying information
                    about the condition that caused activation of the handler.
                </p><p style="color:blue;">这些细节使它看起来很复杂，但最终的结果是非常有用的：处理程序可以执行而不破坏有关导致处理程序激活的条件的信息。</p>
                </div>
                <div class="simplesect">
                    <div class="titlepage">
                        <div>
                            <div class="simple">
                                <h5 class="title"><a name="resignal-with-new-signal"></a>RESIGNAL with New Signal Information</h5>

                            </div>

                        </div>

                    </div>
                    <p>
                        <a class="link" href="sql-syntax.html#resignal" title="13.6.7.4&nbsp;RESIGNAL Syntax"><code class="literal">RESIGNAL</code></a> with a
                        <code class="literal">SET</code> clause provides new signal information,
                        so the statement means <span class="quote">“<span class="quote">pass on the error with
          changes</span>”</span>:
                    </p><p style="color:blue;">resignal with a set子句提供了新的信号信息，因此该语句的意思是“传递带有更改的错误”：</p><pre data-lang="sql" class="programlisting">RESIGNAL SET <em class="replaceable"><code>signal_information_item</code></em> [, <em class="replaceable"><code>signal_information_item</code></em>] ...;
</pre><p>
                    As with <a class="link" href="sql-syntax.html#resignal" title="13.6.7.4&nbsp;RESIGNAL Syntax"><code class="literal">RESIGNAL</code></a> alone, the
                    idea is to pop the diagnostics area stack so that the original
                    information will go out. Unlike
                    <a class="link" href="sql-syntax.html#resignal" title="13.6.7.4&nbsp;RESIGNAL Syntax"><code class="literal">RESIGNAL</code></a> alone, anything
                    specified in the <code class="literal">SET</code> clause changes.
                </p><p style="color:blue;">与resignal一样，我们的想法是弹出诊断区域堆栈，这样原始信息就会消失。与resignal不同，set子句中指定的任何内容都会更改。</p><p>
                    Example:
                </p><p style="color:blue;">例子：</p><pre data-lang="sql" class="programlisting">DROP TABLE IF EXISTS xx;
delimiter //
CREATE PROCEDURE p ()
BEGIN
  DECLARE EXIT HANDLER FOR SQLEXCEPTION
  BEGIN
    SET @error_count = @error_count + 1;
    IF @a = 0 THEN RESIGNAL SET MYSQL_ERRNO = 5; END IF;
  END;
  DROP TABLE xx;
END//
delimiter ;
SET @error_count = 0;
SET @a = 0;
CALL p();
</pre><p>
                    Remember from the previous discussion that
                    <a class="link" href="sql-syntax.html#resignal" title="13.6.7.4&nbsp;RESIGNAL Syntax"><code class="literal">RESIGNAL</code></a> alone results in a
                    diagnostics area stack like this:
                </p><p style="color:blue;">请记住，在前面的讨论中，resignal单独会导致如下诊断区域堆栈：</p><pre data-lang="none" class="programlisting">DA 1. ERROR 1051 (42S02): Unknown table 'xx'
</pre><p>
                    The <code class="literal">RESIGNAL SET MYSQL_ERRNO = 5</code> statement
                    results in this stack instead, which is what the caller sees:
                </p><p style="color:blue;">resignal set mysql_errno=5语句导致这个堆栈，这是调用方看到的：</p><pre data-lang="none" class="programlisting">DA 1. ERROR 5 (42S02): Unknown table 'xx'
</pre><p>
                    In other words, it changes the error number, and nothing else.
                </p><p style="color:blue;">换言之，它更改了错误号，而没有其他更改。</p><p>
                    The <a class="link" href="sql-syntax.html#resignal" title="13.6.7.4&nbsp;RESIGNAL Syntax"><code class="literal">RESIGNAL</code></a> statement can
                    change any or all of the signal information items, making the
                    first condition area of the diagnostics area look quite
                    different.
                </p><p style="color:blue;">resignal语句可以更改任何或所有信号信息项，使诊断区域的第一个条件区域看起来非常不同。</p>
                </div>
                <div class="simplesect">
                    <div class="titlepage">
                        <div>
                            <div class="simple">
                                <h5 class="title"><a name="resignal-with-condition"></a>RESIGNAL with a Condition Value and Optional New Signal Information</h5>

                            </div>

                        </div>

                    </div>
                    <p>
                        <a class="link" href="sql-syntax.html#resignal" title="13.6.7.4&nbsp;RESIGNAL Syntax"><code class="literal">RESIGNAL</code></a> with a condition value
                        means <span class="quote">“<span class="quote">push a condition into the current diagnostics
          area.</span>”</span> If the <code class="literal">SET</code> clause is present,
                        it also changes the error information.
                    </p><p style="color:blue;">带有条件值的resignal表示“将条件推送到当前诊断区域”。如果set子句存在，它还会更改错误信息。</p><pre data-lang="sql" class="programlisting">RESIGNAL <em class="replaceable"><code>condition_value</code></em>
    [SET <em class="replaceable"><code>signal_information_item</code></em> [, <em class="replaceable"><code>signal_information_item</code></em>] ...];
</pre><p>
                    This form of <a class="link" href="sql-syntax.html#resignal" title="13.6.7.4&nbsp;RESIGNAL Syntax"><code class="literal">RESIGNAL</code></a> restores
                    the last diagnostics area and makes it the current diagnostics
                    area. That is, it <span class="quote">“<span class="quote">pops</span>”</span> the diagnostics area
                    stack, which is the same as what a simple
                    <a class="link" href="sql-syntax.html#resignal" title="13.6.7.4&nbsp;RESIGNAL Syntax"><code class="literal">RESIGNAL</code></a> alone would do.
                    However, it also changes the diagnostics area depending on the
                    condition value or signal information.
                </p><p style="color:blue;">这种形式的resignal恢复最后一个诊断区域并使其成为当前诊断区域。也就是说，它“弹出”诊断区域堆栈，这与仅使用简单的resignal所做的相同。但是，它也会根据条件值或信号信息更改诊断区域。</p><p>
                    Example:
                </p><p style="color:blue;">例子：</p><pre data-lang="sql" class="programlisting">DROP TABLE IF EXISTS xx;
delimiter //
CREATE PROCEDURE p ()
BEGIN
  DECLARE EXIT HANDLER FOR SQLEXCEPTION
  BEGIN
    SET @error_count = @error_count + 1;
    IF @a = 0 THEN RESIGNAL SQLSTATE '45000' SET MYSQL_ERRNO=5; END IF;
  END;
  DROP TABLE xx;
END//
delimiter ;
SET @error_count = 0;
SET @a = 0;
SET @@max_error_count = 2;
CALL p();
SHOW ERRORS;
</pre><p>
                    This is similar to the previous example, and the effects are
                    the same, except that if
                    <a class="link" href="sql-syntax.html#resignal" title="13.6.7.4&nbsp;RESIGNAL Syntax"><code class="literal">RESIGNAL</code></a> happens, the current
                    condition area looks different at the end. (The reason the
                    condition adds to rather than replaces the existing condition
                    is the use of a condition value.)
                </p><p style="color:blue;">这与前面的示例类似，并且效果相同，只是如果发生resignal，则当前条件区域在末尾看起来不同。（条件添加而不是替换现有条件的原因是使用条件值）。</p><p>
                    The <a class="link" href="sql-syntax.html#resignal" title="13.6.7.4&nbsp;RESIGNAL Syntax"><code class="literal">RESIGNAL</code></a> statement includes
                    a condition value (<code class="literal">SQLSTATE '45000'</code>), so it
                    adds a new condition area, resulting in a diagnostics area
                    stack that looks like this:
                </p><p style="color:blue;">resignal语句包含一个条件值（sqlstate“45000”），因此它添加了一个新的条件区域，从而生成一个如下所示的诊断区域堆栈：</p><pre data-lang="none" class="programlisting">DA 1. (condition 2) ERROR 1051 (42S02): Unknown table 'xx'
      (condition 1) ERROR 5 (45000) Unknown table 'xx'
</pre><p>
                    The result of <a class="link" href="sql-syntax.html#call" title="13.2.1&nbsp;CALL Syntax"><code class="literal">CALL
                    p()</code></a> and <a class="link" href="sql-syntax.html#show-errors" title="13.7.5.17&nbsp;SHOW ERRORS Syntax"><code class="literal">SHOW ERRORS</code></a>
                    for this example is:
                </p><p style="color:blue;">此示例的call p（）和show errors的结果是：</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>CALL p();</code></strong>
ERROR 5 (45000): Unknown table 'xx'
mysql&gt; <strong class="userinput"><code>SHOW ERRORS;</code></strong>
+-------+------+----------------------------------+
| Level | Code | Message                          |
+-------+------+----------------------------------+
| Error | 1051 | Unknown table 'xx'               |
| Error |    5 | Unknown table 'xx'               |
+-------+------+----------------------------------+
</pre>
                </div>
                <div class="simplesect">
                    <div class="titlepage">
                        <div>
                            <div class="simple">
                                <h5 class="title"><a name="resignal-handler"></a>RESIGNAL Requires Condition Handler Context</h5>

                            </div>

                        </div>

                    </div>
                    <p>
                        All forms of <a class="link" href="sql-syntax.html#resignal" title="13.6.7.4&nbsp;RESIGNAL Syntax"><code class="literal">RESIGNAL</code></a> require
                        that the current context be a condition handler. Otherwise,
                        <a class="link" href="sql-syntax.html#resignal" title="13.6.7.4&nbsp;RESIGNAL Syntax"><code class="literal">RESIGNAL</code></a> is illegal and a
                        <code class="literal">RESIGNAL when handler not active</code> error
                        occurs. For example:
                    </p><p style="color:blue;">所有形式的resignal都要求当前上下文是条件处理程序。否则，resignal是非法的，并在处理程序未激活时发生resignal错误。例如：</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>CREATE PROCEDURE p () RESIGNAL;</code></strong>
Query OK, 0 rows affected (0.00 sec)

mysql&gt; <strong class="userinput"><code>CALL p();</code></strong>
ERROR 1645 (0K000): RESIGNAL when handler not active
</pre><p>
                    Here is a more difficult example:
                </p><p style="color:blue;">下面是一个更困难的例子：</p><pre data-lang="sql" class="programlisting">delimiter //
CREATE FUNCTION f () RETURNS INT
BEGIN
  RESIGNAL;
  RETURN 5;
END//
CREATE PROCEDURE p ()
BEGIN
  DECLARE EXIT HANDLER FOR SQLEXCEPTION SET @a=f();
  SIGNAL SQLSTATE '55555';
END//
delimiter ;
CALL p();
</pre><p>
                    <a class="link" href="sql-syntax.html#resignal" title="13.6.7.4&nbsp;RESIGNAL Syntax"><code class="literal">RESIGNAL</code></a> occurs within the
                    stored function <code class="literal">f()</code>. Although
                    <code class="literal">f()</code> itself is invoked within the context of
                    the <code class="literal">EXIT</code> handler, execution within
                    <code class="literal">f()</code> has its own context, which is not
                    handler context. Thus, <code class="literal">RESIGNAL</code> within
                    <code class="literal">f()</code> results in a <span class="quote">“<span class="quote">handler not
          active</span>”</span> error.
                </p><p style="color:blue;">resignal出现在存储的函数f（）中。尽管f（）本身是在退出处理程序的上下文中调用的，但f（）中的执行有自己的上下文，而不是处理程序上下文。因此，f（）中的resignal会导致“handler not active”错误。</p>
                </div>

            </div>
            <div class="section">
                <div class="titlepage">
                    <div>
                        <div>
                            <h4 class="title"><a name="signal"></a>13.6.7.5&nbsp;SIGNAL Syntax</h4>

                        </div>

                    </div>

                </div>
                <a class="indexterm" name="idm140286830747536"></a><pre data-lang="sql" class="programlisting">SIGNAL <em class="replaceable"><code>condition_value</code></em>
    [SET <em class="replaceable"><code>signal_information_item</code></em>
    [, <em class="replaceable"><code>signal_information_item</code></em>] ...]

<em class="replaceable"><code>condition_value</code></em>: {
    SQLSTATE [VALUE] <em class="replaceable"><code>sqlstate_value</code></em>
  | <em class="replaceable"><code>condition_name</code></em>
}

<em class="replaceable"><code>signal_information_item</code></em>:
    <em class="replaceable"><code>condition_information_item_name</code></em> = <em class="replaceable"><code>simple_value_specification</code></em>

<em class="replaceable"><code>condition_information_item_name</code></em>: {
    CLASS_ORIGIN
  | SUBCLASS_ORIGIN
  | MESSAGE_TEXT
  | MYSQL_ERRNO
  | CONSTRAINT_CATALOG
  | CONSTRAINT_SCHEMA
  | CONSTRAINT_NAME
  | CATALOG_NAME
  | SCHEMA_NAME
  | TABLE_NAME
  | COLUMN_NAME
  | CURSOR_NAME
}

<em class="replaceable"><code>condition_name</code></em>, <em class="replaceable"><code>simple_value_specification</code></em>:
    (see following discussion)
</pre><p>
                <a class="link" href="sql-syntax.html#signal" title="13.6.7.5&nbsp;SIGNAL Syntax"><code class="literal">SIGNAL</code></a> is the way to
                <span class="quote">“<span class="quote">return</span>”</span> an error.
                <a class="link" href="sql-syntax.html#signal" title="13.6.7.5&nbsp;SIGNAL Syntax"><code class="literal">SIGNAL</code></a> provides error information
                to a handler, to an outer portion of the application, or to the
                client. Also, it provides control over the error's
                characteristics (error number, <code class="literal">SQLSTATE</code>
                value, message). Without <a class="link" href="sql-syntax.html#signal" title="13.6.7.5&nbsp;SIGNAL Syntax"><code class="literal">SIGNAL</code></a>,
                it is necessary to resort to workarounds such as deliberately
                referring to a nonexistent table to cause a routine to return an
                error.
            </p><p style="color:blue;">信号是“返回”错误的方法。信号向处理程序、应用程序的外部部分或客户端提供错误信息。此外，它还提供对错误特性（错误号、sqlstate值、消息）的控制。在没有信号的情况下，有必要采取诸如故意引用不存在的表之类的解决方案来导致例程返回错误。</p><p>
                No privileges are required to execute the
                <a class="link" href="sql-syntax.html#signal" title="13.6.7.5&nbsp;SIGNAL Syntax"><code class="literal">SIGNAL</code></a> statement.
            </p><p style="color:blue;">执行signal语句不需要特权。</p><p>
                To retrieve information from the diagnostics area, use the
                <a class="link" href="sql-syntax.html#get-diagnostics" title="13.6.7.3&nbsp;GET DIAGNOSTICS Syntax"><code class="literal">GET DIAGNOSTICS</code></a> statement (see
                <a class="xref" href="sql-syntax.html#get-diagnostics" title="13.6.7.3&nbsp;GET DIAGNOSTICS Syntax">Section&nbsp;13.6.7.3, “GET DIAGNOSTICS Syntax”</a>). For information about the
                diagnostics area, see <a class="xref" href="sql-syntax.html#diagnostics-area" title="13.6.7.7&nbsp;The MySQL Diagnostics Area">Section&nbsp;13.6.7.7, “The MySQL Diagnostics Area”</a>.
            </p><p style="color:blue;">要从诊断区域检索信息，请使用get diagnostics语句（请参阅第13.6.7.3节“get diagnostics syntax”）。有关诊断区域的信息，请参阅第13.6.7.7节“MySQL诊断区域”。</p>
                <div class="itemizedlist">
                    <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><a class="xref" href="sql-syntax.html#signal-overview" title="SIGNAL Overview">SIGNAL Overview</a></p><p style="color:blue;">信号概述</p></li><li class="listitem"><p><a class="xref" href="sql-syntax.html#signal-condition-information-items" title="Signal Condition Information Items">Signal Condition Information Items</a></p><p style="color:blue;">信号状态信息项</p></li><li class="listitem"><p><a class="xref" href="sql-syntax.html#signal-effects" title="Effect of Signals on Handlers, Cursors, and Statements">Effect of Signals on Handlers, Cursors, and Statements</a></p><p style="color:blue;">信号对处理程序、游标和语句的影响</p></li></ul>
                </div>

                <div class="simplesect">

                    <div class="titlepage">
                        <div>

                            <div class="simple">
                                <h5 class="title"><a name="signal-overview"></a>SIGNAL Overview</h5>

                            </div>

                        </div>

                    </div>
                    <p>
                        The <em class="replaceable"><code>condition_value</code></em> in a
                        <a class="link" href="sql-syntax.html#signal" title="13.6.7.5&nbsp;SIGNAL Syntax"><code class="literal">SIGNAL</code></a> statement indicates the
                        error value to be returned. It can be an
                        <code class="literal">SQLSTATE</code> value (a 5-character string
                        literal) or a <em class="replaceable"><code>condition_name</code></em> that
                        refers to a named condition previously defined with
                        <a class="link" href="sql-syntax.html#declare-condition" title="13.6.7.1&nbsp;DECLARE ... CONDITION Syntax"><code class="literal">DECLARE ...
                            CONDITION</code></a> (see <a class="xref" href="sql-syntax.html#declare-condition" title="13.6.7.1&nbsp;DECLARE ... CONDITION Syntax">Section&nbsp;13.6.7.1, “DECLARE ... CONDITION Syntax”</a>).
                    </p><p style="color:blue;">信号语句中的条件值指示要返回的错误值。它可以是一个sqlstate值（一个5个字符的字符串文字）或一个引用先前用declare定义的命名条件的条件名称…条件（见第13.6.7.1节，“声明……条件语法”）。</p><p>
                    An <code class="literal">SQLSTATE</code> value can indicate errors,
                    warnings, or <span class="quote">“<span class="quote">not found.</span>”</span> The first two
                    characters of the value indicate its error class, as discussed
                    in <a class="xref" href="sql-syntax.html#signal-condition-information-items" title="Signal Condition Information Items">Signal Condition Information Items</a>. Some
                    signal values cause statement termination; see
                    <a class="xref" href="sql-syntax.html#signal-effects" title="Effect of Signals on Handlers, Cursors, and Statements">Effect of Signals on Handlers, Cursors, and Statements</a>.
                </p><p style="color:blue;">sqlstate值可以指示错误、警告或“未找到”。该值的前两个字符指示其错误类，如信号条件信息项中所述。某些信号值会导致语句终止；请参阅信号对处理程序、游标和语句的影响。</p><p>
                    The <code class="literal">SQLSTATE</code> value for a
                    <a class="link" href="sql-syntax.html#signal" title="13.6.7.5&nbsp;SIGNAL Syntax"><code class="literal">SIGNAL</code></a> statement should not
                    start with <code class="literal">'00'</code> because such values
                    indicate success and are not valid for signaling an error.
                    This is true whether the <code class="literal">SQLSTATE</code> value is
                    specified directly in the
                    <a class="link" href="sql-syntax.html#signal" title="13.6.7.5&nbsp;SIGNAL Syntax"><code class="literal">SIGNAL</code></a> statement or in a named
                    condition referred to in the statement. If the value is
                    invalid, a <code class="literal">Bad SQLSTATE</code> error occurs.
                </p><p style="color:blue;">signal语句的sqlstate值不应以“00”开头，因为此类值表示成功，并且对于发出错误信号无效。无论是在signal语句中直接指定sqlstate值，还是在语句中引用的命名条件中指定sqlstate值，都是如此。如果该值无效，则会发生错误的sqlstate错误。</p><p>
                    To signal a generic <code class="literal">SQLSTATE</code> value, use
                    <code class="literal">'45000'</code>, which means <span class="quote">“<span class="quote">unhandled
          user-defined exception.</span>”</span>
                </p><p style="color:blue;">要发出一般sqlstate值的信号，请使用“45000”，这意味着“未处理的用户定义异常”。</p><p>
                    The <a class="link" href="sql-syntax.html#signal" title="13.6.7.5&nbsp;SIGNAL Syntax"><code class="literal">SIGNAL</code></a> statement optionally
                    includes a <code class="literal">SET</code> clause that contains
                    multiple signal items, in a list of
                    <em class="replaceable"><code>condition_information_item_name</code></em> =
                    <em class="replaceable"><code>simple_value_specification</code></em>
                    assignments, separated by commas.
                </p><p style="color:blue;">signal语句可选地包括一个set子句，该子句包含多个信号项，在条件信息项名=简单值指定的列表中，用逗号分隔。</p><p>
                    Each
                    <em class="replaceable"><code>condition_information_item_name</code></em> may
                    be specified only once in the <code class="literal">SET</code> clause.
                    Otherwise, a <code class="literal">Duplicate condition information
                    item</code> error occurs.
                </p><p style="color:blue;">每个条件信息项名称只能在SET子句中指定一次。否则，将发生重复条件信息项错误。</p><p>
                    Valid <em class="replaceable"><code>simple_value_specification</code></em>
                    designators can be specified using stored procedure or
                    function parameters, stored program local variables declared
                    with <a class="link" href="sql-syntax.html#declare" title="13.6.3&nbsp;DECLARE Syntax"><code class="literal">DECLARE</code></a>, user-defined
                    variables, system variables, or literals. A character literal
                    may include a <em class="replaceable"><code>_charset</code></em> introducer.
                </p><p style="color:blue;">可以使用存储过程或函数参数、用declare声明的存储程序局部变量、用户定义的变量、系统变量或文本来指定有效的简单值指示符。字符文字可以包括字符集介绍人。</p><p>
                    For information about permissible
                    <em class="replaceable"><code>condition_information_item_name</code></em>
                    values, see
                    <a class="xref" href="sql-syntax.html#signal-condition-information-items" title="Signal Condition Information Items">Signal Condition Information Items</a>.
                </p><p style="color:blue;">有关允许条件信息项名称值的信息，请参阅信号条件信息项。</p><p>
                    The following procedure signals an error or warning depending
                    on the value of <code class="literal">pval</code>, its input parameter:
                </p><p style="color:blue;">以下过程根据输入参数pval的值发出错误或警告信号：</p><pre data-lang="sql" class="programlisting">CREATE PROCEDURE p (pval INT)
BEGIN
  DECLARE specialty CONDITION FOR SQLSTATE '45000';
  IF pval = 0 THEN
    SIGNAL SQLSTATE '01000';
  ELSEIF pval = 1 THEN
    SIGNAL SQLSTATE '45000'
      SET MESSAGE_TEXT = 'An error occurred';
  ELSEIF pval = 2 THEN
    SIGNAL specialty
      SET MESSAGE_TEXT = 'An error occurred';
  ELSE
    SIGNAL SQLSTATE '01000'
      SET MESSAGE_TEXT = 'A warning occurred', MYSQL_ERRNO = 1000;
    SIGNAL SQLSTATE '45000'
      SET MESSAGE_TEXT = 'An error occurred', MYSQL_ERRNO = 1001;
  END IF;
END;
</pre><p>
                    If <code class="literal">pval</code> is 0, <code class="literal">p()</code>
                    signals a warning because <code class="literal">SQLSTATE</code> values
                    that begin with <code class="literal">'01'</code> are signals in the
                    warning class. The warning does not terminate the procedure,
                    and can be seen with <a class="link" href="sql-syntax.html#show-warnings" title="13.7.5.40&nbsp;SHOW WARNINGS Syntax"><code class="literal">SHOW
                    WARNINGS</code></a> after the procedure returns.
                </p><p style="color:blue;">如果pval为0，p（）表示警告，因为以“01”开头的sqlstate值是警告类中的信号。警告不会终止过程，并且可以在过程返回后显示警告。</p><p>
                    If <code class="literal">pval</code> is 1, <code class="literal">p()</code>
                    signals an error and sets the <code class="literal">MESSAGE_TEXT</code>
                    condition information item. The error terminates the
                    procedure, and the text is returned with the error
                    information.
                </p><p style="color:blue;">如果pval为1，p（）将发出错误信号并设置消息文本条件信息项。错误会终止过程，并返回包含错误信息的文本。</p><p>
                    If <code class="literal">pval</code> is 2, the same error is signaled,
                    although the <code class="literal">SQLSTATE</code> value is specified
                    using a named condition in this case.
                </p><p style="color:blue;">如果pval为2，则会发出相同的错误信号，尽管在本例中使用命名条件指定sqlstate值。</p><p>
                    If <code class="literal">pval</code> is anything else,
                    <code class="literal">p()</code> first signals a warning and sets the
                    message text and error number condition information items.
                    This warning does not terminate the procedure, so execution
                    continues and <code class="literal">p()</code> then signals an error.
                    The error does terminate the procedure. The message text and
                    error number set by the warning are replaced by the values set
                    by the error, which are returned with the error information.
                </p><p style="color:blue;">如果pval是其他值，p（）首先发出警告信号，并设置消息文本和错误号条件信息项。此警告不会终止过程，因此继续执行，然后p（）发出错误信号。错误确实会终止过程。由警告设置的消息文本和错误号将替换为由错误设置的值，这些值将与错误信息一起返回。</p><p>
                    <a class="link" href="sql-syntax.html#signal" title="13.6.7.5&nbsp;SIGNAL Syntax"><code class="literal">SIGNAL</code></a> is typically used within
                    stored programs, but it is a MySQL extension that it is
                    permitted outside handler context. For example, if you invoke
                    the <a class="link" href="programs.html#mysql" title="4.5.1&nbsp;mysql — The MySQL Command-Line Client"><span class="command"><strong>mysql</strong></span></a> client program, you can enter any
                    of these statements at the prompt:
                </p><p style="color:blue;">signal通常在存储程序中使用，但它是mysql扩展，允许在处理程序上下文外部使用。例如，如果调用mysql客户端程序，则可以在提示下输入以下任何语句：</p><pre data-lang="sql" class="programlisting">SIGNAL SQLSTATE '77777';

CREATE TRIGGER t_bi BEFORE INSERT ON t
  FOR EACH ROW SIGNAL SQLSTATE '77777';

CREATE EVENT e ON SCHEDULE EVERY 1 SECOND
  DO SIGNAL SQLSTATE '77777';
</pre><p>
                    <a class="link" href="sql-syntax.html#signal" title="13.6.7.5&nbsp;SIGNAL Syntax"><code class="literal">SIGNAL</code></a> executes according to
                    the following rules:
                </p><p style="color:blue;">信号按以下规则执行：</p><p>
                    If the <a class="link" href="sql-syntax.html#signal" title="13.6.7.5&nbsp;SIGNAL Syntax"><code class="literal">SIGNAL</code></a> statement
                    indicates a particular <code class="literal">SQLSTATE</code> value, that
                    value is used to signal the condition specified. Example:
                </p><p style="color:blue;">如果signal语句指示特定的sqlstate值，则该值用于指示指定的条件。例子：</p><pre data-lang="sql" class="programlisting">CREATE PROCEDURE p (divisor INT)
BEGIN
  IF divisor = 0 THEN
    SIGNAL SQLSTATE '22012';
  END IF;
END;
</pre><p>
                    If the <a class="link" href="sql-syntax.html#signal" title="13.6.7.5&nbsp;SIGNAL Syntax"><code class="literal">SIGNAL</code></a> statement uses a
                    named condition, the condition must be declared in some scope
                    that applies to the <a class="link" href="sql-syntax.html#signal" title="13.6.7.5&nbsp;SIGNAL Syntax"><code class="literal">SIGNAL</code></a>
                    statement, and must be defined using an
                    <code class="literal">SQLSTATE</code> value, not a MySQL error number.
                    Example:
                </p><p style="color:blue;">如果signal语句使用命名条件，则必须在应用于signal语句的某个作用域中声明该条件，并且必须使用sqlstate值（而不是mysql错误号）定义该条件。例子：</p><pre data-lang="sql" class="programlisting">CREATE PROCEDURE p (divisor INT)
BEGIN
  DECLARE divide_by_zero CONDITION FOR SQLSTATE '22012';
  IF divisor = 0 THEN
    SIGNAL divide_by_zero;
  END IF;
END;
</pre><p>
                    If the named condition does not exist in the scope of the
                    <a class="link" href="sql-syntax.html#signal" title="13.6.7.5&nbsp;SIGNAL Syntax"><code class="literal">SIGNAL</code></a> statement, an
                    <code class="literal">Undefined CONDITION</code> error occurs.
                </p><p style="color:blue;">如果在信号语句的范围内不存在命名条件，则会出现未定义的条件错误。</p><p>
                    If <a class="link" href="sql-syntax.html#signal" title="13.6.7.5&nbsp;SIGNAL Syntax"><code class="literal">SIGNAL</code></a> refers to a named
                    condition that is defined with a MySQL error number rather
                    than an <code class="literal">SQLSTATE</code> value, a
                    <code class="literal">SIGNAL/RESIGNAL can only use a CONDITION defined with
                        SQLSTATE</code> error occurs. The following statements
                    cause that error because the named condition is associated
                    with a MySQL error number:
                </p><p style="color:blue;">如果signal引用用mysql错误号而不是sqlstate值定义的命名条件，则signal/resignal只能使用用sqlstate error定义的条件。以下语句导致该错误，因为命名条件与MySQL错误号关联：</p><pre data-lang="sql" class="programlisting">DECLARE no_such_table CONDITION FOR 1051;
SIGNAL no_such_table;
</pre><p>
                    If a condition with a given name is declared multiple times in
                    different scopes, the declaration with the most local scope
                    applies. Consider the following procedure:
                </p><p style="color:blue;">如果在不同的作用域中多次声明具有给定名称的条件，则应用具有最本地作用域的声明。考虑以下步骤：</p><pre data-lang="sql" class="programlisting">CREATE PROCEDURE p (divisor INT)
BEGIN
  DECLARE my_error CONDITION FOR SQLSTATE '45000';
  IF divisor = 0 THEN
    BEGIN
      DECLARE my_error CONDITION FOR SQLSTATE '22012';
      SIGNAL my_error;
    END;
  END IF;
  SIGNAL my_error;
END;
</pre><p>
                    If <code class="literal">divisor</code> is 0, the first
                    <a class="link" href="sql-syntax.html#signal" title="13.6.7.5&nbsp;SIGNAL Syntax"><code class="literal">SIGNAL</code></a> statement executes. The
                    innermost <code class="literal">my_error</code> condition declaration
                    applies, raising <code class="literal">SQLSTATE</code>
                    <code class="literal">'22012'</code>.
                </p><p style="color:blue;">如果除数为0，则执行第一个信号语句。应用最里面的my_error condition声明，引发sqlstate“22012”。</p><p>
                    If <code class="literal">divisor</code> is not 0, the second
                    <a class="link" href="sql-syntax.html#signal" title="13.6.7.5&nbsp;SIGNAL Syntax"><code class="literal">SIGNAL</code></a> statement executes. The
                    outermost <code class="literal">my_error</code> condition declaration
                    applies, raising <code class="literal">SQLSTATE</code>
                    <code class="literal">'45000'</code>.
                </p><p style="color:blue;">如果除数不为0，则执行第二个信号语句。应用最外面的my_error condition声明，引发sqlstate“45000”。</p><p>
                    For information about how the server chooses handlers when a
                    condition occurs, see <a class="xref" href="sql-syntax.html#handler-scope" title="13.6.7.6&nbsp;Scope Rules for Handlers">Section&nbsp;13.6.7.6, “Scope Rules for Handlers”</a>.
                </p><p style="color:blue;">有关发生条件时服务器如何选择处理程序的信息，请参阅第13.6.7.6节“处理程序的作用域规则”。</p><p>
                    Signals can be raised within exception handlers:
                </p><p style="color:blue;">可以在异常处理程序中引发信号：</p><pre data-lang="sql" class="programlisting">CREATE PROCEDURE p ()
BEGIN
  DECLARE EXIT HANDLER FOR SQLEXCEPTION
  BEGIN
    SIGNAL SQLSTATE VALUE '99999'
      SET MESSAGE_TEXT = 'An error occurred';
  END;
  DROP TABLE no_such_table;
END;
</pre><p>
                    <code class="literal">CALL p()</code> reaches the
                    <a class="link" href="sql-syntax.html#drop-table" title="13.1.29&nbsp;DROP TABLE Syntax"><code class="literal">DROP TABLE</code></a> statement. There is
                    no table named <code class="literal">no_such_table</code>, so the error
                    handler is activated. The error handler destroys the original
                    error (<span class="quote">“<span class="quote">no such table</span>”</span>) and makes a new error
                    with <code class="literal">SQLSTATE</code> <code class="literal">'99999'</code>
                    and message <code class="literal">An error occurred</code>.
                </p><p style="color:blue;">call p（）到达drop table语句。没有名为no_such_table的表，因此错误处理程序被激活。错误处理程序将销毁原始错误（“没有此类表”），并使用sqlstate“99999”生成新错误，并发送错误消息。</p>
                </div>
                <div class="simplesect">
                    <div class="titlepage">
                        <div>
                            <div class="simple">
                                <h5 class="title"><a name="signal-condition-information-items"></a>Signal Condition Information Items</h5>

                            </div>

                        </div>

                    </div>
                    <p>
                        The following table lists the names of diagnostics area
                        condition information items that can be set in a
                        <a class="link" href="sql-syntax.html#signal" title="13.6.7.5&nbsp;SIGNAL Syntax"><code class="literal">SIGNAL</code></a> (or
                        <a class="link" href="sql-syntax.html#resignal" title="13.6.7.4&nbsp;RESIGNAL Syntax"><code class="literal">RESIGNAL</code></a>) statement. All items
                        are standard SQL except <code class="literal">MYSQL_ERRNO</code>, which
                        is a MySQL extension. For more information about these items
                        see <a class="xref" href="sql-syntax.html#diagnostics-area" title="13.6.7.7&nbsp;The MySQL Diagnostics Area">Section&nbsp;13.6.7.7, “The MySQL Diagnostics Area”</a>.
                    </p><p style="color:blue;">下表列出了可以在SIGNAL（或RESIGNAL）语句中设置的诊断区域条件信息项的名称。除了mysql的扩展mysql，所有项都是标准sql。有关这些项的更多信息，请参阅第13.6.7.7节“MySQL诊断区域”。</p><pre data-lang="none" class="programlisting">Item Name             Definition
---------             ----------
CLASS_ORIGIN          VARCHAR(64)
SUBCLASS_ORIGIN       VARCHAR(64)
CONSTRAINT_CATALOG    VARCHAR(64)
CONSTRAINT_SCHEMA     VARCHAR(64)
CONSTRAINT_NAME       VARCHAR(64)
CATALOG_NAME          VARCHAR(64)
SCHEMA_NAME           VARCHAR(64)
TABLE_NAME            VARCHAR(64)
COLUMN_NAME           VARCHAR(64)
CURSOR_NAME           VARCHAR(64)
MESSAGE_TEXT          VARCHAR(128)
MYSQL_ERRNO           SMALLINT UNSIGNED
</pre><p>
                    The character set for character items is UTF-8.
                </p><p style="color:blue;">字符项的字符集是utf-8。</p><p>
                    It is illegal to assign <code class="literal">NULL</code> to a condition
                    information item in a <a class="link" href="sql-syntax.html#signal" title="13.6.7.5&nbsp;SIGNAL Syntax"><code class="literal">SIGNAL</code></a>
                    statement.
                </p><p style="color:blue;">在signal语句中为条件信息项指定null是非法的。</p><p>
                    A <a class="link" href="sql-syntax.html#signal" title="13.6.7.5&nbsp;SIGNAL Syntax"><code class="literal">SIGNAL</code></a> statement always
                    specifies an <code class="literal">SQLSTATE</code> value, either
                    directly, or indirectly by referring to a named condition
                    defined with an <code class="literal">SQLSTATE</code> value. The first
                    two characters of an <code class="literal">SQLSTATE</code> value are its
                    class, and the class determines the default value for the
                    condition information items:
                </p><p style="color:blue;">signal语句总是通过引用使用sqlstate值定义的命名条件来直接或间接指定sqlstate值。sqlstate值的前两个字符是其类，该类确定条件信息项的默认值：</p>
                    <div class="itemizedlist">
                        <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                            Class = <code class="literal">'00'</code> (success)
                        </p><p style="color:blue;">类='00'（成功）</p><p>
                            Illegal. <code class="literal">SQLSTATE</code> values that begin
                            with <code class="literal">'00'</code> indicate success and are not
                            valid for <a class="link" href="sql-syntax.html#signal" title="13.6.7.5&nbsp;SIGNAL Syntax"><code class="literal">SIGNAL</code></a>.
                        </p><p style="color:blue;">不合法。以“00”开头的sqlstate值表示成功，对信号无效。</p></li><li class="listitem"><p>
                            Class = <code class="literal">'01'</code> (warning)
                        </p><p style="color:blue;">类='01'（警告）</p><pre data-lang="sql" class="programlisting">MESSAGE_TEXT = 'Unhandled user-defined warning condition';
MYSQL_ERRNO = <a class="link" href="error-handling.html#error_er_signal_warn"><code class="literal">ER_SIGNAL_WARN</code></a>
</pre></li><li class="listitem"><p>
                            Class = <code class="literal">'02'</code> (not found)
                        </p><p style="color:blue;">类='02'（未找到）</p><pre data-lang="sql" class="programlisting">MESSAGE_TEXT = 'Unhandled user-defined not found condition';
MYSQL_ERRNO = <a class="link" href="error-handling.html#error_er_signal_not_found"><code class="literal">ER_SIGNAL_NOT_FOUND</code></a>
</pre></li><li class="listitem"><p>
                            Class &gt; <code class="literal">'02'</code> (exception)
                        </p><p style="color:blue;">类别&gt;'02'（例外）</p><pre data-lang="sql" class="programlisting">MESSAGE_TEXT = 'Unhandled user-defined exception condition';
MYSQL_ERRNO = <a class="link" href="error-handling.html#error_er_signal_exception"><code class="literal">ER_SIGNAL_EXCEPTION</code></a>
</pre></li></ul>
                    </div>
                    <p>
                        For legal classes, the other condition information items are
                        set as follows:
                    </p><p style="color:blue;">对于法律类，其他条件信息项设置如下：</p><pre data-lang="sql" class="programlisting">CLASS_ORIGIN = SUBCLASS_ORIGIN = '';
CONSTRAINT_CATALOG = CONSTRAINT_SCHEMA = CONSTRAINT_NAME = '';
CATALOG_NAME = SCHEMA_NAME = TABLE_NAME = COLUMN_NAME = '';
CURSOR_NAME = '';
</pre><p>
                    The error values that are accessible after
                    <a class="link" href="sql-syntax.html#signal" title="13.6.7.5&nbsp;SIGNAL Syntax"><code class="literal">SIGNAL</code></a> executes are the
                    <code class="literal">SQLSTATE</code> value raised by the
                    <a class="link" href="sql-syntax.html#signal" title="13.6.7.5&nbsp;SIGNAL Syntax"><code class="literal">SIGNAL</code></a> statement and the
                    <code class="literal">MESSAGE_TEXT</code> and
                    <code class="literal">MYSQL_ERRNO</code> items. These values are
                    available from the C API:
                </p><p style="color:blue;">signal执行后可访问的错误值是signal语句引发的sqlstate值，以及message_text和mysql_errno项。这些值可从C API获得：</p>
                    <div class="itemizedlist">
                        <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                            <a class="link" href="connectors-apis.html#mysql-sqlstate" title="27.8.7.72&nbsp;mysql_sqlstate()"><code class="literal">mysql_sqlstate()</code></a> returns
                            the <code class="literal">SQLSTATE</code> value.
                        </p><p style="color:blue;">mysql_sqlstate（）返回sqlstate值。</p></li><li class="listitem"><p>
                            <a class="link" href="connectors-apis.html#mysql-errno" title="27.8.7.14&nbsp;mysql_errno()"><code class="literal">mysql_errno()</code></a> returns the
                            <code class="literal">MYSQL_ERRNO</code> value.
                        </p><p style="color:blue;">mysql_errno（）返回mysql_errno值。</p></li><li class="listitem"><p>
                            <a class="link" href="connectors-apis.html#mysql-error" title="27.8.7.15&nbsp;mysql_error()"><code class="literal">mysql_error()</code></a> returns the
                            <code class="literal">MESSAGE_TEXT</code> value.
                        </p><p style="color:blue;">mysql_error（）返回消息文本值。</p></li></ul>
                    </div>
                    <p>
                        At the SQL level, the output from <a class="link" href="sql-syntax.html#show-warnings" title="13.7.5.40&nbsp;SHOW WARNINGS Syntax"><code class="literal">SHOW
                        WARNINGS</code></a> and <a class="link" href="sql-syntax.html#show-errors" title="13.7.5.17&nbsp;SHOW ERRORS Syntax"><code class="literal">SHOW
                        ERRORS</code></a> indicates the <code class="literal">MYSQL_ERRNO</code>
                        and <code class="literal">MESSAGE_TEXT</code> values in the
                        <code class="literal">Code</code> and <code class="literal">Message</code>
                        columns.
                    </p><p style="color:blue;">在sql级别，show warnings和show errors的输出指示代码和消息列中的mysql_errno和message_文本值。</p><p>
                    To retrieve information from the diagnostics area, use the
                    <a class="link" href="sql-syntax.html#get-diagnostics" title="13.6.7.3&nbsp;GET DIAGNOSTICS Syntax"><code class="literal">GET DIAGNOSTICS</code></a> statement (see
                    <a class="xref" href="sql-syntax.html#get-diagnostics" title="13.6.7.3&nbsp;GET DIAGNOSTICS Syntax">Section&nbsp;13.6.7.3, “GET DIAGNOSTICS Syntax”</a>). For information about the
                    diagnostics area, see <a class="xref" href="sql-syntax.html#diagnostics-area" title="13.6.7.7&nbsp;The MySQL Diagnostics Area">Section&nbsp;13.6.7.7, “The MySQL Diagnostics Area”</a>.
                </p><p style="color:blue;">要从诊断区域检索信息，请使用get diagnostics语句（请参阅第13.6.7.3节“get diagnostics syntax”）。有关诊断区域的信息，请参阅第13.6.7.7节“MySQL诊断区域”。</p>
                </div>
                <div class="simplesect">
                    <div class="titlepage">
                        <div>
                            <div class="simple">
                                <h5 class="title"><a name="signal-effects"></a>Effect of Signals on Handlers, Cursors, and Statements</h5>

                            </div>

                        </div>

                    </div>
                    <p>
                        Signals have different effects on statement execution
                        depending on the signal class. The class determines how severe
                        an error is. MySQL ignores the value of the
                        <a class="link" href="server-administration.html#sysvar_sql_mode"><code class="literal">sql_mode</code></a> system variable; in
                        particular, strict SQL mode does not matter. MySQL also
                        ignores <code class="literal">IGNORE</code>: The intent of
                        <a class="link" href="sql-syntax.html#signal" title="13.6.7.5&nbsp;SIGNAL Syntax"><code class="literal">SIGNAL</code></a> is to raise a
                        user-generated error explicitly, so a signal is never ignored.
                    </p><p style="color:blue;">信号对语句执行的影响取决于信号类。类确定错误的严重程度。mysql忽略sql_mode系统变量的值；特别是，严格的sql mode并不重要。mysql还忽略ignore：signal的目的是显式地引发用户生成的错误，因此信号永远不会被忽略。</p><p>
                    In the following descriptions, <span class="quote">“<span class="quote">unhandled</span>”</span> means
                    that no handler for the signaled <code class="literal">SQLSTATE</code>
                    value has been defined with
                    <a class="link" href="sql-syntax.html#declare-handler" title="13.6.7.2&nbsp;DECLARE ... HANDLER Syntax"><code class="literal">DECLARE ...
                        HANDLER</code></a>.
                </p><p style="color:blue;">在下面的描述中，“unhandled”表示没有用declare定义信号sqlstate值的处理程序…处理程序。</p>
                    <div class="itemizedlist">
                        <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                            Class = <code class="literal">'00'</code> (success)
                        </p><p style="color:blue;">类='00'（成功）</p><p>
                            Illegal. <code class="literal">SQLSTATE</code> values that begin
                            with <code class="literal">'00'</code> indicate success and are not
                            valid for <a class="link" href="sql-syntax.html#signal" title="13.6.7.5&nbsp;SIGNAL Syntax"><code class="literal">SIGNAL</code></a>.
                        </p><p style="color:blue;">不合法。以“00”开头的sqlstate值表示成功，对信号无效。</p></li><li class="listitem"><p>
                            Class = <code class="literal">'01'</code> (warning)
                        </p><p style="color:blue;">类='01'（警告）</p><p>
                            The value of the
                            <a class="link" href="server-administration.html#sysvar_warning_count"><code class="literal">warning_count</code></a> system
                            variable goes up. <a class="link" href="sql-syntax.html#show-warnings" title="13.7.5.40&nbsp;SHOW WARNINGS Syntax"><code class="literal">SHOW
                            WARNINGS</code></a> shows the signal.
                            <code class="literal">SQLWARNING</code> handlers catch the signal.
                        </p><p style="color:blue;">warning_count系统变量的值将上升。显示警告显示信号。sqlwarning处理程序捕获信号。</p><p>
                            Warnings cannot be returned from stored functions because
                            the <a class="link" href="sql-syntax.html#return" title="13.6.5.7&nbsp;RETURN Syntax"><code class="literal">RETURN</code></a> statement that
                            causes the function to return clears the diagnostic area.
                            The statement thus clears any warnings that may have been
                            present there (and resets
                            <a class="link" href="server-administration.html#sysvar_warning_count"><code class="literal">warning_count</code></a> to 0).
                        </p><p style="color:blue;">无法从存储的函数返回警告，因为导致函数返回的返回语句将清除诊断区域。因此，该语句将清除所有可能存在的警告（并将警告计数重置为0）。</p></li><li class="listitem"><p>
                            Class = <code class="literal">'02'</code> (not found)
                        </p><p style="color:blue;">类='02'（未找到）</p><p>
                            <code class="literal">NOT FOUND</code> handlers catch the signal.
                            There is no effect on cursors. If the signal is unhandled
                            in a stored function, statements end.
                        </p><p style="color:blue;">找不到处理程序捕获信号。对游标没有影响。如果在存储函数中未处理信号，则语句结束。</p></li><li class="listitem"><p>
                            Class &gt; <code class="literal">'02'</code> (exception)
                        </p><p style="color:blue;">类别&gt;'02'（例外）</p><p>
                            <code class="literal">SQLEXCEPTION</code> handlers catch the signal.
                            If the signal is unhandled in a stored function,
                            statements end.
                        </p><p style="color:blue;">SqlException处理程序捕获信号。如果在存储函数中未处理信号，则语句结束。</p></li><li class="listitem"><p>
                            Class = <code class="literal">'40'</code>
                        </p><p style="color:blue;">类='40'</p><p>
                            Treated as an ordinary exception.
                        </p><p style="color:blue;">作为普通的例外处理。</p></li></ul>
                    </div>

                </div>

            </div>
            <div class="section">
                <div class="titlepage">
                    <div>
                        <div>
                            <h4 class="title"><a name="handler-scope"></a>13.6.7.6&nbsp;Scope Rules for Handlers</h4>

                        </div>

                    </div>

                </div>
                <p>
                    A stored program may include handlers to be invoked when certain
                    conditions occur within the program. The applicability of each
                    handler depends on its location within the program definition
                    and on the condition or conditions that it handles:
                </p><p style="color:blue;">存储的程序可以包括当程序中出现某些条件时要调用的处理程序。每个处理程序的适用性取决于它在程序定义中的位置以及它处理的条件：</p>
                <div class="itemizedlist">
                    <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                        A handler declared in a
                        <a class="link" href="sql-syntax.html#begin-end" title="13.6.1&nbsp;BEGIN ... END Compound-Statement Syntax"><code class="literal">BEGIN ...
                            END</code></a> block is in scope only for the SQL statements
                        following the handler declarations in the block. If the
                        handler itself raises a condition, it cannot handle that
                        condition, nor can any other handlers declared in the block.
                        In the following example, handlers <code class="literal">H1</code> and
                        <code class="literal">H2</code> are in scope for conditions raised by
                        statements <em class="replaceable"><code>stmt1</code></em> and
                        <em class="replaceable"><code>stmt2</code></em>. But neither
                        <code class="literal">H1</code> nor <code class="literal">H2</code> are in scope
                        for conditions raised in the body of <code class="literal">H1</code>
                        or <code class="literal">H2</code>.
                    </p><p style="color:blue;">开始时声明的处理程序…结束块仅在块中处理程序声明之后的SQL语句的作用域中。如果处理程序本身引发一个条件，则它不能处理该条件，也不能处理块中声明的任何其他处理程序。在下面的示例中，处理程序h1和h2在语句stmt1和stmt2引发的条件的作用域中。但是h1和h2都不在h1和h2的范围内。</p><pre data-lang="sql" class="programlisting">BEGIN -- outer block
  DECLARE EXIT HANDLER FOR ...;  -- handler H1
  DECLARE EXIT HANDLER FOR ...;  -- handler H2
  <em class="replaceable"><code>stmt1</code></em>;
  <em class="replaceable"><code>stmt2</code></em>;
END;
</pre></li><li class="listitem"><p>
                        A handler is in scope only for the block in which it is
                        declared, and cannot be activated for conditions occurring
                        outside that block. In the following example, handler
                        <code class="literal">H1</code> is in scope for
                        <em class="replaceable"><code>stmt1</code></em> in the inner block, but not
                        for <em class="replaceable"><code>stmt2</code></em> in the outer block:
                    </p><p style="color:blue;">处理程序仅在声明它的块的作用域中，不能对该块之外发生的条件激活。在下面的示例中，处理程序h1在内部块中的stmt1的作用域中，而不是在外部块中的stmt2的作用域中：</p><pre data-lang="sql" class="programlisting">BEGIN -- outer block
  BEGIN -- inner block
    DECLARE EXIT HANDLER FOR ...;  -- handler H1
    <em class="replaceable"><code>stmt1</code></em>;
  END;
  <em class="replaceable"><code>stmt2</code></em>;
END;
</pre></li><li class="listitem"><p>
                        A handler can be specific or general. A specific handler is
                        for a MySQL error code, <code class="literal">SQLSTATE</code> value,
                        or condition name. A general handler is for a condition in
                        the <code class="literal">SQLWARNING</code>,
                        <code class="literal">SQLEXCEPTION</code>, or <code class="literal">NOT
                        FOUND</code> class. Condition specificity is related to
                        condition precedence, as described later.
                    </p><p style="color:blue;">处理程序可以是特定的或通用的。特定的处理程序用于mysql错误代码、sqlstate值或条件名称。常规处理程序用于SqlWarning、SqlException或Not Found类中的条件。如后文所述，条件特异性与条件优先级相关。</p></li></ul>
                </div>
                <p>
                    Multiple handlers can be declared in different scopes and with
                    different specificities. For example, there might be a specific
                    MySQL error code handler in an outer block, and a general
                    <code class="literal">SQLWARNING</code> handler in an inner block. Or
                    there might be handlers for a specific MySQL error code and the
                    general <code class="literal">SQLWARNING</code> class in the same block.
                </p><p style="color:blue;">多个处理程序可以在不同的作用域中声明，并且具有不同的特性。例如，在外部块中可能有一个特定的mysql错误代码处理程序，在内部块中可能有一个通用的sqlwarning处理程序。或者在同一个块中可能有特定mysql错误代码和一般sqlwarning类的处理程序。</p><p>
                Whether a handler is activated depends not only on its own scope
                and condition value, but on what other handlers are present.
                When a condition occurs in a stored program, the server searches
                for applicable handlers in the current scope (current
                <a class="link" href="sql-syntax.html#begin-end" title="13.6.1&nbsp;BEGIN ... END Compound-Statement Syntax"><code class="literal">BEGIN ...
                    END</code></a> block). If there are no applicable handlers, the
                search continues outward with the handlers in each successive
                containing scope (block). When the server finds one or more
                applicable handlers at a given scope, it chooses among them
                based on condition precedence:
            </p><p style="color:blue;">处理程序是否被激活不仅取决于它自己的作用域和条件值，还取决于存在哪些其他处理程序。当存储程序中出现条件时，服务器在当前作用域（当前开始…端块）。如果没有适用的处理程序，搜索将在每个后续包含作用域（块）中继续向外搜索处理程序。当服务器在给定的作用域中找到一个或多个适用的处理程序时，它将根据条件优先级在这些处理程序中进行选择：</p>
                <div class="itemizedlist">
                    <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                        A MySQL error code handler takes precedence over an
                        <code class="literal">SQLSTATE</code> value handler.
                    </p><p style="color:blue;">mysql错误代码处理程序优先于sqlstate值处理程序。</p></li><li class="listitem"><p>
                        An <code class="literal">SQLSTATE</code> value handler takes
                        precedence over general <code class="literal">SQLWARNING</code>,
                        <code class="literal">SQLEXCEPTION</code>, or <code class="literal">NOT
                        FOUND</code> handlers.
                    </p><p style="color:blue;">sqlstate值处理程序优先于常规sqlwarning、sqlexception或not found处理程序。</p></li><li class="listitem"><p>
                        An <code class="literal">SQLEXCEPTION</code> handler takes precedence
                        over an <code class="literal">SQLWARNING</code> handler.
                    </p><p style="color:blue;">SqlException处理程序优先于SqlWarning处理程序。</p></li><li class="listitem"><p>
                        It is possible to have several applicable handlers with the
                        same precedence. For example, a statement could generate
                        multiple warnings with different error codes, for each of
                        which an error-specific handler exists. In this case, the
                        choice of which handler the server activates is
                        nondeterministic, and may change depending on the
                        circumstances under which the condition occurs.
                    </p><p style="color:blue;">可能有多个具有相同优先级的适用处理程序。例如，语句可以生成具有不同错误代码的多个警告，每个错误都存在一个特定于错误的处理程序。在这种情况下，服务器激活哪个处理程序的选择是不确定的，并且可能会根据条件发生的环境而改变。</p></li></ul>
                </div>
                <p>
                    One implication of the handler selection rules is that if
                    multiple applicable handlers occur in different scopes, handlers
                    with the most local scope take precedence over handlers in outer
                    scopes, even over those for more specific conditions.
                </p><p style="color:blue;">处理程序选择规则的一个含义是，如果多个适用的处理程序出现在不同的作用域中，则具有最本地作用域的处理程序优先于外部作用域中的处理程序，甚至优先于更特定条件下的处理程序。</p><p>
                If there is no appropriate handler when a condition occurs, the
                action taken depends on the class of the condition:
            </p><p style="color:blue;">如果条件发生时没有适当的处理程序，则采取的操作取决于条件的类别：</p>
                <div class="itemizedlist">
                    <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                        For <code class="literal">SQLEXCEPTION</code> conditions, the stored
                        program terminates at the statement that raised the
                        condition, as if there were an <code class="literal">EXIT</code>
                        handler. If the program was called by another stored
                        program, the calling program handles the condition using the
                        handler selection rules applied to its own handlers.
                    </p><p style="color:blue;">对于SqlException条件，存储程序在引发该条件的语句处终止，就像存在一个退出处理程序一样。如果程序被另一个存储程序调用，则调用程序使用应用于其自身处理程序的处理程序选择规则来处理条件。</p></li><li class="listitem"><p>
                        For <code class="literal">SQLWARNING</code> conditions, the program
                        continues executing, as if there were a
                        <code class="literal">CONTINUE</code> handler.
                    </p><p style="color:blue;">对于sqlwarning条件，程序继续执行，就像有一个continue处理程序一样。</p></li><li class="listitem"><p>
                        For <code class="literal">NOT FOUND</code> conditions, if the
                        condition was raised normally, the action is
                        <code class="literal">CONTINUE</code>. If it was raised by
                        <a class="link" href="sql-syntax.html#signal" title="13.6.7.5&nbsp;SIGNAL Syntax"><code class="literal">SIGNAL</code></a> or
                        <a class="link" href="sql-syntax.html#resignal" title="13.6.7.4&nbsp;RESIGNAL Syntax"><code class="literal">RESIGNAL</code></a>, the action is
                        <code class="literal">EXIT</code>.
                    </p><p style="color:blue;">对于未找到的条件，如果条件正常引发，则操作将继续。如果它是由信号或resignal引起的，则操作是exit。</p></li></ul>
                </div>
                <p>
                    The following examples demonstrate how MySQL applies the handler
                    selection rules.
                </p><p style="color:blue;">下面的示例演示mysql如何应用处理程序选择规则。</p><p>
                This procedure contains two handlers, one for the specific
                <code class="literal">SQLSTATE</code> value (<code class="literal">'42S02'</code>)
                that occurs for attempts to drop a nonexistent table, and one
                for the general <code class="literal">SQLEXCEPTION</code> class:
            </p><p style="color:blue;">此过程包含两个处理程序，一个用于特定的SqLtValk值（'42s02），用于尝试删除一个不存在的表，一个用于一般的SqLeExver类：</p><pre data-lang="sql" class="programlisting">CREATE PROCEDURE p1()
BEGIN
  DECLARE CONTINUE HANDLER FOR SQLSTATE '42S02'
    SELECT 'SQLSTATE handler was activated' AS msg;
  DECLARE CONTINUE HANDLER FOR SQLEXCEPTION
    SELECT 'SQLEXCEPTION handler was activated' AS msg;

  DROP TABLE test.t;
END;
</pre><p>
                Both handlers are declared in the same block and have the same
                scope. However, <code class="literal">SQLSTATE</code> handlers take
                precedence over <code class="literal">SQLEXCEPTION</code> handlers, so if
                the table <code class="literal">t</code> is nonexistent, the
                <a class="link" href="sql-syntax.html#drop-table" title="13.1.29&nbsp;DROP TABLE Syntax"><code class="literal">DROP TABLE</code></a> statement raises a
                condition that activates the <code class="literal">SQLSTATE</code>
                handler:
            </p><p style="color:blue;">两个处理程序在同一块中声明，并且具有相同的作用域。但是，Sql状态处理器优先于Sql Exchange处理程序，因此如果表T不存在，DROP表语句会引发激活Sql状态处理程序的条件：</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>CALL p1();</code></strong>
+--------------------------------+
| msg                            |
+--------------------------------+
| SQLSTATE handler was activated |
+--------------------------------+
</pre><p>
                This procedure contains the same two handlers. But this time,
                the <a class="link" href="sql-syntax.html#drop-table" title="13.1.29&nbsp;DROP TABLE Syntax"><code class="literal">DROP TABLE</code></a> statement and
                <code class="literal">SQLEXCEPTION</code> handler are in an inner block
                relative to the <code class="literal">SQLSTATE</code> handler:
            </p><p style="color:blue;">此过程包含相同的两个处理程序。但这次，drop table语句和sqlexception处理程序位于相对于sqlstate处理程序的内部块中：</p><pre data-lang="sql" class="programlisting">CREATE PROCEDURE p2()
BEGIN -- outer block
    DECLARE CONTINUE HANDLER FOR SQLSTATE '42S02'
      SELECT 'SQLSTATE handler was activated' AS msg;
  BEGIN -- inner block
    DECLARE CONTINUE HANDLER FOR SQLEXCEPTION
      SELECT 'SQLEXCEPTION handler was activated' AS msg;

    DROP TABLE test.t; -- occurs within inner block
  END;
END;
</pre><p>
                In this case, the handler that is more local to where the
                condition occurs takes precedence. The
                <code class="literal">SQLEXCEPTION</code> handler activates, even though
                it is more general than the <code class="literal">SQLSTATE</code> handler:
            </p><p style="color:blue;">在这种情况下，更本地的处理程序优先于条件发生的位置。sqlexception处理程序激活，即使它比sqlstate处理程序更通用：</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>CALL p2();</code></strong>
+------------------------------------+
| msg                                |
+------------------------------------+
| SQLEXCEPTION handler was activated |
+------------------------------------+
</pre><p>
                In this procedure, one of the handlers is declared in a block
                inner to the scope of the <a class="link" href="sql-syntax.html#drop-table" title="13.1.29&nbsp;DROP TABLE Syntax"><code class="literal">DROP
                TABLE</code></a> statement:
            </p><p style="color:blue;">在此过程中，在drop table语句范围内的块中声明一个处理程序：</p><pre data-lang="sql" class="programlisting">CREATE PROCEDURE p3()
BEGIN -- outer block
  DECLARE CONTINUE HANDLER FOR SQLEXCEPTION
    SELECT 'SQLEXCEPTION handler was activated' AS msg;
  BEGIN -- inner block
    DECLARE CONTINUE HANDLER FOR SQLSTATE '42S02'
      SELECT 'SQLSTATE handler was activated' AS msg;
  END;

  DROP TABLE test.t; -- occurs within outer block
END;
</pre><p>
                Only the <code class="literal">SQLEXCEPTION</code> handler applies because
                the other one is not in scope for the condition raised by the
                <a class="link" href="sql-syntax.html#drop-table" title="13.1.29&nbsp;DROP TABLE Syntax"><code class="literal">DROP TABLE</code></a>:
            </p><p style="color:blue;">只有SqlException处理程序适用，因为另一个不在Drop表引发的条件的作用域中：</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>CALL p3();</code></strong>
+------------------------------------+
| msg                                |
+------------------------------------+
| SQLEXCEPTION handler was activated |
+------------------------------------+
</pre><p>
                In this procedure, both handlers are declared in a block inner
                to the scope of the <a class="link" href="sql-syntax.html#drop-table" title="13.1.29&nbsp;DROP TABLE Syntax"><code class="literal">DROP TABLE</code></a>
                statement:
            </p><p style="color:blue;">在此过程中，两个处理程序都在drop table语句范围内的块中声明：</p><pre data-lang="sql" class="programlisting">CREATE PROCEDURE p4()
BEGIN -- outer block
  BEGIN -- inner block
    DECLARE CONTINUE HANDLER FOR SQLEXCEPTION
      SELECT 'SQLEXCEPTION handler was activated' AS msg;
    DECLARE CONTINUE HANDLER FOR SQLSTATE '42S02'
      SELECT 'SQLSTATE handler was activated' AS msg;
  END;

  DROP TABLE test.t; -- occurs within outer block
END;
</pre><p>
                Neither handler applies because they are not in scope for the
                <a class="link" href="sql-syntax.html#drop-table" title="13.1.29&nbsp;DROP TABLE Syntax"><code class="literal">DROP TABLE</code></a>. The condition raised
                by the statement goes unhandled and terminates the procedure
                with an error:
            </p><p style="color:blue;">两个处理程序都不适用，因为它们不在drop表的作用域中。语句引发的条件未经处理，并以错误终止过程：</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>CALL p4();</code></strong>
ERROR 1051 (42S02): Unknown table 'test.t'
</pre>
            </div>
            <div class="section">
                <div class="titlepage">
                    <div>
                        <div>
                            <h4 class="title"><a name="diagnostics-area"></a>13.6.7.7&nbsp;The MySQL Diagnostics Area</h4>

                        </div>

                    </div>

                </div>
                <p>
                    SQL statements produce diagnostic information that populates the
                    diagnostics area. Standard SQL has a diagnostics area stack,
                    containing a diagnostics area for each nested execution context.
                    Standard SQL also supports
                    <a class="link" href="sql-syntax.html#get-diagnostics" title="13.6.7.3&nbsp;GET DIAGNOSTICS Syntax"><code class="literal">GET STACKED
                        DIAGNOSTICS</code></a> syntax for referring to the second
                    diagnostics area during condition handler execution. MySQL
                    supports the <code class="literal">STACKED</code> keyword as of MySQL 5.7.
                    Before that, MySQL does not support <code class="literal">STACKED</code>;
                    there is a single diagnostics area containing information from
                    the most recent statement that wrote to it.
                </p><p style="color:blue;">SQL语句生成填充诊断区域的诊断信息。标准sql有一个诊断区域堆栈，其中包含每个嵌套执行上下文的诊断区域。标准sql还支持get stacked diagnostics语法，用于在条件处理程序执行期间引用第二个诊断区域。mysql从mysql 5.7开始支持stacked关键字。在此之前，mysql不支持堆栈；只有一个诊断区域，其中包含最近写入它的语句的信息。</p><p>
                The following discussion describes the structure of the
                diagnostics area in MySQL, the information items recognized by
                MySQL, how statements clear and set the diagnostics area, and
                how diagnostics areas are pushed to and popped from the stack.
            </p><p style="color:blue;">下面的讨论描述mysql中诊断区域的结构、mysql识别的信息项、语句如何清除和设置诊断区域，以及如何将诊断区域推送到堆栈中并从堆栈中弹出。</p>
                <div class="itemizedlist">
                    <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><a class="xref" href="sql-syntax.html#diagnostics-area-structure" title="Diagnostics Area Structure">Diagnostics Area Structure</a></p><p style="color:blue;">诊断区域结构</p></li><li class="listitem"><p><a class="xref" href="sql-syntax.html#diagnostics-area-information-items" title="Diagnostics Area Information Items">Diagnostics Area Information Items</a></p><p style="color:blue;">诊断区域信息项</p></li><li class="listitem"><p><a class="xref" href="sql-syntax.html#diagnostics-area-populating" title="How the Diagnostics Area is Cleared and Populated">How the Diagnostics Area is Cleared and Populated</a></p><p style="color:blue;">如何清除和填充诊断区域</p></li><li class="listitem"><p><a class="xref" href="sql-syntax.html#diagnostics-area-stack" title="How the Diagnostics Area Stack Works">How the Diagnostics Area Stack Works</a></p><p style="color:blue;">诊断区域堆栈的工作原理</p></li><li class="listitem"><p><a class="xref" href="sql-syntax.html#diagnostics-area-system-variables" title="Diagnostics Area-Related System Variables">Diagnostics Area-Related System Variables</a></p><p style="color:blue;">诊断区域相关系统变量</p></li></ul>
                </div>

                <div class="simplesect">

                    <div class="titlepage">
                        <div>

                            <div class="simple">
                                <h5 class="title"><a name="diagnostics-area-structure"></a>Diagnostics Area Structure</h5>

                            </div>

                        </div>

                    </div>
                    <p>
                        The diagnostics area contains two kinds of information:
                    </p><p style="color:blue;">诊断区域包含两种信息：</p>
                    <div class="itemizedlist">
                        <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                            Statement information, such as the number of conditions
                            that occurred or the affected-rows count.
                        </p><p style="color:blue;">语句信息，例如发生的条件数或受影响的行数。</p></li><li class="listitem"><p>
                            Condition information, such as the error code and message.
                            If a statement raises multiple conditions, this part of
                            the diagnostics area has a condition area for each one. If
                            a statement raises no conditions, this part of the
                            diagnostics area is empty.
                        </p><p style="color:blue;">条件信息，如错误代码和消息。如果一个语句引发多个条件，则诊断区域的这一部分对每个条件都有一个条件区域。如果语句不引发任何条件，则诊断区域的此部分为空。</p></li></ul>
                    </div>
                    <p>
                        For a statement that produces three conditions, the
                        diagnostics area contains statement and condition information
                        like this:
                    </p><p style="color:blue;">对于生成三个条件的语句，诊断区域包含如下语句和条件信息：</p><pre data-lang="none" class="programlisting">Statement information:
  row count
  ... other statement information items ...
Condition area list:
  Condition area 1:
    error code for condition 1
    error message for condition 1
    ... other condition information items ...
  Condition area 2:
    error code for condition 2:
    error message for condition 2
    ... other condition information items ...
  Condition area 3:
    error code for condition 3
    error message for condition 3
    ... other condition information items ...
</pre>
                </div>
                <div class="simplesect">
                    <div class="titlepage">
                        <div>
                            <div class="simple">
                                <h5 class="title"><a name="diagnostics-area-information-items"></a>Diagnostics Area Information Items</h5>

                            </div>

                        </div>

                    </div>
                    <p>
                        The diagnostics area contains statement and condition
                        information items. Numeric items are integers. The character
                        set for character items is UTF-8. No item can be
                        <code class="literal">NULL</code>. If a statement or condition item is
                        not set by a statement that populates the diagnostics area,
                        its value is 0 or the empty string, depending on the item data
                        type.
                    </p><p style="color:blue;">诊断区域包含语句和条件信息项。数字项是整数。字符项的字符集是utf-8。任何项目都不能为空。如果语句或条件项不是由填充诊断区域的语句设置的，则其值为0或空字符串，具体取决于项数据类型。</p><p>
                    The statement information part of the diagnostics area
                    contains these items:
                </p><p style="color:blue;">诊断区域的语句信息部分包含以下项：</p>
                    <div class="itemizedlist">
                        <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                            <code class="literal">NUMBER</code>: An integer indicating the
                            number of condition areas that have information.
                        </p><p style="color:blue;">数字：一个整数，表示有信息的条件区域的数目。</p></li><li class="listitem"><p>
                            <code class="literal">ROW_COUNT</code>: An integer indicating the
                            number of rows affected by the statement.
                            <code class="literal">ROW_COUNT</code> has the same value as the
                            <a class="link" href="functions.html#function_row-count"><code class="literal">ROW_COUNT()</code></a> function (see
                            <a class="xref" href="functions.html#information-functions" title="12.15&nbsp;Information Functions">Section&nbsp;12.15, “Information Functions”</a>).
                        </p><p style="color:blue;">row_count：表示受语句影响的行数的整数。row_count与row_count（）函数具有相同的值（请参见第12.15节“信息函数”）。</p></li></ul>
                    </div>
                    <p>
                        The condition information part of the diagnostics area
                        contains a condition area for each condition. Condition areas
                        are numbered from 1 to the value of the
                        <code class="literal">NUMBER</code> statement condition item. If
                        <code class="literal">NUMBER</code> is 0, there are no condition areas.
                    </p><p style="color:blue;">诊断区域的条件信息部分包含每个条件的条件区域。条件区域的编号从1到数字语句条件项的值。如果数字为0，则没有条件区域。</p><p>
                    Each condition area contains the items in the following list.
                    All items are standard SQL except
                    <code class="literal">MYSQL_ERRNO</code>, which is a MySQL extension.
                    The definitions apply for conditions generated other than by a
                    signal (that is, by a <a class="link" href="sql-syntax.html#signal" title="13.6.7.5&nbsp;SIGNAL Syntax"><code class="literal">SIGNAL</code></a> or
                    <a class="link" href="sql-syntax.html#resignal" title="13.6.7.4&nbsp;RESIGNAL Syntax"><code class="literal">RESIGNAL</code></a> statement). For
                    nonsignal conditions, MySQL populates only those condition
                    items not described as always empty. The effects of signals on
                    the condition area are described later.
                </p><p style="color:blue;">每个条件区域包含以下列表中的项。除了mysql的扩展mysql，所有项都是标准sql。这些定义适用于由信号（即，由信号或resignal语句）以外生成的条件。对于非信号条件，mysql只填充那些未描述为始终为空的条件项。稍后将描述信号对条件区域的影响。</p>
                    <div class="itemizedlist">
                        <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                            <code class="literal">CLASS_ORIGIN</code>: A string containing the
                            class of the <code class="literal">RETURNED_SQLSTATE</code> value.
                            If the <code class="literal">RETURNED_SQLSTATE</code> value begins
                            with a class value defined in SQL standards document ISO
                            9075-2 (section 24.1, SQLSTATE),
                            <code class="literal">CLASS_ORIGIN</code> is <code class="literal">'ISO
                            9075'</code>. Otherwise,
                            <code class="literal">CLASS_ORIGIN</code> is
                            <code class="literal">'MySQL'</code>.
                        </p><p style="color:blue;">class_origin：包含返回的_sqlstate值的类的字符串。如果返回的_sqlstate值以SQL标准文档ISO 9075-2（第24.1节，sqlstate）中定义的类值开头，则类_的来源为“ISO 9075”。否则，类的源代码是“mysql”。</p></li><li class="listitem"><p>
                            <code class="literal">SUBCLASS_ORIGIN</code>: A string containing
                            the subclass of the <code class="literal">RETURNED_SQLSTATE</code>
                            value. If <code class="literal">CLASS_ORIGIN</code> is <code class="literal">'ISO
                            9075'</code> or <code class="literal">RETURNED_SQLSTATE</code>
                            ends with <code class="literal">'000'</code>,
                            <code class="literal">SUBCLASS_ORIGIN</code> is <code class="literal">'ISO
                            9075'</code>. Otherwise,
                            <code class="literal">SUBCLASS_ORIGIN</code> is
                            <code class="literal">'MySQL'</code>.
                        </p><p style="color:blue;">subclass_origin：包含返回的_sqlstate值的子类的字符串。如果类起源是“iso 9075”或返回的“sqlstate”以“000”结尾，则子类起源是“iso9075”。否则，子类'u origin是'mysql'。</p></li><li class="listitem"><p>
                            <code class="literal">RETURNED_SQLSTATE</code>: A string that
                            indicates the <code class="literal">SQLSTATE</code> value for the
                            condition.
                        </p><p style="color:blue;">返回的_sqlstate:表示条件的sqlstate值的字符串。</p></li><li class="listitem"><p>
                            <code class="literal">MESSAGE_TEXT</code>: A string that indicates
                            the error message for the condition.
                        </p><p style="color:blue;">消息文本：表示条件错误消息的字符串。</p></li><li class="listitem"><p>
                            <code class="literal">MYSQL_ERRNO</code>: An integer that indicates
                            the MySQL error code for the condition.
                        </p><p style="color:blue;">mysql_errno：表示条件的mysql错误代码的整数。</p></li><li class="listitem"><p>
                            <code class="literal">CONSTRAINT_CATALOG</code>,
                            <code class="literal">CONSTRAINT_SCHEMA</code>,
                            <code class="literal">CONSTRAINT_NAME</code>: Strings that indicate
                            the catalog, schema, and name for a violated constraint.
                            They are always empty.
                        </p><p style="color:blue;">constraint_catalog，constraint_schema，constraint_name：表示违反约束的目录、架构和名称的字符串。它们总是空的。</p></li><li class="listitem"><p>
                            <code class="literal">CATALOG_NAME</code>,
                            <code class="literal">SCHEMA_NAME</code>,
                            <code class="literal">TABLE_NAME</code>,
                            <code class="literal">COLUMN_NAME</code>: Strings that indicate the
                            catalog, schema, table, and column related to the
                            condition. They are always empty.
                        </p><p style="color:blue;">catalog_name，schema_name，table_name，column_name：表示与条件相关的目录、架构、表和列的字符串。它们总是空的。</p></li><li class="listitem"><p>
                            <code class="literal">CURSOR_NAME</code>: A string that indicates
                            the cursor name. This is always empty.
                        </p><p style="color:blue;">游标名：一个表示游标名的字符串。这总是空的。</p></li></ul>
                    </div>
                    <p>
                        For the <code class="literal">RETURNED_SQLSTATE</code>,
                        <code class="literal">MESSAGE_TEXT</code>, and
                        <code class="literal">MYSQL_ERRNO</code> values for particular errors,
                        see <a class="xref" href="error-handling.html#server-error-reference" title="B.3.1&nbsp;Server Error Message Reference">Section&nbsp;B.3.1, “Server Error Message Reference”</a>.
                    </p><p style="color:blue;">有关返回的特定错误的sqlstate、message和mysql errno值，请参阅第B.3.1节“服务器错误消息参考”。</p><p>
                    If a <a class="link" href="sql-syntax.html#signal" title="13.6.7.5&nbsp;SIGNAL Syntax"><code class="literal">SIGNAL</code></a> (or
                    <a class="link" href="sql-syntax.html#resignal" title="13.6.7.4&nbsp;RESIGNAL Syntax"><code class="literal">RESIGNAL</code></a>) statement populates
                    the diagnostics area, its <code class="literal">SET</code> clause can
                    assign to any condition information item except
                    <code class="literal">RETURNED_SQLSTATE</code> any value that is legal
                    for the item data type. <a class="link" href="sql-syntax.html#signal" title="13.6.7.5&nbsp;SIGNAL Syntax"><code class="literal">SIGNAL</code></a>
                    also sets the <code class="literal">RETURNED_SQLSTATE</code> value, but
                    not directly in its <code class="literal">SET</code> clause. That value
                    comes from the <a class="link" href="sql-syntax.html#signal" title="13.6.7.5&nbsp;SIGNAL Syntax"><code class="literal">SIGNAL</code></a> statement
                    <code class="literal">SQLSTATE</code> argument.
                </p><p style="color:blue;">如果signal（或resignal）语句填充诊断区域，则其set子句可以为任何条件信息项分配任何合法的项数据类型值，但返回的值除外。signal还设置返回的_sqlstate值，但不直接在其set子句中设置。该值来自信号语句sqlstate参数。</p><p>
                    <a class="link" href="sql-syntax.html#signal" title="13.6.7.5&nbsp;SIGNAL Syntax"><code class="literal">SIGNAL</code></a> also sets statement
                    information items. It sets <code class="literal">NUMBER</code> to 1. It
                    sets <code class="literal">ROW_COUNT</code> to −1 for errors and 0
                    otherwise.
                </p><p style="color:blue;">signal还设置语句信息项。它把数字设为1。它将错误的行计数设置为-1，否则设置为0。</p>
                </div>
                <div class="simplesect">
                    <div class="titlepage">
                        <div>
                            <div class="simple">
                                <h5 class="title"><a name="diagnostics-area-populating"></a>How the Diagnostics Area is Cleared and Populated</h5>

                            </div>

                        </div>

                    </div>
                    <p>
                        Nondiagnostic SQL statements populate the diagnostics area
                        automatically, and its contents can be set explicitly with the
                        <a class="link" href="sql-syntax.html#signal" title="13.6.7.5&nbsp;SIGNAL Syntax"><code class="literal">SIGNAL</code></a> and
                        <a class="link" href="sql-syntax.html#resignal" title="13.6.7.4&nbsp;RESIGNAL Syntax"><code class="literal">RESIGNAL</code></a> statements. The
                        diagnostics area can be examined with <a class="link" href="sql-syntax.html#get-diagnostics" title="13.6.7.3&nbsp;GET DIAGNOSTICS Syntax"><code class="literal">GET
                        DIAGNOSTICS</code></a> to extract specific items, or with
                        <a class="link" href="sql-syntax.html#show-warnings" title="13.7.5.40&nbsp;SHOW WARNINGS Syntax"><code class="literal">SHOW WARNINGS</code></a> or
                        <a class="link" href="sql-syntax.html#show-errors" title="13.7.5.17&nbsp;SHOW ERRORS Syntax"><code class="literal">SHOW ERRORS</code></a> to see conditions
                        or errors.
                    </p><p style="color:blue;">非诊断性sql语句自动填充诊断区域，其内容可以用signal和resignal语句显式设置。可以使用get diagnostics提取特定项，或使用show warnings或show errors查看条件或错误来检查诊断区域。</p><p>
                    SQL statements clear and set the diagnostics area as follows:
                </p><p style="color:blue;">SQL语句清除并按如下方式设置诊断区域：</p>
                    <div class="itemizedlist">
                        <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                            When the server starts executing a statement after parsing
                            it, it clears the diagnostics area for nondiagnostic
                            statements. Diagnostic statements do not clear the
                            diagnostics area. These statements are diagnostic:
                        </p><p style="color:blue;">当服务器在分析语句后开始执行语句时，它会清除非诊断语句的诊断区域。诊断语句不清除诊断区域。这些陈述是诊断性的：</p>
                            <div class="itemizedlist">
                                <ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
                                    <a class="link" href="sql-syntax.html#get-diagnostics" title="13.6.7.3&nbsp;GET DIAGNOSTICS Syntax"><code class="literal">GET DIAGNOSTICS</code></a>
                                </p><p style="color:blue;">获取诊断</p></li><li class="listitem"><p>
                                    <a class="link" href="sql-syntax.html#show-errors" title="13.7.5.17&nbsp;SHOW ERRORS Syntax"><code class="literal">SHOW ERRORS</code></a>
                                </p><p style="color:blue;">显示错误</p></li><li class="listitem"><p>
                                    <a class="link" href="sql-syntax.html#show-warnings" title="13.7.5.40&nbsp;SHOW WARNINGS Syntax"><code class="literal">SHOW WARNINGS</code></a>
                                </p><p style="color:blue;">显示警告</p></li></ul>
                            </div>
                        </li><li class="listitem"><p>
                            If a statement raises a condition, the diagnostics area is
                            cleared of conditions that belong to earlier statements.
                            The exception is that conditions raised by
                            <a class="link" href="sql-syntax.html#get-diagnostics" title="13.6.7.3&nbsp;GET DIAGNOSTICS Syntax"><code class="literal">GET DIAGNOSTICS</code></a> and
                            <a class="link" href="sql-syntax.html#resignal" title="13.6.7.4&nbsp;RESIGNAL Syntax"><code class="literal">RESIGNAL</code></a> are added to the
                            diagnostics area without clearing it.
                        </p><p style="color:blue;">如果语句引发条件，则诊断区域将清除属于先前语句的条件。例外情况是，get diagnostics和resignal引发的条件将添加到诊断区域而不清除它。</p></li></ul>
                    </div>
                    <p>
                        Thus, even a statement that does not normally clear the
                        diagnostics area when it begins executing clears it if the
                        statement raises a condition.
                    </p><p style="color:blue;">因此，即使在诊断区域开始执行时通常不清除该区域的语句在语句引发条件时也会清除该区域。</p><p>
                    The following example shows the effect of various statements
                    on the diagnostics area, using <a class="link" href="sql-syntax.html#show-warnings" title="13.7.5.40&nbsp;SHOW WARNINGS Syntax"><code class="literal">SHOW
                    WARNINGS</code></a> to display information about conditions
                    stored there.
                </p><p style="color:blue;">下面的示例显示各种语句对诊断区域的影响，使用show warnings显示存储在诊断区域中的条件的信息。</p><p>
                    This <a class="link" href="sql-syntax.html#drop-table" title="13.1.29&nbsp;DROP TABLE Syntax"><code class="literal">DROP TABLE</code></a> statement
                    clears the diagnostics area and populates it when the
                    condition occurs:
                </p><p style="color:blue;">此DROP TABLE语句清除诊断区域，并在条件出现时填充：</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>DROP TABLE IF EXISTS test.no_such_table;</code></strong>
Query OK, 0 rows affected, 1 warning (0.01 sec)

mysql&gt; <strong class="userinput"><code>SHOW WARNINGS;</code></strong>
+-------+------+------------------------------------+
| Level | Code | Message                            |
+-------+------+------------------------------------+
| Note  | 1051 | Unknown table 'test.no_such_table' |
+-------+------+------------------------------------+
1 row in set (0.00 sec)
</pre><p>
                    This
                    <a class="link" href="sql-syntax.html#set-variable" title="13.7.4.1&nbsp;SET Syntax for Variable Assignment"><code class="literal">SET</code></a>
                    statement generates an error, so it clears and populates the
                    diagnostics area:
                </p><p style="color:blue;">此SET语句生成错误，因此它清除并填充诊断区域：</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>SET @x = @@x;</code></strong>
ERROR 1193 (HY000): Unknown system variable 'x'

mysql&gt; <strong class="userinput"><code>SHOW WARNINGS;</code></strong>
+-------+------+-----------------------------+
| Level | Code | Message                     |
+-------+------+-----------------------------+
| Error | 1193 | Unknown system variable 'x' |
+-------+------+-----------------------------+
1 row in set (0.00 sec)
</pre><p>
                    The previous
                    <a class="link" href="sql-syntax.html#set-variable" title="13.7.4.1&nbsp;SET Syntax for Variable Assignment"><code class="literal">SET</code></a>
                    statement produced a single condition, so 1 is the only valid
                    condition number for <a class="link" href="sql-syntax.html#get-diagnostics" title="13.6.7.3&nbsp;GET DIAGNOSTICS Syntax"><code class="literal">GET
                    DIAGNOSTICS</code></a> at this point. The following statement
                    uses a condition number of 2, which produces a warning that is
                    added to the diagnostics area without clearing it:
                </p><p style="color:blue;">前一个set语句生成了一个条件，因此1是此时get diagnostics的唯一有效条件号。以下语句使用条件编号2，它将生成一个警告，该警告将添加到诊断区域而不清除该警告：</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>GET DIAGNOSTICS CONDITION 2 @p = MESSAGE_TEXT;</code></strong>
Query OK, 0 rows affected, 1 warning (0.00 sec)

mysql&gt; <strong class="userinput"><code>SHOW WARNINGS;</code></strong>
+-------+------+------------------------------+
| Level | Code | Message                      |
+-------+------+------------------------------+
| Error | 1193 | Unknown system variable 'xx' |
| Error | 1753 | Invalid condition number     |
+-------+------+------------------------------+
2 rows in set (0.00 sec)
</pre><p>
                    Now there are two conditions in the diagnostics area, so the
                    same <a class="link" href="sql-syntax.html#get-diagnostics" title="13.6.7.3&nbsp;GET DIAGNOSTICS Syntax"><code class="literal">GET DIAGNOSTICS</code></a> statement
                    succeeds:
                </p><p style="color:blue;">现在诊断区域中有两个条件，因此相同的get diagnostics语句成功：</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>GET DIAGNOSTICS CONDITION 2 @p = MESSAGE_TEXT;</code></strong>
Query OK, 0 rows affected (0.00 sec)

mysql&gt; <strong class="userinput"><code>SELECT @p;</code></strong>
+--------------------------+
| @p                       |
+--------------------------+
| Invalid condition number |
+--------------------------+
1 row in set (0.01 sec)
</pre>
                </div>
                <div class="simplesect">
                    <div class="titlepage">
                        <div>
                            <div class="simple">
                                <h5 class="title"><a name="diagnostics-area-stack"></a>How the Diagnostics Area Stack Works</h5>

                            </div>

                        </div>

                    </div>
                    <p>
                        When a push to the diagnostics area stack occurs, the first
                        (current) diagnostics area becomes the second (stacked)
                        diagnostics area and a new current diagnostics area is created
                        as a copy of it. Diagnostics areas are pushed to and popped
                        from the stack under the following circumstances:
                    </p><p style="color:blue;">当推送到诊断区域堆栈时，第一个（当前）诊断区域变为第二个（堆栈）诊断区域，并创建一个新的当前诊断区域作为其副本。在以下情况下，将诊断区域推送到堆栈并从堆栈弹出：</p>
                    <div class="itemizedlist">
                        <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                            Execution of a stored program
                        </p><p style="color:blue;">存储程序的执行</p><p>
                            A push occurs before the program executes and a pop occurs
                            afterward. If the stored program ends while handlers are
                            executing, there can be more than one diagnostics area to
                            pop; this occurs due to an exception for which there are
                            no appropriate handlers or due to
                            <a class="link" href="sql-syntax.html#return" title="13.6.5.7&nbsp;RETURN Syntax"><code class="literal">RETURN</code></a> in the handler.
                        </p><p style="color:blue;">推送发生在程序执行之前，弹出发生在程序执行之后。如果存储的程序在处理程序执行时结束，则可能会弹出多个诊断区域；这是由于没有适当的处理程序或处理程序中返回了异常所致。</p><p>
                            Any warning or error conditions in the popped diagnostics
                            areas then are added to the current diagnostics area,
                            except that, for triggers, only errors are added. When the
                            stored program ends, the caller sees these conditions in
                            its current diagonstics area.
                        </p><p style="color:blue;">弹出的诊断区域中的任何警告或错误条件都将添加到当前诊断区域，但对于触发器，仅添加错误。当存储程序结束时，调用者在其当前诊断区域中看到这些条件。</p></li><li class="listitem"><p>
                            Execution of a condition handler within a stored program
                        </p><p style="color:blue;">在存储程序中执行条件处理程序</p><p>
                            When a push occurs as a result of condition handler
                            activation, the stacked diagnostics area is the area that
                            was current within the stored program prior to the push.
                            The new now-current diagnostics area is the handler's
                            current diagnostics area.
                            <a class="link" href="sql-syntax.html#get-diagnostics" title="13.6.7.3&nbsp;GET DIAGNOSTICS Syntax"><code class="literal">GET
                                [CURRENT] DIAGNOSTICS</code></a> and
                            <a class="link" href="sql-syntax.html#get-diagnostics" title="13.6.7.3&nbsp;GET DIAGNOSTICS Syntax"><code class="literal">GET
                                STACKED DIAGNOSTICS</code></a> can be used within the
                            handler to access the contents of the current (handler)
                            and stacked (stored program) diagnostics areas. Initially,
                            they return the same result, but statements executing
                            within the handler modify the current diagnostics area,
                            clearing and setting its contents according to the normal
                            rules (see <a class="xref" href="sql-syntax.html#diagnostics-area-populating" title="How the Diagnostics Area is Cleared and Populated">How the Diagnostics Area is Cleared and Populated</a>).
                            The stacked diagnostics area cannot be modified by
                            statements executing within the handler except
                            <a class="link" href="sql-syntax.html#resignal" title="13.6.7.4&nbsp;RESIGNAL Syntax"><code class="literal">RESIGNAL</code></a>.
                        </p><p style="color:blue;">当条件处理程序激活后发生推送时，堆栈诊断区域是推送之前存储程序中的当前区域。新的当前诊断区域是处理程序的当前诊断区域。get[current]diagnostics和get stacked diagnostics可在处理程序内用于访问当前（处理程序）和堆栈（存储程序）诊断区域的内容。最初，它们返回相同的结果，但是在处理程序内执行的语句修改当前诊断区域，根据正常规则清除并设置其内容（请参阅如何清除和填充诊断区域）。除了resignal之外，在处理程序内执行的语句不能修改堆栈诊断区域。</p><p>
                            If the handler executes successfully, the current
                            (handler) diagnostics area is popped and the stacked
                            (stored program) diagnostics area again becomes the
                            current diagnostics area. Conditions added to the handler
                            diagnostics area during handler execution are added to the
                            current diagnostics area.
                        </p><p style="color:blue;">如果处理程序执行成功，则弹出当前（处理程序）诊断区域，堆栈（存储程序）诊断区域再次成为当前诊断区域。在处理程序执行期间添加到处理程序诊断区域的条件将添加到当前诊断区域。</p></li><li class="listitem"><p>
                            Execution of <a class="link" href="sql-syntax.html#resignal" title="13.6.7.4&nbsp;RESIGNAL Syntax"><code class="literal">RESIGNAL</code></a>
                        </p><p style="color:blue;">执行辞职</p><p>
                            The <a class="link" href="sql-syntax.html#resignal" title="13.6.7.4&nbsp;RESIGNAL Syntax"><code class="literal">RESIGNAL</code></a> statement
                            passes on the error condition information that is
                            available during execution of a condition handler within a
                            compound statement inside a stored program.
                            <a class="link" href="sql-syntax.html#resignal" title="13.6.7.4&nbsp;RESIGNAL Syntax"><code class="literal">RESIGNAL</code></a> may change some or
                            all information before passing it on, modifying the
                            diagnostics stack as described in
                            <a class="xref" href="sql-syntax.html#resignal" title="13.6.7.4&nbsp;RESIGNAL Syntax">Section&nbsp;13.6.7.4, “RESIGNAL Syntax”</a>.
                        </p><p style="color:blue;">resignal语句传递在存储程序中的复合语句中执行条件处理程序时可用的错误条件信息。resignal可以在传递之前更改部分或全部信息，修改诊断堆栈，如第13.6.7.4节“resignal语法”所述。</p></li></ul>
                    </div>

                </div>
                <div class="simplesect">
                    <div class="titlepage">
                        <div>
                            <div class="simple">
                                <h5 class="title"><a name="diagnostics-area-system-variables"></a>Diagnostics Area-Related System Variables</h5>

                            </div>

                        </div>

                    </div>
                    <p>
                        Certain system variables control or are related to some
                        aspects of the diagnostics area:
                    </p><p style="color:blue;">某些系统变量控制或与诊断领域的某些方面相关：</p>
                    <div class="itemizedlist">
                        <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                            <a class="link" href="server-administration.html#sysvar_max_error_count"><code class="literal">max_error_count</code></a> controls
                            the number of condition areas in the diagnostics area. If
                            more conditions than this occur, MySQL silently discards
                            information for the excess conditions. (Conditions added
                            by <a class="link" href="sql-syntax.html#resignal" title="13.6.7.4&nbsp;RESIGNAL Syntax"><code class="literal">RESIGNAL</code></a> are always
                            added, with older conditions being discarded as necessary
                            to make room.)
                        </p><p style="color:blue;">最大错误计数控制诊断区域中条件区域的数量。如果出现更多的情况，mysql会自动丢弃多余条件的信息。（始终添加resignal添加的条件，根据需要丢弃旧条件以腾出空间。）</p></li><li class="listitem"><p>
                            <a class="link" href="server-administration.html#sysvar_warning_count"><code class="literal">warning_count</code></a> indicates
                            the number of conditions that occurred. This includes
                            errors, warnings, and notes. Normally,
                            <code class="literal">NUMBER</code> and
                            <a class="link" href="server-administration.html#sysvar_warning_count"><code class="literal">warning_count</code></a> are the
                            same. However, as the number of conditions generated
                            exceeds <a class="link" href="server-administration.html#sysvar_max_error_count"><code class="literal">max_error_count</code></a>,
                            the value of
                            <a class="link" href="server-administration.html#sysvar_warning_count"><code class="literal">warning_count</code></a> continues
                            to rise whereas <code class="literal">NUMBER</code> remains capped
                            at <a class="link" href="server-administration.html#sysvar_max_error_count"><code class="literal">max_error_count</code></a>
                            because no additional conditions are stored in the
                            diagnostics area.
                        </p><p style="color:blue;">警告计数指示发生的条件数。这包括错误、警告和注释。通常，数字和警告计数是相同的。但是，由于生成的条件数超过了max_error_count，warning_count的值将继续增加，而number将保持在max_error_count的上限，因为诊断区域中没有存储其他条件。</p></li><li class="listitem"><p>
                            <a class="link" href="server-administration.html#sysvar_error_count"><code class="literal">error_count</code></a> indicates the
                            number of errors that occurred. This value includes
                            <span class="quote">“<span class="quote">not found</span>”</span> and exception conditions, but
                            excludes warnings and notes. Like
                            <a class="link" href="server-administration.html#sysvar_warning_count"><code class="literal">warning_count</code></a>, its value
                            can exceed
                            <a class="link" href="server-administration.html#sysvar_max_error_count"><code class="literal">max_error_count</code></a>.
                        </p><p style="color:blue;">错误计数指示发生的错误数。此值包括“未找到”和异常条件，但不包括警告和注释。与警告计数一样，它的值可以超过最大错误计数。</p></li><li class="listitem"><p>
                            If the <a class="link" href="server-administration.html#sysvar_sql_notes"><code class="literal">sql_notes</code></a> system
                            variable is set to 0, notes are not stored and do not
                            increment <a class="link" href="server-administration.html#sysvar_warning_count"><code class="literal">warning_count</code></a>.
                        </p><p style="color:blue;">如果sql_notes系统变量设置为0，则不存储notes，并且不增加警告计数。</p></li></ul>
                    </div>
                    <p>
                        Example: If <a class="link" href="server-administration.html#sysvar_max_error_count"><code class="literal">max_error_count</code></a>
                        is 10, the diagnostics area can contain a maximum of 10
                        condition areas. Suppose that a statement raises 20
                        conditions, 12 of which are errors. In that case, the
                        diagnostics area contains the first 10 conditions,
                        <code class="literal">NUMBER</code> is 10,
                        <a class="link" href="server-administration.html#sysvar_warning_count"><code class="literal">warning_count</code></a> is 20, and
                        <a class="link" href="server-administration.html#sysvar_error_count"><code class="literal">error_count</code></a> is 12.
                    </p><p style="color:blue;">示例：如果Max GyrRoRySub计数为10，则诊断区域最多可以包含10个条件区域。假设一个语句提出了20个条件，其中12个是错误的。在这种情况下，诊断区域包含前10个条件，数字为10，警告计数为20，错误计数为12。</p><p>
                    Changes to the value of
                    <a class="link" href="server-administration.html#sysvar_max_error_count"><code class="literal">max_error_count</code></a> have no
                    effect until the next attempt to modify the diagnostics area.
                    If the diagnostics area contains 10 condition areas and
                    <a class="link" href="server-administration.html#sysvar_max_error_count"><code class="literal">max_error_count</code></a> is set to 5,
                    that has no immediate effect on the size or content of the
                    diagnostics area.
                </p><p style="color:blue;">对max_error_count值的更改在下次尝试修改诊断区域之前无效。如果诊断区域包含10个条件区域，并且最大错误计数设置为5，则不会立即影响诊断区域的大小或内容。</p>
                </div>

            </div>
            <div class="section">
                <div class="titlepage">
                    <div>
                        <div>
                            <h4 class="title"><a name="conditions-and-parameters"></a>13.6.7.8&nbsp;Condition Handling and OUT or INOUT Parameters</h4>

                        </div>

                    </div>

                </div>
                <a class="indexterm" name="idm140286830303392"></a><a class="indexterm" name="idm140286830301904"></a><a class="indexterm" name="idm140286830300416"></a><a class="indexterm" name="idm140286830298928"></a><p>
                If a stored procedure exits with an unhandled exception,
                modified values of <code class="literal">OUT</code> and
                <code class="literal">INOUT</code> parameters are not propogated back to
                the caller.
            </p><p style="color:blue;">如果存储过程以未处理异常退出，则OUT和IOUT参数的修改值不会被转发回调用方。</p><p>
                If an exception is handled by a <code class="literal">CONTINUE</code> or
                <code class="literal">EXIT</code> handler that contains a
                <a class="link" href="sql-syntax.html#resignal" title="13.6.7.4&nbsp;RESIGNAL Syntax"><code class="literal">RESIGNAL</code></a> statement, execution of
                <a class="link" href="sql-syntax.html#resignal" title="13.6.7.4&nbsp;RESIGNAL Syntax"><code class="literal">RESIGNAL</code></a> pops the Diagnostics
                Area stack, thus signalling the exception (that is, the
                information that existed before entry into the handler). If the
                exception is an error, the values of <code class="literal">OUT</code> and
                <code class="literal">INOUT</code> parameters are not propogated back to
                the caller.
            </p><p style="color:blue;">如果异常由包含辞职语句的继续或退出处理程序来处理，则执行辞职会弹出诊断区域堆栈，从而发出异常信号（即，在进入处理程序之前存在的信息）。如果异常是一个错误，则out和inout参数的值不会被传递回调用方。</p>
            </div>
            <div class="section">
                <div class="titlepage">
                    <div>
                        <div>
                            <h4 class="title"><a name="condition-handling-restrictions"></a>13.6.7.9&nbsp;Restrictions on Condition Handling</h4>

                        </div>

                    </div>

                </div>
                <a class="indexterm" name="idm140286830288176"></a><a class="indexterm" name="idm140286830286688"></a><p>
                <a class="link" href="sql-syntax.html#signal" title="13.6.7.5&nbsp;SIGNAL Syntax"><code class="literal">SIGNAL</code></a>,
                <a class="link" href="sql-syntax.html#resignal" title="13.6.7.4&nbsp;RESIGNAL Syntax"><code class="literal">RESIGNAL</code></a>, and
                <a class="link" href="sql-syntax.html#get-diagnostics" title="13.6.7.3&nbsp;GET DIAGNOSTICS Syntax"><code class="literal">GET DIAGNOSTICS</code></a> are not
                permissible as prepared statements. For example, this statement
                is invalid:
            </p><p style="color:blue;">信号、重签名和GET诊断不允许作为准备好的语句。例如，此语句无效：</p><pre data-lang="sql" class="programlisting">PREPARE stmt1 FROM 'SIGNAL SQLSTATE "02000"';
</pre><p>
                <code class="literal">SQLSTATE</code> values in class
                <code class="literal">'04'</code> are not treated specially. They are
                handled the same as other exceptions.
            </p><p style="color:blue;">类“04”中的SqlState值没有特殊处理。它们的处理方式与其他异常相同。</p><p>
                In standard SQL, the first condition relates to the
                <code class="literal">SQLSTATE</code> value returned for the previous SQL
                statement. In MySQL, this is not guaranteed, so to get the main
                error, you cannot do this:
            </p><p style="color:blue;">在标准sql中，第一个条件与前一个sql语句返回的sqlstate值相关。在mysql中，这是无法保证的，因此要获取主错误，您不能执行以下操作：</p><pre data-lang="sql" class="programlisting">GET DIAGNOSTICS CONDITION 1 @errno = MYSQL_ERRNO;
</pre><p>
                Instead, do this:
            </p><p style="color:blue;">相反，请执行以下操作：</p><pre data-lang="sql" class="programlisting">GET DIAGNOSTICS @cno = NUMBER;
GET DIAGNOSTICS CONDITION @cno @errno = MYSQL_ERRNO;
</pre>
            </div>

        </div>

    </div>
    <div class="section">
        <div class="titlepage">
            <div>
                <div>
                    <h2 class="title" style="clear: both"><a name="sql-syntax-server-administration"></a>13.7&nbsp;Database Administration Statements</h2>

                </div>

            </div>

        </div>
        <div class="toc">
            <dl class="toc"><dt><span class="section"><a href="sql-syntax.html#account-management-sql">13.7.1 Account Management Statements</a></span></dt><dt><span class="section"><a href="sql-syntax.html#table-maintenance-sql">13.7.2 Table Maintenance Statements</a></span></dt><dt><span class="section"><a href="sql-syntax.html#component-sql">13.7.3 Plugin and User-Defined Function Statements</a></span></dt><dt><span class="section"><a href="sql-syntax.html#set-statement">13.7.4 SET Syntax</a></span></dt><dt><span class="section"><a href="sql-syntax.html#show">13.7.5 SHOW Syntax</a></span></dt><dt><span class="section"><a href="sql-syntax.html#other-administrative-sql">13.7.6 Other Administrative Statements</a></span></dt></dl>
        </div>
        <div class="section">
            <div class="titlepage">
                <div>
                    <div>
                        <h3 class="title"><a name="account-management-sql"></a>13.7.1&nbsp;Account Management Statements</h3>

                    </div>

                </div>

            </div>
            <div class="toc">
                <dl class="toc"><dt><span class="section"><a href="sql-syntax.html#alter-user">13.7.1.1 ALTER USER Syntax</a></span></dt><dt><span class="section"><a href="sql-syntax.html#create-user">13.7.1.2 CREATE USER Syntax</a></span></dt><dt><span class="section"><a href="sql-syntax.html#drop-user">13.7.1.3 DROP USER Syntax</a></span></dt><dt><span class="section"><a href="sql-syntax.html#grant">13.7.1.4 GRANT Syntax</a></span></dt><dt><span class="section"><a href="sql-syntax.html#rename-user">13.7.1.5 RENAME USER Syntax</a></span></dt><dt><span class="section"><a href="sql-syntax.html#revoke">13.7.1.6 REVOKE Syntax</a></span></dt><dt><span class="section"><a href="sql-syntax.html#set-password">13.7.1.7 SET PASSWORD Syntax</a></span></dt></dl>
            </div>
            <p>
                MySQL account information is stored in the tables of the
                <code class="literal">mysql</code> system database. This database and the
                access control system are discussed extensively in
                <a class="xref" href="server-administration.html" title="Chapter&nbsp;5&nbsp;MySQL Server Administration">Chapter&nbsp;5, <i>MySQL Server Administration</i></a>, which you should consult
                for additional details.
            </p><p style="color:blue;">mysql帐户信息存储在mysql系统数据库的表中。这个数据库和访问控制系统在第5章mysql服务器管理中进行了详细的讨论，您应该参考该章了解更多详细信息。</p>
            <div class="important" style="margin-left: 0.5in; margin-right: 0.5in;">

                <div class="admon-title">
                    Important
                </div>
                <p>
                    Some MySQL releases introduce changes to the grant tables to add
                    new privileges or features. To make sure that you can take
                    advantage of any new capabilities, update your grant tables to
                    the current structure whenever you upgrade MySQL. See
                    <a class="xref" href="installing.html#upgrading" title="2.11&nbsp;Upgrading MySQL">Section&nbsp;2.11, “Upgrading MySQL”</a>.
                </p><p style="color:blue;">一些mysql版本引入了对grant表的更改，以添加新的特权或特性。为了确保可以利用任何新功能，每当升级mysql时，都要将grant表更新为当前结构。参见2.11节“升级mysql”。</p>
            </div>
            <p>
                When the <a class="link" href="server-administration.html#sysvar_read_only"><code class="literal">read_only</code></a> system
                variable is enabled, account-management statements require the
                <a class="link" href="security.html#priv_super"><code class="literal">SUPER</code></a> privilege, in addition to any
                other required privileges. This is because they modify tables in
                the <code class="literal">mysql</code> system database.
            </p><p style="color:blue;">启用只读系统变量时，除了任何其他必需的权限外，帐户管理语句还需要超级权限。这是因为它们修改mysql系统数据库中的表。</p>
            <div class="section">

                <div class="titlepage">
                    <div>
                        <div>
                            <h4 class="title"><a name="alter-user"></a>13.7.1.1&nbsp;ALTER USER Syntax</h4>
                        </div>
                    </div>
                </div>
                <a class="indexterm" name="idm140286830261552"></a><a class="indexterm" name="idm140286830260480"></a><a class="indexterm" name="idm140286830258992"></a><pre data-lang="sql" class="programlisting">ALTER USER [IF EXISTS]
    <em class="replaceable"><code>user</code></em> [<em class="replaceable"><code>auth_option</code></em>] [, <em class="replaceable"><code>user</code></em> [<em class="replaceable"><code>auth_option</code></em>]] ...
    [REQUIRE {NONE | <em class="replaceable"><code>tls_option</code></em> [[AND] <em class="replaceable"><code>tls_option</code></em>] ...}]
    [WITH <em class="replaceable"><code>resource_option</code></em> [<em class="replaceable"><code>resource_option</code></em>] ...]
    [<em class="replaceable"><code>password_option</code></em> | <em class="replaceable"><code>lock_option</code></em>] ...

ALTER USER [IF EXISTS]
    USER() IDENTIFIED BY '<em class="replaceable"><code>auth_string</code></em>'

<em class="replaceable"><code>user</code></em>:
    (see <a class="xref" href="security.html#account-names" title="6.2.4&nbsp;Specifying Account Names">Section&nbsp;6.2.4, “Specifying Account Names”</a>)

<em class="replaceable"><code>auth_option</code></em>: {
    IDENTIFIED BY '<em class="replaceable"><code>auth_string</code></em>'
  | IDENTIFIED WITH <em class="replaceable"><code>auth_plugin</code></em>
  | IDENTIFIED WITH <em class="replaceable"><code>auth_plugin</code></em> BY '<em class="replaceable"><code>auth_string</code></em>'
  | IDENTIFIED WITH <em class="replaceable"><code>auth_plugin</code></em> AS '<em class="replaceable"><code>auth_string</code></em>'
}

<em class="replaceable"><code>tls_option</code></em>: {
   SSL
 | X509
 | CIPHER '<em class="replaceable"><code>cipher</code></em>'
 | ISSUER '<em class="replaceable"><code>issuer</code></em>'
 | SUBJECT '<em class="replaceable"><code>subject</code></em>'
}

<em class="replaceable"><code>resource_option</code></em>: {
    MAX_QUERIES_PER_HOUR <em class="replaceable"><code>count</code></em>
  | MAX_UPDATES_PER_HOUR <em class="replaceable"><code>count</code></em>
  | MAX_CONNECTIONS_PER_HOUR <em class="replaceable"><code>count</code></em>
  | MAX_USER_CONNECTIONS <em class="replaceable"><code>count</code></em>
}

<em class="replaceable"><code>password_option</code></em>: {
    PASSWORD EXPIRE
  | PASSWORD EXPIRE DEFAULT
  | PASSWORD EXPIRE NEVER
  | PASSWORD EXPIRE INTERVAL <em class="replaceable"><code>N</code></em> DAY
}

<em class="replaceable"><code>lock_option</code></em>: {
    ACCOUNT LOCK
  | ACCOUNT UNLOCK
}
</pre><p>
                The <a class="link" href="sql-syntax.html#alter-user" title="13.7.1.1&nbsp;ALTER USER Syntax"><code class="literal">ALTER USER</code></a> statement modifies
                MySQL accounts. It enables authentication, SSL/TLS,
                resource-limit, and password-management properties to be
                modified for existing accounts. It can also be used to lock and
                unlock accounts.
            </p><p style="color:blue;">alter user语句修改mysql帐户。它允许对现有帐户修改身份验证、SSL/TLS、资源限制和密码管理属性。它还可以用来锁定和解锁帐户。</p><p>
                To use <a class="link" href="sql-syntax.html#alter-user" title="13.7.1.1&nbsp;ALTER USER Syntax"><code class="literal">ALTER USER</code></a>, you must have
                the global <a class="link" href="security.html#priv_create-user"><code class="literal">CREATE USER</code></a> privilege
                or the <a class="link" href="security.html#priv_update"><code class="literal">UPDATE</code></a> privilege for the
                <code class="literal">mysql</code> system database. When the
                <a class="link" href="server-administration.html#sysvar_read_only"><code class="literal">read_only</code></a> system variable is
                enabled, <a class="link" href="sql-syntax.html#alter-user" title="13.7.1.1&nbsp;ALTER USER Syntax"><code class="literal">ALTER USER</code></a> additionally
                requires the <a class="link" href="security.html#priv_super"><code class="literal">SUPER</code></a> privilege.
            </p><p style="color:blue;">要使用alter user，必须具有mysql系统数据库的全局创建用户权限或更新权限。启用只读系统变量时，alter user还需要超级权限。</p><p>
                By default, an error occurs if you try to modify a user that
                does not exist. If the <code class="literal">IF EXISTS</code> clause is
                given, the statement produces a warning for each named user that
                does not exist, rather than an error.
            </p><p style="color:blue;">默认情况下，如果尝试修改不存在的用户，则会发生错误。如果给定IF存在子句，则语句为不存在的每个命名用户生成警告，而不是错误。</p>
                <div class="important" style="margin-left: 0.5in; margin-right: 0.5in;">

                    <div class="admon-title">
                        Important
                    </div>
                    <p>
                        Under some circumstances, <a class="link" href="sql-syntax.html#alter-user" title="13.7.1.1&nbsp;ALTER USER Syntax"><code class="literal">ALTER
                        USER</code></a> may be recorded in server logs or on the client
                        side in a history file such as
                        <code class="filename">~/.mysql_history</code>, which means that
                        cleartext passwords may be read by anyone having read access
                        to that information. For information about the conditions
                        under which this occurs for the server logs and how to control
                        it, see <a class="xref" href="security.html#password-logging" title="6.1.2.3&nbsp;Passwords and Logging">Section&nbsp;6.1.2.3, “Passwords and Logging”</a>. For similar
                        information about client-side logging, see
                        <a class="xref" href="programs.html#mysql-logging" title="4.5.1.3&nbsp;mysql Client Logging">Section&nbsp;4.5.1.3, “mysql Client Logging”</a>.
                    </p><p style="color:blue;">在某些情况下，alter user可能会记录在服务器日志中，或者记录在客户端的历史文件（如~/.mysql_history）中，这意味着任何有权读取该信息的人都可以读取明文密码。有关服务器日志发生这种情况的条件以及如何控制它的信息，请参阅第6.1.2.3节“密码和日志记录”。有关客户端日志记录的类似信息，请参阅第4.5.1.3节“MySQL客户端日志记录”。</p>
                </div>
                <p>
                    There are several aspects to the <a class="link" href="sql-syntax.html#alter-user" title="13.7.1.1&nbsp;ALTER USER Syntax"><code class="literal">ALTER
                    USER</code></a> statement, described under the following topics:
                </p><p style="color:blue;">alter user语句有几个方面，在以下主题中进行了描述：</p>
                <div class="itemizedlist">
                    <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><a class="xref" href="sql-syntax.html#alter-user-overview" title="ALTER USER Overview">ALTER USER Overview</a></p><p style="color:blue;">更改用户概述</p></li><li class="listitem"><p><a class="xref" href="sql-syntax.html#alter-user-authentication" title="ALTER USER Authentication Options">ALTER USER Authentication Options</a></p><p style="color:blue;">更改用户身份验证选项</p></li><li class="listitem"><p><a class="xref" href="sql-syntax.html#alter-user-tls" title="ALTER USER SSL/TLS Options">ALTER USER SSL/TLS Options</a></p><p style="color:blue;">更改用户SSL/TLS选项</p></li><li class="listitem"><p><a class="xref" href="sql-syntax.html#alter-user-resource-limits" title="ALTER USER Resource-Limit Options">ALTER USER Resource-Limit Options</a></p><p style="color:blue;">更改用户资源限制选项</p></li><li class="listitem"><p><a class="xref" href="sql-syntax.html#alter-user-password-management" title="ALTER USER Password-Management Options">ALTER USER Password-Management Options</a></p><p style="color:blue;">更改用户密码管理选项</p></li><li class="listitem"><p><a class="xref" href="sql-syntax.html#alter-user-account-locking" title="ALTER USER Account-Locking Options">ALTER USER Account-Locking Options</a></p><p style="color:blue;">更改用户帐户锁定选项</p></li></ul>
                </div>

                <div class="simplesect">

                    <div class="titlepage">
                        <div>

                            <div class="simple">
                                <h5 class="title"><a name="alter-user-overview"></a>ALTER USER Overview</h5>

                            </div>

                        </div>

                    </div>
                    <p>
                        For each affected account, <a class="link" href="sql-syntax.html#alter-user" title="13.7.1.1&nbsp;ALTER USER Syntax"><code class="literal">ALTER
                        USER</code></a> modifies the corresponding row in the
                        <code class="literal">mysql.user</code> system table to reflect the
                        properties specified in the statement. Unspecified properties
                        retain their current values.
                    </p><p style="color:blue;">对于每个受影响的帐户，alter user修改mysql.user系统表中的相应行，以反映语句中指定的属性。未指定的属性保留其当前值。</p><p>
                    Each account name uses the format described in
                    <a class="xref" href="security.html#account-names" title="6.2.4&nbsp;Specifying Account Names">Section&nbsp;6.2.4, “Specifying Account Names”</a>. The host name part of the
                    account name, if omitted, defaults to <code class="literal">'%'</code>.
                    It is also possible to specify
                    <a class="link" href="functions.html#function_current-user"><code class="literal">CURRENT_USER</code></a> or
                    <a class="link" href="functions.html#function_current-user"><code class="literal">CURRENT_USER()</code></a> to refer to the
                    account associated with the current session.
                </p><p style="color:blue;">每个帐户名使用第6.2.4节“指定帐户名”中描述的格式。帐户名的主机名部分（如果省略）默认为“%”。也可以指定current_user或current_user（）来引用与当前会话关联的帐户。</p><p>
                    For one syntax only, the account may be specified with the
                    <a class="link" href="functions.html#function_user"><code class="literal">USER()</code></a> function:
                </p><p style="color:blue;">仅对于一种语法，可以使用user（）函数指定帐户：</p><pre data-lang="sql" class="programlisting">ALTER USER USER() IDENTIFIED BY '<em class="replaceable"><code>auth_string</code></em>';
</pre><p>
                    This syntax enables changing your own password without naming
                    your account literally.
                </p><p style="color:blue;">此语法允许更改您自己的密码，而不必按字面意思命名您的帐户。</p><p>
                    For <a class="link" href="sql-syntax.html#alter-user" title="13.7.1.1&nbsp;ALTER USER Syntax"><code class="literal">ALTER USER</code></a> syntax that
                    permits an <em class="replaceable"><code>auth_option</code></em> value to
                    follow a <em class="replaceable"><code>user</code></em> value,
                    <em class="replaceable"><code>auth_option</code></em> indicates how the
                    account authenticates by specifying an account authentication
                    plugin, credentials (for example, a password), or both. Each
                    <em class="replaceable"><code>auth_option</code></em> value applies
                    <span class="emphasis"><em>only</em></span> to the account named immediately
                    preceding it.
                </p><p style="color:blue;">对于允许auth_选项值跟随用户值的alter user语法，auth_选项通过指定帐户身份验证插件、凭据（例如，密码）或两者来指示帐户如何进行身份验证。每个auth_选项值仅应用于紧靠其前面命名的帐户。</p><p>
                    Following the <em class="replaceable"><code>user</code></em> specifications,
                    the statement may include options for SSL/TLS, resource-limit,
                    password-management, and locking properties. All such options
                    are <span class="emphasis"><em>global</em></span> to the statement and apply to
                    <span class="emphasis"><em>all</em></span> accounts named in the statement.
                </p><p style="color:blue;">根据用户规范，该语句可以包括ssl/tls、资源限制、密码管理和锁定属性的选项。所有这些选项都是语句的全局选项，并适用于语句中指定的所有帐户。</p><p>
                    Example: Change an account's password and expire it. As a
                    result, the user must connect with the named password and
                    choose a new one at the next connection:
                </p><p style="color:blue;">示例：更改帐户密码并使其过期。因此，用户必须使用命名密码进行连接，并在下次连接时选择新密码：</p><pre data-lang="sql" class="programlisting">ALTER USER 'jeffrey'@'localhost'
  IDENTIFIED BY '<em class="replaceable"><code>new_password</code></em>' PASSWORD EXPIRE;
</pre><p>
                    Example: Modify an account to use the
                    <code class="literal">sha256_password</code> authentication plugin and
                    the given password. Require that a new password be chosen
                    every 180 days:
                </p><p style="color:blue;">示例：修改帐户以使用SHA256密码验证插件和给定的密码。要求每180天选择一个新密码：</p><pre data-lang="sql" class="programlisting">ALTER USER 'jeffrey'@'localhost'
  IDENTIFIED WITH sha256_password BY '<em class="replaceable"><code>new_password</code></em>'
  PASSWORD EXPIRE INTERVAL 180 DAY;
</pre><p>
                    Example: Lock or unlock an account:
                </p><p style="color:blue;">示例：锁定或解锁帐户：</p><pre data-lang="sql" class="programlisting">ALTER USER 'jeffrey'@'localhost' ACCOUNT LOCK;
ALTER USER 'jeffrey'@'localhost' ACCOUNT UNLOCK;
</pre><p>
                    Example: Require an account to connect using SSL and establish
                    a limit of 20 connections per hour:
                </p><p style="color:blue;">示例：要求帐户使用SSL进行连接，并设置每小时20个连接的限制：</p><pre data-lang="sql" class="programlisting">ALTER USER 'jeffrey'@'localhost'
  REQUIRE SSL WITH MAX_CONNECTIONS_PER_HOUR 20;
</pre><p>
                    Example: Alter multiple accounts, specifying some per-account
                    properties and some global properties:
                </p><p style="color:blue;">示例：更改多个帐户，指定一些每个帐户属性和一些全局属性：</p><pre data-lang="sql" class="programlisting">ALTER USER
  'jeffrey'@'localhost' IDENTIFIED BY '<em class="replaceable"><code>new_password</code></em>',
  'jeanne'@'localhost'
  REQUIRE SSL WITH MAX_USER_CONNECTIONS 2;
</pre><p>
                    The <code class="literal">IDENTIFIED BY</code> value following
                    <code class="literal">jeffrey</code> applies only to its immediately
                    preceding account, so it changes the password to
                    <code class="literal">'<em class="replaceable"><code>jeffrey_new_password</code></em>'</code>
                    only for <code class="literal">jeffrey</code>. For
                    <code class="literal">jeanne</code>, there is no per-account value (thus
                    leaving the password unchanged).
                </p><p style="color:blue;">jeffrey后面的identified by值仅适用于其前一个帐户，因此它将密码更改为“jeffrey_new_password”，仅适用于jeffrey。对于jeanne，没有每个帐户的值（因此保持密码不变）。</p><p>
                    The remaining properties apply globally to all accounts named
                    in the statement, so for both accounts:
                </p><p style="color:blue;">其余属性全局应用于语句中命名的所有帐户，因此对于这两个帐户：</p>
                    <div class="itemizedlist">
                        <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                            Connections are required to use SSL.
                        </p><p style="color:blue;">需要连接才能使用ssl。</p></li><li class="listitem"><p>
                            The account can be used for a maximum of two simultaneous
                            connections.
                        </p><p style="color:blue;">该帐户可用于最多两个同时连接。</p></li></ul>
                    </div>
                    <p>
                        In the absence of a particular type of option, the account
                        remains unchanged in that respect. For example, with no
                        locking option, the locking state of the account is not
                        changed.
                    </p><p style="color:blue;">在没有特定类型的选择权的情况下，账户在这方面保持不变。例如，如果没有锁定选项，则不会更改帐户的锁定状态。</p>
                </div>
                <div class="simplesect">
                    <div class="titlepage">
                        <div>
                            <div class="simple">
                                <h5 class="title"><a name="alter-user-authentication"></a>ALTER USER Authentication Options</h5>

                            </div>

                        </div>

                    </div>
                    <p>
                        An account name may be followed by an
                        <em class="replaceable"><code>auth_option</code></em> authentication option
                        that specifies the account authentication plugin, credentials,
                        or both:
                    </p><p style="color:blue;">帐户名后面可以跟一个auth_option authentication选项，该选项指定帐户身份验证插件和/或凭据：</p>
                    <div class="itemizedlist">
                        <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                            <em class="replaceable"><code>auth_plugin</code></em> names an
                            authentication plugin. The plugin name can be a quoted
                            string literal or an unquoted name. Plugin names are
                            stored in the <code class="literal">plugin</code> column of the
                            <code class="literal">mysql.user</code> system table.
                        </p><p style="color:blue;">auth_plugin命名身份验证插件。插件名称可以是带引号的字符串文本或不带引号的名称。插件名称存储在mysql.user系统表的plugin列中。</p><p>
                            For <em class="replaceable"><code>auth_option</code></em> syntax that
                            does not specify an authentication plugin, the default
                            plugin is indicated by the value of the
                            <a class="link" href="server-administration.html#sysvar_default_authentication_plugin"><code class="literal">default_authentication_plugin</code></a>
                            system variable. For descriptions of each plugin, see
                            <a class="xref" href="security.html#authentication-plugins" title="6.4.1&nbsp;Authentication Plugins">Section&nbsp;6.4.1, “Authentication Plugins”</a>.
                        </p><p style="color:blue;">对于未指定身份验证插件的auth_选项语法，默认插件由default_authentication_plugin系统变量的值指示。有关每个插件的说明，请参见第6.4.1节“验证插件”。</p></li><li class="listitem"><p>
                            Credentials are stored in the
                            <code class="literal">mysql.user</code> system table. An
                            <code class="literal">'<em class="replaceable"><code>auth_string</code></em>'</code>
                            value specifies account credentials, either as a cleartext
                            (unencrypted) string or hashed in the format expected by
                            the authentication plugin associated with the account,
                            respectively:
                        </p><p style="color:blue;">凭据存储在mysql.user系统表中。“auth_string”值指定帐户凭据，分别为明文（未加密）字符串或按与帐户关联的身份验证插件所期望的格式哈希：</p>
                            <div class="itemizedlist">
                                <ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
                                    For syntax that uses <code class="literal">BY
                                    '<em class="replaceable"><code>auth_string</code></em>'</code>,
                                    the string is cleartext and is passed to the
                                    authentication plugin for possible hashing. The result
                                    returned by the plugin is stored in the
                                    <code class="literal">mysql.user</code> table. A plugin may use
                                    the value as specified, in which case no hashing
                                    occurs.
                                </p><p style="color:blue;">对于使用“auth_string”的语法，该字符串为明文，并传递给身份验证插件以进行可能的哈希处理。插件返回的结果存储在mysql.user表中。插件可以使用指定的值，在这种情况下不会发生哈希。</p></li><li class="listitem"><p>
                                    For syntax that uses <code class="literal">AS
                                    '<em class="replaceable"><code>auth_string</code></em>'</code>,
                                    the string is assumed to be already in the format the
                                    authentication plugin requires, and is stored as is in
                                    the <code class="literal">mysql.user</code> table. If a plugin
                                    requires a hashed value, the value must be already
                                    hashed in a format appropriate for the plugin, or the
                                    value will not be usable by the plugin and correct
                                    authentication of client connections will not occur.
                                </p><p style="color:blue;">对于使用“auth_string”的语法，假定该字符串已采用身份验证插件所需的格式，并按原样存储在mysql.user表中。如果插件需要散列值，则该值必须已经以适合该插件的格式进行散列，否则该值将无法被插件使用，并且不会对客户端连接进行正确的身份验证。</p></li><li class="listitem"><p>
                                    If an authentication plugin performs no hashing of the
                                    authentication string, the <code class="literal">BY
                                    '<em class="replaceable"><code>auth_string</code></em>'</code> and
                                    <code class="literal">AS
                                        '<em class="replaceable"><code>auth_string</code></em>'</code>
                                    clauses have the same effect: The authentication
                                    string is stored as is in the
                                    <code class="literal">mysql.user</code> system table.
                                </p><p style="color:blue;">如果身份验证插件不执行身份验证字符串的哈希运算，则by'auth_string'和as'auth_string'子句具有相同的效果：身份验证字符串按原样存储在mysql.user系统表中。</p></li></ul>
                            </div>
                        </li></ul>
                    </div>
                    <p>
                        <a class="link" href="sql-syntax.html#alter-user" title="13.7.1.1&nbsp;ALTER USER Syntax"><code class="literal">ALTER USER</code></a> permits these
                        <em class="replaceable"><code>auth_option</code></em> syntaxes:
                    </p><p style="color:blue;">alter user允许这些auth_选项语法：</p>
                    <div class="itemizedlist">
                        <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                            <code class="literal">IDENTIFIED BY
                                '<em class="replaceable"><code>auth_string</code></em>'</code>
                        </p><p style="color:blue;">由“auth_string”标识</p><p>
                            Sets the account authentication plugin to the default
                            plugin, passes the cleartext
                            <code class="literal">'<em class="replaceable"><code>auth_string</code></em>'</code>
                            value to the plugin for possible hashing, and stores the
                            result in the account row in the
                            <code class="literal">mysql.user</code> system table.
                        </p><p style="color:blue;">将帐户身份验证插件设置为默认插件，将明文“auth_string”值传递给插件以进行可能的哈希运算，并将结果存储在mysql.user系统表的帐户行中。</p></li><li class="listitem"><p>
                            <code class="literal">IDENTIFIED WITH
                                <em class="replaceable"><code>auth_plugin</code></em></code>
                        </p><p style="color:blue;">用auth_插件标识</p><p>
                            Sets the account authentication plugin to
                            <em class="replaceable"><code>auth_plugin</code></em>, clears the
                            credentials to the empty string (the credentials are
                            associated with the old authentication plugin, not the new
                            one), and stores the result in the account row in the
                            <code class="literal">mysql.user</code> system table.
                        </p><p style="color:blue;">将帐户身份验证插件设置为auth_plugin，将凭据清除为空字符串（凭据与旧的身份验证插件关联，而不是新的），并将结果存储在mysql.user系统表的帐户行中。</p><p>
                            In addition, the password is marked expired. The user must
                            choose a new one when next connecting.
                        </p><p style="color:blue;">此外，密码被标记为已过期。下次连接时，用户必须选择一个新的。</p></li><li class="listitem"><p>
                            <code class="literal">IDENTIFIED WITH
                                <em class="replaceable"><code>auth_plugin</code></em> BY
                                '<em class="replaceable"><code>auth_string</code></em>'</code>
                        </p><p style="color:blue;">通过“auth_string”用auth_plugin标识</p><p>
                            Sets the account authentication plugin to
                            <em class="replaceable"><code>auth_plugin</code></em>, passes the
                            cleartext
                            <code class="literal">'<em class="replaceable"><code>auth_string</code></em>'</code>
                            value to the plugin for possible hashing, and stores the
                            result in the account row in the
                            <code class="literal">mysql.user</code> system table.
                        </p><p style="color:blue;">将帐户身份验证插件设置为auth_plugin，将明文“auth_string”值传递给插件以进行可能的哈希运算，并将结果存储在mysql.user系统表中的帐户行中。</p></li><li class="listitem"><p>
                            <code class="literal">IDENTIFIED WITH
                                <em class="replaceable"><code>auth_plugin</code></em> AS
                                '<em class="replaceable"><code>auth_string</code></em>'</code>
                        </p><p style="color:blue;">将auth_plugin标识为“auth_string”</p><p>
                            Sets the account authentication plugin to
                            <em class="replaceable"><code>auth_plugin</code></em> and stores the
                            <code class="literal">'<em class="replaceable"><code>auth_string</code></em>'</code>
                            value as is in the <code class="literal">mysql.user</code> account
                            row. If the plugin requires a hashed string, the string is
                            assumed to be already hashed in the format the plugin
                            requires.
                        </p><p style="color:blue;">将帐户身份验证插件设置为auth_plugin，并将“auth_string”值存储在mysql.user account行中。如果插件需要散列字符串，则假定该字符串已经按照插件所需的格式进行了散列。</p></li></ul>
                    </div>
                    <p>
                        Example: Specify the password as cleartext; the default plugin
                        is used:
                    </p><p style="color:blue;">示例：将密码指定为明文；使用默认插件：</p><pre data-lang="sql" class="programlisting">ALTER USER 'jeffrey'@'localhost'
  IDENTIFIED BY '<em class="replaceable"><code>password</code></em>';
</pre><p>
                    Example: Specify the authentication plugin, along with a
                    cleartext password value:
                </p><p style="color:blue;">示例：指定身份验证插件以及明文密码值：</p><pre data-lang="sql" class="programlisting">ALTER USER 'jeffrey'@'localhost'
  IDENTIFIED WITH mysql_native_password
             BY '<em class="replaceable"><code>password</code></em>';
</pre><p>
                    Example: Specify the authentication plugin, along with a
                    hashed password value:
                </p><p style="color:blue;">示例：指定身份验证插件以及哈希密码值：</p><pre data-lang="sql" class="programlisting">ALTER USER 'jeffrey'@'localhost'
  IDENTIFIED WITH mysql_native_password
             AS '*6C8989366EAF75BB670AD8EA7A7FC1176A95CEF4';
</pre><p>
                    For additional information about setting passwords and
                    authentication plugins, see
                    <a class="xref" href="security.html#assigning-passwords" title="6.2.10&nbsp;Assigning Account Passwords">Section&nbsp;6.2.10, “Assigning Account Passwords”</a>, and
                    <a class="xref" href="security.html#pluggable-authentication" title="6.2.13&nbsp;Pluggable Authentication">Section&nbsp;6.2.13, “Pluggable Authentication”</a>.
                </p><p style="color:blue;">有关设置密码和身份验证插件的其他信息，请参阅第6.2.10节“分配帐户密码”和第6.2.13节“可插入身份验证”。</p>
                </div>
                <div class="simplesect">
                    <div class="titlepage">
                        <div>
                            <div class="simple">
                                <h5 class="title"><a name="alter-user-tls"></a>ALTER USER SSL/TLS Options</h5>

                            </div>

                        </div>

                    </div>
                    <a class="indexterm" name="idm140286830126064"></a><a class="indexterm" name="idm140286830124608"></a><a class="indexterm" name="idm140286830123120"></a><p>
                    MySQL can check X.509 certificate attributes in addition to
                    the usual authentication that is based on the user name and
                    credentials. For background information on the use of SSL/TLS
                    with MySQL, see <a class="xref" href="security.html#encrypted-connections" title="6.3&nbsp;Using Encrypted Connections">Section&nbsp;6.3, “Using Encrypted Connections”</a>.
                </p><p style="color:blue;">除了基于用户名和凭据的常规身份验证之外，mysql还可以检查x.509证书属性。有关在mysql中使用ssl/tls的背景信息，请参见第6.3节“使用加密连接”。</p><p>
                    To specify SSL/TLS-related options for a MySQL account, use a
                    <code class="literal">REQUIRE</code> clause that specifies one or more
                    <em class="replaceable"><code>tls_option</code></em> values.
                </p><p style="color:blue;">要为mysql帐户指定与ssl/tls相关的选项，请使用指定一个或多个tls_选项值的require子句。</p><p>
                    Order of <code class="literal">REQUIRE</code> options does not matter,
                    but no option can be specified twice. The
                    <code class="literal">AND</code> keyword is optional between
                    <code class="literal">REQUIRE</code> options.
                </p><p style="color:blue;">Require选项的顺序无关紧要，但任何选项都不能指定两次。and关键字在require选项之间是可选的。</p><p>
                    <a class="link" href="sql-syntax.html#alter-user" title="13.7.1.1&nbsp;ALTER USER Syntax"><code class="literal">ALTER USER</code></a> permits these
                    <em class="replaceable"><code>tls_option</code></em> values:
                </p><p style="color:blue;">alter user允许这些tls_选项值：</p>
                    <div class="itemizedlist">
                        <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                            <code class="literal">NONE</code>
                        </p><p style="color:blue;">无</p><p>
                            Indicates that all accounts named by the statement have no
                            SSL or X.509 requirements. Unencrypted connections are
                            permitted if the user name and password are valid.
                            Encrypted connections can be used, at the client's option,
                            if the client has the proper certificate and key files.
                        </p><p style="color:blue;">指示由语句命名的所有帐户都没有SSL或X.509要求。如果用户名和密码有效，则允许未加密的连接。如果客户机具有正确的证书和密钥文件，则可以根据客户机的选择使用加密连接。</p><pre data-lang="sql" class="programlisting">ALTER USER 'jeffrey'@'localhost' REQUIRE NONE;
</pre><p>
                            Clients attempt to establish a secure connection by
                            default. For clients that have <code class="literal">REQUIRE
                            NONE</code>, the connection attempt falls back to an
                            unencrypted connection if a secure connection cannot be
                            established. To require an encrypted connection, a client
                            need specify only the
                            <a class="link" href="programs.html#option_general_ssl-mode"><code class="option">--ssl-mode=REQUIRED</code></a>
                            option; the connection attempt fails if a secure
                            connection cannot be established.
                        </p><p style="color:blue;">默认情况下，客户端尝试建立安全连接。对于不需要任何连接的客户端，如果无法建立安全连接，则连接尝试会返回到未加密的连接。要要求加密连接，客户端只需要指定--ssl mode=required选项；如果无法建立安全连接，则连接尝试失败。</p></li><li class="listitem"><p>
                            <code class="literal">SSL</code>
                        </p><p style="color:blue;">SSL协议</p><p>
                            Tells the server to permit only encrypted connections for
                            all accounts named by the statement.
                        </p><p style="color:blue;">告诉服务器只允许对由语句命名的所有帐户进行加密连接。</p><pre data-lang="sql" class="programlisting">ALTER USER 'jeffrey'@'localhost' REQUIRE SSL;
</pre><p>
                            Clients attempt to establish a secure connection by
                            default. For accounts that have <code class="literal">REQUIRE
                            SSL</code>, the connection attempt fails if a secure
                            connection cannot be established.
                        </p><p style="color:blue;">默认情况下，客户端尝试建立安全连接。对于需要SSL的帐户，如果无法建立安全连接，则连接尝试将失败。</p></li><li class="listitem"><p>
                            <code class="literal">X509</code>
                        </p><p style="color:blue;">X509年</p><p>
                            For all accounts named by the statement, requires that
                            clients present a valid certificate, but the exact
                            certificate, issuer, and subject do not matter. The only
                            requirement is that it should be possible to verify its
                            signature with one of the CA certificates. Use of X.509
                            certificates always implies encryption, so the
                            <code class="literal">SSL</code> option is unnecessary in this case.
                        </p><p style="color:blue;">对于由语句命名的所有帐户，要求客户端提供有效的证书，但确切的证书、颁发者和主题并不重要。唯一的要求是，应该可以用一个ca证书验证其签名。使用x.509证书总是意味着加密，因此在这种情况下不需要ssl选项。</p><pre data-lang="sql" class="programlisting">ALTER USER 'jeffrey'@'localhost' REQUIRE X509;
</pre><p>
                            For accounts with <code class="literal">REQUIRE X509</code>, clients
                            must specify the <a class="link" href="programs.html#option_general_ssl-key"><code class="option">--ssl-key</code></a>
                            and <a class="link" href="programs.html#option_general_ssl-cert"><code class="option">--ssl-cert</code></a> options to
                            connect. (It is recommended but not required that
                            <a class="link" href="programs.html#option_general_ssl-ca"><code class="option">--ssl-ca</code></a> also be specified
                            so that the public certificate provided by the server can
                            be verified.) This is true for <code class="literal">ISSUER</code>
                            and <code class="literal">SUBJECT</code> as well because those
                            <code class="literal">REQUIRE</code> options imply the requirements
                            of <code class="literal">X509</code>.
                        </p><p style="color:blue;">对于具有Require X509的帐户，客户端必须指定要连接的--ssl密钥和--ssl证书选项。（建议但不要求也指定--ssl ca，以便可以验证服务器提供的公共证书。）对于颁发者和使用者也是如此，因为这些要求选项意味着x509的要求。</p></li><li class="listitem"><p>
                            <code class="literal">ISSUER
                                '<em class="replaceable"><code>issuer</code></em>'</code>
                        </p><p style="color:blue;">发行人“发行人”</p><p>
                            For all accounts named by the statement, requires that
                            clients present a valid X.509 certificate issued by CA
                            <code class="literal">'<em class="replaceable"><code>issuer</code></em>'</code>. If
                            a client presents a certificate that is valid but has a
                            different issuer, the server rejects the connection. Use
                            of X.509 certificates always implies encryption, so the
                            <code class="literal">SSL</code> option is unnecessary in this case.
                        </p><p style="color:blue;">对于由语句命名的所有帐户，要求客户端提供由CA“Issuer”颁发的有效X.509证书。如果客户端提供的证书有效但具有不同的颁发者，服务器将拒绝连接。使用x.509证书总是意味着加密，因此在这种情况下不需要ssl选项。</p><pre data-lang="sql" class="programlisting">ALTER USER 'jeffrey'@'localhost'
  REQUIRE ISSUER '/C=SE/ST=Stockholm/L=Stockholm/
    O=MySQL/CN=CA/emailAddress=ca@example.com';
</pre><p>
                            Because <code class="literal">ISSUER</code> implies the requirements
                            of <code class="literal">X509</code>, clients must specify the
                            <a class="link" href="programs.html#option_general_ssl-key"><code class="option">--ssl-key</code></a> and
                            <a class="link" href="programs.html#option_general_ssl-cert"><code class="option">--ssl-cert</code></a> options to
                            connect. (It is recommended but not required that
                            <a class="link" href="programs.html#option_general_ssl-ca"><code class="option">--ssl-ca</code></a> also be specified
                            so that the public certificate provided by the server can
                            be verified.)
                        </p><p style="color:blue;">因为ISSUER表示X509的要求，所以客户端必须指定要连接的--ssl key和--ssl cert选项。（建议但不要求指定--ssl ca，以便可以验证服务器提供的公共证书。）</p></li><li class="listitem"><p>
                            <code class="literal">SUBJECT
                                '<em class="replaceable"><code>subject</code></em>'</code>
                        </p><p style="color:blue;">主题“主题”</p><p>
                            For all accounts named by the statement, requires that
                            clients present a valid X.509 certificate containing the
                            subject <em class="replaceable"><code>subject</code></em>. If a client
                            presents a certificate that is valid but has a different
                            subject, the server rejects the connection. Use of X.509
                            certificates always implies encryption, so the
                            <code class="literal">SSL</code> option is unnecessary in this case.
                        </p><p style="color:blue;">对于由语句命名的所有帐户，要求客户端提供包含主题主题的有效X.509证书。如果客户端提供的证书有效但具有不同的主题，服务器将拒绝连接。使用x.509证书总是意味着加密，因此在这种情况下不需要ssl选项。</p><pre data-lang="sql" class="programlisting">ALTER USER 'jeffrey'@'localhost'
  REQUIRE SUBJECT '/C=SE/ST=Stockholm/L=Stockholm/
    O=MySQL demo client certificate/
    CN=client/emailAddress=client@example.com';
</pre><p>
                            MySQL does a simple string comparison of the
                            <code class="literal">'<em class="replaceable"><code>subject</code></em>'</code>
                            value to the value in the certificate, so lettercase and
                            component ordering must be given exactly as present in the
                            certificate.
                        </p><p style="color:blue;">mysql将“subject”值与证书中的值进行简单的字符串比较，因此必须给出与证书中完全相同的字母大小写和组件顺序。</p><p>
                            Because <code class="literal">SUBJECT</code> implies the
                            requirements of <code class="literal">X509</code>, clients must
                            specify the <a class="link" href="programs.html#option_general_ssl-key"><code class="option">--ssl-key</code></a> and
                            <a class="link" href="programs.html#option_general_ssl-cert"><code class="option">--ssl-cert</code></a> options to
                            connect. (It is recommended but not required that
                            <a class="link" href="programs.html#option_general_ssl-ca"><code class="option">--ssl-ca</code></a> also be specified
                            so that the public certificate provided by the server can
                            be verified.)
                        </p><p style="color:blue;">因为subject表示x509的要求，所以客户端必须指定要连接的--ssl key和--ssl cert选项。（建议但不要求指定--ssl ca，以便可以验证服务器提供的公共证书。）</p></li><li class="listitem"><p>
                            <code class="literal">CIPHER
                                '<em class="replaceable"><code>cipher</code></em>'</code>
                        </p><p style="color:blue;">密码“密码”</p><p>
                            For all accounts named by the statement, requires a
                            specific cipher method for encrypting connections. This
                            option is needed to ensure that ciphers and key lengths of
                            sufficient strength are used. Encryption can be weak if
                            old algorithms using short encryption keys are used.
                        </p><p style="color:blue;">对于由语句命名的所有帐户，需要使用特定的密码方法来加密连接。此选项用于确保使用足够强度的密码和密钥长度。如果使用使用使用短加密密钥的旧算法，加密可能会很弱。</p><pre data-lang="sql" class="programlisting">ALTER USER 'jeffrey'@'localhost'
  REQUIRE CIPHER 'EDH-RSA-DES-CBC3-SHA';
</pre></li></ul>
                    </div>
                    <p>
                        The <code class="literal">SUBJECT</code>, <code class="literal">ISSUER</code>, and
                        <code class="literal">CIPHER</code> options can be combined in the
                        <code class="literal">REQUIRE</code> clause:
                    </p><p style="color:blue;">主题、颁发者和密码选项可以在REQUIRE子句中组合：</p><pre data-lang="sql" class="programlisting">ALTER USER 'jeffrey'@'localhost'
  REQUIRE SUBJECT '/C=SE/ST=Stockholm/L=Stockholm/
    O=MySQL demo client certificate/
    CN=client/emailAddress=client@example.com'
  AND ISSUER '/C=SE/ST=Stockholm/L=Stockholm/
    O=MySQL/CN=CA/emailAddress=ca@example.com'
  AND CIPHER 'EDH-RSA-DES-CBC3-SHA';
</pre>
                </div>
                <div class="simplesect">
                    <div class="titlepage">
                        <div>
                            <div class="simple">
                                <h5 class="title"><a name="alter-user-resource-limits"></a>ALTER USER Resource-Limit Options</h5>

                            </div>

                        </div>

                    </div>
                    <a class="indexterm" name="idm140286830060848"></a><a class="indexterm" name="idm140286830059360"></a><p>
                    It is possible to place limits on use of server resources by
                    an account, as discussed in <a class="xref" href="security.html#user-resources" title="6.2.16&nbsp;Setting Account Resource Limits">Section&nbsp;6.2.16, “Setting Account Resource Limits”</a>.
                    To do so, use a <code class="literal">WITH</code> clause that specifies
                    one or more <em class="replaceable"><code>resource_option</code></em> values.
                </p><p style="color:blue;">如第6.2.16节“设置帐户资源限制”所述，可以对帐户使用服务器资源设置限制。为此，请使用指定一个或多个资源选项值的WITH子句。</p><p>
                    Order of <code class="literal">WITH</code> options does not matter,
                    except that if a given resource limit is specified multiple
                    times, the last instance takes precedence.
                </p><p style="color:blue;">WITH选项的顺序无关紧要，但如果多次指定给定的资源限制，则以最后一个实例为准。</p><p>
                    <a class="link" href="sql-syntax.html#alter-user" title="13.7.1.1&nbsp;ALTER USER Syntax"><code class="literal">ALTER USER</code></a> permits these
                    <em class="replaceable"><code>resource_option</code></em> values:
                </p><p style="color:blue;">alter user允许这些资源选项值：</p>
                    <div class="itemizedlist">
                        <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                            <code class="literal">MAX_QUERIES_PER_HOUR
                                <em class="replaceable"><code>count</code></em></code>,
                            <code class="literal">MAX_UPDATES_PER_HOUR
                                <em class="replaceable"><code>count</code></em></code>,
                            <code class="literal">MAX_CONNECTIONS_PER_HOUR
                                <em class="replaceable"><code>count</code></em></code>
                        </p><p style="color:blue;">每小时最大查询数、每小时最大更新数、每小时最大连接数</p><p>
                            For all accounts named by the statement, these options
                            restrict how many queries, updates, and connections to the
                            server are permitted to each account during any given
                            one-hour period. (Queries for which results are served
                            from the query cache do not count against the
                            <code class="literal">MAX_QUERIES_PER_HOUR</code> limit.) If
                            <em class="replaceable"><code>count</code></em> is <code class="literal">0</code>
                            (the default), this means that there is no limitation for
                            the account.
                        </p><p style="color:blue;">对于由语句命名的所有帐户，这些选项限制在任何给定的一小时内每个帐户允许查询、更新和连接到服务器的次数。（从查询缓存中提供结果的查询不计入每小时最大查询数限制。）如果计数为0（默认值），则表示该帐户没有限制。</p></li><li class="listitem"><p>
                            <code class="literal">MAX_USER_CONNECTIONS
                                <em class="replaceable"><code>count</code></em></code>
                        </p><p style="color:blue;">最大用户连接数</p><p>
                            For all accounts named by the statement, restricts the
                            maximum number of simultaneous connections to the server
                            by each account. A nonzero
                            <em class="replaceable"><code>count</code></em> specifies the limit for
                            the account explicitly. If
                            <em class="replaceable"><code>count</code></em> is <code class="literal">0</code>
                            (the default), the server determines the number of
                            simultaneous connections for the account from the global
                            value of the
                            <a class="link" href="server-administration.html#sysvar_max_user_connections"><code class="literal">max_user_connections</code></a>
                            system variable. If
                            <a class="link" href="server-administration.html#sysvar_max_user_connections"><code class="literal">max_user_connections</code></a> is
                            also zero, there is no limit for the account.
                        </p><p style="color:blue;">对于由该语句命名的所有帐户，通过每个帐户限制与服务器的同时连接的最大数量。非零计数显式指定帐户的限制。如果“计数”为0（默认值），则服务器将根据“最大用户连接数”系统变量的全局值确定帐户的同时连接数。如果max_user_connections也为零，则该帐户没有限制。</p></li></ul>
                    </div>
                    <p>
                        Example:
                    </p><p style="color:blue;">例子：</p><pre data-lang="sql" class="programlisting">ALTER USER 'jeffrey'@'localhost'
  WITH MAX_QUERIES_PER_HOUR 500 MAX_UPDATES_PER_HOUR 100;
</pre>
                </div>
                <div class="simplesect">
                    <div class="titlepage">
                        <div>
                            <div class="simple">
                                <h5 class="title"><a name="alter-user-password-management"></a>ALTER USER Password-Management Options</h5>

                            </div>

                        </div>

                    </div>
                    <p>
                        <a class="link" href="sql-syntax.html#alter-user" title="13.7.1.1&nbsp;ALTER USER Syntax"><code class="literal">ALTER USER</code></a> supports several
                        <em class="replaceable"><code>password_option</code></em> values for password
                        expiration management, to either expire an account password
                        manually or establish its password expiration policy. Policy
                        options do not expire the password. Instead, they determine
                        how the server applies automatic expiration to the account
                        based on account password age. For a given account, its
                        password age is assessed from the date and time of the most
                        recent password change.
                    </p><p style="color:blue;">alter user支持多个密码过期管理的密码选项值，可以手动使帐户密码过期，也可以建立其密码过期策略。策略选项不会使密码过期。相反，它们决定服务器如何根据帐户密码期限对帐户应用自动过期。对于给定的帐户，其密码期限是从最近密码更改的日期和时间开始计算的。</p><p>
                    This section describes the syntax for password-management
                    options. For information about establishing policy for
                    password management, see
                    <a class="xref" href="security.html#password-management" title="6.2.11&nbsp;Password Management">Section&nbsp;6.2.11, “Password Management”</a>.
                </p><p style="color:blue;">本节介绍密码管理选项的语法。有关建立密码管理策略的信息，请参阅第6.2.11节“密码管理”。</p><p>
                    If multiple password-management options are specified, the
                    last one takes precedence.
                </p><p style="color:blue;">如果指定了多个密码管理选项，则以最后一个为准。</p><p>
                    These options apply only to accounts that use an
                    authentication plugin that stores credentials internally to
                    MySQL. For accounts that use plugins that perform
                    authentication against a credentials system that is external
                    to MySQL, password management must be handled externally
                    against that system as well. For more information about
                    internal credentials storage, see
                    <a class="xref" href="security.html#password-management" title="6.2.11&nbsp;Password Management">Section&nbsp;6.2.11, “Password Management”</a>.
                </p><p style="color:blue;">这些选项仅适用于使用身份验证插件的帐户，该插件在mysql内部存储凭据。对于使用插件对mysql外部的凭据系统执行身份验证的帐户，还必须对该系统在外部处理密码管理。有关内部凭据存储的更多信息，请参阅第6.2.11节“密码管理”。</p><p>
                    A client session operates in restricted mode if the account
                    password was expired manually or if the password age is
                    considered greater than its permitted lifetime per the
                    automatic expiration policy. In restricted mode, operations
                    performed within the session result in an error until the user
                    establishes a new account password. For information about
                    restricted mode, see
                    <a class="xref" href="security.html#expired-password-handling" title="6.2.12&nbsp;Server Handling of Expired Passwords">Section&nbsp;6.2.12, “Server Handling of Expired Passwords”</a>.
                </p><p style="color:blue;">如果帐户密码已手动过期，或者根据自动过期策略认为密码期限大于其允许的生存期，则客户端会话将在受限模式下运行。在受限模式下，在会话中执行的操作会导致错误，直到用户建立新的帐户密码。有关受限模式的信息，请参阅第6.2.12节“服务器处理过期密码”。</p>
                    <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">

                        <div class="admon-title">
                            Note
                        </div>
                        <p>
                            Although it is possible to <span class="quote">“<span class="quote">reset</span>”</span> an expired
                            password by setting it to its current value, it is
                            preferable, as a matter of good policy, to choose a
                            different password.
                        </p><p style="color:blue;">尽管可以通过将过期密码设置为其当前值来“重置”，但作为一个好的策略，最好选择其他密码。</p>
                    </div>
                    <p>
                        <a class="link" href="sql-syntax.html#alter-user" title="13.7.1.1&nbsp;ALTER USER Syntax"><code class="literal">ALTER USER</code></a> permits these
                        <em class="replaceable"><code>password_option</code></em> values for
                        controlling password expiration:
                    </p><p style="color:blue;">alter user允许使用这些密码选项值来控制密码过期：</p>
                    <div class="itemizedlist">
                        <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                            <code class="literal">PASSWORD EXPIRE</code>
                        </p><p style="color:blue;">密码过期</p><p>
                            Immediately marks the password expired for all accounts
                            named by the statement.
                        </p><p style="color:blue;">立即标记由语句命名的所有帐户的密码过期。</p><pre data-lang="sql" class="programlisting">ALTER USER 'jeffrey'@'localhost' PASSWORD EXPIRE;
</pre></li><li class="listitem"><p>
                            <code class="literal">PASSWORD EXPIRE DEFAULT</code>
                        </p><p style="color:blue;">密码过期默认值</p><p>
                            Sets all accounts named by the statement so that the
                            global expiration policy applies, as specified by the
                            <a class="link" href="server-administration.html#sysvar_default_password_lifetime"><code class="literal">default_password_lifetime</code></a>
                            system variable.
                        </p><p style="color:blue;">设置由语句命名的所有帐户，以便应用全局过期策略（由默认的密码生存期系统变量指定）。</p><pre data-lang="sql" class="programlisting">ALTER USER 'jeffrey'@'localhost' PASSWORD EXPIRE DEFAULT;
</pre></li><li class="listitem"><p>
                            <code class="literal">PASSWORD EXPIRE NEVER</code>
                        </p><p style="color:blue;">密码永不过期</p><p>
                            This expiration option overrides the global policy for all
                            accounts named by the statement. For each, it disables
                            password expiration so that the password never expires.
                        </p><p style="color:blue;">此过期选项将覆盖由语句命名的所有帐户的全局策略。对于每个密码，它都会禁用密码过期，这样密码就永远不会过期。</p><pre data-lang="sql" class="programlisting">ALTER USER 'jeffrey'@'localhost' PASSWORD EXPIRE NEVER;
</pre></li><li class="listitem"><p>
                            <code class="literal">PASSWORD EXPIRE INTERVAL
                                <em class="replaceable"><code>N</code></em> DAY</code>
                        </p><p style="color:blue;">密码过期间隔n天</p><p>
                            This expiration option overrides the global policy for all
                            accounts named by the statement. For each, it sets the
                            password lifetime to <em class="replaceable"><code>N</code></em> days.
                            The following statement requires the password to be
                            changed every 180 days:
                        </p><p style="color:blue;">此过期选项将覆盖由语句命名的所有帐户的全局策略。对于每个密码，它将密码生存期设置为n天。以下语句要求每180天更改一次密码：</p><pre data-lang="sql" class="programlisting">ALTER USER 'jeffrey'@'localhost' PASSWORD EXPIRE INTERVAL 180 DAY;
</pre></li></ul>
                    </div>

                </div>
                <div class="simplesect">
                    <div class="titlepage">
                        <div>
                            <div class="simple">
                                <h5 class="title"><a name="alter-user-account-locking"></a>ALTER USER Account-Locking Options</h5>

                            </div>

                        </div>

                    </div>
                    <a class="indexterm" name="idm140286830008832"></a><p>
                    MySQL supports account locking and unlocking using the
                    <code class="literal">ACCOUNT LOCK</code> and <code class="literal">ACCOUNT
                    UNLOCK</code> options, which specify the locking state for
                    an account. For additional discussion, see
                    <a class="xref" href="security.html#account-locking" title="6.2.15&nbsp;Account Locking">Section&nbsp;6.2.15, “Account Locking”</a>.
                </p><p style="color:blue;">mysql支持使用account lock和account unlock选项进行帐户锁定和解锁，这两个选项指定帐户的锁定状态。有关其他讨论，请参见第6.2.15节“帐户锁定”。</p><p>
                    If multiple account-locking options are specified, the last
                    one takes precedence.
                </p><p style="color:blue;">如果指定了多个帐户锁定选项，则以最后一个为准。</p>
                </div>

            </div>
            <div class="section">
                <div class="titlepage">
                    <div>
                        <div>
                            <h4 class="title"><a name="create-user"></a>13.7.1.2&nbsp;CREATE USER Syntax</h4>

                        </div>

                    </div>

                </div>
                <a class="indexterm" name="idm140286830002832"></a><a class="indexterm" name="idm140286830001760"></a><a class="indexterm" name="idm140286830000272"></a><pre data-lang="sql" class="programlisting">CREATE USER [IF NOT EXISTS]
    <em class="replaceable"><code>user</code></em> [<em class="replaceable"><code>auth_option</code></em>] [, <em class="replaceable"><code>user</code></em> [<em class="replaceable"><code>auth_option</code></em>]] ...
    [REQUIRE {NONE | <em class="replaceable"><code>tls_option</code></em> [[AND] <em class="replaceable"><code>tls_option</code></em>] ...}]
    [WITH <em class="replaceable"><code>resource_option</code></em> [<em class="replaceable"><code>resource_option</code></em>] ...]
    [<em class="replaceable"><code>password_option</code></em> | <em class="replaceable"><code>lock_option</code></em>] ...

<em class="replaceable"><code>user</code></em>:
    (see <a class="xref" href="security.html#account-names" title="6.2.4&nbsp;Specifying Account Names">Section&nbsp;6.2.4, “Specifying Account Names”</a>)

<em class="replaceable"><code>auth_option</code></em>: {
    IDENTIFIED BY '<em class="replaceable"><code>auth_string</code></em>'
  | IDENTIFIED WITH <em class="replaceable"><code>auth_plugin</code></em>
  | IDENTIFIED WITH <em class="replaceable"><code>auth_plugin</code></em> BY '<em class="replaceable"><code>auth_string</code></em>'
  | IDENTIFIED WITH <em class="replaceable"><code>auth_plugin</code></em> AS '<em class="replaceable"><code>auth_string</code></em>'
  | IDENTIFIED BY PASSWORD '<em class="replaceable"><code>auth_string</code></em>'
}

<em class="replaceable"><code>tls_option</code></em>: {
   SSL
 | X509
 | CIPHER '<em class="replaceable"><code>cipher</code></em>'
 | ISSUER '<em class="replaceable"><code>issuer</code></em>'
 | SUBJECT '<em class="replaceable"><code>subject</code></em>'
}

<em class="replaceable"><code>resource_option</code></em>: {
    MAX_QUERIES_PER_HOUR <em class="replaceable"><code>count</code></em>
  | MAX_UPDATES_PER_HOUR <em class="replaceable"><code>count</code></em>
  | MAX_CONNECTIONS_PER_HOUR <em class="replaceable"><code>count</code></em>
  | MAX_USER_CONNECTIONS <em class="replaceable"><code>count</code></em>
}

<em class="replaceable"><code>password_option</code></em>: {
    PASSWORD EXPIRE
  | PASSWORD EXPIRE DEFAULT
  | PASSWORD EXPIRE NEVER
  | PASSWORD EXPIRE INTERVAL <em class="replaceable"><code>N</code></em> DAY
}

<em class="replaceable"><code>lock_option</code></em>: {
    ACCOUNT LOCK
  | ACCOUNT UNLOCK
}
</pre><p>
                The <a class="link" href="sql-syntax.html#create-user" title="13.7.1.2&nbsp;CREATE USER Syntax"><code class="literal">CREATE USER</code></a> statement creates
                new MySQL accounts. It enables authentication, SSL/TLS,
                resource-limit, and password-management properties to be
                established for new accounts, and controls whether accounts are
                initially locked or unlocked.
            </p><p style="color:blue;">create user语句创建新的mysql帐户。它允许为新帐户建立身份验证、SSL/TLS、资源限制和密码管理属性，并控制帐户最初是锁定还是解锁。</p><p>
                To use <a class="link" href="sql-syntax.html#create-user" title="13.7.1.2&nbsp;CREATE USER Syntax"><code class="literal">CREATE USER</code></a>, you must have
                the global <a class="link" href="security.html#priv_create-user"><code class="literal">CREATE USER</code></a> privilege,
                or the <a class="link" href="security.html#priv_insert"><code class="literal">INSERT</code></a> privilege for the
                <code class="literal">mysql</code> system database. When the
                <a class="link" href="server-administration.html#sysvar_read_only"><code class="literal">read_only</code></a> system variable is
                enabled, <a class="link" href="sql-syntax.html#create-user" title="13.7.1.2&nbsp;CREATE USER Syntax"><code class="literal">CREATE USER</code></a> additionally
                requires the <a class="link" href="security.html#priv_super"><code class="literal">SUPER</code></a> privilege.
            </p><p style="color:blue;">要使用create user，您必须具有全局create user权限或mysql系统数据库的insert权限。启用只读系统变量时，“创建用户”还需要超级权限。</p><p>
                An error occurs if you try to create an account that already
                exists. If the <code class="literal">IF NOT EXISTS</code> clause is given,
                the statement produces a warning for each named account that
                already exists, rather than an error.
            </p><p style="color:blue;">如果尝试创建已经存在的帐户，则会发生错误。如果给定IF不存在子句，则语句为已存在的每个命名帐户生成警告，而不是错误。</p>
                <div class="important" style="margin-left: 0.5in; margin-right: 0.5in;">

                    <div class="admon-title">
                        Important
                    </div>
                    <p>
                        Under some circumstances, <a class="link" href="sql-syntax.html#create-user" title="13.7.1.2&nbsp;CREATE USER Syntax"><code class="literal">CREATE
                        USER</code></a> may be recorded in server logs or on the client
                        side in a history file such as
                        <code class="filename">~/.mysql_history</code>, which means that
                        cleartext passwords may be read by anyone having read access
                        to that information. For information about the conditions
                        under which this occurs for the server logs and how to control
                        it, see <a class="xref" href="security.html#password-logging" title="6.1.2.3&nbsp;Passwords and Logging">Section&nbsp;6.1.2.3, “Passwords and Logging”</a>. For similar
                        information about client-side logging, see
                        <a class="xref" href="programs.html#mysql-logging" title="4.5.1.3&nbsp;mysql Client Logging">Section&nbsp;4.5.1.3, “mysql Client Logging”</a>.
                    </p><p style="color:blue;">在某些情况下，create user可能会记录在服务器日志中，或者记录在客户端的历史文件（如~/.mysql_history）中，这意味着对该信息具有读取权限的任何人都可以读取明文密码。有关服务器日志发生这种情况的条件以及如何控制它的信息，请参阅第6.1.2.3节“密码和日志记录”。有关客户端日志记录的类似信息，请参阅第4.5.1.3节“MySQL客户端日志记录”。</p>
                </div>
                <p>
                    There are several aspects to the <a class="link" href="sql-syntax.html#create-user" title="13.7.1.2&nbsp;CREATE USER Syntax"><code class="literal">CREATE
                    USER</code></a> statement, described under the following topics:
                </p><p style="color:blue;">create user语句有几个方面，在以下主题中进行了描述：</p>
                <div class="itemizedlist">
                    <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><a class="xref" href="sql-syntax.html#create-user-overview" title="CREATE USER Overview">CREATE USER Overview</a></p><p style="color:blue;">创建用户概述</p></li><li class="listitem"><p><a class="xref" href="sql-syntax.html#create-user-authentication" title="CREATE USER Authentication Options">CREATE USER Authentication Options</a></p><p style="color:blue;">创建用户身份验证选项</p></li><li class="listitem"><p><a class="xref" href="sql-syntax.html#create-user-tls" title="CREATE USER SSL/TLS Options">CREATE USER SSL/TLS Options</a></p><p style="color:blue;">创建用户ssl/tls选项</p></li><li class="listitem"><p><a class="xref" href="sql-syntax.html#create-user-resource-limits" title="CREATE USER Resource-Limit Options">CREATE USER Resource-Limit Options</a></p><p style="color:blue;">创建用户资源限制选项</p></li><li class="listitem"><p><a class="xref" href="sql-syntax.html#create-user-password-management" title="CREATE USER Password-Management Options">CREATE USER Password-Management Options</a></p><p style="color:blue;">创建用户密码管理选项</p></li><li class="listitem"><p><a class="xref" href="sql-syntax.html#create-user-account-locking" title="CREATE USER Account-Locking Options">CREATE USER Account-Locking Options</a></p><p style="color:blue;">创建用户帐户锁定选项</p></li></ul>
                </div>

                <div class="simplesect">

                    <div class="titlepage">
                        <div>

                            <div class="simple">
                                <h5 class="title"><a name="create-user-overview"></a>CREATE USER Overview</h5>

                            </div>

                        </div>

                    </div>
                    <p>
                        For each account, <a class="link" href="sql-syntax.html#create-user" title="13.7.1.2&nbsp;CREATE USER Syntax"><code class="literal">CREATE USER</code></a>
                        creates a new row in the <code class="literal">mysql.user</code> system
                        table. The account row reflects the properties specified in
                        the statement. Unspecified properties are set to their default
                        values:
                    </p><p style="color:blue;">对于每个帐户，create user在mysql.user系统表中创建一个新行。account行反映语句中指定的属性。未指定的属性设置为其默认值：</p>
                    <div class="itemizedlist">
                        <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                            Authentication: The authentication plugin defined by the
                            <a class="link" href="server-administration.html#sysvar_default_authentication_plugin"><code class="literal">default_authentication_plugin</code></a>
                            system variable, and empty credentials
                        </p><p style="color:blue;">authentication：由默认的authentication plugin系统变量和空凭据定义的authentication plugin</p></li><li class="listitem"><p>
                            SSL/TLS: <code class="literal">NONE</code>
                        </p><p style="color:blue;">SSL/TLS:无</p></li><li class="listitem"><p>
                            Resource limits: Unlimited
                        </p><p style="color:blue;">资源限制：无限</p></li><li class="listitem"><p>
                            Password management: <code class="literal">PASSWORD EXPIRE
                            DEFAULT</code>
                        </p><p style="color:blue;">密码管理：默认密码过期</p></li><li class="listitem"><p>
                            Account locking: <code class="literal">ACCOUNT UNLOCK</code>
                        </p><p style="color:blue;">帐户锁定：帐户解锁</p></li></ul>
                    </div>
                    <p>
                        An account when first created has no privileges. To assign
                        privileges, use the <a class="link" href="sql-syntax.html#grant" title="13.7.1.4&nbsp;GRANT Syntax"><code class="literal">GRANT</code></a>
                        statement.
                    </p><p style="color:blue;">首次创建帐户时没有权限。要分配特权，请使用GRANT语句。</p><p>
                    Each account name uses the format described in
                    <a class="xref" href="security.html#account-names" title="6.2.4&nbsp;Specifying Account Names">Section&nbsp;6.2.4, “Specifying Account Names”</a>. For example:
                </p><p style="color:blue;">每个帐户名使用第6.2.4节“指定帐户名”中描述的格式。例如：</p><pre data-lang="sql" class="programlisting">CREATE USER 'jeffrey'@'localhost' IDENTIFIED BY '<em class="replaceable"><code>password</code></em>';
</pre><p>
                    The host name part of the account name, if omitted, defaults
                    to <code class="literal">'%'</code>.
                </p><p style="color:blue;">帐户名的主机名部分（如果省略）默认为“%”。</p><p>
                    Each <em class="replaceable"><code>user</code></em> value naming an account
                    may be followed by an optional
                    <em class="replaceable"><code>auth_option</code></em> value that indicates
                    how the account authenticates. These values enable account
                    authentication plugins and credentials (for example, a
                    password) to be specified. Each
                    <em class="replaceable"><code>auth_option</code></em> value applies
                    <span class="emphasis"><em>only</em></span> to the account named immediately
                    preceding it.
                </p><p style="color:blue;">命名帐户的每个用户值后面都可以跟一个可选的auth_选项值，该值指示帐户如何进行身份验证。这些值允许指定帐户身份验证插件和凭据（例如，密码）。每个auth_选项值仅应用于紧靠其前面命名的帐户。</p><p>
                    Following the <em class="replaceable"><code>user</code></em> specifications,
                    the statement may include options for SSL/TLS, resource-limit,
                    password-management, and locking properties. All such options
                    are <span class="emphasis"><em>global</em></span> to the statement and apply to
                    <span class="emphasis"><em>all</em></span> accounts named in the statement.
                </p><p style="color:blue;">根据用户规范，该语句可以包括ssl/tls、资源限制、密码管理和锁定属性的选项。所有这些选项都是语句的全局选项，并适用于语句中指定的所有帐户。</p><p>
                    Example: Create an account that uses the default
                    authentication plugin and the given password. Mark the
                    password expired so that the user must choose a new one at the
                    first connection to the server:
                </p><p style="color:blue;">示例：创建使用默认身份验证插件和给定密码的帐户。将密码标记为过期，以便用户必须在第一次连接到服务器时选择新密码：</p><pre data-lang="sql" class="programlisting">CREATE USER 'jeffrey'@'localhost'
  IDENTIFIED BY '<em class="replaceable"><code>new_password</code></em>' PASSWORD EXPIRE;
</pre><p>
                    Example: Create an account that uses the
                    <code class="literal">sha256_password</code> authentication plugin and
                    the given password. Require that a new password be chosen
                    every 180 days:
                </p><p style="color:blue;">示例：创建一个使用SHA256密码验证插件和给定密码的帐户。要求每180天选择一个新密码：</p><pre data-lang="sql" class="programlisting">CREATE USER 'jeffrey'@'localhost'
  IDENTIFIED WITH sha256_password BY '<em class="replaceable"><code>new_password</code></em>'
  PASSWORD EXPIRE INTERVAL 180 DAY;
</pre><p>
                    Example: Create multiple accounts, specifying some per-account
                    properties and some global properties:
                </p><p style="color:blue;">示例：创建多个帐户，指定一些每个帐户属性和一些全局属性：</p><pre data-lang="sql" class="programlisting">CREATE USER
  'jeffrey'@'localhost' IDENTIFIED WITH mysql_native_password
                                   BY '<em class="replaceable"><code>new_password1</code></em>',
  'jeanne'@'localhost' IDENTIFIED WITH sha256_password
                                  BY '<em class="replaceable"><code>new_password2</code></em>'
  REQUIRE X509 WITH MAX_QUERIES_PER_HOUR 60
  ACCOUNT LOCK;
</pre><p>
                    Each <em class="replaceable"><code>auth_option</code></em> value
                    (<code class="literal">IDENTIFIED WITH ... BY</code> in this case)
                    applies only to the account named immediately preceding it, so
                    each account uses the immediately following authentication
                    plugin and password.
                </p><p style="color:blue;">每个身份验证选项值（用…在本例中，by）只应用于紧跟在它前面的帐户，因此每个帐户都使用紧跟在它后面的身份验证插件和密码。</p><p>
                    The remaining properties apply globally to all accounts named
                    in the statement, so for both accounts:
                </p><p style="color:blue;">其余属性全局应用于语句中命名的所有帐户，因此对于这两个帐户：</p>
                    <div class="itemizedlist">
                        <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                            Connections must be made using a valid X.509 certificate.
                        </p><p style="color:blue;">必须使用有效的X.509证书进行连接。</p></li><li class="listitem"><p>
                            Up to 60 queries per hour are permitted.
                        </p><p style="color:blue;">每小时最多允许60次查询。</p></li><li class="listitem"><p>
                            The account is locked initially, so effectively it is a
                            placeholder and cannot be used until an administrator
                            unlocks it.
                        </p><p style="color:blue;">帐户最初被锁定，因此它实际上是一个占位符，只有管理员解除锁定后才能使用。</p></li></ul>
                    </div>

                </div>
                <div class="simplesect">
                    <div class="titlepage">
                        <div>
                            <div class="simple">
                                <h5 class="title"><a name="create-user-authentication"></a>CREATE USER Authentication Options</h5>

                            </div>

                        </div>

                    </div>
                    <p>
                        An account name may be followed by an
                        <em class="replaceable"><code>auth_option</code></em> authentication option
                        that specifies the account authentication plugin, credentials,
                        or both:
                    </p><p style="color:blue;">帐户名后面可以跟一个auth_option authentication选项，该选项指定帐户身份验证插件和/或凭据：</p>
                    <div class="itemizedlist">
                        <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                            <em class="replaceable"><code>auth_plugin</code></em> names an
                            authentication plugin. The plugin name can be a quoted
                            string literal or an unquoted name. Plugin names are
                            stored in the <code class="literal">plugin</code> column of the
                            <code class="literal">mysql.user</code> system table.
                        </p><p style="color:blue;">auth_plugin命名身份验证插件。插件名称可以是带引号的字符串文本或不带引号的名称。插件名称存储在mysql.user系统表的plugin列中。</p><p>
                            For <em class="replaceable"><code>auth_option</code></em> syntax that
                            does not specify an authentication plugin, the default
                            plugin is indicated by the value of the
                            <a class="link" href="server-administration.html#sysvar_default_authentication_plugin"><code class="literal">default_authentication_plugin</code></a>
                            system variable. For descriptions of each plugin, see
                            <a class="xref" href="security.html#authentication-plugins" title="6.4.1&nbsp;Authentication Plugins">Section&nbsp;6.4.1, “Authentication Plugins”</a>.
                        </p><p style="color:blue;">对于未指定身份验证插件的auth_选项语法，默认插件由default_authentication_plugin系统变量的值指示。有关每个插件的说明，请参见第6.4.1节“验证插件”。</p></li><li class="listitem"><p>
                            Credentials are stored in the
                            <code class="literal">mysql.user</code> system table. An
                            <code class="literal">'<em class="replaceable"><code>auth_string</code></em>'</code>
                            value specifies account credentials, either as a cleartext
                            (unencrypted) string or hashed in the format expected by
                            the authentication plugin associated with the account,
                            respectively:
                        </p><p style="color:blue;">凭据存储在mysql.user系统表中。“auth_string”值指定帐户凭据，分别为明文（未加密）字符串或按与帐户关联的身份验证插件所期望的格式哈希：</p>
                            <div class="itemizedlist">
                                <ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
                                    For syntax that uses <code class="literal">BY
                                    '<em class="replaceable"><code>auth_string</code></em>'</code>,
                                    the string is cleartext and is passed to the
                                    authentication plugin for possible hashing. The result
                                    returned by the plugin is stored in the
                                    <code class="literal">mysql.user</code> table. A plugin may use
                                    the value as specified, in which case no hashing
                                    occurs.
                                </p><p style="color:blue;">对于使用“auth_string”的语法，该字符串为明文，并传递给身份验证插件以进行可能的哈希处理。插件返回的结果存储在mysql.user表中。插件可以使用指定的值，在这种情况下不会发生哈希。</p></li><li class="listitem"><p>
                                    For syntax that uses <code class="literal">AS
                                    '<em class="replaceable"><code>auth_string</code></em>'</code>,
                                    the string is assumed to be already in the format the
                                    authentication plugin requires, and is stored as is in
                                    the <code class="literal">mysql.user</code> table. If a plugin
                                    requires a hashed value, the value must be already
                                    hashed in a format appropriate for the plugin, or the
                                    value will not be usable by the plugin and correct
                                    authentication of client connections will not occur.
                                </p><p style="color:blue;">对于使用“auth_string”的语法，假定该字符串已采用身份验证插件所需的格式，并按原样存储在mysql.user表中。如果插件需要散列值，则该值必须已经以适合该插件的格式进行散列，否则该值将无法被插件使用，并且不会对客户端连接进行正确的身份验证。</p></li><li class="listitem"><p>
                                    If an authentication plugin performs no hashing of the
                                    authentication string, the <code class="literal">BY
                                    '<em class="replaceable"><code>auth_string</code></em>'</code> and
                                    <code class="literal">AS
                                        '<em class="replaceable"><code>auth_string</code></em>'</code>
                                    clauses have the same effect: The authentication
                                    string is stored as is in the
                                    <code class="literal">mysql.user</code> system table.
                                </p><p style="color:blue;">如果身份验证插件不执行身份验证字符串的哈希运算，则by'auth_string'和as'auth_string'子句具有相同的效果：身份验证字符串按原样存储在mysql.user系统表中。</p></li></ul>
                            </div>
                        </li></ul>
                    </div>
                    <p>
                        <a class="link" href="sql-syntax.html#create-user" title="13.7.1.2&nbsp;CREATE USER Syntax"><code class="literal">CREATE USER</code></a> permits these
                        <em class="replaceable"><code>auth_option</code></em> syntaxes:
                    </p><p style="color:blue;">create user允许这些auth_选项语法：</p>
                    <div class="itemizedlist">
                        <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                            <code class="literal">IDENTIFIED BY
                                '<em class="replaceable"><code>auth_string</code></em>'</code>
                        </p><p style="color:blue;">由“auth_string”标识</p><p>
                            Sets the account authentication plugin to the default
                            plugin, passes the cleartext
                            <code class="literal">'<em class="replaceable"><code>auth_string</code></em>'</code>
                            value to the plugin for possible hashing, and stores the
                            result in the account row in the
                            <code class="literal">mysql.user</code> system table.
                        </p><p style="color:blue;">将帐户身份验证插件设置为默认插件，将明文“auth_string”值传递给插件以进行可能的哈希运算，并将结果存储在mysql.user系统表的帐户行中。</p></li><li class="listitem"><p>
                            <code class="literal">IDENTIFIED WITH
                                <em class="replaceable"><code>auth_plugin</code></em></code>
                        </p><p style="color:blue;">用auth_插件标识</p><p>
                            Sets the account authentication plugin to
                            <em class="replaceable"><code>auth_plugin</code></em>, clears the
                            credentials to the empty string, and stores the result in
                            the account row in the <code class="literal">mysql.user</code>
                            system table.
                        </p><p style="color:blue;">将帐户身份验证插件设置为auth_plugin，清除空字符串的凭据，并将结果存储在mysql.user system表的account行中。</p></li><li class="listitem"><p>
                            <code class="literal">IDENTIFIED WITH
                                <em class="replaceable"><code>auth_plugin</code></em> BY
                                '<em class="replaceable"><code>auth_string</code></em>'</code>
                        </p><p style="color:blue;">通过“auth_string”用auth_plugin标识</p><p>
                            Sets the account authentication plugin to
                            <em class="replaceable"><code>auth_plugin</code></em>, passes the
                            cleartext
                            <code class="literal">'<em class="replaceable"><code>auth_string</code></em>'</code>
                            value to the plugin for possible hashing, and stores the
                            result in the account row in the
                            <code class="literal">mysql.user</code> system table.
                        </p><p style="color:blue;">将帐户身份验证插件设置为auth_plugin，将明文“auth_string”值传递给插件以进行可能的哈希运算，并将结果存储在mysql.user系统表中的帐户行中。</p></li><li class="listitem"><p>
                            <code class="literal">IDENTIFIED WITH
                                <em class="replaceable"><code>auth_plugin</code></em> AS
                                '<em class="replaceable"><code>auth_string</code></em>'</code>
                        </p><p style="color:blue;">将auth_plugin标识为“auth_string”</p><p>
                            Sets the account authentication plugin to
                            <em class="replaceable"><code>auth_plugin</code></em> and stores the
                            <code class="literal">'<em class="replaceable"><code>auth_string</code></em>'</code>
                            value as is in the <code class="literal">mysql.user</code> account
                            row. If the plugin requires a hashed string, the string is
                            assumed to be already hashed in the format the plugin
                            requires.
                        </p><p style="color:blue;">将帐户身份验证插件设置为auth_plugin，并将“auth_string”值存储在mysql.user account行中。如果插件需要散列字符串，则假定该字符串已经按照插件所需的格式进行了散列。</p></li><li class="listitem"><p>
                            <code class="literal">IDENTIFIED BY PASSWORD
                                '<em class="replaceable"><code>auth_string</code></em>'</code>
                        </p><p style="color:blue;">由密码“auth_string”标识</p><p>
                            Sets the account authentication plugin to the default
                            plugin and stores the
                            <code class="literal">'<em class="replaceable"><code>auth_string</code></em>'</code>
                            value as is in the <code class="literal">mysql.user</code> account
                            row. If the plugin requires a hashed string, the string is
                            assumed to be already hashed in the format the plugin
                            requires.
                        </p><p style="color:blue;">将帐户身份验证插件设置为默认插件，并将“auth_string”值存储在mysql.user account行中。如果插件需要散列字符串，则假定该字符串已经按照插件所需的格式进行了散列。</p>
                            <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">

                                <div class="admon-title">
                                    Note
                                </div>
                                <p>
                                    <code class="literal">IDENTIFIED BY PASSWORD</code> syntax is
                                    deprecated and will be removed in a future MySQL
                                    release.
                                </p><p style="color:blue;">不推荐使用密码语法标识，并将在以后的MySQL版本中删除。</p>
                            </div>
                        </li></ul>
                    </div>
                    <p>
                        Example: Specify the password as cleartext; the default plugin
                        is used:
                    </p><p style="color:blue;">示例：将密码指定为明文；使用默认插件：</p><pre data-lang="sql" class="programlisting">CREATE USER 'jeffrey'@'localhost'
  IDENTIFIED BY '<em class="replaceable"><code>password</code></em>';
</pre><p>
                    Example: Specify the authentication plugin, along with a
                    cleartext password value:
                </p><p style="color:blue;">示例：指定身份验证插件以及明文密码值：</p><pre data-lang="sql" class="programlisting">CREATE USER 'jeffrey'@'localhost'
  IDENTIFIED WITH mysql_native_password BY '<em class="replaceable"><code>password</code></em>';
</pre><p>
                    In each case, the password value stored in the account row is
                    the cleartext value
                    <code class="literal">'<em class="replaceable"><code>password</code></em>'</code> after
                    it has been hashed by the authentication plugin associated
                    with the account.
                </p><p style="color:blue;">在每种情况下，存储在account行中的password值是cleartext值password，该值在与该帐户关联的身份验证插件对其进行散列之后。</p><p>
                    For additional information about setting passwords and
                    authentication plugins, see
                    <a class="xref" href="security.html#assigning-passwords" title="6.2.10&nbsp;Assigning Account Passwords">Section&nbsp;6.2.10, “Assigning Account Passwords”</a>, and
                    <a class="xref" href="security.html#pluggable-authentication" title="6.2.13&nbsp;Pluggable Authentication">Section&nbsp;6.2.13, “Pluggable Authentication”</a>.
                </p><p style="color:blue;">有关设置密码和身份验证插件的其他信息，请参阅第6.2.10节“分配帐户密码”和第6.2.13节“可插入身份验证”。</p>
                </div>
                <div class="simplesect">
                    <div class="titlepage">
                        <div>
                            <div class="simple">
                                <h5 class="title"><a name="create-user-tls"></a>CREATE USER SSL/TLS Options</h5>

                            </div>

                        </div>

                    </div>
                    <a class="indexterm" name="idm140286829863872"></a><a class="indexterm" name="idm140286829862416"></a><a class="indexterm" name="idm140286829860928"></a><p>
                    MySQL can check X.509 certificate attributes in addition to
                    the usual authentication that is based on the user name and
                    credentials. For background information on the use of SSL/TLS
                    with MySQL, see <a class="xref" href="security.html#encrypted-connections" title="6.3&nbsp;Using Encrypted Connections">Section&nbsp;6.3, “Using Encrypted Connections”</a>.
                </p><p style="color:blue;">除了基于用户名和凭据的常规身份验证之外，mysql还可以检查x.509证书属性。有关在mysql中使用ssl/tls的背景信息，请参见第6.3节“使用加密连接”。</p><p>
                    To specify SSL/TLS-related options for a MySQL account, use a
                    <code class="literal">REQUIRE</code> clause that specifies one or more
                    <em class="replaceable"><code>tls_option</code></em> values.
                </p><p style="color:blue;">要为mysql帐户指定与ssl/tls相关的选项，请使用指定一个或多个tls_选项值的require子句。</p><p>
                    Order of <code class="literal">REQUIRE</code> options does not matter,
                    but no option can be specified twice. The
                    <code class="literal">AND</code> keyword is optional between
                    <code class="literal">REQUIRE</code> options.
                </p><p style="color:blue;">Require选项的顺序无关紧要，但任何选项都不能指定两次。and关键字在require选项之间是可选的。</p><p>
                    <a class="link" href="sql-syntax.html#create-user" title="13.7.1.2&nbsp;CREATE USER Syntax"><code class="literal">CREATE USER</code></a> permits these
                    <em class="replaceable"><code>tls_option</code></em> values:
                </p><p style="color:blue;">create user允许这些tls_选项值：</p>
                    <div class="itemizedlist">
                        <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                            <code class="literal">NONE</code>
                        </p><p style="color:blue;">无</p><p>
                            Indicates that all accounts named by the statement have no
                            SSL or X.509 requirements. Unencrypted connections are
                            permitted if the user name and password are valid.
                            Encrypted connections can be used, at the client's option,
                            if the client has the proper certificate and key files.
                        </p><p style="color:blue;">指示由语句命名的所有帐户都没有SSL或X.509要求。如果用户名和密码有效，则允许未加密的连接。如果客户机具有正确的证书和密钥文件，则可以根据客户机的选择使用加密连接。</p><pre data-lang="sql" class="programlisting">CREATE USER 'jeffrey'@'localhost' REQUIRE NONE;
</pre><p>
                            Clients attempt to establish a secure connection by
                            default. For clients that have <code class="literal">REQUIRE
                            NONE</code>, the connection attempt falls back to an
                            unencrypted connection if a secure connection cannot be
                            established. To require an encrypted connection, a client
                            need specify only the
                            <a class="link" href="programs.html#option_general_ssl-mode"><code class="option">--ssl-mode=REQUIRED</code></a>
                            option; the connection attempt fails if a secure
                            connection cannot be established.
                        </p><p style="color:blue;">默认情况下，客户端尝试建立安全连接。对于不需要任何连接的客户端，如果无法建立安全连接，则连接尝试会返回到未加密的连接。要要求加密连接，客户端只需要指定--ssl mode=required选项；如果无法建立安全连接，则连接尝试失败。</p><p>
                            <code class="literal">NONE</code> is the default if no SSL-related
                            <code class="literal">REQUIRE</code> options are specified.
                        </p><p style="color:blue;">如果未指定与ssl相关的require选项，则默认为none。</p></li><li class="listitem"><p>
                            <code class="literal">SSL</code>
                        </p><p style="color:blue;">SSL协议</p><p>
                            Tells the server to permit only encrypted connections for
                            all accounts named by the statement.
                        </p><p style="color:blue;">告诉服务器只允许对由语句命名的所有帐户进行加密连接。</p><pre data-lang="sql" class="programlisting">CREATE USER 'jeffrey'@'localhost' REQUIRE SSL;
</pre><p>
                            Clients attempt to establish a secure connection by
                            default. For accounts that have <code class="literal">REQUIRE
                            SSL</code>, the connection attempt fails if a secure
                            connection cannot be established.
                        </p><p style="color:blue;">默认情况下，客户端尝试建立安全连接。对于需要SSL的帐户，如果无法建立安全连接，则连接尝试将失败。</p></li><li class="listitem"><p>
                            <code class="literal">X509</code>
                        </p><p style="color:blue;">X509年</p><p>
                            For all accounts named by the statement, requires that
                            clients present a valid certificate, but the exact
                            certificate, issuer, and subject do not matter. The only
                            requirement is that it should be possible to verify its
                            signature with one of the CA certificates. Use of X.509
                            certificates always implies encryption, so the
                            <code class="literal">SSL</code> option is unnecessary in this case.
                        </p><p style="color:blue;">对于由语句命名的所有帐户，要求客户端提供有效的证书，但确切的证书、颁发者和主题并不重要。唯一的要求是，应该可以用一个ca证书验证其签名。使用x.509证书总是意味着加密，因此在这种情况下不需要ssl选项。</p><pre data-lang="sql" class="programlisting">CREATE USER 'jeffrey'@'localhost' REQUIRE X509;
</pre><p>
                            For accounts with <code class="literal">REQUIRE X509</code>, clients
                            must specify the <a class="link" href="programs.html#option_general_ssl-key"><code class="option">--ssl-key</code></a>
                            and <a class="link" href="programs.html#option_general_ssl-cert"><code class="option">--ssl-cert</code></a> options to
                            connect. (It is recommended but not required that
                            <a class="link" href="programs.html#option_general_ssl-ca"><code class="option">--ssl-ca</code></a> also be specified
                            so that the public certificate provided by the server can
                            be verified.) This is true for <code class="literal">ISSUER</code>
                            and <code class="literal">SUBJECT</code> as well because those
                            <code class="literal">REQUIRE</code> options imply the requirements
                            of <code class="literal">X509</code>.
                        </p><p style="color:blue;">对于具有Require X509的帐户，客户端必须指定要连接的--ssl密钥和--ssl证书选项。（建议但不要求也指定--ssl ca，以便可以验证服务器提供的公共证书。）对于颁发者和使用者也是如此，因为这些要求选项意味着x509的要求。</p></li><li class="listitem"><p>
                            <code class="literal">ISSUER
                                '<em class="replaceable"><code>issuer</code></em>'</code>
                        </p><p style="color:blue;">发行人“发行人”</p><p>
                            For all accounts named by the statement, requires that
                            clients present a valid X.509 certificate issued by CA
                            <code class="literal">'<em class="replaceable"><code>issuer</code></em>'</code>. If
                            a client presents a certificate that is valid but has a
                            different issuer, the server rejects the connection. Use
                            of X.509 certificates always implies encryption, so the
                            <code class="literal">SSL</code> option is unnecessary in this case.
                        </p><p style="color:blue;">对于由语句命名的所有帐户，要求客户端提供由CA“Issuer”颁发的有效X.509证书。如果客户端提供的证书有效但具有不同的颁发者，服务器将拒绝连接。使用x.509证书总是意味着加密，因此在这种情况下不需要ssl选项。</p><pre data-lang="sql" class="programlisting">CREATE USER 'jeffrey'@'localhost'
  REQUIRE ISSUER '/C=SE/ST=Stockholm/L=Stockholm/
    O=MySQL/CN=CA/emailAddress=ca@example.com';
</pre><p>
                            Because <code class="literal">ISSUER</code> implies the requirements
                            of <code class="literal">X509</code>, clients must specify the
                            <a class="link" href="programs.html#option_general_ssl-key"><code class="option">--ssl-key</code></a> and
                            <a class="link" href="programs.html#option_general_ssl-cert"><code class="option">--ssl-cert</code></a> options to
                            connect. (It is recommended but not required that
                            <a class="link" href="programs.html#option_general_ssl-ca"><code class="option">--ssl-ca</code></a> also be specified
                            so that the public certificate provided by the server can
                            be verified.)
                        </p><p style="color:blue;">因为ISSUER表示X509的要求，所以客户端必须指定要连接的--ssl key和--ssl cert选项。（建议但不要求指定--ssl ca，以便可以验证服务器提供的公共证书。）</p></li><li class="listitem"><p>
                            <code class="literal">SUBJECT
                                '<em class="replaceable"><code>subject</code></em>'</code>
                        </p><p style="color:blue;">主题“主题”</p><p>
                            For all accounts named by the statement, requires that
                            clients present a valid X.509 certificate containing the
                            subject <em class="replaceable"><code>subject</code></em>. If a client
                            presents a certificate that is valid but has a different
                            subject, the server rejects the connection. Use of X.509
                            certificates always implies encryption, so the
                            <code class="literal">SSL</code> option is unnecessary in this case.
                        </p><p style="color:blue;">对于由语句命名的所有帐户，要求客户端提供包含主题主题的有效X.509证书。如果客户端提供的证书有效但具有不同的主题，服务器将拒绝连接。使用x.509证书总是意味着加密，因此在这种情况下不需要ssl选项。</p><pre data-lang="sql" class="programlisting">CREATE USER 'jeffrey'@'localhost'
  REQUIRE SUBJECT '/C=SE/ST=Stockholm/L=Stockholm/
    O=MySQL demo client certificate/
    CN=client/emailAddress=client@example.com';
</pre><p>
                            MySQL does a simple string comparison of the
                            <code class="literal">'<em class="replaceable"><code>subject</code></em>'</code>
                            value to the value in the certificate, so lettercase and
                            component ordering must be given exactly as present in the
                            certificate.
                        </p><p style="color:blue;">mysql将“subject”值与证书中的值进行简单的字符串比较，因此必须给出与证书中完全相同的字母大小写和组件顺序。</p><p>
                            Because <code class="literal">SUBJECT</code> implies the
                            requirements of <code class="literal">X509</code>, clients must
                            specify the <a class="link" href="programs.html#option_general_ssl-key"><code class="option">--ssl-key</code></a> and
                            <a class="link" href="programs.html#option_general_ssl-cert"><code class="option">--ssl-cert</code></a> options to
                            connect. (It is recommended but not required that
                            <a class="link" href="programs.html#option_general_ssl-ca"><code class="option">--ssl-ca</code></a> also be specified
                            so that the public certificate provided by the server can
                            be verified.)
                        </p><p style="color:blue;">因为subject表示x509的要求，所以客户端必须指定要连接的--ssl key和--ssl cert选项。（建议但不要求指定--ssl ca，以便可以验证服务器提供的公共证书。）</p></li><li class="listitem"><p>
                            <code class="literal">CIPHER
                                '<em class="replaceable"><code>cipher</code></em>'</code>
                        </p><p style="color:blue;">密码“密码”</p><p>
                            For all accounts named by the statement, requires a
                            specific cipher method for encrypting connections. This
                            option is needed to ensure that ciphers and key lengths of
                            sufficient strength are used. Encryption can be weak if
                            old algorithms using short encryption keys are used.
                        </p><p style="color:blue;">对于由语句命名的所有帐户，需要使用特定的密码方法来加密连接。此选项用于确保使用足够强度的密码和密钥长度。如果使用使用使用短加密密钥的旧算法，加密可能会很弱。</p><pre data-lang="sql" class="programlisting">CREATE USER 'jeffrey'@'localhost'
  REQUIRE CIPHER 'EDH-RSA-DES-CBC3-SHA';
</pre></li></ul>
                    </div>
                    <p>
                        The <code class="literal">SUBJECT</code>, <code class="literal">ISSUER</code>, and
                        <code class="literal">CIPHER</code> options can be combined in the
                        <code class="literal">REQUIRE</code> clause:
                    </p><p style="color:blue;">主题、颁发者和密码选项可以在REQUIRE子句中组合：</p><pre data-lang="sql" class="programlisting">CREATE USER 'jeffrey'@'localhost'
  REQUIRE SUBJECT '/C=SE/ST=Stockholm/L=Stockholm/
    O=MySQL demo client certificate/
    CN=client/emailAddress=client@example.com'
  AND ISSUER '/C=SE/ST=Stockholm/L=Stockholm/
    O=MySQL/CN=CA/emailAddress=ca@example.com'
  AND CIPHER 'EDH-RSA-DES-CBC3-SHA';
</pre>
                </div>
                <div class="simplesect">
                    <div class="titlepage">
                        <div>
                            <div class="simple">
                                <h5 class="title"><a name="create-user-resource-limits"></a>CREATE USER Resource-Limit Options</h5>

                            </div>

                        </div>

                    </div>
                    <a class="indexterm" name="idm140286829796784"></a><a class="indexterm" name="idm140286829795296"></a><p>
                    It is possible to place limits on use of server resources by
                    an account, as discussed in <a class="xref" href="security.html#user-resources" title="6.2.16&nbsp;Setting Account Resource Limits">Section&nbsp;6.2.16, “Setting Account Resource Limits”</a>.
                    To do so, use a <code class="literal">WITH</code> clause that specifies
                    one or more <em class="replaceable"><code>resource_option</code></em> values.
                </p><p style="color:blue;">如第6.2.16节“设置帐户资源限制”所述，可以对帐户使用服务器资源设置限制。为此，请使用指定一个或多个资源选项值的WITH子句。</p><p>
                    Order of <code class="literal">WITH</code> options does not matter,
                    except that if a given resource limit is specified multiple
                    times, the last instance takes precedence.
                </p><p style="color:blue;">WITH选项的顺序无关紧要，但如果多次指定给定的资源限制，则以最后一个实例为准。</p><p>
                    <a class="link" href="sql-syntax.html#create-user" title="13.7.1.2&nbsp;CREATE USER Syntax"><code class="literal">CREATE USER</code></a> permits these
                    <em class="replaceable"><code>resource_option</code></em> values:
                </p><p style="color:blue;">创建用户允许这些资源选项值：</p>
                    <div class="itemizedlist">
                        <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                            <code class="literal">MAX_QUERIES_PER_HOUR
                                <em class="replaceable"><code>count</code></em></code>,
                            <code class="literal">MAX_UPDATES_PER_HOUR
                                <em class="replaceable"><code>count</code></em></code>,
                            <code class="literal">MAX_CONNECTIONS_PER_HOUR
                                <em class="replaceable"><code>count</code></em></code>
                        </p><p style="color:blue;">每小时最大查询数、每小时最大更新数、每小时最大连接数</p><p>
                            For all accounts named by the statement, these options
                            restrict how many queries, updates, and connections to the
                            server are permitted to each account during any given
                            one-hour period. (Queries for which results are served
                            from the query cache do not count against the
                            <code class="literal">MAX_QUERIES_PER_HOUR</code> limit.) If
                            <em class="replaceable"><code>count</code></em> is <code class="literal">0</code>
                            (the default), this means that there is no limitation for
                            the account.
                        </p><p style="color:blue;">对于由语句命名的所有帐户，这些选项限制在任何给定的一小时内每个帐户允许查询、更新和连接到服务器的次数。（从查询缓存中提供结果的查询不计入每小时最大查询数限制。）如果计数为0（默认值），则表示该帐户没有限制。</p></li><li class="listitem"><p>
                            <code class="literal">MAX_USER_CONNECTIONS
                                <em class="replaceable"><code>count</code></em></code>
                        </p><p style="color:blue;">最大用户连接数</p><p>
                            For all accounts named by the statement, restricts the
                            maximum number of simultaneous connections to the server
                            by each account. A nonzero
                            <em class="replaceable"><code>count</code></em> specifies the limit for
                            the account explicitly. If
                            <em class="replaceable"><code>count</code></em> is <code class="literal">0</code>
                            (the default), the server determines the number of
                            simultaneous connections for the account from the global
                            value of the
                            <a class="link" href="server-administration.html#sysvar_max_user_connections"><code class="literal">max_user_connections</code></a>
                            system variable. If
                            <a class="link" href="server-administration.html#sysvar_max_user_connections"><code class="literal">max_user_connections</code></a> is
                            also zero, there is no limit for the account.
                        </p><p style="color:blue;">对于由该语句命名的所有帐户，通过每个帐户限制与服务器的同时连接的最大数量。非零计数显式指定帐户的限制。如果“计数”为0（默认值），则服务器将根据“最大用户连接数”系统变量的全局值确定帐户的同时连接数。如果max_user_connections也为零，则该帐户没有限制。</p></li></ul>
                    </div>
                    <p>
                        Example:
                    </p><p style="color:blue;">例子：</p><pre data-lang="sql" class="programlisting">CREATE USER 'jeffrey'@'localhost'
  WITH MAX_QUERIES_PER_HOUR 500 MAX_UPDATES_PER_HOUR 100;
</pre>
                </div>
                <div class="simplesect">
                    <div class="titlepage">
                        <div>
                            <div class="simple">
                                <h5 class="title"><a name="create-user-password-management"></a>CREATE USER Password-Management Options</h5>

                            </div>

                        </div>

                    </div>
                    <p>
                        Account passwords have an age, assessed from the date and time
                        of the most recent password change.
                    </p><p style="color:blue;">帐户密码有一个年龄，从最近密码更改的日期和时间开始计算。</p><p>
                    <a class="link" href="sql-syntax.html#create-user" title="13.7.1.2&nbsp;CREATE USER Syntax"><code class="literal">CREATE USER</code></a> supports several
                    <em class="replaceable"><code>password_option</code></em> values for password
                    expiration management, to either expire an account password
                    manually or establish its password expiration policy. Policy
                    options do not expire the password. Instead, they determine
                    how the server applies automatic expiration to the account
                    based on account password age. For a given account, its
                    password age is assessed from the date and time of the most
                    recent password change.
                </p><p style="color:blue;">create user支持多个密码过期管理的密码选项值，可以手动使帐户密码过期，也可以建立其密码过期策略。策略选项不会使密码过期。相反，它们决定服务器如何根据帐户密码期限对帐户应用自动过期。对于给定的帐户，其密码期限是从最近密码更改的日期和时间开始计算的。</p><p>
                    This section describes the syntax for password-management
                    options. For information about establishing policy for
                    password management, see
                    <a class="xref" href="security.html#password-management" title="6.2.11&nbsp;Password Management">Section&nbsp;6.2.11, “Password Management”</a>.
                </p><p style="color:blue;">本节介绍密码管理选项的语法。有关建立密码管理策略的信息，请参阅第6.2.11节“密码管理”。</p><p>
                    If multiple password-management options are specified, the
                    last one takes precedence.
                </p><p style="color:blue;">如果指定了多个密码管理选项，则以最后一个为准。</p><p>
                    These options apply only to accounts that use an
                    authentication plugin that stores credentials internally to
                    MySQL. For accounts that use plugins that perform
                    authentication against a credentials system that is external
                    to MySQL, password management must be handled externally
                    against that system as well. For more information about
                    internal credentials storage, see
                    <a class="xref" href="security.html#password-management" title="6.2.11&nbsp;Password Management">Section&nbsp;6.2.11, “Password Management”</a>.
                </p><p style="color:blue;">这些选项仅适用于使用身份验证插件的帐户，该插件在mysql内部存储凭据。对于使用插件对mysql外部的凭据系统执行身份验证的帐户，还必须对该系统在外部处理密码管理。有关内部凭据存储的更多信息，请参阅第6.2.11节“密码管理”。</p><p>
                    A client session operates in restricted mode if the account
                    password was expired manually or if the password age is
                    considered greater than its permitted lifetime per the
                    automatic expiration policy. In restricted mode, operations
                    performed within the session result in an error until the user
                    establishes a new account password. For information about
                    restricted mode, see
                    <a class="xref" href="security.html#expired-password-handling" title="6.2.12&nbsp;Server Handling of Expired Passwords">Section&nbsp;6.2.12, “Server Handling of Expired Passwords”</a>.
                </p><p style="color:blue;">如果帐户密码已手动过期，或者根据自动过期策略认为密码期限大于其允许的生存期，则客户端会话将在受限模式下运行。在受限模式下，在会话中执行的操作会导致错误，直到用户建立新的帐户密码。有关受限模式的信息，请参阅第6.2.12节“服务器处理过期密码”。</p><p>
                    <a class="link" href="sql-syntax.html#create-user" title="13.7.1.2&nbsp;CREATE USER Syntax"><code class="literal">CREATE USER</code></a> permits these
                    <em class="replaceable"><code>password_option</code></em> values for
                    controlling password expiration:
                </p><p style="color:blue;">CREATE USER允许使用这些密码选项值来控制密码过期：</p>
                    <div class="itemizedlist">
                        <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                            <code class="literal">PASSWORD EXPIRE</code>
                        </p><p style="color:blue;">密码过期</p><p>
                            Immediately marks the password expired for all accounts
                            named by the statement.
                        </p><p style="color:blue;">立即标记由语句命名的所有帐户的密码过期。</p><pre data-lang="sql" class="programlisting">CREATE USER 'jeffrey'@'localhost' PASSWORD EXPIRE;
</pre></li><li class="listitem"><p>
                            <code class="literal">PASSWORD EXPIRE DEFAULT</code>
                        </p><p style="color:blue;">密码过期默认值</p><p>
                            Sets all accounts named by the statement so that the
                            global expiration policy applies, as specified by the
                            <a class="link" href="server-administration.html#sysvar_default_password_lifetime"><code class="literal">default_password_lifetime</code></a>
                            system variable.
                        </p><p style="color:blue;">设置由语句命名的所有帐户，以便应用全局过期策略（由默认的密码生存期系统变量指定）。</p><pre data-lang="sql" class="programlisting">CREATE USER 'jeffrey'@'localhost' PASSWORD EXPIRE DEFAULT;
</pre></li><li class="listitem"><p>
                            <code class="literal">PASSWORD EXPIRE NEVER</code>
                        </p><p style="color:blue;">密码永不过期</p><p>
                            This expiration option overrides the global policy for all
                            accounts named by the statement. For each, it disables
                            password expiration so that the password never expires.
                        </p><p style="color:blue;">此过期选项将覆盖由语句命名的所有帐户的全局策略。对于每个密码，它都会禁用密码过期，这样密码就永远不会过期。</p><pre data-lang="sql" class="programlisting">CREATE USER 'jeffrey'@'localhost' PASSWORD EXPIRE NEVER;
</pre></li><li class="listitem"><p>
                            <code class="literal">PASSWORD EXPIRE INTERVAL
                                <em class="replaceable"><code>N</code></em> DAY</code>
                        </p><p style="color:blue;">密码过期间隔n天</p><p>
                            This expiration option overrides the global policy for all
                            accounts named by the statement. For each, it sets the
                            password lifetime to <em class="replaceable"><code>N</code></em> days.
                            The following statement requires the password to be
                            changed every 180 days:
                        </p><p style="color:blue;">此过期选项将覆盖由语句命名的所有帐户的全局策略。对于每个密码，它将密码生存期设置为n天。以下语句要求每180天更改一次密码：</p><pre data-lang="sql" class="programlisting">CREATE USER 'jeffrey'@'localhost' PASSWORD EXPIRE INTERVAL 180 DAY;
</pre></li></ul>
                    </div>

                </div>
                <div class="simplesect">
                    <div class="titlepage">
                        <div>
                            <div class="simple">
                                <h5 class="title"><a name="create-user-account-locking"></a>CREATE USER Account-Locking Options</h5>

                            </div>

                        </div>

                    </div>
                    <a class="indexterm" name="idm140286829745680"></a><p>
                    MySQL supports account locking and unlocking using the
                    <code class="literal">ACCOUNT LOCK</code> and <code class="literal">ACCOUNT
                    UNLOCK</code> options, which specify the locking state for
                    an account. For additional discussion, see
                    <a class="xref" href="security.html#account-locking" title="6.2.15&nbsp;Account Locking">Section&nbsp;6.2.15, “Account Locking”</a>.
                </p><p style="color:blue;">mysql支持使用account lock和account unlock选项进行帐户锁定和解锁，这两个选项指定帐户的锁定状态。有关其他讨论，请参见第6.2.15节“帐户锁定”。</p><p>
                    If multiple account-locking options are specified, the last
                    one takes precedence.
                </p><p style="color:blue;">如果指定了多个帐户锁定选项，则以最后一个为准。</p>
                </div>

            </div>
            <div class="section">
                <div class="titlepage">
                    <div>
                        <div>
                            <h4 class="title"><a name="drop-user"></a>13.7.1.3&nbsp;DROP USER Syntax</h4>

                        </div>

                    </div>

                </div>
                <a class="indexterm" name="idm140286829739616"></a><a class="indexterm" name="idm140286829738544"></a><a class="indexterm" name="idm140286829737056"></a><a class="indexterm" name="idm140286829735568"></a><a class="indexterm" name="idm140286829734080"></a><a class="indexterm" name="idm140286829732592"></a><a class="indexterm" name="idm140286829731104"></a><a class="indexterm" name="idm140286829729616"></a><a class="indexterm" name="idm140286829728128"></a><pre data-lang="sql" class="programlisting">DROP USER [IF EXISTS] <em class="replaceable"><code>user</code></em> [, <em class="replaceable"><code>user</code></em>] ...
</pre><p>
                The <a class="link" href="sql-syntax.html#drop-user" title="13.7.1.3&nbsp;DROP USER Syntax"><code class="literal">DROP USER</code></a> statement removes
                one or more MySQL accounts and their privileges. It removes
                privilege rows for the account from all grant tables.
            </p><p style="color:blue;">DROP USER语句删除一个或多个MySQL帐户及其权限。它从所有授予表中删除帐户的特权行。</p><p>
                To use <a class="link" href="sql-syntax.html#drop-user" title="13.7.1.3&nbsp;DROP USER Syntax"><code class="literal">DROP USER</code></a>, you must have
                the global <a class="link" href="security.html#priv_create-user"><code class="literal">CREATE USER</code></a> privilege,
                or the <a class="link" href="security.html#priv_delete"><code class="literal">DELETE</code></a> privilege for the
                <code class="literal">mysql</code> system database. When the
                <a class="link" href="server-administration.html#sysvar_read_only"><code class="literal">read_only</code></a> system variable is
                enabled, <a class="link" href="sql-syntax.html#drop-user" title="13.7.1.3&nbsp;DROP USER Syntax"><code class="literal">DROP USER</code></a> additionally
                requires the <a class="link" href="security.html#priv_super"><code class="literal">SUPER</code></a> privilege.
            </p><p style="color:blue;">要使用drop user，您必须具有mysql系统数据库的全局创建用户权限或删除权限。启用只读系统变量时，DROP USER还需要超级权限。</p><p>
                An error occurs if you try to drop an account that does not
                exist. If the <code class="literal">IF EXISTS</code> clause is given, the
                statement produces a warning for each named user that does not
                exist, rather than an error.
            </p><p style="color:blue;">如果尝试删除不存在的帐户，则会发生错误。如果给定IF存在子句，则语句为不存在的每个命名用户生成警告，而不是错误。</p><p>
                Each account name uses the format described in
                <a class="xref" href="security.html#account-names" title="6.2.4&nbsp;Specifying Account Names">Section&nbsp;6.2.4, “Specifying Account Names”</a>. For example:
            </p><p style="color:blue;">每个帐户名使用第6.2.4节“指定帐户名”中描述的格式。例如：</p><pre data-lang="sql" class="programlisting">DROP USER 'jeffrey'@'localhost';
</pre><p>
                The host name part of the account name, if omitted, defaults to
                <code class="literal">'%'</code>.
            </p><p style="color:blue;">帐户名的主机名部分（如果省略）默认为“%”。</p>
                <div class="important" style="margin-left: 0.5in; margin-right: 0.5in;">

                    <div class="admon-title">
                        Important
                    </div>
                    <p>
                        <a class="link" href="sql-syntax.html#drop-user" title="13.7.1.3&nbsp;DROP USER Syntax"><code class="literal">DROP USER</code></a> does not
                        automatically close any open user sessions. Rather, in the
                        event that a user with an open session is dropped, the
                        statement does not take effect until that user's session is
                        closed. Once the session is closed, the user is dropped, and
                        that user's next attempt to log in will fail. <span class="emphasis"><em>This
          is by design</em></span>.
                    </p><p style="color:blue;">drop user不会自动关闭任何打开的用户会话。相反，如果具有打开会话的用户被删除，则该语句在该用户的会话关闭之前不会生效。会话关闭后，将删除该用户，该用户下次登录的尝试将失败。这是故意的。</p>
                </div>
                <p>
                    <a class="link" href="sql-syntax.html#drop-user" title="13.7.1.3&nbsp;DROP USER Syntax"><code class="literal">DROP USER</code></a> does not automatically
                    drop or invalidate databases or objects within them that the old
                    user created. This includes stored programs or views for which
                    the <code class="literal">DEFINER</code> attribute names the dropped user.
                    Attempts to access such objects may produce an error if they
                    execute in definer security context. (For information about
                    security context, see
                    <a class="xref" href="stored-objects.html#stored-objects-security" title="23.6&nbsp;Stored Object Access Control">Section&nbsp;23.6, “Stored Object Access Control”</a>.)
                </p><p style="color:blue;">删除用户不会自动删除或使旧用户创建的数据库或其中的对象无效。这包括definer属性为其命名被删除用户的存储程序或视图。如果这些对象在定义的安全上下文中执行，则访问这些对象的尝试可能会产生错误。（有关安全上下文的信息，请参阅第23.6节“存储对象访问控制”。）</p>
            </div>
            <div class="section">
                <div class="titlepage">
                    <div>
                        <div>
                            <h4 class="title"><a name="grant"></a>13.7.1.4&nbsp;GRANT Syntax</h4>

                        </div>

                    </div>

                </div>
                <a class="indexterm" name="idm140286829699344"></a><a class="indexterm" name="idm140286829698272"></a><a class="indexterm" name="idm140286829697184"></a><a class="indexterm" name="idm140286829695696"></a><a class="indexterm" name="idm140286829694624"></a><pre data-lang="sql" class="programlisting">GRANT
    <em class="replaceable"><code>priv_type</code></em> [(<em class="replaceable"><code>column_list</code></em>)]
      [, <em class="replaceable"><code>priv_type</code></em> [(<em class="replaceable"><code>column_list</code></em>)]] ...
    ON [<em class="replaceable"><code>object_type</code></em>] <em class="replaceable"><code>priv_level</code></em>
    TO <em class="replaceable"><code>user</code></em> [<em class="replaceable"><code>auth_option</code></em>] [, <em class="replaceable"><code>user</code></em> [<em class="replaceable"><code>auth_option</code></em>]] ...
    [REQUIRE {NONE | <em class="replaceable"><code>tls_option</code></em> [[AND] <em class="replaceable"><code>tls_option</code></em>] ...}]
    [WITH {GRANT OPTION | <em class="replaceable"><code>resource_option</code></em>} ...]

GRANT PROXY ON <em class="replaceable"><code>user</code></em>
    TO <em class="replaceable"><code>user</code></em> [, <em class="replaceable"><code>user</code></em>] ...
    [WITH GRANT OPTION]

<em class="replaceable"><code>object_type</code></em>: {
    TABLE
  | FUNCTION
  | PROCEDURE
}

<em class="replaceable"><code>priv_level</code></em>: {
    *
  | *.*
  | <em class="replaceable"><code>db_name</code></em>.*
  | <em class="replaceable"><code>db_name.tbl_name</code></em>
  | <em class="replaceable"><code>tbl_name</code></em>
  | <em class="replaceable"><code>db_name</code></em>.<em class="replaceable"><code>routine_name</code></em>
}

<em class="replaceable"><code>user</code></em>:
    (see <a class="xref" href="security.html#account-names" title="6.2.4&nbsp;Specifying Account Names">Section&nbsp;6.2.4, “Specifying Account Names”</a>)

<em class="replaceable"><code>auth_option</code></em>: {
    IDENTIFIED BY '<em class="replaceable"><code>auth_string</code></em>'
  | IDENTIFIED WITH <em class="replaceable"><code>auth_plugin</code></em>
  | IDENTIFIED WITH <em class="replaceable"><code>auth_plugin</code></em> BY '<em class="replaceable"><code>auth_string</code></em>'
  | IDENTIFIED WITH <em class="replaceable"><code>auth_plugin</code></em> AS '<em class="replaceable"><code>auth_string</code></em>'
  | IDENTIFIED BY PASSWORD '<em class="replaceable"><code>auth_string</code></em>'
}

<em class="replaceable"><code>tls_option</code></em>: {
    SSL
  | X509
  | CIPHER '<em class="replaceable"><code>cipher</code></em>'
  | ISSUER '<em class="replaceable"><code>issuer</code></em>'
  | SUBJECT '<em class="replaceable"><code>subject</code></em>'
}

<em class="replaceable"><code>resource_option</code></em>: {
  | MAX_QUERIES_PER_HOUR <em class="replaceable"><code>count</code></em>
  | MAX_UPDATES_PER_HOUR <em class="replaceable"><code>count</code></em>
  | MAX_CONNECTIONS_PER_HOUR <em class="replaceable"><code>count</code></em>
  | MAX_USER_CONNECTIONS <em class="replaceable"><code>count</code></em>
}
</pre><p>
                The <a class="link" href="sql-syntax.html#grant" title="13.7.1.4&nbsp;GRANT Syntax"><code class="literal">GRANT</code></a> statement grants
                privileges to MySQL user accounts. There are several aspects to
                the <a class="link" href="sql-syntax.html#grant" title="13.7.1.4&nbsp;GRANT Syntax"><code class="literal">GRANT</code></a> statement, described
                under the following topics:
            </p><p style="color:blue;">grant语句将特权授予mysql用户帐户。GRANT语句有几个方面，在以下主题下介绍：</p>
                <div class="itemizedlist">
                    <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><a class="xref" href="sql-syntax.html#grant-overview" title="GRANT General Overview">GRANT General Overview</a></p><p style="color:blue;">赠款概述</p></li><li class="listitem"><p><a class="xref" href="sql-syntax.html#grant-quoting" title="Object Quoting Guidelines">Object Quoting Guidelines</a></p><p style="color:blue;">目标报价指南</p></li><li class="listitem"><p><a class="xref" href="sql-syntax.html#grant-privileges" title="Privileges Supported by MySQL">Privileges Supported by MySQL</a></p><p style="color:blue;">MySQL支持的权限</p></li><li class="listitem"><p><a class="xref" href="sql-syntax.html#grant-accounts-passwords" title="Account Names and Passwords">Account Names and Passwords</a></p><p style="color:blue;">帐户名和密码</p></li><li class="listitem"><p><a class="xref" href="sql-syntax.html#grant-global-privileges" title="Global Privileges">Global Privileges</a></p><p style="color:blue;">全局特权</p></li><li class="listitem"><p><a class="xref" href="sql-syntax.html#grant-database-privileges" title="Database Privileges">Database Privileges</a></p><p style="color:blue;">数据库特权</p></li><li class="listitem"><p><a class="xref" href="sql-syntax.html#grant-table-privileges" title="Table Privileges">Table Privileges</a></p><p style="color:blue;">表特权</p></li><li class="listitem"><p><a class="xref" href="sql-syntax.html#grant-column-privileges" title="Column Privileges">Column Privileges</a></p><p style="color:blue;">列权限</p></li><li class="listitem"><p><a class="xref" href="sql-syntax.html#grant-routine-privileges" title="Stored Routine Privileges">Stored Routine Privileges</a></p><p style="color:blue;">存储的例程特权</p></li><li class="listitem"><p><a class="xref" href="sql-syntax.html#grant-proxy-privileges" title="Proxy User Privileges">Proxy User Privileges</a></p><p style="color:blue;">代理用户权限</p></li><li class="listitem"><p><a class="xref" href="sql-syntax.html#grant-account-creation" title="Implicit Account Creation">Implicit Account Creation</a></p><p style="color:blue;">隐式帐户创建</p></li><li class="listitem"><p><a class="xref" href="sql-syntax.html#grant-other-characteristics" title="Other Account Characteristics">Other Account Characteristics</a></p><p style="color:blue;">其他账户特征</p></li><li class="listitem"><p><a class="xref" href="sql-syntax.html#grant-mysql-vs-standard-sql" title="MySQL and Standard SQL Versions of GRANT">MySQL and Standard SQL Versions of GRANT</a></p><p style="color:blue;">grant的mysql和标准sql版本</p></li></ul>
                </div>

                <div class="simplesect">

                    <div class="titlepage">
                        <div>

                            <div class="simple">
                                <h5 class="title"><a name="grant-overview"></a>GRANT General Overview</h5>

                            </div>

                        </div>

                    </div>
                    <p>
                        The <a class="link" href="sql-syntax.html#grant" title="13.7.1.4&nbsp;GRANT Syntax"><code class="literal">GRANT</code></a> statement grants
                        privileges to MySQL user accounts.
                    </p><p style="color:blue;">grant语句将特权授予mysql用户帐户。</p><p>
                    To use <a class="link" href="sql-syntax.html#grant" title="13.7.1.4&nbsp;GRANT Syntax"><code class="literal">GRANT</code></a>, you must have the
                    <a class="link" href="security.html#priv_grant-option"><code class="literal">GRANT OPTION</code></a> privilege, and you
                    must have the privileges that you are granting. When the
                    <a class="link" href="server-administration.html#sysvar_read_only"><code class="literal">read_only</code></a> system variable is
                    enabled, <a class="link" href="sql-syntax.html#grant" title="13.7.1.4&nbsp;GRANT Syntax"><code class="literal">GRANT</code></a> additionally
                    requires the <a class="link" href="security.html#priv_super"><code class="literal">SUPER</code></a> privilege.
                </p><p style="color:blue;">要使用grant，您必须具有grant option特权，并且您必须具有正在授予的特权。启用只读系统变量时，GRANT还需要超级权限。</p><p>
                    The <a class="link" href="sql-syntax.html#revoke" title="13.7.1.6&nbsp;REVOKE Syntax"><code class="literal">REVOKE</code></a> statement is related
                    to <a class="link" href="sql-syntax.html#grant" title="13.7.1.4&nbsp;GRANT Syntax"><code class="literal">GRANT</code></a> and enables
                    administrators to remove account privileges. See
                    <a class="xref" href="sql-syntax.html#revoke" title="13.7.1.6&nbsp;REVOKE Syntax">Section&nbsp;13.7.1.6, “REVOKE Syntax”</a>.
                </p><p style="color:blue;">revoke语句与grant相关，使管理员能够删除帐户权限。见第13.7.1.6节“撤销语法”。</p><p>
                    Each account name uses the format described in
                    <a class="xref" href="security.html#account-names" title="6.2.4&nbsp;Specifying Account Names">Section&nbsp;6.2.4, “Specifying Account Names”</a>. For example:
                </p><p style="color:blue;">每个帐户名使用第6.2.4节“指定帐户名”中描述的格式。例如：</p><pre data-lang="sql" class="programlisting">GRANT ALL ON db1.* TO 'jeffrey'@'localhost';
</pre><p>
                    The host name part of the account, if omitted, defaults to
                    <code class="literal">'%'</code>.
                </p><p style="color:blue;">帐户的主机名部分（如果省略）默认为“%”。</p><p>
                    Normally, a database administrator first uses
                    <a class="link" href="sql-syntax.html#create-user" title="13.7.1.2&nbsp;CREATE USER Syntax"><code class="literal">CREATE USER</code></a> to create an
                    account and define its nonprivilege characteristics such as
                    its password, whether it uses secure connections, and limits
                    on access to server resources, then uses
                    <a class="link" href="sql-syntax.html#grant" title="13.7.1.4&nbsp;GRANT Syntax"><code class="literal">GRANT</code></a> to define its privileges.
                    <a class="link" href="sql-syntax.html#alter-user" title="13.7.1.1&nbsp;ALTER USER Syntax"><code class="literal">ALTER USER</code></a> may be used to
                    change the nonprivilege characteristics of existing accounts.
                    For example:
                </p><p style="color:blue;">通常，数据库管理员首先使用create user创建帐户并定义其非特权特性，如密码、是否使用安全连接以及对服务器资源的访问限制，然后使用grant定义其特权。可以使用ALTE用户更改现有帐户的非特权特性。例如：</p><pre data-lang="sql" class="programlisting">CREATE USER 'jeffrey'@'localhost' IDENTIFIED BY '<em class="replaceable"><code>password</code></em>';
GRANT ALL ON db1.* TO 'jeffrey'@'localhost';
GRANT SELECT ON db2.invoice TO 'jeffrey'@'localhost';
ALTER USER 'jeffrey'@'localhost' WITH MAX_QUERIES_PER_HOUR 90;
</pre>
                    <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">

                        <div class="admon-title">
                            Note
                        </div>
                        <p>
                            Examples shown here include no <code class="literal">IDENTIFIED</code>
                            clause. It is assumed that you establish passwords with
                            <a class="link" href="sql-syntax.html#create-user" title="13.7.1.2&nbsp;CREATE USER Syntax"><code class="literal">CREATE USER</code></a> at
                            account-creation time to avoid creating insecure accounts.
                        </p><p style="color:blue;">此处显示的示例不包括已标识的子句。假设您在创建帐户时与create user建立密码，以避免创建不安全的帐户。</p>
                    </div>
                    <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">
                        <div class="admon-title">
                            Note
                        </div>
                        <p>
                            If an account named in a
                            <a class="link" href="sql-syntax.html#grant" title="13.7.1.4&nbsp;GRANT Syntax"><code class="literal">GRANT</code></a> statement does not
                            already exist, <a class="link" href="sql-syntax.html#grant" title="13.7.1.4&nbsp;GRANT Syntax"><code class="literal">GRANT</code></a> may
                            create it under the conditions described later in the
                            discussion of the
                            <a class="link" href="server-administration.html#sqlmode_no_auto_create_user"><code class="literal">NO_AUTO_CREATE_USER</code></a> SQL
                            mode. It is also possible to use
                            <a class="link" href="sql-syntax.html#grant" title="13.7.1.4&nbsp;GRANT Syntax"><code class="literal">GRANT</code></a> to specify nonprivilege
                            account characteristics such as whether it uses secure
                            connections and limits on access to server resources.
                        </p><p style="color:blue;">如果在GRANT语句中命名的帐户还不存在，则Grand可以在NoAutoPoCeraTySQL用户模式的讨论之后描述的条件下创建它。还可以使用grant指定非特权帐户特性，例如它是否使用安全连接和对服务器资源的访问限制。</p><p>
                        However, use of <a class="link" href="sql-syntax.html#grant" title="13.7.1.4&nbsp;GRANT Syntax"><code class="literal">GRANT</code></a> to
                        create accounts or define nonprivilege characteristics is
                        deprecated as of MySQL 5.7.6. Instead, perform these tasks
                        using <a class="link" href="sql-syntax.html#create-user" title="13.7.1.2&nbsp;CREATE USER Syntax"><code class="literal">CREATE USER</code></a> or
                        <a class="link" href="sql-syntax.html#alter-user" title="13.7.1.1&nbsp;ALTER USER Syntax"><code class="literal">ALTER USER</code></a>.
                    </p><p style="color:blue;">但是，从mysql 5.7.6开始，不赞成使用grant创建帐户或定义非特权特性。相反，使用create user或alter user执行这些任务。</p>
                    </div>
                    <p>
                        From the <a class="link" href="programs.html#mysql" title="4.5.1&nbsp;mysql — The MySQL Command-Line Client"><span class="command"><strong>mysql</strong></span></a> program,
                        <a class="link" href="sql-syntax.html#grant" title="13.7.1.4&nbsp;GRANT Syntax"><code class="literal">GRANT</code></a> responds with
                        <code class="literal">Query OK, 0 rows affected</code> when executed
                        successfully. To determine what privileges result from the
                        operation, use <a class="link" href="sql-syntax.html#show-grants" title="13.7.5.21&nbsp;SHOW GRANTS Syntax"><code class="literal">SHOW GRANTS</code></a>. See
                        <a class="xref" href="sql-syntax.html#show-grants" title="13.7.5.21&nbsp;SHOW GRANTS Syntax">Section&nbsp;13.7.5.21, “SHOW GRANTS Syntax”</a>.
                    </p><p style="color:blue;">在mysql程序中，grant用query ok响应，成功执行时0行受影响。要确定操作产生的特权，请使用show grants。见第13.7.5.21节，“显示授权语法”。</p>
                    <div class="important" style="margin-left: 0.5in; margin-right: 0.5in;">

                        <div class="admon-title">
                            Important
                        </div>
                        <p>
                            Under some circumstances,
                            <a class="link" href="sql-syntax.html#grant" title="13.7.1.4&nbsp;GRANT Syntax"><code class="literal">GRANT</code></a> may be recorded in
                            server logs or on the client side in a history file such as
                            <code class="filename">~/.mysql_history</code>, which means that
                            cleartext passwords may be read by anyone having read access
                            to that information. For information about the conditions
                            under which this occurs for the server logs and how to
                            control it, see <a class="xref" href="security.html#password-logging" title="6.1.2.3&nbsp;Passwords and Logging">Section&nbsp;6.1.2.3, “Passwords and Logging”</a>. For
                            similar information about client-side logging, see
                            <a class="xref" href="programs.html#mysql-logging" title="4.5.1.3&nbsp;mysql Client Logging">Section&nbsp;4.5.1.3, “mysql Client Logging”</a>.
                        </p><p style="color:blue;">在某些情况下，grant可能会记录在服务器日志中，或者记录在客户机端的历史文件（如~/.mysql_history）中，这意味着任何有权读取该信息的人都可以读取明文密码。有关服务器日志发生这种情况的条件以及如何控制它的信息，请参阅第6.1.2.3节“密码和日志记录”。有关客户端日志记录的类似信息，请参阅第4.5.1.3节“MySQL客户端日志记录”。</p>
                    </div>
                    <p>
                        <a class="link" href="sql-syntax.html#grant" title="13.7.1.4&nbsp;GRANT Syntax"><code class="literal">GRANT</code></a> supports host names up to
                        60 characters long. User names can be up to 32 characters.
                        Database, table, column, and routine names can be up to 64
                        characters.
                    </p><p style="color:blue;">grant支持最长60个字符的主机名。用户名最多可包含32个字符。数据库、表、列和例程名称最多可以包含64个字符。</p>
                    <div class="warning" style="margin-left: 0.5in; margin-right: 0.5in;">

                        <div class="admon-title">
                            Warning
                        </div>
                        <p>
            <span class="emphasis"><em>Do not attempt to change the permissible length
            for user names by altering the <code class="literal">mysql.user</code>
            system table. Doing so results in unpredictable behavior
            which may even make it impossible for users to log in to the
            MySQL server</em></span>. Never alter the structure of tables
                            in the <code class="literal">mysql</code> system database in any
                            manner except by means of the procedure described in
                            <a class="xref" href="installing.html#upgrading" title="2.11&nbsp;Upgrading MySQL">Section&nbsp;2.11, “Upgrading MySQL”</a>.
                        </p><p style="color:blue;">不要试图通过更改mysql.user系统表来更改用户名的允许长度。这样做会导致不可预知的行为，甚至可能使用户无法登录到mysql服务器。除非通过第2.11节“升级mysql”中描述的过程，否则不要以任何方式更改mysql系统数据库中表的结构。</p>
                    </div>

                </div>
                <div class="simplesect">
                    <div class="titlepage">
                        <div>
                            <div class="simple">
                                <h5 class="title"><a name="grant-quoting"></a>Object Quoting Guidelines</h5>

                            </div>

                        </div>

                    </div>
                    <a class="indexterm" name="idm140286829599472"></a><p>
                    Several objects within <a class="link" href="sql-syntax.html#grant" title="13.7.1.4&nbsp;GRANT Syntax"><code class="literal">GRANT</code></a>
                    statements are subject to quoting, although quoting is
                    optional in many cases: Account, database, table, column, and
                    routine names. For example, if a
                    <em class="replaceable"><code>user_name</code></em> or
                    <em class="replaceable"><code>host_name</code></em> value in an account name
                    is legal as an unquoted identifier, you need not quote it.
                    However, quotation marks are necessary to specify a
                    <em class="replaceable"><code>user_name</code></em> string containing special
                    characters (such as <code class="literal">-</code>), or a
                    <em class="replaceable"><code>host_name</code></em> string containing special
                    characters or wildcard characters such as <code class="literal">%</code>
                    (for example, <code class="literal">'test-user'@'%.com'</code>). Quote
                    the user name and host name separately.
                </p><p style="color:blue;">GRANT语句中的几个对象都要引用，尽管在许多情况下引用是可选的：帐户、数据库、表、列和例程名称。例如，如果帐户名中的用户名或主机名值作为未引用的标识符是合法的，则无需对其进行引用。但是，引号对于指定包含特殊字符（如-）的用户名字符串或包含特殊字符或通配符（如%“test user”@“%.com”）的主机名字符串是必需的。分别引用用户名和主机名。</p><p>
                    To specify quoted values:
                </p><p style="color:blue;">要指定带引号的值：</p>
                    <div class="itemizedlist">
                        <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                            Quote database, table, column, and routine names as
                            identifiers.
                        </p><p style="color:blue;">引用数据库、表、列和例程名称作为标识符。</p></li><li class="listitem"><p>
                            Quote user names and host names as identifiers or as
                            strings.
                        </p><p style="color:blue;">引用用户名和主机名作为标识符或字符串。</p></li><li class="listitem"><p>
                            Quote passwords as strings.
                        </p><p style="color:blue;">以字符串形式引用密码。</p></li></ul>
                    </div>
                    <p>
                        For string-quoting and identifier-quoting guidelines, see
                        <a class="xref" href="language-structure.html#string-literals" title="9.1.1&nbsp;String Literals">Section&nbsp;9.1.1, “String Literals”</a>, and
                        <a class="xref" href="language-structure.html#identifiers" title="9.2&nbsp;Schema Object Names">Section&nbsp;9.2, “Schema Object Names”</a>.
                    </p><p style="color:blue;">有关字符串引用和标识符引用准则，请参阅第9.1.1节“字符串文本”和第9.2节“架构对象名称”。</p><p>
                    The <code class="literal">_</code> and <code class="literal">%</code> wildcards
                    are permitted when specifying database names in
                    <a class="link" href="sql-syntax.html#grant" title="13.7.1.4&nbsp;GRANT Syntax"><code class="literal">GRANT</code></a> statements that grant
                    privileges at the database level (<code class="literal">GRANT ... ON
                    <em class="replaceable"><code>db_name</code></em>.*</code>). This means,
                    for example, that to use a <code class="literal">_</code> character as
                    part of a database name, specify it as <code class="literal">\_</code>
                    in the <a class="link" href="sql-syntax.html#grant" title="13.7.1.4&nbsp;GRANT Syntax"><code class="literal">GRANT</code></a> statement, to
                    prevent the user from being able to access additional
                    databases matching the wildcard pattern (for example,
                    <code class="literal">GRANT ... ON `foo\_bar`.* TO ...</code>).
                </p><p style="color:blue;">在授予数据库级权限的GRANT语句（GRANT…在db_name.*上）。这意味着，例如，要将字符用作数据库名称的一部分，请在GRANT语句中将其指定为，以防止用户访问与通配符模式匹配的其他数据库（例如，GRANT…在“foo”酒吧`.*到…。</p><p>
                    When a database name not is used to grant privileges at the
                    database level, but as a qualifier for granting privileges to
                    some other object such as a table or routine (for example,
                    <code class="literal">GRANT ... ON
                        <em class="replaceable"><code>db_name</code></em>.<em class="replaceable"><code>tbl_name</code></em></code>),
                    wildcard characters are treated as normal characters.
                </p><p style="color:blue;">当数据库名称不是用于在数据库级别授予权限，而是用作向某些其他对象（如表或例程）授予权限的限定符时（例如，授予…在db_name.tbl_name上，通配符被视为普通字符。</p>
                </div>
                <div class="simplesect">
                    <div class="titlepage">
                        <div>
                            <div class="simple">
                                <h5 class="title"><a name="grant-privileges"></a>Privileges Supported by MySQL</h5>

                            </div>

                        </div>

                    </div>
                    <p>
                        The following table summarizes the permissible
                        <em class="replaceable"><code>priv_type</code></em> privilege types that can
                        be specified for the <a class="link" href="sql-syntax.html#grant" title="13.7.1.4&nbsp;GRANT Syntax"><code class="literal">GRANT</code></a> and
                        <a class="link" href="sql-syntax.html#revoke" title="13.7.1.6&nbsp;REVOKE Syntax"><code class="literal">REVOKE</code></a> statements, and the
                        levels at which each privilege can be granted. For additional
                        information about each privilege, see
                        <a class="xref" href="security.html#privileges-provided" title="6.2.2&nbsp;Privileges Provided by MySQL">Section&nbsp;6.2.2, “Privileges Provided by MySQL”</a>.
                    </p><p style="color:blue;">下表总结了可以为GRANT和REVOKE语句指定的允许的PRIV U类型特权类型，以及授予每个特权的级别。有关每个特权的更多信息，请参见第6.2.2节“MySQL提供的特权”。</p>
                    <div class="table">
                        <a name="idm140286829571280"></a><p class="title"><b>Table&nbsp;13.8&nbsp;Permissible Privileges for GRANT and REVOKE</b></p><p style="color:blue;">表13.8授予和撤销的允许特权</p>
                        <div class="table-contents">
                            <table><colgroup><col width="30%"><col width="70%"></colgroup><thead><tr>
                                <th scope="col">Privilege</th>
                                <th scope="col">Meaning and Grantable Levels</th>
                            </tr></thead><tbody><tr>
                                <td scope="row"><a class="link" href="security.html#priv_all"><code class="literal">ALL [PRIVILEGES]</code></a></td>
                                <td>Grant all privileges at specified access level except
                                    <a class="link" href="security.html#priv_grant-option"><code class="literal">GRANT OPTION</code></a> and
                                    <a class="link" href="security.html#priv_proxy"><code class="literal">PROXY</code></a>.</td>
                            </tr><tr>
                                <td scope="row"><a class="link" href="security.html#priv_alter"><code class="literal">ALTER</code></a></td>
                                <td>Enable use of <a class="link" href="sql-syntax.html#alter-table" title="13.1.8&nbsp;ALTER TABLE Syntax"><code class="literal">ALTER TABLE</code></a>. Levels:
                                    Global, database, table.</td>
                            </tr><tr>
                                <td scope="row"><a class="link" href="security.html#priv_alter-routine"><code class="literal">ALTER ROUTINE</code></a></td>
                                <td>Enable stored routines to be altered or dropped. Levels: Global,
                                    database, routine.</td>
                            </tr><tr>
                                <td scope="row"><a class="link" href="security.html#priv_create"><code class="literal">CREATE</code></a></td>
                                <td>Enable database and table creation. Levels: Global, database, table.</td>
                            </tr><tr>
                                <td scope="row"><a class="link" href="security.html#priv_create-routine"><code class="literal">CREATE ROUTINE</code></a></td>
                                <td>Enable stored routine creation. Levels: Global, database.</td>
                            </tr><tr>
                                <td scope="row"><a class="link" href="security.html#priv_create-tablespace"><code class="literal">CREATE TABLESPACE</code></a></td>
                                <td>Enable tablespaces and log file groups to be created, altered, or
                                    dropped. Level: Global.</td>
                            </tr><tr>
                                <td scope="row"><a class="link" href="security.html#priv_create-temporary-tables"><code class="literal">CREATE TEMPORARY TABLES</code></a></td>
                                <td>Enable use of <a class="link" href="sql-syntax.html#create-table" title="13.1.18&nbsp;CREATE TABLE Syntax"><code class="literal">CREATE
                                    TEMPORARY TABLE</code></a>. Levels: Global, database.</td>
                            </tr><tr>
                                <td scope="row"><a class="link" href="security.html#priv_create-user"><code class="literal">CREATE USER</code></a></td>
                                <td>Enable use of <a class="link" href="sql-syntax.html#create-user" title="13.7.1.2&nbsp;CREATE USER Syntax"><code class="literal">CREATE USER</code></a>,
                                    <a class="link" href="sql-syntax.html#drop-user" title="13.7.1.3&nbsp;DROP USER Syntax"><code class="literal">DROP USER</code></a>,
                                    <a class="link" href="sql-syntax.html#rename-user" title="13.7.1.5&nbsp;RENAME USER Syntax"><code class="literal">RENAME USER</code></a>, and
                                    <a class="link" href="sql-syntax.html#revoke" title="13.7.1.6&nbsp;REVOKE Syntax"><code class="literal">REVOKE ALL
                                        PRIVILEGES</code></a>. Level: Global.</td>
                            </tr><tr>
                                <td scope="row"><a class="link" href="security.html#priv_create-view"><code class="literal">CREATE VIEW</code></a></td>
                                <td>Enable views to be created or altered. Levels: Global, database, table.</td>
                            </tr><tr>
                                <td scope="row"><a class="link" href="security.html#priv_delete"><code class="literal">DELETE</code></a></td>
                                <td>Enable use of <a class="link" href="sql-syntax.html#delete" title="13.2.2&nbsp;DELETE Syntax"><code class="literal">DELETE</code></a>. Level: Global,
                                    database, table.</td>
                            </tr><tr>
                                <td scope="row"><a class="link" href="security.html#priv_drop"><code class="literal">DROP</code></a></td>
                                <td>Enable databases, tables, and views to be dropped. Levels: Global,
                                    database, table.</td>
                            </tr><tr>
                                <td scope="row"><a class="link" href="security.html#priv_event"><code class="literal">EVENT</code></a></td>
                                <td>Enable use of events for the Event Scheduler. Levels: Global, database.</td>
                            </tr><tr>
                                <td scope="row"><a class="link" href="security.html#priv_execute"><code class="literal">EXECUTE</code></a></td>
                                <td>Enable the user to execute stored routines. Levels: Global, database,
                                    routine.</td>
                            </tr><tr>
                                <td scope="row"><a class="link" href="security.html#priv_file"><code class="literal">FILE</code></a></td>
                                <td>Enable the user to cause the server to read or write files. Level:
                                    Global.</td>
                            </tr><tr>
                                <td scope="row"><a class="link" href="security.html#priv_grant-option"><code class="literal">GRANT OPTION</code></a></td>
                                <td>Enable privileges to be granted to or removed from other accounts.
                                    Levels: Global, database, table, routine, proxy.</td>
                            </tr><tr>
                                <td scope="row"><a class="link" href="security.html#priv_index"><code class="literal">INDEX</code></a></td>
                                <td>Enable indexes to be created or dropped. Levels: Global, database,
                                    table.</td>
                            </tr><tr>
                                <td scope="row"><a class="link" href="security.html#priv_insert"><code class="literal">INSERT</code></a></td>
                                <td>Enable use of <a class="link" href="sql-syntax.html#insert" title="13.2.5&nbsp;INSERT Syntax"><code class="literal">INSERT</code></a>. Levels: Global,
                                    database, table, column.</td>
                            </tr><tr>
                                <td scope="row"><a class="link" href="security.html#priv_lock-tables"><code class="literal">LOCK TABLES</code></a></td>
                                <td>Enable use of <a class="link" href="sql-syntax.html#lock-tables" title="13.3.5&nbsp;LOCK TABLES and UNLOCK TABLES Syntax"><code class="literal">LOCK TABLES</code></a> on tables for
                                    which you have the <a class="link" href="sql-syntax.html#select" title="13.2.9&nbsp;SELECT Syntax"><code class="literal">SELECT</code></a>
                                    privilege. Levels: Global, database.</td>
                            </tr><tr>
                                <td scope="row"><a class="link" href="security.html#priv_process"><code class="literal">PROCESS</code></a></td>
                                <td>Enable the user to see all processes with <a class="link" href="sql-syntax.html#show-processlist" title="13.7.5.29&nbsp;SHOW PROCESSLIST Syntax"><code class="literal">SHOW
                                    PROCESSLIST</code></a>. Level: Global.</td>
                            </tr><tr>
                                <td scope="row"><a class="link" href="security.html#priv_proxy"><code class="literal">PROXY</code></a></td>
                                <td>Enable user proxying. Level: From user to user.</td>
                            </tr><tr>
                                <td scope="row"><a class="link" href="security.html#priv_references"><code class="literal">REFERENCES</code></a></td>
                                <td>Enable foreign key creation. Levels: Global, database, table, column.</td>
                            </tr><tr>
                                <td scope="row"><a class="link" href="security.html#priv_reload"><code class="literal">RELOAD</code></a></td>
                                <td>Enable use of <a class="link" href="sql-syntax.html#flush" title="13.7.6.3&nbsp;FLUSH Syntax"><code class="literal">FLUSH</code></a> operations. Level:
                                    Global.</td>
                            </tr><tr>
                                <td scope="row"><a class="link" href="security.html#priv_replication-client"><code class="literal">REPLICATION CLIENT</code></a></td>
                                <td>Enable the user to ask where master or slave servers are. Level: Global.</td>
                            </tr><tr>
                                <td scope="row"><a class="link" href="security.html#priv_replication-slave"><code class="literal">REPLICATION SLAVE</code></a></td>
                                <td>Enable replication slaves to read binary log events from the master.
                                    Level: Global.</td>
                            </tr><tr>
                                <td scope="row"><a class="link" href="security.html#priv_select"><code class="literal">SELECT</code></a></td>
                                <td>Enable use of <a class="link" href="sql-syntax.html#select" title="13.2.9&nbsp;SELECT Syntax"><code class="literal">SELECT</code></a>. Levels: Global,
                                    database, table, column.</td>
                            </tr><tr>
                                <td scope="row"><a class="link" href="security.html#priv_show-databases"><code class="literal">SHOW DATABASES</code></a></td>
                                <td>Enable <a class="link" href="sql-syntax.html#show-databases" title="13.7.5.14&nbsp;SHOW DATABASES Syntax"><code class="literal">SHOW DATABASES</code></a> to show all
                                    databases. Level: Global.</td>
                            </tr><tr>
                                <td scope="row"><a class="link" href="security.html#priv_show-view"><code class="literal">SHOW VIEW</code></a></td>
                                <td>Enable use of <a class="link" href="sql-syntax.html#show-create-view" title="13.7.5.13&nbsp;SHOW CREATE VIEW Syntax"><code class="literal">SHOW CREATE VIEW</code></a>. Levels:
                                    Global, database, table.</td>
                            </tr><tr>
                                <td scope="row"><a class="link" href="security.html#priv_shutdown"><code class="literal">SHUTDOWN</code></a></td>
                                <td>Enable use of <a class="link" href="programs.html#mysqladmin" title="4.5.2&nbsp;mysqladmin — Client for Administering a MySQL Server"><span class="command"><strong>mysqladmin shutdown</strong></span></a>. Level: Global.</td>
                            </tr><tr>
                                <td scope="row"><a class="link" href="security.html#priv_super"><code class="literal">SUPER</code></a></td>
                                <td>Enable use of other administrative operations such as
                                    <a class="link" href="sql-syntax.html#change-master-to" title="13.4.2.1&nbsp;CHANGE MASTER TO Syntax"><code class="literal">CHANGE MASTER TO</code></a>,
                                    <a class="link" href="sql-syntax.html#kill" title="13.7.6.4&nbsp;KILL Syntax"><code class="literal">KILL</code></a>,
                                    <a class="link" href="sql-syntax.html#purge-binary-logs" title="13.4.1.1&nbsp;PURGE BINARY LOGS Syntax"><code class="literal">PURGE BINARY LOGS</code></a>,
                                    <a class="link" href="sql-syntax.html#set-variable" title="13.7.4.1&nbsp;SET Syntax for Variable Assignment"><code class="literal">SET
                                        GLOBAL</code></a>, and <a class="link" href="programs.html#mysqladmin" title="4.5.2&nbsp;mysqladmin — Client for Administering a MySQL Server"><span class="command"><strong>mysqladmin
                debug</strong></span></a> command. Level: Global.</td>
                            </tr><tr>
                                <td scope="row"><a class="link" href="security.html#priv_trigger"><code class="literal">TRIGGER</code></a></td>
                                <td>Enable trigger operations. Levels: Global, database, table.</td>
                            </tr><tr>
                                <td scope="row"><a class="link" href="security.html#priv_update"><code class="literal">UPDATE</code></a></td>
                                <td>Enable use of <a class="link" href="sql-syntax.html#update" title="13.2.11&nbsp;UPDATE Syntax"><code class="literal">UPDATE</code></a>. Levels: Global,
                                    database, table, column.</td>
                            </tr><tr>
                                <td scope="row"><a class="link" href="security.html#priv_usage"><code class="literal">USAGE</code></a></td>
                                <td>Synonym for <span class="quote">“<span class="quote">no privileges</span>”</span></td>
                            </tr></tbody></table>
                        </div>

                    </div>
                    <br class="table-break"><p>
                    A trigger is associated with a table. To create or drop a
                    trigger, you must have the
                    <a class="link" href="security.html#priv_trigger"><code class="literal">TRIGGER</code></a> privilege for the
                    table, not the trigger.
                </p><p style="color:blue;">触发器与表关联。要创建或删除触发器，您必须具有表的触发器权限，而不是触发器的权限。</p><p>
                    In <a class="link" href="sql-syntax.html#grant" title="13.7.1.4&nbsp;GRANT Syntax"><code class="literal">GRANT</code></a> statements, the
                    <a class="link" href="security.html#priv_all"><code class="literal">ALL
                        [PRIVILEGES]</code></a> or <a class="link" href="security.html#priv_proxy"><code class="literal">PROXY</code></a>
                    privilege must be named by itself and cannot be specified
                    along with other privileges.
                    <a class="link" href="security.html#priv_all"><code class="literal">ALL
                        [PRIVILEGES]</code></a> stands for all privileges available for
                    the level at which privileges are to be granted except for the
                    <a class="link" href="security.html#priv_grant-option"><code class="literal">GRANT OPTION</code></a> and
                    <a class="link" href="security.html#priv_proxy"><code class="literal">PROXY</code></a> privileges.
                </p><p style="color:blue;">在GRANT语句中，所有[特权]或代理特权必须由自己命名，不能与其他特权一起指定。所有[特权]表示除授予选项和代理特权外，授予特权的级别的所有可用特权。</p><p>
                    <a class="link" href="security.html#priv_usage"><code class="literal">USAGE</code></a> can be specified to
                    create a user that has no privileges, or to specify the
                    <code class="literal">REQUIRE</code> or <code class="literal">WITH</code> clauses
                    for an account without changing its existing privileges.
                    (However, use of <a class="link" href="sql-syntax.html#grant" title="13.7.1.4&nbsp;GRANT Syntax"><code class="literal">GRANT</code></a> to
                    define nonprivilege characteristics is deprecated.
                </p><p style="color:blue;">可以指定使用以创建没有特权的用户，或者在不更改其现有特权的情况下指定帐户的要求或子句。（但是，不赞成使用grant来定义非特权特性。</p><p>
                    MySQL account information is stored in the tables of the
                    <code class="literal">mysql</code> system database. For additional
                    details, consult <a class="xref" href="security.html#access-control" title="6.2&nbsp;Access Control and Account Management">Section&nbsp;6.2, “Access Control and Account Management”</a>, which
                    discusses the <code class="literal">mysql</code> system database and the
                    access control system extensively.
                </p><p style="color:blue;">mysql帐户信息存储在mysql系统数据库的表中。有关更多详细信息，请参阅第6.2节“访问控制和帐户管理”，其中广泛讨论了MySQL系统数据库和访问控制系统。</p><a class="indexterm" name="idm140286829410416"></a><p>
                    If the grant tables hold privilege rows that contain
                    mixed-case database or table names and the
                    <a class="link" href="server-administration.html#sysvar_lower_case_table_names"><code class="literal">lower_case_table_names</code></a> system
                    variable is set to a nonzero value,
                    <a class="link" href="sql-syntax.html#revoke" title="13.7.1.6&nbsp;REVOKE Syntax"><code class="literal">REVOKE</code></a> cannot be used to revoke
                    these privileges. It will be necessary to manipulate the grant
                    tables directly. (<a class="link" href="sql-syntax.html#grant" title="13.7.1.4&nbsp;GRANT Syntax"><code class="literal">GRANT</code></a> will
                    not create such rows when
                    <a class="link" href="server-administration.html#sysvar_lower_case_table_names"><code class="literal">lower_case_table_names</code></a> is
                    set, but such rows might have been created prior to setting
                    that variable.)
                </p><p style="color:blue;">如果GRANT TABLES持有包含混合大小写数据库或表名的特权行，并且小写的TABLE NAME系统变量设置为非零值，则REVOKE不能用于撤消这些特权。必须直接操作授权表。（当设置小写表名时，grant不会创建这样的行，但这些行可能是在设置该变量之前创建的。）</p><p>
                    Privileges can be granted at several levels, depending on the
                    syntax used for the <code class="literal">ON</code> clause. For
                    <a class="link" href="sql-syntax.html#revoke" title="13.7.1.6&nbsp;REVOKE Syntax"><code class="literal">REVOKE</code></a>, the same
                    <code class="literal">ON</code> syntax specifies which privileges to
                    remove.
                </p><p style="color:blue;">根据on子句使用的语法，可以在多个级别授予特权。对于revoke，相同的on语法指定要删除哪些特权。</p><p>
                    For the global, database, table, and routine levels,
                    <a class="link" href="sql-syntax.html#grant" title="13.7.1.4&nbsp;GRANT Syntax"><code class="literal">GRANT ALL</code></a>
                    assigns only the privileges that exist at the level you are
                    granting. For example, <code class="literal">GRANT ALL ON
                    <em class="replaceable"><code>db_name</code></em>.*</code> is a
                    database-level statement, so it does not grant any global-only
                    privileges such as <a class="link" href="security.html#priv_file"><code class="literal">FILE</code></a>.
                    Granting <a class="link" href="security.html#priv_all"><code class="literal">ALL</code></a> does not assign
                    the <a class="link" href="security.html#priv_grant-option"><code class="literal">GRANT OPTION</code></a> or
                    <a class="link" href="security.html#priv_proxy"><code class="literal">PROXY</code></a> privilege.
                </p><p style="color:blue;">对于全局、数据库、表和例程级别，Grand都只分配在授予的级别上存在的特权。例如，grant all on db_name.*是一个数据库级语句，因此它不授予任何仅全局的权限，例如file。全部授予不会分配授予选项或代理权限。</p><p>
                    The <em class="replaceable"><code>object_type</code></em> clause, if present,
                    should be specified as <code class="literal">TABLE</code>,
                    <code class="literal">FUNCTION</code>, or <code class="literal">PROCEDURE</code>
                    when the following object is a table, a stored function, or a
                    stored procedure.
                </p><p style="color:blue;">当下列对象是表、存储函数或存储过程时，object_type子句（如果存在）应指定为表、函数或过程。</p><p>
                    The privileges that a user holds for a database, table,
                    column, or routine are formed additively as the logical
                    <a class="link" href="functions.html#operator_or"><code class="literal">OR</code></a> of the account privileges at
                    each of the privilege levels, including the global level. It
                    is not possible to deny a privilege granted at a higher level
                    by absence of that privilege at a lower level. For example,
                    this statement grants the
                    <a class="link" href="security.html#priv_select"><code class="literal">SELECT</code></a> and
                    <a class="link" href="security.html#priv_insert"><code class="literal">INSERT</code></a> privileges globally:
                </p><p style="color:blue;">用户对数据库、表、列或例程所拥有的特权是作为每个特权级别（包括全局级别）的帐户特权的逻辑或相加而形成的。不能因为在较低的级别上没有特权而拒绝在较高级别授予的特权。例如，此语句全局授予select和insert权限：</p><pre data-lang="sql" class="programlisting">GRANT SELECT, INSERT ON *.* TO u1;
</pre><p>
                    The globally granted privileges apply to all databases,
                    tables, and columns, even though not granted at any of those
                    lower levels.
                </p><p style="color:blue;">全局授予的特权适用于所有数据库、表和列，即使在这些较低的级别中没有授予。</p><p>
                    Details of the privilege-checking procedure are presented in
                    <a class="xref" href="security.html#request-access" title="6.2.6&nbsp;Access Control, Stage 2: Request Verification">Section&nbsp;6.2.6, “Access Control, Stage 2: Request Verification”</a>.
                </p><p style="color:blue;">有关权限检查过程的详细信息，请参阅第6.2.6节“访问控制，第2阶段：请求验证”。</p><p>
                    If you are using table, column, or routine privileges for even
                    one user, the server examines table, column, and routine
                    privileges for all users and this slows down MySQL a bit.
                    Similarly, if you limit the number of queries, updates, or
                    connections for any users, the server must monitor these
                    values.
                </p><p style="color:blue;">如果您对一个用户使用表、列或例程特权，服务器将检查所有用户的表、列和例程特权，这会稍微减慢mysql的速度。类似地，如果限制任何用户的查询、更新或连接数，服务器必须监视这些值。</p><p>
                    MySQL enables you to grant privileges on databases or tables
                    that do not exist. For tables, the privileges to be granted
                    must include the <a class="link" href="security.html#priv_create"><code class="literal">CREATE</code></a>
                    privilege. <span class="emphasis"><em>This behavior is by design</em></span>,
                    and is intended to enable the database administrator to
                    prepare user accounts and privileges for databases or tables
                    that are to be created at a later time.
                </p><p style="color:blue;">MySQL使您能够授予不存在的数据库或表的权限。对于表，要授予的特权必须包括CREATE特权。此行为是按设计进行的，旨在使数据库管理员能够为以后创建的数据库或表准备用户帐户和权限。</p>
                    <div class="important" style="margin-left: 0.5in; margin-right: 0.5in;">

                        <div class="admon-title">
                            Important
                        </div>
                        <p>
            <span class="emphasis"><em>MySQL does not automatically revoke any privileges
            when you drop a database or table</em></span>. However, if
                            you drop a routine, any routine-level privileges granted for
                            that routine are revoked.
                        </p><p style="color:blue;">当您删除数据库或表时，mysql不会自动撤消任何权限。但是，如果删除某个例程，则为该例程授予的任何例程级权限都将被吊销。</p>
                    </div>

                </div>
                <div class="simplesect">
                    <div class="titlepage">
                        <div>
                            <div class="simple">
                                <h5 class="title"><a name="grant-accounts-passwords"></a>Account Names and Passwords</h5>

                            </div>

                        </div>

                    </div>
                    <p>
                        A <em class="replaceable"><code>user</code></em> value in a
                        <a class="link" href="sql-syntax.html#grant" title="13.7.1.4&nbsp;GRANT Syntax"><code class="literal">GRANT</code></a> statement indicates a
                        MySQL account to which the statement applies. To accommodate
                        granting rights to users from arbitrary hosts, MySQL supports
                        specifying the <em class="replaceable"><code>user</code></em> value in the
                        form
                        <code class="literal">'<em class="replaceable"><code>user_name</code></em>'@'<em class="replaceable"><code>host_name</code></em>'</code>.
                    </p><p style="color:blue;">grant语句中的用户值表示该语句所应用的mysql帐户。为了适应对来自任意主机的用户授予权限，mysql支持以“用户名”@“主机名”的形式指定用户值。</p><p>
                    You can specify wildcards in the host name. For example,
                    <code class="literal">'<em class="replaceable"><code>user_name</code></em>'@'%.example.com'</code>
                    applies to <em class="replaceable"><code>user_name</code></em> for any host
                    in the <code class="literal">example.com</code> domain, and
                    <code class="literal">'<em class="replaceable"><code>user_name</code></em>'@'198.51.100.%'</code>
                    applies to <em class="replaceable"><code>user_name</code></em> for any host
                    in the <code class="literal">198.51.100</code> class C subnet.
                </p><p style="color:blue;">可以在主机名中指定通配符。例如，“用户名”@“%.example.com”适用于example.com域中任何主机的用户名，而“用户名”@“198.51.100.%”适用于198.51.100 C类子网中任何主机的用户名。</p><p>
                    The simple form
                    <code class="literal">'<em class="replaceable"><code>user_name</code></em>'</code> is a
                    synonym for
                    <code class="literal">'<em class="replaceable"><code>user_name</code></em>'@'%'</code>.
                </p><p style="color:blue;">简单形式“用户名”是“用户名”@“%”的同义词。</p><p>
          <span class="emphasis"><em>MySQL does not support wildcards in user
          names</em></span>. To refer to an anonymous user, specify an
                    account with an empty user name with the
                    <a class="link" href="sql-syntax.html#grant" title="13.7.1.4&nbsp;GRANT Syntax"><code class="literal">GRANT</code></a> statement:
                </p><p style="color:blue;">MySQL不支持用户名中的通配符。要引用匿名用户，请使用GRANT语句指定用户名为空的帐户：</p><pre data-lang="sql" class="programlisting">GRANT ALL ON test.* TO ''@'localhost' ...;
</pre><p>
                    In this case, any user who connects from the local host with
                    the correct password for the anonymous user will be permitted
                    access, with the privileges associated with the anonymous-user
                    account.
                </p><p style="color:blue;">在这种情况下，任何使用匿名用户的正确密码从本地主机连接的用户都将被允许使用与匿名用户帐户相关联的权限进行访问。</p><p>
                    For additional information about user name and host name
                    values in account names, see <a class="xref" href="security.html#account-names" title="6.2.4&nbsp;Specifying Account Names">Section&nbsp;6.2.4, “Specifying Account Names”</a>.
                </p><p style="color:blue;">有关帐户名中用户名和主机名值的其他信息，请参阅第6.2.4节“指定帐户名”。</p>
                    <div class="warning" style="margin-left: 0.5in; margin-right: 0.5in;">

                        <div class="admon-title">
                            Warning
                        </div>
                        <p>
                            If you permit local anonymous users to connect to the MySQL
                            server, you should also grant privileges to all local users
                            as
                            <code class="literal">'<em class="replaceable"><code>user_name</code></em>'@'localhost'</code>.
                            Otherwise, the anonymous user account for
                            <code class="literal">localhost</code> in the
                            <code class="literal">mysql.user</code> system table is used when
                            named users try to log in to the MySQL server from the local
                            machine. For details, see
                            <a class="xref" href="security.html#connection-access" title="6.2.5&nbsp;Access Control, Stage 1: Connection Verification">Section&nbsp;6.2.5, “Access Control, Stage 1: Connection Verification”</a>.
                        </p><p style="color:blue;">如果允许本地匿名用户连接到mysql服务器，则还应将权限授予所有本地用户为“user_name”@“localhost”。否则，当命名用户尝试从本地计算机登录到mysql服务器时，将使用mysql.user系统表中localhost的匿名用户帐户。有关详细信息，请参见第6.2.5节“访问控制，第1阶段：连接验证”。</p><p>
                        To determine whether this issue applies to you, execute the
                        following query, which lists any anonymous users:
                    </p><p style="color:blue;">要确定此问题是否适用于您，请执行以下查询，其中列出了所有匿名用户：</p><pre data-lang="sql" class="programlisting">SELECT Host, User FROM mysql.user WHERE User='';
</pre><p>
                        To avoid the problem just described, delete the local
                        anonymous user account using this statement:
                    </p><p style="color:blue;">为避免上述问题，请使用以下语句删除本地匿名用户帐户：</p><pre data-lang="sql" class="programlisting">DROP USER ''@'localhost';
</pre>
                    </div>
                    <a class="indexterm" name="idm140286829351344"></a><p>
                    For <a class="link" href="sql-syntax.html#grant" title="13.7.1.4&nbsp;GRANT Syntax"><code class="literal">GRANT</code></a> syntax that permits
                    an <em class="replaceable"><code>auth_option</code></em> value to follow a
                    <em class="replaceable"><code>user</code></em> value,
                    <em class="replaceable"><code>auth_option</code></em> begins with
                    <code class="literal">IDENTIFIED</code> and indicates how the account
                    authenticates by specifying an account authentication plugin,
                    credentials (for example, a password), or both. Syntax of the
                    <em class="replaceable"><code>auth_option</code></em> clause is the same as
                    for the <a class="link" href="sql-syntax.html#create-user" title="13.7.1.2&nbsp;CREATE USER Syntax"><code class="literal">CREATE USER</code></a> statement.
                    For details, see <a class="xref" href="sql-syntax.html#create-user" title="13.7.1.2&nbsp;CREATE USER Syntax">Section&nbsp;13.7.1.2, “CREATE USER Syntax”</a>.
                </p><p style="color:blue;">对于允许auth_选项值跟随用户值的授权语法，auth_选项以identified开头，并通过指定帐户身份验证插件、凭据（例如，密码）或两者来指示帐户如何进行身份验证。auth_option子句的语法与create user语句的语法相同。有关详细信息，请参见第13.7.1.2节“创建用户语法”。</p>
                    <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">

                        <div class="admon-title">
                            Note
                        </div>
                        <p>
                            Use of <a class="link" href="sql-syntax.html#grant" title="13.7.1.4&nbsp;GRANT Syntax"><code class="literal">GRANT</code></a> to define
                            account authentication characteristics is deprecated as of
                            MySQL 5.7.6. Instead, establish or change authentication
                            characteristics using <a class="link" href="sql-syntax.html#create-user" title="13.7.1.2&nbsp;CREATE USER Syntax"><code class="literal">CREATE
                            USER</code></a> or <a class="link" href="sql-syntax.html#alter-user" title="13.7.1.1&nbsp;ALTER USER Syntax"><code class="literal">ALTER USER</code></a>.
                            This <a class="link" href="sql-syntax.html#grant" title="13.7.1.4&nbsp;GRANT Syntax"><code class="literal">GRANT</code></a> capability will be
                            removed in a future MySQL release.
                        </p><p style="color:blue;">从mysql 5.7.6开始，不赞成使用grant来定义帐户身份验证特征。相反，使用create user或alter user建立或更改身份验证特征。这种授权功能将在未来的mysql版本中删除。</p>
                    </div>
                    <p>
                        When <code class="literal">IDENTIFIED</code> is present and you have the
                        global grant privilege (<a class="link" href="security.html#priv_grant-option"><code class="literal">GRANT
                        OPTION</code></a>), any password specified becomes the new
                        password for the account, even if the account exists and
                        already has a password. Without <code class="literal">IDENTIFIED</code>,
                        the account password remains unchanged.
                    </p><p style="color:blue;">当存在标识时，您拥有全局授予特权（授予选项），指定的任何密码将成为帐户的新密码，即使帐户存在并且已经拥有密码。未经识别，帐户密码保持不变。</p>
                </div>
                <div class="simplesect">
                    <div class="titlepage">
                        <div>
                            <div class="simple">
                                <h5 class="title"><a name="grant-global-privileges"></a>Global Privileges</h5>

                            </div>

                        </div>

                    </div>
                    <p>
                        Global privileges are administrative or apply to all databases
                        on a given server. To assign global privileges, use
                        <code class="literal">ON *.*</code> syntax:
                    </p><p style="color:blue;">全局权限是管理权限或应用于给定服务器上的所有数据库。要分配全局权限，请使用*.*语法：</p><pre data-lang="sql" class="programlisting">GRANT ALL ON *.* TO 'someuser'@'somehost';
GRANT SELECT, INSERT ON *.* TO 'someuser'@'somehost';
</pre><p>
                    The <a class="link" href="security.html#priv_create-tablespace"><code class="literal">CREATE TABLESPACE</code></a>,
                    <a class="link" href="security.html#priv_create-user"><code class="literal">CREATE USER</code></a>,
                    <a class="link" href="security.html#priv_file"><code class="literal">FILE</code></a>,
                    <a class="link" href="security.html#priv_process"><code class="literal">PROCESS</code></a>,
                    <a class="link" href="security.html#priv_reload"><code class="literal">RELOAD</code></a>,
                    <a class="link" href="security.html#priv_replication-client"><code class="literal">REPLICATION CLIENT</code></a>,
                    <a class="link" href="security.html#priv_replication-slave"><code class="literal">REPLICATION SLAVE</code></a>,
                    <a class="link" href="security.html#priv_show-databases"><code class="literal">SHOW DATABASES</code></a>,
                    <a class="link" href="security.html#priv_shutdown"><code class="literal">SHUTDOWN</code></a>, and
                    <a class="link" href="security.html#priv_super"><code class="literal">SUPER</code></a> privileges are
                    administrative and can only be granted globally.
                </p><p style="color:blue;">create tablespace、create user、file、process、reload、replication client、replication slave、show databases、shutdown和super权限是管理权限，只能全局授予。</p><p>
                    Other privileges can be granted globally or at more specific
                    levels.
                </p><p style="color:blue;">其他特权可以全局授予，也可以在更具体的级别授予。</p><p>
                    <a class="link" href="security.html#priv_grant-option"><code class="literal">GRANT OPTION</code></a> granted at the
                    global level for any global privilege applies to all global
                    privileges.
                </p><p style="color:blue;">在全局级别为任何全局权限授予的授予选项适用于所有全局权限。</p><p>
                    MySQL stores global privileges in the
                    <code class="literal">mysql.user</code> system table.
                </p><p style="color:blue;">mysql在mysql.user系统表中存储全局权限。</p>
                </div>
                <div class="simplesect">
                    <div class="titlepage">
                        <div>
                            <div class="simple">
                                <h5 class="title"><a name="grant-database-privileges"></a>Database Privileges</h5>

                            </div>

                        </div>

                    </div>
                    <p>
                        Database privileges apply to all objects in a given database.
                        To assign database-level privileges, use <code class="literal">ON
                        <em class="replaceable"><code>db_name</code></em>.*</code> syntax:
                    </p><p style="color:blue;">数据库特权应用于给定数据库中的所有对象。要分配数据库级权限，请在db_name.*上使用语法：</p><pre data-lang="sql" class="programlisting">GRANT ALL ON mydb.* TO 'someuser'@'somehost';
GRANT SELECT, INSERT ON mydb.* TO 'someuser'@'somehost';
</pre><p>
                    If you use <code class="literal">ON *</code> syntax (rather than
                    <code class="literal">ON *.*</code>), privileges are assigned at the
                    database level for the default database. An error occurs if
                    there is no default database.
                </p><p style="color:blue;">如果使用on*语法（而不是on*.*），则在数据库级别为默认数据库分配特权。如果没有默认数据库，则会发生错误。</p><p>
                    The <a class="link" href="security.html#priv_create"><code class="literal">CREATE</code></a>,
                    <a class="link" href="security.html#priv_drop"><code class="literal">DROP</code></a>,
                    <a class="link" href="security.html#priv_event"><code class="literal">EVENT</code></a>,
                    <a class="link" href="security.html#priv_grant-option"><code class="literal">GRANT OPTION</code></a>,
                    <a class="link" href="security.html#priv_lock-tables"><code class="literal">LOCK TABLES</code></a>, and
                    <a class="link" href="security.html#priv_references"><code class="literal">REFERENCES</code></a> privileges can be
                    specified at the database level. Table or routine privileges
                    also can be specified at the database level, in which case
                    they apply to all tables or routines in the database.
                </p><p style="color:blue;">可以在数据库级别指定create、drop、event、grant选项、lock tables和references权限。表或例程特权也可以在数据库级别指定，在这种情况下，它们应用于数据库中的所有表或例程。</p><p>
                    MySQL stores database privileges in the
                    <code class="literal">mysql.db</code> system table.
                </p><p style="color:blue;">mysql在mysql.db系统表中存储数据库特权。</p>
                </div>
                <div class="simplesect">
                    <div class="titlepage">
                        <div>
                            <div class="simple">
                                <h5 class="title"><a name="grant-table-privileges"></a>Table Privileges</h5>

                            </div>

                        </div>

                    </div>
                    <p>
                        Table privileges apply to all columns in a given table. To
                        assign table-level privileges, use <code class="literal">ON
                        <em class="replaceable"><code>db_name.tbl_name</code></em></code> syntax:
                    </p><p style="color:blue;">表特权应用于给定表中的所有列。要分配表级权限，请使用on db_name.tbl_name语法：</p><pre data-lang="sql" class="programlisting">GRANT ALL ON mydb.mytbl TO 'someuser'@'somehost';
GRANT SELECT, INSERT ON mydb.mytbl TO 'someuser'@'somehost';
</pre><p>
                    If you specify <em class="replaceable"><code>tbl_name</code></em> rather than
                    <em class="replaceable"><code>db_name.tbl_name</code></em>, the statement
                    applies to <em class="replaceable"><code>tbl_name</code></em> in the default
                    database. An error occurs if there is no default database.
                </p><p style="color:blue;">如果指定tbl_name而不是db_name.tbl_name，则语句将应用于默认数据库中的tbl_name。如果没有默认数据库，则会发生错误。</p><p>
                    The permissible <em class="replaceable"><code>priv_type</code></em> values at
                    the table level are <a class="link" href="security.html#priv_alter"><code class="literal">ALTER</code></a>,
                    <a class="link" href="security.html#priv_create-view"><code class="literal">CREATE VIEW</code></a>,
                    <a class="link" href="security.html#priv_create"><code class="literal">CREATE</code></a>,
                    <a class="link" href="security.html#priv_delete"><code class="literal">DELETE</code></a>,
                    <a class="link" href="security.html#priv_drop"><code class="literal">DROP</code></a>,
                    <a class="link" href="security.html#priv_grant-option"><code class="literal">GRANT OPTION</code></a>,
                    <a class="link" href="security.html#priv_index"><code class="literal">INDEX</code></a>,
                    <a class="link" href="security.html#priv_insert"><code class="literal">INSERT</code></a>,
                    <a class="link" href="security.html#priv_references"><code class="literal">REFERENCES</code></a>,
                    <a class="link" href="security.html#priv_select"><code class="literal">SELECT</code></a>,
                    <a class="link" href="security.html#priv_show-view"><code class="literal">SHOW VIEW</code></a>,
                    <a class="link" href="security.html#priv_trigger"><code class="literal">TRIGGER</code></a>, and
                    <a class="link" href="security.html#priv_update"><code class="literal">UPDATE</code></a>.
                </p><p style="color:blue;">表级允许的priv_type值是alter、create view、create、delete、drop、grant option、index、insert、references、select、show view、trigger和update。</p><p>
                    Table-level privileges apply to base tables and views. They do
                    not apply to tables created with <a class="link" href="sql-syntax.html#create-temporary-table" title="13.1.18.3&nbsp;CREATE TEMPORARY TABLE Syntax"><code class="literal">CREATE
                    TEMPORARY TABLE</code></a>, even if the table names match. For
                    information about <code class="literal">TEMPORARY</code> table
                    privileges, see <a class="xref" href="sql-syntax.html#create-temporary-table" title="13.1.18.3&nbsp;CREATE TEMPORARY TABLE Syntax">Section&nbsp;13.1.18.3, “CREATE TEMPORARY TABLE Syntax”</a>.
                </p><p style="color:blue;">表级权限应用于基表和视图。即使表名匹配，它们也不适用于使用“创建临时表”创建的表。有关临时表特权的信息，请参阅第13.1.18.3节“创建临时表语法”。</p><a class="indexterm" name="idm140286829273584"></a><a class="indexterm" name="idm140286829272096"></a><p>
                    MySQL stores table privileges in the
                    <code class="literal">mysql.tables_priv</code> system table.
                </p><p style="color:blue;">mysql将表特权存储在mysql.tables_priv系统表中。</p>
                </div>
                <div class="simplesect">
                    <div class="titlepage">
                        <div>
                            <div class="simple">
                                <h5 class="title"><a name="grant-column-privileges"></a>Column Privileges</h5>

                            </div>

                        </div>

                    </div>
                    <p>
                        Column privileges apply to single columns in a given table.
                        Each privilege to be granted at the column level must be
                        followed by the column or columns, enclosed within
                        parentheses.
                    </p><p style="color:blue;">列特权应用于给定表中的单个列。要在列级别授予的每个特权后面必须跟有一列或多列，并用括号括起来。</p><pre data-lang="sql" class="programlisting">GRANT SELECT (col1), INSERT (col1, col2) ON mydb.mytbl TO 'someuser'@'somehost';
</pre><p>
                    The permissible <em class="replaceable"><code>priv_type</code></em> values
                    for a column (that is, when you use a
                    <em class="replaceable"><code>column_list</code></em> clause) are
                    <a class="link" href="security.html#priv_insert"><code class="literal">INSERT</code></a>,
                    <a class="link" href="security.html#priv_references"><code class="literal">REFERENCES</code></a>,
                    <a class="link" href="security.html#priv_select"><code class="literal">SELECT</code></a>, and
                    <a class="link" href="security.html#priv_update"><code class="literal">UPDATE</code></a>.
                </p><p style="color:blue;">列的允许priv_type值（即，当您使用column_list子句时）是insert、references、select和update。</p><p>
                    MySQL stores column privileges in the
                    <code class="literal">mysql.columns_priv</code> system table.
                </p><p style="color:blue;">mysql在mysql.columns_priv系统表中存储列特权。</p>
                </div>
                <div class="simplesect">
                    <div class="titlepage">
                        <div>
                            <div class="simple">
                                <h5 class="title"><a name="grant-routine-privileges"></a>Stored Routine Privileges</h5>

                            </div>

                        </div>

                    </div>
                    <p>
                        The <a class="link" href="security.html#priv_alter-routine"><code class="literal">ALTER ROUTINE</code></a>,
                        <a class="link" href="security.html#priv_create-routine"><code class="literal">CREATE ROUTINE</code></a>,
                        <a class="link" href="security.html#priv_execute"><code class="literal">EXECUTE</code></a>, and
                        <a class="link" href="security.html#priv_grant-option"><code class="literal">GRANT OPTION</code></a> privileges apply
                        to stored routines (procedures and functions). They can be
                        granted at the global and database levels. Except for
                        <a class="link" href="security.html#priv_create-routine"><code class="literal">CREATE ROUTINE</code></a>, these
                        privileges can be granted at the routine level for individual
                        routines.
                    </p><p style="color:blue;">alter routine、create routine、execute和grant option权限应用于存储例程（过程和函数）。它们可以在全局和数据库级别授予。除了create routine，这些特权可以在例程级别授予单个例程。</p><pre data-lang="sql" class="programlisting">GRANT CREATE ROUTINE ON mydb.* TO 'someuser'@'somehost';
GRANT EXECUTE ON PROCEDURE mydb.myproc TO 'someuser'@'somehost';
</pre><p>
                    The permissible <em class="replaceable"><code>priv_type</code></em> values at
                    the routine level are <a class="link" href="security.html#priv_alter-routine"><code class="literal">ALTER
                    ROUTINE</code></a>, <a class="link" href="security.html#priv_execute"><code class="literal">EXECUTE</code></a>, and
                    <a class="link" href="security.html#priv_grant-option"><code class="literal">GRANT OPTION</code></a>.
                    <a class="link" href="security.html#priv_create-routine"><code class="literal">CREATE ROUTINE</code></a> is not a
                    routine-level privilege because you must have the privilege at
                    the global or database level to create a routine in the first
                    place.
                </p><p style="color:blue;">在例程级别允许的priv_type值是alter routine、execute和grant option。创建例程不是例程级别的权限，因为首先必须具有全局或数据库级别的权限才能创建例程。</p><p>
                    MySQL stores routine-level privileges in the
                    <code class="literal">mysql.procs_priv</code> system table.
                </p><p style="color:blue;">mysql将例程级权限存储在mysql.procs_priv系统表中。</p>
                </div>
                <div class="simplesect">
                    <div class="titlepage">
                        <div>
                            <div class="simple">
                                <h5 class="title"><a name="grant-proxy-privileges"></a>Proxy User Privileges</h5>

                            </div>

                        </div>

                    </div>
                    <p>
                        The <a class="link" href="security.html#priv_proxy"><code class="literal">PROXY</code></a> privilege enables one
                        user to be a proxy for another. The proxy user impersonates or
                        takes the identity of the proxied user; that is, it assumes
                        the privileges of the proxied user.
                    </p><p style="color:blue;">代理特权允许一个用户成为另一个用户的代理。代理用户模拟或获取代理用户的身份；也就是说，它假定代理用户的权限。</p><pre data-lang="sql" class="programlisting">GRANT PROXY ON 'localuser'@'localhost' TO 'externaluser'@'somehost';
</pre><p>
                    When <a class="link" href="security.html#priv_proxy"><code class="literal">PROXY</code></a> is granted, it must
                    be the only privilege named in the
                    <a class="link" href="sql-syntax.html#grant" title="13.7.1.4&nbsp;GRANT Syntax"><code class="literal">GRANT</code></a> statement, the
                    <code class="literal">REQUIRE</code> clause cannot be given, and the
                    only permitted <code class="literal">WITH</code> option is <code class="literal">WITH
                    GRANT OPTION</code>.
                </p><p style="color:blue;">当授予代理时，它必须是GRANT语句中指定的唯一权限，不能授予REQUIRE子句，并且只允许WITH OPTION是WITH GRANT OPTION。</p><p>
                    Proxying requires that the proxy user authenticate through a
                    plugin that returns the name of the proxied user to the server
                    when the proxy user connects, and that the proxy user have the
                    <code class="literal">PROXY</code> privilege for the proxied user. For
                    details and examples, see <a class="xref" href="security.html#proxy-users" title="6.2.14&nbsp;Proxy Users">Section&nbsp;6.2.14, “Proxy Users”</a>.
                </p><p style="color:blue;">代理要求代理用户通过在代理用户连接时将代理用户的名称返回给服务器的插件进行认证，并且代理用户具有代理用户的代理权限。有关详细信息和示例，请参见第6.2.14节“代理用户”。</p><p>
                    MySQL stores proxy privileges in the
                    <code class="literal">mysql.proxies_priv</code> system table.
                </p><p style="color:blue;">MySQL在MySQL .PROXESES-PRIV系统表中存储代理权限。</p>
                </div>
                <div class="simplesect">
                    <div class="titlepage">
                        <div>
                            <div class="simple">
                                <h5 class="title"><a name="grant-account-creation"></a>Implicit Account Creation</h5>

                            </div>

                        </div>

                    </div>
                    <p>
                        If an account named in a <a class="link" href="sql-syntax.html#grant" title="13.7.1.4&nbsp;GRANT Syntax"><code class="literal">GRANT</code></a>
                        statement does not exist, the action taken depends on the
                        <a class="link" href="server-administration.html#sqlmode_no_auto_create_user"><code class="literal">NO_AUTO_CREATE_USER</code></a> SQL
                        mode:
                    </p><p style="color:blue;">如果在GRANT语句中命名的帐户不存在，则所采取的行动取决于NoAutoPoCeraTySQL用户SQL模式：</p>
                    <div class="itemizedlist">
                        <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                            If <a class="link" href="server-administration.html#sqlmode_no_auto_create_user"><code class="literal">NO_AUTO_CREATE_USER</code></a>
                            is not enabled, <a class="link" href="sql-syntax.html#grant" title="13.7.1.4&nbsp;GRANT Syntax"><code class="literal">GRANT</code></a>
                            creates the account. <span class="emphasis"><em>This is very
              insecure</em></span> unless you specify a nonempty password
                            using <code class="literal">IDENTIFIED BY</code>.
                        </p><p style="color:blue;">如果没有启用“自动创建”用户，则Grant将创建帐户。除非使用identified by指定非空密码，否则这是非常不安全的。</p></li><li class="listitem"><p>
                            If <a class="link" href="server-administration.html#sqlmode_no_auto_create_user"><code class="literal">NO_AUTO_CREATE_USER</code></a>
                            is enabled, <a class="link" href="sql-syntax.html#grant" title="13.7.1.4&nbsp;GRANT Syntax"><code class="literal">GRANT</code></a> fails and
                            does not create the account, unless you specify a nonempty
                            password using <code class="literal">IDENTIFIED BY</code> or name an
                            authentication plugin using <code class="literal">IDENTIFIED
                            WITH</code>.
                        </p><p style="color:blue;">如果未启用“自动创建”用户，则除非使用identified by指定非空密码或使用identified with命名身份验证插件，否则grant将失败且不会创建帐户。</p></li></ul>
                    </div>
                    <p>
                        If the account already exists, <code class="literal">IDENTIFIED
                        WITH</code> is prohibited because it is intended only for
                        use when creating new accounts.
                    </p><p style="color:blue;">如果该帐户已经存在，则将其标识为“禁止”，因为它仅用于创建新帐户时使用。</p>
                </div>
                <div class="simplesect">
                    <div class="titlepage">
                        <div>
                            <div class="simple">
                                <h5 class="title"><a name="grant-other-characteristics"></a>Other Account Characteristics</h5>

                            </div>

                        </div>

                    </div>
                    <a class="indexterm" name="idm140286829214176"></a><a class="indexterm" name="idm140286829212688"></a><p>
                    MySQL can check X.509 certificate attributes in addition to
                    the usual authentication that is based on the user name and
                    credentials. For background information on the use of SSL with
                    MySQL, see <a class="xref" href="security.html#encrypted-connections" title="6.3&nbsp;Using Encrypted Connections">Section&nbsp;6.3, “Using Encrypted Connections”</a>.
                </p><p style="color:blue;">除了基于用户名和凭据的常规身份验证之外，mysql还可以检查x.509证书属性。有关在mysql中使用ssl的背景信息，请参见6.3节“使用加密连接”。</p><p>
                    The optional <code class="literal">REQUIRE</code> clause specifies
                    SSL-related options for a MySQL account. The syntax is the
                    same as for the <a class="link" href="sql-syntax.html#create-user" title="13.7.1.2&nbsp;CREATE USER Syntax"><code class="literal">CREATE USER</code></a>
                    statement. For details, see <a class="xref" href="sql-syntax.html#create-user" title="13.7.1.2&nbsp;CREATE USER Syntax">Section&nbsp;13.7.1.2, “CREATE USER Syntax”</a>.
                </p><p style="color:blue;">可选的require子句为mysql帐户指定与ssl相关的选项。语法与create user语句相同。有关详细信息，请参见第13.7.1.2节“创建用户语法”。</p>
                    <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">

                        <div class="admon-title">
                            Note
                        </div>
                        <p>
                            Use of <a class="link" href="sql-syntax.html#grant" title="13.7.1.4&nbsp;GRANT Syntax"><code class="literal">GRANT</code></a> to define
                            account SSL characteristics is deprecated as of MySQL 5.7.6.
                            Instead, establish or change SSL characteristics using
                            <a class="link" href="sql-syntax.html#create-user" title="13.7.1.2&nbsp;CREATE USER Syntax"><code class="literal">CREATE USER</code></a> or
                            <a class="link" href="sql-syntax.html#alter-user" title="13.7.1.1&nbsp;ALTER USER Syntax"><code class="literal">ALTER USER</code></a>. This
                            <a class="link" href="sql-syntax.html#grant" title="13.7.1.4&nbsp;GRANT Syntax"><code class="literal">GRANT</code></a> capability will be
                            removed in a future MySQL release.
                        </p><p style="color:blue;">从mysql 5.7.6开始，不赞成使用grant来定义帐户ssl特性。相反，使用create user或alter user来建立或更改ssl特性。这种授权功能将在未来的mysql版本中删除。</p>
                    </div>
                    <p>
                        The optional <code class="literal">WITH</code> clause is used for these
                        purposes:
                    </p><p style="color:blue;">可选的WITH子句用于以下目的：</p>
                    <div class="itemizedlist">
                        <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                            To enable a user to grant privileges to other users
                        </p><p style="color:blue;">允许用户向其他用户授予权限</p></li><li class="listitem"><p>
                            To specify resource limits for a user
                        </p><p style="color:blue;">指定用户的资源限制</p></li></ul>
                    </div>
                    <p>
                        The <code class="literal">WITH GRANT OPTION</code> clause gives the user
                        the ability to give to other users any privileges the user has
                        at the specified privilege level.
                    </p><p style="color:blue;">WITH GRANT OPTION子句使用户能够将用户在指定权限级别上拥有的任何权限授予其他用户。</p><p>
                    To grant the <a class="link" href="security.html#priv_grant-option"><code class="literal">GRANT OPTION</code></a>
                    privilege to an account without otherwise changing its
                    privileges, do this:
                </p><p style="color:blue;">若要授予帐户“授予选项”权限而不更改其权限，请执行以下操作：</p><pre data-lang="sql" class="programlisting">GRANT USAGE ON *.* TO 'someuser'@'somehost' WITH GRANT OPTION;
</pre><p>
                    Be careful to whom you give the <a class="link" href="security.html#priv_grant-option"><code class="literal">GRANT
                    OPTION</code></a> privilege because two users with different
                    privileges may be able to combine privileges!
                </p><p style="color:blue;">请小心您授予谁“授予选项”权限，因为具有不同权限的两个用户可能可以组合权限！</p><p>
                    You cannot grant another user a privilege which you yourself
                    do not have; the <a class="link" href="security.html#priv_grant-option"><code class="literal">GRANT OPTION</code></a>
                    privilege enables you to assign only those privileges which
                    you yourself possess.
                </p><p style="color:blue;">您不能授予其他用户您自己没有的特权；授予选项特权允许您仅分配您自己拥有的特权。</p><p>
                    Be aware that when you grant a user the
                    <a class="link" href="security.html#priv_grant-option"><code class="literal">GRANT OPTION</code></a> privilege at a
                    particular privilege level, any privileges the user possesses
                    (or may be given in the future) at that level can also be
                    granted by that user to other users. Suppose that you grant a
                    user the <a class="link" href="security.html#priv_insert"><code class="literal">INSERT</code></a> privilege on a
                    database. If you then grant the
                    <a class="link" href="security.html#priv_select"><code class="literal">SELECT</code></a> privilege on the
                    database and specify <code class="literal">WITH GRANT OPTION</code>,
                    that user can give to other users not only the
                    <a class="link" href="security.html#priv_select"><code class="literal">SELECT</code></a> privilege, but also
                    <a class="link" href="security.html#priv_insert"><code class="literal">INSERT</code></a>. If you then grant the
                    <a class="link" href="security.html#priv_update"><code class="literal">UPDATE</code></a> privilege to the user on
                    the database, the user can grant
                    <a class="link" href="security.html#priv_insert"><code class="literal">INSERT</code></a>,
                    <a class="link" href="security.html#priv_select"><code class="literal">SELECT</code></a>, and
                    <a class="link" href="security.html#priv_update"><code class="literal">UPDATE</code></a>.
                </p><p style="color:blue;">请注意，当您在特定权限级别授予用户“授予选项”权限时，该用户在该级别拥有（或将来可能授予）的任何权限也可以由该用户授予其他用户。假设您授予用户数据库的插入权限。如果随后在数据库上授予select权限并指定with grant选项，则该用户不仅可以授予其他用户select权限，还可以向insert授予该权限。如果随后向数据库上的用户授予更新权限，则用户可以授予插入、选择和更新权限。</p><p>
                    For a nonadministrative user, you should not grant the
                    <a class="link" href="security.html#priv_alter"><code class="literal">ALTER</code></a> privilege globally or for
                    the <code class="literal">mysql</code> system database. If you do that,
                    the user can try to subvert the privilege system by renaming
                    tables!
                </p><p style="color:blue;">对于非管理用户，不应全局或针对mysql系统数据库授予alter权限。如果这样做，用户可以尝试通过重命名表来破坏特权系统！</p><p>
                    For additional information about security risks associated
                    with particular privileges, see
                    <a class="xref" href="security.html#privileges-provided" title="6.2.2&nbsp;Privileges Provided by MySQL">Section&nbsp;6.2.2, “Privileges Provided by MySQL”</a>.
                </p><p style="color:blue;">有关与特定权限相关的安全风险的更多信息，请参阅第6.2.2节“MySQL提供的权限”。</p><a class="indexterm" name="idm140286829173408"></a><a class="indexterm" name="idm140286829171920"></a><p>
                    It is possible to place limits on use of server resources by
                    an account, as discussed in <a class="xref" href="security.html#user-resources" title="6.2.16&nbsp;Setting Account Resource Limits">Section&nbsp;6.2.16, “Setting Account Resource Limits”</a>.
                    To do so, use a <code class="literal">WITH</code> clause that specifies
                    one or more <em class="replaceable"><code>resource_option</code></em> values.
                    Limits not specified retain their current values. The syntax
                    is the same as for the <a class="link" href="sql-syntax.html#create-user" title="13.7.1.2&nbsp;CREATE USER Syntax"><code class="literal">CREATE
                    USER</code></a> statement. For details, see
                    <a class="xref" href="sql-syntax.html#create-user" title="13.7.1.2&nbsp;CREATE USER Syntax">Section&nbsp;13.7.1.2, “CREATE USER Syntax”</a>.
                </p><p style="color:blue;">如第6.2.16节“设置帐户资源限制”所述，可以对帐户使用服务器资源设置限制。为此，请使用指定一个或多个资源选项值的WITH子句。未指定的限制保留其当前值。语法与create user语句相同。有关详细信息，请参见第13.7.1.2节“创建用户语法”。</p>
                    <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">

                        <div class="admon-title">
                            Note
                        </div>
                        <p>
                            Use of <a class="link" href="sql-syntax.html#grant" title="13.7.1.4&nbsp;GRANT Syntax"><code class="literal">GRANT</code></a> to define
                            account resource limits is deprecated as of MySQL 5.7.6.
                            Instead, establish or change resource limits using
                            <a class="link" href="sql-syntax.html#create-user" title="13.7.1.2&nbsp;CREATE USER Syntax"><code class="literal">CREATE USER</code></a> or
                            <a class="link" href="sql-syntax.html#alter-user" title="13.7.1.1&nbsp;ALTER USER Syntax"><code class="literal">ALTER USER</code></a>. This
                            <a class="link" href="sql-syntax.html#grant" title="13.7.1.4&nbsp;GRANT Syntax"><code class="literal">GRANT</code></a> capability will be
                            removed in a future MySQL release.
                        </p><p style="color:blue;">从mysql 5.7.6开始，不赞成使用grant定义帐户资源限制。相反，使用create user或alter user来建立或更改资源限制。这种授权功能将在未来的mysql版本中删除。</p>
                    </div>

                </div>
                <div class="simplesect">
                    <div class="titlepage">
                        <div>
                            <div class="simple">
                                <h5 class="title"><a name="grant-mysql-vs-standard-sql"></a>MySQL and Standard SQL Versions of GRANT</h5>

                            </div>

                        </div>

                    </div>
                    <a class="indexterm" name="idm140286829158736"></a><p>
                    The biggest differences between the MySQL and standard SQL
                    versions of <a class="link" href="sql-syntax.html#grant" title="13.7.1.4&nbsp;GRANT Syntax"><code class="literal">GRANT</code></a> are:
                </p><p style="color:blue;">grant的mysql版本和标准sql版本最大的区别是：</p>
                    <div class="itemizedlist">
                        <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                            MySQL associates privileges with the combination of a host
                            name and user name and not with only a user name.
                        </p><p style="color:blue;">mysql将特权与主机名和用户名的组合相关联，而不仅仅与用户名相关联。</p></li><li class="listitem"><p>
                            Standard SQL does not have global or database-level
                            privileges, nor does it support all the privilege types
                            that MySQL supports.
                        </p><p style="color:blue;">标准sql没有全局或数据库级别的权限，也不支持mysql支持的所有权限类型。</p></li><li class="listitem"><p>
                            MySQL does not support the standard SQL
                            <code class="literal">UNDER</code> privilege.
                        </p><p style="color:blue;">mysql不支持特权下的标准sql。</p></li><li class="listitem"><p>
                            Standard SQL privileges are structured in a hierarchical
                            manner. If you remove a user, all privileges the user has
                            been granted are revoked. This is also true in MySQL if
                            you use <a class="link" href="sql-syntax.html#drop-user" title="13.7.1.3&nbsp;DROP USER Syntax"><code class="literal">DROP USER</code></a>. See
                            <a class="xref" href="sql-syntax.html#drop-user" title="13.7.1.3&nbsp;DROP USER Syntax">Section&nbsp;13.7.1.3, “DROP USER Syntax”</a>.
                        </p><p style="color:blue;">标准的sql特权是以分层的方式构造的。如果删除用户，则该用户被授予的所有权限都将被吊销。如果使用drop user，在mysql中也是如此。参见第13.7.1.3节“删除用户语法”。</p></li><li class="listitem"><p>
                            In standard SQL, when you drop a table, all privileges for
                            the table are revoked. In standard SQL, when you revoke a
                            privilege, all privileges that were granted based on that
                            privilege are also revoked. In MySQL, privileges can be
                            dropped with <a class="link" href="sql-syntax.html#drop-user" title="13.7.1.3&nbsp;DROP USER Syntax"><code class="literal">DROP USER</code></a> or
                            <a class="link" href="sql-syntax.html#revoke" title="13.7.1.6&nbsp;REVOKE Syntax"><code class="literal">REVOKE</code></a> statements.
                        </p><p style="color:blue;">在标准sql中，当您删除一个表时，该表的所有特权都将被撤销。在标准sql中，当您撤销一个特权时，基于该特权授予的所有特权也将被撤销。在mysql中，可以使用drop user或revoke语句删除特权。</p></li><li class="listitem"><p>
                            In MySQL, it is possible to have the
                            <a class="link" href="security.html#priv_insert"><code class="literal">INSERT</code></a> privilege for only
                            some of the columns in a table. In this case, you can
                            still execute <a class="link" href="sql-syntax.html#insert" title="13.2.5&nbsp;INSERT Syntax"><code class="literal">INSERT</code></a>
                            statements on the table, provided that you insert values
                            only for those columns for which you have the
                            <a class="link" href="security.html#priv_insert"><code class="literal">INSERT</code></a> privilege. The
                            omitted columns are set to their implicit default values
                            if strict SQL mode is not enabled. In strict mode, the
                            statement is rejected if any of the omitted columns have
                            no default value. (Standard SQL requires you to have the
                            <a class="link" href="security.html#priv_insert"><code class="literal">INSERT</code></a> privilege on all
                            columns.) For information about strict SQL mode and
                            implicit default values, see <a class="xref" href="server-administration.html#sql-mode" title="5.1.10&nbsp;Server SQL Modes">Section&nbsp;5.1.10, “Server SQL Modes”</a>,
                            and <a class="xref" href="data-types.html#data-type-defaults" title="11.7&nbsp;Data Type Default Values">Section&nbsp;11.7, “Data Type Default Values”</a>.
                        </p><p style="color:blue;">在mysql中，可以只对表中的某些列具有insert权限。在这种情况下，您仍然可以在表上执行INSERT语句，前提是您只为具有INSERT权限的列插入值。如果未启用严格SQL模式，则忽略的列将设置为其隐式默认值。在严格模式下，如果省略的任何列没有默认值，则语句将被拒绝。（标准SQL要求您对所有列具有INSERT权限。）有关严格SQL模式和隐式默认值的信息，请参阅第5.1.10节“服务器SQL模式”和第11.7节“数据类型默认值”。</p></li></ul>
                    </div>

                </div>

            </div>
            <div class="section">
                <div class="titlepage">
                    <div>
                        <div>
                            <h4 class="title"><a name="rename-user"></a>13.7.1.5&nbsp;RENAME USER Syntax</h4>

                        </div>

                    </div>

                </div>
                <a class="indexterm" name="idm140286829136128"></a><a class="indexterm" name="idm140286829135056"></a><a class="indexterm" name="idm140286829133568"></a><pre data-lang="sql" class="programlisting">RENAME USER <em class="replaceable"><code>old_user</code></em> TO <em class="replaceable"><code>new_user</code></em>
    [, <em class="replaceable"><code>old_user</code></em> TO <em class="replaceable"><code>new_user</code></em>] ...
</pre><p>
                The <a class="link" href="sql-syntax.html#rename-user" title="13.7.1.5&nbsp;RENAME USER Syntax"><code class="literal">RENAME USER</code></a> statement renames
                existing MySQL accounts. An error occurs for old accounts that
                do not exist or new accounts that already exist.
            </p><p style="color:blue;">重命名用户语句重命名现有的MySQL帐户。对于不存在的旧帐户或已经存在的新帐户发生错误。</p><p>
                To use <a class="link" href="sql-syntax.html#rename-user" title="13.7.1.5&nbsp;RENAME USER Syntax"><code class="literal">RENAME USER</code></a>, you must have
                the global <a class="link" href="security.html#priv_create-user"><code class="literal">CREATE USER</code></a> privilege,
                or the <a class="link" href="security.html#priv_update"><code class="literal">UPDATE</code></a> privilege for the
                <code class="literal">mysql</code> system database. When the
                <a class="link" href="server-administration.html#sysvar_read_only"><code class="literal">read_only</code></a> system variable is
                enabled, <a class="link" href="sql-syntax.html#rename-user" title="13.7.1.5&nbsp;RENAME USER Syntax"><code class="literal">RENAME USER</code></a> additionally
                requires the <a class="link" href="security.html#priv_super"><code class="literal">SUPER</code></a> privilege.
            </p><p style="color:blue;">要使用rename user，必须具有全局创建用户权限或mysql系统数据库的更新权限。启用只读系统变量时，“重命名用户”还需要超级权限。</p><p>
                Each account name uses the format described in
                <a class="xref" href="security.html#account-names" title="6.2.4&nbsp;Specifying Account Names">Section&nbsp;6.2.4, “Specifying Account Names”</a>. For example:
            </p><p style="color:blue;">每个帐户名使用第6.2.4节“指定帐户名”中描述的格式。例如：</p><pre data-lang="sql" class="programlisting">RENAME USER 'jeffrey'@'localhost' TO 'jeff'@'127.0.0.1';
</pre><p>
                The host name part of the account name, if omitted, defaults to
                <code class="literal">'%'</code>.
            </p><p style="color:blue;">帐户名的主机名部分（如果省略）默认为“%”。</p><p>
                <a class="link" href="sql-syntax.html#rename-user" title="13.7.1.5&nbsp;RENAME USER Syntax"><code class="literal">RENAME USER</code></a> causes the privileges
                held by the old user to be those held by the new user. However,
                <a class="link" href="sql-syntax.html#rename-user" title="13.7.1.5&nbsp;RENAME USER Syntax"><code class="literal">RENAME USER</code></a> does not
                automatically drop or invalidate databases or objects within
                them that the old user created. This includes stored programs or
                views for which the <code class="literal">DEFINER</code> attribute names
                the old user. Attempts to access such objects may produce an
                error if they execute in definer security context. (For
                information about security context, see
                <a class="xref" href="stored-objects.html#stored-objects-security" title="23.6&nbsp;Stored Object Access Control">Section&nbsp;23.6, “Stored Object Access Control”</a>.)
            </p><p style="color:blue;">重命名用户使旧用户拥有的权限为新用户拥有的权限。但是，“重命名用户”不会自动删除或使旧用户创建的数据库或其中的对象无效。这包括definer属性为旧用户命名的存储程序或视图。如果这些对象在定义的安全上下文中执行，则访问这些对象的尝试可能会产生错误。（有关安全上下文的信息，请参阅第23.6节“存储对象访问控制”。）</p><p>
                The privilege changes take effect as indicated in
                <a class="xref" href="security.html#privilege-changes" title="6.2.9&nbsp;When Privilege Changes Take Effect">Section&nbsp;6.2.9, “When Privilege Changes Take Effect”</a>.
            </p><p style="color:blue;">特权变更如第6.2.9节“特权变更生效时”所述生效。</p>
            </div>
            <div class="section">
                <div class="titlepage">
                    <div>
                        <div>
                            <h4 class="title"><a name="revoke"></a>13.7.1.6&nbsp;REVOKE Syntax</h4>

                        </div>

                    </div>

                </div>
                <a class="indexterm" name="idm140286829105952"></a><a class="indexterm" name="idm140286829104880"></a><a class="indexterm" name="idm140286829103840"></a><a class="indexterm" name="idm140286829102352"></a><a class="indexterm" name="idm140286829101280"></a><pre data-lang="sql" class="programlisting">REVOKE
    <em class="replaceable"><code>priv_type</code></em> [(<em class="replaceable"><code>column_list</code></em>)]
      [, <em class="replaceable"><code>priv_type</code></em> [(<em class="replaceable"><code>column_list</code></em>)]] ...
    ON [<em class="replaceable"><code>object_type</code></em>] <em class="replaceable"><code>priv_level</code></em>
    FROM <em class="replaceable"><code>user</code></em> [, <em class="replaceable"><code>user</code></em>] ...

REVOKE ALL [PRIVILEGES], GRANT OPTION
    FROM <em class="replaceable"><code>user</code></em> [, <em class="replaceable"><code>user</code></em>] ...

REVOKE PROXY ON <em class="replaceable"><code>user</code></em>
    FROM <em class="replaceable"><code>user</code></em> [, <em class="replaceable"><code>user</code></em>] ...
</pre><p>
                The <a class="link" href="sql-syntax.html#revoke" title="13.7.1.6&nbsp;REVOKE Syntax"><code class="literal">REVOKE</code></a> statement enables
                system administrators to revoke privileges from MySQL accounts.
            </p><p style="color:blue;">revoke语句使系统管理员能够撤消mysql帐户的权限。</p><p>
                For details on the levels at which privileges exist, the
                permissible <em class="replaceable"><code>priv_type</code></em>,
                <em class="replaceable"><code>priv_level</code></em>, and
                <em class="replaceable"><code>object_type</code></em> values, and the syntax
                for specifying users and passwords, see <a class="xref" href="sql-syntax.html#grant" title="13.7.1.4&nbsp;GRANT Syntax">Section&nbsp;13.7.1.4, “GRANT Syntax”</a>.
            </p><p style="color:blue;">有关特权存在的级别、允许的私有类型、私有级别和ObjutsType值以及指定用户和密码的语法的详细信息，请参阅第137.1.4节“授予语法”。</p><p>
                When the <a class="link" href="server-administration.html#sysvar_read_only"><code class="literal">read_only</code></a> system
                variable is enabled, <a class="link" href="sql-syntax.html#revoke" title="13.7.1.6&nbsp;REVOKE Syntax"><code class="literal">REVOKE</code></a>
                requires the <a class="link" href="security.html#priv_super"><code class="literal">SUPER</code></a> privilege in
                addition to any other required privileges described in the
                following discussion.
            </p><p style="color:blue;">当启用只读系统变量时，除了下列讨论中描述的任何其他必需权限外，REVOKE还需要超级权限。</p><p>
                Each account name uses the format described in
                <a class="xref" href="security.html#account-names" title="6.2.4&nbsp;Specifying Account Names">Section&nbsp;6.2.4, “Specifying Account Names”</a>. For example:
            </p><p style="color:blue;">每个帐户名使用第6.2.4节“指定帐户名”中描述的格式。例如：</p><pre data-lang="sql" class="programlisting">REVOKE INSERT ON *.* FROM 'jeffrey'@'localhost';
</pre><p>
                The host name part of the account name, if omitted, defaults to
                <code class="literal">'%'</code>.
            </p><p style="color:blue;">帐户名的主机名部分（如果省略）默认为“%”。</p><p>
                To use the first <a class="link" href="sql-syntax.html#revoke" title="13.7.1.6&nbsp;REVOKE Syntax"><code class="literal">REVOKE</code></a> syntax,
                you must have the <a class="link" href="security.html#priv_grant-option"><code class="literal">GRANT OPTION</code></a>
                privilege, and you must have the privileges that you are
                revoking.
            </p><p style="color:blue;">要使用第一个revoke语法，您必须具有grant option特权，并且您必须具有要撤消的特权。</p><p>
                To revoke all privileges, use the second syntax, which drops all
                global, database, table, column, and routine privileges for the
                named user or users:
            </p><p style="color:blue;">要撤消所有权限，请使用第二种语法，该语法将删除指定用户的所有全局、数据库、表、列和例程权限：</p><pre data-lang="sql" class="programlisting">REVOKE ALL PRIVILEGES, GRANT OPTION FROM <em class="replaceable"><code>user</code></em> [, <em class="replaceable"><code>user</code></em>] ...
</pre><p>
                To use this <a class="link" href="sql-syntax.html#revoke" title="13.7.1.6&nbsp;REVOKE Syntax"><code class="literal">REVOKE</code></a> syntax, you
                must have the global <a class="link" href="security.html#priv_create-user"><code class="literal">CREATE USER</code></a>
                privilege, or the <a class="link" href="security.html#priv_update"><code class="literal">UPDATE</code></a>
                privilege for the <code class="literal">mysql</code> system database.
            </p><p style="color:blue;">要使用此撤销语法，您必须具有全局创建用户权限或mysql系统数据库的更新权限。</p><p>
                User accounts from which privileges are to be revoked must
                exist, but the privileges to be revoked need not be currently
                granted to them.
            </p><p style="color:blue;">必须从中取消特权的用户帐户，但当前不必授予特权。</p><p>
                <a class="link" href="sql-syntax.html#revoke" title="13.7.1.6&nbsp;REVOKE Syntax"><code class="literal">REVOKE</code></a> removes privileges, but
                does not remove rows from the <code class="literal">mysql.user</code>
                system table. To remove a user account entirely, use
                <a class="link" href="sql-syntax.html#drop-user" title="13.7.1.3&nbsp;DROP USER Syntax"><code class="literal">DROP USER</code></a>. See
                <a class="xref" href="sql-syntax.html#drop-user" title="13.7.1.3&nbsp;DROP USER Syntax">Section&nbsp;13.7.1.3, “DROP USER Syntax”</a>.
            </p><p style="color:blue;">revoke删除特权，但不从mysql.user系统表中删除行。要完全删除用户帐户，请使用drop user。参见第13.7.1.3节“删除用户语法”。</p><p>
                If the grant tables hold privilege rows that contain mixed-case
                database or table names and the
                <a class="link" href="server-administration.html#sysvar_lower_case_table_names"><code class="literal">lower_case_table_names</code></a> system
                variable is set to a nonzero value,
                <a class="link" href="sql-syntax.html#revoke" title="13.7.1.6&nbsp;REVOKE Syntax"><code class="literal">REVOKE</code></a> cannot be used to revoke
                these privileges. It will be necessary to manipulate the grant
                tables directly. (<a class="link" href="sql-syntax.html#grant" title="13.7.1.4&nbsp;GRANT Syntax"><code class="literal">GRANT</code></a> will not
                create such rows when
                <a class="link" href="server-administration.html#sysvar_lower_case_table_names"><code class="literal">lower_case_table_names</code></a> is set,
                but such rows might have been created prior to setting the
                variable.)
            </p><p style="color:blue;">如果GRANT TABLES持有包含混合大小写数据库或表名的特权行，并且小写的TABLE NAME系统变量设置为非零值，则REVOKE不能用于撤消这些特权。必须直接操作授权表。（当设置了小写表名时，grant不会创建这样的行，但这些行可能是在设置变量之前创建的。）</p><p>
                When successfully executed from the <a class="link" href="programs.html#mysql" title="4.5.1&nbsp;mysql — The MySQL Command-Line Client"><span class="command"><strong>mysql</strong></span></a>
                program, <a class="link" href="sql-syntax.html#revoke" title="13.7.1.6&nbsp;REVOKE Syntax"><code class="literal">REVOKE</code></a> responds with
                <code class="literal">Query OK, 0 rows affected</code>. To determine what
                privileges remain after the operation, use
                <a class="link" href="sql-syntax.html#show-grants" title="13.7.5.21&nbsp;SHOW GRANTS Syntax"><code class="literal">SHOW GRANTS</code></a>. See
                <a class="xref" href="sql-syntax.html#show-grants" title="13.7.5.21&nbsp;SHOW GRANTS Syntax">Section&nbsp;13.7.5.21, “SHOW GRANTS Syntax”</a>.
            </p><p style="color:blue;">从mysql程序成功执行时，revoke使用query ok响应，0行受影响。要确定操作后保留哪些特权，请使用“显示授权”。见第13.7.5.21节，“显示授权语法”。</p>
            </div>
            <div class="section">
                <div class="titlepage">
                    <div>
                        <div>
                            <h4 class="title"><a name="set-password"></a>13.7.1.7&nbsp;SET PASSWORD Syntax</h4>

                        </div>

                    </div>

                </div>
                <a class="indexterm" name="idm140286829049856"></a><a class="indexterm" name="idm140286829048784"></a><a class="indexterm" name="idm140286829047296"></a><pre data-lang="sql" class="programlisting">SET PASSWORD [FOR <em class="replaceable"><code>user</code></em>] = <em class="replaceable"><code>password_option</code></em>

<em class="replaceable"><code>password_option</code></em>: {
    '<em class="replaceable"><code>auth_string</code></em>'
  | PASSWORD('<em class="replaceable"><code>auth_string</code></em>')
}
</pre><p>
                The <a class="link" href="sql-syntax.html#set-password" title="13.7.1.7&nbsp;SET PASSWORD Syntax"><code class="literal">SET PASSWORD</code></a> statement
                assigns a password to a MySQL user account.
                <code class="literal">'<em class="replaceable"><code>auth_string</code></em>'</code>
                represents a cleartext (unencrypted) password.
            </p><p style="color:blue;">set password语句为MySQL用户帐户分配密码。auth_string'表示明文（未加密）密码。</p>
                <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">

                    <div class="admon-title">
                        Note
                    </div>

                    <div class="itemizedlist">
                        <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                            <a class="link" href="sql-syntax.html#set-password" title="13.7.1.7&nbsp;SET PASSWORD Syntax"><code class="literal">SET PASSWORD
                                ... =
                                PASSWORD('<em class="replaceable"><code>auth_string</code></em>')</code></a>
                            syntax is deprecated as of MySQL 5.7.6 and will be removed
                            in a future MySQL release.
                        </p><p style="color:blue;">设置密码…=password（'auth_string'）语法从mysql 5.7.6开始就被弃用，并将在以后的mysql版本中删除。</p></li><li class="listitem"><p>
                            <a class="link" href="sql-syntax.html#set-password" title="13.7.1.7&nbsp;SET PASSWORD Syntax"><code class="literal">SET PASSWORD
                                ... = '<em class="replaceable"><code>auth_string</code></em>'</code></a>
                            syntax is not deprecated, but <a class="link" href="sql-syntax.html#alter-user" title="13.7.1.1&nbsp;ALTER USER Syntax"><code class="literal">ALTER
                            USER</code></a> is the preferred statement for account
                            alterations, including assigning passwords. For example:
                        </p><p style="color:blue;">设置密码…=“auth_string”语法不被弃用，但alter user是帐户更改（包括分配密码）的首选语句。例如：</p><pre data-lang="sql" class="programlisting">ALTER USER <em class="replaceable"><code>user</code></em> IDENTIFIED BY '<em class="replaceable"><code>auth_string</code></em>';
</pre></li></ul>
                    </div>

                </div>
                <div class="important" style="margin-left: 0.5in; margin-right: 0.5in;">
                    <div class="admon-title">
                        Important
                    </div>
                    <p>
                        Under some circumstances, <a class="link" href="sql-syntax.html#set-password" title="13.7.1.7&nbsp;SET PASSWORD Syntax"><code class="literal">SET
                        PASSWORD</code></a> may be recorded in server logs or on the
                        client side in a history file such as
                        <code class="filename">~/.mysql_history</code>, which means that
                        cleartext passwords may be read by anyone having read access
                        to that information. For information about the conditions
                        under which this occurs for the server logs and how to control
                        it, see <a class="xref" href="security.html#password-logging" title="6.1.2.3&nbsp;Passwords and Logging">Section&nbsp;6.1.2.3, “Passwords and Logging”</a>. For similar
                        information about client-side logging, see
                        <a class="xref" href="programs.html#mysql-logging" title="4.5.1.3&nbsp;mysql Client Logging">Section&nbsp;4.5.1.3, “mysql Client Logging”</a>.
                    </p><p style="color:blue;">在某些情况下，设置的密码可能会记录在服务器日志或客户端的历史文件（如~/.mysql_history）中，这意味着对该信息具有读取权限的任何人都可以读取明文密码。有关服务器日志发生这种情况的条件以及如何控制它的信息，请参阅第6.1.2.3节“密码和日志记录”。有关客户端日志记录的类似信息，请参阅第4.5.1.3节“MySQL客户端日志记录”。</p>
                </div>
                <p>
                    <a class="link" href="sql-syntax.html#set-password" title="13.7.1.7&nbsp;SET PASSWORD Syntax"><code class="literal">SET PASSWORD</code></a> can be used with or
                    without a <code class="literal">FOR</code> clause that explicitly names a
                    user account:
                </p><p style="color:blue;">set password可以与for子句一起使用，也可以不使用for子句来显式命名用户帐户：</p>
                <div class="itemizedlist">
                    <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                        With a <code class="literal">FOR
                        <em class="replaceable"><code>user</code></em></code> clause, the
                        statement sets the password for the named account, which
                        must exist:
                    </p><p style="color:blue;">对于Apple子句，语句为指定的帐户设置密码，该帐户必须存在：</p><pre data-lang="sql" class="programlisting">SET PASSWORD FOR 'jeffrey'@'localhost' = '<em class="replaceable"><code>auth_string</code></em>';
</pre></li><li class="listitem"><p>
                        With no <code class="literal">FOR
                        <em class="replaceable"><code>user</code></em></code> clause, the
                        statement sets the password for the current user:
                    </p><p style="color:blue;">在没有for user子句的情况下，语句为当前用户设置密码：</p><pre data-lang="sql" class="programlisting">SET PASSWORD = '<em class="replaceable"><code>auth_string</code></em>';
</pre><p>
                        Any client who connects to the server using a nonanonymous
                        account can change the password for that account. (In
                        particular, you can change your own password.) To see which
                        account the server authenticated you as, invoke the
                        <a class="link" href="functions.html#function_current-user"><code class="literal">CURRENT_USER()</code></a> function:
                    </p><p style="color:blue;">任何使用非匿名帐户连接到服务器的客户端都可以更改该帐户的密码。（特别是，您可以更改自己的密码。）要查看服务器验证您身份的帐户，请调用current_user（）函数：</p><pre data-lang="sql" class="programlisting">SELECT CURRENT_USER();
</pre></li></ul>
                </div>
                <p>
                    If a <code class="literal">FOR <em class="replaceable"><code>user</code></em></code>
                    clause is given, the account name uses the format described in
                    <a class="xref" href="security.html#account-names" title="6.2.4&nbsp;Specifying Account Names">Section&nbsp;6.2.4, “Specifying Account Names”</a>. For example:
                </p><p style="color:blue;">如果给定for user子句，则帐户名使用第6.2.4节“指定帐户名”中描述的格式。例如：</p><pre data-lang="sql" class="programlisting">SET PASSWORD FOR 'bob'@'%.example.org' = '<em class="replaceable"><code>auth_string</code></em>';
</pre><p>
                The host name part of the account name, if omitted, defaults to
                <code class="literal">'%'</code>.
            </p><p style="color:blue;">帐户名的主机名部分（如果省略）默认为“%”。</p><p>
                Setting the password for a named account (with a
                <code class="literal">FOR</code> clause) requires the
                <a class="link" href="sql-syntax.html#update" title="13.2.11&nbsp;UPDATE Syntax"><code class="literal">UPDATE</code></a> privilege for the
                <code class="literal">mysql</code> system database. Setting the password
                for yourself (for a nonanonymous account with no
                <code class="literal">FOR</code> clause) requires no special privileges.
                When the <a class="link" href="server-administration.html#sysvar_read_only"><code class="literal">read_only</code></a> system
                variable is enabled, <a class="link" href="sql-syntax.html#set-password" title="13.7.1.7&nbsp;SET PASSWORD Syntax"><code class="literal">SET PASSWORD</code></a>
                requires the <a class="link" href="security.html#priv_super"><code class="literal">SUPER</code></a> privilege in
                addition to any other required privileges.
            </p><p style="color:blue;">为命名帐户设置密码（使用for子句）需要mysql系统数据库的更新权限。为自己设置密码（对于没有for子句的非匿名帐户）不需要特殊权限。启用只读系统变量时，SET PASSWORD除了需要任何其他权限外，还需要超级权限。</p><p>
                The password can be specified in these ways:
            </p><p style="color:blue;">密码可以通过以下方式指定：</p>
                <div class="itemizedlist">
                    <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                        Use a string without
                        <a class="link" href="functions.html#function_password"><code class="literal">PASSWORD()</code></a>
                    </p><p style="color:blue;">使用不带密码的字符串（）</p><pre data-lang="sql" class="programlisting">SET PASSWORD FOR 'jeffrey'@'localhost' = '<em class="replaceable"><code>password</code></em>';
</pre><p>
                        <a class="link" href="sql-syntax.html#set-password" title="13.7.1.7&nbsp;SET PASSWORD Syntax"><code class="literal">SET PASSWORD</code></a> interprets the
                        string as a cleartext string, passes it to the
                        authentication plugin associated with the account, and
                        stores the result returned by the plugin in the account row
                        in the <code class="literal">mysql.user</code> system table. (The
                        plugin is given the opportunity to hash the value into the
                        encryption format it expects. The plugin may use the value
                        as specified, in which case no hashing occurs.)
                    </p><p style="color:blue;">set password将字符串解释为明文字符串，将其传递给与帐户关联的身份验证插件，并将插件返回的结果存储在mysql.user system表的account行中。（插件有机会将值散列成它期望的加密格式。插件可以使用指定的值，在这种情况下不会发生哈希运算。）</p></li><li class="listitem"><p>
                        Use the <a class="link" href="functions.html#function_password"><code class="literal">PASSWORD()</code></a> function
                        (deprecated as of MySQL 5.7.6)
                    </p><p style="color:blue;">使用password（）函数（从mysql 5.7.6开始不推荐使用）</p><pre data-lang="sql" class="programlisting">SET PASSWORD FOR 'jeffrey'@'localhost' = PASSWORD('<em class="replaceable"><code>password</code></em>');
</pre><p>
                        The <a class="link" href="functions.html#function_password"><code class="literal">PASSWORD()</code></a> argument is
                        the cleartext (unencrypted) password.
                        <a class="link" href="functions.html#function_password"><code class="literal">PASSWORD()</code></a> hashes the
                        password and returns the encrypted password string for
                        storage in the account row in the
                        <code class="literal">mysql.user</code> system table.
                    </p><p style="color:blue;">password（）参数是明文（未加密）密码。password（）对密码进行哈希运算，并返回用于存储在mysql.user system表的account行中的加密密码字符串。</p><p>
                        The <a class="link" href="functions.html#function_password"><code class="literal">PASSWORD()</code></a> function
                        hashes the password using the hashing method determined by
                        the value of the
                        <a class="link" href="server-administration.html#sysvar_old_passwords"><code class="literal">old_passwords</code></a> system
                        variable value. Be sure that
                        <a class="link" href="server-administration.html#sysvar_old_passwords"><code class="literal">old_passwords</code></a> has the value
                        corresponding to the hashing method expected by the
                        authentication plugin associated with the account. For
                        example, if the account uses the
                        <code class="literal">mysql_native_password</code> plugin, the
                        <a class="link" href="server-administration.html#sysvar_old_passwords"><code class="literal">old_passwords</code></a> value must be
                        0:
                    </p><p style="color:blue;">password（）函数使用由旧密码系统变量值确定的哈希方法对密码进行哈希运算。请确保旧密码具有与帐户关联的身份验证插件所期望的哈希方法对应的值。例如，如果帐户使用mysql_native_password插件，则old_passwords值必须为0：</p><pre data-lang="sql" class="programlisting">SET old_passwords = 0;
SET PASSWORD FOR 'jeffrey'@'localhost' = PASSWORD('<em class="replaceable"><code>password</code></em>');
</pre><p>
                        If the <a class="link" href="server-administration.html#sysvar_old_passwords"><code class="literal">old_passwords</code></a> value
                        differs from that required by the authentication plugin, the
                        hashed password value returned by
                        <a class="link" href="functions.html#function_password"><code class="literal">PASSWORD()</code></a> will not by usable
                        by the plugin and correct authentication of client
                        connections will not occur.
                    </p><p style="color:blue;">如果旧的密码值不同于身份验证插件所需的密码值，则password（）返回的哈希密码值将无法被插件使用，并且不会对客户端连接进行正确的身份验证。</p></li></ul>
                </div>
                <p>
                    The following table shows, for each password hashing method, the
                    permitted value of <code class="literal">old_passwords</code> and which
                    authentication plugins use the hashing method.
                </p><p style="color:blue;">下表显示了对于每个密码哈希方法，旧密码的允许值以及哪些身份验证插件使用哈希方法。</p>
                <div class="informaltable">
                    <table summary="For each password hashing method, the permitted value of old_passwords and which authentication plugins use the hashing method"><colgroup><col width="40%"><col width="20%"><col width="40%"></colgroup><thead><tr>
                        <th scope="col">Password Hashing Method</th>
                        <th scope="col">old_passwords Value</th>
                        <th scope="col">Associated Authentication Plugin</th>
                    </tr></thead><tbody><tr>
                        <td scope="row">MySQL 4.1 native hashing</td>
                        <td>0</td>
                        <td><code class="literal">mysql_native_password</code></td>
                    </tr><tr>
                        <td scope="row">SHA-256 hashing</td>
                        <td>2</td>
                        <td><code class="literal">sha256_password</code></td>
                    </tr></tbody></table>
                </div>
                <p>
                    For additional information about setting passwords and
                    authentication plugins, see
                    <a class="xref" href="security.html#assigning-passwords" title="6.2.10&nbsp;Assigning Account Passwords">Section&nbsp;6.2.10, “Assigning Account Passwords”</a>, and
                    <a class="xref" href="security.html#pluggable-authentication" title="6.2.13&nbsp;Pluggable Authentication">Section&nbsp;6.2.13, “Pluggable Authentication”</a>.
                </p><p style="color:blue;">有关设置密码和身份验证插件的其他信息，请参阅第6.2.10节“分配帐户密码”和第6.2.13节“可插入身份验证”。</p>
            </div>

        </div>
        <div class="section">
            <div class="titlepage">
                <div>
                    <div>
                        <h3 class="title"><a name="table-maintenance-sql"></a>13.7.2&nbsp;Table Maintenance Statements</h3>

                    </div>

                </div>

            </div>
            <div class="toc">
                <dl class="toc"><dt><span class="section"><a href="sql-syntax.html#analyze-table">13.7.2.1 ANALYZE TABLE Syntax</a></span></dt><dt><span class="section"><a href="sql-syntax.html#check-table">13.7.2.2 CHECK TABLE Syntax</a></span></dt><dt><span class="section"><a href="sql-syntax.html#checksum-table">13.7.2.3 CHECKSUM TABLE Syntax</a></span></dt><dt><span class="section"><a href="sql-syntax.html#optimize-table">13.7.2.4 OPTIMIZE TABLE Syntax</a></span></dt><dt><span class="section"><a href="sql-syntax.html#repair-table">13.7.2.5 REPAIR TABLE Syntax</a></span></dt></dl>
            </div>
            <div class="section">
                <div class="titlepage">
                    <div>
                        <div>
                            <h4 class="title"><a name="analyze-table"></a>13.7.2.1&nbsp;ANALYZE TABLE Syntax</h4>

                        </div>

                    </div>

                </div>
                <a class="indexterm" name="idm140286828951584"></a><pre data-lang="sql" class="programlisting">ANALYZE [NO_WRITE_TO_BINLOG | LOCAL]
    TABLE <em class="replaceable"><code>tbl_name</code></em> [, <em class="replaceable"><code>tbl_name</code></em>] ...
</pre><p>
                <a class="link" href="sql-syntax.html#analyze-table" title="13.7.2.1&nbsp;ANALYZE TABLE Syntax"><code class="literal">ANALYZE TABLE</code></a> performs a key
                distribution analysis and stores the distribution for the named
                table or tables. For <code class="literal">MyISAM</code> tables, this
                statement is equivalent to using <a class="link" href="programs.html#myisamchk" title="4.6.3&nbsp;myisamchk — MyISAM Table-Maintenance Utility"><span class="command"><strong>myisamchk
        --analyze</strong></span></a>.
            </p><p style="color:blue;">analyze table执行键分布分析并存储命名表的分布。对于myisam表，此语句相当于使用myisamchk--analyze。</p><p>
                This statement requires <a class="link" href="security.html#priv_select"><code class="literal">SELECT</code></a>
                and <a class="link" href="security.html#priv_insert"><code class="literal">INSERT</code></a> privileges for the
                table.
            </p><p style="color:blue;">此语句要求表具有选择和插入权限。</p><p>
                <a class="link" href="sql-syntax.html#analyze-table" title="13.7.2.1&nbsp;ANALYZE TABLE Syntax"><code class="literal">ANALYZE TABLE</code></a> works with
                <code class="literal">InnoDB</code>, <code class="literal">NDB</code>, and
                <code class="literal">MyISAM</code> tables. It does not work with views.
            </p><p style="color:blue;">analyze table与innodb、ndb和myisam表一起使用。它不适用于视图。</p><p>
                <a class="link" href="sql-syntax.html#analyze-table" title="13.7.2.1&nbsp;ANALYZE TABLE Syntax"><code class="literal">ANALYZE TABLE</code></a> is supported for
                partitioned tables, and you can use <code class="literal">ALTER TABLE ...
                ANALYZE PARTITION</code> to analyze one or more partitions;
                for more information, see <a class="xref" href="sql-syntax.html#alter-table" title="13.1.8&nbsp;ALTER TABLE Syntax">Section&nbsp;13.1.8, “ALTER TABLE Syntax”</a>, and
                <a class="xref" href="partitioning.html#partitioning-maintenance" title="22.3.4&nbsp;Maintenance of Partitions">Section&nbsp;22.3.4, “Maintenance of Partitions”</a>.
            </p><p style="color:blue;">分区表支持分析表，您可以使用alter table…分析分区以分析一个或多个分区；有关更多信息，请参阅第131.8节、“ALTE表语法”和“第二段2.2.4节”“分区维护”。</p><p>
                During the analysis, the table is locked with a read lock for
                <code class="literal">InnoDB</code> and <code class="literal">MyISAM</code>.
            </p><p style="color:blue;">在分析过程中，表被innodb和myisam的读锁锁定。</p><p>
                <a class="link" href="sql-syntax.html#analyze-table" title="13.7.2.1&nbsp;ANALYZE TABLE Syntax"><code class="literal">ANALYZE TABLE</code></a> removes the table
                from the table definition cache, which requires a flush lock. If
                there are long running statements or transactions still using
                the table, subsequent statements and transactions must wait for
                those operations to finish before the flush lock is released.
                Because <a class="link" href="sql-syntax.html#analyze-table" title="13.7.2.1&nbsp;ANALYZE TABLE Syntax"><code class="literal">ANALYZE TABLE</code></a> itself
                typically finishes quickly, it may not be apparent that delayed
                transactions or statements involving the same table are due to
                the remaining flush lock.
            </p><p style="color:blue;">analyze table从表定义缓存中删除表，该缓存需要刷新锁。如果有长时间运行的语句或事务仍在使用表，则在释放刷新锁之前，后续语句和事务必须等待这些操作完成。由于分析表本身通常很快完成，因此可能不太明显，延迟的事务或涉及同一表的语句是由于剩余的刷新锁造成的。</p><p>
                By default, the server writes <a class="link" href="sql-syntax.html#analyze-table" title="13.7.2.1&nbsp;ANALYZE TABLE Syntax"><code class="literal">ANALYZE
                TABLE</code></a> statements to the binary log so that they
                replicate to replication slaves. To suppress logging, specify
                the optional <code class="literal">NO_WRITE_TO_BINLOG</code> keyword or
                its alias <code class="literal">LOCAL</code>.
            </p><p style="color:blue;">默认情况下，服务器将分析表语句写入二进制日志，以便它们复制到复制从属服务器。要禁止日志记录，请指定可选的no_write_to_binlog关键字或其别名local。</p>
                <div class="itemizedlist">
                    <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><a class="xref" href="sql-syntax.html#analyze-table-output" title="ANALYZE TABLE Output">ANALYZE TABLE Output</a></p><p style="color:blue;">分析表输出</p></li><li class="listitem"><p><a class="xref" href="sql-syntax.html#analyze-table-key-distribution-analysis" title="Key Distribution Analysis">Key Distribution Analysis</a></p><p style="color:blue;">关键分布分析</p></li><li class="listitem"><p><a class="xref" href="sql-syntax.html#analyze-table-other-considerations" title="Other Considerations">Other Considerations</a></p><p style="color:blue;">其他注意事项</p></li></ul>
                </div>

                <div class="simplesect">

                    <div class="titlepage">
                        <div>

                            <div class="simple">
                                <h5 class="title"><a name="analyze-table-output"></a>ANALYZE TABLE Output</h5>

                            </div>

                        </div>

                    </div>
                    <p>
                        <a class="link" href="sql-syntax.html#analyze-table" title="13.7.2.1&nbsp;ANALYZE TABLE Syntax"><code class="literal">ANALYZE TABLE</code></a> returns a result
                        set with the columns shown in the following table.
                    </p><p style="color:blue;">analyze table返回一个结果集，其列如下表所示。</p>
                    <div class="informaltable">
                        <table summary="Columns of the ANALYZE TABLE result set."><colgroup><col width="15%"><col width="60%"></colgroup><thead><tr>
                            <th scope="col">Column</th>
                            <th scope="col">Value</th>
                        </tr></thead><tbody><tr>
                            <td scope="row"><code class="literal">Table</code></td>
                            <td>The table name</td>
                        </tr><tr>
                            <td scope="row"><code class="literal">Op</code></td>
                            <td>Always <code class="literal">analyze</code></td>
                        </tr><tr>
                            <td scope="row"><code class="literal">Msg_type</code></td>
                            <td><code class="literal">status</code>, <code class="literal">error</code>,
                                <code class="literal">info</code>, <code class="literal">note</code>, or
                                <code class="literal">warning</code></td>
                        </tr><tr>
                            <td scope="row"><code class="literal">Msg_text</code></td>
                            <td>An informational message</td>
                        </tr></tbody></table>
                    </div>

                </div>
                <div class="simplesect">
                    <div class="titlepage">
                        <div>
                            <div class="simple">
                                <h5 class="title"><a name="analyze-table-key-distribution-analysis"></a>Key Distribution Analysis</h5>

                            </div>

                        </div>

                    </div>
                    <p>
                        If the table has not changed since the last key distribution
                        analysis, the table is not analyzed again.
                    </p><p style="color:blue;">如果自上次密钥分布分析以来表没有更改，则不会再次分析该表。</p><p>
                    MySQL uses the stored key distribution to decide the table
                    join order for joins on something other than a constant. In
                    addition, key distributions can be used when deciding which
                    indexes to use for a specific table within a query.
                </p><p style="color:blue;">mysql使用存储的键分布来决定表的连接顺序，而不是常量。此外，在决定查询中的特定表要使用哪些索引时，可以使用键分布。</p><p>
                    For more information on how key distribution analysis works
                    within <code class="literal">InnoDB</code>, see
                    <a class="xref" href="innodb-storage-engine.html#innodb-persistent-stats" title="14.8.11.1&nbsp;Configuring Persistent Optimizer Statistics Parameters">Section&nbsp;14.8.11.1, “Configuring Persistent Optimizer Statistics Parameters”</a> and
                    <a class="xref" href="innodb-storage-engine.html#innodb-analyze-table-complexity" title="14.8.11.3&nbsp;Estimating ANALYZE TABLE Complexity for InnoDB Tables">Section&nbsp;14.8.11.3, “Estimating ANALYZE TABLE Complexity for InnoDB Tables”</a>. Also see
                    <a class="xref" href="innodb-storage-engine.html#innodb-restrictions" title="14.6.1.6&nbsp;Limits on InnoDB Tables">Section&nbsp;14.6.1.6, “Limits on InnoDB Tables”</a>. In particular, if the
                    <a class="link" href="innodb-storage-engine.html#sysvar_innodb_stats_persistent"><code class="literal">innodb_stats_persistent</code></a>
                    system variable is enabled, you must run
                    <a class="link" href="sql-syntax.html#analyze-table" title="13.7.2.1&nbsp;ANALYZE TABLE Syntax"><code class="literal">ANALYZE TABLE</code></a> after loading
                    substantial data into an <code class="literal">InnoDB</code> table, or
                    creating a new index for one.
                </p><p style="color:blue;">有关密钥分发分析在NoYDB中如何工作的更多信息，请参见第14.11节、“配置永久性优化器统计参数”和“第14节”，“估计UnIDB表的分析表复杂性”。另见第14.6.1.6节“InnoDB表的限制”。特别是，如果启用了innodb_stats_persistent系统变量，则必须在将大量数据加载到innodb表中或为其创建新索引后运行analyze table。</p><p>
                    To check the stored key distribution cardinality, use the
                    <a class="link" href="sql-syntax.html#show-index" title="13.7.5.22&nbsp;SHOW INDEX Syntax"><code class="literal">SHOW INDEX</code></a> statement or the
                    <code class="literal">INFORMATION_SCHEMA</code>
                    <a class="link" href="information-schema.html#statistics-table" title="24.24&nbsp;The INFORMATION_SCHEMA STATISTICS Table"><code class="literal">STATISTICS</code></a> table. See
                    <a class="xref" href="sql-syntax.html#show-index" title="13.7.5.22&nbsp;SHOW INDEX Syntax">Section&nbsp;13.7.5.22, “SHOW INDEX Syntax”</a>, and
                    <a class="xref" href="information-schema.html#statistics-table" title="24.24&nbsp;The INFORMATION_SCHEMA STATISTICS Table">Section&nbsp;24.24, “The INFORMATION_SCHEMA STATISTICS Table”</a>.
                </p><p style="color:blue;">要检查存储的密钥分布基数，请使用show index语句或information_schema statistics表。参见第13.7.5.22节“显示索引语法”和第24.24节“信息模式统计表”。</p>
                </div>
                <div class="simplesect">
                    <div class="titlepage">
                        <div>
                            <div class="simple">
                                <h5 class="title"><a name="analyze-table-other-considerations"></a>Other Considerations</h5>

                            </div>

                        </div>

                    </div>
                    <p>
                        <code class="literal">ANALYZE TABLE</code> clears table statistics from
                        the
                        <a class="ulink" href="https://dev.mysql.com/doc/refman/8.0/en/innodb-tablestats-table.html" target="_top"><code class="literal">INFORMATION_SCHEMA.INNODB_TABLESTATS</code></a>
                        table and sets the <code class="literal">STATS_INITIALIZED</code> column
                        to <code class="literal">Uninitialized</code>. Statistics are collected
                        again the next time the table is accessed.
                    </p><p style="color:blue;">analyze table从information schema.innodb_table stats表中清除表统计信息，并将stats_initialized列设置为uninitialized。下次访问表时将再次收集统计信息。</p>
                </div>

            </div>
            <div class="section">
                <div class="titlepage">
                    <div>
                        <div>
                            <h4 class="title"><a name="check-table"></a>13.7.2.2&nbsp;CHECK TABLE Syntax</h4>

                        </div>

                    </div>

                </div>
                <a class="indexterm" name="idm140286828875344"></a><pre data-lang="sql" class="programlisting">CHECK TABLE <em class="replaceable"><code>tbl_name</code></em> [, <em class="replaceable"><code>tbl_name</code></em>] ... [<em class="replaceable"><code>option</code></em>] ...

<em class="replaceable"><code>option</code></em>: {
    FOR UPGRADE
  | QUICK
  | FAST
  | MEDIUM
  | EXTENDED
  | CHANGED
}
</pre><p>
                <a class="link" href="sql-syntax.html#check-table" title="13.7.2.2&nbsp;CHECK TABLE Syntax"><code class="literal">CHECK TABLE</code></a> checks a table or
                tables for errors. For <code class="literal">MyISAM</code> tables, the key
                statistics are updated as well. <a class="link" href="sql-syntax.html#check-table" title="13.7.2.2&nbsp;CHECK TABLE Syntax"><code class="literal">CHECK
                TABLE</code></a> can also check views for problems, such as
                tables that are referenced in the view definition that no longer
                exist.
            </p><p style="color:blue;">检查表检查一个或多个表是否有错误。对于myisam表，关键统计数据也会更新。检查表还可以检查问题的视图，例如视图定义中引用的表，这些表不再存在。</p><p>
                To check a table, you must have some privilege for it.
            </p><p style="color:blue;">要检查一个表，您必须对它有一些特权。</p><p>
                <a class="link" href="sql-syntax.html#check-table" title="13.7.2.2&nbsp;CHECK TABLE Syntax"><code class="literal">CHECK TABLE</code></a> works for
                <a class="link" href="innodb-storage-engine.html" title="Chapter&nbsp;14&nbsp;The InnoDB Storage Engine"><code class="literal">InnoDB</code></a>,
                <a class="link" href="storage-engines.html#myisam-storage-engine" title="15.2&nbsp;The MyISAM Storage Engine"><code class="literal">MyISAM</code></a>,
                <a class="link" href="storage-engines.html#archive-storage-engine" title="15.5&nbsp;The ARCHIVE Storage Engine"><code class="literal">ARCHIVE</code></a>, and
                <a class="link" href="storage-engines.html#csv-storage-engine" title="15.4&nbsp;The CSV Storage Engine"><code class="literal">CSV</code></a> tables.
            </p><p style="color:blue;">check table适用于innodb、myisam、archive和csv表。</p><p>
                Before running <a class="link" href="sql-syntax.html#check-table" title="13.7.2.2&nbsp;CHECK TABLE Syntax"><code class="literal">CHECK TABLE</code></a> on
                <code class="literal">InnoDB</code> tables, see
                <a class="xref" href="sql-syntax.html#check-table-innodb" title="CHECK TABLE Usage Notes for InnoDB Tables">CHECK TABLE Usage Notes for InnoDB Tables</a>.
            </p><p style="color:blue;">在对innodb表运行check table之前，请参阅innodb表的check table usage notes。</p><p>
                <a class="link" href="sql-syntax.html#check-table" title="13.7.2.2&nbsp;CHECK TABLE Syntax"><code class="literal">CHECK TABLE</code></a> is supported for
                partitioned tables, and you can use <code class="literal">ALTER TABLE ...
                CHECK PARTITION</code> to check one or more partitions; for
                more information, see <a class="xref" href="sql-syntax.html#alter-table" title="13.1.8&nbsp;ALTER TABLE Syntax">Section&nbsp;13.1.8, “ALTER TABLE Syntax”</a>, and
                <a class="xref" href="partitioning.html#partitioning-maintenance" title="22.3.4&nbsp;Maintenance of Partitions">Section&nbsp;22.3.4, “Maintenance of Partitions”</a>.
            </p><p style="color:blue;">分区表支持检查表，您可以使用alter table…检查分区以检查一个或多个分区；有关更多信息，请参阅第131.8节、“ALTER表语法”和第22.3.4节“分区维护”。</p><p>
                <a class="link" href="sql-syntax.html#check-table" title="13.7.2.2&nbsp;CHECK TABLE Syntax"><code class="literal">CHECK TABLE</code></a> ignores virtual
                generated columns that are not indexed.
            </p><p style="color:blue;">检查表忽略未编制索引的虚拟生成列。</p>
                <div class="itemizedlist">
                    <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><a class="xref" href="sql-syntax.html#check-table-output" title="CHECK TABLE Output">CHECK TABLE Output</a></p><p style="color:blue;">检查表输出</p></li><li class="listitem"><p><a class="xref" href="sql-syntax.html#check-table-version-compatibility" title="Checking Version Compatibility">Checking Version Compatibility</a></p><p style="color:blue;">正在检查版本兼容性</p></li><li class="listitem"><p><a class="xref" href="sql-syntax.html#check-table-data-consistency" title="Checking Data Consistency">Checking Data Consistency</a></p><p style="color:blue;">检查数据一致性</p></li><li class="listitem"><p><a class="xref" href="sql-syntax.html#check-table-innodb" title="CHECK TABLE Usage Notes for InnoDB Tables">CHECK TABLE Usage Notes for InnoDB Tables</a></p><p style="color:blue;">innodb表的检查表使用说明</p></li><li class="listitem"><p><a class="xref" href="sql-syntax.html#check-table-myisam" title="CHECK TABLE Usage Notes for MyISAM Tables">CHECK TABLE Usage Notes for MyISAM Tables</a></p><p style="color:blue;">myisam表的检查表使用说明</p></li></ul>
                </div>

                <div class="simplesect">

                    <div class="titlepage">
                        <div>

                            <div class="simple">
                                <h5 class="title"><a name="check-table-output"></a>CHECK TABLE Output</h5>

                            </div>

                        </div>

                    </div>
                    <p>
                        <a class="link" href="sql-syntax.html#check-table" title="13.7.2.2&nbsp;CHECK TABLE Syntax"><code class="literal">CHECK TABLE</code></a> returns a result
                        set with the columns shown in the following table.
                    </p><p style="color:blue;">check table返回一个结果集，其列如下表所示。</p>
                    <div class="informaltable">
                        <table summary="Columns of the CHECK TABLE result set."><colgroup><col width="15%"><col width="60%"></colgroup><thead><tr>
                            <th scope="col">Column</th>
                            <th scope="col">Value</th>
                        </tr></thead><tbody><tr>
                            <td scope="row"><code class="literal">Table</code></td>
                            <td>The table name</td>
                        </tr><tr>
                            <td scope="row"><code class="literal">Op</code></td>
                            <td>Always <code class="literal">check</code></td>
                        </tr><tr>
                            <td scope="row"><code class="literal">Msg_type</code></td>
                            <td><code class="literal">status</code>, <code class="literal">error</code>,
                                <code class="literal">info</code>, <code class="literal">note</code>, or
                                <code class="literal">warning</code></td>
                        </tr><tr>
                            <td scope="row"><code class="literal">Msg_text</code></td>
                            <td>An informational message</td>
                        </tr></tbody></table>
                    </div>
                    <p>
                        The statement might produce many rows of information for each
                        checked table. The last row has a <code class="literal">Msg_type</code>
                        value of <code class="literal">status</code> and the
                        <code class="literal">Msg_text</code> normally should be
                        <code class="literal">OK</code>. For a <code class="literal">MyISAM</code> table,
                        if you don't get <code class="literal">OK</code> or <code class="literal">Table is
                        already up to date</code>, you should normally run a repair
                        of the table. See <a class="xref" href="backup-and-recovery.html#myisam-table-maintenance" title="7.6&nbsp;MyISAM Table Maintenance and Crash Recovery">Section&nbsp;7.6, “MyISAM Table Maintenance and Crash Recovery”</a>.
                        <code class="literal">Table is already up to date</code> means that the
                        storage engine for the table indicated that there was no need
                        to check the table.
                    </p><p style="color:blue;">语句可能会为每个选中的表生成许多行信息。最后一行的msg_type值为status，msg_文本通常应为ok。对于myisam表，如果您不确定或者表已经是最新的，通常应该运行表的修复。见第7.6节，“MyISAM表维护和崩溃恢复”。表已经是最新的意味着表的存储引擎指示不需要检查表。</p>
                </div>
                <div class="simplesect">
                    <div class="titlepage">
                        <div>
                            <div class="simple">
                                <h5 class="title"><a name="check-table-version-compatibility"></a>Checking Version Compatibility</h5>

                            </div>

                        </div>

                    </div>
                    <p>
                        The <code class="literal">FOR UPGRADE</code> option checks whether the
                        named tables are compatible with the current version of MySQL.
                        With <code class="literal">FOR UPGRADE</code>, the server checks each
                        table to determine whether there have been any incompatible
                        changes in any of the table's data types or indexes since the
                        table was created. If not, the check succeeds. Otherwise, if
                        there is a possible incompatibility, the server runs a full
                        check on the table (which might take some time). If the full
                        check succeeds, the server marks the table's
                        <code class="filename">.frm</code> file with the current MySQL version
                        number. Marking the <code class="filename">.frm</code> file ensures
                        that further checks for the table with the same version of the
                        server will be fast.
                    </p><p style="color:blue;">for upgrade选项检查命名表是否与当前版本的mysql兼容。使用for upgrade，服务器检查每个表，以确定自创建表以来，该表的任何数据类型或索引中是否有任何不兼容的更改。如果没有，则检查成功。否则，如果可能存在不兼容，服务器将对表运行完全检查（这可能需要一些时间）。如果完全检查成功，服务器将表的.frm文件标记为当前MySQL版本号。标记.frm文件可以确保使用相同版本的服务器进一步检查表的速度很快。</p><p>
                    Incompatibilities might occur because the storage format for a
                    data type has changed or because its sort order has changed.
                    Our aim is to avoid these changes, but occasionally they are
                    necessary to correct problems that would be worse than an
                    incompatibility between releases.
                </p><p style="color:blue;">由于数据类型的存储格式已更改或其排序顺序已更改，可能会发生不兼容。我们的目标是避免这些更改，但有时它们是必要的，以纠正比版本之间不兼容更糟糕的问题。</p><p>
                    <code class="literal">FOR UPGRADE</code> discovers these
                    incompatibilities:
                </p><p style="color:blue;">对于升级，发现这些不兼容：</p>
                    <div class="itemizedlist">
                        <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                            The indexing order for end-space in
                            <a class="link" href="data-types.html#blob" title="11.4.3&nbsp;The BLOB and TEXT Types"><code class="literal">TEXT</code></a> columns for
                            <code class="literal">InnoDB</code> and <code class="literal">MyISAM</code>
                            tables changed between MySQL 4.1 and 5.0.
                        </p><p style="color:blue;">YNDB和MyISAM表的文本列中的结束空间索引顺序在MySQL 4.1和5之间更改。</p></li><li class="listitem"><p>
                            The storage method of the new
                            <a class="link" href="data-types.html#fixed-point-types" title="11.2.2&nbsp;Fixed-Point Types (Exact Value) - DECIMAL, NUMERIC"><code class="literal">DECIMAL</code></a> data type changed
                            between MySQL 5.0.3 and 5.0.5.
                        </p><p style="color:blue;">新decimal数据类型的存储方法在mysql 5.0.3和5.0.5之间发生了更改。</p></li><li class="listitem"><p>
                            If your table was created by a different version of the
                            MySQL server than the one you are currently running,
                            <code class="literal">FOR UPGRADE</code> indicates that the table
                            has an <code class="filename">.frm</code> file with an incompatible
                            version. In this case, the result set returned by
                            <a class="link" href="sql-syntax.html#check-table" title="13.7.2.2&nbsp;CHECK TABLE Syntax"><code class="literal">CHECK TABLE</code></a> contains a line
                            with a <code class="literal">Msg_type</code> value of
                            <code class="literal">error</code> and a <code class="literal">Msg_text</code>
                            value of <code class="literal">Table upgrade required. Please do
                            "REPAIR TABLE `<em class="replaceable"><code>tbl_name</code></em>`" to
                            fix it!</code>
                        </p><p style="color:blue;">如果您的表是由当前运行的mysql服务器的不同版本创建的，则for upgrade表示该表具有不兼容版本的.frm文件。在这种情况下，检查表返回的结果集包含一行，其中msg_type值为error，msg_text值为table upgrade required。请做“修复表”来修复它！</p></li><li class="listitem"><p>
                            Changes are sometimes made to character sets or collations
                            that require table indexes to be rebuilt. For details
                            about such changes, see
                            <a class="xref" href="installing.html#upgrading-from-previous-series" title="2.11.3&nbsp;Changes in MySQL 5.7">Section&nbsp;2.11.3, “Changes in MySQL 5.7”</a>. For
                            information about rebuilding tables, see
                            <a class="xref" href="installing.html#rebuilding-tables" title="2.11.12&nbsp;Rebuilding or Repairing Tables or Indexes">Section&nbsp;2.11.12, “Rebuilding or Repairing Tables or Indexes”</a>.
                        </p><p style="color:blue;">有时会对需要重建表索引的字符集或排序规则进行更改。有关这些更改的详细信息，请参见2.11.3节“MySQL5.7中的更改”。有关重建表的信息，请参阅2.11.12节“重建或修复表或索引”。</p></li><li class="listitem"><p>
                            The <a class="link" href="data-types.html#year" title="11.3.3&nbsp;The YEAR Type"><code class="literal">YEAR(2)</code></a> data type is
                            deprecated and support for it is removed in MySQL 5.7.5.
                            For tables containing
                            <a class="link" href="data-types.html#year" title="11.3.3&nbsp;The YEAR Type"><code class="literal">YEAR(2)</code></a> columns,
                            <a class="link" href="sql-syntax.html#check-table" title="13.7.2.2&nbsp;CHECK TABLE Syntax"><code class="literal">CHECK TABLE</code></a> recommends
                            <a class="link" href="sql-syntax.html#repair-table" title="13.7.2.5&nbsp;REPAIR TABLE Syntax"><code class="literal">REPAIR TABLE</code></a>, which
                            converts <a class="link" href="data-types.html#year" title="11.3.3&nbsp;The YEAR Type"><code class="literal">YEAR(2)</code></a> to
                            <a class="link" href="data-types.html#year" title="11.3.3&nbsp;The YEAR Type"><code class="literal">YEAR(4)</code></a>.
                        </p><p style="color:blue;">不推荐使用year（2）数据类型，在mysql 5.7.5中不再支持它。对于包含年份（2）列的表，check table建议使用repair table，它将年份（2）转换为年份（4）。</p></li><li class="listitem"><p>
                            As of MySQL 5.7.2, trigger creation time is maintained. If
                            run against a table that has triggers,
                            <a class="link" href="sql-syntax.html#check-table" title="13.7.2.2&nbsp;CHECK TABLE Syntax"><code class="literal">CHECK TABLE
                                ... FOR UPGRADE</code></a> displays this warning for each
                            trigger created before MySQL 5.7.2:
                        </p><p style="color:blue;">从mysql 5.7.2开始，触发器创建时间保持不变。如果对具有触发器的表运行，请检查表…for upgrade为mysql 5.7.2之前创建的每个触发器显示此警告：</p><pre data-lang="none" class="programlisting">Trigger <em class="replaceable"><code>db_name</code></em>.<em class="replaceable"><code>tbl_name</code></em>.<em class="replaceable"><code>trigger_name</code></em> does not have CREATED attribute.
</pre><p>
                            The warning is informational only. No change is made to
                            the trigger.
                        </p><p style="color:blue;">此警告仅供参考。触发器没有变化。</p></li><li class="listitem"><p>
                            As of MySQL 5.7.7, a table is reported as needing a
                            rebuild if it contains old temporal columns in pre-5.6.4
                            format (<a class="link" href="data-types.html#time" title="11.3.2&nbsp;The TIME Type"><code class="literal">TIME</code></a>,
                            <a class="link" href="data-types.html#datetime" title="11.3.1&nbsp;The DATE, DATETIME, and TIMESTAMP Types"><code class="literal">DATETIME</code></a>, and
                            <a class="link" href="data-types.html#datetime" title="11.3.1&nbsp;The DATE, DATETIME, and TIMESTAMP Types"><code class="literal">TIMESTAMP</code></a> columns without
                            support for fractional seconds precision) and the
                            <a class="link" href="server-administration.html#sysvar_avoid_temporal_upgrade"><code class="literal">avoid_temporal_upgrade</code></a>
                            system variable is disabled. This helps the MySQL upgrade
                            procedure detect and upgrade tables containing old
                            temporal columns. If
                            <a class="link" href="server-administration.html#sysvar_avoid_temporal_upgrade"><code class="literal">avoid_temporal_upgrade</code></a> is
                            enabled, <code class="literal">FOR UPGRADE</code> ignores the old
                            temporal columns present in the table; consequently, the
                            upgrade procedure does not upgrade them.
                        </p><p style="color:blue;">从mysql 5.7.7开始，如果表包含5.6.4之前格式的旧时态列（不支持小数秒精度的时间、日期时间和时间戳列），并且禁用“避免时态升级”系统变量，则该表将被报告为需要重建。这有助于mysql升级过程检测和升级包含旧时态列的表。如果启用了avoid_temporal_upgrade，for upgrade将忽略表中的旧时态列；因此，升级过程不会升级它们。</p><p>
                            To check for tables that contain such temporal columns and
                            need a rebuild, disable
                            <a class="link" href="server-administration.html#sysvar_avoid_temporal_upgrade"><code class="literal">avoid_temporal_upgrade</code></a>
                            before executing
                            <a class="link" href="sql-syntax.html#check-table" title="13.7.2.2&nbsp;CHECK TABLE Syntax"><code class="literal">CHECK TABLE
                                ... FOR UPGRADE</code></a>.
                        </p><p style="color:blue;">若要检查包含此类临时列且需要重新生成的表，请在执行检查表之前禁用“避免临时升级”…升级。</p></li><li class="listitem"><p>
                            Warnings are issued for tables that use nonnative
                            partitioning because nonnative partitioning is deprecated
                            in MySQL 5.7 and removed in MySQL
                            8.0. See <a class="xref" href="partitioning.html" title="Chapter&nbsp;22&nbsp;Partitioning">Chapter&nbsp;22, <i>Partitioning</i></a>.
                        </p><p style="color:blue;">对使用非本机分区的表发出警告，因为在mysql 5.7中不推荐使用非本机分区，而在mysql 8.0中删除了非本机分区。见第22章，分割。</p></li></ul>
                    </div>

                </div>
                <div class="simplesect">
                    <div class="titlepage">
                        <div>
                            <div class="simple">
                                <h5 class="title"><a name="check-table-data-consistency"></a>Checking Data Consistency</h5>

                            </div>

                        </div>

                    </div>
                    <p>
                        The following table shows the other check options that can be
                        given. These options are passed to the storage engine, which
                        may use or ignore them.
                    </p><p style="color:blue;">下表显示了可以提供的其他检查选项。这些选项将传递给存储引擎，存储引擎可能会使用或忽略它们。</p>
                    <div class="informaltable">
                        <table summary="Other CHECK TABLE options."><colgroup><col width="15%"><col width="85%"></colgroup><thead><tr>
                            <th scope="col">Type</th>
                            <th scope="col">Meaning</th>
                        </tr></thead><tbody><tr>
                            <td scope="row"><code class="literal">QUICK</code></td>
                            <td>Do not scan the rows to check for incorrect links. Applies to
                                <code class="literal">InnoDB</code> and <code class="literal">MyISAM</code>
                                tables and views.</td>
                        </tr><tr>
                            <td scope="row"><code class="literal">FAST</code></td>
                            <td>Check only tables that have not been closed properly. Ignored for
                                <code class="literal">InnoDB</code>; applies only to
                                <code class="literal">MyISAM</code> tables and views.</td>
                        </tr><tr>
                            <td scope="row"><code class="literal">CHANGED</code></td>
                            <td>Check only tables that have been changed since the last check or that
                                have not been closed properly. Ignored for
                                <code class="literal">InnoDB</code>; applies only to
                                <code class="literal">MyISAM</code> tables and views.</td>
                        </tr><tr>
                            <td scope="row"><code class="literal">MEDIUM</code></td>
                            <td>Scan rows to verify that deleted links are valid. This also calculates a
                                key checksum for the rows and verifies this with a
                                calculated checksum for the keys. Ignored for
                                <code class="literal">InnoDB</code>; applies only to
                                <code class="literal">MyISAM</code> tables and views.</td>
                        </tr><tr>
                            <td scope="row"><code class="literal">EXTENDED</code></td>
                            <td>Do a full key lookup for all keys for each row. This ensures that the
                                table is 100% consistent, but takes a long time. Ignored
                                for <code class="literal">InnoDB</code>; applies only to
                                <code class="literal">MyISAM</code> tables and views.</td>
                        </tr></tbody></table>
                    </div>
                    <p>
                        If none of the options <code class="literal">QUICK</code>,
                        <code class="literal">MEDIUM</code>, or <code class="literal">EXTENDED</code> are
                        specified, the default check type for dynamic-format
                        <code class="literal">MyISAM</code> tables is <code class="literal">MEDIUM</code>.
                        This has the same result as running <a class="link" href="programs.html#myisamchk" title="4.6.3&nbsp;myisamchk — MyISAM Table-Maintenance Utility"><span class="command"><strong>myisamchk
          --medium-check <em class="replaceable"><code>tbl_name</code></em></strong></span></a>
                        on the table. The default check type also is
                        <code class="literal">MEDIUM</code> for static-format
                        <code class="literal">MyISAM</code> tables, unless
                        <code class="literal">CHANGED</code> or <code class="literal">FAST</code> is
                        specified. In that case, the default is
                        <code class="literal">QUICK</code>. The row scan is skipped for
                        <code class="literal">CHANGED</code> and <code class="literal">FAST</code> because
                        the rows are very seldom corrupted.
                    </p><p style="color:blue;">如果未指定“快速”、“中等”或“扩展”选项，则动态格式myisam表的默认检查类型为“中等”。这与在表上运行myisamchk--medium check tbl_name的结果相同。对于静态格式myisam表，默认的检查类型也是medium，除非指定了changed或fast。在这种情况下，默认值是quick。由于行很少损坏，因此跳过行扫描以进行更改和快速扫描。</p><p>
                    You can combine check options, as in the following example
                    that does a quick check on the table to determine whether it
                    was closed properly:
                </p><p style="color:blue;">可以组合检查选项，如下例所示，该示例对表进行快速检查，以确定表是否已正确关闭：</p><pre data-lang="sql" class="programlisting">CHECK TABLE test_table FAST QUICK;
</pre>
                    <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">

                        <div class="admon-title">
                            Note
                        </div>
                        <p>
                            If <a class="link" href="sql-syntax.html#check-table" title="13.7.2.2&nbsp;CHECK TABLE Syntax"><code class="literal">CHECK TABLE</code></a> finds no
                            problems with a table that is marked as
                            <span class="quote">“<span class="quote">corrupted</span>”</span> or <span class="quote">“<span class="quote">not closed
            properly</span>”</span>, <a class="link" href="sql-syntax.html#check-table" title="13.7.2.2&nbsp;CHECK TABLE Syntax"><code class="literal">CHECK TABLE</code></a>
                            may remove the mark.
                        </p><p style="color:blue;">如果检查表发现标记为“已损坏”或“未正确关闭”的表没有问题，则检查表可以删除该标记。</p>
                    </div>
                    <p>
                        If a table is corrupted, the problem is most likely in the
                        indexes and not in the data part. All of the preceding check
                        types check the indexes thoroughly and should thus find most
                        errors.
                    </p><p style="color:blue;">如果表已损坏，则问题很可能出现在索引中，而不是数据部分。前面所有的检查类型都会彻底检查索引，因此应该会发现大多数错误。</p><p>
                    To check a table that you assume is okay, use no check options
                    or the <code class="literal">QUICK</code> option. The latter should be
                    used when you are in a hurry and can take the very small risk
                    that <code class="literal">QUICK</code> does not find an error in the
                    data file. (In most cases, under normal usage, MySQL should
                    find any error in the data file. If this happens, the table is
                    marked as <span class="quote">“<span class="quote">corrupted</span>”</span> and cannot be used until it
                    is repaired.)
                </p><p style="color:blue;">若要检查您认为正常的表，请使用“无检查”选项或“快速”选项。后者应该在您匆忙时使用，并且可以承担很小的风险，即quick不会在数据文件中发现错误。（在大多数情况下，在正常使用情况下，mysql应该在数据文件中找到任何错误。如果发生这种情况，则表被标记为“已损坏”，在修复之前不能使用。）</p><p>
                    <code class="literal">FAST</code> and <code class="literal">CHANGED</code> are
                    mostly intended to be used from a script (for example, to be
                    executed from <span class="command"><strong>cron</strong></span>) to check tables
                    periodically. In most cases, <code class="literal">FAST</code> is to be
                    preferred over <code class="literal">CHANGED</code>. (The only case when
                    it is not preferred is when you suspect that you have found a
                    bug in the <code class="literal">MyISAM</code> code.)
                </p><p style="color:blue;">fast和changed主要用于从脚本（例如，从cron执行）定期检查表。在大多数情况下，快速是首选，而不是改变。（唯一不首选的情况是怀疑在myisam代码中发现了错误。）</p><p>
                    <code class="literal">EXTENDED</code> is to be used only after you have
                    run a normal check but still get errors from a table when
                    MySQL tries to update a row or find a row by key. This is very
                    unlikely if a normal check has succeeded.
                </p><p style="color:blue;">extended只能在运行正常检查后使用，但在mysql尝试更新行或按键查找行时，仍然会从表中获取错误。如果正常检查成功，这是不太可能的。</p><p>
                    Use of <a class="link" href="sql-syntax.html#check-table" title="13.7.2.2&nbsp;CHECK TABLE Syntax"><code class="literal">CHECK
                    TABLE ... EXTENDED</code></a> might influence execution plans
                    generated by the query optimizer.
                </p><p style="color:blue;">使用检查表…扩展可能会影响查询优化器生成的执行计划。</p><p>
                    Some problems reported by <a class="link" href="sql-syntax.html#check-table" title="13.7.2.2&nbsp;CHECK TABLE Syntax"><code class="literal">CHECK
                    TABLE</code></a> cannot be corrected automatically:
                </p><p style="color:blue;">检查表报告的一些问题无法自动更正：</p>
                    <div class="itemizedlist">
                        <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                            <code class="literal">Found row where the auto_increment column has the
                                value 0</code>.
                        </p><p style="color:blue;">找到自动递增列值为0的行。</p><p>
                            This means that you have a row in the table where the
                            <code class="literal">AUTO_INCREMENT</code> index column contains
                            the value 0. (It is possible to create a row where the
                            <code class="literal">AUTO_INCREMENT</code> column is 0 by
                            explicitly setting the column to 0 with an
                            <a class="link" href="sql-syntax.html#update" title="13.2.11&nbsp;UPDATE Syntax"><code class="literal">UPDATE</code></a> statement.)
                        </p><p style="color:blue;">这意味着您在表中有一行“自动递增索引”列包含值0。（通过使用UPDATE语句显式地将列设置为0，可以创建自动递增列为0的行。）</p><p>
                            This is not an error in itself, but could cause trouble if
                            you decide to dump the table and restore it or do an
                            <a class="link" href="sql-syntax.html#alter-table" title="13.1.8&nbsp;ALTER TABLE Syntax"><code class="literal">ALTER TABLE</code></a> on the table.
                            In this case, the <code class="literal">AUTO_INCREMENT</code> column
                            changes value according to the rules of
                            <code class="literal">AUTO_INCREMENT</code> columns, which could
                            cause problems such as a duplicate-key error.
                        </p><p style="color:blue;">这本身不是错误，但如果决定转储表并还原它或对表执行alter table操作，则可能会导致问题。在这种情况下，auto_increment列根据auto_increment列的规则更改值，这可能会导致重复键错误等问题。</p><p>
                            To get rid of the warning, execute an
                            <a class="link" href="sql-syntax.html#update" title="13.2.11&nbsp;UPDATE Syntax"><code class="literal">UPDATE</code></a> statement to set the
                            column to some value other than 0.
                        </p><p style="color:blue;">若要消除警告，请执行UPDATE语句将该列设置为0以外的某个值。</p></li></ul>
                    </div>

                </div>
                <div class="simplesect">
                    <div class="titlepage">
                        <div>
                            <div class="simple">
                                <h5 class="title"><a name="check-table-innodb"></a>CHECK TABLE Usage Notes for InnoDB Tables</h5>

                            </div>

                        </div>

                    </div>
                    <p>
                        The following notes apply to
                        <a class="link" href="innodb-storage-engine.html" title="Chapter&nbsp;14&nbsp;The InnoDB Storage Engine"><code class="literal">InnoDB</code></a> tables:
                    </p><p style="color:blue;">以下注释适用于innodb表：</p>
                    <div class="itemizedlist">
                        <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                            If <a class="link" href="sql-syntax.html#check-table" title="13.7.2.2&nbsp;CHECK TABLE Syntax"><code class="literal">CHECK TABLE</code></a> encounters a
                            corrupt page, the server exits to prevent error
                            propagation (Bug #10132). If the corruption occurs in a
                            secondary index but table data is readable, running
                            <a class="link" href="sql-syntax.html#check-table" title="13.7.2.2&nbsp;CHECK TABLE Syntax"><code class="literal">CHECK TABLE</code></a> can still cause
                            a server exit.
                        </p><p style="color:blue;">如果检查表遇到一个损坏的页面，服务器退出以防止错误传播（bug 10132）。如果在二次索引中发生了损坏，但表数据是可读的，运行检查表仍然可以导致服务器退出。</p></li><li class="listitem"><p>
                            If <a class="link" href="sql-syntax.html#check-table" title="13.7.2.2&nbsp;CHECK TABLE Syntax"><code class="literal">CHECK TABLE</code></a> encounters a
                            corrupted <code class="literal">DB_TRX_ID</code> or
                            <code class="literal">DB_ROLL_PTR</code> field in a clustered index,
                            <a class="link" href="sql-syntax.html#check-table" title="13.7.2.2&nbsp;CHECK TABLE Syntax"><code class="literal">CHECK TABLE</code></a> can cause
                            <code class="literal">InnoDB</code> to access an invalid undo log
                            record, resulting in an
                            <a class="link" href="glossary.html#glos_mvcc" title="MVCC">MVCC</a>-related server exit.
                        </p><p style="color:blue;">如果检查表在聚集索引中遇到损坏的dByrxxIdID或dByLoopypTr字段，则CHECK表可以使InNODB访问无效的撤消日志记录，从而导致MVCC相关的服务器退出。</p></li><li class="listitem"><p>
                            If <a class="link" href="sql-syntax.html#check-table" title="13.7.2.2&nbsp;CHECK TABLE Syntax"><code class="literal">CHECK TABLE</code></a> encounters
                            errors in <code class="literal">InnoDB</code> tables or indexes, it
                            reports an error, and usually marks the index and
                            sometimes marks the table as corrupted, preventing further
                            use of the index or table. Such errors include an
                            incorrect number of entries in a secondary index or
                            incorrect links.
                        </p><p style="color:blue;">如果check table在innodb tables或indexes中遇到错误，它会报告一个错误，并且通常会标记索引，有时会将表标记为已损坏，从而阻止进一步使用索引或表。这些错误包括二级索引中的条目数不正确或链接不正确。</p></li><li class="listitem"><p>
                            If <a class="link" href="sql-syntax.html#check-table" title="13.7.2.2&nbsp;CHECK TABLE Syntax"><code class="literal">CHECK TABLE</code></a> finds an
                            incorrect number of entries in a secondary index, it
                            reports an error but does not cause a server exit or
                            prevent access to the file.
                        </p><p style="color:blue;">如果检查表在辅助索引中查找不正确的条目数，则会报告错误，但不会导致服务器退出或阻止对文件的访问。</p></li><li class="listitem"><p>
                            <a class="link" href="sql-syntax.html#check-table" title="13.7.2.2&nbsp;CHECK TABLE Syntax"><code class="literal">CHECK TABLE</code></a> surveys the
                            index page structure, then surveys each key entry. It does
                            not validate the key pointer to a clustered record or
                            follow the path for <a class="link" href="data-types.html#blob" title="11.4.3&nbsp;The BLOB and TEXT Types"><code class="literal">BLOB</code></a>
                            pointers.
                        </p><p style="color:blue;">检查表调查索引页结构，然后调查每个关键条目。它不会验证指向群集记录的键指针，也不会遵循blob指针的路径。</p></li><li class="listitem"><p>
                            When an <code class="literal">InnoDB</code> table is stored in its
                            own
                            <a class="link" href="glossary.html#glos_ibd_file" title=".ibd file"><code class="filename">.ibd</code>
                                file</a>, the first 3
                            <a class="link" href="glossary.html#glos_page" title="page">pages</a> of the
                            <code class="literal">.ibd</code> file contain header information
                            rather than table or index data. The
                            <a class="link" href="sql-syntax.html#check-table" title="13.7.2.2&nbsp;CHECK TABLE Syntax"><code class="literal">CHECK TABLE</code></a> statement does
                            not detect inconsistencies that affect only the header
                            data. To verify the entire contents of an
                            <code class="literal">InnoDB</code> <code class="literal">.ibd</code> file,
                            use the <a class="link" href="programs.html#innochecksum" title="4.6.1&nbsp;innochecksum — Offline InnoDB File Checksum Utility"><span class="command"><strong>innochecksum</strong></span></a> command.
                        </p><p style="color:blue;">当innodb表存储在自己的.ibd文件中时，.ibd文件的前3页包含头信息，而不是表或索引数据。check table语句不检测只影响头数据的不一致。要验证innodb.ibd文件的全部内容，请使用innochecksum命令。</p></li><li class="listitem"><p>
                            When running <a class="link" href="sql-syntax.html#check-table" title="13.7.2.2&nbsp;CHECK TABLE Syntax"><code class="literal">CHECK TABLE</code></a> on
                            large <code class="literal">InnoDB</code> tables, other threads may
                            be blocked during <a class="link" href="sql-syntax.html#check-table" title="13.7.2.2&nbsp;CHECK TABLE Syntax"><code class="literal">CHECK
                            TABLE</code></a> execution. To avoid timeouts, the
                            semaphore wait threshold (600 seconds) is extended by 2
                            hours (7200 seconds) for <a class="link" href="sql-syntax.html#check-table" title="13.7.2.2&nbsp;CHECK TABLE Syntax"><code class="literal">CHECK
                            TABLE</code></a> operations. If <code class="literal">InnoDB</code>
                            detects semaphore waits of 240 seconds or more, it starts
                            printing <code class="literal">InnoDB</code> monitor output to the
                            error log. If a lock request extends beyond the semaphore
                            wait threshold, <code class="literal">InnoDB</code> aborts the
                            process. To avoid the possibility of a semaphore wait
                            timeout entirely, run
                            <a class="link" href="sql-syntax.html#check-table" title="13.7.2.2&nbsp;CHECK TABLE Syntax"><code class="literal">CHECK TABLE
                                QUICK</code></a> instead of <a class="link" href="sql-syntax.html#check-table" title="13.7.2.2&nbsp;CHECK TABLE Syntax"><code class="literal">CHECK
                            TABLE</code></a>.
                        </p><p style="color:blue;">在大型innodb表上运行check table时，在check table执行期间可能会阻塞其他线程。为了避免超时，检查表操作的信号量等待阈值（600秒）延长了2小时（7200秒）。如果innodb检测到信号量等待240秒或更长时间，它将开始将innodb监视器输出打印到错误日志。如果锁请求超出信号量等待阈值，innodb将中止该进程。要完全避免信号量等待超时的可能性，请运行check table quick而不是check table。</p></li><li class="listitem"><p>
                            <a class="link" href="sql-syntax.html#check-table" title="13.7.2.2&nbsp;CHECK TABLE Syntax"><code class="literal">CHECK TABLE</code></a> functionality
                            for <code class="literal">InnoDB</code> <code class="literal">SPATIAL</code>
                            indexes includes an R-tree validity check and a check to
                            ensure that the R-tree row count matches the clustered
                            index.
                        </p><p style="color:blue;">innodb空间索引的检查表功能包括r树有效性检查和确保r树行数与聚集索引匹配的检查。</p></li><li class="listitem"><p>
                            <a class="link" href="sql-syntax.html#check-table" title="13.7.2.2&nbsp;CHECK TABLE Syntax"><code class="literal">CHECK TABLE</code></a> supports
                            secondary indexes on virtual generated columns, which are
                            supported by <code class="literal">InnoDB</code>.
                        </p><p style="color:blue;">check table支持虚拟生成列的二级索引，innodb支持二级索引。</p></li></ul>
                    </div>

                </div>
                <div class="simplesect">
                    <div class="titlepage">
                        <div>
                            <div class="simple">
                                <h5 class="title"><a name="check-table-myisam"></a>CHECK TABLE Usage Notes for MyISAM Tables</h5>

                            </div>

                        </div>

                    </div>
                    <p>
                        The following notes apply to
                        <a class="link" href="storage-engines.html#myisam-storage-engine" title="15.2&nbsp;The MyISAM Storage Engine"><code class="literal">MyISAM</code></a> tables:
                    </p><p style="color:blue;">以下注释适用于myisam表：</p>
                    <div class="itemizedlist">
                        <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                            <a class="link" href="sql-syntax.html#check-table" title="13.7.2.2&nbsp;CHECK TABLE Syntax"><code class="literal">CHECK TABLE</code></a> updates key
                            statistics for <code class="literal">MyISAM</code> tables.
                        </p><p style="color:blue;">检查表更新myisam表的关键统计信息。</p></li><li class="listitem"><p>
                            If <a class="link" href="sql-syntax.html#check-table" title="13.7.2.2&nbsp;CHECK TABLE Syntax"><code class="literal">CHECK TABLE</code></a> output does
                            not return <code class="literal">OK</code> or <code class="literal">Table is
                            already up to date</code>, you should normally run a
                            repair of the table. See
                            <a class="xref" href="backup-and-recovery.html#myisam-table-maintenance" title="7.6&nbsp;MyISAM Table Maintenance and Crash Recovery">Section&nbsp;7.6, “MyISAM Table Maintenance and Crash Recovery”</a>.
                        </p><p style="color:blue;">如果check table输出不返回ok或者table已经是最新的，则通常应该运行对该表的修复。见第7.6节，“MyISAM表维护和崩溃恢复”。</p></li><li class="listitem"><p>
                            If none of the <a class="link" href="sql-syntax.html#check-table" title="13.7.2.2&nbsp;CHECK TABLE Syntax"><code class="literal">CHECK TABLE</code></a>
                            options <code class="literal">QUICK</code>,
                            <code class="literal">MEDIUM</code>, or <code class="literal">EXTENDED</code>
                            are specified, the default check type for dynamic-format
                            <code class="literal">MyISAM</code> tables is
                            <code class="literal">MEDIUM</code>. This has the same result as
                            running <a class="link" href="programs.html#myisamchk" title="4.6.3&nbsp;myisamchk — MyISAM Table-Maintenance Utility"><span class="command"><strong>myisamchk --medium-check
              <em class="replaceable"><code>tbl_name</code></em></strong></span></a> on the
                            table. The default check type also is
                            <code class="literal">MEDIUM</code> for static-format
                            <code class="literal">MyISAM</code> tables, unless
                            <code class="literal">CHANGED</code> or <code class="literal">FAST</code> is
                            specified. In that case, the default is
                            <code class="literal">QUICK</code>. The row scan is skipped for
                            <code class="literal">CHANGED</code> and <code class="literal">FAST</code>
                            because the rows are very seldom corrupted.
                        </p><p style="color:blue;">如果未指定“快速”、“中等”或“扩展”检查表选项，则动态格式myisam表的默认检查类型为“中等”。这与在表上运行myisamchk--medium check tbl_name的结果相同。对于静态格式myisam表，默认的检查类型也是medium，除非指定了changed或fast。在这种情况下，默认值是quick。由于行很少损坏，因此跳过行扫描以进行更改和快速扫描。</p></li></ul>
                    </div>

                </div>

            </div>
            <div class="section">
                <div class="titlepage">
                    <div>
                        <div>
                            <h4 class="title"><a name="checksum-table"></a>13.7.2.3&nbsp;CHECKSUM TABLE Syntax</h4>

                        </div>

                    </div>

                </div>
                <a class="indexterm" name="idm140286828622352"></a><pre data-lang="sql" class="programlisting">CHECKSUM TABLE <em class="replaceable"><code>tbl_name</code></em> [, <em class="replaceable"><code>tbl_name</code></em>] ... [QUICK | EXTENDED]
</pre><p>
                <a class="link" href="sql-syntax.html#checksum-table" title="13.7.2.3&nbsp;CHECKSUM TABLE Syntax"><code class="literal">CHECKSUM TABLE</code></a> reports a
                <a class="link" href="glossary.html#glos_checksum" title="checksum">checksum</a> for the contents
                of a table. You can use this statement to verify that the
                contents are the same before and after a backup, rollback, or
                other operation that is intended to put the data back to a known
                state.
            </p><p style="color:blue;">校验和表报告表内容的校验和。您可以使用此语句验证备份、回滚或其他旨在将数据恢复到已知状态的操作前后的内容是否相同。</p><p>
                This statement requires the
                <a class="link" href="security.html#priv_select"><code class="literal">SELECT</code></a> privilege for the table.
            </p><p style="color:blue;">此语句需要表的select特权。</p><p>
                This statement is not supported for views. If you run
                <a class="link" href="sql-syntax.html#checksum-table" title="13.7.2.3&nbsp;CHECKSUM TABLE Syntax"><code class="literal">CHECKSUM TABLE</code></a> against a view,
                the <code class="literal">Checksum</code> value is always
                <code class="literal">NULL</code>, and a warning is returned.
            </p><p style="color:blue;">视图不支持此语句。如果对视图运行校验和表，则校验和值始终为空，并返回警告。</p><p>
                For a nonexistent table, <a class="link" href="sql-syntax.html#checksum-table" title="13.7.2.3&nbsp;CHECKSUM TABLE Syntax"><code class="literal">CHECKSUM
                TABLE</code></a> returns <code class="literal">NULL</code> and generates a
                warning.
            </p><p style="color:blue;">对于不存在的表，校验和表返回NULL并生成警告。</p><p>
                During the checksum operation, the table is locked with a read
                lock for <code class="literal">InnoDB</code> and
                <code class="literal">MyISAM</code>.
            </p><p style="color:blue;">在校验和操作期间，表被innodb和myisam的读锁锁定。</p>
                <div class="simplesect">

                    <div class="titlepage">
                        <div>

                            <div class="simple">
                                <h5 class="title"><a name="checksum-table-performance-considerations"></a>Performance Considerations</h5>
                            </div>
                        </div>
                    </div>
                    <p>
                        By default, the entire table is read row by row and the
                        checksum is calculated. For large tables, this could take a
                        long time, thus you would only perform this operation
                        occasionally. This row-by-row calculation is what you get with
                        the <code class="literal">EXTENDED</code> clause, with
                        <code class="literal">InnoDB</code> and all other storage engines other
                        than <code class="literal">MyISAM</code>, and with
                        <code class="literal">MyISAM</code> tables not created with the
                        <code class="literal">CHECKSUM=1</code> clause.
                    </p><p style="color:blue;">默认情况下，整张表逐行读取，并计算校验和。对于大型表，这可能需要很长时间，因此您只能偶尔执行此操作。这种逐行计算是使用扩展子句、innodb和除myisam以外的所有其他存储引擎以及未使用checksum=1子句创建的myisam表得到的结果。</p><p>
                    For <code class="literal">MyISAM</code> tables created with the
                    <code class="literal">CHECKSUM=1</code> clause,
                    <a class="link" href="sql-syntax.html#checksum-table" title="13.7.2.3&nbsp;CHECKSUM TABLE Syntax"><code class="literal">CHECKSUM TABLE</code></a> or
                    <a class="link" href="sql-syntax.html#checksum-table" title="13.7.2.3&nbsp;CHECKSUM TABLE Syntax"><code class="literal">CHECKSUM TABLE
                        ... QUICK</code></a> returns the <span class="quote">“<span class="quote">live</span>”</span> table
                    checksum that can be returned very fast. If the table does not
                    meet all these conditions, the <code class="literal">QUICK</code> method
                    returns <code class="literal">NULL</code>. The <code class="literal">QUICK</code>
                    method is not supported with <code class="literal">InnoDB</code> tables.
                    See <a class="xref" href="sql-syntax.html#create-table" title="13.1.18&nbsp;CREATE TABLE Syntax">Section&nbsp;13.1.18, “CREATE TABLE Syntax”</a> for the syntax of the
                    <code class="literal">CHECKSUM</code> clause.
                </p><p style="color:blue;">对于使用checksum=1子句、checksum表或checksum表创建的myisam表…quick返回可以很快返回的“live”表校验和。如果表不满足所有这些条件，quick方法将返回null。innodb表不支持quick方法。有关校验和子句的语法，请参见第13.1.18节“创建表语法”。</p><p>
                    The checksum value depends on the table row format. If the row
                    format changes, the checksum also changes. For example, the
                    storage format for temporal types such as
                    <a class="link" href="data-types.html#time" title="11.3.2&nbsp;The TIME Type"><code class="literal">TIME</code></a>,
                    <a class="link" href="data-types.html#datetime" title="11.3.1&nbsp;The DATE, DATETIME, and TIMESTAMP Types"><code class="literal">DATETIME</code></a>, and
                    <a class="link" href="data-types.html#datetime" title="11.3.1&nbsp;The DATE, DATETIME, and TIMESTAMP Types"><code class="literal">TIMESTAMP</code></a> changed in MySQL 5.6
                    prior to MySQL 5.6.5, so if a 5.5 table is upgraded to MySQL
                    5.6, the checksum value may change.
                </p><p style="color:blue;">校验和值取决于表行格式。如果行格式更改，校验和也将更改。例如，在mysql 5.6.5之前的mysql 5.6中，时间、日期时间和时间戳等时态类型的存储格式已更改，因此，如果将5.5表升级到mysql 5.6，则校验和值可能会更改。</p>
                    <div class="important" style="margin-left: 0.5in; margin-right: 0.5in;">

                        <div class="admon-title">
                            Important
                        </div>
                        <p>
                            If the checksums for two tables are different, then it is
                            almost certain that the tables are different in some way.
                            However, because the hashing function used by
                            <a class="link" href="sql-syntax.html#checksum-table" title="13.7.2.3&nbsp;CHECKSUM TABLE Syntax"><code class="literal">CHECKSUM TABLE</code></a> is not
                            guaranteed to be collision-free, there is a slight chance
                            that two tables which are not identical can produce the same
                            checksum.
                        </p><p style="color:blue;">如果两个表的校验和不同，那么几乎可以肯定这些表在某些方面是不同的。但是，由于校验和表使用的哈希函数不能保证是无冲突的，所以两个不相同的表产生相同校验和的可能性很小。</p>
                    </div>

                </div>

            </div>
            <div class="section">
                <div class="titlepage">
                    <div>
                        <div>
                            <h4 class="title"><a name="optimize-table"></a>13.7.2.4&nbsp;OPTIMIZE TABLE Syntax</h4>

                        </div>

                    </div>

                </div>
                <a class="indexterm" name="idm140286828581280"></a><a class="indexterm" name="idm140286828580192"></a><a class="indexterm" name="idm140286828578704"></a><pre data-lang="sql" class="programlisting">OPTIMIZE [NO_WRITE_TO_BINLOG | LOCAL]
    TABLE <em class="replaceable"><code>tbl_name</code></em> [, <em class="replaceable"><code>tbl_name</code></em>] ...
</pre><p>
                <a class="link" href="sql-syntax.html#optimize-table" title="13.7.2.4&nbsp;OPTIMIZE TABLE Syntax"><code class="literal">OPTIMIZE TABLE</code></a> reorganizes the
                physical storage of table data and associated index data, to
                reduce storage space and improve I/O efficiency when accessing
                the table. The exact changes made to each table depend on the
                <a class="link" href="glossary.html#glos_storage_engine" title="storage engine">storage engine</a> used
                by that table.
            </p><p style="color:blue;">优化表重新组织表数据和相关索引数据的物理存储，以减少访问表时的存储空间并提高I/O效率。对每个表所做的确切更改取决于该表使用的存储引擎。</p><p>
                Use <a class="link" href="sql-syntax.html#optimize-table" title="13.7.2.4&nbsp;OPTIMIZE TABLE Syntax"><code class="literal">OPTIMIZE TABLE</code></a> in these
                cases, depending on the type of table:
            </p><p style="color:blue;">在这些情况下，根据表的类型使用优化表：</p>
                <div class="itemizedlist">
                    <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                        After doing substantial insert, update, or delete operations
                        on an <code class="literal">InnoDB</code> table that has its own
                        <a class="link" href="glossary.html#glos_ibd_file" title=".ibd file">.ibd file</a> because it
                        was created with the
                        <a class="link" href="innodb-storage-engine.html#sysvar_innodb_file_per_table"><code class="literal">innodb_file_per_table</code></a>
                        option enabled. The table and indexes are reorganized, and
                        disk space can be reclaimed for use by the operating system.
                    </p><p style="color:blue;">在对具有自己的.ibd文件的innodb表执行大量插入、更新或删除操作之后，因为它是在启用innodb_file_per_table选项的情况下创建的。重新组织表和索引，可以回收磁盘空间供操作系统使用。</p></li><li class="listitem"><p>
                        After doing substantial insert, update, or delete operations
                        on columns that are part of a <code class="literal">FULLTEXT</code>
                        index in an <code class="literal">InnoDB</code> table. Set the
                        configuration option
                        <a class="link" href="innodb-storage-engine.html#sysvar_innodb_optimize_fulltext_only"><code class="literal">innodb_optimize_fulltext_only=1</code></a>
                        first. To keep the index maintenance period to a reasonable
                        time, set the
                        <a class="link" href="innodb-storage-engine.html#sysvar_innodb_ft_num_word_optimize"><code class="literal">innodb_ft_num_word_optimize</code></a>
                        option to specify how many words to update in the search
                        index, and run a sequence of <code class="literal">OPTIMIZE
                        TABLE</code> statements until the search index is fully
                        updated.
                    </p><p style="color:blue;">在对innodb表中全文索引的一部分列执行大量插入、更新或删除操作之后。首先设置配置选项innodb_optimize_fulltext_only=1。要将索引维护周期保持在一个合理的时间内，请设置innodb_ft_num_word_optimize选项以指定要在搜索索引中更新多少个单词，并运行一系列优化表语句，直到搜索索引完全更新。</p></li><li class="listitem"><p>
                        After deleting a large part of a <code class="literal">MyISAM</code>
                        or <code class="literal">ARCHIVE</code> table, or making many changes
                        to a <code class="literal">MyISAM</code> or <code class="literal">ARCHIVE
                    </code>table with variable-length rows (tables that have
                        <a class="link" href="data-types.html#char" title="11.4.1&nbsp;The CHAR and VARCHAR Types"><code class="literal">VARCHAR</code></a>,
                        <a class="link" href="data-types.html#binary-varbinary" title="11.4.2&nbsp;The BINARY and VARBINARY Types"><code class="literal">VARBINARY</code></a>,
                        <a class="link" href="data-types.html#blob" title="11.4.3&nbsp;The BLOB and TEXT Types"><code class="literal">BLOB</code></a>, or
                        <a class="link" href="data-types.html#blob" title="11.4.3&nbsp;The BLOB and TEXT Types"><code class="literal">TEXT</code></a> columns). Deleted rows
                        are maintained in a linked list and subsequent
                        <a class="link" href="sql-syntax.html#insert" title="13.2.5&nbsp;INSERT Syntax"><code class="literal">INSERT</code></a> operations reuse old
                        row positions. You can use <a class="link" href="sql-syntax.html#optimize-table" title="13.7.2.4&nbsp;OPTIMIZE TABLE Syntax"><code class="literal">OPTIMIZE
                        TABLE</code></a> to reclaim the unused space and to
                        defragment the data file. After extensive changes to a
                        table, this statement may also improve performance of
                        statements that use the table, sometimes significantly.
                    </p><p style="color:blue;">删除myisam或archive表的很大一部分，或对myisam或archive表进行许多具有可变长度行（具有varchar、varbinary、blob或text列的表）的更改之后。已删除的行保留在链接列表中，后续插入操作将重用旧的行位置。可以使用优化表回收未使用的空间并对数据文件进行碎片整理。在对表进行了大量更改之后，此语句还可以提高使用该表的语句的性能，有时会显著提高。</p></li></ul>
                </div>
                <p>
                    This statement requires <a class="link" href="security.html#priv_select"><code class="literal">SELECT</code></a>
                    and <a class="link" href="security.html#priv_insert"><code class="literal">INSERT</code></a> privileges for the
                    table.
                </p><p style="color:blue;">此语句要求表具有选择和插入权限。</p><p>
                <a class="link" href="sql-syntax.html#optimize-table" title="13.7.2.4&nbsp;OPTIMIZE TABLE Syntax"><code class="literal">OPTIMIZE TABLE</code></a> works for
                <a class="link" href="innodb-storage-engine.html" title="Chapter&nbsp;14&nbsp;The InnoDB Storage Engine"><code class="literal">InnoDB</code></a>,
                <a class="link" href="storage-engines.html#myisam-storage-engine" title="15.2&nbsp;The MyISAM Storage Engine"><code class="literal">MyISAM</code></a>, and
                <a class="link" href="storage-engines.html#archive-storage-engine" title="15.5&nbsp;The ARCHIVE Storage Engine"><code class="literal">ARCHIVE</code></a> tables.
                <a class="link" href="sql-syntax.html#optimize-table" title="13.7.2.4&nbsp;OPTIMIZE TABLE Syntax"><code class="literal">OPTIMIZE TABLE</code></a> is also supported
                for dynamic columns of in-memory
                <a class="link" href="mysql-cluster.html" title="Chapter&nbsp;21&nbsp;MySQL NDB Cluster 7.5 and NDB Cluster 7.6"><code class="literal">NDB</code></a> tables. It does not work for
                fixed-width columns of in-memory tables, nor does it work for
                Disk Data tables. The performance of <code class="literal">OPTIMIZE</code>
                on NDB Cluster tables can be tuned using
                <a class="link" href="mysql-cluster.html#option_mysqld_ndb-optimization-delay"><code class="option">--ndb-optimization-delay</code></a>, which
                controls the length of time to wait between processing batches
                of rows by <a class="link" href="sql-syntax.html#optimize-table" title="13.7.2.4&nbsp;OPTIMIZE TABLE Syntax"><code class="literal">OPTIMIZE TABLE</code></a>. For
                more information, see
                <a class="ulink" href="https://dev.mysql.com/doc/refman/5.6/en/mysql-cluster-limitations-resolved.html" target="_top">Previous NDB Cluster Issues Resolved in NDB Cluster 7.3</a>.
            </p><p style="color:blue;">optimize table适用于innodb、myisam和archive表。内存中ndb表的动态列也支持优化表。它不适用于内存表的固定宽度列，也不适用于磁盘数据表。可以使用--ndb optimization delay调整ndb集群表的优化性能，ndb optimization delay通过optimization table控制处理批处理行之间等待的时间长度。有关详细信息，请参阅以前在ndb cluster 7.3中解决的ndb集群问题。</p><p>
                For NDB Cluster tables, <a class="link" href="sql-syntax.html#optimize-table" title="13.7.2.4&nbsp;OPTIMIZE TABLE Syntax"><code class="literal">OPTIMIZE
                TABLE</code></a> can be interrupted by (for example) killing the
                SQL thread performing the <code class="literal">OPTIMIZE</code> operation.
            </p><p style="color:blue;">对于ndb集群表，可以通过（例如）终止执行优化操作的sql线程来中断优化表。</p><p>
                By default, <a class="link" href="sql-syntax.html#optimize-table" title="13.7.2.4&nbsp;OPTIMIZE TABLE Syntax"><code class="literal">OPTIMIZE TABLE</code></a> does
                <span class="emphasis"><em>not</em></span> work for tables created using any other
                storage engine and returns a result indicating this lack of
                support. You can make <a class="link" href="sql-syntax.html#optimize-table" title="13.7.2.4&nbsp;OPTIMIZE TABLE Syntax"><code class="literal">OPTIMIZE
                TABLE</code></a> work for other storage engines by starting
                <a class="link" href="programs.html#mysqld" title="4.3.1&nbsp;mysqld — The MySQL Server"><span class="command"><strong>mysqld</strong></span></a> with the <code class="option">--skip-new</code>
                option. In this case, <a class="link" href="sql-syntax.html#optimize-table" title="13.7.2.4&nbsp;OPTIMIZE TABLE Syntax"><code class="literal">OPTIMIZE
                TABLE</code></a> is just mapped to <a class="link" href="sql-syntax.html#alter-table" title="13.1.8&nbsp;ALTER TABLE Syntax"><code class="literal">ALTER
                TABLE</code></a>.
            </p><p style="color:blue;">默认情况下，optimize table不适用于使用任何其他存储引擎创建的表，并返回一个结果，指示这种支持的缺乏。通过使用--skip new选项启动mysqld，可以使optimize table适用于其他存储引擎。在本例中，optimize table只是映射到alter table。</p><p>
                This statement does not work with views.
            </p><p style="color:blue;">此语句不适用于视图。</p><p>
                <a class="link" href="sql-syntax.html#optimize-table" title="13.7.2.4&nbsp;OPTIMIZE TABLE Syntax"><code class="literal">OPTIMIZE TABLE</code></a> is supported for
                partitioned tables. For information about using this statement
                with partitioned tables and table partitions, see
                <a class="xref" href="partitioning.html#partitioning-maintenance" title="22.3.4&nbsp;Maintenance of Partitions">Section&nbsp;22.3.4, “Maintenance of Partitions”</a>.
            </p><p style="color:blue;">分区表支持优化表。有关将此语句用于分区表和表分区的信息，请参阅22.3.4节“分区的维护”。</p><p>
                By default, the server writes <a class="link" href="sql-syntax.html#optimize-table" title="13.7.2.4&nbsp;OPTIMIZE TABLE Syntax"><code class="literal">OPTIMIZE
                TABLE</code></a> statements to the binary log so that they
                replicate to replication slaves. To suppress logging, specify
                the optional <code class="literal">NO_WRITE_TO_BINLOG</code> keyword or
                its alias <code class="literal">LOCAL</code>.
            </p><p style="color:blue;">默认情况下，服务器将优化表语句写入二进制日志，以便它们复制到复制从属服务器。要禁止日志记录，请指定可选的no_write_to_binlog关键字或其别名local。</p>
                <div class="itemizedlist">
                    <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><a class="xref" href="sql-syntax.html#optimize-table-output" title="OPTIMIZE TABLE Output">OPTIMIZE TABLE Output</a></p><p style="color:blue;">优化表输出</p></li><li class="listitem"><p><a class="xref" href="sql-syntax.html#optimize-table-innodb-details" title="InnoDB Details">InnoDB Details</a></p><p style="color:blue;">InnoDB详细信息</p></li><li class="listitem"><p><a class="xref" href="sql-syntax.html#optimize-table-myisam-details" title="MyISAM Details">MyISAM Details</a></p><p style="color:blue;">Myisam详细信息</p></li><li class="listitem"><p><a class="xref" href="sql-syntax.html#optimize-table-other-considerations" title="Other Considerations">Other Considerations</a></p><p style="color:blue;">其他注意事项</p></li></ul>
                </div>

                <div class="simplesect">

                    <div class="titlepage">
                        <div>

                            <div class="simple">
                                <h5 class="title"><a name="optimize-table-output"></a>OPTIMIZE TABLE Output</h5>

                            </div>

                        </div>

                    </div>
                    <p>
                        <a class="link" href="sql-syntax.html#optimize-table" title="13.7.2.4&nbsp;OPTIMIZE TABLE Syntax"><code class="literal">OPTIMIZE TABLE</code></a> returns a result
                        set with the columns shown in the following table.
                    </p><p style="color:blue;">optimize table返回一个结果集，其列如下表所示。</p>
                    <div class="informaltable">
                        <table summary="Columns of the OPTIMIZE TABLE result set."><colgroup><col width="15%"><col width="60%"></colgroup><thead><tr>
                            <th scope="col">Column</th>
                            <th scope="col">Value</th>
                        </tr></thead><tbody><tr>
                            <td scope="row"><code class="literal">Table</code></td>
                            <td>The table name</td>
                        </tr><tr>
                            <td scope="row"><code class="literal">Op</code></td>
                            <td>Always <code class="literal">optimize</code></td>
                        </tr><tr>
                            <td scope="row"><code class="literal">Msg_type</code></td>
                            <td><code class="literal">status</code>, <code class="literal">error</code>,
                                <code class="literal">info</code>, <code class="literal">note</code>, or
                                <code class="literal">warning</code></td>
                        </tr><tr>
                            <td scope="row"><code class="literal">Msg_text</code></td>
                            <td>An informational message</td>
                        </tr></tbody></table>
                    </div>
                    <p>
                        <a class="link" href="sql-syntax.html#optimize-table" title="13.7.2.4&nbsp;OPTIMIZE TABLE Syntax"><code class="literal">OPTIMIZE TABLE</code></a> table catches
                        and throws any errors that occur while copying table
                        statistics from the old file to the newly created file. For
                        example. if the user ID of the owner of the
                        <code class="filename">.frm</code>, <code class="filename">.MYD</code>, or
                        <code class="filename">.MYI</code> file is different from the user ID
                        of the <a class="link" href="programs.html#mysqld" title="4.3.1&nbsp;mysqld — The MySQL Server"><span class="command"><strong>mysqld</strong></span></a> process,
                        <a class="link" href="sql-syntax.html#optimize-table" title="13.7.2.4&nbsp;OPTIMIZE TABLE Syntax"><code class="literal">OPTIMIZE TABLE</code></a> generates a
                        "cannot change ownership of the file" error unless
                        <a class="link" href="programs.html#mysqld" title="4.3.1&nbsp;mysqld — The MySQL Server"><span class="command"><strong>mysqld</strong></span></a> is started by the
                        <code class="literal">root</code> user.
                    </p><p style="color:blue;">优化表表捕获并引发将表统计信息从旧文件复制到新创建的文件时发生的任何错误。例如。如果.frm、.myd或.myi文件所有者的用户ID与mysqld进程的用户ID不同，则除非mysqld由根用户启动，否则optimize table将生成“无法更改文件的所有权”错误。</p>
                </div>
                <div class="simplesect">
                    <div class="titlepage">
                        <div>
                            <div class="simple">
                                <h5 class="title"><a name="optimize-table-innodb-details"></a>InnoDB Details</h5>

                            </div>

                        </div>

                    </div>
                    <p>
                        For <code class="literal">InnoDB</code> tables,
                        <a class="link" href="sql-syntax.html#optimize-table" title="13.7.2.4&nbsp;OPTIMIZE TABLE Syntax"><code class="literal">OPTIMIZE TABLE</code></a> is mapped to
                        <a class="link" href="sql-syntax.html#alter-table" title="13.1.8&nbsp;ALTER TABLE Syntax"><code class="literal">ALTER TABLE ...
                            FORCE</code></a>, which rebuilds the table to update index
                        statistics and free unused space in the clustered index. This
                        is displayed in the output of <a class="link" href="sql-syntax.html#optimize-table" title="13.7.2.4&nbsp;OPTIMIZE TABLE Syntax"><code class="literal">OPTIMIZE
                        TABLE</code></a> when you run it on an
                        <code class="literal">InnoDB</code> table, as shown here:
                    </p><p style="color:blue;">对于innodb表，optimize table被映射到alter table…force，它重建表以更新索引统计信息并释放聚集索引中未使用的空间。当您在innodb表上运行optimize表时，它会显示在输出中，如下所示：</p><pre data-lang="sql" class="programlisting">mysql&gt; OPTIMIZE TABLE foo;
+----------+----------+----------+-------------------------------------------------------------------+
| Table    | Op       | Msg_type | Msg_text                                                          |
+----------+----------+----------+-------------------------------------------------------------------+
| test.foo | optimize | note     | Table does not support optimize, doing recreate + analyze instead |
| test.foo | optimize | status   | OK                                                                |
+----------+----------+----------+-------------------------------------------------------------------+
</pre><p>
                    <a class="link" href="sql-syntax.html#optimize-table" title="13.7.2.4&nbsp;OPTIMIZE TABLE Syntax"><code class="literal">OPTIMIZE TABLE</code></a> uses
                    <a class="link" href="innodb-storage-engine.html#innodb-online-ddl" title="14.13&nbsp;InnoDB and Online DDL">online DDL</a> for
                    regular and partitioned <code class="literal">InnoDB</code> tables,
                    which reduces downtime for concurrent DML operations. The
                    table rebuild triggered by <a class="link" href="sql-syntax.html#optimize-table" title="13.7.2.4&nbsp;OPTIMIZE TABLE Syntax"><code class="literal">OPTIMIZE
                    TABLE</code></a> and performed under the cover by
                    <a class="link" href="sql-syntax.html#alter-table" title="13.1.8&nbsp;ALTER TABLE Syntax"><code class="literal">ALTER TABLE ...
                        FORCE</code></a> is completed in place. An exclusive table lock
                    is only taken briefly during the prepare phase and the commit
                    phase of the operation. During the prepare phase, metadata is
                    updated and an intermediate table is created. During the
                    commit phase, table metadata changes are committed.
                </p><p style="color:blue;">optimize table对常规和分区的innodb表使用联机ddl，这减少了并发dml操作的停机时间。优化表触发的表重建，在alter table的掩护下执行…原力已到位。排他表锁只在操作的准备阶段和提交阶段短暂执行。在准备阶段，更新元数据并创建一个中间表。在提交阶段，将提交表元数据更改。</p><p>
                    <a class="link" href="sql-syntax.html#optimize-table" title="13.7.2.4&nbsp;OPTIMIZE TABLE Syntax"><code class="literal">OPTIMIZE TABLE</code></a> rebuilds the
                    table using the table copy method under the following
                    conditions:
                </p><p style="color:blue;">optimize table在以下条件下使用table copy方法重建表：</p>
                    <div class="itemizedlist">
                        <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                            When the <a class="link" href="server-administration.html#sysvar_old_alter_table"><code class="literal">old_alter_table</code></a>
                            system variable is enabled.
                        </p><p style="color:blue;">当启用旧的_alter_table系统变量时。</p></li><li class="listitem"><p>
                            When the <a class="link" href="programs.html#mysqld" title="4.3.1&nbsp;mysqld — The MySQL Server"><span class="command"><strong>mysqld</strong></span></a>
                            <code class="literal">--skip-new</code> option is enabled.
                        </p><p style="color:blue;">当启用mysqld--skip new选项时。</p></li></ul>
                    </div>
                    <p>
                        <a class="link" href="sql-syntax.html#optimize-table" title="13.7.2.4&nbsp;OPTIMIZE TABLE Syntax"><code class="literal">OPTIMIZE TABLE</code></a> using
                        <a class="link" href="innodb-storage-engine.html#innodb-online-ddl" title="14.13&nbsp;InnoDB and Online DDL">online DDL</a> is not
                        supported for <code class="literal">InnoDB</code> tables that contain
                        <code class="literal">FULLTEXT</code> indexes. The table copy method is
                        used instead.
                    </p><p style="color:blue;">包含全文索引的innodb表不支持使用联机ddl优化表。改为使用表复制方法。</p><p>
                    <code class="literal">InnoDB</code> stores data using a page-allocation
                    method and does not suffer from fragmentation in the same way
                    that legacy storage engines (such as
                    <code class="literal">MyISAM</code>) will. When considering whether or
                    not to run optimize, consider the workload of transactions
                    that your server will process:

                </p><p style="color:blue;">innodb使用页面分配方法存储数据，并且不会像传统存储引擎（如myisam）那样受到碎片化的影响。在考虑是否运行优化时，请考虑服务器将处理的事务的工作负载：</p>
                    <div class="itemizedlist">
                        <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                            Some level of fragmentation is expected.
                            <code class="literal">InnoDB</code> only fills
                            <a class="link" href="glossary.html#glos_page" title="page">pages</a> 93% full, to
                            leave room for updates without having to split pages.
                        </p><p style="color:blue;">需要一定程度的碎片化。InnoDB只填充了93%的页面，以便在不必拆分页面的情况下为更新留出空间。</p></li><li class="listitem"><p>
                            Delete operations might leave gaps that leave pages less
                            filled than desired, which could make it worthwhile to
                            optimize the table.
                        </p><p style="color:blue;">delete操作可能会留下一些空白，使得页面的填充率低于期望值，这可能会使优化表变得有价值。</p></li><li class="listitem"><p>
                            Updates to rows usually rewrite the data within the same
                            page, depending on the data type and row format, when
                            sufficient space is available. See
                            <a class="xref" href="innodb-storage-engine.html#innodb-compression-internals" title="14.9.1.5&nbsp;How Compression Works for InnoDB Tables">Section&nbsp;14.9.1.5, “How Compression Works for InnoDB Tables”</a> and
                            <a class="xref" href="innodb-storage-engine.html#innodb-row-format" title="14.11&nbsp;InnoDB Row Formats">Section&nbsp;14.11, “InnoDB Row Formats”</a>.
                        </p><p style="color:blue;">当有足够的空间时，根据数据类型和行格式，对行的更新通常会重写同一页中的数据。参见14.9.1.5节，“InnoDB表的压缩工作原理”和14.11节，“InnoDB行格式”。</p></li><li class="listitem"><p>
                            High-concurrency workloads might leave gaps in indexes
                            over time, as <code class="literal">InnoDB</code> retains multiple
                            versions of the same data due through its
                            <a class="link" href="glossary.html#glos_mvcc" title="MVCC">MVCC</a> mechanism. See
                            <a class="xref" href="innodb-storage-engine.html#innodb-multi-versioning" title="14.3&nbsp;InnoDB Multi-Versioning">Section&nbsp;14.3, “InnoDB Multi-Versioning”</a>.
                        </p><p style="color:blue;">随着时间的推移，高并发性工作负载可能会在索引中留下空白，因为innodb通过其mvcc机制保留了同一数据的多个版本。参见第14.3节“InnoDB多版本控制”。</p></li></ul>
                    </div>
                    <p>
                    </p>
                </div>
                <div class="simplesect">
                    <div class="titlepage">
                        <div>
                            <div class="simple">
                                <h5 class="title"><a name="optimize-table-myisam-details"></a>MyISAM Details</h5>

                            </div>

                        </div>

                    </div>
                    <p>
                        For <code class="literal">MyISAM</code> tables,
                        <a class="link" href="sql-syntax.html#optimize-table" title="13.7.2.4&nbsp;OPTIMIZE TABLE Syntax"><code class="literal">OPTIMIZE TABLE</code></a> works as
                        follows:
                    </p><p style="color:blue;">对于myisam表，optimize table的工作原理如下：</p>
                    <div class="orderedlist">
                        <ol class="orderedlist" type="1"><li class="listitem"><p>
                            If the table has deleted or split rows, repair the table.
                        </p><p style="color:blue;">如果表已删除或拆分行，请修复该表。</p></li><li class="listitem"><p>
                            If the index pages are not sorted, sort them.
                        </p><p style="color:blue;">如果索引页未排序，请对其进行排序。</p></li><li class="listitem"><p>
                            If the table's statistics are not up to date (and the
                            repair could not be accomplished by sorting the index),
                            update them.
                        </p><p style="color:blue;">如果表的统计信息不是最新的（并且无法通过排序索引来完成修复），请更新它们。</p></li></ol>
                    </div>

                </div>
                <div class="simplesect">
                    <div class="titlepage">
                        <div>
                            <div class="simple">
                                <h5 class="title"><a name="optimize-table-other-considerations"></a>Other Considerations</h5>

                            </div>

                        </div>

                    </div>
                    <p>
                        <a class="link" href="sql-syntax.html#optimize-table" title="13.7.2.4&nbsp;OPTIMIZE TABLE Syntax"><code class="literal">OPTIMIZE TABLE</code></a> is performed
                        online for regular and partitioned <code class="literal">InnoDB</code>
                        tables. Otherwise, MySQL <a class="link" href="glossary.html#glos_table_lock" title="table lock">locks
                        the table</a> during the time <a class="link" href="sql-syntax.html#optimize-table" title="13.7.2.4&nbsp;OPTIMIZE TABLE Syntax"><code class="literal">OPTIMIZE
                        TABLE</code></a> is running.
                    </p><p style="color:blue;">对常规和分区的innodb表在线执行优化表。否则，mysql会在优化表运行期间锁定该表。</p><p>
                    <a class="link" href="sql-syntax.html#optimize-table" title="13.7.2.4&nbsp;OPTIMIZE TABLE Syntax"><code class="literal">OPTIMIZE TABLE</code></a> does not sort
                    R-tree indexes, such as spatial indexes on
                    <code class="literal">POINT</code> columns. (Bug #23578)
                </p><p style="color:blue;">优化表不排序r树索引，例如点列上的空间索引。（错误23578）</p>
                </div>

            </div>
            <div class="section">
                <div class="titlepage">
                    <div>
                        <div>
                            <h4 class="title"><a name="repair-table"></a>13.7.2.5&nbsp;REPAIR TABLE Syntax</h4>

                        </div>

                    </div>

                </div>
                <a class="indexterm" name="idm140286828423408"></a><pre data-lang="sql" class="programlisting">REPAIR [NO_WRITE_TO_BINLOG | LOCAL]
    TABLE <em class="replaceable"><code>tbl_name</code></em> [, <em class="replaceable"><code>tbl_name</code></em>] ...
    [QUICK] [EXTENDED] [USE_FRM]
</pre><p>
                <a class="link" href="sql-syntax.html#repair-table" title="13.7.2.5&nbsp;REPAIR TABLE Syntax"><code class="literal">REPAIR TABLE</code></a> repairs a possibly
                corrupted table, for certain storage engines only.
            </p><p style="color:blue;">修复表仅修复某些存储引擎可能损坏的表。</p><p>
                This statement requires <a class="link" href="security.html#priv_select"><code class="literal">SELECT</code></a>
                and <a class="link" href="security.html#priv_insert"><code class="literal">INSERT</code></a> privileges for the
                table.
            </p><p style="color:blue;">此语句要求表具有选择和插入权限。</p><p>
                Although normally you should never have to run
                <a class="link" href="sql-syntax.html#repair-table" title="13.7.2.5&nbsp;REPAIR TABLE Syntax"><code class="literal">REPAIR TABLE</code></a>, if disaster
                strikes, this statement is very likely to get back all your data
                from a <code class="literal">MyISAM</code> table. If your tables become
                corrupted often, try to find the reason for it, to eliminate the
                need to use <a class="link" href="sql-syntax.html#repair-table" title="13.7.2.5&nbsp;REPAIR TABLE Syntax"><code class="literal">REPAIR TABLE</code></a>. See
                <a class="xref" href="error-handling.html#crashing" title="B.4.3.3&nbsp;What to Do If MySQL Keeps Crashing">Section&nbsp;B.4.3.3, “What to Do If MySQL Keeps Crashing”</a>, and
                <a class="xref" href="storage-engines.html#myisam-table-problems" title="15.2.4&nbsp;MyISAM Table Problems">Section&nbsp;15.2.4, “MyISAM Table Problems”</a>.
            </p><p style="color:blue;">尽管通常不必运行repair table，但如果发生灾难，此语句很可能从myisam表中获取所有数据。如果您的表经常损坏，请尝试查找损坏的原因，以消除使用修复表的需要。请参阅B.4.3.3节，“如果MySQL继续崩溃该怎么办”，以及15.2.4节，“MyISAM表问题”。</p><p>
                <a class="link" href="sql-syntax.html#repair-table" title="13.7.2.5&nbsp;REPAIR TABLE Syntax"><code class="literal">REPAIR TABLE</code></a> checks the table to
                see whether an upgrade is required. If so, it performs the
                upgrade, following the same rules as
                <a class="link" href="sql-syntax.html#check-table" title="13.7.2.2&nbsp;CHECK TABLE Syntax"><code class="literal">CHECK TABLE ... FOR
                    UPGRADE</code></a>. See <a class="xref" href="sql-syntax.html#check-table" title="13.7.2.2&nbsp;CHECK TABLE Syntax">Section&nbsp;13.7.2.2, “CHECK TABLE Syntax”</a>, for more
                information.
            </p><p style="color:blue;">repair table检查表以查看是否需要升级。如果是，它将执行升级，遵循与检查表相同的规则…升级。有关详细信息，请参阅第13.7.2.2节“检查表语法”。</p>
                <div class="important" style="margin-left: 0.5in; margin-right: 0.5in;">

                    <div class="admon-title">
                        Important
                    </div>

                    <div class="itemizedlist">
                        <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                            Make a backup of a table before performing a table repair
                            operation; under some circumstances the operation might
                            cause data loss. Possible causes include but are not
                            limited to file system errors. See
                            <a class="xref" href="backup-and-recovery.html" title="Chapter&nbsp;7&nbsp;Backup and Recovery">Chapter&nbsp;7, <i>Backup and Recovery</i></a>.
                        </p><p style="color:blue;">在执行表修复操作之前备份表；在某些情况下，该操作可能会导致数据丢失。可能的原因包括但不限于文件系统错误。见第7章，备份和恢复。</p></li><li class="listitem"><p>
                            If the server crashes during a <a class="link" href="sql-syntax.html#repair-table" title="13.7.2.5&nbsp;REPAIR TABLE Syntax"><code class="literal">REPAIR
                            TABLE</code></a> operation, it is essential after
                            restarting it that you immediately execute another
                            <a class="link" href="sql-syntax.html#repair-table" title="13.7.2.5&nbsp;REPAIR TABLE Syntax"><code class="literal">REPAIR TABLE</code></a> statement for
                            the table before performing any other operations on it. In
                            the worst case, you might have a new clean index file
                            without information about the data file, and then the next
                            operation you perform could overwrite the data file. This
                            is an unlikely but possible scenario that underscores the
                            value of making a backup first.
                        </p><p style="color:blue;">如果在修复表操作期间服务器崩溃，则在重新启动服务器之后，必须在对其执行任何其他操作之前立即对该表执行另一个修复表语句。在最坏的情况下，可能会有一个新的干净索引文件，而不包含有关该数据文件的信息，然后执行的下一个操作可能会覆盖该数据文件。这是一个不太可能但可能的场景，强调了先备份的价值。</p></li><li class="listitem"><p>
                            In the event that a table on the master becomes corrupted
                            and you run <a class="link" href="sql-syntax.html#repair-table" title="13.7.2.5&nbsp;REPAIR TABLE Syntax"><code class="literal">REPAIR TABLE</code></a> on
                            it, any resulting changes to the original table are
                            <span class="emphasis"><em>not</em></span> propagated to slaves.
                        </p><p style="color:blue;">如果主表上的某个表损坏，并且在其上运行repair table，则对原始表所做的任何更改都不会传播到从表。</p></li></ul>
                    </div>

                </div>
                <a class="indexterm" name="idm140286828395456"></a><a class="indexterm" name="idm140286828393952"></a>
                <div class="itemizedlist">
                    <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><a class="xref" href="sql-syntax.html#repair-table-support" title="REPAIR TABLE Storage Engine and Partitioning Support">REPAIR TABLE Storage Engine and Partitioning Support</a></p><p style="color:blue;">修复表存储引擎和分区支持</p></li><li class="listitem"><p><a class="xref" href="sql-syntax.html#repair-table-options" title="REPAIR TABLE Options">REPAIR TABLE Options</a></p><p style="color:blue;">修复表选项</p></li><li class="listitem"><p><a class="xref" href="sql-syntax.html#repair-table-output" title="REPAIR TABLE Output">REPAIR TABLE Output</a></p><p style="color:blue;">修复表输出</p></li><li class="listitem"><p><a class="xref" href="sql-syntax.html#repair-table-table-repair-considerations" title="Table Repair Considerations">Table Repair Considerations</a></p><p style="color:blue;">表修复注意事项</p></li></ul>
                </div>

                <div class="simplesect">

                    <div class="titlepage">
                        <div>

                            <div class="simple">
                                <h5 class="title"><a name="repair-table-support"></a>REPAIR TABLE Storage Engine and Partitioning Support</h5>

                            </div>

                        </div>

                    </div>
                    <a class="indexterm" name="idm140286828386272"></a><a class="indexterm" name="idm140286828384816"></a><p>
                    <a class="link" href="sql-syntax.html#repair-table" title="13.7.2.5&nbsp;REPAIR TABLE Syntax"><code class="literal">REPAIR TABLE</code></a> works for
                    <a class="link" href="storage-engines.html#myisam-storage-engine" title="15.2&nbsp;The MyISAM Storage Engine"><code class="literal">MyISAM</code></a>,
                    <a class="link" href="storage-engines.html#archive-storage-engine" title="15.5&nbsp;The ARCHIVE Storage Engine"><code class="literal">ARCHIVE</code></a>, and
                    <a class="link" href="storage-engines.html#csv-storage-engine" title="15.4&nbsp;The CSV Storage Engine"><code class="literal">CSV</code></a> tables. For
                    <a class="link" href="storage-engines.html#myisam-storage-engine" title="15.2&nbsp;The MyISAM Storage Engine"><code class="literal">MyISAM</code></a> tables, it has the same
                    effect as <a class="link" href="programs.html#myisamchk" title="4.6.3&nbsp;myisamchk — MyISAM Table-Maintenance Utility"><span class="command"><strong>myisamchk --recover
          <em class="replaceable"><code>tbl_name</code></em></strong></span></a> by default. This
                    statement does not work with views.
                </p><p style="color:blue;">修复表适用于myisam、archive和csv表。对于myisam表，它的效果与myisamchk相同——默认情况下是recover tbl_name。此语句不适用于视图。</p><p>
                    <a class="link" href="sql-syntax.html#repair-table" title="13.7.2.5&nbsp;REPAIR TABLE Syntax"><code class="literal">REPAIR TABLE</code></a> is supported for
                    partitioned tables. However, the <code class="literal">USE_FRM</code>
                    option cannot be used with this statement on a partitioned
                    table.
                </p><p style="color:blue;">分区表支持修复表。但是，use_frm选项不能与分区表上的此语句一起使用。</p><p>
                    You can use <code class="literal">ALTER TABLE ... REPAIR
                    PARTITION</code> to repair one or more partitions; for more
                    information, see <a class="xref" href="sql-syntax.html#alter-table" title="13.1.8&nbsp;ALTER TABLE Syntax">Section&nbsp;13.1.8, “ALTER TABLE Syntax”</a>, and
                    <a class="xref" href="partitioning.html#partitioning-maintenance" title="22.3.4&nbsp;Maintenance of Partitions">Section&nbsp;22.3.4, “Maintenance of Partitions”</a>.
                </p><p style="color:blue;">您可以使用alter table…修复分区以修复一个或多个分区；有关详细信息，请参阅第131.8节、“ALTER表语法”和“第二段2.2.4节”“分区维护”。</p>
                </div>

                <div class="simplesect">

                    <div class="titlepage">
                        <div>

                            <div class="simple">
                                <h5 class="title"><a name="repair-table-options"></a>REPAIR TABLE Options</h5>

                            </div>

                        </div>

                    </div>
                    <a class="indexterm" name="idm140286828368912"></a>
                    <div class="itemizedlist">
                        <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                            <code class="literal">NO_WRITE_TO_BINLOG</code> or
                            <code class="literal">LOCAL</code>
                        </p><p style="color:blue;">没有写入日志或本地</p><p>
                            By default, the server writes <a class="link" href="sql-syntax.html#repair-table" title="13.7.2.5&nbsp;REPAIR TABLE Syntax"><code class="literal">REPAIR
                            TABLE</code></a> statements to the binary log so that they
                            replicate to replication slaves. To suppress logging,
                            specify the optional <code class="literal">NO_WRITE_TO_BINLOG</code>
                            keyword or its alias <code class="literal">LOCAL</code>.
                        </p><p style="color:blue;">默认情况下，服务器将修复表语句写入二进制日志，以便它们复制到复制从属服务器。要禁止日志记录，请指定可选的no_write_to_binlog关键字或其别名local。</p></li><li class="listitem"><p>
                            <code class="literal">QUICK</code>
                        </p><p style="color:blue;">快</p><p>
                            If you use the <code class="literal">QUICK</code> option,
                            <a class="link" href="sql-syntax.html#repair-table" title="13.7.2.5&nbsp;REPAIR TABLE Syntax"><code class="literal">REPAIR TABLE</code></a> tries to
                            repair only the index file, and not the data file. This
                            type of repair is like that done by <a class="link" href="programs.html#myisamchk" title="4.6.3&nbsp;myisamchk — MyISAM Table-Maintenance Utility"><span class="command"><strong>myisamchk
              --recover --quick</strong></span></a>.
                        </p><p style="color:blue;">如果使用quick选项，repair table将尝试只修复索引文件，而不修复数据文件。这种类型的修复就像Myisamchk做的--恢复--快。</p></li><li class="listitem"><p>
                            <code class="literal">EXTENDED</code>
                        </p><p style="color:blue;">扩展的</p><p>
                            If you use the <code class="literal">EXTENDED</code> option, MySQL
                            creates the index row by row instead of creating one index
                            at a time with sorting. This type of repair is like that
                            done by <a class="link" href="programs.html#myisamchk" title="4.6.3&nbsp;myisamchk — MyISAM Table-Maintenance Utility"><span class="command"><strong>myisamchk --safe-recover</strong></span></a>.
                        </p><p style="color:blue;">如果使用扩展选项，mysql将逐行创建索引，而不是一次创建一个排序索引。这种类型的修复和Myisamchk做的一样——安全恢复。</p></li><li class="listitem"><p>
                            <code class="literal">USE_FRM</code>
                        </p><p style="color:blue;">使用frm</p><p>
                            The <code class="literal">USE_FRM</code> option is available for use
                            if the <code class="filename">.MYI</code> index file is missing or
                            if its header is corrupted. This option tells MySQL not to
                            trust the information in the <code class="filename">.MYI</code>
                            file header and to re-create it using information from the
                            <code class="filename">.frm</code> file. This kind of repair cannot
                            be done with <a class="link" href="programs.html#myisamchk" title="4.6.3&nbsp;myisamchk — MyISAM Table-Maintenance Utility"><span class="command"><strong>myisamchk</strong></span></a>.
                        </p><p style="color:blue;">如果.myi索引文件丢失或其头已损坏，则可以使用use_frm选项。此选项告诉mysql不要信任.myi文件头中的信息，并使用.frm文件中的信息重新创建它。这种修复不能用myisamchk完成。</p>
                            <div class="caution" style="margin-left: 0.5in; margin-right: 0.5in;">

                                <div class="admon-title">
                                    Caution
                                </div>
                                <p>
                                    Use the <code class="literal">USE_FRM</code> option
                                    <span class="emphasis"><em>only</em></span> if you cannot use regular
                                    <code class="literal">REPAIR</code> modes. Telling the server to
                                    ignore the <code class="filename">.MYI</code> file makes
                                    important table metadata stored in the
                                    <code class="filename">.MYI</code> unavailable to the repair
                                    process, which can have deleterious consequences:
                                </p><p style="color:blue;">仅当您不能使用常规维修模式时，才使用“使用frm”选项。告诉服务器忽略.myi文件会使存储在.myi中的重要表元数据对修复过程不可用，这可能会产生有害后果：</p>
                                <div class="itemizedlist">
                                    <ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
                                        The current <code class="literal">AUTO_INCREMENT</code> value
                                        is lost.
                                    </p><p style="color:blue;">当前自动增量值丢失。</p></li><li class="listitem"><p>
                                        The link to deleted records in the table is lost,
                                        which means that free space for deleted records will
                                        remain unoccupied thereafter.
                                    </p><p style="color:blue;">与表中已删除记录的链接丢失，这意味着此后已删除记录的可用空间将保持未占用状态。</p></li><li class="listitem"><p>
                                        The <code class="filename">.MYI</code> header indicates
                                        whether the table is compressed. If the server
                                        ignores this information, it cannot tell that a
                                        table is compressed and repair can cause change or
                                        loss of table contents. This means that
                                        <code class="literal">USE_FRM</code> should not be used with
                                        compressed tables. That should not be necessary,
                                        anyway: Compressed tables are read only, so they
                                        should not become corrupt.
                                    </p><p style="color:blue;">.myi头指示表是否被压缩。如果服务器忽略此信息，则无法判断表已被压缩，而修复可能导致表内容的更改或丢失。这意味着use_frm不应与压缩表一起使用。无论如何，这不应该是必要的：压缩表是只读的，因此它们不应该损坏。</p></li></ul>
                                </div>
                                <p>
                                    If you use <code class="literal">USE_FRM</code> for a table that
                                    was created by a different version of the MySQL server
                                    than the one you are currently running,
                                    <a class="link" href="sql-syntax.html#repair-table" title="13.7.2.5&nbsp;REPAIR TABLE Syntax"><code class="literal">REPAIR TABLE</code></a> does not
                                    attempt to repair the table. In this case, the result
                                    set returned by <a class="link" href="sql-syntax.html#repair-table" title="13.7.2.5&nbsp;REPAIR TABLE Syntax"><code class="literal">REPAIR
                                    TABLE</code></a> contains a line with a
                                    <code class="literal">Msg_type</code> value of
                                    <code class="literal">error</code> and a
                                    <code class="literal">Msg_text</code> value of <code class="literal">Failed
                                    repairing incompatible .FRM file</code>.
                                </p><p style="color:blue;">如果对由mysql服务器的另一个版本创建的表使用_frm而不是当前运行的版本，则repair table不会尝试修复该表。在这种情况下，修复表返回的结果集包含一行，该行的msg_type值为error，msg_text值为failed repairing uncompatible.frm file。</p><p>
                                If <code class="literal">USE_FRM</code> is used,
                                <a class="link" href="sql-syntax.html#repair-table" title="13.7.2.5&nbsp;REPAIR TABLE Syntax"><code class="literal">REPAIR TABLE</code></a> does not
                                check the table to see whether an upgrade is required.
                            </p><p style="color:blue;">如果使用use_frm，则repair table不会检查该表以查看是否需要升级。</p>
                            </div>
                        </li></ul>
                    </div>

                </div>
                <div class="simplesect">
                    <div class="titlepage">
                        <div>
                            <div class="simple">
                                <h5 class="title"><a name="repair-table-output"></a>REPAIR TABLE Output</h5>

                            </div>

                        </div>

                    </div>
                    <a class="indexterm" name="idm140286828325504"></a><p>
                    <a class="link" href="sql-syntax.html#repair-table" title="13.7.2.5&nbsp;REPAIR TABLE Syntax"><code class="literal">REPAIR TABLE</code></a> returns a result
                    set with the columns shown in the following table.
                </p><p style="color:blue;">repair table返回一个结果集，其列如下表所示。</p>
                    <div class="informaltable">
                        <table summary="Columns of the REPAIR TABLE result set."><colgroup><col width="15%"><col width="60%"></colgroup><thead><tr>
                            <th scope="col">Column</th>
                            <th scope="col">Value</th>
                        </tr></thead><tbody><tr>
                            <td scope="row"><code class="literal">Table</code></td>
                            <td>The table name</td>
                        </tr><tr>
                            <td scope="row"><code class="literal">Op</code></td>
                            <td>Always <code class="literal">repair</code></td>
                        </tr><tr>
                            <td scope="row"><code class="literal">Msg_type</code></td>
                            <td><code class="literal">status</code>, <code class="literal">error</code>,
                                <code class="literal">info</code>, <code class="literal">note</code>, or
                                <code class="literal">warning</code></td>
                        </tr><tr>
                            <td scope="row"><code class="literal">Msg_text</code></td>
                            <td>An informational message</td>
                        </tr></tbody></table>
                    </div>
                    <p>
                        The <a class="link" href="sql-syntax.html#repair-table" title="13.7.2.5&nbsp;REPAIR TABLE Syntax"><code class="literal">REPAIR TABLE</code></a> statement
                        might produce many rows of information for each repaired
                        table. The last row has a <code class="literal">Msg_type</code> value of
                        <code class="literal">status</code> and <code class="literal">Msg_test</code>
                        normally should be <code class="literal">OK</code>. For a
                        <code class="literal">MyISAM</code> table, if you do not get
                        <code class="literal">OK</code>, you should try repairing it with
                        <a class="link" href="programs.html#myisamchk" title="4.6.3&nbsp;myisamchk — MyISAM Table-Maintenance Utility"><span class="command"><strong>myisamchk --safe-recover</strong></span></a>.
                        (<a class="link" href="sql-syntax.html#repair-table" title="13.7.2.5&nbsp;REPAIR TABLE Syntax"><code class="literal">REPAIR TABLE</code></a> does not
                        implement all the options of <a class="link" href="programs.html#myisamchk" title="4.6.3&nbsp;myisamchk — MyISAM Table-Maintenance Utility"><span class="command"><strong>myisamchk</strong></span></a>.
                        With <a class="link" href="programs.html#myisamchk" title="4.6.3&nbsp;myisamchk — MyISAM Table-Maintenance Utility"><span class="command"><strong>myisamchk --safe-recover</strong></span></a>, you can also
                        use options that <a class="link" href="sql-syntax.html#repair-table" title="13.7.2.5&nbsp;REPAIR TABLE Syntax"><code class="literal">REPAIR TABLE</code></a>
                        does not support, such as
                        <a class="link" href="programs.html#option_myisamchk_max-record-length"><code class="option">--max-record-length</code></a>.)
                    </p><p style="color:blue;">repair table语句可能为每个修复的表生成许多行信息。最后一行的msg_type值为status，msg_test通常应为ok。对于myisam表，如果您不满意，应该尝试使用myisamchk修复它——安全恢复。（修复表没有实现myisamchk的所有选项。使用myisamchk--safe recover，还可以使用repair table不支持的选项，例如--max record length。）</p><p>
                    <a class="link" href="sql-syntax.html#repair-table" title="13.7.2.5&nbsp;REPAIR TABLE Syntax"><code class="literal">REPAIR TABLE</code></a> table catches and
                    throws any errors that occur while copying table statistics
                    from the old corrupted file to the newly created file. For
                    example. if the user ID of the owner of the
                    <code class="filename">.frm</code>, <code class="filename">.MYD</code>, or
                    <code class="filename">.MYI</code> file is different from the user ID
                    of the <a class="link" href="programs.html#mysqld" title="4.3.1&nbsp;mysqld — The MySQL Server"><span class="command"><strong>mysqld</strong></span></a> process,
                    <a class="link" href="sql-syntax.html#repair-table" title="13.7.2.5&nbsp;REPAIR TABLE Syntax"><code class="literal">REPAIR TABLE</code></a> generates a
                    "cannot change ownership of the file" error unless
                    <a class="link" href="programs.html#mysqld" title="4.3.1&nbsp;mysqld — The MySQL Server"><span class="command"><strong>mysqld</strong></span></a> is started by the
                    <code class="literal">root</code> user.
                </p><p style="color:blue;">repair table捕获并抛出将表统计信息从旧的损坏文件复制到新创建的文件时发生的任何错误。例如。如果.frm、.myd或.myi文件所有者的用户ID与mysqld进程的用户ID不同，则修复表将生成“无法更改文件的所有权”错误，除非mysqld由根用户启动。</p>
                </div>
                <div class="simplesect">
                    <div class="titlepage">
                        <div>
                            <div class="simple">
                                <h5 class="title"><a name="repair-table-table-repair-considerations"></a>Table Repair Considerations</h5>

                            </div>

                        </div>

                    </div>
                    <p>
                        <a class="link" href="sql-syntax.html#repair-table" title="13.7.2.5&nbsp;REPAIR TABLE Syntax"><code class="literal">REPAIR TABLE</code></a> upgrades a table
                        if it contains old temporal columns in pre-5.6.4 format
                        (<a class="link" href="data-types.html#time" title="11.3.2&nbsp;The TIME Type"><code class="literal">TIME</code></a>,
                        <a class="link" href="data-types.html#datetime" title="11.3.1&nbsp;The DATE, DATETIME, and TIMESTAMP Types"><code class="literal">DATETIME</code></a>, and
                        <a class="link" href="data-types.html#datetime" title="11.3.1&nbsp;The DATE, DATETIME, and TIMESTAMP Types"><code class="literal">TIMESTAMP</code></a> columns without
                        support for fractional seconds precision) and the
                        <a class="link" href="server-administration.html#sysvar_avoid_temporal_upgrade"><code class="literal">avoid_temporal_upgrade</code></a> system
                        variable is disabled. If
                        <a class="link" href="server-administration.html#sysvar_avoid_temporal_upgrade"><code class="literal">avoid_temporal_upgrade</code></a> is
                        enabled, <a class="link" href="sql-syntax.html#repair-table" title="13.7.2.5&nbsp;REPAIR TABLE Syntax"><code class="literal">REPAIR TABLE</code></a> ignores
                        the old temporal columns present in the table and does not
                        upgrade them.
                    </p><p style="color:blue;">如果修复表包含5.6.4之前格式的旧时态列（不支持小数秒精度的时间、日期时间和时间戳列），并且禁用“避免时态升级”系统变量，则会升级该表。如果启用了avoid_temporal_upgrade，repair table将忽略表中存在的旧时态列，并且不升级它们。</p><p>
                    To upgrade tables that contain such temporal columns, disable
                    <a class="link" href="server-administration.html#sysvar_avoid_temporal_upgrade"><code class="literal">avoid_temporal_upgrade</code></a> before
                    executing <a class="link" href="sql-syntax.html#repair-table" title="13.7.2.5&nbsp;REPAIR TABLE Syntax"><code class="literal">REPAIR TABLE</code></a>.
                </p><p style="color:blue;">若要升级包含此类时态列的表，请在执行修复表之前禁用“避免时态升级”。</p><p>
                    You may be able to increase <a class="link" href="sql-syntax.html#repair-table" title="13.7.2.5&nbsp;REPAIR TABLE Syntax"><code class="literal">REPAIR
                    TABLE</code></a> performance by setting certain system
                    variables. See <a class="xref" href="optimization.html#repair-table-optimization" title="8.6.3&nbsp;Optimizing REPAIR TABLE Statements">Section&nbsp;8.6.3, “Optimizing REPAIR TABLE Statements”</a>.
                </p><p style="color:blue;">通过设置某些系统变量，可以提高修复表的性能。见第8.6.3节“优化修复表语句”。</p>
                </div>

            </div>

        </div>
        <div class="section">
            <div class="titlepage">
                <div>
                    <div>
                        <h3 class="title"><a name="component-sql"></a>13.7.3&nbsp;Plugin and User-Defined Function Statements</h3>

                    </div>

                </div>

            </div>
            <div class="toc">
                <dl class="toc"><dt><span class="section"><a href="sql-syntax.html#create-function-udf">13.7.3.1 CREATE FUNCTION Syntax for User-Defined Functions</a></span></dt><dt><span class="section"><a href="sql-syntax.html#drop-function-udf">13.7.3.2 DROP FUNCTION Syntax</a></span></dt><dt><span class="section"><a href="sql-syntax.html#install-plugin">13.7.3.3 INSTALL PLUGIN Syntax</a></span></dt><dt><span class="section"><a href="sql-syntax.html#uninstall-plugin">13.7.3.4 UNINSTALL PLUGIN Syntax</a></span></dt></dl>
            </div>
            <div class="section">
                <div class="titlepage">
                    <div>
                        <div>
                            <h4 class="title"><a name="create-function-udf"></a>13.7.3.1&nbsp;CREATE FUNCTION Syntax for User-Defined Functions</h4>

                        </div>

                    </div>

                </div>
                <a class="indexterm" name="idm140286828260352"></a><a class="indexterm" name="idm140286828259264"></a><a class="indexterm" name="idm140286828257776"></a><a class="indexterm" name="idm140286828256288"></a><a class="indexterm" name="idm140286828255216"></a><a class="indexterm" name="idm140286828254144"></a><pre data-lang="sql" class="programlisting">CREATE [AGGREGATE] FUNCTION <em class="replaceable"><code>function_name</code></em>
    RETURNS {STRING|INTEGER|REAL|DECIMAL}
    SONAME <em class="replaceable"><code>shared_library_name</code></em>
</pre><p>
                A user-defined function (UDF) is a way to extend MySQL with a
                new function that works like a native (built-in) MySQL function
                such as <a class="link" href="functions.html#function_abs"><code class="literal">ABS()</code></a> or
                <a class="link" href="functions.html#function_concat"><code class="literal">CONCAT()</code></a>.
            </p><p style="color:blue;">用户定义函数（udf）是一种使用新函数扩展mysql的方法，该函数的工作方式类似于本机（内置）mysql函数，如abs（）或concat（）。</p><p>
                <em class="replaceable"><code>function_name</code></em> is the name that should
                be used in SQL statements to invoke the function. The
                <code class="literal">RETURNS</code> clause indicates the type of the
                function's return value. <a class="link" href="data-types.html#fixed-point-types" title="11.2.2&nbsp;Fixed-Point Types (Exact Value) - DECIMAL, NUMERIC"><code class="literal">DECIMAL</code></a>
                is a legal value after <code class="literal">RETURNS</code>, but currently
                <a class="link" href="data-types.html#fixed-point-types" title="11.2.2&nbsp;Fixed-Point Types (Exact Value) - DECIMAL, NUMERIC"><code class="literal">DECIMAL</code></a> functions return string
                values and should be written like <code class="literal">STRING</code>
                functions.
            </p><p style="color:blue;">function_name是应该在sql语句中用来调用函数的名称。return s子句指示函数返回值的类型。decimal是返回后的合法值，但目前decimal函数返回字符串值，应该像字符串函数一样写入。</p><p>
                <em class="replaceable"><code>shared_library_name</code></em> is the base name
                of the shared library file that contains the code that
                implements the function. The file must be located in the plugin
                directory. This directory is given by the value of the
                <a class="link" href="server-administration.html#sysvar_plugin_dir"><code class="literal">plugin_dir</code></a> system variable. For
                more information, see <a class="xref" href="server-administration.html#udf-loading" title="5.6.1&nbsp;Installing and Uninstalling User-Defined Functions">Section&nbsp;5.6.1, “Installing and Uninstalling User-Defined Functions”</a>.
            </p><p style="color:blue;">shared_library_name是包含实现该函数的代码的共享库文件的基名称。文件必须位于插件目录中。此目录由plugin_dir系统变量的值给定。有关详细信息，请参阅第5.6.1节“安装和卸载用户定义函数”。</p><p>
                To create a function, you must have the
                <a class="link" href="security.html#priv_insert"><code class="literal">INSERT</code></a> privilege for the
                <code class="literal">mysql</code> system database. This is necessary
                because <a class="link" href="sql-syntax.html#create-function" title="13.1.13&nbsp;CREATE FUNCTION Syntax"><code class="literal">CREATE FUNCTION</code></a> adds a
                row to the <code class="literal">mysql.func</code> system table that
                records the function's name, type, and shared library name.
            </p><p style="color:blue;">要创建函数，您必须具有mysql系统数据库的insert权限。这是必需的，因为create function在mysql.func系统表中添加一行，记录函数的名称、类型和共享库名称。</p><p>
                An active function is one that has been loaded with
                <a class="link" href="sql-syntax.html#create-function" title="13.1.13&nbsp;CREATE FUNCTION Syntax"><code class="literal">CREATE FUNCTION</code></a> and not removed
                with <a class="link" href="sql-syntax.html#drop-function" title="13.1.24&nbsp;DROP FUNCTION Syntax"><code class="literal">DROP FUNCTION</code></a>. All active
                functions are reloaded each time the server starts, unless you
                start <a class="link" href="programs.html#mysqld" title="4.3.1&nbsp;mysqld — The MySQL Server"><span class="command"><strong>mysqld</strong></span></a> with the
                <a class="link" href="server-administration.html#option_mysqld_skip-grant-tables"><code class="option">--skip-grant-tables</code></a> option. In
                this case, UDF initialization is skipped and UDFs are
                unavailable.
            </p><p style="color:blue;">活动函数是已用create函数加载但未用drop函数删除的函数。每次服务器启动时都会重新加载所有活动函数，除非使用--skip grant tables选项启动mysqld。在这种情况下，将跳过自定义项初始化，并且自定义项不可用。</p><p>
                For instructions on writing user-defined functions, see
                <a class="xref" href="extending-mysql.html#adding-udf" title="28.4.2&nbsp;Adding a User-Defined Function">Section&nbsp;28.4.2, “Adding a User-Defined Function”</a>. For the UDF mechanism to work,
                functions must be written in C or C++ (or another language that
                can use C calling conventions), your operating system must
                support dynamic loading and you must have compiled
                <a class="link" href="programs.html#mysqld" title="4.3.1&nbsp;mysqld — The MySQL Server"><span class="command"><strong>mysqld</strong></span></a> dynamically (not statically).
            </p><p style="color:blue;">有关编写用户定义函数的说明，请参阅第28.4.2节“添加用户定义函数”。为了使UDF机制工作，函数必须用C或C++编写（或者可以使用C调用约定的另一种语言），您的操作系统必须支持动态加载，并且必须动态编译（不静态地）MySQL。</p><p>
                An <code class="literal">AGGREGATE</code> function works exactly like a
                native MySQL aggregate (summary) function such as
                <code class="literal">SUM</code> or
                <a class="link" href="functions.html#function_count"><code class="literal">COUNT()</code></a>.
            </p><p style="color:blue;">聚合函数的工作方式与本地mysql聚合（摘要）函数（如sum或count（））完全相同。</p>
                <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">

                    <div class="admon-title">
                        Note
                    </div>
                    <p>
                        To upgrade the shared library associated with a UDF, issue a
                        <a class="link" href="sql-syntax.html#drop-function" title="13.1.24&nbsp;DROP FUNCTION Syntax"><code class="literal">DROP FUNCTION</code></a> statement,
                        upgrade the shared library, and then issue a
                        <a class="link" href="sql-syntax.html#create-function" title="13.1.13&nbsp;CREATE FUNCTION Syntax"><code class="literal">CREATE FUNCTION</code></a> statement. If
                        you upgrade the shared library first and then use
                        <a class="link" href="sql-syntax.html#drop-function" title="13.1.24&nbsp;DROP FUNCTION Syntax"><code class="literal">DROP FUNCTION</code></a>, the server may
                        crash.
                    </p><p style="color:blue;">若要升级与UDF关联的共享库，请发出DROP FUNCTION语句，升级共享库，然后发出CREATE FUNCTION语句。如果先升级共享库，然后使用drop函数，服务器可能会崩溃。</p>
                </div>

            </div>
            <div class="section">
                <div class="titlepage">
                    <div>
                        <div>
                            <h4 class="title"><a name="drop-function-udf"></a>13.7.3.2&nbsp;DROP FUNCTION Syntax</h4>

                        </div>

                    </div>

                </div>
                <a class="indexterm" name="idm140286828213728"></a><a class="indexterm" name="idm140286828212656"></a><a class="indexterm" name="idm140286828211168"></a><a class="indexterm" name="idm140286828209680"></a><a class="indexterm" name="idm140286828208608"></a><a class="indexterm" name="idm140286828207536"></a><pre data-lang="sql" class="programlisting">DROP FUNCTION <em class="replaceable"><code>function_name</code></em>
</pre><p>
                This statement drops the user-defined function (UDF) named
                <em class="replaceable"><code>function_name</code></em>.
            </p><p style="color:blue;">此语句删除名为function_name的用户定义函数（UDF）。</p><p>
                To drop a function, you must have the
                <a class="link" href="security.html#priv_delete"><code class="literal">DELETE</code></a> privilege for the
                <code class="literal">mysql</code> system database. This is because
                <a class="link" href="sql-syntax.html#drop-function" title="13.1.24&nbsp;DROP FUNCTION Syntax"><code class="literal">DROP FUNCTION</code></a> removes a row from
                the <code class="literal">mysql.func</code> system table that records the
                function's name, type, and shared library name.
            </p><p style="color:blue;">要删除函数，您必须具有mysql系统数据库的删除权限。这是因为drop函数从mysql.func系统表中删除一行，该行记录函数的名称、类型和共享库名称。</p>
                <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">

                    <div class="admon-title">
                        Note
                    </div>
                    <p>
                        To upgrade the shared library associated with a UDF, issue a
                        <a class="link" href="sql-syntax.html#drop-function" title="13.1.24&nbsp;DROP FUNCTION Syntax"><code class="literal">DROP FUNCTION</code></a> statement,
                        upgrade the shared library, and then issue a
                        <a class="link" href="sql-syntax.html#create-function" title="13.1.13&nbsp;CREATE FUNCTION Syntax"><code class="literal">CREATE FUNCTION</code></a> statement. If
                        you upgrade the shared library first and then use
                        <a class="link" href="sql-syntax.html#drop-function" title="13.1.24&nbsp;DROP FUNCTION Syntax"><code class="literal">DROP FUNCTION</code></a>, the server may
                        crash.
                    </p><p style="color:blue;">若要升级与UDF关联的共享库，请发出DROP FUNCTION语句，升级共享库，然后发出CREATE FUNCTION语句。如果先升级共享库，然后使用drop函数，服务器可能会崩溃。</p>
                </div>
                <p>
                    <a class="link" href="sql-syntax.html#drop-function" title="13.1.24&nbsp;DROP FUNCTION Syntax"><code class="literal">DROP FUNCTION</code></a> is also used to
                    drop stored functions (see <a class="xref" href="sql-syntax.html#drop-procedure" title="13.1.27&nbsp;DROP PROCEDURE and DROP FUNCTION Syntax">Section&nbsp;13.1.27, “DROP PROCEDURE and DROP FUNCTION Syntax”</a>).
                </p><p style="color:blue;">drop函数还用于删除存储的函数（请参阅13.1.27节，“drop procedure and drop function syntax”）。</p>
            </div>
            <div class="section">
                <div class="titlepage">
                    <div>
                        <div>
                            <h4 class="title"><a name="install-plugin"></a>13.7.3.3&nbsp;INSTALL PLUGIN Syntax</h4>

                        </div>

                    </div>

                </div>
                <a class="indexterm" name="idm140286828186592"></a><a class="indexterm" name="idm140286828185504"></a><a class="indexterm" name="idm140286828184432"></a><pre data-lang="sql" class="programlisting">INSTALL PLUGIN <em class="replaceable"><code>plugin_name</code></em> SONAME '<em class="replaceable"><code>shared_library_name</code></em>'
</pre><p>
                This statement installs a server plugin. It requires the
                <a class="link" href="security.html#priv_insert"><code class="literal">INSERT</code></a> privilege for the
                <code class="literal">mysql.plugin</code> system table.
            </p><p style="color:blue;">此语句安装服务器插件。它需要mysql.plugin系统表的insert特权。</p><p>
                <em class="replaceable"><code>plugin_name</code></em> is the name of the plugin
                as defined in the plugin descriptor structure contained in the
                library file (see <a class="xref" href="extending-mysql.html#plugin-data-structures" title="28.2.4.2&nbsp;Plugin Data Structures">Section&nbsp;28.2.4.2, “Plugin Data Structures”</a>).
                Plugin names are not case-sensitive. For maximal compatibility,
                plugin names should be limited to ASCII letters, digits, and
                underscore because they are used in C source files, shell
                command lines, M4 and Bourne shell scripts, and SQL
                environments.
            </p><p style="color:blue;">plugin_name是在库文件中包含的插件描述符结构中定义的插件名称（参见第28.2.4.2节“插件数据结构”）。插件名称不区分大小写。对于最大兼容性，插件名称应限于ASCII字母、数字和下划线，因为它们在C源文件、shell命令行、M4和Berne shell脚本和SQL环境中使用。</p><p>
                <em class="replaceable"><code>shared_library_name</code></em> is the name of
                the shared library that contains the plugin code. The name
                includes the file name extension (for example,
                <code class="filename">libmyplugin.so</code>,
                <code class="filename">libmyplugin.dll</code>, or
                <code class="filename">libmyplugin.dylib</code>).
            </p><p style="color:blue;">shared_library_name是包含插件代码的共享库的名称。名称包括文件扩展名（例如，libmyplugin.so、libmyplugin.dll或libmyplugin.dylib）。</p><p>
                The shared library must be located in the plugin directory (the
                directory named by the
                <a class="link" href="server-administration.html#sysvar_plugin_dir"><code class="literal">plugin_dir</code></a> system variable).
                The library must be in the plugin directory itself, not in a
                subdirectory. By default,
                <a class="link" href="server-administration.html#sysvar_plugin_dir"><code class="literal">plugin_dir</code></a> is the
                <code class="filename">plugin</code> directory under the directory named
                by the <code class="literal">pkglibdir</code> configuration variable, but
                it can be changed by setting the value of
                <a class="link" href="server-administration.html#sysvar_plugin_dir"><code class="literal">plugin_dir</code></a> at server startup.
                For example, set its value in a <code class="filename">my.cnf</code>
                file:
            </p><p style="color:blue;">共享库必须位于plugin目录中（由plugin_dir系统变量命名的目录）。库必须位于插件目录本身，而不是子目录中。默认情况下，plugin_dir是pkglibdir配置变量命名目录下的plugin目录，但可以通过在服务器启动时设置plugin_dir的值来更改。例如，在my.cnf文件中设置其值：</p><pre data-lang="ini" class="programlisting">[mysqld]
plugin_dir=<em class="replaceable"><code>/path/to/plugin/directory</code></em>
</pre><p>
                If the value of <a class="link" href="server-administration.html#sysvar_plugin_dir"><code class="literal">plugin_dir</code></a> is a
                relative path name, it is taken to be relative to the MySQL base
                directory (the value of the
                <a class="link" href="server-administration.html#sysvar_basedir"><code class="literal">basedir</code></a> system variable).
            </p><p style="color:blue;">如果plugin_dir的值是相对路径名，则将其视为相对于mysql基目录（basedir系统变量的值）。</p><p>
                <a class="link" href="sql-syntax.html#install-plugin" title="13.7.3.3&nbsp;INSTALL PLUGIN Syntax"><code class="literal">INSTALL PLUGIN</code></a> loads and
                initializes the plugin code to make the plugin available for
                use. A plugin is initialized by executing its initialization
                function, which handles any setup that the plugin must perform
                before it can be used. When the server shuts down, it executes
                the deinitialization function for each plugin that is loaded so
                that the plugin has a chance to perform any final cleanup.
            </p><p style="color:blue;">install plugin加载并初始化插件代码以使插件可用。插件通过执行其初始化函数来初始化，该函数处理插件在使用之前必须执行的任何设置。当服务器关闭时，它会为加载的每个插件执行去初始化功能，以便插件有机会执行任何最终清理。</p><p>
                <a class="link" href="sql-syntax.html#install-plugin" title="13.7.3.3&nbsp;INSTALL PLUGIN Syntax"><code class="literal">INSTALL PLUGIN</code></a> also registers the
                plugin by adding a line that indicates the plugin name and
                library file name to the <code class="literal">mysql.plugin</code> system
                table. At server startup, the server loads and initializes any
                plugin that is listed in <code class="literal">mysql.plugin</code>. This
                means that a plugin is installed with
                <a class="link" href="sql-syntax.html#install-plugin" title="13.7.3.3&nbsp;INSTALL PLUGIN Syntax"><code class="literal">INSTALL PLUGIN</code></a> only once, not
                every time the server starts. Plugin loading at startup does not
                occur if the server is started with the
                <a class="link" href="server-administration.html#option_mysqld_skip-grant-tables"><code class="option">--skip-grant-tables</code></a> option.
            </p><p style="color:blue;">install plugin还通过在mysql.plugin系统表中添加一行指示插件名称和库文件名来注册插件。在服务器启动时，服务器加载并初始化mysql.plugin中列出的任何插件。这意味着插件只安装一次，而不是每次服务器启动时。如果使用--skip grant tables选项启动服务器，则不会在启动时加载插件。</p><p>
                A plugin library can contain multiple plugins. For each of them
                to be installed, use a separate <a class="link" href="sql-syntax.html#install-plugin" title="13.7.3.3&nbsp;INSTALL PLUGIN Syntax"><code class="literal">INSTALL
                PLUGIN</code></a> statement. Each statement names a different
                plugin, but all of them specify the same library name.
            </p><p style="color:blue;">插件库可以包含多个插件。对于要安装的每个插件，请使用单独的install plugin语句。每个语句命名一个不同的插件，但它们都指定相同的库名称。</p><p>
                <a class="link" href="sql-syntax.html#install-plugin" title="13.7.3.3&nbsp;INSTALL PLUGIN Syntax"><code class="literal">INSTALL PLUGIN</code></a> causes the server
                to read option (<code class="filename">my.cnf</code>) files just as
                during server startup. This enables the plugin to pick up any
                relevant options from those files. It is possible to add plugin
                options to an option file even before loading a plugin (if the
                <code class="literal">loose</code> prefix is used). It is also possible to
                uninstall a plugin, edit <code class="filename">my.cnf</code>, and
                install the plugin again. Restarting the plugin this way enables
                it to the new option values without a server restart.
            </p><p style="color:blue;">安装插件使服务器读取选项（my.cnf）文件，就像在服务器启动期间一样。这使得插件能够从这些文件中选择任何相关的选项。甚至在加载插件之前（如果使用松散前缀），也可以将插件选项添加到选项文件中。也可以卸载插件，编辑my.cnf，然后重新安装插件。通过这种方式重新启动插件，可以在不重新启动服务器的情况下将其设置为新的选项值。</p><p>
                For options that control individual plugin loading at server
                startup, see <a class="xref" href="server-administration.html#plugin-loading" title="5.5.1&nbsp;Installing and Uninstalling Plugins">Section&nbsp;5.5.1, “Installing and Uninstalling Plugins”</a>. If you need to
                load plugins for a single server startup when the
                <a class="link" href="server-administration.html#option_mysqld_skip-grant-tables"><code class="option">--skip-grant-tables</code></a> option is
                given (which tells the server not to read system tables), use
                the <a class="link" href="server-administration.html#option_mysqld_plugin-load"><code class="option">--plugin-load</code></a> option. See
                <a class="xref" href="server-administration.html#server-options" title="5.1.6&nbsp;Server Command Options">Section&nbsp;5.1.6, “Server Command Options”</a>.
            </p><p style="color:blue;">有关在服务器启动时控制单个插件加载的选项，请参阅第5.5.1节“安装和卸载插件”。如果在给定--skip grant tables选项（它告诉服务器不要读取系统表）时，需要为单个服务器启动加载插件，请使用--plugin load选项。参见第5.1.6节“服务器命令选项”。</p><p>
                To remove a plugin, use the <a class="link" href="sql-syntax.html#uninstall-plugin" title="13.7.3.4&nbsp;UNINSTALL PLUGIN Syntax"><code class="literal">UNINSTALL
                PLUGIN</code></a> statement.
            </p><p style="color:blue;">要删除插件，请使用uninstall plugin语句。</p><p>
                For additional information about plugin loading, see
                <a class="xref" href="server-administration.html#plugin-loading" title="5.5.1&nbsp;Installing and Uninstalling Plugins">Section&nbsp;5.5.1, “Installing and Uninstalling Plugins”</a>.
            </p><p style="color:blue;">有关插件加载的更多信息，请参见第5.5.1节“安装和卸载插件”。</p><p>
                To see what plugins are installed, use the
                <a class="link" href="sql-syntax.html#show-plugins" title="13.7.5.25&nbsp;SHOW PLUGINS Syntax"><code class="literal">SHOW PLUGINS</code></a> statement or query
                the <code class="literal">INFORMATION_SCHEMA</code> the
                <a class="link" href="information-schema.html#plugins-table" title="24.17&nbsp;The INFORMATION_SCHEMA PLUGINS Table"><code class="literal">PLUGINS</code></a> table.
            </p><p style="color:blue;">要查看安装了哪些插件，请使用show plugins语句或查询plugins表的信息模式。</p><p>
                If you recompile a plugin library and need to reinstall it, you
                can use either of the following methods:
            </p><p style="color:blue;">如果重新编译插件库并需要重新安装，可以使用以下任一方法：</p>
                <div class="itemizedlist">
                    <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                        Use <a class="link" href="sql-syntax.html#uninstall-plugin" title="13.7.3.4&nbsp;UNINSTALL PLUGIN Syntax"><code class="literal">UNINSTALL PLUGIN</code></a> to
                        uninstall all plugins in the library, install the new plugin
                        library file in the plugin directory, and then use
                        <a class="link" href="sql-syntax.html#install-plugin" title="13.7.3.3&nbsp;INSTALL PLUGIN Syntax"><code class="literal">INSTALL PLUGIN</code></a> to install all
                        plugins in the library. This procedure has the advantage
                        that it can be used without stopping the server. However, if
                        the plugin library contains many plugins, you must issue
                        many <a class="link" href="sql-syntax.html#install-plugin" title="13.7.3.3&nbsp;INSTALL PLUGIN Syntax"><code class="literal">INSTALL PLUGIN</code></a> and
                        <a class="link" href="sql-syntax.html#uninstall-plugin" title="13.7.3.4&nbsp;UNINSTALL PLUGIN Syntax"><code class="literal">UNINSTALL PLUGIN</code></a> statements.
                    </p><p style="color:blue;">使用uninstall plugin卸载库中的所有插件，在插件目录中安装新的插件库文件，然后使用install plugin安装库中的所有插件。此过程的优点是可以在不停止服务器的情况下使用它。但是，如果插件库包含许多插件，则必须发出许多install plugin和uninstall plugin语句。</p></li><li class="listitem"><p>
                        Stop the server, install the new plugin library file in the
                        plugin directory, and restart the server.
                    </p><p style="color:blue;">停止服务器，在插件目录中安装新的插件库文件，然后重新启动服务器。</p></li></ul>
                </div>

            </div>
            <div class="section">
                <div class="titlepage">
                    <div>
                        <div>
                            <h4 class="title"><a name="uninstall-plugin"></a>13.7.3.4&nbsp;UNINSTALL PLUGIN Syntax</h4>

                        </div>

                    </div>

                </div>
                <a class="indexterm" name="idm140286828125504"></a><a class="indexterm" name="idm140286828124416"></a><a class="indexterm" name="idm140286828123344"></a><pre data-lang="sql" class="programlisting">UNINSTALL PLUGIN <em class="replaceable"><code>plugin_name</code></em>
</pre><p>
                This statement removes an installed server plugin. It requires
                the <a class="link" href="security.html#priv_delete"><code class="literal">DELETE</code></a> privilege for the
                <code class="literal">mysql.plugin</code> system table.
                <a class="link" href="sql-syntax.html#uninstall-plugin" title="13.7.3.4&nbsp;UNINSTALL PLUGIN Syntax"><code class="literal">UNINSTALL PLUGIN</code></a> is the
                complement of <a class="link" href="sql-syntax.html#install-plugin" title="13.7.3.3&nbsp;INSTALL PLUGIN Syntax"><code class="literal">INSTALL PLUGIN</code></a>.
            </p><p style="color:blue;">此语句删除已安装的服务器插件。它需要mysql.plugin系统表的删除权限。卸载插件是安装插件的补充。</p><p>
                <em class="replaceable"><code>plugin_name</code></em> must be the name of some
                plugin that is listed in the <code class="literal">mysql.plugin</code>
                table. The server executes the plugin's deinitialization
                function and removes the row for the plugin from the
                <code class="literal">mysql.plugin</code> system table, so that subsequent
                server restarts will not load and initialize the plugin.
                <a class="link" href="sql-syntax.html#uninstall-plugin" title="13.7.3.4&nbsp;UNINSTALL PLUGIN Syntax"><code class="literal">UNINSTALL PLUGIN</code></a> does not remove
                the plugin's shared library file.
            </p><p style="color:blue;">plugin_name必须是mysql.plugin表中列出的某个插件的名称。服务器执行插件的取消初始化功能，并从mysql.plugin系统表中删除该插件的行，以便后续服务器重新启动时不会加载和初始化插件。卸载插件不会删除插件的共享库文件。</p><p>
                You cannot uninstall a plugin if any table that uses it is open.
            </p><p style="color:blue;">如果使用插件的任何表处于打开状态，则无法卸载插件。</p><p>
                Plugin removal has implications for the use of associated
                tables. For example, if a full-text parser plugin is associated
                with a <code class="literal">FULLTEXT</code> index on the table,
                uninstalling the plugin makes the table unusable. Any attempt to
                access the table results in an error. The table cannot even be
                opened, so you cannot drop an index for which the plugin is
                used. This means that uninstalling a plugin is something to do
                with care unless you do not care about the table contents. If
                you are uninstalling a plugin with no intention of reinstalling
                it later and you care about the table contents, you should dump
                the table with <a class="link" href="programs.html#mysqldump" title="4.5.4&nbsp;mysqldump — A Database Backup Program"><span class="command"><strong>mysqldump</strong></span></a> and remove the
                <code class="literal">WITH PARSER</code> clause from the dumped
                <a class="link" href="sql-syntax.html#create-table" title="13.1.18&nbsp;CREATE TABLE Syntax"><code class="literal">CREATE TABLE</code></a> statement so that
                you can reload the table later. If you do not care about the
                table, <a class="link" href="sql-syntax.html#drop-table" title="13.1.29&nbsp;DROP TABLE Syntax"><code class="literal">DROP TABLE</code></a> can be used
                even if any plugins associated with the table are missing.
            </p><p style="color:blue;">插件移除对关联表的使用有影响。例如，如果全文分析器插件与表上的全文索引关联，则卸载该插件会使表不可用。任何访问表的尝试都会导致错误。该表甚至无法打开，因此您不能删除使用插件的索引。这意味着卸载插件需要小心，除非您不关心表内容。如果你正在卸载一个插件，不打算以后重新安装它，你关心表内容，你应该用MySql DUMP转储表，并从被丢弃的CREATE表语句中删除带解析器子句，这样你就可以在以后重新加载表。如果您不关心表，那么即使缺少与表相关联的任何插件，也可以使用drop table。</p><p>
                For additional information about plugin loading, see
                <a class="xref" href="server-administration.html#plugin-loading" title="5.5.1&nbsp;Installing and Uninstalling Plugins">Section&nbsp;5.5.1, “Installing and Uninstalling Plugins”</a>.
            </p><p style="color:blue;">有关插件加载的更多信息，请参见第5.5.1节“安装和卸载插件”。</p>
            </div>

        </div>
        <div class="section">
            <div class="titlepage">
                <div>
                    <div>
                        <h3 class="title"><a name="set-statement"></a>13.7.4&nbsp;SET Syntax</h3>

                    </div>

                </div>

            </div>
            <div class="toc">
                <dl class="toc"><dt><span class="section"><a href="sql-syntax.html#set-variable">13.7.4.1 SET Syntax for Variable Assignment</a></span></dt><dt><span class="section"><a href="sql-syntax.html#set-character-set">13.7.4.2 SET CHARACTER SET Syntax</a></span></dt><dt><span class="section"><a href="sql-syntax.html#set-names">13.7.4.3 SET NAMES Syntax</a></span></dt></dl>
            </div>
            <p>
                The <a class="link" href="sql-syntax.html#set-statement" title="13.7.4&nbsp;SET Syntax"><code class="literal">SET</code></a>
                statement has several forms. Descriptions for those forms that are
                not associated with a specific server capability appear in
                subsections of this section:
            </p><p style="color:blue;">set语句有几种形式。与特定服务器功能没有关联的表单的说明显示在本节的子部分中：</p>
            <div class="itemizedlist">
                <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                    <a class="link" href="sql-syntax.html#set-variable" title="13.7.4.1&nbsp;SET Syntax for Variable Assignment"><code class="literal">SET
                        <em class="replaceable"><code>var_name</code></em> =
                        <em class="replaceable"><code>value</code></em></code></a> enables you to
                    assign values to variables that affect the operation of the
                    server or clients. See <a class="xref" href="sql-syntax.html#set-variable" title="13.7.4.1&nbsp;SET Syntax for Variable Assignment">Section&nbsp;13.7.4.1, “SET Syntax for Variable Assignment”</a>.
                </p><p style="color:blue;">set var_name=value允许您将值分配给影响服务器或客户端操作的变量。见第13.7.4.1节“变量赋值的设置语法”。</p></li><li class="listitem"><p>
                    <a class="link" href="sql-syntax.html#set-character-set" title="13.7.4.2&nbsp;SET CHARACTER SET Syntax"><code class="literal">SET CHARACTER SET</code></a> and
                    <a class="link" href="sql-syntax.html#set-names" title="13.7.4.3&nbsp;SET NAMES Syntax"><code class="literal">SET NAMES</code></a> assign values to
                    character set and collation variables associated with the
                    current connection to the server. See
                    <a class="xref" href="sql-syntax.html#set-character-set" title="13.7.4.2&nbsp;SET CHARACTER SET Syntax">Section&nbsp;13.7.4.2, “SET CHARACTER SET Syntax”</a>, and
                    <a class="xref" href="sql-syntax.html#set-names" title="13.7.4.3&nbsp;SET NAMES Syntax">Section&nbsp;13.7.4.3, “SET NAMES Syntax”</a>.
                </p><p style="color:blue;">set character set和set names将值分配给与当前服务器连接相关联的字符集和排序规则变量。参见第13.7.4.2节“设置字符集语法”和第13.7.4.3节“设置名称语法”。</p></li></ul>
            </div>
            <p>
                Descriptions for the other forms appear elsewhere, grouped with
                other statements related to the capability they help implement:
            </p><p style="color:blue;">其他表单的描述出现在其他地方，与其他与它们帮助实现的功能相关的语句组合在一起：</p>
            <div class="itemizedlist">
                <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                    <a class="link" href="sql-syntax.html#set-password" title="13.7.1.7&nbsp;SET PASSWORD Syntax"><code class="literal">SET PASSWORD</code></a> assigns account
                    passwords. See <a class="xref" href="sql-syntax.html#set-password" title="13.7.1.7&nbsp;SET PASSWORD Syntax">Section&nbsp;13.7.1.7, “SET PASSWORD Syntax”</a>.
                </p><p style="color:blue;">设置密码分配帐户密码。参见第13.7.1.7节“设置密码语法”。</p></li><li class="listitem"><p>
                    <a class="link" href="sql-syntax.html#set-transaction" title="13.3.6&nbsp;SET TRANSACTION Syntax"><code class="literal">SET
                        TRANSACTION ISOLATION LEVEL</code></a> sets the isolation level
                    for transaction processing. See
                    <a class="xref" href="sql-syntax.html#set-transaction" title="13.3.6&nbsp;SET TRANSACTION Syntax">Section&nbsp;13.3.6, “SET TRANSACTION Syntax”</a>.
                </p><p style="color:blue;">设置事务隔离级别设置事务处理的隔离级别。参见第13.3.6节“设置事务语法”。</p></li></ul>
            </div>
            <div class="section">
                <div class="titlepage">
                    <div>
                        <div>
                            <h4 class="title"><a name="set-variable"></a>13.7.4.1&nbsp;SET Syntax for Variable Assignment</h4>

                        </div>

                    </div>

                </div>
                <a class="indexterm" name="idm140286828080864"></a><a class="indexterm" name="idm140286828079408"></a><a class="indexterm" name="idm140286828077920"></a><pre data-lang="sql" class="programlisting">SET <em class="replaceable"><code>variable</code></em> = <em class="replaceable"><code>expr</code></em> [, <em class="replaceable"><code>variable</code></em> = <em class="replaceable"><code>expr</code></em>] ...

<em class="replaceable"><code>variable</code></em>: {
    <em class="replaceable"><code>user_var_name</code></em>
  | <em class="replaceable"><code>param_name</code></em>
  | <em class="replaceable"><code>local_var_name</code></em>
  | {GLOBAL | @@GLOBAL.} <em class="replaceable"><code>system_var_name</code></em>
  | [SESSION | @@SESSION. | @@] <em class="replaceable"><code>system_var_name</code></em>
}
</pre><p>
                <a class="link" href="sql-syntax.html#set-variable" title="13.7.4.1&nbsp;SET Syntax for Variable Assignment"><code class="literal">SET</code></a>
                syntax for variable assignment enables you to assign values to
                different types of variables that affect the operation of the
                server or clients:
            </p><p style="color:blue;">通过变量赋值的set语法，可以将值赋给影响服务器或客户端操作的不同类型的变量：</p>
                <div class="itemizedlist">
                    <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                        User-defined variables. See
                        <a class="xref" href="language-structure.html#user-variables" title="9.4&nbsp;User-Defined Variables">Section&nbsp;9.4, “User-Defined Variables”</a>.
                    </p><p style="color:blue;">用户定义的变量。见第9.4节“用户定义变量”。</p></li><li class="listitem"><p>
                        Stored procedure and function parameters, and stored program
                        local variables. See
                        <a class="xref" href="sql-syntax.html#stored-program-variables" title="13.6.4&nbsp;Variables in Stored Programs">Section&nbsp;13.6.4, “Variables in Stored Programs”</a>.
                    </p><p style="color:blue;">存储过程和函数参数，以及存储程序局部变量。参见第13.6.4节“存储程序中的变量”。</p></li><li class="listitem"><p>
                        System variables. See
                        <a class="xref" href="server-administration.html#server-system-variables" title="5.1.7&nbsp;Server System Variables">Section&nbsp;5.1.7, “Server System Variables”</a>. System variables
                        also can be set at server startup, as described in
                        <a class="xref" href="server-administration.html#using-system-variables" title="5.1.8&nbsp;Using System Variables">Section&nbsp;5.1.8, “Using System Variables”</a>.
                    </p><p style="color:blue;">系统变量。见第5.1.7节“服务器系统变量”。系统变量也可以在服务器启动时设置，如第5.1.8节“使用系统变量”所述。</p></li></ul>
                </div>
                <p>
                    A <a class="link" href="sql-syntax.html#set-variable" title="13.7.4.1&nbsp;SET Syntax for Variable Assignment"><code class="literal">SET</code></a>
                    statement that assigns variable values is not written to the
                    binary log, so in replication scenarios it affects only the host
                    on which you execute it. To affect all replication hosts,
                    execute the statement on each host.
                </p><p style="color:blue;">分配变量值的set语句不会写入二进制日志，因此在复制场景中，它只影响执行它的主机。要影响所有复制主机，请在每个主机上执行该语句。</p><p>
                The following sections describe
                <a class="link" href="sql-syntax.html#set-variable" title="13.7.4.1&nbsp;SET Syntax for Variable Assignment"><code class="literal">SET</code></a>
                syntax for setting variables. They use the
                <a class="link" href="functions.html#operator_assign-equal"><code class="literal">=</code></a>
                assignment operator, but the
                <a class="link" href="functions.html#operator_assign-value"><code class="literal">:=</code></a>
                assignment operator is also permitted for this purpose.
            </p><p style="color:blue;">以下各节介绍设置变量的集合语法。它们使用=赋值运算符，但也允许使用：=赋值运算符。</p>
                <div class="itemizedlist">
                    <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><a class="xref" href="sql-syntax.html#set-variable-user-variables" title="User-Defined Variable Assignment">User-Defined Variable Assignment</a></p><p style="color:blue;">用户定义变量分配</p></li><li class="listitem"><p><a class="xref" href="sql-syntax.html#set-variable-parameters-local-variables" title="Parameter and Local Variable Assignment">Parameter and Local Variable Assignment</a></p><p style="color:blue;">参数与局部变量赋值</p></li><li class="listitem"><p><a class="xref" href="sql-syntax.html#set-variable-system-variables" title="System Variable Assignment">System Variable Assignment</a></p><p style="color:blue;">系统变量分配</p></li><li class="listitem"><p><a class="xref" href="sql-syntax.html#set-variable-error-handling" title="SET Error Handling">SET Error Handling</a></p><p style="color:blue;">设置错误处理</p></li><li class="listitem"><p><a class="xref" href="sql-syntax.html#set-variable-multiple-assignments" title="Multiple Variable Assignment">Multiple Variable Assignment</a></p><p style="color:blue;">多变量赋值</p></li><li class="listitem"><p><a class="xref" href="sql-syntax.html#variable-references-in-expressions" title="System Variable References in Expressions">System Variable References in Expressions</a></p><p style="color:blue;">表达式中的系统变量引用</p></li></ul>
                </div>

                <div class="simplesect">

                    <div class="titlepage">
                        <div>

                            <div class="simple">
                                <h5 class="title"><a name="set-variable-user-variables"></a>User-Defined Variable Assignment</h5>

                            </div>

                        </div>

                    </div>
                    <p>
                        User-defined variables are created locally within a session
                        and exist only within the context of that session; see
                        <a class="xref" href="language-structure.html#user-variables" title="9.4&nbsp;User-Defined Variables">Section&nbsp;9.4, “User-Defined Variables”</a>.
                    </p><p style="color:blue;">用户定义的变量是在会话中本地创建的，并且只存在于该会话的上下文中；参见第9.4节“用户定义变量”。</p><p>
                    A user-defined variable is written as
                    <code class="literal">@<em class="replaceable"><code>var_name</code></em></code> and is
                    assigned an expression value as follows:
                </p><p style="color:blue;">用户定义的变量被写为@var_name，并被分配一个表达式值，如下所示：</p><pre data-lang="sql" class="programlisting">SET @<em class="replaceable"><code>var_name</code></em> = <em class="replaceable"><code>expr</code></em>;
</pre><p>
                    Examples:
                </p><p style="color:blue;">实例：</p><pre data-lang="sql" class="programlisting">SET @name = 43;
SET @total_tax = (SELECT SUM(tax) FROM taxable_transactions);
</pre><p>
                    As demonstrated by those statements,
                    <em class="replaceable"><code>expr</code></em> can range from simple (a
                    literal value) to more complex (the value returned by a scalar
                    subquery).
                </p><p style="color:blue;">如这些语句所示，expr可以从简单（文本值）到更复杂（标量子查询返回的值）不等。</p><p>
                    The Performance Schema
                    <a class="link" href="performance-schema.html#performance-schema-user-variable-tables" title="25.12.10&nbsp;Performance Schema User-Defined Variable Tables"><code class="literal">user_variables_by_thread</code></a> table
                    contains information about user-defined variables. See
                    <a class="xref" href="performance-schema.html#performance-schema-user-variable-tables" title="25.12.10&nbsp;Performance Schema User-Defined Variable Tables">Section&nbsp;25.12.10, “Performance Schema User-Defined Variable Tables”</a>.
                </p><p style="color:blue;">performance schema user_variables_by_thread表包含有关用户定义变量的信息。见第25.12.10节“性能模式用户定义变量表”。</p>
                </div>
                <div class="simplesect">
                    <div class="titlepage">
                        <div>
                            <div class="simple">
                                <h5 class="title"><a name="set-variable-parameters-local-variables"></a>Parameter and Local Variable Assignment</h5>

                            </div>

                        </div>

                    </div>
                    <p>
                        <a class="link" href="sql-syntax.html#set-variable" title="13.7.4.1&nbsp;SET Syntax for Variable Assignment"><code class="literal">SET</code></a>
                        applies to parameters and local variables in the context of
                        the stored object within which they are defined. The following
                        procedure uses the <code class="literal">increment</code> procedure
                        parameter and <code class="literal">counter</code> local variable:
                    </p><p style="color:blue;">set应用于定义参数和局部变量的存储对象上下文中的参数和局部变量。以下过程使用增量过程参数和计数器局部变量：</p><pre data-lang="sql" class="programlisting">CREATE PROCEDURE p(increment INT)
BEGIN
  DECLARE counter INT DEFAULT 0;
  WHILE counter &lt; 10 DO
    -- ... do work ...
    SET counter = counter + increment;
  END WHILE;
END;
</pre>
                </div>
                <div class="simplesect">
                    <div class="titlepage">
                        <div>
                            <div class="simple">
                                <h5 class="title"><a name="set-variable-system-variables"></a>System Variable Assignment</h5>

                            </div>

                        </div>

                    </div>
                    <p>
                        The MySQL server maintains system variables that configure its
                        operation. A system variable can have a global value that
                        affects server operation as a whole, a session value that
                        affects the current session, or both. Many system variables
                        are dynamic and can be changed at runtime using the
                        <a class="link" href="sql-syntax.html#set-variable" title="13.7.4.1&nbsp;SET Syntax for Variable Assignment"><code class="literal">SET</code></a>
                        statement to affect operation of the current server instance.
                        (To make a global system variable setting permanent so that it
                        applies across server restarts, you should also set it in an
                        option file.)
                    </p><p style="color:blue;">mysql服务器维护配置其操作的系统变量。系统变量可以具有影响整个服务器操作的全局值，也可以具有影响当前会话的会话值，或者同时具有这两个值。许多系统变量是动态的，可以在运行时使用set语句进行更改，以影响当前服务器实例的操作。（要使全局系统变量设置永久，以便在服务器重新启动时应用，还应在选项文件中设置它。）</p><p>
                    If you change a session system variable, the value remains in
                    effect within your session until you change the variable to a
                    different value or the session ends. The change has no effect
                    on other sessions.
                </p><p style="color:blue;">如果更改会话系统变量，该值将在会话中保持有效，直到将该变量更改为其他值或会话结束。此更改对其他会话没有影响。</p><p>
                    If you change a global system variable, the value is
                    remembered and used to initialize the session value for new
                    sessions until you change the variable to a different value or
                    the server exits. The change is visible to any client that
                    accesses the global value. However, the change affects the
                    corresponding session value only for clients that connect
                    after the change. The global variable change does not affect
                    the session value for any current client sessions (not even
                    the session within which the global value change occurs).
                </p><p style="color:blue;">如果更改全局系统变量，则记住该值并将其初始化为新会话的会话值，直到将变量更改为不同的值或服务器退出。任何访问全局值的客户端都可以看到该更改。但是，更改仅影响更改后连接的客户端的相应会话值。全局变量更改不会影响任何当前客户端会话（甚至不影响发生全局值更改的会话）的会话值。</p>
                    <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">

                        <div class="admon-title">
                            Note
                        </div>
                        <p>
                            Setting a global system variable value always requires
                            special privileges. Setting a session system variable value
                            normally requires no special privileges and can be done by
                            any user, although there are exceptions. For more
                            information, see
                            <a class="xref" href="server-administration.html#system-variable-privileges" title="5.1.8.1&nbsp;System Variable Privileges">Section&nbsp;5.1.8.1, “System Variable Privileges”</a>.
                        </p><p style="color:blue;">设置全局系统变量值始终需要特殊权限。设置会话系统变量值通常不需要特殊权限，并且可以由任何用户完成，尽管有例外。有关详细信息，请参见第5.1.8.1节“系统变量特权”。</p>
                    </div>
                    <p>
                        The following discussion describes the syntax options for
                        setting system variables:
                    </p><p style="color:blue;">以下讨论介绍了设置系统变量的语法选项：</p>
                    <div class="itemizedlist">
                        <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                            To assign a value to a global system variable, precede the
                            variable name by the <code class="literal">GLOBAL</code> keyword or
                            the <code class="literal">@@GLOBAL.</code> qualifier:
                        </p><p style="color:blue;">若要为全局系统变量赋值，请在变量名前面加上global关键字或@@global。限定符：</p><pre data-lang="sql" class="programlisting">SET GLOBAL max_connections = 1000;
SET @@GLOBAL.max_connections = 1000;
</pre></li><li class="listitem"><p>
                            To assign a value to a session system variable, precede
                            the variable name by the <code class="literal">SESSION</code> or
                            <code class="literal">LOCAL</code> keyword, by the
                            <code class="literal">@@SESSION.</code>,
                            <code class="literal">@@LOCAL.</code>, or <code class="literal">@@</code>
                            qualifier, or by no keyword or no modifier at all:
                        </p><p style="color:blue;">若要给会话系统变量赋值，请在变量名前面加上会话或本地关键字、@@session、@@local.或@@qualifier，或者根本不加关键字或修饰符：</p><pre data-lang="sql" class="programlisting">SET SESSION sql_mode = 'TRADITIONAL';
SET LOCAL sql_mode = 'TRADITIONAL';
SET @@SESSION.sql_mode = 'TRADITIONAL';
SET @@LOCAL.sql_mode = 'TRADITIONAL';
SET @@sql_mode = 'TRADITIONAL';
SET sql_mode = 'TRADITIONAL';
</pre><p>
                            A client can change its own session variables, but not
                            those of any other client.
                        </p><p style="color:blue;">客户机可以更改自己的会话变量，但不能更改任何其他客户机的会话变量。</p></li></ul>
                    </div>
                    <p>
                        To set a global system variable value to the compiled-in MySQL
                        default value or a session system variable to the current
                        corresponding global value, set the variable to the value
                        <code class="literal">DEFAULT</code>. For example, the following two
                        statements are identical in setting the session value of
                        <a class="link" href="server-administration.html#sysvar_max_join_size"><code class="literal">max_join_size</code></a> to the current
                        global value:
                    </p><p style="color:blue;">若要将全局系统变量值设置为在mysql中编译的默认值，或将会话系统变量设置为当前对应的全局值，请将该变量设置为默认值。例如，在将“最大连接大小”的会话值设置为当前全局值时，以下两个语句是相同的：</p><pre data-lang="sql" class="programlisting">SET @@SESSION.max_join_size = DEFAULT;
SET @@SESSION.max_join_size = @@GLOBAL.max_join_size;
</pre><p>
                    To display system variable names and values:
                </p><p style="color:blue;">要显示系统变量名称和值，请执行以下操作：</p>
                    <div class="itemizedlist">
                        <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                            Use the <a class="link" href="sql-syntax.html#show-variables" title="13.7.5.39&nbsp;SHOW VARIABLES Syntax"><code class="literal">SHOW VARIABLES</code></a>
                            statement; see <a class="xref" href="sql-syntax.html#show-variables" title="13.7.5.39&nbsp;SHOW VARIABLES Syntax">Section&nbsp;13.7.5.39, “SHOW VARIABLES Syntax”</a>.
                        </p><p style="color:blue;">使用show variables语句；参见第13.7.5.39节“show variables syntax”。</p></li><li class="listitem"><p>
                            Several Performance Schema tables provide system variable
                            information. See
                            <a class="xref" href="performance-schema.html#performance-schema-system-variable-tables" title="25.12.13&nbsp;Performance Schema System Variable Tables">Section&nbsp;25.12.13, “Performance Schema System Variable Tables”</a>.
                        </p><p style="color:blue;">几个性能模式表提供系统变量信息。见第25.12.13节“性能模式系统变量表”。</p></li></ul>
                    </div>

                </div>
                <div class="simplesect">
                    <div class="titlepage">
                        <div>
                            <div class="simple">
                                <h5 class="title"><a name="set-variable-error-handling"></a>SET Error Handling</h5>

                            </div>

                        </div>

                    </div>
                    <p>
                        If any variable assignment in a
                        <a class="link" href="sql-syntax.html#set-variable" title="13.7.4.1&nbsp;SET Syntax for Variable Assignment"><code class="literal">SET</code></a>
                        statement fails, the entire statement fails and no variables
                        are changed.
                    </p><p style="color:blue;">如果set语句中的任何变量赋值失败，则整个语句将失败，并且不会更改任何变量。</p><p>
                    <a class="link" href="sql-syntax.html#set-variable" title="13.7.4.1&nbsp;SET Syntax for Variable Assignment"><code class="literal">SET</code></a>
                    produces an error under the circumstances described here. Most
                    of the examples show
                    <a class="link" href="sql-syntax.html#set-variable" title="13.7.4.1&nbsp;SET Syntax for Variable Assignment"><code class="literal">SET</code></a>
                    statements that use keyword syntax (for example,
                    <code class="literal">GLOBAL</code> or <code class="literal">SESSION</code>), but
                    the principles are also true for statements that use the
                    corresponding modifiers (for example,
                    <code class="literal">@@GLOBAL.</code> or
                    <code class="literal">@@SESSION.</code>).
                </p><p style="color:blue;">set在这里描述的情况下产生错误。大多数示例都显示了使用关键字语法（例如，global或session）的set语句，但是对于使用相应修饰符（例如，@global）的语句，原则也是正确的。或@@会话）。</p>
                    <div class="itemizedlist">
                        <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                            Use of
                            <a class="link" href="sql-syntax.html#set-variable" title="13.7.4.1&nbsp;SET Syntax for Variable Assignment"><code class="literal">SET</code></a>
                            (any variant) to set a read-only variable:
                        </p><p style="color:blue;">使用set（任意变量）设置只读变量：</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>SET GLOBAL version = 'abc';</code></strong>
ERROR 1238 (HY000): Variable 'version' is a read only variable
</pre></li><li class="listitem"><p>
                            Use of <code class="literal">GLOBAL</code> to set a variable that
                            has only a session value:
                        </p><p style="color:blue;">使用全局设置只有会话值的变量：</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>SET GLOBAL sql_log_bin = ON;</code></strong>
ERROR 1231 (42000): Variable 'sql_log_bin' can't be
set to the value of 'ON'
</pre></li><li class="listitem"><p>
                            Use of <code class="literal">SESSION</code> to set a variable that
                            has only a global value:
                        </p><p style="color:blue;">使用session设置只有全局值的变量：</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>SET SESSION max_connections = 1000;</code></strong>
ERROR 1229 (HY000): Variable 'max_connections' is a
GLOBAL variable and should be set with SET GLOBAL
</pre></li><li class="listitem"><p>
                            Omission of <code class="literal">GLOBAL</code> to set a variable
                            that has only a global value:
                        </p><p style="color:blue;">省略global以设置仅具有全局值的变量：</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>SET max_connections = 1000;</code></strong>
ERROR 1229 (HY000): Variable 'max_connections' is a
GLOBAL variable and should be set with SET GLOBAL
</pre></li><li class="listitem"><p>
                            The <code class="literal">@@GLOBAL.</code>,
                            <code class="literal">@@SESSION.</code>, and <code class="literal">@@</code>
                            modifiers apply only to system variables. An error occurs
                            for attempts to apply them to user-defined variables,
                            stored procedure or function parameters, or stored program
                            local variables.
                        </p><p style="color:blue;">“@@全局”、“会话”和“@”修饰符只应用于系统变量。尝试将它们应用于用户定义的变量、存储过程或函数参数或存储程序局部变量时出错。</p></li><li class="listitem"><p>
                            Not all system variables can be set to
                            <code class="literal">DEFAULT</code>. In such cases, assigning
                            <code class="literal">DEFAULT</code> results in an error.
                        </p><p style="color:blue;">并非所有系统变量都可以设置为默认值。在这种情况下，指定默认值会导致错误。</p></li><li class="listitem"><p>
                            An error occurs for attempts to assign
                            <code class="literal">DEFAULT</code> to user-defined variables,
                            stored procedure or function parameters, or stored program
                            local variables.
                        </p><p style="color:blue;">尝试将默认值分配给用户定义的变量、存储过程或函数参数或存储程序局部变量时出错。</p></li></ul>
                    </div>

                </div>
                <div class="simplesect">
                    <div class="titlepage">
                        <div>
                            <div class="simple">
                                <h5 class="title"><a name="set-variable-multiple-assignments"></a>Multiple Variable Assignment</h5>

                            </div>

                        </div>

                    </div>
                    <p>
                        A <a class="link" href="sql-syntax.html#set-variable" title="13.7.4.1&nbsp;SET Syntax for Variable Assignment"><code class="literal">SET</code></a>
                        statement can contain multiple variable assignments, separated
                        by commas. This statement assigns a value to a user-defined
                        variable and a system variable:
                    </p><p style="color:blue;">set语句可以包含多个变量赋值，用逗号分隔。此语句为用户定义的变量和系统变量赋值：</p><pre data-lang="sql" class="programlisting">SET @x = 1, SESSION sql_mode = '';
</pre><p>
                    If you set multiple system variables in a single statement,
                    the most recent <code class="literal">GLOBAL</code> or
                    <code class="literal">SESSION</code> keyword in the statement is used
                    for following assignments that have no keyword specified.
                </p><p style="color:blue;">如果在一个语句中设置多个系统变量，则语句中最新的全局或会话关键字将用于以下未指定关键字的赋值。</p><p>
                    Examples of multiple-variable assignment:
                </p><p style="color:blue;">多变量赋值示例：</p><pre data-lang="sql" class="programlisting">SET GLOBAL sort_buffer_size = 1000000, SESSION sort_buffer_size = 1000000;
SET @@GLOBAL.sort_buffer_size = 1000000, @@LOCAL.sort_buffer_size = 1000000;
SET GLOBAL max_connections = 1000, sort_buffer_size = 1000000;
</pre><p>
                    The <code class="literal">@@GLOBAL.</code>,
                    <code class="literal">@@SESSION.</code>, and <code class="literal">@@</code>
                    modifiers apply only to the immediately following system
                    variable, not any remaining system variables. This statement
                    sets the <a class="link" href="server-administration.html#sysvar_sort_buffer_size"><code class="literal">sort_buffer_size</code></a>
                    global value to 50000 and the session value to 1000000:
                </p><p style="color:blue;">“@global.”、“@session.”和“@modifiers”只应用于紧跟其后的系统变量，而不应用于任何剩余的系统变量。此语句将sort_buffer_size全局值设置为50000，将会话值设置为1000000：</p><pre data-lang="sql" class="programlisting">SET @@GLOBAL.sort_buffer_size = 50000, sort_buffer_size = 1000000;
</pre>
                </div>
                <div class="simplesect">
                    <div class="titlepage">
                        <div>
                            <div class="simple">
                                <h5 class="title"><a name="variable-references-in-expressions"></a>System Variable References in Expressions</h5>

                            </div>

                        </div>

                    </div>
                    <p>
                        To refer to the value of a system variable in expressions, use
                        one of the <code class="literal">@@</code>-modifiers. For example, you
                        can retrieve system variable values in a
                        <a class="link" href="sql-syntax.html#select" title="13.2.9&nbsp;SELECT Syntax"><code class="literal">SELECT</code></a> statement like this:
                    </p><p style="color:blue;">若要在表达式中引用系统变量的值，请使用@@-修饰符之一。例如，可以在select语句中检索系统变量值，如下所示：</p><pre data-lang="sql" class="programlisting">SELECT @@GLOBAL.sql_mode, @@SESSION.sql_mode, @@sql_mode;
</pre>
                    <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">

                        <div class="admon-title">
                            Note
                        </div>
                        <p>
                            A reference to a system variable in an expression as
                            <code class="literal">@@<em class="replaceable"><code>var_name</code></em></code>
                            (with <code class="literal">@@</code> rather than
                            <code class="literal">@@GLOBAL.</code> or
                            <code class="literal">@@SESSION.</code>) returns the session value if
                            it exists and the global value otherwise. This differs from
                            <code class="literal">SET @@<em class="replaceable"><code>var_name</code></em> =
                                <em class="replaceable"><code>expr</code></em></code>, which always
                            refers to the session value.
                        </p><p style="color:blue;">在表达式中对系统变量的引用为@@var_name（使用@@而不是@@global）。或“@ session”返回会话值，如果存在，则以全局值返回。这与始终引用会话值的set@@var_name=expr不同。</p>
                    </div>

                </div>

            </div>
            <div class="section">
                <div class="titlepage">
                    <div>
                        <div>
                            <h4 class="title"><a name="set-character-set"></a>13.7.4.2&nbsp;SET CHARACTER SET Syntax</h4>

                        </div>

                    </div>

                </div>
                <a class="indexterm" name="idm140286827949840"></a><a class="indexterm" name="idm140286827948784"></a><a class="indexterm" name="idm140286827947712"></a><a class="indexterm" name="idm140286827946224"></a><pre data-lang="sql" class="programlisting">SET {CHARACTER SET | CHARSET}
    {'<em class="replaceable"><code>charset_name</code></em>' | DEFAULT}
</pre><p>
                This statement maps all strings sent between the server and the
                current client with the given mapping. <code class="literal">SET CHARACTER
                SET</code> sets three session system variables:
                <a class="link" href="server-administration.html#sysvar_character_set_client"><code class="literal">character_set_client</code></a> and
                <a class="link" href="server-administration.html#sysvar_character_set_results"><code class="literal">character_set_results</code></a> are set
                to the given character set, and
                <a class="link" href="server-administration.html#sysvar_character_set_connection"><code class="literal">character_set_connection</code></a> to the
                value of
                <a class="link" href="server-administration.html#sysvar_character_set_database"><code class="literal">character_set_database</code></a>. See
                <a class="xref" href="charset.html#charset-connection" title="10.4&nbsp;Connection Character Sets and Collations">Section&nbsp;10.4, “Connection Character Sets and Collations”</a>.
            </p><p style="color:blue;">此语句使用给定的映射映射在服务器和当前客户端之间发送的所有字符串。set character set设置三个会话系统变量：character_set_client和character_set_results设置为给定的字符集，character_set_connection设置为character_set_数据库的值。见第10.4节“连接字符集和排序规则”。</p><p>
                <em class="replaceable"><code>charset_name</code></em> may be quoted or
                unquoted.
            </p><p style="color:blue;">字符集名称可以是引号或非引号。</p><p>
                The default character set mapping can be restored by using the
                value <code class="literal">DEFAULT</code>. The default depends on the
                server configuration.
            </p><p style="color:blue;">可以使用值default恢复默认字符集映射。默认值取决于服务器配置。</p><p>
                Some character sets cannot be used as the client character set.
                Attempting to use them with <a class="link" href="sql-syntax.html#set-character-set" title="13.7.4.2&nbsp;SET CHARACTER SET Syntax"><code class="literal">SET CHARACTER
                SET</code></a> produces an error. See
                <a class="xref" href="charset.html#charset-connection-impermissible-client-charset" title="Impermissible Client Character Sets">Impermissible Client Character Sets</a>.
            </p><p style="color:blue;">某些字符集不能用作客户端字符集。尝试将它们与集合字符集一起使用会产生错误。请参见不允许的客户端字符集。</p>
            </div>
            <div class="section">
                <div class="titlepage">
                    <div>
                        <div>
                            <h4 class="title"><a name="set-names"></a>13.7.4.3&nbsp;SET NAMES Syntax</h4>

                        </div>

                    </div>

                </div>
                <a class="indexterm" name="idm140286827925696"></a><a class="indexterm" name="idm140286827924624"></a><pre data-lang="sql" class="programlisting">SET NAMES {'<em class="replaceable"><code>charset_name</code></em>'
    [COLLATE '<em class="replaceable"><code>collation_name</code></em>'] | DEFAULT}
</pre><p>
                This statement sets the three session system variables
                <a class="link" href="server-administration.html#sysvar_character_set_client"><code class="literal">character_set_client</code></a>,
                <a class="link" href="server-administration.html#sysvar_character_set_connection"><code class="literal">character_set_connection</code></a>, and
                <a class="link" href="server-administration.html#sysvar_character_set_results"><code class="literal">character_set_results</code></a> to the
                given character set. Setting
                <a class="link" href="server-administration.html#sysvar_character_set_connection"><code class="literal">character_set_connection</code></a> to
                <code class="literal">charset_name</code> also sets
                <a class="link" href="server-administration.html#sysvar_collation_connection"><code class="literal">collation_connection</code></a> to the
                default collation for <code class="literal">charset_name</code>. See
                <a class="xref" href="charset.html#charset-connection" title="10.4&nbsp;Connection Character Sets and Collations">Section&nbsp;10.4, “Connection Character Sets and Collations”</a>.
            </p><p style="color:blue;">此语句将三个会话系统变量character_set_client、character_set_connection和character_set_results设置为给定的字符集。将character_set_connection设置为charset_name还将collation_connection设置为charset_name的默认排序规则。见第10.4节“连接字符集和排序规则”。</p><p>
                The optional <code class="literal">COLLATE</code> clause may be used to
                specify a collation explicitly. If given, the collation must one
                of the permitted collations for
                <em class="replaceable"><code>charset_name</code></em>.
            </p><p style="color:blue;">可选的collate子句可用于显式指定排序规则。如果给定，则排序规则必须是字符集名称允许的排序规则之一。</p><p>
                <em class="replaceable"><code>charset_name</code></em> and
                <em class="replaceable"><code>collation_name</code></em> may be quoted or
                unquoted.
            </p><p style="color:blue;">字符集名称和排序规则名称可以加引号或不加引号。</p><p>
                The default mapping can be restored by using a value of
                <code class="literal">DEFAULT</code>. The default depends on the server
                configuration.
            </p><p style="color:blue;">可以使用默认值还原默认映射。默认值取决于服务器配置。</p><p>
                Some character sets cannot be used as the client character set.
                Attempting to use them with <a class="link" href="sql-syntax.html#set-names" title="13.7.4.3&nbsp;SET NAMES Syntax"><code class="literal">SET
                NAMES</code></a> produces an error. See
                <a class="xref" href="charset.html#charset-connection-impermissible-client-charset" title="Impermissible Client Character Sets">Impermissible Client Character Sets</a>.
            </p><p style="color:blue;">某些字符集不能用作客户端字符集。尝试将它们与集合名称一起使用会产生错误。请参见不允许的客户端字符集。</p>
            </div>

        </div>
        <div class="section">
            <div class="titlepage">
                <div>
                    <div>
                        <h3 class="title"><a name="show"></a>13.7.5&nbsp;SHOW Syntax</h3>

                    </div>

                </div>

            </div>
            <div class="toc">
                <dl class="toc"><dt><span class="section"><a href="sql-syntax.html#show-binary-logs">13.7.5.1 SHOW BINARY LOGS Syntax</a></span></dt><dt><span class="section"><a href="sql-syntax.html#show-binlog-events">13.7.5.2 SHOW BINLOG EVENTS Syntax</a></span></dt><dt><span class="section"><a href="sql-syntax.html#show-character-set">13.7.5.3 SHOW CHARACTER SET Syntax</a></span></dt><dt><span class="section"><a href="sql-syntax.html#show-collation">13.7.5.4 SHOW COLLATION Syntax</a></span></dt><dt><span class="section"><a href="sql-syntax.html#show-columns">13.7.5.5 SHOW COLUMNS Syntax</a></span></dt><dt><span class="section"><a href="sql-syntax.html#show-create-database">13.7.5.6 SHOW CREATE DATABASE Syntax</a></span></dt><dt><span class="section"><a href="sql-syntax.html#show-create-event">13.7.5.7 SHOW CREATE EVENT Syntax</a></span></dt><dt><span class="section"><a href="sql-syntax.html#show-create-function">13.7.5.8 SHOW CREATE FUNCTION Syntax</a></span></dt><dt><span class="section"><a href="sql-syntax.html#show-create-procedure">13.7.5.9 SHOW CREATE PROCEDURE Syntax</a></span></dt><dt><span class="section"><a href="sql-syntax.html#show-create-table">13.7.5.10 SHOW CREATE TABLE Syntax</a></span></dt><dt><span class="section"><a href="sql-syntax.html#show-create-trigger">13.7.5.11 SHOW CREATE TRIGGER Syntax</a></span></dt><dt><span class="section"><a href="sql-syntax.html#show-create-user">13.7.5.12 SHOW CREATE USER Syntax</a></span></dt><dt><span class="section"><a href="sql-syntax.html#show-create-view">13.7.5.13 SHOW CREATE VIEW Syntax</a></span></dt><dt><span class="section"><a href="sql-syntax.html#show-databases">13.7.5.14 SHOW DATABASES Syntax</a></span></dt><dt><span class="section"><a href="sql-syntax.html#show-engine">13.7.5.15 SHOW ENGINE Syntax</a></span></dt><dt><span class="section"><a href="sql-syntax.html#show-engines">13.7.5.16 SHOW ENGINES Syntax</a></span></dt><dt><span class="section"><a href="sql-syntax.html#show-errors">13.7.5.17 SHOW ERRORS Syntax</a></span></dt><dt><span class="section"><a href="sql-syntax.html#show-events">13.7.5.18 SHOW EVENTS Syntax</a></span></dt><dt><span class="section"><a href="sql-syntax.html#show-function-code">13.7.5.19 SHOW FUNCTION CODE Syntax</a></span></dt><dt><span class="section"><a href="sql-syntax.html#show-function-status">13.7.5.20 SHOW FUNCTION STATUS Syntax</a></span></dt><dt><span class="section"><a href="sql-syntax.html#show-grants">13.7.5.21 SHOW GRANTS Syntax</a></span></dt><dt><span class="section"><a href="sql-syntax.html#show-index">13.7.5.22 SHOW INDEX Syntax</a></span></dt><dt><span class="section"><a href="sql-syntax.html#show-master-status">13.7.5.23 SHOW MASTER STATUS Syntax</a></span></dt><dt><span class="section"><a href="sql-syntax.html#show-open-tables">13.7.5.24 SHOW OPEN TABLES Syntax</a></span></dt><dt><span class="section"><a href="sql-syntax.html#show-plugins">13.7.5.25 SHOW PLUGINS Syntax</a></span></dt><dt><span class="section"><a href="sql-syntax.html#show-privileges">13.7.5.26 SHOW PRIVILEGES Syntax</a></span></dt><dt><span class="section"><a href="sql-syntax.html#show-procedure-code">13.7.5.27 SHOW PROCEDURE CODE Syntax</a></span></dt><dt><span class="section"><a href="sql-syntax.html#show-procedure-status">13.7.5.28 SHOW PROCEDURE STATUS Syntax</a></span></dt><dt><span class="section"><a href="sql-syntax.html#show-processlist">13.7.5.29 SHOW PROCESSLIST Syntax</a></span></dt><dt><span class="section"><a href="sql-syntax.html#show-profile">13.7.5.30 SHOW PROFILE Syntax</a></span></dt><dt><span class="section"><a href="sql-syntax.html#show-profiles">13.7.5.31 SHOW PROFILES Syntax</a></span></dt><dt><span class="section"><a href="sql-syntax.html#show-relaylog-events">13.7.5.32 SHOW RELAYLOG EVENTS Syntax</a></span></dt><dt><span class="section"><a href="sql-syntax.html#show-slave-hosts">13.7.5.33 SHOW SLAVE HOSTS Syntax</a></span></dt><dt><span class="section"><a href="sql-syntax.html#show-slave-status">13.7.5.34 SHOW SLAVE STATUS Syntax</a></span></dt><dt><span class="section"><a href="sql-syntax.html#show-status">13.7.5.35 SHOW STATUS Syntax</a></span></dt><dt><span class="section"><a href="sql-syntax.html#show-table-status">13.7.5.36 SHOW TABLE STATUS Syntax</a></span></dt><dt><span class="section"><a href="sql-syntax.html#show-tables">13.7.5.37 SHOW TABLES Syntax</a></span></dt><dt><span class="section"><a href="sql-syntax.html#show-triggers">13.7.5.38 SHOW TRIGGERS Syntax</a></span></dt><dt><span class="section"><a href="sql-syntax.html#show-variables">13.7.5.39 SHOW VARIABLES Syntax</a></span></dt><dt><span class="section"><a href="sql-syntax.html#show-warnings">13.7.5.40 SHOW WARNINGS Syntax</a></span></dt></dl>
            </div>
            <a class="indexterm" name="idm140286827899872"></a><a class="indexterm" name="idm140286827897056"></a><a class="indexterm" name="idm140286827895568"></a><a class="indexterm" name="idm140286827894480"></a><a class="indexterm" name="idm140286827893392"></a><a class="indexterm" name="idm140286827892304"></a><a class="indexterm" name="idm140286827891216"></a><a class="indexterm" name="idm140286827890144"></a><a class="indexterm" name="idm140286827889056"></a><a class="indexterm" name="idm140286827887968"></a><a class="indexterm" name="idm140286827886880"></a><a class="indexterm" name="idm140286827885792"></a><a class="indexterm" name="idm140286827884704"></a><a class="indexterm" name="idm140286827883616"></a><a class="indexterm" name="idm140286827882528"></a><a class="indexterm" name="idm140286827881440"></a><a class="indexterm" name="idm140286827880352"></a><a class="indexterm" name="idm140286827879280"></a><a class="indexterm" name="idm140286827878208"></a><a class="indexterm" name="idm140286827877136"></a><a class="indexterm" name="idm140286827876064"></a><a class="indexterm" name="idm140286827874992"></a><a class="indexterm" name="idm140286827873904"></a><a class="indexterm" name="idm140286827872816"></a><a class="indexterm" name="idm140286827871744"></a><a class="indexterm" name="idm140286827870672"></a><a class="indexterm" name="idm140286827869600"></a><a class="indexterm" name="idm140286827868512"></a><a class="indexterm" name="idm140286827867424"></a><a class="indexterm" name="idm140286827866336"></a><a class="indexterm" name="idm140286827865264"></a><a class="indexterm" name="idm140286827864176"></a><a class="indexterm" name="idm140286827863088"></a><a class="indexterm" name="idm140286827862000"></a><a class="indexterm" name="idm140286827860912"></a><a class="indexterm" name="idm140286827859840"></a><a class="indexterm" name="idm140286827858768"></a><a class="indexterm" name="idm140286827857680"></a><a class="indexterm" name="idm140286827856592"></a><a class="indexterm" name="idm140286827855504"></a><a class="indexterm" name="idm140286827854432"></a><a class="indexterm" name="idm140286827853360"></a><a class="indexterm" name="idm140286827852272"></a><a class="indexterm" name="idm140286827851200"></a><a class="indexterm" name="idm140286827850112"></a><p>
            <a class="link" href="sql-syntax.html#show" title="13.7.5&nbsp;SHOW Syntax"><code class="literal">SHOW</code></a> has many forms that provide
            information about databases, tables, columns, or status
            information about the server. This section describes those
            following:
        </p><p style="color:blue;">show有许多表单提供有关数据库、表、列或服务器状态信息的信息。本节介绍以下内容：</p><pre data-lang="sql" class="programlisting">SHOW {BINARY | MASTER} LOGS
SHOW BINLOG EVENTS [IN '<em class="replaceable"><code>log_name</code></em>'] [FROM <em class="replaceable"><code>pos</code></em>] [LIMIT [<em class="replaceable"><code>offset</code></em>,] <em class="replaceable"><code>row_count</code></em>]
SHOW CHARACTER SET [<em class="replaceable"><code>like_or_where</code></em>]
SHOW COLLATION [<em class="replaceable"><code>like_or_where</code></em>]
SHOW [FULL] COLUMNS FROM <em class="replaceable"><code>tbl_name</code></em> [FROM <em class="replaceable"><code>db_name</code></em>] [<em class="replaceable"><code>like_or_where</code></em>]
SHOW CREATE DATABASE <em class="replaceable"><code>db_name</code></em>
SHOW CREATE EVENT <em class="replaceable"><code>event_name</code></em>
SHOW CREATE FUNCTION <em class="replaceable"><code>func_name</code></em>
SHOW CREATE PROCEDURE <em class="replaceable"><code>proc_name</code></em>
SHOW CREATE TABLE <em class="replaceable"><code>tbl_name</code></em>
SHOW CREATE TRIGGER <em class="replaceable"><code>trigger_name</code></em>
SHOW CREATE VIEW <em class="replaceable"><code>view_name</code></em>
SHOW DATABASES [<em class="replaceable"><code>like_or_where</code></em>]
SHOW ENGINE <em class="replaceable"><code>engine_name</code></em> {STATUS | MUTEX}
SHOW [STORAGE] ENGINES
SHOW ERRORS [LIMIT [<em class="replaceable"><code>offset</code></em>,] <em class="replaceable"><code>row_count</code></em>]
SHOW EVENTS
SHOW FUNCTION CODE <em class="replaceable"><code>func_name</code></em>
SHOW FUNCTION STATUS [<em class="replaceable"><code>like_or_where</code></em>]
SHOW GRANTS FOR <em class="replaceable"><code>user</code></em>
SHOW INDEX FROM <em class="replaceable"><code>tbl_name</code></em> [FROM <em class="replaceable"><code>db_name</code></em>]
SHOW MASTER STATUS
SHOW OPEN TABLES [FROM <em class="replaceable"><code>db_name</code></em>] [<em class="replaceable"><code>like_or_where</code></em>]
SHOW PLUGINS
SHOW PROCEDURE CODE <em class="replaceable"><code>proc_name</code></em>
SHOW PROCEDURE STATUS [<em class="replaceable"><code>like_or_where</code></em>]
SHOW PRIVILEGES
SHOW [FULL] PROCESSLIST
SHOW PROFILE [<em class="replaceable"><code>types</code></em>] [FOR QUERY <em class="replaceable"><code>n</code></em>] [OFFSET <em class="replaceable"><code>n</code></em>] [LIMIT <em class="replaceable"><code>n</code></em>]
SHOW PROFILES
SHOW RELAYLOG EVENTS [IN '<em class="replaceable"><code>log_name</code></em>'] [FROM <em class="replaceable"><code>pos</code></em>] [LIMIT [<em class="replaceable"><code>offset</code></em>,] <em class="replaceable"><code>row_count</code></em>]
SHOW SLAVE HOSTS
SHOW SLAVE STATUS [FOR CHANNEL <em class="replaceable"><code>channel</code></em>]
SHOW [GLOBAL | SESSION] STATUS [<em class="replaceable"><code>like_or_where</code></em>]
SHOW TABLE STATUS [FROM <em class="replaceable"><code>db_name</code></em>] [<em class="replaceable"><code>like_or_where</code></em>]
SHOW [FULL] TABLES [FROM <em class="replaceable"><code>db_name</code></em>] [<em class="replaceable"><code>like_or_where</code></em>]
SHOW TRIGGERS [FROM <em class="replaceable"><code>db_name</code></em>] [<em class="replaceable"><code>like_or_where</code></em>]
SHOW [GLOBAL | SESSION] VARIABLES [<em class="replaceable"><code>like_or_where</code></em>]
SHOW WARNINGS [LIMIT [<em class="replaceable"><code>offset</code></em>,] <em class="replaceable"><code>row_count</code></em>]

<em class="replaceable"><code>like_or_where</code></em>:
    LIKE '<em class="replaceable"><code>pattern</code></em>'
  | WHERE <em class="replaceable"><code>expr</code></em>
</pre><p>
            If the syntax for a given <a class="link" href="sql-syntax.html#show" title="13.7.5&nbsp;SHOW Syntax"><code class="literal">SHOW</code></a>
            statement includes a <a class="link" href="functions.html#operator_like"><code class="literal">LIKE
            '<em class="replaceable"><code>pattern</code></em>'</code></a> part,
            <code class="literal">'<em class="replaceable"><code>pattern</code></em>'</code> is a
            string that can contain the SQL <code class="literal">%</code> and
            <code class="literal">_</code> wildcard characters. The pattern is useful
            for restricting statement output to matching values.
        </p><p style="color:blue;">如果给定show语句的语法包含类似的“pattern”部分，“pattern”是一个字符串，可以包含sql%和通配符。该模式用于将语句输出限制为匹配的值。</p><p>
            Several <a class="link" href="sql-syntax.html#show" title="13.7.5&nbsp;SHOW Syntax"><code class="literal">SHOW</code></a> statements also accept
            a <code class="literal">WHERE</code> clause that provides more flexibility
            in specifying which rows to display. See
            <a class="xref" href="information-schema.html#extended-show" title="24.35&nbsp;Extensions to SHOW Statements">Section&nbsp;24.35, “Extensions to SHOW Statements”</a>.
        </p><p style="color:blue;">几个显示语句也接受WHERE子句，它在指定要显示哪些行时提供了更大的灵活性。见第24.35节“显示语句的扩展”。</p><p>
            Many MySQL APIs (such as PHP) enable you to treat the result
            returned from a <a class="link" href="sql-syntax.html#show" title="13.7.5&nbsp;SHOW Syntax"><code class="literal">SHOW</code></a> statement as
            you would a result set from a
            <a class="link" href="sql-syntax.html#select" title="13.2.9&nbsp;SELECT Syntax"><code class="literal">SELECT</code></a>; see
            <a class="xref" href="connectors-apis.html" title="Chapter&nbsp;27&nbsp;Connectors and APIs">Chapter&nbsp;27, <i>Connectors and APIs</i></a>, or your API documentation for
            more information. In addition, you can work in SQL with results
            from queries on tables in the
            <code class="literal">INFORMATION_SCHEMA</code> database, which you cannot
            easily do with results from <a class="link" href="sql-syntax.html#show" title="13.7.5&nbsp;SHOW Syntax"><code class="literal">SHOW</code></a>
            statements. See <a class="xref" href="information-schema.html" title="Chapter&nbsp;24&nbsp;INFORMATION_SCHEMA Tables">Chapter&nbsp;24, <i>INFORMATION_SCHEMA Tables</i></a>.
        </p><p style="color:blue;">许多mysql api（如php）使您能够像处理select的结果集一样处理show语句返回的结果；有关更多信息，请参阅第27章，连接器和api或api文档。此外，您还可以在sql中处理information_schema数据库中表查询的结果，而show语句的结果很难处理这些结果。见第24章，信息模式表。</p>
            <div class="section">

                <div class="titlepage">
                    <div>
                        <div>
                            <h4 class="title"><a name="show-binary-logs"></a>13.7.5.1&nbsp;SHOW BINARY LOGS Syntax</h4>
                        </div>
                    </div>
                </div>
                <a class="indexterm" name="idm140286827803968"></a><a class="indexterm" name="idm140286827802880"></a><pre data-lang="sql" class="programlisting">SHOW BINARY LOGS
SHOW MASTER LOGS
</pre><p>
                Lists the binary log files on the server. This statement is used
                as part of the procedure described in
                <a class="xref" href="sql-syntax.html#purge-binary-logs" title="13.4.1.1&nbsp;PURGE BINARY LOGS Syntax">Section&nbsp;13.4.1.1, “PURGE BINARY LOGS Syntax”</a>, that shows how to determine
                which logs can be purged. A user with the
                <a class="link" href="security.html#priv_super"><code class="literal">SUPER</code></a> or
                <a class="link" href="security.html#priv_replication-client"><code class="literal">REPLICATION CLIENT</code></a> privilege may
                execute this statement.
            </p><p style="color:blue;">列出服务器上的二进制日志文件。此语句用作第13.4.1.1节“清除二进制日志语法”中描述的过程的一部分，该部分说明如何确定可以清除哪些日志。具有超级或复制客户端权限的用户可以执行此语句。</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>SHOW BINARY LOGS;</code></strong>
+---------------+-----------+
| Log_name      | File_size |
+---------------+-----------+
| binlog.000015 |    724935 |
| binlog.000016 |    733481 |
+---------------+-----------+
</pre><p>
                <a class="link" href="sql-syntax.html#show-binary-logs" title="13.7.5.1&nbsp;SHOW BINARY LOGS Syntax"><code class="literal">SHOW MASTER
                    LOGS</code></a> is equivalent to <a class="link" href="sql-syntax.html#show-binary-logs" title="13.7.5.1&nbsp;SHOW BINARY LOGS Syntax"><code class="literal">SHOW BINARY
                LOGS</code></a>.
            </p><p style="color:blue;">显示主日志等同于显示二进制日志。</p>
            </div>
            <div class="section">
                <div class="titlepage">
                    <div>
                        <div>
                            <h4 class="title"><a name="show-binlog-events"></a>13.7.5.2&nbsp;SHOW BINLOG EVENTS Syntax</h4>

                        </div>

                    </div>

                </div>
                <a class="indexterm" name="idm140286827787216"></a><pre data-lang="sql" class="programlisting">SHOW BINLOG EVENTS
   [IN '<em class="replaceable"><code>log_name</code></em>']
   [FROM <em class="replaceable"><code>pos</code></em>]
   [LIMIT [<em class="replaceable"><code>offset</code></em>,] <em class="replaceable"><code>row_count</code></em>]
</pre><p>
                Shows the events in the binary log. If you do not specify
                <code class="literal">'<em class="replaceable"><code>log_name</code></em>'</code>, the
                first binary log is displayed. <a class="link" href="sql-syntax.html#show-binlog-events" title="13.7.5.2&nbsp;SHOW BINLOG EVENTS Syntax"><code class="literal">SHOW BINLOG
                EVENTS</code></a> requires the <a class="link" href="security.html#priv_replication-slave"><code class="literal">REPLICATION
                SLAVE</code></a> privilege.
            </p><p style="color:blue;">显示二进制日志中的事件。如果未指定“日志名称”，则显示第一个二进制日志。show binlog events需要复制从属权限。</p><p>
                The <code class="literal">LIMIT</code> clause has the same syntax as for
                the <a class="link" href="sql-syntax.html#select" title="13.2.9&nbsp;SELECT Syntax"><code class="literal">SELECT</code></a> statement. See
                <a class="xref" href="sql-syntax.html#select" title="13.2.9&nbsp;SELECT Syntax">Section&nbsp;13.2.9, “SELECT Syntax”</a>.
            </p><p style="color:blue;">LIMIT子句的语法与SELECT语句的语法相同。参见第13.2.9节“选择语法”。</p>
                <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">

                    <div class="admon-title">
                        Note
                    </div>
                    <p>
                        Issuing a <a class="link" href="sql-syntax.html#show-binlog-events" title="13.7.5.2&nbsp;SHOW BINLOG EVENTS Syntax"><code class="literal">SHOW BINLOG EVENTS</code></a>
                        with no <code class="literal">LIMIT</code> clause could start a very
                        time- and resource-consuming process because the server
                        returns to the client the complete contents of the binary log
                        (which includes all statements executed by the server that
                        modify data). As an alternative to <a class="link" href="sql-syntax.html#show-binlog-events" title="13.7.5.2&nbsp;SHOW BINLOG EVENTS Syntax"><code class="literal">SHOW
                        BINLOG EVENTS</code></a>, use the
                        <a class="link" href="programs.html#mysqlbinlog" title="4.6.7&nbsp;mysqlbinlog — Utility for Processing Binary Log Files"><span class="command"><strong>mysqlbinlog</strong></span></a> utility to save the binary log
                        to a text file for later examination and analysis. See
                        <a class="xref" href="programs.html#mysqlbinlog" title="4.6.7&nbsp;mysqlbinlog — Utility for Processing Binary Log Files">Section&nbsp;4.6.7, “<span class="command"><strong>mysqlbinlog</strong></span> — Utility for Processing Binary Log Files”</a>.
                    </p><p style="color:blue;">发出show binlog events without no limit子句可能会启动一个非常耗时且耗费资源的过程，因为服务器将二进制日志的完整内容（包括服务器执行的所有修改数据的语句）返回给客户端。作为显示binlog事件的另一种方法，可以使用mysqlbinlog实用程序将二进制日志保存到文本文件中，以便以后进行检查和分析。参见4.6.7节，“mysqlbinlog-处理二进制日志文件的实用程序”。</p>
                </div>
                <p>
                    <a class="link" href="sql-syntax.html#show-binlog-events" title="13.7.5.2&nbsp;SHOW BINLOG EVENTS Syntax"><code class="literal">SHOW BINLOG EVENTS</code></a> displays the
                    following fields for each event in the binary log:
                </p><p style="color:blue;">show binlog events显示二进制日志中每个事件的以下字段：</p>
                <div class="itemizedlist">
                    <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                        <code class="literal">Log_name</code>
                    </p><p style="color:blue;">日志名称</p><p>
                        The name of the file that is being listed.
                    </p><p style="color:blue;">正在列出的文件的名称。</p></li><li class="listitem"><p>
                        <code class="literal">Pos</code>
                    </p><p style="color:blue;">销售时点情报系统</p><p>
                        The position at which the event occurs.
                    </p><p style="color:blue;">事件发生的位置。</p></li><li class="listitem"><p>
                        <code class="literal">Event_type</code>
                    </p><p style="color:blue;">事件类型</p><p>
                        An identifier that describes the event type.
                    </p><p style="color:blue;">描述事件类型的标识符。</p></li><li class="listitem"><p>
                        <code class="literal">Server_id</code>
                    </p><p style="color:blue;">服务器ID</p><p>
                        The server ID of the server on which the event originated.
                    </p><p style="color:blue;">发起事件的服务器的服务器ID。</p></li><li class="listitem"><p>
                        <code class="literal">End_log_pos</code>
                    </p><p style="color:blue;">结束日志位置</p><p>
                        The position at which the next event begins, which is equal
                        to <code class="literal">Pos</code> plus the size of the event.
                    </p><p style="color:blue;">下一个事件开始的位置，等于pos加上事件的大小。</p></li><li class="listitem"><p>
                        <code class="literal">Info</code>
                    </p><p style="color:blue;">信息</p><p>
                        More detailed information about the event type. The format
                        of this information depends on the event type.
                    </p><p style="color:blue;">有关事件类型的详细信息。此信息的格式取决于事件类型。</p></li></ul>
                </div>
                <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">
                    <div class="admon-title">
                        Note
                    </div>
                    <p>
                        Some events relating to the setting of user and system
                        variables are not included in the output from
                        <a class="link" href="sql-syntax.html#show-binlog-events" title="13.7.5.2&nbsp;SHOW BINLOG EVENTS Syntax"><code class="literal">SHOW BINLOG EVENTS</code></a>. To get
                        complete coverage of events within a binary log, use
                        <a class="link" href="programs.html#mysqlbinlog" title="4.6.7&nbsp;mysqlbinlog — Utility for Processing Binary Log Files"><span class="command"><strong>mysqlbinlog</strong></span></a>.
                    </p><p style="color:blue;">与用户和系统变量设置相关的一些事件不包含在show binlog事件的输出中。要获得二进制日志中事件的完整覆盖率，请使用mysqlbinlog。</p>
                </div>
                <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">
                    <div class="admon-title">
                        Note
                    </div>
                    <p>
                        <a class="link" href="sql-syntax.html#show-binlog-events" title="13.7.5.2&nbsp;SHOW BINLOG EVENTS Syntax"><code class="literal">SHOW BINLOG EVENTS</code></a> does
                        <span class="emphasis"><em>not</em></span> work with relay log files. You can
                        use <a class="link" href="sql-syntax.html#show-relaylog-events" title="13.7.5.32&nbsp;SHOW RELAYLOG EVENTS Syntax"><code class="literal">SHOW RELAYLOG EVENTS</code></a> for
                        this purpose.
                    </p><p style="color:blue;">show binlog events不适用于中继日志文件。您可以为此目的使用show relaylog事件。</p>
                </div>

            </div>
            <div class="section">
                <div class="titlepage">
                    <div>
                        <div>
                            <h4 class="title"><a name="show-character-set"></a>13.7.5.3&nbsp;SHOW CHARACTER SET Syntax</h4>

                        </div>

                    </div>

                </div>
                <a class="indexterm" name="idm140286827744112"></a><pre data-lang="sql" class="programlisting">SHOW CHARACTER SET
    [LIKE '<em class="replaceable"><code>pattern</code></em>' | WHERE <em class="replaceable"><code>expr</code></em>]
</pre><p>
                The <a class="link" href="sql-syntax.html#show-character-set" title="13.7.5.3&nbsp;SHOW CHARACTER SET Syntax"><code class="literal">SHOW CHARACTER SET</code></a> statement
                shows all available character sets. The
                <a class="link" href="functions.html#operator_like"><code class="literal">LIKE</code></a> clause, if present, indicates
                which character set names to match. The <code class="literal">WHERE</code>
                clause can be given to select rows using more general
                conditions, as discussed in <a class="xref" href="information-schema.html#extended-show" title="24.35&nbsp;Extensions to SHOW Statements">Section&nbsp;24.35, “Extensions to SHOW Statements”</a>. For
                example:
            </p><p style="color:blue;">show character set语句显示所有可用的字符集。LIKE子句（如果存在）指示要匹配的字符集名称。where子句可用于使用更一般的条件选择行，如第24.35节“显示语句的扩展”所述。例如：</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>SHOW CHARACTER SET LIKE 'latin%';</code></strong>
+---------+-----------------------------+-------------------+--------+
| Charset | Description                 | Default collation | Maxlen |
+---------+-----------------------------+-------------------+--------+
| latin1  | cp1252 West European        | latin1_swedish_ci |      1 |
| latin2  | ISO 8859-2 Central European | latin2_general_ci |      1 |
| latin5  | ISO 8859-9 Turkish          | latin5_turkish_ci |      1 |
| latin7  | ISO 8859-13 Baltic          | latin7_general_ci |      1 |
+---------+-----------------------------+-------------------+--------+
</pre><p>
                <a class="link" href="sql-syntax.html#show-character-set" title="13.7.5.3&nbsp;SHOW CHARACTER SET Syntax"><code class="literal">SHOW CHARACTER SET</code></a> output has
                these columns:
            </p><p style="color:blue;">显示字符集输出具有以下列：</p>
                <div class="itemizedlist">
                    <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                        <code class="literal">Charset</code>
                    </p><p style="color:blue;">字符集</p><p>
                        The character set name.
                    </p><p style="color:blue;">字符集名称。</p></li><li class="listitem"><p>
                        <code class="literal">Description</code>
                    </p><p style="color:blue;">说明</p><p>
                        A description of the character set.
                    </p><p style="color:blue;">字符集的描述。</p></li><li class="listitem"><p>
                        <code class="literal">Default collation</code>
                    </p><p style="color:blue;">缺省校对</p><p>
                        The default collation for the character set.
                    </p><p style="color:blue;">字符集的默认排序规则。</p></li><li class="listitem"><p>
                        <code class="literal">Maxlen</code>
                    </p><p style="color:blue;">马克斯伦</p><p>
                        The maximum number of bytes required to store one character.
                    </p><p style="color:blue;">存储一个字符所需的最大字节数。</p></li></ul>
                </div>
                <p>
                    The <code class="literal">filename</code> character set is for internal
                    use only; consequently, <a class="link" href="sql-syntax.html#show-character-set" title="13.7.5.3&nbsp;SHOW CHARACTER SET Syntax"><code class="literal">SHOW CHARACTER
                    SET</code></a> does not display it.
                </p><p style="color:blue;">文件名字符集仅供内部使用；因此，“显示字符集”不显示它。</p><p>
                Character set information is also available from the
                <code class="literal">INFORMATION_SCHEMA</code>
                <a class="link" href="information-schema.html#character-sets-table" title="24.2&nbsp;The INFORMATION_SCHEMA CHARACTER_SETS Table"><code class="literal">CHARACTER_SETS</code></a> table. See
                <a class="xref" href="information-schema.html#character-sets-table" title="24.2&nbsp;The INFORMATION_SCHEMA CHARACTER_SETS Table">Section&nbsp;24.2, “The INFORMATION_SCHEMA CHARACTER_SETS Table”</a>.
            </p><p style="color:blue;">字符集信息也可以从信息架构字符集表中获得。参见第24.2节“信息模式字符设置表”。</p>
            </div>
            <div class="section">
                <div class="titlepage">
                    <div>
                        <div>
                            <h4 class="title"><a name="show-collation"></a>13.7.5.4&nbsp;SHOW COLLATION Syntax</h4>

                        </div>

                    </div>

                </div>
                <a class="indexterm" name="idm140286827715008"></a><pre data-lang="sql" class="programlisting">SHOW COLLATION
    [LIKE '<em class="replaceable"><code>pattern</code></em>' | WHERE <em class="replaceable"><code>expr</code></em>]
</pre><p>
                This statement lists collations supported by the server. By
                default, the output from <a class="link" href="sql-syntax.html#show-collation" title="13.7.5.4&nbsp;SHOW COLLATION Syntax"><code class="literal">SHOW
                COLLATION</code></a> includes all available collations. The
                <a class="link" href="functions.html#operator_like"><code class="literal">LIKE</code></a> clause, if present, indicates
                which collation names to match. The <code class="literal">WHERE</code>
                clause can be given to select rows using more general
                conditions, as discussed in <a class="xref" href="information-schema.html#extended-show" title="24.35&nbsp;Extensions to SHOW Statements">Section&nbsp;24.35, “Extensions to SHOW Statements”</a>. For
                example:
            </p><p style="color:blue;">此语句列出服务器支持的排序规则。默认情况下，显示排序规则的输出包括所有可用的排序规则。LIKE子句（如果存在）指示要匹配的排序规则名称。where子句可用于使用更一般的条件选择行，如第24.35节“显示语句的扩展”所述。例如：</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>SHOW COLLATION WHERE Charset = 'latin1';</code></strong>
+-------------------+---------+----+---------+----------+---------+
| Collation         | Charset | Id | Default | Compiled | Sortlen |
+-------------------+---------+----+---------+----------+---------+
| latin1_german1_ci | latin1  |  5 |         | Yes      |       1 |
| latin1_swedish_ci | latin1  |  8 | Yes     | Yes      |       1 |
| latin1_danish_ci  | latin1  | 15 |         | Yes      |       1 |
| latin1_german2_ci | latin1  | 31 |         | Yes      |       2 |
| latin1_bin        | latin1  | 47 |         | Yes      |       1 |
| latin1_general_ci | latin1  | 48 |         | Yes      |       1 |
| latin1_general_cs | latin1  | 49 |         | Yes      |       1 |
| latin1_spanish_ci | latin1  | 94 |         | Yes      |       1 |
+-------------------+---------+----+---------+----------+---------+
</pre><p>
                <a class="link" href="sql-syntax.html#show-collation" title="13.7.5.4&nbsp;SHOW COLLATION Syntax"><code class="literal">SHOW COLLATION</code></a> output has these
                columns:
            </p><p style="color:blue;">显示排序规则输出具有以下列：</p>
                <div class="itemizedlist">
                    <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                        <code class="literal">Collation</code>
                    </p><p style="color:blue;">校勘</p><p>
                        The collation name.
                    </p><p style="color:blue;">排序规则名称。</p></li><li class="listitem"><p>
                        <code class="literal">Charset</code>
                    </p><p style="color:blue;">字符集</p><p>
                        The name of the character set with which the collation is
                        associated.
                    </p><p style="color:blue;">与排序规则关联的字符集的名称。</p></li><li class="listitem"><p>
                        <code class="literal">Id</code>
                    </p><p style="color:blue;">身份证件</p><p>
                        The collation ID.
                    </p><p style="color:blue;">排序规则ID。</p></li><li class="listitem"><p>
                        <code class="literal">Default</code>
                    </p><p style="color:blue;">默认</p><p>
                        Whether the collation is the default for its character set.
                    </p><p style="color:blue;">排序规则是否为其字符集的默认值。</p></li><li class="listitem"><p>
                        <code class="literal">Compiled</code>
                    </p><p style="color:blue;">编译的</p><p>
                        Whether the character set is compiled into the server.
                    </p><p style="color:blue;">是否将字符集编译到服务器中。</p></li><li class="listitem"><p>
                        <code class="literal">Sortlen</code>
                    </p><p style="color:blue;">索特伦</p><p>
                        This is related to the amount of memory required to sort
                        strings expressed in the character set.
                    </p><p style="color:blue;">这与对字符集中表示的字符串进行排序所需的内存量有关。</p></li></ul>
                </div>
                <p>
                    To see the default collation for each character set, use the
                    following statement. <code class="literal">Default</code> is a reserved
                    word, so to use it as an identifier, it must be quoted as such:
                </p><p style="color:blue;">要查看每个字符集的默认排序规则，请使用以下语句。默认值是保留字，因此要将其用作标识符，必须将其引用为：</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>SHOW COLLATION WHERE `Default` = 'Yes';</code></strong>
+---------------------+----------+----+---------+----------+---------+
| Collation           | Charset  | Id | Default | Compiled | Sortlen |
+---------------------+----------+----+---------+----------+---------+
| big5_chinese_ci     | big5     |  1 | Yes     | Yes      |       1 |
| dec8_swedish_ci     | dec8     |  3 | Yes     | Yes      |       1 |
| cp850_general_ci    | cp850    |  4 | Yes     | Yes      |       1 |
| hp8_english_ci      | hp8      |  6 | Yes     | Yes      |       1 |
| koi8r_general_ci    | koi8r    |  7 | Yes     | Yes      |       1 |
| latin1_swedish_ci   | latin1   |  8 | Yes     | Yes      |       1 |
...
</pre><p>
                Collation information is also available from the
                <code class="literal">INFORMATION_SCHEMA</code>
                <a class="link" href="information-schema.html#collations-table" title="24.3&nbsp;The INFORMATION_SCHEMA COLLATIONS Table"><code class="literal">COLLATIONS</code></a> table. See
                <a class="xref" href="information-schema.html#collations-table" title="24.3&nbsp;The INFORMATION_SCHEMA COLLATIONS Table">Section&nbsp;24.3, “The INFORMATION_SCHEMA COLLATIONS Table”</a>.
            </p><p style="color:blue;">排序规则信息也可以从信息架构排序规则表中获得。参见第24.3节“信息模式排序表”。</p>
            </div>
            <div class="section">
                <div class="titlepage">
                    <div>
                        <div>
                            <h4 class="title"><a name="show-columns"></a>13.7.5.5&nbsp;SHOW COLUMNS Syntax</h4>

                        </div>

                    </div>

                </div>
                <a class="indexterm" name="idm140286827680496"></a><a class="indexterm" name="idm140286827677680"></a><a class="indexterm" name="idm140286827676608"></a><pre data-lang="sql" class="programlisting">SHOW [FULL] {COLUMNS | FIELDS}
    {FROM | IN} <em class="replaceable"><code>tbl_name</code></em>
    [{FROM | IN} <em class="replaceable"><code>db_name</code></em>]
    [LIKE '<em class="replaceable"><code>pattern</code></em>' | WHERE <em class="replaceable"><code>expr</code></em>]
</pre><p>
                <a class="link" href="sql-syntax.html#show-columns" title="13.7.5.5&nbsp;SHOW COLUMNS Syntax"><code class="literal">SHOW COLUMNS</code></a> displays information
                about the columns in a given table. It also works for views.
                <a class="link" href="sql-syntax.html#show-columns" title="13.7.5.5&nbsp;SHOW COLUMNS Syntax"><code class="literal">SHOW COLUMNS</code></a> displays information
                only for those columns for which you have some privilege.
            </p><p style="color:blue;">显示列显示有关给定表中列的信息。它也适用于视图。“显示列”仅显示您具有某些特权的列的信息。</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>SHOW COLUMNS FROM City;</code></strong>
+-------------+----------+------+-----+---------+----------------+
| Field       | Type     | Null | Key | Default | Extra          |
+-------------+----------+------+-----+---------+----------------+
| ID          | int(11)  | NO   | PRI | NULL    | auto_increment |
| Name        | char(35) | NO   |     |         |                |
| CountryCode | char(3)  | NO   | MUL |         |                |
| District    | char(20) | NO   |     |         |                |
| Population  | int(11)  | NO   |     | 0       |                |
+-------------+----------+------+-----+---------+----------------+
</pre><p>
                An alternative to <code class="literal"><em class="replaceable"><code>tbl_name</code></em>
                FROM <em class="replaceable"><code>db_name</code></em></code> syntax is
                <em class="replaceable"><code>db_name.tbl_name</code></em>. These two
                statements are equivalent:
            </p><p style="color:blue;">db_name语法中tbl_name的另一种选择是db_name.tbl_name。这两种说法是等价的：</p><pre data-lang="sql" class="programlisting">SHOW COLUMNS FROM mytable FROM mydb;
SHOW COLUMNS FROM mydb.mytable;
</pre><p>
                The optional <code class="literal">FULL</code> keyword causes the output
                to include the column collation and comments, as well as the
                privileges you have for each column.
            </p><p style="color:blue;">可选的full关键字使输出包含列排序规则和注释，以及您对每一列的权限。</p><p>
                The <a class="link" href="functions.html#operator_like"><code class="literal">LIKE</code></a> clause, if present,
                indicates which column names to match. The
                <code class="literal">WHERE</code> clause can be given to select rows
                using more general conditions, as discussed in
                <a class="xref" href="information-schema.html#extended-show" title="24.35&nbsp;Extensions to SHOW Statements">Section&nbsp;24.35, “Extensions to SHOW Statements”</a>.
            </p><p style="color:blue;">LIKE子句（如果存在）指示要匹配的列名。where子句可用于使用更一般的条件选择行，如第24.35节“显示语句的扩展”所述。</p><p>
                The data types may differ from what you expect them to be based
                on a <a class="link" href="sql-syntax.html#create-table" title="13.1.18&nbsp;CREATE TABLE Syntax"><code class="literal">CREATE TABLE</code></a> statement
                because MySQL sometimes changes data types when you create or
                alter a table. The conditions under which this occurs are
                described in <a class="xref" href="sql-syntax.html#silent-column-changes" title="13.1.18.7&nbsp;Silent Column Specification Changes">Section&nbsp;13.1.18.7, “Silent Column Specification Changes”</a>.
            </p><p style="color:blue;">数据类型可能与基于CREATETABLE语句的预期不同，因为在创建或更改表时，MySQL有时会更改数据类型。第13.1.18.7节“静默列规范变更”中描述了发生这种情况的条件。</p><p>
                <a class="link" href="sql-syntax.html#show-columns" title="13.7.5.5&nbsp;SHOW COLUMNS Syntax"><code class="literal">SHOW COLUMNS</code></a> displays the
                following values for each table column:
            </p><p style="color:blue;">显示列为每个表列显示以下值：</p>
                <div class="itemizedlist">
                    <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                        <code class="literal">Field</code>
                    </p><p style="color:blue;">字段</p><p>
                        The column name.
                    </p><p style="color:blue;">列名。</p></li><li class="listitem"><p>
                        <code class="literal">Type</code>
                    </p><p style="color:blue;">类型</p><p>
                        The column data type.
                    </p><p style="color:blue;">列数据类型。</p></li><li class="listitem"><p>
                        <code class="literal">Collation</code>
                    </p><p style="color:blue;">校勘</p><p>
                        The collation for nonbinary string columns, or
                        <code class="literal">NULL</code> for other columns. This value is
                        displayed only if you use the <code class="literal">FULL</code>
                        keyword.
                    </p><p style="color:blue;">非二进制字符串列的排序规则，或其他列的排序规则为空。仅当使用full关键字时才显示此值。</p></li><li class="listitem"><p>
                        <code class="literal">Null</code>
                    </p><p style="color:blue;">无效的</p><p>
                        The column nullability. The value is <code class="literal">YES</code>
                        if <code class="literal">NULL</code> values can be stored in the
                        column, <code class="literal">NO</code> if not.
                    </p><p style="color:blue;">列的可空性。如果列中可以存储空值，则该值为“是”，否则为“否”。</p></li><li class="listitem"><p>
                        <code class="literal">Key</code>
                    </p><p style="color:blue;">钥匙</p><p>
                        Whether the column is indexed:
                    </p><p style="color:blue;">列是否已索引：</p>
                        <div class="itemizedlist">
                            <ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
                                If <code class="literal">Key</code> is empty, the column either is
                                not indexed or is indexed only as a secondary column in
                                a multiple-column, nonunique index.
                            </p><p style="color:blue;">如果key为空，则该列要么没有索引，要么仅作为多列ununique index中的辅助列进行索引。</p></li><li class="listitem"><p>
                                If <code class="literal">Key</code> is <code class="literal">PRI</code>, the
                                column is a <code class="literal">PRIMARY KEY</code> or is one of
                                the columns in a multiple-column <code class="literal">PRIMARY
                                KEY</code>.
                            </p><p style="color:blue;">如果key是pri，则该列是主键或是多列主键中的列之一。</p></li><li class="listitem"><p>
                                If <code class="literal">Key</code> is <code class="literal">UNI</code>, the
                                column is the first column of a
                                <code class="literal">UNIQUE</code> index. (A
                                <code class="literal">UNIQUE</code> index permits multiple
                                <code class="literal">NULL</code> values, but you can tell whether
                                the column permits <code class="literal">NULL</code> by checking
                                the <code class="literal">Null</code> field.)
                            </p><p style="color:blue;">如果key是uni，则列是唯一索引的第一列。（唯一索引允许多个空值，但可以通过检查空字段来判断列是否允许空值。）</p></li><li class="listitem"><p>
                                If <code class="literal">Key</code> is <code class="literal">MUL</code>, the
                                column is the first column of a nonunique index in which
                                multiple occurrences of a given value are permitted
                                within the column.
                            </p><p style="color:blue;">如果key为mul，则列是非唯一索引的第一列，其中允许在列中多次出现给定值。</p></li></ul>
                        </div>
                        <p>
                            If more than one of the <code class="literal">Key</code> values
                            applies to a given column of a table, <code class="literal">Key</code>
                            displays the one with the highest priority, in the order
                            <code class="literal">PRI</code>, <code class="literal">UNI</code>,
                            <code class="literal">MUL</code>.
                        </p><p style="color:blue;">如果多个键值应用于表的给定列，则键按pri、uni、mul顺序显示优先级最高的列。</p><p>
                            A <code class="literal">UNIQUE</code> index may be displayed as
                            <code class="literal">PRI</code> if it cannot contain
                            <code class="literal">NULL</code> values and there is no
                            <code class="literal">PRIMARY KEY</code> in the table. A
                            <code class="literal">UNIQUE</code> index may display as
                            <code class="literal">MUL</code> if several columns form a composite
                            <code class="literal">UNIQUE</code> index; although the combination of
                            the columns is unique, each column can still hold multiple
                            occurrences of a given value.
                        </p><p style="color:blue;">如果唯一索引不能包含空值并且表中没有主键，则该索引可以显示为pri。如果多个列构成复合唯一索引，则唯一索引可能显示为mul；尽管列的组合是唯一的，但每个列仍可以保存给定值的多个引用。</p></li><li class="listitem"><p>
                        <code class="literal">Default</code>
                    </p><p style="color:blue;">默认</p><p>
                        The default value for the column. This is
                        <code class="literal">NULL</code> if the column has an explicit
                        default of <code class="literal">NULL</code>, or if the column
                        definition includes no <code class="literal">DEFAULT</code> clause.
                    </p><p style="color:blue;">列的默认值。如果列的显式默认值为空，或者列定义不包含默认子句，则此值为空。</p></li><li class="listitem"><p>
                        <code class="literal">Extra</code>
                    </p><p style="color:blue;">额外的</p><p>
                        Any additional information that is available about a given
                        column. The value is nonempty in these cases:
                    </p><p style="color:blue;">有关给定列的任何其他可用信息。在这些情况下，该值不是空的：</p><a class="indexterm" name="idm140286827609136"></a>
                        <div class="itemizedlist">
                            <ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
                                <code class="literal">auto_increment</code> for columns that have
                                the <code class="literal">AUTO_INCREMENT</code> attribute.
                            </p><p style="color:blue;">具有auto_increment属性的列的auto_increment。</p></li><li class="listitem"><p>
                                <code class="literal">on update CURRENT_TIMESTAMP</code> for
                                <a class="link" href="data-types.html#datetime" title="11.3.1&nbsp;The DATE, DATETIME, and TIMESTAMP Types"><code class="literal">TIMESTAMP</code></a> or
                                <a class="link" href="data-types.html#datetime" title="11.3.1&nbsp;The DATE, DATETIME, and TIMESTAMP Types"><code class="literal">DATETIME</code></a> columns that
                                have the <code class="literal">ON UPDATE CURRENT_TIMESTAMP</code>
                                attribute.
                            </p><p style="color:blue;">具有on update current_timestamp属性的timestamp或datetime列的on update current_timestamp。</p></li><li class="listitem"><p>
                                <code class="literal">VIRTUAL GENERATED</code> or <code class="literal">VIRTUAL
                                STORED</code> for generated columns.
                            </p><p style="color:blue;">为生成的列虚拟生成或虚拟存储。</p></li></ul>
                        </div>
                    </li><li class="listitem"><p>
                        <code class="literal">Privileges</code>
                    </p><p style="color:blue;">特权</p><p>
                        The privileges you have for the column. This value is
                        displayed only if you use the <code class="literal">FULL</code>
                        keyword.
                    </p><p style="color:blue;">您对该列的权限。仅当使用full关键字时才显示此值。</p></li><li class="listitem"><p>
                        <code class="literal">Comment</code>
                    </p><p style="color:blue;">评论</p><p>
                        Any comment included in the column definition. This value is
                        displayed only if you use the <code class="literal">FULL</code>
                        keyword.
                    </p><p style="color:blue;">列定义中包含的任何注释。仅当使用full关键字时才显示此值。</p></li></ul>
                </div>
                <p>
                    Table column information is also available from the
                    <code class="literal">INFORMATION_SCHEMA</code>
                    <a class="link" href="information-schema.html#columns-table" title="24.5&nbsp;The INFORMATION_SCHEMA COLUMNS Table"><code class="literal">COLUMNS</code></a> table. See
                    <a class="xref" href="information-schema.html#columns-table" title="24.5&nbsp;The INFORMATION_SCHEMA COLUMNS Table">Section&nbsp;24.5, “The INFORMATION_SCHEMA COLUMNS Table”</a>.
                </p><p style="color:blue;">表列信息也可以从信息架构列表中获得。参见第24.5节“信息模式列表”。</p><p>
                You can list a table's columns with the <a class="link" href="programs.html#mysqlshow" title="4.5.7&nbsp;mysqlshow — Display Database, Table, and Column Information"><span class="command"><strong>mysqlshow
        <em class="replaceable"><code>db_name</code></em>
        <em class="replaceable"><code>tbl_name</code></em></strong></span></a> command.
            </p><p style="color:blue;">可以使用mysqlshow db_name tbl_name命令列出表的列。</p><p>
                The <a class="link" href="sql-syntax.html#describe" title="13.8.1&nbsp;DESCRIBE Syntax"><code class="literal">DESCRIBE</code></a> statement provides
                information similar to <a class="link" href="sql-syntax.html#show-columns" title="13.7.5.5&nbsp;SHOW COLUMNS Syntax"><code class="literal">SHOW
                COLUMNS</code></a>. See <a class="xref" href="sql-syntax.html#describe" title="13.8.1&nbsp;DESCRIBE Syntax">Section&nbsp;13.8.1, “DESCRIBE Syntax”</a>.
            </p><p style="color:blue;">describe语句提供类似于show columns的信息。见第13.8.1节“描述语法”。</p><p>
                The <a class="link" href="sql-syntax.html#show-create-table" title="13.7.5.10&nbsp;SHOW CREATE TABLE Syntax"><code class="literal">SHOW CREATE TABLE</code></a>,
                <a class="link" href="sql-syntax.html#show-table-status" title="13.7.5.36&nbsp;SHOW TABLE STATUS Syntax"><code class="literal">SHOW TABLE STATUS</code></a>, and
                <a class="link" href="sql-syntax.html#show-index" title="13.7.5.22&nbsp;SHOW INDEX Syntax"><code class="literal">SHOW INDEX</code></a> statements also
                provide information about tables. See <a class="xref" href="sql-syntax.html#show" title="13.7.5&nbsp;SHOW Syntax">Section&nbsp;13.7.5, “SHOW Syntax”</a>.
            </p><p style="color:blue;">show create table、show table status和show index语句还提供有关表的信息。见第13.7.5节“显示语法”。</p>
            </div>
            <div class="section">
                <div class="titlepage">
                    <div>
                        <div>
                            <h4 class="title"><a name="show-create-database"></a>13.7.5.6&nbsp;SHOW CREATE DATABASE Syntax</h4>

                        </div>

                    </div>

                </div>
                <a class="indexterm" name="idm140286827576688"></a><a class="indexterm" name="idm140286827575632"></a><pre data-lang="sql" class="programlisting">SHOW CREATE {DATABASE | SCHEMA} [IF NOT EXISTS] <em class="replaceable"><code>db_name</code></em>
</pre><p>
                Shows the <a class="link" href="sql-syntax.html#create-database" title="13.1.11&nbsp;CREATE DATABASE Syntax"><code class="literal">CREATE DATABASE</code></a>
                statement that creates the named database. If the
                <code class="literal">SHOW</code> statement includes an <code class="literal">IF NOT
                EXISTS</code> clause, the output too includes such a clause.
                <a class="link" href="sql-syntax.html#show-create-database" title="13.7.5.6&nbsp;SHOW CREATE DATABASE Syntax"><code class="literal">SHOW
                    CREATE SCHEMA</code></a> is a synonym for
                <a class="link" href="sql-syntax.html#show-create-database" title="13.7.5.6&nbsp;SHOW CREATE DATABASE Syntax"><code class="literal">SHOW CREATE DATABASE</code></a>.
            </p><p style="color:blue;">显示创建命名数据库的create database语句。如果show语句包含if not exists子句，则输出也包含此类子句。show create schema是show create database的同义词。</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>SHOW CREATE DATABASE test\G</code></strong>
*************************** 1. row ***************************
       Database: test
Create Database: CREATE DATABASE `test`
                 /*!40100 DEFAULT CHARACTER SET latin1 */

mysql&gt; <strong class="userinput"><code>SHOW CREATE SCHEMA test\G</code></strong>
*************************** 1. row ***************************
       Database: test
Create Database: CREATE DATABASE `test`
                 /*!40100 DEFAULT CHARACTER SET latin1 */
</pre><p>
                <a class="link" href="sql-syntax.html#show-create-database" title="13.7.5.6&nbsp;SHOW CREATE DATABASE Syntax"><code class="literal">SHOW CREATE DATABASE</code></a> quotes table
                and column names according to the value of the
                <a class="link" href="server-administration.html#sysvar_sql_quote_show_create"><code class="literal">sql_quote_show_create</code></a> option.
                See <a class="xref" href="server-administration.html#server-system-variables" title="5.1.7&nbsp;Server System Variables">Section&nbsp;5.1.7, “Server System Variables”</a>.
            </p><p style="color:blue;">根据sql quote\u show\u create选项的值显示create database quotes表和列名。见第5.1.7节“服务器系统变量”。</p>
            </div>
            <div class="section">
                <div class="titlepage">
                    <div>
                        <div>
                            <h4 class="title"><a name="show-create-event"></a>13.7.5.7&nbsp;SHOW CREATE EVENT Syntax</h4>

                        </div>

                    </div>

                </div>
                <pre data-lang="sql" class="programlisting">SHOW CREATE EVENT <em class="replaceable"><code>event_name</code></em>
</pre><p>
                This statement displays the <a class="link" href="sql-syntax.html#create-event" title="13.1.12&nbsp;CREATE EVENT Syntax"><code class="literal">CREATE
                EVENT</code></a> statement needed to re-create a given event. It
                requires the <a class="link" href="security.html#priv_event"><code class="literal">EVENT</code></a> privilege for
                the database from which the event is to be shown. For example
                (using the same event <code class="literal">e_daily</code> defined and
                then altered in <a class="xref" href="sql-syntax.html#show-events" title="13.7.5.18&nbsp;SHOW EVENTS Syntax">Section&nbsp;13.7.5.18, “SHOW EVENTS Syntax”</a>):
            </p><p style="color:blue;">此语句显示重新创建给定事件所需的create event语句。它需要显示事件的数据库的事件特权。例如（使用第13.7.5.18节“显示事件语法”中定义并更改的相同事件e_u daily）：</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>SHOW CREATE EVENT myschema.e_daily\G</code></strong>
*************************** 1. row ***************************
               Event: e_daily
            sql_mode: ONLY_FULL_GROUP_BY,STRICT_TRANS_TABLES,
                      NO_ZERO_IN_DATE,NO_ZERO_DATE,
                      ERROR_FOR_DIVISION_BY_ZERO,
                      NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION
           time_zone: SYSTEM
        Create Event: CREATE DEFINER=`jon`@`ghidora` EVENT `e_daily`
                        ON SCHEDULE EVERY 1 DAY
                        STARTS CURRENT_TIMESTAMP + INTERVAL 6 HOUR
                        ON COMPLETION NOT PRESERVE
                        ENABLE
                        COMMENT 'Saves total number of sessions then
                                clears the table each day'
                        DO BEGIN
                          INSERT INTO site_activity.totals (time, total)
                            SELECT CURRENT_TIMESTAMP, COUNT(*)
                              FROM site_activity.sessions;
                          DELETE FROM site_activity.sessions;
                        END
character_set_client: utf8
collation_connection: utf8_general_ci
  Database Collation: latin1_swedish_ci
</pre><p>
                <code class="literal">character_set_client</code> is the session value of
                the <a class="link" href="server-administration.html#sysvar_character_set_client"><code class="literal">character_set_client</code></a> system
                variable when the event was created.
                <code class="literal">collation_connection</code> is the session value of
                the <a class="link" href="server-administration.html#sysvar_collation_connection"><code class="literal">collation_connection</code></a> system
                variable when the event was created. <code class="literal">Database
                Collation</code> is the collation of the database with which
                the event is associated.
            </p><p style="color:blue;">character_set_client是创建事件时character_set_client系统变量的会话值。collation_connection是创建事件时collation_connection系统变量的会话值。数据库排序规则是与事件关联的数据库的排序规则。</p><p>
                The output reflects the current status of the event
                (<code class="literal">ENABLE</code>) rather than the status with which it
                was created.
            </p><p style="color:blue;">输出反映事件的当前状态（enable），而不是事件创建时的状态。</p>
            </div>
            <div class="section">
                <div class="titlepage">
                    <div>
                        <div>
                            <h4 class="title"><a name="show-create-function"></a>13.7.5.8&nbsp;SHOW CREATE FUNCTION Syntax</h4>

                        </div>

                    </div>

                </div>
                <a class="indexterm" name="idm140286827534192"></a><pre data-lang="sql" class="programlisting">SHOW CREATE FUNCTION <em class="replaceable"><code>func_name</code></em>
</pre><p>
                This statement is similar to <a class="link" href="sql-syntax.html#show-create-procedure" title="13.7.5.9&nbsp;SHOW CREATE PROCEDURE Syntax"><code class="literal">SHOW CREATE
                PROCEDURE</code></a> but for stored functions. See
                <a class="xref" href="sql-syntax.html#show-create-procedure" title="13.7.5.9&nbsp;SHOW CREATE PROCEDURE Syntax">Section&nbsp;13.7.5.9, “SHOW CREATE PROCEDURE Syntax”</a>.
            </p><p style="color:blue;">此语句类似于show create procedure，但用于存储函数。参见第13.7.5.9节“显示创建过程语法”。</p>
            </div>
            <div class="section">
                <div class="titlepage">
                    <div>
                        <div>
                            <h4 class="title"><a name="show-create-procedure"></a>13.7.5.9&nbsp;SHOW CREATE PROCEDURE Syntax</h4>

                        </div>

                    </div>

                </div>
                <a class="indexterm" name="idm140286827525056"></a><pre data-lang="sql" class="programlisting">SHOW CREATE PROCEDURE <em class="replaceable"><code>proc_name</code></em>
</pre><p>
                This statement is a MySQL extension. It returns the exact string
                that can be used to re-create the named stored procedure. A
                similar statement, <a class="link" href="sql-syntax.html#show-create-function" title="13.7.5.8&nbsp;SHOW CREATE FUNCTION Syntax"><code class="literal">SHOW CREATE
                FUNCTION</code></a>, displays information about stored functions
                (see <a class="xref" href="sql-syntax.html#show-create-function" title="13.7.5.8&nbsp;SHOW CREATE FUNCTION Syntax">Section&nbsp;13.7.5.8, “SHOW CREATE FUNCTION Syntax”</a>).
            </p><p style="color:blue;">此语句是MySQL扩展。它返回可用于重新创建命名存储过程的确切字符串。类似的语句show create function显示有关存储函数的信息（参见第13.7.5.8节“show create function syntax”）。</p><p>
                To use either statement, you must be the user named in the
                routine <code class="literal">DEFINER</code> clause or have
                <a class="link" href="sql-syntax.html#select" title="13.2.9&nbsp;SELECT Syntax"><code class="literal">SELECT</code></a> access to the
                <code class="literal">mysql.proc</code> table. If you do not have
                privileges for the routine itself, the value displayed for the
                <code class="literal">Create Procedure</code> or <code class="literal">Create
                Function</code> field will be <code class="literal">NULL</code>.
            </p><p style="color:blue;">要使用这两个语句，您必须是例程definer子句中指定的用户，或者具有对mysql.proc表的select访问权限。如果您没有例程本身的权限，则为create procedure或create function字段显示的值将为空。</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>SHOW CREATE PROCEDURE test.simpleproc\G</code></strong>
*************************** 1. row ***************************
           Procedure: simpleproc
            sql_mode: ONLY_FULL_GROUP_BY,STRICT_TRANS_TABLES,
                      NO_ZERO_IN_DATE,NO_ZERO_DATE,
                      ERROR_FOR_DIVISION_BY_ZERO,
                      NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION
    Create Procedure: CREATE PROCEDURE `simpleproc`(OUT param1 INT)
                      BEGIN
                      SELECT COUNT(*) INTO param1 FROM t;
                      END
character_set_client: utf8
collation_connection: utf8_general_ci
  Database Collation: latin1_swedish_ci

mysql&gt; <strong class="userinput"><code>SHOW CREATE FUNCTION test.hello\G</code></strong>
*************************** 1. row ***************************
            Function: hello
            sql_mode: ONLY_FULL_GROUP_BY,STRICT_TRANS_TABLES,
                      NO_ZERO_IN_DATE,NO_ZERO_DATE,
                      ERROR_FOR_DIVISION_BY_ZERO,
                      NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION
     Create Function: CREATE FUNCTION `hello`(s CHAR(20))
                      RETURNS char(50) CHARSET latin1
                      RETURN CONCAT('Hello, ',s,'!')
character_set_client: utf8
collation_connection: utf8_general_ci
  Database Collation: latin1_swedish_ci
</pre><p>
                <code class="literal">character_set_client</code> is the session value of
                the <a class="link" href="server-administration.html#sysvar_character_set_client"><code class="literal">character_set_client</code></a> system
                variable when the routine was created.
                <code class="literal">collation_connection</code> is the session value of
                the <a class="link" href="server-administration.html#sysvar_collation_connection"><code class="literal">collation_connection</code></a> system
                variable when the routine was created. <code class="literal">Database
                Collation</code> is the collation of the database with which
                the routine is associated.
            </p><p style="color:blue;">character_set_client是创建例程时character_set_client系统变量的会话值。collation_connection是创建例程时collation_connection系统变量的会话值。数据库排序规则是与例程关联的数据库的排序规则。</p>
            </div>
            <div class="section">
                <div class="titlepage">
                    <div>
                        <div>
                            <h4 class="title"><a name="show-create-table"></a>13.7.5.10&nbsp;SHOW CREATE TABLE Syntax</h4>

                        </div>

                    </div>

                </div>
                <a class="indexterm" name="idm140286827500400"></a><pre data-lang="sql" class="programlisting">SHOW CREATE TABLE <em class="replaceable"><code>tbl_name</code></em>
</pre><p>
                Shows the <a class="link" href="sql-syntax.html#create-table" title="13.1.18&nbsp;CREATE TABLE Syntax"><code class="literal">CREATE TABLE</code></a> statement
                that creates the named table. To use this statement, you must
                have some privilege for the table. This statement also works
                with views.
            </p><p style="color:blue;">显示创建命名表的CREATETABLE语句。若要使用此语句，您必须对该表具有某些特权。此语句也适用于视图。</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>SHOW CREATE TABLE t\G</code></strong>
*************************** 1. row ***************************
       Table: t
Create Table: CREATE TABLE `t` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `s` char(60) DEFAULT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=latin1</pre><p>
                <a class="link" href="sql-syntax.html#show-create-table" title="13.7.5.10&nbsp;SHOW CREATE TABLE Syntax"><code class="literal">SHOW CREATE TABLE</code></a> quotes table
                and column names according to the value of the
                <a class="link" href="server-administration.html#sysvar_sql_quote_show_create"><code class="literal">sql_quote_show_create</code></a> option.
                See <a class="xref" href="server-administration.html#server-system-variables" title="5.1.7&nbsp;Server System Variables">Section&nbsp;5.1.7, “Server System Variables”</a>.
            </p><p style="color:blue;">根据sql quote\u show\u create选项的值显示create table quotes table和column names。见第5.1.7节“服务器系统变量”。</p><p>
                For information about how <a class="link" href="sql-syntax.html#create-table" title="13.1.18&nbsp;CREATE TABLE Syntax"><code class="literal">CREATE
                TABLE</code></a> statements are stored by MySQL, see
                <a class="xref" href="sql-syntax.html#create-table-statement-retention" title="13.1.18.1&nbsp;CREATE TABLE Statement Retention">Section&nbsp;13.1.18.1, “CREATE TABLE Statement Retention”</a>.
            </p><p style="color:blue;">有关mysql如何存储create table语句的信息，请参阅13.1.18.1节“create table statement retention”。</p>
            </div>
            <div class="section">
                <div class="titlepage">
                    <div>
                        <div>
                            <h4 class="title"><a name="show-create-trigger"></a>13.7.5.11&nbsp;SHOW CREATE TRIGGER Syntax</h4>

                        </div>

                    </div>

                </div>
                <a class="indexterm" name="idm140286827481776"></a><pre data-lang="sql" class="programlisting">SHOW CREATE TRIGGER <em class="replaceable"><code>trigger_name</code></em>
</pre><p>
                This statement shows the <a class="link" href="sql-syntax.html#create-trigger" title="13.1.20&nbsp;CREATE TRIGGER Syntax"><code class="literal">CREATE
                TRIGGER</code></a> statement that creates the named trigger. This
                statement requires the <a class="link" href="security.html#priv_trigger"><code class="literal">TRIGGER</code></a>
                privilege for the table associated with the trigger.
            </p><p style="color:blue;">此语句显示创建命名触发器的create trigger语句。此语句要求与触发器关联的表具有触发器特权。</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>SHOW CREATE TRIGGER ins_sum\G</code></strong>
*************************** 1. row ***************************
               Trigger: ins_sum
              sql_mode: ONLY_FULL_GROUP_BY,STRICT_TRANS_TABLES,
                        NO_ZERO_IN_DATE,NO_ZERO_DATE,
                        ERROR_FOR_DIVISION_BY_ZERO,
                        NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION
SQL Original Statement: CREATE DEFINER=`me`@`localhost` TRIGGER ins_sum
                        BEFORE INSERT ON account
                        FOR EACH ROW SET @sum = @sum + NEW.amount
  character_set_client: utf8
  collation_connection: utf8_general_ci
    Database Collation: latin1_swedish_ci
               Created: 2018-08-08 10:10:07.90
</pre><p>
                <a class="link" href="sql-syntax.html#show-create-trigger" title="13.7.5.11&nbsp;SHOW CREATE TRIGGER Syntax"><code class="literal">SHOW CREATE TRIGGER</code></a> output has
                these columns:
            </p><p style="color:blue;">显示创建触发器输出具有以下列：</p>
                <div class="itemizedlist">
                    <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                        <code class="literal">Trigger</code>: The trigger name.
                    </p><p style="color:blue;">触发器：触发器名称。</p></li><li class="listitem"><p>
                        <code class="literal">sql_mode</code>: The SQL mode in effect when the
                        trigger executes.
                    </p><p style="color:blue;">sql_mode：触发器执行时生效的sql模式。</p></li><li class="listitem"><p>
                        <code class="literal">SQL Original Statement</code>: The
                        <a class="link" href="sql-syntax.html#create-trigger" title="13.1.20&nbsp;CREATE TRIGGER Syntax"><code class="literal">CREATE TRIGGER</code></a> statement that
                        defines the trigger.
                    </p><p style="color:blue;">SQL原始语句：定义触发器的CREATETRIGGER语句。</p></li><li class="listitem"><p>
                        <code class="literal">character_set_client</code>: The session value
                        of the <a class="link" href="server-administration.html#sysvar_character_set_client"><code class="literal">character_set_client</code></a>
                        system variable when the trigger was created.
                    </p><p style="color:blue;">character_set_client：创建触发器时character_set_client系统变量的会话值。</p></li><li class="listitem"><p>
                        <code class="literal">collation_connection</code>: The session value
                        of the <a class="link" href="server-administration.html#sysvar_collation_connection"><code class="literal">collation_connection</code></a>
                        system variable when the trigger was created.
                    </p><p style="color:blue;">collation_connection：创建触发器时collation_connection系统变量的会话值。</p></li><li class="listitem"><p>
                        <code class="literal">Database Collation</code>: The collation of the
                        database with which the trigger is associated.
                    </p><p style="color:blue;">数据库排序规则：与触发器关联的数据库的排序规则。</p></li><li class="listitem"><p>
                        <code class="literal">Created</code>: The date and time when the
                        trigger was created. This is a
                        <code class="literal">TIMESTAMP(2)</code> value (with a fractional
                        part in hundredths of seconds) for triggers created in MySQL
                        5.7.2 or later, <code class="literal">NULL</code> for triggers created
                        prior to 5.7.2.
                    </p><p style="color:blue;">created：创建触发器的日期和时间。这是mysql 5.7.2或更高版本中创建的触发器的时间戳（2）值（小数部分以百分之几秒为单位），对于5.7.2之前创建的触发器为空。</p></li></ul>
                </div>
                <p>
                    Trigger information is also available from the
                    <code class="literal">INFORMATION_SCHEMA</code>
                    <a class="link" href="information-schema.html#triggers-table" title="24.29&nbsp;The INFORMATION_SCHEMA TRIGGERS Table"><code class="literal">TRIGGERS</code></a> table. See
                    <a class="xref" href="information-schema.html#triggers-table" title="24.29&nbsp;The INFORMATION_SCHEMA TRIGGERS Table">Section&nbsp;24.29, “The INFORMATION_SCHEMA TRIGGERS Table”</a>.
                </p><p style="color:blue;">触发器信息也可以从信息架构触发器表中获得。参见第24.29节“信息架构触发器表”。</p>
            </div>
            <div class="section">
                <div class="titlepage">
                    <div>
                        <div>
                            <h4 class="title"><a name="show-create-user"></a>13.7.5.12&nbsp;SHOW CREATE USER Syntax</h4>

                        </div>

                    </div>

                </div>
                <a class="indexterm" name="idm140286827449104"></a><pre data-lang="sql" class="programlisting">SHOW CREATE USER <em class="replaceable"><code>user</code></em>
</pre><p>
                This statement shows the <a class="link" href="sql-syntax.html#create-user" title="13.7.1.2&nbsp;CREATE USER Syntax"><code class="literal">CREATE
                USER</code></a> statement that creates the named user. An error
                occurs if the user does not exist. The statement requires the
                <a class="link" href="security.html#priv_select"><code class="literal">SELECT</code></a> privilege for the
                <code class="literal">mysql</code> system database, except to display
                information for the current user.
            </p><p style="color:blue;">此语句显示创建命名用户的create user语句。如果用户不存在，则会出现错误。该语句要求mysql系统数据库具有select权限，但显示当前用户的信息除外。</p><p>
                To name the account, use the format described in
                <a class="xref" href="security.html#account-names" title="6.2.4&nbsp;Specifying Account Names">Section&nbsp;6.2.4, “Specifying Account Names”</a>. The host name part of the
                account name, if omitted, defaults to <code class="literal">'%'</code>. It
                is also possible to specify
                <a class="link" href="functions.html#function_current-user"><code class="literal">CURRENT_USER</code></a> or
                <a class="link" href="functions.html#function_current-user"><code class="literal">CURRENT_USER()</code></a> to refer to the
                account associated with the current session.
            </p><p style="color:blue;">要命名帐户，请使用第6.2.4节“指定帐户名”中描述的格式。帐户名的主机名部分（如果省略）默认为“%”。也可以指定current_user或current_user（）来引用与当前会话关联的帐户。</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>SHOW CREATE USER 'root'@'localhost'\G</code></strong>
*************************** 1. row ***************************
CREATE USER for root@localhost: CREATE USER 'root'@'localhost'
IDENTIFIED WITH 'mysql_native_password'
AS '*2470C0C06DEE42FD1618BB99005ADCA2EC9D1E19'
REQUIRE NONE PASSWORD EXPIRE DEFAULT ACCOUNT UNLOCK
</pre><p>
                The output format is affected by the setting of the
                <a class="link" href="replication.html#sysvar_log_builtin_as_identified_by_password"><code class="literal">log_builtin_as_identified_by_password</code></a>
                system variable.
            </p><p style="color:blue;">输出格式受LOG U BUILTIN U AS U IDENTIFIED U BY U PASSWORD系统变量设置的影响。</p><p>
                To display the privileges granted to an account, use the
                <a class="link" href="sql-syntax.html#show-grants" title="13.7.5.21&nbsp;SHOW GRANTS Syntax"><code class="literal">SHOW GRANTS</code></a> statement. See
                <a class="xref" href="sql-syntax.html#show-grants" title="13.7.5.21&nbsp;SHOW GRANTS Syntax">Section&nbsp;13.7.5.21, “SHOW GRANTS Syntax”</a>.
            </p><p style="color:blue;">要显示授予帐户的权限，请使用show grants语句。见第13.7.5.21节，“显示授权语法”。</p>
            </div>
            <div class="section">
                <div class="titlepage">
                    <div>
                        <div>
                            <h4 class="title"><a name="show-create-view"></a>13.7.5.13&nbsp;SHOW CREATE VIEW Syntax</h4>

                        </div>

                    </div>

                </div>
                <a class="indexterm" name="idm140286827427984"></a><pre data-lang="sql" class="programlisting">SHOW CREATE VIEW <em class="replaceable"><code>view_name</code></em>
</pre><p>
                This statement shows the <a class="link" href="sql-syntax.html#create-view" title="13.1.21&nbsp;CREATE VIEW Syntax"><code class="literal">CREATE
                VIEW</code></a> statement that creates the named view.
            </p><p style="color:blue;">此语句显示创建命名视图的create view语句。</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>SHOW CREATE VIEW v\G</code></strong>
*************************** 1. row ***************************
                View: v
         Create View: CREATE ALGORITHM=UNDEFINED
                      DEFINER=`bob`@`localhost`
                      SQL SECURITY DEFINER VIEW
                      `v` AS select 1 AS `a`,2 AS `b`
character_set_client: utf8
collation_connection: utf8_general_ci
</pre><p>
                <code class="literal">character_set_client</code> is the session value of
                the <a class="link" href="server-administration.html#sysvar_character_set_client"><code class="literal">character_set_client</code></a> system
                variable when the view was created.
                <code class="literal">collation_connection</code> is the session value of
                the <a class="link" href="server-administration.html#sysvar_collation_connection"><code class="literal">collation_connection</code></a> system
                variable when the view was created.
            </p><p style="color:blue;">character_set_client是创建视图时character_set_client系统变量的会话值。collation_connection是创建视图时collation_connection系统变量的会话值。</p><p>
                Use of <a class="link" href="sql-syntax.html#show-create-view" title="13.7.5.13&nbsp;SHOW CREATE VIEW Syntax"><code class="literal">SHOW CREATE VIEW</code></a> requires
                the <a class="link" href="security.html#priv_show-view"><code class="literal">SHOW VIEW</code></a> privilege, and the
                <a class="link" href="security.html#priv_select"><code class="literal">SELECT</code></a> privilege for the view in
                question.
            </p><p style="color:blue;">使用“显示创建视图”需要“显示视图”权限和有关视图的“选择”权限。</p><p>
                View information is also available from the
                <code class="literal">INFORMATION_SCHEMA</code>
                <a class="link" href="information-schema.html#views-table" title="24.31&nbsp;The INFORMATION_SCHEMA VIEWS Table"><code class="literal">VIEWS</code></a> table. See
                <a class="xref" href="information-schema.html#views-table" title="24.31&nbsp;The INFORMATION_SCHEMA VIEWS Table">Section&nbsp;24.31, “The INFORMATION_SCHEMA VIEWS Table”</a>.
            </p><p style="color:blue;">视图信息也可以从信息架构视图表中获得。参见第24.31节“信息模式视图表”。</p><p>
                MySQL lets you use different
                <a class="link" href="server-administration.html#sysvar_sql_mode"><code class="literal">sql_mode</code></a> settings to tell the
                server the type of SQL syntax to support. For example, you might
                use the <a class="link" href="server-administration.html#sqlmode_ansi"><code class="literal">ANSI</code></a> SQL mode to
                ensure MySQL correctly interprets the standard SQL concatenation
                operator, the double bar (<code class="literal">||</code>), in your
                queries. If you then create a view that concatenates items, you
                might worry that changing the
                <a class="link" href="server-administration.html#sysvar_sql_mode"><code class="literal">sql_mode</code></a> setting to a value
                different from <a class="link" href="server-administration.html#sqlmode_ansi"><code class="literal">ANSI</code></a> could
                cause the view to become invalid. But this is not the case. No
                matter how you write out a view definition, MySQL always stores
                it the same way, in a canonical form. Here is an example that
                shows how the server changes a double bar concatenation operator
                to a <a class="link" href="functions.html#function_concat"><code class="literal">CONCAT()</code></a> function:
            </p><p style="color:blue;">mysql允许您使用不同的sql_模式设置来告诉服务器要支持的sql语法类型。例如，您可以使用ansi sql模式来确保mysql在查询中正确地解释标准sql连接运算符，即双条（）。如果随后创建一个连接项的视图，则可能会担心将sql_mode设置更改为与ansi不同的值会导致视图无效。但事实并非如此。不管您如何编写视图定义，mysql总是以相同的方式以规范的形式存储它。下面是一个示例，显示服务器如何将双条连接运算符更改为concat（）函数：</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>SET sql_mode = 'ANSI';</code></strong>
Query OK, 0 rows affected (0.00 sec)

mysql&gt; <strong class="userinput"><code>CREATE VIEW test.v AS SELECT 'a' || 'b' as col1;</code></strong>
Query OK, 0 rows affected (0.01 sec)

mysql&gt; <strong class="userinput"><code>SHOW CREATE VIEW test.v\G</code></strong>
*************************** 1. row ***************************
                View: v
         Create View: CREATE VIEW "v" AS select concat('a','b') AS "col1"
...
1 row in set (0.00 sec)
</pre><p>
                The advantage of storing a view definition in canonical form is
                that changes made later to the value of
                <a class="link" href="server-administration.html#sysvar_sql_mode"><code class="literal">sql_mode</code></a> will not affect the
                results from the view. However an additional consequence is that
                comments prior to <a class="link" href="sql-syntax.html#select" title="13.2.9&nbsp;SELECT Syntax"><code class="literal">SELECT</code></a> are
                stripped from the definition by the server.
            </p><p style="color:blue;">以规范形式存储视图定义的好处是，以后对sql_mode的值所做的更改不会影响视图的结果。但是，另一个结果是，服务器会从定义中删除select之前的注释。</p>
            </div>
            <div class="section">
                <div class="titlepage">
                    <div>
                        <div>
                            <h4 class="title"><a name="show-databases"></a>13.7.5.14&nbsp;SHOW DATABASES Syntax</h4>

                        </div>

                    </div>

                </div>
                <a class="indexterm" name="idm140286827391984"></a><a class="indexterm" name="idm140286827390896"></a><pre data-lang="sql" class="programlisting">SHOW {DATABASES | SCHEMAS}
    [LIKE '<em class="replaceable"><code>pattern</code></em>' | WHERE <em class="replaceable"><code>expr</code></em>]
</pre><p>
                <a class="link" href="sql-syntax.html#show-databases" title="13.7.5.14&nbsp;SHOW DATABASES Syntax"><code class="literal">SHOW DATABASES</code></a> lists the
                databases on the MySQL server host.
                <a class="link" href="sql-syntax.html#show-databases" title="13.7.5.14&nbsp;SHOW DATABASES Syntax"><code class="literal">SHOW
                    SCHEMAS</code></a> is a synonym for <a class="link" href="sql-syntax.html#show-databases" title="13.7.5.14&nbsp;SHOW DATABASES Syntax"><code class="literal">SHOW
                DATABASES</code></a>. The <a class="link" href="functions.html#operator_like"><code class="literal">LIKE</code></a>
                clause, if present, indicates which database names to match. The
                <code class="literal">WHERE</code> clause can be given to select rows
                using more general conditions, as discussed in
                <a class="xref" href="information-schema.html#extended-show" title="24.35&nbsp;Extensions to SHOW Statements">Section&nbsp;24.35, “Extensions to SHOW Statements”</a>.
            </p><p style="color:blue;">show databases列出mysql服务器主机上的数据库。show schemas是show数据库的同义词。LIKE子句（如果存在）指示要匹配的数据库名称。where子句可用于使用更一般的条件选择行，如第24.35节“显示语句的扩展”所述。</p><p>
                You see only those databases for which you have some kind of
                privilege, unless you have the global <a class="link" href="sql-syntax.html#show-databases" title="13.7.5.14&nbsp;SHOW DATABASES Syntax"><code class="literal">SHOW
                DATABASES</code></a> privilege. You can also get this list using
                the <a class="link" href="programs.html#mysqlshow" title="4.5.7&nbsp;mysqlshow — Display Database, Table, and Column Information"><span class="command"><strong>mysqlshow</strong></span></a> command.
            </p><p style="color:blue;">除非您具有“全局显示数据库”权限，否则只能看到具有某种权限的数据库。您还可以使用mysqlshow命令获取此列表。</p><p>
                If the server was started with the
                <a class="link" href="server-administration.html#option_mysqld_skip-show-database"><code class="option">--skip-show-database</code></a> option, you
                cannot use this statement at all unless you have the
                <a class="link" href="security.html#priv_show-databases"><code class="literal">SHOW DATABASES</code></a> privilege.
            </p><p style="color:blue;">如果服务器是使用--skip show database选项启动的，则除非您具有show databases特权，否则根本不能使用此语句。</p><p>
                MySQL implements databases as directories in the data directory,
                so this statement simply lists directories in that location.
                However, the output may include names of directories that do not
                correspond to actual databases.
            </p><p style="color:blue;">mysql将数据库实现为数据目录中的目录，因此此语句只列出该位置中的目录。但是，输出可能包含与实际数据库不对应的目录名。</p><p>
                Database information is also available from the
                <code class="literal">INFORMATION_SCHEMA</code>
                <a class="link" href="information-schema.html#schemata-table" title="24.22&nbsp;The INFORMATION_SCHEMA SCHEMATA Table"><code class="literal">SCHEMATA</code></a> table. See
                <a class="xref" href="information-schema.html#schemata-table" title="24.22&nbsp;The INFORMATION_SCHEMA SCHEMATA Table">Section&nbsp;24.22, “The INFORMATION_SCHEMA SCHEMATA Table”</a>.
            </p><p style="color:blue;">数据库信息也可以从information\u schema schemata表中获得。参见第24.22节“信息模式模式表”。</p>
                <div class="caution" style="margin-left: 0.5in; margin-right: 0.5in;">

                    <div class="admon-title">
                        Caution
                    </div>
                    <p>
                        Because a global privilege is considered a privilege for all
                        databases, <span class="emphasis"><em>any</em></span> global privilege enables a
                        user to see all database names with <a class="link" href="sql-syntax.html#show-databases" title="13.7.5.14&nbsp;SHOW DATABASES Syntax"><code class="literal">SHOW
                        DATABASES</code></a> or by examining the
                        <code class="literal">INFORMATION_SCHEMA</code>
                        <a class="link" href="information-schema.html#schemata-table" title="24.22&nbsp;The INFORMATION_SCHEMA SCHEMATA Table"><code class="literal">SCHEMATA</code></a> table.
                    </p><p style="color:blue;">由于全局权限被视为所有数据库的权限，因此任何全局权限都允许用户查看所有带有show databases的数据库名，或通过检查information_schema schemata表查看所有数据库名。</p>
                </div>

            </div>
            <div class="section">
                <div class="titlepage">
                    <div>
                        <div>
                            <h4 class="title"><a name="show-engine"></a>13.7.5.15&nbsp;SHOW ENGINE Syntax</h4>

                        </div>

                    </div>

                </div>
                <a class="indexterm" name="idm140286827362048"></a><a class="indexterm" name="idm140286827360976"></a><pre data-lang="sql" class="programlisting">SHOW ENGINE <em class="replaceable"><code>engine_name</code></em> {STATUS | MUTEX}
</pre><p>
                <a class="link" href="sql-syntax.html#show-engine" title="13.7.5.15&nbsp;SHOW ENGINE Syntax"><code class="literal">SHOW ENGINE</code></a> displays operational
                information about a storage engine. It requires the
                <a class="link" href="security.html#priv_process"><code class="literal">PROCESS</code></a> privilege. The statement
                has these variants:
            </p><p style="color:blue;">显示引擎显示有关存储引擎的操作信息。它需要进程特权。该语句有以下变体：</p><pre data-lang="sql" class="programlisting">SHOW ENGINE INNODB STATUS
SHOW ENGINE INNODB MUTEX
SHOW ENGINE PERFORMANCE_SCHEMA STATUS
</pre><p>
                <a class="link" href="sql-syntax.html#show-engine" title="13.7.5.15&nbsp;SHOW ENGINE Syntax"><code class="literal">SHOW ENGINE INNODB
                    STATUS</code></a> displays extensive information from the
                standard <code class="literal">InnoDB</code> Monitor about the state of
                the <code class="literal">InnoDB</code> storage engine. For information
                about the standard monitor and other <code class="literal">InnoDB</code>
                Monitors that provide information about
                <code class="literal">InnoDB</code> processing, see
                <a class="xref" href="innodb-storage-engine.html#innodb-monitors" title="14.17&nbsp;InnoDB Monitors">Section&nbsp;14.17, “InnoDB Monitors”</a>.
            </p><p style="color:blue;">show engine innodb status显示来自标准innodb监视器的有关innodb存储引擎状态的大量信息。有关标准监视器和其他提供InnoDB处理信息的InnoDB监视器的信息，请参阅第14.17节“InnoDB监视器”。</p><p>
                <a class="link" href="sql-syntax.html#show-engine" title="13.7.5.15&nbsp;SHOW ENGINE Syntax"><code class="literal">SHOW ENGINE INNODB
                    MUTEX</code></a> displays <code class="literal">InnoDB</code>
                <a class="link" href="glossary.html#glos_mutex" title="mutex">mutex</a> and
                <a class="link" href="glossary.html#glos_rw_lock" title="rw-lock">rw-lock</a> statistics.
            </p><p style="color:blue;">show engine innodb mutex显示innodb mutex和rw lock统计信息。</p>
                <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">

                    <div class="admon-title">
                        Note
                    </div>
                    <p>
                        <code class="literal">InnoDB</code> mutexes and rwlocks can also be
                        monitored using <a class="link" href="performance-schema.html" title="Chapter&nbsp;25&nbsp;MySQL Performance Schema">Performance
                        Schema</a> tables. See
                        <a class="xref" href="innodb-storage-engine.html#monitor-innodb-mutex-waits-performance-schema" title="14.16.2&nbsp;Monitoring InnoDB Mutex Waits Using Performance Schema">Section&nbsp;14.16.2, “Monitoring InnoDB Mutex Waits Using Performance Schema”</a>.
                    </p><p style="color:blue;">innodb互斥和rwlocks也可以使用性能模式表进行监控。参见14.16.2节，“使用性能模式监视innodb mutex等待”。</p>
                </div>
                <p>
                    <a class="link" href="sql-syntax.html#show-engine" title="13.7.5.15&nbsp;SHOW ENGINE Syntax"><code class="literal">SHOW ENGINE INNODB
                        MUTEX</code></a> output was removed in MySQL 5.7.2. It was
                    revised and reintroduced in MySQL 5.7.8.
                </p><p style="color:blue;">在mysql 5.7.2中删除了show engine innodb mutex输出。在mysql 5.7.8中对其进行了修改和重新引入。</p><p>
                In MySQL 5.7.8, mutex statistics collection is configured
                dynamically using the following options:
            </p><p style="color:blue;">在mysql 5.7.8中，互斥统计信息收集是使用以下选项动态配置的：</p>
                <div class="itemizedlist">
                    <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                        To enable the collection of mutex statistics, run:
                    </p><p style="color:blue;">要启用互斥统计信息的收集，请运行：</p><pre data-lang="sql" class="programlisting">SET GLOBAL innodb_monitor_enable='latch';</pre></li><li class="listitem"><p>
                        To reset mutex statistics, run:
                    </p><p style="color:blue;">要重置互斥统计信息，请运行：</p><pre data-lang="sql" class="programlisting">SET GLOBAL innodb_monitor_reset='latch';</pre></li><li class="listitem"><p>
                        To disable the collection of mutex statistics, run:
                    </p><p style="color:blue;">要禁用互斥统计信息的收集，请运行：</p><pre data-lang="sql" class="programlisting">SET GLOBAL innodb_monitor_disable='latch';</pre></li></ul>
                </div>
                <p>
                    Collection of mutex statistics for
                    <a class="link" href="sql-syntax.html#show-engine" title="13.7.5.15&nbsp;SHOW ENGINE Syntax"><code class="literal">SHOW ENGINE INNODB
                        MUTEX</code></a> can also be enabled by setting
                    <a class="link" href="innodb-storage-engine.html#sysvar_innodb_monitor_enable"><code class="literal">innodb_monitor_enable='all'</code></a>, or
                    disabled by setting
                    <a class="link" href="innodb-storage-engine.html#sysvar_innodb_monitor_disable"><code class="literal">innodb_monitor_disable='all'</code></a>.
                </p><p style="color:blue;">显示引擎innodb mutex的互斥统计信息的收集也可以通过设置innodb_monitor_enable=“all”来启用，或者通过设置innodb_monitor_disable=“all”来禁用。</p><p>
                <a class="link" href="sql-syntax.html#show-engine" title="13.7.5.15&nbsp;SHOW ENGINE Syntax"><code class="literal">SHOW ENGINE INNODB
                    MUTEX</code></a> output has these columns:
            </p><p style="color:blue;">show engine innodb mutex输出有以下列：</p>
                <div class="itemizedlist">
                    <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                        <code class="literal">Type</code>
                    </p><p style="color:blue;">类型</p><p>
                        Always <code class="literal">InnoDB</code>.
                    </p><p style="color:blue;">总是InnoDB。</p></li><li class="listitem"><p>
                        <code class="literal">Name</code>
                    </p><p style="color:blue;">姓名</p><p>
                        Prior to MySQL 5.7.8, the <code class="literal">Name</code> field
                        reports the source file where the mutex is implemented, and
                        the line number in the file where the mutex is created. The
                        line number is specific to your version of MySQL. As of
                        MySQL 5.7.8, only the mutex name is reported. File name and
                        line number are still reported for rwlocks.
                    </p><p style="color:blue;">在mysql 5.7.8之前，name字段报告实现互斥的源文件，以及创建互斥的文件中的行号。行号特定于您的mysql版本。从mysql 5.7.8开始，只报告互斥名称。仍会报告rwlocks的文件名和行号。</p></li><li class="listitem"><p>
                        <code class="literal">Status</code>
                    </p><p style="color:blue;">地位</p><p>
                        The mutex status.
                    </p><p style="color:blue;">互斥状态。</p><p>
                        Prior to MySQL 5.7.8, the <code class="literal">Status</code> field
                        displays several values if
                        <a class="link" href="installing.html#option_cmake_with_debug"><code class="option">WITH_DEBUG</code></a> was defined at
                        MySQL compilation time. If
                        <a class="link" href="installing.html#option_cmake_with_debug"><code class="option">WITH_DEBUG</code></a> was not defined,
                        the statement displays only the <code class="literal">os_waits</code>
                        value. In the latter case (without
                        <a class="link" href="installing.html#option_cmake_with_debug"><code class="option">WITH_DEBUG</code></a>), the information
                        on which the output is based is insufficient to distinguish
                        regular mutexes and mutexes that protect rwlocks (which
                        permit multiple readers or a single writer). Consequently,
                        the output may appear to contain multiple rows for the same
                        mutex. Pre-MySQL 5.7.8 <code class="literal">Status</code> field
                        values include:
                    </p><p style="color:blue;">在mysql 5.7.8之前，如果在mysql编译时定义了with_debug，status字段将显示多个值。如果未定义WITH U DEBUG，则语句仅显示OS U WAITS值。在后一种情况下（不带除错），输出所基于的信息不足以区分常规互斥和保护rwlocks的互斥（允许多个读卡器或单个写卡器）。因此，输出可能包含同一互斥对象的多行。MySQL 5.7.8之前的状态字段值包括：</p>
                        <div class="itemizedlist">
                            <ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
                                <code class="literal">count</code> indicates how many times the
                                mutex was requested.
                            </p><p style="color:blue;">count指示请求互斥锁的次数。</p></li><li class="listitem"><p>
                                <code class="literal">spin_waits</code> indicates how many times
                                the spinlock had to run.
                            </p><p style="color:blue;">spin_waits指示spinlock必须运行多少次。</p></li><li class="listitem"><p>
                                <code class="literal">spin_rounds</code> indicates the number of
                                spinlock rounds. (<code class="literal">spin_rounds</code> divided
                                by <code class="literal">spin_waits</code> provides the average
                                round count.)
                            </p><p style="color:blue;">旋转回合表示旋转锁定回合的数目。（spin_rounds除以spin_waits可提供平均轮数。）</p></li><li class="listitem"><p>
                                <code class="literal">os_waits</code> indicates the number of
                                operating system waits. This occurs when the spinlock
                                did not work (the mutex was not locked during the
                                spinlock and it was necessary to yield to the operating
                                system and wait).
                            </p><p style="color:blue;">os_waits表示操作系统等待的次数。当spinlock不起作用时（互斥锁在spinlock期间没有被锁定，必须屈服于操作系统并等待）。</p></li><li class="listitem"><p>
                                <code class="literal">os_yields</code> indicates the number of
                                times a thread trying to lock a mutex gave up its
                                timeslice and yielded to the operating system (on the
                                presumption that permitting other threads to run will
                                free the mutex so that it can be locked).
                            </p><p style="color:blue;">os_yields表示试图锁定互斥锁的线程放弃其时间间隔并向操作系统屈服的次数（假定允许其他线程运行将释放互斥锁以便锁定它）。</p></li><li class="listitem"><p>
                                <code class="literal">os_wait_times</code> indicates the amount of
                                time (in ms) spent in operating system waits. In MySQL
                                5.7 timing is disabled and this value is
                                always 0.
                            </p><p style="color:blue;">os_wait_times表示操作系统等待的时间（毫秒）。在mysql 5.7中，计时被禁用，并且该值始终为0。</p></li></ul>
                        </div>
                        <p>
                            As of MySQL 5.7.8, the <code class="literal">Status</code> field
                            reports the number of spins, waits, and calls. Statistics
                            for low-level operating system mutexes, which are
                            implemented outside of <code class="literal">InnoDB</code>, are not
                            reported.
                        </p><p style="color:blue;">从mysql 5.7.8开始，status字段报告旋转、等待和调用的次数。不会报告在innodb之外实现的低级操作系统互斥的统计信息。</p>
                        <div class="itemizedlist">
                            <ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
                                <code class="literal">spins</code> indicates the number of spins.
                            </p><p style="color:blue;">旋转表示旋转的次数。</p></li><li class="listitem"><p>
                                <code class="literal">waits</code> indicates the number of mutex
                                waits.
                            </p><p style="color:blue;">waits表示互斥等待的次数。</p></li><li class="listitem"><p>
                                <code class="literal">calls</code> indicates how many times the
                                mutex was requested.
                            </p><p style="color:blue;">调用指示请求互斥锁的次数。</p></li></ul>
                        </div>
                    </li></ul>
                </div>
                <p>
                    <code class="literal">SHOW ENGINE INNODB MUTEX</code> skips the
                    <a class="link" href="glossary.html#glos_mutex" title="mutex">mutexes</a> and
                    <a class="link" href="glossary.html#glos_rw_lock" title="rw-lock">rw-locks</a> of
                    <a class="link" href="glossary.html#glos_buffer_pool" title="buffer pool">buffer pool</a> blocks, as
                    the amount of output can be overwhelming on systems with a large
                    buffer pool. (There is one mutex and one rw-lock in each 16K
                    buffer pool block, and there are 65,536 blocks per gigabyte.)
                    <code class="literal">SHOW ENGINE INNODB MUTEX</code> also does not list
                    any mutexes or rw-locks that have never been waited on
                    (<code class="literal">os_waits=0</code>). Thus, <code class="literal">SHOW ENGINE
                    INNODB MUTEX</code> only displays information about mutexes
                    and rw-locks outside of the buffer pool that have caused at
                    least one OS-level <a class="link" href="glossary.html#glos_wait" title="wait">wait</a>.
                </p><p style="color:blue;">show engine innodb mutex跳过缓冲池块的互斥锁和rw锁，因为在具有大型缓冲池的系统上，输出量可能会非常大。（每个16k缓冲池块中有一个互斥锁和一个rw锁，每千兆字节有65536个块。）show engine innodb mutex也没有列出任何从未等待过的互斥锁或rw锁（os_waits=0）。因此，show engine innodb mutex只显示缓冲池外导致至少一个操作系统级等待的互斥和rw锁的信息。</p><p>
                Use <a class="link" href="sql-syntax.html#show-engine" title="13.7.5.15&nbsp;SHOW ENGINE Syntax"><code class="literal">SHOW ENGINE
                PERFORMANCE_SCHEMA STATUS</code></a> to inspect the internal
                operation of the Performance Schema code:
            </p><p style="color:blue;">使用“显示引擎性能架构状态”检查性能架构代码的内部操作：</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>SHOW ENGINE PERFORMANCE_SCHEMA STATUS\G</code></strong>
...
*************************** 3. row ***************************
  Type: performance_schema
  Name: events_waits_history.size
Status: 76
*************************** 4. row ***************************
  Type: performance_schema
  Name: events_waits_history.count
Status: 10000
*************************** 5. row ***************************
  Type: performance_schema
  Name: events_waits_history.memory
Status: 760000
...
*************************** 57. row ***************************
  Type: performance_schema
  Name: performance_schema.memory
Status: 26459600
...
</pre><p>
                This statement is intended to help the DBA understand the
                effects that different Performance Schema options have on memory
                requirements.
            </p><p style="color:blue;">此语句旨在帮助dba了解不同性能模式选项对内存需求的影响。</p><p>
                <code class="literal">Name</code> values consist of two parts, which name
                an internal buffer and a buffer attribute, respectively.
                Interpret buffer names as follows:
            </p><p style="color:blue;">名称值由两部分组成，分别命名内部缓冲区和缓冲区属性。按如下方式解释缓冲区名称：</p>
                <div class="itemizedlist">
                    <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                        An internal buffer that is not exposed as a table is named
                        within parentheses. Examples:
                        <code class="literal">(pfs_cond_class).size</code>,
                        <code class="literal">(pfs_mutex_class).memory</code>.
                    </p><p style="color:blue;">未公开为表的内部缓冲区在括号内命名。示例：（pfs_cond_class）.大小，（pfs_mutex_class）.内存。</p></li><li class="listitem"><p>
                        An internal buffer that is exposed as a table in the
                        <code class="literal">performance_schema</code> database is named
                        after the table, without parentheses. Examples:
                        <code class="literal">events_waits_history.size</code>,
                        <code class="literal">mutex_instances.count</code>.
                    </p><p style="color:blue;">在性能架构数据库中公开为表的内部缓冲区是以表命名的，不带括号。示例：events_waits_history.size，mutex_instances.count。</p></li><li class="listitem"><p>
                        A value that applies to the Performance Schema as a whole
                        begins with <code class="literal">performance_schema</code>. Example:
                        <code class="literal">performance_schema.memory</code>.
                    </p><p style="color:blue;">应用于整个性能架构的值从性能架构开始。示例：performance_schema.memory。</p></li></ul>
                </div>
                <p>
                    Buffer attributes have these meanings:
                </p><p style="color:blue;">缓冲区属性具有以下含义：</p>
                <div class="itemizedlist">
                    <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                        <code class="literal">size</code> is the size of the internal record
                        used by the implementation, such as the size of a row in a
                        table. <code class="literal">size</code> values cannot be changed.
                    </p><p style="color:blue;">size是实现使用的内部记录的大小，例如表中行的大小。无法更改大小值。</p></li><li class="listitem"><p>
                        <code class="literal">count</code> is the number of internal records,
                        such as the number of rows in a table.
                        <code class="literal">count</code> values can be changed using
                        Performance Schema configuration options.
                    </p><p style="color:blue;">count是内部记录的数目，例如表中的行数。可以使用性能架构配置选项更改计数值。</p></li><li class="listitem"><p>
                        For a table,
                        <code class="literal"><em class="replaceable"><code>tbl_name</code></em>.memory</code>
                        is the product of <code class="literal">size</code> and
                        <code class="literal">count</code>. For the Performance Schema as a
                        whole, <code class="literal">performance_schema.memory</code> is the
                        sum of all the memory used (the sum of all other
                        <code class="literal">memory</code> values).
                    </p><p style="color:blue;">对于表，tbl_name.memory是大小和计数的乘积。对于整个性能模式，performance_schema.memory是所有使用的内存的总和（所有其他内存值的总和）。</p></li></ul>
                </div>
                <p>
                    In some cases, there is a direct relationship between a
                    Performance Schema configuration parameter and a <code class="literal">SHOW
                    ENGINE</code> value. For example,
                    <code class="literal">events_waits_history_long.count</code> corresponds
                    to
                    <a class="link" href="performance-schema.html#sysvar_performance_schema_events_waits_history_long_size"><code class="literal">performance_schema_events_waits_history_long_size</code></a>.
                    In other cases, the relationship is more complex. For example,
                    <code class="literal">events_waits_history.count</code> corresponds to
                    <a class="link" href="performance-schema.html#sysvar_performance_schema_events_waits_history_size"><code class="literal">performance_schema_events_waits_history_size</code></a>
                    (the number of rows per thread) multiplied by
                    <a class="link" href="performance-schema.html#sysvar_performance_schema_max_thread_instances"><code class="literal">performance_schema_max_thread_instances</code></a>
                    ( the number of threads).
                </p><p style="color:blue;">在某些情况下，性能模式配置参数和显示引擎值之间存在直接关系。例如，events_waits_history_long.count对应于performance_schema_events_waits_history_long_size。在其他情况下，这种关系更为复杂。例如，events_waits_history.count对应于performance_schema_events_waits_history_size（每个线程的行数）乘以performance_schema_max_thread_instances（线程数）。</p><p><a name="show-engine-ndb-status"></a><b>SHOW ENGINE NDB STATUS.&nbsp;</b>
                If the server has the <a class="link" href="mysql-cluster.html" title="Chapter&nbsp;21&nbsp;MySQL NDB Cluster 7.5 and NDB Cluster 7.6"><code class="literal">NDB</code></a> storage
                engine enabled, <code class="literal">SHOW ENGINE NDB STATUS</code>
                displays cluster status information such as the number of
                connected data nodes, the cluster connectstring, and cluster
                binary log epochs, as well as counts of various Cluster API
                objects created by the MySQL Server when connected to the
                cluster. Sample output from this statement is shown here:
            </p><p style="color:blue;">显示引擎ndb状态。如果服务器启用了ndb存储引擎，show engine ndb status将显示群集状态信息，如连接的数据节点数、群集连接字符串和群集二进制日志段，以及连接到群集时mysql服务器创建的各种群集api对象的计数。此语句的示例输出如下所示：</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>SHOW ENGINE NDB STATUS;</code></strong>
+------------+-----------------------+--------------------------------------------------+
| Type       | Name                  | Status                                           |
+------------+-----------------------+--------------------------------------------------+
| ndbcluster | connection            | cluster_node_id=7,
  connected_host=198.51.100.103, connected_port=1186, number_of_data_nodes=4,
  number_of_ready_data_nodes=3, connect_count=0                                         |
| ndbcluster | NdbTransaction        | created=6, free=0, sizeof=212                    |
| ndbcluster | NdbOperation          | created=8, free=8, sizeof=660                    |
| ndbcluster | NdbIndexScanOperation | created=1, free=1, sizeof=744                    |
| ndbcluster | NdbIndexOperation     | created=0, free=0, sizeof=664                    |
| ndbcluster | NdbRecAttr            | created=1285, free=1285, sizeof=60               |
| ndbcluster | NdbApiSignal          | created=16, free=16, sizeof=136                  |
| ndbcluster | NdbLabel              | created=0, free=0, sizeof=196                    |
| ndbcluster | NdbBranch             | created=0, free=0, sizeof=24                     |
| ndbcluster | NdbSubroutine         | created=0, free=0, sizeof=68                     |
| ndbcluster | NdbCall               | created=0, free=0, sizeof=16                     |
| ndbcluster | NdbBlob               | created=1, free=1, sizeof=264                    |
| ndbcluster | NdbReceiver           | created=4, free=0, sizeof=68                     |
| ndbcluster | binlog                | latest_epoch=155467, latest_trans_epoch=148126,
  latest_received_binlog_epoch=0, latest_handled_binlog_epoch=0,
  latest_applied_binlog_epoch=0                                                         |
+------------+-----------------------+--------------------------------------------------+
</pre><p>
                The <code class="literal">Status</code> column in each of these rows
                provides information about the MySQL server's connection to
                the cluster and about the cluster binary log's status,
                respectively. The <code class="literal">Status</code> information is in
                the form of comma-delimited set of name/value pairs.
            </p><p style="color:blue;">这些行中的status列分别提供有关mysql服务器到集群的连接和集群二进制日志状态的信息。状态信息采用逗号分隔的名称/值对集的形式。</p><p>
                The <code class="literal">connection</code> row's
                <code class="literal">Status</code> column contains the name/value pairs
                described in the following table.
            </p><p style="color:blue;">连接行的status列包含下表中描述的名称/值对。</p>
                <div class="informaltable">
                    <table summary="Name and value pairs found in the connection row Status column in the output of the SHOW ENGINE NDB STATUS statement."><colgroup><col width="40%"><col width="60%"></colgroup><thead><tr>
                        <th scope="col">Name</th>
                        <th scope="col">Value</th>
                    </tr></thead><tbody><tr>
                        <td scope="row"><code class="literal">cluster_node_id</code></td>
                        <td>The node ID of the MySQL server in the cluster</td>
                    </tr><tr>
                        <td scope="row"><code class="literal">connected_host</code></td>
                        <td>The host name or IP address of the cluster management server to which
                            the MySQL server is connected</td>
                    </tr><tr>
                        <td scope="row"><code class="literal">connected_port</code></td>
                        <td>The port used by the MySQL server to connect to the management server
                            (<code class="literal">connected_host</code>)</td>
                    </tr><tr>
                        <td scope="row"><code class="literal">number_of_data_nodes</code></td>
                        <td>The number of data nodes configured for the cluster (that is, the number
                            of <code class="literal">[ndbd]</code> sections in the cluster
                            <code class="filename">config.ini</code> file)</td>
                    </tr><tr>
                        <td scope="row"><code class="literal">number_of_ready_data_nodes</code></td>
                        <td>The number of data nodes in the cluster that are actually running</td>
                    </tr><tr>
                        <td scope="row"><code class="literal">connect_count</code></td>
                        <td>The number of times this <a class="link" href="programs.html#mysqld" title="4.3.1&nbsp;mysqld — The MySQL Server"><span class="command"><strong>mysqld</strong></span></a> has connected or
                            reconnected to cluster data nodes</td>
                    </tr></tbody></table>
                </div>
                <p>
                    The <code class="literal">binlog</code> row's
                    <code class="literal">Status</code> column contains information relating
                    to NDB Cluster Replication. The name/value pairs it contains are
                    described in the following table.
                </p><p style="color:blue;">binlog行的status列包含与ndb集群复制相关的信息。下表描述了它包含的名称/值对。</p>
                <div class="informaltable">
                    <table summary="Name and value pairs found in the binlog row Status column in the output of the SHOW ENGINE NDB STATUS statement."><colgroup><col width="40%"><col width="60%"></colgroup><thead><tr>
                        <th scope="col">Name</th>
                        <th scope="col">Value</th>
                    </tr></thead><tbody><tr>
                        <td scope="row"><code class="literal">latest_epoch</code></td>
                        <td>The most recent epoch most recently run on this MySQL server (that is,
                            the sequence number of the most recent transaction run on
                            the server)</td>
                    </tr><tr>
                        <td scope="row"><code class="literal">latest_trans_epoch</code></td>
                        <td>The most recent epoch processed by the cluster's data nodes</td>
                    </tr><tr>
                        <td scope="row"><code class="literal">latest_received_binlog_epoch</code></td>
                        <td>The most recent epoch received by the binary log thread</td>
                    </tr><tr>
                        <td scope="row"><code class="literal">latest_handled_binlog_epoch</code></td>
                        <td>The most recent epoch processed by the binary log thread (for writing to
                            the binary log)</td>
                    </tr><tr>
                        <td scope="row"><code class="literal">latest_applied_binlog_epoch</code></td>
                        <td>The most recent epoch actually written to the binary log</td>
                    </tr></tbody></table>
                </div>
                <p>
                    See <a class="xref" href="mysql-cluster.html#mysql-cluster-replication" title="21.6&nbsp;NDB Cluster Replication">Section&nbsp;21.6, “NDB Cluster Replication”</a>, for more
                    information.
                </p><p style="color:blue;">有关详细信息，请参阅21.6节“NDB群集复制”。</p><p>
                The remaining rows from the output of <code class="literal">SHOW ENGINE NDB
                STATUS</code> which are most likely to prove useful in
                monitoring the cluster are listed here by
                <code class="literal">Name</code>:
            </p><p style="color:blue;">show engine ndb status输出中最有可能用于监视集群的其余行按名称列出：</p>
                <div class="itemizedlist">
                    <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                        <code class="literal">NdbTransaction</code>: The number and size of
                        <code class="literal">NdbTransaction</code> objects that have been
                        created. An <code class="literal">NdbTransaction</code> is created
                        each time a table schema operation (such as
                        <a class="link" href="sql-syntax.html#create-table" title="13.1.18&nbsp;CREATE TABLE Syntax"><code class="literal">CREATE TABLE</code></a> or
                        <a class="link" href="sql-syntax.html#alter-table" title="13.1.8&nbsp;ALTER TABLE Syntax"><code class="literal">ALTER TABLE</code></a>) is performed on
                        an <a class="link" href="mysql-cluster.html" title="Chapter&nbsp;21&nbsp;MySQL NDB Cluster 7.5 and NDB Cluster 7.6"><code class="literal">NDB</code></a> table.
                    </p><p style="color:blue;">ndbtransaction：已创建的ndbtransaction对象的数量和大小。每次对ndb表执行表架构操作（如create table或alter table）时，都会创建ndbtransaction。</p></li><li class="listitem"><p>
                        <code class="literal">NdbOperation</code>: The number and size of
                        <code class="literal">NdbOperation</code> objects that have been
                        created.
                    </p><p style="color:blue;">ndbooperation：已创建的ndbooperation对象的数量和大小。</p></li><li class="listitem"><p>
                        <code class="literal">NdbIndexScanOperation</code>: The number and
                        size of <code class="literal">NdbIndexScanOperation</code> objects
                        that have been created.
                    </p><p style="color:blue;">ndbindexscanoperation：已创建的ndbindexscanoperation对象的数目和大小。</p></li><li class="listitem"><p>
                        <code class="literal">NdbIndexOperation</code>: The number and size of
                        <code class="literal">NdbIndexOperation</code> objects that have been
                        created.
                    </p><p style="color:blue;">ndbindexoperation：已创建的ndbindexoperation对象的数量和大小。</p></li><li class="listitem"><p>
                        <code class="literal">NdbRecAttr</code>: The number and size of
                        <code class="literal">NdbRecAttr</code> objects that have been
                        created. In general, one of these is created each time a
                        data manipulation statement is performed by an SQL node.
                    </p><p style="color:blue;">ndbrecatrt：已创建的ndbrecatrt对象的数量和大小。通常，每次sql节点执行数据操作语句时都会创建其中一个。</p></li><li class="listitem"><p>
                        <code class="literal">NdbBlob</code>: The number and size of
                        <code class="literal">NdbBlob</code> objects that have been created.
                        An <code class="literal">NdbBlob</code> is created for each new
                        operation involving a <a class="link" href="data-types.html#blob" title="11.4.3&nbsp;The BLOB and TEXT Types"><code class="literal">BLOB</code></a>
                        column in an <a class="link" href="mysql-cluster.html" title="Chapter&nbsp;21&nbsp;MySQL NDB Cluster 7.5 and NDB Cluster 7.6"><code class="literal">NDB</code></a> table.
                    </p><p style="color:blue;">ndbblob：已创建的ndbblob对象的数量和大小。为每个涉及ndb表中blob列的新操作创建ndbblob。</p></li><li class="listitem"><p>
                        <code class="literal">NdbReceiver</code>: The number and size of any
                        <code class="literal">NdbReceiver</code> object that have been
                        created. The number in the <code class="literal">created</code> column
                        is the same as the number of data nodes in the cluster to
                        which the MySQL server has connected.
                    </p><p style="color:blue;">ndbreceiver：已创建的任何ndbreceiver对象的数量和大小。created列中的数字与mysql服务器连接到的集群中的数据节点数相同。</p></li></ul>
                </div>
                <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">
                    <div class="admon-title">
                        Note
                    </div>
                    <p>
                        <code class="literal">SHOW ENGINE NDB STATUS</code> returns an empty
                        result if no operations involving
                        <a class="link" href="mysql-cluster.html" title="Chapter&nbsp;21&nbsp;MySQL NDB Cluster 7.5 and NDB Cluster 7.6"><code class="literal">NDB</code></a> tables have been performed
                        during the current session by the MySQL client accessing the
                        SQL node on which this statement is run.
                    </p><p style="color:blue;">如果mysql客户端在当前会话期间没有执行任何涉及ndb表的操作，则show engine ndb status返回空结果，mysql客户端访问运行此语句的sql节点。</p>
                </div>

            </div>
            <div class="section">
                <div class="titlepage">
                    <div>
                        <div>
                            <h4 class="title"><a name="show-engines"></a>13.7.5.16&nbsp;SHOW ENGINES Syntax</h4>

                        </div>

                    </div>

                </div>
                <a class="indexterm" name="idm140286827159360"></a><a class="indexterm" name="idm140286827158288"></a><pre data-lang="sql" class="programlisting">SHOW [STORAGE] ENGINES
</pre><p>
                <a class="link" href="sql-syntax.html#show-engines" title="13.7.5.16&nbsp;SHOW ENGINES Syntax"><code class="literal">SHOW ENGINES</code></a> displays status
                information about the server's storage engines. This is
                particularly useful for checking whether a storage engine is
                supported, or to see what the default engine is.
            </p><p style="color:blue;">显示引擎显示有关服务器存储引擎的状态信息。这对于检查存储引擎是否受支持或查看默认引擎是什么特别有用。</p><p>
                For information about MySQL storage engines, see
                <a class="xref" href="innodb-storage-engine.html" title="Chapter&nbsp;14&nbsp;The InnoDB Storage Engine">Chapter&nbsp;14, <i>The InnoDB Storage Engine</i></a>, and
                <a class="xref" href="storage-engines.html" title="Chapter&nbsp;15&nbsp;Alternative Storage Engines">Chapter&nbsp;15, <i>Alternative Storage Engines</i></a>.
            </p><p style="color:blue;">有关mysql存储引擎的信息，请参阅第14章，innodb存储引擎和第15章，备用存储引擎。</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>SHOW ENGINES\G</code></strong>
*************************** 1. row ***************************
      Engine: InnoDB
     Support: DEFAULT
     Comment: Supports transactions, row-level locking, and foreign keys
Transactions: YES
          XA: YES
  Savepoints: YES
*************************** 2. row ***************************
      Engine: MRG_MYISAM
     Support: YES
     Comment: Collection of identical MyISAM tables
Transactions: NO
          XA: NO
  Savepoints: NO
*************************** 3. row ***************************
      Engine: MEMORY
     Support: YES
     Comment: Hash based, stored in memory, useful for temporary tables
Transactions: NO
          XA: NO
  Savepoints: NO
*************************** 4. row ***************************
      Engine: BLACKHOLE
     Support: YES
     Comment: /dev/null storage engine (anything you write to it disappears)
Transactions: NO
          XA: NO
  Savepoints: NO
*************************** 5. row ***************************
      Engine: MyISAM
     Support: YES
     Comment: MyISAM storage engine
Transactions: NO
          XA: NO
  Savepoints: NO
*************************** 6. row ***************************
      Engine: CSV
     Support: YES
     Comment: CSV storage engine
Transactions: NO
          XA: NO
  Savepoints: NO
*************************** 7. row ***************************
      Engine: ARCHIVE
     Support: YES
     Comment: Archive storage engine
Transactions: NO
          XA: NO
  Savepoints: NO
*************************** 8. row ***************************
      Engine: PERFORMANCE_SCHEMA
     Support: YES
     Comment: Performance Schema
Transactions: NO
          XA: NO
  Savepoints: NO
*************************** 9. row ***************************
      Engine: FEDERATED
     Support: YES
     Comment: Federated MySQL storage engine
Transactions: NO
          XA: NO
  Savepoints: NO
</pre><p>
                The output from <a class="link" href="sql-syntax.html#show-engines" title="13.7.5.16&nbsp;SHOW ENGINES Syntax"><code class="literal">SHOW ENGINES</code></a> may
                vary according to the MySQL version used and other factors.
            </p><p style="color:blue;">根据使用的mysql版本和其他因素，显示引擎的输出可能会有所不同。</p><p>
                <a class="link" href="sql-syntax.html#show-engines" title="13.7.5.16&nbsp;SHOW ENGINES Syntax"><code class="literal">SHOW ENGINES</code></a> output has these
                columns:
            </p><p style="color:blue;">显示引擎输出包含以下列：</p>
                <div class="itemizedlist">
                    <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                        <code class="literal">Engine</code>
                    </p><p style="color:blue;">发动机</p><p>
                        The name of the storage engine.
                    </p><p style="color:blue;">存储引擎的名称。</p></li><li class="listitem"><p>
                        <code class="literal">Support</code>
                    </p><p style="color:blue;">支持</p><p>
                        The server's level of support for the storage engine, as
                        shown in the following table.
                    </p><p style="color:blue;">服务器对存储引擎的支持级别，如下表所示。</p>
                        <div class="informaltable">
                            <table summary="Values for the Support column in the output of the SHOW ENGINES statement."><colgroup><col width="15%"><col width="85%"></colgroup><thead><tr>
                                <th scope="col">Value</th>
                                <th scope="col">Meaning</th>
                            </tr></thead><tbody><tr>
                                <td scope="row"><code class="literal">YES</code></td>
                                <td>The engine is supported and is active</td>
                            </tr><tr>
                                <td scope="row"><code class="literal">DEFAULT</code></td>
                                <td>Like <code class="literal">YES</code>, plus this is the default engine</td>
                            </tr><tr>
                                <td scope="row"><code class="literal">NO</code></td>
                                <td>The engine is not supported</td>
                            </tr><tr>
                                <td scope="row"><code class="literal">DISABLED</code></td>
                                <td>The engine is supported but has been disabled</td>
                            </tr></tbody></table>
                        </div>
                        <p>
                            A value of <code class="literal">NO</code> means that the server was
                            compiled without support for the engine, so it cannot be
                            enabled at runtime.
                        </p><p style="color:blue;">值no意味着服务器是在不支持引擎的情况下编译的，因此无法在运行时启用它。</p><p>
                            A value of <code class="literal">DISABLED</code> occurs either because
                            the server was started with an option that disables the
                            engine, or because not all options required to enable it
                            were given. In the latter case, the error log should contain
                            a reason indicating why the option is disabled. See
                            <a class="xref" href="server-administration.html#error-log" title="5.4.2&nbsp;The Error Log">Section&nbsp;5.4.2, “The Error Log”</a>.
                        </p><p style="color:blue;">发生值disabled的原因可能是服务器是使用禁用引擎的选项启动的，也可能是没有提供启用该引擎所需的所有选项。在后一种情况下，错误日志应该包含一个原因，说明为什么禁用该选项。见第5.4.2节“错误日志”。</p><p>
                            You might also see <code class="literal">DISABLED</code> for a storage
                            engine if the server was compiled to support it, but was
                            started with a
                            <code class="option">--skip-<em class="replaceable"><code>engine_name</code></em></code>
                            option. For the <a class="link" href="mysql-cluster.html" title="Chapter&nbsp;21&nbsp;MySQL NDB Cluster 7.5 and NDB Cluster 7.6"><code class="literal">NDB</code></a> storage
                            engine, <code class="literal">DISABLED</code> means the server was
                            compiled with support for NDB Cluster, but was not started
                            with the <a class="link" href="mysql-cluster.html#option_mysqld_ndbcluster"><code class="option">--ndbcluster</code></a> option.
                        </p><p style="color:blue;">如果服务器被编译为支持存储引擎，但启动时使用了--skip-engine_-name选项，则可能会看到存储引擎被禁用。对于ndb存储引擎，禁用意味着服务器是在支持ndb群集的情况下编译的，但不是使用--ndb cluster选项启动的。</p><p>
                            All MySQL servers support <code class="literal">MyISAM</code> tables.
                            It is not possible to disable <code class="literal">MyISAM</code>.
                        </p><p style="color:blue;">所有mysql服务器都支持myisam表。无法禁用Myisam。</p></li><li class="listitem"><p>
                        <code class="literal">Comment</code>
                    </p><p style="color:blue;">评论</p><p>
                        A brief description of the storage engine.
                    </p><p style="color:blue;">存储引擎的简要说明。</p></li><li class="listitem"><p>
                        <code class="literal">Transactions</code>
                    </p><p style="color:blue;">交易</p><p>
                        Whether the storage engine supports transactions.
                    </p><p style="color:blue;">存储引擎是否支持事务。</p></li><li class="listitem"><p>
                        <code class="literal">XA</code>
                    </p><p style="color:blue;">Xa公司</p><p>
                        Whether the storage engine supports XA transactions.
                    </p><p style="color:blue;">存储引擎是否支持xa事务。</p></li><li class="listitem"><p>
                        <code class="literal">Savepoints</code>
                    </p><p style="color:blue;">保存点</p><p>
                        Whether the storage engine supports savepoints.
                    </p><p style="color:blue;">存储引擎是否支持保存点。</p></li></ul>
                </div>
                <p>
                    Storage engine information is also available from the
                    <code class="literal">INFORMATION_SCHEMA</code>
                    <a class="link" href="information-schema.html#engines-table" title="24.7&nbsp;The INFORMATION_SCHEMA ENGINES Table"><code class="literal">ENGINES</code></a> table. See
                    <a class="xref" href="information-schema.html#engines-table" title="24.7&nbsp;The INFORMATION_SCHEMA ENGINES Table">Section&nbsp;24.7, “The INFORMATION_SCHEMA ENGINES Table”</a>.
                </p><p style="color:blue;">存储引擎信息也可以从信息架构引擎表中获得。参见第24.7节“信息模式引擎表”。</p>
            </div>
            <div class="section">
                <div class="titlepage">
                    <div>
                        <div>
                            <h4 class="title"><a name="show-errors"></a>13.7.5.17&nbsp;SHOW ERRORS Syntax</h4>

                        </div>

                    </div>

                </div>
                <a class="indexterm" name="idm140286827096224"></a><a class="indexterm" name="idm140286827095152"></a><pre data-lang="sql" class="programlisting">SHOW ERRORS [LIMIT [<em class="replaceable"><code>offset</code></em>,] <em class="replaceable"><code>row_count</code></em>]
SHOW COUNT(*) ERRORS
</pre><p>
                <a class="link" href="sql-syntax.html#show-errors" title="13.7.5.17&nbsp;SHOW ERRORS Syntax"><code class="literal">SHOW ERRORS</code></a> is a diagnostic
                statement that is similar to <a class="link" href="sql-syntax.html#show-warnings" title="13.7.5.40&nbsp;SHOW WARNINGS Syntax"><code class="literal">SHOW
                WARNINGS</code></a>, except that it displays information only for
                errors, rather than for errors, warnings, and notes.
            </p><p style="color:blue;">show errors是一种类似于show warnings的诊断语句，只是它只显示错误的信息，而不显示错误、警告和注释的信息。</p><p>
                The <code class="literal">LIMIT</code> clause has the same syntax as for
                the <a class="link" href="sql-syntax.html#select" title="13.2.9&nbsp;SELECT Syntax"><code class="literal">SELECT</code></a> statement. See
                <a class="xref" href="sql-syntax.html#select" title="13.2.9&nbsp;SELECT Syntax">Section&nbsp;13.2.9, “SELECT Syntax”</a>.
            </p><p style="color:blue;">LIMIT子句的语法与SELECT语句的语法相同。参见第13.2.9节“选择语法”。</p><p>
                The <a class="link" href="sql-syntax.html#show-errors" title="13.7.5.17&nbsp;SHOW ERRORS Syntax"><code class="literal">SHOW COUNT(*)
                ERRORS</code></a> statement displays the number of errors. You
                can also retrieve this number from the
                <a class="link" href="server-administration.html#sysvar_error_count"><code class="literal">error_count</code></a> variable:
            </p><p style="color:blue;">show count（*）errors语句显示错误数。您还可以从错误计数变量中检索此数字：</p><pre data-lang="sql" class="programlisting">SHOW COUNT(*) ERRORS;
SELECT @@error_count;
</pre><p>
                <a class="link" href="sql-syntax.html#show-errors" title="13.7.5.17&nbsp;SHOW ERRORS Syntax"><code class="literal">SHOW ERRORS</code></a> and
                <a class="link" href="server-administration.html#sysvar_error_count"><code class="literal">error_count</code></a> apply only to
                errors, not warnings or notes. In other respects, they are
                similar to <a class="link" href="sql-syntax.html#show-warnings" title="13.7.5.40&nbsp;SHOW WARNINGS Syntax"><code class="literal">SHOW WARNINGS</code></a> and
                <a class="link" href="server-administration.html#sysvar_warning_count"><code class="literal">warning_count</code></a>. In particular,
                <a class="link" href="sql-syntax.html#show-errors" title="13.7.5.17&nbsp;SHOW ERRORS Syntax"><code class="literal">SHOW ERRORS</code></a> cannot display
                information for more than
                <a class="link" href="server-administration.html#sysvar_max_error_count"><code class="literal">max_error_count</code></a> messages, and
                <a class="link" href="server-administration.html#sysvar_error_count"><code class="literal">error_count</code></a> can exceed the
                value of <a class="link" href="server-administration.html#sysvar_max_error_count"><code class="literal">max_error_count</code></a> if the
                number of errors exceeds
                <a class="link" href="server-administration.html#sysvar_max_error_count"><code class="literal">max_error_count</code></a>.
            </p><p style="color:blue;">显示错误和错误计数仅适用于错误，不适用于警告或注释。在其他方面，它们类似于显示警告和警告计数。特别是，“显示错误”不能显示超过“最大错误计数”消息的信息，如果错误数超过“最大错误计数”，则“错误计数”可以超过“最大错误计数”的值。</p><p>
                For more information, see <a class="xref" href="sql-syntax.html#show-warnings" title="13.7.5.40&nbsp;SHOW WARNINGS Syntax">Section&nbsp;13.7.5.40, “SHOW WARNINGS Syntax”</a>.
            </p><p style="color:blue;">有关详细信息，请参阅第13.7.5.40节“显示警告语法”。</p>
            </div>
            <div class="section">
                <div class="titlepage">
                    <div>
                        <div>
                            <h4 class="title"><a name="show-events"></a>13.7.5.18&nbsp;SHOW EVENTS Syntax</h4>

                        </div>

                    </div>

                </div>
                <a class="indexterm" name="idm140286827065200"></a><pre data-lang="sql" class="programlisting">SHOW EVENTS
    [{FROM | IN} <em class="replaceable"><code>schema_name</code></em>]
    [LIKE '<em class="replaceable"><code>pattern</code></em>' | WHERE <em class="replaceable"><code>expr</code></em>]
</pre><p>
                This statement displays information about Event Manager events,
                which are discussed in <a class="xref" href="stored-objects.html#event-scheduler" title="23.4&nbsp;Using the Event Scheduler">Section&nbsp;23.4, “Using the Event Scheduler”</a>. It
                requires the <a class="link" href="security.html#priv_event"><code class="literal">EVENT</code></a> privilege for
                the database from which the events are to be shown.
            </p><p style="color:blue;">此语句显示有关事件管理器事件的信息，在第23.4节“使用事件调度程序”中进行了讨论。它需要显示事件的数据库的事件特权。</p><p>
                In its simplest form, <a class="link" href="sql-syntax.html#show-events" title="13.7.5.18&nbsp;SHOW EVENTS Syntax"><code class="literal">SHOW EVENTS</code></a>
                lists all of the events in the current schema:
            </p><p style="color:blue;">show events以最简单的形式列出当前架构中的所有事件：</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT CURRENT_USER(), SCHEMA();</code></strong>
+----------------+----------+
| CURRENT_USER() | SCHEMA() |
+----------------+----------+
| jon@ghidora    | myschema |
+----------------+----------+
1 row in set (0.00 sec)

mysql&gt; <strong class="userinput"><code>SHOW EVENTS\G</code></strong>
*************************** 1. row ***************************
                  Db: myschema
                Name: e_daily
             Definer: jon@ghidora
           Time zone: SYSTEM
                Type: RECURRING
          Execute at: NULL
      Interval value: 1
      Interval field: DAY
              Starts: 2018-08-08 11:06:34
                Ends: NULL
              Status: ENABLED
          Originator: 1
character_set_client: utf8
collation_connection: utf8_general_ci
  Database Collation: latin1_swedish_ci
</pre><p>
                To see events for a specific schema, use the
                <code class="literal">FROM</code> clause. For example, to see events for
                the <code class="literal">test</code> schema, use the following statement:
            </p><p style="color:blue;">要查看特定架构的事件，请使用from子句。例如，要查看测试架构的事件，请使用以下语句：</p><pre data-lang="sql" class="programlisting">SHOW EVENTS FROM test;
</pre><p>
                The <a class="link" href="functions.html#operator_like"><code class="literal">LIKE</code></a> clause, if present,
                indicates which event names to match. The
                <code class="literal">WHERE</code> clause can be given to select rows
                using more general conditions, as discussed in
                <a class="xref" href="information-schema.html#extended-show" title="24.35&nbsp;Extensions to SHOW Statements">Section&nbsp;24.35, “Extensions to SHOW Statements”</a>.
            </p><p style="color:blue;">LIKE子句（如果存在）指示要匹配的事件名称。where子句可用于使用更一般的条件选择行，如第24.35节“显示语句的扩展”所述。</p><p>
                <a class="link" href="sql-syntax.html#show-events" title="13.7.5.18&nbsp;SHOW EVENTS Syntax"><code class="literal">SHOW EVENTS</code></a> output has these
                columns:
            </p><p style="color:blue;">显示事件输出具有以下列：</p>
                <div class="itemizedlist">
                    <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                        <code class="literal">Db</code>
                    </p><p style="color:blue;">分贝</p><p>
                        The name of the schema (database) to which the event
                        belongs.
                    </p><p style="color:blue;">事件所属架构（数据库）的名称。</p></li><li class="listitem"><p>
                        <code class="literal">Name</code>
                    </p><p style="color:blue;">姓名</p><p>
                        The name of the event.
                    </p><p style="color:blue;">事件的名称。</p></li><li class="listitem"><p>
                        <code class="literal">Definer</code>
                    </p><p style="color:blue;">定义者</p><p>
                        The account of the user who created the event, in
                        <code class="literal">'<em class="replaceable"><code>user_name</code></em>'@'<em class="replaceable"><code>host_name</code></em>'</code>
                        format.
                    </p><p style="color:blue;">以“用户名”@“主机名”格式创建事件的用户的帐户。</p></li><li class="listitem"><p>
                        <code class="literal">Time zone</code>
                    </p><p style="color:blue;">时区</p><p>
                        The event time zone, which is the time zone used for
                        scheduling the event and that is in effect within the event
                        as it executes. The default value is
                        <code class="literal">SYSTEM</code>.
                    </p><p style="color:blue;">事件时区，用于调度事件的时区，在事件执行时在事件内有效。默认值为系统。</p></li><li class="listitem"><p>
                        <code class="literal">Type</code>
                    </p><p style="color:blue;">类型</p><p>
                        The event repetition type, either <code class="literal">ONE
                        TIME</code> (transient) or <code class="literal">RECURRING</code>
                        (repeating).
                    </p><p style="color:blue;">事件重复类型，一次（暂时）或重复（重复）。</p></li><li class="listitem"><p>
                        <code class="literal">Execute At</code>
                    </p><p style="color:blue;">执行于</p><p>
                        For a one-time event, this is the
                        <a class="link" href="data-types.html#datetime" title="11.3.1&nbsp;The DATE, DATETIME, and TIMESTAMP Types"><code class="literal">DATETIME</code></a> value specified in
                        the <code class="literal">AT</code> clause of the
                        <a class="link" href="sql-syntax.html#create-event" title="13.1.12&nbsp;CREATE EVENT Syntax"><code class="literal">CREATE EVENT</code></a> statement used
                        to create the event, or of the last
                        <a class="link" href="sql-syntax.html#alter-event" title="13.1.2&nbsp;ALTER EVENT Syntax"><code class="literal">ALTER EVENT</code></a> statement that
                        modified the event. The value shown in this column reflects
                        the addition or subtraction of any
                        <code class="literal">INTERVAL</code> value included in the event's
                        <code class="literal">AT</code> clause. For example, if an event is
                        created using <code class="literal">ON SCHEDULE AT CURRENT_TIMESTAMP +
                        '1:6' DAY_HOUR</code>, and the event was created at
                        2018-02-09 14:05:30, the value shown in this column would be
                        <code class="literal">'2018-02-10 20:05:30'</code>. If the event's
                        timing is determined by an <code class="literal">EVERY</code> clause
                        instead of an <code class="literal">AT</code> clause (that is, if the
                        event is recurring), the value of this column is
                        <code class="literal">NULL</code>.
                    </p><p style="color:blue;">对于一次性事件，这是用于创建事件的create event语句的at子句或修改事件的最后一条alter event语句中指定的datetime值。此列中显示的值反映事件at子句中包含的任何间隔值的加减。例如，如果使用“按计划”在当前时间戳+“1:6”天时创建事件，并且该事件是在2018-02-09 14:05:30创建的，则此列中显示的值将为“2018-02-10 20:05:30”。如果事件的时间由every子句而不是at子句确定（即，如果事件是重复的），则此列的值为空。</p></li><li class="listitem"><p>
                        <code class="literal">Interval Value</code>
                    </p><p style="color:blue;">区间值</p><p>
                        For a recurring event, the number of intervals to wait
                        between event executions. For a transient event, the value
                        of this column is always <code class="literal">NULL</code>.
                    </p><p style="color:blue;">对于重复事件，事件执行之间等待的间隔数。对于临时事件，此列的值始终为空。</p></li><li class="listitem"><p>
                        <code class="literal">Interval Field</code>
                    </p><p style="color:blue;">区间域</p><p>
                        The time units used for the interval which a recurring event
                        waits before repeating. For a transient event, the value of
                        this column is always <code class="literal">NULL</code>.
                    </p><p style="color:blue;">重复事件在重复之前等待的时间间隔所用的时间单位。对于临时事件，此列的值始终为空。</p></li><li class="listitem"><p>
                        <code class="literal">Starts</code>
                    </p><p style="color:blue;">开始</p><p>
                        The start date and time for a recurring event. This is
                        displayed as a <a class="link" href="data-types.html#datetime" title="11.3.1&nbsp;The DATE, DATETIME, and TIMESTAMP Types"><code class="literal">DATETIME</code></a>
                        value, and is <code class="literal">NULL</code> if no start date and
                        time are defined for the event. For a transient event, this
                        column is always <code class="literal">NULL</code>. For a recurring
                        event whose definition includes a <code class="literal">STARTS</code>
                        clause, this column contains the corresponding
                        <a class="link" href="data-types.html#datetime" title="11.3.1&nbsp;The DATE, DATETIME, and TIMESTAMP Types"><code class="literal">DATETIME</code></a> value. As with the
                        <code class="literal">Execute At</code> column, this value resolves
                        any expressions used. If there is no
                        <code class="literal">STARTS</code> clause affecting the timing of the
                        event, this column is <code class="literal">NULL</code>
                    </p><p style="color:blue;">重复事件的开始日期和时间。这将显示为日期时间值，如果没有为事件定义开始日期和时间，则为空。对于临时事件，此列始终为空。对于定义包含starts子句的定期事件，此列包含相应的datetime值。与execute at列一样，此值解析使用的任何表达式。如果没有影响事件计时的starts子句，则此列为空</p></li><li class="listitem"><p>
                        <code class="literal">Ends</code>
                    </p><p style="color:blue;">末端</p><p>
                        For a recurring event whose definition includes a
                        <code class="literal">ENDS</code> clause, this column contains the
                        corresponding <a class="link" href="data-types.html#datetime" title="11.3.1&nbsp;The DATE, DATETIME, and TIMESTAMP Types"><code class="literal">DATETIME</code></a> value.
                        As with the <code class="literal">Execute At</code> column, this value
                        resolves any expressions used. If there is no
                        <code class="literal">ENDS</code> clause affecting the timing of the
                        event, this column is <code class="literal">NULL</code>.
                    </p><p style="color:blue;">对于定义包含ENDS子句的定期事件，此列包含相应的日期时间值。与execute at列一样，此值解析使用的任何表达式。如果没有影响事件计时的ENDS子句，则此列为空。</p></li><li class="listitem"><p>
                        <code class="literal">Status</code>
                    </p><p style="color:blue;">地位</p><p>
                        The event status. One of <code class="literal">ENABLED</code>,
                        <code class="literal">DISABLED</code>, or
                        <code class="literal">SLAVESIDE_DISABLED</code>.
                        <code class="literal">SLAVESIDE_DISABLED</code> indicates that the
                        creation of the event occurred on another MySQL server
                        acting as a replication master and replicated to the current
                        MySQL server which is acting as a slave, but the event is
                        not presently being executed on the slave. For more
                        information, see
                        <a class="xref" href="replication.html#replication-features-invoked" title="16.4.1.16&nbsp;Replication of Invoked Features">Section&nbsp;16.4.1.16, “Replication of Invoked Features”</a>. information.
                    </p><p style="color:blue;">事件状态。已启用、已禁用或已禁用的侧翼之一。slaveside_disabled表示事件的创建发生在作为复制主服务器的另一台mysql服务器上，并复制到作为从服务器的当前mysql服务器上，但该事件当前未在从服务器上执行。有关更多信息，请参阅第16.4.1.16节“被调用功能的复制”。信息。</p></li><li class="listitem"><p>
                        <code class="literal">Originator</code>
                    </p><p style="color:blue;">发起人</p><p>
                        The server ID of the MySQL server on which the event was
                        created; used in replication. This value may be updated by
                        <a class="link" href="sql-syntax.html#alter-event" title="13.1.2&nbsp;ALTER EVENT Syntax"><code class="literal">ALTER EVENT</code></a> to the server ID
                        of the server on which that statement occurs, if executed on
                        a master server. The default value is 0.
                    </p><p style="color:blue;">创建事件的MySQL服务器的服务器ID；用于复制。如果在主服务器上执行，则可以通过alter event将该值更新为发生该语句的服务器的服务器id。默认值为0。</p></li><li class="listitem"><p>
                        <code class="literal">character_set_client</code>
                    </p><p style="color:blue;">字符集客户端</p><p>
                        The session value of the
                        <a class="link" href="server-administration.html#sysvar_character_set_client"><code class="literal">character_set_client</code></a> system
                        variable when the event was created.
                    </p><p style="color:blue;">创建事件时character_set_client系统变量的会话值。</p></li><li class="listitem"><p>
                        <code class="literal">collation_connection</code>
                    </p><p style="color:blue;">排序规则连接</p><p>
                        The session value of the
                        <a class="link" href="server-administration.html#sysvar_collation_connection"><code class="literal">collation_connection</code></a> system
                        variable when the event was created.
                    </p><p style="color:blue;">创建事件时排序规则连接系统变量的会话值。</p></li><li class="listitem"><p>
                        <code class="literal">Database Collation</code>
                    </p><p style="color:blue;">数据库排序规则</p><p>
                        The collation of the database with which the event is
                        associated.
                    </p><p style="color:blue;">与事件关联的数据库的排序规则。</p></li></ul>
                </div>
                <p>
                    For more information about <code class="literal">SLAVESIDE_DISABLED</code>
                    and the <code class="literal">Originator</code> column, see
                    <a class="xref" href="replication.html#replication-features-invoked" title="16.4.1.16&nbsp;Replication of Invoked Features">Section&nbsp;16.4.1.16, “Replication of Invoked Features”</a>.
                </p><p style="color:blue;">有关禁用slaveside和originator列的更多信息，请参阅第16.4.1.16节“被调用功能的复制”。</p><p>
                Times displayed by <a class="link" href="sql-syntax.html#show-events" title="13.7.5.18&nbsp;SHOW EVENTS Syntax"><code class="literal">SHOW EVENTS</code></a>
                are given in the event time zone, as discussed in
                <a class="xref" href="stored-objects.html#events-metadata" title="23.4.4&nbsp;Event Metadata">Section&nbsp;23.4.4, “Event Metadata”</a>.
            </p><p style="color:blue;">如第23.4.4节“事件元数据”所述，显示事件显示的时间在事件时区中给出。</p><p>
                Event information is also available from the
                <code class="literal">INFORMATION_SCHEMA</code>
                <a class="link" href="information-schema.html#events-table" title="24.8&nbsp;The INFORMATION_SCHEMA EVENTS Table"><code class="literal">EVENTS</code></a> table. See
                <a class="xref" href="information-schema.html#events-table" title="24.8&nbsp;The INFORMATION_SCHEMA EVENTS Table">Section&nbsp;24.8, “The INFORMATION_SCHEMA EVENTS Table”</a>.
            </p><p style="color:blue;">事件信息也可以从信息架构事件表中获得。参见第24.8节“信息模式事件表”。</p><p>
                The event action statement is not shown in the output of
                <a class="link" href="sql-syntax.html#show-events" title="13.7.5.18&nbsp;SHOW EVENTS Syntax"><code class="literal">SHOW EVENTS</code></a>. Use
                <a class="link" href="sql-syntax.html#show-create-event" title="13.7.5.7&nbsp;SHOW CREATE EVENT Syntax"><code class="literal">SHOW CREATE EVENT</code></a> or the
                <code class="literal">INFORMATION_SCHEMA</code>
                <a class="link" href="information-schema.html#events-table" title="24.8&nbsp;The INFORMATION_SCHEMA EVENTS Table"><code class="literal">EVENTS</code></a> table.
            </p><p style="color:blue;">显示事件的输出中不显示事件操作语句。使用“显示创建事件”或“信息架构事件”表。</p>
            </div>
            <div class="section">
                <div class="titlepage">
                    <div>
                        <div>
                            <h4 class="title"><a name="show-function-code"></a>13.7.5.19&nbsp;SHOW FUNCTION CODE Syntax</h4>

                        </div>

                    </div>

                </div>
                <a class="indexterm" name="idm140286826965152"></a><pre data-lang="sql" class="programlisting">SHOW FUNCTION CODE <em class="replaceable"><code>func_name</code></em>
</pre><p>
                This statement is similar to <a class="link" href="sql-syntax.html#show-procedure-code" title="13.7.5.27&nbsp;SHOW PROCEDURE CODE Syntax"><code class="literal">SHOW PROCEDURE
                CODE</code></a> but for stored functions. See
                <a class="xref" href="sql-syntax.html#show-procedure-code" title="13.7.5.27&nbsp;SHOW PROCEDURE CODE Syntax">Section&nbsp;13.7.5.27, “SHOW PROCEDURE CODE Syntax”</a>.
            </p><p style="color:blue;">此语句类似于show过程代码，但用于存储函数。见第13.7.5.27节“显示过程代码语法”。</p>
            </div>
            <div class="section">
                <div class="titlepage">
                    <div>
                        <div>
                            <h4 class="title"><a name="show-function-status"></a>13.7.5.20&nbsp;SHOW FUNCTION STATUS Syntax</h4>

                        </div>

                    </div>

                </div>
                <a class="indexterm" name="idm140286826955856"></a><pre data-lang="sql" class="programlisting">SHOW FUNCTION STATUS
    [LIKE '<em class="replaceable"><code>pattern</code></em>' | WHERE <em class="replaceable"><code>expr</code></em>]
</pre><p>
                This statement is similar to <a class="link" href="sql-syntax.html#show-procedure-status" title="13.7.5.28&nbsp;SHOW PROCEDURE STATUS Syntax"><code class="literal">SHOW PROCEDURE
                STATUS</code></a> but for stored functions. See
                <a class="xref" href="sql-syntax.html#show-procedure-status" title="13.7.5.28&nbsp;SHOW PROCEDURE STATUS Syntax">Section&nbsp;13.7.5.28, “SHOW PROCEDURE STATUS Syntax”</a>.
            </p><p style="color:blue;">此语句类似于show procedure status，但用于存储函数。见第13.7.5.28节“显示过程状态语法”。</p>
            </div>
            <div class="section">
                <div class="titlepage">
                    <div>
                        <div>
                            <h4 class="title"><a name="show-grants"></a>13.7.5.21&nbsp;SHOW GRANTS Syntax</h4>

                        </div>

                    </div>

                </div>
                <a class="indexterm" name="idm140286826946128"></a><a class="indexterm" name="idm140286826944640"></a><a class="indexterm" name="idm140286826943152"></a><pre data-lang="sql" class="programlisting">SHOW GRANTS [FOR <em class="replaceable"><code>user</code></em>]
</pre><p>
                This statement displays the privileges that are assigned to a
                MySQL user account, in the form of
                <a class="link" href="sql-syntax.html#grant" title="13.7.1.4&nbsp;GRANT Syntax"><code class="literal">GRANT</code></a> statements that must be
                executed to duplicate the privilege assignments.
            </p><p style="color:blue;">此语句以GRANT语句的形式显示分配给MySQL用户帐户的权限，必须执行GRANT语句才能复制权限分配。</p>
                <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">

                    <div class="admon-title">
                        Note
                    </div>
                    <p>
                        To display nonprivilege information for MySQL accounts, use
                        the <a class="link" href="sql-syntax.html#show-create-user" title="13.7.5.12&nbsp;SHOW CREATE USER Syntax"><code class="literal">SHOW CREATE USER</code></a> statement.
                        See <a class="xref" href="sql-syntax.html#show-create-user" title="13.7.5.12&nbsp;SHOW CREATE USER Syntax">Section&nbsp;13.7.5.12, “SHOW CREATE USER Syntax”</a>.
                    </p><p style="color:blue;">要显示mysql帐户的非特权信息，请使用show create user语句。参见第13.7.5.12节“显示创建用户语法”。</p>
                </div>
                <p>
                    <a class="link" href="sql-syntax.html#show-grants" title="13.7.5.21&nbsp;SHOW GRANTS Syntax"><code class="literal">SHOW GRANTS</code></a> requires the
                    <a class="link" href="security.html#priv_select"><code class="literal">SELECT</code></a> privilege for the
                    <code class="literal">mysql</code> system database, except to display
                    privileges for the current user.
                </p><p style="color:blue;">show grants需要mysql系统数据库的select权限，但显示当前用户的权限除外。</p><p>
                To name the account for <a class="link" href="sql-syntax.html#show-grants" title="13.7.5.21&nbsp;SHOW GRANTS Syntax"><code class="literal">SHOW
                GRANTS</code></a>, use the same format as for the
                <a class="link" href="sql-syntax.html#grant" title="13.7.1.4&nbsp;GRANT Syntax"><code class="literal">GRANT</code></a> statement (for example,
                <code class="literal">'jeffrey'@'localhost'</code>):
            </p><p style="color:blue;">要为show grants命名帐户，请使用与grant语句相同的格式（例如，'jeffrey'@'localhost'）：</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>SHOW GRANTS FOR 'jeffrey'@'localhost';</code></strong>
+------------------------------------------------------------------+
| Grants for jeffrey@localhost                                     |
+------------------------------------------------------------------+
| GRANT USAGE ON *.* TO `jeffrey`@`localhost`                      |
| GRANT SELECT, INSERT, UPDATE ON `db1`.* TO `jeffrey`@`localhost` |
+------------------------------------------------------------------+
</pre><p>
                The host part, if omitted, defaults to <code class="literal">'%'</code>.
                For additional information about specifying account names, see
                <a class="xref" href="security.html#account-names" title="6.2.4&nbsp;Specifying Account Names">Section&nbsp;6.2.4, “Specifying Account Names”</a>.
            </p><p style="color:blue;">主机部分（如果省略）默认为“%”。有关指定帐户名的其他信息，请参阅第6.2.4节“指定帐户名”。</p><p>
                To display the privileges granted to the current user (the
                account you are using to connect to the server), you can use any
                of the following statements:
            </p><p style="color:blue;">要显示授予当前用户（用于连接服务器的帐户）的权限，可以使用以下任何语句：</p><pre data-lang="sql" class="programlisting">SHOW GRANTS;
SHOW GRANTS FOR CURRENT_USER;
SHOW GRANTS FOR CURRENT_USER();
</pre><a class="indexterm" name="idm140286826920720"></a><a class="indexterm" name="idm140286826919232"></a><a class="indexterm" name="idm140286826918160"></a><a class="indexterm" name="idm140286826916672"></a><p>
                If <code class="literal">SHOW GRANTS FOR CURRENT_USER</code> (or any
                equivalent syntax) is used in definer context, such as within a
                stored procedure that executes with definer rather than invoker
                privileges, the grants displayed are those of the definer and
                not the invoker.
            </p><p style="color:blue;">如果在定义者上下文中（例如在使用定义者而不是调用者特权执行的存储过程中）使用当前用户的show grants（或任何等效语法），则显示的授权是定义者的授权，而不是调用者的授权。</p><p>
                <a class="link" href="sql-syntax.html#show-grants" title="13.7.5.21&nbsp;SHOW GRANTS Syntax"><code class="literal">SHOW GRANTS</code></a> does not display
                privileges that are available to the named account but are
                granted to a different account. For example, if an anonymous
                account exists, the named account might be able to use its
                privileges, but <a class="link" href="sql-syntax.html#show-grants" title="13.7.5.21&nbsp;SHOW GRANTS Syntax"><code class="literal">SHOW GRANTS</code></a> does
                not display them.
            </p><p style="color:blue;">显示授权不显示可用于命名帐户但被授予其他帐户的权限。例如，如果匿名帐户存在，命名帐户可能能够使用其特权，但显示授权不显示它们。</p><p>
                <code class="literal">SHOW GRANTS</code> output does not include
                <code class="literal">IDENTIFIED BY PASSWORD</code> clauses. Use the
                <a class="link" href="sql-syntax.html#show-create-user" title="13.7.5.12&nbsp;SHOW CREATE USER Syntax"><code class="literal">SHOW CREATE USER</code></a> statement
                instead. See <a class="xref" href="sql-syntax.html#show-create-user" title="13.7.5.12&nbsp;SHOW CREATE USER Syntax">Section&nbsp;13.7.5.12, “SHOW CREATE USER Syntax”</a>.
            </p><p style="color:blue;">show grants输出不包括由密码子句标识的。改用show create user语句。参见第13.7.5.12节“显示创建用户语法”。</p>
            </div>
            <div class="section">
                <div class="titlepage">
                    <div>
                        <div>
                            <h4 class="title"><a name="show-index"></a>13.7.5.22&nbsp;SHOW INDEX Syntax</h4>

                        </div>

                    </div>

                </div>
                <a class="indexterm" name="idm140286826905584"></a><a class="indexterm" name="idm140286826903680"></a><a class="indexterm" name="idm140286826902608"></a><pre data-lang="sql" class="programlisting">SHOW {INDEX | INDEXES | KEYS}
    {FROM | IN} <em class="replaceable"><code>tbl_name</code></em>
    [{FROM | IN} <em class="replaceable"><code>db_name</code></em>]
    [WHERE <em class="replaceable"><code>expr</code></em>]
</pre><p>
                <a class="link" href="sql-syntax.html#show-index" title="13.7.5.22&nbsp;SHOW INDEX Syntax"><code class="literal">SHOW INDEX</code></a> returns table index
                information. The format resembles that of the
                <code class="literal">SQLStatistics</code> call in ODBC. This statement
                requires some privilege for any column in the table.
            </p><p style="color:blue;">show index返回表索引信息。格式类似于odbc中的sqlstatistics调用。此语句对表中的任何列都需要一些特权。</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>SHOW INDEX FROM City\G</code></strong>
*************************** 1. row ***************************
        Table: city
   Non_unique: 0
     Key_name: PRIMARY
 Seq_in_index: 1
  Column_name: ID
    Collation: A
  Cardinality: 4188
     Sub_part: NULL
       Packed: NULL
         Null:
   Index_type: BTREE
      Comment:
Index_comment:
*************************** 2. row ***************************
        Table: city
   Non_unique: 1
     Key_name: CountryCode
 Seq_in_index: 1
  Column_name: CountryCode
    Collation: A
  Cardinality: 232
     Sub_part: NULL
       Packed: NULL
         Null:
   Index_type: BTREE
      Comment:
Index_comment:
</pre><p>
                An alternative to <code class="literal"><em class="replaceable"><code>tbl_name</code></em>
                FROM <em class="replaceable"><code>db_name</code></em></code> syntax is
                <em class="replaceable"><code>db_name</code></em>.<em class="replaceable"><code>tbl_name</code></em>.
                These two statements are equivalent:
            </p><p style="color:blue;">db_name语法中tbl_name的另一种选择是db_name.tbl_name。这两种说法是等价的：</p><pre data-lang="sql" class="programlisting">SHOW INDEX FROM mytable FROM mydb;
SHOW INDEX FROM mydb.mytable;
</pre><p>
                The <code class="literal">WHERE</code> clause can be given to select rows
                using more general conditions, as discussed in
                <a class="xref" href="information-schema.html#extended-show" title="24.35&nbsp;Extensions to SHOW Statements">Section&nbsp;24.35, “Extensions to SHOW Statements”</a>.
            </p><p style="color:blue;">where子句可用于使用更一般的条件选择行，如第24.35节“显示语句的扩展”所述。</p><p>
                <a class="link" href="sql-syntax.html#show-index" title="13.7.5.22&nbsp;SHOW INDEX Syntax"><code class="literal">SHOW INDEX</code></a> returns the following
                fields:
            </p><p style="color:blue;">show index返回以下字段：</p>
                <div class="itemizedlist">
                    <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                        <code class="literal">Table</code>
                    </p><p style="color:blue;">桌子</p><p>
                        The name of the table.
                    </p><p style="color:blue;">表的名称。</p></li><li class="listitem"><p>
                        <code class="literal">Non_unique</code>
                    </p><p style="color:blue;">非唯一</p><p>
                        0 if the index cannot contain duplicates, 1 if it can.
                    </p><p style="color:blue;">如果索引不能包含重复项，则为0；如果可以，则为1。</p></li><li class="listitem"><p>
                        <code class="literal">Key_name</code>
                    </p><p style="color:blue;">密钥名称</p><p>
                        The name of the index. If the index is the primary key, the
                        name is always <code class="literal">PRIMARY</code>.
                    </p><p style="color:blue;">索引的名称。如果索引是主键，则名称始终是主键。</p></li><li class="listitem"><p>
                        <code class="literal">Seq_in_index</code>
                    </p><p style="color:blue;">序列索引</p><p>
                        The column sequence number in the index, starting with 1.
                    </p><p style="color:blue;">索引中的列序号，从1开始。</p></li><li class="listitem"><p>
                        <code class="literal">Column_name</code>
                    </p><p style="color:blue;">列名</p><p>
                        The name of the column.
                    </p><p style="color:blue;">列的名称。</p></li><li class="listitem"><p>
                        <code class="literal">Collation</code>
                    </p><p style="color:blue;">校勘</p><a class="indexterm" name="idm140286826872896"></a><p>
                        How the column is sorted in the index. This can have values
                        <code class="literal">A</code> (ascending) or <code class="literal">NULL</code>
                        (not sorted).
                    </p><p style="color:blue;">列在索引中的排序方式。它可以有值a（升序）或null（未排序）。</p></li><li class="listitem"><p>
                        <code class="literal">Cardinality</code>
                    </p><p style="color:blue;">基数</p><a class="indexterm" name="idm140286826867632"></a><a class="indexterm" name="idm140286826865728"></a><p>
                        An estimate of the number of unique values in the index. To
                        update this number, run <a class="link" href="sql-syntax.html#analyze-table" title="13.7.2.1&nbsp;ANALYZE TABLE Syntax"><code class="literal">ANALYZE
                        TABLE</code></a> or (for <code class="literal">MyISAM</code> tables)
                        <a class="link" href="programs.html#myisamchk" title="4.6.3&nbsp;myisamchk — MyISAM Table-Maintenance Utility"><span class="command"><strong>myisamchk -a</strong></span></a>.
                    </p><p style="color:blue;">对索引中唯一值数目的估计。要更新此数字，请运行analyze table或（对于myisam tables）myisamchk-a。</p><p>
                        <code class="literal">Cardinality</code> is counted based on
                        statistics stored as integers, so the value is not
                        necessarily exact even for small tables. The higher the
                        cardinality, the greater the chance that MySQL uses the
                        index when doing joins.
                    </p><p style="color:blue;">基数是根据存储为整数的统计数据计算的，因此即使对于小表，该值也不一定精确。基数越高，mysql在进行连接时使用索引的可能性就越大。</p></li><li class="listitem"><p>
                        <code class="literal">Sub_part</code>
                    </p><p style="color:blue;">子部分</p><p>
                        The index prefix. That is, the number of indexed characters
                        if the column is only partly indexed,
                        <code class="literal">NULL</code> if the entire column is indexed.
                    </p><p style="color:blue;">索引前缀。也就是说，如果列只是部分索引，则为索引字符数；如果整个列都已索引，则为空。</p>
                        <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">

                            <div class="admon-title">
                                Note
                            </div>
                            <p>
                                Prefix <span class="emphasis"><em>limits</em></span> are measured in bytes.
                                However, prefix <span class="emphasis"><em>lengths</em></span> for index
                                specifications in <a class="link" href="sql-syntax.html#create-table" title="13.1.18&nbsp;CREATE TABLE Syntax"><code class="literal">CREATE
                                TABLE</code></a>, <a class="link" href="sql-syntax.html#alter-table" title="13.1.8&nbsp;ALTER TABLE Syntax"><code class="literal">ALTER
                                TABLE</code></a>, and <a class="link" href="sql-syntax.html#create-index" title="13.1.14&nbsp;CREATE INDEX Syntax"><code class="literal">CREATE
                                INDEX</code></a> statements are interpreted as number of
                                characters for nonbinary string types
                                (<a class="link" href="data-types.html#char" title="11.4.1&nbsp;The CHAR and VARCHAR Types"><code class="literal">CHAR</code></a>,
                                <a class="link" href="data-types.html#char" title="11.4.1&nbsp;The CHAR and VARCHAR Types"><code class="literal">VARCHAR</code></a>,
                                <a class="link" href="data-types.html#blob" title="11.4.3&nbsp;The BLOB and TEXT Types"><code class="literal">TEXT</code></a>) and number of bytes
                                for binary string types
                                (<a class="link" href="data-types.html#binary-varbinary" title="11.4.2&nbsp;The BINARY and VARBINARY Types"><code class="literal">BINARY</code></a>,
                                <a class="link" href="data-types.html#binary-varbinary" title="11.4.2&nbsp;The BINARY and VARBINARY Types"><code class="literal">VARBINARY</code></a>,
                                <a class="link" href="data-types.html#blob" title="11.4.3&nbsp;The BLOB and TEXT Types"><code class="literal">BLOB</code></a>). Take this into
                                account when specifying a prefix length for a nonbinary
                                string column that uses a multibyte character set.
                            </p><p style="color:blue;">前缀限制以字节为单位。但是，CREATE TABLE、ALTER TABLE和CREATE INDEX语句中索引规范的前缀长度解释为非二进制字符串类型（char、varchar、text）的字符数和二进制字符串类型（binary、varbinary、blob）的字节数。在为使用多字节字符集的非二进制字符串列指定前缀长度时，请考虑此问题。</p>
                        </div>
                        <p>
                            For additional information about index prefixes, see
                            <a class="xref" href="optimization.html#column-indexes" title="8.3.4&nbsp;Column Indexes">Section&nbsp;8.3.4, “Column Indexes”</a>, and
                            <a class="xref" href="sql-syntax.html#create-index" title="13.1.14&nbsp;CREATE INDEX Syntax">Section&nbsp;13.1.14, “CREATE INDEX Syntax”</a>.
                        </p><p style="color:blue;">有关索引前缀的其他信息，请参见第8.3.4节“列索引”和第13.1.14节“创建索引语法”。</p></li><li class="listitem"><p>
                        <code class="literal">Packed</code>
                    </p><p style="color:blue;">拥挤的</p><p>
                        Indicates how the key is packed. <code class="literal">NULL</code> if
                        it is not.
                    </p><p style="color:blue;">指示如何打包密钥。如果不是，则为空。</p></li><li class="listitem"><p>
                        <code class="literal">Null</code>
                    </p><p style="color:blue;">无效的</p><p>
                        Contains <code class="literal">YES</code> if the column may contain
                        <code class="literal">NULL</code> values and <code class="literal">''</code> if
                        not.
                    </p><p style="color:blue;">如果列可能包含空值，则包含yes；如果不包含空值，则包含''。</p></li><li class="listitem"><p>
                        <code class="literal">Index_type</code>
                    </p><p style="color:blue;">索引类型</p><p>
                        The index method used (<code class="literal">BTREE</code>,
                        <code class="literal">FULLTEXT</code>, <code class="literal">HASH</code>,
                        <code class="literal">RTREE</code>).
                    </p><p style="color:blue;">使用的索引方法（btree、fulltext、hash、rtree）。</p></li><li class="listitem"><p>
                        <code class="literal">Comment</code>
                    </p><p style="color:blue;">评论</p><p>
                        Information about the index not described in its own column,
                        such as <code class="literal">disabled</code> if the index is
                        disabled.
                    </p><p style="color:blue;">未在其自身列中描述的有关索引的信息，例如，如果索引已禁用，则禁用该索引。</p></li><li class="listitem"><p>
                        <code class="literal">Index_comment</code>
                    </p><p style="color:blue;">索引注释</p><p>
                        Any comment provided for the index with a
                        <code class="literal">COMMENT</code> attribute when the index was
                        created.
                    </p><p style="color:blue;">创建索引时为具有comment属性的索引提供的任何注释。</p></li></ul>
                </div>
                <p>
                    Information about table indexes is also available from the
                    <code class="literal">INFORMATION_SCHEMA</code>
                    <a class="link" href="information-schema.html#statistics-table" title="24.24&nbsp;The INFORMATION_SCHEMA STATISTICS Table"><code class="literal">STATISTICS</code></a> table. See
                    <a class="xref" href="information-schema.html#statistics-table" title="24.24&nbsp;The INFORMATION_SCHEMA STATISTICS Table">Section&nbsp;24.24, “The INFORMATION_SCHEMA STATISTICS Table”</a>.
                </p><p style="color:blue;">有关表索引的信息也可以从信息架构统计表中获得。参见第24.24节“信息模式统计表”。</p><p>
                You can list a table's indexes with the <a class="link" href="programs.html#mysqlshow" title="4.5.7&nbsp;mysqlshow — Display Database, Table, and Column Information"><span class="command"><strong>mysqlshow -k
        <em class="replaceable"><code>db_name</code></em>
        <em class="replaceable"><code>tbl_name</code></em></strong></span></a> command.
            </p><p style="color:blue;">可以使用mysqlshow-k db_name tbl_name命令列出表的索引。</p>
            </div>
            <div class="section">
                <div class="titlepage">
                    <div>
                        <div>
                            <h4 class="title"><a name="show-master-status"></a>13.7.5.23&nbsp;SHOW MASTER STATUS Syntax</h4>

                        </div>

                    </div>

                </div>
                <a class="indexterm" name="idm140286826817152"></a><pre data-lang="sql" class="programlisting">SHOW MASTER STATUS
</pre><p>
                This statement provides status information about the binary log
                files of the master. It requires either the
                <a class="link" href="security.html#priv_super"><code class="literal">SUPER</code></a> or
                <a class="link" href="security.html#priv_replication-client"><code class="literal">REPLICATION CLIENT</code></a> privilege.
            </p><p style="color:blue;">此语句提供有关主机二进制日志文件的状态信息。它需要超级或复制客户端权限。</p><p>
                Example:
            </p><p style="color:blue;">例子：</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>SHOW MASTER STATUS\G</code></strong>
*************************** 1. row ***************************
             File: master-bin.000002
         Position: 1307
     Binlog_Do_DB: test
 Binlog_Ignore_DB: manual, mysql
Executed_Gtid_Set: 3E11FA47-71CA-11E1-9E33-C80AA9429562:1-5
1 row in set (0.00 sec)
</pre><p>
                When global transaction IDs are in use,
                <code class="literal">Executed_Gtid_Set</code> shows the set of GTIDs for
                transactions that have been executed on the master. This is the
                same as the value for the
                <a class="link" href="replication.html#sysvar_gtid_executed"><code class="literal">gtid_executed</code></a> system variable
                on this server, as well as the value for
                <code class="literal">Executed_Gtid_Set</code> in the output of
                <a class="link" href="sql-syntax.html#show-slave-status" title="13.7.5.34&nbsp;SHOW SLAVE STATUS Syntax"><code class="literal">SHOW SLAVE STATUS</code></a> on this server.
            </p><p style="color:blue;">当使用全局事务id时，executed_gtid_set显示已在主服务器上执行的事务的gtid集。这与此服务器上gtid_executed系统变量的值以及此服务器上show slave status的输出中设置的executed_gtid_的值相同。</p>
            </div>
            <div class="section">
                <div class="titlepage">
                    <div>
                        <div>
                            <h4 class="title"><a name="show-open-tables"></a>13.7.5.24&nbsp;SHOW OPEN TABLES Syntax</h4>

                        </div>

                    </div>

                </div>
                <a class="indexterm" name="idm140286826800896"></a><a class="indexterm" name="idm140286826798992"></a><pre data-lang="sql" class="programlisting">SHOW OPEN TABLES
    [{FROM | IN} <em class="replaceable"><code>db_name</code></em>]
    [LIKE '<em class="replaceable"><code>pattern</code></em>' | WHERE <em class="replaceable"><code>expr</code></em>]
</pre><p>
                <a class="link" href="sql-syntax.html#show-open-tables" title="13.7.5.24&nbsp;SHOW OPEN TABLES Syntax"><code class="literal">SHOW OPEN TABLES</code></a> lists the
                non-<code class="literal">TEMPORARY</code> tables that are currently open
                in the table cache. See <a class="xref" href="optimization.html#table-cache" title="8.4.3.1&nbsp;How MySQL Opens and Closes Tables">Section&nbsp;8.4.3.1, “How MySQL Opens and Closes Tables”</a>. The
                <code class="literal">FROM</code> clause, if present, restricts the tables
                shown to those present in the <em class="replaceable"><code>db_name</code></em>
                database. The <a class="link" href="functions.html#operator_like"><code class="literal">LIKE</code></a> clause, if
                present, indicates which table names to match. The
                <code class="literal">WHERE</code> clause can be given to select rows
                using more general conditions, as discussed in
                <a class="xref" href="information-schema.html#extended-show" title="24.35&nbsp;Extensions to SHOW Statements">Section&nbsp;24.35, “Extensions to SHOW Statements”</a>.
            </p><p style="color:blue;">show open tables列出当前在表缓存中打开的非临时表。参见第8.4.3.1节“MySQL如何打开和关闭表”。FROM子句（如果存在）将显示的表限制为数据库中存在的表。LIKE子句（如果存在）指示要匹配的表名。where子句可用于使用更一般的条件选择行，如第24.35节“显示语句的扩展”所述。</p><p>
                <a class="link" href="sql-syntax.html#show-open-tables" title="13.7.5.24&nbsp;SHOW OPEN TABLES Syntax"><code class="literal">SHOW OPEN TABLES</code></a> output has these
                columns:
            </p><p style="color:blue;">显示打开的表输出包含以下列：</p>
                <div class="itemizedlist">
                    <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                        <code class="literal">Database</code>
                    </p><p style="color:blue;">数据库</p><p>
                        The database containing the table.
                    </p><p style="color:blue;">包含表的数据库。</p></li><li class="listitem"><p>
                        <code class="literal">Table</code>
                    </p><p style="color:blue;">桌子</p><p>
                        The table name.
                    </p><p style="color:blue;">表名。</p></li><li class="listitem"><p>
                        <code class="literal">In_use</code>
                    </p><p style="color:blue;">使用中</p><p>
                        The number of table locks or lock requests there are for the
                        table. For example, if one client acquires a lock for a
                        table using <code class="literal">LOCK TABLE t1 WRITE</code>,
                        <code class="literal">In_use</code> will be 1. If another client
                        issues <code class="literal">LOCK TABLE t1 WRITE</code> while the
                        table remains locked, the client will block waiting for the
                        lock, but the lock request causes <code class="literal">In_use</code>
                        to be 2. If the count is zero, the table is open but not
                        currently being used. <code class="literal">In_use</code> is also
                        increased by the
                        <a class="link" href="sql-syntax.html#handler" title="13.2.4&nbsp;HANDLER Syntax"><code class="literal">HANDLER ...
                            OPEN</code></a> statement and decreased by
                        <a class="link" href="sql-syntax.html#handler" title="13.2.4&nbsp;HANDLER Syntax"><code class="literal">HANDLER ...
                            CLOSE</code></a>.
                    </p><p style="color:blue;">表的锁或锁请求数。例如，如果一个客户机使用lock table t1 write获取表的锁，则in-use将为1。如果另一个客户机在表保持锁定的情况下发出锁表T1 WRITE，则客户机将阻止等待锁，但锁请求会导致In-Use为2。如果计数为零，则表处于打开状态，但当前未使用。处理程序也会增加in_use…打开语句并按处理程序减少…接近。</p></li><li class="listitem"><p>
                        <code class="literal">Name_locked</code>
                    </p><p style="color:blue;">姓名已锁定</p><p>
                        Whether the table name is locked. Name locking is used for
                        operations such as dropping or renaming tables.
                    </p><p style="color:blue;">是否锁定了表名。名称锁定用于删除或重命名表等操作。</p></li></ul>
                </div>
                <p>
                    If you have no privileges for a table, it does not show up in
                    the output from <a class="link" href="sql-syntax.html#show-open-tables" title="13.7.5.24&nbsp;SHOW OPEN TABLES Syntax"><code class="literal">SHOW OPEN TABLES</code></a>.
                </p><p style="color:blue;">如果您没有表的权限，则它不会显示在“显示打开的表”的输出中。</p>
            </div>
            <div class="section">
                <div class="titlepage">
                    <div>
                        <div>
                            <h4 class="title"><a name="show-plugins"></a>13.7.5.25&nbsp;SHOW PLUGINS Syntax</h4>

                        </div>

                    </div>

                </div>
                <a class="indexterm" name="idm140286826766160"></a><pre data-lang="sql" class="programlisting">SHOW PLUGINS
</pre><p>
                <a class="link" href="sql-syntax.html#show-plugins" title="13.7.5.25&nbsp;SHOW PLUGINS Syntax"><code class="literal">SHOW PLUGINS</code></a> displays information
                about server plugins.
            </p><p style="color:blue;">显示插件显示有关服务器插件的信息。</p><p>
                Example of <a class="link" href="sql-syntax.html#show-plugins" title="13.7.5.25&nbsp;SHOW PLUGINS Syntax"><code class="literal">SHOW PLUGINS</code></a> output:
            </p><p style="color:blue;">显示插件输出示例：</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>SHOW PLUGINS\G</code></strong>
*************************** 1. row ***************************
   Name: binlog
 Status: ACTIVE
   Type: STORAGE ENGINE
Library: NULL
License: GPL
*************************** 2. row ***************************
   Name: CSV
 Status: ACTIVE
   Type: STORAGE ENGINE
Library: NULL
License: GPL
*************************** 3. row ***************************
   Name: MEMORY
 Status: ACTIVE
   Type: STORAGE ENGINE
Library: NULL
License: GPL
*************************** 4. row ***************************
   Name: MyISAM
 Status: ACTIVE
   Type: STORAGE ENGINE
Library: NULL
License: GPL
...
</pre><p>
                <a class="link" href="sql-syntax.html#show-plugins" title="13.7.5.25&nbsp;SHOW PLUGINS Syntax"><code class="literal">SHOW PLUGINS</code></a> output has these
                columns:
            </p><p style="color:blue;">显示插件输出包含以下列：</p>
                <div class="itemizedlist">
                    <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                        <code class="literal">Name</code>
                    </p><p style="color:blue;">姓名</p><p>
                        The name used to refer to the plugin in statements such as
                        <a class="link" href="sql-syntax.html#install-plugin" title="13.7.3.3&nbsp;INSTALL PLUGIN Syntax"><code class="literal">INSTALL PLUGIN</code></a> and
                        <a class="link" href="sql-syntax.html#uninstall-plugin" title="13.7.3.4&nbsp;UNINSTALL PLUGIN Syntax"><code class="literal">UNINSTALL PLUGIN</code></a>.
                    </p><p style="color:blue;">用于在install plugin和uninstall plugin等语句中引用插件的名称。</p></li><li class="listitem"><p>
                        <code class="literal">Status</code>
                    </p><p style="color:blue;">地位</p><p>
                        The plugin status, one of <code class="literal">ACTIVE</code>,
                        <code class="literal">INACTIVE</code>, <code class="literal">DISABLED</code>, or
                        <code class="literal">DELETED</code>.
                    </p><p style="color:blue;">插件状态，包括活动、非活动、禁用或删除。</p></li><li class="listitem"><p>
                        <code class="literal">Type</code>
                    </p><p style="color:blue;">类型</p><p>
                        The type of plugin, such as <code class="literal">STORAGE
                        ENGINE</code>, <code class="literal">INFORMATION_SCHEMA</code>, or
                        <code class="literal">AUTHENTICATION</code>.
                    </p><p style="color:blue;">插件的类型，如存储引擎、信息架构或身份验证。</p></li><li class="listitem"><p>
                        <code class="literal">Library</code>
                    </p><p style="color:blue;">图书馆</p><p>
                        The name of the plugin shared library file. This is the name
                        used to refer to the plugin file in statements such as
                        <a class="link" href="sql-syntax.html#install-plugin" title="13.7.3.3&nbsp;INSTALL PLUGIN Syntax"><code class="literal">INSTALL PLUGIN</code></a> and
                        <a class="link" href="sql-syntax.html#uninstall-plugin" title="13.7.3.4&nbsp;UNINSTALL PLUGIN Syntax"><code class="literal">UNINSTALL PLUGIN</code></a>. This file
                        is located in the directory named by the
                        <a class="link" href="server-administration.html#sysvar_plugin_dir"><code class="literal">plugin_dir</code></a> system variable.
                        If the library name is <code class="literal">NULL</code>, the plugin
                        is compiled in and cannot be uninstalled with
                        <a class="link" href="sql-syntax.html#uninstall-plugin" title="13.7.3.4&nbsp;UNINSTALL PLUGIN Syntax"><code class="literal">UNINSTALL PLUGIN</code></a>.
                    </p><p style="color:blue;">插件共享库文件的名称。这是用于在install plugin和uninstall plugin等语句中引用插件文件的名称。此文件位于plugin_dir系统变量命名的目录中。如果库名称为空，则插件将在中编译，并且无法使用卸载插件卸载。</p></li><li class="listitem"><p>
                        <code class="literal">License</code>
                    </p><p style="color:blue;">许可证</p><p>
                        How the plugin is licensed (for example,
                        <code class="literal">GPL</code>).
                    </p><p style="color:blue;">插件的许可方式（例如，gpl）。</p></li></ul>
                </div>
                <p>
                    For plugins installed with <a class="link" href="sql-syntax.html#install-plugin" title="13.7.3.3&nbsp;INSTALL PLUGIN Syntax"><code class="literal">INSTALL
                    PLUGIN</code></a>, the <code class="literal">Name</code> and
                    <code class="literal">Library</code> values are also registered in the
                    <code class="literal">mysql.plugin</code> system table.
                </p><p style="color:blue;">对于与install plugin一起安装的插件，名称和库值也注册在mysql.plugin系统表中。</p><p>
                For information about plugin data structures that form the basis
                of the information displayed by <a class="link" href="sql-syntax.html#show-plugins" title="13.7.5.25&nbsp;SHOW PLUGINS Syntax"><code class="literal">SHOW
                PLUGINS</code></a>, see <a class="xref" href="extending-mysql.html#plugin-api" title="28.2&nbsp;The MySQL Plugin API">Section&nbsp;28.2, “The MySQL Plugin API”</a>.
            </p><p style="color:blue;">有关构成show plugins显示信息基础的插件数据结构的信息，请参阅28.2节“mysql插件api”。</p><p>
                Plugin information is also available from the
                <code class="literal">INFORMATION_SCHEMA</code>
                <code class="literal">.PLUGINS</code> table. See
                <a class="xref" href="information-schema.html#plugins-table" title="24.17&nbsp;The INFORMATION_SCHEMA PLUGINS Table">Section&nbsp;24.17, “The INFORMATION_SCHEMA PLUGINS Table”</a>.
            </p><p style="color:blue;">插件信息也可以从information-schema.plugins表中获得。参见第24.17节“信息模式插件表”。</p>
            </div>
            <div class="section">
                <div class="titlepage">
                    <div>
                        <div>
                            <h4 class="title"><a name="show-privileges"></a>13.7.5.26&nbsp;SHOW PRIVILEGES Syntax</h4>

                        </div>

                    </div>

                </div>
                <a class="indexterm" name="idm140286826719792"></a><pre data-lang="sql" class="programlisting">SHOW PRIVILEGES
</pre><p>
                <a class="link" href="sql-syntax.html#show-privileges" title="13.7.5.26&nbsp;SHOW PRIVILEGES Syntax"><code class="literal">SHOW PRIVILEGES</code></a> shows the list of
                system privileges that the MySQL server supports. The exact list
                of privileges depends on the version of your server.
            </p><p style="color:blue;">show privileges显示mysql服务器支持的系统权限列表。权限的确切列表取决于服务器的版本。</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>SHOW PRIVILEGES\G</code></strong>
*************************** 1. row ***************************
Privilege: Alter
  Context: Tables
  Comment: To alter the table
*************************** 2. row ***************************
Privilege: Alter routine
  Context: Functions,Procedures
  Comment: To alter or drop stored functions/procedures
*************************** 3. row ***************************
Privilege: Create
  Context: Databases,Tables,Indexes
  Comment: To create new databases and tables
*************************** 4. row ***************************
Privilege: Create routine
  Context: Databases
  Comment: To use CREATE FUNCTION/PROCEDURE
*************************** 5. row ***************************
Privilege: Create temporary tables
  Context: Databases
  Comment: To use CREATE TEMPORARY TABLE
...
</pre><p>
                Privileges belonging to a specific user are displayed by the
                <a class="link" href="sql-syntax.html#show-grants" title="13.7.5.21&nbsp;SHOW GRANTS Syntax"><code class="literal">SHOW GRANTS</code></a> statement. See
                <a class="xref" href="sql-syntax.html#show-grants" title="13.7.5.21&nbsp;SHOW GRANTS Syntax">Section&nbsp;13.7.5.21, “SHOW GRANTS Syntax”</a>, for more information.
            </p><p style="color:blue;">属于特定用户的权限由show grants语句显示。有关详细信息，请参阅第13.7.5.21节“显示授权语法”。</p>
            </div>
            <div class="section">
                <div class="titlepage">
                    <div>
                        <div>
                            <h4 class="title"><a name="show-procedure-code"></a>13.7.5.27&nbsp;SHOW PROCEDURE CODE Syntax</h4>

                        </div>

                    </div>

                </div>
                <a class="indexterm" name="idm140286826706224"></a><pre data-lang="sql" class="programlisting">SHOW PROCEDURE CODE <em class="replaceable"><code>proc_name</code></em>
</pre><p>
                This statement is a MySQL extension that is available only for
                servers that have been built with debugging support. It displays
                a representation of the internal implementation of the named
                stored procedure. A similar statement, <a class="link" href="sql-syntax.html#show-function-code" title="13.7.5.19&nbsp;SHOW FUNCTION CODE Syntax"><code class="literal">SHOW
                FUNCTION CODE</code></a>, displays information about stored
                functions (see <a class="xref" href="sql-syntax.html#show-function-code" title="13.7.5.19&nbsp;SHOW FUNCTION CODE Syntax">Section&nbsp;13.7.5.19, “SHOW FUNCTION CODE Syntax”</a>).
            </p><p style="color:blue;">此语句是一个mysql扩展，仅适用于使用调试支持构建的服务器。它显示命名存储过程的内部实现的表示。类似的语句show function code显示有关存储函数的信息（参见第13.7.5.19节“show function code syntax”）。</p><p>
                To use either statement, you must be the owner of the routine or
                have <a class="link" href="sql-syntax.html#select" title="13.2.9&nbsp;SELECT Syntax"><code class="literal">SELECT</code></a> access to the
                <code class="literal">mysql.proc</code> table.
            </p><p style="color:blue;">要使用这两个语句，您必须是例程的所有者，或者具有对mysql.proc表的select访问权限。</p><p>
                If the named routine is available, each statement produces a
                result set. Each row in the result set corresponds to one
                <span class="quote">“<span class="quote">instruction</span>”</span> in the routine. The first column is
                <code class="literal">Pos</code>, which is an ordinal number beginning
                with 0. The second column is <code class="literal">Instruction</code>,
                which contains an SQL statement (usually changed from the
                original source), or a directive which has meaning only to the
                stored-routine handler.
            </p><p style="color:blue;">如果命名例程可用，则每个语句都会生成一个结果集。结果集中的每一行对应于例程中的一条“指令”。第一列是pos，它是以0开头的序号。第二列是指令，它包含一个sql语句（通常是从原始源更改的），或者是一个只对存储的例程处理程序有意义的指令。</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>DELIMITER //</code></strong>
mysql&gt; <strong class="userinput"><code>CREATE PROCEDURE p1 ()</code></strong>
    -&gt; <strong class="userinput"><code>BEGIN</code></strong>
    -&gt;   <strong class="userinput"><code>DECLARE fanta INT DEFAULT 55;</code></strong>
    -&gt;   <strong class="userinput"><code>DROP TABLE t2;</code></strong>
    -&gt;   <strong class="userinput"><code>LOOP</code></strong>
    -&gt;     <strong class="userinput"><code>INSERT INTO t3 VALUES (fanta);</code></strong>
    -&gt;     <strong class="userinput"><code>END LOOP;</code></strong>
    -&gt;   <strong class="userinput"><code>END//</code></strong>
Query OK, 0 rows affected (0.00 sec)

mysql&gt; <strong class="userinput"><code>SHOW PROCEDURE CODE p1//</code></strong>
+-----+----------------------------------------+
| Pos | Instruction                            |
+-----+----------------------------------------+
|   0 | set fanta@0 55                         |
|   1 | stmt 9 "DROP TABLE t2"                 |
|   2 | stmt 5 "INSERT INTO t3 VALUES (fanta)" |
|   3 | jump 2                                 |
+-----+----------------------------------------+
4 rows in set (0.00 sec)
</pre><p>
                In this example, the nonexecutable <code class="literal">BEGIN</code> and
                <code class="literal">END</code> statements have disappeared, and for the
                <code class="literal">DECLARE
                    <em class="replaceable"><code>variable_name</code></em></code> statement,
                only the executable part appears (the part where the default is
                assigned). For each statement that is taken from source, there
                is a code word <code class="literal">stmt</code> followed by a type (9
                means <code class="literal">DROP</code>, 5 means
                <a class="link" href="sql-syntax.html#insert" title="13.2.5&nbsp;INSERT Syntax"><code class="literal">INSERT</code></a>, and so on). The final row
                contains an instruction <code class="literal">jump 2</code>, meaning
                <code class="literal">GOTO instruction #2</code>.
            </p><p style="color:blue;">在本例中，不可执行的begin和end语句已经消失，对于declare variable_name语句，只显示可执行部分（分配默认值的部分）。对于从源代码获取的每条语句，都有一个代码字stmt，后面跟着一个类型（9表示drop，5表示insert，依此类推）。最后一行包含一个指令跳转2，即goto指令2。</p>
            </div>
            <div class="section">
                <div class="titlepage">
                    <div>
                        <div>
                            <h4 class="title"><a name="show-procedure-status"></a>13.7.5.28&nbsp;SHOW PROCEDURE STATUS Syntax</h4>

                        </div>

                    </div>

                </div>
                <a class="indexterm" name="idm140286826675200"></a><pre data-lang="sql" class="programlisting">SHOW PROCEDURE STATUS
    [LIKE '<em class="replaceable"><code>pattern</code></em>' | WHERE <em class="replaceable"><code>expr</code></em>]
</pre><p>
                This statement is a MySQL extension. It returns characteristics
                of a stored procedure, such as the database, name, type,
                creator, creation and modification dates, and character set
                information. A similar statement, <a class="link" href="sql-syntax.html#show-function-status" title="13.7.5.20&nbsp;SHOW FUNCTION STATUS Syntax"><code class="literal">SHOW
                FUNCTION STATUS</code></a>, displays information about stored
                functions (see <a class="xref" href="sql-syntax.html#show-function-status" title="13.7.5.20&nbsp;SHOW FUNCTION STATUS Syntax">Section&nbsp;13.7.5.20, “SHOW FUNCTION STATUS Syntax”</a>).
            </p><p style="color:blue;">此语句是MySQL扩展。它返回存储过程的特征，如数据库、名称、类型、创建者、创建和修改日期以及字符集信息。类似的语句show function status显示有关存储函数的信息（参见第13.7.5.20节“show function status syntax”）。</p><p>
                The <a class="link" href="functions.html#operator_like"><code class="literal">LIKE</code></a> clause, if present,
                indicates which procedure or function names to match. The
                <code class="literal">WHERE</code> clause can be given to select rows
                using more general conditions, as discussed in
                <a class="xref" href="information-schema.html#extended-show" title="24.35&nbsp;Extensions to SHOW Statements">Section&nbsp;24.35, “Extensions to SHOW Statements”</a>.
            </p><p style="color:blue;">LIKE子句（如果存在）指示要匹配的过程或函数名。where子句可用于使用更一般的条件选择行，如第24.35节“显示语句的扩展”所述。</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>SHOW PROCEDURE STATUS LIKE 'sp1'\G</code></strong>
*************************** 1. row ***************************
                  Db: test
                Name: sp1
                Type: PROCEDURE
             Definer: testuser@localhost
            Modified: 2018-08-08 13:54:11
             Created: 2018-08-08 13:54:11
       Security_type: DEFINER
             Comment:
character_set_client: utf8
collation_connection: utf8_general_ci
  Database Collation: latin1_swedish_ci
</pre><p>
                <code class="literal">character_set_client</code> is the session value of
                the <a class="link" href="server-administration.html#sysvar_character_set_client"><code class="literal">character_set_client</code></a> system
                variable when the routine was created.
                <code class="literal">collation_connection</code> is the session value of
                the <a class="link" href="server-administration.html#sysvar_collation_connection"><code class="literal">collation_connection</code></a> system
                variable when the routine was created. <code class="literal">Database
                Collation</code> is the collation of the database with which
                the routine is associated.
            </p><p style="color:blue;">character_set_client是创建例程时character_set_client系统变量的会话值。collation_connection是创建例程时collation_connection系统变量的会话值。数据库排序规则是与例程关联的数据库的排序规则。</p><p>
                Stored routine information is also available from the
                <code class="literal">INFORMATION_SCHEMA</code>
                <a class="link" href="information-schema.html#parameters-table" title="24.15&nbsp;The INFORMATION_SCHEMA PARAMETERS Table"><code class="literal">PARAMETERS</code></a> and
                <a class="link" href="information-schema.html#routines-table" title="24.21&nbsp;The INFORMATION_SCHEMA ROUTINES Table"><code class="literal">ROUTINES</code></a> tables. See
                <a class="xref" href="information-schema.html#parameters-table" title="24.15&nbsp;The INFORMATION_SCHEMA PARAMETERS Table">Section&nbsp;24.15, “The INFORMATION_SCHEMA PARAMETERS Table”</a>, and
                <a class="xref" href="information-schema.html#routines-table" title="24.21&nbsp;The INFORMATION_SCHEMA ROUTINES Table">Section&nbsp;24.21, “The INFORMATION_SCHEMA ROUTINES Table”</a>.
            </p><p style="color:blue;">存储的常规信息也可从Debug Type架构参数和例程表中获取。参见第24.15节，“信息结构模式参数表”和第24.21节“信息模式模式例程表”。</p>
            </div>
            <div class="section">
                <div class="titlepage">
                    <div>
                        <div>
                            <h4 class="title"><a name="show-processlist"></a>13.7.5.29&nbsp;SHOW PROCESSLIST Syntax</h4>

                        </div>

                    </div>

                </div>
                <a class="indexterm" name="idm140286826648880"></a><a class="indexterm" name="idm140286826647808"></a><a class="indexterm" name="idm140286826646736"></a><a class="indexterm" name="idm140286826645648"></a><a class="indexterm" name="idm140286826644160"></a><a class="indexterm" name="idm140286826642672"></a><pre data-lang="sql" class="programlisting">SHOW [FULL] PROCESSLIST
</pre><p>
                <a class="link" href="sql-syntax.html#show-processlist" title="13.7.5.29&nbsp;SHOW PROCESSLIST Syntax"><code class="literal">SHOW PROCESSLIST</code></a> shows which
                threads are running. If you have the
                <a class="link" href="security.html#priv_process"><code class="literal">PROCESS</code></a> privilege, you can see
                all threads. Otherwise, you can see only your own threads (that
                is, threads associated with the MySQL account that you are
                using). If you do not use the <code class="literal">FULL</code> keyword,
                only the first 100 characters of each statement are shown in the
                <code class="literal">Info</code> field.
            </p><p style="color:blue;">show processlist显示正在运行的线程。如果您具有进程特权，则可以看到所有线程。否则，您只能看到自己的线程（即，与您正在使用的mysql帐户关联的线程）。如果不使用full关键字，则在info字段中只显示每个语句的前100个字符。</p><p>
                The <a class="link" href="sql-syntax.html#show-processlist" title="13.7.5.29&nbsp;SHOW PROCESSLIST Syntax"><code class="literal">SHOW PROCESSLIST</code></a> statement is
                very useful if you get the <span class="quote">“<span class="quote">too many connections</span>”</span>
                error message and want to find out what is going on. MySQL
                reserves one extra connection to be used by accounts that have
                the <a class="link" href="security.html#priv_super"><code class="literal">SUPER</code></a> privilege, to ensure
                that administrators should always be able to connect and check
                the system (assuming that you are not giving this privilege to
                all your users).
            </p><p style="color:blue;">如果您收到“连接太多”错误消息并想知道发生了什么，那么show processlist语句非常有用。mysql保留了一个额外的连接供具有超级权限的帐户使用，以确保管理员始终能够连接和检查系统（假设您没有将此权限授予所有用户）。</p><p>
                Threads can be killed with the
                <a class="link" href="sql-syntax.html#kill" title="13.7.6.4&nbsp;KILL Syntax"><code class="literal">KILL</code></a> statement. See
                <a class="xref" href="sql-syntax.html#kill" title="13.7.6.4&nbsp;KILL Syntax">Section&nbsp;13.7.6.4, “KILL Syntax”</a>.
            </p><p style="color:blue;">可以使用kill语句终止线程。见第13.7.6.4节“终止语法”。</p><p>
                Example of <a class="link" href="sql-syntax.html#show-processlist" title="13.7.5.29&nbsp;SHOW PROCESSLIST Syntax"><code class="literal">SHOW PROCESSLIST</code></a>
                output:
            </p><p style="color:blue;">显示进程列表输出示例：</p><pre data-lang="sql" class="programlisting">mysql&gt; SHOW FULL PROCESSLIST\G
*************************** 1. row ***************************
Id: 1
User: system user
Host:
db: NULL
Command: Connect
Time: 1030455
State: Waiting for master to send event
Info: NULL
*************************** 2. row ***************************
Id: 2
User: system user
Host:
db: NULL
Command: Connect
Time: 1004
State: Has read all relay log; waiting for the slave
       I/O thread to update it
Info: NULL
*************************** 3. row ***************************
Id: 3112
User: replikator
Host: artemis:2204
db: NULL
Command: Binlog Dump
Time: 2144
State: Has sent all binlog to slave; waiting for binlog to be updated
Info: NULL
*************************** 4. row ***************************
Id: 3113
User: replikator
Host: iconnect2:45781
db: NULL
Command: Binlog Dump
Time: 2086
State: Has sent all binlog to slave; waiting for binlog to be updated
Info: NULL
*************************** 5. row ***************************
Id: 3123
User: stefan
Host: localhost
db: apollon
Command: Query
Time: 0
State: NULL
Info: SHOW FULL PROCESSLIST
5 rows in set (0.00 sec)
</pre><p>
                <a class="link" href="sql-syntax.html#show-processlist" title="13.7.5.29&nbsp;SHOW PROCESSLIST Syntax"><code class="literal">SHOW PROCESSLIST</code></a> output has these
                columns:
            </p><p style="color:blue;">显示进程列表输出具有以下列：</p>
                <div class="itemizedlist">
                    <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><a name="processlist_id"></a>
                        <code class="literal">Id</code>
                    </p><p style="color:blue;">身份证件</p><p>
                        The connection identifier. This is the same type of value
                        displayed in the <code class="literal">ID</code> column of the
                        <code class="literal">INFORMATION_SCHEMA</code>
                        <a class="link" href="information-schema.html#processlist-table" title="24.18&nbsp;The INFORMATION_SCHEMA PROCESSLIST Table"><code class="literal">PROCESSLIST</code></a> table, the
                        <code class="literal">PROCESSLIST_ID</code> column of the Performance
                        Schema <a class="link" href="performance-schema.html#threads-table" title="25.12.16.3&nbsp;The threads Table"><code class="literal">threads</code></a> table, and
                        returned by the
                        <a class="link" href="functions.html#function_connection-id"><code class="literal">CONNECTION_ID()</code></a> function.
                    </p><p style="color:blue;">连接标识符。这与information schema processlist表的id列、performance schema threads表的processlist id列中显示的值类型相同，并由connection \u id（）函数返回。</p></li><li class="listitem"><p><a name="processlist_user"></a>
                        <code class="literal">User</code>
                    </p><p style="color:blue;">用户</p><p>
                        The MySQL user who issued the statement. A value of
                        <code class="literal">system user</code> refers to a nonclient thread
                        spawned by the server to handle tasks internally. This could
                        be the I/O or SQL thread used on replication slaves or a
                        delayed-row handler. For <code class="literal">system user</code>,
                        there is no host specified in the <code class="literal">Host</code>
                        column. <code class="literal">unauthenticated user</code> refers to a
                        thread that has become associated with a client connection
                        but for which authentication of the client user has not yet
                        been done. <code class="literal">event_scheduler</code> refers to the
                        thread that monitors scheduled events (see
                        <a class="xref" href="stored-objects.html#event-scheduler" title="23.4&nbsp;Using the Event Scheduler">Section&nbsp;23.4, “Using the Event Scheduler”</a>).
                    </p><p style="color:blue;">发出声明的mysql用户。system user的值是指服务器生成的用于在内部处理任务的非客户端线程。这可能是复制从机上使用的I/O或SQL线程，也可能是延迟的行处理程序。对于系统用户，主机列中没有指定主机。未经身份验证的用户指的是已与客户端连接关联但尚未对客户端用户进行身份验证的线程。事件调度器是指监视已调度事件的线程（参见第23.4节“使用事件调度器”）。</p></li><li class="listitem"><p><a name="processlist_host"></a>
                        <code class="literal">Host</code>
                    </p><p style="color:blue;">主持人</p><p>
                        The host name of the client issuing the statement (except
                        for <code class="literal">system user</code>, for which there is no
                        host). The host name for TCP/IP connections is reported in
                        <code class="literal"><em class="replaceable"><code>host_name</code></em>:<em class="replaceable"><code>client_port</code></em></code>
                        format to make it easier to determine which client is doing
                        what.
                    </p><p style="color:blue;">发出语句的客户端的主机名（系统用户除外，该用户没有主机）。TCP/IP连接的主机名以主机名：客户端端口格式报告，以便更容易确定哪个客户端正在执行什么操作。</p></li><li class="listitem"><p><a name="processlist_db"></a>
                        <code class="literal">db</code>
                    </p><p style="color:blue;">分贝</p><p>
                        The default database, if one is selected; otherwise
                        <code class="literal">NULL</code>.
                    </p><p style="color:blue;">如果选择了默认数据库，则为默认数据库；否则为空。</p></li><li class="listitem"><p><a name="processlist_command"></a>
                        <code class="literal">Command</code>
                    </p><p style="color:blue;">命令</p><p>
                        The type of command the thread is executing. For
                        descriptions for thread commands, see
                        <a class="xref" href="optimization.html#thread-information" title="8.14&nbsp;Examining Thread Information">Section&nbsp;8.14, “Examining Thread Information”</a>. The value of this
                        column corresponds to the
                        <code class="literal">COM_<em class="replaceable"><code>xxx</code></em></code>
                        commands of the client/server protocol and
                        <code class="literal">Com_<em class="replaceable"><code>xxx</code></em></code> status
                        variables. See <a class="xref" href="server-administration.html#server-status-variables" title="5.1.9&nbsp;Server Status Variables">Section&nbsp;5.1.9, “Server Status Variables”</a>.
                    </p><p style="color:blue;">线程正在执行的命令的类型。有关线程命令的说明，请参阅8.14节“检查线程信息”。此列的值对应于客户机/服务器协议的com_xxx命令和com_xxx状态变量。见第5.1.9节“服务器状态变量”。</p></li><li class="listitem"><p><a name="processlist_time"></a>
                        <code class="literal">Time</code>
                    </p><p style="color:blue;">时间</p><p>
                        The time in seconds that the thread has been in its current
                        state. For a slave SQL thread, the value is the number of
                        seconds between the timestamp of the last replicated event
                        and the real time of the slave machine. See
                        <a class="xref" href="replication.html#replication-implementation-details" title="16.2.2&nbsp;Replication Implementation Details">Section&nbsp;16.2.2, “Replication Implementation Details”</a>.
                    </p><p style="color:blue;">线程处于当前状态的时间（秒）。对于从属SQL线程，该值是最后一个复制事件的时间戳与从属计算机的实时之间的秒数。参见第16.2.2节“复制实现详细信息”。</p></li><li class="listitem"><p><a name="processlist_state"></a>
                        <code class="literal">State</code>
                    </p><p style="color:blue;">国家</p><p>
                        An action, event, or state that indicates what the thread is
                        doing. Descriptions for <code class="literal">State</code> values can
                        be found at <a class="xref" href="optimization.html#thread-information" title="8.14&nbsp;Examining Thread Information">Section&nbsp;8.14, “Examining Thread Information”</a>.
                    </p><p style="color:blue;">指示线程正在执行的操作、事件或状态。有关状态值的说明，请参见第8.14节“检查线程信息”。</p><p>
                        Most states correspond to very quick operations. If a thread
                        stays in a given state for many seconds, there might be a
                        problem that needs to be investigated.
                    </p><p style="color:blue;">大多数状态对应于非常快速的操作。如果一个线程在一个给定的状态下停留了很多秒，可能有一个问题需要调查。</p><p>
                        For the <a class="link" href="sql-syntax.html#show-processlist" title="13.7.5.29&nbsp;SHOW PROCESSLIST Syntax"><code class="literal">SHOW PROCESSLIST</code></a>
                        statement, the value of <code class="literal">State</code> is
                        <code class="literal">NULL</code>.
                    </p><p style="color:blue;">对于show processlist语句，state的值为空。</p></li><li class="listitem"><p><a name="processlist_info"></a>
                        <code class="literal">Info</code>
                    </p><p style="color:blue;">信息</p><p>
                        The statement the thread is executing, or
                        <code class="literal">NULL</code> if it is not executing any
                        statement. The statement might be the one sent to the
                        server, or an innermost statement if the statement executes
                        other statements. For example, if a <code class="literal">CALL</code>
                        statement executes a stored procedure that is executing a
                        <a class="link" href="sql-syntax.html#select" title="13.2.9&nbsp;SELECT Syntax"><code class="literal">SELECT</code></a> statement, the
                        <code class="literal">Info</code> value shows the
                        <a class="link" href="sql-syntax.html#select" title="13.2.9&nbsp;SELECT Syntax"><code class="literal">SELECT</code></a> statement.
                    </p><p style="color:blue;">线程正在执行的语句，如果不执行任何语句，则为空。该语句可能是发送到服务器的语句，如果该语句执行其他语句，则可能是最里面的语句。例如，如果call语句执行执行select语句的存储过程，则info值显示select语句。</p></li></ul>
                </div>
                <p>
                    Process information is also available from the
                    <a class="link" href="programs.html#mysqladmin" title="4.5.2&nbsp;mysqladmin — Client for Administering a MySQL Server"><span class="command"><strong>mysqladmin processlist</strong></span></a> command, the
                    <code class="literal">INFORMATION_SCHEMA</code>
                    <a class="link" href="information-schema.html#processlist-table" title="24.18&nbsp;The INFORMATION_SCHEMA PROCESSLIST Table"><code class="literal">PROCESSLIST</code></a> table, and the
                    Performance Schema <a class="link" href="performance-schema.html#threads-table" title="25.12.16.3&nbsp;The threads Table"><code class="literal">threads</code></a> table
                    (see <a class="xref" href="programs.html#mysqladmin" title="4.5.2&nbsp;mysqladmin — Client for Administering a MySQL Server">Section&nbsp;4.5.2, “<span class="command"><strong>mysqladmin</strong></span> — Client for Administering a MySQL Server”</a>,
                    <a class="xref" href="information-schema.html#processlist-table" title="24.18&nbsp;The INFORMATION_SCHEMA PROCESSLIST Table">Section&nbsp;24.18, “The INFORMATION_SCHEMA PROCESSLIST Table”</a>, and
                    <a class="xref" href="performance-schema.html#threads-table" title="25.12.16.3&nbsp;The threads Table">Section&nbsp;25.12.16.3, “The threads Table”</a>). In contrast to the
                    <code class="literal">INFORMATION_SCHEMA</code>
                    <a class="link" href="information-schema.html#processlist-table" title="24.18&nbsp;The INFORMATION_SCHEMA PROCESSLIST Table"><code class="literal">PROCESSLIST</code></a> table and
                    <a class="link" href="sql-syntax.html#show-processlist" title="13.7.5.29&nbsp;SHOW PROCESSLIST Syntax"><code class="literal">SHOW PROCESSLIST</code></a> statement, which
                    have negative performance consequences because they require a
                    mutex, access to <a class="link" href="performance-schema.html#threads-table" title="25.12.16.3&nbsp;The threads Table"><code class="literal">threads</code></a> does not
                    require a mutex and has minimal impact on server performance.
                    The <a class="link" href="performance-schema.html#threads-table" title="25.12.16.3&nbsp;The threads Table"><code class="literal">threads</code></a> table also shows
                    information about background threads, which the
                    <a class="link" href="information-schema.html#processlist-table" title="24.18&nbsp;The INFORMATION_SCHEMA PROCESSLIST Table"><code class="literal">PROCESSLIST</code></a> table and
                    <a class="link" href="sql-syntax.html#show-processlist" title="13.7.5.29&nbsp;SHOW PROCESSLIST Syntax"><code class="literal">SHOW PROCESSLIST</code></a> do not. This
                    means that <a class="link" href="performance-schema.html#threads-table" title="25.12.16.3&nbsp;The threads Table"><code class="literal">threads</code></a> can be used to
                    monitor activity the other thread information sources cannot.
                </p><p style="color:blue;">进程信息也可以从mysqladmin processlist命令、information戥schema processlist表和performance schema threads表中获得（请参阅第4.5.2节“mysqladmin-用于管理mysql服务器的客户端”、第24.18节“information戥schema processlist表”和第25.12.16.3节“线程表”）。与information_schema processlist table和show processlist语句不同，它们由于需要互斥而对性能产生负面影响，对线程的访问不需要互斥，并且对服务器性能的影响最小。threads表还显示有关后台线程的信息，而processlist表和show processlist不显示这些信息。这意味着线程可以用来监视其他线程信息源不能监视的活动。</p>
            </div>
            <div class="section">
                <div class="titlepage">
                    <div>
                        <div>
                            <h4 class="title"><a name="show-profile"></a>13.7.5.30&nbsp;SHOW PROFILE Syntax</h4>

                        </div>

                    </div>

                </div>
                <a class="indexterm" name="idm140286826554592"></a><a class="indexterm" name="idm140286826553520"></a><pre data-lang="sql" class="programlisting">SHOW PROFILE [<em class="replaceable"><code>type</code></em> [, <em class="replaceable"><code>type</code></em>] ... ]
    [FOR QUERY <em class="replaceable"><code>n</code></em>]
    [LIMIT <em class="replaceable"><code>row_count</code></em> [OFFSET <em class="replaceable"><code>offset</code></em>]]

<em class="replaceable"><code>type</code></em>: {
    ALL
  | BLOCK IO
  | CONTEXT SWITCHES
  | CPU
  | IPC
  | MEMORY
  | PAGE FAULTS
  | SOURCE
  | SWAPS
}
</pre><p>
                The <a class="link" href="sql-syntax.html#show-profile" title="13.7.5.30&nbsp;SHOW PROFILE Syntax"><code class="literal">SHOW PROFILE</code></a> and
                <a class="link" href="sql-syntax.html#show-profiles" title="13.7.5.31&nbsp;SHOW PROFILES Syntax"><code class="literal">SHOW PROFILES</code></a> statements display
                profiling information that indicates resource usage for
                statements executed during the course of the current session.
            </p><p style="color:blue;">show profile和show profiles语句显示分析信息，指示在当前会话过程中执行的语句的资源使用情况。</p>
                <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">

                    <div class="admon-title">
                        Note
                    </div>
                    <p>
                        The <a class="link" href="sql-syntax.html#show-profile" title="13.7.5.30&nbsp;SHOW PROFILE Syntax"><code class="literal">SHOW PROFILE</code></a> and
                        <a class="link" href="sql-syntax.html#show-profiles" title="13.7.5.31&nbsp;SHOW PROFILES Syntax"><code class="literal">SHOW PROFILES</code></a> statements are
                        deprecated and will be removed in a future MySQL release. Use
                        the <a class="link" href="performance-schema.html" title="Chapter&nbsp;25&nbsp;MySQL Performance Schema">Performance
                        Schema</a> instead; see
                        <a class="xref" href="performance-schema.html#performance-schema-query-profiling" title="25.19.1&nbsp;Query Profiling Using Performance Schema">Section&nbsp;25.19.1, “Query Profiling Using Performance Schema”</a>.
                    </p><p style="color:blue;">show profile和show profiles语句已弃用，将在以后的mysql版本中删除。请改用性能模式；请参阅25.19.1节，“使用性能模式进行查询分析”。</p>
                </div>
                <p>
                    To control profiling, use the
                    <a class="link" href="server-administration.html#sysvar_profiling"><code class="literal">profiling</code></a> session variable,
                    which has a default value of 0 (<code class="literal">OFF</code>). Enable
                    profiling by setting <a class="link" href="server-administration.html#sysvar_profiling"><code class="literal">profiling</code></a>
                    to 1 or <code class="literal">ON</code>:
                </p><p style="color:blue;">要控制分析，请使用分析会话变量，该变量的默认值为0（off）。通过将分析设置为1或打开启用分析：</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>SET profiling = 1;</code></strong>
</pre><p>
                <a class="link" href="sql-syntax.html#show-profiles" title="13.7.5.31&nbsp;SHOW PROFILES Syntax"><code class="literal">SHOW PROFILES</code></a> displays a list of
                the most recent statements sent to the server. The size of the
                list is controlled by the
                <a class="link" href="server-administration.html#sysvar_profiling_history_size"><code class="literal">profiling_history_size</code></a> session
                variable, which has a default value of 15. The maximum value is
                100. Setting the value to 0 has the practical effect of
                disabling profiling.
            </p><p style="color:blue;">显示配置文件显示发送到服务器的最新语句的列表。列表的大小由profiling_history_size session变量控制，该变量的默认值为15。最大值为100。将该值设置为0具有禁用分析的实际效果。</p><p>
                All statements are profiled except <a class="link" href="sql-syntax.html#show-profile" title="13.7.5.30&nbsp;SHOW PROFILE Syntax"><code class="literal">SHOW
                PROFILE</code></a> and <a class="link" href="sql-syntax.html#show-profiles" title="13.7.5.31&nbsp;SHOW PROFILES Syntax"><code class="literal">SHOW
                PROFILES</code></a>, so you will find neither of those statements
                in the profile list. Malformed statements are profiled. For
                example, <code class="literal">SHOW PROFILING</code> is an illegal
                statement, and a syntax error occurs if you try to execute it,
                but it will show up in the profiling list.
            </p><p style="color:blue;">除了show profile和show profiles之外，所有语句都将被分析，因此您将在profile列表中找不到这两个语句。分析格式错误的语句。例如，show profiling是一个非法语句，如果您尝试执行它，就会出现语法错误，但它会显示在profiling列表中。</p><p>
                <a class="link" href="sql-syntax.html#show-profile" title="13.7.5.30&nbsp;SHOW PROFILE Syntax"><code class="literal">SHOW PROFILE</code></a> displays detailed
                information about a single statement. Without the <code class="literal">FOR
                QUERY <em class="replaceable"><code>n</code></em></code> clause, the output
                pertains to the most recently executed statement. If
                <code class="literal">FOR QUERY <em class="replaceable"><code>n</code></em></code> is
                included, <a class="link" href="sql-syntax.html#show-profile" title="13.7.5.30&nbsp;SHOW PROFILE Syntax"><code class="literal">SHOW PROFILE</code></a> displays
                information for statement <em class="replaceable"><code>n</code></em>. The
                values of <em class="replaceable"><code>n</code></em> correspond to the
                <code class="literal">Query_ID</code> values displayed by
                <a class="link" href="sql-syntax.html#show-profiles" title="13.7.5.31&nbsp;SHOW PROFILES Syntax"><code class="literal">SHOW PROFILES</code></a>.
            </p><p style="color:blue;">显示配置文件显示有关单个语句的详细信息。如果没有for query n子句，输出就属于最近执行的语句。如果包含查询n，则show profile显示语句n的信息。n的值对应于show profiles显示的查询id值。</p><p>
                The <code class="literal">LIMIT
                <em class="replaceable"><code>row_count</code></em></code> clause may be
                given to limit the output to
                <em class="replaceable"><code>row_count</code></em> rows. If
                <code class="literal">LIMIT</code> is given, <code class="literal">OFFSET
                <em class="replaceable"><code>offset</code></em></code> may be added to
                begin the output <em class="replaceable"><code>offset</code></em> rows into the
                full set of rows.
            </p><p style="color:blue;">可以使用LIMIT ROW U COUNT子句将输出限制为ROW U COUNT ROWS。如果给定了限制，则可以添加偏移量偏移量，以将输出偏移量行开始添加到完整的行集合中。</p><p>
                By default, <a class="link" href="sql-syntax.html#show-profile" title="13.7.5.30&nbsp;SHOW PROFILE Syntax"><code class="literal">SHOW PROFILE</code></a> displays
                <code class="literal">Status</code> and <code class="literal">Duration</code>
                columns. The <code class="literal">Status</code> values are like the
                <code class="literal">State</code> values displayed by
                <a class="link" href="sql-syntax.html#show-processlist" title="13.7.5.29&nbsp;SHOW PROCESSLIST Syntax"><code class="literal">SHOW PROCESSLIST</code></a>, although there
                might be some minor differences in interpretion for the two
                statements for some status values (see
                <a class="xref" href="optimization.html#thread-information" title="8.14&nbsp;Examining Thread Information">Section&nbsp;8.14, “Examining Thread Information”</a>).
            </p><p style="color:blue;">默认情况下，“显示配置文件”显示“状态”和“持续时间”列。这些状态值与show processlist显示的状态值类似，不过对于某些状态值，这两个语句的解释可能有一些细微的差异（请参阅第8.14节“检查线程信息”）。</p><p>
                Optional <em class="replaceable"><code>type</code></em> values may be specified
                to display specific additional types of information:
            </p><p style="color:blue;">可以指定可选的类型值以显示特定的附加信息类型：</p>
                <div class="itemizedlist">
                    <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                        <code class="literal">ALL</code> displays all information
                    </p><p style="color:blue;">全部显示所有信息</p></li><li class="listitem"><p>
                        <code class="literal">BLOCK IO</code> displays counts for block input
                        and output operations
                    </p><p style="color:blue;">块IO显示块输入和输出操作的计数</p></li><li class="listitem"><p>
                        <code class="literal">CONTEXT SWITCHES</code> displays counts for
                        voluntary and involuntary context switches
                    </p><p style="color:blue;">上下文切换显示自愿和非自愿上下文切换的计数</p></li><li class="listitem"><p>
                        <code class="literal">CPU</code> displays user and system CPU usage
                        times
                    </p><p style="color:blue;">CPU显示用户和系统CPU使用时间</p></li><li class="listitem"><p>
                        <code class="literal">IPC</code> displays counts for messages sent and
                        received
                    </p><p style="color:blue;">IPC显示发送和接收消息的计数</p></li><li class="listitem"><p>
                        <code class="literal">MEMORY</code> is not currently implemented
                    </p><p style="color:blue;">内存当前未实现</p></li><li class="listitem"><p>
                        <code class="literal">PAGE FAULTS</code> displays counts for major and
                        minor page faults
                    </p><p style="color:blue;">页面错误显示主要和次要页面错误的计数</p></li><li class="listitem"><p>
                        <code class="literal">SOURCE</code> displays the names of functions
                        from the source code, together with the name and line number
                        of the file in which the function occurs
                    </p><p style="color:blue;">source显示源代码中函数的名称，以及函数所在文件的名称和行号</p></li><li class="listitem"><p>
                        <code class="literal">SWAPS</code> displays swap counts
                    </p><p style="color:blue;">交换显示交换计数</p></li></ul>
                </div>
                <p>
                    Profiling is enabled per session. When a session ends, its
                    profiling information is lost.
                </p><p style="color:blue;">每个会话都启用分析。当会话结束时，其分析信息将丢失。</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT @@profiling;</code></strong>
+-------------+
| @@profiling |
+-------------+
|           0 |
+-------------+
1 row in set (0.00 sec)

mysql&gt; <strong class="userinput"><code>SET profiling = 1;</code></strong>
Query OK, 0 rows affected (0.00 sec)

mysql&gt; <strong class="userinput"><code>DROP TABLE IF EXISTS t1;</code></strong>
Query OK, 0 rows affected, 1 warning (0.00 sec)

mysql&gt; <strong class="userinput"><code>CREATE TABLE T1 (id INT);</code></strong>
Query OK, 0 rows affected (0.01 sec)

mysql&gt; <strong class="userinput"><code>SHOW PROFILES;</code></strong>
+----------+----------+--------------------------+
| Query_ID | Duration | Query                    |
+----------+----------+--------------------------+
|        0 | 0.000088 | SET PROFILING = 1        |
|        1 | 0.000136 | DROP TABLE IF EXISTS t1  |
|        2 | 0.011947 | CREATE TABLE t1 (id INT) |
+----------+----------+--------------------------+
3 rows in set (0.00 sec)

mysql&gt; <strong class="userinput"><code>SHOW PROFILE;</code></strong>
+----------------------+----------+
| Status               | Duration |
+----------------------+----------+
| checking permissions | 0.000040 |
| creating table       | 0.000056 |
| After create         | 0.011363 |
| query end            | 0.000375 |
| freeing items        | 0.000089 |
| logging slow query   | 0.000019 |
| cleaning up          | 0.000005 |
+----------------------+----------+
7 rows in set (0.00 sec)

mysql&gt; <strong class="userinput"><code>SHOW PROFILE FOR QUERY 1;</code></strong>
+--------------------+----------+
| Status             | Duration |
+--------------------+----------+
| query end          | 0.000107 |
| freeing items      | 0.000008 |
| logging slow query | 0.000015 |
| cleaning up        | 0.000006 |
+--------------------+----------+
4 rows in set (0.00 sec)

mysql&gt; <strong class="userinput"><code>SHOW PROFILE CPU FOR QUERY 2;</code></strong>
+----------------------+----------+----------+------------+
| Status               | Duration | CPU_user | CPU_system |
+----------------------+----------+----------+------------+
| checking permissions | 0.000040 | 0.000038 |   0.000002 |
| creating table       | 0.000056 | 0.000028 |   0.000028 |
| After create         | 0.011363 | 0.000217 |   0.001571 |
| query end            | 0.000375 | 0.000013 |   0.000028 |
| freeing items        | 0.000089 | 0.000010 |   0.000014 |
| logging slow query   | 0.000019 | 0.000009 |   0.000010 |
| cleaning up          | 0.000005 | 0.000003 |   0.000002 |
+----------------------+----------+----------+------------+
7 rows in set (0.00 sec)
</pre>
                <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">

                    <div class="admon-title">
                        Note
                    </div>
                    <p>
                        Profiling is only partially functional on some architectures.
                        For values that depend on the <code class="literal">getrusage()</code>
                        system call, <code class="literal">NULL</code> is returned on systems
                        such as Windows that do not support the call. In addition,
                        profiling is per process and not per thread. This means that
                        activity on threads within the server other than your own may
                        affect the timing information that you see.
                    </p><p style="color:blue;">在某些架构上，分析只是部分功能。对于依赖于getRusage（）系统调用的值，在不支持该调用的系统（如Windows）上返回null。此外，分析是按进程而不是按线程进行的。这意味着服务器中线程上的活动（而不是您自己的线程）可能会影响您看到的计时信息。</p>
                </div>
                <p>
                    Profiling information is also available from the
                    <code class="literal">INFORMATION_SCHEMA</code>
                    <a class="link" href="information-schema.html#profiling-table" title="24.19&nbsp;The INFORMATION_SCHEMA PROFILING Table"><code class="literal">PROFILING</code></a> table. See
                    <a class="xref" href="information-schema.html#profiling-table" title="24.19&nbsp;The INFORMATION_SCHEMA PROFILING Table">Section&nbsp;24.19, “The INFORMATION_SCHEMA PROFILING Table”</a>. For example, the following
                    queries are equivalent:
                </p><p style="color:blue;">信息架构分析表中也提供了分析信息。参见第24.19节“信息模式分析表”。例如，以下查询是等效的：</p><pre data-lang="sql" class="programlisting">SHOW PROFILE FOR QUERY 2;

SELECT STATE, FORMAT(DURATION, 6) AS DURATION
FROM INFORMATION_SCHEMA.PROFILING
WHERE QUERY_ID = 2 ORDER BY SEQ;
</pre>
            </div>
            <div class="section">
                <div class="titlepage">
                    <div>
                        <div>
                            <h4 class="title"><a name="show-profiles"></a>13.7.5.31&nbsp;SHOW PROFILES Syntax</h4>

                        </div>

                    </div>

                </div>
                <a class="indexterm" name="idm140286826471200"></a><pre data-lang="sql" class="programlisting">SHOW PROFILES
</pre><p>
                The <a class="link" href="sql-syntax.html#show-profiles" title="13.7.5.31&nbsp;SHOW PROFILES Syntax"><code class="literal">SHOW PROFILES</code></a> statement,
                together with <a class="link" href="sql-syntax.html#show-profile" title="13.7.5.30&nbsp;SHOW PROFILE Syntax"><code class="literal">SHOW PROFILE</code></a>,
                displays profiling information that indicates resource usage for
                statements executed during the course of the current session.
                For more information, see <a class="xref" href="sql-syntax.html#show-profile" title="13.7.5.30&nbsp;SHOW PROFILE Syntax">Section&nbsp;13.7.5.30, “SHOW PROFILE Syntax”</a>.
            </p><p style="color:blue;">show profiles语句与show profile一起显示分析信息，这些信息指示在当前会话过程中执行的语句的资源使用情况。有关详细信息，请参阅第13.7.5.30节“显示配置文件语法”。</p>
                <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">

                    <div class="admon-title">
                        Note
                    </div>
                    <p>
                        The <a class="link" href="sql-syntax.html#show-profile" title="13.7.5.30&nbsp;SHOW PROFILE Syntax"><code class="literal">SHOW PROFILE</code></a> and
                        <a class="link" href="sql-syntax.html#show-profiles" title="13.7.5.31&nbsp;SHOW PROFILES Syntax"><code class="literal">SHOW PROFILES</code></a> statements are
                        deprecated and will be removed in a future MySQL release. Use
                        the <a class="link" href="performance-schema.html" title="Chapter&nbsp;25&nbsp;MySQL Performance Schema">Performance
                        Schema</a> instead; see
                        <a class="xref" href="performance-schema.html#performance-schema-query-profiling" title="25.19.1&nbsp;Query Profiling Using Performance Schema">Section&nbsp;25.19.1, “Query Profiling Using Performance Schema”</a>.
                    </p><p style="color:blue;">show profile和show profiles语句已弃用，将在以后的mysql版本中删除。请改用性能模式；请参阅25.19.1节，“使用性能模式进行查询分析”。</p>
                </div>

            </div>
            <div class="section">
                <div class="titlepage">
                    <div>
                        <div>
                            <h4 class="title"><a name="show-relaylog-events"></a>13.7.5.32&nbsp;SHOW RELAYLOG EVENTS Syntax</h4>

                        </div>

                    </div>

                </div>
                <a class="indexterm" name="idm140286826456192"></a><pre data-lang="sql" class="programlisting">SHOW RELAYLOG EVENTS
    [IN '<em class="replaceable"><code>log_name</code></em>']
    [FROM <em class="replaceable"><code>pos</code></em>]
    [LIMIT [<em class="replaceable"><code>offset</code></em>,] <em class="replaceable"><code>row_count</code></em>]
    [<em class="replaceable"><code>channel_option</code></em>]

<em class="replaceable"><code>channel_option</code></em>:
    FOR CHANNEL <em class="replaceable"><code>channel</code></em>
</pre><p>
                Shows the events in the relay log of a replication slave. If you
                do not specify
                <code class="literal">'<em class="replaceable"><code>log_name</code></em>'</code>, the
                first relay log is displayed. This statement has no effect on
                the master. <a class="link" href="sql-syntax.html#show-relaylog-events" title="13.7.5.32&nbsp;SHOW RELAYLOG EVENTS Syntax"><code class="literal">SHOW RELAYLOG EVENTS</code></a>
                requires the <a class="link" href="security.html#priv_replication-slave"><code class="literal">REPLICATION SLAVE</code></a>
                privilege.
            </p><p style="color:blue;">显示复制从属服务器的中继日志中的事件。如果未指定“日志名称”，将显示第一个中继日志。这句话对主人没有影响。Show RelayLog事件需要复制从属权限。</p><p>
                The <code class="literal">LIMIT</code> clause has the same syntax as for
                the <a class="link" href="sql-syntax.html#select" title="13.2.9&nbsp;SELECT Syntax"><code class="literal">SELECT</code></a> statement. See
                <a class="xref" href="sql-syntax.html#select" title="13.2.9&nbsp;SELECT Syntax">Section&nbsp;13.2.9, “SELECT Syntax”</a>.
            </p><p style="color:blue;">LIMIT子句的语法与SELECT语句的语法相同。参见第13.2.9节“选择语法”。</p>
                <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">

                    <div class="admon-title">
                        Note
                    </div>
                    <p>
                        Issuing a <a class="link" href="sql-syntax.html#show-relaylog-events" title="13.7.5.32&nbsp;SHOW RELAYLOG EVENTS Syntax"><code class="literal">SHOW RELAYLOG EVENTS</code></a>
                        with no <code class="literal">LIMIT</code> clause could start a very
                        time- and resource-consuming process because the server
                        returns to the client the complete contents of the relay log
                        (including all statements modifying data that have been
                        received by the slave).
                    </p><p style="color:blue;">发出show relay log events with no limit子句可能会启动一个非常耗时和资源消耗的过程，因为服务器将中继日志的完整内容（包括修改从服务器接收到的数据的所有语句）返回给客户端。</p>
                </div>
                <p>
                    The optional <code class="literal">FOR CHANNEL
                    <em class="replaceable"><code>channel</code></em></code> clause enables you
                    to name which replication channel the statement applies to.
                    Providing a <code class="literal">FOR CHANNEL
                    <em class="replaceable"><code>channel</code></em></code> clause applies the
                    statement to a specific replication channel. If no channel is
                    named and no extra channels exist, the statement applies to the
                    default channel.
                </p><p style="color:blue;">可选的for channel channel子句允许您命名该语句应用于哪个复制通道。提供for channel channel子句将语句应用于特定的复制通道。如果没有指定信道，并且没有额外的信道存在，则该语句应用于默认信道。</p><p>
                When using multiple replication channels, if a
                <a class="link" href="sql-syntax.html#show-relaylog-events" title="13.7.5.32&nbsp;SHOW RELAYLOG EVENTS Syntax"><code class="literal">SHOW RELAYLOG EVENTS</code></a> statement
                does not have a channel defined using a <code class="literal">FOR CHANNEL
                <em class="replaceable"><code>channel</code></em></code> clause an error is
                generated. See <a class="xref" href="replication.html#replication-channels" title="16.2.3&nbsp;Replication Channels">Section&nbsp;16.2.3, “Replication Channels”</a> for more
                information.
            </p><p style="color:blue;">使用多个复制通道时，如果show relaylog events语句没有使用for channel channel子句定义通道，则会生成错误。有关更多信息，请参阅第16.2.3节“复制通道”。</p><p>
                <a class="link" href="sql-syntax.html#show-relaylog-events" title="13.7.5.32&nbsp;SHOW RELAYLOG EVENTS Syntax"><code class="literal">SHOW RELAYLOG EVENTS</code></a> displays the
                following fields for each event in the relay log:
            </p><p style="color:blue;">show relay log events显示中继日志中每个事件的以下字段：</p>
                <div class="itemizedlist">
                    <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                        <code class="literal">Log_name</code>
                    </p><p style="color:blue;">日志名称</p><p>
                        The name of the file that is being listed.
                    </p><p style="color:blue;">正在列出的文件的名称。</p></li><li class="listitem"><p>
                        <code class="literal">Pos</code>
                    </p><p style="color:blue;">销售时点情报系统</p><p>
                        The position at which the event occurs.
                    </p><p style="color:blue;">事件发生的位置。</p></li><li class="listitem"><p>
                        <code class="literal">Event_type</code>
                    </p><p style="color:blue;">事件类型</p><p>
                        An identifier that describes the event type.
                    </p><p style="color:blue;">描述事件类型的标识符。</p></li><li class="listitem"><p>
                        <code class="literal">Server_id</code>
                    </p><p style="color:blue;">服务器ID</p><p>
                        The server ID of the server on which the event originated.
                    </p><p style="color:blue;">发起事件的服务器的服务器ID。</p></li><li class="listitem"><p>
                        <code class="literal">End_log_pos</code>
                    </p><p style="color:blue;">结束日志位置</p><p>
                        The value of <code class="literal">End_log_pos</code> for this event
                        in the master's binary log.
                    </p><p style="color:blue;">主机二进制日志中此事件的结束日志位置值。</p></li><li class="listitem"><p>
                        <code class="literal">Info</code>
                    </p><p style="color:blue;">信息</p><p>
                        More detailed information about the event type. The format
                        of this information depends on the event type.
                    </p><p style="color:blue;">有关事件类型的详细信息。此信息的格式取决于事件类型。</p></li></ul>
                </div>
                <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">
                    <div class="admon-title">
                        Note
                    </div>
                    <p>
                        Some events relating to the setting of user and system
                        variables are not included in the output from
                        <a class="link" href="sql-syntax.html#show-relaylog-events" title="13.7.5.32&nbsp;SHOW RELAYLOG EVENTS Syntax"><code class="literal">SHOW RELAYLOG EVENTS</code></a>. To get
                        complete coverage of events within a relay log, use
                        <a class="link" href="programs.html#mysqlbinlog" title="4.6.7&nbsp;mysqlbinlog — Utility for Processing Binary Log Files"><span class="command"><strong>mysqlbinlog</strong></span></a>.
                    </p><p style="color:blue;">show relaylog事件的输出中不包括与用户和系统变量设置相关的一些事件。要获得中继日志中事件的完整覆盖率，请使用mysqlbinlog。</p>
                </div>

            </div>
            <div class="section">
                <div class="titlepage">
                    <div>
                        <div>
                            <h4 class="title"><a name="show-slave-hosts"></a>13.7.5.33&nbsp;SHOW SLAVE HOSTS Syntax</h4>

                        </div>

                    </div>

                </div>
                <a class="indexterm" name="idm140286826412560"></a><pre data-lang="sql" class="programlisting">SHOW SLAVE HOSTS
</pre><p>
                Displays a list of replication slaves currently registered with
                the master.
            </p><p style="color:blue;">显示当前在主服务器上注册的复制从属服务器的列表。</p><p>
                <code class="literal">SHOW SLAVE HOSTS</code> should be executed on a
                server that acts as a replication master. <code class="literal">SHOW SLAVE
                HOSTS</code> requires the <a class="link" href="security.html#priv_replication-slave"><code class="literal">REPLICATION
                SLAVE</code></a> privilege. The statement displays information
                about servers that are or have been connected as replication
                slaves, with each row of the result corresponding to one slave
                server, as shown here:
            </p><p style="color:blue;">show slave hosts应该在充当复制主服务器的服务器上执行。显示从属主机需要复制从属权限。该语句显示有关作为复制从属服务器连接或已作为复制从属服务器连接的服务器的信息，结果的每一行对应于一个从属服务器，如下所示：</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>SHOW SLAVE HOSTS</code></strong>;
+------------+-----------+------+-----------+--------------------------------------+
| Server_id  | Host      | Port | Master_id | Slave_UUID                           |
+------------+-----------+------+-----------+--------------------------------------+
|  192168010 | iconnect2 | 3306 | 192168011 | 14cb6624-7f93-11e0-b2c0-c80aa9429562 |
| 1921680101 | athena    | 3306 | 192168011 | 07af4990-f41f-11df-a566-7ac56fdaf645 |
+------------+-----------+------+-----------+--------------------------------------+
</pre>
                <div class="itemizedlist">
                    <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                        <code class="literal">Server_id</code>: The unique server ID of the
                        slave server, as configured in the slave server's
                        option file, or on the command line with
                        <a class="link" href="replication.html#option_mysqld_server-id"><code class="option">--server-id=<em class="replaceable"><code>value</code></em></code></a>.
                    </p><p style="color:blue;">服务器ID：从服务器的唯一服务器ID，在从服务器的选项文件中配置，或在命令行中使用--server id=value。</p></li><li class="listitem"><p>
                        <code class="literal">Host</code>: The host name of the slave server
                        as specified on the slave with the
                        <a class="link" href="replication.html#sysvar_report_host"><code class="option">--report-host</code></a> option. This
                        can differ from the machine name as configured in the
                        operating system.
                    </p><p style="color:blue;">host：使用--report host选项在从属服务器上指定的从属服务器的主机名。这可能与操作系统中配置的计算机名称不同。</p></li><li class="listitem"><p>
                        <code class="literal">User</code>: The slave server user name as,
                        specified on the slave with the
                        <a class="link" href="replication.html#sysvar_report_user"><code class="option">--report-user</code></a> option.
                        Statement output includes this column only if the master
                        server is started with the
                        <a class="link" href="replication.html#option_mysqld_show-slave-auth-info"><code class="option">--show-slave-auth-info</code></a>
                        option.
                    </p><p style="color:blue;">user：从服务器用户名as，在带有--report user选项的从服务器上指定。仅当主服务器使用--show slave auth info选项启动时，语句输出才包含此列。</p></li><li class="listitem"><p>
                        <code class="literal">Password</code>: The slave server password as,
                        specified on the slave with the
                        <a class="link" href="replication.html#sysvar_report_password"><code class="option">--report-password</code></a> option.
                        Statement output includes this column only if the master
                        server is started with the
                        <a class="link" href="replication.html#option_mysqld_show-slave-auth-info"><code class="option">--show-slave-auth-info</code></a>
                        option.
                    </p><p style="color:blue;">password：从服务器密码，在带有--report password选项的从服务器上指定。仅当主服务器使用--show slave auth info选项启动时，语句输出才包含此列。</p></li><li class="listitem"><p>
                        <code class="literal">Port</code>: The port on the master to which the
                        slave server is listening, as specified on the slave with
                        the <a class="link" href="replication.html#sysvar_report_port"><code class="option">--report-port</code></a> option.
                    </p><p style="color:blue;">端口：从服务器正在侦听的主服务器上的端口，在带有--report port选项的从服务器上指定。</p><p>
                        A zero in this column means that the slave port
                        (<a class="link" href="replication.html#sysvar_report_port"><code class="option">--report-port</code></a>) was not set.
                    </p><p style="color:blue;">此列中的零表示未设置从端口（--report port）。</p></li><li class="listitem"><p>
                        <code class="literal">Master_id</code>: The unique server ID of the
                        master server that the slave server is replicating from.
                        This is the server ID of the server on which <code class="literal">SHOW
                        SLAVE HOSTS</code> is executed, so this same value is
                        listed for each row in the result.
                    </p><p style="color:blue;">master_id：从服务器复制的主服务器的唯一服务器id。这是执行show slave hosts的服务器的服务器id，因此结果中的每一行都列出相同的值。</p></li><li class="listitem"><p>
                        <a class="indexterm" name="idm140286826381936"></a>

                        <code class="literal">Slave_UUID</code>: The globally unique ID of
                        this slave, as generated on the slave and found in the
                        slave's <code class="filename">auto.cnf</code> file.
                    </p><p style="color:blue;">slave_uid：在从机上生成并在从机的auto.cnf文件中找到的该从机的全局唯一ID。</p></li></ul>
                </div>

            </div>
            <div class="section">
                <div class="titlepage">
                    <div>
                        <div>
                            <h4 class="title"><a name="show-slave-status"></a>13.7.5.34&nbsp;SHOW SLAVE STATUS Syntax</h4>

                        </div>

                    </div>

                </div>
                <a class="indexterm" name="idm140286826376768"></a><pre data-lang="sql" class="programlisting">SHOW SLAVE STATUS [FOR CHANNEL <em class="replaceable"><code>channel</code></em>]
</pre><p>
                This statement provides status information on essential
                parameters of the slave threads. It requires either the
                <a class="link" href="security.html#priv_super"><code class="literal">SUPER</code></a> or
                <a class="link" href="security.html#priv_replication-client"><code class="literal">REPLICATION CLIENT</code></a> privilege.
            </p><p style="color:blue;">此语句提供从属线程的基本参数的状态信息。它需要超级或复制客户端权限。</p><p>
                If you issue this statement using the <a class="link" href="programs.html#mysql" title="4.5.1&nbsp;mysql — The MySQL Command-Line Client"><span class="command"><strong>mysql</strong></span></a>
                client, you can use a <code class="literal">\G</code> statement terminator
                rather than a semicolon to obtain a more readable vertical
                layout:
            </p><p style="color:blue;">如果使用mysql客户端发出此语句，则可以使用语句结束符而不是分号来获得更可读的垂直布局：</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>SHOW SLAVE STATUS\G</code></strong>
*************************** 1. row ***************************
               Slave_IO_State: Waiting for master to send event
                  Master_Host: localhost
                  Master_User: repl
                  Master_Port: 13000
                Connect_Retry: 60
              Master_Log_File: master-bin.000002
          Read_Master_Log_Pos: 1307
               Relay_Log_File: slave-relay-bin.000003
                Relay_Log_Pos: 1508
        Relay_Master_Log_File: master-bin.000002
             Slave_IO_Running: Yes
            Slave_SQL_Running: Yes
              Replicate_Do_DB:
          Replicate_Ignore_DB:
           Replicate_Do_Table:
       Replicate_Ignore_Table:
      Replicate_Wild_Do_Table:
  Replicate_Wild_Ignore_Table:
                   Last_Errno: 0
                   Last_Error:
                 Skip_Counter: 0
          Exec_Master_Log_Pos: 1307
              Relay_Log_Space: 1858
              Until_Condition: None
               Until_Log_File:
                Until_Log_Pos: 0
           Master_SSL_Allowed: No
           Master_SSL_CA_File:
           Master_SSL_CA_Path:
              Master_SSL_Cert:
            Master_SSL_Cipher:
               Master_SSL_Key:
        Seconds_Behind_Master: 0
Master_SSL_Verify_Server_Cert: No
                Last_IO_Errno: 0
                Last_IO_Error:
               Last_SQL_Errno: 0
               Last_SQL_Error:
  Replicate_Ignore_Server_Ids:
             Master_Server_Id: 1
                  Master_UUID: 3e11fa47-71ca-11e1-9e33-c80aa9429562
             Master_Info_File: /var/mysqld.2/data/master.info
                    SQL_Delay: 0
          SQL_Remaining_Delay: NULL
      Slave_SQL_Running_State: Reading event from the relay log
           Master_Retry_Count: 10
                  Master_Bind:
      Last_IO_Error_Timestamp:
     Last_SQL_Error_Timestamp:
               Master_SSL_Crl:
           Master_SSL_Crlpath:
           Retrieved_Gtid_Set: 3e11fa47-71ca-11e1-9e33-c80aa9429562:1-5
            Executed_Gtid_Set: 3e11fa47-71ca-11e1-9e33-c80aa9429562:1-5
                Auto_Position: 1
         Replicate_Rewrite_DB:
                 Channel_name:
           Master_TLS_Version: TLSv1.2
</pre><p>
                The Performance Schema provides tables that expose replication
                information. This is similar to the information available from
                the <a class="link" href="sql-syntax.html#show-slave-status" title="13.7.5.34&nbsp;SHOW SLAVE STATUS Syntax"><code class="literal">SHOW SLAVE STATUS</code></a> statement,
                but represented in table form. For details, see
                <a class="xref" href="performance-schema.html#performance-schema-replication-tables" title="25.12.11&nbsp;Performance Schema Replication Tables">Section&nbsp;25.12.11, “Performance Schema Replication Tables”</a>.
            </p><p style="color:blue;">性能架构提供公开复制信息的表。这与show slave status语句中提供的信息类似，但以表格形式表示。有关详细信息，请参阅25.12.11节“性能模式复制表”。</p><p>
                The following list describes the fields returned by
                <a class="link" href="sql-syntax.html#show-slave-status" title="13.7.5.34&nbsp;SHOW SLAVE STATUS Syntax"><code class="literal">SHOW SLAVE STATUS</code></a>. For additional
                information about interpreting their meanings, see
                <a class="xref" href="replication.html#replication-administration-status" title="16.1.7.1&nbsp;Checking Replication Status">Section&nbsp;16.1.7.1, “Checking Replication Status”</a>.
            </p><p style="color:blue;">下表描述了show slave status返回的字段。有关解释其含义的其他信息，请参阅第16.1.7.1节“检查复制状态”。</p>
                <div class="itemizedlist">
                    <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                        <code class="literal">Slave_IO_State</code>
                    </p><p style="color:blue;">奴隶国</p><p>
                        A copy of the <code class="literal">State</code> field of the
                        <a class="link" href="sql-syntax.html#show-processlist" title="13.7.5.29&nbsp;SHOW PROCESSLIST Syntax"><code class="literal">SHOW PROCESSLIST</code></a> output for
                        the slave I/O thread. This tells you what the thread is
                        doing: trying to connect to the master, waiting for events
                        from the master, reconnecting to the master, and so on. For
                        a listing of possible states, see
                        <a class="xref" href="optimization.html#slave-io-thread-states" title="8.14.5&nbsp;Replication Slave I/O Thread States">Section&nbsp;8.14.5, “Replication Slave I/O Thread States”</a>.
                    </p><p style="color:blue;">从I/O线程的Show ProcessList输出的状态字段的副本。这将告诉您线程正在做什么：尝试连接到主线程，等待来自主线程的事件，重新连接到主线程，等等。有关可能状态的列表，请参阅8.14.5节“复制从I/O线程状态”。</p></li><li class="listitem"><p>
                        <code class="literal">Master_Host</code>
                    </p><p style="color:blue;">主人</p><p>
                        The master host that the slave is connected to.
                    </p><p style="color:blue;">从机连接到的主主机。</p></li><li class="listitem"><p>
                        <code class="literal">Master_User</code>
                    </p><p style="color:blue;">主用户</p><p>
                        The user name of the account used to connect to the master.
                    </p><p style="color:blue;">用于连接到主机的帐户的用户名。</p></li><li class="listitem"><p>
                        <code class="literal">Master_Port</code>
                    </p><p style="color:blue;">主端口</p><p>
                        The port used to connect to the master.
                    </p><p style="color:blue;">用于连接到主机的端口。</p></li><li class="listitem"><p>
                        <code class="literal">Connect_Retry</code>
                    </p><p style="color:blue;">连接重试</p><p>
                        The number of seconds between connect retries (default 60).
                        This can be set with the <a class="link" href="sql-syntax.html#change-master-to" title="13.4.2.1&nbsp;CHANGE MASTER TO Syntax"><code class="literal">CHANGE MASTER
                        TO</code></a> statement.
                    </p><p style="color:blue;">连接重试之间的秒数（默认为60）。这可以用change master to语句设置。</p></li><li class="listitem"><p>
                        <code class="literal">Master_Log_File</code>
                    </p><p style="color:blue;">主日志文件</p><p>
                        The name of the master binary log file from which the I/O
                        thread is currently reading.
                    </p><p style="color:blue;">I/O线程当前从中读取的主二进制日志文件的名称。</p></li><li class="listitem"><p>
                        <code class="literal">Read_Master_Log_Pos</code>
                    </p><p style="color:blue;">读取主机日志位置</p><p>
                        The position in the current master binary log file up to
                        which the I/O thread has read.
                    </p><p style="color:blue;">当前主二进制日志文件中I/O线程已读取的位置。</p></li><li class="listitem"><p>
                        <code class="literal">Relay_Log_File</code>
                    </p><p style="color:blue;">中继日志文件</p><p>
                        The name of the relay log file from which the SQL thread is
                        currently reading and executing.
                    </p><p style="color:blue;">SQL线程当前正在从中读取和执行的中继日志文件的名称。</p></li><li class="listitem"><p>
                        <code class="literal">Relay_Log_Pos</code>
                    </p><p style="color:blue;">继电器日志位置</p><p>
                        The position in the current relay log file up to which the
                        SQL thread has read and executed.
                    </p><p style="color:blue;">当前中继日志文件中SQL线程已读取并执行的位置。</p></li><li class="listitem"><p>
                        <code class="literal">Relay_Master_Log_File</code>
                    </p><p style="color:blue;">中继主机日志文件</p><p>
                        The name of the master binary log file containing the most
                        recent event executed by the SQL thread.
                    </p><p style="color:blue;">包含SQL线程执行的最新事件的主二进制日志文件的名称。</p></li><li class="listitem"><p>
                        <code class="literal">Slave_IO_Running</code>
                    </p><p style="color:blue;">从IO运行</p><p>
                        Whether the I/O thread is started and has connected
                        successfully to the master. Internally, the state of this
                        thread is represented by one of the following three values:
                    </p><p style="color:blue;">I/O线程是否已启动并已成功连接到主机。在内部，此线程的状态由以下三个值之一表示：</p>
                        <div class="itemizedlist">
                            <ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p><b>MYSQL_SLAVE_NOT_RUN.&nbsp;</b>
                                The slave I/O thread is not running. For this state,
                                <code class="literal">Slave_IO_Running</code> is
                                <code class="literal">No</code>.
                            </p><p style="color:blue;">mysql_slave_不运行。从I/O线程未运行。对于此状态，slave_io_running为否。</p></li><li class="listitem"><p><b>MYSQL_SLAVE_RUN_NOT_CONNECT.&nbsp;</b>
                                The slave I/O thread is running, but is not connected
                                to a replication master. For this state,
                                <code class="literal">Slave_IO_Running</code> is
                                <code class="literal">Connecting</code>.
                            </p><p style="color:blue;">mysql_slave_run_not_connect.从I/O线程正在运行，但未连接到复制主线程。对于此状态，正在运行的从设备正在连接。</p></li><li class="listitem"><p><b>MYSQL_SLAVE_RUN_CONNECT.&nbsp;</b>
                                The slave I/O thread is running, and is connected to a
                                replication master. For this state,
                                <code class="literal">Slave_IO_Running</code> is
                                <code class="literal">Yes</code>.
                            </p><p style="color:blue;">mysql_slave_run_connect.从I/O线程正在运行，并连接到复制主线程。对于此状态，slave_io_running为yes。</p></li></ul>
                        </div>
                        <p>
                            The value of the
                            <a class="link" href="server-administration.html#statvar_Slave_running"><code class="literal">Slave_running</code></a> system
                            status variable corresponds with this value.
                        </p><p style="color:blue;">slave_running系统状态变量的值与此值对应。</p></li><li class="listitem"><p>
                        <code class="literal">Slave_SQL_Running</code>
                    </p><p style="color:blue;">从SQL运行</p><p>
                        Whether the SQL thread is started.
                    </p><p style="color:blue;">是否启动SQL线程。</p></li><li class="listitem"><p>
                        <code class="literal">Replicate_Do_DB</code>,
                        <code class="literal">Replicate_Ignore_DB</code>
                    </p><p style="color:blue;">复制数据库，复制忽略数据库</p><p>
                        The lists of databases that were specified with the
                        <a class="link" href="replication.html#option_mysqld_replicate-do-db"><code class="option">--replicate-do-db</code></a> and
                        <a class="link" href="replication.html#option_mysqld_replicate-ignore-db"><code class="option">--replicate-ignore-db</code></a>
                        options, if any.
                    </p><p style="color:blue;">使用--replicate do db和--replicate ignore db选项（如果有）指定的数据库列表。</p></li><li class="listitem"><p>
                        <code class="literal">Replicate_Do_Table</code>,
                        <code class="literal">Replicate_Ignore_Table</code>,
                        <code class="literal">Replicate_Wild_Do_Table</code>,
                        <code class="literal">Replicate_Wild_Ignore_Table</code>
                    </p><p style="color:blue;">复制表，复制忽略表，复制野生表，复制忽略表</p><p>
                        The lists of tables that were specified with the
                        <a class="link" href="replication.html#option_mysqld_replicate-do-table"><code class="option">--replicate-do-table</code></a>,
                        <a class="link" href="replication.html#option_mysqld_replicate-ignore-table"><code class="option">--replicate-ignore-table</code></a>,
                        <a class="link" href="replication.html#option_mysqld_replicate-wild-do-table"><code class="option">--replicate-wild-do-table</code></a>,
                        and
                        <a class="link" href="replication.html#option_mysqld_replicate-wild-ignore-table"><code class="option">--replicate-wild-ignore-table</code></a>
                        options, if any.
                    </p><p style="color:blue;">使用--replicate do table、--replicate ignore table、--replicate wild do table和--replicate wild ignore table选项（如果有）指定的表列表。</p></li><li class="listitem"><p>
                        <code class="literal">Last_Errno</code>, <code class="literal">Last_Error</code>
                    </p><p style="color:blue;">最后一个错误，最后一个错误</p><p>
                        These columns are aliases for
                        <code class="literal">Last_SQL_Errno</code> and
                        <code class="literal">Last_SQL_Error</code>.
                    </p><p style="color:blue;">这些列是last_sql_errno和last_sql_error的别名。</p><p>
                        Issuing <a class="link" href="sql-syntax.html#reset-master" title="13.4.1.2&nbsp;RESET MASTER Syntax"><code class="literal">RESET MASTER</code></a> or
                        <a class="link" href="sql-syntax.html#reset-slave" title="13.4.2.4&nbsp;RESET SLAVE Syntax"><code class="literal">RESET SLAVE</code></a> resets the values
                        shown in these columns.
                    </p><p style="color:blue;">发出reset master或reset slave将重置这些列中显示的值。</p>
                        <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">

                            <div class="admon-title">
                                Note
                            </div>
                            <p>
                                When the slave SQL thread receives an error, it reports
                                the error first, then stops the SQL thread. This means
                                that there is a small window of time during which
                                <a class="link" href="sql-syntax.html#show-slave-status" title="13.7.5.34&nbsp;SHOW SLAVE STATUS Syntax"><code class="literal">SHOW SLAVE STATUS</code></a> shows a
                                nonzero value for <code class="literal">Last_SQL_Errno</code> even
                                though <code class="literal">Slave_SQL_Running</code> still displays
                                <code class="literal">Yes</code>.
                            </p><p style="color:blue;">当从sql线程收到错误时，它首先报告错误，然后停止sql线程。这意味着有一个很小的时间窗口，在此期间，show slave status显示last_sql_errno的非零值，即使slave_sql_running仍然显示yes。</p>
                        </div>
                    </li><li class="listitem"><p>
                        <code class="literal">Skip_Counter</code>
                    </p><p style="color:blue;">跳过计数器</p><p>
                        The current value of the
                        <a class="link" href="replication.html#sysvar_sql_slave_skip_counter"><code class="literal">sql_slave_skip_counter</code></a>
                        system variable. See
                        <a class="xref" href="sql-syntax.html#set-global-sql-slave-skip-counter" title="13.4.2.5&nbsp;SET GLOBAL sql_slave_skip_counter Syntax">Section&nbsp;13.4.2.5, “SET GLOBAL sql_slave_skip_counter Syntax”</a>.
                    </p><p style="color:blue;">sql_slave_skip_counter系统变量的当前值。请参阅第13.4.2.5节“设置全局SQL从属跳过计数器语法”。</p></li><li class="listitem"><p>
                        <code class="literal">Exec_Master_Log_Pos</code>
                    </p><p style="color:blue;">执行主机日志位置</p><p>
                        The position in the current master binary log file to which
                        the SQL thread has read and executed, marking the start of
                        the next transaction or event to be processed. You can use
                        this value with the <a class="link" href="sql-syntax.html#change-master-to" title="13.4.2.1&nbsp;CHANGE MASTER TO Syntax"><code class="literal">CHANGE MASTER
                        TO</code></a> statement's
                        <code class="literal">MASTER_LOG_POS</code> option when starting a new
                        slave from an existing slave, so that the new slave reads
                        from this point. The coordinates given by
                        (<code class="literal">Relay_Master_Log_File</code>,
                        <code class="literal">Exec_Master_Log_Pos</code>) in the master's
                        binary log correspond to the coordinates given by
                        (<code class="literal">Relay_Log_File</code>,
                        <code class="literal">Relay_Log_Pos</code>) in the relay log.
                    </p><p style="color:blue;">当前主二进制日志文件中SQL线程已读取并执行的位置，标记要处理的下一个事务或事件的开始。当从一个已有的奴隶启动一个新的奴隶时，您可以使用该变量的值来更改语句的选项，以便新的奴隶从这一点读取。主机二进制日志中由（relay_master_log_file，exec_master_log_pos）给出的坐标对应于中继日志中由（relay_log_file，relay_log_pos）给出的坐标。</p><p>
                        Inconsistencies in the sequence of transactions from the
                        relay log which have been executed can cause this value to
                        be a <span class="quote">“<span class="quote">low-water mark</span>”</span>. In other words,
                        transactions appearing before the position are guaranteed to
                        have committed, but transactions after the position may have
                        committed or not. If these gaps need to be corrected, use
                        <a class="link" href="sql-syntax.html#start-slave" title="13.4.2.6&nbsp;START SLAVE Syntax"><code class="literal">START SLAVE
                            UNTIL SQL_AFTER_MTS_GAPS</code></a>. See
                        <a class="xref" href="replication.html#replication-features-transaction-inconsistencies" title="16.4.1.32&nbsp;Replication and Transaction Inconsistencies">Section&nbsp;16.4.1.32, “Replication and Transaction Inconsistencies”</a>
                        for more information.
                    </p><p style="color:blue;">已执行的中继日志中的事务序列不一致可能导致此值为“低水位线”。换言之，在头寸之前出现的交易被保证已提交，但头寸之后的交易可能已提交或未提交。如果需要更正这些间隙，请使用start slave直到sql_after_mts_间隙。有关更多信息，请参阅第16.4.1.32节“复制和事务不一致”。</p></li><li class="listitem"><p>
                        <code class="literal">Relay_Log_Space</code>
                    </p><p style="color:blue;">中继日志空间</p><p>
                        The total combined size of all existing relay log files.
                    </p><p style="color:blue;">所有现有中继日志文件的总组合大小。</p></li><li class="listitem"><p>
                        <code class="literal">Until_Condition</code>,
                        <code class="literal">Until_Log_File</code>,
                        <code class="literal">Until_Log_Pos</code>
                    </p><p style="color:blue;">直到条件，直到日志文件，直到日志位置</p><p>
                        The values specified in the <code class="literal">UNTIL</code> clause
                        of the <a class="link" href="sql-syntax.html#start-slave" title="13.4.2.6&nbsp;START SLAVE Syntax"><code class="literal">START SLAVE</code></a> statement.
                    </p><p style="color:blue;">在start slave语句的until子句中指定的值。</p><p>
                        <code class="literal">Until_Condition</code> has these values:
                    </p><p style="color:blue;">直到条件具有这些值：</p>
                        <div class="itemizedlist">
                            <ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
                                <code class="literal">None</code> if no <code class="literal">UNTIL</code>
                                clause was specified
                            </p><p style="color:blue;">如果指定了no-until子句，则为none</p></li><li class="listitem"><p>
                                <code class="literal">Master</code> if the slave is reading until
                                a given position in the master's binary log
                            </p><p style="color:blue;">如果从机读取到主机二进制日志中的给定位置</p></li><li class="listitem"><p>
                                <code class="literal">Relay</code> if the slave is reading until a
                                given position in its relay log
                            </p><p style="color:blue;">如果从机读取数据直到其继电器日志中的给定位置</p></li><li class="listitem"><p>
                                <code class="literal">SQL_BEFORE_GTIDS</code> if the slave SQL
                                thread is processing transactions until it has reached
                                the first transaction whose GTID is listed in the
                                <code class="literal">gtid_set</code>.
                            </p><p style="color:blue;">如果从属SQL线程正在处理事务，直到到达GTID列在GTID集合中的第一个事务。</p></li><li class="listitem"><p>
                                <code class="literal">SQL_AFTER_GTIDS</code> if the slave threads
                                are processing all transactions until the last
                                transaction in the <code class="literal">gtid_set</code> has been
                                processed by both threads.
                            </p><p style="color:blue;">如果从线程正在处理所有事务，直到gtid集中的最后一个事务被两个线程处理完为止，则为sql_after_gtid。</p></li><li class="listitem"><p>
                                <a class="link" href="sql-syntax.html#start-slave" title="13.4.2.6&nbsp;START SLAVE Syntax"><code class="literal">SQL_AFTER_MTS_GAPS</code></a>
                                if a multithreaded slave's SQL threads are running until
                                no more gaps are found in the relay log.
                            </p><p style="color:blue;">如果多线程从机的SQL线程正在运行，直到在中继日志中找不到更多的间隔，则返回一个接一个的SQL间隔。</p></li></ul>
                        </div>
                        <p>
                            <code class="literal">Until_Log_File</code> and
                            <code class="literal">Until_Log_Pos</code> indicate the log file name
                            and position that define the coordinates at which the SQL
                            thread stops executing.
                        </p><p style="color:blue;">until_log_file和until_log_pos指示定义SQL线程停止执行的坐标的日志文件名和位置。</p><p>
                            For more information on <code class="literal">UNTIL</code> clauses,
                            see <a class="xref" href="sql-syntax.html#start-slave" title="13.4.2.6&nbsp;START SLAVE Syntax">Section&nbsp;13.4.2.6, “START SLAVE Syntax”</a>.
                        </p><p style="color:blue;">有关until子句的更多信息，请参见第13.4.2.6节“start slave syntax”。</p></li><li class="listitem"><p>
                        <code class="literal">Master_SSL_Allowed</code>,
                        <code class="literal">Master_SSL_CA_File</code>,
                        <code class="literal">Master_SSL_CA_Path</code>,
                        <code class="literal">Master_SSL_Cert</code>,
                        <code class="literal">Master_SSL_Cipher</code>,
                        <code class="literal">Master_SSL_CRL_File</code>,
                        <code class="literal">Master_SSL_CRL_Path</code>,
                        <code class="literal">Master_SSL_Key</code>,
                        <code class="literal">Master_SSL_Verify_Server_Cert</code>
                    </p><p style="color:blue;">允许Master_ssl_，Master_ssl_ca_文件，Master_ssl_ca_路径，Master_ssl_证书，Master_ssl_密码，Master_ssl_crl_文件，Master_ssl_crl_路径，Master_ssl_密钥，Master_ssl_验证服务器_证书</p><p>
                        These fields show the SSL parameters used by the slave to
                        connect to the master, if any.
                    </p><p style="color:blue;">这些字段显示从属服务器连接到主服务器（如果有的话）所使用的ssl参数。</p><p>
                        <code class="literal">Master_SSL_Allowed</code> has these values:
                    </p><p style="color:blue;">允许的master_ssl_具有以下值：</p>
                        <div class="itemizedlist">
                            <ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
                                <code class="literal">Yes</code> if an SSL connection to the
                                master is permitted
                            </p><p style="color:blue;">如果允许到主服务器的ssl连接，则为yes</p></li><li class="listitem"><p>
                                <code class="literal">No</code> if an SSL connection to the master
                                is not permitted
                            </p><p style="color:blue;">如果不允许到主服务器的ssl连接，则为否</p></li><li class="listitem"><p>
                                <code class="literal">Ignored</code> if an SSL connection is
                                permitted but the slave server does not have SSL support
                                enabled
                            </p><p style="color:blue;">如果允许SSL连接但从属服务器未启用SSL支持，则忽略</p></li></ul>
                        </div>
                        <p>
                            The values of the other SSL-related fields correspond to the
                            values of the <code class="literal">MASTER_SSL_CA</code>,
                            <code class="literal">MASTER_SSL_CAPATH</code>,
                            <code class="literal">MASTER_SSL_CERT</code>,
                            <code class="literal">MASTER_SSL_CIPHER</code>,
                            <code class="literal">MASTER_SSL_CRL</code>,
                            <code class="literal">MASTER_SSL_CRLPATH</code>,
                            <code class="literal">MASTER_SSL_KEY</code>, and
                            <code class="literal">MASTER_SSL_VERIFY_SERVER_CERT</code> options to
                            the <a class="link" href="sql-syntax.html#change-master-to" title="13.4.2.1&nbsp;CHANGE MASTER TO Syntax"><code class="literal">CHANGE MASTER TO</code></a>
                            statement. See <a class="xref" href="sql-syntax.html#change-master-to" title="13.4.2.1&nbsp;CHANGE MASTER TO Syntax">Section&nbsp;13.4.2.1, “CHANGE MASTER TO Syntax”</a>.
                        </p><p style="color:blue;">其他与ssl相关的字段的值对应于将master-to语句更改为master-ca、master-ssl-capath、master-ssl-cert、master-ssl-cipher、master-ssl-crl、master-ssl-crlpath、master-ssl-key和master-ssl-verify-server-cert选项的值。见13.4.2.1节，“将master更改为syntax”。</p></li><li class="listitem"><p>
                        <code class="literal">Seconds_Behind_Master</code>
                    </p><p style="color:blue;">秒数落后大师</p><p>
                        This field is an indication of how <span class="quote">“<span class="quote">late</span>”</span> the
                        slave is:
                    </p><p style="color:blue;">此字段指示从设备的“延迟”程度：</p>
                        <div class="itemizedlist">
                            <ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
                                When the slave is actively processing updates, this
                                field shows the difference between the current timestamp
                                on the slave and the original timestamp logged on the
                                master for the event currently being processed on the
                                slave.
                            </p><p style="color:blue;">当从机正在积极处理更新时，此字段显示从机上当前时间戳与主机上为从机上当前处理的事件记录的原始时间戳之间的差异。</p></li><li class="listitem"><p>
                                When no event is currently being processed on the slave,
                                this value is 0.
                            </p><p style="color:blue;">当从机上当前未处理任何事件时，此值为0。</p></li></ul>
                        </div>
                        <p>
                            In essence, this field measures the time difference in
                            seconds between the slave SQL thread and the slave I/O
                            thread. If the network connection between master and slave
                            is fast, the slave I/O thread is very close to the master,
                            so this field is a good approximation of how late the slave
                            SQL thread is compared to the master. If the network is
                            slow, this is <span class="emphasis"><em>not</em></span> a good approximation;
                            the slave SQL thread may quite often be caught up with the
                            slow-reading slave I/O thread, so
                            <code class="literal">Seconds_Behind_Master</code> often shows a value
                            of 0, even if the I/O thread is late compared to the master.
                            In other words, <span class="emphasis"><em>this column is useful only for
            fast networks</em></span>.
                        </p><p style="color:blue;">实际上，此字段测量从SQL线程和从I/O线程之间的时间差（秒）。如果主从之间的网络连接速度很快，从属I/O线程与主机非常接近，因此该字段是从属SQL线程与主机相比有多晚的一个很好的近似。如果网络是慢的，这不是一个好的近似；从属SQL线程可能经常赶上慢读奴隶I/O线程，所以SuthsSyBeNekHub常常显示值为0，即使I/O线程与主机相比较晚。换句话说，本专栏仅对快速网络有用。</p><p>
                            This time difference computation works even if the master
                            and slave do not have identical clock times, provided that
                            the difference, computed when the slave I/O thread starts,
                            remains constant from then on. Any changes—including
                            NTP updates—can lead to clock skews that can make
                            calculation of <code class="literal">Seconds_Behind_Master</code> less
                            reliable.
                        </p><p style="color:blue;">即使主线程和从线程没有相同的时钟时间，这种时差计算仍然有效，前提是从线程启动时计算的时差从那时起保持不变。包括ntp更新在内的任何更改都可能导致时钟偏移，这可能会降低主机后秒数的计算可靠性。</p><p>
                            In MySQL 5.7, this field is
                            <code class="literal">NULL</code> (undefined or unknown) if the slave
                            SQL thread is not running, or if the SQL thread has consumed
                            all of the relay log and the slave I/O thread is not
                            running. (In older versions of MySQL, this field was
                            <code class="literal">NULL</code> if the slave SQL thread or the slave
                            I/O thread was not running or was not connected to the
                            master.) If the I/O thread is running but the relay log is
                            exhausted, <code class="literal">Seconds_Behind_Master</code> is set
                            to 0.
                        </p><p style="color:blue;">在mysql 5.7中，如果从sql线程没有运行，或者sql线程已经消耗了所有的中继日志，而从i/o线程没有运行，则该字段为空（未定义或未知）。（在较旧版本的MySQL中，如果从SQL线程或从I/O线程未运行或未连接到主线程，则此字段为空。）如果I/O线程正在运行，但中继日志已用尽，则主线程后面的秒数设置为0。</p><p>
                            The value of <code class="literal">Seconds_Behind_Master</code> is
                            based on the timestamps stored in events, which are
                            preserved through replication. This means that if a master
                            M1 is itself a slave of M0, any event from M1's binary log
                            that originates from M0's binary log has M0's timestamp for
                            that event. This enables MySQL to replicate
                            <a class="link" href="data-types.html#datetime" title="11.3.1&nbsp;The DATE, DATETIME, and TIMESTAMP Types"><code class="literal">TIMESTAMP</code></a> successfully.
                            However, the problem for
                            <code class="literal">Seconds_Behind_Master</code> is that if M1 also
                            receives direct updates from clients, the
                            <code class="literal">Seconds_Behind_Master</code> value randomly
                            fluctuates because sometimes the last event from M1
                            originates from M0 and sometimes is the result of a direct
                            update on M1.
                        </p><p style="color:blue;">seconds_behind_master的值基于存储在事件中的时间戳，这些时间戳通过复制保存。这意味着，如果主m1本身是m0的从机，则来自m1的二进制日志的任何事件（源自m0的二进制日志）都具有该事件的m0的时间戳。这使得mysql能够成功地复制时间戳。然而，seconds_behind_master的问题是，如果m1也从客户机接收到直接更新，seconds_behind_master值随机波动，因为有时m1的最后一个事件来自m0，有时是m1直接更新的结果。</p><p>
                            When using a multithreaded slave, you should keep in mind
                            that this value is based on
                            <code class="literal">Exec_Master_Log_Pos</code>, and so may not
                            reflect the position of the most recently committed
                            transaction.
                        </p><p style="color:blue;">使用多线程从机时，应记住此值基于exec_master_log_pos，因此可能不会反映最近提交的事务的位置。</p></li><li class="listitem"><p>
                        <code class="literal">Last_IO_Errno</code>,
                        <code class="literal">Last_IO_Error</code>
                    </p><p style="color:blue;">最后一个错误，最后一个错误</p><p>
                        The error number and error message of the most recent error
                        that caused the I/O thread to stop. An error number of 0 and
                        message of the empty string mean <span class="quote">“<span class="quote">no error.</span>”</span> If
                        the <code class="literal">Last_IO_Error</code> value is not empty, the
                        error values also appear in the slave's error log.
                    </p><p style="color:blue;">导致I/O线程停止的最新错误的错误号和错误消息。0的错误号和空字符串的消息表示“无错误”。如果最后一个错误值不是空的，则错误值也会显示在从属错误日志中。</p><p>
                        I/O error information includes a timestamp showing when the
                        most recent I/O thread error occurred. This timestamp uses
                        the format <em class="replaceable"><code>YYMMDD hh:mm:ss</code></em>, and
                        appears in the <code class="literal">Last_IO_Error_Timestamp</code>
                        column.
                    </p><p style="color:blue;">I/O错误信息包括显示最近I/O线程错误发生时间的时间戳。此时间戳使用yymmdd hh:mm:ss格式，并显示在最后一个“IO”错误“时间戳”列中。</p><p>
                        Issuing <a class="link" href="sql-syntax.html#reset-master" title="13.4.1.2&nbsp;RESET MASTER Syntax"><code class="literal">RESET MASTER</code></a> or
                        <a class="link" href="sql-syntax.html#reset-slave" title="13.4.2.4&nbsp;RESET SLAVE Syntax"><code class="literal">RESET SLAVE</code></a> resets the values
                        shown in these columns.
                    </p><p style="color:blue;">发出reset master或reset slave将重置这些列中显示的值。</p></li><li class="listitem"><p>
                        <code class="literal">Last_SQL_Errno</code>,
                        <code class="literal">Last_SQL_Error</code>
                    </p><p style="color:blue;">最后一个SQL错误，最后一个SQL错误</p><p>
                        The error number and error message of the most recent error
                        that caused the SQL thread to stop. An error number of 0 and
                        message of the empty string mean <span class="quote">“<span class="quote">no error.</span>”</span> If
                        the <code class="literal">Last_SQL_Error</code> value is not empty,
                        the error values also appear in the slave's error log.
                    </p><p style="color:blue;">导致SQL线程停止的最新错误的错误号和错误消息。错误号0和空字符串的消息表示“无错误”。如果最后一个SQL错误值不是空的，则错误值也会显示在从属错误日志中。</p><p>
                        If the slave is multithreaded, the SQL thread is the
                        coordinator for worker threads. In this case, the
                        <code class="literal">Last_SQL_Error</code> field shows exactly what
                        the <code class="literal">Last_Error_Message</code> column in the
                        Performance Schema
                        <a class="link" href="performance-schema.html#replication-applier-status-by-coordinator-table" title="25.12.11.5&nbsp;The replication_applier_status_by_coordinator Table"><code class="literal">replication_applier_status_by_coordinator</code></a>
                        table shows. The field value is modified to suggest that
                        there may be more failures in the other worker threads which
                        can be seen in the
                        <a class="link" href="performance-schema.html#replication-applier-status-by-worker-table" title="25.12.11.6&nbsp;The replication_applier_status_by_worker Table"><code class="literal">replication_applier_status_by_worker</code></a>
                        table that shows each worker thread's status. If that table
                        is not available, the slave error log can be used. The log
                        or the
                        <a class="link" href="performance-schema.html#replication-applier-status-by-worker-table" title="25.12.11.6&nbsp;The replication_applier_status_by_worker Table"><code class="literal">replication_applier_status_by_worker</code></a>
                        table should also be used to learn more about the failure
                        shown by <a class="link" href="sql-syntax.html#show-slave-status" title="13.7.5.34&nbsp;SHOW SLAVE STATUS Syntax"><code class="literal">SHOW SLAVE STATUS</code></a> or
                        the coordinator table.
                    </p><p style="color:blue;">如果从线程是多线程的，则sql线程是工作线程的协调器。在本例中，last_sql_error字段精确显示了performance schema replication_applier_status_by_coordinator表中的last_error_消息列。该字段值被修改为表示其他工作线程中可能有更多故障，这些故障可以在显示每个工作线程状态的replication_applier_status_by_worker表中看到。如果该表不可用，则可以使用从属错误日志。还应使用日志或replication_applier_status_by_worker表了解有关show slave status或coordinator表显示的故障的更多信息。</p><p>
                        SQL error information includes a timestamp showing when the
                        most recent SQL thread error occurred. This timestamp uses
                        the format <em class="replaceable"><code>YYMMDD hh:mm:ss</code></em>, and
                        appears in the <code class="literal">Last_SQL_Error_Timestamp</code>
                        column.
                    </p><p style="color:blue;">SQL错误信息包括一个时间戳，显示最近发生的SQL线程错误的时间。此时间戳使用yymmdd hh:mm:ss格式，并显示在最后一个SQL错误时间戳列中。</p><p>
                        Issuing <a class="link" href="sql-syntax.html#reset-master" title="13.4.1.2&nbsp;RESET MASTER Syntax"><code class="literal">RESET MASTER</code></a> or
                        <a class="link" href="sql-syntax.html#reset-slave" title="13.4.2.4&nbsp;RESET SLAVE Syntax"><code class="literal">RESET SLAVE</code></a> resets the values
                        shown in these columns.
                    </p><p style="color:blue;">发出reset master或reset slave将重置这些列中显示的值。</p><p>
                        In MySQL 5.7, all error codes and messages
                        displayed in the <code class="literal">Last_SQL_Errno</code> and
                        <code class="literal">Last_SQL_Error</code> columns correspond to
                        error values listed in
                        <a class="xref" href="error-handling.html#server-error-reference" title="B.3.1&nbsp;Server Error Message Reference">Section&nbsp;B.3.1, “Server Error Message Reference”</a>. This was not
                        always true in previous versions. (Bug #11760365, Bug
                        #52768)
                    </p><p style="color:blue;">在mysql 5.7中，last_sql_errno和last_sql_error列中显示的所有错误代码和消息都对应于“服务器错误消息引用”一节中列出的错误值。以前的版本并不总是这样。（错误11760365，错误52768）</p></li><li class="listitem"><p>
                        <code class="literal">Replicate_Ignore_Server_Ids</code>
                    </p><p style="color:blue;">复制忽略服务器ID</p><p>
                        In MySQL 5.7, you set a slave to ignore events
                        from 0 or more masters using the
                        <code class="literal">IGNORE_SERVER_IDS</code> option of the
                        <a class="link" href="sql-syntax.html#change-master-to" title="13.4.2.1&nbsp;CHANGE MASTER TO Syntax"><code class="literal">CHANGE MASTER TO</code></a> statement.
                        By default this is blank, and is usually modified only when
                        using a circular or other multi-master replication setup.
                        The message shown for
                        <code class="literal">Replicate_Ignore_Server_Ids</code> when not
                        blank consists of a comma-delimited list of one or more
                        numbers, indicating the server IDs to be ignored. For
                        example:
                    </p><p style="color:blue;">在mysql 5.7中，使用change master to语句的ignore_server_ids选项将从服务器设置为忽略来自0个或更多主服务器的事件。默认情况下，此值为空，通常仅在使用循环或其他多主复制设置时才进行修改。当不为空时，显示的用于replicate_ignore_server_ids的消息由一个或多个数字的逗号分隔列表组成，指示要忽略的服务器id。例如：</p><pre data-lang="none" class="programlisting">	Replicate_Ignore_Server_Ids: 2, 6, 9
</pre>
                        <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">

                            <div class="admon-title">
                                Note
                            </div>
                            <p>
                                <code class="literal">Ignored_server_ids</code> also shows the
                                server IDs to be ignored, but is a space-delimited list,
                                which is preceded by the total number of server IDs to be
                                ignored. For example, if a <a class="link" href="sql-syntax.html#change-master-to" title="13.4.2.1&nbsp;CHANGE MASTER TO Syntax"><code class="literal">CHANGE
                                MASTER TO</code></a> statement containing the
                                <code class="literal">IGNORE_SERVER_IDS = (2,6,9)</code> option has
                                been issued to tell a slave to ignore masters having the
                                server ID 2, 6, or 9, that information appears as shown
                                here:
                            </p><p style="color:blue;">忽略的服务器标识还显示要忽略的服务器标识，但它是一个空格分隔的列表，前面是要忽略的服务器标识总数。例如，如果发出包含ignore_server_ids=（2,6,9）选项的change master to语句，告诉从服务器忽略服务器id为2、6或9的主服务器，则该信息将显示如下：</p><pre data-lang="none" class="programlisting">	Ignored_server_ids: 3, 2, 6, 9
</pre><p>
                            The first number (in this case <code class="literal">3</code>) shows
                            the number of server IDs being ignored.
                        </p><p style="color:blue;">第一个数字（在本例中是3）显示被忽略的服务器id的数量。</p>
                        </div>
                        <p>
                            <code class="literal">Replicate_Ignore_Server_Ids</code> filtering is
                            performed by the I/O thread, rather than by the SQL thread,
                            which means that events which are filtered out are not
                            written to the relay log. This differs from the filtering
                            actions taken by server options such
                            <a class="link" href="replication.html#option_mysqld_replicate-do-table"><code class="option">--replicate-do-table</code></a>, which
                            apply to the SQL thread.
                        </p><p style="color:blue;">replicate_ignore_server_ids筛选由I/O线程执行，而不是由SQL线程执行，这意味着筛选出的事件不会写入中继日志。这不同于服务器选项（例如，replicate do table）执行的筛选操作，后者适用于sql线程。</p></li><li class="listitem"><p>
                        <code class="literal">Master_Server_Id</code>
                    </p><p style="color:blue;">主服务器ID</p><p>
                        The <a class="link" href="server-administration.html#sysvar_server_id"><code class="literal">server_id</code></a> value from
                        the master.
                    </p><p style="color:blue;">来自主服务器的服务器ID值。</p></li><li class="listitem"><p>
                        <code class="literal">Master_UUID</code>
                    </p><p style="color:blue;">大师</p><p>
                        The <a class="link" href="replication.html#sysvar_server_uuid"><code class="literal">server_uuid</code></a> value from
                        the master.
                    </p><p style="color:blue;">来自主服务器的服务器ID值。</p></li><li class="listitem"><p>
                        <code class="literal">Master_Info_File</code>
                    </p><p style="color:blue;">主信息文件</p><p>
                        The location of the <code class="filename">master.info</code> file.
                    </p><p style="color:blue;">master.info文件的位置。</p></li><li class="listitem"><p>
                        <code class="literal">SQL_Delay</code>
                    </p><p style="color:blue;">SQL延迟</p><p>
                        The number of seconds that the slave must lag the master.
                    </p><p style="color:blue;">从机必须滞后于主机的秒数。</p></li><li class="listitem"><p>
                        <code class="literal">SQL_Remaining_Delay</code>
                    </p><p style="color:blue;">SQL剩余延迟</p><p>
                        When <code class="literal">Slave_SQL_Running_State</code> is
                        <code class="literal">Waiting until MASTER_DELAY seconds after master
                            executed event</code>, this field contains the number of
                        delay seconds remaining. At other times, this field is
                        <code class="literal">NULL</code>.
                    </p><p style="color:blue;">当slave_sql_running_state在主执行事件后等待主延迟秒数时，此字段包含剩余的延迟秒数。其他时候，此字段为空。</p></li><li class="listitem"><p>
                        <code class="literal">Slave_SQL_Running_State</code>
                    </p><p style="color:blue;">从SQL运行状态</p><p>
                        The state of the SQL thread (analogous to
                        <code class="literal">Slave_IO_State</code>). The value is identical
                        to the <code class="literal">State</code> value of the SQL thread as
                        displayed by <a class="link" href="sql-syntax.html#show-processlist" title="13.7.5.29&nbsp;SHOW PROCESSLIST Syntax"><code class="literal">SHOW
                        PROCESSLIST</code></a>.
                        <a class="xref" href="optimization.html#slave-sql-thread-states" title="8.14.6&nbsp;Replication Slave SQL Thread States">Section&nbsp;8.14.6, “Replication Slave SQL Thread States”</a>, provides a
                        listing of possible states
                    </p><p style="color:blue;">SQL线程的状态（类似于从属状态）。该值与show processlist显示的sql线程的状态值相同。第8.14.6节“复制从SQL线程状态”提供了可能的状态列表</p></li><li class="listitem"><p>
                        <code class="literal">Master_Retry_Count</code>
                    </p><p style="color:blue;">主机重试次数</p><p>
                        The number of times the slave can attempt to reconnect to
                        the master in the event of a lost connection. This value can
                        be set using the <code class="literal">MASTER_RETRY_COUNT</code>
                        option of the <a class="link" href="sql-syntax.html#change-master-to" title="13.4.2.1&nbsp;CHANGE MASTER TO Syntax"><code class="literal">CHANGE MASTER
                        TO</code></a> statement (preferred) or the older
                        <a class="link" href="replication.html#option_mysqld_master-retry-count"><code class="option">--master-retry-count</code></a> server
                        option (still supported for backward compatibility).
                    </p><p style="color:blue;">在连接断开的情况下，从机可以尝试重新连接到主机的次数。可以使用change master to语句的master\u retry\u count选项（首选）或较旧的--master retry count server选项（仍支持向后兼容）设置此值。</p></li><li class="listitem"><p>
                        <code class="literal">Master_Bind</code>
                    </p><p style="color:blue;">大师绑定</p><p>
                        The network interface that the slave is bound to, if any.
                        This is set using the <code class="literal">MASTER_BIND</code> option
                        for the <a class="link" href="sql-syntax.html#change-master-to" title="13.4.2.1&nbsp;CHANGE MASTER TO Syntax"><code class="literal">CHANGE MASTER TO</code></a>
                        statement.
                    </p><p style="color:blue;">从机绑定到的网络接口（如果有）。这是使用change master to语句的master_bind选项设置的。</p></li><li class="listitem"><p>
                        <code class="literal">Last_IO_Error_Timestamp</code>
                    </p><p style="color:blue;">上次IO错误时间戳</p><p>
                        A timestamp in <em class="replaceable"><code>YYMMDD hh:mm:ss</code></em>
                        format that shows when the most recent I/O error took place.
                    </p><p style="color:blue;">以yymmdd hh:mm:ss格式显示最近一次I/O错误发生时间的时间戳。</p></li><li class="listitem"><p>
                        <code class="literal">Last_SQL_Error_Timestamp</code>
                    </p><p style="color:blue;">上一个SQL错误时间戳</p><p>
                        A timestamp in <em class="replaceable"><code>YYMMDD hh:mm:ss</code></em>
                        format that shows when the most recent SQL error occurred.
                    </p><p style="color:blue;">以yymmdd hh:mm:ss格式显示最近一次SQL错误发生时间的时间戳。</p></li><li class="listitem"><p>
                        <code class="literal">Retrieved_Gtid_Set</code>
                    </p><p style="color:blue;">检索集</p><p>
                        The set of global transaction IDs corresponding to all
                        transactions received by this slave. Empty if GTIDs are not
                        in use. See
                        <a class="xref" href="replication.html#replication-gtids-concepts-gtid-sets" title="GTID Sets">GTID Sets</a> for
                        more information.
                    </p><p style="color:blue;">对应于此从机接收的所有事务的全局事务ID集。如果没有使用gtid，则为空。有关详细信息，请参见gtid集合。</p><p>
                        This is the set of all GTIDs that exist or have existed in
                        the relay logs. Each GTID is added as soon as the
                        <code class="literal">Gtid_log_event</code> is received. This can
                        cause partially transmitted transactions to have their GTIDs
                        included in the set.
                    </p><p style="color:blue;">这是存在于或存在于中继日志中的所有GTIDS的集合。一旦收到gtid_log_事件，就会添加每个gtid。这可能会导致部分传输的事务的gtid包含在集合中。</p><p>
                        When all relay logs are lost due to executing
                        <a class="link" href="sql-syntax.html#reset-slave" title="13.4.2.4&nbsp;RESET SLAVE Syntax"><code class="literal">RESET SLAVE</code></a> or
                        <a class="link" href="sql-syntax.html#change-master-to" title="13.4.2.1&nbsp;CHANGE MASTER TO Syntax"><code class="literal">CHANGE MASTER TO</code></a>, or due to
                        the effects of the
                        <a class="link" href="replication.html#option_mysqld_relay-log-recovery"><code class="option">--relay-log-recovery</code></a> option,
                        the set is cleared. When
                        <a class="link" href="replication.html#sysvar_relay_log_purge"><code class="literal">relay_log_purge = 1</code></a>, the
                        newest relay log is always kept, and the set is not cleared.
                    </p><p style="color:blue;">当由于执行reset slave或将master更改为，或由于--relay log recovery选项的影响，所有中继日志都丢失时，将清除集合。当relay_log_purge=1时，始终保留最新的relay log，并且不清除集合。</p></li><li class="listitem"><p>
                        <code class="literal">Executed_Gtid_Set</code>
                    </p><p style="color:blue;">执行的集合</p><p>
                        The set of global transaction IDs written in the binary log.
                        This is the same as the value for the global
                        <a class="link" href="replication.html#sysvar_gtid_executed"><code class="literal">gtid_executed</code></a> system
                        variable on this server, as well as the value for
                        <code class="literal">Executed_Gtid_Set</code> in the output of
                        <a class="link" href="sql-syntax.html#show-master-status" title="13.7.5.23&nbsp;SHOW MASTER STATUS Syntax"><code class="literal">SHOW MASTER STATUS</code></a> on this
                        server. Empty if GTIDs are not in use. See
                        <a class="xref" href="replication.html#replication-gtids-concepts-gtid-sets" title="GTID Sets">GTID Sets</a> for
                        more information.
                    </p><p style="color:blue;">写入二进制日志中的全局事务ID集。这与此服务器上全局gtid_executed系统变量的值以及此服务器上show master status的输出中设置的executed_gtid_的值相同。如果没有使用gtid，则为空。有关详细信息，请参见gtid集合。</p></li><li class="listitem"><p>
                        <code class="literal">Auto_Position</code>
                    </p><p style="color:blue;">自动位置</p><p>
                        1 if autopositioning is in use; otherwise 0.
                    </p><p style="color:blue;">如果正在使用自动定位，则为1；否则为0。</p></li><li class="listitem"><p>
                        <code class="literal">Replicate_Rewrite_DB</code>
                    </p><p style="color:blue;">复制重写数据库</p><p>
                        The <code class="literal">Replicate_Rewrite_DB</code> value displays
                        any replication filtering rules that were specified. For
                        example, if the following replication filter rule was set:
                    </p><p style="color:blue;">replicate_rewrite_db值显示指定的所有复制筛选规则。例如，如果设置了以下复制筛选器规则：</p><pre data-lang="sql" class="programlisting">CHANGE REPLICATION FILTER REPLICATE_REWRITE_DB=((db1,db2), (db3,db4));</pre><p>
                        the <code class="literal">Replicate_Rewrite_DB</code> value displays:
                    </p><p style="color:blue;">replicate_rewrite_db值显示：</p><pre data-lang="none" class="programlisting">Replicate_Rewrite_DB: (db1,db2),(db3,db4)</pre><p>
                        For more information, see
                        <a class="xref" href="sql-syntax.html#change-replication-filter" title="13.4.2.2&nbsp;CHANGE REPLICATION FILTER Syntax">Section&nbsp;13.4.2.2, “CHANGE REPLICATION FILTER Syntax”</a>.
                    </p><p style="color:blue;">有关详细信息，请参阅第13.4.2.2节“更改复制筛选器语法”。</p></li><li class="listitem"><p>
                        <code class="literal">Channel_name</code>
                    </p><p style="color:blue;">频道名称</p><p>
                        The replication channel which is being displayed. There is
                        always a default replication channel, and more replication
                        channels can be added. See
                        <a class="xref" href="replication.html#replication-channels" title="16.2.3&nbsp;Replication Channels">Section&nbsp;16.2.3, “Replication Channels”</a> for more information.
                    </p><p style="color:blue;">正在显示的复制通道。总是有一个默认的复制通道，可以添加更多的复制通道。有关更多信息，请参阅第16.2.3节“复制通道”。</p></li><li class="listitem"><p>
                        <code class="literal">Master_TLS_Version</code>
                    </p><p style="color:blue;">主版本</p><p>
                        The TLS version used on the master. For TLS version
                        information, see
                        <a class="xref" href="security.html#encrypted-connection-protocols-ciphers" title="6.3.2&nbsp;Encrypted Connection TLS Protocols and Ciphers">Section&nbsp;6.3.2, “Encrypted Connection TLS Protocols and Ciphers”</a>.
                        This column was added in MySQL 5.7.10.
                    </p><p style="color:blue;">主机上使用的TLS版本。有关TLS版本信息，请参阅第6.3.2节“加密连接TLS协议和密码”。此列是在mysql 5.7.10中添加的。</p></li></ul>
                </div>

            </div>
            <div class="section">
                <div class="titlepage">
                    <div>
                        <div>
                            <h4 class="title"><a name="show-status"></a>13.7.5.35&nbsp;SHOW STATUS Syntax</h4>

                        </div>

                    </div>

                </div>
                <a class="indexterm" name="idm140286826103296"></a><a class="indexterm" name="idm140286826102224"></a><a class="indexterm" name="idm140286826101152"></a><pre data-lang="sql" class="programlisting">SHOW [GLOBAL | SESSION] STATUS
    [LIKE '<em class="replaceable"><code>pattern</code></em>' | WHERE <em class="replaceable"><code>expr</code></em>]
</pre><a class="indexterm" name="idm140286826095792"></a>
                <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">

                    <div class="admon-title">
                        Note
                    </div>
                    <p>
                        As of MySQL 5.7.6, the value of the
                        <a class="link" href="server-administration.html#sysvar_show_compatibility_56"><code class="literal">show_compatibility_56</code></a> system
                        variable affects the information available from and privileges
                        required for the statement described here. For details, see
                        the description of that variable in
                        <a class="xref" href="server-administration.html#server-system-variables" title="5.1.7&nbsp;Server System Variables">Section&nbsp;5.1.7, “Server System Variables”</a>.
                    </p><p style="color:blue;">从mysql 5.7.6开始，show_compatibility_56系统变量的值将影响此处所述语句的可用信息和所需权限。有关详细信息，请参阅第5.1.7节“服务器系统变量”中对该变量的描述。</p>
                </div>
                <p>
                    <a class="link" href="sql-syntax.html#show-status" title="13.7.5.35&nbsp;SHOW STATUS Syntax"><code class="literal">SHOW STATUS</code></a> provides server
                    status information (see
                    <a class="xref" href="server-administration.html#server-status-variables" title="5.1.9&nbsp;Server Status Variables">Section&nbsp;5.1.9, “Server Status Variables”</a>). This statement does
                    not require any privilege. It requires only the ability to
                    connect to the server.
                </p><p style="color:blue;">显示状态提供服务器状态信息（参见第5.1.9节“服务器状态变量”）。此语句不需要任何特权。它只需要连接到服务器的能力。</p><p>
                Status variable information is also available from these
                sources:
            </p><p style="color:blue;">状态变量信息也可从以下来源获得：</p>
                <div class="itemizedlist">
                    <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                        Performance Schema tables. See
                        <a class="xref" href="performance-schema.html#performance-schema-status-variable-tables" title="25.12.14&nbsp;Performance Schema Status Variable Tables">Section&nbsp;25.12.14, “Performance Schema Status Variable Tables”</a>.
                    </p><p style="color:blue;">性能架构表。见第25.12.14节“性能模式状态变量表”。</p></li><li class="listitem"><p>
                        The
                        <a class="link" href="information-schema.html#variables-table" title="24.11&nbsp;The INFORMATION_SCHEMA GLOBAL_VARIABLES and SESSION_VARIABLES Tables"><code class="literal">GLOBAL_STATUS</code></a>
                        and
                        <a class="link" href="information-schema.html#variables-table" title="24.11&nbsp;The INFORMATION_SCHEMA GLOBAL_VARIABLES and SESSION_VARIABLES Tables"><code class="literal">SESSION_STATUS</code></a>
                        tables. See <a class="xref" href="information-schema.html#status-table" title="24.10&nbsp;The INFORMATION_SCHEMA GLOBAL_STATUS and SESSION_STATUS Tables">Section&nbsp;24.10, “The INFORMATION_SCHEMA GLOBAL_STATUS and SESSION_STATUS Tables”</a>.
                    </p><p style="color:blue;">全局状态和会话状态表。参见第24.10节“信息模式全局状态和会话状态表”。</p></li><li class="listitem"><p>
                        The <a class="link" href="programs.html#mysqladmin" title="4.5.2&nbsp;mysqladmin — Client for Administering a MySQL Server"><span class="command"><strong>mysqladmin extended-status</strong></span></a> command.
                        See <a class="xref" href="programs.html#mysqladmin" title="4.5.2&nbsp;mysqladmin — Client for Administering a MySQL Server">Section&nbsp;4.5.2, “<span class="command"><strong>mysqladmin</strong></span> — Client for Administering a MySQL Server”</a>.
                    </p><p style="color:blue;">mysqladmin扩展状态命令。请参阅4.5.2节，“mysqladmin-用于管理mysql服务器的客户端”。</p></li></ul>
                </div>
                <p>
                    For <a class="link" href="sql-syntax.html#show-status" title="13.7.5.35&nbsp;SHOW STATUS Syntax"><code class="literal">SHOW STATUS</code></a>, a
                    <a class="link" href="functions.html#operator_like"><code class="literal">LIKE</code></a> clause, if present, indicates
                    which variable names to match. A <code class="literal">WHERE</code> clause
                    can be given to select rows using more general conditions, as
                    discussed in <a class="xref" href="information-schema.html#extended-show" title="24.35&nbsp;Extensions to SHOW Statements">Section&nbsp;24.35, “Extensions to SHOW Statements”</a>.
                </p><p style="color:blue;">对于show status，like子句（如果存在）指示要匹配的变量名。一个where子句可以使用更一般的条件来选择行，如24.35节“显示语句的扩展”所述。</p><p>
                <a class="link" href="sql-syntax.html#show-status" title="13.7.5.35&nbsp;SHOW STATUS Syntax"><code class="literal">SHOW STATUS</code></a> accepts an optional
                <code class="literal">GLOBAL</code> or <code class="literal">SESSION</code> variable
                scope modifier:
            </p><p style="color:blue;">show status接受可选的全局或会话变量作用域修饰符：</p>
                <div class="itemizedlist">
                    <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                        With a <code class="literal">GLOBAL</code> modifier, the statement
                        displays the global status values. A global status variable
                        may represent status for some aspect of the server itself
                        (for example, <code class="literal">Aborted_connects</code>), or the
                        aggregated status over all connections to MySQL (for
                        example, <code class="literal">Bytes_received</code> and
                        <code class="literal">Bytes_sent</code>). If a variable has no global
                        value, the session value is displayed.
                    </p><p style="color:blue;">使用全局修饰符，语句将显示全局状态值。全局状态变量可以表示服务器本身的某个方面的状态（例如，aborted_connects），也可以表示到mysql的所有连接的聚合状态（例如，bytes_received和bytes_sent）。如果变量没有全局值，则显示会话值。</p></li><li class="listitem"><p>
                        With a <code class="literal">SESSION</code> modifier, the statement
                        displays the status variable values for the current
                        connection. If a variable has no session value, the global
                        value is displayed. <code class="literal">LOCAL</code> is a synonym
                        for <code class="literal">SESSION</code>.
                    </p><p style="color:blue;">使用会话修饰符，语句显示当前连接的状态变量值。如果变量没有会话值，则显示全局值。local是session的同义词。</p></li><li class="listitem"><p>
                        If no modifier is present, the default is
                        <code class="literal">SESSION</code>.
                    </p><p style="color:blue;">如果不存在修饰符，则默认为session。</p></li></ul>
                </div>
                <p>
                    The scope for each status variable is listed at
                    <a class="xref" href="server-administration.html#server-status-variables" title="5.1.9&nbsp;Server Status Variables">Section&nbsp;5.1.9, “Server Status Variables”</a>.
                </p><p style="color:blue;">每个状态变量的作用域在第5.1.9节“服务器状态变量”中列出。</p><p>
                Each invocation of the <a class="link" href="sql-syntax.html#show-status" title="13.7.5.35&nbsp;SHOW STATUS Syntax"><code class="literal">SHOW
                STATUS</code></a> statement uses an internal temporary table and
                increments the global
                <a class="link" href="server-administration.html#statvar_Created_tmp_tables"><code class="literal">Created_tmp_tables</code></a> value.
            </p><p style="color:blue;">对show status语句的每次调用都使用一个内部临时表，并增加全局创建的“tmp”表值。</p><p>
                Partial output is shown here. The list of names and values may
                differ for your server. The meaning of each variable is given in
                <a class="xref" href="server-administration.html#server-status-variables" title="5.1.9&nbsp;Server Status Variables">Section&nbsp;5.1.9, “Server Status Variables”</a>.
            </p><p style="color:blue;">此处显示部分输出。名称和值的列表可能因服务器而异。各变量的含义见第5.1.9节“服务器状态变量”。</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>SHOW STATUS;</code></strong>
+--------------------------+------------+
| Variable_name            | Value      |
+--------------------------+------------+
| Aborted_clients          | 0          |
| Aborted_connects         | 0          |
| Bytes_received           | 155372598  |
| Bytes_sent               | 1176560426 |
| Connections              | 30023      |
| Created_tmp_disk_tables  | 0          |
| Created_tmp_tables       | 8340       |
| Created_tmp_files        | 60         |
...
| Open_tables              | 1          |
| Open_files               | 2          |
| Open_streams             | 0          |
| Opened_tables            | 44600      |
| Questions                | 2026873    |
...
| Table_locks_immediate    | 1920382    |
| Table_locks_waited       | 0          |
| Threads_cached           | 0          |
| Threads_created          | 30022      |
| Threads_connected        | 1          |
| Threads_running          | 1          |
| Uptime                   | 80380      |
+--------------------------+------------+
</pre><p>
                With a <a class="link" href="functions.html#operator_like"><code class="literal">LIKE</code></a> clause, the statement
                displays only rows for those variables with names that match the
                pattern:
            </p><p style="color:blue;">使用LIKE子句，语句仅显示名称与模式匹配的变量行：</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>SHOW STATUS LIKE 'Key%';</code></strong>
+--------------------+----------+
| Variable_name      | Value    |
+--------------------+----------+
| Key_blocks_used    | 14955    |
| Key_read_requests  | 96854827 |
| Key_reads          | 162040   |
| Key_write_requests | 7589728  |
| Key_writes         | 3813196  |
+--------------------+----------+
</pre>
            </div>
            <div class="section">
                <div class="titlepage">
                    <div>
                        <div>
                            <h4 class="title"><a name="show-table-status"></a>13.7.5.36&nbsp;SHOW TABLE STATUS Syntax</h4>

                        </div>

                    </div>

                </div>
                <a class="indexterm" name="idm140286826048416"></a><a class="indexterm" name="idm140286826047360"></a><a class="indexterm" name="idm140286826045872"></a><a class="indexterm" name="idm140286826044384"></a><pre data-lang="sql" class="programlisting">SHOW TABLE STATUS
    [{FROM | IN} <em class="replaceable"><code>db_name</code></em>]
    [LIKE '<em class="replaceable"><code>pattern</code></em>' | WHERE <em class="replaceable"><code>expr</code></em>]
</pre><p>
                <a class="link" href="sql-syntax.html#show-table-status" title="13.7.5.36&nbsp;SHOW TABLE STATUS Syntax"><code class="literal">SHOW TABLE STATUS</code></a> works likes
                <a class="link" href="sql-syntax.html#show-tables" title="13.7.5.37&nbsp;SHOW TABLES Syntax"><code class="literal">SHOW TABLES</code></a>, but provides a lot
                of information about each non-<code class="literal">TEMPORARY</code>
                table. You can also get this list using the <a class="link" href="programs.html#mysqlshow" title="4.5.7&nbsp;mysqlshow — Display Database, Table, and Column Information"><span class="command"><strong>mysqlshow
        --status <em class="replaceable"><code>db_name</code></em></strong></span></a> command.
                The <a class="link" href="functions.html#operator_like"><code class="literal">LIKE</code></a> clause, if present,
                indicates which table names to match. The
                <code class="literal">WHERE</code> clause can be given to select rows
                using more general conditions, as discussed in
                <a class="xref" href="information-schema.html#extended-show" title="24.35&nbsp;Extensions to SHOW Statements">Section&nbsp;24.35, “Extensions to SHOW Statements”</a>.
            </p><p style="color:blue;">show table status works与show tables类似，但提供了关于每个非临时表的大量信息。还可以使用mysqlshow--status db_name命令获取此列表。LIKE子句（如果存在）指示要匹配的表名。where子句可用于使用更一般的条件选择行，如第24.35节“显示语句的扩展”所述。</p><p>
                This statement also displays information about views.
            </p><p style="color:blue;">此语句还显示有关视图的信息。</p><p>
                <a class="link" href="sql-syntax.html#show-table-status" title="13.7.5.36&nbsp;SHOW TABLE STATUS Syntax"><code class="literal">SHOW TABLE STATUS</code></a> output has
                these columns:
            </p><p style="color:blue;">显示表状态输出具有以下列：</p>
                <div class="itemizedlist">
                    <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                        <code class="literal">Name</code>
                    </p><p style="color:blue;">姓名</p><p>
                        The name of the table.
                    </p><p style="color:blue;">表的名称。</p></li><li class="listitem"><p>
                        <code class="literal">Engine</code>
                    </p><p style="color:blue;">发动机</p><p>
                        The storage engine for the table. See
                        <a class="xref" href="innodb-storage-engine.html" title="Chapter&nbsp;14&nbsp;The InnoDB Storage Engine">Chapter&nbsp;14, <i>The InnoDB Storage Engine</i></a>, and
                        <a class="xref" href="storage-engines.html" title="Chapter&nbsp;15&nbsp;Alternative Storage Engines">Chapter&nbsp;15, <i>Alternative Storage Engines</i></a>.
                    </p><p style="color:blue;">桌子的存储引擎。参见第14章，InnoDB存储引擎和第15章，替代存储引擎。</p><p>
                        For partitioned tables, <code class="literal">Engine</code> shows the
                        name of the storage engine used by all partitions.
                    </p><p style="color:blue;">对于分区表，engine显示所有分区使用的存储引擎的名称。</p></li><li class="listitem"><p>
                        <code class="literal">Version</code>
                    </p><p style="color:blue;">版本</p><p>
                        The version number of the table's <code class="filename">.frm</code>
                        file.
                    </p><p style="color:blue;">表的.frm文件的版本号。</p></li><li class="listitem"><p>
                        <code class="literal">Row_format</code>
                    </p><p style="color:blue;">行格式</p><p>
                        The row-storage format (<code class="literal">Fixed</code>,
                        <code class="literal">Dynamic</code>, <code class="literal">Compressed</code>,
                        <code class="literal">Redundant</code>, <code class="literal">Compact</code>).
                        For <code class="literal">MyISAM</code> tables,
                        <code class="literal">Dynamic</code> corresponds to what
                        <a class="link" href="programs.html#myisamchk" title="4.6.3&nbsp;myisamchk — MyISAM Table-Maintenance Utility"><span class="command"><strong>myisamchk -dvv</strong></span></a> reports as
                        <code class="literal">Packed</code>. <code class="literal">InnoDB</code> table
                        format is either <code class="literal">Redundant</code> or
                        <code class="literal">Compact</code> when using the
                        <code class="literal">Antelope</code> file format, or
                        <code class="literal">Compressed</code> or <code class="literal">Dynamic</code>
                        when using the <code class="literal">Barracuda</code> file format.
                    </p><p style="color:blue;">行存储格式（固定、动态、压缩、冗余、压缩）。对于myisam表，dynamic对应于myisamchk-dvv报告的打包内容。innodb table format在使用羚羊文件格式时是冗余的或压缩的，在使用梭鱼文件格式时是压缩的或动态的。</p></li><li class="listitem"><p>
                        <code class="literal">Rows</code>
                    </p><p style="color:blue;">排</p><p>
                        The number of rows. Some storage engines, such as
                        <code class="literal">MyISAM</code>, store the exact count. For other
                        storage engines, such as <code class="literal">InnoDB</code>, this
                        value is an approximation, and may vary from the actual
                        value by as much as 40% to 50%. In such cases, use
                        <code class="literal">SELECT COUNT(*)</code> to obtain an accurate
                        count.
                    </p><p style="color:blue;">行数。一些存储引擎（如myisam）存储精确的计数。对于其他存储引擎，如NONDB，这个值是一个近似值，并且可以从实际值变化多达40%到50%。在这种情况下，使用select count（*）获得准确的计数。</p><p>
                        The <code class="literal">Rows</code> value is <code class="literal">NULL</code>
                        for <code class="literal">INFORMATION_SCHEMA</code> tables.
                    </p><p style="color:blue;">信息架构表的行值为空。</p><p>
                        For <a class="link" href="innodb-storage-engine.html" title="Chapter&nbsp;14&nbsp;The InnoDB Storage Engine"><code class="literal">InnoDB</code></a> tables, the row
                        count is only a rough estimate used in SQL optimization.
                        (This is also true if the
                        <a class="link" href="innodb-storage-engine.html" title="Chapter&nbsp;14&nbsp;The InnoDB Storage Engine"><code class="literal">InnoDB</code></a> table is partitioned.)
                    </p><p style="color:blue;">对于innodb表，行数只是sql优化中使用的一个粗略估计。（如果对innodb表进行分区，也是这样。）</p></li><li class="listitem"><p>
                        <code class="literal">Avg_row_length</code>
                    </p><p style="color:blue;">平均行长度</p><p>
                        The average row length.
                    </p><p style="color:blue;">平均行长度。</p><p>
                        Refer to the notes at the end of this section for related
                        information.
                    </p><p style="color:blue;">有关信息，请参阅本节末尾的注释。</p></li><li class="listitem"><p>
                        <code class="literal">Data_length</code>
                    </p><p style="color:blue;">数据长度</p><p>
                        For <code class="literal">MyISAM</code>,
                        <code class="literal">Data_length</code> is the length of the data
                        file, in bytes.
                    </p><p style="color:blue;">对于myisam，data_length是数据文件的长度，以字节为单位。</p><p>
                        For <code class="literal">InnoDB</code>,
                        <code class="literal">Data_length</code> is the approximate amount of
                        memory allocated for the clustered index, in bytes.
                        Specifically, it is the clustered index size, in pages,
                        multiplied by the <code class="literal">InnoDB</code> page size.
                    </p><p style="color:blue;">对于InInDB，DATAYLUM是以字节为单位分配的聚集索引的近似内存量。具体来说，它是聚集索引大小（以页为单位）乘以innodb页大小。</p><p>
                        Refer to the notes at the end of this section for
                        information regarding other storage engines.
                    </p><p style="color:blue;">有关其他存储引擎的信息，请参阅本节末尾的说明。</p></li><li class="listitem"><p>
                        <code class="literal">Max_data_length</code>
                    </p><p style="color:blue;">最大数据长度</p><p>
                        For <code class="literal">MyISAM</code>,
                        <code class="literal">Max_data_length</code> is maximum length of the
                        data file. This is the total number of bytes of data that
                        can be stored in the table, given the data pointer size
                        used.
                    </p><p style="color:blue;">对于MyISAM，Max数据数据长度是数据文件的最大长度。这是给定使用的数据指针大小，表中可存储的数据字节总数。</p><p>
                        Unused for <code class="literal">InnoDB</code>.
                    </p><p style="color:blue;">未用于InnoDB。</p><p>
                        Refer to the notes at the end of this section for
                        information regarding other storage engines.
                    </p><p style="color:blue;">有关其他存储引擎的信息，请参阅本节末尾的说明。</p></li><li class="listitem"><p>
                        <code class="literal">Index_length</code>
                    </p><p style="color:blue;">索引长度</p><p>
                        For <code class="literal">MyISAM</code>,
                        <code class="literal">Index_length</code> is the length of the index
                        file, in bytes.
                    </p><p style="color:blue;">对于myisam，index_length是索引文件的长度，以字节为单位。</p><p>
                        For <code class="literal">InnoDB</code>,
                        <code class="literal">Index_length</code> is the approximate amount of
                        memory allocated for non-clustered indexes, in bytes.
                        Specifically, it is the sum of non-clustered index sizes, in
                        pages, multiplied by the <code class="literal">InnoDB</code> page
                        size.
                    </p><p style="color:blue;">对于NYNDB，索引xCHILL是为非聚集索引分配的内存的近似量，以字节为单位。具体来说，它是非聚集索引大小（以页为单位）乘以innodb页大小的总和。</p><p>
                        Refer to the notes at the end of this section for
                        information regarding other storage engines.
                    </p><p style="color:blue;">有关其他存储引擎的信息，请参阅本节末尾的说明。</p></li><li class="listitem"><p>
                        <code class="literal">Data_free</code>
                    </p><p style="color:blue;">无数据</p><p>
                        The number of allocated but unused bytes.
                    </p><p style="color:blue;">已分配但未使用的字节数。</p><p>
                        <code class="literal">InnoDB</code> tables report the free space of
                        the tablespace to which the table belongs. For a table
                        located in the shared tablespace, this is the free space of
                        the shared tablespace. If you are using multiple tablespaces
                        and the table has its own tablespace, the free space is for
                        only that table. Free space means the number of bytes in
                        completely free extents minus a safety margin. Even if free
                        space displays as 0, it may be possible to insert rows as
                        long as new extents need not be allocated.
                    </p><p style="color:blue;">innodb tables报告表所属表空间的可用空间。对于位于共享表空间中的表，这是共享表空间的可用空间。如果使用多个表空间，并且表有自己的表空间，则可用空间仅用于该表。可用空间是指完全可用区中的字节数减去安全裕度。即使可用空间显示为0，只要不需要分配新的扩展数据块，也可以插入行。</p><p>
                        For NDB Cluster, <code class="literal">Data_free</code> shows the
                        space allocated on disk for, but not used by, a Disk Data
                        table or fragment on disk. (In-memory data resource usage is
                        reported by the <code class="literal">Data_length</code> column.)
                    </p><p style="color:blue;">对于ndb集群，data_free显示磁盘上为磁盘上的磁盘数据表或片段分配但未被使用的空间。（内存中的数据资源使用情况由“数据长度”列报告。）</p><p>
                        For partitioned tables, this value is only an estimate and
                        may not be absolutely correct. A more accurate method of
                        obtaining this information in such cases is to query the
                        <code class="literal">INFORMATION_SCHEMA</code>
                        <a class="link" href="information-schema.html#partitions-table" title="24.16&nbsp;The INFORMATION_SCHEMA PARTITIONS Table"><code class="literal">PARTITIONS</code></a> table, as shown in
                        this example:
                    </p><p style="color:blue;">对于分区表，此值只是一个估计值，可能不是绝对正确的。在这种情况下获得此信息的更精确的方法是查询信息-StaseStudio分区表，如本示例所示：</p><pre data-lang="sql" class="programlisting">SELECT SUM(DATA_FREE)
    FROM  INFORMATION_SCHEMA.PARTITIONS
    WHERE TABLE_SCHEMA = 'mydb'
    AND   TABLE_NAME   = 'mytable';
</pre><p>
                        For more information, see
                        <a class="xref" href="information-schema.html#partitions-table" title="24.16&nbsp;The INFORMATION_SCHEMA PARTITIONS Table">Section&nbsp;24.16, “The INFORMATION_SCHEMA PARTITIONS Table”</a>.
                    </p><p style="color:blue;">有关更多信息，请参见第24.16节“信息-IOS模式分区表”。</p></li><li class="listitem"><p>
                        <code class="literal">Auto_increment</code>
                    </p><p style="color:blue;">自动递增</p><p>
                        The next <code class="literal">AUTO_INCREMENT</code> value.
                    </p><p style="color:blue;">下一个自动递增值。</p></li><li class="listitem"><p>
                        <code class="literal">Create_time</code>
                    </p><p style="color:blue;">创建时间</p><p>
                        When the table was created.
                    </p><p style="color:blue;">创建表时。</p></li><li class="listitem"><p>
                        <code class="literal">Update_time</code>
                    </p><p style="color:blue;">更新时间</p><p>
                        When the data file was last updated. For some storage
                        engines, this value is <code class="literal">NULL</code>. For example,
                        <code class="literal">InnoDB</code> stores multiple tables in its
                        <a class="link" href="glossary.html#glos_system_tablespace" title="system tablespace">system
                            tablespace</a> and the data file timestamp does not
                        apply. Even with
                        <a class="link" href="glossary.html#glos_file_per_table" title="file-per-table">file-per-table</a>
                        mode with each <code class="literal">InnoDB</code> table in a separate
                        <code class="literal">.ibd</code> file,
                        <a class="link" href="glossary.html#glos_change_buffering" title="change buffering">change
                            buffering</a> can delay the write to the data file, so
                        the file modification time is different from the time of the
                        last insert, update, or delete. For
                        <code class="literal">MyISAM</code>, the data file timestamp is used;
                        however, on Windows the timestamp is not updated by updates,
                        so the value is inaccurate.
                    </p><p style="color:blue;">上次更新数据文件的时间。对于某些存储引擎，此值为空。例如，innodb在其系统表空间中存储多个表，而数据文件时间戳不适用。即使在每个innodb表都在一个单独的.ibd文件中的file per table模式下，更改缓冲也会延迟对数据文件的写入，因此文件修改时间与上次插入、更新或删除的时间不同。对于myisam，使用数据文件时间戳；但是，在windows上，时间戳不会被更新更新，因此该值不准确。</p><p>
                        <code class="literal">Update_time</code> displays a timestamp value
                        for the last <a class="link" href="sql-syntax.html#update" title="13.2.11&nbsp;UPDATE Syntax"><code class="literal">UPDATE</code></a>,
                        <a class="link" href="sql-syntax.html#insert" title="13.2.5&nbsp;INSERT Syntax"><code class="literal">INSERT</code></a>, or
                        <a class="link" href="sql-syntax.html#delete" title="13.2.2&nbsp;DELETE Syntax"><code class="literal">DELETE</code></a> performed on
                        <code class="literal">InnoDB</code> tables that are not partitioned.
                        For MVCC, the timestamp value reflects the
                        <a class="link" href="sql-syntax.html#commit" title="13.3.1&nbsp;START TRANSACTION, COMMIT, and ROLLBACK Syntax"><code class="literal">COMMIT</code></a> time, which is
                        considered the last update time. Timestamps are not
                        persisted when the server is restarted or when the table is
                        evicted from the <code class="literal">InnoDB</code> data dictionary
                        cache.
                    </p><p style="color:blue;">update_time显示上次对未分区的innodb表执行的更新、插入或删除的时间戳值。对于mvcc，timestamp值反映提交时间，它被认为是最后一次更新时间。重新启动服务器或从innodb数据字典缓存中逐出表时，时间戳不会持久化。</p><p>
                        The <code class="literal">Update_time</code> column also shows this
                        information for partitioned <code class="literal">InnoDB</code>
                        tables.
                    </p><p style="color:blue;">update_time列还显示分区innodb表的此信息。</p></li><li class="listitem"><p>
                        <code class="literal">Check_time</code>
                    </p><p style="color:blue;">检查时间</p><p>
                        When the table was last checked. Not all storage engines
                        update this time, in which case, the value is always
                        <code class="literal">NULL</code>.
                    </p><p style="color:blue;">上次检查桌子的时候。不是所有的存储引擎都会更新，在这种情况下，该值总是空的。</p><p>
                        For partitioned <a class="link" href="innodb-storage-engine.html" title="Chapter&nbsp;14&nbsp;The InnoDB Storage Engine"><code class="literal">InnoDB</code></a> tables,
                        <code class="literal">Check_time</code> is always
                        <code class="literal">NULL</code>.
                    </p><p style="color:blue;">对于已分区的innodb表，check_time始终为空。</p></li><li class="listitem"><p>
                        <code class="literal">Collation</code>
                    </p><p style="color:blue;">校勘</p><p>
                        The table default collation. The output does not explicitly
                        list the table default character set, but the collation name
                        begins with the character set name.
                    </p><p style="color:blue;">表的默认排序规则。输出没有显式列出表默认字符集，但排序规则名称以字符集名称开头。</p></li><li class="listitem"><p>
                        <code class="literal">Checksum</code>
                    </p><p style="color:blue;">校验和</p><p>
                        The live checksum value, if any.
                    </p><p style="color:blue;">实时校验和值（如果有）。</p></li><li class="listitem"><p>
                        <code class="literal">Create_options</code>
                    </p><p style="color:blue;">创建选项</p><p>
                        Extra options used with <a class="link" href="sql-syntax.html#create-table" title="13.1.18&nbsp;CREATE TABLE Syntax"><code class="literal">CREATE
                        TABLE</code></a>. The original options from when
                        <a class="link" href="sql-syntax.html#create-table" title="13.1.18&nbsp;CREATE TABLE Syntax"><code class="literal">CREATE TABLE</code></a> was executed are
                        retained and the options reported here may differ from the
                        active table settings and options.
                    </p><p style="color:blue;">用于创建表的额外选项。执行create table时的原始选项将保留，此处报告的选项可能与活动表设置和选项不同。</p><p>
                        <code class="literal">Create_options</code> shows
                        <code class="literal">partitioned</code> if the table is partitioned.
                        It also shows the <code class="literal">ENCRYPTION</code> option
                        specified when creating or altering a file-per-table
                        tablespace.
                    </p><p style="color:blue;">如果表已分区，则create_选项将显示partitioned。它还显示了在创建或更改每个表空间的文件时指定的加密选项。</p></li><li class="listitem"><p>
                        <code class="literal">Comment</code>
                    </p><p style="color:blue;">评论</p><p>
                        The comment used when creating the table (or information as
                        to why MySQL could not access the table information).
                    </p><p style="color:blue;">创建表时使用的注释（或有关MySQL无法访问表信息的原因的信息）。</p></li></ul>
                </div>
                <h5><a name="idm140286825921008"></a>Notes</h5>
                <div class="itemizedlist">
                    <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                        For <a class="link" href="mysql-cluster.html" title="Chapter&nbsp;21&nbsp;MySQL NDB Cluster 7.5 and NDB Cluster 7.6"><code class="literal">NDB</code></a> tables, the output of
                        this statement shows appropriate values for the
                        <code class="literal">Avg_row_length</code> and
                        <code class="literal">Data_length</code> columns, with the exception
                        that <a class="link" href="data-types.html#blob" title="11.4.3&nbsp;The BLOB and TEXT Types"><code class="literal">BLOB</code></a> columns are not
                        taken into account.
                    </p><p style="color:blue;">对于ndb表，此语句的输出显示了avg_row_length和data_length列的适当值，但blob列未被考虑在内的情况除外。</p></li><li class="listitem"><p>
                        For <a class="link" href="mysql-cluster.html" title="Chapter&nbsp;21&nbsp;MySQL NDB Cluster 7.5 and NDB Cluster 7.6"><code class="literal">NDB</code></a> tables,
                        <code class="literal">Data_length</code> includes data stored in main
                        memory only; the <code class="literal">Max_data_length</code> and
                        <code class="literal">Data_free</code> columns apply to Disk Data.
                    </p><p style="color:blue;">对于ndb表，data_length只包括存储在主存储器中的数据；max_data_length和data_free列适用于磁盘数据。</p></li><li class="listitem"><p>
                        For NDB Cluster Disk Data tables,
                        <code class="literal">Max_data_length</code> shows the space allocated
                        for the disk part of a Disk Data table or fragment.
                        (In-memory data resource usage is reported by the
                        <code class="literal">Data_length</code> column.)
                    </p><p style="color:blue;">对于ndb集群磁盘数据表，max_data_length显示为磁盘数据表或片段的磁盘部分分配的空间。（内存中的数据资源使用情况由“数据长度”列报告。）</p></li><li class="listitem"><p>
                        For <code class="literal">MEMORY</code> tables, the
                        <code class="literal">Data_length</code>,
                        <code class="literal">Max_data_length</code>, and
                        <code class="literal">Index_length</code> values approximate the
                        actual amount of allocated memory. The allocation algorithm
                        reserves memory in large amounts to reduce the number of
                        allocation operations.
                    </p><p style="color:blue;">对于内存表，DATAL长度、Max数据DATAL长度和索引长度值近似于实际分配的内存量。分配算法大量保留内存以减少分配操作的次数。</p></li><li class="listitem"><p>
                        For views, all columns displayed by
                        <a class="link" href="sql-syntax.html#show-table-status" title="13.7.5.36&nbsp;SHOW TABLE STATUS Syntax"><code class="literal">SHOW TABLE STATUS</code></a> are
                        <code class="literal">NULL</code> except that <code class="literal">Name</code>
                        indicates the view name and <code class="literal">Comment</code> says
                        <code class="literal">VIEW</code>.
                    </p><p style="color:blue;">对于视图，按“显示表状态”显示的所有列都为空，但该名称表示视图名称，而注释表示视图。</p></li></ul>
                </div>
                <p>
                    Table information is also available from the
                    <code class="literal">INFORMATION_SCHEMA</code>
                    <a class="link" href="information-schema.html#tables-table" title="24.25&nbsp;The INFORMATION_SCHEMA TABLES Table"><code class="literal">TABLES</code></a> table. See
                    <a class="xref" href="information-schema.html#tables-table" title="24.25&nbsp;The INFORMATION_SCHEMA TABLES Table">Section&nbsp;24.25, “The INFORMATION_SCHEMA TABLES Table”</a>.
                </p><p style="color:blue;">表信息也可以从信息架构表表中获得。参见第24.25节“信息架构表”。</p>
            </div>
            <div class="section">
                <div class="titlepage">
                    <div>
                        <div>
                            <h4 class="title"><a name="show-tables"></a>13.7.5.37&nbsp;SHOW TABLES Syntax</h4>

                        </div>

                    </div>

                </div>
                <a class="indexterm" name="idm140286825895280"></a><a class="indexterm" name="idm140286825892464"></a><pre data-lang="sql" class="programlisting">SHOW [FULL] TABLES
    [{FROM | IN} <em class="replaceable"><code>db_name</code></em>]
    [LIKE '<em class="replaceable"><code>pattern</code></em>' | WHERE <em class="replaceable"><code>expr</code></em>]
</pre><p>
                <a class="link" href="sql-syntax.html#show-tables" title="13.7.5.37&nbsp;SHOW TABLES Syntax"><code class="literal">SHOW TABLES</code></a> lists the
                non-<code class="literal">TEMPORARY</code> tables in a given database. You
                can also get this list using the <a class="link" href="programs.html#mysqlshow" title="4.5.7&nbsp;mysqlshow — Display Database, Table, and Column Information"><span class="command"><strong>mysqlshow
        <em class="replaceable"><code>db_name</code></em></strong></span></a> command. The
                <a class="link" href="functions.html#operator_like"><code class="literal">LIKE</code></a> clause, if present, indicates
                which table names to match. The <code class="literal">WHERE</code> clause
                can be given to select rows using more general conditions, as
                discussed in <a class="xref" href="information-schema.html#extended-show" title="24.35&nbsp;Extensions to SHOW Statements">Section&nbsp;24.35, “Extensions to SHOW Statements”</a>.
            </p><p style="color:blue;">show tables列出给定数据库中的非临时表。您还可以使用mysqlshow db_name命令获取此列表。LIKE子句（如果存在）指示要匹配的表名。where子句可用于使用更一般的条件选择行，如第24.35节“显示语句的扩展”所述。</p><p>
                Matching performed by the <code class="literal">LIKE</code> clause is
                dependent on the setting of the
                <a class="link" href="server-administration.html#sysvar_lower_case_table_names"><code class="literal">lower_case_table_names</code></a> system
                variable.
            </p><p style="color:blue;">LIKE子句执行的匹配取决于小写TABLE_NAMES系统变量的设置。</p><p>
                This statement also lists any views in the database. The
                optional <code class="literal">FULL</code> modifier causes
                <a class="link" href="sql-syntax.html#show-tables" title="13.7.5.37&nbsp;SHOW TABLES Syntax"><code class="literal">SHOW TABLES</code></a> to display a second
                output column with values of <code class="literal">BASE TABLE</code> for a
                table, <code class="literal">VIEW</code> for a view, or <code class="literal">SYSTEM
                VIEW</code> for an <code class="literal">INFORMATION_SCHEMA</code>
                table.
            </p><p style="color:blue;">此语句还列出数据库中的任何视图。可选的full修饰符使show tables显示第二个输出列，其中包含表的基表、视图的视图或信息架构表的系统视图的值。</p><p>
                If you have no privileges for a base table or view, it does not
                show up in the output from <a class="link" href="sql-syntax.html#show-tables" title="13.7.5.37&nbsp;SHOW TABLES Syntax"><code class="literal">SHOW
                TABLES</code></a> or <a class="link" href="programs.html#mysqlshow" title="4.5.7&nbsp;mysqlshow — Display Database, Table, and Column Information"><span class="command"><strong>mysqlshow db_name</strong></span></a>.
            </p><p style="color:blue;">如果您没有基本表或视图的权限，则它不会显示在显示表或mysqlshow db_name的输出中。</p><p>
                Table information is also available from the
                <code class="literal">INFORMATION_SCHEMA</code>
                <a class="link" href="information-schema.html#tables-table" title="24.25&nbsp;The INFORMATION_SCHEMA TABLES Table"><code class="literal">TABLES</code></a> table. See
                <a class="xref" href="information-schema.html#tables-table" title="24.25&nbsp;The INFORMATION_SCHEMA TABLES Table">Section&nbsp;24.25, “The INFORMATION_SCHEMA TABLES Table”</a>.
            </p><p style="color:blue;">表信息也可以从信息架构表表中获得。参见第24.25节“信息架构表”。</p>
            </div>
            <div class="section">
                <div class="titlepage">
                    <div>
                        <div>
                            <h4 class="title"><a name="show-triggers"></a>13.7.5.38&nbsp;SHOW TRIGGERS Syntax</h4>

                        </div>

                    </div>

                </div>
                <a class="indexterm" name="idm140286825864208"></a><a class="indexterm" name="idm140286825863136"></a><a class="indexterm" name="idm140286825862064"></a><pre data-lang="sql" class="programlisting">SHOW TRIGGERS
    [{FROM | IN} <em class="replaceable"><code>db_name</code></em>]
    [LIKE '<em class="replaceable"><code>pattern</code></em>' | WHERE <em class="replaceable"><code>expr</code></em>]
</pre><p>
                <a class="link" href="sql-syntax.html#show-triggers" title="13.7.5.38&nbsp;SHOW TRIGGERS Syntax"><code class="literal">SHOW TRIGGERS</code></a> lists the triggers
                currently defined for tables in a database (the default database
                unless a <code class="literal">FROM</code> clause is given). This
                statement returns results only for databases and tables for
                which you have the <a class="link" href="security.html#priv_trigger"><code class="literal">TRIGGER</code></a>
                privilege. The <a class="link" href="functions.html#operator_like"><code class="literal">LIKE</code></a> clause, if
                present, indicates which table names (not trigger names) to
                match and causes the statement to display triggers for those
                tables. The <code class="literal">WHERE</code> clause can be given to
                select rows using more general conditions, as discussed in
                <a class="xref" href="information-schema.html#extended-show" title="24.35&nbsp;Extensions to SHOW Statements">Section&nbsp;24.35, “Extensions to SHOW Statements”</a>.
            </p><p style="color:blue;">show triggers列出当前为数据库中的表定义的触发器（除非给定from子句，否则为默认数据库）。此语句仅返回具有触发器特权的数据库和表的结果。LIKE子句（如果存在）指示要匹配的表名（而不是触发器名），并使语句显示这些表的触发器。where子句可用于使用更一般的条件选择行，如第24.35节“显示语句的扩展”所述。</p><p>
                For the <code class="literal">ins_sum</code> trigger defined in
                <a class="xref" href="stored-objects.html#triggers" title="23.3&nbsp;Using Triggers">Section&nbsp;23.3, “Using Triggers”</a>, the output of
                <a class="link" href="sql-syntax.html#show-triggers" title="13.7.5.38&nbsp;SHOW TRIGGERS Syntax"><code class="literal">SHOW TRIGGERS</code></a> is as shown here:
            </p><p style="color:blue;">对于第23.3节“使用触发器”中定义的INS_SUM触发器，显示触发器的输出如下所示：</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>SHOW TRIGGERS LIKE 'acc%'\G</code></strong>
*************************** 1. row ***************************
             Trigger: ins_sum
               Event: INSERT
               Table: account
           Statement: SET @sum = @sum + NEW.amount
              Timing: BEFORE
             Created: 2018-08-08 10:10:12.61
            sql_mode: ONLY_FULL_GROUP_BY,STRICT_TRANS_TABLES,
                      NO_ZERO_IN_DATE,NO_ZERO_DATE,
                      ERROR_FOR_DIVISION_BY_ZERO,
                      NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION
             Definer: me@localhost
character_set_client: utf8
collation_connection: utf8_general_ci
  Database Collation: latin1_swedish_ci
</pre><p>
                <a class="link" href="sql-syntax.html#show-triggers" title="13.7.5.38&nbsp;SHOW TRIGGERS Syntax"><code class="literal">SHOW TRIGGERS</code></a> output has these
                columns:
            </p><p style="color:blue;">显示触发器输出具有以下列：</p>
                <div class="itemizedlist">
                    <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                        <code class="literal">Trigger</code>
                    </p><p style="color:blue;">触发</p><p>
                        The name of the trigger.
                    </p><p style="color:blue;">触发器的名称。</p></li><li class="listitem"><p>
                        <code class="literal">Event</code>
                    </p><p style="color:blue;">事件</p><p>
                        The trigger event. This is the type of operation on the
                        associated table for which the trigger activates. The value
                        is <code class="literal">INSERT</code> (a row was inserted),
                        <code class="literal">DELETE</code> (a row was deleted), or
                        <code class="literal">UPDATE</code> (a row was modified).
                    </p><p style="color:blue;">触发事件。这是触发器激活的关联表上的操作类型。值为insert（插入了一行）、delete（删除了一行）或update（修改了一行）。</p></li><li class="listitem"><p>
                        <code class="literal">Table</code>
                    </p><p style="color:blue;">桌子</p><p>
                        The table for which the trigger is defined.
                    </p><p style="color:blue;">为其定义触发器的表。</p></li><li class="listitem"><p>
                        <code class="literal">Statement</code>
                    </p><p style="color:blue;">声明</p><p>
                        The trigger body; that is, the statement executed when the
                        trigger activates.
                    </p><p style="color:blue;">触发器主体；即触发器激活时执行的语句。</p></li><li class="listitem"><p>
                        <code class="literal">Timing</code>
                    </p><p style="color:blue;">时机</p><p>
                        Whether the trigger activates before or after the triggering
                        event. The value is <code class="literal">BEFORE</code> or
                        <code class="literal">AFTER</code>.
                    </p><p style="color:blue;">触发器是在触发事件之前还是之后激活。值在之前或之后。</p></li><li class="listitem"><p>
                        <code class="literal">Created</code>
                    </p><p style="color:blue;">创建</p><p>
                        The date and time when the trigger was created. This is a
                        <code class="literal">TIMESTAMP(2)</code> value (with a fractional
                        part in hundredths of seconds) for triggers created in MySQL
                        5.7.2 or later, <code class="literal">NULL</code> for triggers created
                        prior to 5.7.2.
                    </p><p style="color:blue;">创建触发器的日期和时间。这是mysql 5.7.2或更高版本中创建的触发器的时间戳（2）值（小数部分以百分之几秒为单位），对于5.7.2之前创建的触发器为空。</p></li><li class="listitem"><p>
                        <code class="literal">sql_mode</code>
                    </p><p style="color:blue;">SQL模式</p><p>
                        The SQL mode in effect when the trigger was created, and
                        under which the trigger executes. For the permitted values,
                        see <a class="xref" href="server-administration.html#sql-mode" title="5.1.10&nbsp;Server SQL Modes">Section&nbsp;5.1.10, “Server SQL Modes”</a>.
                    </p><p style="color:blue;">创建触发器时生效的SQL模式，触发器在该模式下执行。有关允许的值，请参阅第5.1.10节“服务器SQL模式”。</p></li><li class="listitem"><p>
                        <code class="literal">Definer</code>
                    </p><p style="color:blue;">定义者</p><p>
                        The account of the user who created the trigger, in
                        <code class="literal">'<em class="replaceable"><code>user_name</code></em>'@'<em class="replaceable"><code>host_name</code></em>'</code>
                        format.
                    </p><p style="color:blue;">以“用户名”@“主机名”格式创建触发器的用户的帐户。</p></li><li class="listitem"><p>
                        <code class="literal">character_set_client</code>
                    </p><p style="color:blue;">字符集客户端</p><p>
                        The session value of the
                        <a class="link" href="server-administration.html#sysvar_character_set_client"><code class="literal">character_set_client</code></a> system
                        variable when the trigger was created.
                    </p><p style="color:blue;">创建触发器时character_set_client系统变量的会话值。</p></li><li class="listitem"><p>
                        <code class="literal">collation_connection</code>
                    </p><p style="color:blue;">排序规则连接</p><p>
                        The session value of the
                        <a class="link" href="server-administration.html#sysvar_collation_connection"><code class="literal">collation_connection</code></a> system
                        variable when the trigger was created.
                    </p><p style="color:blue;">创建触发器时排序规则连接系统变量的会话值。</p></li><li class="listitem"><p>
                        <code class="literal">Database Collation</code>
                    </p><p style="color:blue;">数据库排序规则</p><p>
                        The collation of the database with which the trigger is
                        associated.
                    </p><p style="color:blue;">与触发器关联的数据库的排序规则。</p></li></ul>
                </div>
                <p>
                    Trigger information is also available from the
                    <code class="literal">INFORMATION_SCHEMA</code>
                    <a class="link" href="information-schema.html#triggers-table" title="24.29&nbsp;The INFORMATION_SCHEMA TRIGGERS Table"><code class="literal">TRIGGERS</code></a> table. See
                    <a class="xref" href="information-schema.html#triggers-table" title="24.29&nbsp;The INFORMATION_SCHEMA TRIGGERS Table">Section&nbsp;24.29, “The INFORMATION_SCHEMA TRIGGERS Table”</a>.
                </p><p style="color:blue;">触发器信息也可以从信息架构触发器表中获得。参见第24.29节“信息架构触发器表”。</p>
            </div>
            <div class="section">
                <div class="titlepage">
                    <div>
                        <div>
                            <h4 class="title"><a name="show-variables"></a>13.7.5.39&nbsp;SHOW VARIABLES Syntax</h4>

                        </div>

                    </div>

                </div>
                <a class="indexterm" name="idm140286825805680"></a><a class="indexterm" name="idm140286825804592"></a><a class="indexterm" name="idm140286825803520"></a><a class="indexterm" name="idm140286825802448"></a><a class="indexterm" name="idm140286825800960"></a><pre data-lang="sql" class="programlisting">SHOW [GLOBAL | SESSION] VARIABLES
    [LIKE '<em class="replaceable"><code>pattern</code></em>' | WHERE <em class="replaceable"><code>expr</code></em>]
</pre><a class="indexterm" name="idm140286825795600"></a>
                <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">

                    <div class="admon-title">
                        Note
                    </div>
                    <p>
                        As of MySQL 5.7.6, the value of the
                        <a class="link" href="server-administration.html#sysvar_show_compatibility_56"><code class="literal">show_compatibility_56</code></a> system
                        variable affects the information available from and privileges
                        required for the statement described here. For details, see
                        the description of that variable in
                        <a class="xref" href="server-administration.html#server-system-variables" title="5.1.7&nbsp;Server System Variables">Section&nbsp;5.1.7, “Server System Variables”</a>.
                    </p><p style="color:blue;">从mysql 5.7.6开始，show_compatibility_56系统变量的值将影响此处所述语句的可用信息和所需权限。有关详细信息，请参阅第5.1.7节“服务器系统变量”中对该变量的描述。</p>
                </div>
                <p>
                    <a class="link" href="sql-syntax.html#show-variables" title="13.7.5.39&nbsp;SHOW VARIABLES Syntax"><code class="literal">SHOW VARIABLES</code></a> shows the values
                    of MySQL system variables (see
                    <a class="xref" href="server-administration.html#server-system-variables" title="5.1.7&nbsp;Server System Variables">Section&nbsp;5.1.7, “Server System Variables”</a>). This statement does
                    not require any privilege. It requires only the ability to
                    connect to the server.
                </p><p style="color:blue;">show variables显示mysql系统变量的值（参见第5.1.7节“服务器系统变量”）。此语句不需要任何特权。它只需要连接到服务器的能力。</p><p>
                System variable information is also available from these
                sources:
            </p><p style="color:blue;">系统变量信息也可从以下来源获得：</p>
                <div class="itemizedlist">
                    <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                        Performance Schema tables. See
                        <a class="xref" href="performance-schema.html#performance-schema-system-variable-tables" title="25.12.13&nbsp;Performance Schema System Variable Tables">Section&nbsp;25.12.13, “Performance Schema System Variable Tables”</a>.
                    </p><p style="color:blue;">性能架构表。见第25.12.13节“性能模式系统变量表”。</p></li><li class="listitem"><p>
                        The
                        <a class="link" href="information-schema.html#variables-table" title="24.11&nbsp;The INFORMATION_SCHEMA GLOBAL_VARIABLES and SESSION_VARIABLES Tables"><code class="literal">GLOBAL_VARIABLES</code></a>
                        and
                        <a class="link" href="information-schema.html#variables-table" title="24.11&nbsp;The INFORMATION_SCHEMA GLOBAL_VARIABLES and SESSION_VARIABLES Tables"><code class="literal">SESSION_VARIABLES</code></a>
                        tables. See <a class="xref" href="information-schema.html#variables-table" title="24.11&nbsp;The INFORMATION_SCHEMA GLOBAL_VARIABLES and SESSION_VARIABLES Tables">Section&nbsp;24.11, “The INFORMATION_SCHEMA GLOBAL_VARIABLES and SESSION_VARIABLES Tables”</a>.
                    </p><p style="color:blue;">全局变量和会话变量表。参见第24.11节“信息模式全局变量和会话变量表”。</p></li><li class="listitem"><p>
                        The <a class="link" href="programs.html#mysqladmin" title="4.5.2&nbsp;mysqladmin — Client for Administering a MySQL Server"><span class="command"><strong>mysqladmin variables</strong></span></a> command. See
                        <a class="xref" href="programs.html#mysqladmin" title="4.5.2&nbsp;mysqladmin — Client for Administering a MySQL Server">Section&nbsp;4.5.2, “<span class="command"><strong>mysqladmin</strong></span> — Client for Administering a MySQL Server”</a>.
                    </p><p style="color:blue;">mysqladmin变量命令。请参阅4.5.2节，“mysqladmin-用于管理mysql服务器的客户端”。</p></li></ul>
                </div>
                <p>
                    For <a class="link" href="sql-syntax.html#show-variables" title="13.7.5.39&nbsp;SHOW VARIABLES Syntax"><code class="literal">SHOW VARIABLES</code></a>, a
                    <a class="link" href="functions.html#operator_like"><code class="literal">LIKE</code></a> clause, if present, indicates
                    which variable names to match. A <code class="literal">WHERE</code> clause
                    can be given to select rows using more general conditions, as
                    discussed in <a class="xref" href="information-schema.html#extended-show" title="24.35&nbsp;Extensions to SHOW Statements">Section&nbsp;24.35, “Extensions to SHOW Statements”</a>.
                </p><p style="color:blue;">对于show variables，like子句（如果存在）指示要匹配的变量名。一个where子句可以使用更一般的条件来选择行，如24.35节“显示语句的扩展”所述。</p><p>
                <a class="link" href="sql-syntax.html#show-variables" title="13.7.5.39&nbsp;SHOW VARIABLES Syntax"><code class="literal">SHOW VARIABLES</code></a> accepts an
                optional <code class="literal">GLOBAL</code> or <code class="literal">SESSION</code>
                variable scope modifier:
            </p><p style="color:blue;">show variables接受可选的全局或会话变量作用域修饰符：</p>
                <div class="itemizedlist">
                    <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                        With a <code class="literal">GLOBAL</code> modifier, the statement
                        displays global system variable values. These are the values
                        used to initialize the corresponding session variables for
                        new connections to MySQL. If a variable has no global value,
                        no value is displayed.
                    </p><p style="color:blue;">使用全局修饰符，该语句显示全局系统变量值。这些值用于初始化到mysql的新连接的相应会话变量。如果变量没有全局值，则不显示任何值。</p></li><li class="listitem"><p>
                        With a <code class="literal">SESSION</code> modifier, the statement
                        displays the system variable values that are in effect for
                        the current connection. If a variable has no session value,
                        the global value is displayed. <code class="literal">LOCAL</code> is a
                        synonym for <code class="literal">SESSION</code>.
                    </p><p style="color:blue;">使用会话修饰符，语句将显示对当前连接有效的系统变量值。如果变量没有会话值，则显示全局值。local是session的同义词。</p></li><li class="listitem"><p>
                        If no modifier is present, the default is
                        <code class="literal">SESSION</code>.
                    </p><p style="color:blue;">如果不存在修饰符，则默认为session。</p></li></ul>
                </div>
                <p>
                    The scope for each system variable is listed at
                    <a class="xref" href="server-administration.html#server-system-variables" title="5.1.7&nbsp;Server System Variables">Section&nbsp;5.1.7, “Server System Variables”</a>.
                </p><p style="color:blue;">每个系统变量的作用域在第5.1.7节“服务器系统变量”中列出。</p><p>
                <a class="link" href="sql-syntax.html#show-variables" title="13.7.5.39&nbsp;SHOW VARIABLES Syntax"><code class="literal">SHOW VARIABLES</code></a> is subject to a
                version-dependent display-width limit. For variables with very
                long values that are not completely displayed, use
                <a class="link" href="sql-syntax.html#select" title="13.2.9&nbsp;SELECT Syntax"><code class="literal">SELECT</code></a> as a workaround. For
                example:
            </p><p style="color:blue;">显示变量受版本相关的显示宽度限制。对于值很长但未完全显示的变量，请使用“选择”作为解决方法。例如：</p><pre data-lang="sql" class="programlisting">SELECT @@GLOBAL.innodb_data_file_path;
</pre><p>
                Most system variables can be set at server startup (read-only
                variables such as
                <a class="link" href="server-administration.html#sysvar_version_comment"><code class="literal">version_comment</code></a> are
                exceptions). Many can be changed at runtime with the
                <a class="link" href="sql-syntax.html#set-variable" title="13.7.4.1&nbsp;SET Syntax for Variable Assignment"><code class="literal">SET</code></a>
                statement. See <a class="xref" href="server-administration.html#using-system-variables" title="5.1.8&nbsp;Using System Variables">Section&nbsp;5.1.8, “Using System Variables”</a>, and
                <a class="xref" href="sql-syntax.html#set-variable" title="13.7.4.1&nbsp;SET Syntax for Variable Assignment">Section&nbsp;13.7.4.1, “SET Syntax for Variable Assignment”</a>.
            </p><p style="color:blue;">大多数系统变量可以在服务器启动时设置（只读变量，如version_comment是例外）。许多可以在运行时使用set语句进行更改。参见第5.1.8节“使用系统变量”，以及第13.7.4.1节“设置变量赋值语法”。</p><p>
                Partial output is shown here. The list of names and values may
                differ for your server.
                <a class="xref" href="server-administration.html#server-system-variables" title="5.1.7&nbsp;Server System Variables">Section&nbsp;5.1.7, “Server System Variables”</a>, describes the meaning
                of each variable, and <a class="xref" href="server-administration.html#server-configuration" title="5.1.1&nbsp;Configuring the Server">Section&nbsp;5.1.1, “Configuring the Server”</a>,
                provides information about tuning them.
            </p><p style="color:blue;">此处显示部分输出。名称和值的列表可能因服务器而异。第5.1.7节“服务器系统变量”描述了每个变量的含义，第5.1.1节“配置服务器”提供了有关调整这些变量的信息。</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>SHOW VARIABLES;</code></strong>
+-----------------------------------------+---------------------------+
| Variable_name                           | Value                     |
+-----------------------------------------+---------------------------+
| auto_increment_increment                | 1                         |
| auto_increment_offset                   | 1                         |
| autocommit                              | ON                        |
| automatic_sp_privileges                 | ON                        |
| back_log                                | 50                        |
| basedir                                 | /home/jon/bin/mysql-5.5   |
| big_tables                              | OFF                       |
| binlog_cache_size                       | 32768                     |
| binlog_direct_non_transactional_updates | OFF                       |
| binlog_format                           | STATEMENT                 |
| binlog_stmt_cache_size                  | 32768                     |
| bulk_insert_buffer_size                 | 8388608                   |
...
| max_allowed_packet                      | 4194304                   |
| max_binlog_cache_size                   | 18446744073709547520      |
| max_binlog_size                         | 1073741824                |
| max_binlog_stmt_cache_size              | 18446744073709547520      |
| max_connect_errors                      | 100                       |
| max_connections                         | 151                       |
| max_delayed_threads                     | 20                        |
| max_error_count                         | 64                        |
| max_heap_table_size                     | 16777216                  |
| max_insert_delayed_threads              | 20                        |
| max_join_size                           | 18446744073709551615      |
...

| thread_handling                         | one-thread-per-connection |
| thread_stack                            | 262144                    |
| time_format                             | %H:%i:%s                  |
| time_zone                               | SYSTEM                    |
| timestamp                               | 1316689732                |
| tmp_table_size                          | 16777216                  |
| tmpdir                                  | /tmp                      |
| transaction_alloc_block_size            | 8192                      |
| transaction_isolation                   | REPEATABLE-READ           |
| transaction_prealloc_size               | 4096                      |
| transaction_read_only                   | OFF                       |
| tx_isolation                            | REPEATABLE-READ           |
| tx_read_only                            | OFF                       |
| unique_checks                           | ON                        |
| updatable_views_with_limit              | YES                       |
| version                                 | 5.5.17-log                |
| version_comment                         | Source distribution       |
| version_compile_machine                 | x86_64                    |
| version_compile_os                      | Linux                     |
| wait_timeout                            | 28800                     |
| warning_count                           | 0                         |
+-----------------------------------------+---------------------------+
</pre><p>
                With a <a class="link" href="functions.html#operator_like"><code class="literal">LIKE</code></a> clause, the statement
                displays only rows for those variables with names that match the
                pattern. To obtain the row for a specific variable, use a
                <a class="link" href="functions.html#operator_like"><code class="literal">LIKE</code></a> clause as shown:
            </p><p style="color:blue;">使用LIKE子句，该语句只显示名称与模式匹配的变量的行。要获取特定变量的行，请使用like子句，如下所示：</p><pre data-lang="sql" class="programlisting">SHOW VARIABLES LIKE 'max_join_size';
SHOW SESSION VARIABLES LIKE 'max_join_size';
</pre><p>
                To get a list of variables whose name match a pattern, use the
                <code class="literal">%</code> wildcard character in a
                <a class="link" href="functions.html#operator_like"><code class="literal">LIKE</code></a> clause:
            </p><p style="color:blue;">要获取名称与模式匹配的变量列表，请在LIKE子句中使用%通配符：</p><pre data-lang="sql" class="programlisting">SHOW VARIABLES LIKE '%size%';
SHOW GLOBAL VARIABLES LIKE '%size%';
</pre><p>
                Wildcard characters can be used in any position within the
                pattern to be matched. Strictly speaking, because
                <code class="literal">_</code> is a wildcard that matches any single
                character, you should escape it as <code class="literal">\_</code> to
                match it literally. In practice, this is rarely necessary.
            </p><p style="color:blue;">通配符可用于要匹配的模式中的任何位置。严格地说，因为是一个与任何单个字符匹配的通配符，所以您应该将其转义为\，以逐字匹配它。实际上，这是很少必要的。</p>
            </div>
            <div class="section">
                <div class="titlepage">
                    <div>
                        <div>
                            <h4 class="title"><a name="show-warnings"></a>13.7.5.40&nbsp;SHOW WARNINGS Syntax</h4>

                        </div>

                    </div>

                </div>
                <a class="indexterm" name="idm140286825731440"></a><a class="indexterm" name="idm140286825730368"></a><pre data-lang="sql" class="programlisting">SHOW WARNINGS [LIMIT [<em class="replaceable"><code>offset</code></em>,] <em class="replaceable"><code>row_count</code></em>]
SHOW COUNT(*) WARNINGS
</pre><p>
                <a class="link" href="sql-syntax.html#show-warnings" title="13.7.5.40&nbsp;SHOW WARNINGS Syntax"><code class="literal">SHOW WARNINGS</code></a> is a diagnostic
                statement that displays information about the conditions
                (errors, warnings, and notes) resulting from executing a
                statement in the current session. Warnings are generated for DML
                statements such as <a class="link" href="sql-syntax.html#insert" title="13.2.5&nbsp;INSERT Syntax"><code class="literal">INSERT</code></a>,
                <a class="link" href="sql-syntax.html#update" title="13.2.11&nbsp;UPDATE Syntax"><code class="literal">UPDATE</code></a>, and
                <a class="link" href="sql-syntax.html#load-data" title="13.2.6&nbsp;LOAD DATA Syntax"><code class="literal">LOAD DATA</code></a> as well as DDL
                statements such as <a class="link" href="sql-syntax.html#create-table" title="13.1.18&nbsp;CREATE TABLE Syntax"><code class="literal">CREATE TABLE</code></a>
                and <a class="link" href="sql-syntax.html#alter-table" title="13.1.8&nbsp;ALTER TABLE Syntax"><code class="literal">ALTER TABLE</code></a>.
            </p><p style="color:blue;">show warnings是一个诊断语句，它显示有关在当前会话中执行语句所导致的条件（错误、警告和注释）的信息。对dml语句（如insert、update和load data）以及ddl语句（如create table和alter table）生成警告。</p><p>
                The <code class="literal">LIMIT</code> clause has the same syntax as for
                the <a class="link" href="sql-syntax.html#select" title="13.2.9&nbsp;SELECT Syntax"><code class="literal">SELECT</code></a> statement. See
                <a class="xref" href="sql-syntax.html#select" title="13.2.9&nbsp;SELECT Syntax">Section&nbsp;13.2.9, “SELECT Syntax”</a>.
            </p><p style="color:blue;">LIMIT子句的语法与SELECT语句的语法相同。参见第13.2.9节“选择语法”。</p><p>
                <a class="link" href="sql-syntax.html#show-warnings" title="13.7.5.40&nbsp;SHOW WARNINGS Syntax"><code class="literal">SHOW WARNINGS</code></a> is also used
                following <a class="link" href="sql-syntax.html#explain" title="13.8.2&nbsp;EXPLAIN Syntax"><code class="literal">EXPLAIN</code></a>, to display the
                extended information generated by
                <a class="link" href="sql-syntax.html#explain" title="13.8.2&nbsp;EXPLAIN Syntax"><code class="literal">EXPLAIN</code></a>. See
                <a class="xref" href="optimization.html#explain-extended" title="8.8.3&nbsp;Extended EXPLAIN Output Format">Section&nbsp;8.8.3, “Extended EXPLAIN Output Format”</a>.
            </p><p style="color:blue;">show warnings还用于显示explain生成的扩展信息。见第8.8.3节，“扩展解释输出格式”。</p><p>
                <a class="link" href="sql-syntax.html#show-warnings" title="13.7.5.40&nbsp;SHOW WARNINGS Syntax"><code class="literal">SHOW WARNINGS</code></a> displays
                information about the conditions resulting from execution of the
                most recent nondiagnostic statement in the current session. If
                the most recent statement resulted in an error during parsing,
                <a class="link" href="sql-syntax.html#show-warnings" title="13.7.5.40&nbsp;SHOW WARNINGS Syntax"><code class="literal">SHOW WARNINGS</code></a> shows the resulting
                conditions, regardless of statement type (diagnostic or
                nondiagnostic).
            </p><p style="color:blue;">show warnings显示有关在当前会话中执行最新的非诊断语句所导致的条件的信息。如果最新的语句在解析期间导致错误，show warnings将显示结果条件，而不考虑语句类型（诊断或非诊断）。</p><p>
                The <a class="link" href="sql-syntax.html#show-warnings" title="13.7.5.40&nbsp;SHOW WARNINGS Syntax"><code class="literal">SHOW COUNT(*)
                WARNINGS</code></a> diagnostic statement displays the total
                number of errors, warnings, and notes. You can also retrieve
                this number from the
                <a class="link" href="server-administration.html#sysvar_warning_count"><code class="literal">warning_count</code></a> system variable:
            </p><p style="color:blue;">show count（*）warnings诊断语句显示错误、警告和注释的总数。您还可以从warning_count系统变量中检索此数字：</p><pre data-lang="sql" class="programlisting">SHOW COUNT(*) WARNINGS;
SELECT @@warning_count;
</pre><p>
                A difference in these statements is that the first is a
                diagnostic statement that does not clear the message list. The
                second, because it is a <a class="link" href="sql-syntax.html#select" title="13.2.9&nbsp;SELECT Syntax"><code class="literal">SELECT</code></a>
                statement is considered nondiagnostic and does clear the message
                list.
            </p><p style="color:blue;">这些语句中的一个区别是，第一个语句是不清除消息列表的诊断语句。第二个，因为它是一个select语句，所以被认为是非诊断性的，并且确实清除了消息列表。</p><p>
                A related diagnostic statement, <a class="link" href="sql-syntax.html#show-errors" title="13.7.5.17&nbsp;SHOW ERRORS Syntax"><code class="literal">SHOW
                ERRORS</code></a>, shows only error conditions (it excludes
                warnings and notes), and
                <a class="link" href="sql-syntax.html#show-warnings" title="13.7.5.40&nbsp;SHOW WARNINGS Syntax"><code class="literal">SHOW COUNT(*)
                    ERRORS</code></a> statement displays the total number of errors.
                See <a class="xref" href="sql-syntax.html#show-errors" title="13.7.5.17&nbsp;SHOW ERRORS Syntax">Section&nbsp;13.7.5.17, “SHOW ERRORS Syntax”</a>. <a class="link" href="sql-syntax.html#get-diagnostics" title="13.6.7.3&nbsp;GET DIAGNOSTICS Syntax"><code class="literal">GET
                DIAGNOSTICS</code></a> can be used to examine information for
                individual conditions. See <a class="xref" href="sql-syntax.html#get-diagnostics" title="13.6.7.3&nbsp;GET DIAGNOSTICS Syntax">Section&nbsp;13.6.7.3, “GET DIAGNOSTICS Syntax”</a>.
            </p><p style="color:blue;">相关的诊断语句show errors只显示错误条件（不包括警告和注释），show count（*）errors语句显示错误总数。见第13.7.5.17节“显示错误语法”。get diagnostics可用于检查个别情况的信息。参见第13.6.7.3节“获取诊断语法”。</p><p>
                Here is a simple example that shows data-conversion warnings for
                <a class="link" href="sql-syntax.html#insert" title="13.2.5&nbsp;INSERT Syntax"><code class="literal">INSERT</code></a>. The example assumes that
                strict SQL mode is disabled. With strict mode enabled, the
                warnings would become errors and terminate the
                <a class="link" href="sql-syntax.html#insert" title="13.2.5&nbsp;INSERT Syntax"><code class="literal">INSERT</code></a>.
            </p><p style="color:blue;">下面是一个简单的示例，显示了insert的数据转换警告。该示例假设已禁用严格SQL模式。启用严格模式时，警告将变为错误并终止插入。</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>CREATE TABLE t1 (a TINYINT NOT NULL, b CHAR(4));</code></strong>
Query OK, 0 rows affected (0.05 sec)

mysql&gt; <strong class="userinput"><code>INSERT INTO t1 VALUES(10,'mysql'), (NULL,'test'), (300,'xyz');</code></strong>
Query OK, 3 rows affected, 3 warnings (0.00 sec)
Records: 3  Duplicates: 0  Warnings: 3

mysql&gt; <strong class="userinput"><code>SHOW WARNINGS\G</code></strong>
*************************** 1. row ***************************
  Level: Warning
   Code: 1265
Message: Data truncated for column 'b' at row 1
*************************** 2. row ***************************
  Level: Warning
   Code: 1048
Message: Column 'a' cannot be null
*************************** 3. row ***************************
  Level: Warning
   Code: 1264
Message: Out of range value for column 'a' at row 3
3 rows in set (0.00 sec)
</pre><p>
                The <a class="link" href="server-administration.html#sysvar_max_error_count"><code class="literal">max_error_count</code></a> system
                variable controls the maximum number of error, warning, and note
                messages for which the server stores information, and thus the
                number of messages that <a class="link" href="sql-syntax.html#show-warnings" title="13.7.5.40&nbsp;SHOW WARNINGS Syntax"><code class="literal">SHOW
                WARNINGS</code></a> displays. To change the number of messages
                the server can store, change the value of
                <a class="link" href="server-administration.html#sysvar_max_error_count"><code class="literal">max_error_count</code></a>. The default is
                64.
            </p><p style="color:blue;">Max GyErruryCurt系统变量控制服务器存储信息的最大错误数、警告和注释消息，从而控制显示警告的消息的数量。若要更改服务器可以存储的邮件数，请更改“最大错误计数”的值。默认值为64。</p><p>
                <a class="link" href="server-administration.html#sysvar_max_error_count"><code class="literal">max_error_count</code></a> controls only
                how many messages are stored, not how many are counted. The
                value of <a class="link" href="server-administration.html#sysvar_warning_count"><code class="literal">warning_count</code></a> is not
                limited by <a class="link" href="server-administration.html#sysvar_max_error_count"><code class="literal">max_error_count</code></a>,
                even if the number of messages generated exceeds
                <a class="link" href="server-administration.html#sysvar_max_error_count"><code class="literal">max_error_count</code></a>. The following
                example demonstrates this. The <a class="link" href="sql-syntax.html#alter-table" title="13.1.8&nbsp;ALTER TABLE Syntax"><code class="literal">ALTER
                TABLE</code></a> statement produces three warning messages
                (strict SQL mode is disabled for the example to prevent an error
                from occuring after a single conversion issue). Only one message
                is stored and displayed because
                <a class="link" href="server-administration.html#sysvar_max_error_count"><code class="literal">max_error_count</code></a> has been set to
                1, but all three are counted (as shown by the value of
                <a class="link" href="server-administration.html#sysvar_warning_count"><code class="literal">warning_count</code></a>):
            </p><p style="color:blue;">max_error_count只控制存储了多少条消息，而不是计数多少条。警告计数的值不受最大错误计数的限制，即使生成的消息数超过最大错误计数。下面的示例演示了这一点。alter table语句生成三条警告消息（示例中禁用了严格的sql模式，以防止在单个转换问题之后发生错误）。仅存储并显示一条消息，因为“最大错误计数”已设置为1，但三条消息都已计数（如“警告计数”值所示）：</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>SHOW VARIABLES LIKE 'max_error_count';</code></strong>
+-----------------+-------+
| Variable_name   | Value |
+-----------------+-------+
| max_error_count | 64    |
+-----------------+-------+
1 row in set (0.00 sec)

mysql&gt; <strong class="userinput"><code>SET max_error_count=1, sql_mode = '';</code></strong>
Query OK, 0 rows affected (0.00 sec)

mysql&gt; <strong class="userinput"><code>ALTER TABLE t1 MODIFY b CHAR;</code></strong>
Query OK, 3 rows affected, 3 warnings (0.00 sec)
Records: 3  Duplicates: 0  Warnings: 3

mysql&gt; <strong class="userinput"><code>SHOW WARNINGS;</code></strong>
+---------+------+----------------------------------------+
| Level   | Code | Message                                |
+---------+------+----------------------------------------+
| Warning | 1263 | Data truncated for column 'b' at row 1 |
+---------+------+----------------------------------------+
1 row in set (0.00 sec)

mysql&gt; <strong class="userinput"><code>SELECT @@warning_count;</code></strong>
+-----------------+
| @@warning_count |
+-----------------+
|               3 |
+-----------------+
1 row in set (0.01 sec)
</pre><p>
                To disable message storage, set
                <a class="link" href="server-administration.html#sysvar_max_error_count"><code class="literal">max_error_count</code></a> to 0. In this
                case, <a class="link" href="server-administration.html#sysvar_warning_count"><code class="literal">warning_count</code></a> still
                indicates how many warnings occurred, but messages are not
                stored and cannot be displayed.
            </p><p style="color:blue;">若要禁用邮件存储，请将“最大错误计数”设置为0。在这种情况下，warning_count仍然指示发生了多少个警告，但不会存储和显示消息。</p><p>
                The <a class="link" href="server-administration.html#sysvar_sql_notes"><code class="literal">sql_notes</code></a> system variable
                controls whether note messages increment
                <a class="link" href="server-administration.html#sysvar_warning_count"><code class="literal">warning_count</code></a> and whether the
                server stores them. By default,
                <a class="link" href="server-administration.html#sysvar_sql_notes"><code class="literal">sql_notes</code></a> is 1, but if set to
                0, notes do not increment
                <a class="link" href="server-administration.html#sysvar_warning_count"><code class="literal">warning_count</code></a> and the server
                does not store them:
            </p><p style="color:blue;">sql notes系统变量控制注释消息是否增加警告计数以及服务器是否存储它们。默认情况下，sql_notes为1，但如果设置为0，notes不会增加警告计数，服务器不会存储它们：</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>SET sql_notes = 1;</code></strong>
mysql&gt; <strong class="userinput"><code>DROP TABLE IF EXISTS test.no_such_table;</code></strong>
Query OK, 0 rows affected, 1 warning (0.00 sec)
mysql&gt; <strong class="userinput"><code>SHOW WARNINGS;</code></strong>
+-------+------+------------------------------------+
| Level | Code | Message                            |
+-------+------+------------------------------------+
| Note  | 1051 | Unknown table 'test.no_such_table' |
+-------+------+------------------------------------+
1 row in set (0.00 sec)

mysql&gt; <strong class="userinput"><code>SET sql_notes = 0;</code></strong>
mysql&gt; <strong class="userinput"><code>DROP TABLE IF EXISTS test.no_such_table;</code></strong>
Query OK, 0 rows affected (0.00 sec)
mysql&gt; <strong class="userinput"><code>SHOW WARNINGS;</code></strong>
Empty set (0.00 sec)
</pre><p>
                The MySQL server sends to each client a count indicating the
                total number of errors, warnings, and notes resulting from the
                most recent statement executed by that client. From the C API,
                this value can be obtained by calling
                <a class="link" href="connectors-apis.html#mysql-warning-count" title="27.8.7.78&nbsp;mysql_warning_count()"><code class="literal">mysql_warning_count()</code></a>. See
                <a class="xref" href="connectors-apis.html#mysql-warning-count" title="27.8.7.78&nbsp;mysql_warning_count()">Section&nbsp;27.8.7.78, “mysql_warning_count()”</a>.
            </p><p style="color:blue;">mysql服务器向每个客户机发送一个计数，指示由该客户机执行的最新语句产生的错误、警告和注释的总数。从C API中，可以通过调用mysql_warning_count（）获取此值。见27.8.7.78节，“mysql_warning_count（）”。</p><p>
                In the <a class="link" href="programs.html#mysql" title="4.5.1&nbsp;mysql — The MySQL Command-Line Client"><span class="command"><strong>mysql</strong></span></a> client, you can enable and
                disable automatic warnings display using the
                <code class="literal">warnings</code> and <code class="literal">nowarning</code>
                commands, respectively, or their shortcuts,
                <code class="literal">\W</code> and <code class="literal">\w</code> (see
                <a class="xref" href="programs.html#mysql-commands" title="4.5.1.2&nbsp;mysql Client Commands">Section&nbsp;4.5.1.2, “mysql Client Commands”</a>). For example:
            </p><p style="color:blue;">在mysql客户机中，您可以分别使用warnings和nowarning命令或它们的快捷方式w和w来启用和禁用自动警告显示（请参见第4.5.1.2节“mysql客户机命令”）。例如：</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>\W</code></strong>
Show warnings enabled.
mysql&gt; <strong class="userinput"><code>SELECT 1/0;</code></strong>
+------+
| 1/0  |
+------+
| NULL |
+------+
1 row in set, 1 warning (0.03 sec)

Warning (Code 1365): Division by 0
mysql&gt; <strong class="userinput"><code>\w</code></strong>
Show warnings disabled.
</pre>
            </div>

        </div>
        <div class="section">
            <div class="titlepage">
                <div>
                    <div>
                        <h3 class="title"><a name="other-administrative-sql"></a>13.7.6&nbsp;Other Administrative Statements</h3>

                    </div>

                </div>

            </div>
            <div class="toc">
                <dl class="toc"><dt><span class="section"><a href="sql-syntax.html#binlog">13.7.6.1 BINLOG Syntax</a></span></dt><dt><span class="section"><a href="sql-syntax.html#cache-index">13.7.6.2 CACHE INDEX Syntax</a></span></dt><dt><span class="section"><a href="sql-syntax.html#flush">13.7.6.3 FLUSH Syntax</a></span></dt><dt><span class="section"><a href="sql-syntax.html#kill">13.7.6.4 KILL Syntax</a></span></dt><dt><span class="section"><a href="sql-syntax.html#load-index">13.7.6.5 LOAD INDEX INTO CACHE Syntax</a></span></dt><dt><span class="section"><a href="sql-syntax.html#reset">13.7.6.6 RESET Syntax</a></span></dt><dt><span class="section"><a href="sql-syntax.html#shutdown">13.7.6.7 SHUTDOWN Syntax</a></span></dt></dl>
            </div>
            <div class="section">
                <div class="titlepage">
                    <div>
                        <div>
                            <h4 class="title"><a name="binlog"></a>13.7.6.1&nbsp;BINLOG Syntax</h4>

                        </div>

                    </div>

                </div>
                <a class="indexterm" name="idm140286825637680"></a><pre data-lang="sql" class="programlisting">BINLOG '<em class="replaceable"><code>str</code></em>'
</pre><p>
                <a class="link" href="sql-syntax.html#binlog" title="13.7.6.1&nbsp;BINLOG Syntax"><code class="literal">BINLOG</code></a> is an internal-use
                statement. It is generated by the <a class="link" href="programs.html#mysqlbinlog" title="4.6.7&nbsp;mysqlbinlog — Utility for Processing Binary Log Files"><span class="command"><strong>mysqlbinlog</strong></span></a>
                program as the printable representation of certain events in
                binary log files. (See <a class="xref" href="programs.html#mysqlbinlog" title="4.6.7&nbsp;mysqlbinlog — Utility for Processing Binary Log Files">Section&nbsp;4.6.7, “<span class="command"><strong>mysqlbinlog</strong></span> — Utility for Processing Binary Log Files”</a>.) The
                <code class="literal">'<em class="replaceable"><code>str</code></em>'</code> value is a
                base 64-encoded string the that server decodes to determine the
                data change indicated by the corresponding event. This statement
                requires the <a class="link" href="security.html#priv_super"><code class="literal">SUPER</code></a> privilege.
            </p><p style="color:blue;">binlog是一个内部use语句。它由mysqlbinlog程序生成，作为二进制日志文件中某些事件的可打印表示。（请参阅第4.6.7节，“mysqlbinlog-处理二进制日志文件的实用程序”。）str值是一个基本的64编码字符串，服务器对其进行解码，以确定由相应事件指示的数据更改。此语句需要超级特权。</p><p>
                This statement can execute only format description events and
                row events.
            </p><p style="color:blue;">此语句只能执行格式描述事件和行事件。</p>
            </div>
            <div class="section">
                <div class="titlepage">
                    <div>
                        <div>
                            <h4 class="title"><a name="cache-index"></a>13.7.6.2&nbsp;CACHE INDEX Syntax</h4>

                        </div>

                    </div>

                </div>
                <a class="indexterm" name="idm140286825624384"></a><a class="indexterm" name="idm140286825623312"></a><a class="indexterm" name="idm140286825621824"></a><pre data-lang="sql" class="programlisting">CACHE INDEX {
      <em class="replaceable"><code>tbl_index_list</code></em> [, <em class="replaceable"><code>tbl_index_list</code></em>] ...
    | <em class="replaceable"><code>tbl_name</code></em> PARTITION (<em class="replaceable"><code>partition_list</code></em>)
  }
  IN <em class="replaceable"><code>key_cache_name</code></em>

<em class="replaceable"><code>tbl_index_list</code></em>:
  <em class="replaceable"><code>tbl_name</code></em> [{INDEX|KEY} (<em class="replaceable"><code>index_name</code></em>[, <em class="replaceable"><code>index_name</code></em>] ...)]

<em class="replaceable"><code>partition_list</code></em>: {
    <em class="replaceable"><code>partition_name</code></em>[, <em class="replaceable"><code>partition_name</code></em>] ...
  | ALL
}
</pre><p>
                The <a class="link" href="sql-syntax.html#cache-index" title="13.7.6.2&nbsp;CACHE INDEX Syntax"><code class="literal">CACHE INDEX</code></a> statement assigns
                table indexes to a specific key cache. It applies only to
                <code class="literal">MyISAM</code> tables, including partitioned
                <code class="literal">MyISAM</code> tables. After the indexes have been
                assigned, they can be preloaded into the cache if desired with
                <a class="link" href="sql-syntax.html#load-index" title="13.7.6.5&nbsp;LOAD INDEX INTO CACHE Syntax"><code class="literal">LOAD INDEX INTO
                    CACHE</code></a>.
            </p><p style="color:blue;">cache index语句将表索引分配给特定的键缓存。它只适用于myisam表，包括分区的myisam表。分配索引后，如果需要，可以将它们预加载到缓存中，并将索引加载到缓存中。</p><p>
                The following statement assigns indexes from the tables
                <code class="literal">t1</code>, <code class="literal">t2</code>, and
                <code class="literal">t3</code> to the key cache named
                <code class="literal">hot_cache</code>:
            </p><p style="color:blue;">以下语句将表T1、T2和T3中的索引分配给名为hot_cache的密钥缓存：</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>CACHE INDEX t1, t2, t3 IN hot_cache;</code></strong>
+---------+--------------------+----------+----------+
| Table   | Op                 | Msg_type | Msg_text |
+---------+--------------------+----------+----------+
| test.t1 | assign_to_keycache | status   | OK       |
| test.t2 | assign_to_keycache | status   | OK       |
| test.t3 | assign_to_keycache | status   | OK       |
+---------+--------------------+----------+----------+
</pre><p>
                The syntax of <a class="link" href="sql-syntax.html#cache-index" title="13.7.6.2&nbsp;CACHE INDEX Syntax"><code class="literal">CACHE INDEX</code></a> enables
                you to specify that only particular indexes from a table should
                be assigned to the cache. However, the implementation assigns
                all the table's indexes to the cache, so there is no reason to
                specify anything other than the table name.
            </p><p style="color:blue;">缓存索引的语法使您能够指定只应将表中的特定索引分配给缓存。但是，实现会将表的所有索引分配给缓存，因此除了表名之外，没有理由指定任何其他内容。</p><p>
                The key cache referred to in a <a class="link" href="sql-syntax.html#cache-index" title="13.7.6.2&nbsp;CACHE INDEX Syntax"><code class="literal">CACHE
                INDEX</code></a> statement can be created by setting its size
                with a parameter setting statement or in the server parameter
                settings. For example:
            </p><p style="color:blue;">通过使用参数设置语句或在服务器参数设置中设置其大小，可以创建cache index语句中引用的密钥缓存。例如：</p><pre data-lang="sql" class="programlisting">SET GLOBAL keycache1.key_buffer_size=128*1024;
</pre><p>
                Key cache parameters are accessed as members of a structured
                system variable. See
                <a class="xref" href="server-administration.html#structured-system-variables" title="5.1.8.3&nbsp;Structured System Variables">Section&nbsp;5.1.8.3, “Structured System Variables”</a>.
            </p><p style="color:blue;">关键缓存参数作为结构化系统变量的成员访问。见第5.1.8.3节“结构化系统变量”。</p><p>
                A key cache must exist before you assign indexes to it, or an
                error occurs:
            </p><p style="color:blue;">密钥缓存必须在分配索引之前存在，否则会发生错误：</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>CACHE INDEX t1 IN non_existent_cache;</code></strong>
ERROR 1284 (HY000): Unknown key cache 'non_existent_cache'
</pre><p>
                By default, table indexes are assigned to the main (default) key
                cache created at the server startup. When a key cache is
                destroyed, all indexes assigned to it are reassigned to the
                default key cache.
            </p><p style="color:blue;">默认情况下，表索引被分配给在服务器启动时创建的主（默认）键缓存。当密钥缓存被销毁时，分配给它的所有索引都将重新分配给默认密钥缓存。</p><p>
                Index assignment affects the server globally: If one client
                assigns an index to a given cache, this cache is used for all
                queries involving the index, no matter which client issues the
                queries.
            </p><p style="color:blue;">索引分配全局影响服务器：如果一个客户端将索引分配给给定的缓存，则无论哪个客户端发出查询，此缓存都将用于涉及索引的所有查询。</p><p>
                <a class="link" href="sql-syntax.html#cache-index" title="13.7.6.2&nbsp;CACHE INDEX Syntax"><code class="literal">CACHE INDEX</code></a> is supported for
                partitioned <code class="literal">MyISAM</code> tables. You can assign one
                or more indexes for one, several, or all partitions to a given
                key cache. For example, you can do the following:
            </p><p style="color:blue;">分区myisam表支持缓存索引。可以将一个、多个或所有分区的一个或多个索引分配给给定的密钥缓存。例如，可以执行以下操作：</p><pre data-lang="sql" class="programlisting">CREATE TABLE pt (c1 INT, c2 VARCHAR(50), INDEX i(c1))
    ENGINE=MyISAM
    PARTITION BY HASH(c1)
    PARTITIONS 4;

SET GLOBAL kc_fast.key_buffer_size = 128 * 1024;
SET GLOBAL kc_slow.key_buffer_size = 128 * 1024;

CACHE INDEX pt PARTITION (p0) IN kc_fast;
CACHE INDEX pt PARTITION (p1, p3) IN kc_slow;
</pre><p>
                The previous set of statements performs the following actions:
            </p><p style="color:blue;">前一组语句执行以下操作：</p>
                <div class="itemizedlist">
                    <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                        Creates a partitioned table with 4 partitions; these
                        partitions are automatically named <code class="literal">p0</code>,
                        ..., <code class="literal">p3</code>; this table has an index named
                        <code class="literal">i</code> on column <code class="literal">c1</code>.
                    </p><p style="color:blue;">创建一个有4个分区的分区表；这些分区自动命名为p0，…，p3；该表在列c1上有一个名为i的索引。</p></li><li class="listitem"><p>
                        Creates 2 key caches named <code class="literal">kc_fast</code> and
                        <code class="literal">kc_slow</code>
                    </p><p style="color:blue;">创建两个名为kc_fast和kc_slow的密钥缓存</p></li><li class="listitem"><p>
                        Assigns the index for partition <code class="literal">p0</code> to the
                        <code class="literal">kc_fast</code> key cache and the index for
                        partitions <code class="literal">p1</code> and <code class="literal">p3</code>
                        to the <code class="literal">kc_slow</code> key cache; the index for
                        the remaining partition (<code class="literal">p2</code>) uses the
                        server's default key cache.
                    </p><p style="color:blue;">将分区p0的索引分配给kc_快键缓存，将分区p1和p3的索引分配给kc_慢键缓存；其余分区（p2）的索引使用服务器的默认密钥缓存。</p></li></ul>
                </div>
                <p>
                    If you wish instead to assign the indexes for all partitions in
                    table <code class="literal">pt</code> to a single key cache named
                    <code class="literal">kc_all</code>, you can use either of the following
                    two statements:
                </p><p style="color:blue;">如果希望将表pt中所有分区的索引分配给名为kc_all的单键缓存，则可以使用以下两个语句之一：</p><pre data-lang="sql" class="programlisting">CACHE INDEX pt PARTITION (ALL) IN kc_all;

CACHE INDEX pt IN kc_all;
</pre><p>
                The two statements just shown are equivalent, and issuing either
                one has exactly the same effect. In other words, if you wish to
                assign indexes for all partitions of a partitioned table to the
                same key cache, the <code class="literal">PARTITION (ALL)</code> clause is
                optional.
            </p><p style="color:blue;">刚才显示的两个语句是等价的，并且发出其中一个语句的效果完全相同。换句话说，如果希望将分区表的所有分区的索引分配给同一个密钥缓存，则分区（ALL）子句是可选的。</p><p>
                When assigning indexes for multiple partitions to a key cache,
                the partitions need not be contiguous, and you need not list
                their names in any particular order. Indexes for any partitions
                not explicitly assigned to a key cache automatically use the
                server default key cache.
            </p><p style="color:blue;">将多个分区的索引分配给键缓存时，分区不必是连续的，也不必按任何特定顺序列出它们的名称。未显式分配给密钥缓存的任何分区的索引将自动使用服务器默认密钥缓存。</p><p>
                Index preloading is also supported for partitioned
                <code class="literal">MyISAM</code> tables. For more information, see
                <a class="xref" href="sql-syntax.html#load-index" title="13.7.6.5&nbsp;LOAD INDEX INTO CACHE Syntax">Section&nbsp;13.7.6.5, “LOAD INDEX INTO CACHE Syntax”</a>.
            </p><p style="color:blue;">分区myisam表也支持索引预加载。有关详细信息，请参阅第13.7.6.5节“将索引加载到缓存语法”。</p>
            </div>
            <div class="section">
                <div class="titlepage">
                    <div>
                        <div>
                            <h4 class="title"><a name="flush"></a>13.7.6.3&nbsp;FLUSH Syntax</h4>

                        </div>

                    </div>

                </div>
                <a class="indexterm" name="idm140286825567744"></a><a class="indexterm" name="idm140286825566672"></a><a class="indexterm" name="idm140286825565600"></a><a class="indexterm" name="idm140286825564112"></a><pre data-lang="sql" class="programlisting">FLUSH [NO_WRITE_TO_BINLOG | LOCAL] {
    <em class="replaceable"><code>flush_option</code></em> [, <em class="replaceable"><code>flush_option</code></em>] ...
  | <em class="replaceable"><code>tables_option</code></em>
}

<em class="replaceable"><code>flush_option</code></em>: {
    BINARY LOGS
  | DES_KEY_FILE
  | ENGINE LOGS
  | ERROR LOGS
  | GENERAL LOGS
  | HOSTS
  | LOGS
  | PRIVILEGES
  | OPTIMIZER_COSTS
  | QUERY CACHE
  | RELAY LOGS [FOR CHANNEL <em class="replaceable"><code>channel</code></em>]
  | SLOW LOGS
  | STATUS
  | USER_RESOURCES
}

<em class="replaceable"><code>tables_option</code></em>: {
    TABLES
  | TABLES <em class="replaceable"><code>tbl_name</code></em> [, <em class="replaceable"><code>tbl_name</code></em>] ...
  | TABLES WITH READ LOCK
  | TABLES <em class="replaceable"><code>tbl_name</code></em> [, <em class="replaceable"><code>tbl_name</code></em>] ... WITH READ LOCK
  | TABLES <em class="replaceable"><code>tbl_name</code></em> [, <em class="replaceable"><code>tbl_name</code></em>] ... FOR EXPORT
}
</pre><p>
                The <a class="link" href="sql-syntax.html#flush" title="13.7.6.3&nbsp;FLUSH Syntax"><code class="literal">FLUSH</code></a> statement has several
                variant forms that clear or reload various internal caches,
                flush tables, or acquire locks. To execute
                <a class="link" href="sql-syntax.html#flush" title="13.7.6.3&nbsp;FLUSH Syntax"><code class="literal">FLUSH</code></a>, you must have the
                <a class="link" href="security.html#priv_reload"><code class="literal">RELOAD</code></a> privilege. Specific flush
                options might require additional privileges, as described later.
            </p><p style="color:blue;">flush语句有几种不同的形式，用于清除或重新加载各种内部缓存、刷新表或获取锁。要执行刷新，您必须具有重新加载权限。如后文所述，特定的刷新选项可能需要额外的权限。</p>
                <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">

                    <div class="admon-title">
                        Note
                    </div>
                    <p>
                        It is not possible to issue
                        <a class="link" href="sql-syntax.html#flush" title="13.7.6.3&nbsp;FLUSH Syntax"><code class="literal">FLUSH</code></a> statements within stored
                        functions or triggers. However, you may use
                        <a class="link" href="sql-syntax.html#flush" title="13.7.6.3&nbsp;FLUSH Syntax"><code class="literal">FLUSH</code></a> in stored procedures, so
                        long as these are not called from stored functions or
                        triggers. See <a class="xref" href="stored-objects.html#stored-program-restrictions" title="23.8&nbsp;Restrictions on Stored Programs">Section&nbsp;23.8, “Restrictions on Stored Programs”</a>.
                    </p><p style="color:blue;">不能在存储的函数或触发器中发出flush语句。但是，您可以在存储过程中使用flush，只要这些过程不是从存储函数或触发器调用的。参见第23.8节“存储程序的限制”。</p>
                </div>
                <p>
                    By default, the server writes
                    <a class="link" href="sql-syntax.html#flush" title="13.7.6.3&nbsp;FLUSH Syntax"><code class="literal">FLUSH</code></a> statements to the binary
                    log so that they replicate to replication slaves. To suppress
                    logging, specify the optional
                    <code class="literal">NO_WRITE_TO_BINLOG</code> keyword or its alias
                    <code class="literal">LOCAL</code>.
                </p><p style="color:blue;">默认情况下，服务器将flush语句写入二进制日志，以便它们复制到复制从属服务器。要禁止日志记录，请指定可选的no_write_to_binlog关键字或其别名local。</p>
                <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">

                    <div class="admon-title">
                        Note
                    </div>
                    <p>
                        <a class="link" href="sql-syntax.html#flush-logs"><code class="literal">FLUSH LOGS</code></a>,
                        <a class="link" href="sql-syntax.html#flush-binary-logs"><code class="literal">FLUSH BINARY LOGS</code></a>,
                        <a class="link" href="sql-syntax.html#flush-tables-with-read-lock"><code class="literal">FLUSH TABLES WITH READ LOCK</code></a>
                        (with or without a table list), and
                        <a class="link" href="sql-syntax.html#flush-tables-for-export-with-list"><code class="literal">FLUSH
                            TABLES <em class="replaceable"><code>tbl_name</code></em> ... FOR
                            EXPORT</code></a> are not written to the binary log in any case
                        because they would cause problems if replicated to a slave.
                    </p><p style="color:blue;">刷新日志、刷新二进制日志、使用读锁刷新表（使用或不使用表列表）和刷新表tbl_name…for export在任何情况下都不会写入二进制日志，因为如果复制到从机上，它们会导致问题。</p>
                </div>
                <p>
                    The <a class="link" href="sql-syntax.html#flush" title="13.7.6.3&nbsp;FLUSH Syntax"><code class="literal">FLUSH</code></a> statement causes an
                    implicit commit. See <a class="xref" href="sql-syntax.html#implicit-commit" title="13.3.3&nbsp;Statements That Cause an Implicit Commit">Section&nbsp;13.3.3, “Statements That Cause an Implicit Commit”</a>.
                </p><p style="color:blue;">flush语句导致隐式提交。参见第13.3.3节，“导致隐式提交的语句”。</p><p>
                The <a class="link" href="programs.html#mysqladmin" title="4.5.2&nbsp;mysqladmin — Client for Administering a MySQL Server"><span class="command"><strong>mysqladmin</strong></span></a> utility provides a
                command-line interface to some flush operations, using commands
                such as <code class="literal">flush-hosts</code>,
                <code class="literal">flush-logs</code>,
                <code class="literal">flush-privileges</code>,
                <code class="literal">flush-status</code>, and
                <code class="literal">flush-tables</code>. See
                <a class="xref" href="programs.html#mysqladmin" title="4.5.2&nbsp;mysqladmin — Client for Administering a MySQL Server">Section&nbsp;4.5.2, “<span class="command"><strong>mysqladmin</strong></span> — Client for Administering a MySQL Server”</a>.
            </p><p style="color:blue;">mysqladmin实用程序使用诸如flush hosts、flush logs、flush privileges、flush status和flush tables等命令为某些刷新操作提供了命令行界面。请参阅4.5.2节，“mysqladmin-用于管理mysql服务器的客户端”。</p><p>
                Sending a <code class="literal">SIGHUP</code> signal to the server causes
                several flush operations to occur that are similar to various
                forms of the <a class="link" href="sql-syntax.html#flush" title="13.7.6.3&nbsp;FLUSH Syntax"><code class="literal">FLUSH</code></a> statement. See
                <a class="xref" href="server-administration.html#server-signal-response" title="5.1.15&nbsp;Server Response to Signals">Section&nbsp;5.1.15, “Server Response to Signals”</a>.
            </p><p style="color:blue;">向服务器发送sighup信号会导致发生一些与flush语句的各种形式类似的刷新操作。见第5.1.15节，“服务器对信号的响应”。</p><p>
                The <a class="link" href="sql-syntax.html#reset" title="13.7.6.6&nbsp;RESET Syntax"><code class="literal">RESET</code></a> statement is similar to
                <a class="link" href="sql-syntax.html#flush" title="13.7.6.3&nbsp;FLUSH Syntax"><code class="literal">FLUSH</code></a>. See
                <a class="xref" href="sql-syntax.html#reset" title="13.7.6.6&nbsp;RESET Syntax">Section&nbsp;13.7.6.6, “RESET Syntax”</a>, for information about using the
                <a class="link" href="sql-syntax.html#reset" title="13.7.6.6&nbsp;RESET Syntax"><code class="literal">RESET</code></a> statement with replication.
            </p><p style="color:blue;">reset语句类似于flush。有关在复制中使用reset语句的信息，请参阅第13.7.6.6节“reset syntax”。</p><p>
                The following list describes the permitted
                <a class="link" href="sql-syntax.html#flush" title="13.7.6.3&nbsp;FLUSH Syntax"><code class="literal">FLUSH</code></a> statement
                <em class="replaceable"><code>flush_option</code></em> values. For descriptions
                of <a class="link" href="sql-syntax.html#flush-tables-variants" title="FLUSH TABLES Syntax"><code class="literal">FLUSH
                TABLES</code></a> variants, see
                <a class="xref" href="sql-syntax.html#flush-tables-variants" title="FLUSH TABLES Syntax">FLUSH TABLES Syntax</a>.
            </p><p style="color:blue;">下表描述了允许的flush语句flush_选项值。有关刷新表变量的说明，请参见刷新表语法。</p>
                <div class="itemizedlist">
                    <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><a name="flush-binary-logs"></a>
                        <a class="link" href="sql-syntax.html#flush-binary-logs"><code class="literal">FLUSH BINARY LOGS</code></a>
                    </p><p style="color:blue;">刷新二进制日志</p><p>
                        Closes and reopens any binary log file to which the server
                        is writing. If binary logging is enabled, the sequence
                        number of the binary log file is incremented by one relative
                        to the previous file.
                    </p><p style="color:blue;">关闭并重新打开服务器正在写入的任何二进制日志文件。如果启用了二进制日志记录，则二进制日志文件的序列号相对于上一个文件递增一。</p></li><li class="listitem"><p><a name="flush-des-key-file"></a>
                        <a class="link" href="sql-syntax.html#flush-des-key-file"><code class="literal">FLUSH DES_KEY_FILE</code></a>
                    </p><p style="color:blue;">刷新des_key_文件</p><p>
                        Reloads the DES keys from the file that was specified with
                        the <a class="link" href="server-administration.html#option_mysqld_des-key-file"><code class="option">--des-key-file</code></a> option at
                        server startup time.
                    </p><p style="color:blue;">从服务器启动时用--des key file选项指定的文件重新加载des密钥。</p>
                        <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">

                            <div class="admon-title">
                                Note
                            </div>
                            <p>
                                The <a class="link" href="functions.html#function_des-encrypt"><code class="literal">DES_ENCRYPT()</code></a> and
                                <a class="link" href="functions.html#function_des-decrypt"><code class="literal">DES_DECRYPT()</code></a> functions are
                                deprecated as of MySQL 5.7.6, will be removed in a future
                                MySQL release, and should no longer be used. Consequently,
                                <a class="link" href="server-administration.html#option_mysqld_des-key-file"><code class="option">--des-key-file</code></a> and
                                <code class="literal">DES_KEY_FILE</code> also are deprecated and
                                will be removed.
                            </p><p style="color:blue;">从mysql 5.7.6开始，des_encrypt（）和des_decrypt（）函数已被弃用，将在以后的mysql版本中删除，并且不再使用。因此，-des key file和des_key_file也被弃用，并将被删除。</p>
                        </div>
                    </li><li class="listitem"><p><a name="flush-engine-logs"></a>
                        <a class="link" href="sql-syntax.html#flush-engine-logs"><code class="literal">FLUSH ENGINE LOGS</code></a>
                    </p><p style="color:blue;">冲洗发动机日志</p><p>
                        Closes and reopens any flushable logs for installed storage
                        engines. This causes <code class="literal">InnoDB</code> to flush its
                        logs to disk.
                    </p><p style="color:blue;">关闭并重新打开已安装存储引擎的任何可刷新日志。这导致innodb将其日志刷新到磁盘。</p></li><li class="listitem"><p><a name="flush-error-logs"></a>
                        <a class="link" href="sql-syntax.html#flush-error-logs"><code class="literal">FLUSH ERROR LOGS</code></a>
                    </p><p style="color:blue;">刷新错误日志</p><p>
                        Closes and reopens any error log file to which the server is
                        writing.
                    </p><p style="color:blue;">关闭并重新打开服务器正在写入的任何错误日志文件。</p></li><li class="listitem"><p><a name="flush-general-logs"></a>
                        <a class="link" href="sql-syntax.html#flush-general-logs"><code class="literal">FLUSH GENERAL LOGS</code></a>
                    </p><p style="color:blue;">刷新常规日志</p><p>
                        Closes and reopens any general query log file to which the
                        server is writing.
                    </p><p style="color:blue;">关闭并重新打开服务器正在写入的任何常规查询日志文件。</p></li><li class="listitem"><p><a name="flush-hosts"></a>
                        <a class="link" href="sql-syntax.html#flush-hosts"><code class="literal">FLUSH HOSTS</code></a>
                    </p><p style="color:blue;">刷新主机</p><p>
                        Empties the host cache and the Performance Schema
                        <a class="link" href="performance-schema.html#host-cache-table" title="25.12.16.1&nbsp;The host_cache Table"><code class="literal">host_cache</code></a> table that exposes
                        the cache contents, and unblocks any blocked hosts. See
                        <a class="xref" href="optimization.html#host-cache" title="8.12.5.2&nbsp;DNS Lookup Optimization and the Host Cache">Section&nbsp;8.12.5.2, “DNS Lookup Optimization and the Host Cache”</a>.
                    </p><p style="color:blue;">清空主机缓存和显示缓存内容的性能架构主机缓存表，并取消阻止任何被阻止的主机。参见第8.12.5.2节“DNS查找优化和主机缓存”。</p><p>
                        Flush the host cache if some of your hosts change IP address
                        or if the error message <code class="literal">Host
                        '<em class="replaceable"><code>host_name</code></em>' is blocked</code>
                        occurs for connections from legitimate hosts. (See
                        <a class="xref" href="error-handling.html#blocked-host" title="B.4.2.5&nbsp;Host 'host_name' is blocked">Section&nbsp;B.4.2.5, “Host 'host_name' is blocked”</a>.) When more than
                        <a class="link" href="server-administration.html#sysvar_max_connect_errors"><code class="literal">max_connect_errors</code></a> errors
                        occur successively for a given host while connecting to the
                        MySQL server, MySQL assumes that something is wrong and
                        blocks the host from further connection requests. Flushing
                        the host cache enables further connection attempts from the
                        host. The default value of
                        <a class="link" href="server-administration.html#sysvar_max_connect_errors"><code class="literal">max_connect_errors</code></a> is 100.
                        To avoid this error message, start the server with
                        <a class="link" href="server-administration.html#sysvar_max_connect_errors"><code class="literal">max_connect_errors</code></a> set to a
                        large value.
                    </p><p style="color:blue;">如果某些主机更改了IP地址，或者如果来自合法主机的连接出现错误消息“主机名”被阻止，则刷新主机缓存。（请参阅第B.4.2.5节，“主机'主机名'被阻止”。）当连接到MySQL服务器时，给定主机连续出现超过max_connect_的错误时，MySQL会假设有问题，并阻止主机进一步的连接请求。刷新主机缓存将启用来自主机的进一步连接尝试。最大连接错误的默认值是100。若要避免此错误消息，请在max_connect_errors设置为大值的情况下启动服务器。</p></li><li class="listitem"><p><a name="flush-logs"></a>
                        <a class="link" href="sql-syntax.html#flush-logs"><code class="literal">FLUSH LOGS</code></a>
                    </p><p style="color:blue;">刷新日志</p><p>
                        Closes and reopens any log file to which the server is
                        writing. If binary logging is enabled, the sequence number
                        of the binary log file is incremented by one relative to the
                        previous file. If relay logging is enabled, the sequence
                        number of the relay log file is incremented by one relative
                        to the previous file.
                    </p><p style="color:blue;">关闭并重新打开服务器正在写入的任何日志文件。如果启用了二进制日志记录，则二进制日志文件的序列号相对于上一个文件递增一。如果启用中继日志记录，则中继日志文件的序列号相对于上一个文件递增一。</p><p>
                        <a class="link" href="sql-syntax.html#flush-logs"><code class="literal">FLUSH LOGS</code></a> has no effect on
                        tables used for the general query log or for the slow query
                        log (see <a class="xref" href="server-administration.html#log-destinations" title="5.4.1&nbsp;Selecting General Query Log and Slow Query Log Output Destinations">Section&nbsp;5.4.1, “Selecting General Query Log and Slow Query Log Output Destinations”</a>).
                    </p><p style="color:blue;">刷新日志对用于常规查询日志或慢速查询日志的表没有影响（请参阅第5.4.1节“选择常规查询日志和慢速查询日志输出目标”）。</p></li><li class="listitem"><p><a name="flush-optimizer-costs"></a>
                        <a class="link" href="sql-syntax.html#flush-optimizer-costs"><code class="literal">FLUSH OPTIMIZER_COSTS</code></a>
                    </p><p style="color:blue;">刷新优化器成本</p><p>
                        Rereads the cost model tables so that the optimizer starts
                        using the current cost estimates stored in them. The server
                        writes a warning to the error log for any unrecognized
                        entries. (For information about these tables, see
                        <a class="xref" href="optimization.html#cost-model" title="8.9.5&nbsp;The Optimizer Cost Model">Section&nbsp;8.9.5, “The Optimizer Cost Model”</a>.) This operation affects only
                        sessions that begin subsequent to the flush. Existing
                        sessions continue to use the cost estimates that were
                        current when they began.
                    </p><p style="color:blue;">重新读取成本模型表，以便优化器开始使用存储在其中的当前成本估算。服务器将任何无法识别的条目的警告写入错误日志。（有关这些表的信息，请参阅8.9.5节，“优化器成本模型”。）此操作仅影响在刷新之后开始的会话。现有会话继续使用当前开始时的成本估计。</p></li><li class="listitem"><p><a name="flush-privileges"></a>
                        <a class="link" href="sql-syntax.html#flush-privileges"><code class="literal">FLUSH PRIVILEGES</code></a>
                    </p><p style="color:blue;">刷新权限</p><p>
                        Reloads the privileges from the grant tables in the
                        <code class="literal">mysql</code> system database.
                    </p><p style="color:blue;">从mysql系统数据库中的grant表重新加载权限。</p><p>
                        The server caches information in memory as a result of
                        <a class="link" href="sql-syntax.html#grant" title="13.7.1.4&nbsp;GRANT Syntax"><code class="literal">GRANT</code></a>,
                        <a class="link" href="sql-syntax.html#create-user" title="13.7.1.2&nbsp;CREATE USER Syntax"><code class="literal">CREATE USER</code></a>,
                        <a class="link" href="sql-syntax.html#create-server" title="13.1.17&nbsp;CREATE SERVER Syntax"><code class="literal">CREATE SERVER</code></a>, and
                        <a class="link" href="sql-syntax.html#install-plugin" title="13.7.3.3&nbsp;INSTALL PLUGIN Syntax"><code class="literal">INSTALL PLUGIN</code></a> statements.
                        This memory is not released by the corresponding
                        <a class="link" href="sql-syntax.html#revoke" title="13.7.1.6&nbsp;REVOKE Syntax"><code class="literal">REVOKE</code></a>,
                        <a class="link" href="sql-syntax.html#drop-user" title="13.7.1.3&nbsp;DROP USER Syntax"><code class="literal">DROP USER</code></a>,
                        <a class="link" href="sql-syntax.html#drop-server" title="13.1.28&nbsp;DROP SERVER Syntax"><code class="literal">DROP SERVER</code></a>, and
                        <a class="link" href="sql-syntax.html#uninstall-plugin" title="13.7.3.4&nbsp;UNINSTALL PLUGIN Syntax"><code class="literal">UNINSTALL PLUGIN</code></a> statements,
                        so for a server that executes many instances of the
                        statements that cause caching, there will be an increase in
                        memory use. This cached memory can be freed with
                        <a class="link" href="sql-syntax.html#flush-privileges"><code class="literal">FLUSH PRIVILEGES</code></a>.
                    </p><p style="color:blue;">由于grant、create user、create server和install plugin语句，服务器将信息缓存在内存中。相应的revoke、drop user、drop server和uninstall plugin语句不会释放此内存，因此对于执行导致缓存的语句的多个实例的服务器，内存使用将增加。可以使用刷新权限释放此缓存内存。</p></li><li class="listitem"><p><a name="flush-query-cache"></a>
                        <a class="link" href="sql-syntax.html#flush-query-cache"><code class="literal">FLUSH QUERY CACHE</code></a>
                    </p><p style="color:blue;">刷新查询缓存</p><p>
                        Defragment the query cache to better utilize its memory.
                        <a class="link" href="sql-syntax.html#flush-query-cache"><code class="literal">FLUSH QUERY CACHE</code></a> does not
                        remove any queries from the cache, unlike
                        <a class="link" href="sql-syntax.html#flush-tables"><code class="literal">FLUSH TABLES</code></a> or
                        <code class="literal">RESET QUERY CACHE</code>.
                    </p><p style="color:blue;">对查询缓存进行碎片整理以更好地利用其内存。刷新查询缓存不会从缓存中删除任何查询，这与刷新表或重置查询缓存不同。</p>
                        <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">

                            <div class="admon-title">
                                Note
                            </div>
                            <p>
                                The query cache is deprecated as of MySQL 5.7.20, and is
                                removed in MySQL 8.0. Deprecation includes
                                <a class="link" href="sql-syntax.html#flush-query-cache"><code class="literal">FLUSH QUERY CACHE</code></a>.
                            </p><p style="color:blue;">从mysql 5.7.20开始，查询缓存已被弃用，并在mysql 8.0中被删除。不推荐包括刷新查询缓存。</p>
                        </div>
                    </li><li class="listitem"><p><a name="flush-relay-logs"></a>
                        <a class="link" href="sql-syntax.html#flush-relay-logs"><code class="literal">FLUSH
                            RELAY LOGS [FOR CHANNEL
                            <em class="replaceable"><code>channel</code></em>]</code></a>
                    </p><p style="color:blue;">刷新中继日志[用于通道通道]</p><p>
                        Closes and reopens any relay log file to which the server is
                        writing. If relay logging is enabled, the sequence number of
                        the relay log file is incremented by one relative to the
                        previous file.
                    </p><p style="color:blue;">关闭并重新打开服务器正在写入的任何中继日志文件。如果启用中继日志记录，则中继日志文件的序列号相对于上一个文件递增一。</p><p>
                        The <code class="literal">FOR CHANNEL
                        <em class="replaceable"><code>channel</code></em></code> clause enables
                        you to name which replication channel the statement applies
                        to. Execute
                        <a class="link" href="sql-syntax.html#flush-relay-logs"><code class="literal">FLUSH
                            RELAY LOGS FOR CHANNEL
                            <em class="replaceable"><code>channel</code></em></code></a> to flush the
                        relay log for a specific replication channel. If no channel
                        is named and no extra replication channels exist, the
                        statement applies to the default channel. If no channel is
                        named and multiple replication channels exist, the statement
                        applies to all replication channels, with the exception of
                        the <code class="literal">group_replication_applier</code> channel.
                        For more information, see
                        <a class="xref" href="replication.html#replication-channels" title="16.2.3&nbsp;Replication Channels">Section&nbsp;16.2.3, “Replication Channels”</a>.
                    </p><p style="color:blue;">for channel channel子句允许您命名该语句应用于哪个复制通道。执行通道通道的刷新中继日志以刷新特定复制通道的中继日志。如果没有命名通道，并且没有额外的复制通道，则该语句应用于默认通道。如果没有命名信道，并且存在多个复制通道，则该语句适用于所有复制通道，除了GROPUPDATICORIPApple通道之外。有关更多信息，请参阅第16.2.3节“复制通道”。</p></li><li class="listitem"><p><a name="flush-slow-logs"></a>
                        <a class="link" href="sql-syntax.html#flush-slow-logs"><code class="literal">FLUSH SLOW LOGS</code></a>
                    </p><p style="color:blue;">刷新慢日志</p><p>
                        Closes and reopens any slow query log file to which the
                        server is writing.
                    </p><p style="color:blue;">关闭并重新打开服务器正在写入的任何慢速查询日志文件。</p></li><li class="listitem"><p><a name="flush-status"></a>
                        <a class="link" href="sql-syntax.html#flush-status"><code class="literal">FLUSH STATUS</code></a>
                    </p><p style="color:blue;">刷新状态</p>
                        <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">

                            <div class="admon-title">
                                Note
                            </div>
                            <p>
                                The value of the
                                <a class="link" href="server-administration.html#sysvar_show_compatibility_56"><code class="literal">show_compatibility_56</code></a>
                                system variable affects the operation of this option. For
                                details, see the description of that variable in
                                <a class="xref" href="server-administration.html#server-system-variables" title="5.1.7&nbsp;Server System Variables">Section&nbsp;5.1.7, “Server System Variables”</a>.
                            </p><p style="color:blue;">show_compatibility_系统变量的值会影响此选项的操作。有关详细信息，请参阅第5.1.7节“服务器系统变量”中对该变量的描述。</p>
                        </div>
                        <p>
                            This option adds the current thread's session status
                            variable values to the global values and resets the session
                            values to zero. Some global variables may be reset to zero
                            as well. It also resets the counters for key caches (default
                            and named) to zero and sets
                            <a class="link" href="server-administration.html#statvar_Max_used_connections"><code class="literal">Max_used_connections</code></a> to
                            the current number of open connections. This information may
                            be of use when debugging a query. See
                            <a class="xref" href="introduction.html#bug-reports" title="1.7&nbsp;How to Report Bugs or Problems">Section&nbsp;1.7, “How to Report Bugs or Problems”</a>.
                        </p><p style="color:blue;">此选项将当前线程的会话状态变量值添加到全局值，并将会话值重置为零。一些全局变量也可能重置为零。它还将密钥缓存（默认和命名）的计数器重置为零，并将max_used_connections设置为当前打开的连接数。此信息在调试查询时可能有用。参见第1.7节“如何报告错误或问题”。</p></li><li class="listitem"><p><a name="flush-user-resources"></a>
                        <a class="link" href="sql-syntax.html#flush-user-resources"><code class="literal">FLUSH USER_RESOURCES</code></a>
                    </p><p style="color:blue;">刷新用户资源</p><p>
                        Resets all per-hour user resources to zero. This enables
                        clients that have reached their hourly connection, query, or
                        update limits to resume activity immediately.
                        <a class="link" href="sql-syntax.html#flush-user-resources"><code class="literal">FLUSH USER_RESOURCES</code></a> does not
                        apply to the limit on maximum simultaneous connections that
                        is controlled by the
                        <a class="link" href="server-administration.html#sysvar_max_user_connections"><code class="literal">max_user_connections</code></a> system
                        variable. See <a class="xref" href="security.html#user-resources" title="6.2.16&nbsp;Setting Account Resource Limits">Section&nbsp;6.2.16, “Setting Account Resource Limits”</a>.
                    </p><p style="color:blue;">将每小时的所有用户资源重置为零。这使已达到每小时连接、查询或更新限制的客户端能够立即恢复活动。同花顺不适用于由系统变量控制的最大同时连接的限制。见第6.2.16节“设置账户资源限制”。</p></li></ul>
                </div>
                <h5><a name="flush-tables-variants"></a>FLUSH TABLES Syntax</h5>
                <p>
                    <a class="link" href="sql-syntax.html#flush-tables"><code class="literal">FLUSH TABLES</code></a> flushes tables, and,
                    depending on the variant used, acquires locks. Any
                    <code class="literal">TABLES</code> variant used in a
                    <a class="link" href="sql-syntax.html#flush" title="13.7.6.3&nbsp;FLUSH Syntax"><code class="literal">FLUSH</code></a> statement must be the only
                    option used. <a class="link" href="sql-syntax.html#flush-tables"><code class="literal">FLUSH
                    TABLE</code></a> is a synonym for <a class="link" href="sql-syntax.html#flush-tables"><code class="literal">FLUSH
                    TABLES</code></a>.
                </p><p style="color:blue;">flush tables刷新表，并根据使用的变量获取锁。flush语句中使用的任何表变量都必须是唯一使用的选项。flush table是flush tables的同义词。</p>
                <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">

                    <div class="admon-title">
                        Note
                    </div>
                    <p>
                        The descriptions here that indicate tables are flushed by
                        closing them apply differently for <code class="literal">InnoDB</code>,
                        which flushes table contents to disk but leaves them open.
                        This still permits table files to be copied while the tables
                        are open, as long as other activity does not modify them.
                    </p><p style="color:blue;">这里表示通过关闭表来刷新表的描述对innodb的应用不同，innodb将表内容刷新到磁盘，但将其保留为打开状态。这仍然允许在表打开时复制表文件，只要其他活动不修改它们。</p>
                </div>
                <div class="itemizedlist">
                    <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><a name="flush-tables"></a>
                        <a class="link" href="sql-syntax.html#flush-tables"><code class="literal">FLUSH TABLES</code></a>
                    </p><p style="color:blue;">冲洗表</p><p>
                        Closes all open tables, forces all tables in use to be
                        closed, and flushes the query cache and prepared statement
                        cache. <a class="link" href="sql-syntax.html#flush-tables"><code class="literal">FLUSH TABLES</code></a> also
                        removes all query results from the query cache, like the
                        <code class="literal">RESET QUERY CACHE</code> statement. For
                        information about query caching and prepared statement
                        caching, see <a class="xref" href="optimization.html#query-cache" title="8.10.3&nbsp;The MySQL Query Cache">Section&nbsp;8.10.3, “The MySQL Query Cache”</a>. and
                        <a class="xref" href="optimization.html#statement-caching" title="8.10.4&nbsp;Caching of Prepared Statements and Stored Programs">Section&nbsp;8.10.4, “Caching of Prepared Statements and Stored Programs”</a>.
                    </p><p style="color:blue;">关闭所有打开的表，强制关闭所有正在使用的表，并刷新查询缓存和准备好的语句缓存。flush tables还从查询缓存中删除所有查询结果，如reset query cache语句。有关查询缓存和prepared语句缓存的信息，请参阅8.10.3节“mysql查询缓存”。以及第8.10.4节“准备好的语句和存储程序的缓存”。</p><p>
                        <a class="link" href="sql-syntax.html#flush-tables"><code class="literal">FLUSH TABLES</code></a> is not permitted
                        when there is an active
                        <a class="link" href="sql-syntax.html#lock-tables" title="13.3.5&nbsp;LOCK TABLES and UNLOCK TABLES Syntax"><code class="literal">LOCK TABLES ...
                            READ</code></a>. To flush and lock tables, use
                        <a class="link" href="sql-syntax.html#flush-tables-with-read-lock-with-list"><code class="literal">FLUSH
                            TABLES <em class="replaceable"><code>tbl_name</code></em> ... WITH READ
                            LOCK</code></a> instead.
                    </p><p style="color:blue;">当存在活动锁表时，不允许刷新表…读。要刷新和锁定表，请使用flush tables tbl_name…用读锁代替。</p></li><li class="listitem"><p><a name="flush-tables-with-list"></a>
                        <a class="link" href="sql-syntax.html#flush-tables-with-list"><code class="literal">FLUSH
                            TABLES <em class="replaceable"><code>tbl_name</code></em> [,
                            <em class="replaceable"><code>tbl_name</code></em>] ...</code></a>
                    </p><p style="color:blue;">刷新表tbl_name[，tbl_name]…</p><p>
                        With a list of one or more comma-separated table names, this
                        statement is like <a class="link" href="sql-syntax.html#flush-tables"><code class="literal">FLUSH
                        TABLES</code></a> with no names except that the server
                        flushes only the named tables. If a named table does not
                        exist, no error occurs.
                    </p><p style="color:blue;">对于一个或多个逗号分隔的表名列表，此语句类似于没有名称的刷新表，只是服务器只刷新命名的表。如果命名表不存在，则不会发生错误。</p></li><li class="listitem"><p><a name="flush-tables-with-read-lock"></a>
                        <a class="link" href="sql-syntax.html#flush-tables-with-read-lock"><code class="literal">FLUSH
                            TABLES WITH READ LOCK</code></a>
                    </p><p style="color:blue;">用读锁刷新表</p><p>
                        Closes all open tables and locks all tables for all
                        databases with a global read lock. This is a very convenient
                        way to get backups if you have a file system such as Veritas
                        or ZFS that can take snapshots in time. Use
                        <a class="link" href="sql-syntax.html#lock-tables" title="13.3.5&nbsp;LOCK TABLES and UNLOCK TABLES Syntax"><code class="literal">UNLOCK
                            TABLES</code></a> to release the lock.
                    </p><p style="color:blue;">关闭所有打开的表，并使用全局读取锁锁定所有数据库的所有表。如果您有一个文件系统（如veritas或zfs）可以及时拍摄快照，那么这是获取备份的非常方便的方法。使用解锁表释放锁。</p><p>
                        <a class="link" href="sql-syntax.html#flush-tables-with-read-lock"><code class="literal">FLUSH TABLES WITH READ LOCK</code></a>
                        acquires a global read lock rather than table locks, so it
                        is not subject to the same behavior as
                        <a class="link" href="sql-syntax.html#lock-tables" title="13.3.5&nbsp;LOCK TABLES and UNLOCK TABLES Syntax"><code class="literal">LOCK TABLES</code></a> and
                        <a class="link" href="sql-syntax.html#lock-tables" title="13.3.5&nbsp;LOCK TABLES and UNLOCK TABLES Syntax"><code class="literal">UNLOCK
                            TABLES</code></a> with respect to table locking and implicit
                        commits:
                    </p><p style="color:blue;">带读锁的flush tables获取全局读锁，而不是表锁，因此它在表锁和隐式提交方面不受锁表和解锁表的相同行为的影响：</p>
                        <div class="itemizedlist">
                            <ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
                                <a class="link" href="sql-syntax.html#lock-tables" title="13.3.5&nbsp;LOCK TABLES and UNLOCK TABLES Syntax"><code class="literal">UNLOCK
                                    TABLES</code></a> implicitly commits any active
                                transaction only if any tables currently have been
                                locked with <a class="link" href="sql-syntax.html#lock-tables" title="13.3.5&nbsp;LOCK TABLES and UNLOCK TABLES Syntax"><code class="literal">LOCK TABLES</code></a>.
                                The commit does not occur for
                                <a class="link" href="sql-syntax.html#lock-tables" title="13.3.5&nbsp;LOCK TABLES and UNLOCK TABLES Syntax"><code class="literal">UNLOCK
                                    TABLES</code></a> following <a class="link" href="sql-syntax.html#flush-tables-with-read-lock"><code class="literal">FLUSH
                                TABLES WITH READ LOCK</code></a> because the latter
                                statement does not acquire table locks.
                            </p><p style="color:blue;">只有当当前已使用锁定表锁定任何表时，解锁表才会隐式提交任何活动事务。由于后面的语句不获取表锁，因此对于具有读锁的刷新表之后的解锁表不进行提交。</p></li><li class="listitem"><p>
                                Beginning a transaction causes table locks acquired with
                                <a class="link" href="sql-syntax.html#lock-tables" title="13.3.5&nbsp;LOCK TABLES and UNLOCK TABLES Syntax"><code class="literal">LOCK TABLES</code></a> to be
                                released, as though you had executed
                                <a class="link" href="sql-syntax.html#lock-tables" title="13.3.5&nbsp;LOCK TABLES and UNLOCK TABLES Syntax"><code class="literal">UNLOCK
                                    TABLES</code></a>. Beginning a transaction does not
                                release a global read lock acquired with
                                <a class="link" href="sql-syntax.html#flush-tables-with-read-lock"><code class="literal">FLUSH TABLES WITH READ
                                    LOCK</code></a>.
                            </p><p style="color:blue;">开始一个事务会导致用锁表获取的表锁被释放，就好像您已经执行了unlock tables一样。开始事务不会释放使用带有读取锁的刷新表获取的全局读取锁。</p></li></ul>
                        </div>
                        <p>
                            Prior to MySQL 5.7.19, <a class="link" href="sql-syntax.html#flush-tables-with-read-lock"><code class="literal">FLUSH TABLES
                            WITH READ LOCK</code></a> is not compatible with XA
                            transactions.
                        </p><p style="color:blue;">在mysql 5.7.19之前，带有读锁的flush表与xa事务不兼容。</p><p>
                            <a class="link" href="sql-syntax.html#flush-tables-with-read-lock"><code class="literal">FLUSH TABLES WITH READ LOCK</code></a>
                            does not prevent the server from inserting rows into the log
                            tables (see <a class="xref" href="server-administration.html#log-destinations" title="5.4.1&nbsp;Selecting General Query Log and Slow Query Log Output Destinations">Section&nbsp;5.4.1, “Selecting General Query Log and Slow Query Log Output Destinations”</a>).
                        </p><p style="color:blue;">带有读锁的刷新表不会阻止服务器将行插入到日志表中（请参阅5.4.1节，“选择常规查询日志和慢速查询日志输出目标”）。</p></li><li class="listitem"><p><a name="flush-tables-with-read-lock-with-list"></a>
                        <a class="link" href="sql-syntax.html#flush-tables-with-read-lock-with-list"><code class="literal">FLUSH
                            TABLES <em class="replaceable"><code>tbl_name</code></em> [,
                            <em class="replaceable"><code>tbl_name</code></em>] ... WITH READ
                            LOCK</code></a>
                    </p><p style="color:blue;">刷新表tbl_name[，tbl_name]…带读锁</p><p>
                        This statement flushes and acquires read locks for the named
                        tables. The statement first acquires exclusive metadata
                        locks for the tables, so it waits for transactions that have
                        those tables open to complete. Then the statement flushes
                        the tables from the table cache, reopens the tables,
                        acquires table locks (like
                        <a class="link" href="sql-syntax.html#lock-tables" title="13.3.5&nbsp;LOCK TABLES and UNLOCK TABLES Syntax"><code class="literal">LOCK TABLES ...
                            READ</code></a>), and downgrades the metadata locks from
                        exclusive to shared. After the statement acquires locks and
                        downgrades the metadata locks, other sessions can read but
                        not modify the tables.
                    </p><p style="color:blue;">此语句刷新并获取命名表的读锁。语句首先获取表的独占元数据锁，以便等待打开这些表的事务完成。然后语句从表缓存刷新表，重新打开表，获取表锁（如锁表…读取），并将元数据锁从独占降级为共享。在语句获取锁并降级元数据锁之后，其他会话可以读取但不能修改表。</p><p>
                        Because this statement acquires table locks, you must have
                        the <a class="link" href="security.html#priv_lock-tables"><code class="literal">LOCK TABLES</code></a> privilege for
                        each table, in addition to the
                        <a class="link" href="security.html#priv_reload"><code class="literal">RELOAD</code></a> privilege that is
                        required to use any <a class="link" href="sql-syntax.html#flush" title="13.7.6.3&nbsp;FLUSH Syntax"><code class="literal">FLUSH</code></a>
                        statement.
                    </p><p style="color:blue;">由于此语句获取表锁，除了使用任何flush语句所需的reload权限外，还必须具有每个表的lock tables权限。</p><p>
                        This statement applies only to existing base
                        (non-<code class="literal">TEMPORARY) </code>tables. If a name refers
                        to a base table, that table is used. If it refers to a
                        <code class="literal">TEMPORARY</code> table, it is ignored. If a name
                        applies to a view, an
                        <a class="link" href="error-handling.html#error_er_wrong_object"><code class="literal">ER_WRONG_OBJECT</code></a> error
                        occurs. Otherwise, an
                        <a class="link" href="error-handling.html#error_er_no_such_table"><code class="literal">ER_NO_SUCH_TABLE</code></a> error
                        occurs.
                    </p><p style="color:blue;">此语句仅适用于现有的基（非临时）表。如果名称引用基表，则使用该表。如果它引用临时表，则忽略它。如果名称应用于视图，则会发生er_error_object错误。否则，将发生er_no_这样的表错误。</p><p>
                        Use <a class="link" href="sql-syntax.html#lock-tables" title="13.3.5&nbsp;LOCK TABLES and UNLOCK TABLES Syntax"><code class="literal">UNLOCK
                        TABLES</code></a> to release the locks,
                        <a class="link" href="sql-syntax.html#lock-tables" title="13.3.5&nbsp;LOCK TABLES and UNLOCK TABLES Syntax"><code class="literal">LOCK TABLES</code></a> to release the
                        locks and acquire other locks, or
                        <a class="link" href="sql-syntax.html#commit" title="13.3.1&nbsp;START TRANSACTION, COMMIT, and ROLLBACK Syntax"><code class="literal">START
                            TRANSACTION</code></a> to release the locks and begin a new
                        transaction.
                    </p><p style="color:blue;">使用unlock tables释放锁，lock tables释放锁并获取其他锁，或者启动transaction释放锁并开始新的事务。</p><p>
                        This <a class="link" href="sql-syntax.html#flush-tables"><code class="literal">FLUSH TABLES</code></a> variant
                        enables tables to be flushed and locked in a single
                        operation. It provides a workaround for the restriction that
                        <a class="link" href="sql-syntax.html#flush-tables"><code class="literal">FLUSH TABLES</code></a> is not permitted
                        when there is an active
                        <a class="link" href="sql-syntax.html#lock-tables" title="13.3.5&nbsp;LOCK TABLES and UNLOCK TABLES Syntax"><code class="literal">LOCK TABLES ...
                            READ</code></a>.
                    </p><p style="color:blue;">此flush tables变量允许在单个操作中刷新和锁定表。它提供了一个解决方案，用于限制当存在活动锁表时不允许刷新表…阅读。</p><p>
                        This statement does not perform an implicit
                        <a class="link" href="sql-syntax.html#lock-tables" title="13.3.5&nbsp;LOCK TABLES and UNLOCK TABLES Syntax"><code class="literal">UNLOCK
                            TABLES</code></a>, so an error results if you use the
                        statement while there is any active
                        <a class="link" href="sql-syntax.html#lock-tables" title="13.3.5&nbsp;LOCK TABLES and UNLOCK TABLES Syntax"><code class="literal">LOCK TABLES</code></a> or use it a
                        second time without first releasing the locks acquired.
                    </p><p style="color:blue;">此语句不执行隐式解锁表，因此，如果在存在任何活动的锁表时使用该语句，或在未首先释放所获取的锁的情况下再次使用该语句，则会产生错误。</p><p>
                        If a flushed table was opened with
                        <a class="link" href="sql-syntax.html#handler" title="13.2.4&nbsp;HANDLER Syntax"><code class="literal">HANDLER</code></a>, the handler is
                        implicitly flushed and loses its position.
                    </p><p style="color:blue;">如果使用处理程序打开刷新的表，则处理程序将隐式刷新并丢失其位置。</p></li><li class="listitem"><p><a name="flush-tables-for-export-with-list"></a>
                        <a class="link" href="sql-syntax.html#flush-tables-for-export-with-list"><code class="literal">FLUSH
                            TABLES <em class="replaceable"><code>tbl_name</code></em> [,
                            <em class="replaceable"><code>tbl_name</code></em>] ... FOR
                            EXPORT</code></a>
                    </p><p style="color:blue;">刷新表tbl_name[，tbl_name]…出口</p><p>
                        This <a class="link" href="sql-syntax.html#flush-tables"><code class="literal">FLUSH TABLES</code></a> variant
                        applies to <code class="literal">InnoDB</code> tables. It ensures that
                        changes to the named tables have been flushed to disk so
                        that binary table copies can be made while the server is
                        running.
                    </p><p style="color:blue;">这个flush tables变量适用于innodb tables。它确保已将对命名表的更改刷新到磁盘，以便可以在服务器运行时生成二进制表副本。</p><p>
                        The statement works like this:
                    </p><p style="color:blue;">声明的工作原理如下：</p>
                        <div class="orderedlist">
                            <ol class="orderedlist" type="1"><li class="listitem"><p>
                                It acquires shared metadata locks for the named tables.
                                The statement blocks as long as other sessions have
                                active transactions that have modified those tables or
                                hold table locks for them. When the locks have been
                                acquired, the statement blocks transactions that attempt
                                to update the tables, while permitting read-only
                                operations to continue.
                            </p><p style="color:blue;">它获取命名表的共享元数据锁。只要其他会话具有修改了这些表或为它们保留表锁的活动事务，语句就会阻塞。获取锁后，语句将阻止尝试更新表的事务，同时允许只读操作继续。</p></li><li class="listitem"><p>
                                It checks whether all storage engines for the tables
                                support <code class="literal">FOR EXPORT</code>. If any do not, an
                                <a class="link" href="error-handling.html#error_er_illegal_ha"><code class="literal">ER_ILLEGAL_HA</code></a> error
                                occurs and the statement fails.
                            </p><p style="color:blue;">它检查表的所有存储引擎是否支持导出。如果没有，则会发生er_非法的ha错误，并且语句失败。</p></li><li class="listitem"><p>
                                The statement notifies the storage engine for each table
                                to make the table ready for export. The storage engine
                                must ensure that any pending changes are written to
                                disk.
                            </p><p style="color:blue;">语句通知每个表的存储引擎，使表准备好导出。存储引擎必须确保将任何挂起的更改写入磁盘。</p></li><li class="listitem"><p>
                                The statement puts the session in lock-tables mode so
                                that the metadata locks acquired earlier are not
                                released when the <code class="literal">FOR EXPORT</code>
                                statement completes.
                            </p><p style="color:blue;">语句将会话置于锁表模式，以便在for export语句完成时不会释放先前获取的元数据锁。</p></li></ol>
                        </div>
                        <p>
                            The
                            <a class="link" href="sql-syntax.html#flush-tables-for-export-with-list"><code class="literal">FLUSH
                                TABLES ... FOR EXPORT</code></a> statement requires that you
                            have the <a class="link" href="sql-syntax.html#select" title="13.2.9&nbsp;SELECT Syntax"><code class="literal">SELECT</code></a> privilege for
                            each table. Because this statement acquires table locks, you
                            must also have the <a class="link" href="security.html#priv_lock-tables"><code class="literal">LOCK
                            TABLES</code></a> privilege for each table, in addition to
                            the <a class="link" href="security.html#priv_reload"><code class="literal">RELOAD</code></a> privilege that is
                            required to use any <a class="link" href="sql-syntax.html#flush" title="13.7.6.3&nbsp;FLUSH Syntax"><code class="literal">FLUSH</code></a>
                            statement.
                        </p><p style="color:blue;">冲水台…for export语句要求您对每个表都具有select特权。由于此语句获取表锁，除了使用任何flush语句所需的重新加载权限外，还必须具有每个表的lock tables权限。</p><p>
                            This statement applies only to existing base
                            (non-<code class="literal">TEMPORARY</code>) tables. If a name refers
                            to a base table, that table is used. If it refers to a
                            <code class="literal">TEMPORARY</code> table, it is ignored. If a name
                            applies to a view, an
                            <a class="link" href="error-handling.html#error_er_wrong_object"><code class="literal">ER_WRONG_OBJECT</code></a> error
                            occurs. Otherwise, an
                            <a class="link" href="error-handling.html#error_er_no_such_table"><code class="literal">ER_NO_SUCH_TABLE</code></a> error
                            occurs.
                        </p><p style="color:blue;">此语句仅适用于现有的基（非临时）表。如果名称引用基表，则使用该表。如果它引用临时表，则忽略它。如果名称应用于视图，则会发生er_error_object错误。否则，将发生er_no_这样的表错误。</p><p>
                            <code class="literal">InnoDB</code> supports <code class="literal">FOR
                            EXPORT</code> for tables that have their own
                            <a class="link" href="glossary.html#glos_ibd_file" title=".ibd file"><code class="filename">.ibd</code>
                                file</a> file (that is, tables created with the
                            <a class="link" href="innodb-storage-engine.html#sysvar_innodb_file_per_table"><code class="literal">innodb_file_per_table</code></a>
                            setting enabled). <code class="literal">InnoDB</code> ensures when
                            notified by the <code class="literal">FOR EXPORT</code> statement that
                            any changes have been flushed to disk. This permits a binary
                            copy of table contents to be made while the <code class="literal">FOR
                            EXPORT</code> statement is in effect because the
                            <code class="filename">.ibd</code> file is transaction consistent and
                            can be copied while the server is running. <code class="literal">FOR
                            EXPORT</code> does not apply to <code class="literal">InnoDB</code>
                            system tablespace files, or to <code class="literal">InnoDB</code>
                            tables that have <code class="literal">FULLTEXT</code> indexes.
                        </p><p style="color:blue;">innodb支持导出具有自己的.ibd文件文件的表（即，启用innodb_file_per_table设置创建的表）。innodb确保当for export语句通知时，任何更改都已刷新到磁盘。这允许在for export语句生效时生成表内容的二进制副本，因为.ibd文件是事务一致的，并且可以在服务器运行时复制。for export不适用于innodb系统表空间文件，也不适用于具有全文索引的innodb表。</p><p>
                            <a class="link" href="sql-syntax.html#flush-tables-for-export-with-list"><code class="literal">FLUSH
                                TABLES ...FOR EXPORT</code></a> is supported for partitioned
                            <code class="literal">InnoDB</code> tables.
                        </p><p style="color:blue;">分区的innodb表支持flush tables…for export。</p><p>
                            When notified by <code class="literal">FOR EXPORT</code>,
                            <code class="literal">InnoDB</code> writes to disk certain kinds of
                            data that is normally held in memory or in separate disk
                            buffers outside the tablespace files. For each table,
                            <code class="literal">InnoDB</code> also produces a file named
                            <code class="filename"><em class="replaceable"><code>table_name</code></em>.cfg</code>
                            in the same database directory as the table. The
                            <code class="filename">.cfg</code> file contains metadata needed to
                            reimport the tablespace files later, into the same or
                            different server.
                        </p><p style="color:blue;">当收到导出通知时，innodb会将通常保存在内存中或表空间文件之外的单独磁盘缓冲区中的某些类型的数据写入磁盘。对于每个表，innodb还会在与表相同的数据库目录中生成一个名为table_name.cfg的文件。cfg文件包含稍后将表空间文件重新导入到同一或不同服务器所需的元数据。</p><p>
                            When the <code class="literal">FOR EXPORT</code> statement completes,
                            <code class="literal">InnoDB</code> will have flushed all
                            <a class="link" href="glossary.html#glos_dirty_page" title="dirty page">dirty pages</a> to the
                            table data files. Any
                            <a class="link" href="glossary.html#glos_change_buffer" title="change buffer">change buffer</a>
                            entries are merged prior to flushing. At this point, the
                            tables are locked and quiescent: The tables are in a
                            transactionally consistent state on disk and you can copy
                            the <code class="filename">.ibd</code> tablespace files along with
                            the corresponding <code class="filename">.cfg</code> files to get a
                            consistent snapshot of those tables.
                        </p><p style="color:blue;">当for export语句完成时，innodb会将所有脏页刷新到表数据文件中。任何更改缓冲区条目都会在刷新之前合并。此时，表被锁定且处于静止状态：表在磁盘上处于事务一致状态，您可以复制.ibd表空间文件以及相应的.cfg文件，以获得这些表的一致快照。</p><p>
                            For the procedure to reimport the copied table data into a
                            MySQL instance, see <a class="xref" href="innodb-storage-engine.html#tablespace-copying" title="14.6.3.7&nbsp;Copying Tablespaces to Another Instance">Section&nbsp;14.6.3.7, “Copying Tablespaces to Another Instance”</a>.
                        </p><p style="color:blue;">有关将复制的表数据重新导入mysql实例的过程，请参阅14.6.3.7节“将表空间复制到另一个实例”。</p><p>
                            After you are done with the tables, use
                            <a class="link" href="sql-syntax.html#lock-tables" title="13.3.5&nbsp;LOCK TABLES and UNLOCK TABLES Syntax"><code class="literal">UNLOCK
                                TABLES</code></a> to release the locks,
                            <a class="link" href="sql-syntax.html#lock-tables" title="13.3.5&nbsp;LOCK TABLES and UNLOCK TABLES Syntax"><code class="literal">LOCK TABLES</code></a> to release the
                            locks and acquire other locks, or
                            <a class="link" href="sql-syntax.html#commit" title="13.3.1&nbsp;START TRANSACTION, COMMIT, and ROLLBACK Syntax"><code class="literal">START
                                TRANSACTION</code></a> to release the locks and begin a new
                            transaction.
                        </p><p style="color:blue;">处理完表后，使用unlock tables释放锁，使用lock tables释放锁并获取其他锁，或者启动transaction释放锁并开始新的事务。</p><p>
                            While any of these statements is in effect within the
                            session, attempts to use
                            <a class="link" href="sql-syntax.html#flush-tables-for-export-with-list"><code class="literal">FLUSH
                                TABLES ... FOR EXPORT</code></a> produce an error:
                        </p><p style="color:blue;">当这些语句中的任何一个在会话中有效时，尝试使用刷新表…对于导出产生错误：</p><pre data-lang="sql" class="programlisting">FLUSH TABLES ... WITH READ LOCK
FLUSH TABLES ... FOR EXPORT
LOCK TABLES ... READ
LOCK TABLES ... WRITE
</pre><p>
                            While
                            <a class="link" href="sql-syntax.html#flush-tables-for-export-with-list"><code class="literal">FLUSH
                                TABLES ... FOR EXPORT</code></a> is in effect within the
                            session, attempts to use any of these statements produce an
                            error:
                        </p><p style="color:blue;">刷新表时…如果导出在会话中有效，则尝试使用以下任何语句都会产生错误：</p><pre data-lang="sql" class="programlisting">FLUSH TABLES WITH READ LOCK
FLUSH TABLES ... WITH READ LOCK
FLUSH TABLES ... FOR EXPORT
</pre></li></ul>
                </div>

            </div>
            <div class="section">
                <div class="titlepage">
                    <div>
                        <div>
                            <h4 class="title"><a name="kill"></a>13.7.6.4&nbsp;KILL Syntax</h4>

                        </div>

                    </div>

                </div>
                <a class="indexterm" name="idm140286825280128"></a><a class="indexterm" name="idm140286825279056"></a><pre data-lang="sql" class="programlisting">KILL [CONNECTION | QUERY] <em class="replaceable"><code>processlist_id</code></em>
</pre><p>
                Each connection to <a class="link" href="programs.html#mysqld" title="4.3.1&nbsp;mysqld — The MySQL Server"><span class="command"><strong>mysqld</strong></span></a> runs in a separate
                thread. You can kill a thread with the <code class="literal">KILL
                <em class="replaceable"><code>processlist_id</code></em></code> statement.
            </p><p style="color:blue;">到mysqld的每个连接都在一个单独的线程中运行。可以使用kill processlist_id语句终止线程。</p><p>
                Thread processlist identifiers can be determined from the
                <code class="literal">ID</code> column of the
                <code class="literal">INFORMATION_SCHEMA</code>
                <a class="link" href="information-schema.html#processlist-table" title="24.18&nbsp;The INFORMATION_SCHEMA PROCESSLIST Table"><code class="literal">PROCESSLIST</code></a> table, the
                <code class="literal">Id</code> column of <a class="link" href="sql-syntax.html#show-processlist" title="13.7.5.29&nbsp;SHOW PROCESSLIST Syntax"><code class="literal">SHOW
                PROCESSLIST</code></a> output, and the
                <code class="literal">PROCESSLIST_ID</code> column of the Performance
                Schema <a class="link" href="performance-schema.html#threads-table" title="25.12.16.3&nbsp;The threads Table"><code class="literal">threads</code></a> table. The value for
                the current thread is returned by the
                <a class="link" href="functions.html#function_connection-id"><code class="literal">CONNECTION_ID()</code></a> function.
            </p><p style="color:blue;">线程进程列表标识符可以从information schema processlist表的id列、show processlist output的id列和performance schema threads表的processlist id列确定。当前线程的值由connection_id（）函数返回。</p><p>
                <a class="link" href="sql-syntax.html#kill" title="13.7.6.4&nbsp;KILL Syntax"><code class="literal">KILL</code></a> permits an optional
                <code class="literal">CONNECTION</code> or <code class="literal">QUERY</code>
                modifier:
            </p><p style="color:blue;">kill允许可选的连接或查询修饰符：</p>
                <div class="itemizedlist">
                    <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                        <a class="link" href="sql-syntax.html#kill" title="13.7.6.4&nbsp;KILL Syntax"><code class="literal">KILL
                            CONNECTION</code></a> is the same as
                        <a class="link" href="sql-syntax.html#kill" title="13.7.6.4&nbsp;KILL Syntax"><code class="literal">KILL</code></a> with no modifier: It
                        terminates the connection associated with the given
                        <em class="replaceable"><code>processlist_id</code></em>, after terminating
                        any statement the connection is executing.
                    </p><p style="color:blue;">kill connection与kill相同，没有修饰符：它在终止连接正在执行的任何语句后，终止与给定processlist_id关联的连接。</p></li><li class="listitem"><p>
                        <a class="link" href="sql-syntax.html#kill" title="13.7.6.4&nbsp;KILL Syntax"><code class="literal">KILL QUERY</code></a>
                        terminates the statement the connection is currently
                        executing, but leaves the connection itself intact.
                    </p><p style="color:blue;">kill query终止连接当前正在执行的语句，但保留连接本身的完整性。</p></li></ul>
                </div>
                <p>
                    The ability to see which threads are available to be killed
                    depends on the <a class="link" href="security.html#priv_process"><code class="literal">PROCESS</code></a> privilege:
                </p><p style="color:blue;">查看哪些线程可被终止的能力取决于进程特权：</p>
                <div class="itemizedlist">
                    <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                        Without <a class="link" href="security.html#priv_process"><code class="literal">PROCESS</code></a>, you can see
                        only your own threads.
                    </p><p style="color:blue;">没有进程，您只能看到自己的线程。</p></li><li class="listitem"><p>
                        With <a class="link" href="security.html#priv_process"><code class="literal">PROCESS</code></a>, you can see all
                        threads.
                    </p><p style="color:blue;">通过进程，您可以看到所有线程。</p></li></ul>
                </div>
                <p>
                    The ability to kill threads and statements depends on the
                    <a class="link" href="security.html#priv_super"><code class="literal">SUPER</code></a> privilege:
                </p><p style="color:blue;">杀死线程和语句的能力取决于超级特权：</p>
                <div class="itemizedlist">
                    <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                        Without <a class="link" href="security.html#priv_super"><code class="literal">SUPER</code></a>, you can kill
                        only your own threads and statements.
                    </p><p style="color:blue;">没有super，您只能杀死自己的线程和语句。</p></li><li class="listitem"><p>
                        With <a class="link" href="security.html#priv_super"><code class="literal">SUPER</code></a>, you can kill all
                        threads and statements.
                    </p><p style="color:blue;">使用super，可以杀死所有线程和语句。</p></li></ul>
                </div>
                <p>
                    You can also use the <a class="link" href="programs.html#mysqladmin" title="4.5.2&nbsp;mysqladmin — Client for Administering a MySQL Server"><span class="command"><strong>mysqladmin processlist</strong></span></a>
                    and <a class="link" href="programs.html#mysqladmin" title="4.5.2&nbsp;mysqladmin — Client for Administering a MySQL Server"><span class="command"><strong>mysqladmin kill</strong></span></a> commands to examine and
                    kill threads.
                </p><p style="color:blue;">您还可以使用mysqladmin processlist和mysqladmin kill命令来检查和终止线程。</p>
                <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">

                    <div class="admon-title">
                        Note
                    </div>
                    <p>
                        You cannot use <a class="link" href="sql-syntax.html#kill" title="13.7.6.4&nbsp;KILL Syntax"><code class="literal">KILL</code></a> with the
                        Embedded MySQL Server library because the embedded server
                        merely runs inside the threads of the host application. It
                        does not create any connection threads of its own.
                    </p><p style="color:blue;">不能对嵌入式mysql服务器库使用kill，因为嵌入式服务器只在宿主应用程序的线程内运行。它不创建自己的任何连接线程。</p>
                </div>
                <p>
                    When you use <a class="link" href="sql-syntax.html#kill" title="13.7.6.4&nbsp;KILL Syntax"><code class="literal">KILL</code></a>, a
                    thread-specific kill flag is set for the thread. In most cases,
                    it might take some time for the thread to die because the kill
                    flag is checked only at specific intervals:
                </p><p style="color:blue;">使用kill时，会为线程设置特定于线程的kill标志。在大多数情况下，线程可能需要一段时间才能消亡，因为kill标志只在特定的时间间隔进行检查：</p>
                <div class="itemizedlist">
                    <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                        During <a class="link" href="sql-syntax.html#select" title="13.2.9&nbsp;SELECT Syntax"><code class="literal">SELECT</code></a> operations, for
                        <code class="literal">ORDER BY</code> and <code class="literal">GROUP BY</code>
                        loops, the flag is checked after reading a block of rows. If
                        the kill flag is set, the statement is aborted.
                    </p><p style="color:blue;">在选择操作期间，对于ORDERBY和GROUPBY循环，在读取行块后检查标志。如果设置了kill标志，则语句将中止。</p></li><li class="listitem"><p>
                        <a class="link" href="sql-syntax.html#alter-table" title="13.1.8&nbsp;ALTER TABLE Syntax"><code class="literal">ALTER TABLE</code></a> operations that
                        make a table copy check the kill flag periodically for each
                        few copied rows read from the original table. If the kill
                        flag was set, the statement is aborted and the temporary
                        table is deleted.
                    </p><p style="color:blue;">对于从原始表中读取的每几行复制的行，进行表复制的alter table操作会定期检查kill标志。如果设置了kill标志，则语句将中止并删除临时表。</p><p>
                        The <a class="link" href="sql-syntax.html#kill" title="13.7.6.4&nbsp;KILL Syntax"><code class="literal">KILL</code></a> statement returns
                        without waiting for confirmation, but the kill flag check
                        aborts the operation within a reasonably small amount of
                        time. Aborting the operation to perform any necessary
                        cleanup also takes some time.
                    </p><p style="color:blue;">kill语句返回时不等待确认，但kill标志检查会在相当短的时间内中止操作。中止操作以执行任何必要的清理也需要一些时间。</p></li><li class="listitem"><p>
                        During <a class="link" href="sql-syntax.html#update" title="13.2.11&nbsp;UPDATE Syntax"><code class="literal">UPDATE</code></a> or
                        <a class="link" href="sql-syntax.html#delete" title="13.2.2&nbsp;DELETE Syntax"><code class="literal">DELETE</code></a> operations, the kill
                        flag is checked after each block read and after each updated
                        or deleted row. If the kill flag is set, the statement is
                        aborted. If you are not using transactions, the changes are
                        not rolled back.
                    </p><p style="color:blue;">在更新或删除操作期间，在每次读取块之后以及在每次更新或删除行之后检查kill标志。如果设置了kill标志，则语句将中止。如果不使用事务，则不会回滚更改。</p></li><li class="listitem"><p>
                        <a class="link" href="functions.html#function_get-lock"><code class="literal">GET_LOCK()</code></a> aborts and returns
                        <code class="literal">NULL</code>.
                    </p><p style="color:blue;">get_lock（）中止并返回空值。</p></li><li class="listitem"><p>
                        If the thread is in the table lock handler (state:
                        <code class="literal">Locked</code>), the table lock is quickly
                        aborted.
                    </p><p style="color:blue;">如果线程处于表锁处理程序（状态：locked）中，则表锁将快速中止。</p></li><li class="listitem"><p>
                        If the thread is waiting for free disk space in a write
                        call, the write is aborted with a <span class="quote">“<span class="quote">disk full</span>”</span>
                        error message.
                    </p><p style="color:blue;">如果线程在写调用中等待空闲磁盘空间，则写操作将中止，并显示“磁盘已满”错误消息。</p></li></ul>
                </div>
                <div class="warning" style="margin-left: 0.5in; margin-right: 0.5in;">
                    <div class="admon-title">
                        Warning
                    </div>
                    <p>
                        Killing a <a class="link" href="sql-syntax.html#repair-table" title="13.7.2.5&nbsp;REPAIR TABLE Syntax"><code class="literal">REPAIR TABLE</code></a> or
                        <a class="link" href="sql-syntax.html#optimize-table" title="13.7.2.4&nbsp;OPTIMIZE TABLE Syntax"><code class="literal">OPTIMIZE TABLE</code></a> operation on a
                        <code class="literal">MyISAM</code> table results in a table that is
                        corrupted and unusable. Any reads or writes to such a table
                        fail until you optimize or repair it again (without
                        interruption).
                    </p><p style="color:blue;">在myisam表上终止修复表或优化表操作会导致表损坏且无法使用。对这样一个表的任何读或写操作都会失败，除非您再次优化或修复它（不中断）。</p>
                </div>

            </div>
            <div class="section">
                <div class="titlepage">
                    <div>
                        <div>
                            <h4 class="title"><a name="load-index"></a>13.7.6.5&nbsp;LOAD INDEX INTO CACHE Syntax</h4>

                        </div>

                    </div>

                </div>
                <pre data-lang="sql" class="programlisting">LOAD INDEX INTO CACHE
  <em class="replaceable"><code>tbl_index_list</code></em> [, <em class="replaceable"><code>tbl_index_list</code></em>] ...

<em class="replaceable"><code>tbl_index_list</code></em>:
  <em class="replaceable"><code>tbl_name</code></em>
    [PARTITION (<em class="replaceable"><code>partition_list</code></em>)]
    [{INDEX|KEY} (<em class="replaceable"><code>index_name</code></em>[, <em class="replaceable"><code>index_name</code></em>] ...)]
    [IGNORE LEAVES]

<em class="replaceable"><code>partition_list</code></em>: {
    <em class="replaceable"><code>partition_name</code></em>[, <em class="replaceable"><code>partition_name</code></em>] ...
  | ALL
}
</pre><p>
                The <a class="link" href="sql-syntax.html#load-index" title="13.7.6.5&nbsp;LOAD INDEX INTO CACHE Syntax"><code class="literal">LOAD INDEX INTO
                CACHE</code></a> statement preloads a table index into the key
                cache to which it has been assigned by an explicit
                <a class="link" href="sql-syntax.html#cache-index" title="13.7.6.2&nbsp;CACHE INDEX Syntax"><code class="literal">CACHE INDEX</code></a> statement, or into
                the default key cache otherwise.
            </p><p style="color:blue;">LOAD INDEX INTO CACHE语句将表索引预加载到由显式CACHE INDEX语句分配给它的键缓存中，否则加载到默认键缓存中。</p><p>
                <a class="link" href="sql-syntax.html#load-index" title="13.7.6.5&nbsp;LOAD INDEX INTO CACHE Syntax"><code class="literal">LOAD INDEX INTO
                    CACHE</code></a> applies only to <code class="literal">MyISAM</code>
                tables, including partitioned <code class="literal">MyISAM</code> tables.
                In addition, indexes on partitioned tables can be preloaded for
                one, several, or all partitions.
            </p><p style="color:blue;">将索引加载到缓存中仅适用于myisam表，包括分区的myisam表。此外，可以为一个、多个或所有分区预加载分区表上的索引。</p><p>
                The <code class="literal">IGNORE LEAVES</code> modifier causes only blocks
                for the nonleaf nodes of the index to be preloaded.
            </p><p style="color:blue;">“忽略叶”修改器只会导致预加载索引的非叶节点的块。</p><p>
                <code class="literal">IGNORE LEAVES</code> is also supported for
                partitioned <code class="literal">MyISAM</code> tables.
            </p><p style="color:blue;">分区myisam表也支持忽略叶。</p><p>
                The following statement preloads nodes (index blocks) of indexes
                for the tables <code class="literal">t1</code> and <code class="literal">t2</code>:
            </p><p style="color:blue;">以下语句预加载表T1和T2的索引节点（索引块）：</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>LOAD INDEX INTO CACHE t1, t2 IGNORE LEAVES;</code></strong>
+---------+--------------+----------+----------+
| Table   | Op           | Msg_type | Msg_text |
+---------+--------------+----------+----------+
| test.t1 | preload_keys | status   | OK       |
| test.t2 | preload_keys | status   | OK       |
+---------+--------------+----------+----------+
</pre><p>
                This statement preloads all index blocks from
                <code class="literal">t1</code>. It preloads only blocks for the nonleaf
                nodes from <code class="literal">t2</code>.
            </p><p style="color:blue;">此语句预加载T1中的所有索引块。它只为t2中的非叶节点预加载块。</p><p>
                The syntax of <a class="link" href="sql-syntax.html#load-index" title="13.7.6.5&nbsp;LOAD INDEX INTO CACHE Syntax"><code class="literal">LOAD
                INDEX INTO CACHE</code></a> enables you to specify that only
                particular indexes from a table should be preloaded. However,
                the implementation preloads all the table's indexes into the
                cache, so there is no reason to specify anything other than the
                table name.
            </p><p style="color:blue;">将索引加载到缓存中的语法使您能够指定只应预加载表中的特定索引。但是，实现会将表的所有索引预加载到缓存中，因此除了表名之外，没有理由指定任何其他内容。</p><p>
                It is possible to preload indexes on specific partitions of
                partitioned <code class="literal">MyISAM</code> tables. For example, of
                the following 2 statements, the first preloads indexes for
                partition <code class="literal">p0</code> of a partitioned table
                <code class="literal">pt</code>, while the second preloads the indexes for
                partitions <code class="literal">p1</code> and <code class="literal">p3</code> of
                the same table:
            </p><p style="color:blue;">可以在分区myisam表的特定分区上预加载索引。例如，在以下2条语句中，第一条预加载已分区表pt的分区p0的索引，而第二条预加载同一表的分区p1和p3的索引：</p><pre data-lang="sql" class="programlisting">LOAD INDEX INTO CACHE pt PARTITION (p0);
LOAD INDEX INTO CACHE pt PARTITION (p1, p3);
</pre><p>
                To preload the indexes for all partitions in table
                <code class="literal">pt</code>, you can use either of the following two
                statements:
            </p><p style="color:blue;">要预加载表pt中所有分区的索引，可以使用以下两个语句之一：</p><pre data-lang="sql" class="programlisting">LOAD INDEX INTO CACHE pt PARTITION (ALL);

LOAD INDEX INTO CACHE pt;
</pre><p>
                The two statements just shown are equivalent, and issuing either
                one has exactly the same effect. In other words, if you wish to
                preload indexes for all partitions of a partitioned table, the
                <code class="literal">PARTITION (ALL)</code> clause is optional.
            </p><p style="color:blue;">刚才显示的两个语句是等价的，并且发出其中一个语句的效果完全相同。换句话说，如果希望为分区表的所有分区预加载索引，分区（ALL）子句是可选的。</p><p>
                When preloading indexes for multiple partitions, the partitions
                need not be contiguous, and you need not list their names in any
                particular order.
            </p><p style="color:blue;">当为多个分区预加载索引时，分区不必是连续的，也不必按任何特定顺序列出它们的名称。</p><p>
                <a class="link" href="sql-syntax.html#load-index" title="13.7.6.5&nbsp;LOAD INDEX INTO CACHE Syntax"><code class="literal">LOAD INDEX INTO
                    CACHE ... IGNORE LEAVES</code></a> fails unless all indexes in a
                table have the same block size. To determine index block sizes
                for a table, use <a class="link" href="programs.html#myisamchk" title="4.6.3&nbsp;myisamchk — MyISAM Table-Maintenance Utility"><span class="command"><strong>myisamchk -dv</strong></span></a> and check the
                <code class="literal">Blocksize</code> column.
            </p><p style="color:blue;">将索引加载到缓存…忽略叶失败，除非表中的所有索引具有相同的块大小。要确定表的索引块大小，请使用myisamchk-dv并检查blocksize列。</p>
            </div>
            <div class="section">
                <div class="titlepage">
                    <div>
                        <div>
                            <h4 class="title"><a name="reset"></a>13.7.6.6&nbsp;RESET Syntax</h4>

                        </div>

                    </div>

                </div>
                <a class="indexterm" name="idm140286825171024"></a><a class="indexterm" name="idm140286825169952"></a><pre data-lang="sql" class="programlisting">RESET <em class="replaceable"><code>reset_option</code></em> [, <em class="replaceable"><code>reset_option</code></em>] ...

<em class="replaceable"><code>reset_option</code></em>: {
    MASTER
  | QUERY CACHE
  | SLAVE
}
</pre><p>
                The <a class="link" href="sql-syntax.html#reset" title="13.7.6.6&nbsp;RESET Syntax"><code class="literal">RESET</code></a> statement is used to
                clear the state of various server operations. You must have the
                <a class="link" href="security.html#priv_reload"><code class="literal">RELOAD</code></a> privilege to execute
                <a class="link" href="sql-syntax.html#reset" title="13.7.6.6&nbsp;RESET Syntax"><code class="literal">RESET</code></a>.
            </p><p style="color:blue;">reset语句用于清除各种服务器操作的状态。您必须具有重新加载权限才能执行重置。</p><p>
                <a class="link" href="sql-syntax.html#reset" title="13.7.6.6&nbsp;RESET Syntax"><code class="literal">RESET</code></a> acts as a stronger version
                of the <a class="link" href="sql-syntax.html#flush" title="13.7.6.3&nbsp;FLUSH Syntax"><code class="literal">FLUSH</code></a> statement. See
                <a class="xref" href="sql-syntax.html#flush" title="13.7.6.3&nbsp;FLUSH Syntax">Section&nbsp;13.7.6.3, “FLUSH Syntax”</a>.
            </p><p style="color:blue;">reset充当flush语句的更强大版本。见第13.7.6.3节“刷新语法”。</p><p>
                The <a class="link" href="sql-syntax.html#reset" title="13.7.6.6&nbsp;RESET Syntax"><code class="literal">RESET</code></a> statement causes an
                implicit commit. See <a class="xref" href="sql-syntax.html#implicit-commit" title="13.3.3&nbsp;Statements That Cause an Implicit Commit">Section&nbsp;13.3.3, “Statements That Cause an Implicit Commit”</a>.
            </p><p style="color:blue;">reset语句导致隐式提交。参见第13.3.3节，“导致隐式提交的语句”。</p><p>
                The following list describes the permitted
                <a class="link" href="sql-syntax.html#reset" title="13.7.6.6&nbsp;RESET Syntax"><code class="literal">RESET</code></a> statement
                <em class="replaceable"><code>reset_option</code></em> values:
            </p><p style="color:blue;">以下列表描述了允许的reset语句reset_选项值：</p>
                <div class="itemizedlist">
                    <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                        <code class="literal">RESET MASTER</code>
                    </p><p style="color:blue;">复位大师</p><p>
                        Deletes all binary logs listed in the index file, resets the
                        binary log index file to be empty, and creates a new binary
                        log file.
                    </p><p style="color:blue;">删除索引文件中列出的所有二进制日志，将二进制日志索引文件重置为空，并创建新的二进制日志文件。</p></li><li class="listitem"><p>
                        <code class="literal">RESET QUERY CACHE</code>
                    </p><p style="color:blue;">重置查询缓存</p><p>
                        Removes all query results from the query cache.
                    </p><p style="color:blue;">从查询缓存中删除所有查询结果。</p>
                        <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">

                            <div class="admon-title">
                                Note
                            </div>
                            <p>
                                The query cache is deprecated as of MySQL 5.7.20, and is
                                removed in MySQL 8.0. Deprecation includes
                                <a class="link" href="sql-syntax.html#reset" title="13.7.6.6&nbsp;RESET Syntax"><code class="literal">RESET QUERY
                                    CACHE</code></a>.
                            </p><p style="color:blue;">从mysql 5.7.20开始，查询缓存已被弃用，并在mysql 8.0中被删除。不推荐使用重置查询缓存。</p>
                        </div>
                    </li><li class="listitem"><p>
                        <code class="literal">RESET SLAVE</code>
                    </p><p style="color:blue;">复位从机</p><p>
                        Makes the slave forget its replication position in the
                        master binary logs. Also resets the relay log by deleting
                        any existing relay log files and beginning a new one.
                    </p><p style="color:blue;">使从机忘记其在主二进制日志中的复制位置。还通过删除任何现有的中继日志文件并开始新的日志文件来重置中继日志。</p></li></ul>
                </div>

            </div>
            <div class="section">
                <div class="titlepage">
                    <div>
                        <div>
                            <h4 class="title"><a name="shutdown"></a>13.7.6.7&nbsp;SHUTDOWN Syntax</h4>

                        </div>

                    </div>

                </div>
                <a class="indexterm" name="idm140286825141392"></a><pre data-lang="sql" class="programlisting">SHUTDOWN
</pre><p>
                This statement stops the MySQL server. It requires the
                <a class="link" href="security.html#priv_shutdown"><code class="literal">SHUTDOWN</code></a> privilege.
            </p><p style="color:blue;">此语句停止mysql服务器。它需要关闭权限。</p><p>
                <a class="link" href="sql-syntax.html#shutdown" title="13.7.6.7&nbsp;SHUTDOWN Syntax"><code class="literal">SHUTDOWN</code></a> provides an SQL-level
                interface to the same functionality available using the
                <a class="link" href="programs.html#mysqladmin" title="4.5.2&nbsp;mysqladmin — Client for Administering a MySQL Server"><span class="command"><strong>mysqladmin shutdown</strong></span></a> command or the
                <a class="link" href="connectors-apis.html#mysql-shutdown" title="27.8.7.71&nbsp;mysql_shutdown()"><code class="literal">mysql_shutdown()</code></a> C API function.
            </p><p style="color:blue;">shutdown为使用mysqladmin shutdown命令或mysql_shutdown（）c api函数的相同功能提供了一个sql级别的接口。</p><p>
                The
                <a class="link" href="server-administration.html#statvar_Com_xxx"><code class="literal">Com_shutdown</code></a>
                status variable tracks the number of
                <a class="link" href="sql-syntax.html#shutdown" title="13.7.6.7&nbsp;SHUTDOWN Syntax"><code class="literal">SHUTDOWN</code></a> statements. Because
                status variables are initialized for each server startup and do
                not persist across restarts, <code class="literal">Com_shutdown</code>
                normally has a value of zero, but can be nonzero if
                <a class="link" href="sql-syntax.html#shutdown" title="13.7.6.7&nbsp;SHUTDOWN Syntax"><code class="literal">SHUTDOWN</code></a> statements were executed
                but failed.
            </p><p style="color:blue;">COM U SHUTDOWN STATUS变量跟踪SHUTDOWN语句的数量。因为状态变量是为每个服务器启动初始化的，并且不会在重新启动时持续存在，所以COM U SHUTDOWN通常值为零，但如果SHUTDOWN语句已执行但失败，则可以为非零。</p>
            </div>

        </div>

    </div>
    <div class="section">
        <div class="titlepage">
            <div>
                <div>
                    <h2 class="title" style="clear: both"><a name="sql-syntax-utility"></a>13.8&nbsp;Utility Statements</h2>

                </div>

            </div>

        </div>
        <div class="toc">
            <dl class="toc"><dt><span class="section"><a href="sql-syntax.html#describe">13.8.1 DESCRIBE Syntax</a></span></dt><dt><span class="section"><a href="sql-syntax.html#explain">13.8.2 EXPLAIN Syntax</a></span></dt><dt><span class="section"><a href="sql-syntax.html#help">13.8.3 HELP Syntax</a></span></dt><dt><span class="section"><a href="sql-syntax.html#use">13.8.4 USE Syntax</a></span></dt></dl>
        </div>
        <div class="section">
            <div class="titlepage">
                <div>
                    <div>
                        <h3 class="title"><a name="describe"></a>13.8.1&nbsp;DESCRIBE Syntax</h3>

                    </div>

                </div>

            </div>
            <a class="indexterm" name="idm140286825121920"></a><a class="indexterm" name="idm140286825120848"></a><p>
            The <a class="link" href="sql-syntax.html#describe" title="13.8.1&nbsp;DESCRIBE Syntax"><code class="literal">DESCRIBE</code></a> and
            <a class="link" href="sql-syntax.html#explain" title="13.8.2&nbsp;EXPLAIN Syntax"><code class="literal">EXPLAIN</code></a> statements are synonyms,
            used either to obtain information about table structure or query
            execution plans. For more information, see
            <a class="xref" href="sql-syntax.html#show-columns" title="13.7.5.5&nbsp;SHOW COLUMNS Syntax">Section&nbsp;13.7.5.5, “SHOW COLUMNS Syntax”</a>, and <a class="xref" href="sql-syntax.html#explain" title="13.8.2&nbsp;EXPLAIN Syntax">Section&nbsp;13.8.2, “EXPLAIN Syntax”</a>.
        </p><p style="color:blue;">describe和explain语句是同义词，用于获取有关表结构或查询执行计划的信息。有关详细信息，请参阅第13.7.5.5节“显示列语法”和第13.8.2节“解释语法”。</p>
        </div>
        <div class="section">
            <div class="titlepage">
                <div>
                    <div>
                        <h3 class="title"><a name="explain"></a>13.8.2&nbsp;EXPLAIN Syntax</h3>

                    </div>

                </div>

            </div>
            <a class="indexterm" name="idm140286825114176"></a><a class="indexterm" name="idm140286825113104"></a><pre data-lang="sql" class="programlisting">{EXPLAIN | DESCRIBE | DESC}
    <em class="replaceable"><code>tbl_name</code></em> [<em class="replaceable"><code>col_name</code></em> | <em class="replaceable"><code>wild</code></em>]

{EXPLAIN | DESCRIBE | DESC}
    [<em class="replaceable"><code>explain_type</code></em>]
    {<em class="replaceable"><code>explainable_stmt</code></em> | FOR CONNECTION <em class="replaceable"><code>connection_id</code></em>}

<em class="replaceable"><code>explain_type</code></em>: {
    EXTENDED
  | PARTITIONS
  | FORMAT = <em class="replaceable"><code>format_name</code></em>
}

<em class="replaceable"><code>format_name</code></em>: {
    TRADITIONAL
  | JSON
}

<em class="replaceable"><code>explainable_stmt</code></em>: {
    SELECT statement
  | DELETE statement
  | INSERT statement
  | REPLACE statement
  | UPDATE statement
}
</pre><p>
            The <a class="link" href="sql-syntax.html#describe" title="13.8.1&nbsp;DESCRIBE Syntax"><code class="literal">DESCRIBE</code></a> and
            <a class="link" href="sql-syntax.html#explain" title="13.8.2&nbsp;EXPLAIN Syntax"><code class="literal">EXPLAIN</code></a> statements are synonyms. In
            practice, the <a class="link" href="sql-syntax.html#describe" title="13.8.1&nbsp;DESCRIBE Syntax"><code class="literal">DESCRIBE</code></a> keyword is
            more often used to obtain information about table structure,
            whereas <a class="link" href="sql-syntax.html#explain" title="13.8.2&nbsp;EXPLAIN Syntax"><code class="literal">EXPLAIN</code></a> is used to obtain a
            query execution plan (that is, an explanation of how MySQL would
            execute a query).
        </p><p style="color:blue;">描述和解释语句是同义词。实际上，describe关键字更常用于获取表结构的信息，而explain则用于获取查询执行计划（即mysql如何执行查询的解释）。</p><p>
            The following discussion uses the
            <a class="link" href="sql-syntax.html#describe" title="13.8.1&nbsp;DESCRIBE Syntax"><code class="literal">DESCRIBE</code></a> and
            <a class="link" href="sql-syntax.html#explain" title="13.8.2&nbsp;EXPLAIN Syntax"><code class="literal">EXPLAIN</code></a> keywords in accordance with
            those uses, but the MySQL parser treats them as completely
            synonymous.
        </p><p style="color:blue;">下面的讨论根据这些用法使用describe和explain关键字，但是mysql解析器将它们视为完全同义词。</p>
            <div class="itemizedlist">
                <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><a class="xref" href="sql-syntax.html#explain-table-structure" title="Obtaining Table Structure Information">Obtaining Table Structure Information</a></p><p style="color:blue;">获取表结构信息</p></li><li class="listitem"><p><a class="xref" href="sql-syntax.html#explain-execution-plan" title="Obtaining Execution Plan Information">Obtaining Execution Plan Information</a></p><p style="color:blue;">获取执行计划信息</p></li></ul>
            </div>

            <div class="simplesect">

                <div class="titlepage">
                    <div>

                        <div class="simple">
                            <h4 class="title"><a name="explain-table-structure"></a>Obtaining Table Structure Information</h4>

                        </div>

                    </div>

                </div>
                <p>
                    <a class="link" href="sql-syntax.html#describe" title="13.8.1&nbsp;DESCRIBE Syntax"><code class="literal">DESCRIBE</code></a> provides information
                    about the columns in a table:
                </p><p style="color:blue;">“说明”提供有关表中列的信息：</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>DESCRIBE City;</code></strong>
+------------+----------+------+-----+---------+----------------+
| Field      | Type     | Null | Key | Default | Extra          |
+------------+----------+------+-----+---------+----------------+
| Id         | int(11)  | NO   | PRI | NULL    | auto_increment |
| Name       | char(35) | NO   |     |         |                |
| Country    | char(3)  | NO   | UNI |         |                |
| District   | char(20) | YES  | MUL |         |                |
| Population | int(11)  | NO   |     | 0       |                |
+------------+----------+------+-----+---------+----------------+
</pre><p>
                <a class="link" href="sql-syntax.html#describe" title="13.8.1&nbsp;DESCRIBE Syntax"><code class="literal">DESCRIBE</code></a> is a shortcut for
                <a class="link" href="sql-syntax.html#show-columns" title="13.7.5.5&nbsp;SHOW COLUMNS Syntax"><code class="literal">SHOW COLUMNS</code></a>. These statements
                also display information for views. The description for
                <a class="link" href="sql-syntax.html#show-columns" title="13.7.5.5&nbsp;SHOW COLUMNS Syntax"><code class="literal">SHOW COLUMNS</code></a> provides more
                information about the output columns. See
                <a class="xref" href="sql-syntax.html#show-columns" title="13.7.5.5&nbsp;SHOW COLUMNS Syntax">Section&nbsp;13.7.5.5, “SHOW COLUMNS Syntax”</a>.
            </p><p style="color:blue;">“描述”是显示列的快捷方式。这些语句还显示视图的信息。“显示列”的说明提供了有关输出列的详细信息。见第13.7.5.5节“显示列语法”。</p><p>
                By default, <a class="link" href="sql-syntax.html#describe" title="13.8.1&nbsp;DESCRIBE Syntax"><code class="literal">DESCRIBE</code></a> displays
                information about all columns in the table.
                <em class="replaceable"><code>col_name</code></em>, if given, is the name of a
                column in the table. In this case, the statement displays
                information only for the named column.
                <em class="replaceable"><code>wild</code></em>, if given, is a pattern string.
                It can contain the SQL <code class="literal">%</code> and
                <code class="literal">_</code> wildcard characters. In this case, the
                statement displays output only for the columns with names
                matching the string. There is no need to enclose the string
                within quotation marks unless it contains spaces or other
                special characters.
            </p><p style="color:blue;">默认情况下，“描述”显示有关表中所有列的信息。col_name（如果给定）是表中列的名称。在这种情况下，语句仅显示命名列的信息。wild（如果给定）是一个模式字符串。它可以包含SQL%和通配符。在这种情况下，语句只显示名称与字符串匹配的列的输出。除非字符串包含空格或其他特殊字符，否则无需将其括在引号内。</p><a class="indexterm" name="idm140286825075488"></a><a class="indexterm" name="idm140286825074416"></a><p>
                The <a class="link" href="sql-syntax.html#describe" title="13.8.1&nbsp;DESCRIBE Syntax"><code class="literal">DESCRIBE</code></a> statement is
                provided for compatibility with Oracle.
            </p><p style="color:blue;">提供describe语句是为了与oracle兼容。</p><p>
                The <a class="link" href="sql-syntax.html#show-create-table" title="13.7.5.10&nbsp;SHOW CREATE TABLE Syntax"><code class="literal">SHOW CREATE TABLE</code></a>,
                <a class="link" href="sql-syntax.html#show-table-status" title="13.7.5.36&nbsp;SHOW TABLE STATUS Syntax"><code class="literal">SHOW TABLE STATUS</code></a>, and
                <a class="link" href="sql-syntax.html#show-index" title="13.7.5.22&nbsp;SHOW INDEX Syntax"><code class="literal">SHOW INDEX</code></a> statements also
                provide information about tables. See <a class="xref" href="sql-syntax.html#show" title="13.7.5&nbsp;SHOW Syntax">Section&nbsp;13.7.5, “SHOW Syntax”</a>.
            </p><p style="color:blue;">show create table、show table status和show index语句还提供有关表的信息。见第13.7.5节“显示语法”。</p>
            </div>
            <div class="simplesect">
                <div class="titlepage">
                    <div>
                        <div class="simple">
                            <h4 class="title"><a name="explain-execution-plan"></a>Obtaining Execution Plan Information</h4>

                        </div>

                    </div>

                </div>
                <p>
                    The <a class="link" href="sql-syntax.html#explain" title="13.8.2&nbsp;EXPLAIN Syntax"><code class="literal">EXPLAIN</code></a> statement provides
                    information about how MySQL executes statements:
                </p><p style="color:blue;">explain语句提供有关mysql如何执行语句的信息：</p>
                <div class="itemizedlist">
                    <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                        <a class="link" href="sql-syntax.html#explain" title="13.8.2&nbsp;EXPLAIN Syntax"><code class="literal">EXPLAIN</code></a> works with
                        <a class="link" href="sql-syntax.html#select" title="13.2.9&nbsp;SELECT Syntax"><code class="literal">SELECT</code></a>,
                        <a class="link" href="sql-syntax.html#delete" title="13.2.2&nbsp;DELETE Syntax"><code class="literal">DELETE</code></a>,
                        <a class="link" href="sql-syntax.html#insert" title="13.2.5&nbsp;INSERT Syntax"><code class="literal">INSERT</code></a>,
                        <a class="link" href="sql-syntax.html#replace" title="13.2.8&nbsp;REPLACE Syntax"><code class="literal">REPLACE</code></a>, and
                        <a class="link" href="sql-syntax.html#update" title="13.2.11&nbsp;UPDATE Syntax"><code class="literal">UPDATE</code></a> statements.
                    </p><p style="color:blue;">explain使用select、delete、insert、replace和update语句。</p></li><li class="listitem"><p>
                        When <a class="link" href="sql-syntax.html#explain" title="13.8.2&nbsp;EXPLAIN Syntax"><code class="literal">EXPLAIN</code></a> is used with an
                        explainable statement, MySQL displays information from the
                        optimizer about the statement execution plan. That is, MySQL
                        explains how it would process the statement, including
                        information about how tables are joined and in which order.
                        For information about using
                        <a class="link" href="sql-syntax.html#explain" title="13.8.2&nbsp;EXPLAIN Syntax"><code class="literal">EXPLAIN</code></a> to obtain execution
                        plan information, see <a class="xref" href="optimization.html#explain-output" title="8.8.2&nbsp;EXPLAIN Output Format">Section&nbsp;8.8.2, “EXPLAIN Output Format”</a>.
                    </p><p style="color:blue;">当explain与可解释语句一起使用时，mysql将显示来自优化器的有关语句执行计划的信息。也就是说，mysql解释了它将如何处理语句，包括有关如何联接表以及以何种顺序联接表的信息。有关使用explain获取执行计划信息的信息，请参阅第8.8.2节“explain output format”。</p></li><li class="listitem"><p>
                        When <a class="link" href="sql-syntax.html#explain" title="13.8.2&nbsp;EXPLAIN Syntax"><code class="literal">EXPLAIN</code></a> is used with
                        <code class="literal">FOR CONNECTION
                            <em class="replaceable"><code>connection_id</code></em></code> rather
                        than an explainable statement, it displays the execution
                        plan for the statement executing in the named connection.
                        See <a class="xref" href="optimization.html#explain-for-connection" title="8.8.4&nbsp;Obtaining Execution Plan Information for a Named Connection">Section&nbsp;8.8.4, “Obtaining Execution Plan Information for a Named Connection”</a>.
                    </p><p style="color:blue;">当explain与for connection connection\u id一起使用而不是可解释的语句时，它将显示在命名连接中执行的语句的执行计划。参见第8.8.4节“获取命名连接的执行计划信息”。</p></li><li class="listitem"><p>
                        For <a class="link" href="sql-syntax.html#select" title="13.2.9&nbsp;SELECT Syntax"><code class="literal">SELECT</code></a> statements,
                        <a class="link" href="sql-syntax.html#explain" title="13.8.2&nbsp;EXPLAIN Syntax"><code class="literal">EXPLAIN</code></a> produces additional
                        execution plan information that can be displayed using
                        <a class="link" href="sql-syntax.html#show-warnings" title="13.7.5.40&nbsp;SHOW WARNINGS Syntax"><code class="literal">SHOW WARNINGS</code></a>. See
                        <a class="xref" href="optimization.html#explain-extended" title="8.8.3&nbsp;Extended EXPLAIN Output Format">Section&nbsp;8.8.3, “Extended EXPLAIN Output Format”</a>.
                    </p><p style="color:blue;">对于select语句，explain生成可以使用show warnings显示的附加执行计划信息。见第8.8.3节，“扩展解释输出格式”。</p>
                        <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">

                            <div class="admon-title">
                                Note
                            </div>
                            <p>
                                In older MySQL releases, extended information was produced
                                using <a class="link" href="sql-syntax.html#explain" title="13.8.2&nbsp;EXPLAIN Syntax"><code class="literal">EXPLAIN
                                EXTENDED</code></a>. That syntax is still recognized for
                                backward compatibility but extended output is now enabled
                                by default, so the <code class="literal">EXTENDED</code> keyword is
                                superfluous and deprecated. Its use results in a warning,
                                and it is removed from
                                <a class="link" href="sql-syntax.html#explain" title="13.8.2&nbsp;EXPLAIN Syntax"><code class="literal">EXPLAIN</code></a> syntax in MySQL
                                8.0.
                            </p><p style="color:blue;">在旧的mysql版本中，扩展信息是使用explain extended生成的。由于向后兼容，仍然可以识别该语法，但现在默认情况下已启用扩展输出，因此扩展关键字是多余的，已弃用。它的使用会导致一个警告，并从mysql 8.0的explain语法中删除。</p>
                        </div>
                    </li><li class="listitem"><p>
                        <a class="link" href="sql-syntax.html#explain" title="13.8.2&nbsp;EXPLAIN Syntax"><code class="literal">EXPLAIN</code></a> is useful for
                        examining queries involving partitioned tables. See
                        <a class="xref" href="partitioning.html#partitioning-info" title="22.3.5&nbsp;Obtaining Information About Partitions">Section&nbsp;22.3.5, “Obtaining Information About Partitions”</a>.
                    </p><p style="color:blue;">explain对于检查涉及分区表的查询很有用。见第22.3.5节“获取分区信息”。</p>
                        <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">

                            <div class="admon-title">
                                Note
                            </div>
                            <p>
                                In older MySQL releases, partition information was
                                produced using
                                <a class="link" href="sql-syntax.html#explain" title="13.8.2&nbsp;EXPLAIN Syntax"><code class="literal">EXPLAIN
                                    PARTITIONS</code></a>. That syntax is still recognized for
                                backward compatibility but partition output is now enabled
                                by default, so the <code class="literal">PARTITIONS</code> keyword
                                is superfluous and deprecated. Its use results in a
                                warning, and it is removed from
                                <a class="link" href="sql-syntax.html#explain" title="13.8.2&nbsp;EXPLAIN Syntax"><code class="literal">EXPLAIN</code></a> syntax in MySQL
                                8.0.
                            </p><p style="color:blue;">在旧的MySQL发布中，使用解释分区生成分区信息。这种语法仍然是向后兼容的，但默认情况下分区输出现在启用，因此分区关键字是多余的和不推荐的。它的使用会导致一个警告，并从mysql 8.0的explain语法中删除。</p>
                        </div>
                    </li><li class="listitem"><p>
                        The <code class="literal">FORMAT</code> option can be used to select
                        the output format. <code class="literal">TRADITIONAL</code> presents
                        the output in tabular format. This is the default if no
                        <code class="literal">FORMAT</code> option is present.
                        <code class="literal">JSON</code> format displays the information in
                        JSON format.
                    </p><p style="color:blue;">format选项可用于选择输出格式。传统的以表格形式显示输出。如果不存在格式选项，则此为默认值。json格式以json格式显示信息。</p></li></ul>
                </div>
                <p>
                    <a class="link" href="sql-syntax.html#explain" title="13.8.2&nbsp;EXPLAIN Syntax"><code class="literal">EXPLAIN</code></a> requires the
                    <a class="link" href="security.html#priv_select"><code class="literal">SELECT</code></a> privilege for any tables
                    or views accessed, including any underlying tables of views. For
                    views, <a class="link" href="sql-syntax.html#explain" title="13.8.2&nbsp;EXPLAIN Syntax"><code class="literal">EXPLAIN</code></a> also requires the
                    <a class="link" href="security.html#priv_show-view"><code class="literal">SHOW VIEW</code></a> privilege.
                </p><p style="color:blue;">explain要求对访问的任何表或视图（包括任何基础视图表）具有选择权限。对于视图，“解释”还需要“显示视图”权限。</p><p>
                <a class="indexterm" name="idm140286825019568"></a>

                With the help of <a class="link" href="sql-syntax.html#explain" title="13.8.2&nbsp;EXPLAIN Syntax"><code class="literal">EXPLAIN</code></a>, you can
                see where you should add indexes to tables so that the statement
                executes faster by using indexes to find rows. You can also use
                <a class="link" href="sql-syntax.html#explain" title="13.8.2&nbsp;EXPLAIN Syntax"><code class="literal">EXPLAIN</code></a> to check whether the
                optimizer joins the tables in an optimal order. To give a hint
                to the optimizer to use a join order corresponding to the order
                in which the tables are named in a
                <a class="link" href="sql-syntax.html#select" title="13.2.9&nbsp;SELECT Syntax"><code class="literal">SELECT</code></a> statement, begin the
                statement with <code class="literal">SELECT STRAIGHT_JOIN</code> rather
                than just <a class="link" href="sql-syntax.html#select" title="13.2.9&nbsp;SELECT Syntax"><code class="literal">SELECT</code></a>. (See
                <a class="xref" href="sql-syntax.html#select" title="13.2.9&nbsp;SELECT Syntax">Section&nbsp;13.2.9, “SELECT Syntax”</a>.)
            </p><p style="color:blue;">在explain的帮助下，您可以看到应该在哪里向表添加索引，以便通过使用索引查找行来加快语句的执行速度。您还可以使用explain检查优化器是否以最佳顺序连接表。要提示优化器使用与select语句中表的命名顺序相对应的联接顺序，请使用select straight_join开始语句，而不仅仅是select。（见第13.2.9节，“选择语法”。）</p><p>
                The optimizer trace may sometimes provide information
                complementary to that of <a class="link" href="sql-syntax.html#explain" title="13.8.2&nbsp;EXPLAIN Syntax"><code class="literal">EXPLAIN</code></a>.
                However, the optimizer trace format and content are subject to
                change between versions. For details, see
                <a class="ulink" href="https://dev.mysql.com/doc/internals/en/optimizer-tracing.html" target="_top">MySQL
                    Internals: Tracing the Optimizer</a>.
            </p><p style="color:blue;">优化器跟踪有时可能提供与explain的信息互补的信息。但是，优化器跟踪格式和内容可能在不同版本之间发生更改。有关详细信息，请参见mysql内部：跟踪优化器。</p><p>
                If you have a problem with indexes not being used when you
                believe that they should be, run <a class="link" href="sql-syntax.html#analyze-table" title="13.7.2.1&nbsp;ANALYZE TABLE Syntax"><code class="literal">ANALYZE
                TABLE</code></a> to update table statistics, such as cardinality
                of keys, that can affect the choices the optimizer makes. See
                <a class="xref" href="sql-syntax.html#analyze-table" title="13.7.2.1&nbsp;ANALYZE TABLE Syntax">Section&nbsp;13.7.2.1, “ANALYZE TABLE Syntax”</a>.
            </p><p style="color:blue;">如果在认为应该使用索引时没有使用索引有问题，请运行analyze table来更新表统计信息，例如键的基数，这可能会影响优化器的选择。见第13.7.2.1节“分析表语法”。</p>
                <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">

                    <div class="admon-title">
                        Note
                    </div>
                    <p>
                        MySQL Workbench has a Visual Explain capability that provides a
                        visual representation of
                        <a class="link" href="sql-syntax.html#explain" title="13.8.2&nbsp;EXPLAIN Syntax"><code class="literal">EXPLAIN</code></a> output. See
                        <a class="ulink" href="https://dev.mysql.com/doc/workbench/en/wb-tutorial-visual-explain-dbt3.html" target="_top">Tutorial: Using Explain to Improve Query Performance</a>.
                    </p><p style="color:blue;">mysql工作台具有可视化解释功能，它提供了解释输出的可视化表示。请参阅教程：使用explain提高查询性能。</p>
                </div>

            </div>

        </div>
        <div class="section">
            <div class="titlepage">
                <div>
                    <div>
                        <h3 class="title"><a name="help"></a>13.8.3&nbsp;HELP Syntax</h3>

                    </div>

                </div>

            </div>
            <a class="indexterm" name="idm140286825002112"></a><pre data-lang="sql" class="programlisting">HELP '<em class="replaceable"><code>search_string</code></em>'
</pre><p>
            The <a class="link" href="sql-syntax.html#help" title="13.8.3&nbsp;HELP Syntax"><code class="literal">HELP</code></a> statement returns online
            information from the MySQL Reference Manual. Its proper operation
            requires that the help tables in the <code class="literal">mysql</code>
            database be initialized with help topic information (see
            <a class="xref" href="server-administration.html#server-side-help-support" title="5.1.13&nbsp;Server-Side Help Support">Section&nbsp;5.1.13, “Server-Side Help Support”</a>).
        </p><p style="color:blue;">帮助语句返回mysql参考手册中的联机信息。它的正确操作要求使用帮助主题信息初始化mysql数据库中的帮助表（请参阅5.1.13节，“服务器端帮助支持”）。</p><p>
            The <a class="link" href="sql-syntax.html#help" title="13.8.3&nbsp;HELP Syntax"><code class="literal">HELP</code></a> statement searches the
            help tables for the given search string and displays the result of
            the search. The search string is not case-sensitive.
        </p><p style="color:blue;">帮助语句在帮助表中搜索给定的搜索字符串，并显示搜索结果。搜索字符串不区分大小写。</p><p>
            The search string can contain the wildcard characters
            <code class="literal">%</code> and <code class="literal">_</code>. These have the same
            meaning as for pattern-matching operations performed with the
            <a class="link" href="functions.html#operator_like"><code class="literal">LIKE</code></a> operator. For example,
            <code class="literal">HELP 'rep%'</code> returns a list of topics that begin
            with <code class="literal">rep</code>.
        </p><p style="color:blue;">搜索字符串可以包含通配符%和\u。它们与使用like运算符执行的模式匹配操作具有相同的含义。例如，帮助'rep%'返回以rep开头的主题列表。</p><p>
            The HELP statement understands several types of search strings:
        </p><p style="color:blue;">帮助语句理解几种类型的搜索字符串：</p>
            <div class="itemizedlist">
                <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                    At the most general level, use <code class="literal">contents</code> to
                    retrieve a list of the top-level help categories:
                </p><p style="color:blue;">在最一般的级别上，使用内容检索顶级帮助类别的列表：</p><pre data-lang="sql" class="programlisting">HELP 'contents'
</pre></li><li class="listitem"><p>
                    For a list of topics in a given help category, such as
                    <code class="literal">Data Types</code>, use the category name:
                </p><p style="color:blue;">对于给定帮助类别中的主题列表（如数据类型），请使用类别名称：</p><pre data-lang="sql" class="programlisting">HELP 'data types'
</pre></li><li class="listitem"><p>
                    For help on a specific help topic, such as the
                    <a class="link" href="functions.html#function_ascii"><code class="literal">ASCII()</code></a> function or the
                    <a class="link" href="sql-syntax.html#create-table" title="13.1.18&nbsp;CREATE TABLE Syntax"><code class="literal">CREATE TABLE</code></a> statement, use the
                    associated keyword or keywords:
                </p><p style="color:blue;">有关特定帮助主题（如ascii（）函数或create table语句）的帮助，请使用相关的关键字：</p><pre data-lang="sql" class="programlisting">HELP 'ascii'
HELP 'create table'
</pre></li></ul>
            </div>
            <p>
                In other words, the search string matches a category, many topics,
                or a single topic. You cannot necessarily tell in advance whether
                a given search string will return a list of items or the help
                information for a single help topic. However, you can tell what
                kind of response <a class="link" href="sql-syntax.html#help" title="13.8.3&nbsp;HELP Syntax"><code class="literal">HELP</code></a> returned by
                examining the number of rows and columns in the result set.
            </p><p style="color:blue;">换句话说，搜索字符串匹配一个类别、多个主题或单个主题。您不必预先判断给定的搜索字符串是返回项目列表还是返回单个帮助主题的帮助信息。但是，可以通过检查结果集中的行数和列数来判断返回的响应帮助类型。</p><p>
            The following descriptions indicate the forms that the result set
            can take. Output for the example statements is shown using the
            familiar <span class="quote">“<span class="quote">tabular</span>”</span> or <span class="quote">“<span class="quote">vertical</span>”</span> format
            that you see when using the <a class="link" href="programs.html#mysql" title="4.5.1&nbsp;mysql — The MySQL Command-Line Client"><span class="command"><strong>mysql</strong></span></a> client, but
            note that <a class="link" href="programs.html#mysql" title="4.5.1&nbsp;mysql — The MySQL Command-Line Client"><span class="command"><strong>mysql</strong></span></a> itself reformats
            <a class="link" href="sql-syntax.html#help" title="13.8.3&nbsp;HELP Syntax"><code class="literal">HELP</code></a> result sets in a different
            way.
        </p><p style="color:blue;">以下描述指示结果集可以采用的形式。示例语句的输出使用您在使用mysql客户机时看到的熟悉的“表格”或“垂直”格式显示，但请注意，mysql本身以不同的方式重新格式化帮助结果集。</p>
            <div class="itemizedlist">
                <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                    Empty result set
                </p><p style="color:blue;">空结果集</p><p>
                    No match could be found for the search string.
                </p><p style="color:blue;">找不到搜索字符串的匹配项。</p></li><li class="listitem"><p>
                    Result set containing a single row with three columns
                </p><p style="color:blue;">包含一行三列的结果集</p><p>
                    This means that the search string yielded a hit for the help
                    topic. The result has three columns:
                </p><p style="color:blue;">这意味着搜索字符串对帮助主题产生了命中率。结果有三列：</p>
                    <div class="itemizedlist">
                        <ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
                            <code class="literal">name</code>: The topic name.
                        </p><p style="color:blue;">name：主题名。</p></li><li class="listitem"><p>
                            <code class="literal">description</code>: Descriptive help text for
                            the topic.
                        </p><p style="color:blue;">描述：主题的描述性帮助文本。</p></li><li class="listitem"><p>
                            <code class="literal">example</code>: Usage example or examples.
                            This column might be blank.
                        </p><p style="color:blue;">示例：用法示例。此列可能为空。</p></li></ul>
                    </div>
                    <p>
                        Example: <code class="literal">HELP 'replace'</code>
                    </p><p style="color:blue;">示例：帮助“替换”</p><p>
                        Yields:
                    </p><p style="color:blue;">产量：</p><pre data-lang="none" class="programlisting">name: REPLACE
description: Syntax:
REPLACE(str,from_str,to_str)

Returns the string str with all occurrences of the string from_str
replaced by the string to_str. REPLACE() performs a case-sensitive
match when searching for from_str.
example: mysql&gt; SELECT REPLACE('www.mysql.com', 'w', 'Ww');
        -&gt; 'WwWwWw.mysql.com'
</pre></li><li class="listitem"><p>
                    Result set containing multiple rows with two columns
                </p><p style="color:blue;">包含两列多行的结果集</p><p>
                    This means that the search string matched many help topics.
                    The result set indicates the help topic names:
                </p><p style="color:blue;">这意味着搜索字符串匹配许多帮助主题。结果集指示帮助主题名称：</p>
                    <div class="itemizedlist">
                        <ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
                            <code class="literal">name</code>: The help topic name.
                        </p><p style="color:blue;">名称：帮助主题名称。</p></li><li class="listitem"><p>
                            <code class="literal">is_it_category</code>: <code class="literal">Y</code> if
                            the name represents a help category, <code class="literal">N</code>
                            if it does not. If it does not, the
                            <code class="literal">name</code> value when specified as the
                            argument to the <a class="link" href="sql-syntax.html#help" title="13.8.3&nbsp;HELP Syntax"><code class="literal">HELP</code></a>
                            statement should yield a single-row result set containing
                            a description for the named item.
                        </p><p style="color:blue;">is_it_category：如果名称表示帮助类别，则为y；如果名称不表示帮助类别，则为n。如果没有，则当指定名称值作为帮助语句的参数时，该值应生成包含命名项说明的单行结果集。</p></li></ul>
                    </div>
                    <p>
                        Example: <code class="literal">HELP 'status'</code>
                    </p><p style="color:blue;">示例：帮助“状态”</p><p>
                        Yields:
                    </p><p style="color:blue;">产量：</p><pre data-lang="none" class="programlisting">+-----------------------+----------------+
| name                  | is_it_category |
+-----------------------+----------------+
| SHOW                  | N              |
| SHOW ENGINE           | N              |
| SHOW MASTER STATUS    | N              |
| SHOW PROCEDURE STATUS | N              |
| SHOW SLAVE STATUS     | N              |
| SHOW STATUS           | N              |
| SHOW TABLE STATUS     | N              |
+-----------------------+----------------+
</pre></li><li class="listitem"><p>
                    Result set containing multiple rows with three columns
                </p><p style="color:blue;">包含三列多行的结果集</p><p>
                    This means the search string matches a category. The result
                    set contains category entries:
                </p><p style="color:blue;">这意味着搜索字符串与类别匹配。结果集包含类别项：</p>
                    <div class="itemizedlist">
                        <ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
                            <code class="literal">source_category_name</code>: The help category
                            name.
                        </p><p style="color:blue;">源类别名称：帮助类别名称。</p></li><li class="listitem"><p>
                            <code class="literal">name</code>: The category or topic name
                        </p><p style="color:blue;">名称：类别或主题名称</p></li><li class="listitem"><p>
                            <code class="literal">is_it_category</code>: <code class="literal">Y</code> if
                            the name represents a help category, <code class="literal">N</code>
                            if it does not. If it does not, the
                            <code class="literal">name</code> value when specified as the
                            argument to the <a class="link" href="sql-syntax.html#help" title="13.8.3&nbsp;HELP Syntax"><code class="literal">HELP</code></a>
                            statement should yield a single-row result set containing
                            a description for the named item.
                        </p><p style="color:blue;">is_it_category：如果名称表示帮助类别，则为y；如果名称不表示帮助类别，则为n。如果没有，则当指定名称值作为帮助语句的参数时，该值应生成包含命名项说明的单行结果集。</p></li></ul>
                    </div>
                    <p>
                        Example: <code class="literal">HELP 'functions'</code>
                    </p><p style="color:blue;">示例：帮助“函数”</p><p>
                        Yields:
                    </p><p style="color:blue;">产量：</p><pre data-lang="none" class="programlisting">+----------------------+-------------------------+----------------+
| source_category_name | name                    | is_it_category |
+----------------------+-------------------------+----------------+
| Functions            | CREATE FUNCTION         | N              |
| Functions            | DROP FUNCTION           | N              |
| Functions            | Bit Functions           | Y              |
| Functions            | Comparison operators    | Y              |
| Functions            | Control flow functions  | Y              |
| Functions            | Date and Time Functions | Y              |
| Functions            | Encryption Functions    | Y              |
| Functions            | Information Functions   | Y              |
| Functions            | Logical operators       | Y              |
| Functions            | Miscellaneous Functions | Y              |
| Functions            | Numeric Functions       | Y              |
| Functions            | String Functions        | Y              |
+----------------------+-------------------------+----------------+
</pre></li></ul>
            </div>

        </div>
        <div class="section">
            <div class="titlepage">
                <div>
                    <div>
                        <h3 class="title"><a name="use"></a>13.8.4&nbsp;USE Syntax</h3>

                    </div>

                </div>

            </div>
            <a class="indexterm" name="idm140286824932576"></a><a class="indexterm" name="idm140286824931536"></a><pre data-lang="sql" class="programlisting">USE <em class="replaceable"><code>db_name</code></em>
</pre><p>
            The <a class="link" href="sql-syntax.html#use" title="13.8.4&nbsp;USE Syntax"><code class="literal">USE</code></a> statement tells MySQL to
            use the named database as the default (current) database for
            subsequent statements. This statement requires some privilege for
            the database or some object within it.
        </p><p style="color:blue;">use语句告诉mysql使用命名数据库作为后续语句的默认（当前）数据库。此语句要求数据库或其中某个对象具有某些特权。</p><p>
            The named database remains the default until the end of the
            session or another <a class="link" href="sql-syntax.html#use" title="13.8.4&nbsp;USE Syntax"><code class="literal">USE</code></a> statement is
            issued:
        </p><p style="color:blue;">在会话结束或发出另一个use语句之前，指定的数据库将保持默认值：</p><pre data-lang="sql" class="programlisting">USE db1;
SELECT COUNT(*) FROM mytable;   # selects from db1.mytable
USE db2;
SELECT COUNT(*) FROM mytable;   # selects from db2.mytable
</pre><p>
            The database name must be specified on a single line. Newlines in
            database names are not supported.
        </p><p style="color:blue;">必须在单行上指定数据库名称。不支持数据库名称中的换行符。</p><p>
            Making a particular database the default by means of the
            <a class="link" href="sql-syntax.html#use" title="13.8.4&nbsp;USE Syntax"><code class="literal">USE</code></a> statement does not preclude
            accessing tables in other databases. The following example
            accesses the <code class="literal">author</code> table from the
            <code class="literal">db1</code> database and the <code class="literal">editor</code>
            table from the <code class="literal">db2</code> database:
        </p><p style="color:blue;">通过use语句使特定数据库成为默认数据库并不排除访问其他数据库中的表。以下示例从db1数据库访问author表，从db2数据库访问editor表：</p><pre data-lang="sql" class="programlisting">USE db1;
SELECT author_name,editor_name FROM author,db2.editor
  WHERE author.editor_id = db2.editor.editor_id;
</pre>
        </div>

    </div>

</div>
<div class="copyright-footer">

</div>
<div class="navfooter">
    <hr>
    <table width="100%" summary="Navigation footer">
        <tbody><tr>
            <td width="40%" align="left"><a accesskey="p" href="functions.html">Prev</a></td>
            <td width="20%" align="center"><a accesskey="u" href="">Up</a></td>
            <td width="40%" align="right">&nbsp;<a accesskey="n" href="innodb-storage-engine.html">Next</a></td>
        </tr>
        <tr>
            <td width="40%" align="left" valign="top">Chapter&nbsp;12 Functions and Operators</td>
            <td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td>
            <td width="40%" align="right" valign="top">Chapter&nbsp;14 The InnoDB Storage Engine</td>
        </tr>
        </tbody></table>
</div>


</body></html>