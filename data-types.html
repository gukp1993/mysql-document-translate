<html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
    <title>Chapter&nbsp;11 Data Types</title>
    <link rel="stylesheet" href="mvl.css" type="text/css">
    <meta name="generator" content="DocBook XSL Stylesheets + chunker.py v1.9.2">
    <link rel="start" href="index.html" title="{book-title}">
    <link rel="up" href="" title="">
    <link rel="prev" href="charset.html" title="Chapter&nbsp;10 Character Sets, Collations, Unicode">
    <link rel="next" href="functions.html" title="Chapter&nbsp;12 Functions and Operators">
    <script src="https://code.jquery.com/jquery-3.3.1.min.js"></script><script src="https://code.jquery.com/jquery-3.3.1.min.js"></script><script src="https://code.jquery.com/jquery-3.3.1.min.js"></script></head>
<body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF">
<div class="navheader">
    <table width="100%" summary="Navigation header">
        <tbody><tr>
            <th colspan="3" align="center">Chapter&nbsp;11 Data Types</th>
        </tr>
        <tr>
            <td width="20%" align="left"><a accesskey="p" href="charset.html">Prev</a>&nbsp;</td>
            <th width="60%" align="center"></th>
            <td width="20%" align="right">&nbsp;<a accesskey="n" href="functions.html">Next</a></td>
        </tr>
        </tbody></table>
    <hr>
</div>
<div class="chapter">
    <div class="titlepage">
        <div>
            <div>
                <h1 class="title"><a name="data-types"></a>Chapter&nbsp;11&nbsp;Data Types</h1>

            </div>

        </div>

    </div>
    <div class="toc">
        <p><b>Table of Contents</b></p><p style="color:blue;">目录</p><p></p><dl class="toc"><dt><span class="section"><a href="data-types.html#data-type-overview">11.1 Data Type Overview</a></span></dt><dd><dl><dt><span class="section"><a href="data-types.html#numeric-type-overview">11.1.1 Numeric Type Overview</a></span></dt><dt><span class="section"><a href="data-types.html#date-and-time-type-overview">11.1.2 Date and Time Type Overview</a></span></dt><dt><span class="section"><a href="data-types.html#string-type-overview">11.1.3 String Type Overview</a></span></dt></dl></dd><dt><span class="section"><a href="data-types.html#numeric-types">11.2 Numeric Types</a></span></dt><dd><dl><dt><span class="section"><a href="data-types.html#integer-types">11.2.1 Integer Types (Exact Value) - INTEGER, INT, SMALLINT, TINYINT,
MEDIUMINT, BIGINT</a></span></dt><dt><span class="section"><a href="data-types.html#fixed-point-types">11.2.2 Fixed-Point Types (Exact Value) - DECIMAL, NUMERIC</a></span></dt><dt><span class="section"><a href="data-types.html#floating-point-types">11.2.3 Floating-Point Types (Approximate Value) - FLOAT, DOUBLE</a></span></dt><dt><span class="section"><a href="data-types.html#bit-type">11.2.4 Bit-Value Type - BIT</a></span></dt><dt><span class="section"><a href="data-types.html#numeric-type-attributes">11.2.5 Numeric Type Attributes</a></span></dt><dt><span class="section"><a href="data-types.html#out-of-range-and-overflow">11.2.6 Out-of-Range and Overflow Handling</a></span></dt></dl></dd><dt><span class="section"><a href="data-types.html#date-and-time-types">11.3 Date and Time Types</a></span></dt><dd><dl><dt><span class="section"><a href="data-types.html#datetime">11.3.1 The DATE, DATETIME, and TIMESTAMP Types</a></span></dt><dt><span class="section"><a href="data-types.html#time">11.3.2 The TIME Type</a></span></dt><dt><span class="section"><a href="data-types.html#year">11.3.3 The YEAR Type</a></span></dt><dt><span class="section"><a href="data-types.html#migrating-from-year2">11.3.4 2-Digit YEAR(2) Limitations and Migrating to 4-Digit YEAR</a></span></dt><dt><span class="section"><a href="data-types.html#timestamp-initialization">11.3.5 Automatic Initialization and Updating for TIMESTAMP and DATETIME</a></span></dt><dt><span class="section"><a href="data-types.html#fractional-seconds">11.3.6 Fractional Seconds in Time Values</a></span></dt><dt><span class="section"><a href="data-types.html#date-and-time-type-conversion">11.3.7 Conversion Between Date and Time Types</a></span></dt><dt><span class="section"><a href="data-types.html#two-digit-years">11.3.8 2-Digit Years in Dates</a></span></dt></dl></dd><dt><span class="section"><a href="data-types.html#string-types">11.4 String Types</a></span></dt><dd><dl><dt><span class="section"><a href="data-types.html#char">11.4.1 The CHAR and VARCHAR Types</a></span></dt><dt><span class="section"><a href="data-types.html#binary-varbinary">11.4.2 The BINARY and VARBINARY Types</a></span></dt><dt><span class="section"><a href="data-types.html#blob">11.4.3 The BLOB and TEXT Types</a></span></dt><dt><span class="section"><a href="data-types.html#enum">11.4.4 The ENUM Type</a></span></dt><dt><span class="section"><a href="data-types.html#set">11.4.5 The SET Type</a></span></dt></dl></dd><dt><span class="section"><a href="data-types.html#spatial-types">11.5 Spatial Data Types</a></span></dt><dd><dl><dt><span class="section"><a href="data-types.html#spatial-type-overview">11.5.1 Spatial Data Types</a></span></dt><dt><span class="section"><a href="data-types.html#opengis-geometry-model">11.5.2 The OpenGIS Geometry Model</a></span></dt><dt><span class="section"><a href="data-types.html#gis-data-formats">11.5.3 Supported Spatial Data Formats</a></span></dt><dt><span class="section"><a href="data-types.html#geometry-well-formedness-validity">11.5.4 Geometry Well-Formedness and Validity</a></span></dt><dt><span class="section"><a href="data-types.html#creating-spatial-columns">11.5.5 Creating Spatial Columns</a></span></dt><dt><span class="section"><a href="data-types.html#populating-spatial-columns">11.5.6 Populating Spatial Columns</a></span></dt><dt><span class="section"><a href="data-types.html#fetching-spatial-data">11.5.7 Fetching Spatial Data</a></span></dt><dt><span class="section"><a href="data-types.html#optimizing-spatial-analysis">11.5.8 Optimizing Spatial Analysis</a></span></dt><dt><span class="section"><a href="data-types.html#creating-spatial-indexes">11.5.9 Creating Spatial Indexes</a></span></dt><dt><span class="section"><a href="data-types.html#using-spatial-indexes">11.5.10 Using Spatial Indexes</a></span></dt></dl></dd><dt><span class="section"><a href="data-types.html#json">11.6 The JSON Data Type</a></span></dt><dt><span class="section"><a href="data-types.html#data-type-defaults">11.7 Data Type Default Values</a></span></dt><dt><span class="section"><a href="data-types.html#storage-requirements">11.8 Data Type Storage Requirements</a></span></dt><dt><span class="section"><a href="data-types.html#choosing-types">11.9 Choosing the Right Type for a Column</a></span></dt><dt><span class="section"><a href="data-types.html#other-vendor-data-types">11.10 Using Data Types from Other Database Engines</a></span></dt></dl>
    </div>
    <p>
        MySQL supports a number of <a class="link" href="glossary.html#glos_sql" title="SQL">SQL</a> data
        types in several categories: numeric types, date and time types,
        string (character and byte) types, spatial types, and the
        <a class="link" href="data-types.html#json" title="11.6&nbsp;The JSON Data Type"><code class="literal">JSON</code></a> data type. This chapter provides
        an overview of these data types, a more detailed description of the
        properties of the types in each category, and a summary of the data
        type storage requirements. The initial overview is intentionally
        brief. The more detailed descriptions later in the chapter should be
        consulted for additional information about particular data types,
        such as the permissible formats in which you can specify values.
    </p><p style="color:blue;">mysql支持多种类型的sql数据类型：数字类型、日期和时间类型、字符串（字符和字节）类型、空间类型和json数据类型。本章概述这些数据类型，更详细地描述每个类别中类型的属性，以及数据类型存储要求的摘要。最初的概述故意简短。有关特定数据类型的其他信息，如可以指定值的允许格式，请参阅本章后面更详细的说明。</p><p></p><a class="indexterm" name="idm140286861996544"></a><a class="indexterm" name="idm140286861995472"></a><a class="indexterm" name="idm140286861993984"></a><a class="indexterm" name="idm140286861992496"></a><p>
    Data type descriptions use these conventions:
</p><p style="color:blue;">数据类型描述使用以下约定：</p><p></p>
    <div class="itemizedlist">
        <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            For integer types, <em class="replaceable"><code>M</code></em> indicates the
            maximum display width. For floating-point and fixed-point types,
            <em class="replaceable"><code>M</code></em> is the total number of digits that
            can be stored (the precision). For string types,
            <em class="replaceable"><code>M</code></em> is the maximum length. The maximum
            permissible value of <em class="replaceable"><code>M</code></em> depends on the
            data type.
        </p><p style="color:blue;">对于整数类型，M表示最大显示宽度。对于浮点和定点类型，m是可以存储的总位数（精度）。对于字符串类型，M是最大长度。m的最大允许值取决于数据类型。</p><p></p><a class="indexterm" name="idm140286861987712"></a><a class="indexterm" name="idm140286861986640"></a><a class="indexterm" name="idm140286861985152"></a><a class="indexterm" name="idm140286861984080"></a><a class="indexterm" name="idm140286861982592"></a><a class="indexterm" name="idm140286861981520"></a></li><li class="listitem"><p>
            <a class="indexterm" name="idm140286861979392"></a>

            <a class="indexterm" name="idm140286861978320"></a>

            <a class="indexterm" name="idm140286861976832"></a>

            <a class="indexterm" name="idm140286861975760"></a>

            <em class="replaceable"><code>D</code></em> applies to floating-point and
            fixed-point types and indicates the number of digits following
            the decimal point (the scale). The maximum possible value is 30,
            but should be no greater than
            <em class="replaceable"><code>M</code></em>−2.
        </p><p style="color:blue;">d适用于浮点和定点类型，并指示小数点（刻度）后的位数。最大可能值为30，但不应大于m＝2。</p><p></p></li><li class="listitem"><p>
            <em class="replaceable"><code>fsp</code></em> applies to the
            <a class="link" href="data-types.html#time" title="11.3.2&nbsp;The TIME Type"><code class="literal">TIME</code></a>,
            <a class="link" href="data-types.html#datetime" title="11.3.1&nbsp;The DATE, DATETIME, and TIMESTAMP Types"><code class="literal">DATETIME</code></a>, and
            <a class="link" href="data-types.html#datetime" title="11.3.1&nbsp;The DATE, DATETIME, and TIMESTAMP Types"><code class="literal">TIMESTAMP</code></a> types and represents
            fractional seconds precision; that is, the number of digits
            following the decimal point for fractional parts of seconds. The
            <em class="replaceable"><code>fsp</code></em> value, if given, must be in the
            range 0 to 6. A value of 0 signifies that there is no fractional
            part. If omitted, the default precision is 0. (This differs from
            the standard SQL default of 6, for compatibility with previous
            MySQL versions.)
        </p><p style="color:blue;">fsp适用于时间、日期时间和时间戳类型，表示小数秒精度；也就是说，小数点后的位数表示小数秒的小数部分。fsp值（如果给定）必须在0到6的范围内。值为0表示不存在小数部分。如果省略，则默认精度为0。（这与标准的SQL默认值6不同，因为它与以前的MySQL版本兼容。）</p><p></p><a class="indexterm" name="idm140286861967728"></a><a class="indexterm" name="idm140286861966640"></a></li><li class="listitem"><p>
            Square brackets (<code class="literal">[</code> and <code class="literal">]</code>)
            indicate optional parts of type definitions.
        </p><p style="color:blue;">方括号（[和]）表示类型定义的可选部分。</p><p></p><a class="indexterm" name="idm140286861962912"></a><a class="indexterm" name="idm140286861961424"></a></li></ul>
    </div>

    <div class="section">

        <div class="titlepage">
            <div>
                <div>
                    <h2 class="title" style="clear: both"><a name="data-type-overview"></a>11.1&nbsp;Data Type Overview</h2>

                </div>

            </div>

        </div>

        <div class="toc">
            <dl class="toc"><dt><span class="section"><a href="data-types.html#numeric-type-overview">11.1.1 Numeric Type Overview</a></span></dt><dt><span class="section"><a href="data-types.html#date-and-time-type-overview">11.1.2 Date and Time Type Overview</a></span></dt><dt><span class="section"><a href="data-types.html#string-type-overview">11.1.3 String Type Overview</a></span></dt></dl>
        </div>
        <a class="indexterm" name="idm140286861958944"></a>
        <div class="section">

            <div class="titlepage">
                <div>
                    <div>
                        <h3 class="title"><a name="numeric-type-overview"></a>11.1.1&nbsp;Numeric Type Overview</h3>

                    </div>

                </div>

            </div>
            <a class="indexterm" name="idm140286861956352"></a><a class="indexterm" name="idm140286861955280"></a><a class="indexterm" name="idm140286861954208"></a><p>
            A summary of the numeric data types follows. For additional
            information about properties and storage requirements of the
            numeric types, see <a class="xref" href="data-types.html#numeric-types" title="11.2&nbsp;Numeric Types">Section&nbsp;11.2, “Numeric Types”</a>, and
            <a class="xref" href="data-types.html#storage-requirements" title="11.8&nbsp;Data Type Storage Requirements">Section&nbsp;11.8, “Data Type Storage Requirements”</a>.
        </p><p style="color:blue;">下面是数字数据类型的摘要。有关数值类型的属性和存储要求的其他信息，请参阅第11.2节“数值类型”和第11.8节“数据类型存储要求”。</p><p></p><p>
            For integer types, <em class="replaceable"><code>M</code></em> indicates the
            maximum display width. The maximum display width is 255. Display
            width is unrelated to the range of values a type can contain, as
            described in <a class="xref" href="data-types.html#numeric-types" title="11.2&nbsp;Numeric Types">Section&nbsp;11.2, “Numeric Types”</a>.
        </p><p style="color:blue;">对于整数类型，M表示最大显示宽度。最大显示宽度为255。显示宽度与类型可以包含的值范围无关，如第11.2节“数值类型”所述。</p><p></p><p>
            For floating-point and fixed-point types,
            <em class="replaceable"><code>M</code></em> is the total number of digits that
            can be stored.
        </p><p style="color:blue;">对于浮点和定点类型，m是可以存储的总位数。</p><p></p><p>
            If you specify <code class="literal">ZEROFILL</code> for a numeric column,
            MySQL automatically adds the <code class="literal">UNSIGNED</code>
            attribute to the column.
        </p><p style="color:blue;">如果为数字列指定零填充，mysql会自动向该列添加unsigned属性。</p><p></p><p>
            Numeric data types that permit the <code class="literal">UNSIGNED</code>
            attribute also permit <code class="literal">SIGNED</code>. However, these
            data types are signed by default, so the
            <code class="literal">SIGNED</code> attribute has no effect.
        </p><p style="color:blue;">允许无符号属性的数字数据类型也允许有符号。但是，这些数据类型在默认情况下是签名的，因此签名属性不起作用。</p><p></p><p>
            <code class="literal">SERIAL</code> is an alias for <code class="literal">BIGINT
            UNSIGNED NOT NULL AUTO_INCREMENT UNIQUE</code>.
        </p><p style="color:blue;">serial是bigint unsigned not null auto_increment unique的别名。</p><p></p><p>
            <code class="literal">SERIAL DEFAULT VALUE</code> in the definition of an
            integer column is an alias for <code class="literal">NOT NULL AUTO_INCREMENT
            UNIQUE</code>.
        </p><p style="color:blue;">整数列定义中的串行默认值是非空自动递增唯一的别名。</p><p></p>
            <div class="warning" style="margin-left: 0.5in; margin-right: 0.5in;">

                <div class="admon-title">
                    Warning
                </div>
                <p>
                    When you use subtraction between integer values where one is
                    of type <code class="literal">UNSIGNED</code>, the result is unsigned
                    unless the
                    <a class="link" href="server-administration.html#sqlmode_no_unsigned_subtraction"><code class="literal">NO_UNSIGNED_SUBTRACTION</code></a> SQL
                    mode is enabled. See <a class="xref" href="functions.html#cast-functions" title="12.10&nbsp;Cast Functions and Operators">Section&nbsp;12.10, “Cast Functions and Operators”</a>.
                </p><p style="color:blue;">如果在整数值之间使用减法（其中一个为无符号类型），则除非启用无符号减法SQL模式，否则结果为无符号。见第12.10节“浇铸函数和运算符”。</p><p></p>
            </div>
            <div class="itemizedlist">
                <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                    <a class="indexterm" name="idm140286861934384"></a>

                    <a class="indexterm" name="idm140286861933312"></a>

                    <a class="link" href="data-types.html#bit-type" title="11.2.4&nbsp;Bit-Value Type - BIT"><code class="literal">BIT[(<em class="replaceable"><code>M</code></em>)]</code></a>
                </p><p style="color:blue;">位[（m）]</p><p></p><p>
                    A bit-value type. <em class="replaceable"><code>M</code></em> indicates the
                    number of bits per value, from 1 to 64. The default is 1 if
                    <em class="replaceable"><code>M</code></em> is omitted.
                </p><p style="color:blue;">位值类型。m表示每个值的位数，从1到64。如果省略m，则默认值为1。</p><p></p></li><li class="listitem"><p>
                    <a class="indexterm" name="idm140286861925520"></a>

                    <a class="indexterm" name="idm140286861924448"></a>

                    <a class="link" href="data-types.html#integer-types" title="11.2.1&nbsp;Integer Types (Exact Value) - INTEGER, INT, SMALLINT, TINYINT, MEDIUMINT, BIGINT"><code class="literal">TINYINT[(<em class="replaceable"><code>M</code></em>)]
                        [UNSIGNED] [ZEROFILL]</code></a>
                </p><p style="color:blue;">tinyint[（m）][无符号][零填充]</p><p></p><p>
                    A very small integer. The signed range is
                    <code class="literal">-128</code> to <code class="literal">127</code>. The
                    unsigned range is <code class="literal">0</code> to
                    <code class="literal">255</code>.
                </p><p style="color:blue;">一个非常小的整数。有符号的范围是-128到127。无符号范围是0到255。</p><p></p></li><li class="listitem"><p>
                    <a class="indexterm" name="idm140286861914736"></a>

                    <a class="indexterm" name="idm140286861913664"></a>

                    <a class="indexterm" name="idm140286861912592"></a>

                    <a class="indexterm" name="idm140286861911104"></a>

                    <a class="link" href="data-types.html#integer-types" title="11.2.1&nbsp;Integer Types (Exact Value) - INTEGER, INT, SMALLINT, TINYINT, MEDIUMINT, BIGINT"><code class="literal">BOOL</code></a>,
                    <a class="link" href="data-types.html#integer-types" title="11.2.1&nbsp;Integer Types (Exact Value) - INTEGER, INT, SMALLINT, TINYINT, MEDIUMINT, BIGINT"><code class="literal">BOOLEAN</code></a>
                </p><p style="color:blue;">布尔值</p><p></p><p>
                    These types are synonyms for
                    <a class="link" href="data-types.html#integer-types" title="11.2.1&nbsp;Integer Types (Exact Value) - INTEGER, INT, SMALLINT, TINYINT, MEDIUMINT, BIGINT"><code class="literal">TINYINT(1)</code></a>. A value of zero
                    is considered false. Nonzero values are considered true:
                </p><p style="color:blue;">这些类型是tinyint（1）的同义词。值为零被认为是错误的。非零值视为真：</p><p></p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT IF(0, 'true', 'false');</code></strong>
+------------------------+
| IF(0, 'true', 'false') |
+------------------------+
| false                  |
+------------------------+

mysql&gt; <strong class="userinput"><code>SELECT IF(1, 'true', 'false');</code></strong>
+------------------------+
| IF(1, 'true', 'false') |
+------------------------+
| true                   |
+------------------------+

mysql&gt; <strong class="userinput"><code>SELECT IF(2, 'true', 'false');</code></strong>
+------------------------+
| IF(2, 'true', 'false') |
+------------------------+
| true                   |
+------------------------+
</pre><p>
                    However, the values <code class="literal">TRUE</code> and
                    <code class="literal">FALSE</code> are merely aliases for
                    <code class="literal">1</code> and <code class="literal">0</code>, respectively,
                    as shown here:
                </p><p style="color:blue;">但是，值true和false分别只是1和0的别名，如下所示：</p><p></p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT IF(0 = FALSE, 'true', 'false');</code></strong>
+--------------------------------+
| IF(0 = FALSE, 'true', 'false') |
+--------------------------------+
| true                           |
+--------------------------------+

mysql&gt; <strong class="userinput"><code>SELECT IF(1 = TRUE, 'true', 'false');</code></strong>
+-------------------------------+
| IF(1 = TRUE, 'true', 'false') |
+-------------------------------+
| true                          |
+-------------------------------+

mysql&gt; <strong class="userinput"><code>SELECT IF(2 = TRUE, 'true', 'false');</code></strong>
+-------------------------------+
| IF(2 = TRUE, 'true', 'false') |
+-------------------------------+
| false                         |
+-------------------------------+

mysql&gt; <strong class="userinput"><code>SELECT IF(2 = FALSE, 'true', 'false');</code></strong>
+--------------------------------+
| IF(2 = FALSE, 'true', 'false') |
+--------------------------------+
| false                          |
+--------------------------------+
</pre><p>
                    The last two statements display the results shown because
                    <code class="literal">2</code> is equal to neither
                    <code class="literal">1</code> nor <code class="literal">0</code>.
                </p><p style="color:blue;">最后两个语句显示所显示的结果，因为2既不等于1也不等于0。</p><p></p></li><li class="listitem"><p>
                    <a class="indexterm" name="idm140286861887376"></a>

                    <a class="indexterm" name="idm140286861886304"></a>

                    <a class="link" href="data-types.html#integer-types" title="11.2.1&nbsp;Integer Types (Exact Value) - INTEGER, INT, SMALLINT, TINYINT, MEDIUMINT, BIGINT"><code class="literal">SMALLINT[(<em class="replaceable"><code>M</code></em>)]
                        [UNSIGNED] [ZEROFILL]</code></a>
                </p><p style="color:blue;">smallint[（m）][无符号][零填充]</p><p></p><p>
                    A small integer. The signed range is
                    <code class="literal">-32768</code> to <code class="literal">32767</code>. The
                    unsigned range is <code class="literal">0</code> to
                    <code class="literal">65535</code>.
                </p><p style="color:blue;">一个小整数。有符号的范围是-32768到32767。无符号范围是0到65535。</p><p></p></li><li class="listitem"><p>
                    <a class="indexterm" name="idm140286861876528"></a>

                    <a class="indexterm" name="idm140286861875456"></a>

                    <a class="link" href="data-types.html#integer-types" title="11.2.1&nbsp;Integer Types (Exact Value) - INTEGER, INT, SMALLINT, TINYINT, MEDIUMINT, BIGINT"><code class="literal">MEDIUMINT[(<em class="replaceable"><code>M</code></em>)]
                        [UNSIGNED] [ZEROFILL]</code></a>
                </p><p style="color:blue;">中间点[（m）][无符号][零填充]</p><p></p><p>
                    A medium-sized integer. The signed range is
                    <code class="literal">-8388608</code> to <code class="literal">8388607</code>.
                    The unsigned range is <code class="literal">0</code> to
                    <code class="literal">16777215</code>.
                </p><p style="color:blue;">中等大小的整数。签名范围是-8388608到8388607。无符号范围是0到16777215。</p><p></p></li><li class="listitem"><p>
                    <a class="indexterm" name="idm140286861865696"></a>

                    <a class="indexterm" name="idm140286861864624"></a>

                    <a class="link" href="data-types.html#integer-types" title="11.2.1&nbsp;Integer Types (Exact Value) - INTEGER, INT, SMALLINT, TINYINT, MEDIUMINT, BIGINT"><code class="literal">INT[(<em class="replaceable"><code>M</code></em>)]
                        [UNSIGNED] [ZEROFILL]</code></a>
                </p><p style="color:blue;">int[（m）][无符号][零填充]</p><p></p><p>
                    A normal-size integer. The signed range is
                    <code class="literal">-2147483648</code> to
                    <code class="literal">2147483647</code>. The unsigned range is
                    <code class="literal">0</code> to <code class="literal">4294967295</code>.
                </p><p style="color:blue;">一个普通大小的整数。有符号的范围是-2147483648到2147483647。无符号范围是0到4294967295。</p><p></p></li><li class="listitem"><p>
                    <a class="indexterm" name="idm140286861855584"></a>

                    <a class="indexterm" name="idm140286861854512"></a>

                    <a class="link" href="data-types.html#integer-types" title="11.2.1&nbsp;Integer Types (Exact Value) - INTEGER, INT, SMALLINT, TINYINT, MEDIUMINT, BIGINT"><code class="literal">INTEGER[(<em class="replaceable"><code>M</code></em>)]
                        [UNSIGNED] [ZEROFILL]</code></a>
                </p><p style="color:blue;">整数[（m）][无符号][零填充]</p><p></p><p>
                    This type is a synonym for
                    <a class="link" href="data-types.html#integer-types" title="11.2.1&nbsp;Integer Types (Exact Value) - INTEGER, INT, SMALLINT, TINYINT, MEDIUMINT, BIGINT"><code class="literal">INT</code></a>.
                </p><p style="color:blue;">这种类型是int的同义词。</p><p></p></li><li class="listitem"><p>
                    <a class="indexterm" name="idm140286861846400"></a>

                    <a class="indexterm" name="idm140286861845328"></a>

                    <a class="indexterm" name="idm140286861843840"></a>

                    <a class="link" href="data-types.html#integer-types" title="11.2.1&nbsp;Integer Types (Exact Value) - INTEGER, INT, SMALLINT, TINYINT, MEDIUMINT, BIGINT"><code class="literal">BIGINT[(<em class="replaceable"><code>M</code></em>)]
                        [UNSIGNED] [ZEROFILL]</code></a>
                </p><p style="color:blue;">bigint[（m）][无符号][零填充]</p><p></p><p>
                    A large integer. The signed range is
                    <code class="literal">-9223372036854775808</code> to
                    <code class="literal">9223372036854775807</code>. The unsigned range
                    is <code class="literal">0</code> to
                    <code class="literal">18446744073709551615</code>.
                </p><p style="color:blue;">一个大整数。签名范围是-9223372036854775808到9223372036854775807。无符号范围是0到18446744073709551615。</p><p></p><p>
                    <code class="literal">SERIAL</code> is an alias for <code class="literal">BIGINT
                    UNSIGNED NOT NULL AUTO_INCREMENT UNIQUE</code>.
                </p><p style="color:blue;">serial是bigint unsigned not null auto_increment unique的别名。</p><p></p><p>
                    Some things you should be aware of with respect to
                    <a class="link" href="data-types.html#integer-types" title="11.2.1&nbsp;Integer Types (Exact Value) - INTEGER, INT, SMALLINT, TINYINT, MEDIUMINT, BIGINT"><code class="literal">BIGINT</code></a> columns:
                </p><p style="color:blue;">关于bigint列，您应该注意以下几点：</p><p></p>
                    <div class="itemizedlist">
                        <ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
                            <a class="indexterm" name="idm140286861832800"></a>

                            All arithmetic is done using signed
                            <a class="link" href="data-types.html#integer-types" title="11.2.1&nbsp;Integer Types (Exact Value) - INTEGER, INT, SMALLINT, TINYINT, MEDIUMINT, BIGINT"><code class="literal">BIGINT</code></a> or
                            <a class="link" href="data-types.html#floating-point-types" title="11.2.3&nbsp;Floating-Point Types (Approximate Value) - FLOAT, DOUBLE"><code class="literal">DOUBLE</code></a> values, so you
                            should not use unsigned big integers larger than
                            <code class="literal">9223372036854775807</code> (63 bits) except
                            with bit functions! If you do that, some of the last
                            digits in the result may be wrong because of rounding
                            errors when converting a
                            <a class="link" href="data-types.html#integer-types" title="11.2.1&nbsp;Integer Types (Exact Value) - INTEGER, INT, SMALLINT, TINYINT, MEDIUMINT, BIGINT"><code class="literal">BIGINT</code></a> value to a
                            <a class="link" href="data-types.html#floating-point-types" title="11.2.3&nbsp;Floating-Point Types (Approximate Value) - FLOAT, DOUBLE"><code class="literal">DOUBLE</code></a>.
                        </p><p style="color:blue;">所有的运算都是使用有符号的bigint或double值完成的，所以除了位函数之外，不应该使用大于9223372036854775807（63位）的无符号大整数！如果这样做，则结果中的某些最后数字可能是错误的，因为在将bigint值转换为double时会出现舍入错误。</p><p></p><p>
                            MySQL can handle <a class="link" href="data-types.html#integer-types" title="11.2.1&nbsp;Integer Types (Exact Value) - INTEGER, INT, SMALLINT, TINYINT, MEDIUMINT, BIGINT"><code class="literal">BIGINT</code></a>
                            in the following cases:
                        </p><p style="color:blue;">在以下情况下，mysql可以处理bigint：</p><p></p>
                            <div class="itemizedlist">
                                <ul class="itemizedlist" style="list-style-type: square; "><li class="listitem"><p>
                                    When using integers to store large unsigned values
                                    in a <a class="link" href="data-types.html#integer-types" title="11.2.1&nbsp;Integer Types (Exact Value) - INTEGER, INT, SMALLINT, TINYINT, MEDIUMINT, BIGINT"><code class="literal">BIGINT</code></a> column.
                                </p><p style="color:blue;">当使用整数在bigint列中存储大的无符号值时。</p><p></p></li><li class="listitem"><p>
                                    In
                                    <a class="link" href="functions.html#function_min"><code class="literal">MIN(<em class="replaceable"><code>col_name</code></em>)</code></a>
                                    or
                                    <a class="link" href="functions.html#function_max"><code class="literal">MAX(<em class="replaceable"><code>col_name</code></em>)</code></a>,
                                    where <em class="replaceable"><code>col_name</code></em> refers to
                                    a <a class="link" href="data-types.html#integer-types" title="11.2.1&nbsp;Integer Types (Exact Value) - INTEGER, INT, SMALLINT, TINYINT, MEDIUMINT, BIGINT"><code class="literal">BIGINT</code></a> column.
                                </p><p style="color:blue;">在min（col_name）或max（col_name）中，col_name指的是bigint列。</p><p></p></li><li class="listitem"><p>
                                    When using operators
                                    (<a class="link" href="functions.html#operator_plus"><code class="literal">+</code></a>,
                                    <a class="link" href="functions.html#operator_minus"><code class="literal">-</code></a>,
                                    <a class="link" href="functions.html#operator_times"><code class="literal">*</code></a>,
                                    and so on) where both operands are integers.
                                </p><p style="color:blue;">当使用两个操作数都是整数的运算符（+、-、*等）时。</p><p></p></li></ul>
                            </div>
                        </li><li class="listitem"><p>
                            You can always store an exact integer value in a
                            <a class="link" href="data-types.html#integer-types" title="11.2.1&nbsp;Integer Types (Exact Value) - INTEGER, INT, SMALLINT, TINYINT, MEDIUMINT, BIGINT"><code class="literal">BIGINT</code></a> column by storing
                            it using a string. In this case, MySQL performs a
                            string-to-number conversion that involves no
                            intermediate double-precision representation.
                        </p><p style="color:blue;">通过使用字符串存储bigint列，可以始终在其中存储一个精确的整数值。在本例中，mysql执行一个字符串到数字的转换，不涉及中间的双精度表示。</p><p></p></li><li class="listitem"><p>
                            The <a class="link" href="functions.html#operator_minus"><code class="literal">-</code></a>,
                            <a class="link" href="functions.html#operator_plus"><code class="literal">+</code></a>, and
                            <a class="link" href="functions.html#operator_times"><code class="literal">*</code></a>
                            operators use <a class="link" href="data-types.html#integer-types" title="11.2.1&nbsp;Integer Types (Exact Value) - INTEGER, INT, SMALLINT, TINYINT, MEDIUMINT, BIGINT"><code class="literal">BIGINT</code></a>
                            arithmetic when both operands are integer values. This
                            means that if you multiply two big integers (or results
                            from functions that return integers), you may get
                            unexpected results when the result is larger than
                            <code class="literal">9223372036854775807</code>.
                        </p><p style="color:blue;">当两个操作数都是整数值时-、+和*运算符使用bigint算术。这意味着，如果将两个大整数相乘（或由返回整数的函数产生的结果），当结果大于9223372036854775807时，可能会得到意外的结果。</p><p></p></li></ul>
                    </div>
                </li><li class="listitem"><p>
                    <a class="indexterm" name="idm140286861798896"></a>

                    <a class="indexterm" name="idm140286861797824"></a>

                    <a class="link" href="data-types.html#fixed-point-types" title="11.2.2&nbsp;Fixed-Point Types (Exact Value) - DECIMAL, NUMERIC"><code class="literal">DECIMAL[(<em class="replaceable"><code>M</code></em>[,<em class="replaceable"><code>D</code></em>])]
                        [UNSIGNED] [ZEROFILL]</code></a>
                </p><p style="color:blue;">十进制[（m[，d]）][无符号][零填充]</p><p></p><p>
                    A packed <span class="quote">“<span class="quote">exact</span>”</span> fixed-point number.
                    <em class="replaceable"><code>M</code></em> is the total number of digits
                    (the precision) and <em class="replaceable"><code>D</code></em> is the
                    number of digits after the decimal point (the scale). The
                    decimal point and (for negative numbers) the
                    <code class="literal">-</code> sign are not counted in
                    <em class="replaceable"><code>M</code></em>. If
                    <em class="replaceable"><code>D</code></em> is 0, values have no decimal
                    point or fractional part. The maximum number of digits
                    (<em class="replaceable"><code>M</code></em>) for
                    <a class="link" href="data-types.html#fixed-point-types" title="11.2.2&nbsp;Fixed-Point Types (Exact Value) - DECIMAL, NUMERIC"><code class="literal">DECIMAL</code></a> is 65. The maximum
                    number of supported decimals (<em class="replaceable"><code>D</code></em>)
                    is 30. If <em class="replaceable"><code>D</code></em> is omitted, the
                    default is 0. If <em class="replaceable"><code>M</code></em> is omitted,
                    the default is 10.
                </p><p style="color:blue;">一个压缩的“精确”定点数。m是总位数（精度），d是小数点（刻度）后的位数。小数点和（对于负数）符号不以m计。如果d为0，则值没有小数点或小数部分。十进制的最大位数（m）是65。支持小数（d）的最大数目是30。如果省略d，则默认值为0。如果省略m，则默认值为10。</p><p></p><p>
                    <code class="literal">UNSIGNED</code>, if specified, disallows
                    negative values.
                </p><p style="color:blue;">如果指定了unsigned，则不允许使用负值。</p><p></p><p>
                    All basic calculations (<code class="literal">+, -, *, /</code>) with
                    <a class="link" href="data-types.html#fixed-point-types" title="11.2.2&nbsp;Fixed-Point Types (Exact Value) - DECIMAL, NUMERIC"><code class="literal">DECIMAL</code></a> columns are done with
                    a precision of 65 digits.
                </p><p style="color:blue;">所有带小数列的基本计算（+，-，*，/）都以65位的精度完成。</p><p></p></li><li class="listitem"><p>
                    <a class="indexterm" name="idm140286861780896"></a>

                    <a class="indexterm" name="idm140286861779824"></a>

                    <a class="indexterm" name="idm140286861778752"></a>

                    <a class="indexterm" name="idm140286861777680"></a>

                    <a class="indexterm" name="idm140286861776224"></a>

                    <a class="indexterm" name="idm140286861774736"></a>

                    <a class="link" href="data-types.html#fixed-point-types" title="11.2.2&nbsp;Fixed-Point Types (Exact Value) - DECIMAL, NUMERIC"><code class="literal">DEC[(<em class="replaceable"><code>M</code></em>[,<em class="replaceable"><code>D</code></em>])]
                        [UNSIGNED] [ZEROFILL]</code></a>,
                    <a class="link" href="data-types.html#fixed-point-types" title="11.2.2&nbsp;Fixed-Point Types (Exact Value) - DECIMAL, NUMERIC"><code class="literal">NUMERIC[(<em class="replaceable"><code>M</code></em>[,<em class="replaceable"><code>D</code></em>])]
                        [UNSIGNED] [ZEROFILL]</code></a>,
                    <a class="link" href="data-types.html#fixed-point-types" title="11.2.2&nbsp;Fixed-Point Types (Exact Value) - DECIMAL, NUMERIC"><code class="literal">FIXED[(<em class="replaceable"><code>M</code></em>[,<em class="replaceable"><code>D</code></em>])]
                        [UNSIGNED] [ZEROFILL]</code></a>
                </p><p style="color:blue;">dec[（m[，d]）][无符号][零填充]，数字[（m[，d]）][无符号][零填充]，固定[（m[，d]）][无符号][零填充]</p><p></p><p>
                    These types are synonyms for
                    <a class="link" href="data-types.html#fixed-point-types" title="11.2.2&nbsp;Fixed-Point Types (Exact Value) - DECIMAL, NUMERIC"><code class="literal">DECIMAL</code></a>. The
                    <a class="link" href="data-types.html#fixed-point-types" title="11.2.2&nbsp;Fixed-Point Types (Exact Value) - DECIMAL, NUMERIC"><code class="literal">FIXED</code></a> synonym is available
                    for compatibility with other database systems.
                </p><p style="color:blue;">这些类型是decimal的同义词。固定的同义词可与其他数据库系统兼容。</p><p></p></li><li class="listitem"><p>
                    <a class="indexterm" name="idm140286861760800"></a>

                    <a class="indexterm" name="idm140286861759728"></a>

                    <a class="link" href="data-types.html#floating-point-types" title="11.2.3&nbsp;Floating-Point Types (Approximate Value) - FLOAT, DOUBLE"><code class="literal">FLOAT[(<em class="replaceable"><code>M</code></em>,<em class="replaceable"><code>D</code></em>)]
                        [UNSIGNED] [ZEROFILL]</code></a>
                </p><p style="color:blue;">浮点[（m，d）][无符号][零填充]</p><p></p><p>
                    A small (single-precision) floating-point number.
                    Permissible values are <code class="literal">-3.402823466E+38</code>
                    to <code class="literal">-1.175494351E-38</code>,
                    <code class="literal">0</code>, and <code class="literal">1.175494351E-38</code>
                    to <code class="literal">3.402823466E+38</code>. These are the
                    theoretical limits, based on the IEEE standard. The actual
                    range might be slightly smaller depending on your hardware
                    or operating system.
                </p><p style="color:blue;">一个小的（单精度）浮点数。允许值为-3.402823466E+38至-1.175494351E-38、0和1.175494351E-38至3.402823466E+38。这些是基于ieee标准的理论极限。根据硬件或操作系统的不同，实际范围可能会稍微小一些。</p><p></p><p>
                    <em class="replaceable"><code>M</code></em> is the total number of digits
                    and <em class="replaceable"><code>D</code></em> is the number of digits
                    following the decimal point. If <em class="replaceable"><code>M</code></em>
                    and <em class="replaceable"><code>D</code></em> are omitted, values are
                    stored to the limits permitted by the hardware. A
                    single-precision floating-point number is accurate to
                    approximately 7 decimal places.
                </p><p style="color:blue;">m是总位数，d是小数点后的位数。如果省略m和d，则将值存储到硬件允许的范围内。单精度浮点数精确到小数点后7位。</p><p></p><p>
                    <code class="literal">FLOAT(<em class="replaceable"><code>M</code></em>,<em class="replaceable"><code>D</code></em>)</code>
                    is a nonstandard MySQL extension.
                </p><p style="color:blue;">float（m，d）是一个非标准的mysql扩展。</p><p></p><p>
                    <code class="literal">UNSIGNED</code>, if specified, disallows
                    negative values.
                </p><p style="color:blue;">如果指定了unsigned，则不允许使用负值。</p><p></p><p>
                    Using <a class="link" href="data-types.html#floating-point-types" title="11.2.3&nbsp;Floating-Point Types (Approximate Value) - FLOAT, DOUBLE"><code class="literal">FLOAT</code></a> might give you
                    some unexpected problems because all calculations in MySQL
                    are done with double precision. See
                    <a class="xref" href="error-handling.html#no-matching-rows" title="B.4.4.7&nbsp;Solving Problems with No Matching Rows">Section&nbsp;B.4.4.7, “Solving Problems with No Matching Rows”</a>.
                </p><p style="color:blue;">使用float可能会带来一些意想不到的问题，因为mysql中的所有计算都是以双精度完成的。参见第B.4.4.7节“解决没有匹配行的问题”。</p><p></p></li><li class="listitem"><p>
                    <a class="indexterm" name="idm140286861742656"></a>

                    <a class="indexterm" name="idm140286861741584"></a>

                    <a class="indexterm" name="idm140286861740512"></a>

                    <a class="link" href="data-types.html#floating-point-types" title="11.2.3&nbsp;Floating-Point Types (Approximate Value) - FLOAT, DOUBLE"><code class="literal">FLOAT(<em class="replaceable"><code>p</code></em>)
                        [UNSIGNED] [ZEROFILL]</code></a>
                </p><p style="color:blue;">浮点（P）[无符号][零填充]</p><p></p><p>
                    A floating-point number. <em class="replaceable"><code>p</code></em>
                    represents the precision in bits, but MySQL uses this value
                    only to determine whether to use
                    <a class="link" href="data-types.html#floating-point-types" title="11.2.3&nbsp;Floating-Point Types (Approximate Value) - FLOAT, DOUBLE"><code class="literal">FLOAT</code></a> or
                    <a class="link" href="data-types.html#floating-point-types" title="11.2.3&nbsp;Floating-Point Types (Approximate Value) - FLOAT, DOUBLE"><code class="literal">DOUBLE</code></a> for the resulting data
                    type. If <em class="replaceable"><code>p</code></em> is from 0 to 24, the
                    data type becomes <a class="link" href="data-types.html#floating-point-types" title="11.2.3&nbsp;Floating-Point Types (Approximate Value) - FLOAT, DOUBLE"><code class="literal">FLOAT</code></a> with
                    no <em class="replaceable"><code>M</code></em> or
                    <em class="replaceable"><code>D</code></em> values. If
                    <em class="replaceable"><code>p</code></em> is from 25 to 53, the data type
                    becomes <a class="link" href="data-types.html#floating-point-types" title="11.2.3&nbsp;Floating-Point Types (Approximate Value) - FLOAT, DOUBLE"><code class="literal">DOUBLE</code></a> with no
                    <em class="replaceable"><code>M</code></em> or <em class="replaceable"><code>D</code></em>
                    values. The range of the resulting column is the same as for
                    the single-precision <a class="link" href="data-types.html#floating-point-types" title="11.2.3&nbsp;Floating-Point Types (Approximate Value) - FLOAT, DOUBLE"><code class="literal">FLOAT</code></a> or
                    double-precision <a class="link" href="data-types.html#floating-point-types" title="11.2.3&nbsp;Floating-Point Types (Approximate Value) - FLOAT, DOUBLE"><code class="literal">DOUBLE</code></a> data
                    types described earlier in this section.
                </p><p style="color:blue;">浮点数p表示以位为单位的精度，但mysql仅使用此值来确定是否对结果数据类型使用float或double。如果p从0到24，则数据类型变为float，没有m或d值。如果p从25到53，则数据类型变为double，没有m或d值。结果列的范围与本节前面描述的单精度浮点或双精度双精度数据类型的范围相同。</p><p></p><p>
                    <a class="indexterm" name="idm140286861725840"></a>

                    <a class="indexterm" name="idm140286861724768"></a>

                    <a class="link" href="data-types.html#floating-point-types" title="11.2.3&nbsp;Floating-Point Types (Approximate Value) - FLOAT, DOUBLE"><code class="literal">FLOAT(<em class="replaceable"><code>p</code></em>)</code></a>
                    syntax is provided for ODBC compatibility.
                </p><p style="color:blue;">float（p）语法是为了与odbc兼容而提供的。</p><p></p></li><li class="listitem"><p>
                    <a class="indexterm" name="idm140286861718784"></a>

                    <a class="indexterm" name="idm140286861717712"></a>

                    <a class="indexterm" name="idm140286861716640"></a>

                    <a class="indexterm" name="idm140286861715152"></a>

                    <a class="link" href="data-types.html#floating-point-types" title="11.2.3&nbsp;Floating-Point Types (Approximate Value) - FLOAT, DOUBLE"><code class="literal">DOUBLE[(<em class="replaceable"><code>M</code></em>,<em class="replaceable"><code>D</code></em>)]
                        [UNSIGNED] [ZEROFILL]</code></a>
                </p><p style="color:blue;">双[（m，d）][无符号][零填充]</p><p></p><p>
                    A normal-size (double-precision) floating-point number.
                    Permissible values are
                    <code class="literal">-1.7976931348623157E+308</code> to
                    <code class="literal">-2.2250738585072014E-308</code>,
                    <code class="literal">0</code>, and
                    <code class="literal">2.2250738585072014E-308</code> to
                    <code class="literal">1.7976931348623157E+308</code>. These are the
                    theoretical limits, based on the IEEE standard. The actual
                    range might be slightly smaller depending on your hardware
                    or operating system.
                </p><p style="color:blue;">正常大小（双精度）的浮点数。允许值为-1.7976931348623157E+308至-2.2250738585072014E-308、0和2.2250738585072014E-308至1.7976931348623157E+308。这些是基于ieee标准的理论极限。根据硬件或操作系统的不同，实际范围可能会稍微小一些。</p><p></p><p>
                    <em class="replaceable"><code>M</code></em> is the total number of digits
                    and <em class="replaceable"><code>D</code></em> is the number of digits
                    following the decimal point. If <em class="replaceable"><code>M</code></em>
                    and <em class="replaceable"><code>D</code></em> are omitted, values are
                    stored to the limits permitted by the hardware. A
                    double-precision floating-point number is accurate to
                    approximately 15 decimal places.
                </p><p style="color:blue;">m是总位数，d是小数点后的位数。如果省略m和d，则将值存储到硬件允许的范围内。双精度浮点数精确到小数点后15位。</p><p></p><p>
                    <code class="literal">DOUBLE(<em class="replaceable"><code>M</code></em>,<em class="replaceable"><code>D</code></em>)</code>
                    is a nonstandard MySQL extension.
                </p><p style="color:blue;">double（m，d）是一个非标准的mysql扩展。</p><p></p><p>
                    <code class="literal">UNSIGNED</code>, if specified, disallows
                    negative values.
                </p><p style="color:blue;">如果指定了unsigned，则不允许使用负值。</p><p></p></li><li class="listitem"><p>
                    <a class="indexterm" name="idm140286861699328"></a>

                    <a class="indexterm" name="idm140286861698240"></a>

                    <a class="indexterm" name="idm140286861697168"></a>

                    <a class="indexterm" name="idm140286861695680"></a>

                    <a class="link" href="data-types.html#floating-point-types" title="11.2.3&nbsp;Floating-Point Types (Approximate Value) - FLOAT, DOUBLE"><code class="literal">DOUBLE
                        PRECISION[(<em class="replaceable"><code>M</code></em>,<em class="replaceable"><code>D</code></em>)]
                        [UNSIGNED] [ZEROFILL]</code></a>,
                    <a class="link" href="data-types.html#floating-point-types" title="11.2.3&nbsp;Floating-Point Types (Approximate Value) - FLOAT, DOUBLE"><code class="literal">REAL[(<em class="replaceable"><code>M</code></em>,<em class="replaceable"><code>D</code></em>)]
                        [UNSIGNED] [ZEROFILL]</code></a>
                </p><p style="color:blue;">双精度[（m，d）][无符号][零填充]，实[（m，d）][无符号][零填充]</p><p></p><p>
                    These types are synonyms for
                    <a class="link" href="data-types.html#floating-point-types" title="11.2.3&nbsp;Floating-Point Types (Approximate Value) - FLOAT, DOUBLE"><code class="literal">DOUBLE</code></a>. Exception: If the
                    <a class="link" href="server-administration.html#sqlmode_real_as_float"><code class="literal">REAL_AS_FLOAT</code></a> SQL mode is
                    enabled, <a class="link" href="data-types.html#floating-point-types" title="11.2.3&nbsp;Floating-Point Types (Approximate Value) - FLOAT, DOUBLE"><code class="literal">REAL</code></a> is a synonym
                    for <a class="link" href="data-types.html#floating-point-types" title="11.2.3&nbsp;Floating-Point Types (Approximate Value) - FLOAT, DOUBLE"><code class="literal">FLOAT</code></a> rather than
                    <a class="link" href="data-types.html#floating-point-types" title="11.2.3&nbsp;Floating-Point Types (Approximate Value) - FLOAT, DOUBLE"><code class="literal">DOUBLE</code></a>.
                </p><p style="color:blue;">这些类型是double的同义词。异常：如果启用了real_as_float sql模式，real是float的同义词，而不是double。</p><p></p></li></ul>
            </div>

        </div>
        <div class="section">
            <div class="titlepage">
                <div>
                    <div>
                        <h3 class="title"><a name="date-and-time-type-overview"></a>11.1.2&nbsp;Date and Time Type Overview</h3>

                    </div>

                </div>

            </div>
            <p>
                A summary of the temporal data types follows. For additional
                information about properties and storage requirements of the
                temporal types, see <a class="xref" href="data-types.html#date-and-time-types" title="11.3&nbsp;Date and Time Types">Section&nbsp;11.3, “Date and Time Types”</a>, and
                <a class="xref" href="data-types.html#storage-requirements" title="11.8&nbsp;Data Type Storage Requirements">Section&nbsp;11.8, “Data Type Storage Requirements”</a>. For descriptions of
                functions that operate on temporal values, see
                <a class="xref" href="functions.html#date-and-time-functions" title="12.7&nbsp;Date and Time Functions">Section&nbsp;12.7, “Date and Time Functions”</a>.
            </p><p style="color:blue;">下面是时态数据类型的摘要。有关时态类型的属性和存储要求的更多信息，请参见第11.3节“日期和时间类型”和第11.8节“数据类型存储要求”。有关对时间值进行操作的函数的描述，请参见第12.7节“日期和时间函数”。</p><p></p><p>
            For the <a class="link" href="data-types.html#datetime" title="11.3.1&nbsp;The DATE, DATETIME, and TIMESTAMP Types"><code class="literal">DATE</code></a> and
            <a class="link" href="data-types.html#datetime" title="11.3.1&nbsp;The DATE, DATETIME, and TIMESTAMP Types"><code class="literal">DATETIME</code></a> range descriptions,
            <span class="quote">“<span class="quote">supported</span>”</span> means that although earlier values
            might work, there is no guarantee.
        </p><p style="color:blue;">对于日期和日期时间范围描述，“受支持”意味着尽管较早的值可能起作用，但不能保证。</p><p></p><a class="indexterm" name="idm140286861675264"></a><a class="indexterm" name="idm140286861674176"></a><p>
            MySQL permits fractional seconds for
            <a class="link" href="data-types.html#time" title="11.3.2&nbsp;The TIME Type"><code class="literal">TIME</code></a>,
            <a class="link" href="data-types.html#datetime" title="11.3.1&nbsp;The DATE, DATETIME, and TIMESTAMP Types"><code class="literal">DATETIME</code></a>, and
            <a class="link" href="data-types.html#datetime" title="11.3.1&nbsp;The DATE, DATETIME, and TIMESTAMP Types"><code class="literal">TIMESTAMP</code></a> values, with up to
            microseconds (6 digits) precision. To define a column that
            includes a fractional seconds part, use the syntax
            <code class="literal"><em class="replaceable"><code>type_name</code></em>(<em class="replaceable"><code>fsp</code></em>)</code>,
            where <em class="replaceable"><code>type_name</code></em> is
            <a class="link" href="data-types.html#time" title="11.3.2&nbsp;The TIME Type"><code class="literal">TIME</code></a>,
            <a class="link" href="data-types.html#datetime" title="11.3.1&nbsp;The DATE, DATETIME, and TIMESTAMP Types"><code class="literal">DATETIME</code></a>, or
            <a class="link" href="data-types.html#datetime" title="11.3.1&nbsp;The DATE, DATETIME, and TIMESTAMP Types"><code class="literal">TIMESTAMP</code></a>, and
            <em class="replaceable"><code>fsp</code></em> is the fractional seconds
            precision. For example:
        </p><p style="color:blue;">mysql允许时间、日期时间和时间戳值的小数秒，精度可达微秒（6位）。要定义包含小数秒部分的列，请使用语法type_name（fsp），其中type_name是time、datetime或timestamp，fsp是小数秒精度。例如：</p><p></p><pre data-lang="sql" class="programlisting">CREATE TABLE t1 (t TIME(3), dt DATETIME(6));
</pre><p>
            The <em class="replaceable"><code>fsp</code></em> value, if given, must be in
            the range 0 to 6. A value of 0 signifies that there is no
            fractional part. If omitted, the default precision is 0. (This
            differs from the standard SQL default of 6, for compatibility
            with previous MySQL versions.)
        </p><p style="color:blue;">fsp值（如果给定）必须在0到6的范围内。值为0表示不存在小数部分。如果省略，则默认精度为0。（这与标准的SQL默认值6不同，因为它与以前的MySQL版本兼容。）</p><p></p><p>
            Any <a class="link" href="data-types.html#datetime" title="11.3.1&nbsp;The DATE, DATETIME, and TIMESTAMP Types"><code class="literal">TIMESTAMP</code></a> or
            <a class="link" href="data-types.html#datetime" title="11.3.1&nbsp;The DATE, DATETIME, and TIMESTAMP Types"><code class="literal">DATETIME</code></a> column in a table can
            have automatic initialization and updating properties.
        </p><p style="color:blue;">表中的任何时间戳或日期时间列都可以具有自动初始化和更新属性。</p><p></p>
            <div class="itemizedlist">
                <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                    <a class="indexterm" name="idm140286861654608"></a>

                    <a class="indexterm" name="idm140286861653536"></a>

                    <a class="link" href="data-types.html#datetime" title="11.3.1&nbsp;The DATE, DATETIME, and TIMESTAMP Types"><code class="literal">DATE</code></a>
                </p><p style="color:blue;">日期</p><p></p><p>
                    A date. The supported range is
                    <code class="literal">'1000-01-01'</code> to
                    <code class="literal">'9999-12-31'</code>. MySQL displays
                    <a class="link" href="data-types.html#datetime" title="11.3.1&nbsp;The DATE, DATETIME, and TIMESTAMP Types"><code class="literal">DATE</code></a> values in
                    <code class="literal">'YYYY-MM-DD'</code> format, but permits
                    assignment of values to <a class="link" href="data-types.html#datetime" title="11.3.1&nbsp;The DATE, DATETIME, and TIMESTAMP Types"><code class="literal">DATE</code></a>
                    columns using either strings or numbers.
                </p><p style="color:blue;">约会。支持的范围是“1000-01-01”到“9999-12-31”。mysql以“yyyy-mm-dd”格式显示日期值，但允许使用字符串或数字将值分配给日期列。</p><p></p></li><li class="listitem"><p>
                    <a class="indexterm" name="idm140286861643024"></a>

                    <a class="indexterm" name="idm140286861641952"></a>

                    <a class="link" href="data-types.html#datetime" title="11.3.1&nbsp;The DATE, DATETIME, and TIMESTAMP Types"><code class="literal">DATETIME[(<em class="replaceable"><code>fsp</code></em>)]</code></a>
                </p><p style="color:blue;">日期时间[（fsp）]</p><p></p><p>
                    A date and time combination. The supported range is
                    <code class="literal">'1000-01-01 00:00:00.000000'</code> to
                    <code class="literal">'9999-12-31 23:59:59.999999'</code>. MySQL
                    displays <a class="link" href="data-types.html#datetime" title="11.3.1&nbsp;The DATE, DATETIME, and TIMESTAMP Types"><code class="literal">DATETIME</code></a> values in
                    <code class="literal">'<em class="replaceable"><code>YYYY-MM-DD
                        hh:mm:ss</code></em>[.<em class="replaceable"><code>fraction</code></em>]'</code>
                    format, but permits assignment of values to
                    <a class="link" href="data-types.html#datetime" title="11.3.1&nbsp;The DATE, DATETIME, and TIMESTAMP Types"><code class="literal">DATETIME</code></a> columns using either
                    strings or numbers.
                </p><p style="color:blue;">日期和时间的组合。支持的范围是“1000-01-01 00:00:00.000000”到“9999-12-31 23:59:59.999999”。mysql以“yyyy-mm-dd hh:mm:ss[.fraction]格式显示日期时间值，但允许使用字符串或数字将值分配给日期时间列。</p><p></p><p>
                    An optional <em class="replaceable"><code>fsp</code></em> value in the
                    range from 0 to 6 may be given to specify fractional seconds
                    precision. A value of 0 signifies that there is no
                    fractional part. If omitted, the default precision is 0.
                </p><p style="color:blue;">可以给出0到6范围内的可选fsp值，以指定小数秒精度。值为0表示不存在小数部分。如果省略，则默认精度为0。</p><p></p><p>
                    Automatic initialization and updating to the current date
                    and time for <a class="link" href="data-types.html#datetime" title="11.3.1&nbsp;The DATE, DATETIME, and TIMESTAMP Types"><code class="literal">DATETIME</code></a> columns
                    can be specified using <code class="literal">DEFAULT</code> and
                    <code class="literal">ON UPDATE</code> column definition clauses, as
                    described in <a class="xref" href="data-types.html#timestamp-initialization" title="11.3.5&nbsp;Automatic Initialization and Updating for TIMESTAMP and DATETIME">Section&nbsp;11.3.5, “Automatic Initialization and Updating for TIMESTAMP and DATETIME”</a>.
                </p><p style="color:blue;">可以使用default和on update列定义子句为date time列指定自动初始化和更新到当前日期和时间，如第11.3.5节“时间戳和日期时间的自动初始化和更新”中所述。</p><p></p></li><li class="listitem"><p>
                    <a class="indexterm" name="idm140286861624480"></a>

                    <a class="indexterm" name="idm140286861623408"></a>

                    <a class="link" href="data-types.html#datetime" title="11.3.1&nbsp;The DATE, DATETIME, and TIMESTAMP Types"><code class="literal">TIMESTAMP[(<em class="replaceable"><code>fsp</code></em>)]</code></a>
                </p><p style="color:blue;">时间戳[（fsp）]</p><p></p><p>
                    A timestamp. The range is <code class="literal">'1970-01-01
                    00:00:01.000000'</code> UTC to <code class="literal">'2038-01-19
                    03:14:07.999999'</code> UTC.
                    <a class="link" href="data-types.html#datetime" title="11.3.1&nbsp;The DATE, DATETIME, and TIMESTAMP Types"><code class="literal">TIMESTAMP</code></a> values are stored
                    as the number of seconds since the epoch
                    (<code class="literal">'1970-01-01 00:00:00'</code> UTC). A
                    <a class="link" href="data-types.html#datetime" title="11.3.1&nbsp;The DATE, DATETIME, and TIMESTAMP Types"><code class="literal">TIMESTAMP</code></a> cannot represent
                    the value <code class="literal">'1970-01-01 00:00:00'</code> because
                    that is equivalent to 0 seconds from the epoch and the value
                    0 is reserved for representing <code class="literal">'0000-00-00
                    00:00:00'</code>, the <span class="quote">“<span class="quote">zero</span>”</span>
                    <a class="link" href="data-types.html#datetime" title="11.3.1&nbsp;The DATE, DATETIME, and TIMESTAMP Types"><code class="literal">TIMESTAMP</code></a> value.
                </p><p style="color:blue;">时间戳。范围是“1970-01-01 00:00:01.000000”UTC到“2038-01-19 03:14:07.999999”UTC。时间戳值存储为自纪元以来的秒数（“1970-01-01 00:00:00”UTC）。时间戳不能表示值“1970-01-01 00:00:00”，因为这相当于从纪元开始的0秒，而值0保留用于表示“0000-00-00 00:00:00”（零）时间戳值。</p><p></p><p>
                    An optional <em class="replaceable"><code>fsp</code></em> value in the
                    range from 0 to 6 may be given to specify fractional seconds
                    precision. A value of 0 signifies that there is no
                    fractional part. If omitted, the default precision is 0.
                </p><p style="color:blue;">可以给出0到6范围内的可选fsp值，以指定小数秒精度。值为0表示不存在小数部分。如果省略，则默认精度为0。</p><p></p><p>
                    The way the server handles <code class="literal">TIMESTAMP</code>
                    definitions depends on the value of the
                    <a class="link" href="server-administration.html#sysvar_explicit_defaults_for_timestamp"><code class="literal">explicit_defaults_for_timestamp</code></a>
                    system variable (see
                    <a class="xref" href="server-administration.html#server-system-variables" title="5.1.7&nbsp;Server System Variables">Section&nbsp;5.1.7, “Server System Variables”</a>).
                </p><p style="color:blue;">服务器处理时间戳定义的方式取决于时间戳系统变量的显式默认值（请参阅第5.1.7节“服务器系统变量”）。</p><p></p><p>
                    If
                    <a class="link" href="server-administration.html#sysvar_explicit_defaults_for_timestamp"><code class="literal">explicit_defaults_for_timestamp</code></a>
                    is enabled, there is no automatic assignment of the
                    <code class="literal">DEFAULT CURRENT_TIMESTAMP</code> or <code class="literal">ON
                    UPDATE CURRENT_TIMESTAMP</code> attributes to any
                    <a class="link" href="data-types.html#datetime" title="11.3.1&nbsp;The DATE, DATETIME, and TIMESTAMP Types"><code class="literal">TIMESTAMP</code></a> column. They must
                    be included explicitly in the column definition. Also, any
                    <a class="link" href="data-types.html#datetime" title="11.3.1&nbsp;The DATE, DATETIME, and TIMESTAMP Types"><code class="literal">TIMESTAMP</code></a> not explicitly
                    declared as <code class="literal">NOT NULL</code> permits
                    <code class="literal">NULL</code> values.
                </p><p style="color:blue;">如果启用了explicit_defaults_for_timestamp，则不会自动将默认的current_timestamp或update current_timestamp属性分配给任何timestamp列。它们必须显式地包含在列定义中。此外，任何未显式声明为not null的时间戳都允许空值。</p><p></p><p>
                    If
                    <a class="link" href="server-administration.html#sysvar_explicit_defaults_for_timestamp"><code class="literal">explicit_defaults_for_timestamp</code></a>
                    is disabled, the server handles <code class="literal">TIMESTAMP</code>
                    as follows:
                </p><p style="color:blue;">如果禁用explicit_defaults_for_timestamp，服务器将按如下方式处理时间戳：</p><p></p><p>
                    Unless specified otherwise, the first
                    <a class="link" href="data-types.html#datetime" title="11.3.1&nbsp;The DATE, DATETIME, and TIMESTAMP Types"><code class="literal">TIMESTAMP</code></a> column in a table
                    is defined to be automatically set to the date and time of
                    the most recent modification if not explicitly assigned a
                    value. This makes <a class="link" href="data-types.html#datetime" title="11.3.1&nbsp;The DATE, DATETIME, and TIMESTAMP Types"><code class="literal">TIMESTAMP</code></a>
                    useful for recording the timestamp of an
                    <a class="link" href="sql-syntax.html#insert" title="13.2.5&nbsp;INSERT Syntax"><code class="literal">INSERT</code></a> or
                    <a class="link" href="sql-syntax.html#update" title="13.2.11&nbsp;UPDATE Syntax"><code class="literal">UPDATE</code></a> operation. You can
                    also set any <a class="link" href="data-types.html#datetime" title="11.3.1&nbsp;The DATE, DATETIME, and TIMESTAMP Types"><code class="literal">TIMESTAMP</code></a> column
                    to the current date and time by assigning it a
                    <code class="literal">NULL</code> value, unless it has been defined
                    with the <code class="literal">NULL</code> attribute to permit
                    <code class="literal">NULL</code> values.
                </p><p style="color:blue;">除非另有说明，否则表中的第一个时间戳列定义为，如果未显式分配值，则自动设置为最近修改的日期和时间。这使得时间戳对于记录插入或更新操作的时间戳非常有用。您还可以通过为当前日期和时间分配空值来将任何时间戳列设置为当前日期和时间，除非已使用null属性定义该列以允许空值。</p><p></p><p>
                    Automatic initialization and updating to the current date
                    and time can be specified using <code class="literal">DEFAULT
                    CURRENT_TIMESTAMP</code> and <code class="literal">ON UPDATE
                    CURRENT_TIMESTAMP</code> column definition clauses. By
                    default, the first <a class="link" href="data-types.html#datetime" title="11.3.1&nbsp;The DATE, DATETIME, and TIMESTAMP Types"><code class="literal">TIMESTAMP</code></a>
                    column has these properties, as previously noted. However,
                    any <a class="link" href="data-types.html#datetime" title="11.3.1&nbsp;The DATE, DATETIME, and TIMESTAMP Types"><code class="literal">TIMESTAMP</code></a> column in a
                    table can be defined to have these properties.
                </p><p style="color:blue;">可以使用默认的current_timestamp和on update current_timestamp列定义子句指定当前日期和时间的自动初始化和更新。默认情况下，如前所述，第一个timestamp列具有这些属性。但是，表中的任何时间戳列都可以定义为具有这些属性。</p><p></p></li><li class="listitem"><p>
                    <a class="indexterm" name="idm140286861580752"></a>

                    <a class="indexterm" name="idm140286861579680"></a>

                    <a class="link" href="data-types.html#time" title="11.3.2&nbsp;The TIME Type"><code class="literal">TIME[(<em class="replaceable"><code>fsp</code></em>)]</code></a>
                </p><p style="color:blue;">时间[（fsp）]</p><p></p><p>
                    A time. The range is <code class="literal">'-838:59:59.000000'</code>
                    to <code class="literal">'838:59:59.000000'</code>. MySQL displays
                    <a class="link" href="data-types.html#time" title="11.3.2&nbsp;The TIME Type"><code class="literal">TIME</code></a> values in
                    <code class="literal">'<em class="replaceable"><code>hh:mm:ss</code></em>[.<em class="replaceable"><code>fraction</code></em>]'</code>
                    format, but permits assignment of values to
                    <a class="link" href="data-types.html#time" title="11.3.2&nbsp;The TIME Type"><code class="literal">TIME</code></a> columns using either
                    strings or numbers.
                </p><p style="color:blue;">一次。范围是'-838:59:59.000000'到'838:59:59.000000'。mysql以'hh:mm:ss[.fraction]'格式显示时间值，但允许使用字符串或数字将值分配给时间列。</p><p></p><p>
                    An optional <em class="replaceable"><code>fsp</code></em> value in the
                    range from 0 to 6 may be given to specify fractional seconds
                    precision. A value of 0 signifies that there is no
                    fractional part. If omitted, the default precision is 0.
                </p><p style="color:blue;">可以给出0到6范围内的可选fsp值，以指定小数秒精度。值为0表示不存在小数部分。如果省略，则默认精度为0。</p><p></p></li><li class="listitem"><p>
                    <a class="indexterm" name="idm140286861566960"></a>

                    <a class="indexterm" name="idm140286861565888"></a>

                    <a class="link" href="data-types.html#year" title="11.3.3&nbsp;The YEAR Type"><code class="literal">YEAR[(4)]</code></a>
                </p><p style="color:blue;">第[（4）年]</p><p></p><p>
                    A year in 4-digit format. MySQL displays
                    <a class="link" href="data-types.html#year" title="11.3.3&nbsp;The YEAR Type"><code class="literal">YEAR</code></a> values in
                    <code class="literal">YYYY</code> format, but permits assignment of
                    values to <a class="link" href="data-types.html#year" title="11.3.3&nbsp;The YEAR Type"><code class="literal">YEAR</code></a> columns using
                    either strings or numbers. Values display as
                    <code class="literal">1901</code> to <code class="literal">2155</code>, and
                    <code class="literal">0000</code>.
                </p><p style="color:blue;">四位数格式的一年。mysql以yyyy格式显示年份值，但允许使用字符串或数字将值分配给年份列。值显示为1901到2155和0000。</p><p></p>
                    <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">

                        <div class="admon-title">
                            Note
                        </div>
                        <p>
                            The <a class="link" href="data-types.html#year" title="11.3.3&nbsp;The YEAR Type"><code class="literal">YEAR(2)</code></a> data type is
                            deprecated and support for it is removed in MySQL 5.7.5.
                            To convert <a class="link" href="data-types.html#year" title="11.3.3&nbsp;The YEAR Type"><code class="literal">YEAR(2)</code></a> columns
                            to <a class="link" href="data-types.html#year" title="11.3.3&nbsp;The YEAR Type"><code class="literal">YEAR(4)</code></a>, see
                            <a class="xref" href="data-types.html#migrating-from-year2" title="11.3.4&nbsp;2-Digit YEAR(2) Limitations and Migrating to 4-Digit YEAR">Section&nbsp;11.3.4, “2-Digit YEAR(2) Limitations and Migrating to 4-Digit YEAR”</a>.
                        </p><p style="color:blue;">不推荐使用year（2）数据类型，在mysql 5.7.5中不再支持它。要将年份（2）列转换为年份（4），请参见第11.3.4节，“2位数年份（2）限制和迁移到4位数年份”。</p><p></p>
                    </div>
                    <p>
                        For additional information about
                        <a class="link" href="data-types.html#year" title="11.3.3&nbsp;The YEAR Type"><code class="literal">YEAR</code></a> display format and
                        interpretation of input values, see <a class="xref" href="data-types.html#year" title="11.3.3&nbsp;The YEAR Type">Section&nbsp;11.3.3, “The YEAR Type”</a>.
                    </p><p style="color:blue;">有关年份显示格式和输入值解释的其他信息，请参见第11.3.3节“年份类型”。</p><p></p></li></ul>
            </div>
            <p>
                The <a class="link" href="functions.html#function_sum"><code class="literal">SUM()</code></a> and
                <a class="link" href="functions.html#function_avg"><code class="literal">AVG()</code></a> aggregate functions do not
                work with temporal values. (They convert the values to numbers,
                losing everything after the first nonnumeric character.) To work
                around this problem, convert to numeric units, perform the
                aggregate operation, and convert back to a temporal value.
                Examples:
            </p><p style="color:blue;">sum（）和avg（）聚合函数不能处理时间值。（它们将值转换为数字，在第一个非数字字符之后丢失所有内容。）若要解决此问题，请转换为数字单位，执行聚合操作，然后转换回时间值。示例：</p><p></p><pre data-lang="sql" class="programlisting">SELECT SEC_TO_TIME(SUM(TIME_TO_SEC(<em class="replaceable"><code>time_col</code></em>))) FROM <em class="replaceable"><code>tbl_name</code></em>;
SELECT FROM_DAYS(SUM(TO_DAYS(<em class="replaceable"><code>date_col</code></em>))) FROM <em class="replaceable"><code>tbl_name</code></em>;
</pre>
            <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">

                <div class="admon-title">
                    Note
                </div>
                <p>
                    The MySQL server can be run with the
                    <a class="link" href="server-administration.html#sqlmode_maxdb"><code class="literal">MAXDB</code></a> SQL mode enabled. In
                    this case, <a class="link" href="data-types.html#datetime" title="11.3.1&nbsp;The DATE, DATETIME, and TIMESTAMP Types"><code class="literal">TIMESTAMP</code></a> is
                    identical with <a class="link" href="data-types.html#datetime" title="11.3.1&nbsp;The DATE, DATETIME, and TIMESTAMP Types"><code class="literal">DATETIME</code></a>. If
                    this mode is enabled at the time that a table is created,
                    <a class="link" href="data-types.html#datetime" title="11.3.1&nbsp;The DATE, DATETIME, and TIMESTAMP Types"><code class="literal">TIMESTAMP</code></a> columns are created
                    as <a class="link" href="data-types.html#datetime" title="11.3.1&nbsp;The DATE, DATETIME, and TIMESTAMP Types"><code class="literal">DATETIME</code></a> columns. As a
                    result, such columns use
                    <a class="link" href="data-types.html#datetime" title="11.3.1&nbsp;The DATE, DATETIME, and TIMESTAMP Types"><code class="literal">DATETIME</code></a> display format, have
                    the same range of values, and there is no automatic
                    initialization or updating to the current date and time. See
                    <a class="xref" href="server-administration.html#sql-mode" title="5.1.10&nbsp;Server SQL Modes">Section&nbsp;5.1.10, “Server SQL Modes”</a>.
                </p><p style="color:blue;">mysql服务器可以在启用maxdb sql模式的情况下运行。在本例中，时间戳与日期时间相同。如果在创建表时启用此模式，则将时间戳列创建为日期时间列。因此，这些列使用日期时间显示格式，具有相同的值范围，并且没有自动初始化或更新到当前日期和时间。参见第5.1.10节“服务器SQL模式”。</p><p></p>
            </div>
            <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">
                <div class="admon-title">
                    Note
                </div>
                <p>
                    As of MySQL 5.7.22, <a class="link" href="server-administration.html#sqlmode_maxdb"><code class="literal">MAXDB</code></a> is
                    deprecated. It will be removed in a future version of MySQL.
                </p><p style="color:blue;">从mysql 5.7.22开始，maxdb已被弃用。它将在mysql的未来版本中被删除。</p><p></p>
            </div>

        </div>
        <div class="section">
            <div class="titlepage">
                <div>
                    <div>
                        <h3 class="title"><a name="string-type-overview"></a>11.1.3&nbsp;String Type Overview</h3>

                    </div>

                </div>

            </div>
            <p>
                A summary of the string data types follows. For additional
                information about properties and storage requirements of the
                string types, see <a class="xref" href="data-types.html#string-types" title="11.4&nbsp;String Types">Section&nbsp;11.4, “String Types”</a>, and
                <a class="xref" href="data-types.html#storage-requirements" title="11.8&nbsp;Data Type Storage Requirements">Section&nbsp;11.8, “Data Type Storage Requirements”</a>.
            </p><p style="color:blue;">下面是字符串数据类型的摘要。有关字符串类型的属性和存储要求的其他信息，请参阅第11.4节“字符串类型”和第11.8节“数据类型存储要求”。</p><p></p><p>
            In some cases, MySQL may change a string column to a type
            different from that given in a <a class="link" href="sql-syntax.html#create-table" title="13.1.18&nbsp;CREATE TABLE Syntax"><code class="literal">CREATE
            TABLE</code></a> or <a class="link" href="sql-syntax.html#alter-table" title="13.1.8&nbsp;ALTER TABLE Syntax"><code class="literal">ALTER TABLE</code></a>
            statement. See <a class="xref" href="sql-syntax.html#silent-column-changes" title="13.1.18.7&nbsp;Silent Column Specification Changes">Section&nbsp;13.1.18.7, “Silent Column Specification Changes”</a>.
        </p><p style="color:blue;">在某些情况下，mysql可能会将字符串列更改为不同于create table或alter table语句中给定的类型。见第13.1.18.7节，“无声柱规范变更”。</p><p></p><p>
            MySQL interprets length specifications in character column
            definitions in character units. This applies to
            <a class="link" href="data-types.html#char" title="11.4.1&nbsp;The CHAR and VARCHAR Types"><code class="literal">CHAR</code></a>,
            <a class="link" href="data-types.html#char" title="11.4.1&nbsp;The CHAR and VARCHAR Types"><code class="literal">VARCHAR</code></a>, and the
            <a class="link" href="data-types.html#blob" title="11.4.3&nbsp;The BLOB and TEXT Types"><code class="literal">TEXT</code></a> types.
        </p><p style="color:blue;">mysql以字符单位解释字符列定义中的长度规范。这适用于char、varchar和文本类型。</p><p></p><p>
            Column definitions for character string data types
            <a class="link" href="data-types.html#char" title="11.4.1&nbsp;The CHAR and VARCHAR Types"><code class="literal">CHAR</code></a>,
            <a class="link" href="data-types.html#char" title="11.4.1&nbsp;The CHAR and VARCHAR Types"><code class="literal">VARCHAR</code></a>, the
            <a class="link" href="data-types.html#blob" title="11.4.3&nbsp;The BLOB and TEXT Types"><code class="literal">TEXT</code></a> types,
            <a class="link" href="data-types.html#enum" title="11.4.4&nbsp;The ENUM Type"><code class="literal">ENUM</code></a>,
            <a class="link" href="data-types.html#set" title="11.4.5&nbsp;The SET Type"><code class="literal">SET</code></a>, and any synonyms) can
            specify the column character set and collation:
        </p><p style="color:blue;">字符串数据类型char、varchar、文本类型、枚举、集和任何同义词的列定义）可以指定列字符集和排序规则：</p><p></p>
            <div class="itemizedlist">
                <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                    <code class="literal">CHARACTER SET</code> specifies the character
                    set. If desired, a collation for the character set can be
                    specified with the <code class="literal">COLLATE</code> attribute,
                    along with any other attributes. For example:
                </p><p style="color:blue;">字符集指定字符集。如果需要，可以使用collate属性和任何其他属性指定字符集的排序规则。例如：</p><p></p><pre data-lang="sql" class="programlisting">CREATE TABLE t
(
    c1 VARCHAR(20) CHARACTER SET utf8,
    c2 TEXT CHARACTER SET latin1 COLLATE latin1_general_cs
);
</pre><p>
                    This table definition creates a column named
                    <code class="literal">c1</code> that has a character set of
                    <code class="literal">utf8</code> with the default collation for that
                    character set, and a column named <code class="literal">c2</code> that
                    has a character set of <code class="literal">latin1</code> and a
                    case-sensitive collation.
                </p><p style="color:blue;">此表定义创建名为c1的列，该列的字符集为utf8，具有该字符集的默认排序规则；创建名为c2的列，该列的字符集为latin1，并且具有区分大小写的排序规则。</p><p></p><p>
                    The rules for assigning the character set and collation when
                    either or both of <code class="literal">CHARACTER SET</code> and the
                    <code class="literal">COLLATE</code> attribute are missing are
                    described in <a class="xref" href="charset.html#charset-column" title="10.3.5&nbsp;Column Character Set and Collation">Section&nbsp;10.3.5, “Column Character Set and Collation”</a>.
                </p><p style="color:blue;">第10.3.5节“列字符集和排序规则”描述了在缺少字符集和排序规则属性中的一个或两个时分配字符集和排序规则。</p><p></p><p>
                    <code class="literal">CHARSET</code> is a synonym for
                    <code class="literal">CHARACTER SET</code>.
                </p><p style="color:blue;">字符集是字符集的同义词。</p><p></p></li><li class="listitem"><p>
                    Specifying the <code class="literal">CHARACTER SET binary</code>
                    attribute for a character string data type causes the column
                    to be created as the corresponding binary string data type:
                    <a class="link" href="data-types.html#char" title="11.4.1&nbsp;The CHAR and VARCHAR Types"><code class="literal">CHAR</code></a> becomes
                    <a class="link" href="data-types.html#binary-varbinary" title="11.4.2&nbsp;The BINARY and VARBINARY Types"><code class="literal">BINARY</code></a>,
                    <a class="link" href="data-types.html#char" title="11.4.1&nbsp;The CHAR and VARCHAR Types"><code class="literal">VARCHAR</code></a> becomes
                    <a class="link" href="data-types.html#binary-varbinary" title="11.4.2&nbsp;The BINARY and VARBINARY Types"><code class="literal">VARBINARY</code></a>, and
                    <a class="link" href="data-types.html#blob" title="11.4.3&nbsp;The BLOB and TEXT Types"><code class="literal">TEXT</code></a> becomes
                    <a class="link" href="data-types.html#blob" title="11.4.3&nbsp;The BLOB and TEXT Types"><code class="literal">BLOB</code></a>. For the
                    <a class="link" href="data-types.html#enum" title="11.4.4&nbsp;The ENUM Type"><code class="literal">ENUM</code></a> and
                    <a class="link" href="data-types.html#set" title="11.4.5&nbsp;The SET Type"><code class="literal">SET</code></a> data types, this does not
                    occur; they are created as declared. Suppose that you
                    specify a table using this definition:
                </p><p style="color:blue;">为字符串数据类型指定字符集binary属性会导致将列创建为相应的二进制字符串数据类型：char变为binary，varchar变为varbinary，text变为blob。对于枚举和集合数据类型，不会发生这种情况；它们是按声明创建的。假设您使用此定义指定一个表：</p><p></p><pre data-lang="sql" class="programlisting">CREATE TABLE t
(
  c1 VARCHAR(10) CHARACTER SET binary,
  c2 TEXT CHARACTER SET binary,
  c3 ENUM('a','b','c') CHARACTER SET binary
);
</pre><p>
                    The resulting table has this definition:
                </p><p style="color:blue;">结果表具有以下定义：</p><p></p><pre data-lang="sql" class="programlisting">CREATE TABLE t
(
  c1 VARBINARY(10),
  c2 BLOB,
  c3 ENUM('a','b','c') CHARACTER SET binary
);
</pre></li><li class="listitem"><p>
                    The <code class="literal">BINARY</code> attribute is a nonstandard
                    MySQL extension that is shorthand for specifying the binary
                    (<code class="literal">_bin</code>) collation of the column character
                    set (or of the table default character set if no column
                    character set is specified). In this case, comparison and
                    sorting are based on numeric character code values. Suppose
                    that you specify a table using this definition:
                </p><p style="color:blue;">binary属性是一个非标准的mysql扩展，它是指定列字符集（如果未指定列字符集，则为表默认字符集）的二进制（_bin）排序规则的简写。在这种情况下，比较和排序基于数字字符代码值。假设您使用此定义指定一个表：</p><p></p><pre data-lang="sql" class="programlisting">CREATE TABLE t
(
  c1 VARCHAR(10) CHARACTER SET latin1 BINARY,
  c2 TEXT BINARY
) CHARACTER SET utf8mb4;
</pre><p>
                    The resulting table has this definition:
                </p><p style="color:blue;">结果表具有以下定义：</p><p></p><pre data-lang="sql" class="programlisting">CREATE TABLE t (
  c1 VARCHAR(10) CHARACTER SET latin1 COLLATE latin1_bin,
  c2 TEXT CHARACTER SET utf8mb4 COLLATE utf8mb4_bin
) CHARACTER SET utf8mb4;
</pre></li><li class="listitem"><p>
                    The <code class="literal">ASCII</code> attribute is shorthand for
                    <code class="literal">CHARACTER SET latin1</code>.
                </p><p style="color:blue;">ascii属性是字符集latin1的缩写。</p><p></p></li><li class="listitem"><p>
                    The <code class="literal">UNICODE</code> attribute is shorthand for
                    <code class="literal">CHARACTER SET ucs2</code>.
                </p><p style="color:blue;">unicode属性是字符集ucs2的缩写。</p><p></p></li></ul>
            </div>
            <p>
                Character column comparison and sorting are based on the
                collation assigned to the column. For the
                <a class="link" href="data-types.html#char" title="11.4.1&nbsp;The CHAR and VARCHAR Types"><code class="literal">CHAR</code></a>,
                <a class="link" href="data-types.html#char" title="11.4.1&nbsp;The CHAR and VARCHAR Types"><code class="literal">VARCHAR</code></a>,
                <a class="link" href="data-types.html#blob" title="11.4.3&nbsp;The BLOB and TEXT Types"><code class="literal">TEXT</code></a>,
                <a class="link" href="data-types.html#enum" title="11.4.4&nbsp;The ENUM Type"><code class="literal">ENUM</code></a>, and
                <a class="link" href="data-types.html#set" title="11.4.5&nbsp;The SET Type"><code class="literal">SET</code></a> data types, you can declare a
                column with a binary (<code class="literal">_bin</code>) collation or the
                <code class="literal">BINARY</code> attribute to cause comparison and
                sorting to use the underlying character code values rather than
                a lexical ordering.
            </p><p style="color:blue;">字符列比较和排序基于分配给该列的排序规则。对于CHAR、VARCHAR、文本、EnUM和SET数据类型，可以用二进制（X-Bin）排序或二进制属性来声明列，以使比较和排序使用基础字符代码值而不是词汇排序。</p><p></p><p>
            For additional information about use of character sets in MySQL,
            see <a class="xref" href="charset.html" title="Chapter&nbsp;10&nbsp;Character Sets, Collations, Unicode">Chapter&nbsp;10, <i>Character Sets, Collations, Unicode</i></a>.
        </p><p style="color:blue;">有关在mysql中使用字符集的更多信息，请参阅第10章，字符集，排序规则，unicode。</p><p></p>
            <div class="itemizedlist">
                <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                    <a class="indexterm" name="idm140286861465456"></a>

                    <a class="indexterm" name="idm140286861464384"></a>

                    <a class="indexterm" name="idm140286861463312"></a>

                    <a class="indexterm" name="idm140286861462240"></a>

                    <a class="indexterm" name="idm140286861461168"></a>

                    <a class="indexterm" name="idm140286861459680"></a>

                    <a class="indexterm" name="idm140286861458192"></a>

                    <a class="indexterm" name="idm140286861456704"></a>

                    <code class="literal">[NATIONAL] CHAR[(<em class="replaceable"><code>M</code></em>)]
                        [CHARACTER SET <em class="replaceable"><code>charset_name</code></em>]
                        [COLLATE
                        <em class="replaceable"><code>collation_name</code></em>]</code>
                </p><p style="color:blue;">[国家]字符[（m）][字符集字符集名称][整理排序规则名称]</p><p></p><p>
                    A fixed-length string that is always right-padded with
                    spaces to the specified length when stored.
                    <em class="replaceable"><code>M</code></em> represents the column length in
                    characters. The range of <em class="replaceable"><code>M</code></em> is 0
                    to 255. If <em class="replaceable"><code>M</code></em> is omitted, the
                    length is 1.
                </p><p style="color:blue;">一个固定长度的字符串，在存储时总是用空格填充到指定长度。m表示以字符为单位的列长度。m的范围是0到255。如果省略m，则长度为1。</p><p></p><a class="indexterm" name="idm140286861451200"></a>
                    <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">

                        <div class="admon-title">
                            Note
                        </div>
                        <p>
                            Trailing spaces are removed when
                            <a class="link" href="data-types.html#char" title="11.4.1&nbsp;The CHAR and VARCHAR Types"><code class="literal">CHAR</code></a> values are retrieved
                            unless the
                            <a class="link" href="server-administration.html#sqlmode_pad_char_to_full_length"><code class="literal">PAD_CHAR_TO_FULL_LENGTH</code></a>
                            SQL mode is enabled.
                        </p><p style="color:blue;">检索char值时将删除尾随空格，除非启用pad-char-to-full-length sql模式。</p><p></p>
                    </div>
                    <p>
                        <a class="link" href="data-types.html#char" title="11.4.1&nbsp;The CHAR and VARCHAR Types"><code class="literal">CHAR</code></a> is shorthand for
                        <a class="link" href="data-types.html#char" title="11.4.1&nbsp;The CHAR and VARCHAR Types"><code class="literal">CHARACTER</code></a>.
                        <a class="link" href="data-types.html#char" title="11.4.1&nbsp;The CHAR and VARCHAR Types"><code class="literal">NATIONAL CHAR</code></a> (or its
                        equivalent short form, <a class="link" href="data-types.html#char" title="11.4.1&nbsp;The CHAR and VARCHAR Types"><code class="literal">NCHAR</code></a>)
                        is the standard SQL way to define that a
                        <a class="link" href="data-types.html#char" title="11.4.1&nbsp;The CHAR and VARCHAR Types"><code class="literal">CHAR</code></a> column should use some
                        predefined character set. MySQL uses <code class="literal">utf8</code>
                        as this predefined character set.
                        <a class="xref" href="charset.html#charset-national" title="10.3.7&nbsp;The National Character Set">Section&nbsp;10.3.7, “The National Character Set”</a>.
                    </p><p style="color:blue;">char是字符的缩写。national char（或其等价的缩写，nchar）是定义char列应该使用一些预定义字符集的标准sql方式。mysql使用utf8作为这个预定义的字符集。第10.3.7节，“民族性格集”。</p><p></p><p>
                        The <a class="link" href="data-types.html#binary-varbinary" title="11.4.2&nbsp;The BINARY and VARBINARY Types"><code class="literal">CHAR BYTE</code></a> data type is an
                        alias for the <a class="link" href="data-types.html#binary-varbinary" title="11.4.2&nbsp;The BINARY and VARBINARY Types"><code class="literal">BINARY</code></a> data
                        type. This is a compatibility feature.
                    </p><p style="color:blue;">字符字节数据类型是二进制数据类型的别名。这是一个兼容性功能。</p><p></p><p>
                        MySQL permits you to create a column of type
                        <code class="literal">CHAR(0)</code>. This is useful primarily when
                        you have to be compliant with old applications that depend
                        on the existence of a column but that do not actually use
                        its value. <code class="literal">CHAR(0)</code> is also quite nice
                        when you need a column that can take only two values: A
                        column that is defined as <code class="literal">CHAR(0) NULL</code>
                        occupies only one bit and can take only the values
                        <code class="literal">NULL</code> and <code class="literal">''</code> (the empty
                        string).
                    </p><p style="color:blue;">mysql允许您创建char（0）类型的列。这是有用的，主要是当您必须遵守旧的应用程序依赖于一个列的存在，但实际上并不使用它的值。当您需要一个只能接受两个值的列时，char（0）也非常好：定义为char（0）null的列只占用一位，并且只能接受null和“”（空字符串）的值。</p><p></p></li><li class="listitem"><p>
                    <a class="indexterm" name="idm140286861424960"></a>

                    <a class="indexterm" name="idm140286861423888"></a>

                    <a class="indexterm" name="idm140286861422800"></a>

                    <a class="indexterm" name="idm140286861421728"></a>

                    <a class="indexterm" name="idm140286861420656"></a>

                    <a class="indexterm" name="idm140286861419568"></a>

                    <a class="indexterm" name="idm140286861418496"></a>

                    <a class="indexterm" name="idm140286861417008"></a>

                    <a class="indexterm" name="idm140286861415520"></a>

                    <a class="indexterm" name="idm140286861414032"></a>

                    <a class="indexterm" name="idm140286861412544"></a>

                    <a class="indexterm" name="idm140286861411056"></a>

                    <code class="literal">[NATIONAL] VARCHAR(<em class="replaceable"><code>M</code></em>)
                        [CHARACTER SET <em class="replaceable"><code>charset_name</code></em>]
                        [COLLATE
                        <em class="replaceable"><code>collation_name</code></em>]</code>
                </p><p style="color:blue;">[国家]varchar（m）[字符集字符集名称][整理排序规则名称]</p><p></p><a class="indexterm" name="idm140286861407440"></a><p>
                    A variable-length string. <em class="replaceable"><code>M</code></em>
                    represents the maximum column length in characters. The
                    range of <em class="replaceable"><code>M</code></em> is 0 to 65,535. The
                    effective maximum length of a
                    <a class="link" href="data-types.html#char" title="11.4.1&nbsp;The CHAR and VARCHAR Types"><code class="literal">VARCHAR</code></a> is subject to the
                    maximum row size (65,535 bytes, which is shared among all
                    columns) and the character set used. For example,
                    <code class="literal">utf8</code> characters can require up to three
                    bytes per character, so a
                    <a class="link" href="data-types.html#char" title="11.4.1&nbsp;The CHAR and VARCHAR Types"><code class="literal">VARCHAR</code></a> column that uses the
                    <code class="literal">utf8</code> character set can be declared to be
                    a maximum of 21,844 characters. See
                    <a class="xref" href="optimization.html#column-count-limit" title="8.4.7&nbsp;Limits on Table Column Count and Row Size">Section&nbsp;8.4.7, “Limits on Table Column Count and Row Size”</a>.
                </p><p style="color:blue;">可变长度的字符串。M表示字符中的最大列长度。m的范围是0到65535。VARCHAR的有效最大长度服从最大行大小（65535字节，在所有列之间共享）和所使用的字符集。例如，UTF8字符需要每个字符最多三字节，因此使用UTF8字符集的VARCHAR列可以被声明为最多21844个字符。见第8.4.7节，“表格列数和行大小限制”。</p><p></p><p>
                    MySQL stores <a class="link" href="data-types.html#char" title="11.4.1&nbsp;The CHAR and VARCHAR Types"><code class="literal">VARCHAR</code></a> values
                    as a 1-byte or 2-byte length prefix plus data. The length
                    prefix indicates the number of bytes in the value. A
                    <a class="link" href="data-types.html#char" title="11.4.1&nbsp;The CHAR and VARCHAR Types"><code class="literal">VARCHAR</code></a> column uses one
                    length byte if values require no more than 255 bytes, two
                    length bytes if values may require more than 255 bytes.
                </p><p style="color:blue;">mysql将varchar值存储为1字节或2字节长度的前缀加上数据。长度前缀指示值中的字节数。如果值要求的字节数不超过255，则varchar列使用一个长度字节；如果值要求的字节数可能超过255，则使用两个长度字节。</p><p></p>
                    <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">

                        <div class="admon-title">
                            Note
                        </div>
                        <p>
                            MySQL follows the standard SQL specification, and does
                            <span class="emphasis"><em>not</em></span> remove trailing spaces from
                            <a class="link" href="data-types.html#char" title="11.4.1&nbsp;The CHAR and VARCHAR Types"><code class="literal">VARCHAR</code></a> values.
                        </p><p style="color:blue;">mysql遵循标准sql规范，并且不从varchar值中删除尾随空格。</p><p></p>
                    </div>
                    <p>
                        <a class="link" href="data-types.html#char" title="11.4.1&nbsp;The CHAR and VARCHAR Types"><code class="literal">VARCHAR</code></a> is shorthand for
                        <a class="link" href="data-types.html#char" title="11.4.1&nbsp;The CHAR and VARCHAR Types"><code class="literal">CHARACTER VARYING</code></a>.
                        <a class="link" href="data-types.html#char" title="11.4.1&nbsp;The CHAR and VARCHAR Types"><code class="literal">NATIONAL VARCHAR</code></a> is the
                        standard SQL way to define that a
                        <a class="link" href="data-types.html#char" title="11.4.1&nbsp;The CHAR and VARCHAR Types"><code class="literal">VARCHAR</code></a> column should use
                        some predefined character set. MySQL uses
                        <code class="literal">utf8</code> as this predefined character set.
                        <a class="xref" href="charset.html#charset-national" title="10.3.7&nbsp;The National Character Set">Section&nbsp;10.3.7, “The National Character Set”</a>.
                        <a class="link" href="data-types.html#char" title="11.4.1&nbsp;The CHAR and VARCHAR Types"><code class="literal">NVARCHAR</code></a> is shorthand for
                        <a class="link" href="data-types.html#char" title="11.4.1&nbsp;The CHAR and VARCHAR Types"><code class="literal">NATIONAL VARCHAR</code></a>.
                    </p><p style="color:blue;">varchar是字符变化的缩写。national varchar是定义varchar列应该使用一些预定义字符集的标准sql方法。mysql使用utf8作为这个预定义的字符集。第10.3.7节，“民族性格集”。nvarchar是national varchar的缩写。</p><p></p></li><li class="listitem"><p>
                    <a class="indexterm" name="idm140286861381968"></a>

                    <a class="indexterm" name="idm140286861380896"></a>

                    <a class="link" href="data-types.html#binary-varbinary" title="11.4.2&nbsp;The BINARY and VARBINARY Types"><code class="literal">BINARY[(<em class="replaceable"><code>M</code></em>)]</code></a>
                </p><p style="color:blue;">二进制[（m）]</p><p></p><p>
                    The <a class="link" href="data-types.html#binary-varbinary" title="11.4.2&nbsp;The BINARY and VARBINARY Types"><code class="literal">BINARY</code></a> type is similar to
                    the <a class="link" href="data-types.html#char" title="11.4.1&nbsp;The CHAR and VARCHAR Types"><code class="literal">CHAR</code></a> type, but stores
                    binary byte strings rather than nonbinary character strings.
                    An optional length <em class="replaceable"><code>M</code></em> represents
                    the column length in bytes. If omitted,
                    <em class="replaceable"><code>M</code></em> defaults to 1.
                </p><p style="color:blue;">二进制类型类似于char类型，但存储二进制字节字符串而不是非二进制字符串。可选长度m表示以字节为单位的列长度。如果省略，m默认为1。</p><p></p></li><li class="listitem"><p>
                    <a class="indexterm" name="idm140286861371280"></a>

                    <a class="indexterm" name="idm140286861370208"></a>

                    <a class="link" href="data-types.html#binary-varbinary" title="11.4.2&nbsp;The BINARY and VARBINARY Types"><code class="literal">VARBINARY(<em class="replaceable"><code>M</code></em>)</code></a>
                </p><p style="color:blue;">变二进制（m）</p><p></p><p>
                    The <a class="link" href="data-types.html#binary-varbinary" title="11.4.2&nbsp;The BINARY and VARBINARY Types"><code class="literal">VARBINARY</code></a> type is similar
                    to the <a class="link" href="data-types.html#char" title="11.4.1&nbsp;The CHAR and VARCHAR Types"><code class="literal">VARCHAR</code></a> type, but
                    stores binary byte strings rather than nonbinary character
                    strings. <em class="replaceable"><code>M</code></em> represents the maximum
                    column length in bytes.
                </p><p style="color:blue;">varbinary类型类似于varchar类型，但存储二进制字节字符串而不是非二进制字符串。m以字节表示最大列长度。</p><p></p></li><li class="listitem"><p>
                    <a class="indexterm" name="idm140286861361072"></a>

                    <a class="indexterm" name="idm140286861360000"></a>

                    <a class="link" href="data-types.html#blob" title="11.4.3&nbsp;The BLOB and TEXT Types"><code class="literal">TINYBLOB</code></a>
                </p><p style="color:blue;">锡球</p><p></p><p>
                    A <a class="link" href="data-types.html#blob" title="11.4.3&nbsp;The BLOB and TEXT Types"><code class="literal">BLOB</code></a> column with a maximum
                    length of 255 (2<sup>8</sup> − 1)
                    bytes. Each <a class="link" href="data-types.html#blob" title="11.4.3&nbsp;The BLOB and TEXT Types"><code class="literal">TINYBLOB</code></a> value is
                    stored using a 1-byte length prefix that indicates the
                    number of bytes in the value.
                </p><p style="color:blue;">最大长度为255（28～1）字节的Bulb列。每个tinyblob值都使用一个1字节长度的前缀来存储，该前缀指示值中的字节数。</p><p></p></li><li class="listitem"><p>
                    <a class="indexterm" name="idm140286861351200"></a>

                    <a class="indexterm" name="idm140286861350128"></a>

                    <a class="link" href="data-types.html#blob" title="11.4.3&nbsp;The BLOB and TEXT Types"><code class="literal">TINYTEXT
                        [CHARACTER SET <em class="replaceable"><code>charset_name</code></em>]
                        [COLLATE
                        <em class="replaceable"><code>collation_name</code></em>]</code></a>
                </p><p style="color:blue;">tinytext[字符集字符集名称][排序规则名称]</p><p></p><p>
                    A <a class="link" href="data-types.html#blob" title="11.4.3&nbsp;The BLOB and TEXT Types"><code class="literal">TEXT</code></a> column with a maximum
                    length of 255 (2<sup>8</sup> − 1)
                    characters. The effective maximum length is less if the
                    value contains multibyte characters. Each
                    <a class="link" href="data-types.html#blob" title="11.4.3&nbsp;The BLOB and TEXT Types"><code class="literal">TINYTEXT</code></a> value is stored
                    using a 1-byte length prefix that indicates the number of
                    bytes in the value.
                </p><p style="color:blue;">最大长度为255（28到1）字符的文本列。如果值包含0个字符，则有效最大长度较少。每个tinytext值都使用一个1字节长度的前缀来存储，该前缀指示值中的字节数。</p><p></p></li><li class="listitem"><p>
                    <a class="indexterm" name="idm140286861340208"></a>

                    <a class="indexterm" name="idm140286861339136"></a>

                    <a class="link" href="data-types.html#blob" title="11.4.3&nbsp;The BLOB and TEXT Types"><code class="literal">BLOB[(<em class="replaceable"><code>M</code></em>)]</code></a>
                </p><p style="color:blue;">团块[（m）]</p><p></p><p>
                    A <a class="link" href="data-types.html#blob" title="11.4.3&nbsp;The BLOB and TEXT Types"><code class="literal">BLOB</code></a> column with a maximum
                    length of 65,535 (2<sup>16</sup> − 1)
                    bytes. Each <a class="link" href="data-types.html#blob" title="11.4.3&nbsp;The BLOB and TEXT Types"><code class="literal">BLOB</code></a> value is
                    stored using a 2-byte length prefix that indicates the
                    number of bytes in the value.
                </p><p style="color:blue;">最大长度为65535（216～1）字节的Bulb列。每个blob值都使用一个2字节长度的前缀来存储，该前缀指示值中的字节数。</p><p></p><p>
                    An optional length <em class="replaceable"><code>M</code></em> can be given
                    for this type. If this is done, MySQL creates the column as
                    the smallest <a class="link" href="data-types.html#blob" title="11.4.3&nbsp;The BLOB and TEXT Types"><code class="literal">BLOB</code></a> type large
                    enough to hold values <em class="replaceable"><code>M</code></em> bytes
                    long.
                </p><p style="color:blue;">对于这种类型，可以给出可选的长度m。如果这样做了，mysql会将该列创建为最小的blob类型，其大小足以容纳m字节长的值。</p><p></p></li><li class="listitem"><p>
                    <a class="indexterm" name="idm140286861327312"></a>

                    <a class="indexterm" name="idm140286861326240"></a>

                    <a class="link" href="data-types.html#blob" title="11.4.3&nbsp;The BLOB and TEXT Types"><code class="literal">TEXT[(<em class="replaceable"><code>M</code></em>)]
                        [CHARACTER SET <em class="replaceable"><code>charset_name</code></em>]
                        [COLLATE
                        <em class="replaceable"><code>collation_name</code></em>]</code></a>
                </p><p style="color:blue;">文本[（m）][字符集字符集名称][整理排序规则名称]</p><p></p><p>
                    A <a class="link" href="data-types.html#blob" title="11.4.3&nbsp;The BLOB and TEXT Types"><code class="literal">TEXT</code></a> column with a maximum
                    length of 65,535 (2<sup>16</sup> − 1)
                    characters. The effective maximum length is less if the
                    value contains multibyte characters. Each
                    <a class="link" href="data-types.html#blob" title="11.4.3&nbsp;The BLOB and TEXT Types"><code class="literal">TEXT</code></a> value is stored using a
                    2-byte length prefix that indicates the number of bytes in
                    the value.
                </p><p style="color:blue;">最大长度为65535（216到1）字符的文本列。如果值包含0个字符，则有效最大长度较少。每个文本值都使用2字节长度的前缀存储，该前缀指示值中的字节数。</p><p></p><p>
                    An optional length <em class="replaceable"><code>M</code></em> can be given
                    for this type. If this is done, MySQL creates the column as
                    the smallest <a class="link" href="data-types.html#blob" title="11.4.3&nbsp;The BLOB and TEXT Types"><code class="literal">TEXT</code></a> type large
                    enough to hold values <em class="replaceable"><code>M</code></em>
                    characters long.
                </p><p style="color:blue;">对于这种类型，可以给出可选的长度m。如果这样做了，mysql会将列创建为最小的文本类型，该文本类型的大小足以容纳m个字符的值。</p><p></p></li><li class="listitem"><p>
                    <a class="indexterm" name="idm140286861313248"></a>

                    <a class="indexterm" name="idm140286861312176"></a>

                    <a class="link" href="data-types.html#blob" title="11.4.3&nbsp;The BLOB and TEXT Types"><code class="literal">MEDIUMBLOB</code></a>
                </p><p style="color:blue;">中珠</p><p></p><p>
                    A <a class="link" href="data-types.html#blob" title="11.4.3&nbsp;The BLOB and TEXT Types"><code class="literal">BLOB</code></a> column with a maximum
                    length of 16,777,215 (2<sup>24</sup> −
                    1) bytes. Each <a class="link" href="data-types.html#blob" title="11.4.3&nbsp;The BLOB and TEXT Types"><code class="literal">MEDIUMBLOB</code></a>
                    value is stored using a 3-byte length prefix that indicates
                    the number of bytes in the value.
                </p><p style="color:blue;">最大长度为16777215（224～1）字节的Bulb列。每个mediumblob值都使用一个3字节长度的前缀来存储，该前缀指示值中的字节数。</p><p></p></li><li class="listitem"><p>
                    <a class="indexterm" name="idm140286861303360"></a>

                    <a class="indexterm" name="idm140286861302288"></a>

                    <a class="link" href="data-types.html#blob" title="11.4.3&nbsp;The BLOB and TEXT Types"><code class="literal">MEDIUMTEXT
                        [CHARACTER SET <em class="replaceable"><code>charset_name</code></em>]
                        [COLLATE
                        <em class="replaceable"><code>collation_name</code></em>]</code></a>
                </p><p style="color:blue;">mediumtext[字符集字符集名称][整理排序规则名称]</p><p></p><p>
                    A <a class="link" href="data-types.html#blob" title="11.4.3&nbsp;The BLOB and TEXT Types"><code class="literal">TEXT</code></a> column with a maximum
                    length of 16,777,215 (2<sup>24</sup> −
                    1) characters. The effective maximum length is less if the
                    value contains multibyte characters. Each
                    <a class="link" href="data-types.html#blob" title="11.4.3&nbsp;The BLOB and TEXT Types"><code class="literal">MEDIUMTEXT</code></a> value is stored
                    using a 3-byte length prefix that indicates the number of
                    bytes in the value.
                </p><p style="color:blue;">最大长度为16777215（224到1）字符的文本列。如果值包含0个字符，则有效最大长度较少。每个mediumText值都使用一个3字节长度的前缀来存储，该前缀指示值中的字节数。</p><p></p></li><li class="listitem"><p>
                    <a class="indexterm" name="idm140286861291648"></a>

                    <a class="indexterm" name="idm140286861290576"></a>

                    <a class="link" href="data-types.html#blob" title="11.4.3&nbsp;The BLOB and TEXT Types"><code class="literal">LONGBLOB</code></a>
                </p><p style="color:blue;">长圆点</p><p></p><p>
                    A <a class="link" href="data-types.html#blob" title="11.4.3&nbsp;The BLOB and TEXT Types"><code class="literal">BLOB</code></a> column with a maximum
                    length of 4,294,967,295 or 4GB
                    (2<sup>32</sup> − 1) bytes. The
                    effective maximum length of
                    <a class="link" href="data-types.html#blob" title="11.4.3&nbsp;The BLOB and TEXT Types"><code class="literal">LONGBLOB</code></a> columns depends on
                    the configured maximum packet size in the client/server
                    protocol and available memory. Each
                    <a class="link" href="data-types.html#blob" title="11.4.3&nbsp;The BLOB and TEXT Types"><code class="literal">LONGBLOB</code></a> value is stored
                    using a 4-byte length prefix that indicates the number of
                    bytes in the value.
                </p><p style="color:blue;">最大长度为4294967295或4GB（232～1）字节的Bulb列。长BLUBB列的有效最大长度取决于客户机/服务器协议中配置的最大包大小和可用内存。每个longblob值都使用一个4字节长的前缀来存储，该前缀指示值中的字节数。</p><p></p></li><li class="listitem"><p>
                    <a class="indexterm" name="idm140286861280304"></a>

                    <a class="indexterm" name="idm140286861279232"></a>

                    <a class="link" href="data-types.html#blob" title="11.4.3&nbsp;The BLOB and TEXT Types"><code class="literal">LONGTEXT
                        [CHARACTER SET <em class="replaceable"><code>charset_name</code></em>]
                        [COLLATE
                        <em class="replaceable"><code>collation_name</code></em>]</code></a>
                </p><p style="color:blue;">长文本[字符集字符集名称][排序规则名称]</p><p></p><p>
                    A <a class="link" href="data-types.html#blob" title="11.4.3&nbsp;The BLOB and TEXT Types"><code class="literal">TEXT</code></a> column with a maximum
                    length of 4,294,967,295 or 4GB
                    (2<sup>32</sup> − 1) characters. The
                    effective maximum length is less if the value contains
                    multibyte characters. The effective maximum length of
                    <a class="link" href="data-types.html#blob" title="11.4.3&nbsp;The BLOB and TEXT Types"><code class="literal">LONGTEXT</code></a>
                    columns also depends on the configured maximum packet size
                    in the client/server protocol and available memory. Each
                    <a class="link" href="data-types.html#blob" title="11.4.3&nbsp;The BLOB and TEXT Types"><code class="literal">LONGTEXT</code></a>
                    value is stored using a 4-byte length prefix that indicates
                    the number of bytes in the value.
                </p><p style="color:blue;">最大长度为4294967295或4GB（232到1）字符的文本列。如果值包含0个字符，则有效最大长度较少。LoeType列的有效最大长度还取决于客户机/服务器协议中配置的最大包大小和可用内存。每个longtext值都使用一个4字节长的前缀来存储，该前缀指示值中的字节数。</p><p></p></li><li class="listitem"><p>
                    <a class="indexterm" name="idm140286861267856"></a>

                    <a class="indexterm" name="idm140286861266784"></a>

                    <a class="link" href="data-types.html#enum" title="11.4.4&nbsp;The ENUM Type"><code class="literal">ENUM('<em class="replaceable"><code>value1</code></em>','<em class="replaceable"><code>value2</code></em>',...)
                        [CHARACTER SET <em class="replaceable"><code>charset_name</code></em>]
                        [COLLATE
                        <em class="replaceable"><code>collation_name</code></em>]</code></a>
                </p><p style="color:blue;">枚举（'value1'，'value2'，…）[字符集字符集名称][整理排序规则名称]</p><p></p><p>
                    An enumeration. A string object that can have only one
                    value, chosen from the list of values
                    <code class="literal">'<em class="replaceable"><code>value1</code></em>'</code>,
                    <code class="literal">'<em class="replaceable"><code>value2</code></em>'</code>,
                    <code class="literal">...</code>, <code class="literal">NULL</code> or the
                    special <code class="literal">''</code> error value.
                    <a class="link" href="data-types.html#enum" title="11.4.4&nbsp;The ENUM Type"><code class="literal">ENUM</code></a> values are represented
                    internally as integers.
                </p><p style="color:blue;">列举。只能有一个值的字符串对象，从值列表“value1”、“value2”、…、null或特殊的“”错误值中选择。枚举值在内部表示为整数。</p><p></p><p>
                    An <a class="link" href="data-types.html#enum" title="11.4.4&nbsp;The ENUM Type"><code class="literal">ENUM</code></a> column can have a
                    maximum of 65,535 distinct elements. (The practical limit is
                    less than 3000.) A table can have no more than 255 unique
                    element list definitions among its
                    <a class="link" href="data-types.html#enum" title="11.4.4&nbsp;The ENUM Type"><code class="literal">ENUM</code></a> and
                    <a class="link" href="data-types.html#set" title="11.4.5&nbsp;The SET Type"><code class="literal">SET</code></a> columns considered as a
                    group. For more information on these limits, see
                    <a class="xref" href="sql-syntax.html#limits-frm-file" title="Limits Imposed by .frm File Structure">Limits Imposed by .frm File Structure</a>.
                </p><p style="color:blue;">枚举列最多可以有65535个不同的元素。（实际限制小于3000。）表的枚举列和集合列之间的唯一元素列表定义不能超过255个。有关这些限制的详细信息，请参见.frm文件结构施加的限制。</p><p></p></li><li class="listitem"><p>
                    <a class="indexterm" name="idm140286861248544"></a>

                    <a class="indexterm" name="idm140286861247472"></a>

                    <a class="link" href="data-types.html#set" title="11.4.5&nbsp;The SET Type"><code class="literal">SET('<em class="replaceable"><code>value1</code></em>','<em class="replaceable"><code>value2</code></em>',...)
                        [CHARACTER SET <em class="replaceable"><code>charset_name</code></em>]
                        [COLLATE
                        <em class="replaceable"><code>collation_name</code></em>]</code></a>
                </p><p style="color:blue;">set（'value1'，'value2'，…）[字符集字符集名称][整理排序规则名称]</p><p></p><p>
                    A set. A string object that can have zero or more values,
                    each of which must be chosen from the list of values
                    <code class="literal">'<em class="replaceable"><code>value1</code></em>'</code>,
                    <code class="literal">'<em class="replaceable"><code>value2</code></em>'</code>,
                    <code class="literal">...</code> <a class="link" href="data-types.html#set" title="11.4.5&nbsp;The SET Type"><code class="literal">SET</code></a>
                    values are represented internally as integers.
                </p><p style="color:blue;">一套。一个字符串对象，可以有零个或多个值，每个值都必须从值“value1”、“value2”的列表中选择…设定值在内部表示为整数。</p><p></p><p>
                    A <a class="link" href="data-types.html#set" title="11.4.5&nbsp;The SET Type"><code class="literal">SET</code></a> column can have a
                    maximum of 64 distinct members. A table can have no more
                    than 255 unique element list definitions among its
                    <a class="link" href="data-types.html#enum" title="11.4.4&nbsp;The ENUM Type"><code class="literal">ENUM</code></a> and
                    <a class="link" href="data-types.html#set" title="11.4.5&nbsp;The SET Type"><code class="literal">SET</code></a> columns considered as a
                    group. For more information on this limit, see
                    <a class="xref" href="sql-syntax.html#limits-frm-file" title="Limits Imposed by .frm File Structure">Limits Imposed by .frm File Structure</a>.
                </p><p style="color:blue;">集合列最多可以有64个不同的成员。一个表的枚举列和集合列之间的唯一元素列表定义不能超过255个。有关此限制的详细信息，请参见.frm文件结构施加的限制。</p><p></p></li></ul>
            </div>

        </div>

    </div>
    <div class="section">
        <div class="titlepage">
            <div>
                <div>
                    <h2 class="title" style="clear: both"><a name="numeric-types"></a>11.2&nbsp;Numeric Types</h2>

                </div>

            </div>

        </div>
        <div class="toc">
            <dl class="toc"><dt><span class="section"><a href="data-types.html#integer-types">11.2.1 Integer Types (Exact Value) - INTEGER, INT, SMALLINT, TINYINT,
MEDIUMINT, BIGINT</a></span></dt><dt><span class="section"><a href="data-types.html#fixed-point-types">11.2.2 Fixed-Point Types (Exact Value) - DECIMAL, NUMERIC</a></span></dt><dt><span class="section"><a href="data-types.html#floating-point-types">11.2.3 Floating-Point Types (Approximate Value) - FLOAT, DOUBLE</a></span></dt><dt><span class="section"><a href="data-types.html#bit-type">11.2.4 Bit-Value Type - BIT</a></span></dt><dt><span class="section"><a href="data-types.html#numeric-type-attributes">11.2.5 Numeric Type Attributes</a></span></dt><dt><span class="section"><a href="data-types.html#out-of-range-and-overflow">11.2.6 Out-of-Range and Overflow Handling</a></span></dt></dl>
        </div>
        <p>
            MySQL supports all standard SQL numeric data types. These types
            include the exact numeric data types
            (<a class="link" href="data-types.html#integer-types" title="11.2.1&nbsp;Integer Types (Exact Value) - INTEGER, INT, SMALLINT, TINYINT, MEDIUMINT, BIGINT"><code class="literal">INTEGER</code></a>,
            <a class="link" href="data-types.html#integer-types" title="11.2.1&nbsp;Integer Types (Exact Value) - INTEGER, INT, SMALLINT, TINYINT, MEDIUMINT, BIGINT"><code class="literal">SMALLINT</code></a>,
            <a class="link" href="data-types.html#fixed-point-types" title="11.2.2&nbsp;Fixed-Point Types (Exact Value) - DECIMAL, NUMERIC"><code class="literal">DECIMAL</code></a>, and
            <a class="link" href="data-types.html#fixed-point-types" title="11.2.2&nbsp;Fixed-Point Types (Exact Value) - DECIMAL, NUMERIC"><code class="literal">NUMERIC</code></a>), as well as the
            approximate numeric data types
            (<a class="link" href="data-types.html#floating-point-types" title="11.2.3&nbsp;Floating-Point Types (Approximate Value) - FLOAT, DOUBLE"><code class="literal">FLOAT</code></a>,
            <a class="link" href="data-types.html#floating-point-types" title="11.2.3&nbsp;Floating-Point Types (Approximate Value) - FLOAT, DOUBLE"><code class="literal">REAL</code></a>, and
            <a class="link" href="data-types.html#floating-point-types" title="11.2.3&nbsp;Floating-Point Types (Approximate Value) - FLOAT, DOUBLE"><code class="literal">DOUBLE PRECISION</code></a>). The keyword
            <a class="link" href="data-types.html#integer-types" title="11.2.1&nbsp;Integer Types (Exact Value) - INTEGER, INT, SMALLINT, TINYINT, MEDIUMINT, BIGINT"><code class="literal">INT</code></a> is a synonym for
            <a class="link" href="data-types.html#integer-types" title="11.2.1&nbsp;Integer Types (Exact Value) - INTEGER, INT, SMALLINT, TINYINT, MEDIUMINT, BIGINT"><code class="literal">INTEGER</code></a>, and the keywords
            <a class="link" href="data-types.html#fixed-point-types" title="11.2.2&nbsp;Fixed-Point Types (Exact Value) - DECIMAL, NUMERIC"><code class="literal">DEC</code></a> and
            <a class="link" href="data-types.html#fixed-point-types" title="11.2.2&nbsp;Fixed-Point Types (Exact Value) - DECIMAL, NUMERIC"><code class="literal">FIXED</code></a> are synonyms for
            <a class="link" href="data-types.html#fixed-point-types" title="11.2.2&nbsp;Fixed-Point Types (Exact Value) - DECIMAL, NUMERIC"><code class="literal">DECIMAL</code></a>. MySQL treats
            <a class="link" href="data-types.html#floating-point-types" title="11.2.3&nbsp;Floating-Point Types (Approximate Value) - FLOAT, DOUBLE"><code class="literal">DOUBLE</code></a> as a synonym for
            <a class="link" href="data-types.html#floating-point-types" title="11.2.3&nbsp;Floating-Point Types (Approximate Value) - FLOAT, DOUBLE"><code class="literal">DOUBLE PRECISION</code></a> (a nonstandard
            extension). MySQL also treats <a class="link" href="data-types.html#floating-point-types" title="11.2.3&nbsp;Floating-Point Types (Approximate Value) - FLOAT, DOUBLE"><code class="literal">REAL</code></a>
            as a synonym for <a class="link" href="data-types.html#floating-point-types" title="11.2.3&nbsp;Floating-Point Types (Approximate Value) - FLOAT, DOUBLE"><code class="literal">DOUBLE PRECISION</code></a>
            (a nonstandard variation), unless the
            <a class="link" href="server-administration.html#sqlmode_real_as_float"><code class="literal">REAL_AS_FLOAT</code></a> SQL mode is
            enabled.
        </p><p style="color:blue;">mysql支持所有标准的sql数值数据类型。这些类型包括确切的数字数据类型（整数、Simple、十进制和数字），以及近似的数值数据类型（浮点、实数和双精度）。关键字int是integer的同义词，关键字dec和fixed是decimal的同义词。mysql将double视为double precision（非标准扩展）的同义词。mysql还将real视为双精度（非标准变体）的同义词，除非启用了real-as-float sql模式。</p><p></p><p>
        The <a class="link" href="data-types.html#bit-type" title="11.2.4&nbsp;Bit-Value Type - BIT"><code class="literal">BIT</code></a> data type stores bit values
        and is supported for <a class="link" href="storage-engines.html#myisam-storage-engine" title="15.2&nbsp;The MyISAM Storage Engine"><code class="literal">MyISAM</code></a>,
        <a class="link" href="storage-engines.html#memory-storage-engine" title="15.3&nbsp;The MEMORY Storage Engine"><code class="literal">MEMORY</code></a>,
        <a class="link" href="innodb-storage-engine.html" title="Chapter&nbsp;14&nbsp;The InnoDB Storage Engine"><code class="literal">InnoDB</code></a>, and
        <a class="link" href="mysql-cluster.html" title="Chapter&nbsp;21&nbsp;MySQL NDB Cluster 7.5 and NDB Cluster 7.6"><code class="literal">NDB</code></a> tables.
    </p><p style="color:blue;">位数据类型存储位值，并支持myisam、memory、innodb和ndb表。</p><p></p><p>
        For information about how MySQL handles assignment of out-of-range
        values to columns and overflow during expression evaluation, see
        <a class="xref" href="data-types.html#out-of-range-and-overflow" title="11.2.6&nbsp;Out-of-Range and Overflow Handling">Section&nbsp;11.2.6, “Out-of-Range and Overflow Handling”</a>.
    </p><p style="color:blue;">有关mysql如何在表达式求值期间处理列的超出范围值赋值和溢出的信息，请参阅11.2.6节“超出范围和溢出处理”。</p><p></p><p>
        For information about numeric type storage requirements, see
        <a class="xref" href="data-types.html#storage-requirements" title="11.8&nbsp;Data Type Storage Requirements">Section&nbsp;11.8, “Data Type Storage Requirements”</a>.
    </p><p style="color:blue;">有关数字类型存储要求的信息，请参阅第11.8节“数据类型存储要求”。</p><p></p><p>
        The data type used for the result of a calculation on numeric
        operands depends on the types of the operands and the operations
        performed on them. For more information, see
        <a class="xref" href="functions.html#arithmetic-functions" title="12.6.1&nbsp;Arithmetic Operators">Section&nbsp;12.6.1, “Arithmetic Operators”</a>.
    </p><p style="color:blue;">用于数值操作数计算结果的数据类型取决于操作数的类型以及对其执行的操作。有关更多信息，请参见第12.6.1节“算术运算符”。</p><p></p>
        <div class="section">

            <div class="titlepage">
                <div>
                    <div>
                        <h3 class="title"><a name="integer-types"></a>11.2.1&nbsp;Integer Types (Exact Value) - INTEGER, INT, SMALLINT, TINYINT,
                            MEDIUMINT, BIGINT</h3>
                    </div>
                </div>
            </div>
            <p>
                MySQL supports the SQL standard integer types
                <code class="literal">INTEGER</code> (or <code class="literal">INT</code>) and
                <code class="literal">SMALLINT</code>. As an extension to the standard,
                MySQL also supports the integer types
                <code class="literal">TINYINT</code>, <code class="literal">MEDIUMINT</code>, and
                <code class="literal">BIGINT</code>. The following table shows the
                required storage and range for each integer type.
            </p><p style="color:blue;">mysql支持sql标准整数类型integer（或int）和smallint。作为标准的扩展，mysql还支持整数类型tinyint、mediumint和bigint。下表显示了每个整数类型所需的存储空间和范围。</p><p></p>
            <div class="table">
                <a name="integer-type-storage-and-range"></a><p class="title"><b>Table&nbsp;11.1&nbsp;Required Storage and Range for Integer Types Supported by MySQL</b></p><p style="color:blue;">表11.1 mysql支持的整数类型所需的存储空间和范围</p><p></p>
                <div class="table-contents">
                    <table summary="Required storage and range for integer types supported by MySQL. Information includes the integer type, the storage size in bytes, the minimum signed and unsigned values, and the maximum signed and unsigned values."><colgroup><col width="16%"><col width="16%"><col width="16%"><col width="16%"><col width="16%"><col width="16%"></colgroup><thead><tr>
                        <th scope="col">Type</th>
                        <th scope="col">Storage (Bytes)</th>
                        <th scope="col">Minimum Value Signed</th>
                        <th scope="col">Minimum Value Unsigned</th>
                        <th scope="col">Maximum Value Signed</th>
                        <th scope="col">Maximum Value Unsigned</th>
                    </tr></thead><tbody><tr>
                        <td scope="row"><code class="literal">TINYINT</code></td>
                        <td>1</td>
                        <td><code class="literal">-128</code></td>
                        <td><code class="literal">0</code></td>
                        <td><code class="literal">127</code></td>
                        <td><code class="literal">255</code></td>
                    </tr><tr>
                        <td scope="row"><code class="literal">SMALLINT</code></td>
                        <td>2</td>
                        <td><code class="literal">-32768</code></td>
                        <td><code class="literal">0</code></td>
                        <td><code class="literal">32767</code></td>
                        <td><code class="literal">65535</code></td>
                    </tr><tr>
                        <td scope="row"><code class="literal">MEDIUMINT</code></td>
                        <td>3</td>
                        <td><code class="literal">-8388608</code></td>
                        <td><code class="literal">0</code></td>
                        <td><code class="literal">8388607</code></td>
                        <td><code class="literal">16777215</code></td>
                    </tr><tr>
                        <td scope="row"><code class="literal">INT</code></td>
                        <td>4</td>
                        <td><code class="literal">-2147483648</code></td>
                        <td><code class="literal">0</code></td>
                        <td><code class="literal">2147483647</code></td>
                        <td><code class="literal">4294967295</code></td>
                    </tr><tr>
                        <td scope="row"><code class="literal">BIGINT</code></td>
                        <td>8</td>
                        <td><code class="literal">-2<sup>63</sup></code></td>
                        <td><code class="literal">0</code></td>
                        <td><code class="literal">2<sup>63</sup>-1</code></td>
                        <td><code class="literal">2<sup>64</sup>-1</code></td>
                    </tr></tbody></table>
                </div>

            </div>
            <br class="table-break">
        </div>
        <div class="section">
            <div class="titlepage">
                <div>
                    <div>
                        <h3 class="title"><a name="fixed-point-types"></a>11.2.2&nbsp;Fixed-Point Types (Exact Value) - DECIMAL, NUMERIC</h3>

                    </div>

                </div>

            </div>
            <p>
                The <code class="literal">DECIMAL</code> and <code class="literal">NUMERIC</code>
                types store exact numeric data values. These types are used when
                it is important to preserve exact precision, for example with
                monetary data. In MySQL, <code class="literal">NUMERIC</code> is
                implemented as <code class="literal">DECIMAL</code>, so the following
                remarks about <code class="literal">DECIMAL</code> apply equally to
                <code class="literal">NUMERIC</code>.
            </p><p style="color:blue;">decimal和numeric类型存储精确的数字数据值。当保持精确精度非常重要时（例如对于货币数据），使用这些类型。在mysql中，numeric被实现为decimal，因此下面关于decimal的说明同样适用于numeric。</p><p></p><p>
            MySQL stores <code class="literal">DECIMAL</code> values in binary format.
            See <a class="xref" href="functions.html#precision-math" title="12.22&nbsp;Precision Math">Section&nbsp;12.22, “Precision Math”</a>.
        </p><p style="color:blue;">mysql以二进制格式存储十进制值。见第12.22节“精确数学”。</p><p></p><p>
            In a <code class="literal">DECIMAL</code> column declaration, the
            precision and scale can be (and usually is) specified. For
            example:
        </p><p style="color:blue;">在十进制列声明中，可以（通常是）指定精度和小数位数。例如：</p><p></p><pre data-lang="sql" class="programlisting">salary DECIMAL(5,2)
</pre><p>
            In this example, <code class="literal">5</code> is the precision and
            <code class="literal">2</code> is the scale. The precision represents the
            number of significant digits that are stored for values, and the
            scale represents the number of digits that can be stored
            following the decimal point.
        </p><p style="color:blue;">在本例中，5是精度，2是刻度。精度表示为值存储的有效位数，小数位数表示可以存储在小数点后的位数。</p><p></p><p>
            Standard SQL requires that <code class="literal">DECIMAL(5,2)</code> be
            able to store any value with five digits and two decimals, so
            values that can be stored in the <code class="literal">salary</code>
            column range from <code class="literal">-999.99</code> to
            <code class="literal">999.99</code>.
        </p><p style="color:blue;">标准sql要求decimal（5,2）能够存储5位和2位小数的任何值，因此可以存储在salary列中的值的范围是-999.99到999.99。</p><p></p><p>
            In standard SQL, the syntax
            <code class="literal">DECIMAL(<em class="replaceable"><code>M</code></em>)</code> is
            equivalent to
            <code class="literal">DECIMAL(<em class="replaceable"><code>M</code></em>,0)</code>.
            Similarly, the syntax <code class="literal">DECIMAL</code> is equivalent
            to <code class="literal">DECIMAL(<em class="replaceable"><code>M</code></em>,0)</code>,
            where the implementation is permitted to decide the value of
            <em class="replaceable"><code>M</code></em>. MySQL supports both of these
            variant forms of <code class="literal">DECIMAL</code> syntax. The default
            value of <em class="replaceable"><code>M</code></em> is 10.
        </p><p style="color:blue;">在标准sql中，语法decimal（m）等同于decimal（m，0）。类似地，语法decimal相当于decimal（m，0），允许实现决定m的值。mysql支持这两种形式的decimal语法。m的默认值是10。</p><p></p><p>
            If the scale is 0, <code class="literal">DECIMAL</code> values contain no
            decimal point or fractional part.
        </p><p style="color:blue;">如果小数位数为0，则十进制值不包含小数点或小数部分。</p><p></p><p>
            The maximum number of digits for <code class="literal">DECIMAL</code> is
            65, but the actual range for a given <code class="literal">DECIMAL</code>
            column can be constrained by the precision or scale for a given
            column. When such a column is assigned a value with more digits
            following the decimal point than are permitted by the specified
            scale, the value is converted to that scale. (The precise
            behavior is operating system-specific, but generally the effect
            is truncation to the permissible number of digits.)
        </p><p style="color:blue;">十进制的最大位数是65，但给定小数列的实际范围可以由给定列的精度或比例来限制。如果为此类列分配的小数点后的位数超过指定小数位数所允许的值，则该值将转换为该小数位数。（精确的行为是特定于操作系统的，但通常效果是截断到允许的位数。）</p><p></p>
        </div>
        <div class="section">
            <div class="titlepage">
                <div>
                    <div>
                        <h3 class="title"><a name="floating-point-types"></a>11.2.3&nbsp;Floating-Point Types (Approximate Value) - FLOAT, DOUBLE</h3>

                    </div>

                </div>

            </div>
            <p>
                The <code class="literal">FLOAT</code> and <code class="literal">DOUBLE</code> types
                represent approximate numeric data values. MySQL uses four bytes
                for single-precision values and eight bytes for double-precision
                values.
            </p><p style="color:blue;">浮点型和double型表示近似的数值数据值。mysql使用4个字节表示单精度值，使用8个字节表示双精度值。</p><p></p><p>
            For <code class="literal">FLOAT</code>, the SQL standard permits an
            optional specification of the precision (but not the range of
            the exponent) in bits following the keyword
            <code class="literal">FLOAT</code> in parentheses; ; that is,
            <a class="link" href="data-types.html#floating-point-types" title="11.2.3&nbsp;Floating-Point Types (Approximate Value) - FLOAT, DOUBLE"><code class="literal">FLOAT(<em class="replaceable"><code>p</code></em>)</code></a>.
            MySQL also supports this optional precision specification, but
            the precision value in
            <a class="link" href="data-types.html#floating-point-types" title="11.2.3&nbsp;Floating-Point Types (Approximate Value) - FLOAT, DOUBLE"><code class="literal">FLOAT(<em class="replaceable"><code>p</code></em>)</code></a>
            is used only to determine storage size. A precision from 0 to 23
            results in a 4-byte single-precision <code class="literal">FLOAT</code>
            column. A precision from 24 to 53 results in an 8-byte
            double-precision <code class="literal">DOUBLE</code> column.
        </p><p style="color:blue;">对于float，sql标准允许在括号中的float关键字后面的位中指定精度（而不是指数的范围）；即float（p）。mysql还支持这个可选的精度规范，但是float（p）中的精度值仅用于确定存储大小。从0到23的精度将产生4字节的单精度浮点列。从24到53的精度将产生8字节的双精度双列。</p><p></p><p>
            MySQL permits a nonstandard syntax:
            <code class="literal">FLOAT(<em class="replaceable"><code>M</code></em>,<em class="replaceable"><code>D</code></em>)</code>
            or
            <code class="literal">REAL(<em class="replaceable"><code>M</code></em>,<em class="replaceable"><code>D</code></em>)</code>
            or <code class="literal">DOUBLE
            PRECISION(<em class="replaceable"><code>M</code></em>,<em class="replaceable"><code>D</code></em>)</code>.
            Here,
            <code class="literal">(<em class="replaceable"><code>M</code></em>,<em class="replaceable"><code>D</code></em>)</code>
            means than values can be stored with up to
            <em class="replaceable"><code>M</code></em> digits in total, of which
            <em class="replaceable"><code>D</code></em> digits may be after the decimal
            point. For example, a column defined as
            <code class="literal">FLOAT(7,4)</code> will look like
            <code class="literal">-999.9999</code> when displayed. MySQL performs
            rounding when storing values, so if you insert
            <code class="literal">999.00009</code> into a
            <code class="literal">FLOAT(7,4)</code> column, the approximate result is
            <code class="literal">999.0001</code>.
        </p><p style="color:blue;">mysql允许使用非标准语法：float（m，d）或real（m，d）或double precision（m，d）。这里，（m，d）表示than值最多可以存储m个数字，其中d个数字可以在小数点后。例如，定义为float（7,4）的列在显示时看起来像-999.9999。MySQL在存储值时执行舍入，因此如果将999.00009插入到浮点（7，4）列中，则近似结果为999.0001。</p><p></p><p>
            Because floating-point values are approximate and not stored as
            exact values, attempts to treat them as exact in comparisons may
            lead to problems. They are also subject to platform or
            implementation dependencies. For more information, see
            <a class="xref" href="error-handling.html#problems-with-float" title="B.4.4.8&nbsp;Problems with Floating-Point Values">Section&nbsp;B.4.4.8, “Problems with Floating-Point Values”</a>
        </p><p style="color:blue;">因为浮点值是近似的，而不是作为精确值存储的，所以尝试在比较中精确地对待它们可能会导致问题。它们还受平台或实现依赖性的影响。有关详细信息，请参阅第B.4.4.8节“浮点值问题”</p><p></p><p>
            For maximum portability, code requiring storage of approximate
            numeric data values should use <code class="literal">FLOAT</code> or
            <code class="literal">DOUBLE PRECISION</code> with no specification of
            precision or number of digits.
        </p><p style="color:blue;">为了最大可移植性，需要存储近似数值数据值的代码应该使用浮点或双精度，而不需要精度或数字位数。</p><p></p>
        </div>
        <div class="section">
            <div class="titlepage">
                <div>
                    <div>
                        <h3 class="title"><a name="bit-type"></a>11.2.4&nbsp;Bit-Value Type - BIT</h3>

                    </div>

                </div>

            </div>
            <p>
                The <code class="literal">BIT</code> data type is used to store bit
                values. A type of
                <code class="literal">BIT(<em class="replaceable"><code>M</code></em>)</code> enables
                storage of <em class="replaceable"><code>M</code></em>-bit values.
                <em class="replaceable"><code>M</code></em> can range from 1 to 64.
            </p><p style="color:blue;">位数据类型用于存储位值。一种位（m）类型允许存储m位值。m的范围从1到64。</p><p></p><p>
            To specify bit values,
            <code class="literal">b'<em class="replaceable"><code>value</code></em>'</code> notation
            can be used. <em class="replaceable"><code>value</code></em> is a binary value
            written using zeros and ones. For example,
            <code class="literal">b'111'</code> and <code class="literal">b'10000000'</code>
            represent 7 and 128, respectively. See
            <a class="xref" href="language-structure.html#bit-value-literals" title="9.1.5&nbsp;Bit-Value Literals">Section&nbsp;9.1.5, “Bit-Value Literals”</a>.
        </p><p style="color:blue;">要指定位值，可以使用b'value'符号。值是使用0和1写入的二进制值。例如，b'111'和b'10000000'分别表示7和128。见第9.1.5节“位值文字”。</p><p></p><p>
            If you assign a value to a
            <code class="literal">BIT(<em class="replaceable"><code>M</code></em>)</code> column that
            is less than <em class="replaceable"><code>M</code></em> bits long, the value
            is padded on the left with zeros. For example, assigning a value
            of <code class="literal">b'101'</code> to a <code class="literal">BIT(6)</code>
            column is, in effect, the same as assigning
            <code class="literal">b'000101'</code>.
        </p><p style="color:blue;">如果为长度小于m位的位（m）列指定一个值，则该值将用零填充在左侧。例如，给位（6）列赋值b'101'实际上与赋值b'000101'相同。</p><p></p><p><b>NDB Cluster.&nbsp;</b>
            The maximum combined size of all <code class="literal">BIT</code>
            columns used in a given <a class="link" href="mysql-cluster.html" title="Chapter&nbsp;21&nbsp;MySQL NDB Cluster 7.5 and NDB Cluster 7.6"><code class="literal">NDB</code></a> table
            must not exceed 4096 bits.
        </p><p style="color:blue;">ndb集群。在给定的NDB表中使用的所有位列的最大组合大小不得超过4096位。</p><p></p>
        </div>
        <div class="section">
            <div class="titlepage">
                <div>
                    <div>
                        <h3 class="title"><a name="numeric-type-attributes"></a>11.2.5&nbsp;Numeric Type Attributes</h3>

                    </div>

                </div>

            </div>
            <a class="indexterm" name="idm140286861070640"></a><a class="indexterm" name="idm140286861069568"></a><a class="indexterm" name="idm140286861068496"></a><p>
            MySQL supports an extension for optionally specifying the
            display width of integer data types in parentheses following the
            base keyword for the type. For example,
            <a class="link" href="data-types.html#integer-types" title="11.2.1&nbsp;Integer Types (Exact Value) - INTEGER, INT, SMALLINT, TINYINT, MEDIUMINT, BIGINT"><code class="literal">INT(4)</code></a> specifies an
            <a class="link" href="data-types.html#integer-types" title="11.2.1&nbsp;Integer Types (Exact Value) - INTEGER, INT, SMALLINT, TINYINT, MEDIUMINT, BIGINT"><code class="literal">INT</code></a> with a display width of four
            digits. This optional display width may be used by applications
            to display integer values having a width less than the width
            specified for the column by left-padding them with spaces. (That
            is, this width is present in the metadata returned with result
            sets. Whether it is used is up to the application.)
        </p><p style="color:blue;">mysql支持一个扩展，可以选择在类型的基关键字后面的括号中指定整数数据类型的显示宽度。例如，int（4）指定一个显示宽度为四位数的int。应用程序可以使用此可选显示宽度来显示整数值，该整数值的宽度小于通过用空格左填充为列指定的宽度。（也就是说，此宽度存在于结果集返回的元数据中。是否使用取决于应用程序。）</p><p></p><p>
            The display width does <span class="emphasis"><em>not</em></span> constrain the
            range of values that can be stored in the column. Nor does it
            prevent values wider than the column display width from being
            displayed correctly. For example, a column specified as
            <a class="link" href="data-types.html#integer-types" title="11.2.1&nbsp;Integer Types (Exact Value) - INTEGER, INT, SMALLINT, TINYINT, MEDIUMINT, BIGINT"><code class="literal">SMALLINT(3)</code></a> has the usual
            <a class="link" href="data-types.html#integer-types" title="11.2.1&nbsp;Integer Types (Exact Value) - INTEGER, INT, SMALLINT, TINYINT, MEDIUMINT, BIGINT"><code class="literal">SMALLINT</code></a> range of
            <code class="literal">-32768</code> to <code class="literal">32767</code>, and
            values outside the range permitted by three digits are displayed
            in full using more than three digits.
        </p><p style="color:blue;">显示宽度不限制可以存储在列中的值的范围。它也不能防止大于列显示宽度的值被正确显示。例如，指定为smallint（3）的列通常的smallint范围为-32768到32767，超出三位数字允许的范围的值将使用三位以上的数字完整显示。</p><p></p><p>
            When used in conjunction with the optional (nonstandard)
            <code class="literal">ZEROFILL</code> attribute, the default padding of
            spaces is replaced with zeros. For example, for a column
            declared as <a class="link" href="data-types.html#integer-types" title="11.2.1&nbsp;Integer Types (Exact Value) - INTEGER, INT, SMALLINT, TINYINT, MEDIUMINT, BIGINT"><code class="literal">INT(4) ZEROFILL</code></a>, a
            value of <code class="literal">5</code> is retrieved as
            <code class="literal">0005</code>.
        </p><p style="color:blue;">当与可选（非标准）零填充属性一起使用时，空格的默认填充将替换为零。例如，对于声明为int（4）zerofill的列，将5的值检索为0005。</p><p></p>
            <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">

                <div class="admon-title">
                    Note
                </div>
                <p>
                    The <code class="literal">ZEROFILL</code> attribute is ignored for
                    columns involved in expressions or
                    <a class="link" href="sql-syntax.html#union" title="13.2.9.3&nbsp;UNION Syntax"><code class="literal">UNION</code></a> queries.
                </p><p style="color:blue;">对于表达式或联合查询中涉及的列，将忽略zerofill属性。</p><p></p><p>
                If you store values larger than the display width in an
                integer column that has the <code class="literal">ZEROFILL</code>
                attribute, you may experience problems when MySQL generates
                temporary tables for some complicated joins. In these cases,
                MySQL assumes that the data values fit within the column
                display width.
            </p><p style="color:blue;">如果将大于显示宽度的值存储在具有zerofill属性的整数列中，则在mysql为某些复杂的联接生成临时表时可能会遇到问题。在这些情况下，mysql假设数据值符合列显示宽度。</p><p></p>
            </div>
            <p>
                All integer types can have an optional (nonstandard)
                <code class="literal">UNSIGNED</code> attribute. An unsigned type can be
                used to permit only nonnegative numbers in a column or when you
                need a larger upper numeric range for the column. For example,
                if an <a class="link" href="data-types.html#integer-types" title="11.2.1&nbsp;Integer Types (Exact Value) - INTEGER, INT, SMALLINT, TINYINT, MEDIUMINT, BIGINT"><code class="literal">INT</code></a> column is
                <code class="literal">UNSIGNED</code>, the size of the column's range is
                the same but its endpoints shift up, from
                <code class="literal">-2147483648</code> and <code class="literal">2147483647</code>
                to <code class="literal">0</code> and <code class="literal">4294967295</code>.
            </p><p style="color:blue;">所有整数类型都可以有一个可选的（非标准的）无符号属性。无符号类型可用于仅允许列中的非负数，或者在需要较大的列上限数值范围时使用。例如，如果int列是无符号列，则该列的范围大小相同，但其端点会上移，从-2147483648和2147483647移到0和4294967295。</p><p></p><p>
            Floating-point and fixed-point types also can be
            <code class="literal">UNSIGNED</code>. As with integer types, this
            attribute prevents negative values from being stored in the
            column. Unlike the integer types, the upper range of column
            values remains the same.
        </p><p style="color:blue;">浮点和定点类型也可以是无符号的。与整数类型一样，此属性防止将负值存储在列中。与整数类型不同，列值的上限保持不变。</p><p></p><p>
            If you specify <code class="literal">ZEROFILL</code> for a numeric column,
            MySQL automatically adds the <code class="literal">UNSIGNED</code>
            attribute.
        </p><p style="color:blue;">如果为数字列指定零填充，mysql会自动添加unsigned属性。</p><p></p><p>
            Integer or floating-point data types can have the
            <code class="literal">AUTO_INCREMENT</code> attribute. When you insert a
            value of <code class="literal">NULL</code> into an indexed
            <code class="literal">AUTO_INCREMENT</code> column, the column is set to
            the next sequence value. Typically this is
            <code class="literal"><em class="replaceable"><code>value</code></em>+1</code>, where
            <em class="replaceable"><code>value</code></em> is the largest value for the
            column currently in the table.
            (<code class="literal">AUTO_INCREMENT</code> sequences begin with
            <code class="literal">1</code>.)
        </p><p style="color:blue;">整数或浮点数据类型可以具有“自动递增”属性。将空值插入索引的自动递增列时，该列将设置为下一个序列值。通常这是value+1，其中value是表中当前列的最大值。（自动递增序列以1开头。）</p><p></p><p>
            Storing <code class="literal">0</code> into an
            <code class="literal">AUTO_INCREMENT</code> column has the same effect as
            storing <code class="literal">NULL</code>, unless the
            <a class="link" href="server-administration.html#sqlmode_no_auto_value_on_zero"><code class="literal">NO_AUTO_VALUE_ON_ZERO</code></a> SQL mode
            is enabled.
        </p><p style="color:blue;">将0存储到auto_increment列与存储空值具有相同的效果，除非启用了no_auto_value_on_zero sql模式。</p><p></p><p>
            Inserting <code class="literal">NULL</code> to generate
            <code class="literal">AUTO_INCREMENT</code> values requires that the
            column be declared <code class="literal">NOT NULL</code>. If the column is
            declared <code class="literal">NULL</code>, inserting
            <code class="literal">NULL</code> stores a <code class="literal">NULL</code>. When
            you insert any other value into an
            <code class="literal">AUTO_INCREMENT</code> column, the column is set to
            that value and the sequence is reset so that the next
            automatically generated value follows sequentially from the
            inserted value.
        </p><p style="color:blue;">插入空值以生成自动递增值需要声明列不为空。如果列声明为空，则插入空将存储空值。在自动递增列中插入任何其他值时，该列将设置为该值并重置序列，以便下一个自动生成的值从插入的值开始按顺序跟随。</p><p></p><p>
            Negative values for <code class="literal">AUTO_INCREMENT</code> columns
            are not supported.
        </p><p style="color:blue;">不支持自动递增列的负值。</p><p></p>
        </div>
        <div class="section">
            <div class="titlepage">
                <div>
                    <div>
                        <h3 class="title"><a name="out-of-range-and-overflow"></a>11.2.6&nbsp;Out-of-Range and Overflow Handling</h3>

                    </div>

                </div>

            </div>
            <a class="indexterm" name="idm140286861023104"></a><a class="indexterm" name="idm140286861022032"></a><p>
            When MySQL stores a value in a numeric column that is outside
            the permissible range of the column data type, the result
            depends on the SQL mode in effect at the time:
        </p><p style="color:blue;">当mysql在列数据类型允许范围之外的数字列中存储值时，结果取决于当时有效的sql模式：</p><p></p>
            <div class="itemizedlist">
                <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                    If strict SQL mode is enabled, MySQL rejects the
                    out-of-range value with an error, and the insert fails, in
                    accordance with the SQL standard.
                </p><p style="color:blue;">如果启用了strict sql模式，mysql会根据sql标准拒绝超出范围的值并返回一个错误，插入操作将失败。</p><p></p></li><li class="listitem"><p>
                    If no restrictive modes are enabled, MySQL clips the value
                    to the appropriate endpoint of the column data type range
                    and stores the resulting value instead.
                </p><p style="color:blue;">如果没有启用限制模式，mysql会将该值剪辑到列数据类型范围的适当端点，并存储结果值。</p><p></p><p>
                    When an out-of-range value is assigned to an integer column,
                    MySQL stores the value representing the corresponding
                    endpoint of the column data type range.
                </p><p style="color:blue;">将超出范围的值分配给整数列时，mysql存储表示列数据类型范围的相应端点的值。</p><p></p><p>
                    When a floating-point or fixed-point column is assigned a
                    value that exceeds the range implied by the specified (or
                    default) precision and scale, MySQL stores the value
                    representing the corresponding endpoint of that range.
                </p><p style="color:blue;">当给浮点或定点列分配的值超出指定（或默认）精度和小数位数所隐含的范围时，mysql将存储表示该范围的相应端点的值。</p><p></p></li></ul>
            </div>
            <p>
                Suppose that a table <code class="literal">t1</code> has this definition:
            </p><p style="color:blue;">假设表T1具有以下定义：</p><p></p><pre data-lang="sql" class="programlisting">CREATE TABLE t1 (i1 TINYINT, i2 TINYINT UNSIGNED);
</pre><p>
            With strict SQL mode enabled, an out of range error occurs:
        </p><p style="color:blue;">启用严格SQL模式时，会发生超出范围的错误：</p><p></p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>SET sql_mode = 'TRADITIONAL';</code></strong>
mysql&gt; <strong class="userinput"><code>INSERT INTO t1 (i1, i2) VALUES(256, 256);</code></strong>
ERROR 1264 (22003): Out of range value for column 'i1' at row 1
mysql&gt; <strong class="userinput"><code>SELECT * FROM t1;</code></strong>
Empty set (0.00 sec)
</pre><p>
            With strict SQL mode not enabled, clipping with warnings occurs:
        </p><p style="color:blue;">在未启用严格SQL模式的情况下，将出现带警告的剪辑：</p><p></p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>SET sql_mode = '';</code></strong>
mysql&gt; <strong class="userinput"><code>INSERT INTO t1 (i1, i2) VALUES(256, 256);</code></strong>
mysql&gt; <strong class="userinput"><code>SHOW WARNINGS;</code></strong>
+---------+------+---------------------------------------------+
| Level   | Code | Message                                     |
+---------+------+---------------------------------------------+
| Warning | 1264 | Out of range value for column 'i1' at row 1 |
| Warning | 1264 | Out of range value for column 'i2' at row 1 |
+---------+------+---------------------------------------------+
mysql&gt; <strong class="userinput"><code>SELECT * FROM t1;</code></strong>
+------+------+
| i1   | i2   |
+------+------+
|  127 |  255 |
+------+------+
</pre><p>
            When strict SQL mode is not enabled, column-assignment
            conversions that occur due to clipping are reported as warnings
            for <a class="link" href="sql-syntax.html#alter-table" title="13.1.8&nbsp;ALTER TABLE Syntax"><code class="literal">ALTER TABLE</code></a>,
            <a class="link" href="sql-syntax.html#load-data" title="13.2.6&nbsp;LOAD DATA Syntax"><code class="literal">LOAD DATA</code></a>,
            <a class="link" href="sql-syntax.html#update" title="13.2.11&nbsp;UPDATE Syntax"><code class="literal">UPDATE</code></a>, and multiple-row
            <a class="link" href="sql-syntax.html#insert" title="13.2.5&nbsp;INSERT Syntax"><code class="literal">INSERT</code></a> statements. In strict
            mode, these statements fail, and some or all the values are not
            inserted or changed, depending on whether the table is a
            transactional table and other factors. For details, see
            <a class="xref" href="server-administration.html#sql-mode" title="5.1.10&nbsp;Server SQL Modes">Section&nbsp;5.1.10, “Server SQL Modes”</a>.
        </p><p style="color:blue;">如果未启用strict sql模式，则由于剪切而发生的列分配转换将报告为alter table、load data、update和多行插入语句的警告。在严格模式下，这些语句失败，并且根据表是否是事务表和其他因素，不会插入或更改某些或所有值。有关详细信息，请参阅第5.1.10节“服务器SQL模式”。</p><p></p><p>
            Overflow during numeric expression evaluation results in an
            error. For example, the largest signed
            <a class="link" href="data-types.html#integer-types" title="11.2.1&nbsp;Integer Types (Exact Value) - INTEGER, INT, SMALLINT, TINYINT, MEDIUMINT, BIGINT"><code class="literal">BIGINT</code></a> value is
            9223372036854775807, so the following expression produces an
            error:
        </p><p style="color:blue;">数值表达式求值期间溢出导致错误。例如，最大的有符号bigint值是9223372036854775807，因此以下表达式会产生错误：</p><p></p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT 9223372036854775807 + 1;</code></strong>
ERROR 1690 (22003): BIGINT value is out of range in '(9223372036854775807 + 1)'
</pre><p>
            To enable the operation to succeed in this case, convert the
            value to unsigned;
        </p><p style="color:blue;">若要在这种情况下使操作成功，请将该值转换为unsigned；</p><p></p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT CAST(9223372036854775807 AS UNSIGNED) + 1;</code></strong>
+-------------------------------------------+
| CAST(9223372036854775807 AS UNSIGNED) + 1 |
+-------------------------------------------+
|                       9223372036854775808 |
+-------------------------------------------+
</pre><p>
            Whether overflow occurs depends on the range of the operands, so
            another way to handle the preceding expression is to use
            exact-value arithmetic because
            <a class="link" href="data-types.html#fixed-point-types" title="11.2.2&nbsp;Fixed-Point Types (Exact Value) - DECIMAL, NUMERIC"><code class="literal">DECIMAL</code></a> values have a larger
            range than integers:
        </p><p style="color:blue;">是否发生溢出取决于操作数的范围，因此处理前面表达式的另一种方法是使用精确值算术，因为十进制值的范围大于整数：</p><p></p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT 9223372036854775807.0 + 1;</code></strong>
+---------------------------+
| 9223372036854775807.0 + 1 |
+---------------------------+
|     9223372036854775808.0 |
+---------------------------+
</pre><p>
            Subtraction between integer values, where one is of type
            <code class="literal">UNSIGNED</code>, produces an unsigned result by
            default. If the result would otherwise have been negative, an
            error results:
        </p><p style="color:blue;">默认情况下，整数值之间的减法（其中一个为无符号类型）会产生无符号结果。如果结果本来是负数，则会产生错误：</p><p></p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>SET sql_mode = '';</code></strong>
Query OK, 0 rows affected (0.00 sec)

mysql&gt; <strong class="userinput"><code>SELECT CAST(0 AS UNSIGNED) - 1;</code></strong>
<span class="errortext">ERROR 1690 (22003): BIGINT UNSIGNED value is out of range in '(cast(0 as unsigned) - 1)'</span>
</pre><p>
            If the <a class="link" href="server-administration.html#sqlmode_no_unsigned_subtraction"><code class="literal">NO_UNSIGNED_SUBTRACTION</code></a>
            SQL mode is enabled, the result is negative:
        </p><p style="color:blue;">如果启用了无符号减法SQL模式，则结果为负：</p><p></p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>SET sql_mode = 'NO_UNSIGNED_SUBTRACTION';</code></strong>
mysql&gt; <strong class="userinput"><code>SELECT CAST(0 AS UNSIGNED) - 1;</code></strong>
+-------------------------+
| CAST(0 AS UNSIGNED) - 1 |
+-------------------------+
|                      -1 |
+-------------------------+
</pre><p>
            If the result of such an operation is used to update an
            <code class="literal">UNSIGNED</code> integer column, the result is
            clipped to the maximum value for the column type, or clipped to
            0 if <a class="link" href="server-administration.html#sqlmode_no_unsigned_subtraction"><code class="literal">NO_UNSIGNED_SUBTRACTION</code></a>
            is enabled. If strict SQL mode is enabled, an error occurs and
            the column remains unchanged.
        </p><p style="color:blue;">如果使用这种操作的结果来更新无符号整数列，则将结果剪辑为列类型的最大值，或者如果启用NoIUnSigNeNdx减法，则将结果剪切为0。如果启用了strict sql模式，则会发生错误，列保持不变。</p><p></p>
        </div>

    </div>
    <div class="section">
        <div class="titlepage">
            <div>
                <div>
                    <h2 class="title" style="clear: both"><a name="date-and-time-types"></a>11.3&nbsp;Date and Time Types</h2>

                </div>

            </div>

        </div>
        <div class="toc">
            <dl class="toc"><dt><span class="section"><a href="data-types.html#datetime">11.3.1 The DATE, DATETIME, and TIMESTAMP Types</a></span></dt><dt><span class="section"><a href="data-types.html#time">11.3.2 The TIME Type</a></span></dt><dt><span class="section"><a href="data-types.html#year">11.3.3 The YEAR Type</a></span></dt><dt><span class="section"><a href="data-types.html#migrating-from-year2">11.3.4 2-Digit YEAR(2) Limitations and Migrating to 4-Digit YEAR</a></span></dt><dt><span class="section"><a href="data-types.html#timestamp-initialization">11.3.5 Automatic Initialization and Updating for TIMESTAMP and DATETIME</a></span></dt><dt><span class="section"><a href="data-types.html#fractional-seconds">11.3.6 Fractional Seconds in Time Values</a></span></dt><dt><span class="section"><a href="data-types.html#date-and-time-type-conversion">11.3.7 Conversion Between Date and Time Types</a></span></dt><dt><span class="section"><a href="data-types.html#two-digit-years">11.3.8 2-Digit Years in Dates</a></span></dt></dl>
        </div>
        <a class="indexterm" name="idm140286860977200"></a><a class="indexterm" name="idm140286860975712"></a><p>
        The date and time types for representing temporal values are
        <a class="link" href="data-types.html#datetime" title="11.3.1&nbsp;The DATE, DATETIME, and TIMESTAMP Types"><code class="literal">DATE</code></a>,
        <a class="link" href="data-types.html#time" title="11.3.2&nbsp;The TIME Type"><code class="literal">TIME</code></a>,
        <a class="link" href="data-types.html#datetime" title="11.3.1&nbsp;The DATE, DATETIME, and TIMESTAMP Types"><code class="literal">DATETIME</code></a>,
        <a class="link" href="data-types.html#datetime" title="11.3.1&nbsp;The DATE, DATETIME, and TIMESTAMP Types"><code class="literal">TIMESTAMP</code></a>, and
        <a class="link" href="data-types.html#year" title="11.3.3&nbsp;The YEAR Type"><code class="literal">YEAR</code></a>. Each temporal type has a
        range of valid values, as well as a <span class="quote">“<span class="quote">zero</span>”</span> value that
        may be used when you specify an invalid value that MySQL cannot
        represent. The <a class="link" href="data-types.html#datetime" title="11.3.1&nbsp;The DATE, DATETIME, and TIMESTAMP Types"><code class="literal">TIMESTAMP</code></a> type has
        special automatic updating behavior, described later. For temporal
        type storage requirements, see
        <a class="xref" href="data-types.html#storage-requirements" title="11.8&nbsp;Data Type Storage Requirements">Section&nbsp;11.8, “Data Type Storage Requirements”</a>.
    </p><p style="color:blue;">表示时间值的日期和时间类型是日期、时间、日期时间、时间戳和年份。每个时态类型都有一个有效值的范围，以及一个“零”值，当您指定一个mysql不能表示的无效值时，可以使用该值。时间戳类型具有特殊的自动更新行为，稍后将进行描述。关于时间型存储要求，见第11.8节“数据型存储要求”。</p><p></p><p>
        Keep in mind these general considerations when working with date
        and time types:
    </p><p style="color:blue;">在使用日期和时间类型时，请记住以下一般注意事项：</p><p></p>
        <div class="itemizedlist">
            <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                MySQL retrieves values for a given date or time type in a
                standard output format, but it attempts to interpret a variety
                of formats for input values that you supply (for example, when
                you specify a value to be assigned to or compared to a date or
                time type). For a description of the permitted formats for
                date and time types, see
                <a class="xref" href="language-structure.html#date-and-time-literals" title="9.1.3&nbsp;Date and Time Literals">Section&nbsp;9.1.3, “Date and Time Literals”</a>. It is expected that
                you supply valid values. Unpredictable results may occur if
                you use values in other formats.
            </p><p style="color:blue;">mysql以标准输出格式检索给定日期或时间类型的值，但它尝试为您提供的输入值解释各种格式（例如，当您指定要分配给日期或时间类型或与之比较的值时）。有关日期和时间类型允许格式的说明，请参见第9.1.3节“日期和时间文本”。希望您提供有效值。如果使用其他格式的值，可能会出现不可预测的结果。</p><p></p></li><li class="listitem"><p>
                Although MySQL tries to interpret values in several formats,
                date parts must always be given in year-month-day order (for
                example, <code class="literal">'98-09-04'</code>), rather than in the
                month-day-year or day-month-year orders commonly used
                elsewhere (for example, <code class="literal">'09-04-98'</code>,
                <code class="literal">'04-09-98'</code>).
            </p><p style="color:blue;">尽管mysql尝试以多种格式解释值，但日期部分必须始终以年-月-日顺序（例如，“98-09-04”）给出，而不是以其他地方常用的月-日-年或日-月-年顺序（例如，“09-04-98”、“04-09-98”）给出。</p><p></p></li><li class="listitem"><p>
                Dates containing 2-digit year values are ambiguous because the
                century is unknown. MySQL interprets 2-digit year values using
                these rules:
            </p><p style="color:blue;">包含两位数年份值的日期不明确，因为世纪未知。mysql使用以下规则解释2位数的年份值：</p><p></p>
                <div class="itemizedlist">
                    <ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
                        Year values in the range <code class="literal">70-99</code> are
                        converted to <code class="literal">1970-1999</code>.
                    </p><p style="color:blue;">70-99之间的年份值转换为1970-1999。</p><p></p></li><li class="listitem"><p>
                        Year values in the range <code class="literal">00-69</code> are
                        converted to <code class="literal">2000-2069</code>.
                    </p><p style="color:blue;">范围为00-69的年份值转换为2000-2069。</p><p></p></li></ul>
                </div>
                <p>
                    See also <a class="xref" href="data-types.html#two-digit-years" title="11.3.8&nbsp;2-Digit Years in Dates">Section&nbsp;11.3.8, “2-Digit Years in Dates”</a>.
                </p><p style="color:blue;">另见第11.3.8节“日期中的两位数年份”。</p><p></p></li><li class="listitem"><p>
                Conversion of values from one temporal type to another occurs
                according to the rules in
                <a class="xref" href="data-types.html#date-and-time-type-conversion" title="11.3.7&nbsp;Conversion Between Date and Time Types">Section&nbsp;11.3.7, “Conversion Between Date and Time Types”</a>.
            </p><p style="color:blue;">根据第11.3.7节“日期和时间类型之间的转换”中的规则，将值从一种时态类型转换为另一种时态类型。</p><p></p></li><li class="listitem"><p>
                MySQL automatically converts a date or time value to a number
                if the value is used in a numeric context and vice versa.
            </p><p style="color:blue;">如果在数字上下文中使用日期或时间值，mysql会自动将其转换为数字，反之亦然。</p><p></p></li><li class="listitem"><p>
                By default, when MySQL encounters a value for a date or time
                type that is out of range or otherwise invalid for the type,
                it converts the value to the <span class="quote">“<span class="quote">zero</span>”</span> value for
                that type. The exception is that out-of-range
                <a class="link" href="data-types.html#time" title="11.3.2&nbsp;The TIME Type"><code class="literal">TIME</code></a> values are clipped to the
                appropriate endpoint of the
                <a class="link" href="data-types.html#time" title="11.3.2&nbsp;The TIME Type"><code class="literal">TIME</code></a> range.
            </p><p style="color:blue;">默认情况下，当mysql遇到日期或时间类型的值超出范围或对该类型无效时，它会将该值转换为该类型的“零”值。例外情况是超出范围的时间值被剪裁到时间范围的适当端点。</p><p></p></li><li class="listitem"><p>
                By setting the SQL mode to the appropriate value, you can
                specify more exactly what kind of dates you want MySQL to
                support. (See <a class="xref" href="server-administration.html#sql-mode" title="5.1.10&nbsp;Server SQL Modes">Section&nbsp;5.1.10, “Server SQL Modes”</a>.) You can get MySQL
                to accept certain dates, such as
                <code class="literal">'2009-11-31'</code>, by enabling the
                <a class="link" href="server-administration.html#sqlmode_allow_invalid_dates"><code class="literal">ALLOW_INVALID_DATES</code></a> SQL
                mode. This is useful when you want to store a <span class="quote">“<span class="quote">possibly
          wrong</span>”</span> value which the user has specified (for example,
                in a web form) in the database for future processing. Under
                this mode, MySQL verifies only that the month is in the range
                from 1 to 12 and that the day is in the range from 1 to 31.
            </p><p style="color:blue;">通过将sql模式设置为适当的值，可以更准确地指定希望mysql支持的日期类型。（请参阅第5.1.10节“服务器SQL模式”。）通过启用“允许无效日期”SQL模式，可以使MySQL接受某些日期，例如“2009-11-31”。当您希望在数据库中存储用户指定的“可能错误”值（例如，在web表单中）以供将来处理时，这非常有用。在此模式下，mysql只验证月份是否在1到12之间，日期是否在1到31之间。</p><p></p></li><li class="listitem"><p>
                MySQL permits you to store dates where the day or month and
                day are zero in a <a class="link" href="data-types.html#datetime" title="11.3.1&nbsp;The DATE, DATETIME, and TIMESTAMP Types"><code class="literal">DATE</code></a> or
                <a class="link" href="data-types.html#datetime" title="11.3.1&nbsp;The DATE, DATETIME, and TIMESTAMP Types"><code class="literal">DATETIME</code></a> column. This is useful
                for applications that need to store birthdates for which you
                may not know the exact date. In this case, you simply store
                the date as <code class="literal">'2009-00-00'</code> or
                <code class="literal">'2009-01-00'</code>. If you store dates such as
                these, you should not expect to get correct results for
                functions such as <a class="link" href="functions.html#function_date-sub"><code class="literal">DATE_SUB()</code></a> or
                <a class="link" href="functions.html#function_date-add"><code class="literal">DATE_ADD()</code></a> that require
                complete dates. To disallow zero month or day parts in dates,
                enable the <a class="link" href="server-administration.html#sqlmode_no_zero_in_date"><code class="literal">NO_ZERO_IN_DATE</code></a>
                mode.
            </p><p style="color:blue;">mysql允许您在日期或日期时间列中存储日期，其中日期、月份和日期为零。这对于需要存储您可能不知道确切日期的生日的应用程序非常有用。在本例中，您只需将日期存储为“2009-00-00”或“2009-01-00”。如果存储这样的日期，则不应期望为需要完整日期的函数（如date_sub（）或date_add（））获得正确的结果。若要在日期中不允许零月份或零日期部分，请在日期模式中启用“无零”。</p><p></p></li><li class="listitem"><p>
                MySQL permits you to store a <span class="quote">“<span class="quote">zero</span>”</span> value of
                <code class="literal">'0000-00-00'</code> as a <span class="quote">“<span class="quote">dummy
          date.</span>”</span> This is in some cases more convenient than using
                <code class="literal">NULL</code> values, and uses less data and index
                space. To disallow <code class="literal">'0000-00-00'</code>, enable the
                <a class="link" href="server-administration.html#sqlmode_no_zero_date"><code class="literal">NO_ZERO_DATE</code></a> mode.
            </p><p style="color:blue;">mysql允许您将“0000-00-00”的“零”值存储为“伪日期”，在某些情况下，这比使用空值更方便，并且使用的数据和索引空间更少。若要禁止“0000-00-00”，请启用“无零”日期模式。</p><p></p></li><li class="listitem"><p>
                <span class="quote">“<span class="quote">Zero</span>”</span> date or time values used through
                Connector/ODBC are converted automatically to
                <code class="literal">NULL</code> because ODBC cannot handle such
                values.
            </p><p style="color:blue;">通过连接器/ODBC使用的“零”日期或时间值将自动转换为空，因为ODBC无法处理此类值。</p><p></p></li></ul>
        </div>
        <p>
            The following table shows the format of the <span class="quote">“<span class="quote">zero</span>”</span>
            value for each type. The <span class="quote">“<span class="quote">zero</span>”</span> values are special,
            but you can store or refer to them explicitly using the values
            shown in the table. You can also do this using the values
            <code class="literal">'0'</code> or <code class="literal">0</code>, which are easier
            to write. For temporal types that include a date part
            (<a class="link" href="data-types.html#datetime" title="11.3.1&nbsp;The DATE, DATETIME, and TIMESTAMP Types"><code class="literal">DATE</code></a>,
            <a class="link" href="data-types.html#datetime" title="11.3.1&nbsp;The DATE, DATETIME, and TIMESTAMP Types"><code class="literal">DATETIME</code></a>, and
            <a class="link" href="data-types.html#datetime" title="11.3.1&nbsp;The DATE, DATETIME, and TIMESTAMP Types"><code class="literal">TIMESTAMP</code></a>), use of these values may
            produce warning or errors. The precise behavior depends on which
            if any of strict SQL mode and the
            <a class="link" href="server-administration.html#sqlmode_no_zero_date"><code class="literal">NO_ZERO_DATE</code></a> SQL mode are
            enabled; see <a class="xref" href="server-administration.html#sql-mode" title="5.1.10&nbsp;Server SQL Modes">Section&nbsp;5.1.10, “Server SQL Modes”</a>.
        </p><p style="color:blue;">下表显示了每种类型的“零”值的格式。“零”值是特殊的，但是您可以使用表中显示的值来存储或显式引用它们。您还可以使用值“0”或0来完成此操作，这些值更易于编写。对于包含日期部分（日期、日期时间和时间戳）的时态类型，使用这些值可能会产生警告或错误。精确的行为取决于是否启用了严格SQL模式和无日期SQL模式；请参阅第5.1.10节“服务器SQL模式”。</p><p></p>
        <div class="informaltable">
            <table summary="Format of the zero value for temporal data types."><colgroup><col width="30%"><col width="40%"></colgroup><thead><tr>
                <th scope="col">Data Type</th>
                <th scope="col"><span class="quote">“<span class="quote">Zero</span>”</span> Value</th>
            </tr></thead><tbody><tr>
                <td scope="row"><a class="link" href="data-types.html#datetime" title="11.3.1&nbsp;The DATE, DATETIME, and TIMESTAMP Types"><code class="literal">DATE</code></a></td>
                <td><code class="literal">'0000-00-00'</code></td>
            </tr><tr>
                <td scope="row"><a class="link" href="data-types.html#time" title="11.3.2&nbsp;The TIME Type"><code class="literal">TIME</code></a></td>
                <td><code class="literal">'00:00:00'</code></td>
            </tr><tr>
                <td scope="row"><a class="link" href="data-types.html#datetime" title="11.3.1&nbsp;The DATE, DATETIME, and TIMESTAMP Types"><code class="literal">DATETIME</code></a></td>
                <td><code class="literal">'0000-00-00 00:00:00'</code></td>
            </tr><tr>
                <td scope="row"><a class="link" href="data-types.html#datetime" title="11.3.1&nbsp;The DATE, DATETIME, and TIMESTAMP Types"><code class="literal">TIMESTAMP</code></a></td>
                <td><code class="literal">'0000-00-00 00:00:00'</code></td>
            </tr><tr>
                <td scope="row"><a class="link" href="data-types.html#year" title="11.3.3&nbsp;The YEAR Type"><code class="literal">YEAR</code></a></td>
                <td><code class="literal">0000</code></td>
            </tr></tbody></table>
        </div>
        <div class="section">
            <div class="titlepage">
                <div>
                    <div>
                        <h3 class="title"><a name="datetime"></a>11.3.1&nbsp;The DATE, DATETIME, and TIMESTAMP Types</h3>

                    </div>

                </div>

            </div>
            <a class="indexterm" name="idm140286860890704"></a><a class="indexterm" name="idm140286860889664"></a><a class="indexterm" name="idm140286860888592"></a><a class="indexterm" name="idm140286860887520"></a><a class="indexterm" name="idm140286860886032"></a><a class="indexterm" name="idm140286860884544"></a><p>
            The <code class="literal">DATE</code>, <code class="literal">DATETIME</code>, and
            <code class="literal">TIMESTAMP</code> types are related. This section
            describes their characteristics, how they are similar, and how
            they differ. MySQL recognizes <code class="literal">DATE</code>,
            <code class="literal">DATETIME</code>, and <code class="literal">TIMESTAMP</code>
            values in several formats, described in
            <a class="xref" href="language-structure.html#date-and-time-literals" title="9.1.3&nbsp;Date and Time Literals">Section&nbsp;9.1.3, “Date and Time Literals”</a>. For the
            <code class="literal">DATE</code> and <code class="literal">DATETIME</code> range
            descriptions, <span class="quote">“<span class="quote">supported</span>”</span> means that although
            earlier values might work, there is no guarantee.
        </p><p style="color:blue;">日期、日期时间和时间戳类型是相关的。本节介绍了它们的特点、相似之处和不同之处。mysql以多种格式识别日期、日期时间和时间戳值，如9.1.3节“日期和时间文本”所述。对于日期和日期时间范围描述，“受支持”意味着尽管较早的值可能起作用，但不能保证。</p><p></p><p>
            The <code class="literal">DATE</code> type is used for values with a date
            part but no time part. MySQL retrieves and displays
            <code class="literal">DATE</code> values in
            <code class="literal">'YYYY-MM-DD'</code> format. The supported range is
            <code class="literal">'1000-01-01'</code> to
            <code class="literal">'9999-12-31'</code>.
        </p><p style="color:blue;">日期类型用于具有日期部分但没有时间部分的值。mysql检索并显示“yyyy-mm-dd”格式的日期值。支持的范围是“1000-01-01”到“9999-12-31”。</p><p></p><p>
            The <code class="literal">DATETIME</code> type is used for values that
            contain both date and time parts. MySQL retrieves and displays
            <code class="literal">DATETIME</code> values in <em class="replaceable"><code>'YYYY-MM-DD
            hh:mm:ss'</code></em> format. The supported range is
            <code class="literal">'1000-01-01 00:00:00'</code> to <code class="literal">'9999-12-31
            23:59:59'</code>.
        </p><p style="color:blue;">DateTime类型用于同时包含日期和时间部分的值。mysql检索并显示“yyyy-mm-dd hh:mm:ss”格式的日期时间值。支持的范围是“1000-01-01 00:00:00”到“9999-12-31 23:59:59”。</p><p></p><p>
            The <code class="literal">TIMESTAMP</code> data type is used for values
            that contain both date and time parts.
            <code class="literal">TIMESTAMP</code> has a range of <code class="literal">'1970-01-01
            00:00:01'</code> UTC to <code class="literal">'2038-01-19
            03:14:07'</code> UTC.
        </p><p style="color:blue;">时间戳数据类型用于包含日期和时间部分的值。时间戳的范围是“1970-01-01 00:00:01”UTC到“2038-01-19 03:14:07”UTC。</p><p></p><p>
            A <code class="literal">DATETIME</code> or <code class="literal">TIMESTAMP</code>
            value can include a trailing fractional seconds part in up to
            microseconds (6 digits) precision. In particular, any fractional
            part in a value inserted into a <code class="literal">DATETIME</code> or
            <code class="literal">TIMESTAMP</code> column is stored rather than
            discarded. With the fractional part included, the format for
            these values is <code class="literal">'<em class="replaceable"><code>YYYY-MM-DD
            hh:mm:ss</code></em>[.<em class="replaceable"><code>fraction</code></em>]'</code>,
            the range for <code class="literal">DATETIME</code> values is
            <code class="literal">'1000-01-01 00:00:00.000000'</code> to
            <code class="literal">'9999-12-31 23:59:59.999999'</code>, and the range
            for <code class="literal">TIMESTAMP</code> values is <code class="literal">'1970-01-01
            00:00:01.000000'</code> to <code class="literal">'2038-01-19
            03:14:07.999999'</code>. The fractional part should always be
            separated from the rest of the time by a decimal point; no other
            fractional seconds delimiter is recognized. For information
            about fractional seconds support in MySQL, see
            <a class="xref" href="data-types.html#fractional-seconds" title="11.3.6&nbsp;Fractional Seconds in Time Values">Section&nbsp;11.3.6, “Fractional Seconds in Time Values”</a>.
        </p><p style="color:blue;">datetime或timestamp值可以包含最高达微秒（6位）精度的尾随小数秒部分。特别是，插入datetime或timestamp列的值中的任何小数部分都将被存储而不是丢弃。包含小数部分时，这些值的格式为“yyyy-mm-dd hh:mm:ss[.fraction]”，日期时间值的范围为“1000-01-01 00:00:00.000000”到“9999-12-31 23:59:59.999999”，时间戳值的范围为“1970-01-01 00:00:01.000000”到“2038-01-19 03:14:07.999999”。小数部分应始终与其余时间用小数点分隔；不能识别其他小数秒分隔符。有关MySQL中分数秒支持的信息，请参阅第11.3.6节“时间值中的分数秒”。</p><p></p><p>
            The <code class="literal">TIMESTAMP</code> and <code class="literal">DATETIME</code>
            data types offer automatic initialization and updating to the
            current date and time. For more information, see
            <a class="xref" href="data-types.html#timestamp-initialization" title="11.3.5&nbsp;Automatic Initialization and Updating for TIMESTAMP and DATETIME">Section&nbsp;11.3.5, “Automatic Initialization and Updating for TIMESTAMP and DATETIME”</a>.
        </p><p style="color:blue;">时间戳和日期时间数据类型提供对当前日期和时间的自动初始化和更新。有关更多信息，请参阅第11.3.5节“时间戳和日期时间的自动初始化和更新”。</p><p></p><p>
            MySQL converts <code class="literal">TIMESTAMP</code> values from the
            current time zone to UTC for storage, and back from UTC to the
            current time zone for retrieval. (This does not occur for other
            types such as <code class="literal">DATETIME</code>.) By default, the
            current time zone for each connection is the server's time. The
            time zone can be set on a per-connection basis. As long as the
            time zone setting remains constant, you get back the same value
            you store. If you store a <code class="literal">TIMESTAMP</code> value,
            and then change the time zone and retrieve the value, the
            retrieved value is different from the value you stored. This
            occurs because the same time zone was not used for conversion in
            both directions. The current time zone is available as the value
            of the <a class="link" href="server-administration.html#sysvar_time_zone"><code class="literal">time_zone</code></a> system
            variable. For more information, see
            <a class="xref" href="server-administration.html#time-zone-support" title="5.1.12&nbsp;MySQL Server Time Zone Support">Section&nbsp;5.1.12, “MySQL Server Time Zone Support”</a>.
        </p><p style="color:blue;">mysql将时间戳值从当前时区转换为utc进行存储，然后从utc返回当前时区进行检索。（其他类型（如datetime）不会发生这种情况。）默认情况下，每个连接的当前时区是服务器的时间。时区可以根据每个连接进行设置。只要时区设置保持不变，就可以得到存储的相同值。如果存储时间戳值，然后更改时区并检索该值，则检索到的值与存储的值不同。发生这种情况的原因是没有使用同一时区在两个方向上进行转换。当前时区可用作时区系统变量的值。有关详细信息，请参阅第5.1.12节“MySQL服务器时区支持”。</p><p></p><p>
            Invalid <code class="literal">DATE</code>, <code class="literal">DATETIME</code>, or
            <code class="literal">TIMESTAMP</code> values are converted to the
            <span class="quote">“<span class="quote">zero</span>”</span> value of the appropriate type
            (<code class="literal">'0000-00-00'</code> or <code class="literal">'0000-00-00
            00:00:00'</code>), if the SQL mode permits this conversion.
            The precise behavior depends on which if any of strict SQL mode
            and the <a class="link" href="server-administration.html#sqlmode_no_zero_date"><code class="literal">NO_ZERO_DATE</code></a> SQL mode
            are enabled; see <a class="xref" href="server-administration.html#sql-mode" title="5.1.10&nbsp;Server SQL Modes">Section&nbsp;5.1.10, “Server SQL Modes”</a>.
        </p><p style="color:blue;">如果SQL模式允许此转换，则无效的日期、日期时间或时间戳值将转换为适当类型的“零”值（“0000-00-00”或“0000-00-00 00:00”）。精确的行为取决于是否启用了严格SQL模式和无日期SQL模式；请参阅第5.1.10节“服务器SQL模式”。</p><p></p><a class="indexterm" name="idm140286860839200"></a><a class="indexterm" name="idm140286860837712"></a><p>
            Be aware of certain properties of date value interpretation in
            MySQL:
        </p><p style="color:blue;">了解MySQL中日期值解释的某些属性：</p><p></p>
            <div class="itemizedlist">
                <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                    MySQL permits a <span class="quote">“<span class="quote">relaxed</span>”</span> format for values
                    specified as strings, in which any punctuation character may
                    be used as the delimiter between date parts or time parts.
                    In some cases, this syntax can be deceiving. For example, a
                    value such as <code class="literal">'10:11:12'</code> might look like
                    a time value because of the <code class="literal">:</code>, but is
                    interpreted as the year <code class="literal">'2010-11-12'</code> if
                    used in a date context. The value
                    <code class="literal">'10:45:15'</code> is converted to
                    <code class="literal">'0000-00-00'</code> because
                    <code class="literal">'45'</code> is not a valid month.
                </p><p style="color:blue;">mysql允许对指定为字符串的值使用“宽松”格式，其中任何标点字符都可以用作日期部分或时间部分之间的分隔符。在某些情况下，这种语法可能具有欺骗性。例如，“10:11:12”这样的值可能看起来像时间值，因为：，但如果在日期上下文中使用，则会被解释为“2010-11-12”年。值“10:45:15”转换为“0000-00-00”，因为“45”不是有效的月份。</p><p></p><p>
                    The only delimiter recognized between a date and time part
                    and a fractional seconds part is the decimal point.
                </p><p style="color:blue;">日期和时间部分与小数秒部分之间唯一可识别的分隔符是小数点。</p><p></p></li><li class="listitem"><p>
                    The server requires that month and day values be valid, and
                    not merely in the range 1 to 12 and 1 to 31, respectively.
                    With strict mode disabled, invalid dates such as
                    <code class="literal">'2004-04-31'</code> are converted to
                    <code class="literal">'0000-00-00'</code> and a warning is generated.
                    With strict mode enabled, invalid dates generate an error.
                    To permit such dates, enable
                    <a class="link" href="server-administration.html#sqlmode_allow_invalid_dates"><code class="literal">ALLOW_INVALID_DATES</code></a>. See
                    <a class="xref" href="server-administration.html#sql-mode" title="5.1.10&nbsp;Server SQL Modes">Section&nbsp;5.1.10, “Server SQL Modes”</a>, for more information.
                </p><p style="color:blue;">服务器要求月和日的值是有效的，而不仅仅是分别在1到12和1到31之间。在禁用严格模式的情况下，将“2004-04-31”等无效日期转换为“0000-00-00”，并生成警告。启用严格模式时，无效日期将生成错误。若要允许此类日期，请启用“允许无效日期”。有关详细信息，请参阅第5.1.10节“服务器SQL模式”。</p><p></p></li><li class="listitem"><p>
                    MySQL does not accept <code class="literal">TIMESTAMP</code> values
                    that include a zero in the day or month column or values
                    that are not a valid date. The sole exception to this rule
                    is the special <span class="quote">“<span class="quote">zero</span>”</span> value
                    <code class="literal">'0000-00-00 00:00:00'</code>, if the SQL mode
                    permits this value. The precise behavior depends on which if
                    any of strict SQL mode and the
                    <a class="link" href="server-administration.html#sqlmode_no_zero_date"><code class="literal">NO_ZERO_DATE</code></a> SQL mode are
                    enabled; see <a class="xref" href="server-administration.html#sql-mode" title="5.1.10&nbsp;Server SQL Modes">Section&nbsp;5.1.10, “Server SQL Modes”</a>.
                </p><p style="color:blue;">mysql不接受在day或month列中包含零的时间戳值或不是有效日期的值。如果sql模式允许此值，则此规则的唯一例外是特殊的“零”值“0000-00-00 00:00:00”。精确的行为取决于是否启用了严格SQL模式和无日期SQL模式；请参阅第5.1.10节“服务器SQL模式”。</p><p></p></li><li class="listitem"><p>
                    Dates containing 2-digit year values are ambiguous because
                    the century is unknown. MySQL interprets 2-digit year values
                    using these rules:
                </p><p style="color:blue;">包含两位数年份值的日期不明确，因为世纪未知。mysql使用以下规则解释2位数的年份值：</p><p></p>
                    <div class="itemizedlist">
                        <ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
                            Year values in the range <code class="literal">00-69</code> are
                            converted to <code class="literal">2000-2069</code>.
                        </p><p style="color:blue;">范围为00-69的年份值转换为2000-2069。</p><p></p></li><li class="listitem"><p>
                            Year values in the range <code class="literal">70-99</code> are
                            converted to <code class="literal">1970-1999</code>.
                        </p><p style="color:blue;">70-99之间的年份值转换为1970-1999。</p><p></p></li></ul>
                    </div>
                    <p>
                        See also <a class="xref" href="data-types.html#two-digit-years" title="11.3.8&nbsp;2-Digit Years in Dates">Section&nbsp;11.3.8, “2-Digit Years in Dates”</a>.
                    </p><p style="color:blue;">另见第11.3.8节“日期中的两位数年份”。</p><p></p></li></ul>
            </div>
            <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">
                <div class="admon-title">
                    Note
                </div>
                <p>
                    The MySQL server can be run with the
                    <a class="link" href="server-administration.html#sqlmode_maxdb"><code class="literal">MAXDB</code></a> SQL mode enabled. In
                    this case, <code class="literal">TIMESTAMP</code> is identical with
                    <code class="literal">DATETIME</code>. If this mode is enabled at the
                    time that a table is created, <code class="literal">TIMESTAMP</code>
                    columns are created as <code class="literal">DATETIME</code> columns. As
                    a result, such columns use <code class="literal">DATETIME</code> display
                    format, have the same range of values, and there is no
                    automatic initialization or updating to the current date and
                    time. See <a class="xref" href="server-administration.html#sql-mode" title="5.1.10&nbsp;Server SQL Modes">Section&nbsp;5.1.10, “Server SQL Modes”</a>.
                </p><p style="color:blue;">mysql服务器可以在启用maxdb sql模式的情况下运行。在本例中，时间戳与日期时间相同。如果在创建表时启用此模式，则将时间戳列创建为日期时间列。因此，这些列使用日期时间显示格式，具有相同的值范围，并且没有自动初始化或更新到当前日期和时间。参见第5.1.10节“服务器SQL模式”。</p><p></p>
            </div>
            <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">
                <div class="admon-title">
                    Note
                </div>
                <p>
                    As of MySQL 5.7.22, <a class="link" href="server-administration.html#sqlmode_maxdb"><code class="literal">MAXDB</code></a> is
                    deprecated. It will be removed in a future version of MySQL.
                </p><p style="color:blue;">从mysql 5.7.22开始，maxdb已被弃用。它将在mysql的未来版本中被删除。</p><p></p>
            </div>

        </div>
        <div class="section">
            <div class="titlepage">
                <div>
                    <div>
                        <h3 class="title"><a name="time"></a>11.3.2&nbsp;The TIME Type</h3>

                    </div>

                </div>

            </div>
            <a class="indexterm" name="idm140286860802352"></a><a class="indexterm" name="idm140286860801280"></a><p>
            MySQL retrieves and displays <code class="literal">TIME</code> values in
            <em class="replaceable"><code>'hh:mm:ss'</code></em> format (or
            <em class="replaceable"><code>'hhh:mm:ss'</code></em> format for large hours
            values). <code class="literal">TIME</code> values may range from
            <code class="literal">'-838:59:59'</code> to
            <code class="literal">'838:59:59'</code>. The hours part may be so large
            because the <code class="literal">TIME</code> type can be used not only to
            represent a time of day (which must be less than 24 hours), but
            also elapsed time or a time interval between two events (which
            may be much greater than 24 hours, or even negative).
        </p><p style="color:blue;">mysql检索并显示“hh:mm:ss”格式的时间值（或“hh:mm:ss”格式的大小时值）。时间值的范围从'-838:59:59'到'-838:59:59'。小时部分可能很大，因为时间类型不仅可以用来表示一天中的某个时间（必须小于24小时），还可以表示经过的时间或两个事件之间的时间间隔（可能远远大于24小时，甚至为负）。</p><p></p><p>
            MySQL recognizes <code class="literal">TIME</code> values in several
            formats, some of which can include a trailing fractional seconds
            part in up to microseconds (6 digits) precision. See
            <a class="xref" href="language-structure.html#date-and-time-literals" title="9.1.3&nbsp;Date and Time Literals">Section&nbsp;9.1.3, “Date and Time Literals”</a>. For information about
            fractional seconds support in MySQL, see
            <a class="xref" href="data-types.html#fractional-seconds" title="11.3.6&nbsp;Fractional Seconds in Time Values">Section&nbsp;11.3.6, “Fractional Seconds in Time Values”</a>. In particular, any
            fractional part in a value inserted into a
            <code class="literal">TIME</code> column is stored rather than discarded.
            With the fractional part included, the range for
            <code class="literal">TIME</code> values is
            <code class="literal">'-838:59:59.000000'</code> to
            <code class="literal">'838:59:59.000000'</code>.
        </p><p style="color:blue;">mysql可以识别多种格式的时间值，其中一些格式可以包含最高达微秒（6位）精度的小数秒部分。见第9.1.3节“日期和时间文字”。有关MySQL中分数秒支持的信息，请参阅第11.3.6节“时间值中的分数秒”。特别是，插入时间列的值中的任何小数部分都将被存储而不是丢弃。包含小数部分时，时间值的范围为“-838:59:59.000000”到“838:59:59.000000”。</p><p></p><p>
            Be careful about assigning abbreviated values to a
            <code class="literal">TIME</code> column. MySQL interprets abbreviated
            <code class="literal">TIME</code> values with colons as time of the day.
            That is, <code class="literal">'11:12'</code> means
            <code class="literal">'11:12:00'</code>, not
            <code class="literal">'00:11:12'</code>. MySQL interprets abbreviated
            values without colons using the assumption that the two
            rightmost digits represent seconds (that is, as elapsed time
            rather than as time of day). For example, you might think of
            <code class="literal">'1112'</code> and <code class="literal">1112</code> as meaning
            <code class="literal">'11:12:00'</code> (12 minutes after 11 o'clock), but
            MySQL interprets them as <code class="literal">'00:11:12'</code> (11
            minutes, 12 seconds). Similarly, <code class="literal">'12'</code> and
            <code class="literal">12</code> are interpreted as
            <code class="literal">'00:00:12'</code>.
        </p><p style="color:blue;">请小心将缩写值分配给时间列。mysql将带有冒号的缩写时间值解释为一天中的时间。也就是说，“11:12”是指“11:12:00”，而不是“00:11:12”。mysql使用两个最右边的数字表示秒（即，作为经过的时间而不是一天中的时间）的假设来解释不带冒号的缩写值。例如，您可能认为“1112”和“1112”表示“11:12:00”（11点后12分钟），但MySQL将其解释为“00:11:12”（11分钟，12秒）。类似地，“12”和12被解释为“00:00:12”。</p><p></p><p>
            The only delimiter recognized between a time part and a
            fractional seconds part is the decimal point.
        </p><p style="color:blue;">时间部分和小数秒部分之间唯一可识别的分隔符是小数点。</p><p></p><p>
            By default, values that lie outside the <code class="literal">TIME</code>
            range but are otherwise valid are clipped to the closest
            endpoint of the range. For example,
            <code class="literal">'-850:00:00'</code> and
            <code class="literal">'850:00:00'</code> are converted to
            <code class="literal">'-838:59:59'</code> and
            <code class="literal">'838:59:59'</code>. Invalid <code class="literal">TIME</code>
            values are converted to <code class="literal">'00:00:00'</code>. Note that
            because <code class="literal">'00:00:00'</code> is itself a valid
            <code class="literal">TIME</code> value, there is no way to tell, from a
            value of <code class="literal">'00:00:00'</code> stored in a table,
            whether the original value was specified as
            <code class="literal">'00:00:00'</code> or whether it was invalid.
        </p><p style="color:blue;">默认情况下，位于时间范围之外但在其他情况下有效的值将被剪裁到范围的最近端点。例如，“-850:00:00”和“850:00:00”转换为“-838:59:59”和“838:59:59”。无效的时间值转换为“00:00:00”。请注意，由于“00:00:00”本身是一个有效的时间值，因此无法从存储在表中的“00:00:00”值判断原始值是指定为“00:00:00”还是无效。</p><p></p><p>
            For more restrictive treatment of invalid
            <code class="literal">TIME</code> values, enable strict SQL mode to cause
            errors to occur. See <a class="xref" href="server-administration.html#sql-mode" title="5.1.10&nbsp;Server SQL Modes">Section&nbsp;5.1.10, “Server SQL Modes”</a>.
        </p><p style="color:blue;">要对无效时间值进行更严格的处理，请启用严格的SQL模式以导致错误发生。参见第5.1.10节“服务器SQL模式”。</p><p></p>
        </div>
        <div class="section">
            <div class="titlepage">
                <div>
                    <div>
                        <h3 class="title"><a name="year"></a>11.3.3&nbsp;The YEAR Type</h3>

                    </div>

                </div>

            </div>
            <a class="indexterm" name="idm140286860767024"></a><a class="indexterm" name="idm140286860765952"></a><p>
            The <code class="literal">YEAR</code> type is a 1-byte type used to
            represent year values. It can be declared as
            <code class="literal">YEAR</code> with an implicit display width of 4
            characters, or equivalently as <code class="literal">YEAR(4)</code> with
            an explicit display width.
        </p><p style="color:blue;">年份类型是一个1字节类型，用于表示年份值。它可以声明为隐式显示宽度为4个字符的年份，也可以等效为显式显示宽度的年份（4）。</p><p></p>
            <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">

                <div class="admon-title">
                    Note
                </div>
                <p>
                    The 2-digit <code class="literal">YEAR(2)</code> data type is deprecated
                    and support for it is removed in MySQL 5.7.5. To convert
                    <code class="literal">YEAR(2)</code> columns to
                    <code class="literal">YEAR(4)</code>, see
                    <a class="xref" href="data-types.html#migrating-from-year2" title="11.3.4&nbsp;2-Digit YEAR(2) Limitations and Migrating to 4-Digit YEAR">Section&nbsp;11.3.4, “2-Digit YEAR(2) Limitations and Migrating to 4-Digit YEAR”</a>.
                </p><p style="color:blue;">不推荐使用2位数的年份（2）数据类型，在mysql 5.7.5中不再支持它。要将年份（2）列转换为年份（4），请参见第11.3.4节，“2位数年份（2）限制和迁移到4位数年份”。</p><p></p>
            </div>
            <p>
                MySQL displays <code class="literal">YEAR</code> values in
                <code class="literal">YYYY</code> format, with a range of
                <code class="literal">1901</code> to <code class="literal">2155</code>, and
                <code class="literal">0000</code>.
            </p><p style="color:blue;">mysql以yyyy格式显示年份值，范围是1901到2155和0000。</p><p></p><p>
            <code class="literal">YEAR</code> accepts input values in a variety of
            formats:
        </p><p style="color:blue;">年份接受多种格式的输入值：</p><p></p>
            <div class="itemizedlist">
                <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                    As 4-digit strings in the range <code class="literal">'1901'</code> to
                    <code class="literal">'2155'</code>.
                </p><p style="color:blue;">作为“1901”到“2155”范围内的4位字符串。</p><p></p></li><li class="listitem"><p>
                    As 4-digit numbers in the range <code class="literal">1901</code> to
                    <code class="literal">2155</code>.
                </p><p style="color:blue;">作为1901到2155范围内的4位数字。</p><p></p></li><li class="listitem"><p>
                    As 1- or 2-digit strings in the range <code class="literal">'0'</code>
                    to <code class="literal">'99'</code>. MySQL converts values in the
                    ranges <code class="literal">'0'</code> to <code class="literal">'69'</code> and
                    <code class="literal">'70'</code> to <code class="literal">'99'</code> to
                    <code class="literal">YEAR</code> values in the ranges
                    <code class="literal">2000</code> to <code class="literal">2069</code> and
                    <code class="literal">1970</code> to <code class="literal">1999</code>.
                </p><p style="color:blue;">作为“0”到“99”范围内的1位或2位字符串。MySQL将范围“0”到“69”和“70”到“99”的值转换为2000到2069和1970到1999之间的年份值。</p><p></p></li><li class="listitem"><p>
                    As 1- or 2-digit numbers in the range <code class="literal">0</code>
                    to <code class="literal">99</code>. MySQL converts values in the
                    ranges <code class="literal">1</code> to <code class="literal">69</code> and
                    <code class="literal">70</code> to <code class="literal">99</code> to
                    <code class="literal">YEAR</code> values in the ranges
                    <code class="literal">2001</code> to <code class="literal">2069</code> and
                    <code class="literal">1970</code> to <code class="literal">1999</code>.
                </p><p style="color:blue;">作为0到99范围内的1位或2位数字。mysql将范围为1到69、70到99的值转换为范围为2001到2069和1970到1999的年份值。</p><p></p><p>
                    The result of inserting a numeric <code class="literal">0</code> has a
                    display value of <code class="literal">0000</code> and an internal
                    value of <code class="literal">0000</code>. To insert zero and have it
                    be interpreted as <code class="literal">2000</code>, specify it as a
                    string <code class="literal">'0'</code> or <code class="literal">'00'</code>.
                </p><p style="color:blue;">插入数字0的结果的显示值为0000，内部值为0000。若要插入零并将其解释为2000，请将其指定为字符串“0”或“00”。</p><p></p></li><li class="listitem"><p>
                    As the result of functions that return a value that is
                    acceptable in a <code class="literal">YEAR</code> context, such as
                    <a class="link" href="functions.html#function_now"><code class="literal">NOW()</code></a>.
                </p><p style="color:blue;">作为返回在年份上下文中可接受的值的函数的结果，例如now（）。</p><p></p></li></ul>
            </div>
            <p>
                If strict SQL mode is not enabled, MySQL converts invalid
                <code class="literal">YEAR</code> values to <code class="literal">0000</code>. In
                strict SQL mode, attempting to insert an invalid
                <code class="literal">YEAR</code> value produces an error.
            </p><p style="color:blue;">如果没有启用严格的sql模式，mysql会将无效的年份值转换为0000。在严格的SQL模式下，尝试插入无效的年份值会产生错误。</p><p></p><p>
            See also <a class="xref" href="data-types.html#two-digit-years" title="11.3.8&nbsp;2-Digit Years in Dates">Section&nbsp;11.3.8, “2-Digit Years in Dates”</a>.
        </p><p style="color:blue;">另见第11.3.8节“日期中的两位数年份”。</p><p></p>
        </div>
        <div class="section">
            <div class="titlepage">
                <div>
                    <div>
                        <h3 class="title"><a name="migrating-from-year2"></a>11.3.4&nbsp;2-Digit YEAR(2) Limitations and Migrating to 4-Digit YEAR</h3>

                    </div>

                </div>

            </div>
            <p>
                This section describes problems that can occur when using the
                2-digit <a class="link" href="data-types.html#year" title="11.3.3&nbsp;The YEAR Type"><code class="literal">YEAR(2)</code></a> data type and
                provides information about converting existing
                <a class="link" href="data-types.html#year" title="11.3.3&nbsp;The YEAR Type"><code class="literal">YEAR(2)</code></a> columns to 4-digit
                <a class="link" href="data-types.html#year" title="11.3.3&nbsp;The YEAR Type"><code class="literal">YEAR</code></a> columns.
            </p><p style="color:blue;">本节描述使用2位数年（2）数据类型时可能出现的问题，并提供有关将现有年（2）列转换为4位数年份列的信息。</p><p></p><p>
            Although the internal range of values for
            <a class="link" href="data-types.html#year" title="11.3.3&nbsp;The YEAR Type"><code class="literal">YEAR(4)</code></a> and the deprecated
            <a class="link" href="data-types.html#year" title="11.3.3&nbsp;The YEAR Type"><code class="literal">YEAR(2)</code></a> type is the same
            (<code class="literal">1901</code> to <code class="literal">2155</code>, and
            <code class="literal">0000</code>), the display width for
            <a class="link" href="data-types.html#year" title="11.3.3&nbsp;The YEAR Type"><code class="literal">YEAR(2)</code></a> makes that type
            inherently ambiguous because displayed values indicate only the
            last two digits of the internal values and omit the century
            digits. The result can be a loss of information under certain
            circumstances. For this reason, avoid using
            <a class="link" href="data-types.html#year" title="11.3.3&nbsp;The YEAR Type"><code class="literal">YEAR(2)</code></a> in your applications and
            use <a class="link" href="data-types.html#year" title="11.3.3&nbsp;The YEAR Type"><code class="literal">YEAR(4)</code></a> wherever you need a
            <a class="link" href="data-types.html#year" title="11.3.3&nbsp;The YEAR Type"><code class="literal">YEAR</code></a> data type. As of MySQL
            5.7.5, support for <a class="link" href="data-types.html#year" title="11.3.3&nbsp;The YEAR Type"><code class="literal">YEAR(2)</code></a> is
            removed and existing <a class="link" href="data-types.html#year" title="11.3.3&nbsp;The YEAR Type"><code class="literal">YEAR(2)</code></a>
            columns must be converted to 4-digit
            <a class="link" href="data-types.html#year" title="11.3.3&nbsp;The YEAR Type"><code class="literal">YEAR</code></a> columns to become usable
            again.
        </p><p style="color:blue;">尽管年份（4）和已弃用的年份（2）类型的值的内部范围相同（1901到2155和0000），但年份（2）的显示宽度使该类型固有地不明确，因为显示的值仅指示内部值的最后两位数字，而忽略了世纪数字。在某些情况下，结果可能是信息丢失。因此，请避免在应用程序中使用年份（2），并在需要年份数据类型的任何地方使用年份（4）。在MySQL 5.7.5中，移除了年份（2）的支持，并且现有的年份（2）列必须转换为4位数的年份列以再次使用。</p><p></p>
            <div class="simplesect">

                <div class="titlepage">
                    <div>

                        <div class="simple">
                            <h4 class="title"><a name="year2-limitations"></a>YEAR(2) Limitations</h4>
                        </div>
                    </div>
                </div>
                <p>
                    Issues with the <a class="link" href="data-types.html#year" title="11.3.3&nbsp;The YEAR Type"><code class="literal">YEAR(2)</code></a> data
                    type include ambiguity of displayed values, and possible loss
                    of information when values are dumped and reloaded or
                    converted to strings.
                </p><p style="color:blue;">年份（2）数据类型的问题包括显示值的模糊性，以及值被转储、重新加载或转换为字符串时可能丢失的信息。</p><p></p>
                <div class="itemizedlist">
                    <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                        Displayed <a class="link" href="data-types.html#year" title="11.3.3&nbsp;The YEAR Type"><code class="literal">YEAR(2)</code></a> values
                        can be ambiguous. It is possible for up to three
                        <a class="link" href="data-types.html#year" title="11.3.3&nbsp;The YEAR Type"><code class="literal">YEAR(2)</code></a> values that have
                        different internal values to have the same displayed
                        value, as the following example demonstrates:
                    </p><p style="color:blue;">显示的年份（2）值可能不明确。以下示例表明，最多三年（2）个具有不同内部值的值可以具有相同的显示值：</p><p></p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>CREATE TABLE t (y2 YEAR(2), y4 YEAR(4));</code></strong>
Query OK, 0 rows affected (0.01 sec)

mysql&gt; <strong class="userinput"><code>INSERT INTO t (y2) VALUES(1912),(2012),(2112);</code></strong>
Query OK, 3 rows affected (0.00 sec)
Records: 3  Duplicates: 0  Warnings: 0

mysql&gt; <strong class="userinput"><code>UPDATE t SET y4 = y2;</code></strong>
Query OK, 3 rows affected (0.00 sec)
Rows matched: 3  Changed: 3  Warnings: 0

mysql&gt; <strong class="userinput"><code>SELECT * FROM t;</code></strong>
+------+------+
| y2   | y4   |
+------+------+
|   12 | 1912 |
|   12 | 2012 |
|   12 | 2112 |
+------+------+
3 rows in set (0.00 sec)
</pre></li><li class="listitem"><p>
                        If you use <a class="link" href="programs.html#mysqldump" title="4.5.4&nbsp;mysqldump — A Database Backup Program"><span class="command"><strong>mysqldump</strong></span></a> to dump the table
                        created in the preceding example, the dump file represents
                        all <code class="literal">y2</code> values using the same 2-digit
                        representation (<code class="literal">12</code>). If you reload the
                        table from the dump file, all resulting rows have internal
                        value <code class="literal">2012</code> and display value
                        <code class="literal">12</code>, thus losing the distinctions
                        between them.
                    </p><p style="color:blue;">如果使用mysqldump转储在前面的示例中创建的表，则转储文件使用相同的2位表示法（12）表示所有y2值。如果从转储文件重新加载表，则生成的所有行都具有内部值2012和显示值12，因此它们之间的区别将消失。</p><p></p></li><li class="listitem"><p>
                        Conversion of a <a class="link" href="data-types.html#year" title="11.3.3&nbsp;The YEAR Type"><code class="literal">YEAR(2)</code></a> or
                        <a class="link" href="data-types.html#year" title="11.3.3&nbsp;The YEAR Type"><code class="literal">YEAR(4)</code></a> data value to
                        string form uses the data type display width. Suppose that
                        <a class="link" href="data-types.html#year" title="11.3.3&nbsp;The YEAR Type"><code class="literal">YEAR(2)</code></a> and
                        <a class="link" href="data-types.html#year" title="11.3.3&nbsp;The YEAR Type"><code class="literal">YEAR(4)</code></a> columns both
                        contain the value <code class="literal">1970</code>. Assigning each
                        column to a string results in a value of
                        <code class="literal">'70'</code> or <code class="literal">'1970'</code>,
                        respectively. That is, loss of information occurs for
                        conversion from <a class="link" href="data-types.html#year" title="11.3.3&nbsp;The YEAR Type"><code class="literal">YEAR(2)</code></a> to
                        string.
                    </p><p style="color:blue;">将年份（2）或年份（4）数据值转换为字符串形式使用数据类型显示宽度。假设年份（2）和年份（4）列都包含值1970。将每一列赋给一个字符串，结果分别为“70”或“1970”。也就是说，将年份（2）转换为字符串时会丢失信息。</p><p></p></li><li class="listitem"><p>
                        Values outside the range from <code class="literal">1970</code> to
                        <code class="literal">2069</code> are stored incorrectly when
                        inserted into a <a class="link" href="data-types.html#year" title="11.3.3&nbsp;The YEAR Type"><code class="literal">YEAR(2)</code></a>
                        column in a <a class="link" href="storage-engines.html#csv-storage-engine" title="15.4&nbsp;The CSV Storage Engine"><code class="literal">CSV</code></a> table. For
                        example, inserting <code class="literal">2211</code> results in a
                        display value of <code class="literal">11</code> but an internal
                        value of <code class="literal">2011</code>.
                    </p><p style="color:blue;">当插入CSV表中的年份（2）列时，1970到2069之间的值存储不正确。例如，插入2211将导致显示值为11，但内部值为2011。</p><p></p></li></ul>
                </div>
                <p>
                    To avoid these problems, use
                    <a class="link" href="data-types.html#year" title="11.3.3&nbsp;The YEAR Type"><code class="literal">YEAR(4)</code></a> rather than
                    <a class="link" href="data-types.html#year" title="11.3.3&nbsp;The YEAR Type"><code class="literal">YEAR(2)</code></a>. Suggestions regarding
                    migration strategies appear later in this section.
                </p><p style="color:blue;">要避免这些问题，请使用年份（4）而不是年份（2）。有关迁移策略的建议将在本节后面部分介绍。</p><p></p>
            </div>
            <div class="simplesect">
                <div class="titlepage">
                    <div>
                        <div class="simple">
                            <h4 class="title"><a name="limited-y2-support"></a>Reduced/Removed YEAR(2) Support in MySQL 5.7</h4>

                        </div>

                    </div>

                </div>
                <p>
                    Before MySQL 5.7.5, support for
                    <a class="link" href="data-types.html#year" title="11.3.3&nbsp;The YEAR Type"><code class="literal">YEAR(2)</code></a> is diminished. As of
                    MySQL 5.7.5, support for
                    <a class="link" href="data-types.html#year" title="11.3.3&nbsp;The YEAR Type"><code class="literal">YEAR(2)</code></a> is removed.
                </p><p style="color:blue;">在mysql 5.7.5之前，对第（2）年的支持减少了。从mysql 5.7.5开始，删除了对第（2）年的支持。</p><p></p>
                <div class="itemizedlist">
                    <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                        <a class="link" href="data-types.html#year" title="11.3.3&nbsp;The YEAR Type"><code class="literal">YEAR(2)</code></a> column definitions
                        for new tables produce warnings or errors:
                    </p><p style="color:blue;">年份（2）新表的列定义产生警告或错误：</p><p></p>
                        <div class="itemizedlist">
                            <ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
                                Before MySQL 5.7.5,
                                <a class="link" href="data-types.html#year" title="11.3.3&nbsp;The YEAR Type"><code class="literal">YEAR(2)</code></a> column
                                definitions for new tables are converted (with an
                                <a class="link" href="error-handling.html#error_er_invalid_year_column_length"><code class="literal">ER_INVALID_YEAR_COLUMN_LENGTH</code></a>
                                warning) to <a class="link" href="data-types.html#year" title="11.3.3&nbsp;The YEAR Type"><code class="literal">YEAR(4)</code></a>:
                            </p><p style="color:blue;">在mysql 5.7.5之前，新表的year（2）列定义被转换为year（4）：</p><p></p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>CREATE TABLE t1 (y YEAR(2));</code></strong>
Query OK, 0 rows affected, 1 warning (0.04 sec)

mysql&gt; <strong class="userinput"><code>SHOW WARNINGS\G</code></strong>
*************************** 1. row ***************************
  Level: Warning
   Code: 1818
Message: YEAR(2) column type is deprecated. Creating YEAR(4) column instead.
1 row in set (0.00 sec)

mysql&gt; <strong class="userinput"><code>SHOW CREATE TABLE t1\G</code></strong>
*************************** 1. row ***************************
       Table: t1
Create Table: CREATE TABLE `t1` (
  `y` year(4) DEFAULT NULL
) ENGINE=InnoDB DEFAULT CHARSET=latin1
1 row in set (0.00 sec)
</pre></li><li class="listitem"><p>
                                As of MySQL 5.7.5,
                                <a class="link" href="data-types.html#year" title="11.3.3&nbsp;The YEAR Type"><code class="literal">YEAR(2)</code></a> column
                                definitions for new tables produce an
                                <a class="link" href="error-handling.html#error_er_invalid_year_column_length"><code class="literal">ER_INVALID_YEAR_COLUMN_LENGTH</code></a>
                                error:
                            </p><p style="color:blue;">从mysql 5.7.5开始，新表的year（2）列定义产生er_invalid_year_column_length错误：</p><p></p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>CREATE TABLE t1 (y YEAR(2));</code></strong>
ERROR 1818 (HY000): Supports only YEAR or YEAR(4) column.
</pre></li></ul>
                        </div>
                    </li><li class="listitem"><p>
                        <a class="link" href="data-types.html#year" title="11.3.3&nbsp;The YEAR Type"><code class="literal">YEAR(2)</code></a> column in existing
                        tables remain as <a class="link" href="data-types.html#year" title="11.3.3&nbsp;The YEAR Type"><code class="literal">YEAR(2)</code></a>:
                    </p><p style="color:blue;">现有表中的年份（2）列为年度（2）：</p><p></p>
                        <div class="itemizedlist">
                            <ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
                                Before MySQL 5.7.5,
                                <a class="link" href="data-types.html#year" title="11.3.3&nbsp;The YEAR Type"><code class="literal">YEAR(2)</code></a> is processed in
                                queries as in older versions of MySQL.
                            </p><p style="color:blue;">在mysql 5.7.5之前，在查询中处理年份（2）与在旧版本的mysql中一样。</p><p></p></li><li class="listitem"><p>
                                As of MySQL 5.7.5,
                                <a class="link" href="data-types.html#year" title="11.3.3&nbsp;The YEAR Type"><code class="literal">YEAR(2)</code></a> columns in
                                queries produce warnings or errors.
                            </p><p style="color:blue;">从mysql 5.7.5开始，查询中的year（2）列会产生警告或错误。</p><p></p></li></ul>
                        </div>
                    </li><li class="listitem"><p>
                        Several programs or statements convert
                        <a class="link" href="data-types.html#year" title="11.3.3&nbsp;The YEAR Type"><code class="literal">YEAR(2)</code></a> to
                        <a class="link" href="data-types.html#year" title="11.3.3&nbsp;The YEAR Type"><code class="literal">YEAR(4)</code></a> automatically:
                    </p><p style="color:blue;">有几个程序或报表自动将年份（2）转换为年份（4）：</p><p></p>
                        <div class="itemizedlist">
                            <ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
                                <a class="link" href="sql-syntax.html#alter-table" title="13.1.8&nbsp;ALTER TABLE Syntax"><code class="literal">ALTER TABLE</code></a> statements
                                that result in a table rebuild.
                            </p><p style="color:blue;">更改导致表重建的表语句。</p><p></p></li><li class="listitem"><p>
                                <a class="link" href="sql-syntax.html#repair-table" title="13.7.2.5&nbsp;REPAIR TABLE Syntax"><code class="literal">REPAIR TABLE</code></a> (which
                                <a class="link" href="sql-syntax.html#check-table" title="13.7.2.2&nbsp;CHECK TABLE Syntax"><code class="literal">CHECK TABLE</code></a> recommends
                                you use, if it finds a table that contains
                                <a class="link" href="data-types.html#year" title="11.3.3&nbsp;The YEAR Type"><code class="literal">YEAR(2)</code></a> columns).
                            </p><p style="color:blue;">修复表（如果发现包含年份（2）列的表，则建议使用该检查表）。</p><p></p></li><li class="listitem"><p>
                                <a class="link" href="programs.html#mysql-upgrade" title="4.4.7&nbsp;mysql_upgrade — Check and Upgrade MySQL Tables"><span class="command"><strong>mysql_upgrade</strong></span></a> (which uses
                                <a class="link" href="sql-syntax.html#repair-table" title="13.7.2.5&nbsp;REPAIR TABLE Syntax"><code class="literal">REPAIR TABLE</code></a>).
                            </p><p style="color:blue;">mysql_升级（使用修复表）。</p><p></p></li><li class="listitem"><p>
                                Dumping with <a class="link" href="programs.html#mysqldump" title="4.5.4&nbsp;mysqldump — A Database Backup Program"><span class="command"><strong>mysqldump</strong></span></a> and
                                reloading the dump file. Unlike the conversions
                                performed by the preceding three items, a dump and
                                reload has the potential to change data values.
                            </p><p style="color:blue;">使用mysqldump转储并重新加载转储文件。与前三项执行的转换不同，转储和重新加载有可能更改数据值。</p><p></p></li></ul>
                        </div>
                        <p>
                            A MySQL upgrade usually involves at least one of the last
                            two items. However, with respect to
                            <a class="link" href="data-types.html#year" title="11.3.3&nbsp;The YEAR Type"><code class="literal">YEAR(2)</code></a>,
                            <a class="link" href="programs.html#mysql-upgrade" title="4.4.7&nbsp;mysql_upgrade — Check and Upgrade MySQL Tables"><span class="command"><strong>mysql_upgrade</strong></span></a> is preferable to
                            <a class="link" href="programs.html#mysqldump" title="4.5.4&nbsp;mysqldump — A Database Backup Program"><span class="command"><strong>mysqldump</strong></span></a>, which, as noted, can change
                            data values.
                        </p><p style="color:blue;">mysql升级通常至少涉及最后两项中的一项。但是，对于第（2）年，mysql_升级比mysqldump更可取，如前所述，mysqldump可以更改数据值。</p><p></p></li></ul>
                </div>

            </div>
            <div class="simplesect">
                <div class="titlepage">
                    <div>
                        <div class="simple">
                            <h4 class="title"><a name="migrating-from-y2-to-y4"></a>Migrating from YEAR(2) to YEAR(4)</h4>

                        </div>

                    </div>

                </div>
                <p>
                    To convert <a class="link" href="data-types.html#year" title="11.3.3&nbsp;The YEAR Type"><code class="literal">YEAR(2)</code></a> columns to
                    <a class="link" href="data-types.html#year" title="11.3.3&nbsp;The YEAR Type"><code class="literal">YEAR(4)</code></a>, you can do so manually
                    at any time without upgrading. Alternatively, you can upgrade
                    to a version of MySQL with reduced or removed support for
                    <a class="link" href="data-types.html#year" title="11.3.3&nbsp;The YEAR Type"><code class="literal">YEAR(2)</code></a> (MySQL 5.6.6 or later),
                    then have MySQL convert <a class="link" href="data-types.html#year" title="11.3.3&nbsp;The YEAR Type"><code class="literal">YEAR(2)</code></a>
                    columns automatically. In the latter case, avoid upgrading by
                    dumping and reloading your data because that can change data
                    values. In addition, if you use replication, there are upgrade
                    considerations you must take into account.
                </p><p style="color:blue;">若要将年份（2）列转换为年份（4），可以随时手动执行此操作，而无需升级。或者，您可以升级到mysql版本，减少或删除对year（2）的支持（mysql 5.6.6或更高版本），然后让mysql自动转换year（2）列。在后一种情况下，请避免通过转储和重新加载数据进行升级，因为这可能会更改数据值。此外，如果使用复制，则必须考虑升级注意事项。</p><p></p><p>
                To convert <a class="link" href="data-types.html#year" title="11.3.3&nbsp;The YEAR Type"><code class="literal">YEAR(2)</code></a> columns to
                <a class="link" href="data-types.html#year" title="11.3.3&nbsp;The YEAR Type"><code class="literal">YEAR(4)</code></a> manually, use
                <a class="link" href="sql-syntax.html#alter-table" title="13.1.8&nbsp;ALTER TABLE Syntax"><code class="literal">ALTER TABLE</code></a> or
                <a class="link" href="sql-syntax.html#repair-table" title="13.7.2.5&nbsp;REPAIR TABLE Syntax"><code class="literal">REPAIR TABLE</code></a>. Suppose that a
                table <code class="literal">t1</code> has this definition:
            </p><p style="color:blue;">要手动将年份（2）列转换为年份（4），请使用alter table或repair table。假设表T1具有以下定义：</p><p></p><pre data-lang="sql" class="programlisting">CREATE TABLE t1 (ycol YEAR(2) NOT NULL DEFAULT '70');
</pre><p>
                Modify the column using <code class="literal">ALTER TABLE</code> as
                follows:
            </p><p style="color:blue;">使用alter table修改列，如下所示：</p><p></p><pre data-lang="sql" class="programlisting">ALTER TABLE t1 FORCE;
</pre><p>
                The <a class="link" href="sql-syntax.html#alter-table" title="13.1.8&nbsp;ALTER TABLE Syntax"><code class="literal">ALTER TABLE</code></a> statement
                converts the table without changing
                <a class="link" href="data-types.html#year" title="11.3.3&nbsp;The YEAR Type"><code class="literal">YEAR(2)</code></a> values. If the server
                is a replication master, the <a class="link" href="sql-syntax.html#alter-table" title="13.1.8&nbsp;ALTER TABLE Syntax"><code class="literal">ALTER
                TABLE</code></a> statement replicates to slaves and makes the
                corresponding table change on each one.
            </p><p style="color:blue;">alter table语句在不更改year（2）值的情况下转换表。如果服务器是复制主服务器，alter table语句将复制到从服务器，并在每个从服务器上更改相应的表。</p><p></p><p>
                Another migration method is to perform a binary upgrade:
                Upgrade MySQL in place without dumping and reloading your
                data. Then run <a class="link" href="programs.html#mysql-upgrade" title="4.4.7&nbsp;mysql_upgrade — Check and Upgrade MySQL Tables"><span class="command"><strong>mysql_upgrade</strong></span></a>, which uses
                <a class="link" href="sql-syntax.html#repair-table" title="13.7.2.5&nbsp;REPAIR TABLE Syntax"><code class="literal">REPAIR TABLE</code></a> to convert
                <a class="link" href="data-types.html#year" title="11.3.3&nbsp;The YEAR Type"><code class="literal">YEAR(2)</code></a> columns to
                <a class="link" href="data-types.html#year" title="11.3.3&nbsp;The YEAR Type"><code class="literal">YEAR(4)</code></a> without changing data
                values. If the server is a replication master, the
                <a class="link" href="sql-syntax.html#repair-table" title="13.7.2.5&nbsp;REPAIR TABLE Syntax"><code class="literal">REPAIR TABLE</code></a> statements
                replicate to slaves and make the corresponding table changes
                on each one, unless you invoke
                <a class="link" href="programs.html#mysql-upgrade" title="4.4.7&nbsp;mysql_upgrade — Check and Upgrade MySQL Tables"><span class="command"><strong>mysql_upgrade</strong></span></a> with the
                <a class="link" href="programs.html#option_mysql_upgrade_write-binlog"><code class="option">--skip-write-binlog</code></a>
                option.
            </p><p style="color:blue;">另一种迁移方法是执行二进制升级：在不转储和重新加载数据的情况下就地升级mysql。然后运行mysql_upgrade，它使用repair表将year（2）列转换为year（4），而不更改数据值。如果服务器是复制主服务器，则repair table语句将复制到从服务器，并对每个从服务器进行相应的表更改，除非使用--skip write binlog选项调用mysql_upgrade。</p><p></p><p>
                Upgrades to replication servers usually involve upgrading
                slaves to a newer version of MySQL, then upgrading the master.
                For example, if a master and slave both run MySQL 5.5, a
                typical upgrade sequence involves upgrading the slave to 5.6,
                then upgrading the master to 5.6. With regard to the different
                treatment of <a class="link" href="data-types.html#year" title="11.3.3&nbsp;The YEAR Type"><code class="literal">YEAR(2)</code></a> as of
                MySQL 5.6.6, that upgrade sequence results in a problem:
                Suppose that the slave has been upgraded but not yet the
                master. Then creating a table containing a
                <a class="link" href="data-types.html#year" title="11.3.3&nbsp;The YEAR Type"><code class="literal">YEAR(2)</code></a> column on the master
                results in a table containing a
                <a class="link" href="data-types.html#year" title="11.3.3&nbsp;The YEAR Type"><code class="literal">YEAR(4)</code></a> column on the slave.
                Consequently, the following operations have a different result
                on the master and slave, if you use statement-based
                replication:
            </p><p style="color:blue;">对复制服务器的升级通常包括将从属服务器升级到较新版本的mysql，然后升级主服务器。例如，如果主服务器和从服务器都运行mysql 5.5，典型的升级顺序是将从服务器升级到5.6，然后将主服务器升级到5.6。对于从mysql 5.6.6开始的第（2）年的不同处理，该升级序列导致了一个问题：假设从服务器已经升级，但主服务器还没有。然后在主表上创建一个包含year（2）列的表，在从表上创建一个包含year（4）列的表。因此，如果使用基于语句的复制，则以下操作在主服务器和从服务器上的结果不同：</p><p></p>
                <div class="itemizedlist">
                    <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                        Inserting numeric <code class="literal">0</code>. The resulting
                        value has an internal value of <code class="literal">2000</code> on
                        the master but <code class="literal">0000</code> on the slave.
                    </p><p style="color:blue;">正在插入数字0。结果值在主节点上的内部值为2000，而在从节点上的内部值为0000。</p><p></p></li><li class="listitem"><p>
                        Converting <a class="link" href="data-types.html#year" title="11.3.3&nbsp;The YEAR Type"><code class="literal">YEAR(2)</code></a> to
                        string. This operation uses the display value of
                        <a class="link" href="data-types.html#year" title="11.3.3&nbsp;The YEAR Type"><code class="literal">YEAR(2)</code></a> on the master but
                        <a class="link" href="data-types.html#year" title="11.3.3&nbsp;The YEAR Type"><code class="literal">YEAR(4)</code></a> on the slave.
                    </p><p style="color:blue;">将年份（2）转换为字符串。此操作使用主设备上年份（2）的显示值，而从设备上年份（4）的显示值。</p><p></p></li></ul>
                </div>
                <p>
                    To avoid such problems, modify all
                    <a class="link" href="data-types.html#year" title="11.3.3&nbsp;The YEAR Type"><code class="literal">YEAR(2)</code></a> columns on the master
                    to <a class="link" href="data-types.html#year" title="11.3.3&nbsp;The YEAR Type"><code class="literal">YEAR(4)</code></a> before upgrading.
                    (Use <a class="link" href="sql-syntax.html#alter-table" title="13.1.8&nbsp;ALTER TABLE Syntax"><code class="literal">ALTER TABLE</code></a>, as described
                    previously.) That makes it possible to upgrade normally (slave
                    first, then master) without introducing any
                    <a class="link" href="data-types.html#year" title="11.3.3&nbsp;The YEAR Type"><code class="literal">YEAR(2)</code></a> to
                    <a class="link" href="data-types.html#year" title="11.3.3&nbsp;The YEAR Type"><code class="literal">YEAR(4)</code></a> differences between the
                    master and slave.
                </p><p style="color:blue;">若要避免此类问题，请在升级前将主控形状上的所有年份（2）列修改为年份（4）。（如前所述，使用alter table。）这样就可以正常升级（先从服务器，然后主服务器），而不需要在主服务器和从服务器之间引入任何年份（2）到年份（4）的差异。</p><p></p><p>
                One migration method should be avoided: Do not dump your data
                with <a class="link" href="programs.html#mysqldump" title="4.5.4&nbsp;mysqldump — A Database Backup Program"><span class="command"><strong>mysqldump</strong></span></a> and reload the dump file
                after upgrading. That has the potential to change
                <a class="link" href="data-types.html#year" title="11.3.3&nbsp;The YEAR Type"><code class="literal">YEAR(2)</code></a> values, as described
                previously.
            </p><p style="color:blue;">应该避免一种迁移方法：不要使用mysqldump转储数据，并在升级后重新加载转储文件。如前所述，这有可能改变第（2）年的值。</p><p></p><p>
                A migration from <a class="link" href="data-types.html#year" title="11.3.3&nbsp;The YEAR Type"><code class="literal">YEAR(2)</code></a> to
                <a class="link" href="data-types.html#year" title="11.3.3&nbsp;The YEAR Type"><code class="literal">YEAR(4)</code></a> should also involve
                examining application code for the possibility of changed
                behavior under conditions such as these:
            </p><p style="color:blue;">从第（2）年迁移到第（4）年还应包括检查应用程序代码，以确定在以下条件下更改行为的可能性：</p><p></p>
                <div class="itemizedlist">
                    <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                        Code that expects selecting a
                        <a class="link" href="data-types.html#year" title="11.3.3&nbsp;The YEAR Type"><code class="literal">YEAR</code></a> column to produce
                        exactly two digits.
                    </p><p style="color:blue;">希望选择年份列产生正好两位数的代码。</p><p></p></li><li class="listitem"><p>
                        Code that does not account for different handling for
                        inserts of numeric <code class="literal">0</code>: Inserting
                        <code class="literal">0</code> into
                        <a class="link" href="data-types.html#year" title="11.3.3&nbsp;The YEAR Type"><code class="literal">YEAR(2)</code></a> or
                        <a class="link" href="data-types.html#year" title="11.3.3&nbsp;The YEAR Type"><code class="literal">YEAR(4)</code></a> results in an
                        internal value of <code class="literal">2000</code> or
                        <code class="literal">0000</code>, respectively.
                    </p><p style="color:blue;">不考虑对数字0的插入的不同处理的代码：将0插入到年份（2）或年份（4）中会分别产生2000或0000的内部值。</p><p></p></li></ul>
                </div>

            </div>

        </div>
        <div class="section">
            <div class="titlepage">
                <div>
                    <div>
                        <h3 class="title"><a name="timestamp-initialization"></a>11.3.5&nbsp;Automatic Initialization and Updating for TIMESTAMP and DATETIME</h3>

                    </div>

                </div>

            </div>
            <a class="indexterm" name="idm140286860548800"></a><p>
            <a class="link" href="data-types.html#datetime" title="11.3.1&nbsp;The DATE, DATETIME, and TIMESTAMP Types"><code class="literal">TIMESTAMP</code></a> and
            <a class="link" href="data-types.html#datetime" title="11.3.1&nbsp;The DATE, DATETIME, and TIMESTAMP Types"><code class="literal">DATETIME</code></a> columns can be
            automatically initializated and updated to the current date and
            time (that is, the current timestamp).
        </p><p style="color:blue;">timestamp和date time列可以自动初始化并更新为当前日期和时间（即当前时间戳）。</p><p></p><p>
            For any <a class="link" href="data-types.html#datetime" title="11.3.1&nbsp;The DATE, DATETIME, and TIMESTAMP Types"><code class="literal">TIMESTAMP</code></a> or
            <a class="link" href="data-types.html#datetime" title="11.3.1&nbsp;The DATE, DATETIME, and TIMESTAMP Types"><code class="literal">DATETIME</code></a> column in a table, you
            can assign the current timestamp as the default value, the
            auto-update value, or both:
        </p><p style="color:blue;">对于表中的任何时间戳或日期时间列，可以将当前时间戳指定为默认值或自动更新值，或同时指定这两个值：</p><p></p>
            <div class="itemizedlist">
                <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                    An auto-initialized column is set to the current timestamp
                    for inserted rows that specify no value for the column.
                </p><p style="color:blue;">对于没有为列指定值的插入行，将自动初始化列设置为当前时间戳。</p><p></p></li><li class="listitem"><p>
                    An auto-updated column is automatically updated to the
                    current timestamp when the value of any other column in the
                    row is changed from its current value. An auto-updated
                    column remains unchanged if all other columns are set to
                    their current values. To prevent an auto-updated column from
                    updating when other columns change, explicitly set it to its
                    current value. To update an auto-updated column even when
                    other columns do not change, explicitly set it to the value
                    it should have (for example, set it to
                    <a class="link" href="functions.html#function_current-timestamp"><code class="literal">CURRENT_TIMESTAMP</code></a>).
                </p><p style="color:blue;">当行中任何其他列的值从其当前值更改时，自动更新列将自动更新为当前时间戳。如果所有其他列都设置为其当前值，则自动更新的列将保持不变。若要防止在其他列更改时自动更新列，请将其显式设置为当前值。要更新自动更新列（即使其他列没有更改），请显式将其设置为应有的值（例如，将其设置为当前时间戳）。</p><p></p></li></ul>
            </div>
            <p>
                In addition, if the
                <a class="link" href="server-administration.html#sysvar_explicit_defaults_for_timestamp"><code class="literal">explicit_defaults_for_timestamp</code></a>
                system variable is disabled, you can initialize or update any
                <a class="link" href="data-types.html#datetime" title="11.3.1&nbsp;The DATE, DATETIME, and TIMESTAMP Types"><code class="literal">TIMESTAMP</code></a> (but not
                <code class="literal">DATETIME</code>) column to the current date and time
                by assigning it a <code class="literal">NULL</code> value, unless it has
                been defined with the <code class="literal">NULL</code> attribute to
                permit <code class="literal">NULL</code> values.
            </p><p style="color:blue;">此外，如果已禁用EXPLICIT U defaults_for_timestamp系统变量，则可以通过为任何timestamp（但不是date time）列分配空值，将其初始化或更新为当前日期和时间，除非已使用NULL属性定义该列以允许空值。</p><p></p><p>
            To specify automatic properties, use the <code class="literal">DEFAULT
            CURRENT_TIMESTAMP</code> and <code class="literal">ON UPDATE
            CURRENT_TIMESTAMP</code> clauses in column definitions. The
            order of the clauses does not matter. If both are present in a
            column definition, either can occur first. Any of the synonyms
            for <a class="link" href="functions.html#function_current-timestamp"><code class="literal">CURRENT_TIMESTAMP</code></a> have the
            same meaning as
            <a class="link" href="functions.html#function_current-timestamp"><code class="literal">CURRENT_TIMESTAMP</code></a>. These are
            <a class="link" href="functions.html#function_current-timestamp"><code class="literal">CURRENT_TIMESTAMP()</code></a>,
            <a class="link" href="functions.html#function_now"><code class="literal">NOW()</code></a>,
            <a class="link" href="functions.html#function_localtime"><code class="literal">LOCALTIME</code></a>,
            <a class="link" href="functions.html#function_localtime"><code class="literal">LOCALTIME()</code></a>,
            <a class="link" href="functions.html#function_localtimestamp"><code class="literal">LOCALTIMESTAMP</code></a>, and
            <a class="link" href="functions.html#function_localtimestamp"><code class="literal">LOCALTIMESTAMP()</code></a>.
        </p><p style="color:blue;">要指定自动属性，请在列定义中使用默认的current_timestamp和on update current_timestamp子句。条款的顺序无关紧要。如果列定义中同时存在这两种情况，则可以先出现其中之一。当前时间戳的任何同义词都具有与当前时间戳相同的含义。它们是current_timestamp（）、now（）、localtime、localtime（）、localtimestamp和localtimestamp（）。</p><p></p><p>
            Use of <code class="literal">DEFAULT CURRENT_TIMESTAMP</code> and
            <code class="literal">ON UPDATE CURRENT_TIMESTAMP</code> is specific to
            <a class="link" href="data-types.html#datetime" title="11.3.1&nbsp;The DATE, DATETIME, and TIMESTAMP Types"><code class="literal">TIMESTAMP</code></a> and
            <a class="link" href="data-types.html#datetime" title="11.3.1&nbsp;The DATE, DATETIME, and TIMESTAMP Types"><code class="literal">DATETIME</code></a>. The
            <code class="literal">DEFAULT</code> clause also can be used to specify a
            constant (nonautomatic) default value (for example,
            <code class="literal">DEFAULT 0</code> or <code class="literal">DEFAULT '2000-01-01
            00:00:00'</code>).
        </p><p style="color:blue;">默认current_timestamp和on update current_timestamp的使用特定于timestamp和datetime。default子句还可用于指定常量（非自动）默认值（例如，默认值0或默认值“2000-01-01 00:00:00”）。</p><p></p>
            <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">

                <div class="admon-title">
                    Note
                </div>
                <p>
                    The following examples use <code class="literal">DEFAULT 0</code>, a
                    default that can produce warnings or errors depending on
                    whether strict SQL mode or the
                    <a class="link" href="server-administration.html#sqlmode_no_zero_date"><code class="literal">NO_ZERO_DATE</code></a> SQL mode is
                    enabled. Be aware that the
                    <a class="link" href="server-administration.html#sqlmode_traditional"><code class="literal">TRADITIONAL</code></a> SQL mode
                    includes strict mode and
                    <a class="link" href="server-administration.html#sqlmode_no_zero_date"><code class="literal">NO_ZERO_DATE</code></a>. See
                    <a class="xref" href="server-administration.html#sql-mode" title="5.1.10&nbsp;Server SQL Modes">Section&nbsp;5.1.10, “Server SQL Modes”</a>.
                </p><p style="color:blue;">下面的示例使用默认值0，默认值可以产生警告或错误，具体取决于是否启用了严格SQL模式或无零日期SQL模式。请注意，传统的sql模式包括strict模式和no_zero_date。参见第5.1.10节“服务器SQL模式”。</p><p></p>
            </div>
            <p>
                <a class="link" href="data-types.html#datetime" title="11.3.1&nbsp;The DATE, DATETIME, and TIMESTAMP Types"><code class="literal">TIMESTAMP</code></a> or
                <a class="link" href="data-types.html#datetime" title="11.3.1&nbsp;The DATE, DATETIME, and TIMESTAMP Types"><code class="literal">DATETIME</code></a> column definitions can
                specify the current timestamp for both the default and
                auto-update values, for one but not the other, or for neither.
                Different columns can have different combinations of automatic
                properties. The following rules describe the possibilities:
            </p><p style="color:blue;">timestamp或datetime列定义可以为默认值和自动更新值指定当前时间戳，也可以为一个值指定当前时间戳，但不能为另一个值指定当前时间戳，也可以为两个值都指定当前时间戳。不同的列可以有不同的自动属性组合。以下规则描述了这些可能性：</p><p></p>
            <div class="itemizedlist">
                <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                    With both <code class="literal">DEFAULT CURRENT_TIMESTAMP</code> and
                    <code class="literal">ON UPDATE CURRENT_TIMESTAMP</code>, the column
                    has the current timestamp for its default value and is
                    automatically updated to the current timestamp.
                </p><p style="color:blue;">对于默认的current_timestamp和update current_timestamp，列的默认值都是current timestamp，并自动更新为current timestamp。</p><p></p><pre data-lang="sql" class="programlisting">CREATE TABLE t1 (
  ts TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
  dt DATETIME DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
);
</pre></li><li class="listitem"><p>
                    With a <code class="literal">DEFAULT</code> clause but no <code class="literal">ON
                    UPDATE CURRENT_TIMESTAMP</code> clause, the column has
                    the given default value and is not automatically updated to
                    the current timestamp.
                </p><p style="color:blue;">如果有default子句，但没有on update current_timestamp子句，则该列具有给定的默认值，并且不会自动更新为当前时间戳。</p><p></p><p>
                    The default depends on whether the
                    <code class="literal">DEFAULT</code> clause specifies
                    <code class="literal">CURRENT_TIMESTAMP</code> or a constant value.
                    With <code class="literal">CURRENT_TIMESTAMP</code>, the default is
                    the current timestamp.
                </p><p style="color:blue;">默认值取决于default子句指定的是当前时间戳还是常量值。对于当前时间戳，默认值是当前时间戳。</p><p></p><pre data-lang="sql" class="programlisting">CREATE TABLE t1 (
  ts TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  dt DATETIME DEFAULT CURRENT_TIMESTAMP
);
</pre><p>
                    With a constant, the default is the given value. In this
                    case, the column has no automatic properties at all.
                </p><p style="color:blue;">对于常量，默认值为给定值。在这种情况下，列根本没有自动属性。</p><p></p><pre data-lang="sql" class="programlisting">CREATE TABLE t1 (
  ts TIMESTAMP DEFAULT 0,
  dt DATETIME DEFAULT 0
);
</pre></li><li class="listitem"><p>
                    With an <code class="literal">ON UPDATE CURRENT_TIMESTAMP</code>
                    clause and a constant <code class="literal">DEFAULT</code> clause, the
                    column is automatically updated to the current timestamp and
                    has the given constant default value.
                </p><p style="color:blue;">使用on update current_timestamp子句和constant default子句，该列将自动更新为当前时间戳并具有给定的常量默认值。</p><p></p><pre data-lang="sql" class="programlisting">CREATE TABLE t1 (
  ts TIMESTAMP DEFAULT 0 ON UPDATE CURRENT_TIMESTAMP,
  dt DATETIME DEFAULT 0 ON UPDATE CURRENT_TIMESTAMP
);
</pre></li><li class="listitem"><p>
                    With an <code class="literal">ON UPDATE CURRENT_TIMESTAMP</code>
                    clause but no <code class="literal">DEFAULT</code> clause, the column
                    is automatically updated to the current timestamp but does
                    not have the current timestamp for its default value.
                </p><p style="color:blue;">如果有on update current_timestamp子句但没有default子句，则该列将自动更新为当前时间戳，但其默认值没有当前时间戳。</p><p></p><p>
                    The default in this case is type dependent.
                    <a class="link" href="data-types.html#datetime" title="11.3.1&nbsp;The DATE, DATETIME, and TIMESTAMP Types"><code class="literal">TIMESTAMP</code></a> has a default of 0
                    unless defined with the <code class="literal">NULL</code> attribute,
                    in which case the default is <code class="literal">NULL</code>.
                </p><p style="color:blue;">在这种情况下，默认值是依赖于类型的。除非使用null属性定义，否则timestamp的默认值为0，在这种情况下，默认值为null。</p><p></p><pre data-lang="sql" class="programlisting">CREATE TABLE t1 (
  ts1 TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,     -- default 0
  ts2 TIMESTAMP NULL ON UPDATE CURRENT_TIMESTAMP -- default NULL
);
</pre><p>
                    <a class="link" href="data-types.html#datetime" title="11.3.1&nbsp;The DATE, DATETIME, and TIMESTAMP Types"><code class="literal">DATETIME</code></a> has a default of
                    <code class="literal">NULL</code> unless defined with the <code class="literal">NOT
                    NULL</code> attribute, in which case the default is 0.
                </p><p style="color:blue;">除非使用not null属性定义，否则datetime的默认值为null，在这种情况下，默认值为0。</p><p></p><pre data-lang="sql" class="programlisting">CREATE TABLE t1 (
  dt1 DATETIME ON UPDATE CURRENT_TIMESTAMP,         -- default NULL
  dt2 DATETIME NOT NULL ON UPDATE CURRENT_TIMESTAMP -- default 0
);
</pre></li></ul>
            </div>
            <p>
                <a class="link" href="data-types.html#datetime" title="11.3.1&nbsp;The DATE, DATETIME, and TIMESTAMP Types"><code class="literal">TIMESTAMP</code></a> and
                <a class="link" href="data-types.html#datetime" title="11.3.1&nbsp;The DATE, DATETIME, and TIMESTAMP Types"><code class="literal">DATETIME</code></a> columns have no
                automatic properties unless they are specified explicitly, with
                this exception: If the
                <a class="link" href="server-administration.html#sysvar_explicit_defaults_for_timestamp"><code class="literal">explicit_defaults_for_timestamp</code></a>
                system variable is disabled, the <span class="emphasis"><em>first</em></span>
                <a class="link" href="data-types.html#datetime" title="11.3.1&nbsp;The DATE, DATETIME, and TIMESTAMP Types"><code class="literal">TIMESTAMP</code></a> column has both
                <code class="literal">DEFAULT CURRENT_TIMESTAMP</code> and <code class="literal">ON
                UPDATE CURRENT_TIMESTAMP</code> if neither is specified
                explicitly. To suppress automatic properties for the first
                <a class="link" href="data-types.html#datetime" title="11.3.1&nbsp;The DATE, DATETIME, and TIMESTAMP Types"><code class="literal">TIMESTAMP</code></a> column, use one of
                these strategies:
            </p><p style="color:blue;">除非显式指定，否则timestamp和datetime列没有自动属性，但有一个例外：如果禁用explicit_defaults_for_timestamp系统变量，则第一个timestamp列同时具有默认的current_timestamp和update current_timestamp（如果两者都未显式指定）。要抑制第一个时间戳列的自动属性，请使用以下策略之一：</p><p></p>
            <div class="itemizedlist">
                <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                    Enable the
                    <a class="link" href="server-administration.html#sysvar_explicit_defaults_for_timestamp"><code class="literal">explicit_defaults_for_timestamp</code></a>
                    system variable. In this case, the <code class="literal">DEFAULT
                    CURRENT_TIMESTAMP</code> and <code class="literal">ON UPDATE
                    CURRENT_TIMESTAMP</code> clauses that specify automatic
                    initialization and updating are available, but are not
                    assigned to any <a class="link" href="data-types.html#datetime" title="11.3.1&nbsp;The DATE, DATETIME, and TIMESTAMP Types"><code class="literal">TIMESTAMP</code></a>
                    column unless explicitly included in the column definition.
                </p><p style="color:blue;">为时间戳系统变量启用显式默认值。在这种情况下，指定自动初始化和更新的默认current_timestamp和on update current_timestamp子句可用，但除非列定义中明确包含，否则不会分配给任何timestamp列。</p><p></p></li><li class="listitem"><p>
                    Alternatively, if
                    <a class="link" href="server-administration.html#sysvar_explicit_defaults_for_timestamp"><code class="literal">explicit_defaults_for_timestamp</code></a>
                    is disabled, do either of the following:
                </p><p style="color:blue;">或者，如果禁用explicit_defaults_for_timestamp，请执行以下任一操作：</p><p></p>
                    <div class="itemizedlist">
                        <ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
                            Define the column with a <code class="literal">DEFAULT</code>
                            clause that specifies a constant default value.
                        </p><p style="color:blue;">使用指定常量默认值的default子句定义列。</p><p></p></li><li class="listitem"><p>
                            Specify the <code class="literal">NULL</code> attribute. This also
                            causes the column to permit <code class="literal">NULL</code>
                            values, which means that you cannot assign the current
                            timestamp by setting the column to
                            <code class="literal">NULL</code>. Assigning
                            <code class="literal">NULL</code> sets the column to
                            <code class="literal">NULL</code>, not the current timestamp. To
                            assign the current timestamp, set the column to
                            <a class="link" href="functions.html#function_current-timestamp"><code class="literal">CURRENT_TIMESTAMP</code></a> or a
                            synonym such as <a class="link" href="functions.html#function_now"><code class="literal">NOW()</code></a>.
                        </p><p style="color:blue;">指定空属性。这还导致列允许空值，这意味着您不能通过将列设置为空来分配当前时间戳。赋值空将列设置为空，而不是当前时间戳。要分配当前时间戳，请将列设置为current_timestamp或now（）等同义词。</p><p></p></li></ul>
                    </div>
                </li></ul>
            </div>
            <p>
                Consider these table definitions:
            </p><p style="color:blue;">请考虑以下表定义：</p><p></p><pre data-lang="sql" class="programlisting">CREATE TABLE t1 (
  ts1 TIMESTAMP DEFAULT 0,
  ts2 TIMESTAMP DEFAULT CURRENT_TIMESTAMP
                ON UPDATE CURRENT_TIMESTAMP);
CREATE TABLE t2 (
  ts1 TIMESTAMP NULL,
  ts2 TIMESTAMP DEFAULT CURRENT_TIMESTAMP
                ON UPDATE CURRENT_TIMESTAMP);
CREATE TABLE t3 (
  ts1 TIMESTAMP NULL DEFAULT 0,
  ts2 TIMESTAMP DEFAULT CURRENT_TIMESTAMP
                ON UPDATE CURRENT_TIMESTAMP);
</pre><p>
            The tables have these properties:
        </p><p style="color:blue;">这些表具有以下属性：</p><p></p>
            <div class="itemizedlist">
                <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                    In each table definition, the first
                    <a class="link" href="data-types.html#datetime" title="11.3.1&nbsp;The DATE, DATETIME, and TIMESTAMP Types"><code class="literal">TIMESTAMP</code></a> column has no
                    automatic initialization or updating.
                </p><p style="color:blue;">在每个表定义中，第一个timestamp列没有自动初始化或更新。</p><p></p></li><li class="listitem"><p>
                    The tables differ in how the <code class="literal">ts1</code> column
                    handles <code class="literal">NULL</code> values. For
                    <code class="literal">t1</code>, <code class="literal">ts1</code> is
                    <code class="literal">NOT NULL</code> and assigning it a value of
                    <code class="literal">NULL</code> sets it to the current timestamp.
                    For <code class="literal">t2</code> and <code class="literal">t3</code>,
                    <code class="literal">ts1</code> permits <code class="literal">NULL</code> and
                    assigning it a value of <code class="literal">NULL</code> sets it to
                    <code class="literal">NULL</code>.
                </p><p style="color:blue;">这些表在ts1列处理空值的方式上有所不同。对于T1，TS1不为空，并且将其赋值为空将其设置为当前时间戳。对于t2和t3，ts1允许null，并将其赋值为null将其设置为null。</p><p></p></li><li class="listitem"><p>
                    <code class="literal">t2</code> and <code class="literal">t3</code> differ in
                    the default value for <code class="literal">ts1</code>. For
                    <code class="literal">t2</code>, <code class="literal">ts1</code> is defined to
                    permit <code class="literal">NULL</code>, so the default is also
                    <code class="literal">NULL</code> in the absence of an explicit
                    <code class="literal">DEFAULT</code> clause. For
                    <code class="literal">t3</code>, <code class="literal">ts1</code> permits
                    <code class="literal">NULL</code> but has an explicit default of 0.
                </p><p style="color:blue;">t2和t3与ts1的默认值不同。对于t2，ts1被定义为允许null，因此在没有显式default子句的情况下，缺省值也是null。对于t3，ts1允许空值，但显式默认值为0。</p><p></p></li></ul>
            </div>
            <p>
                If a <a class="link" href="data-types.html#datetime" title="11.3.1&nbsp;The DATE, DATETIME, and TIMESTAMP Types"><code class="literal">TIMESTAMP</code></a> or
                <a class="link" href="data-types.html#datetime" title="11.3.1&nbsp;The DATE, DATETIME, and TIMESTAMP Types"><code class="literal">DATETIME</code></a> column definition
                includes an explicit fractional seconds precision value
                anywhere, the same value must be used throughout the column
                definition. This is permitted:
            </p><p style="color:blue;">如果时间戳或日期时间列定义在任何地方包含显式小数秒精度值，则必须在整个列定义中使用相同的值。这是允许的：</p><p></p><pre data-lang="sql" class="programlisting">CREATE TABLE t1 (
  ts TIMESTAMP(6) DEFAULT CURRENT_TIMESTAMP(6) ON UPDATE CURRENT_TIMESTAMP(6)
);
</pre><p>
            This is not permitted:
        </p><p style="color:blue;">这是不允许的：</p><p></p><pre data-lang="sql" class="programlisting">CREATE TABLE t1 (
  ts TIMESTAMP(6) DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP(3)
);
</pre>
            <h4><a name="idm140286860423616"></a>TIMESTAMP Initialization and the NULL Attribute</h4>
            <p>
                If the
                <a class="link" href="server-administration.html#sysvar_explicit_defaults_for_timestamp"><code class="literal">explicit_defaults_for_timestamp</code></a>
                system variable is disabled,
                <a class="link" href="data-types.html#datetime" title="11.3.1&nbsp;The DATE, DATETIME, and TIMESTAMP Types"><code class="literal">TIMESTAMP</code></a> columns by default are
                <code class="literal">NOT NULL</code>, cannot contain
                <code class="literal">NULL</code> values, and assigning
                <code class="literal">NULL</code> assigns the current timestamp. To permit
                a <a class="link" href="data-types.html#datetime" title="11.3.1&nbsp;The DATE, DATETIME, and TIMESTAMP Types"><code class="literal">TIMESTAMP</code></a> column to contain
                <code class="literal">NULL</code>, explicitly declare it with the
                <code class="literal">NULL</code> attribute. In this case, the default
                value also becomes <code class="literal">NULL</code> unless overridden
                with a <code class="literal">DEFAULT</code> clause that specifies a
                different default value. <code class="literal">DEFAULT NULL</code> can be
                used to explicitly specify <code class="literal">NULL</code> as the
                default value. (For a <a class="link" href="data-types.html#datetime" title="11.3.1&nbsp;The DATE, DATETIME, and TIMESTAMP Types"><code class="literal">TIMESTAMP</code></a>
                column not declared with the <code class="literal">NULL</code> attribute,
                <code class="literal">DEFAULT NULL</code> is invalid.) If a
                <a class="link" href="data-types.html#datetime" title="11.3.1&nbsp;The DATE, DATETIME, and TIMESTAMP Types"><code class="literal">TIMESTAMP</code></a> column permits
                <code class="literal">NULL</code> values, assigning
                <code class="literal">NULL</code> sets it to <code class="literal">NULL</code>, not
                to the current timestamp.
            </p><p style="color:blue;">如果禁用EXPLICIT U defaults_for_timestamp系统变量，则默认情况下时间戳列不为空，不能包含空值，并且赋值为空将指定当前时间戳。若要允许时间戳列包含null，请使用null属性显式声明它。在这种情况下，除非使用指定不同默认值的default子句重写，否则默认值也将变为空。可以使用default null显式指定null作为默认值。（对于没有使用null属性声明的timestamp列，默认值null无效。）如果timestamp列允许空值，则将其设置为null，而不是当前timestamp。</p><p></p><p>
            The following table contains several
            <a class="link" href="data-types.html#datetime" title="11.3.1&nbsp;The DATE, DATETIME, and TIMESTAMP Types"><code class="literal">TIMESTAMP</code></a> columns that permit
            <code class="literal">NULL</code> values:
        </p><p style="color:blue;">下表包含几个允许空值的时间戳列：</p><p></p><pre data-lang="sql" class="programlisting">CREATE TABLE t
(
  ts1 TIMESTAMP NULL DEFAULT NULL,
  ts2 TIMESTAMP NULL DEFAULT 0,
  ts3 TIMESTAMP NULL DEFAULT CURRENT_TIMESTAMP
);
</pre><p>
            A <a class="link" href="data-types.html#datetime" title="11.3.1&nbsp;The DATE, DATETIME, and TIMESTAMP Types"><code class="literal">TIMESTAMP</code></a> column that permits
            <code class="literal">NULL</code> values does <span class="emphasis"><em>not</em></span>
            take on the current timestamp at insert time except under one of
            the following conditions:
        </p><p style="color:blue;">允许空值的时间戳列在插入时不接受当前时间戳，除非在下列条件之一下：</p><p></p>
            <div class="itemizedlist">
                <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                    Its default value is defined as
                    <a class="link" href="functions.html#function_current-timestamp"><code class="literal">CURRENT_TIMESTAMP</code></a> and no
                    value is specified for the column
                </p><p style="color:blue;">它的默认值被定义为current_timestamp，并且没有为列指定值</p><p></p></li><li class="listitem"><p>
                    <a class="link" href="functions.html#function_current-timestamp"><code class="literal">CURRENT_TIMESTAMP</code></a> or any of
                    its synonyms such as <a class="link" href="functions.html#function_now"><code class="literal">NOW()</code></a> is
                    explicitly inserted into the column
                </p><p style="color:blue;">当前时间戳或其任何同义词（如now（））显式插入到列中</p><p></p></li></ul>
            </div>
            <p>
                In other words, a <a class="link" href="data-types.html#datetime" title="11.3.1&nbsp;The DATE, DATETIME, and TIMESTAMP Types"><code class="literal">TIMESTAMP</code></a>
                column defined to permit <code class="literal">NULL</code> values
                auto-initializes only if its definition includes
                <code class="literal">DEFAULT CURRENT_TIMESTAMP</code>:
            </p><p style="color:blue;">换句话说，仅当定义包含默认的当前时间戳时，定义为允许空值的时间戳列才会自动初始化：</p><p></p><pre data-lang="sql" class="programlisting">CREATE TABLE t (ts TIMESTAMP NULL DEFAULT CURRENT_TIMESTAMP);
</pre><p>
            If the <a class="link" href="data-types.html#datetime" title="11.3.1&nbsp;The DATE, DATETIME, and TIMESTAMP Types"><code class="literal">TIMESTAMP</code></a> column permits
            <code class="literal">NULL</code> values but its definition does not
            include <code class="literal">DEFAULT CURRENT_TIMESTAMP</code>, you must
            explicitly insert a value corresponding to the current date and
            time. Suppose that tables <code class="literal">t1</code> and
            <code class="literal">t2</code> have these definitions:
        </p><p style="color:blue;">如果timestamp列允许空值，但其定义不包括默认的current_timestamp，则必须显式插入与当前日期和时间对应的值。假设表T1和T2有以下定义：</p><p></p><pre data-lang="sql" class="programlisting">CREATE TABLE t1 (ts TIMESTAMP NULL DEFAULT '0000-00-00 00:00:00');
CREATE TABLE t2 (ts TIMESTAMP NULL DEFAULT NULL);
</pre><p>
            To set the <a class="link" href="data-types.html#datetime" title="11.3.1&nbsp;The DATE, DATETIME, and TIMESTAMP Types"><code class="literal">TIMESTAMP</code></a> column in
            either table to the current timestamp at insert time, explicitly
            assign it that value. For example:
        </p><p style="color:blue;">要将任一表中的timestamp列设置为插入时的当前timestamp，请显式地为其指定该值。例如：</p><p></p><pre data-lang="sql" class="programlisting">INSERT INTO t2 VALUES (CURRENT_TIMESTAMP);
INSERT INTO t1 VALUES (NOW());
</pre><p>
            If the
            <a class="link" href="server-administration.html#sysvar_explicit_defaults_for_timestamp"><code class="literal">explicit_defaults_for_timestamp</code></a>
            system variable is enabled,
            <a class="link" href="data-types.html#datetime" title="11.3.1&nbsp;The DATE, DATETIME, and TIMESTAMP Types"><code class="literal">TIMESTAMP</code></a> columns permit
            <code class="literal">NULL</code> values only if declared with the
            <code class="literal">NULL</code> attribute. Also,
            <a class="link" href="data-types.html#datetime" title="11.3.1&nbsp;The DATE, DATETIME, and TIMESTAMP Types"><code class="literal">TIMESTAMP</code></a> columns do not permit
            assigning <code class="literal">NULL</code> to assign the current
            timestamp, whether declared with the <code class="literal">NULL</code> or
            <code class="literal">NOT NULL</code> attribute. To assign the current
            timestamp, set the column to
            <a class="link" href="functions.html#function_current-timestamp"><code class="literal">CURRENT_TIMESTAMP</code></a> or a synonym
            such as <a class="link" href="functions.html#function_now"><code class="literal">NOW()</code></a>.
        </p><p style="color:blue;">如果启用EXPLICIT U defaults_for_timestamp系统变量，则仅当使用NULL属性声明时，时间戳列才允许空值。此外，时间戳列不允许分配空值来分配当前时间戳，无论是否使用空属性声明。要分配当前时间戳，请将列设置为current_timestamp或now（）等同义词。</p><p></p>
        </div>
        <div class="section">
            <div class="titlepage">
                <div>
                    <div>
                        <h3 class="title"><a name="fractional-seconds"></a>11.3.6&nbsp;Fractional Seconds in Time Values</h3>

                    </div>

                </div>

            </div>
            <p>
                MySQL 5.7 has fractional seconds support for
                <a class="link" href="data-types.html#time" title="11.3.2&nbsp;The TIME Type"><code class="literal">TIME</code></a>,
                <a class="link" href="data-types.html#datetime" title="11.3.1&nbsp;The DATE, DATETIME, and TIMESTAMP Types"><code class="literal">DATETIME</code></a>, and
                <a class="link" href="data-types.html#datetime" title="11.3.1&nbsp;The DATE, DATETIME, and TIMESTAMP Types"><code class="literal">TIMESTAMP</code></a> values, with up to
                microseconds (6 digits) precision:
            </p><p style="color:blue;">mysql 5.7支持时间、日期时间和时间戳值的小数秒，精度高达微秒（6位）：</p><p></p>
            <div class="itemizedlist">
                <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                    To define a column that includes a fractional seconds part,
                    use the syntax
                    <code class="literal"><em class="replaceable"><code>type_name</code></em>(<em class="replaceable"><code>fsp</code></em>)</code>,
                    where <em class="replaceable"><code>type_name</code></em> is
                    <a class="link" href="data-types.html#time" title="11.3.2&nbsp;The TIME Type"><code class="literal">TIME</code></a>,
                    <a class="link" href="data-types.html#datetime" title="11.3.1&nbsp;The DATE, DATETIME, and TIMESTAMP Types"><code class="literal">DATETIME</code></a>, or
                    <a class="link" href="data-types.html#datetime" title="11.3.1&nbsp;The DATE, DATETIME, and TIMESTAMP Types"><code class="literal">TIMESTAMP</code></a>, and
                    <em class="replaceable"><code>fsp</code></em> is the fractional seconds
                    precision. For example:
                </p><p style="color:blue;">要定义包含小数秒部分的列，请使用语法type_name（fsp），其中type_name是time、datetime或timestamp，fsp是小数秒精度。例如：</p><p></p><pre data-lang="sql" class="programlisting">CREATE TABLE t1 (t TIME(3), dt DATETIME(6));
</pre><p>
                    The <em class="replaceable"><code>fsp</code></em> value, if given, must be
                    in the range 0 to 6. A value of 0 signifies that there is no
                    fractional part. If omitted, the default precision is 0.
                    (This differs from the standard SQL default of 6, for
                    compatibility with previous MySQL versions.)
                </p><p style="color:blue;">fsp值（如果给定）必须在0到6的范围内。值为0表示不存在小数部分。如果省略，则默认精度为0。（这与标准的SQL默认值6不同，因为它与以前的MySQL版本兼容。）</p><p></p></li><li class="listitem"><p>
                    Inserting a <a class="link" href="data-types.html#time" title="11.3.2&nbsp;The TIME Type"><code class="literal">TIME</code></a>,
                    <a class="link" href="data-types.html#datetime" title="11.3.1&nbsp;The DATE, DATETIME, and TIMESTAMP Types"><code class="literal">DATE</code></a>, or
                    <a class="link" href="data-types.html#datetime" title="11.3.1&nbsp;The DATE, DATETIME, and TIMESTAMP Types"><code class="literal">TIMESTAMP</code></a> value with a
                    fractional seconds part into a column of the same type but
                    having fewer fractional digits results in rounding. Consider
                    a table created and populated as follows:
                </p><p style="color:blue;">将带有小数秒部分的时间、日期或时间戳值插入同一类型但小数位数较少的列中会导致舍入。考虑如下创建和填充的表：</p><p></p><pre data-lang="sql" class="programlisting">CREATE TABLE fractest( c1 TIME(2), c2 DATETIME(2), c3 TIMESTAMP(2) );
INSERT INTO fractest VALUES
('17:51:04.777', '2018-09-08 17:51:04.777', '2018-09-08 17:51:04.777');
</pre><p>
                    The temporal values are inserted into the table with
                    rounding:
                </p><p style="color:blue;">时间值通过舍入插入到表中：</p><p></p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT * FROM fractest;</code></strong>
+-------------+------------------------+------------------------+
| c1          | c2                     | c3                     |
+-------------+------------------------+------------------------+
| 17:51:04.78 | 2018-09-08 17:51:04.78 | 2018-09-08 17:51:04.78 |
+-------------+------------------------+------------------------+
</pre><p>
                    No warning or error is given when such rounding occurs. This
                    behavior follows the SQL standard, and is not affected by
                    the server <a class="link" href="server-administration.html#sysvar_sql_mode"><code class="literal">sql_mode</code></a>
                    setting.
                </p><p style="color:blue;">当这种舍入发生时，不会给出警告或错误。此行为遵循SQL标准，不受服务器SQL模式设置的影响。</p><p></p></li><li class="listitem"><p>
                    Functions that take temporal arguments accept values with
                    fractional seconds. Return values from temporal functions
                    include fractional seconds as appropriate. For example,
                    <a class="link" href="functions.html#function_now"><code class="literal">NOW()</code></a> with no argument
                    returns the current date and time with no fractional part,
                    but takes an optional argument from 0 to 6 to specify that
                    the return value includes a fractional seconds part of that
                    many digits.
                </p><p style="color:blue;">接受时态参数的函数接受带有小数秒的值。时间函数的返回值包括适当的小数秒。例如，不带参数的now（）返回不带小数部分的当前日期和时间，但接受0到6之间的可选参数以指定返回值包含该多个数字的小数秒部分。</p><p></p></li><li class="listitem"><p>
                    Syntax for temporal literals produces temporal values:
                    <code class="literal">DATE '<em class="replaceable"><code>str</code></em>'</code>,
                    <code class="literal">TIME '<em class="replaceable"><code>str</code></em>'</code>,
                    and <code class="literal">TIMESTAMP
                    '<em class="replaceable"><code>str</code></em>'</code>, and the
                    ODBC-syntax equivalents. The resulting value includes a
                    trailing fractional seconds part if specified. Previously,
                    the temporal type keyword was ignored and these constructs
                    produced the string value. See
                    <a class="xref" href="language-structure.html#date-and-time-standard-sql-literals" title="Standard SQL and ODBC Date and Time Literals">Standard SQL and ODBC Date and Time Literals</a>
                </p><p style="color:blue;">时态字面值的语法产生时态值：日期'str'，时间'str'，时间戳'str'，以及odbc语法等价物。如果指定，则结果值包括后面的小数秒部分。以前，临时类型关键字被忽略，这些构造生成字符串值。请参阅标准SQL和ODBC日期和时间文本</p><p></p></li></ul>
            </div>

        </div>
        <div class="section">
            <div class="titlepage">
                <div>
                    <div>
                        <h3 class="title"><a name="date-and-time-type-conversion"></a>11.3.7&nbsp;Conversion Between Date and Time Types</h3>

                    </div>

                </div>

            </div>
            <p>
                To some extent, you can convert a value from one temporal type
                to another. However, there may be some alteration of the value
                or loss of information. In all cases, conversion between
                temporal types is subject to the range of valid values for the
                resulting type. For example, although
                <a class="link" href="data-types.html#datetime" title="11.3.1&nbsp;The DATE, DATETIME, and TIMESTAMP Types"><code class="literal">DATE</code></a>,
                <a class="link" href="data-types.html#datetime" title="11.3.1&nbsp;The DATE, DATETIME, and TIMESTAMP Types"><code class="literal">DATETIME</code></a>, and
                <a class="link" href="data-types.html#datetime" title="11.3.1&nbsp;The DATE, DATETIME, and TIMESTAMP Types"><code class="literal">TIMESTAMP</code></a> values all can be
                specified using the same set of formats, the types do not all
                have the same range of values.
                <a class="link" href="data-types.html#datetime" title="11.3.1&nbsp;The DATE, DATETIME, and TIMESTAMP Types"><code class="literal">TIMESTAMP</code></a> values cannot be
                earlier than <code class="literal">1970</code> UTC or later than
                <code class="literal">'2038-01-19 03:14:07'</code> UTC. This means that a
                date such as <code class="literal">'1968-01-01'</code>, while valid as a
                <a class="link" href="data-types.html#datetime" title="11.3.1&nbsp;The DATE, DATETIME, and TIMESTAMP Types"><code class="literal">DATE</code></a> or
                <a class="link" href="data-types.html#datetime" title="11.3.1&nbsp;The DATE, DATETIME, and TIMESTAMP Types"><code class="literal">DATETIME</code></a> value, is not valid as a
                <a class="link" href="data-types.html#datetime" title="11.3.1&nbsp;The DATE, DATETIME, and TIMESTAMP Types"><code class="literal">TIMESTAMP</code></a> value and is converted
                to <code class="literal">0</code>.
            </p><p style="color:blue;">在某种程度上，您可以将一个值从一个时态类型转换为另一个时态类型。但是，信息的价值可能会有一些变化或丢失。在所有情况下，时间类型之间的转换都取决于结果类型的有效值范围。例如，尽管日期、日期时间和时间戳值都可以使用相同的格式集指定，但这些类型的值范围并不都相同。时间戳值不能早于1970 UTC或晚于'2038-01-19 03:14:07'UTC。这意味着“1968-01-01”等日期作为日期或日期时间值有效，但作为时间戳值无效，并转换为0。</p><p></p><p>
            Conversion of <a class="link" href="data-types.html#datetime" title="11.3.1&nbsp;The DATE, DATETIME, and TIMESTAMP Types"><code class="literal">DATE</code></a> values:
        </p><p style="color:blue;">日期值转换：</p><p></p>
            <div class="itemizedlist">
                <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                    Conversion to a <a class="link" href="data-types.html#datetime" title="11.3.1&nbsp;The DATE, DATETIME, and TIMESTAMP Types"><code class="literal">DATETIME</code></a> or
                    <a class="link" href="data-types.html#datetime" title="11.3.1&nbsp;The DATE, DATETIME, and TIMESTAMP Types"><code class="literal">TIMESTAMP</code></a> value adds a time
                    part of <code class="literal">'00:00:00'</code> because the
                    <a class="link" href="data-types.html#datetime" title="11.3.1&nbsp;The DATE, DATETIME, and TIMESTAMP Types"><code class="literal">DATE</code></a> value contains no time
                    information.
                </p><p style="color:blue;">转换为日期时间或时间戳值将添加“00:00:00”的时间部分，因为日期值不包含时间信息。</p><p></p></li><li class="listitem"><p>
                    Conversion to a <a class="link" href="data-types.html#time" title="11.3.2&nbsp;The TIME Type"><code class="literal">TIME</code></a> value is
                    not useful; the result is <code class="literal">'00:00:00'</code>.
                </p><p style="color:blue;">转换为时间值无效；结果为“00:00:00”。</p><p></p></li></ul>
            </div>
            <p>
                Conversion of <a class="link" href="data-types.html#datetime" title="11.3.1&nbsp;The DATE, DATETIME, and TIMESTAMP Types"><code class="literal">DATETIME</code></a> and
                <a class="link" href="data-types.html#datetime" title="11.3.1&nbsp;The DATE, DATETIME, and TIMESTAMP Types"><code class="literal">TIMESTAMP</code></a> values:
            </p><p style="color:blue;">日期时间和时间戳值的转换：</p><p></p>
            <div class="itemizedlist">
                <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                    Conversion to a <a class="link" href="data-types.html#datetime" title="11.3.1&nbsp;The DATE, DATETIME, and TIMESTAMP Types"><code class="literal">DATE</code></a> value
                    takes fractional seconds into account and rounds the time
                    part. For example, <code class="literal">'1999-12-31
                    23:59:59.499'</code> becomes
                    <code class="literal">'1999-12-31'</code>, whereas
                    <code class="literal">'1999-12-31 23:59:59.500'</code> becomes
                    <code class="literal">'2000-01-01'</code>.
                </p><p style="color:blue;">转换为日期值需要考虑到小数秒并舍入时间部分。例如，“1999-12-31 23:59:59.499”变为“1999-12-31”，而“1999-12-31 23:59:59.500”变为“2000-01-01”。</p><p></p></li><li class="listitem"><p>
                    Conversion to a <a class="link" href="data-types.html#time" title="11.3.2&nbsp;The TIME Type"><code class="literal">TIME</code></a> value
                    discards the date part because the
                    <a class="link" href="data-types.html#time" title="11.3.2&nbsp;The TIME Type"><code class="literal">TIME</code></a> type contains no date
                    information.
                </p><p style="color:blue;">转换为时间值将丢弃日期部分，因为时间类型不包含日期信息。</p><p></p></li></ul>
            </div>
            <p>
                For conversion of <a class="link" href="data-types.html#time" title="11.3.2&nbsp;The TIME Type"><code class="literal">TIME</code></a> values to
                other temporal types, the value of
                <a class="link" href="functions.html#function_current-date"><code class="literal">CURRENT_DATE()</code></a> is used for the
                date part. The <a class="link" href="data-types.html#time" title="11.3.2&nbsp;The TIME Type"><code class="literal">TIME</code></a> is
                interpreted as elapsed time (not time of day) and added to the
                date. This means that the date part of the result differs from
                the current date if the time value is outside the range from
                <code class="literal">'00:00:00'</code> to <code class="literal">'23:59:59'</code>.
            </p><p style="color:blue;">为了将时间值转换为其他时间类型，日期部分使用current_date（）的值。时间被解释为经过的时间（不是一天中的时间），并添加到日期中。这意味着，如果时间值超出“00:00:00”到“23:59:59”的范围，则结果的日期部分与当前日期不同。</p><p></p><p>
            Suppose that the current date is
            <code class="literal">'2012-01-01'</code>.
            <a class="link" href="data-types.html#time" title="11.3.2&nbsp;The TIME Type"><code class="literal">TIME</code></a> values of
            <code class="literal">'12:00:00'</code>, <code class="literal">'24:00:00'</code>,
            and <code class="literal">'-12:00:00'</code>, when converted to
            <a class="link" href="data-types.html#datetime" title="11.3.1&nbsp;The DATE, DATETIME, and TIMESTAMP Types"><code class="literal">DATETIME</code></a> or
            <a class="link" href="data-types.html#datetime" title="11.3.1&nbsp;The DATE, DATETIME, and TIMESTAMP Types"><code class="literal">TIMESTAMP</code></a> values, result in
            <code class="literal">'2012-01-01 12:00:00'</code>, <code class="literal">'2012-01-02
            00:00:00'</code>, and <code class="literal">'2011-12-31
            12:00:00'</code>, respectively.
        </p><p style="color:blue;">假设当前日期为“2012-01-01”。“12:00:00”、“24:00:00”和“-12:00:00”的时间值转换为日期时间或时间戳值时，将分别生成“2012-01-01 12:00:00”、“2012-01-02 00:00:00”和“2011-12-31 12:00:00”。</p><p></p><p>
            Conversion of <a class="link" href="data-types.html#time" title="11.3.2&nbsp;The TIME Type"><code class="literal">TIME</code></a> to
            <a class="link" href="data-types.html#datetime" title="11.3.1&nbsp;The DATE, DATETIME, and TIMESTAMP Types"><code class="literal">DATE</code></a> is similar but discards the
            time part from the result: <code class="literal">'2012-01-01'</code>,
            <code class="literal">'2012-01-02'</code>, and
            <code class="literal">'2011-12-31'</code>, respectively.
        </p><p style="color:blue;">迄今为止的时间转换是相似的，但会分别从结果“2012-01-01”、“2012-01-02”和“2011-12-31”中丢弃时间部分。</p><p></p><p>
            Explicit conversion can be used to override implicit conversion.
            For example, in comparison of
            <a class="link" href="data-types.html#datetime" title="11.3.1&nbsp;The DATE, DATETIME, and TIMESTAMP Types"><code class="literal">DATE</code></a> and
            <a class="link" href="data-types.html#datetime" title="11.3.1&nbsp;The DATE, DATETIME, and TIMESTAMP Types"><code class="literal">DATETIME</code></a> values, the
            <a class="link" href="data-types.html#datetime" title="11.3.1&nbsp;The DATE, DATETIME, and TIMESTAMP Types"><code class="literal">DATE</code></a> value is coerced to the
            <a class="link" href="data-types.html#datetime" title="11.3.1&nbsp;The DATE, DATETIME, and TIMESTAMP Types"><code class="literal">DATETIME</code></a> type by adding a time
            part of <code class="literal">'00:00:00'</code>. To perform the comparison
            by ignoring the time part of the
            <a class="link" href="data-types.html#datetime" title="11.3.1&nbsp;The DATE, DATETIME, and TIMESTAMP Types"><code class="literal">DATETIME</code></a> value instead, use the
            <a class="link" href="functions.html#function_cast"><code class="literal">CAST()</code></a> function in the following
            way:
        </p><p style="color:blue;">显式转换可用于重写隐式转换。例如，在日期和日期时间值的比较中，通过添加“00:00:00”的时间部分，日期值被强制为日期时间类型。要通过忽略datetime值的时间部分来执行比较，请按以下方式使用cast（）函数：</p><p></p><pre data-lang="sql" class="programlisting"><em class="replaceable"><code>date_col</code></em> = CAST(<em class="replaceable"><code>datetime_col</code></em> AS DATE)
</pre><p>
            Conversion of <a class="link" href="data-types.html#time" title="11.3.2&nbsp;The TIME Type"><code class="literal">TIME</code></a> and
            <a class="link" href="data-types.html#datetime" title="11.3.1&nbsp;The DATE, DATETIME, and TIMESTAMP Types"><code class="literal">DATETIME</code></a> values to numeric form
            (for example, by adding <code class="literal">+0</code>) depends on
            whether the value contains a fractional seconds part.
            <a class="link" href="data-types.html#time" title="11.3.2&nbsp;The TIME Type"><code class="literal">TIME(<em class="replaceable"><code>N</code></em>)</code></a>
            or
            <a class="link" href="data-types.html#datetime" title="11.3.1&nbsp;The DATE, DATETIME, and TIMESTAMP Types"><code class="literal">DATETIME(<em class="replaceable"><code>N</code></em>)</code></a>
            is converted to integer when <em class="replaceable"><code>N</code></em> is 0
            (or omitted) and to a <code class="literal">DECIMAL</code> value with
            <em class="replaceable"><code>N</code></em> decimal digits when
            <em class="replaceable"><code>N</code></em> is greater than 0:
        </p><p style="color:blue;">将时间和日期时间值转换为数字形式（例如，通过添加+0）取决于该值是否包含小数秒部分。当n为0（或省略）时，时间（n）或日期时间（n）转换为整数；当n大于0时，转换为具有n个十进制数字的十进制值：</p><p></p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT CURTIME(), CURTIME()+0, CURTIME(3)+0;</code></strong>
+-----------+-------------+--------------+
| CURTIME() | CURTIME()+0 | CURTIME(3)+0 |
+-----------+-------------+--------------+
| 09:28:00  |       92800 |    92800.887 |
+-----------+-------------+--------------+
mysql&gt; <strong class="userinput"><code>SELECT NOW(), NOW()+0, NOW(3)+0;</code></strong>
+---------------------+----------------+--------------------+
| NOW()               | NOW()+0        | NOW(3)+0           |
+---------------------+----------------+--------------------+
| 2012-08-15 09:28:00 | 20120815092800 | 20120815092800.889 |
+---------------------+----------------+--------------------+
</pre>
        </div>
        <div class="section">
            <div class="titlepage">
                <div>
                    <div>
                        <h3 class="title"><a name="two-digit-years"></a>11.3.8&nbsp;2-Digit Years in Dates</h3>

                    </div>

                </div>

            </div>
            <p>
                Date values with 2-digit years are ambiguous because the century
                is unknown. Such values must be interpreted into 4-digit form
                because MySQL stores years internally using 4 digits.
            </p><p style="color:blue;">具有两位数年份的日期值不明确，因为世纪未知。这些值必须解释为4位数的形式，因为mysql在内部使用4位数存储年份。</p><p></p><p>
            For <a class="link" href="data-types.html#datetime" title="11.3.1&nbsp;The DATE, DATETIME, and TIMESTAMP Types"><code class="literal">DATETIME</code></a>,
            <a class="link" href="data-types.html#datetime" title="11.3.1&nbsp;The DATE, DATETIME, and TIMESTAMP Types"><code class="literal">DATE</code></a>, and
            <a class="link" href="data-types.html#datetime" title="11.3.1&nbsp;The DATE, DATETIME, and TIMESTAMP Types"><code class="literal">TIMESTAMP</code></a> types, MySQL interprets
            dates specified with ambiguous year values using these rules:
        </p><p style="color:blue;">对于datetime、date和timestamp类型，mysql使用以下规则解释使用不明确年份值指定的日期：</p><p></p>
            <div class="itemizedlist">
                <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                    Year values in the range <code class="literal">00-69</code> are
                    converted to <code class="literal">2000-2069</code>.
                </p><p style="color:blue;">范围为00-69的年份值转换为2000-2069。</p><p></p></li><li class="listitem"><p>
                    Year values in the range <code class="literal">70-99</code> are
                    converted to <code class="literal">1970-1999</code>.
                </p><p style="color:blue;">70-99之间的年份值转换为1970-1999。</p><p></p></li></ul>
            </div>
            <p>
                For <code class="literal">YEAR</code>, the rules are the same, with this
                exception: A numeric <code class="literal">00</code> inserted into
                <code class="literal">YEAR</code> results in <code class="literal">0000</code>
                rather than <code class="literal">2000</code>. To specify zero for
                <code class="literal">YEAR</code> and have it be interpreted as
                <code class="literal">2000</code>, specify it as a string
                <code class="literal">'0'</code> or <code class="literal">'00'</code>.
            </p><p style="color:blue;">对于年份，规则是相同的，只有一个例外：插入年份中的数字00的结果是0000，而不是2000。若要为年份指定零并将其解释为2000，请将其指定为字符串“0”或“00”。</p><p></p><p>
            Remember that these rules are only heuristics that provide
            reasonable guesses as to what your data values mean. If the
            rules used by MySQL do not produce the values you require, you
            must provide unambiguous input containing 4-digit year values.
        </p><p style="color:blue;">请记住，这些规则只是提供合理猜测数据值含义的启发式方法。如果mysql使用的规则没有生成所需的值，则必须提供包含4位年份值的明确输入。</p><p></p><p>
            <code class="literal">ORDER BY</code> properly sorts
            <a class="link" href="data-types.html#year" title="11.3.3&nbsp;The YEAR Type"><code class="literal">YEAR</code></a> values that have 2-digit
            years.
        </p><p style="color:blue;">Order by对具有2位数年份的年份值进行正确排序。</p><p></p><p>
            Some functions like <a class="link" href="functions.html#function_min"><code class="literal">MIN()</code></a> and
            <a class="link" href="functions.html#function_max"><code class="literal">MAX()</code></a> convert a
            <a class="link" href="data-types.html#year" title="11.3.3&nbsp;The YEAR Type"><code class="literal">YEAR</code></a> to a number. This means that
            a value with a 2-digit year does not work properly with these
            functions. The fix in this case is to convert the
            <a class="link" href="data-types.html#year" title="11.3.3&nbsp;The YEAR Type"><code class="literal">YEAR</code></a> to 4-digit year format.
        </p><p style="color:blue;">一些函数，如min（）和max（）将一年转换为一个数字。这意味着具有2位数年份的值不能正确处理这些函数。在这种情况下，修复方法是将年份转换为4位数的年份格式。</p><p></p>
        </div>

    </div>
    <div class="section">
        <div class="titlepage">
            <div>
                <div>
                    <h2 class="title" style="clear: both"><a name="string-types"></a>11.4&nbsp;String Types</h2>

                </div>

            </div>

        </div>
        <div class="toc">
            <dl class="toc"><dt><span class="section"><a href="data-types.html#char">11.4.1 The CHAR and VARCHAR Types</a></span></dt><dt><span class="section"><a href="data-types.html#binary-varbinary">11.4.2 The BINARY and VARBINARY Types</a></span></dt><dt><span class="section"><a href="data-types.html#blob">11.4.3 The BLOB and TEXT Types</a></span></dt><dt><span class="section"><a href="data-types.html#enum">11.4.4 The ENUM Type</a></span></dt><dt><span class="section"><a href="data-types.html#set">11.4.5 The SET Type</a></span></dt></dl>
        </div>
        <a class="indexterm" name="idm140286860231584"></a><a class="indexterm" name="idm140286860230096"></a><a class="indexterm" name="idm140286860229024"></a><a class="indexterm" name="idm140286860227952"></a><a class="indexterm" name="idm140286860226880"></a><a class="indexterm" name="idm140286860225392"></a><p>
        The string types are <a class="link" href="data-types.html#char" title="11.4.1&nbsp;The CHAR and VARCHAR Types"><code class="literal">CHAR</code></a>,
        <a class="link" href="data-types.html#char" title="11.4.1&nbsp;The CHAR and VARCHAR Types"><code class="literal">VARCHAR</code></a>,
        <a class="link" href="data-types.html#binary-varbinary" title="11.4.2&nbsp;The BINARY and VARBINARY Types"><code class="literal">BINARY</code></a>,
        <a class="link" href="data-types.html#binary-varbinary" title="11.4.2&nbsp;The BINARY and VARBINARY Types"><code class="literal">VARBINARY</code></a>,
        <a class="link" href="data-types.html#blob" title="11.4.3&nbsp;The BLOB and TEXT Types"><code class="literal">BLOB</code></a>,
        <a class="link" href="data-types.html#blob" title="11.4.3&nbsp;The BLOB and TEXT Types"><code class="literal">TEXT</code></a>,
        <a class="link" href="data-types.html#enum" title="11.4.4&nbsp;The ENUM Type"><code class="literal">ENUM</code></a>, and
        <a class="link" href="data-types.html#set" title="11.4.5&nbsp;The SET Type"><code class="literal">SET</code></a>. This section describes how
        these types work and how to use them in your queries. For string
        type storage requirements, see
        <a class="xref" href="data-types.html#storage-requirements" title="11.8&nbsp;Data Type Storage Requirements">Section&nbsp;11.8, “Data Type Storage Requirements”</a>.
    </p><p style="color:blue;">字符串类型有char、varchar、binary、varbinary、blob、text、enum和set。本节介绍这些类型如何工作以及如何在查询中使用它们。有关字符串类型存储要求，请参见第11.8节“数据类型存储要求”。</p><p></p>
        <div class="section">

            <div class="titlepage">
                <div>
                    <div>
                        <h3 class="title"><a name="char"></a>11.4.1&nbsp;The CHAR and VARCHAR Types</h3>
                    </div>
                </div>
            </div>
            <a class="indexterm" name="idm140286860211728"></a><a class="indexterm" name="idm140286860210272"></a><a class="indexterm" name="idm140286860208784"></a><p>
            The <code class="literal">CHAR</code> and <code class="literal">VARCHAR</code> types
            are similar, but differ in the way they are stored and
            retrieved. They also differ in maximum length and in whether
            trailing spaces are retained.
        </p><p style="color:blue;">char和varchar类型相似，但存储和检索方式不同。它们在最大长度和尾迹空间是否保留方面也不同。</p><p></p><p>
            The <code class="literal">CHAR</code> and <code class="literal">VARCHAR</code> types
            are declared with a length that indicates the maximum number of
            characters you want to store. For example,
            <code class="literal">CHAR(30)</code> can hold up to 30 characters.
        </p><p style="color:blue;">Car和VARCHAR类型的声明长度表示要存储的最大字符数。例如，char（30）最多可以容纳30个字符。</p><p></p><p>
            The length of a <code class="literal">CHAR</code> column is fixed to the
            length that you declare when you create the table. The length
            can be any value from 0 to 255. When <code class="literal">CHAR</code>
            values are stored, they are right-padded with spaces to the
            specified length. When <code class="literal">CHAR</code> values are
            retrieved, trailing spaces are removed unless the
            <a class="link" href="server-administration.html#sqlmode_pad_char_to_full_length"><code class="literal">PAD_CHAR_TO_FULL_LENGTH</code></a> SQL
            mode is enabled.
        </p><p style="color:blue;">char列的长度固定为创建表时声明的长度。长度可以是0到255之间的任意值。在存储char值时，会用空格将其右填充到指定的长度。检索char值时，除非启用pad_char_to_full_length sql模式，否则将删除尾随空格。</p><p></p><p>
            Values in <code class="literal">VARCHAR</code> columns are variable-length
            strings. The length can be specified as a value from 0 to
            65,535. The effective maximum length of a
            <code class="literal">VARCHAR</code> is subject to the maximum row size
            (65,535 bytes, which is shared among all columns) and the
            character set used. See <a class="xref" href="optimization.html#column-count-limit" title="8.4.7&nbsp;Limits on Table Column Count and Row Size">Section&nbsp;8.4.7, “Limits on Table Column Count and Row Size”</a>.
        </p><p style="color:blue;">varchar列中的值是可变长度字符串。长度可以指定为0到65535之间的值。VARCHAR的有效最大长度服从最大行大小（65535字节，在所有列之间共享）和所使用的字符集。见第8.4.7节，“表格列数和行大小限制”。</p><p></p><p>
            In contrast to <code class="literal">CHAR</code>,
            <code class="literal">VARCHAR</code> values are stored as a 1-byte or
            2-byte length prefix plus data. The length prefix indicates the
            number of bytes in the value. A column uses one length byte if
            values require no more than 255 bytes, two length bytes if
            values may require more than 255 bytes.
        </p><p style="color:blue;">与char相反，varchar值存储为1字节或2字节长度的前缀加上数据。长度前缀指示值中的字节数。如果值要求的字节数不超过255，则列使用一个长度字节；如果值要求的字节数可能超过255，则列使用两个长度字节。</p><p></p><p>
            If strict SQL mode is not enabled and you assign a value to a
            <code class="literal">CHAR</code> or <code class="literal">VARCHAR</code> column
            that exceeds the column's maximum length, the value is truncated
            to fit and a warning is generated. For truncation of nonspace
            characters, you can cause an error to occur (rather than a
            warning) and suppress insertion of the value by using strict SQL
            mode. See <a class="xref" href="server-administration.html#sql-mode" title="5.1.10&nbsp;Server SQL Modes">Section&nbsp;5.1.10, “Server SQL Modes”</a>.
        </p><p style="color:blue;">如果没有启用严格的SQL模式，并且将一个值分配给超过列最大长度的char或vARAR列，则将该值截断为适合并生成警告。对于非空格字符的截断，可以导致错误（而不是警告）并通过使用严格的SQL模式禁止插入该值。参见第5.1.10节“服务器SQL模式”。</p><p></p><p>
            For <code class="literal">VARCHAR</code> columns, trailing spaces in
            excess of the column length are truncated prior to insertion and
            a warning is generated, regardless of the SQL mode in use. For
            <code class="literal">CHAR</code> columns, truncation of excess trailing
            spaces from inserted values is performed silently regardless of
            the SQL mode.
        </p><p style="color:blue;">对于varchar列，超出列长度的尾随空格在插入之前被截断，并生成警告，而不管使用的是何种sql模式。对于char列，不管sql模式如何，从插入的值中截断多余的尾随空格都将以静默方式执行。</p><p></p><p>
            <code class="literal">VARCHAR</code> values are not padded when they are
            stored. Trailing spaces are retained when values are stored and
            retrieved, in conformance with standard SQL.
        </p><p style="color:blue;">存储varchar值时不填充它们。根据标准sql，在存储和检索值时保留尾随空格。</p><p></p><p>
            The following table illustrates the differences between
            <code class="literal">CHAR</code> and <code class="literal">VARCHAR</code> by
            showing the result of storing various string values into
            <code class="literal">CHAR(4)</code> and <code class="literal">VARCHAR(4)</code>
            columns (assuming that the column uses a single-byte character
            set such as <code class="literal">latin1</code>).
        </p><p style="color:blue;">下表通过显示将各种字符串值存储到char（4）和varchar（4）列中的结果（假设该列使用单字节字符集，如latin1）来说明char和varchar之间的区别。</p><p></p>
            <div class="informaltable">
                <table summary="Illustration of the difference between CHAR and VARCHAR storage requirements by showing the required storage for various string values in CHAR(4) and VARCHAR(4) columns."><colgroup><col width="15%"><col width="15%"><col width="20%"><col width="15%"><col width="20%"></colgroup><thead><tr>
                    <th scope="col">Value</th>
                    <th scope="col"><code class="literal">CHAR(4)</code></th>
                    <th scope="col">Storage Required</th>
                    <th scope="col"><code class="literal">VARCHAR(4)</code></th>
                    <th scope="col">Storage Required</th>
                </tr></thead><tbody><tr>
                    <td scope="row"><code class="literal">''</code></td>
                    <td><code class="literal">'&nbsp;&nbsp;&nbsp;&nbsp;'</code></td>
                    <td>4 bytes</td>
                    <td><code class="literal">''</code></td>
                    <td>1 byte</td>
                </tr><tr>
                    <td scope="row"><code class="literal">'ab'</code></td>
                    <td><code class="literal">'ab&nbsp;&nbsp;'</code></td>
                    <td>4 bytes</td>
                    <td><code class="literal">'ab'</code></td>
                    <td>3 bytes</td>
                </tr><tr>
                    <td scope="row"><code class="literal">'abcd'</code></td>
                    <td><code class="literal">'abcd'</code></td>
                    <td>4 bytes</td>
                    <td><code class="literal">'abcd'</code></td>
                    <td>5 bytes</td>
                </tr><tr>
                    <td scope="row"><code class="literal">'abcdefgh'</code></td>
                    <td><code class="literal">'abcd'</code></td>
                    <td>4 bytes</td>
                    <td><code class="literal">'abcd'</code></td>
                    <td>5 bytes</td>
                </tr></tbody></table>
            </div>
            <p>
                The values shown as stored in the last row of the table apply
                <span class="emphasis"><em>only when not using strict mode</em></span>; if MySQL
                is running in strict mode, values that exceed the column length
                are <span class="emphasis"><em>not stored</em></span>, and an error results.
            </p><p style="color:blue;">存储在表最后一行的值仅在不使用strict模式时才适用；如果mysql运行在strict模式下，则不存储超过列长度的值，并会导致错误。</p><p></p><p>
            <code class="literal">InnoDB</code> encodes fixed-length fields greater
            than or equal to 768 bytes in length as variable-length fields,
            which can be stored off-page. For example, a
            <code class="literal">CHAR(255)</code> column can exceed 768 bytes if the
            maximum byte length of the character set is greater than 3, as
            it is with <code class="literal">utf8mb4</code>.
        </p><p style="color:blue;">innodb将长度大于或等于768字节的固定长度字段编码为可变长度字段，这些字段可以在页面外存储。例如，如果字符集的最大字节长度大于3，则字符（255）列可以超过768字节，因为它与UTF8Mb4是相同的。</p><p></p><p>
            If a given value is stored into the <code class="literal">CHAR(4)</code>
            and <code class="literal">VARCHAR(4)</code> columns, the values retrieved
            from the columns are not always the same because trailing spaces
            are removed from <code class="literal">CHAR</code> columns upon retrieval.
            The following example illustrates this difference:
        </p><p style="color:blue;">如果给定值存储在char（4）和varchar（4）列中，则从列中检索的值并不总是相同的，因为检索时会从char列中删除尾随空格。以下示例说明了这种差异：</p><p></p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>CREATE TABLE vc (v VARCHAR(4), c CHAR(4));</code></strong>
Query OK, 0 rows affected (0.01 sec)

mysql&gt; <strong class="userinput"><code>INSERT INTO vc VALUES ('ab  ', 'ab  ');</code></strong>
Query OK, 1 row affected (0.00 sec)

mysql&gt; <strong class="userinput"><code>SELECT CONCAT('(', v, ')'), CONCAT('(', c, ')') FROM vc;</code></strong>
+---------------------+---------------------+
| CONCAT('(', v, ')') | CONCAT('(', c, ')') |
+---------------------+---------------------+
| (ab  )              | (ab)                |
+---------------------+---------------------+
1 row in set (0.06 sec)
</pre><p>
            Values in <code class="literal">CHAR</code> and <code class="literal">VARCHAR</code>
            columns are sorted and compared according to the character set
            collation assigned to the column.
        </p><p style="color:blue;">char和varchar列中的值根据分配给该列的字符集排序规则进行排序和比较。</p><p></p><a class="indexterm" name="idm140286860132240"></a><a class="indexterm" name="idm140286860130752"></a><p>
            All MySQL collations are of type PAD SPACE. This means that all
            <code class="literal">CHAR</code>, <code class="literal">VARCHAR</code>, and
            <code class="literal">TEXT</code> values are compared without regard to
            any trailing spaces. <span class="quote">“<span class="quote">Comparison</span>”</span> in this context
            does not include the <a class="link" href="functions.html#operator_like"><code class="literal">LIKE</code></a>
            pattern-matching operator, for which trailing spaces are
            significant. For example:
        </p><p style="color:blue;">所有mysql排序规则都是pad space类型。这意味着所有char、varchar和文本值都将进行比较，而不考虑任何尾随空格。此上下文中的“比较”不包括like模式匹配运算符，其尾随空格是重要的。例如：</p><p></p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>CREATE TABLE names (myname CHAR(10));</code></strong>
Query OK, 0 rows affected (0.03 sec)

mysql&gt; <strong class="userinput"><code>INSERT INTO names VALUES ('Jones');</code></strong>
Query OK, 1 row affected (0.00 sec)

mysql&gt; <strong class="userinput"><code>SELECT myname = 'Jones', myname = 'Jones  ' FROM names;</code></strong>
+------------------+--------------------+
| myname = 'Jones' | myname = 'Jones  ' |
+------------------+--------------------+
|                1 |                  1 |
+------------------+--------------------+
1 row in set (0.00 sec)

mysql&gt; <strong class="userinput"><code>SELECT myname LIKE 'Jones', myname LIKE 'Jones  ' FROM names;</code></strong>
+---------------------+-----------------------+
| myname LIKE 'Jones' | myname LIKE 'Jones  ' |
+---------------------+-----------------------+
|                   1 |                     0 |
+---------------------+-----------------------+
1 row in set (0.00 sec)
</pre><p>
            This is true for all MySQL versions, and is not affected by the
            server SQL mode.
        </p><p style="color:blue;">对于所有mysql版本都是这样，并且不受服务器sql模式的影响。</p><p></p>
            <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">

                <div class="admon-title">
                    Note
                </div>
                <p>
                    For more information about MySQL character sets and
                    collations, see <a class="xref" href="charset.html" title="Chapter&nbsp;10&nbsp;Character Sets, Collations, Unicode">Chapter&nbsp;10, <i>Character Sets, Collations, Unicode</i></a>. For additional
                    information about storage requirements, see
                    <a class="xref" href="data-types.html#storage-requirements" title="11.8&nbsp;Data Type Storage Requirements">Section&nbsp;11.8, “Data Type Storage Requirements”</a>.
                </p><p style="color:blue;">有关mysql字符集和排序规则的更多信息，请参阅第10章，字符集，排序规则，unicode。有关存储要求的更多信息，请参见第11.8节“数据类型存储要求”。</p><p></p>
            </div>
            <p>
                For those cases where trailing pad characters are stripped or
                comparisons ignore them, if a column has an index that requires
                unique values, inserting into the column values that differ only
                in number of trailing pad characters will result in a
                duplicate-key error. For example, if a table contains
                <code class="literal">'a'</code>, an attempt to store
                <code class="literal">'a&nbsp;'</code> causes a duplicate-key error.
            </p><p style="color:blue;">对于删除尾随填充字符或忽略它们的比较的情况，如果列具有需要唯一值的索引，则在仅尾随填充字符数不同的列中插入值将导致重复的键错误。例如，如果表包含“a”，则尝试存储“a”会导致重复键错误。</p><p></p>
        </div>
        <div class="section">
            <div class="titlepage">
                <div>
                    <div>
                        <h3 class="title"><a name="binary-varbinary"></a>11.4.2&nbsp;The BINARY and VARBINARY Types</h3>

                    </div>

                </div>

            </div>
            <a class="indexterm" name="idm140286860114144"></a><a class="indexterm" name="idm140286860113104"></a><a class="indexterm" name="idm140286860112032"></a><a class="indexterm" name="idm140286860110544"></a><p>
            The <code class="literal">BINARY</code> and <code class="literal">VARBINARY</code>
            types are similar to <a class="link" href="data-types.html#char" title="11.4.1&nbsp;The CHAR and VARCHAR Types"><code class="literal">CHAR</code></a> and
            <a class="link" href="data-types.html#char" title="11.4.1&nbsp;The CHAR and VARCHAR Types"><code class="literal">VARCHAR</code></a>, except that they contain
            binary strings rather than nonbinary strings. That is, they
            contain byte strings rather than character strings. This means
            they have the <code class="literal">binary</code> character set and
            collation, and comparison and sorting are based on the numeric
            values of the bytes in the values.
        </p><p style="color:blue;">binary和varbinary类型与char和varchar类似，只是它们包含二进制字符串而不是非二进制字符串。也就是说，它们包含字节字符串而不是字符串。这意味着它们具有二进制字符集和排序规则，并且比较和排序基于值中字节的数值。</p><p></p><p>
            The permissible maximum length is the same for
            <code class="literal">BINARY</code> and <code class="literal">VARBINARY</code> as it
            is for <a class="link" href="data-types.html#char" title="11.4.1&nbsp;The CHAR and VARCHAR Types"><code class="literal">CHAR</code></a> and
            <a class="link" href="data-types.html#char" title="11.4.1&nbsp;The CHAR and VARCHAR Types"><code class="literal">VARCHAR</code></a>, except that the length
            for <code class="literal">BINARY</code> and <code class="literal">VARBINARY</code>
            is a length in bytes rather than in characters.
        </p><p style="color:blue;">二进制和VARCHARE的允许最大长度与CHAR和VARCHAR相同，除了二进制和ValBoin的长度是字节的长度，而不是字符的长度。</p><p></p><p>
            The <code class="literal">BINARY</code> and <code class="literal">VARBINARY</code>
            data types are distinct from the <code class="literal">CHAR BINARY</code>
            and <code class="literal">VARCHAR BINARY</code> data types. For the latter
            types, the <code class="literal">BINARY</code> attribute does not cause
            the column to be treated as a binary string column. Instead, it
            causes the binary (<code class="literal">_bin</code>) collation for the
            column character set to be used, and the column itself contains
            nonbinary character strings rather than binary byte strings. For
            example, <code class="literal">CHAR(5) BINARY</code> is treated as
            <code class="literal">CHAR(5) CHARACTER SET latin1 COLLATE
                latin1_bin</code>, assuming that the default character set is
            <code class="literal">latin1</code>. This differs from
            <code class="literal">BINARY(5)</code>, which stores 5-bytes binary
            strings that have the <code class="literal">binary</code> character set
            and collation. For information about differences between binary
            strings and binary collations for nonbinary strings, see
            <a class="xref" href="charset.html#charset-binary-collations" title="10.8.5&nbsp;The binary Collation Compared to _bin Collations">Section&nbsp;10.8.5, “The binary Collation Compared to _bin Collations”</a>.
        </p><p style="color:blue;">binary和varbinary数据类型不同于char binary和varchar binary数据类型。对于后一种类型，binary属性不会将列视为二进制字符串列。相反，它会使用列字符集的二进制（_bin）排序规则，并且列本身包含非二进制字符串而不是二进制字节字符串。例如，char（5）二进制被视为char（5）字符集latin1 collate latin1_bin，假设默认字符集为latin1。这与binary（5）不同，后者存储具有二进制字符集和排序规则的5字节二进制字符串。有关二进制字符串和非二进制字符串的二进制排序规则之间的差异的信息，请参阅第10.8.5节“二进制排序规则与二进制排序规则的比较”。</p><p></p><p>
            If strict SQL mode is not enabled and you assign a value to a
            <code class="literal">BINARY</code> or <code class="literal">VARBINARY</code> column
            that exceeds the column's maximum length, the value is truncated
            to fit and a warning is generated. For cases of truncation, you
            can cause an error to occur (rather than a warning) and suppress
            insertion of the value by using strict SQL mode. See
            <a class="xref" href="server-administration.html#sql-mode" title="5.1.10&nbsp;Server SQL Modes">Section&nbsp;5.1.10, “Server SQL Modes”</a>.
        </p><p style="color:blue;">如果没有启用严格的SQL模式，并且将值赋给二进制或VARBIX列超过列的最大长度，则将该值截断为适合并生成警告。对于截断情况，您可以导致发生错误（而不是警告），并通过使用严格的SQL模式禁止插入值。参见第5.1.10节“服务器SQL模式”。</p><p></p><p>
            When <code class="literal">BINARY</code> values are stored, they are
            right-padded with the pad value to the specified length. The pad
            value is <code class="literal">0x00</code> (the zero byte). Values are
            right-padded with <code class="literal">0x00</code> on insert, and no
            trailing bytes are removed on select. All bytes are significant
            in comparisons, including <code class="literal">ORDER BY</code> and
            <code class="literal">DISTINCT</code> operations. <code class="literal">0x00</code>
            bytes and spaces are different in comparisons, with
            <code class="literal">0x00</code> &lt; space.
        </p><p style="color:blue;">当存储二进制值时，它们用pad值填充到指定的长度。pad值为0x00（零字节）。值在插入时用0x00填充，在选择时不删除任何后续字节。所有字节在比较中都是重要的，包括按顺序和不同的操作。0x00字节和空格在比较中不同，0x00&lt;空格。</p><p></p><p>
            Example: For a <code class="literal">BINARY(3)</code> column,
            <code class="literal">'a&nbsp;'</code> becomes
            <code class="literal">'a&nbsp;\0'</code> when inserted.
            <code class="literal">'a\0'</code> becomes <code class="literal">'a\0\0'</code> when
            inserted. Both inserted values remain unchanged when selected.
        </p><p style="color:blue;">示例：对于二进制（3）列，插入时“a”变为“a \0”。插入时，“\0”变为“A\0\0”。选中时，两个插入的值保持不变。</p><p></p><p>
            For <code class="literal">VARBINARY</code>, there is no padding on insert
            and no bytes are stripped on select. All bytes are significant
            in comparisons, including <code class="literal">ORDER BY</code> and
            <code class="literal">DISTINCT</code> operations. <code class="literal">0x00</code>
            bytes and spaces are different in comparisons, with
            <code class="literal">0x00</code> &lt; space.
        </p><p style="color:blue;">对于varbinary，insert没有填充，select没有剥离字节。所有字节在比较中都是重要的，包括按顺序和不同的操作。0x00字节和空格在比较中不同，0x00&lt;空格。</p><p></p><p>
            For those cases where trailing pad bytes are stripped or
            comparisons ignore them, if a column has an index that requires
            unique values, inserting into the column values that differ only
            in number of trailing pad bytes will result in a duplicate-key
            error. For example, if a table contains <code class="literal">'a'</code>,
            an attempt to store <code class="literal">'a\0'</code> causes a
            duplicate-key error.
        </p><p style="color:blue;">对于删除尾随焊盘字节或忽略它们的比较的情况，如果列具有需要唯一值的索引，则在仅尾随焊盘字节数不同的列中插入值将导致重复的键错误。例如，如果表包含“a”，则尝试存储“a\0”会导致重复键错误。</p><p></p><p>
            You should consider the preceding padding and stripping
            characteristics carefully if you plan to use the
            <code class="literal">BINARY</code> data type for storing binary data and
            you require that the value retrieved be exactly the same as the
            value stored. The following example illustrates how
            <code class="literal">0x00</code>-padding of <code class="literal">BINARY</code>
            values affects column value comparisons:
        </p><p style="color:blue;">如果计划使用二进制数据类型存储二进制数据，并且要求检索的值与存储的值完全相同，则应仔细考虑前面的填充和剥离特性。以下示例说明二进制值的0x00填充如何影响列值比较：</p><p></p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>CREATE TABLE t (c BINARY(3));</code></strong>
Query OK, 0 rows affected (0.01 sec)

mysql&gt; <strong class="userinput"><code>INSERT INTO t SET c = 'a';</code></strong>
Query OK, 1 row affected (0.01 sec)

mysql&gt; <strong class="userinput"><code>SELECT HEX(c), c = 'a', c = 'a\0\0' from t;</code></strong>
+--------+---------+-------------+
| HEX(c) | c = 'a' | c = 'a\0\0' |
+--------+---------+-------------+
| 610000 |       0 |           1 |
+--------+---------+-------------+
1 row in set (0.09 sec)
</pre><p>
            If the value retrieved must be the same as the value specified
            for storage with no padding, it might be preferable to use
            <code class="literal">VARBINARY</code> or one of the
            <a class="link" href="data-types.html#blob" title="11.4.3&nbsp;The BLOB and TEXT Types"><code class="literal">BLOB</code></a> data types instead.
        </p><p style="color:blue;">如果检索到的值必须与为不带填充的存储指定的值相同，则最好使用varbinary或某个blob数据类型。</p><p></p>
        </div>
        <div class="section">
            <div class="titlepage">
                <div>
                    <div>
                        <h3 class="title"><a name="blob"></a>11.4.3&nbsp;The BLOB and TEXT Types</h3>

                    </div>

                </div>

            </div>
            <a class="indexterm" name="idm140286860057568"></a><a class="indexterm" name="idm140286860056496"></a><a class="indexterm" name="idm140286860055424"></a><a class="indexterm" name="idm140286860053936"></a><a class="indexterm" name="idm140286860052448"></a><a class="indexterm" name="idm140286860051376"></a><p>
            A <code class="literal">BLOB</code> is a binary large object that can hold
            a variable amount of data. The four <code class="literal">BLOB</code>
            types are <code class="literal">TINYBLOB</code>, <code class="literal">BLOB</code>,
            <code class="literal">MEDIUMBLOB</code>, and <code class="literal">LONGBLOB</code>.
            These differ only in the maximum length of the values they can
            hold. The four <code class="literal">TEXT</code> types are
            <code class="literal">TINYTEXT</code>, <code class="literal">TEXT</code>,
            <code class="literal">MEDIUMTEXT</code>, and <code class="literal">LONGTEXT</code>.
            These correspond to the four <code class="literal">BLOB</code> types and
            have the same maximum lengths and storage requirements. See
            <a class="xref" href="data-types.html#storage-requirements" title="11.8&nbsp;Data Type Storage Requirements">Section&nbsp;11.8, “Data Type Storage Requirements”</a>.
        </p><p style="color:blue;">blob是一个二进制大对象，可以保存可变数量的数据。四种blob类型是tinyblob、blob、mediumblob和longblob。这些仅在它们所能保持的最大值上不同。这四种文本类型是tinytext、text、mediumtext和longtext。这些对应于四个BLB类型，并且具有相同的最大长度和存储要求。见第11.8节“数据类型存储要求”。</p><p></p><p>
            <code class="literal">BLOB</code> values are treated as binary strings
            (byte strings). They have the <code class="literal">binary</code>
            character set and collation, and comparison and sorting are
            based on the numeric values of the bytes in column values.
            <code class="literal">TEXT</code> values are treated as nonbinary strings
            (character strings). They have a character set other than
            <code class="literal">binary</code>, and values are sorted and compared
            based on the collation of the character set.
        </p><p style="color:blue;">blob值被视为二进制字符串（字节字符串）。它们有二进制字符集和排序规则，比较和排序基于列值中字节的数值。文本值被视为非二进制字符串（字符串）。它们具有二进制以外的字符集，并且根据字符集的排序规则对值进行排序和比较。</p><p></p><p>
            If strict SQL mode is not enabled and you assign a value to a
            <code class="literal">BLOB</code> or <code class="literal">TEXT</code> column that
            exceeds the column's maximum length, the value is truncated to
            fit and a warning is generated. For truncation of nonspace
            characters, you can cause an error to occur (rather than a
            warning) and suppress insertion of the value by using strict SQL
            mode. See <a class="xref" href="server-administration.html#sql-mode" title="5.1.10&nbsp;Server SQL Modes">Section&nbsp;5.1.10, “Server SQL Modes”</a>.
        </p><p style="color:blue;">如果没有启用严格的SQL模式，并且将值分配给超过列最大长度的BLB或文本列，则将该值截断为适合并生成警告。对于非空格字符的截断，可以导致错误（而不是警告）并通过使用严格的SQL模式禁止插入该值。参见第5.1.10节“服务器SQL模式”。</p><p></p><p>
            Truncation of excess trailing spaces from values to be inserted
            into <a class="link" href="data-types.html#blob" title="11.4.3&nbsp;The BLOB and TEXT Types"><code class="literal">TEXT</code></a> columns always
            generates a warning, regardless of the SQL mode.
        </p><p style="color:blue;">从要插入到文本列的值中截断多余的尾随空格始终会生成警告，而不管SQL模式如何。</p><p></p><p>
            For <code class="literal">TEXT</code> and <code class="literal">BLOB</code> columns,
            there is no padding on insert and no bytes are stripped on
            select.
        </p><p style="color:blue;">对于文本列和blob列，在insert上没有填充，在select上没有剥离字节。</p><p></p><p>
            If a <code class="literal">TEXT</code> column is indexed, index entry
            comparisons are space-padded at the end. This means that, if the
            index requires unique values, duplicate-key errors will occur
            for values that differ only in the number of trailing spaces.
            For example, if a table contains <code class="literal">'a'</code>, an
            attempt to store <code class="literal">'a&nbsp;'</code> causes a
            duplicate-key error. This is not true for
            <code class="literal">BLOB</code> columns.
        </p><p style="color:blue;">如果文本列已编制索引，则索引项比较在结尾处填充空格。这意味着，如果索引要求唯一的值，则只在尾随空格数不同的值将出现重复的键错误。例如，如果表包含“a”，则尝试存储“a”会导致重复键错误。blob列不是这样。</p><p></p><p>
            In most respects, you can regard a <code class="literal">BLOB</code>
            column as a <a class="link" href="data-types.html#binary-varbinary" title="11.4.2&nbsp;The BINARY and VARBINARY Types"><code class="literal">VARBINARY</code></a> column that
            can be as large as you like. Similarly, you can regard a
            <code class="literal">TEXT</code> column as a
            <a class="link" href="data-types.html#char" title="11.4.1&nbsp;The CHAR and VARCHAR Types"><code class="literal">VARCHAR</code></a> column.
            <code class="literal">BLOB</code> and <code class="literal">TEXT</code> differ from
            <a class="link" href="data-types.html#binary-varbinary" title="11.4.2&nbsp;The BINARY and VARBINARY Types"><code class="literal">VARBINARY</code></a> and
            <a class="link" href="data-types.html#char" title="11.4.1&nbsp;The CHAR and VARCHAR Types"><code class="literal">VARCHAR</code></a> in the following ways:
        </p><p style="color:blue;">在大多数情况下，您可以将blob列视为varbinary列，该列可以根据您的需要大。类似地，可以将文本列视为varchar列。blob和text与varbinary和varchar有以下区别：</p><p></p>
            <div class="itemizedlist">
                <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                    For indexes on <code class="literal">BLOB</code> and
                    <code class="literal">TEXT</code> columns, you must specify an index
                    prefix length. For <a class="link" href="data-types.html#char" title="11.4.1&nbsp;The CHAR and VARCHAR Types"><code class="literal">CHAR</code></a> and
                    <a class="link" href="data-types.html#char" title="11.4.1&nbsp;The CHAR and VARCHAR Types"><code class="literal">VARCHAR</code></a>, a prefix length is
                    optional. See <a class="xref" href="optimization.html#column-indexes" title="8.3.4&nbsp;Column Indexes">Section&nbsp;8.3.4, “Column Indexes”</a>.
                </p><p style="color:blue;">对于blob列和文本列上的索引，必须指定索引前缀长度。对于char和varchar，前缀长度是可选的。见第8.3.4节“列索引”。</p><p></p></li><li class="listitem"><p>
                    <a class="indexterm" name="idm140286860011072"></a>

                    <a class="indexterm" name="idm140286860009584"></a>

                    <a class="indexterm" name="idm140286860008096"></a>

                    <code class="literal">BLOB</code> and <code class="literal">TEXT</code> columns
                    cannot have <code class="literal">DEFAULT</code> values.
                </p><p style="color:blue;">blob列和文本列不能有默认值。</p><p></p></li></ul>
            </div>
            <p>
                If you use the <code class="literal">BINARY</code> attribute with a
                <code class="literal">TEXT</code> data type, the column is assigned the
                binary (<code class="literal">_bin</code>) collation of the column
                character set.
            </p><p style="color:blue;">如果将binary属性与文本数据类型一起使用，则会为列指定列字符集的binary（_bin）排序规则。</p><p></p><p>
            <code class="literal">LONG</code> and <code class="literal">LONG VARCHAR</code> map
            to the <code class="literal">MEDIUMTEXT</code> data type. This is a
            compatibility feature.
        </p><p style="color:blue;">long和long varchar映射到mediumtext数据类型。这是一个兼容性功能。</p><p></p><p>
            MySQL Connector/ODBC defines <code class="literal">BLOB</code> values as
            <code class="literal">LONGVARBINARY</code> and <code class="literal">TEXT</code>
            values as <code class="literal">LONGVARCHAR</code>.
        </p><p style="color:blue;">mysql connector/odbc将blob值定义为longvarbinary，将文本值定义为longvarchar。</p><p></p><p>
            Because <code class="literal">BLOB</code> and <code class="literal">TEXT</code>
            values can be extremely long, you might encounter some
            constraints in using them:
        </p><p style="color:blue;">由于blob和文本值可能非常长，因此在使用它们时可能会遇到一些限制：</p><p></p>
            <div class="itemizedlist">
                <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                    Only the first
                    <a class="link" href="server-administration.html#sysvar_max_sort_length"><code class="literal">max_sort_length</code></a> bytes of
                    the column are used when sorting. The default value of
                    <a class="link" href="server-administration.html#sysvar_max_sort_length"><code class="literal">max_sort_length</code></a> is 1024.
                    You can make more bytes significant in sorting or grouping
                    by increasing the value of
                    <a class="link" href="server-administration.html#sysvar_max_sort_length"><code class="literal">max_sort_length</code></a> at server
                    startup or runtime. Any client can change the value of its
                    session <a class="link" href="server-administration.html#sysvar_max_sort_length"><code class="literal">max_sort_length</code></a>
                    variable:
                </p><p style="color:blue;">排序时只使用列的第一个最大排序长度字节。最大排序长度的默认值是1024。通过在服务器启动或运行时增加max_sort_length的值，可以使更多字节在排序或分组中具有重要意义。任何客户端都可以更改其会话最大排序长度变量的值：</p><p></p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>SET max_sort_length = 2000;</code></strong>
mysql&gt; <strong class="userinput"><code>SELECT id, comment FROM t</code></strong>
    -&gt; <strong class="userinput"><code>ORDER BY comment;</code></strong>
</pre></li><li class="listitem"><p>
                    Instances of <code class="literal">BLOB</code> or
                    <code class="literal">TEXT</code> columns in the result of a query
                    that is processed using a temporary table causes the server
                    to use a table on disk rather than in memory because the
                    <code class="literal">MEMORY</code> storage engine does not support
                    those data types (see
                    <a class="xref" href="optimization.html#internal-temporary-tables" title="8.4.4&nbsp;Internal Temporary Table Use in MySQL">Section&nbsp;8.4.4, “Internal Temporary Table Use in MySQL”</a>). Use of disk
                    incurs a performance penalty, so include
                    <code class="literal">BLOB</code> or <code class="literal">TEXT</code> columns
                    in the query result only if they are really needed. For
                    example, avoid using
                    <a class="link" href="sql-syntax.html#select" title="13.2.9&nbsp;SELECT Syntax"><code class="literal">SELECT *</code></a>,
                    which selects all columns.
                </p><p style="color:blue;">使用临时表处理的查询结果中的blob或文本列实例会导致服务器使用磁盘上的表，而不是内存中的表，因为内存存储引擎不支持这些数据类型（请参阅8.4.4节，“MySQL中的内部临时表使用”）。使用磁盘会导致性能损失，因此只有在确实需要时才在查询结果中包含blob列或文本列。例如，避免使用select*，它将选择所有列。</p><p></p></li><li class="listitem"><p>
                    The maximum size of a <code class="literal">BLOB</code> or
                    <code class="literal">TEXT</code> object is determined by its type,
                    but the largest value you actually can transmit between the
                    client and server is determined by the amount of available
                    memory and the size of the communications buffers. You can
                    change the message buffer size by changing the value of the
                    <a class="link" href="server-administration.html#sysvar_max_allowed_packet"><code class="literal">max_allowed_packet</code></a>
                    variable, but you must do so for both the server and your
                    client program. For example, both <a class="link" href="programs.html#mysql" title="4.5.1&nbsp;mysql — The MySQL Command-Line Client"><span class="command"><strong>mysql</strong></span></a>
                    and <a class="link" href="programs.html#mysqldump" title="4.5.4&nbsp;mysqldump — A Database Backup Program"><span class="command"><strong>mysqldump</strong></span></a> enable you to change the
                    client-side
                    <a class="link" href="server-administration.html#sysvar_max_allowed_packet"><code class="literal">max_allowed_packet</code></a> value.
                    See <a class="xref" href="server-administration.html#server-configuration" title="5.1.1&nbsp;Configuring the Server">Section&nbsp;5.1.1, “Configuring the Server”</a>,
                    <a class="xref" href="programs.html#mysql" title="4.5.1&nbsp;mysql — The MySQL Command-Line Client">Section&nbsp;4.5.1, “<span class="command"><strong>mysql</strong></span> — The MySQL Command-Line Client”</a>, and <a class="xref" href="programs.html#mysqldump" title="4.5.4&nbsp;mysqldump — A Database Backup Program">Section&nbsp;4.5.4, “<span class="command"><strong>mysqldump</strong></span> — A Database Backup Program”</a>.
                    You may also want to compare the packet sizes and the size
                    of the data objects you are storing with the storage
                    requirements, see <a class="xref" href="data-types.html#storage-requirements" title="11.8&nbsp;Data Type Storage Requirements">Section&nbsp;11.8, “Data Type Storage Requirements”</a>
                </p><p style="color:blue;">BLB或文本对象的最大大小由其类型决定，但实际上在客户端和服务器之间传输的最大值取决于可用内存的数量和通信缓冲区的大小。您可以通过更改max_allowed_packet变量的值来更改消息缓冲区大小，但对于服务器和客户端程序都必须这样做。例如，mysql和mysqldump都允许您更改客户端max_allowed_packet值。参见第5.1.1节，“配置服务器”，第4.5.1节，“mysql-mysql命令行客户端”，第4.5.4节，“mysqldump-数据库备份程序”。您可能还需要将数据包大小和要存储的数据对象的大小与存储要求进行比较，请参见第11.8节“数据类型存储要求”</p><p></p></li></ul>
            </div>
            <p>
                Each <code class="literal">BLOB</code> or <code class="literal">TEXT</code> value is
                represented internally by a separately allocated object. This is
                in contrast to all other data types, for which storage is
                allocated once per column when the table is opened.
            </p><p style="color:blue;">每个blob或文本值在内部由单独分配的对象表示。这与所有其他数据类型不同，在打开表时，每列为这些数据类型分配一次存储空间。</p><p></p><p>
            In some cases, it may be desirable to store binary data such as
            media files in <code class="literal">BLOB</code> or
            <code class="literal">TEXT</code> columns. You may find MySQL's string
            handling functions useful for working with such data. See
            <a class="xref" href="functions.html#string-functions" title="12.5&nbsp;String Functions and Operators">Section&nbsp;12.5, “String Functions and Operators”</a>. For security and other
            reasons, it is usually preferable to do so using application
            code rather than giving application users the
            <a class="link" href="security.html#priv_file"><code class="literal">FILE</code></a> privilege. You can discuss
            specifics for various languages and platforms in the MySQL
            Forums (<a class="ulink" href="http://forums.mysql.com/" target="_top">http://forums.mysql.com/</a>).
        </p><p style="color:blue;">在某些情况下，可能需要在blob或文本列中存储二进制数据，例如媒体文件。您可能会发现mysql的字符串处理函数对于处理此类数据非常有用。见第12.5节“字符串函数和运算符”。出于安全和其他原因，通常最好使用应用程序代码，而不是授予应用程序用户文件权限。您可以在mysql论坛（http://forums.mysql.com/）中讨论各种语言和平台的细节。</p><p></p>
        </div>
        <div class="section">
            <div class="titlepage">
                <div>
                    <div>
                        <h3 class="title"><a name="enum"></a>11.4.4&nbsp;The ENUM Type</h3>

                    </div>

                </div>

            </div>
            <a class="indexterm" name="idm140286859958624"></a><a class="indexterm" name="idm140286859957552"></a><p>
            An <code class="literal">ENUM</code> is a string object with a value
            chosen from a list of permitted values that are enumerated
            explicitly in the column specification at table creation time.
            It has these advantages:
        </p><p style="color:blue;">枚举是一个字符串对象，其值从允许值列表中选择，这些允许值在创建表时在列规范中显式枚举。它具有以下优点：</p><p></p>
            <div class="itemizedlist">
                <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                    Compact data storage in situations where a column has a
                    limited set of possible values. The strings you specify as
                    input values are automatically encoded as numbers. See
                    <a class="xref" href="data-types.html#storage-requirements" title="11.8&nbsp;Data Type Storage Requirements">Section&nbsp;11.8, “Data Type Storage Requirements”</a> for the storage
                    requirements for <code class="literal">ENUM</code> types.
                </p><p style="color:blue;">在列具有有限可能值集的情况下压缩数据存储。指定为输入值的字符串将自动编码为数字。枚举类型的存储要求见第11.8节“数据类型存储要求”。</p><p></p></li><li class="listitem"><p>
                    Readable queries and output. The numbers are translated back
                    to the corresponding strings in query results.
                </p><p style="color:blue;">可读的查询和输出。这些数字被转换回查询结果中相应的字符串。</p><p></p></li></ul>
            </div>
            <p>
                and these potential issues to consider:
            </p><p style="color:blue;">以及需要考虑的潜在问题：</p><p></p>
            <div class="itemizedlist">
                <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                    If you make enumeration values that look like numbers, it is
                    easy to mix up the literal values with their internal index
                    numbers, as explained in <a class="xref" href="data-types.html#enum-limits" title="Enumeration Limitations">Enumeration Limitations</a>.
                </p><p style="color:blue;">如果使枚举值看起来像数字，则很容易将文字值与其内部索引号混淆，如枚举限制中所述。</p><p></p></li><li class="listitem"><p>
                    Using <code class="literal">ENUM</code> columns in <code class="literal">ORDER
                    BY</code> clauses requires extra care, as explained in
                    <a class="xref" href="data-types.html#enum-sorting" title="Enumeration Sorting">Enumeration Sorting</a>.
                </p><p style="color:blue;">按照ORDERBY子句使用枚举列需要格外小心，如枚举排序中所述。</p><p></p></li></ul>
            </div>
            <div class="itemizedlist">
                <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><a class="xref" href="data-types.html#enum-using" title="Creating and Using ENUM Columns">Creating and Using ENUM Columns</a></p><p style="color:blue;">创建和使用枚举列</p><p></p></li><li class="listitem"><p><a class="xref" href="data-types.html#enum-indexes" title="Index Values for Enumeration Literals">Index Values for Enumeration Literals</a></p><p style="color:blue;">枚举文本的索引值</p><p></p></li><li class="listitem"><p><a class="xref" href="data-types.html#enum-literals" title="Handling of Enumeration Literals">Handling of Enumeration Literals</a></p><p style="color:blue;">枚举文字的处理</p><p></p></li><li class="listitem"><p><a class="xref" href="data-types.html#enum-nulls" title="Empty or NULL Enumeration Values">Empty or NULL Enumeration Values</a></p><p style="color:blue;">枚举值为空或为空</p><p></p></li><li class="listitem"><p><a class="xref" href="data-types.html#enum-sorting" title="Enumeration Sorting">Enumeration Sorting</a></p><p style="color:blue;">枚举排序</p><p></p></li><li class="listitem"><p><a class="xref" href="data-types.html#enum-limits" title="Enumeration Limitations">Enumeration Limitations</a></p><p style="color:blue;">枚举限制</p><p></p></li></ul>
            </div>
            <div class="simplesect">
                <div class="titlepage">
                    <div>
                        <div class="simple">
                            <h4 class="title"><a name="enum-using"></a>Creating and Using ENUM Columns</h4>

                        </div>

                    </div>

                </div>
                <p>
                    An enumeration value must be a quoted string literal. For
                    example, you can create a table with an
                    <code class="literal">ENUM</code> column like this:
                </p><p style="color:blue;">枚举值必须是带引号的字符串文本。例如，可以创建一个具有如下枚举列的表：</p><p></p><pre data-lang="sql" class="programlisting">CREATE TABLE shirts (
    name VARCHAR(40),
    size ENUM('x-small', 'small', 'medium', 'large', 'x-large')
);
INSERT INTO shirts (name, size) VALUES ('dress shirt','large'), ('t-shirt','medium'),
  ('polo shirt','small');
SELECT name, size FROM shirts WHERE size = 'medium';
+---------+--------+
| name    | size   |
+---------+--------+
| t-shirt | medium |
+---------+--------+
UPDATE shirts SET size = 'small' WHERE size = 'large';
COMMIT;
</pre><p>
                Inserting 1 million rows into this table with a value of
                <code class="literal">'medium'</code> would require 1 million bytes of
                storage, as opposed to 6 million bytes if you stored the
                actual string <code class="literal">'medium'</code> in a
                <code class="literal">VARCHAR</code> column.
            </p><p style="color:blue;">将值为“medium”的100万行插入此表将需要100万字节的存储空间，而如果将实际字符串“medium”存储在varchar列中，则需要600万字节的存储空间。</p><p></p>
            </div>
            <div class="simplesect">
                <div class="titlepage">
                    <div>
                        <div class="simple">
                            <h4 class="title"><a name="enum-indexes"></a>Index Values for Enumeration Literals</h4>

                        </div>

                    </div>

                </div>
                <p>
                    Each enumeration value has an index:
                </p><p style="color:blue;">每个枚举值都有一个索引：</p><p></p>
                <div class="itemizedlist">
                    <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                        The elements listed in the column specification are
                        assigned index numbers, beginning with 1.
                    </p><p style="color:blue;">列规范中列出的元素被分配了索引号，从1开始。</p><p></p></li><li class="listitem"><p>
                        The index value of the empty string error value is 0. This
                        means that you can use the following
                        <a class="link" href="sql-syntax.html#select" title="13.2.9&nbsp;SELECT Syntax"><code class="literal">SELECT</code></a> statement to find
                        rows into which invalid <code class="literal">ENUM</code> values
                        were assigned:
                    </p><p style="color:blue;">空字符串错误值的索引值为0。这意味着您可以使用以下select语句查找分配了无效枚举值的行：</p><p></p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT * FROM <em class="replaceable"><code>tbl_name</code></em> WHERE <em class="replaceable"><code>enum_col</code></em>=0;</code></strong>
</pre></li><li class="listitem"><p>
                        The index of the <code class="literal">NULL</code> value is
                        <code class="literal">NULL</code>.
                    </p><p style="color:blue;">空值的索引为空。</p><p></p></li><li class="listitem"><p>
                        The term <span class="quote">“<span class="quote">index</span>”</span> here refers to a position
                        within the list of enumeration values. It has nothing to
                        do with table indexes.
                    </p><p style="color:blue;">这里的“索引”是指枚举值列表中的一个位置。它与表索引无关。</p><p></p></li></ul>
                </div>
                <p>
                    For example, a column specified as <code class="literal">ENUM('Mercury',
                    'Venus', 'Earth')</code> can have any of the values shown
                    here. The index of each value is also shown.
                </p><p style="color:blue;">例如，指定为enum（“mercury”、“venus”、“earth”）的列可以具有此处显示的任何值。还显示了每个值的索引。</p><p></p>
                <div class="informaltable">
                    <table summary="Possible values for a column specified as ENUM('Mercury', 'Venus', 'Earth'). The table also shows the index of each value."><colgroup><col width="15%"><col width="15%"></colgroup><thead><tr>
                        <th scope="col">Value</th>
                        <th scope="col">Index</th>
                    </tr></thead><tbody><tr>
                        <td scope="row"><code class="literal">NULL</code></td>
                        <td><code class="literal">NULL</code></td>
                    </tr><tr>
                        <td scope="row"><code class="literal">''</code></td>
                        <td>0</td>
                    </tr><tr>
                        <td scope="row"><code class="literal">'Mercury'</code></td>
                        <td>1</td>
                    </tr><tr>
                        <td scope="row"><code class="literal">'Venus'</code></td>
                        <td>2</td>
                    </tr><tr>
                        <td scope="row"><code class="literal">'Earth'</code></td>
                        <td>3</td>
                    </tr></tbody></table>
                </div>
                <p>
                    An <a class="link" href="data-types.html#enum" title="11.4.4&nbsp;The ENUM Type"><code class="literal">ENUM</code></a> column can have a
                    maximum of 65,535 distinct elements. (The practical limit is
                    less than 3000.) A table can have no more than 255 unique
                    element list definitions among its
                    <a class="link" href="data-types.html#enum" title="11.4.4&nbsp;The ENUM Type"><code class="literal">ENUM</code></a> and
                    <a class="link" href="data-types.html#set" title="11.4.5&nbsp;The SET Type"><code class="literal">SET</code></a> columns considered as a
                    group. For more information on these limits, see
                    <a class="xref" href="sql-syntax.html#limits-frm-file" title="Limits Imposed by .frm File Structure">Limits Imposed by .frm File Structure</a>.
                </p><p style="color:blue;">枚举列最多可以有65535个不同的元素。（实际限制小于3000。）表的枚举列和集合列之间的唯一元素列表定义不能超过255个。有关这些限制的详细信息，请参见.frm文件结构施加的限制。</p><p></p><p>
                If you retrieve an <code class="literal">ENUM</code> value in a numeric
                context, the column value's index is returned. For example,
                you can retrieve numeric values from an
                <code class="literal">ENUM</code> column like this:
            </p><p style="color:blue;">如果在数值上下文中检索枚举值，则返回列值的索引。例如，可以从枚举列中检索数值，如下所示：</p><p></p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT <em class="replaceable"><code>enum_col</code></em>+0 FROM <em class="replaceable"><code>tbl_name</code></em>;</code></strong>
</pre><p>
                Functions such as <a class="link" href="functions.html#function_sum"><code class="literal">SUM()</code></a> or
                <a class="link" href="functions.html#function_avg"><code class="literal">AVG()</code></a> that expect a numeric
                argument cast the argument to a number if necessary. For
                <code class="literal">ENUM</code> values, the index number is used in
                the calculation.
            </p><p style="color:blue;">需要数值参数的sum（）或avg（）函数在必要时将参数转换为数字。对于枚举值，将在计算中使用索引号。</p><p></p>
            </div>
            <div class="simplesect">
                <div class="titlepage">
                    <div>
                        <div class="simple">
                            <h4 class="title"><a name="enum-literals"></a>Handling of Enumeration Literals</h4>

                        </div>

                    </div>

                </div>
                <a class="indexterm" name="idm140286859884624"></a><p>
                Trailing spaces are automatically deleted from
                <code class="literal">ENUM</code> member values in the table definition
                when a table is created.
            </p><p style="color:blue;">创建表时，将自动从表定义中的枚举成员值中删除尾随空格。</p><p></p><p>
                When retrieved, values stored into an <code class="literal">ENUM</code>
                column are displayed using the lettercase that was used in the
                column definition. Note that <code class="literal">ENUM</code> columns
                can be assigned a character set and collation. For binary or
                case-sensitive collations, lettercase is taken into account
                when assigning values to the column.
            </p><p style="color:blue;">检索时，存储在枚举列中的值将使用列定义中使用的字母大小写显示。请注意，可以为枚举列分配字符集和排序规则。对于二进制或区分大小写的排序规则，将值分配给列时将考虑字母大小写。</p><p></p><p>
                If you store a number into an <code class="literal">ENUM</code> column,
                the number is treated as the index into the possible values,
                and the value stored is the enumeration member with that
                index. (However, this does <span class="emphasis"><em>not</em></span> work with
                <a class="link" href="sql-syntax.html#load-data" title="13.2.6&nbsp;LOAD DATA Syntax"><code class="literal">LOAD DATA</code></a>, which treats all
                input as strings.) If the numeric value is quoted, it is still
                interpreted as an index if there is no matching string in the
                list of enumeration values. For these reasons, it is not
                advisable to define an <code class="literal">ENUM</code> column with
                enumeration values that look like numbers, because this can
                easily become confusing. For example, the following column has
                enumeration members with string values of
                <code class="literal">'0'</code>, <code class="literal">'1'</code>, and
                <code class="literal">'2'</code>, but numeric index values of
                <code class="literal">1</code>, <code class="literal">2</code>, and
                <code class="literal">3</code>:
            </p><p style="color:blue;">如果将数字存储到枚举列中，则该数字将被视为可能值的索引，并且存储的值是具有该索引的枚举成员。（但是，这对于将所有输入都视为字符串的加载数据不起作用。）如果数值被引用，则如果枚举值列表中没有匹配的字符串，则仍将其解释为索引。由于这些原因，不建议使用看起来像数字的枚举值定义枚举列，因为这很容易使人混淆。例如，以下列具有字符串值为“0”、“1”和“2”但数字索引值为1、2和3的枚举成员：</p><p></p><pre data-lang="sql" class="programlisting">numbers ENUM('0','1','2')
</pre><p>
                If you store <code class="literal">2</code>, it is interpreted as an
                index value, and becomes <code class="literal">'1'</code> (the value
                with index 2). If you store <code class="literal">'2'</code>, it matches
                an enumeration value, so it is stored as
                <code class="literal">'2'</code>. If you store <code class="literal">'3'</code>,
                it does not match any enumeration value, so it is treated as
                an index and becomes <code class="literal">'2'</code> (the value with
                index 3).
            </p><p style="color:blue;">如果存储2，它将被解释为一个索引值，并变为“1”（带有索引2的值）。如果存储“2”，则它与枚举值匹配，因此存储为“2”。如果存储“3”，则它与任何枚举值都不匹配，因此它被视为索引并变为“2”（具有索引3的值）。</p><p></p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>INSERT INTO t (numbers) VALUES(2),('2'),('3');</code></strong>
mysql&gt; <strong class="userinput"><code>SELECT * FROM t;</code></strong>
+---------+
| numbers |
+---------+
| 1       |
| 2       |
| 2       |
+---------+
</pre><p>
                To determine all possible values for an
                <code class="literal">ENUM</code> column, use
                <a class="link" href="sql-syntax.html#show-columns" title="13.7.5.5&nbsp;SHOW COLUMNS Syntax"><code class="literal">SHOW COLUMNS
                    FROM <em class="replaceable"><code>tbl_name</code></em> LIKE
                    '<em class="replaceable"><code>enum_col</code></em>'</code></a> and parse the
                <code class="literal">ENUM</code> definition in the
                <code class="literal">Type</code> column of the output.
            </p><p style="color:blue;">要确定枚举列的所有可能值，请使用来自tbl_name的show columns，如'enum_col'，并分析输出的type列中的枚举定义。</p><p></p><p>
                In the C API, <code class="literal">ENUM</code> values are returned as
                strings. For information about using result set metadata to
                distinguish them from other strings, see
                <a class="xref" href="connectors-apis.html#c-api-data-structures" title="27.8.5&nbsp;C API Data Structures">Section&nbsp;27.8.5, “C API Data Structures”</a>.
            </p><p style="color:blue;">在C API中，枚举值作为字符串返回。有关使用结果集元数据将它们与其他字符串区分开来的信息，请参阅第27.8.5节“C API数据结构”。</p><p></p>
            </div>
            <div class="simplesect">
                <div class="titlepage">
                    <div>
                        <div class="simple">
                            <h4 class="title"><a name="enum-nulls"></a>Empty or NULL Enumeration Values</h4>

                        </div>

                    </div>

                </div>
                <p>
                    An enumeration value can also be the empty string
                    (<code class="literal">''</code>) or <code class="literal">NULL</code> under
                    certain circumstances:
                </p><p style="color:blue;">枚举值在某些情况下也可以是空字符串（''）或空值：</p><p></p>
                <div class="itemizedlist">
                    <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                        If you insert an invalid value into an
                        <code class="literal">ENUM</code> (that is, a string not present in
                        the list of permitted values), the empty string is
                        inserted instead as a special error value. This string can
                        be distinguished from a <span class="quote">“<span class="quote">normal</span>”</span> empty string
                        by the fact that this string has the numeric value 0. See
                        <a class="xref" href="data-types.html#enum-indexes" title="Index Values for Enumeration Literals">Index Values for Enumeration Literals</a> for details about the
                        numeric indexes for the enumeration values.
                    </p><p style="color:blue;">如果将无效值插入枚举（即，允许值列表中不存在的字符串），则会将空字符串作为特殊错误值插入。此字符串与“普通”空字符串的区别在于此字符串的数值为0。有关枚举值的数字索引的详细信息，请参见枚举文本的索引值。</p><p></p><p>
                        If strict SQL mode is enabled, attempts to insert invalid
                        <code class="literal">ENUM</code> values result in an error.
                    </p><p style="color:blue;">如果启用了严格SQL模式，则尝试插入无效的枚举值将导致错误。</p><p></p></li><li class="listitem"><p>
                        If an <code class="literal">ENUM</code> column is declared to permit
                        <code class="literal">NULL</code>, the <code class="literal">NULL</code> value
                        is a valid value for the column, and the default value is
                        <code class="literal">NULL</code>. If an <code class="literal">ENUM</code>
                        column is declared <code class="literal">NOT NULL</code>, its
                        default value is the first element of the list of
                        permitted values.
                    </p><p style="color:blue;">如果枚举列声明为允许空，则空值是该列的有效值，默认值为空。如果枚举列声明为非空，则其默认值是允许值列表的第一个元素。</p><p></p></li></ul>
                </div>

            </div>
            <div class="simplesect">
                <div class="titlepage">
                    <div>
                        <div class="simple">
                            <h4 class="title"><a name="enum-sorting"></a>Enumeration Sorting</h4>

                        </div>

                    </div>

                </div>
                <p>
                    <code class="literal">ENUM</code> values are sorted based on their index
                    numbers, which depend on the order in which the enumeration
                    members were listed in the column specification. For example,
                    <code class="literal">'b'</code> sorts before <code class="literal">'a'</code> for
                    <code class="literal">ENUM('b', 'a')</code>. The empty string sorts
                    before nonempty strings, and <code class="literal">NULL</code> values
                    sort before all other enumeration values.
                </p><p style="color:blue;">枚举值根据其索引号进行排序，索引号取决于枚举成员在列规范中列出的顺序。例如，对于枚举（'b'，'a'），'b'排序在'a'之前。空字符串在非空字符串之前排序，空值在所有其他枚举值之前排序。</p><p></p><p>
                To prevent unexpected results when using the <code class="literal">ORDER
                BY</code> clause on an <code class="literal">ENUM</code> column, use
                one of these techniques:
            </p><p style="color:blue;">要在枚举列上使用ORDER BY子句时防止出现意外结果，请使用以下技术之一：</p><p></p>
                <div class="itemizedlist">
                    <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                        Specify the <code class="literal">ENUM</code> list in alphabetic
                        order.
                    </p><p style="color:blue;">按字母顺序指定枚举列表。</p><p></p></li><li class="listitem"><p>
                        Make sure that the column is sorted lexically rather than
                        by index number by coding <code class="literal">ORDER BY
                        CAST(<em class="replaceable"><code>col</code></em> AS CHAR)</code> or
                        <code class="literal">ORDER BY
                            CONCAT(<em class="replaceable"><code>col</code></em>)</code>.
                    </p><p style="color:blue;">通过按CAST（COL为CHAR）或CONTAT（COL）顺序编码顺序，确保列按词汇而不是索引编号排序。</p><p></p></li></ul>
                </div>

            </div>
            <div class="simplesect">
                <div class="titlepage">
                    <div>
                        <div class="simple">
                            <h4 class="title"><a name="enum-limits"></a>Enumeration Limitations</h4>

                        </div>

                    </div>

                </div>
                <p>
                    An enumeration value cannot be an expression, even one that
                    evaluates to a string value.
                </p><p style="color:blue;">枚举值不能是表达式，甚至不能是计算结果为字符串值的表达式。</p><p></p><p>
                For example, this <a class="link" href="sql-syntax.html#create-table" title="13.1.18&nbsp;CREATE TABLE Syntax"><code class="literal">CREATE TABLE</code></a>
                statement does <span class="emphasis"><em>not</em></span> work because the
                <code class="literal">CONCAT</code> function cannot be used to construct
                an enumeration value:
            </p><p style="color:blue;">例如，此CREATE TABLE语句不起作用，因为concat函数不能用于构造枚举值：</p><p></p><pre data-lang="sql" class="programlisting">CREATE TABLE sizes (
    size ENUM('small', CONCAT('med','ium'), 'large')
);
</pre><p>
                You also cannot employ a user variable as an enumeration
                value. This pair of statements do <span class="emphasis"><em>not</em></span>
                work:
            </p><p style="color:blue;">也不能将用户变量用作枚举值。这对语句不起作用：</p><p></p><pre data-lang="sql" class="programlisting">SET @mysize = 'medium';

CREATE TABLE sizes (
    size ENUM('small', @mysize, 'large')
);
</pre><p>
                We strongly recommend that you do <span class="emphasis"><em>not</em></span> use
                numbers as enumeration values, because it does not save on
                storage over the appropriate
                <a class="link" href="data-types.html#integer-types" title="11.2.1&nbsp;Integer Types (Exact Value) - INTEGER, INT, SMALLINT, TINYINT, MEDIUMINT, BIGINT"><code class="literal">TINYINT</code></a> or
                <a class="link" href="data-types.html#integer-types" title="11.2.1&nbsp;Integer Types (Exact Value) - INTEGER, INT, SMALLINT, TINYINT, MEDIUMINT, BIGINT"><code class="literal">SMALLINT</code></a> type, and it is easy
                to mix up the strings and the underlying number values (which
                might not be the same) if you quote the
                <code class="literal">ENUM</code> values incorrectly. If you do use a
                number as an enumeration value, always enclose it in quotation
                marks. If the quotation marks are omitted, the number is
                regarded as an index. See <a class="xref" href="data-types.html#enum-literals" title="Handling of Enumeration Literals">Handling of Enumeration Literals</a> to
                see how even a quoted number could be mistakenly used as a
                numeric index value.
            </p><p style="color:blue;">我们强烈建议您不要使用数字作为枚举值，因为它不会保存在适当的tinyint或smallint类型的存储中，而且如果您不正确地引用枚举值，很容易混淆字符串和基础数字值（可能不同）。如果使用数字作为枚举值，请始终将其括在引号中。如果省略引号，则该数字视为索引。请参阅枚举文本的处理，以了解如何将引用的数字错误地用作数字索引值。</p><p></p><p>
                Duplicate values in the definition cause a warning, or an
                error if strict SQL mode is enabled.
            </p><p style="color:blue;">定义中的重复值会导致警告，如果启用了严格SQL模式，则会导致错误。</p><p></p>
            </div>

        </div>
        <div class="section">
            <div class="titlepage">
                <div>
                    <div>
                        <h3 class="title"><a name="set"></a>11.4.5&nbsp;The SET Type</h3>

                    </div>

                </div>

            </div>
            <a class="indexterm" name="idm140286859815840"></a><a class="indexterm" name="idm140286859814768"></a><p>
            A <code class="literal">SET</code> is a string object that can have zero
            or more values, each of which must be chosen from a list of
            permitted values specified when the table is created.
            <code class="literal">SET</code> column values that consist of multiple
            set members are specified with members separated by commas
            (<code class="literal">,</code>). A consequence of this is that
            <code class="literal">SET</code> member values should not themselves
            contain commas.
        </p><p style="color:blue;">集合是一个字符串对象，可以有零个或多个值，每个值都必须从创建表时指定的允许值列表中选择。由多个集合成员组成的集合列值由逗号（，）分隔的成员指定。其结果是，设置的成员值本身不应包含逗号。</p><p></p><p>
            For example, a column specified as <code class="literal">SET('one', 'two')
            NOT NULL</code> can have any of these values:
        </p><p style="color:blue;">例如，指定为set（'one'，'two'）且不为null的列可以具有以下任何值：</p><p></p><pre data-lang="simple" class="programlisting">''
'one'
'two'
'one,two'
</pre><p>
            A <a class="link" href="data-types.html#set" title="11.4.5&nbsp;The SET Type"><code class="literal">SET</code></a> column can have a maximum
            of 64 distinct members. A table can have no more than 255 unique
            element list definitions among its
            <a class="link" href="data-types.html#enum" title="11.4.4&nbsp;The ENUM Type"><code class="literal">ENUM</code></a> and
            <a class="link" href="data-types.html#set" title="11.4.5&nbsp;The SET Type"><code class="literal">SET</code></a> columns considered as a
            group. For more information on this limit, see
            <a class="xref" href="sql-syntax.html#limits-frm-file" title="Limits Imposed by .frm File Structure">Limits Imposed by .frm File Structure</a>.
        </p><p style="color:blue;">集合列最多可以有64个不同的成员。一个表的枚举列和集合列之间的唯一元素列表定义不能超过255个。有关此限制的详细信息，请参见.frm文件结构施加的限制。</p><p></p><p>
            Duplicate values in the definition cause a warning, or an error
            if strict SQL mode is enabled.
        </p><p style="color:blue;">定义中的重复值会导致警告，如果启用了严格SQL模式，则会导致错误。</p><p></p><a class="indexterm" name="idm140286859802256"></a><p>
            Trailing spaces are automatically deleted from
            <code class="literal">SET</code> member values in the table definition
            when a table is created.
        </p><p style="color:blue;">创建表时，将自动从表定义中的集合成员值中删除尾随空格。</p><p></p><p>
            When retrieved, values stored in a <code class="literal">SET</code> column
            are displayed using the lettercase that was used in the column
            definition. Note that <code class="literal">SET</code> columns can be
            assigned a character set and collation. For binary or
            case-sensitive collations, lettercase is taken into account when
            assigning values to the column.
        </p><p style="color:blue;">检索时，存储在集合列中的值将使用列定义中使用的字母大小写显示。请注意，可以为集合列分配字符集和排序规则。对于二进制或区分大小写的排序规则，将值分配给列时将考虑字母大小写。</p><p></p><p>
            MySQL stores <code class="literal">SET</code> values numerically, with the
            low-order bit of the stored value corresponding to the first set
            member. If you retrieve a <code class="literal">SET</code> value in a
            numeric context, the value retrieved has bits set corresponding
            to the set members that make up the column value. For example,
            you can retrieve numeric values from a <code class="literal">SET</code>
            column like this:
        </p><p style="color:blue;">mysql以数字方式存储设置值，存储值的低位对应于第一个set成员。如果在数字上下文中检索到一个设置值，则检索到的值具有与构成列值的设置成员相对应的位集。例如，可以从如下所示的集合列中检索数值：</p><p></p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT <em class="replaceable"><code>set_col</code></em>+0 FROM <em class="replaceable"><code>tbl_name</code></em>;</code></strong>
</pre><p>
            If a number is stored into a <code class="literal">SET</code> column, the
            bits that are set in the binary representation of the number
            determine the set members in the column value. For a column
            specified as <code class="literal">SET('a','b','c','d')</code>, the
            members have the following decimal and binary values.
        </p><p style="color:blue;">如果一个数字存储在一个集合列中，则在该数字的二进制表示形式中设置的位决定了列值中的集合成员。对于指定为set（'a'，'b'，'c'，'d'）的列，成员具有以下十进制和二进制值。</p><p></p>
            <div class="informaltable">
                <table summary="Decimal and binary values for members of a column specified as SET('a','b','c','d')."><colgroup><col width="15%"><col width="20%"><col width="20%"></colgroup><thead><tr>
                    <th scope="col"><code class="literal">SET</code> Member</th>
                    <th scope="col">Decimal Value</th>
                    <th scope="col">Binary Value</th>
                </tr></thead><tbody><tr>
                    <td scope="row"><code class="literal">'a'</code></td>
                    <td><code class="literal">1</code></td>
                    <td><code class="literal">0001</code></td>
                </tr><tr>
                    <td scope="row"><code class="literal">'b'</code></td>
                    <td><code class="literal">2</code></td>
                    <td><code class="literal">0010</code></td>
                </tr><tr>
                    <td scope="row"><code class="literal">'c'</code></td>
                    <td><code class="literal">4</code></td>
                    <td><code class="literal">0100</code></td>
                </tr><tr>
                    <td scope="row"><code class="literal">'d'</code></td>
                    <td><code class="literal">8</code></td>
                    <td><code class="literal">1000</code></td>
                </tr></tbody></table>
            </div>
            <p>
                If you assign a value of <code class="literal">9</code> to this column,
                that is <code class="literal">1001</code> in binary, so the first and
                fourth <code class="literal">SET</code> value members
                <code class="literal">'a'</code> and <code class="literal">'d'</code> are selected
                and the resulting value is <code class="literal">'a,d'</code>.
            </p><p style="color:blue;">如果将值9赋给此列，即1001（二进制），则选择第一个和第四个集值成员“a”和“d”，结果值为“a，d”。</p><p></p><p>
            For a value containing more than one <code class="literal">SET</code>
            element, it does not matter what order the elements are listed
            in when you insert the value. It also does not matter how many
            times a given element is listed in the value. When the value is
            retrieved later, each element in the value appears once, with
            elements listed according to the order in which they were
            specified at table creation time. Suppose that a column is
            specified as <code class="literal">SET('a','b','c','d')</code>:
        </p><p style="color:blue;">对于包含多个集合元素的值，插入该值时元素的列出顺序并不重要。给定元素在值中列出的次数也无关紧要。稍后检索该值时，该值中的每个元素都会出现一次，其中的元素将根据在表创建时指定它们的顺序列出。假设列被指定为set（'a'，'b'，'c'，'d'）：</p><p></p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>CREATE TABLE myset (col SET('a', 'b', 'c', 'd'));</code></strong>
</pre><p>
            If you insert the values <code class="literal">'a,d'</code>,
            <code class="literal">'d,a'</code>, <code class="literal">'a,d,d'</code>,
            <code class="literal">'a,d,a'</code>, and <code class="literal">'d,a,d'</code>:
        </p><p style="color:blue;">如果插入值“a，d”、“d，a”、“a，d，d”、“a，d，a”和“d，a，d”：</p><p></p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>INSERT INTO myset (col) VALUES </code></strong>
-&gt; ('a,d'), ('d,a'), ('a,d,a'), ('a,d,d'), ('d,a,d');
Query OK, 5 rows affected (0.01 sec)
Records: 5  Duplicates: 0  Warnings: 0
</pre><p>
            Then all these values appear as <code class="literal">'a,d'</code> when
            retrieved:
        </p><p style="color:blue;">检索时，所有这些值都显示为“a，d”：</p><p></p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT col FROM myset;</code></strong>
+------+
| col  |
+------+
| a,d  |
| a,d  |
| a,d  |
| a,d  |
| a,d  |
+------+
5 rows in set (0.04 sec)
</pre><p>
            If you set a <code class="literal">SET</code> column to an unsupported
            value, the value is ignored and a warning is issued:
        </p><p style="color:blue;">如果将集合列设置为不支持的值，则忽略该值并发出警告：</p><p></p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>INSERT INTO myset (col) VALUES ('a,d,d,s');</code></strong>
Query OK, 1 row affected, 1 warning (0.03 sec)

mysql&gt; <strong class="userinput"><code>SHOW WARNINGS;</code></strong>
+---------+------+------------------------------------------+
| Level   | Code | Message                                  |
+---------+------+------------------------------------------+
| Warning | 1265 | Data truncated for column 'col' at row 1 |
+---------+------+------------------------------------------+
1 row in set (0.04 sec)

mysql&gt; <strong class="userinput"><code>SELECT col FROM myset;</code></strong>
+------+
| col  |
+------+
| a,d  |
| a,d  |
| a,d  |
| a,d  |
| a,d  |
| a,d  |
+------+
6 rows in set (0.01 sec)
</pre><p>
            If strict SQL mode is enabled, attempts to insert invalid
            <code class="literal">SET</code> values result in an error.
        </p><p style="color:blue;">如果启用了严格SQL模式，则尝试插入无效的集值将导致错误。</p><p></p><p>
            <code class="literal">SET</code> values are sorted numerically.
            <code class="literal">NULL</code> values sort before
            non-<code class="literal">NULL</code> <code class="literal">SET</code> values.
        </p><p style="color:blue;">设定值按数字排序。空值在非空集值之前排序。</p><p></p><p>
            Functions such as <a class="link" href="functions.html#function_sum"><code class="literal">SUM()</code></a> or
            <a class="link" href="functions.html#function_avg"><code class="literal">AVG()</code></a> that expect a numeric
            argument cast the argument to a number if necessary. For
            <code class="literal">SET</code> values, the cast operation causes the
            numeric value to be used.
        </p><p style="color:blue;">需要数值参数的sum（）或avg（）函数在必要时将参数转换为数字。对于设置值，强制转换操作将使用数值。</p><p></p><p>
            Normally, you search for <code class="literal">SET</code> values using the
            <a class="link" href="functions.html#function_find-in-set"><code class="literal">FIND_IN_SET()</code></a> function or the
            <a class="link" href="functions.html#operator_like"><code class="literal">LIKE</code></a> operator:
        </p><p style="color:blue;">通常，使用find_in_set（）函数或类似运算符搜索设置值：</p><p></p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT * FROM <em class="replaceable"><code>tbl_name</code></em> WHERE FIND_IN_SET('<em class="replaceable"><code>value</code></em>',<em class="replaceable"><code>set_col</code></em>)&gt;0;</code></strong>
mysql&gt; <strong class="userinput"><code>SELECT * FROM <em class="replaceable"><code>tbl_name</code></em> WHERE <em class="replaceable"><code>set_col</code></em> LIKE '%<em class="replaceable"><code>value</code></em>%';</code></strong>
</pre><p>
            The first statement finds rows where
            <em class="replaceable"><code>set_col</code></em> contains the
            <em class="replaceable"><code>value</code></em> set member. The second is
            similar, but not the same: It finds rows where
            <em class="replaceable"><code>set_col</code></em> contains
            <em class="replaceable"><code>value</code></em> anywhere, even as a substring
            of another set member.
        </p><p style="color:blue;">第一条语句查找集合列包含值集成员的行。第二个类似，但不相同：它查找集合列在任何地方包含值的行，甚至作为另一个集合成员的子字符串。</p><p></p><p>
            The following statements also are permitted:
        </p><p style="color:blue;">还允许以下声明：</p><p></p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT * FROM <em class="replaceable"><code>tbl_name</code></em> WHERE <em class="replaceable"><code>set_col</code></em> &amp; 1;</code></strong>
mysql&gt; <strong class="userinput"><code>SELECT * FROM <em class="replaceable"><code>tbl_name</code></em> WHERE <em class="replaceable"><code>set_col</code></em> = '<em class="replaceable"><code>val1</code></em>,<em class="replaceable"><code>val2</code></em>';</code></strong>
</pre><p>
            The first of these statements looks for values containing the
            first set member. The second looks for an exact match. Be
            careful with comparisons of the second type. Comparing set
            values to
            <code class="literal">'<em class="replaceable"><code>val1</code></em>,<em class="replaceable"><code>val2</code></em>'</code>
            returns different results than comparing values to
            <code class="literal">'<em class="replaceable"><code>val2</code></em>,<em class="replaceable"><code>val1</code></em>'</code>.
            You should specify the values in the same order they are listed
            in the column definition.
        </p><p style="color:blue;">这些语句中的第一个语句查找包含第一个set成员的值。第二个要找一个完全匹配的。小心比较第二种类型。将集合值与“val1，val2”进行比较所返回的结果与将值与“val2，val1”进行比较所返回的结果不同。您应该按照列定义中列出的顺序指定值。</p><p></p><p>
            To determine all possible values for a <code class="literal">SET</code>
            column, use <code class="literal">SHOW COLUMNS FROM
            <em class="replaceable"><code>tbl_name</code></em> LIKE
            <em class="replaceable"><code>set_col</code></em></code> and parse the
            <code class="literal">SET</code> definition in the <code class="literal">Type</code>
            column of the output.
        </p><p style="color:blue;">若要确定集合列的所有可能值，请使用来自tbl_name的show columns like set_col并分析输出的type列中的集合定义。</p><p></p><p>
            In the C API, <code class="literal">SET</code> values are returned as
            strings. For information about using result set metadata to
            distinguish them from other strings, see
            <a class="xref" href="connectors-apis.html#c-api-data-structures" title="27.8.5&nbsp;C API Data Structures">Section&nbsp;27.8.5, “C API Data Structures”</a>.
        </p><p style="color:blue;">在C API中，设置值作为字符串返回。有关使用结果集元数据将它们与其他字符串区分开来的信息，请参阅第27.8.5节“C API数据结构”。</p><p></p>
        </div>

    </div>
    <div class="section">
        <div class="titlepage">
            <div>
                <div>
                    <h2 class="title" style="clear: both"><a name="spatial-types"></a>11.5&nbsp;Spatial Data Types</h2>

                </div>

            </div>

        </div>
        <div class="toc">
            <dl class="toc"><dt><span class="section"><a href="data-types.html#spatial-type-overview">11.5.1 Spatial Data Types</a></span></dt><dt><span class="section"><a href="data-types.html#opengis-geometry-model">11.5.2 The OpenGIS Geometry Model</a></span></dt><dt><span class="section"><a href="data-types.html#gis-data-formats">11.5.3 Supported Spatial Data Formats</a></span></dt><dt><span class="section"><a href="data-types.html#geometry-well-formedness-validity">11.5.4 Geometry Well-Formedness and Validity</a></span></dt><dt><span class="section"><a href="data-types.html#creating-spatial-columns">11.5.5 Creating Spatial Columns</a></span></dt><dt><span class="section"><a href="data-types.html#populating-spatial-columns">11.5.6 Populating Spatial Columns</a></span></dt><dt><span class="section"><a href="data-types.html#fetching-spatial-data">11.5.7 Fetching Spatial Data</a></span></dt><dt><span class="section"><a href="data-types.html#optimizing-spatial-analysis">11.5.8 Optimizing Spatial Analysis</a></span></dt><dt><span class="section"><a href="data-types.html#creating-spatial-indexes">11.5.9 Creating Spatial Indexes</a></span></dt><dt><span class="section"><a href="data-types.html#using-spatial-indexes">11.5.10 Using Spatial Indexes</a></span></dt></dl>
        </div>
        <a class="indexterm" name="idm140286859705872"></a><a class="indexterm" name="idm140286859704800"></a><a class="indexterm" name="idm140286859703712"></a><a class="indexterm" name="idm140286859702624"></a><a class="indexterm" name="idm140286859701552"></a><a class="indexterm" name="idm140286859700464"></a><p>
        The <a class="ulink" href="http://www.opengeospatial.org" target="_top">Open Geospatial
        Consortium</a> (OGC) is an international consortium of more
        than 250 companies, agencies, and universities participating in
        the development of publicly available conceptual solutions that
        can be useful with all kinds of applications that manage spatial
        data.
    </p><p style="color:blue;">开放地理空间联盟（ogc）是一个由250多家公司、机构和大学组成的国际联盟，参与开发可用于管理空间数据的各种应用程序的公开概念解决方案。</p><p></p><p>
        The Open Geospatial Consortium publishes the
        <em class="citetitle">OpenGIS® Implementation Standard for Geographic
            information - Simple Feature Access - Part 2: SQL
            Option</em>, a document that proposes several conceptual
        ways for extending an SQL RDBMS to support spatial data. This
        specification is available from the OGC website at
        <a class="ulink" href="http://www.opengeospatial.org/standards/sfs" target="_top">http://www.opengeospatial.org/standards/sfs</a>.
    </p><p style="color:blue;">open geospatial consortium发布了opengis®地理信息实现标准-简单功能访问-第2部分：sql选项，该文档提出了几种扩展sql rdbms以支持空间数据的概念方法。本规范可从OGC网站http://www.opengeospatial.org/standards/sfs获得。</p><p></p><p>
        Following the OGC specification, MySQL implements spatial
        extensions as a subset of the <span class="bold"><strong>SQL with
      Geometry Types</strong></span> environment. This term refers to an SQL
        environment that has been extended with a set of geometry types. A
        geometry-valued SQL column is implemented as a column that has a
        geometry type. The specification describes a set of SQL geometry
        types, as well as functions on those types to create and analyze
        geometry values.
    </p><p style="color:blue;">遵循ogc规范，mysql将空间扩展作为sql with geometry types环境的一个子集来实现。这个术语指的是一个sql环境，它已经用一组几何类型进行了扩展。几何值SQL列实现为具有几何类型的列。规范描述了一组sql几何体类型，以及用于创建和分析几何体值的这些类型的函数。</p><p></p><p>
        MySQL spatial extensions enable the generation, storage, and
        analysis of geographic features:
    </p><p style="color:blue;">mysql空间扩展支持生成、存储和分析地理特征：</p><p></p>
        <div class="itemizedlist">
            <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                Data types for representing spatial values
            </p><p style="color:blue;">表示空间值的数据类型</p><p></p></li><li class="listitem"><p>
                Functions for manipulating spatial values
            </p><p style="color:blue;">操作空间值的函数</p><p></p></li><li class="listitem"><p>
                Spatial indexing for improved access times to spatial columns
            </p><p style="color:blue;">提高空间柱访问次数的空间索引</p><p></p></li></ul>
        </div>
        <p>
            The spatial data types and functions are available for
            <a class="link" href="storage-engines.html#myisam-storage-engine" title="15.2&nbsp;The MyISAM Storage Engine"><code class="literal">MyISAM</code></a>,
            <a class="link" href="innodb-storage-engine.html" title="Chapter&nbsp;14&nbsp;The InnoDB Storage Engine"><code class="literal">InnoDB</code></a>,
            <a class="link" href="mysql-cluster.html" title="Chapter&nbsp;21&nbsp;MySQL NDB Cluster 7.5 and NDB Cluster 7.6"><code class="literal">NDB</code></a>, and
            <a class="link" href="storage-engines.html#archive-storage-engine" title="15.5&nbsp;The ARCHIVE Storage Engine"><code class="literal">ARCHIVE</code></a> tables. For indexing spatial
            columns, <code class="literal">MyISAM</code> and <code class="literal">InnoDB</code>
            support both <code class="literal">SPATIAL</code> and
            non-<code class="literal">SPATIAL</code> indexes. The other storage engines
            support non-<code class="literal">SPATIAL</code> indexes, as described in
            <a class="xref" href="sql-syntax.html#create-index" title="13.1.14&nbsp;CREATE INDEX Syntax">Section&nbsp;13.1.14, “CREATE INDEX Syntax”</a>.
        </p><p style="color:blue;">空间数据类型和功能可用于myisam、innodb、ndb和archive表。对于索引空间列，MyISAM和InNDB支持空间索引和非空间索引。其他存储引擎支持非空间索引，如第13.1.14节“创建索引语法”所述。</p><p></p><a class="indexterm" name="idm140286859680096"></a><p>
        A <span class="bold"><strong>geographic feature</strong></span> is anything
        in the world that has a location. A feature can be:
    </p><p style="color:blue;">地理特征是指世界上任何有地理位置的事物。功能可以是：</p><p></p>
        <div class="itemizedlist">
            <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                An entity. For example, a mountain, a pond, a city.
            </p><p style="color:blue;">一个实体。例如，一座山，一个池塘，一座城市。</p><p></p></li><li class="listitem"><p>
                A space. For example, town district, the tropics.
            </p><p style="color:blue;">一个空间。例如，市区，热带地区。</p><p></p></li><li class="listitem"><p>
                A definable location. For example, a crossroad, as a
                particular place where two streets intersect.
            </p><p style="color:blue;">可确定的地点。例如，十字路口，作为两条街道相交的特定地方。</p><p></p></li></ul>
        </div>
        <a class="indexterm" name="idm140286859674832"></a><p>
        Some documents use the term <span class="bold"><strong>geospatial
      feature</strong></span> to refer to geographic features.
    </p><p style="color:blue;">有些文档使用术语“地理空间要素”来指代地理要素。</p><p></p><a class="indexterm" name="idm140286859672576"></a><p>
        <span class="bold"><strong>Geometry</strong></span> is another word that
        denotes a geographic feature. Originally the word
        <span class="bold"><strong>geometry</strong></span> meant measurement of the
        earth. Another meaning comes from cartography, referring to the
        geometric features that cartographers use to map the world.
    </p><p style="color:blue;">几何是另一个表示地理特征的词。最初几何这个词的意思是测量地球。另一个含义来自制图，指的是制图者用来绘制世界地图的几何特征。</p><p></p><p>
        The discussion here considers these terms synonymous:
        <span class="bold"><strong>geographic feature</strong></span>,
        <span class="bold"><strong>geospatial feature</strong></span>,
        <span class="bold"><strong>feature</strong></span>, or
        <span class="bold"><strong>geometry</strong></span>. The term most commonly
        used is <span class="bold"><strong>geometry</strong></span>, defined as
        <span class="emphasis"><em>a point or an aggregate of points representing anything
      in the world that has a location</em></span>.
    </p><p style="color:blue;">这里的讨论认为这些术语同义：地理特征、地理空间特征、特征或几何。最常用的术语是几何，定义为一个点或点的集合，表示世界上任何具有位置的事物。</p><p></p><p>
        The following material covers these topics:
    </p><p style="color:blue;">以下材料涵盖这些主题：</p><p></p>
        <div class="itemizedlist">
            <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                The spatial data types implemented in MySQL model
            </p><p style="color:blue;">mysql模型中空间数据类型的实现</p><p></p></li><li class="listitem"><p>
                The basis of the spatial extensions in the OpenGIS geometry
                model
            </p><p style="color:blue;">opengis几何模型空间扩展的基础</p><p></p></li><li class="listitem"><p>
                Data formats for representing spatial data
            </p><p style="color:blue;">表示空间数据的数据格式</p><p></p></li><li class="listitem"><p>
                How to use spatial data in MySQL
            </p><p style="color:blue;">如何在mysql中使用空间数据</p><p></p></li><li class="listitem"><p>
                Use of indexing for spatial data
            </p><p style="color:blue;">空间数据索引技术的应用</p><p></p></li><li class="listitem"><p>
                MySQL differences from the OpenGIS specification
            </p><p style="color:blue;">mysql与opengis规范的区别</p><p></p></li></ul>
        </div>
        <p>
            For information about functions that operate on spatial data, see
            <a class="xref" href="functions.html#spatial-analysis-functions" title="12.16&nbsp;Spatial Analysis Functions">Section&nbsp;12.16, “Spatial Analysis Functions”</a>.
        </p><p style="color:blue;">有关操作空间数据的函数的信息，请参见第12.16节“空间分析函数”。</p><p></p>
        <h3><a name="idm140286859657600"></a>MySQL GIS Conformance and Compatibility</h3>
        <p>
            MySQL does not implement the following GIS features:
        </p><p style="color:blue;">MySQL没有实现以下地理信息系统功能：</p><p></p>
        <div class="itemizedlist">
            <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                Additional Metadata Views
            </p><p style="color:blue;">其他元数据视图</p><p></p><p>
                OpenGIS specifications propose several additional metadata
                views. For example, a system view named
                <code class="literal">GEOMETRY_COLUMNS</code> contains a description of
                geometry columns, one row for each geometry column in the
                database.
            </p><p style="color:blue;">opengis规范提出了一些额外的元数据视图。例如，名为geometry_columns的系统视图包含对geometry列的描述，数据库中每个geometry列对应一行。</p><p></p></li><li class="listitem"><p>
                The OpenGIS function <a class="link" href="functions.html#function_length"><code class="literal">Length()</code></a>
                on <code class="literal">LineString</code> and
                <code class="literal">MultiLineString</code> should be called in MySQL
                as <a class="link" href="functions.html#function_st-length"><code class="literal">ST_Length()</code></a>
            </p><p style="color:blue;">在mysql中，linestring和multilinestring上的opengis函数length（）应作为st_length（）调用</p><p></p><p>
                The problem is that there is an existing SQL function
                <a class="link" href="functions.html#function_length"><code class="literal">Length()</code></a> that calculates the
                length of string values, and sometimes it is not possible to
                distinguish whether the function is called in a textual or
                spatial context.
            </p><p style="color:blue;">问题在于，存在一个计算字符串值长度的现有SQL函数长度（），有时无法区分函数是否在文本或空间上下文中调用。</p><p></p></li></ul>
        </div>
        <h3><a name="idm140286859646928"></a>Additional Resources</h3>
        <p>
            The Open Geospatial Consortium publishes the
            <em class="citetitle">OpenGIS® Implementation Standard for Geographic
                information - Simple feature access - Part 2: SQL
                option</em>, a document that proposes several conceptual
            ways for extending an SQL RDBMS to support spatial data. The Open
            Geospatial Consortium (OGC) maintains a website at
            <a class="ulink" href="http://www.opengeospatial.org/" target="_top">http://www.opengeospatial.org/</a>. The specification
            is available there at
            <a class="ulink" href="http://www.opengeospatial.org/standards/sfs" target="_top">http://www.opengeospatial.org/standards/sfs</a>. It
            contains additional information relevant to the material here.
        </p><p style="color:blue;">open geospatial consortium发布了opengis®地理信息实现标准-简单功能访问-第2部分：sql选项，该文档提出了几种扩展sql rdbms以支持空间数据的概念方法。开放地理空间联盟（ogc）在http://www.open geospatial.org/上维护一个网站。该规范可在http://www.opengeospatial.org/standards/sfs上获得。它包含与此处材料相关的附加信息。</p><p></p><p>
        If you have questions or concerns about the use of the spatial
        extensions to MySQL, you can discuss them in the GIS forum:
        <a class="ulink" href="https://forums.mysql.com/list.php?23" target="_top">https://forums.mysql.com/list.php?23</a>.
    </p><p style="color:blue;">如果您对MySQL空间扩展的使用有疑问或担忧，可以在地理信息系统论坛：https://forums.mysql.com/list.php中进行讨论。23。</p><p></p>
        <div class="section">

            <div class="titlepage">
                <div>
                    <div>
                        <h3 class="title"><a name="spatial-type-overview"></a>11.5.1&nbsp;Spatial Data Types</h3>
                    </div>
                </div>
            </div>
            <a class="indexterm" name="idm140286859641456"></a><a class="indexterm" name="idm140286859640384"></a><a class="indexterm" name="idm140286859639312"></a><a class="indexterm" name="idm140286859638240"></a><a class="indexterm" name="idm140286859637168"></a><a class="indexterm" name="idm140286859636096"></a><a class="indexterm" name="idm140286859635008"></a><a class="indexterm" name="idm140286859633936"></a><a class="indexterm" name="idm140286859632848"></a><a class="indexterm" name="idm140286859631360"></a><a class="indexterm" name="idm140286859629872"></a><a class="indexterm" name="idm140286859628384"></a><a class="indexterm" name="idm140286859626896"></a><a class="indexterm" name="idm140286859625408"></a><a class="indexterm" name="idm140286859623920"></a><a class="indexterm" name="idm140286859622432"></a><p>
            MySQL has spatial data types that correspond to OpenGIS classes.
            The basis for these types is described in
            <a class="xref" href="data-types.html#opengis-geometry-model" title="11.5.2&nbsp;The OpenGIS Geometry Model">Section&nbsp;11.5.2, “The OpenGIS Geometry Model”</a>.
        </p><p style="color:blue;">mysql具有与opengis类相对应的空间数据类型。第11.5.2节“OpenGIS几何模型”描述了这些类型的基础。</p><p></p><p>
            Some spatial data types hold single geometry values:
        </p><p style="color:blue;">某些空间数据类型包含单个几何图形值：</p><p></p>
            <div class="itemizedlist">
                <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                    <code class="literal">GEOMETRY</code>
                </p><p style="color:blue;">几何学</p><p></p></li><li class="listitem"><p>
                    <code class="literal">POINT</code>
                </p><p style="color:blue;">点</p><p></p></li><li class="listitem"><p>
                    <code class="literal">LINESTRING</code>
                </p><p style="color:blue;">线串</p><p></p></li><li class="listitem"><p>
                    <code class="literal">POLYGON</code>
                </p><p style="color:blue;">多边形</p><p></p></li></ul>
            </div>
            <p>
                <code class="literal">GEOMETRY</code> can store geometry values of any
                type. The other single-value types (<code class="literal">POINT</code>,
                <code class="literal">LINESTRING</code>, and <code class="literal">POLYGON</code>)
                restrict their values to a particular geometry type.
            </p><p style="color:blue;">几何图形可以存储任何类型的几何图形值。其他单值类型（点、线串和多边形）将其值限制为特定的几何类型。</p><p></p><p>
            The other spatial data types hold collections of values:
        </p><p style="color:blue;">其他空间数据类型包含值的集合：</p><p></p>
            <div class="itemizedlist">
                <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                    <code class="literal">MULTIPOINT</code>
                </p><p style="color:blue;">多点</p><p></p></li><li class="listitem"><p>
                    <code class="literal">MULTILINESTRING</code>
                </p><p style="color:blue;">多行线</p><p></p></li><li class="listitem"><p>
                    <code class="literal">MULTIPOLYGON</code>
                </p><p style="color:blue;">多多边形</p><p></p></li><li class="listitem"><p>
                    <code class="literal">GEOMETRYCOLLECTION</code>
                </p><p style="color:blue;">几何集合</p><p></p></li></ul>
            </div>
            <p>
                <code class="literal">GEOMETRYCOLLECTION</code> can store a collection of
                objects of any type. The other collection types
                (<code class="literal">MULTIPOINT</code>,
                <code class="literal">MULTILINESTRING</code>, and
                <code class="literal">MULTIPOLYGON</code>) restrict collection members to
                those having a particular geometry type.
            </p><p style="color:blue;">geometryCollection可以存储任何类型的对象的集合。其他集合类型（multipoint、multilinestring和multipolygon）将集合成员限制为具有特定几何体类型的成员。</p><p></p><p>
            Example: To create a table named <code class="literal">geom</code> that
            has a column named <code class="literal">g</code> that can store values of
            any geometry type, use this statement:
        </p><p style="color:blue;">示例：要创建一个名为geom的表，该表具有一个名为g的列，该列可以存储任何几何类型的值，请使用以下语句：</p><p></p><pre data-lang="sql" class="programlisting">CREATE TABLE geom (g GEOMETRY);
</pre><p>
            <code class="literal">SPATIAL</code> indexes can be created on
            <code class="literal">NOT NULL</code> spatial columns, so if you plan to
            index the column, declare it <code class="literal">NOT NULL</code>:
        </p><p style="color:blue;">可以在不为空的空间列上创建空间索引，因此，如果计划为该列编制索引，请将其声明为不为空：</p><p></p><pre data-lang="sql" class="programlisting">CREATE TABLE geom (g GEOMETRY NOT NULL);
</pre><p>
            For other examples showing how to use spatial data types in
            MySQL, see <a class="xref" href="data-types.html#creating-spatial-columns" title="11.5.5&nbsp;Creating Spatial Columns">Section&nbsp;11.5.5, “Creating Spatial Columns”</a>.
        </p><p style="color:blue;">有关如何在mysql中使用空间数据类型的其他示例，请参见第11.5.5节“创建空间列”。</p><p></p>
        </div>
        <div class="section">
            <div class="titlepage">
                <div>
                    <div>
                        <h3 class="title"><a name="opengis-geometry-model"></a>11.5.2&nbsp;The OpenGIS Geometry Model</h3>

                    </div>

                </div>

            </div>
            <div class="toc">
                <dl class="toc"><dt><span class="section"><a href="data-types.html#gis-geometry-class-hierarchy">11.5.2.1 The Geometry Class Hierarchy</a></span></dt><dt><span class="section"><a href="data-types.html#gis-class-geometry">11.5.2.2 Geometry Class</a></span></dt><dt><span class="section"><a href="data-types.html#gis-class-point">11.5.2.3 Point Class</a></span></dt><dt><span class="section"><a href="data-types.html#gis-class-curve">11.5.2.4 Curve Class</a></span></dt><dt><span class="section"><a href="data-types.html#gis-class-linestring">11.5.2.5 LineString Class</a></span></dt><dt><span class="section"><a href="data-types.html#gis-class-surface">11.5.2.6 Surface Class</a></span></dt><dt><span class="section"><a href="data-types.html#gis-class-polygon">11.5.2.7 Polygon Class</a></span></dt><dt><span class="section"><a href="data-types.html#gis-class-geometrycollection">11.5.2.8 GeometryCollection Class</a></span></dt><dt><span class="section"><a href="data-types.html#gis-class-multipoint">11.5.2.9 MultiPoint Class</a></span></dt><dt><span class="section"><a href="data-types.html#gis-class-multicurve">11.5.2.10 MultiCurve Class</a></span></dt><dt><span class="section"><a href="data-types.html#gis-class-multilinestring">11.5.2.11 MultiLineString Class</a></span></dt><dt><span class="section"><a href="data-types.html#gis-class-multisurface">11.5.2.12 MultiSurface Class</a></span></dt><dt><span class="section"><a href="data-types.html#gis-class-multipolygon">11.5.2.13 MultiPolygon Class</a></span></dt></dl>
            </div>
            <p>
                The set of geometry types proposed by OGC's
                <span class="bold"><strong>SQL with Geometry Types</strong></span>
                environment is based on the <span class="bold"><strong>OpenGIS
        Geometry Model</strong></span>. In this model, each geometric object
                has the following general properties:
            </p><p style="color:blue;">ogc的sql几何类型环境提出的几何类型集合是基于opengis几何模型的。在此模型中，每个几何对象都具有以下常规属性：</p><p></p>
            <div class="itemizedlist">
                <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                    It is associated with a spatial reference system, which
                    describes the coordinate space in which the object is
                    defined.
                </p><p style="color:blue;">它与空间参照系相关联，该参照系描述定义对象的坐标空间。</p><p></p></li><li class="listitem"><p>
                    It belongs to some geometry class.
                </p><p style="color:blue;">它属于某个几何类。</p><p></p></li></ul>
            </div>
            <div class="section">
                <div class="titlepage">
                    <div>
                        <div>
                            <h4 class="title"><a name="gis-geometry-class-hierarchy"></a>11.5.2.1&nbsp;The Geometry Class Hierarchy</h4>

                        </div>

                    </div>

                </div>
                <p>
                    The geometry classes define a hierarchy as follows:
                </p><p style="color:blue;">几何类定义层次结构如下：</p><p></p>
                <div class="itemizedlist">
                    <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                        <code class="literal">Geometry</code> (noninstantiable)
                    </p><p style="color:blue;">几何（不可实例化）</p><p></p>
                        <div class="itemizedlist">
                            <ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
                                <code class="literal">Point</code> (instantiable)
                            </p><p style="color:blue;">点（可实例化）</p><p></p></li><li class="listitem"><p>
                                <code class="literal">Curve</code> (noninstantiable)
                            </p><p style="color:blue;">曲线（不可逆）</p><p></p>
                                <div class="itemizedlist">
                                    <ul class="itemizedlist" style="list-style-type: square; "><li class="listitem"><p>
                                        <code class="literal">LineString</code> (instantiable)
                                    </p><p style="color:blue;">linestring（可实例化）</p><p></p>
                                        <div class="itemizedlist">
                                            <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                                                <code class="literal">Line</code>
                                            </p><p style="color:blue;">生产线</p><p></p></li><li class="listitem"><p>
                                                <code class="literal">LinearRing</code>
                                            </p><p style="color:blue;">划线</p><p></p></li></ul>
                                        </div>
                                    </li></ul>
                                </div>
                            </li><li class="listitem"><p>
                                <code class="literal">Surface</code> (noninstantiable)
                            </p><p style="color:blue;">表面（不可接触）</p><p></p>
                                <div class="itemizedlist">
                                    <ul class="itemizedlist" style="list-style-type: square; "><li class="listitem"><p>
                                        <code class="literal">Polygon</code> (instantiable)
                                    </p><p style="color:blue;">多边形（可实例化）</p><p></p></li></ul>
                                </div>
                            </li><li class="listitem"><p>
                                <code class="literal">GeometryCollection</code> (instantiable)
                            </p><p style="color:blue;">几何集合（可实例化）</p><p></p>
                                <div class="itemizedlist">
                                    <ul class="itemizedlist" style="list-style-type: square; "><li class="listitem"><p>
                                        <code class="literal">MultiPoint</code> (instantiable)
                                    </p><p style="color:blue;">多点（可实例化）</p><p></p></li><li class="listitem"><p>
                                        <code class="literal">MultiCurve</code> (noninstantiable)
                                    </p><p style="color:blue;">多曲线（不可逆）</p><p></p>
                                        <div class="itemizedlist">
                                            <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                                                <code class="literal">MultiLineString</code>
                                                (instantiable)
                                            </p><p style="color:blue;">多行（可实例化）</p><p></p></li></ul>
                                        </div>
                                    </li><li class="listitem"><p>
                                        <code class="literal">MultiSurface</code> (noninstantiable)
                                    </p><p style="color:blue;">多曲面（不可实例化）</p><p></p>
                                        <div class="itemizedlist">
                                            <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                                                <code class="literal">MultiPolygon</code> (instantiable)
                                            </p><p style="color:blue;">多多边形（可实例化）</p><p></p></li></ul>
                                        </div>
                                    </li></ul>
                                </div>
                            </li></ul>
                        </div>
                    </li></ul>
                </div>
                <p>
                    It is not possible to create objects in noninstantiable
                    classes. It is possible to create objects in instantiable
                    classes. All classes have properties, and instantiable classes
                    may also have assertions (rules that define valid class
                    instances).
                </p><p style="color:blue;">不可能在不可实例化的类中创建对象。可以在可实例化类中创建对象。所有类都有属性，可实例化类也可能有断言（定义有效类实例的规则）。</p><p></p><p>
                <code class="literal">Geometry</code> is the base class. It is an
                abstract class. The instantiable subclasses of
                <code class="literal">Geometry</code> are restricted to zero-, one-, and
                two-dimensional geometric objects that exist in
                two-dimensional coordinate space. All instantiable geometry
                classes are defined so that valid instances of a geometry
                class are topologically closed (that is, all defined
                geometries include their boundary).
            </p><p style="color:blue;">几何是基类。这是一个抽象的类。实例化的几何子类被限制在二维坐标空间中存在的零、一维和二维几何对象。定义了所有可实例化的几何类，以便几何类的有效实例在拓扑上是闭合的（即，所有已定义的几何体都包含其边界）。</p><p></p><p>
                The base <code class="literal">Geometry</code> class has subclasses for
                <code class="literal">Point</code>, <code class="literal">Curve</code>,
                <code class="literal">Surface</code>, and
                <code class="literal">GeometryCollection</code>:
            </p><p style="color:blue;">基本几何类具有点、曲线、曲面和几何集合的子类：</p><p></p>
                <div class="itemizedlist">
                    <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                        <code class="literal">Point</code> represents zero-dimensional
                        objects.
                    </p><p style="color:blue;">点表示零维对象。</p><p></p></li><li class="listitem"><p>
                        <code class="literal">Curve</code> represents one-dimensional
                        objects, and has subclass <code class="literal">LineString</code>,
                        with sub-subclasses <code class="literal">Line</code> and
                        <code class="literal">LinearRing</code>.
                    </p><p style="color:blue;">曲线表示一维对象，具有子类linestring、子类line和linearring。</p><p></p></li><li class="listitem"><p>
                        <code class="literal">Surface</code> is designed for two-dimensional
                        objects and has subclass <code class="literal">Polygon</code>.
                    </p><p style="color:blue;">曲面是为二维对象设计的，具有子类多边形。</p><p></p></li><li class="listitem"><p>
                        <code class="literal">GeometryCollection</code> has specialized
                        zero-, one-, and two-dimensional collection classes named
                        <code class="literal">MultiPoint</code>,
                        <code class="literal">MultiLineString</code>, and
                        <code class="literal">MultiPolygon</code> for modeling geometries
                        corresponding to collections of <code class="literal">Points</code>,
                        <code class="literal">LineStrings</code>, and
                        <code class="literal">Polygons</code>, respectively.
                        <code class="literal">MultiCurve</code> and
                        <code class="literal">MultiSurface</code> are introduced as abstract
                        superclasses that generalize the collection interfaces to
                        handle <code class="literal">Curves</code> and
                        <code class="literal">Surfaces</code>.
                    </p><p style="color:blue;">geometrycollection具有专门的零、一和二维集合类multipoint、multilinestring和multipolygon，用于分别对点、线串和多边形集合对应的几何体进行建模。多曲线和多曲面作为抽象超类被引入，该超类将集合接口推广到处理曲线和曲面。</p><p></p></li></ul>
                </div>
                <p>
                    <code class="literal">Geometry</code>, <code class="literal">Curve</code>,
                    <code class="literal">Surface</code>, <code class="literal">MultiCurve</code>, and
                    <code class="literal">MultiSurface</code> are defined as noninstantiable
                    classes. They define a common set of methods for their
                    subclasses and are included for extensibility.
                </p><p style="color:blue;">几何、曲线、曲面、多曲线和多曲面被定义为不可实例化类。它们为它们的子类定义了一组公共方法，并且为了可扩展性而包含了这些方法。</p><p></p><p>
                <code class="literal">Point</code>, <code class="literal">LineString</code>,
                <code class="literal">Polygon</code>,
                <code class="literal">GeometryCollection</code>,
                <code class="literal">MultiPoint</code>,
                <code class="literal">MultiLineString</code>, and
                <code class="literal">MultiPolygon</code> are instantiable classes.
            </p><p style="color:blue;">point、linestring、polygon、geometrycollection、multipoint、multilinestring和multipolygon是可实例化的类。</p><p></p>
            </div>
            <div class="section">
                <div class="titlepage">
                    <div>
                        <div>
                            <h4 class="title"><a name="gis-class-geometry"></a>11.5.2.2&nbsp;Geometry Class</h4>

                        </div>

                    </div>

                </div>
                <p>
                    <code class="literal">Geometry</code> is the root class of the
                    hierarchy. It is a noninstantiable class but has a number of
                    properties, described in the following list, that are common
                    to all geometry values created from any of the
                    <code class="literal">Geometry</code> subclasses. Particular subclasses
                    have their own specific properties, described later.
                </p><p style="color:blue;">几何体是层次结构的根类。它是一个不可实例化的类，但有许多属性，如以下列表中所述，这些属性对于从任何几何子类创建的所有几何值都是通用的。特定的子类有它们自己的特定属性，稍后将进行描述。</p><p></p><p>
                <span class="bold"><strong>Geometry Properties</strong></span>
            </p><p style="color:blue;">几何特性</p><p></p><p>
                A geometry value has the following properties:
            </p><p style="color:blue;">几何体值具有以下特性：</p><p></p>
                <div class="itemizedlist">
                    <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                        Its <span class="bold"><strong>type</strong></span>. Each geometry
                        belongs to one of the instantiable classes in the
                        hierarchy.
                    </p><p style="color:blue;">它的类型。每个几何体都属于层次中的一个可实例化类。</p><p></p></li><li class="listitem"><p>
                        Its <span class="bold"><strong>SRID</strong></span>, or spatial
                        reference identifier. This value identifies the geometry's
                        associated spatial reference system that describes the
                        coordinate space in which the geometry object is defined.
                    </p><p style="color:blue;">它的srid或空间引用标识符。该值标识几何图形的关联空间参照系，该参照系描述定义几何图形对象的坐标空间。</p><p></p><p>
                        In MySQL, the SRID value is an integer associated with the
                        geometry value. The maximum usable SRID value is
                        2<sup>32</sup>−1. If a larger value
                        is given, only the lower 32 bits are used. All
                        computations are done assuming SRID 0, regardless of the
                        actual SRID value. SRID 0 represents an infinite flat
                        Cartesian plane with no units assigned to its axes.
                    </p><p style="color:blue;">在mysql中，srid值是与几何体值关联的整数。最大可用值为232×1。如果给定较大的值，则仅使用较低的32位。所有计算都是假设srid为0完成的，而不考虑实际的srid值。srid 0表示无限平面笛卡尔平面，其轴没有指定单位。</p><p></p></li><li class="listitem"><p>
                        Its <span class="bold"><strong>coordinates</strong></span> in its
                        spatial reference system, represented as double-precision
                        (8-byte) numbers. All nonempty geometries include at least
                        one pair of (X,Y) coordinates. Empty geometries contain no
                        coordinates.
                    </p><p style="color:blue;">它在空间参考系中的坐标，用双精度（8字节）数字表示。所有非空几何体至少包含一对（x，y）坐标。空几何图形不包含坐标。</p><p></p><p>
                        Coordinates are related to the SRID. For example, in
                        different coordinate systems, the distance between two
                        objects may differ even when objects have the same
                        coordinates, because the distance on the
                        <span class="bold"><strong>planar</strong></span> coordinate system
                        and the distance on the
                        <span class="bold"><strong>geodetic</strong></span> system
                        (coordinates on the Earth's surface) are different things.
                    </p><p style="color:blue;">坐标与srid相关。例如，在不同的坐标系中，即使对象具有相同的坐标，两个对象之间的距离也可能不同，因为平面坐标系上的距离和大地坐标系（地球表面上的坐标）上的距离是不同的。</p><p></p></li><li class="listitem"><p>
                        Its <span class="bold"><strong>interior</strong></span>,
                        <span class="bold"><strong>boundary</strong></span>, and
                        <span class="bold"><strong>exterior</strong></span>.
                    </p><p style="color:blue;">它的内部、边界和外部。</p><p></p><p>
                        Every geometry occupies some position in space. The
                        exterior of a geometry is all space not occupied by the
                        geometry. The interior is the space occupied by the
                        geometry. The boundary is the interface between the
                        geometry's interior and exterior.
                    </p><p style="color:blue;">每一个几何体在空间中都占有一定的位置。几何体的外部是几何体未占用的所有空间。内部是几何体占用的空间。边界是几何体内部和外部之间的界面。</p><p></p></li><li class="listitem"><p>
                        Its <span class="bold"><strong>MBR</strong></span> (minimum bounding
                        rectangle), or envelope. This is the bounding geometry,
                        formed by the minimum and maximum (X,Y) coordinates:
                    </p><p style="color:blue;">其mbr（最小边界矩形）或信封。这是由最小和最大（x，y）坐标构成的边界几何：</p><p></p><pre data-lang="simple" class="programlisting">((MINX MINY, MAXX MINY, MAXX MAXY, MINX MAXY, MINX MINY))
</pre></li><li class="listitem"><p>
                        Whether the value is
                        <span class="bold"><strong>simple</strong></span> or
                        <span class="bold"><strong>nonsimple</strong></span>. Geometry
                        values of types (<code class="literal">LineString</code>,
                        <code class="literal">MultiPoint</code>,
                        <code class="literal">MultiLineString</code>) are either simple or
                        nonsimple. Each type determines its own assertions for
                        being simple or nonsimple.
                    </p><p style="color:blue;">值是简单的还是非简单的。类型（linestring、multipoint、multilinestring）的几何体值可以是简单的，也可以是非简单的。每种类型都决定了它自己的断言是简单的还是非简单的。</p><p></p></li><li class="listitem"><p>
                        Whether the value is
                        <span class="bold"><strong>closed</strong></span> or
                        <span class="bold"><strong>not closed</strong></span>. Geometry
                        values of types (<code class="literal">LineString</code>,
                        <code class="literal">MultiString</code>) are either closed or not
                        closed. Each type determines its own assertions for being
                        closed or not closed.
                    </p><p style="color:blue;">值是否关闭。类型（linestring、multistring）的几何体值要么是闭合的，要么不是闭合的。每种类型都确定自己的断言是关闭的还是未关闭的。</p><p></p></li><li class="listitem"><p>
                        Whether the value is
                        <span class="bold"><strong>empty</strong></span> or
                        <span class="bold"><strong>nonempty</strong></span> A geometry is
                        empty if it does not have any points. Exterior, interior,
                        and boundary of an empty geometry are not defined (that
                        is, they are represented by a <code class="literal">NULL</code>
                        value). An empty geometry is defined to be always simple
                        and has an area of 0.
                    </p><p style="color:blue;">无论该值是空的还是非空的，如果几何图形没有任何点，则该几何图形为空。未定义空几何图形的外部、内部和边界（即，它们由空值表示）。空几何体定义为总是简单的，并且其面积为0。</p><p></p></li><li class="listitem"><p>
                        Its <span class="bold"><strong>dimension</strong></span>. A geometry
                        can have a dimension of −1, 0, 1, or 2:
                    </p><p style="color:blue;">它的尺寸。几何图形的尺寸可以是-1、0、1或2：</p><p></p>
                        <div class="itemizedlist">
                            <ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
                                −1 for an empty geometry.
                            </p><p style="color:blue;">空几何体为-1。</p><p></p></li><li class="listitem"><p>
                                0 for a geometry with no length and no area.
                            </p><p style="color:blue;">0表示没有长度和面积的几何图形。</p><p></p></li><li class="listitem"><p>
                                1 for a geometry with nonzero length and zero area.
                            </p><p style="color:blue;">1表示长度和面积为非零的几何体。</p><p></p></li><li class="listitem"><p>
                                2 for a geometry with nonzero area.
                            </p><p style="color:blue;">2表示面积为非零的几何体。</p><p></p></li></ul>
                        </div>
                        <p>
                            <code class="literal">Point</code> objects have a dimension of zero.
                            <code class="literal">LineString</code> objects have a dimension of
                            1. <code class="literal">Polygon</code> objects have a dimension of
                            2. The dimensions of <code class="literal">MultiPoint</code>,
                            <code class="literal">MultiLineString</code>, and
                            <code class="literal">MultiPolygon</code> objects are the same as
                            the dimensions of the elements they consist of.
                        </p><p style="color:blue;">点对象的维数为零。linestring对象的维度为1。多边形对象的维数为2。多点、多线和多多边形对象的尺寸与它们所包含的元素的尺寸相同。</p><p></p></li></ul>
                </div>

            </div>
            <div class="section">
                <div class="titlepage">
                    <div>
                        <div>
                            <h4 class="title"><a name="gis-class-point"></a>11.5.2.3&nbsp;Point Class</h4>

                        </div>

                    </div>

                </div>
                <p>
                    A <code class="literal">Point</code> is a geometry that represents a
                    single location in coordinate space.
                </p><p style="color:blue;">点是表示坐标空间中单个位置的几何图形。</p><p></p><p>
          <span class="bold"><strong><code class="literal">Point</code>
          Examples</strong></span>
            </p><p style="color:blue;">点示例</p><p></p>
                <div class="itemizedlist">
                    <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                        Imagine a large-scale map of the world with many cities. A
                        <code class="literal">Point</code> object could represent each city.
                    </p><p style="color:blue;">想象一下一张世界上有许多城市的大比例尺地图。点对象可以表示每个城市。</p><p></p></li><li class="listitem"><p>
                        On a city map, a <code class="literal">Point</code> object could
                        represent a bus stop.
                    </p><p style="color:blue;">在城市地图上，点对象可以表示公共汽车站。</p><p></p></li></ul>
                </div>
                <p>
          <span class="bold"><strong><code class="literal">Point</code>
          Properties</strong></span>
                </p><p style="color:blue;">点属性</p><p></p>
                <div class="itemizedlist">
                    <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                        X-coordinate value.
                    </p><p style="color:blue;">X坐标值。</p><p></p></li><li class="listitem"><p>
                        Y-coordinate value.
                    </p><p style="color:blue;">Y坐标值。</p><p></p></li><li class="listitem"><p>
                        <code class="literal">Point</code> is defined as a zero-dimensional
                        geometry.
                    </p><p style="color:blue;">点被定义为零维几何体。</p><p></p></li><li class="listitem"><p>
                        The boundary of a <code class="literal">Point</code> is the empty
                        set.
                    </p><p style="color:blue;">点的边界是空集。</p><p></p></li></ul>
                </div>

            </div>
            <div class="section">
                <div class="titlepage">
                    <div>
                        <div>
                            <h4 class="title"><a name="gis-class-curve"></a>11.5.2.4&nbsp;Curve Class</h4>

                        </div>

                    </div>

                </div>
                <p>
                    A <code class="literal">Curve</code> is a one-dimensional geometry,
                    usually represented by a sequence of points. Particular
                    subclasses of <code class="literal">Curve</code> define the type of
                    interpolation between points. <code class="literal">Curve</code> is a
                    noninstantiable class.
                </p><p style="color:blue;">曲线是一维几何图形，通常由一系列点表示。曲线的特定子类定义了点之间的插值类型。曲线是一个不可实例化的类。</p><p></p><p>
          <span class="bold"><strong><code class="literal">Curve</code>
          Properties</strong></span>
            </p><p style="color:blue;">曲线特性</p><p></p>
                <div class="itemizedlist">
                    <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                        A <code class="literal">Curve</code> has the coordinates of its
                        points.
                    </p><p style="color:blue;">曲线有其点的坐标。</p><p></p></li><li class="listitem"><p>
                        A <code class="literal">Curve</code> is defined as a one-dimensional
                        geometry.
                    </p><p style="color:blue;">曲线被定义为一维几何图形。</p><p></p></li><li class="listitem"><p>
                        A <code class="literal">Curve</code> is simple if it does not pass
                        through the same point twice, with the exception that a
                        curve can still be simple if the start and end points are
                        the same.
                    </p><p style="color:blue;">如果曲线不经过同一点两次，则曲线很简单，但如果起点和终点相同，则曲线仍然可以很简单。</p><p></p></li><li class="listitem"><p>
                        A <code class="literal">Curve</code> is closed if its start point is
                        equal to its endpoint.
                    </p><p style="color:blue;">如果曲线的起点等于其终点，则曲线是闭合的。</p><p></p></li><li class="listitem"><p>
                        The boundary of a closed <code class="literal">Curve</code> is
                        empty.
                    </p><p style="color:blue;">闭合曲线的边界为空。</p><p></p></li><li class="listitem"><p>
                        The boundary of a nonclosed <code class="literal">Curve</code>
                        consists of its two endpoints.
                    </p><p style="color:blue;">非闭合曲线的边界由其两个端点组成。</p><p></p></li><li class="listitem"><p>
                        A <code class="literal">Curve</code> that is simple and closed is a
                        <code class="literal">LinearRing</code>.
                    </p><p style="color:blue;">一条简单而封闭的曲线就是一条线。</p><p></p></li></ul>
                </div>

            </div>
            <div class="section">
                <div class="titlepage">
                    <div>
                        <div>
                            <h4 class="title"><a name="gis-class-linestring"></a>11.5.2.5&nbsp;LineString Class</h4>

                        </div>

                    </div>

                </div>
                <p>
                    A <code class="literal">LineString</code> is a <code class="literal">Curve</code>
                    with linear interpolation between points.
                </p><p style="color:blue;">线串是点之间具有线性插值的曲线。</p><p></p><p>
          <span class="bold"><strong><code class="literal">LineString</code>
          Examples</strong></span>
            </p><p style="color:blue;">字符串示例</p><p></p>
                <div class="itemizedlist">
                    <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                        On a world map, <code class="literal">LineString</code> objects
                        could represent rivers.
                    </p><p style="color:blue;">在世界地图上，linestring对象可以表示河流。</p><p></p></li><li class="listitem"><p>
                        In a city map, <code class="literal">LineString</code> objects could
                        represent streets.
                    </p><p style="color:blue;">在城市地图中，linestring对象可以表示街道。</p><p></p></li></ul>
                </div>
                <p>
          <span class="bold"><strong><code class="literal">LineString</code>
          Properties</strong></span>
                </p><p style="color:blue;">线串属性</p><p></p>
                <div class="itemizedlist">
                    <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                        A <code class="literal">LineString</code> has coordinates of
                        segments, defined by each consecutive pair of points.
                    </p><p style="color:blue;">线串具有段的坐标，由每个连续的点对定义。</p><p></p></li><li class="listitem"><p>
                        A <code class="literal">LineString</code> is a
                        <code class="literal">Line</code> if it consists of exactly two
                        points.
                    </p><p style="color:blue;">如果一个linestring正好由两点组成，那么它就是一条线。</p><p></p></li><li class="listitem"><p>
                        A <code class="literal">LineString</code> is a
                        <code class="literal">LinearRing</code> if it is both closed and
                        simple.
                    </p><p style="color:blue;">如果一个linestring既封闭又简单，那么它就是一个linearring。</p><p></p></li></ul>
                </div>

            </div>
            <div class="section">
                <div class="titlepage">
                    <div>
                        <div>
                            <h4 class="title"><a name="gis-class-surface"></a>11.5.2.6&nbsp;Surface Class</h4>

                        </div>

                    </div>

                </div>
                <p>
                    A <code class="literal">Surface</code> is a two-dimensional geometry. It
                    is a noninstantiable class. Its only instantiable subclass is
                    <code class="literal">Polygon</code>.
                </p><p style="color:blue;">曲面是二维几何体。它是一个不可实例化的类。它唯一可实例化的子类是polygon。</p><p></p><p>
          <span class="bold"><strong><code class="literal">Surface</code>
          Properties</strong></span>
            </p><p style="color:blue;">表面性质</p><p></p>
                <div class="itemizedlist">
                    <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                        A <code class="literal">Surface</code> is defined as a
                        two-dimensional geometry.
                    </p><p style="color:blue;">曲面被定义为二维几何体。</p><p></p></li><li class="listitem"><p>
                        The OpenGIS specification defines a simple
                        <code class="literal">Surface</code> as a geometry that consists of
                        a single <span class="quote">“<span class="quote">patch</span>”</span> that is associated with a
                        single exterior boundary and zero or more interior
                        boundaries.
                    </p><p style="color:blue;">opengis规范将一个简单的曲面定义为一个几何体，该几何体由一个与单个外部边界和零个或多个内部边界关联的“面片”组成。</p><p></p></li><li class="listitem"><p>
                        The boundary of a simple <code class="literal">Surface</code> is the
                        set of closed curves corresponding to its exterior and
                        interior boundaries.
                    </p><p style="color:blue;">简单曲面的边界是与其内外边界相对应的一组闭合曲线。</p><p></p></li></ul>
                </div>

            </div>
            <div class="section">
                <div class="titlepage">
                    <div>
                        <div>
                            <h4 class="title"><a name="gis-class-polygon"></a>11.5.2.7&nbsp;Polygon Class</h4>

                        </div>

                    </div>

                </div>
                <p>
                    A <code class="literal">Polygon</code> is a planar
                    <code class="literal">Surface</code> representing a multisided geometry.
                    It is defined by a single exterior boundary and zero or more
                    interior boundaries, where each interior boundary defines a
                    hole in the <code class="literal">Polygon</code>.
                </p><p style="color:blue;">多边形是表示多维几何体的平面。它由单个外部边界和零个或多个内部边界定义，其中每个内部边界定义多边形中的孔。</p><p></p><p>
          <span class="bold"><strong><code class="literal">Polygon</code>
          Examples</strong></span>
            </p><p style="color:blue;">多边形示例</p><p></p>
                <div class="itemizedlist">
                    <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                        On a region map, <code class="literal">Polygon</code> objects could
                        represent forests, districts, and so on.
                    </p><p style="color:blue;">在区域地图上，多边形对象可以表示森林、地区等。</p><p></p></li></ul>
                </div>
                <p>
          <span class="bold"><strong><code class="literal">Polygon</code>
          Assertions</strong></span>
                </p><p style="color:blue;">多边形断言</p><p></p>
                <div class="itemizedlist">
                    <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                        The boundary of a <code class="literal">Polygon</code> consists of a
                        set of <code class="literal">LinearRing</code> objects (that is,
                        <code class="literal">LineString</code> objects that are both simple
                        and closed) that make up its exterior and interior
                        boundaries.
                    </p><p style="color:blue;">多边形的边界由组成其外部和内部边界的一组线性化对象（即简单和闭合的线串对象）组成。</p><p></p></li><li class="listitem"><p>
                        A <code class="literal">Polygon</code> has no rings that cross. The
                        rings in the boundary of a <code class="literal">Polygon</code> may
                        intersect at a <code class="literal">Point</code>, but only as a
                        tangent.
                    </p><p style="color:blue;">多边形没有交叉的环。多边形边界中的环可以在某一点相交，但只能作为切线相交。</p><p></p></li><li class="listitem"><p>
                        A <code class="literal">Polygon</code> has no lines, spikes, or
                        punctures.
                    </p><p style="color:blue;">多边形没有线条、尖刺或穿孔。</p><p></p></li><li class="listitem"><p>
                        A <code class="literal">Polygon</code> has an interior that is a
                        connected point set.
                    </p><p style="color:blue;">多边形的内部是一个连接点集。</p><p></p></li><li class="listitem"><p>
                        A <code class="literal">Polygon</code> may have holes. The exterior
                        of a <code class="literal">Polygon</code> with holes is not
                        connected. Each hole defines a connected component of the
                        exterior.
                    </p><p style="color:blue;">多边形可能有洞。带有孔的多边形的外部未连接。每个孔都定义了外部的连接组件。</p><p></p></li></ul>
                </div>
                <p>
                    The preceding assertions make a <code class="literal">Polygon</code> a
                    simple geometry.
                </p><p style="color:blue;">前面的断言使多边形成为一个简单的几何体。</p><p></p>
            </div>
            <div class="section">
                <div class="titlepage">
                    <div>
                        <div>
                            <h4 class="title"><a name="gis-class-geometrycollection"></a>11.5.2.8&nbsp;GeometryCollection Class</h4>

                        </div>

                    </div>

                </div>
                <p>
                    A <code class="literal">GeometryCollection</code> is a geometry that is
                    a collection of zero or more geometries of any class.
                </p><p style="color:blue;">geometry collection是任何类的零个或多个几何图形的集合。</p><p></p><p>
                All the elements in a geometry collection must be in the same
                spatial reference system (that is, in the same coordinate
                system). There are no other constraints on the elements of a
                geometry collection, although the subclasses of
                <code class="literal">GeometryCollection</code> described in the
                following sections may restrict membership. Restrictions may
                be based on:
            </p><p style="color:blue;">几何图形集合中的所有元素必须位于同一空间参照系（即，在同一坐标系中）。在几何图形集合的元素上没有其他约束，尽管以下各节中描述的geometryCollection的子类可能会限制成员资格。限制可能基于：</p><p></p>
                <div class="itemizedlist">
                    <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                        Element type (for example, a <code class="literal">MultiPoint</code>
                        may contain only <code class="literal">Point</code> elements)
                    </p><p style="color:blue;">元素类型（例如，多点只能包含点元素）</p><p></p></li><li class="listitem"><p>
                        Dimension
                    </p><p style="color:blue;">尺寸</p><p></p></li><li class="listitem"><p>
                        Constraints on the degree of spatial overlap between
                        elements
                    </p><p style="color:blue;">元素间空间重叠程度的约束</p><p></p></li></ul>
                </div>

            </div>
            <div class="section">
                <div class="titlepage">
                    <div>
                        <div>
                            <h4 class="title"><a name="gis-class-multipoint"></a>11.5.2.9&nbsp;MultiPoint Class</h4>

                        </div>

                    </div>

                </div>
                <p>
                    A <code class="literal">MultiPoint</code> is a geometry collection
                    composed of <code class="literal">Point</code> elements. The points are
                    not connected or ordered in any way.
                </p><p style="color:blue;">多点是由点元素组成的几何集合。这些点没有以任何方式连接或排列。</p><p></p><p>
          <span class="bold"><strong><code class="literal">MultiPoint</code>
          Examples</strong></span>
            </p><p style="color:blue;">多点示例</p><p></p>
                <div class="itemizedlist">
                    <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                        On a world map, a <code class="literal">MultiPoint</code> could
                        represent a chain of small islands.
                    </p><p style="color:blue;">在世界地图上，多点可以代表一系列小岛。</p><p></p></li><li class="listitem"><p>
                        On a city map, a <code class="literal">MultiPoint</code> could
                        represent the outlets for a ticket office.
                    </p><p style="color:blue;">在城市地图上，多点可以代表售票处的出口。</p><p></p></li></ul>
                </div>
                <p>
          <span class="bold"><strong><code class="literal">MultiPoint</code>
          Properties</strong></span>
                </p><p style="color:blue;">多点属性</p><p></p>
                <div class="itemizedlist">
                    <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                        A <code class="literal">MultiPoint</code> is a zero-dimensional
                        geometry.
                    </p><p style="color:blue;">多点是零维几何。</p><p></p></li><li class="listitem"><p>
                        A <code class="literal">MultiPoint</code> is simple if no two of its
                        <code class="literal">Point</code> values are equal (have identical
                        coordinate values).
                    </p><p style="color:blue;">如果多点的两个点值都不相等（坐标值相同），则多点比较简单。</p><p></p></li><li class="listitem"><p>
                        The boundary of a <code class="literal">MultiPoint</code> is the
                        empty set.
                    </p><p style="color:blue;">多点的边界是空集。</p><p></p></li></ul>
                </div>

            </div>
            <div class="section">
                <div class="titlepage">
                    <div>
                        <div>
                            <h4 class="title"><a name="gis-class-multicurve"></a>11.5.2.10&nbsp;MultiCurve Class</h4>

                        </div>

                    </div>

                </div>
                <p>
                    A <code class="literal">MultiCurve</code> is a geometry collection
                    composed of <code class="literal">Curve</code> elements.
                    <code class="literal">MultiCurve</code> is a noninstantiable class.
                </p><p style="color:blue;">多曲线是由曲线元素组成的几何集合。多曲线是一个不可实例化的类。</p><p></p><p>
          <span class="bold"><strong><code class="literal">MultiCurve</code>
          Properties</strong></span>
            </p><p style="color:blue;">多曲线性质</p><p></p>
                <div class="itemizedlist">
                    <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                        A <code class="literal">MultiCurve</code> is a one-dimensional
                        geometry.
                    </p><p style="color:blue;">多曲线是一维几何。</p><p></p></li><li class="listitem"><p>
                        A <code class="literal">MultiCurve</code> is simple if and only if
                        all of its elements are simple; the only intersections
                        between any two elements occur at points that are on the
                        boundaries of both elements.
                    </p><p style="color:blue;">多曲线是简单的当且仅当它的所有元素都是简单的；任何两个元素之间的唯一交点出现在两个元素边界上的点上。</p><p></p></li><li class="listitem"><p>
                        A <code class="literal">MultiCurve</code> boundary is obtained by
                        applying the <span class="quote">“<span class="quote">mod 2 union rule</span>”</span> (also known
                        as the <span class="quote">“<span class="quote">odd-even rule</span>”</span>): A point is in the
                        boundary of a <code class="literal">MultiCurve</code> if it is in
                        the boundaries of an odd number of
                        <code class="literal">Curve</code> elements.
                    </p><p style="color:blue;">应用“mod 2并集规则”（也称为“奇偶规则”）可获得多曲线边界：如果一个点位于奇数个曲线元素的边界中，则该点位于多曲线的边界中。</p><p></p></li><li class="listitem"><p>
                        A <code class="literal">MultiCurve</code> is closed if all of its
                        elements are closed.
                    </p><p style="color:blue;">如果一个多曲线的所有元素都是封闭的，那么它就是封闭的。</p><p></p></li><li class="listitem"><p>
                        The boundary of a closed <code class="literal">MultiCurve</code> is
                        always empty.
                    </p><p style="color:blue;">闭多曲线的边界总是空的。</p><p></p></li></ul>
                </div>

            </div>
            <div class="section">
                <div class="titlepage">
                    <div>
                        <div>
                            <h4 class="title"><a name="gis-class-multilinestring"></a>11.5.2.11&nbsp;MultiLineString Class</h4>

                        </div>

                    </div>

                </div>
                <p>
                    A <code class="literal">MultiLineString</code> is a
                    <code class="literal">MultiCurve</code> geometry collection composed of
                    <code class="literal">LineString</code> elements.
                </p><p style="color:blue;">多行线是由线串元素组成的多曲线几何集合。</p><p></p><p>
          <span class="bold"><strong><code class="literal">MultiLineString</code>
          Examples</strong></span>
            </p><p style="color:blue;">多行线示例</p><p></p>
                <div class="itemizedlist">
                    <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                        On a region map, a <code class="literal">MultiLineString</code>
                        could represent a river system or a highway system.
                    </p><p style="color:blue;">在区域地图上，多行线可以表示河流系统或公路系统。</p><p></p></li></ul>
                </div>

            </div>
            <div class="section">
                <div class="titlepage">
                    <div>
                        <div>
                            <h4 class="title"><a name="gis-class-multisurface"></a>11.5.2.12&nbsp;MultiSurface Class</h4>

                        </div>

                    </div>

                </div>
                <p>
                    A <code class="literal">MultiSurface</code> is a geometry collection
                    composed of surface elements. <code class="literal">MultiSurface</code>
                    is a noninstantiable class. Its only instantiable subclass is
                    <code class="literal">MultiPolygon</code>.
                </p><p style="color:blue;">多曲面是由曲面元素组成的几何集合。多曲面是一个不可实例化的类。它唯一的可实例化子类是multipolygon。</p><p></p><p>
          <span class="bold"><strong><code class="literal">MultiSurface</code>
          Assertions</strong></span>
            </p><p style="color:blue;">多曲面断言</p><p></p>
                <div class="itemizedlist">
                    <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                        Surfaces within a <code class="literal">MultiSurface</code> have no
                        interiors that intersect.
                    </p><p style="color:blue;">多曲面内的曲面没有相交的内部。</p><p></p></li><li class="listitem"><p>
                        Surfaces within a <code class="literal">MultiSurface</code> have
                        boundaries that intersect at most at a finite number of
                        points.
                    </p><p style="color:blue;">多曲面内的曲面具有最多在有限个点相交的边界。</p><p></p></li></ul>
                </div>

            </div>
            <div class="section">
                <div class="titlepage">
                    <div>
                        <div>
                            <h4 class="title"><a name="gis-class-multipolygon"></a>11.5.2.13&nbsp;MultiPolygon Class</h4>

                        </div>

                    </div>

                </div>
                <p>
                    A <code class="literal">MultiPolygon</code> is a
                    <code class="literal">MultiSurface</code> object composed of
                    <code class="literal">Polygon</code> elements.
                </p><p style="color:blue;">多多边形是由多边形元素组成的多曲面对象。</p><p></p><p>
          <span class="bold"><strong><code class="literal">MultiPolygon</code>
          Examples</strong></span>
            </p><p style="color:blue;">多多边形示例</p><p></p>
                <div class="itemizedlist">
                    <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                        On a region map, a <code class="literal">MultiPolygon</code> could
                        represent a system of lakes.
                    </p><p style="color:blue;">在区域地图上，多多边形可以代表一个湖泊系统。</p><p></p></li></ul>
                </div>
                <p>
          <span class="bold"><strong><code class="literal">MultiPolygon</code>
          Assertions</strong></span>
                </p><p style="color:blue;">多多边形断言</p><p></p>
                <div class="itemizedlist">
                    <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                        A <code class="literal">MultiPolygon</code> has no two
                        <code class="literal">Polygon</code> elements with interiors that
                        intersect.
                    </p><p style="color:blue;">多多边形没有两个内部相交的多边形元素。</p><p></p></li><li class="listitem"><p>
                        A <code class="literal">MultiPolygon</code> has no two
                        <code class="literal">Polygon</code> elements that cross (crossing
                        is also forbidden by the previous assertion), or that
                        touch at an infinite number of points.
                    </p><p style="color:blue;">多多边形没有两个多边形元素相交（前面的断言也禁止交叉），或者在无穷多个点处接触。</p><p></p></li><li class="listitem"><p>
                        A <code class="literal">MultiPolygon</code> may not have cut lines,
                        spikes, or punctures. A <code class="literal">MultiPolygon</code> is
                        a regular, closed point set.
                    </p><p style="color:blue;">多重多边形可能没有切割线、尖刺或穿孔。多多边形是正则的闭点集。</p><p></p></li><li class="listitem"><p>
                        A <code class="literal">MultiPolygon</code> that has more than one
                        <code class="literal">Polygon</code> has an interior that is not
                        connected. The number of connected components of the
                        interior of a <code class="literal">MultiPolygon</code> is equal to
                        the number of <code class="literal">Polygon</code> values in the
                        <code class="literal">MultiPolygon</code>.
                    </p><p style="color:blue;">具有多个多边形的多多边形具有未连接的内部。多多边形内部的连接组件数等于多多边形中的多边形值数。</p><p></p></li></ul>
                </div>
                <p>
          <span class="bold"><strong><code class="literal">MultiPolygon</code>
          Properties</strong></span>
                </p><p style="color:blue;">多多边形性质</p><p></p>
                <div class="itemizedlist">
                    <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                        A <code class="literal">MultiPolygon</code> is a two-dimensional
                        geometry.
                    </p><p style="color:blue;">多多边形是二维几何体。</p><p></p></li><li class="listitem"><p>
                        A <code class="literal">MultiPolygon</code> boundary is a set of
                        closed curves (<code class="literal">LineString</code> values)
                        corresponding to the boundaries of its
                        <code class="literal">Polygon</code> elements.
                    </p><p style="color:blue;">多多边形边界是与其多边形元素边界相对应的一组闭合曲线（线串值）。</p><p></p></li><li class="listitem"><p>
                        Each <code class="literal">Curve</code> in the boundary of the
                        <code class="literal">MultiPolygon</code> is in the boundary of
                        exactly one <code class="literal">Polygon</code> element.
                    </p><p style="color:blue;">多多边形边界中的每条曲线正好位于一个多边形元素的边界中。</p><p></p></li><li class="listitem"><p>
                        Every <code class="literal">Curve</code> in the boundary of an
                        <code class="literal">Polygon</code> element is in the boundary of
                        the <code class="literal">MultiPolygon</code>.
                    </p><p style="color:blue;">多边形元素边界中的每条曲线都在多多边形的边界中。</p><p></p></li></ul>
                </div>

            </div>

        </div>
        <div class="section">
            <div class="titlepage">
                <div>
                    <div>
                        <h3 class="title"><a name="gis-data-formats"></a>11.5.3&nbsp;Supported Spatial Data Formats</h3>

                    </div>

                </div>

            </div>
            <p>
                Two standard spatial data formats are used to represent geometry
                objects in queries:
            </p><p style="color:blue;">两种标准空间数据格式用于表示查询中的几何图形对象：</p><p></p>
            <div class="itemizedlist">
                <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                    Well-Known Text (WKT) format
                </p><p style="color:blue;">众所周知的文本（WKT）格式</p><p></p></li><li class="listitem"><p>
                    Well-Known Binary (WKB) format
                </p><p style="color:blue;">众所周知的二进制（wkb）格式</p><p></p></li></ul>
            </div>
            <p>
                Internally, MySQL stores geometry values in a format that is not
                identical to either WKT or WKB format. (Internal format is like
                WKB but with an initial 4 bytes to indicate the SRID.)
            </p><p style="color:blue;">在内部，mysql以与wkt或wkb格式不同的格式存储几何体值。（内部格式类似于wkb，但有一个4字节的首字母来表示srid。）</p><p></p><p>
            There are functions available to convert between different data
            formats; see <a class="xref" href="functions.html#gis-format-conversion-functions" title="12.16.6&nbsp;Geometry Format Conversion Functions">Section&nbsp;12.16.6, “Geometry Format Conversion Functions”</a>.
        </p><p style="color:blue;">可以在不同的数据格式之间进行转换；请参见第12.16.6节“几何格式转换函数”。</p><p></p><p>
            The following sections describe the spatial data formats MySQL
            uses:
        </p><p style="color:blue;">以下各节介绍MySQL使用的空间数据格式：</p><p></p>
            <div class="itemizedlist">
                <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><a class="xref" href="data-types.html#gis-wkt-format" title="Well-Known Text (WKT) Format">Well-Known Text (WKT) Format</a></p><p style="color:blue;">众所周知的文本（WKT）格式</p><p></p></li><li class="listitem"><p><a class="xref" href="data-types.html#gis-wkb-format" title="Well-Known Binary (WKB) Format">Well-Known Binary (WKB) Format</a></p><p style="color:blue;">众所周知的二进制（wkb）格式</p><p></p></li><li class="listitem"><p><a class="xref" href="data-types.html#gis-internal-format" title="Internal Geometry Storage Format">Internal Geometry Storage Format</a></p><p style="color:blue;">内部几何存储格式</p><p></p></li></ul>
            </div>

            <div class="simplesect">

                <div class="titlepage">
                    <div>

                        <div class="simple">
                            <h4 class="title"><a name="gis-wkt-format"></a>Well-Known Text (WKT) Format</h4>

                        </div>

                    </div>

                </div>
                <a class="indexterm" name="idm140286859292224"></a><a class="indexterm" name="idm140286859290768"></a><a class="indexterm" name="idm140286859289280"></a><p>
                The Well-Known Text (WKT) representation of geometry values is
                designed for exchanging geometry data in ASCII form. The
                OpenGIS specification provides a Backus-Naur grammar that
                specifies the formal production rules for writing WKT values
                (see <a class="xref" href="data-types.html#spatial-types" title="11.5&nbsp;Spatial Data Types">Section&nbsp;11.5, “Spatial Data Types”</a>).
            </p><p style="color:blue;">众所周知的几何值文本（wkt）表示是为交换ascii格式的几何数据而设计的。opengis规范提供了一个backus-naur语法，它指定了书写wkt值的正式生产规则（参见第11.5节“空间数据类型”）。</p><p></p><p>
                Examples of WKT representations of geometry objects:
            </p><p style="color:blue;">几何对象的WKT表示示例：</p><p></p>
                <div class="itemizedlist">
                    <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                        A <code class="literal">Point</code>:
                    </p><p style="color:blue;">一点：</p><p></p><pre data-lang="simple" class="programlisting">POINT(15 20)
</pre><p>
                        The point coordinates are specified with no separating
                        comma. This differs from the syntax for the SQL
                        <a class="link" href="functions.html#function_point"><code class="literal">Point()</code></a> function, which
                        requires a comma between the coordinates. Take care to use
                        the syntax appropriate to the context of a given spatial
                        operation. For example, the following statements both use
                        <a class="link" href="functions.html#function_st-x"><code class="literal">ST_X()</code></a> to extract the
                        X-coordinate from a <code class="literal">Point</code> object. The
                        first produces the object directly using the
                        <a class="link" href="functions.html#function_point"><code class="literal">Point()</code></a> function. The
                        second uses a WKT representation converted to a
                        <code class="literal">Point</code> with
                        <a class="link" href="functions.html#function_st-geomfromtext"><code class="literal">ST_GeomFromText()</code></a>.
                    </p><p style="color:blue;">指定的点坐标没有分隔逗号。这与sql point（）函数的语法不同，后者要求坐标之间有逗号。注意使用适合给定空间操作上下文的语法。例如，以下语句都使用st_x（）从点对象中提取x坐标。第一个直接使用point（）函数生成对象。第二种方法使用WKT表示转换为具有st_geomfromtext（）的点。</p><p></p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT ST_X(Point(15, 20));</code></strong>
+---------------------+
| ST_X(POINT(15, 20)) |
+---------------------+
|                  15 |
+---------------------+

mysql&gt; <strong class="userinput"><code>SELECT ST_X(ST_GeomFromText('POINT(15 20)'));</code></strong>
+---------------------------------------+
| ST_X(ST_GeomFromText('POINT(15 20)')) |
+---------------------------------------+
|                                    15 |
+---------------------------------------+
</pre></li><li class="listitem"><p>
                        A <code class="literal">LineString</code> with four points:
                    </p><p style="color:blue;">有四个点的线串：</p><p></p><pre data-lang="simple" class="programlisting">LINESTRING(0 0, 10 10, 20 25, 50 60)
</pre><p>
                        The point coordinate pairs are separated by commas.
                    </p><p style="color:blue;">点坐标对由逗号分隔。</p><p></p></li><li class="listitem"><p>
                        A <code class="literal">Polygon</code> with one exterior ring and
                        one interior ring:
                    </p><p style="color:blue;">具有一个外环和一个内环的多边形：</p><p></p><pre data-lang="simple" class="programlisting">POLYGON((0 0,10 0,10 10,0 10,0 0),(5 5,7 5,7 7,5 7, 5 5))
</pre></li><li class="listitem"><p>
                        A <code class="literal">MultiPoint</code> with three
                        <code class="literal">Point</code> values:
                    </p><p style="color:blue;">具有三个点值的多点：</p><p></p><pre data-lang="simple" class="programlisting">MULTIPOINT(0 0, 20 20, 60 60)
</pre><p>
                        As of MySQL 5.7.9, spatial functions such as
                        <a class="link" href="functions.html#function_st-mpointfromtext"><code class="literal">ST_MPointFromText()</code></a> and
                        <a class="link" href="functions.html#function_st-geomfromtext"><code class="literal">ST_GeomFromText()</code></a> that
                        accept WKT-format representations of
                        <code class="literal">MultiPoint</code> values permit individual
                        points within values to be surrounded by parentheses. For
                        example, both of the following function calls are valid,
                        whereas before MySQL 5.7.9 the second one produces an
                        error:
                    </p><p style="color:blue;">从mysql 5.7.9开始，接受wkt格式的多点值表示的空间函数（如st-mpointfromtext（）和st-geomfromtext（））允许值中的各个点被括号包围。例如，以下两个函数调用都是有效的，而在mysql 5.7.9之前，第二个函数调用会产生错误：</p><p></p><pre data-lang="sql" class="programlisting">ST_MPointFromText('MULTIPOINT (1 1, 2 2, 3 3)')
ST_MPointFromText('MULTIPOINT ((1 1), (2 2), (3 3))')
</pre><p>
                        As of MySQL 5.7.9, output for
                        <code class="literal">MultiPoint</code> values includes parentheses
                        around each point. For example:
                    </p><p style="color:blue;">从mysql 5.7.9开始，多点值的输出在每个点周围都包含括号。例如：</p><p></p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>SET @mp = 'MULTIPOINT(1 1, 2 2, 3 3)';</code></strong>
mysql&gt; <strong class="userinput"><code>SELECT ST_AsText(ST_GeomFromText(@mp));</code></strong>
+---------------------------------+
| ST_AsText(ST_GeomFromText(@mp)) |
+---------------------------------+
| MULTIPOINT((1 1),(2 2),(3 3))   |
+---------------------------------+
</pre><p>
                        Before MySQL 5.7.9, output for the same value does not
                        include parentheses around each point:
                    </p><p style="color:blue;">在mysql 5.7.9之前，相同值的输出不包括每个点周围的括号：</p><p></p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>SET @mp = 'MULTIPOINT(1 1, 2 2, 3 3)';</code></strong>
mysql&gt; <strong class="userinput"><code>SELECT ST_AsText(ST_GeomFromText(@mp));</code></strong>
+---------------------------------+
| ST_AsText(ST_GeomFromText(@mp)) |
+---------------------------------+
| MULTIPOINT(1 1,2 2,3 3)         |
+---------------------------------+
</pre></li><li class="listitem"><p>
                        A <code class="literal">MultiLineString</code> with two
                        <code class="literal">LineString</code> values:
                    </p><p style="color:blue;">具有两个linestring值的多行字符串：</p><p></p><pre data-lang="simple" class="programlisting">MULTILINESTRING((10 10, 20 20), (15 15, 30 15))
</pre></li><li class="listitem"><p>
                        A <code class="literal">MultiPolygon</code> with two
                        <code class="literal">Polygon</code> values:
                    </p><p style="color:blue;">具有两个多边形值的多多边形：</p><p></p><pre data-lang="simple" class="programlisting">MULTIPOLYGON(((0 0,10 0,10 10,0 10,0 0)),((5 5,7 5,7 7,5 7, 5 5)))
</pre></li><li class="listitem"><p>
                        A <code class="literal">GeometryCollection</code> consisting of two
                        <code class="literal">Point</code> values and one
                        <code class="literal">LineString</code>:
                    </p><p style="color:blue;">由两个点值和一个线串组成的几何集合：</p><p></p><pre data-lang="simple" class="programlisting">GEOMETRYCOLLECTION(POINT(10 10), POINT(30 30), LINESTRING(15 15, 20 20))
</pre></li></ul>
                </div>

            </div>
            <div class="simplesect">
                <div class="titlepage">
                    <div>
                        <div class="simple">
                            <h4 class="title"><a name="gis-wkb-format"></a>Well-Known Binary (WKB) Format</h4>

                        </div>

                    </div>

                </div>
                <a class="indexterm" name="idm140286859236960"></a><a class="indexterm" name="idm140286859235504"></a><a class="indexterm" name="idm140286859234000"></a><p>
                The Well-Known Binary (WKB) representation of geometric values
                is used for exchanging geometry data as binary streams
                represented by <a class="link" href="data-types.html#blob" title="11.4.3&nbsp;The BLOB and TEXT Types"><code class="literal">BLOB</code></a> values
                containing geometric WKB information. This format is defined
                by the OpenGIS specification (see
                <a class="xref" href="data-types.html#spatial-types" title="11.5&nbsp;Spatial Data Types">Section&nbsp;11.5, “Spatial Data Types”</a>). It is also defined in the
                ISO <em class="citetitle">SQL/MM Part 3: Spatial</em> standard.
            </p><p style="color:blue;">几何值的众所周知的二进制（wkb）表示用于将几何数据作为二进制流进行交换，二进制流由包含几何wkb信息的blob值表示。这种格式由opengis规范定义（见第11.5节“空间数据类型”）。它也在iso sql/mm第3部分：空间标准中定义。</p><p></p><p>
                WKB uses 1-byte unsigned integers, 4-byte unsigned integers,
                and 8-byte double-precision numbers (IEEE 754 format). A byte
                is eight bits.
            </p><p style="color:blue;">wkb使用1字节无符号整数、4字节无符号整数和8字节双精度数（ieee 754格式）。一个字节是八位。</p><p></p><p>
                For example, a WKB value that corresponds to <code class="literal">POINT(1
                -1)</code> consists of this sequence of 21 bytes, each
                represented by two hexadecimal digits:
            </p><p style="color:blue;">例如，对应于点（1-1）的wkb值由21个字节组成，每个字节由两个十六进制数字表示：</p><p></p><pre data-lang="simple" class="programlisting">0101000000000000000000F03F000000000000F0BF
</pre><p>
                The sequence consists of the components shown in the following
                table.
            </p><p style="color:blue;">序列由下表所示的组件组成。</p><p></p>
                <div class="table">
                    <a name="wkb-components-example-table"></a><p class="title"><b>Table&nbsp;11.2&nbsp;WKB Components Example</b></p><p style="color:blue;">表11.2 WKB组件示例</p><p></p>
                    <div class="table-contents">
                        <table summary="Example showing component in WKB values."><colgroup><col width="30%"><col width="30%"><col width="40%"></colgroup><thead><tr>
                            <th scope="col">Component</th>
                            <th scope="col">Size</th>
                            <th scope="col">Value</th>
                        </tr></thead><tbody><tr>
                            <td align="left" scope="row">Byte order</td>
                            <td align="left">1 byte</td>
                            <td align="left"><code class="literal">01</code></td>
                        </tr><tr>
                            <td align="left" scope="row">WKB type</td>
                            <td align="left">4 bytes</td>
                            <td align="left"><code class="literal">01000000</code></td>
                        </tr><tr>
                            <td align="left" scope="row">X coordinate</td>
                            <td align="left">8 bytes</td>
                            <td align="left"><code class="literal">000000000000F03F</code></td>
                        </tr><tr>
                            <td align="left" scope="row">Y coordinate</td>
                            <td align="left">8 bytes</td>
                            <td align="left"><code class="literal">000000000000F0BF</code></td>
                        </tr></tbody></table>
                    </div>

                </div>
                <br class="table-break"><p>
                Component representation is as follows:
            </p><p style="color:blue;">组件表示如下：</p><p></p>
                <div class="itemizedlist">
                    <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                        The byte order indicator is either 1 or 0 to signify
                        little-endian or big-endian storage. The little-endian and
                        big-endian byte orders are also known as Network Data
                        Representation (NDR) and External Data Representation
                        (XDR), respectively.
                    </p><p style="color:blue;">字节顺序指示符是1或0，表示小尾数或大尾数存储。小端字节顺序和大端字节顺序分别称为网络数据表示（ndr）和外部数据表示（xdr）。</p><p></p></li><li class="listitem"><p>
                        The WKB type is a code that indicates the geometry type.
                        MySQL uses values from 1 through 7 to indicate
                        <code class="literal">Point</code>, <code class="literal">LineString</code>,
                        <code class="literal">Polygon</code>, <code class="literal">MultiPoint</code>,
                        <code class="literal">MultiLineString</code>,
                        <code class="literal">MultiPolygon</code>, and
                        <code class="literal">GeometryCollection</code>.
                    </p><p style="color:blue;">WKB类型是指示几何图形类型的代码。mysql使用从1到7的值来表示点、线串、多边形、多点、多线串、多多边形和geometrycollection。</p><p></p></li><li class="listitem"><p>
                        A <code class="literal">Point</code> value has X and Y coordinates,
                        each represented as a double-precision value.
                    </p><p style="color:blue;">点值有x和y坐标，每个坐标都表示为双精度值。</p><p></p></li></ul>
                </div>
                <p>
                    WKB values for more complex geometry values have more complex
                    data structures, as detailed in the OpenGIS specification.
                </p><p style="color:blue;">更复杂几何体值的wkb值具有更复杂的数据结构，如opengis规范中所述。</p><p></p>
            </div>
            <div class="simplesect">
                <div class="titlepage">
                    <div>
                        <div class="simple">
                            <h4 class="title"><a name="gis-internal-format"></a>Internal Geometry Storage Format</h4>

                        </div>

                    </div>

                </div>
                <a class="indexterm" name="idm140286859188416"></a><a class="indexterm" name="idm140286859186960"></a><p>
                MySQL stores geometry values using 4 bytes to indicate the
                SRID followed by the WKB representation of the value. For a
                description of WKB format, see
                <a class="xref" href="data-types.html#gis-wkb-format" title="Well-Known Binary (WKB) Format">Well-Known Binary (WKB) Format</a>.
            </p><p style="color:blue;">mysql使用4个字节存储几何体值，以指示srid后跟值的wkb表示。有关wkb格式的说明，请参见众所周知的二进制（wkb）格式。</p><p></p><p>
                For the WKB part, these MySQL-specific considerations apply:
            </p><p style="color:blue;">对于wkb部分，以下针对mysql的注意事项适用：</p><p></p>
                <div class="itemizedlist">
                    <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                        The byte-order indicator byte is 1 because MySQL stores
                        geometries as little-ending values.
                    </p><p style="color:blue;">字节顺序指示符字节是1，因为mysql将几何图形存储为很少的结束值。</p><p></p></li><li class="listitem"><p>
                        MySQL supports geometry types of <code class="literal">Point</code>,
                        <code class="literal">LineString</code>, <code class="literal">Polygon</code>,
                        <code class="literal">MultiPoint</code>,
                        <code class="literal">MultiLineString</code>,
                        <code class="literal">MultiPolygon</code>, and
                        <code class="literal">GeometryCollection</code>. Other geometry
                        types are not supported.
                    </p><p style="color:blue;">mysql支持点、线串、多边形、多点、多行、多多边形和geometrycollection的几何类型。不支持其他几何体类型。</p><p></p></li></ul>
                </div>
                <p>
                    The <a class="link" href="functions.html#function_length"><code class="literal">LENGTH()</code></a> function returns
                    the space in bytes required for value storage. Example:
                </p><p style="color:blue;">函数的作用是：返回值存储所需的字节空间。例子：</p><p></p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>SET @g = ST_GeomFromText('POINT(1 -1)');</code></strong>
mysql&gt; <strong class="userinput"><code>SELECT LENGTH(@g);</code></strong>
+------------+
| LENGTH(@g) |
+------------+
|         25 |
+------------+
mysql&gt; <strong class="userinput"><code>SELECT HEX(@g);</code></strong>
+----------------------------------------------------+
| HEX(@g)                                            |
+----------------------------------------------------+
| 000000000101000000000000000000F03F000000000000F0BF |
+----------------------------------------------------+
</pre><p>
                The value length is 25 bytes, made up of these components (as
                can be seen from the hexadecimal value):
            </p><p style="color:blue;">值长度为25字节，由这些组件组成（从十六进制值可以看出）：</p><p></p>
                <div class="itemizedlist">
                    <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                        4 bytes for integer SRID (0)
                    </p><p style="color:blue;">整数srid（0）为4字节</p><p></p></li><li class="listitem"><p>
                        1 byte for integer byte order (1 = little-endian)
                    </p><p style="color:blue;">1字节表示整数字节顺序（1=小尾数）</p><p></p></li><li class="listitem"><p>
                        4 bytes for integer type information (1 =
                        <code class="literal">Point</code>)
                    </p><p style="color:blue;">整数类型信息为4字节（1=点）</p><p></p></li><li class="listitem"><p>
                        8 bytes for double-precision X coordinate (1)
                    </p><p style="color:blue;">双精度x坐标为8字节（1）</p><p></p></li><li class="listitem"><p>
                        8 bytes for double-precision Y coordinate (−1)
                    </p><p style="color:blue;">双精度Y坐标（-1）为8字节</p><p></p></li></ul>
                </div>

            </div>

        </div>
        <div class="section">
            <div class="titlepage">
                <div>
                    <div>
                        <h3 class="title"><a name="geometry-well-formedness-validity"></a>11.5.4&nbsp;Geometry Well-Formedness and Validity</h3>

                    </div>

                </div>

            </div>
            <a class="indexterm" name="idm140286859163840"></a><a class="indexterm" name="idm140286859162336"></a><a class="indexterm" name="idm140286859160832"></a><a class="indexterm" name="idm140286859159344"></a><a class="indexterm" name="idm140286859157856"></a><a class="indexterm" name="idm140286859156368"></a><a class="indexterm" name="idm140286859154880"></a><a class="indexterm" name="idm140286859153392"></a><a class="indexterm" name="idm140286859151904"></a><a class="indexterm" name="idm140286859150400"></a><p>
            For geometry values, MySQL distinguishes between the concepts of
            syntactically well-formed and geometrically valid.
        </p><p style="color:blue;">对于几何值，mysql区分了语法良好和几何有效的概念。</p><p></p><p>
            A geometry is syntactically well-formed if it satisfies
            conditions such as those in this (nonexhaustive) list:
        </p><p style="color:blue;">如果几何体满足以下条件（非排气式），则其语法形式良好：</p><p></p>
            <div class="itemizedlist">
                <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                    Linestrings have at least two points
                </p><p style="color:blue;">字符串至少有两点</p><p></p></li><li class="listitem"><p>
                    Polygons have at least one ring
                </p><p style="color:blue;">多边形至少有一个环</p><p></p></li><li class="listitem"><p>
                    Polygon rings are closed (first and last points the same)
                </p><p style="color:blue;">多边形环闭合（第一个点和最后一个点相同）</p><p></p></li><li class="listitem"><p>
                    Polygon rings have at least 4 points (minimum polygon is a
                    triangle with first and last points the same)
                </p><p style="color:blue;">多边形环至少有4个点（最小多边形是第一个点和最后一个点相同的三角形）</p><p></p></li><li class="listitem"><p>
                    Collections are not empty (except
                    <code class="literal">GeometryCollection</code>)
                </p><p style="color:blue;">集合不为空（GeometryCollection除外）</p><p></p></li></ul>
            </div>
            <p>
                A geometry is geometrically valid if it is syntactically
                well-formed and satisfies conditions such as those in this
                (nonexhaustive) list:
            </p><p style="color:blue;">一个几何体在几何上是有效的，如果它在语法上是良好的，并且满足如下条件（非xhaustive）：</p><p></p>
            <div class="itemizedlist">
                <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                    Polygons are not self-intersecting
                </p><p style="color:blue;">多边形不是自交的</p><p></p></li><li class="listitem"><p>
                    Polygon interior rings are inside the exterior ring
                </p><p style="color:blue;">多边形内环在外环内</p><p></p></li><li class="listitem"><p>
                    Multipolygons do not have overlapping polygons
                </p><p style="color:blue;">多多边形没有重叠的多边形</p><p></p></li></ul>
            </div>
            <p>
                Spatial functions fail if a geometry is not syntactically
                well-formed. Spatial import functions that parse WKT or WKB
                values raise an error for attempts to create a geometry that is
                not syntactically well-formed. Syntactic well-formedness is also
                checked for attempts to store geometries into tables.
            </p><p style="color:blue;">如果几何结构的句法结构不好，空间函数就会失效。解析wkt或wkb值的空间导入函数会在尝试创建语法不正确的几何体时引发错误。对于将几何图形存储到表中的尝试，还检查语法良好性。</p><p></p><p>
            It is permitted to insert, select, and update geometrically
            invalid geometries, but they must be syntactically well-formed.
            Due to the computational expense, MySQL does not check
            explicitly for geometric validity. Spatial computations may
            detect some cases of invalid geometries and raise an error, but
            they may also return an undefined result without detecting the
            invalidity. Applications that require geometically valid
            geometries should check them using the
            <a class="link" href="functions.html#function_st-isvalid"><code class="literal">ST_IsValid()</code></a> function.
        </p><p style="color:blue;">允许插入、选择和更新几何上无效的几何图形，但它们必须在语法上构造良好。由于计算开销，mysql没有显式地检查几何有效性。空间计算可能会检测到一些无效几何图形并产生错误，但它们也可能返回未定义的结果，而不检测无效几何图形。需要几何有效的几何图形的应用程序应该使用st_isvalid（）函数检查它们。</p><p></p>
        </div>
        <div class="section">
            <div class="titlepage">
                <div>
                    <div>
                        <h3 class="title"><a name="creating-spatial-columns"></a>11.5.5&nbsp;Creating Spatial Columns</h3>

                    </div>

                </div>

            </div>
            <p>
                MySQL provides a standard way of creating spatial columns for
                geometry types, for example, with <a class="link" href="sql-syntax.html#create-table" title="13.1.18&nbsp;CREATE TABLE Syntax"><code class="literal">CREATE
                TABLE</code></a> or <a class="link" href="sql-syntax.html#alter-table" title="13.1.8&nbsp;ALTER TABLE Syntax"><code class="literal">ALTER TABLE</code></a>.
                Spatial columns are supported for
                <a class="link" href="storage-engines.html#myisam-storage-engine" title="15.2&nbsp;The MyISAM Storage Engine"><code class="literal">MyISAM</code></a>,
                <a class="link" href="innodb-storage-engine.html" title="Chapter&nbsp;14&nbsp;The InnoDB Storage Engine"><code class="literal">InnoDB</code></a>,
                <a class="link" href="mysql-cluster.html" title="Chapter&nbsp;21&nbsp;MySQL NDB Cluster 7.5 and NDB Cluster 7.6"><code class="literal">NDB</code></a>, and
                <a class="link" href="storage-engines.html#archive-storage-engine" title="15.5&nbsp;The ARCHIVE Storage Engine"><code class="literal">ARCHIVE</code></a> tables. See also the notes
                about spatial indexes under
                <a class="xref" href="data-types.html#creating-spatial-indexes" title="11.5.9&nbsp;Creating Spatial Indexes">Section&nbsp;11.5.9, “Creating Spatial Indexes”</a>.
            </p><p style="color:blue;">mysql提供了为几何类型创建空间列的标准方法，例如，使用create table或alter table。myisam、innodb、ndb和archive表支持空间列。另请参见第11.5.9节“创建空间索引”中有关空间索引的说明。</p><p></p>
            <div class="itemizedlist">
                <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                    Use the <a class="link" href="sql-syntax.html#create-table" title="13.1.18&nbsp;CREATE TABLE Syntax"><code class="literal">CREATE TABLE</code></a>
                    statement to create a table with a spatial column:
                </p><p style="color:blue;">使用CREATE TABLE语句创建具有空间列的表：</p><p></p><pre data-lang="sql" class="programlisting">CREATE TABLE geom (g GEOMETRY);
</pre></li><li class="listitem"><p>
                    Use the <a class="link" href="sql-syntax.html#alter-table" title="13.1.8&nbsp;ALTER TABLE Syntax"><code class="literal">ALTER TABLE</code></a> statement
                    to add or drop a spatial column to or from an existing
                    table:
                </p><p style="color:blue;">使用“更改表”语句向现有表添加或删除一个空间列：</p><p></p><pre data-lang="sql" class="programlisting">ALTER TABLE geom ADD pt POINT;
ALTER TABLE geom DROP pt;
</pre></li></ul>
            </div>

        </div>
        <div class="section">
            <div class="titlepage">
                <div>
                    <div>
                        <h3 class="title"><a name="populating-spatial-columns"></a>11.5.6&nbsp;Populating Spatial Columns</h3>

                    </div>

                </div>

            </div>
            <p>
                After you have created spatial columns, you can populate them
                with spatial data.
            </p><p style="color:blue;">创建空间列后，可以使用空间数据填充它们。</p><p></p><p>
            Values should be stored in internal geometry format, but you can
            convert them to that format from either Well-Known Text (WKT) or
            Well-Known Binary (WKB) format. The following examples
            demonstrate how to insert geometry values into a table by
            converting WKT values to internal geometry format:
        </p><p style="color:blue;">值应以内部几何格式存储，但可以将它们从已知文本（wkt）或已知二进制（wkb）格式转换为该格式。以下示例演示如何通过将WKT值转换为内部几何图形格式将几何图形值插入到表中：</p><p></p>
            <div class="itemizedlist">
                <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                    Perform the conversion directly in the
                    <a class="link" href="sql-syntax.html#insert" title="13.2.5&nbsp;INSERT Syntax"><code class="literal">INSERT</code></a> statement:
                </p><p style="color:blue;">在insert语句中直接执行转换：</p><p></p><pre data-lang="sql" class="programlisting">INSERT INTO geom VALUES (ST_GeomFromText('POINT(1 1)'));

SET @g = 'POINT(1 1)';
INSERT INTO geom VALUES (ST_GeomFromText(@g));
</pre></li><li class="listitem"><p>
                    Perform the conversion prior to the
                    <a class="link" href="sql-syntax.html#insert" title="13.2.5&nbsp;INSERT Syntax"><code class="literal">INSERT</code></a>:
                </p><p style="color:blue;">在插入之前执行转换：</p><p></p><pre data-lang="sql" class="programlisting">SET @g = ST_GeomFromText('POINT(1 1)');
INSERT INTO geom VALUES (@g);
</pre></li></ul>
            </div>
            <p>
                The following examples insert more complex geometries into the
                table:
            </p><p style="color:blue;">以下示例将更复杂的几何图形插入到表中：</p><p></p><pre data-lang="sql" class="programlisting">SET @g = 'LINESTRING(0 0,1 1,2 2)';
INSERT INTO geom VALUES (ST_GeomFromText(@g));

SET @g = 'POLYGON((0 0,10 0,10 10,0 10,0 0),(5 5,7 5,7 7,5 7, 5 5))';
INSERT INTO geom VALUES (ST_GeomFromText(@g));

SET @g =
'GEOMETRYCOLLECTION(POINT(1 1),LINESTRING(0 0,1 1,2 2,3 3,4 4))';
INSERT INTO geom VALUES (ST_GeomFromText(@g));
</pre><p>
            The preceding examples use
            <a class="link" href="functions.html#function_st-geomfromtext"><code class="literal">ST_GeomFromText()</code></a> to create
            geometry values. You can also use type-specific functions:
        </p><p style="color:blue;">前面的示例使用st_geomfromtext（）创建几何体值。也可以使用类型特定的函数：</p><p></p><pre data-lang="sql" class="programlisting">SET @g = 'POINT(1 1)';
INSERT INTO geom VALUES (ST_PointFromText(@g));

SET @g = 'LINESTRING(0 0,1 1,2 2)';
INSERT INTO geom VALUES (ST_LineStringFromText(@g));

SET @g = 'POLYGON((0 0,10 0,10 10,0 10,0 0),(5 5,7 5,7 7,5 7, 5 5))';
INSERT INTO geom VALUES (ST_PolygonFromText(@g));

SET @g =
'GEOMETRYCOLLECTION(POINT(1 1),LINESTRING(0 0,1 1,2 2,3 3,4 4))';
INSERT INTO geom VALUES (ST_GeomCollFromText(@g));
</pre><p>
            A client application program that wants to use WKB
            representations of geometry values is responsible for sending
            correctly formed WKB in queries to the server. There are several
            ways to satisfy this requirement. For example:
        </p><p style="color:blue;">要使用几何图形值的wkb表示的客户机应用程序负责将查询中格式正确的wkb发送到服务器。有几种方法可以满足这一要求。例如：</p><p></p>
            <div class="itemizedlist">
                <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                    Inserting a <code class="literal">POINT(1 1)</code> value with hex
                    literal syntax:
                </p><p style="color:blue;">使用十六进制文字语法插入点（11）值：</p><p></p><pre data-lang="sql" class="programlisting">INSERT INTO geom VALUES
(ST_GeomFromWKB(X'0101000000000000000000F03F000000000000F03F'));
</pre></li><li class="listitem"><p>
                    An ODBC application can send a WKB representation, binding
                    it to a placeholder using an argument of
                    <a class="link" href="data-types.html#blob" title="11.4.3&nbsp;The BLOB and TEXT Types"><code class="literal">BLOB</code></a> type:
                </p><p style="color:blue;">ODBC应用程序可以发送WKB表示，并使用blob类型的参数将其绑定到占位符：</p><p></p><pre data-lang="sql" class="programlisting">INSERT INTO geom VALUES (ST_GeomFromWKB(?))
</pre><p>
                    Other programming interfaces may support a similar
                    placeholder mechanism.
                </p><p style="color:blue;">其他编程接口可能支持类似的占位符机制。</p><p></p></li><li class="listitem"><p>
                    In a C program, you can escape a binary value using
                    <a class="link" href="connectors-apis.html#mysql-real-escape-string-quote" title="27.8.7.56&nbsp;mysql_real_escape_string_quote()"><code class="literal">mysql_real_escape_string_quote()</code></a>
                    and include the result in a query string that is sent to the
                    server. See
                    <a class="xref" href="connectors-apis.html#mysql-real-escape-string-quote" title="27.8.7.56&nbsp;mysql_real_escape_string_quote()">Section&nbsp;27.8.7.56, “mysql_real_escape_string_quote()”</a>.
                </p><p style="color:blue;">在C程序中，可以使用mysql_real_escape_string_quote（）转义二进制值，并将结果包含在发送到服务器的查询字符串中。见第27.8.7.56节，“mysql_real_escape_string_quote（）”。</p><p></p></li></ul>
            </div>

        </div>
        <div class="section">
            <div class="titlepage">
                <div>
                    <div>
                        <h3 class="title"><a name="fetching-spatial-data"></a>11.5.7&nbsp;Fetching Spatial Data</h3>

                    </div>

                </div>

            </div>
            <p>
                Geometry values stored in a table can be fetched in internal
                format. You can also convert them to WKT or WKB format.
            </p><p style="color:blue;">存储在表中的几何图形值可以内部格式获取。也可以将它们转换为WKT或WKB格式。</p><p></p>
            <div class="itemizedlist">
                <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                    Fetching spatial data in internal format:
                </p><p style="color:blue;">以内部格式获取空间数据：</p><p></p><p>
                    Fetching geometry values using internal format can be useful
                    in table-to-table transfers:
                </p><p style="color:blue;">在表到表的传输中，使用内部格式获取几何图形值非常有用：</p><p></p><pre data-lang="sql" class="programlisting">CREATE TABLE geom2 (g GEOMETRY) SELECT g FROM geom;
</pre></li><li class="listitem"><p>
                    Fetching spatial data in WKT format:
                </p><p style="color:blue;">以WKT格式获取空间数据：</p><p></p><p>
                    The <a class="link" href="functions.html#function_st-astext"><code class="literal">ST_AsText()</code></a> function
                    converts a geometry from internal format to a WKT string.
                </p><p style="color:blue;">函数的作用是：将几何图形从内部格式转换为WKT字符串。</p><p></p><pre data-lang="sql" class="programlisting">SELECT ST_AsText(g) FROM geom;
</pre></li><li class="listitem"><p>
                    Fetching spatial data in WKB format:
                </p><p style="color:blue;">以WKB格式获取空间数据：</p><p></p><p>
                    The <a class="link" href="functions.html#function_st-asbinary"><code class="literal">ST_AsBinary()</code></a> function
                    converts a geometry from internal format to a
                    <a class="link" href="data-types.html#blob" title="11.4.3&nbsp;The BLOB and TEXT Types"><code class="literal">BLOB</code></a> containing the WKB
                    value.
                </p><p style="color:blue;">函数的作用是：将几何图形从内部格式转换为包含wkb值的blob。</p><p></p><pre data-lang="sql" class="programlisting">SELECT ST_AsBinary(g) FROM geom;
</pre></li></ul>
            </div>

        </div>
        <div class="section">
            <div class="titlepage">
                <div>
                    <div>
                        <h3 class="title"><a name="optimizing-spatial-analysis"></a>11.5.8&nbsp;Optimizing Spatial Analysis</h3>

                    </div>

                </div>

            </div>
            <p>
                For <a class="link" href="storage-engines.html#myisam-storage-engine" title="15.2&nbsp;The MyISAM Storage Engine"><code class="literal">MyISAM</code></a> and
                <code class="literal">InnoDB</code> tables, search operations in columns
                containing spatial data can be optimized using
                <code class="literal">SPATIAL</code> indexes. The most typical operations
                are:
            </p><p style="color:blue;">对于myisam和innodb表，可以使用空间索引优化包含空间数据的列中的搜索操作。最典型的操作是：</p><p></p>
            <div class="itemizedlist">
                <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                    Point queries that search for all objects that contain a
                    given point
                </p><p style="color:blue;">搜索包含给定点的所有对象的点查询</p><p></p></li><li class="listitem"><p>
                    Region queries that search for all objects that overlap a
                    given region
                </p><p style="color:blue;">区域查询，用于搜索与给定区域重叠的所有对象</p><p></p></li></ul>
            </div>
            <p>
                MySQL uses <span class="bold"><strong>R-Trees with quadratic
        splitting</strong></span> for <code class="literal">SPATIAL</code> indexes on
                spatial columns. A <code class="literal">SPATIAL</code> index is built
                using the minimum bounding rectangle (MBR) of a geometry. For
                most geometries, the MBR is a minimum rectangle that surrounds
                the geometries. For a horizontal or a vertical linestring, the
                MBR is a rectangle degenerated into the linestring. For a point,
                the MBR is a rectangle degenerated into the point.
            </p><p style="color:blue;">mysql对空间列上的空间索引使用带有二次分裂的r树。使用几何图形的最小边界矩形（mbr）建立空间索引。对于大多数几何图形，mbr是包围几何图形的最小矩形。对于水平或垂直线串，mbr是退化为线串的矩形。对于一个点，mbr是退化为该点的矩形。</p><p></p><p>
            It is also possible to create normal indexes on spatial columns.
            In a non-<code class="literal">SPATIAL</code> index, you must declare a
            prefix for any spatial column except for
            <code class="literal">POINT</code> columns.
        </p><p style="color:blue;">也可以在空间列上创建普通索引。在非空间索引中，必须为任何空间列（点列除外）声明前缀。</p><p></p><p>
            <code class="literal">MyISAM</code> and <code class="literal">InnoDB</code> support
            both <code class="literal">SPATIAL</code> and
            non-<code class="literal">SPATIAL</code> indexes. Other storage engines
            support non-<code class="literal">SPATIAL</code> indexes, as described in
            <a class="xref" href="sql-syntax.html#create-index" title="13.1.14&nbsp;CREATE INDEX Syntax">Section&nbsp;13.1.14, “CREATE INDEX Syntax”</a>.
        </p><p style="color:blue;">myisam和innodb同时支持空间索引和非空间索引。其他存储引擎支持非空间索引，如第13.1.14节“创建索引语法”所述。</p><p></p>
        </div>
        <div class="section">
            <div class="titlepage">
                <div>
                    <div>
                        <h3 class="title"><a name="creating-spatial-indexes"></a>11.5.9&nbsp;Creating Spatial Indexes</h3>

                    </div>

                </div>

            </div>
            <p>
                For <code class="literal">InnoDB</code> and <code class="literal">MyISAM</code>
                tables, MySQL can create spatial indexes using syntax similar to
                that for creating regular indexes, but using the
                <code class="literal">SPATIAL</code> keyword. Columns in spatial indexes
                must be declared <code class="literal">NOT NULL</code>. The following
                examples demonstrate how to create spatial indexes:
            </p><p style="color:blue;">对于innodb和myisam表，mysql可以使用与创建常规索引类似的语法创建空间索引，但使用的是spatial关键字。空间索引中的列必须声明为非空。以下示例演示如何创建空间索引：</p><p></p>
            <div class="itemizedlist">
                <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                    With <a class="link" href="sql-syntax.html#create-table" title="13.1.18&nbsp;CREATE TABLE Syntax"><code class="literal">CREATE TABLE</code></a>:
                </p><p style="color:blue;">使用创建表：</p><p></p><pre data-lang="sql" class="programlisting">CREATE TABLE geom (g GEOMETRY NOT NULL, SPATIAL INDEX(g));
</pre></li><li class="listitem"><p>
                    With <a class="link" href="sql-syntax.html#alter-table" title="13.1.8&nbsp;ALTER TABLE Syntax"><code class="literal">ALTER TABLE</code></a>:
                </p><p style="color:blue;">使用alter table：</p><p></p><pre data-lang="sql" class="programlisting">CREATE TABLE geom (g GEOMETRY NOT NULL);
ALTER TABLE geom ADD SPATIAL INDEX(g);
</pre></li><li class="listitem"><p>
                    With <a class="link" href="sql-syntax.html#create-index" title="13.1.14&nbsp;CREATE INDEX Syntax"><code class="literal">CREATE INDEX</code></a>:
                </p><p style="color:blue;">使用创建索引：</p><p></p><pre data-lang="sql" class="programlisting">CREATE TABLE geom (g GEOMETRY NOT NULL);
CREATE SPATIAL INDEX g ON geom (g);
</pre></li></ul>
            </div>
            <p>
                <code class="literal">SPATIAL INDEX</code> creates an R-tree index. For
                storage engines that support nonspatial indexing of spatial
                columns, the engine creates a B-tree index. A B-tree index on
                spatial values is useful for exact-value lookups, but not for
                range scans.
            </p><p style="color:blue;">空间索引创建r树索引。对于支持非空间索引空间列的存储引擎，引擎创建B-树索引。空间值上的b树索引对于精确的值查找非常有用，但对于范围扫描则不有用。</p><p></p><p>
            For more information on indexing spatial columns, see
            <a class="xref" href="sql-syntax.html#create-index" title="13.1.14&nbsp;CREATE INDEX Syntax">Section&nbsp;13.1.14, “CREATE INDEX Syntax”</a>.
        </p><p style="color:blue;">有关索引空间列的更多信息，请参见第131.14节，“创建索引语法”。</p><p></p><p>
            To drop spatial indexes, use <a class="link" href="sql-syntax.html#alter-table" title="13.1.8&nbsp;ALTER TABLE Syntax"><code class="literal">ALTER
            TABLE</code></a> or <a class="link" href="sql-syntax.html#drop-index" title="13.1.25&nbsp;DROP INDEX Syntax"><code class="literal">DROP INDEX</code></a>:
        </p><p style="color:blue;">要删除空间索引，请使用alter table或drop index：</p><p></p>
            <div class="itemizedlist">
                <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                    With <a class="link" href="sql-syntax.html#alter-table" title="13.1.8&nbsp;ALTER TABLE Syntax"><code class="literal">ALTER TABLE</code></a>:
                </p><p style="color:blue;">使用alter table：</p><p></p><pre data-lang="sql" class="programlisting">ALTER TABLE geom DROP INDEX g;
</pre></li><li class="listitem"><p>
                    With <a class="link" href="sql-syntax.html#drop-index" title="13.1.25&nbsp;DROP INDEX Syntax"><code class="literal">DROP INDEX</code></a>:
                </p><p style="color:blue;">带下降索引：</p><p></p><pre data-lang="sql" class="programlisting">DROP INDEX g ON geom;
</pre></li></ul>
            </div>
            <p>
                Example: Suppose that a table <code class="literal">geom</code> contains
                more than 32,000 geometries, which are stored in the column
                <code class="literal">g</code> of type <code class="literal">GEOMETRY</code>. The
                table also has an <code class="literal">AUTO_INCREMENT</code> column
                <code class="literal">fid</code> for storing object ID values.
            </p><p style="color:blue;">示例：假设一个表geom包含32000多个几何图形，这些几何图形存储在geometry类型的g列中。该表还有一个用于存储对象id值的自动递增列fid。</p><p></p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>DESCRIBE geom;</code></strong>
+-------+----------+------+-----+---------+----------------+
| Field | Type     | Null | Key | Default | Extra          |
+-------+----------+------+-----+---------+----------------+
| fid   | int(11)  |      | PRI | NULL    | auto_increment |
| g     | geometry |      |     |         |                |
+-------+----------+------+-----+---------+----------------+
2 rows in set (0.00 sec)

mysql&gt; <strong class="userinput"><code>SELECT COUNT(*) FROM geom;</code></strong>
+----------+
| count(*) |
+----------+
|    32376 |
+----------+
1 row in set (0.00 sec)
</pre><p>
            To add a spatial index on the column <code class="literal">g</code>, use
            this statement:
        </p><p style="color:blue;">要在列g上添加空间索引，请使用以下语句：</p><p></p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>ALTER TABLE geom ADD SPATIAL INDEX(g);</code></strong>
Query OK, 32376 rows affected (4.05 sec)
Records: 32376  Duplicates: 0  Warnings: 0
</pre>
        </div>
        <div class="section">
            <div class="titlepage">
                <div>
                    <div>
                        <h3 class="title"><a name="using-spatial-indexes"></a>11.5.10&nbsp;Using Spatial Indexes</h3>

                    </div>

                </div>

            </div>
            <p>
                The optimizer investigates whether available spatial indexes can
                be involved in the search for queries that use a function such
                as <a class="link" href="functions.html#function_mbrcontains"><code class="literal">MBRContains()</code></a> or
                <a class="link" href="functions.html#function_mbrwithin"><code class="literal">MBRWithin()</code></a> in the
                <code class="literal">WHERE</code> clause. The following query finds all
                objects that are in the given rectangle:
            </p><p style="color:blue;">优化器调查是否可以在搜索使用where子句中的mbrcontains（）或mbrinfin（）等函数的查询时使用可用的空间索引。以下查询查找给定矩形中的所有对象：</p><p></p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>SET @poly =</code></strong>
    -&gt; <strong class="userinput"><code>'Polygon((30000 15000,
                 31000 15000,
                 31000 16000,
                 30000 16000,
                 30000 15000))';</code></strong>
mysql&gt; <strong class="userinput"><code>SELECT fid,ST_AsText(g) FROM geom WHERE</code></strong>
    -&gt; <strong class="userinput"><code>MBRContains(ST_GeomFromText(@poly),g);</code></strong>
+-----+---------------------------------------------------------------+
| fid | ST_AsText(g)                                                  |
+-----+---------------------------------------------------------------+
|  21 | LINESTRING(30350.4 15828.8,30350.6 15845,30333.8 15845,30 ... |
|  22 | LINESTRING(30350.6 15871.4,30350.6 15887.8,30334 15887.8, ... |
|  23 | LINESTRING(30350.6 15914.2,30350.6 15930.4,30334 15930.4, ... |
|  24 | LINESTRING(30290.2 15823,30290.2 15839.4,30273.4 15839.4, ... |
|  25 | LINESTRING(30291.4 15866.2,30291.6 15882.4,30274.8 15882. ... |
|  26 | LINESTRING(30291.6 15918.2,30291.6 15934.4,30275 15934.4, ... |
| 249 | LINESTRING(30337.8 15938.6,30337.8 15946.8,30320.4 15946. ... |
|   1 | LINESTRING(30250.4 15129.2,30248.8 15138.4,30238.2 15136. ... |
|   2 | LINESTRING(30220.2 15122.8,30217.2 15137.8,30207.6 15136, ... |
|   3 | LINESTRING(30179 15114.4,30176.6 15129.4,30167 15128,3016 ... |
|   4 | LINESTRING(30155.2 15121.4,30140.4 15118.6,30142 15109,30 ... |
|   5 | LINESTRING(30192.4 15085,30177.6 15082.2,30179.2 15072.4, ... |
|   6 | LINESTRING(30244 15087,30229 15086.2,30229.4 15076.4,3024 ... |
|   7 | LINESTRING(30200.6 15059.4,30185.6 15058.6,30186 15048.8, ... |
|  10 | LINESTRING(30179.6 15017.8,30181 15002.8,30190.8 15003.6, ... |
|  11 | LINESTRING(30154.2 15000.4,30168.6 15004.8,30166 15014.2, ... |
|  13 | LINESTRING(30105 15065.8,30108.4 15050.8,30118 15053,3011 ... |
| 154 | LINESTRING(30276.2 15143.8,30261.4 15141,30263 15131.4,30 ... |
| 155 | LINESTRING(30269.8 15084,30269.4 15093.4,30258.6 15093,30 ... |
| 157 | LINESTRING(30128.2 15011,30113.2 15010.2,30113.6 15000.4, ... |
+-----+---------------------------------------------------------------+
20 rows in set (0.00 sec)
</pre><p>
            Use <a class="link" href="sql-syntax.html#explain" title="13.8.2&nbsp;EXPLAIN Syntax"><code class="literal">EXPLAIN</code></a> to check the way this
            query is executed:
        </p><p style="color:blue;">使用explain检查执行此查询的方式：</p><p></p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>SET @poly =</code></strong>
    -&gt; <strong class="userinput"><code>'Polygon((30000 15000,
                 31000 15000,
                 31000 16000,
                 30000 16000,
                 30000 15000))';</code></strong>
mysql&gt; <strong class="userinput"><code>EXPLAIN SELECT fid,ST_AsText(g) FROM geom WHERE</code></strong>
    -&gt; <strong class="userinput"><code>MBRContains(ST_GeomFromText(@poly),g)\G</code></strong>
*************************** 1. row ***************************
           id: 1
  select_type: SIMPLE
        table: geom
         type: range
possible_keys: g
          key: g
      key_len: 32
          ref: NULL
         rows: 50
        Extra: Using where
1 row in set (0.00 sec)
</pre><p>
            Check what would happen without a spatial index:
        </p><p style="color:blue;">检查没有空间索引会发生什么：</p><p></p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>SET @poly =</code></strong>
    -&gt; <strong class="userinput"><code>'Polygon((30000 15000,
                 31000 15000,
                 31000 16000,
                 30000 16000,
                 30000 15000))';</code></strong>
mysql&gt; <strong class="userinput"><code>EXPLAIN SELECT fid,ST_AsText(g) FROM g IGNORE INDEX (g) WHERE</code></strong>
    -&gt; <strong class="userinput"><code>MBRContains(ST_GeomFromText(@poly),g)\G</code></strong>
*************************** 1. row ***************************
           id: 1
  select_type: SIMPLE
        table: geom
         type: ALL
possible_keys: NULL
          key: NULL
      key_len: NULL
          ref: NULL
         rows: 32376
        Extra: Using where
1 row in set (0.00 sec)
</pre><p>
            Executing the <a class="link" href="sql-syntax.html#select" title="13.2.9&nbsp;SELECT Syntax"><code class="literal">SELECT</code></a> statement
            without the spatial index yields the same result but causes the
            execution time to rise from 0.00 seconds to 0.46 seconds:
        </p><p style="color:blue;">在不使用空间索引的情况下执行select语句会产生相同的结果，但会导致执行时间从0.00秒增加到0.46秒：</p><p></p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>SET @poly =</code></strong>
    -&gt; <strong class="userinput"><code>'Polygon((30000 15000,
                 31000 15000,
                 31000 16000,
                 30000 16000,
                 30000 15000))';</code></strong>
mysql&gt; <strong class="userinput"><code>SELECT fid,ST_AsText(g) FROM geom IGNORE INDEX (g) WHERE</code></strong>
    -&gt; <strong class="userinput"><code>MBRContains(ST_GeomFromText(@poly),g);</code></strong>
+-----+---------------------------------------------------------------+
| fid | ST_AsText(g)                                                  |
+-----+---------------------------------------------------------------+
|   1 | LINESTRING(30250.4 15129.2,30248.8 15138.4,30238.2 15136. ... |
|   2 | LINESTRING(30220.2 15122.8,30217.2 15137.8,30207.6 15136, ... |
|   3 | LINESTRING(30179 15114.4,30176.6 15129.4,30167 15128,3016 ... |
|   4 | LINESTRING(30155.2 15121.4,30140.4 15118.6,30142 15109,30 ... |
|   5 | LINESTRING(30192.4 15085,30177.6 15082.2,30179.2 15072.4, ... |
|   6 | LINESTRING(30244 15087,30229 15086.2,30229.4 15076.4,3024 ... |
|   7 | LINESTRING(30200.6 15059.4,30185.6 15058.6,30186 15048.8, ... |
|  10 | LINESTRING(30179.6 15017.8,30181 15002.8,30190.8 15003.6, ... |
|  11 | LINESTRING(30154.2 15000.4,30168.6 15004.8,30166 15014.2, ... |
|  13 | LINESTRING(30105 15065.8,30108.4 15050.8,30118 15053,3011 ... |
|  21 | LINESTRING(30350.4 15828.8,30350.6 15845,30333.8 15845,30 ... |
|  22 | LINESTRING(30350.6 15871.4,30350.6 15887.8,30334 15887.8, ... |
|  23 | LINESTRING(30350.6 15914.2,30350.6 15930.4,30334 15930.4, ... |
|  24 | LINESTRING(30290.2 15823,30290.2 15839.4,30273.4 15839.4, ... |
|  25 | LINESTRING(30291.4 15866.2,30291.6 15882.4,30274.8 15882. ... |
|  26 | LINESTRING(30291.6 15918.2,30291.6 15934.4,30275 15934.4, ... |
| 154 | LINESTRING(30276.2 15143.8,30261.4 15141,30263 15131.4,30 ... |
| 155 | LINESTRING(30269.8 15084,30269.4 15093.4,30258.6 15093,30 ... |
| 157 | LINESTRING(30128.2 15011,30113.2 15010.2,30113.6 15000.4, ... |
| 249 | LINESTRING(30337.8 15938.6,30337.8 15946.8,30320.4 15946. ... |
+-----+---------------------------------------------------------------+
20 rows in set (0.46 sec)
</pre>
        </div>

    </div>

    <div class="section">

        <div class="titlepage">
            <div>
                <div>
                    <h2 class="title" style="clear: both"><a name="json"></a>11.6&nbsp;The JSON Data Type</h2>

                </div>

            </div>

        </div>
        <a class="indexterm" name="idm140286858992048"></a>
        <div class="itemizedlist">
            <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><a class="xref" href="data-types.html#json-values" title="Creating JSON Values">Creating JSON Values</a></p><p style="color:blue;">创建json值</p><p></p></li><li class="listitem"><p><a class="xref" href="data-types.html#json-normalization" title="Normalization, Merging, and Autowrapping of JSON Values">Normalization, Merging, and Autowrapping of JSON Values</a></p><p style="color:blue;">json值的规范化、合并和自动包装</p><p></p></li><li class="listitem"><p><a class="xref" href="data-types.html#json-paths" title="Searching and Modifying JSON Values">Searching and Modifying JSON Values</a></p><p style="color:blue;">搜索和修改json值</p><p></p></li><li class="listitem"><p><a class="xref" href="data-types.html#json-path-syntax" title="JSON Path Syntax">JSON Path Syntax</a></p><p style="color:blue;">json路径语法</p><p></p></li><li class="listitem"><p><a class="xref" href="data-types.html#json-comparison" title="Comparison and Ordering of JSON Values">Comparison and Ordering of JSON Values</a></p><p style="color:blue;">json值的比较与排序</p><p></p></li><li class="listitem"><p><a class="xref" href="data-types.html#json-converting-between-types" title="Converting between JSON and non-JSON values">Converting between JSON and non-JSON values</a></p><p style="color:blue;">在json和非json值之间转换</p><p></p></li><li class="listitem"><p><a class="xref" href="data-types.html#json-aggregation" title="Aggregation of JSON Values">Aggregation of JSON Values</a></p><p style="color:blue;">json值的聚合</p><p></p></li></ul>
        </div>
        <p>
            As of MySQL 5.7.8, MySQL supports a native <code class="literal">JSON</code>
            data type defined by
            <a class="ulink" href="https://tools.ietf.org/html/rfc7159" target="_top">RFC 7159</a>
            that enables efficient access to data in JSON (JavaScript Object
            Notation) documents. The <code class="literal">JSON</code> data type
            provides these advantages over storing JSON-format strings in a
            string column:
        </p><p style="color:blue;">从mysql 5.7.8开始，mysql支持由rfc 7159定义的本地json数据类型，该数据类型允许高效访问json（javascript对象表示法）文档中的数据。与在字符串列中存储json格式字符串相比，json数据类型具有以下优点：</p><p></p>
        <div class="itemizedlist">
            <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                Automatic validation of JSON documents stored in
                <code class="literal">JSON</code> columns. Invalid documents produce an
                error.
            </p><p style="color:blue;">存储在json列中的json文档的自动验证。无效文档会产生错误。</p><p></p></li><li class="listitem"><p>
                Optimized storage format. JSON documents stored in
                <code class="literal">JSON</code> columns are converted to an internal
                format that permits quick read access to document elements.
                When the server later must read a JSON value stored in this
                binary format, the value need not be parsed from a text
                representation. The binary format is structured to enable the
                server to look up subobjects or nested values directly by key
                or array index without reading all values before or after them
                in the document.
            </p><p style="color:blue;">优化的存储格式。存储在json列中的json文档被转换为允许快速读取文档元素的内部格式。当服务器以后必须读取以这种二进制格式存储的json值时，不需要从文本表示中解析该值。二进制格式的结构使服务器能够通过键或数组索引直接查找子对象或嵌套值，而不必读取文档中子对象或嵌套值之前或之后的所有值。</p><p></p></li></ul>
        </div>
        <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">
            <div class="admon-title">
                Note
            </div>
            <p>
                This discussion uses <code class="literal">JSON</code> in monotype to
                indicate specifically the JSON data type and <span class="quote">“<span class="quote">JSON</span>”</span>
                in regular font to indicate JSON data in general.
            </p><p style="color:blue;">本讨论使用monotype中的json来具体表示json数据类型，使用常规字体中的“json”来表示json数据。</p><p></p>
        </div>
        <p>
            The space required to store a <code class="literal">JSON</code> document is
            roughly the same as for <a class="link" href="data-types.html#blob" title="11.4.3&nbsp;The BLOB and TEXT Types"><code class="literal">LONGBLOB</code></a> or
            <a class="link" href="data-types.html#blob" title="11.4.3&nbsp;The BLOB and TEXT Types"><code class="literal">LONGTEXT</code></a>; see
            <a class="xref" href="data-types.html#storage-requirements" title="11.8&nbsp;Data Type Storage Requirements">Section&nbsp;11.8, “Data Type Storage Requirements”</a>, for more information. It
            is important to keep in mind that the size of any JSON document
            stored in a <code class="literal">JSON</code> column is limited to the value
            of the <a class="link" href="server-administration.html#sysvar_max_allowed_packet"><code class="literal">max_allowed_packet</code></a> system
            variable. (When the server is manipulating a JSON value internally
            in memory, it can be larger than this; the limit applies when the
            server stores it.)
        </p><p style="color:blue;">存储json文档所需的空间与longblob或longtext大致相同；有关详细信息，请参阅11.8节“数据类型存储要求”。必须记住，存储在json列中的任何json文档的大小都限制在max_allowed_packet系统变量的值内。（当服务器在内存中内部操作json值时，该值可能大于此值；当服务器存储该值时，将应用此限制。）</p><p></p><p>
        A <code class="literal">JSON</code> column cannot have a
        non-<code class="literal">NULL</code> default value.
    </p><p style="color:blue;">JSON列不能有非空的默认值。</p><p></p><p>
        Along with the <code class="literal">JSON</code> data type, a set of SQL
        functions is available to enable operations on JSON values, such
        as creation, manipulation, and searching. The following discussion
        shows examples of these operations. For details about individual
        functions, see <a class="xref" href="functions.html#json-functions" title="12.17&nbsp;JSON Functions">Section&nbsp;12.17, “JSON Functions”</a>.
    </p><p style="color:blue;">除了json数据类型之外，还提供了一组sql函数来启用对json值的操作，例如创建、操作和搜索。下面的讨论显示了这些操作的示例。有关各个函数的详细信息，请参见第12.17节“JSON函数”。</p><p></p><p>
        A set of spatial functions for operating on GeoJSON values is also
        available. See <a class="xref" href="functions.html#spatial-geojson-functions" title="12.16.11&nbsp;Spatial GeoJSON Functions">Section&nbsp;12.16.11, “Spatial GeoJSON Functions”</a>.
    </p><p style="color:blue;">还提供了一组用于操作geojson值的空间函数。见第12.16.11节“空间geojson函数”。</p><p></p><p>
        <code class="literal">JSON</code> columns, like columns of other binary
        types, are not indexed directly; instead, you can create an index
        on a generated column that extracts a scalar value from the
        <code class="literal">JSON</code> column. See
        <a class="xref" href="sql-syntax.html#json-column-indirect-index" title="Indexing a Generated Column to Provide a JSON Column Index">Indexing a Generated Column to Provide a JSON Column Index</a>, for a detailed
        example.
    </p><p style="color:blue;">与其他二进制类型的列一样，json列没有直接索引；相反，您可以在生成的列上创建索引，从json列中提取标量值。有关详细示例，请参阅索引生成的列以提供JSON列索引。</p><p></p><p>
        The MySQL optimizer also looks for compatible indexes on virtual
        columns that match JSON expressions.
    </p><p style="color:blue;">mysql优化器还在与json表达式匹配的虚拟列上查找兼容的索引。</p><p></p><p>
        MySQL NDB Cluster 7.5 (7.5.2 and later) supports
        <code class="literal">JSON</code> columns and MySQL JSON functions,
        including creation of an index on a column generated from a
        <code class="literal">JSON</code> column as a workaround for being unable to
        index a <code class="literal">JSON</code> column. A maximum of 3
        <code class="literal">JSON</code> columns per
        <a class="link" href="mysql-cluster.html" title="Chapter&nbsp;21&nbsp;MySQL NDB Cluster 7.5 and NDB Cluster 7.6"><code class="literal">NDB</code></a> table is supported.
    </p><p style="color:blue;">mysql ndb cluster 7.5（7.5.2及更高版本）支持json列和mysql json函数，包括在json列生成的列上创建索引，以解决无法索引json列的问题。支持每个NDB表最多3个JSON列。</p><p></p><p>
        The next few sections provide basic information regarding the
        creation and manipulation of JSON values.
    </p><p style="color:blue;">接下来的几节将提供有关json值的创建和操作的基本信息。</p><p></p>
        <div class="simplesect">

            <div class="titlepage">
                <div>

                    <div class="simple">
                        <h3 class="title"><a name="json-values"></a>Creating JSON Values</h3>
                    </div>
                </div>
            </div>
            <a class="indexterm" name="idm140286858953168"></a><a class="indexterm" name="idm140286858951680"></a><a class="indexterm" name="idm140286858950192"></a><a class="indexterm" name="idm140286858948704"></a><a class="indexterm" name="idm140286858947216"></a><a class="indexterm" name="idm140286858945728"></a><a class="indexterm" name="idm140286858944240"></a><a class="indexterm" name="idm140286858942752"></a><a class="indexterm" name="idm140286858941264"></a><a class="indexterm" name="idm140286858939776"></a><a class="indexterm" name="idm140286858938288"></a><a class="indexterm" name="idm140286858936800"></a><a class="indexterm" name="idm140286858935312"></a><a class="indexterm" name="idm140286858933824"></a><a class="indexterm" name="idm140286858932336"></a><a class="indexterm" name="idm140286858930848"></a><p>
            A JSON array contains a list of values separated by commas and
            enclosed within <code class="literal">[</code> and <code class="literal">]</code>
            characters:
        </p><p style="color:blue;">json数组包含由逗号分隔并包含在[和]字符内的值列表：</p><p></p><pre data-lang="json" class="programlisting">["abc", 10, null, true, false]
</pre><p>
            A JSON object contains a set of key-value pairs separated by
            commas and enclosed within <code class="literal">{</code> and
            <code class="literal">}</code> characters:
        </p><p style="color:blue;">json对象包含一组由逗号分隔并包含在{和}字符中的键值对：</p><p></p><pre data-lang="json" class="programlisting">{"k1": "value", "k2": 10}
</pre><p>
            As the examples illustrate, JSON arrays and objects can contain
            scalar values that are strings or numbers, the JSON null
            literal, or the JSON boolean true or false literals. Keys in
            JSON objects must be strings. Temporal (date, time, or datetime)
            scalar values are also permitted:
        </p><p style="color:blue;">如示例所示，json数组和对象可以包含字符串或数字、json空文本或json布尔真或假文本的标量值。json对象中的键必须是字符串。也允许使用临时（日期、时间或日期时间）标量值：</p><p></p><pre data-lang="json" class="programlisting">["12:18:29.000000", "2015-07-29", "2015-07-29 12:18:29.000000"]
</pre><p>
            Nesting is permitted within JSON array elements and JSON object
            key values:
        </p><p style="color:blue;">json数组元素和json对象键值中允许嵌套：</p><p></p><pre data-lang="json" class="programlisting">[99, {"id": "HK500", "cost": 75.99}, ["hot", "cold"]]
{"k1": "value", "k2": [10, 20]}
</pre><p>
            You can also obtain JSON values from a number of functions
            supplied by MySQL for this purpose (see
            <a class="xref" href="functions.html#json-creation-functions" title="12.17.2&nbsp;Functions That Create JSON Values">Section&nbsp;12.17.2, “Functions That Create JSON Values”</a>) as well as by casting
            values of other types to the <code class="literal">JSON</code> type using
            <a class="link" href="functions.html#function_cast"><code class="literal">CAST(<em class="replaceable"><code>value</code></em> AS
                JSON)</code></a> (see
            <a class="xref" href="data-types.html#json-converting-between-types" title="Converting between JSON and non-JSON values">Converting between JSON and non-JSON values</a>). The next
            several paragraphs describe how MySQL handles JSON values
            provided as input.
        </p><p style="color:blue;">您还可以从mysql为此目的提供的许多函数中获取json值（请参见12.17.2节，“创建json值的函数”）以及使用cast（值为json）将其他类型的值转换为json类型（请参见在json值和非json值之间转换）。接下来的几段描述mysql如何处理作为输入提供的json值。</p><p></p><a class="indexterm" name="idm140286858915872"></a><a class="indexterm" name="idm140286858914800"></a><p>
            In MySQL, JSON values are written as strings. MySQL parses any
            string used in a context that requires a JSON value, and
            produces an error if it is not valid as JSON. These contexts
            include inserting a value into a column that has the
            <code class="literal">JSON</code> data type and passing an argument to a
            function that expects a JSON value (usually shown as
            <em class="replaceable"><code>json_doc</code></em> or
            <em class="replaceable"><code>json_val</code></em> in the documentation for
            MySQL JSON functions), as the following examples demonstrate:
        </p><p style="color:blue;">在mysql中，json值是以字符串形式写入的。mysql解析上下文中使用的任何需要json值的字符串，如果该字符串作为json无效，则会产生错误。这些上下文包括将值插入具有json数据类型的列，并将参数传递给期望json值的函数（在mysql json函数的文档中通常显示为json-doc或json-val），如下例所示：</p><p></p>
            <div class="itemizedlist">
                <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                    Attempting to insert a value into a <code class="literal">JSON</code>
                    column succeeds if the value is a valid JSON value, but
                    fails if it is not:
                </p><p style="color:blue;">如果值是有效的json值，则尝试将值插入json列会成功，如果不是，则会失败：</p><p></p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>CREATE TABLE t1 (jdoc JSON);</code></strong>
Query OK, 0 rows affected (0.20 sec)

mysql&gt; <strong class="userinput"><code>INSERT INTO t1 VALUES('{"key1": "value1", "key2": "value2"}');</code></strong>
Query OK, 1 row affected (0.01 sec)

mysql&gt; <strong class="userinput"><code>INSERT INTO t1 VALUES('[1, 2,');</code></strong>
ERROR 3140 (22032) at line 2: Invalid JSON text:
"Invalid value." at position 6 in value (or column) '[1, 2,'.
</pre><p>
                    Positions for <span class="quote">“<span class="quote">at position
            <em class="replaceable"><code>N</code></em></span>”</span> in such error messages
                    are 0-based, but should be considered rough indications of
                    where the problem in a value actually occurs.
                </p><p style="color:blue;">在这些错误信息中，“在位置n”的位置是基于0的，但是应该认为是一个值中问题实际发生位置的粗略指示。</p><p></p></li><li class="listitem"><p>
                    The <a class="link" href="functions.html#function_json-type"><code class="literal">JSON_TYPE()</code></a> function
                    expects a JSON argument and attempts to parse it into a JSON
                    value. It returns the value's JSON type if it is valid
                    and produces an error otherwise:
                </p><p style="color:blue;">json_type（）函数需要一个json参数，并尝试将其解析为json值。如果值有效，则返回该值的json类型，否则将产生错误：</p><p></p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT JSON_TYPE('["a", "b", 1]');</code></strong>
+----------------------------+
| JSON_TYPE('["a", "b", 1]') |
+----------------------------+
| ARRAY                      |
+----------------------------+

mysql&gt; <strong class="userinput"><code>SELECT JSON_TYPE('"hello"');</code></strong>
+----------------------+
| JSON_TYPE('"hello"') |
+----------------------+
| STRING               |
+----------------------+

mysql&gt; <strong class="userinput"><code>SELECT JSON_TYPE('hello');</code></strong>
ERROR 3146 (22032): Invalid data type for JSON data in argument 1
to function json_type; a JSON string or JSON type is required.
</pre></li></ul>
            </div>
            <p>
                MySQL handles strings used in JSON context using the
                <code class="literal">utf8mb4</code> character set and
                <code class="literal">utf8mb4_bin</code> collation. Strings in other
                character sets are converted to <code class="literal">utf8mb4</code> as
                necessary. (For strings in the <code class="literal">ascii</code> or
                <code class="literal">utf8</code> character sets, no conversion is needed
                because <code class="literal">ascii</code> and <code class="literal">utf8</code> are
                subsets of <code class="literal">utf8mb4</code>.)
            </p><p style="color:blue;">mysql使用utf8mb4字符集和utf8mb4-bin排序规则处理json上下文中使用的字符串。其他字符集中的字符串将根据需要转换为utf8mb4。（对于ascii或utf8字符集中的字符串，不需要转换，因为ascii和utf8是utf8mb4的子集。）</p><p></p><p>
            As an alternative to writing JSON values using literal strings,
            functions exist for composing JSON values from component
            elements. <a class="link" href="functions.html#function_json-array"><code class="literal">JSON_ARRAY()</code></a> takes a
            (possibly empty) list of values and returns a JSON array
            containing those values:
        </p><p style="color:blue;">作为使用文字字符串编写JSON值的另一种选择，函数用于从组件元素组成JSON值。json_array（）接受（可能为空）值列表并返回包含这些值的json数组：</p><p></p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT JSON_ARRAY('a', 1, NOW());</code></strong>
+----------------------------------------+
| JSON_ARRAY('a', 1, NOW())              |
+----------------------------------------+
| ["a", 1, "2015-07-27 09:43:47.000000"] |
+----------------------------------------+
</pre><p>
            <a class="link" href="functions.html#function_json-object"><code class="literal">JSON_OBJECT()</code></a> takes a (possibly
            empty) list of key-value pairs and returns a JSON object
            containing those pairs:
        </p><p style="color:blue;">json_object（）获取键值对的列表（可能为空），并返回包含这些对的json对象：</p><p></p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT JSON_OBJECT('key1', 1, 'key2', 'abc');</code></strong>
+---------------------------------------+
| JSON_OBJECT('key1', 1, 'key2', 'abc') |
+---------------------------------------+
| {"key1": 1, "key2": "abc"}            |
+---------------------------------------+
</pre><p>
            <a class="link" href="functions.html#function_json-merge"><code class="literal">JSON_MERGE()</code></a> takes two or more
            JSON documents and returns the combined result:
        </p><p style="color:blue;">json_merge（）接受两个或多个json文档并返回合并结果：</p><p></p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT JSON_MERGE('["a", 1]', '{"key": "value"}');</code></strong>
+--------------------------------------------+
| JSON_MERGE('["a", 1]', '{"key": "value"}') |
+--------------------------------------------+
| ["a", 1, {"key": "value"}]                 |
+--------------------------------------------+
</pre><p>
            For information about the merging rules, see
            <a class="xref" href="data-types.html#json-normalization" title="Normalization, Merging, and Autowrapping of JSON Values">Normalization, Merging, and Autowrapping of JSON Values</a>.
        </p><p style="color:blue;">有关合并规则的信息，请参阅json值的规范化、合并和自动包装。</p><p></p><p>
            JSON values can be assigned to user-defined variables:
        </p><p style="color:blue;">json值可以分配给用户定义的变量：</p><p></p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>SET @j = JSON_OBJECT('key', 'value');</code></strong>
mysql&gt; <strong class="userinput"><code>SELECT @j;</code></strong>
+------------------+
| @j               |
+------------------+
| {"key": "value"} |
+------------------+
</pre><p>
            However, user-defined variables cannot be of
            <code class="literal">JSON</code> data type, so although
            <code class="literal">@j</code> in the preceding example looks like a JSON
            value and has the same character set and collation as a JSON
            value, it does <span class="emphasis"><em>not</em></span> have the
            <code class="literal">JSON</code> data type. Instead, the result from
            <a class="link" href="functions.html#function_json-object"><code class="literal">JSON_OBJECT()</code></a> is converted to a
            string when assigned to the variable.
        </p><p style="color:blue;">但是，用户定义的变量不能是json数据类型，因此尽管前例中的@j看起来像json值，并且具有与json值相同的字符集和排序规则，但它没有json数据类型。相反，json_object（）的结果在分配给变量时转换为字符串。</p><p></p><p>
            Strings produced by converting JSON values have a character set
            of <code class="literal">utf8mb4</code> and a collation of
            <code class="literal">utf8mb4_bin</code>:
        </p><p style="color:blue;">转换json值生成的字符串具有utf8mb4字符集和utf8mb4的排序规则：</p><p></p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT CHARSET(@j), COLLATION(@j);</code></strong>
+-------------+---------------+
| CHARSET(@j) | COLLATION(@j) |
+-------------+---------------+
| utf8mb4     | utf8mb4_bin   |
+-------------+---------------+
</pre><p>
            Because <code class="literal">utf8mb4_bin</code> is a binary collation,
            comparison of JSON values is case-sensitive.
        </p><p style="color:blue;">因为utf8mb4_bin是二进制排序规则，所以json值的比较是区分大小写的。</p><p></p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT JSON_ARRAY('x') = JSON_ARRAY('X');</code></strong>
+-----------------------------------+
| JSON_ARRAY('x') = JSON_ARRAY('X') |
+-----------------------------------+
|                                 0 |
+-----------------------------------+
</pre><a class="indexterm" name="idm140286858865376"></a><p>
            Case sensitivity also applies to the JSON
            <code class="literal">null</code>, <code class="literal">true</code>, and
            <code class="literal">false</code> literals, which always must be written
            in lowercase:
        </p><p style="color:blue;">区分大小写还适用于json null、true和false文本，这些文本必须始终用小写字母书写：</p><p></p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT JSON_VALID('null'), JSON_VALID('Null'), JSON_VALID('NULL');</code></strong>
+--------------------+--------------------+--------------------+
| JSON_VALID('null') | JSON_VALID('Null') | JSON_VALID('NULL') |
+--------------------+--------------------+--------------------+
|                  1 |                  0 |                  0 |
+--------------------+--------------------+--------------------+

mysql&gt; <strong class="userinput"><code>SELECT CAST('null' AS JSON);</code></strong>
+----------------------+
| CAST('null' AS JSON) |
+----------------------+
| null                 |
+----------------------+
1 row in set (0.00 sec)

mysql&gt; <strong class="userinput"><code>SELECT CAST('NULL' AS JSON);</code></strong>
ERROR 3141 (22032): Invalid JSON text in argument 1 to function cast_as_json:
"Invalid value." at position 0 in 'NULL'.
</pre><p>
            Case sensitivity of the JSON literals differs from that of the
            SQL <code class="literal">NULL</code>, <code class="literal">TRUE</code>, and
            <code class="literal">FALSE</code> literals, which can be written in any
            lettercase:
        </p><p style="color:blue;">json文本的区分大小写与sql null、true和false文本的区分大小写不同，sql null、true和false文本可以用任何字母写：</p><p></p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT ISNULL(null), ISNULL(Null), ISNULL(NULL);</code></strong>
+--------------+--------------+--------------+
| ISNULL(null) | ISNULL(Null) | ISNULL(NULL) |
+--------------+--------------+--------------+
|            1 |            1 |            1 |
+--------------+--------------+--------------+
</pre><a class="indexterm" name="idm140286858852432"></a><p>
            Sometimes it may be necessary or desirable to insert quote
            characters (<code class="literal">"</code> or <code class="literal">'</code>) into a
            JSON document. Assume for this example that you want to insert
            some JSON objects containing strings representing sentences that
            state some facts about MySQL, each paired with an appropriate
            keyword, into a table created using the SQL statement shown
            here:
        </p><p style="color:blue;">有时可能需要或希望在json文档中插入引号字符（“or”）。假设在本例中，您希望将一些包含字符串的json对象插入到使用下面所示的sql语句创建的表中，这些字符串表示有关mysql的一些事实，每个事实都与适当的关键字配对：</p><p></p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>CREATE TABLE facts (sentence JSON);</code></strong>
</pre><p>
            Among these keyword-sentence pairs is this one:
        </p><p style="color:blue;">在这些关键词-句子对中，有这样一个：</p><p></p><pre data-lang="simple" class="programlisting">mascot: The MySQL mascot is a dolphin named "Sakila".
</pre><p>
            One way to insert this as a JSON object into the
            <code class="literal">facts</code> table is to use the MySQL
            <a class="link" href="functions.html#function_json-object"><code class="literal">JSON_OBJECT()</code></a> function. In this
            case, you must escape each quote character using a backslash, as
            shown here:
        </p><p style="color:blue;">将其作为json对象插入facts表的一种方法是使用mysql json_object（）函数。在这种情况下，必须使用反斜杠转义每个引号字符，如下所示：</p><p></p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>INSERT INTO facts VALUES</code></strong>
     &gt;   <strong class="userinput"><code>(JSON_OBJECT("mascot", "Our mascot is a dolphin named \"Sakila\"."));</code></strong>
</pre><p>
            This does not work in the same way if you insert the value as a
            JSON object literal, in which case, you must use the double
            backslash escape sequence, like this:
        </p><p style="color:blue;">如果将值作为json对象文本插入，则此操作的方式不同，在这种情况下，必须使用双反斜杠转义序列，如下所示：</p><p></p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>INSERT INTO facts VALUES</code></strong>
     &gt;   <strong class="userinput"><code>('{"mascot": "Our mascot is a dolphin named \\"Sakila\\"."}');</code></strong>
</pre><p>
            Using the double backslash keeps MySQL from performing escape
            sequence processing, and instead causes it to pass the string
            literal to the storage engine for processing. After inserting
            the JSON object in either of the ways just shown, you can see
            that the backslashes are present in the JSON column value by
            doing a simple <a class="link" href="sql-syntax.html#select" title="13.2.9&nbsp;SELECT Syntax"><code class="literal">SELECT</code></a>, like this:
        </p><p style="color:blue;">使用双反斜杠可以防止mysql执行转义序列处理，而是使它将字符串文本传递给存储引擎进行处理。在以刚才所示的任何一种方式插入json对象之后，您可以通过执行一个简单的选择来看到反斜杠出现在json列值中，如下所示：</p><p></p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT sentence FROM facts;</code></strong>
+---------------------------------------------------------+
| sentence                                                |
+---------------------------------------------------------+
| {"mascot": "Our mascot is a dolphin named \"Sakila\"."} |
+---------------------------------------------------------+
</pre><p>
            To look up this particular sentence employing
            <code class="literal">mascot</code> as the key, you can use the
            column-path operator
            <a class="link" href="functions.html#operator_json-column-path"><code class="literal">-&gt;</code></a>,
            as shown here:
        </p><p style="color:blue;">要查找使用吉祥物作为键的特定语句，可以使用列路径运算符-&gt;，如下所示：</p><p></p><pre data-lang="sql" class="programlisting">mysql&gt; SELECT col-&gt;"$.mascot" FROM qtest;
+---------------------------------------------+
| col-&gt;"$.mascot"                             |
+---------------------------------------------+
| "Our mascot is a dolphin named \"Sakila\"." |
+---------------------------------------------+
1 row in set (0.00 sec)
</pre><p>
            This leaves the backslashes intact, along with the surrounding
            quote marks. To display the desired value using
            <code class="literal">mascot</code> as the key, but without including the
            surrounding quote marks or any escapes, use the inline path
            operator
            <a class="link" href="functions.html#operator_json-inline-path"><code class="literal">-&gt;&gt;</code></a>,
            like this:
        </p><p style="color:blue;">这将使反斜杠和周围的引号保持完整。要使用吉祥物作为键显示所需的值，但不包括周围的引号或任何转义符，请使用inline path运算符-&gt;&gt;，如下所示：</p><p></p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT sentence-&gt;&gt;"$.mascot" FROM facts;</code></strong>
+-----------------------------------------+
| sentence-&gt;&gt;"$.mascot"                   |
+-----------------------------------------+
| Our mascot is a dolphin named "Sakila". |
+-----------------------------------------+
</pre>
            <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">

                <div class="admon-title">
                    Note
                </div>
                <p>
                    The previous example does not work as shown if the
                    <a class="link" href="server-administration.html#sqlmode_no_backslash_escapes"><code class="literal">NO_BACKSLASH_ESCAPES</code></a> server
                    SQL mode is enabled. If this mode is set, a single backslash
                    instead of double backslashes can be used to insert the JSON
                    object literal, and the backslashes are preserved. If you use
                    the <code class="literal">JSON_OBJECT()</code> function when performing
                    the insert and this mode is set, you must alternate single and
                    double quotes, like this:
                </p><p style="color:blue;">如果启用了无反斜杠转义服务器SQL模式，则前面的示例将无法正常工作。如果设置此模式，则可以使用单反斜杠而不是双反斜杠插入json对象文本，并保留反斜杠。如果在执行insert时使用json_object（）函数，并且设置了此模式，则必须交替使用单引号和双引号，如下所示：</p><p></p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>INSERT INTO facts VALUES</code></strong>
     &gt; <strong class="userinput"><code>(JSON_OBJECT('mascot', 'Our mascot is a dolphin named "Sakila".'));</code></strong>
</pre><p>
                See the description of the
                <a class="link" href="functions.html#function_json-unquote"><code class="literal">JSON_UNQUOTE()</code></a> function for
                more information about the effects of this mode on escaped
                characters in JSON values.
            </p><p style="color:blue;">有关此模式对json值中转义字符的影响的详细信息，请参见json_nquote（）函数的说明。</p><p></p>
            </div>

        </div>
        <div class="simplesect">
            <div class="titlepage">
                <div>
                    <div class="simple">
                        <h3 class="title"><a name="json-normalization"></a>Normalization, Merging, and Autowrapping of JSON Values</h3>

                    </div>

                </div>

            </div>
            <a class="indexterm" name="idm140286858815712"></a><a class="indexterm" name="idm140286858814256"></a><a class="indexterm" name="idm140286858813184"></a><a class="indexterm" name="idm140286858811696"></a><a class="indexterm" name="idm140286858810624"></a><a class="indexterm" name="idm140286858809136"></a><p>
            When a string is parsed and found to be a valid JSON document,
            it is also normalized: Members with keys that duplicate a key
            found earlier in the document are discarded (even if the values
            differ). The object value produced by the following
            <a class="link" href="functions.html#function_json-object"><code class="literal">JSON_OBJECT()</code></a> call does not
            include the second <code class="literal">key1</code> element because that
            key name occurs earlier in the value:
        </p><p style="color:blue;">当一个字符串被解析并被发现是一个有效的json文档时，它也会被规范化：具有与文档前面找到的键重复的键的成员将被丢弃（即使值不同）。以下json_object（）调用生成的对象值不包括第二个key1元素，因为该键名出现在该值的前面：</p><p></p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT JSON_OBJECT('key1', 1, 'key2', 'abc', 'key1', 'def');</code></strong>
+------------------------------------------------------+
| JSON_OBJECT('key1', 1, 'key2', 'abc', 'key1', 'def') |
+------------------------------------------------------+
| {"key1": 1, "key2": "abc"}                           |
+------------------------------------------------------+
</pre>
            <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">

                <div class="admon-title">
                    Note
                </div>
                <p>
                    This <span class="quote">“<span class="quote">first key wins</span>”</span> handling of duplicate keys
                    is not consistent with
                    <a class="ulink" href="https://tools.ietf.org/html/rfc7159" target="_top">RFC
                        7159</a>. This is a known issue in MySQL 5.7, which is
                    fixed in MySQL 8.0. (Bug #86866, Bug #26369555)
                </p><p style="color:blue;">对重复密钥的这种“第一个密钥获胜”处理与rfc 7159不一致。这是mysql 5.7中的一个已知问题，mysql 8.0中已经修复了这个问题。（错误86866，错误26369555）</p><p></p>
            </div>
            <p>
                MySQL also discards extra whitespace between keys, values, or
                elements in the original JSON document. To make lookups more
                efficient, it also sorts the keys of a JSON object.
                <span class="emphasis"><em>You should be aware that the result of this ordering
        is subject to change and not guaranteed to be consistent across
        releases.</em></span>
            </p><p style="color:blue;">mysql还丢弃原始json文档中键、值或元素之间的额外空格。为了提高查找效率，它还对json对象的键进行排序。您应该知道，此排序的结果可能会发生更改，并且不能保证在不同版本之间保持一致。</p><p></p><p>
            MySQL functions that produce JSON values (see
            <a class="xref" href="functions.html#json-creation-functions" title="12.17.2&nbsp;Functions That Create JSON Values">Section&nbsp;12.17.2, “Functions That Create JSON Values”</a>) always return
            normalized values.
        </p><p style="color:blue;">生成json值的mysql函数（参见12.17.2节，“创建json值的函数”）总是返回规范化值。</p><p></p>
            <h4><a name="json-merging"></a>Merging JSON Values</h4>
            <a class="indexterm" name="idm140286858797808"></a><a class="indexterm" name="idm140286858796736"></a><p>
            In contexts that combine multiple arrays, the arrays are merged
            into a single array by concatenating arrays named later to the
            end of the first array. In the following example,
            <a class="link" href="functions.html#function_json-merge"><code class="literal">JSON_MERGE()</code></a> merges its arguments
            into a single array:
        </p><p style="color:blue;">在组合多个数组的上下文中，通过将后面命名的数组连接到第一个数组的末尾，将这些数组合并到单个数组中。在下面的示例中，json_merge（）将其参数合并到单个数组中：</p><p></p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT JSON_MERGE('[1, 2]', '["a", "b"]', '[true, false]');</code></strong>
+-----------------------------------------------------+
| JSON_MERGE('[1, 2]', '["a", "b"]', '[true, false]') |
+-----------------------------------------------------+
| [1, 2, "a", "b", true, false]                       |
+-----------------------------------------------------+
</pre><p>
            Normalization is also performed when values are inserted into
            JSON columns, as shown here:
        </p><p style="color:blue;">当值插入到json列时，也会执行规范化，如下所示：</p><p></p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>CREATE TABLE t1 (c1 JSON);</code></strong>

mysql&gt; <strong class="userinput"><code>INSERT INTO t1 VALUES</code></strong>
     &gt;     <strong class="userinput"><code>('{"x": 17, "x": "red"}'),</code></strong>
     &gt;     <strong class="userinput"><code>('{"x": 17, "x": "red", "x": [3, 5, 7]}');</code></strong>

mysql&gt; <strong class="userinput"><code>SELECT c1 FROM t1;</code></strong>
+-----------+
| c1        |
+-----------+
| {"x": 17} |
| {"x": 17} |
+-----------+
</pre><p>
            Multiple objects when merged produce a single object. If
            multiple objects have the same key, the value for that key in
            the resulting merged object is an array containing the key
            values:
        </p><p style="color:blue;">合并时多个对象生成单个对象。如果多个对象具有相同的键，则生成的合并对象中该键的值是包含键值的数组：</p><p></p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT JSON_MERGE('{"a": 1, "b": 2}', '{"c": 3, "a": 4}');</code></strong>
+----------------------------------------------------+
| JSON_MERGE('{"a": 1, "b": 2}', '{"c": 3, "a": 4}') |
+----------------------------------------------------+
| {"a": [1, 4], "b": 2, "c": 3}                      |
+----------------------------------------------------+
</pre><p>
            Nonarray values used in a context that requires an array value
            are autowrapped: The value is surrounded by <code class="literal">[</code>
            and <code class="literal">]</code> characters to convert it to an array.
            In the following statement, each argument is autowrapped as an
            array (<code class="literal">[1]</code>, <code class="literal">[2]</code>). These
            are then merged to produce a single result array:
        </p><p style="color:blue;">在需要数组值的上下文中使用的非数组值是自动包装的：该值由[和]字符包围以将其转换为数组。在下面的语句中，每个参数都自动包装为数组（[1]，[2]）。然后合并这些结果以生成单个结果数组：</p><p></p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT JSON_MERGE('1', '2');</code></strong>
+----------------------+
| JSON_MERGE('1', '2') |
+----------------------+
| [1, 2]               |
+----------------------+
</pre><p>
            Array and object values are merged by autowrapping the object as
            an array and merging the two arrays:
        </p><p style="color:blue;">通过将对象自动包装为数组并合并两个数组，可以合并数组和对象值：</p><p></p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT JSON_MERGE('[10, 20]', '{"a": "x", "b": "y"}');</code></strong>
+------------------------------------------------+
| JSON_MERGE('[10, 20]', '{"a": "x", "b": "y"}') |
+------------------------------------------------+
| [10, 20, {"a": "x", "b": "y"}]                 |
+------------------------------------------------+
</pre>
        </div>
        <div class="simplesect">
            <div class="titlepage">
                <div>
                    <div class="simple">
                        <h3 class="title"><a name="json-paths"></a>Searching and Modifying JSON Values</h3>

                    </div>

                </div>

            </div>
            <p>
                A JSON path expression selects a value within a JSON document.
            </p><p style="color:blue;">json路径表达式选择json文档中的值。</p><p></p><p>
            Path expressions are useful with functions that extract parts of
            or modify a JSON document, to specify where within that document
            to operate. For example, the following query extracts from a
            JSON document the value of the member with the
            <code class="literal">name</code> key:
        </p><p style="color:blue;">路径表达式对于提取或修改json文档的一部分以指定该文档中的操作位置的函数非常有用。例如，以下查询从json文档中提取具有名称键的成员的值：</p><p></p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT JSON_EXTRACT('{"id": 14, "name": "Aztalan"}', '$.name');</code></strong>
+---------------------------------------------------------+
| JSON_EXTRACT('{"id": 14, "name": "Aztalan"}', '$.name') |
+---------------------------------------------------------+
| "Aztalan"                                               |
+---------------------------------------------------------+
</pre><p>
            Path syntax uses a leading <code class="literal">$</code> character to
            represent the JSON document under consideration, optionally
            followed by selectors that indicate successively more specific
            parts of the document:
        </p><p style="color:blue;">路径语法使用前导$字符表示考虑中的json文档，后面还可以选择使用选择器，这些选择器依次指示文档的更具体的部分：</p><p></p>
            <div class="itemizedlist">
                <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                    A period followed by a key name names the member in an
                    object with the given key. The key name must be specified
                    within double quotation marks if the name without quotes is
                    not legal within path expressions (for example, if it
                    contains a space).
                </p><p style="color:blue;">后跟键名的句点用给定的键命名对象中的成员。如果不带引号的名称在路径表达式中不合法（例如，如果包含空格），则必须在双引号中指定密钥名称。</p><p></p></li><li class="listitem"><p>
                    <code class="literal">[<em class="replaceable"><code>N</code></em>]</code> appended
                    to a <em class="replaceable"><code>path</code></em> that selects an array
                    names the value at position <em class="replaceable"><code>N</code></em>
                    within the array. Array positions are integers beginning
                    with zero. If <em class="replaceable"><code>path</code></em> does not
                    select an array value, <em class="replaceable"><code>path</code></em>[0]
                    evaluates to the same value as
                    <em class="replaceable"><code>path</code></em>:
                </p><p style="color:blue;">[N]附加到选择数组的路径后，将该值命名为数组中位置N处的值。数组位置是以零开头的整数。如果path未选择数组值，则path[0]的计算结果与path相同：</p><p></p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT JSON_SET('"x"', '$[0]', 'a');</code></strong>
+------------------------------+
| JSON_SET('"x"', '$[0]', 'a') |
+------------------------------+
| "a"                          |
+------------------------------+
1 row in set (0.00 sec)
</pre></li><li class="listitem"><p>
                    Paths can contain <code class="literal">*</code> or
                    <code class="literal">**</code> wildcards:
                </p><p style="color:blue;">路径可以包含*或**通配符：</p><p></p>
                    <div class="itemizedlist">
                        <ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
                            <code class="literal">.[*]</code> evaluates to the values of all
                            members in a JSON object.
                        </p><p style="color:blue;">[*]计算为JSON对象中所有成员的值。</p><p></p></li><li class="listitem"><p>
                            <code class="literal">[*]</code> evaluates to the values of all
                            elements in a JSON array.
                        </p><p style="color:blue;">[*]计算为json数组中所有元素的值。</p><p></p></li><li class="listitem"><p>
                            <code class="literal"><em class="replaceable"><code>prefix</code></em>**<em class="replaceable"><code>suffix</code></em></code>
                            evaluates to all paths that begin with the named prefix
                            and end with the named suffix.
                        </p><p style="color:blue;">前缀**后缀计算结果为以命名前缀开头、以命名后缀结尾的所有路径。</p><p></p></li></ul>
                    </div>
                </li><li class="listitem"><p>
                    A path that does not exist in the document (evaluates to
                    nonexistent data) evaluates to <code class="literal">NULL</code>.
                </p><p style="color:blue;">文档中不存在的路径（评估为不存在的数据）计算为空。</p><p></p></li></ul>
            </div>
            <p>
                Let <code class="literal">$</code> refer to this JSON array with three
                elements:
            </p><p style="color:blue;">让$引用这个包含三个元素的json数组：</p><p></p><pre data-lang="json" class="programlisting">[3, {"a": [5, 6], "b": 10}, [99, 100]]
</pre><p>
            Then:
        </p><p style="color:blue;">然后：</p><p></p>
            <div class="itemizedlist">
                <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                    <code class="literal">$[0]</code> evaluates to <code class="literal">3</code>.
                </p><p style="color:blue;">$[0]的计算结果为3。</p><p></p></li><li class="listitem"><p>
                    <code class="literal">$[1]</code> evaluates to <code class="literal">{"a": [5, 6],
                    "b": 10}</code>.
                </p><p style="color:blue;">$[1]的计算结果为{“a”：[5，6]，“b”：10}。</p><p></p></li><li class="listitem"><p>
                    <code class="literal">$[2]</code> evaluates to <code class="literal">[99,
                    100]</code>.
                </p><p style="color:blue;">$[2]的计算结果为[99100]。</p><p></p></li><li class="listitem"><p>
                    <code class="literal">$[3]</code> evaluates to <code class="literal">NULL</code>
                    (it refers to the fourth array element, which does not
                    exist).
                </p><p style="color:blue;">$ [ 3 ]计算为null（它指的是不存在的第四个数组元素）。</p><p></p></li></ul>
            </div>
            <p>
                Because <code class="literal">$[1]</code> and <code class="literal">$[2]</code>
                evaluate to nonscalar values, they can be used as the basis for
                more-specific path expressions that select nested values.
                Examples:
            </p><p style="color:blue;">由于$[1]和$[2]的计算结果是非标量值，因此它们可以用作选择嵌套值的更特定路径表达式的基础。示例：</p><p></p>
            <div class="itemizedlist">
                <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                    <code class="literal">$[1].a</code> evaluates to <code class="literal">[5,
                    6]</code>.
                </p><p style="color:blue;">$[1].a的计算结果为[5，6]。</p><p></p></li><li class="listitem"><p>
                    <code class="literal">$[1].a[1]</code> evaluates to
                    <code class="literal">6</code>.
                </p><p style="color:blue;">$[1].a[1]的计算结果为6。</p><p></p></li><li class="listitem"><p>
                    <code class="literal">$[1].b</code> evaluates to
                    <code class="literal">10</code>.
                </p><p style="color:blue;">$[1].b的计算结果为10。</p><p></p></li><li class="listitem"><p>
                    <code class="literal">$[2][0]</code> evaluates to
                    <code class="literal">99</code>.
                </p><p style="color:blue;">$[2][0]的计算结果为99。</p><p></p></li></ul>
            </div>
            <p>
                As mentioned previously, path components that name keys must be
                quoted if the unquoted key name is not legal in path
                expressions. Let <code class="literal">$</code> refer to this value:
            </p><p style="color:blue;">如前所述，如果在路径表达式中未引用的密钥名称不合法，则必须引用名称密钥的路径组件。让$引用此值：</p><p></p><pre data-lang="json" class="programlisting">{"a fish": "shark", "a bird": "sparrow"}
</pre><p>
            The keys both contain a space and must be quoted:
        </p><p style="color:blue;">这两个键都包含空格，并且必须引用：</p><p></p>
            <div class="itemizedlist">
                <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                    <code class="literal">$."a fish"</code> evaluates to
                    <code class="literal">shark</code>.
                </p><p style="color:blue;">$“一条鱼”等于鲨鱼。</p><p></p></li><li class="listitem"><p>
                    <code class="literal">$."a bird"</code> evaluates to
                    <code class="literal">sparrow</code>.
                </p><p style="color:blue;">$“一只鸟”的值是麻雀。</p><p></p></li></ul>
            </div>
            <p>
                Paths that use wildcards evaluate to an array that can contain
                multiple values:
            </p><p style="color:blue;">使用通配符的路径对可以包含多个值的数组求值：</p><p></p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT JSON_EXTRACT('{"a": 1, "b": 2, "c": [3, 4, 5]}', '$.*');</code></strong>
+---------------------------------------------------------+
| JSON_EXTRACT('{"a": 1, "b": 2, "c": [3, 4, 5]}', '$.*') |
+---------------------------------------------------------+
| [1, 2, [3, 4, 5]]                                       |
+---------------------------------------------------------+
mysql&gt; <strong class="userinput"><code>SELECT JSON_EXTRACT('{"a": 1, "b": 2, "c": [3, 4, 5]}', '$.c[*]');</code></strong>
+------------------------------------------------------------+
| JSON_EXTRACT('{"a": 1, "b": 2, "c": [3, 4, 5]}', '$.c[*]') |
+------------------------------------------------------------+
| [3, 4, 5]                                                  |
+------------------------------------------------------------+
</pre><p>
            In the following example, the path <code class="literal">$**.b</code>
            evaluates to multiple paths (<code class="literal">$.a.b</code> and
            <code class="literal">$.c.b</code>) and produces an array of the matching
            path values:
        </p><p style="color:blue;">在以下示例中，路径$**.B计算为多个路径（$.a.b和$.c.b），并生成匹配路径值的数组：</p><p></p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT JSON_EXTRACT('{"a": {"b": 1}, "c": {"b": 2}}', '$**.b');</code></strong>
+---------------------------------------------------------+
| JSON_EXTRACT('{"a": {"b": 1}, "c": {"b": 2}}', '$**.b') |
+---------------------------------------------------------+
| [1, 2]                                                  |
+---------------------------------------------------------+
</pre><p>
            In MySQL 5.7.9 and later, you can use
            <a class="link" href="functions.html#operator_json-column-path"><code class="literal"><em class="replaceable"><code>column</code></em>-&gt;<em class="replaceable"><code>path</code></em></code></a>
            with a JSON column identifier and JSON path expression as a
            synonym for
            <a class="link" href="functions.html#function_json-extract"><code class="literal">JSON_EXTRACT(<em class="replaceable"><code>column</code></em>,
                <em class="replaceable"><code>path</code></em>)</code></a>. See
            <a class="xref" href="functions.html#json-search-functions" title="12.17.3&nbsp;Functions That Search JSON Values">Section&nbsp;12.17.3, “Functions That Search JSON Values”</a>, for more information.
            See also <a class="xref" href="sql-syntax.html#json-column-indirect-index" title="Indexing a Generated Column to Provide a JSON Column Index">Indexing a Generated Column to Provide a JSON Column Index</a>.
        </p><p style="color:blue;">在mysql 5.7.9及更高版本中，可以将column-&gt;path与json列标识符和json路径表达式一起用作json_extract（column，path）的同义词。有关更多信息，请参见第12.17.3节“搜索json值的函数”。请参阅索引生成的列以提供JSON列索引。</p><p></p><p>
            Some functions take an existing JSON document, modify it in some
            way, and return the resulting modified document. Path
            expressions indicate where in the document to make changes. For
            example, the <a class="link" href="functions.html#function_json-set"><code class="literal">JSON_SET()</code></a>,
            <a class="link" href="functions.html#function_json-insert"><code class="literal">JSON_INSERT()</code></a>, and
            <a class="link" href="functions.html#function_json-replace"><code class="literal">JSON_REPLACE()</code></a> functions each
            take a JSON document, plus one or more path/value pairs that
            describe where to modify the document and the values to use. The
            functions differ in how they handle existing and nonexisting
            values within the document.
        </p><p style="color:blue;">一些函数使用现有的JSON文档，以某种方式修改它，并返回生成的修改后的文档。路径表达式指示文档中要进行更改的位置。例如，json_set（）、json_insert（）和json_replace（）函数各自采用一个json文档，外加一个或多个路径/值对，这些路径/值对描述修改文档的位置和使用的值。这些函数在处理文档中现有的和未定义的值方面有所不同。</p><p></p><p>
            Consider this document:
        </p><p style="color:blue;">考虑本文件：</p><p></p><pre data-lang="sql" class="programlisting">mysql&gt; SET @j = '["a", {"b": [true, false]}, [10, 20]]';
</pre><p>
            <a class="link" href="functions.html#function_json-set"><code class="literal">JSON_SET()</code></a> replaces values for
            paths that exist and adds values for paths that do not exist:.
        </p><p style="color:blue;">JSONSO SET（）替换存在的路径的值，并为不存在的路径添加值：</p><p></p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT JSON_SET(@j, '$[1].b[0]', 1, '$[2][2]', 2);</code></strong>
+--------------------------------------------+
| JSON_SET(@j, '$[1].b[0]', 1, '$[2][2]', 2) |
+--------------------------------------------+
| ["a", {"b": [1, false]}, [10, 20, 2]]      |
+--------------------------------------------+
</pre><p>
            In this case, the path <code class="literal">$[1].b[0]</code> selects an
            existing value (<code class="literal">true</code>), which is replaced with
            the value following the path argument (<code class="literal">1</code>).
            The path <code class="literal">$[2][2]</code> does not exist, so the
            corresponding value (<code class="literal">2</code>) is added to the value
            selected by <code class="literal">$[2]</code>.
        </p><p style="color:blue;">在这种情况下，路径$〔1〕B〔0〕选择一个已存在的值（true），该值被路径参数（1）后面的值所取代。路径$〔2〕〔2〕不存在，因此相应的值（2）被添加到$（2）所选择的值中。</p><p></p><p>
            <a class="link" href="functions.html#function_json-insert"><code class="literal">JSON_INSERT()</code></a> adds new values but
            does not replace existing values:
        </p><p style="color:blue;">JSON1插入（）添加新的值，但不替换现有值：</p><p></p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT JSON_INSERT(@j, '$[1].b[0]', 1, '$[2][2]', 2);</code></strong>
+-----------------------------------------------+
| JSON_INSERT(@j, '$[1].b[0]', 1, '$[2][2]', 2) |
+-----------------------------------------------+
| ["a", {"b": [true, false]}, [10, 20, 2]]      |
+-----------------------------------------------+
</pre><p>
            <a class="link" href="functions.html#function_json-replace"><code class="literal">JSON_REPLACE()</code></a> replaces existing
            values and ignores new values:
        </p><p style="color:blue;">JSONReRePoT（）替换现有的值，忽略新的值：</p><p></p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT JSON_REPLACE(@j, '$[1].b[0]', 1, '$[2][2]', 2);</code></strong>
+------------------------------------------------+
| JSON_REPLACE(@j, '$[1].b[0]', 1, '$[2][2]', 2) |
+------------------------------------------------+
| ["a", {"b": [1, false]}, [10, 20]]             |
+------------------------------------------------+
</pre><p>
            The path/value pairs are evaluated left to right. The document
            produced by evaluating one pair becomes the new value against
            which the next pair is evaluated.
        </p><p style="color:blue;">路径/值对从左到右求值。对一对进行求值生成的文档将成为对下一对进行求值的新值。</p><p></p><p>
            <code class="literal">JSON_REMOVE()</code> takes a JSON document and one
            or more paths that specify values to be removed from the
            document. The return value is the original document minus the
            values selected by paths that exist within the document:
        </p><p style="color:blue;">json_remove（）接受一个json文档和一个或多个指定要从文档中删除的值的路径。返回值是原始文档减去文档中存在的路径所选择的值：</p><p></p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT JSON_REMOVE(@j, '$[2]', '$[1].b[1]', '$[1].b[1]');</code></strong>
+---------------------------------------------------+
| JSON_REMOVE(@j, '$[2]', '$[1].b[1]', '$[1].b[1]') |
+---------------------------------------------------+
| ["a", {"b": [true]}]                              |
+---------------------------------------------------+
</pre><p>
            The paths have these effects:
        </p><p style="color:blue;">路径具有以下效果：</p><p></p>
            <div class="itemizedlist">
                <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                    <code class="literal">$[2]</code> matches <code class="literal">[10, 20]</code>
                    and removes it.
                </p><p style="color:blue;">$[2]匹配[10，20]并删除它。</p><p></p></li><li class="listitem"><p>
                    The first instance of <code class="literal">$[1].b[1]</code> matches
                    <code class="literal">false</code> in the <code class="literal">b</code> element
                    and removes it.
                </p><p style="color:blue;">$[1].b[1]的第一个实例与b元素中的false匹配，并将其删除。</p><p></p></li><li class="listitem"><p>
                    The second instance of <code class="literal">$[1].b[1]</code> matches
                    nothing: That element has already been removed, the path no
                    longer exists, and has no effect.
                </p><p style="color:blue;">$（1）.b（1）的第二个实例不匹配：该元素已经被移除，路径不再存在，并且没有任何效果。</p><p></p></li></ul>
            </div>

        </div>
        <div class="simplesect">
            <div class="titlepage">
                <div>
                    <div class="simple">
                        <h3 class="title"><a name="json-path-syntax"></a>JSON Path Syntax</h3>

                    </div>

                </div>

            </div>
            <p>
                Many of the JSON functions supported by MySQL and described
                elsewhere in this Manual (see <a class="xref" href="functions.html#json-functions" title="12.17&nbsp;JSON Functions">Section&nbsp;12.17, “JSON Functions”</a>)
                require a path expression in order to identify a specific
                element in a JSON document. A path consists of the path's
                scope followed by one or more path legs. For paths used in MySQL
                JSON functions, the scope is always the document being searched
                or otherwise operated on, represented by a leading
                <code class="literal">$</code> character. Path legs are separated by
                period characters (<code class="literal">.</code>). Cells in arrays are
                represented by
                <code class="literal">[<em class="replaceable"><code>N</code></em>]</code>, where
                <em class="replaceable"><code>N</code></em> is a non-negative integer. Names of
                keys must be double-quoted strings or valid ECMAScript
                identifiers (see
                <code class="uri">http://www.ecma-international.org/ecma-262/5.1/#sec-7.6</code>).
                Path expressions, like JSON text, should be encoded using the
                <code class="literal">ascii</code>, <code class="literal">utf8</code>, or
                <code class="literal">utf8mb4</code> character set. Other character
                encodings are implicitly coerced to <code class="literal">utf8mb4</code>.
                The complete syntax is shown here:
            </p><p style="color:blue;">mysql支持的许多json函数以及本手册其他地方的描述（请参阅12.17节，“json函数”）需要一个路径表达式来标识json文档中的特定元素。路径由路径的作用域和一个或多个路径腿组成。对于mysql json函数中使用的路径，作用域始终是正在搜索或以其他方式操作的文档，由前导$字符表示。路径分支由句点字符（.）分隔。数组中的单元格用[n]表示，其中n是非负整数。密钥的名称必须是双引号字符串或有效的ecmascript标识符（请参见http://www.ecma-international.org/ecma-262/5.1/sec-7.6）。路径表达式，如json文本，应该使用ascii、utf8或utf8mb4字符集进行编码。其他字符编码被隐式强制为utf8mb4。完整的语法如下所示：</p><p></p><pre data-lang="clike" class="programlisting"><em class="replaceable"><code>pathExpression</code></em>:
    <em class="replaceable"><code>scope</code></em>[(<em class="replaceable"><code>pathLeg</code></em>)*]

<em class="replaceable"><code>pathLeg</code></em>:
    <em class="replaceable"><code>member</code></em> | <em class="replaceable"><code>arrayLocation</code></em> | <em class="replaceable"><code>doubleAsterisk</code></em>

<em class="replaceable"><code>member</code></em>:
    <em class="replaceable"><code>period</code></em> ( <em class="replaceable"><code>keyName</code></em> | <em class="replaceable"><code>asterisk</code></em> )

<em class="replaceable"><code>arrayLocation</code></em>:
    <em class="replaceable"><code>leftBracket</code></em> ( <em class="replaceable"><code>nonNegativeInteger</code></em> | <em class="replaceable"><code>asterisk</code></em> ) <em class="replaceable"><code>rightBracket</code></em>

<em class="replaceable"><code>keyName</code></em>:
    <em class="replaceable"><code>ESIdentifier</code></em> | <em class="replaceable"><code>doubleQuotedString</code></em>

<em class="replaceable"><code>doubleAsterisk</code></em>:
    '**'

<em class="replaceable"><code>period</code></em>:
    '.'

<em class="replaceable"><code>asterisk</code></em>:
    '*'

<em class="replaceable"><code>leftBracket</code></em>:
    '['

<em class="replaceable"><code>rightBracket</code></em>:
    ']'
</pre><p>
            As noted previously, in MySQL, the scope of the path is always
            the document being operated on, represented as
            <code class="literal">$</code>. You can use <code class="literal">'$'</code> as a
            synonynm for the document in JSON path expressions.
        </p><p style="color:blue;">如前所述，在mysql中，路径的范围始终是正在操作的文档，表示为$。在json路径表达式中，可以使用“$”作为文档的syonnynm。</p><p></p>
            <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">

                <div class="admon-title">
                    Note
                </div>
                <p>
                    Some implementations support column references for scopes of
                    JSON paths; currently, MySQL does not support these.
                </p><p style="color:blue;">有些实现支持json路径作用域的列引用；目前，mysql不支持这些。</p><p></p>
            </div>
            <p>
                The wildcard <code class="literal">*</code> and <code class="literal">**</code>
                tokens are used as follows:
            </p><p style="color:blue;">通配符*和**标记使用如下：</p><p></p>
            <div class="itemizedlist">
                <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                    <code class="literal">.*</code> represents the values of all members
                    in the object.
                </p><p style="color:blue;">*表示对象中所有成员的值。</p><p></p></li><li class="listitem"><p>
                    <code class="literal">[*]</code> represents the values of all cells in
                    the array.
                </p><p style="color:blue;">[*]表示数组中所有单元格的值。</p><p></p></li><li class="listitem"><p>
                    <code class="literal">[<em class="replaceable"><code>prefix</code></em>]**<em class="replaceable"><code>suffix</code></em></code>
                    represents all paths beginning with
                    <em class="replaceable"><code>prefix</code></em> and ending with
                    <em class="replaceable"><code>suffix</code></em>.
                    <em class="replaceable"><code>prefix</code></em> is optional, while
                    <em class="replaceable"><code>suffix</code></em> is required; in other
                    words, a path may not end in <code class="literal">**</code>.
                </p><p style="color:blue;">[前缀]**后缀表示以前缀开头、以后缀结尾的所有路径。前缀是可选的，而后缀是必需的；换句话说，路径不能以**结尾。</p><p></p><p>
                    In addition, a path may not contain the sequence
                    <code class="literal">***</code>.
                </p><p style="color:blue;">此外，路径不能包含序列***。</p><p></p></li></ul>
            </div>
            <p>
                For path syntax examples, see the descriptions of the various
                JSON functions that take paths as arguments, such as
                <a class="link" href="functions.html#function_json-contains-path"><code class="literal">JSON_CONTAINS_PATH()</code></a>,
                <a class="link" href="functions.html#function_json-set"><code class="literal">JSON_SET()</code></a>, and
                <a class="link" href="functions.html#function_json-replace"><code class="literal">JSON_REPLACE()</code></a>. For examples
                which include the use of the <code class="literal">*</code> and
                <code class="literal">**</code> wildcards, see the description of the
                <a class="link" href="functions.html#function_json-search"><code class="literal">JSON_SEARCH()</code></a> function.
            </p><p style="color:blue;">有关路径语法示例，请参见以路径为参数的各种json函数的说明，例如json_contains_path（）、json_set（）和json_replace（）。有关使用*和**通配符的示例，请参见json_search（）函数的说明。</p><p></p>
        </div>
        <div class="simplesect">
            <div class="titlepage">
                <div>
                    <div class="simple">
                        <h3 class="title"><a name="json-comparison"></a>Comparison and Ordering of JSON Values</h3>

                    </div>

                </div>

            </div>
            <p>
                JSON values can be compared using the
                <a class="link" href="functions.html#operator_equal"><code class="literal">=</code></a>,
                <a class="link" href="functions.html#operator_less-than"><code class="literal">&lt;</code></a>,
                <a class="link" href="functions.html#operator_less-than-or-equal"><code class="literal">&lt;=</code></a>,
                <a class="link" href="functions.html#operator_greater-than"><code class="literal">&gt;</code></a>,
                <a class="link" href="functions.html#operator_greater-than-or-equal"><code class="literal">&gt;=</code></a>,
                <a class="link" href="functions.html#operator_not-equal"><code class="literal">&lt;&gt;</code></a>,
                <a class="link" href="functions.html#operator_not-equal"><code class="literal">!=</code></a>, and
                <a class="link" href="functions.html#operator_equal-to"><code class="literal">&lt;=&gt;</code></a>
                operators.
            </p><p style="color:blue;">可以使用=，&lt;，&lt;=，&gt;，&gt;=，&lt;&gt;，，比较json值！=，和&lt;=&gt;运算符。</p><p></p><p>
            The following comparison operators and functions are not yet
            supported with JSON values:
        </p><p style="color:blue;">JSON值尚不支持以下比较运算符和函数：</p><p></p>
            <div class="itemizedlist">
                <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                    <a class="link" href="functions.html#operator_between"><code class="literal">BETWEEN</code></a>
                </p><p style="color:blue;">介于</p><p></p></li><li class="listitem"><p>
                    <a class="link" href="functions.html#operator_in"><code class="literal">IN()</code></a>
                </p><p style="color:blue;">在（）</p><p></p></li><li class="listitem"><p>
                    <a class="link" href="functions.html#function_greatest"><code class="literal">GREATEST()</code></a>
                </p><p style="color:blue;">最伟大的（）</p><p></p></li><li class="listitem"><p>
                    <a class="link" href="functions.html#function_least"><code class="literal">LEAST()</code></a>
                </p><p style="color:blue;">最小值（）</p><p></p></li></ul>
            </div>
            <p>
                A workaround for the comparison operators and functions just
                listed is to cast JSON values to a native MySQL numeric or
                string data type so they have a consistent non-JSON scalar type.
            </p><p style="color:blue;">刚刚列出的比较运算符和函数的一个解决方法是将json值转换为原生mysql数值或字符串数据类型，以便它们具有一致的非json标量类型。</p><p></p><p>
            Comparison of JSON values takes place at two levels. The first
            level of comparison is based on the JSON types of the compared
            values. If the types differ, the comparison result is determined
            solely by which type has higher precedence. If the two values
            have the same JSON type, a second level of comparison occurs
            using type-specific rules.
        </p><p style="color:blue;">json值的比较在两个级别进行。第一级比较基于比较值的json类型。如果类型不同，则比较结果仅由具有更高优先级的类型决定。如果这两个值具有相同的json类型，则使用类型特定的规则进行第二级比较。</p><p></p><p>
            The following list shows the precedences of JSON types, from
            highest precedence to the lowest. (The type names are those
            returned by the <a class="link" href="functions.html#function_json-type"><code class="literal">JSON_TYPE()</code></a>
            function.) Types shown together on a line have the same
            precedence. Any value having a JSON type listed earlier in the
            list compares greater than any value having a JSON type listed
            later in the list.
        </p><p style="color:blue;">下面的列表显示了json类型的优先级，从最高优先级到最低优先级。（类型名是json_type（）函数返回的名称。）一行中一起显示的类型具有相同的优先级。列表中前面列出的json类型的任何值都比列表中后面列出的json类型的任何值大。</p><p></p><pre data-lang="simple" class="programlisting">BLOB
BIT
OPAQUE
DATETIME
TIME
DATE
BOOLEAN
ARRAY
OBJECT
STRING
INTEGER, DOUBLE
NULL
</pre><p>
            For JSON values of the same precedence, the comparison rules are
            type specific:
        </p><p style="color:blue;">对于具有相同优先级的json值，比较规则是特定于类型的：</p><p></p>
            <div class="itemizedlist">
                <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                    <code class="literal">BLOB</code>
                </p><p style="color:blue;">斑点</p><p></p><p>
                    The first <em class="replaceable"><code>N</code></em> bytes of the two
                    values are compared, where <em class="replaceable"><code>N</code></em> is
                    the number of bytes in the shorter value. If the first
                    <em class="replaceable"><code>N</code></em> bytes of the two values are
                    identical, the shorter value is ordered before the longer
                    value.
                </p><p style="color:blue;">比较两个值的前n个字节，其中n是较短值中的字节数。如果两个值的前n个字节相同，则较短的值在较长的值之前排序。</p><p></p></li><li class="listitem"><p>
                    <code class="literal">BIT</code>
                </p><p style="color:blue;">钻头</p><p></p><p>
                    Same rules as for <code class="literal">BLOB</code>.
                </p><p style="color:blue;">与blob相同的规则。</p><p></p></li><li class="listitem"><p>
                    <code class="literal">OPAQUE</code>
                </p><p style="color:blue;">不透明的</p><p></p><p>
                    Same rules as for <code class="literal">BLOB</code>.
                    <code class="literal">OPAQUE</code> values are values that are not
                    classified as one of the other types.
                </p><p style="color:blue;">与blob相同的规则。不透明值是未分类为其他类型之一的值。</p><p></p></li><li class="listitem"><p>
                    <code class="literal">DATETIME</code>
                </p><p style="color:blue;">日期时间</p><p></p><p>
                    A value that represents an earlier point in time is ordered
                    before a value that represents a later point in time. If two
                    values originally come from the MySQL
                    <code class="literal">DATETIME</code> and <code class="literal">TIMESTAMP</code>
                    types, respectively, they are equal if they represent the
                    same point in time.
                </p><p style="color:blue;">表示较早时间点的值在表示较晚时间点的值之前排序。如果两个值最初分别来自mysql datetime和timestamp类型，则它们表示同一时间点时相等。</p><p></p></li><li class="listitem"><p>
                    <code class="literal">TIME</code>
                </p><p style="color:blue;">时间</p><p></p><p>
                    The smaller of two time values is ordered before the larger
                    one.
                </p><p style="color:blue;">两个时间值中的较小值在较大值之前排序。</p><p></p></li><li class="listitem"><p>
                    <code class="literal">DATE</code>
                </p><p style="color:blue;">日期</p><p></p><p>
                    The earlier date is ordered before the more recent date.
                </p><p style="color:blue;">较早的日期比最近的日期早。</p><p></p></li><li class="listitem"><p>
                    <code class="literal">ARRAY</code>
                </p><p style="color:blue;">阵列</p><p></p><p>
                    Two JSON arrays are equal if they have the same length and
                    values in corresponding positions in the arrays are equal.
                </p><p style="color:blue;">如果两个json数组的长度相同，并且数组中相应位置的值相等，则它们相等。</p><p></p><p>
                    If the arrays are not equal, their order is determined by
                    the elements in the first position where there is a
                    difference. The array with the smaller value in that
                    position is ordered first. If all values of the shorter
                    array are equal to the corresponding values in the longer
                    array, the shorter array is ordered first.
                </p><p style="color:blue;">如果数组不相等，则它们的顺序由第一个位置上存在差异的元素决定。该位置值较小的数组首先排序。如果较短数组的所有值都等于较长数组中的相应值，则首先对较短数组排序。</p><p></p><p>
                    Example:
                </p><p style="color:blue;">例子：</p><p></p><pre data-lang="simple" class="programlisting">[] &lt; ["a"] &lt; ["ab"] &lt; ["ab", "cd", "ef"] &lt; ["ab", "ef"]
</pre></li><li class="listitem"><p>
                    <code class="literal">BOOLEAN</code>
                </p><p style="color:blue;">布尔型</p><p></p><p>
                    The JSON false literal is less than the JSON true literal.
                </p><p style="color:blue;">json假文本小于json真文本。</p><p></p></li><li class="listitem"><p>
                    <code class="literal">OBJECT</code>
                </p><p style="color:blue;">对象</p><p></p><p>
                    Two JSON objects are equal if they have the same set of
                    keys, and each key has the same value in both objects.
                </p><p style="color:blue;">如果两个json对象具有相同的键集，并且每个键在两个对象中具有相同的值，则它们是相等的。</p><p></p><p>
                    Example:
                </p><p style="color:blue;">例子：</p><p></p><pre data-lang="simple" class="programlisting">{"a": 1, "b": 2} = {"b": 2, "a": 1}
</pre><p>
                    The order of two objects that are not equal is unspecified
                    but deterministic.
                </p><p style="color:blue;">两个不相等的对象的顺序是不确定的，但是确定的。</p><p></p></li><li class="listitem"><p>
                    <code class="literal">STRING</code>
                </p><p style="color:blue;">字符串</p><p></p><p>
                    Strings are ordered lexically on the first
                    <em class="replaceable"><code>N</code></em> bytes of the
                    <code class="literal">utf8mb4</code> representation of the two strings
                    being compared, where <em class="replaceable"><code>N</code></em> is the
                    length of the shorter string. If the first
                    <em class="replaceable"><code>N</code></em> bytes of the two strings are
                    identical, the shorter string is considered smaller than the
                    longer string.
                </p><p style="color:blue;">字符串是在比较两个字符串的UTF8Mb4表示的第一个N个字节上排序的，其中N是较短字符串的长度。如果两个字符串的前n个字节相同，则认为较短的字符串小于较长的字符串。</p><p></p><p>
                    Example:
                </p><p style="color:blue;">例子：</p><p></p><pre data-lang="simple" class="programlisting">"a" &lt; "ab" &lt; "b" &lt; "bc"
</pre><p>
                    This ordering is equivalent to the ordering of SQL strings
                    with collation <code class="literal">utf8mb4_bin</code>. Because
                    <code class="literal">utf8mb4_bin</code> is a binary collation,
                    comparison of JSON values is case-sensitive:
                </p><p style="color:blue;">此顺序相当于排序规则为utf8mb4_bin的sql字符串的顺序。由于utf8mb4_bin是二进制排序规则，因此json值的比较区分大小写：</p><p></p><pre data-lang="simple" class="programlisting">"A" &lt; "a"
</pre></li><li class="listitem"><p>
                    <code class="literal">INTEGER</code>, <code class="literal">DOUBLE</code>
                </p><p style="color:blue;">整数，双精度</p><p></p><p>
                    JSON values can contain exact-value numbers and
                    approximate-value numbers. For a general discussion of these
                    types of numbers, see <a class="xref" href="language-structure.html#number-literals" title="9.1.2&nbsp;Numeric Literals">Section&nbsp;9.1.2, “Numeric Literals”</a>.
                </p><p style="color:blue;">JSON值可以包含精确值和近似值。有关这些类型的数字的一般性讨论，请参见第9.1.2节“数字文字”。</p><p></p><p>
                    The rules for comparing native MySQL numeric types are
                    discussed in <a class="xref" href="functions.html#type-conversion" title="12.2&nbsp;Type Conversion in Expression Evaluation">Section&nbsp;12.2, “Type Conversion in Expression Evaluation”</a>, but the
                    rules for comparing numbers within JSON values differ
                    somewhat:
                </p><p style="color:blue;">比较原生mysql数值类型的规则在12.2节“表达式求值中的类型转换”中进行了讨论，但是比较json值中的数字的规则有些不同：</p><p></p>
                    <div class="itemizedlist">
                        <ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
                            In a comparison between two columns that use the native
                            MySQL <a class="link" href="data-types.html#integer-types" title="11.2.1&nbsp;Integer Types (Exact Value) - INTEGER, INT, SMALLINT, TINYINT, MEDIUMINT, BIGINT"><code class="literal">INT</code></a> and
                            <a class="link" href="data-types.html#floating-point-types" title="11.2.3&nbsp;Floating-Point Types (Approximate Value) - FLOAT, DOUBLE"><code class="literal">DOUBLE</code></a> numeric types,
                            respectively, it is known that all comparisons involve
                            an integer and a double, so the integer is converted to
                            double for all rows. That is, exact-value numbers are
                            converted to approximate-value numbers.
                        </p><p style="color:blue;">在分别使用原生mysql int和double numeric类型的两列之间进行比较时，我们知道所有比较都涉及一个整数和一个double，因此所有行的整数都转换为double。也就是说，精确的数值被转换成近似的数值。</p><p></p></li><li class="listitem"><p>
                            On the other hand, if the query compares two JSON
                            columns containing numbers, it cannot be known in
                            advance whether numbers will be integer or double. To
                            provide the most consistent behavior across all rows,
                            MySQL converts approximate-value numbers to exact-value
                            numbers. The resulting ordering is consistent and does
                            not lose precision for the exact-value numbers. For
                            example, given the scalars 9223372036854775805,
                            9223372036854775806, 9223372036854775807 and
                            9.223372036854776e18, the order is such as this:
                        </p><p style="color:blue;">另一方面，如果查询比较两个包含数字的json列，则无法预先知道数字是整数还是双精度。为了在所有行中提供最一致的行为，MySQL将近似值转换为精确值。得到的排序是一致的，并且不会丢失精确数值的精度。例如，给定标量9223372036854775805、9223372036854775806、9223372036854775807和9.223372036854776e18，顺序如下：</p><p></p><pre data-lang="sql" class="programlisting">9223372036854775805 &lt; 9223372036854775806 &lt; 9223372036854775807
&lt; 9.223372036854776e18 = 9223372036854776000 &lt; 9223372036854776001
</pre></li></ul>
                    </div>
                    <p>
                        Were JSON comparisons to use the non-JSON numeric comparison
                        rules, inconsistent ordering could occur. The usual MySQL
                        comparison rules for numbers yield these orderings:
                    </p><p style="color:blue;">如果使用非json数值比较规则进行json比较，则可能出现顺序不一致的情况。通常的mysql数字比较规则产生以下顺序：</p><p></p>
                    <div class="itemizedlist">
                        <ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
                            Integer comparison:
                        </p><p style="color:blue;">整数比较：</p><p></p><pre data-lang="sql" class="programlisting">9223372036854775805 &lt; 9223372036854775806 &lt; 9223372036854775807
</pre><p>
                            (not defined for 9.223372036854776e18)
                        </p><p style="color:blue;">（9.223372036854776E18未定义）</p><p></p></li><li class="listitem"><p>
                            Double comparison:
                        </p><p style="color:blue;">双重比较：</p><p></p><pre data-lang="simple" class="programlisting">9223372036854775805 = 9223372036854775806 = 9223372036854775807 = 9.223372036854776e18
</pre></li></ul>
                    </div>
                </li></ul>
            </div>
            <p>
                For comparison of any JSON value to SQL <code class="literal">NULL</code>,
                the result is <code class="literal">UNKNOWN</code>.
            </p><p style="color:blue;">要将任何json值与sql null进行比较，结果是未知的。</p><p></p><p>
            For comparison of JSON and non-JSON values, the non-JSON value
            is converted to JSON according to the rules in the following
            table, then the values compared as described previously.
        </p><p style="color:blue;">为了比较json值和非json值，根据下表中的规则将非json值转换为json，然后按前面描述的方式将值进行比较。</p><p></p>
        </div>
        <div class="simplesect">
            <div class="titlepage">
                <div>
                    <div class="simple">
                        <h3 class="title"><a name="json-converting-between-types"></a>Converting between JSON and non-JSON values</h3>

                    </div>

                </div>

            </div>
            <p>
                The following table provides a summary of the rules that MySQL
                follows when casting between JSON values and values of other
                types:
            </p><p style="color:blue;">下表总结了MySQL在JSON值和其他类型的值之间转换时遵循的规则：</p><p></p>
            <div class="oracle-all">
                <a name="json-conversion-rules"></a><p class="title"><b>Table&nbsp;11.3&nbsp;JSON Conversion Rules</b></p><p style="color:blue;">表11.3 JSON转换规则</p><p></p>
                <div class="oracle-all-contents">
                    <table summary="Conversion rules for the JSON data type"><colgroup><col width="20%"><col width="40%"><col width="40%"></colgroup><thead><tr>
                        <th scope="col">other type</th>
                        <th scope="col">CAST(other type AS JSON)</th>
                        <th scope="col">CAST(JSON AS other type)</th>
                    </tr></thead><tbody><tr>
                        <td scope="row">JSON</td>
                        <td>No change</td>
                        <td>No change</td>
                    </tr><tr>
                        <td scope="row">utf8 character type (<code class="literal">utf8mb4</code>,
                            <code class="literal">utf8</code>, <code class="literal">ascii</code>)</td>
                        <td>The string is parsed into a JSON value.</td>
                        <td>The JSON value is serialized into a <code class="literal">utf8mb4</code> string.</td>
                    </tr><tr>
                        <td scope="row">Other character types</td>
                        <td>Other character encodings are implicitly converted to
                            <code class="literal">utf8mb4</code> and treated as described for
                            utf8 character type.</td>
                        <td>The JSON value is serialized into a <code class="literal">utf8mb4</code> string,
                            then cast to the other character encoding. The result may
                            not be meaningful.</td>
                    </tr><tr>
                        <td scope="row"><code class="literal">NULL</code></td>
                        <td>Results in a <code class="literal">NULL</code> value of type JSON.</td>
                        <td>Not applicable.</td>
                    </tr><tr>
                        <td scope="row">Geometry types</td>
                        <td>The geometry value is converted into a JSON document by calling
                            <a class="link" href="functions.html#function_st-asgeojson"><code class="literal">ST_AsGeoJSON()</code></a>.</td>
                        <td>Illegal operation. Workaround: Pass the result of
                            <a class="link" href="functions.html#function_cast"><code class="literal">CAST(<em class="replaceable"><code>json_val</code></em>
                                AS CHAR)</code></a> to
                            <a class="link" href="functions.html#function_st-geomfromgeojson"><code class="literal">ST_GeomFromGeoJSON()</code></a>.</td>
                    </tr><tr>
                        <td scope="row">All other types</td>
                        <td>Results in a JSON document consisting of a single scalar value.</td>
                        <td>Succeeds if the JSON document consists of a single scalar value of the
                            target type and that scalar value can be cast to the
                            target type. Otherwise, returns <code class="literal">NULL</code>
                            and produces a warning.</td>
                    </tr></tbody></table>
                </div>

            </div>
            <br class="oracle-all-break"><p>
            <code class="literal">ORDER BY</code> and <code class="literal">GROUP BY</code> for
            JSON values works according to these principles:
        </p><p style="color:blue;">JSON值的ORDER BY和GROUP BY根据以下原则工作：</p><p></p>
            <div class="itemizedlist">
                <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                    Ordering of scalar JSON values uses the same rules as in the
                    preceding discussion.
                </p><p style="color:blue;">标量json值的排序使用与前面讨论中相同的规则。</p><p></p></li><li class="listitem"><p>
                    For ascending sorts, SQL <code class="literal">NULL</code> orders
                    before all JSON values, including the JSON null literal; for
                    descending sorts, SQL <code class="literal">NULL</code> orders after
                    all JSON values, including the JSON null literal.
                </p><p style="color:blue;">对于升序排序，sql null在所有json值之前排序，包括json null文本；对于降序排序，sql null在所有json值之后排序，包括json null文本。</p><p></p></li><li class="listitem"><p>
                    Sort keys for JSON values are bound by the value of the
                    <a class="link" href="server-administration.html#sysvar_max_sort_length"><code class="literal">max_sort_length</code></a> system
                    variable, so keys that differ only after the first
                    <a class="link" href="server-administration.html#sysvar_max_sort_length"><code class="literal">max_sort_length</code></a> bytes
                    compare as equal.
                </p><p style="color:blue;">json值的排序键由max_sort_length系统变量的值绑定，因此仅在第一个max_sort_length字节之后不同的键比较为相等。</p><p></p></li><li class="listitem"><p>
                    Sorting of nonscalar values is not currently supported and a
                    warning occurs.
                </p><p style="color:blue;">当前不支持对非标量值进行排序，并出现警告。</p><p></p></li></ul>
            </div>
            <p>
                For sorting, it can be beneficial to cast a JSON scalar to some
                other native MySQL type. For example, if a column named
                <code class="literal">jdoc</code> contains JSON objects having a member
                consisting of an <code class="literal">id</code> key and a nonnegative
                value, use this expression to sort by <code class="literal">id</code>
                values:
            </p><p style="color:blue;">对于排序，将json标量强制转换为其他本地mysql类型是有益的。例如，如果名为jdoc的列包含json对象，该对象的成员由id键和非负值组成，请使用此表达式按id值排序：</p><p></p><pre data-lang="sql" class="programlisting">ORDER BY CAST(JSON_EXTRACT(jdoc, '$.id') AS UNSIGNED)
</pre><p>
            If there happens to be a generated column defined to use the
            same expression as in the <code class="literal">ORDER BY</code>, the MySQL
            optimizer recognizes that and considers using the index for the
            query execution plan. See
            <a class="xref" href="optimization.html#generated-column-index-optimizations" title="8.3.10&nbsp;Optimizer Use of Generated Column Indexes">Section&nbsp;8.3.10, “Optimizer Use of Generated Column Indexes”</a>.
        </p><p style="color:blue;">如果碰巧有一个生成的列被定义为使用与order by中相同的表达式，mysql优化器就会识别出这一点，并考虑将索引用于查询执行计划。见第8.3.10节，“优化器对生成列索引的使用”。</p><p></p>
        </div>
        <div class="simplesect">
            <div class="titlepage">
                <div>
                    <div class="simple">
                        <h3 class="title"><a name="json-aggregation"></a>Aggregation of JSON Values</h3>

                    </div>

                </div>

            </div>
            <p>
                For aggregation of JSON values, SQL <code class="literal">NULL</code>
                values are ignored as for other data types.
                Non-<code class="literal">NULL</code> values are converted to a numeric
                type and aggregated, except for
                <a class="link" href="functions.html#function_min"><code class="literal">MIN()</code></a>,
                <a class="link" href="functions.html#function_max"><code class="literal">MAX()</code></a>, and
                <a class="link" href="functions.html#function_group-concat"><code class="literal">GROUP_CONCAT()</code></a>. The conversion to
                number should produce a meaningful result for JSON values that
                are numeric scalars, although (depending on the values)
                truncation and loss of precision may occur. Conversion to number
                of other JSON values may not produce a meaningful result.
            </p><p style="color:blue;">对于json值的聚合，对于其他数据类型，将忽略sql空值。非空值转换为数值类型并进行聚合，但min（）、max（）和group_concat（）除外。转换为数字应该会对作为数字标量的json值产生有意义的结果，尽管（取决于这些值）可能会发生截断和精度损失。转换为其他json值可能不会产生有意义的结果。</p><p></p>
        </div>

    </div>
    <div class="section">
        <div class="titlepage">
            <div>
                <div>
                    <h2 class="title" style="clear: both"><a name="data-type-defaults"></a>11.7&nbsp;Data Type Default Values</h2>

                </div>

            </div>

        </div>
        <a class="indexterm" name="idm140286858486320"></a><a class="indexterm" name="idm140286858485280"></a><a class="indexterm" name="idm140286858483792"></a><a class="indexterm" name="idm140286858482720"></a><a class="indexterm" name="idm140286858481232"></a><a class="indexterm" name="idm140286858480160"></a><p>
        Data type specifications can have explicit or implicit default
        values.
    </p><p style="color:blue;">数据类型规范可以具有显式或隐式默认值。</p><p></p>
        <div class="itemizedlist">
            <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><a class="xref" href="data-types.html#data-types-defaults-explicit" title="Handling of Explicit Defaults">Handling of Explicit Defaults</a></p><p style="color:blue;">显式缺省的处理</p><p></p></li><li class="listitem"><p><a class="xref" href="data-types.html#data-types-defaults-implicit" title="Handling of Implicit Defaults">Handling of Implicit Defaults</a></p><p style="color:blue;">隐式违约的处理</p><p></p></li></ul>
        </div>

        <div class="simplesect">

            <div class="titlepage">
                <div>

                    <div class="simple">
                        <h3 class="title"><a name="data-types-defaults-explicit"></a>Handling of Explicit Defaults</h3>

                    </div>

                </div>

            </div>
            <p>
                A <code class="literal">DEFAULT <em class="replaceable"><code>value</code></em></code>
                clause in a data type specification explicitly indicates a
                default value for a column. Examples:
            </p><p style="color:blue;">数据类型规范中的默认值子句显式指示列的默认值。示例：</p><p></p><pre data-lang="sql" class="programlisting">CREATE TABLE t1 (
  i     INT DEFAULT -1,
  c     VARCHAR(10) DEFAULT '',
  price DOUBLE(16,2) DEFAULT '0.00'
);
</pre><a class="indexterm" name="idm140286858472416"></a><p>
            <code class="literal">SERIAL DEFAULT VALUE</code> is a special case. In
            the definition of an integer column, it is an alias for
            <code class="literal">NOT NULL AUTO_INCREMENT UNIQUE</code>.
        </p><p style="color:blue;">序列默认值是一种特殊情况。在整数列的定义中，它是非空的auto_increment unique的别名。</p><p></p><p>
            With one exception, the default value specified in a
            <code class="literal">DEFAULT</code> clause must be a literal constant; it
            cannot be a function or an expression. This means, for example,
            that you cannot set the default for a date column to be the
            value of a function such as <a class="link" href="functions.html#function_now"><code class="literal">NOW()</code></a>
            or <a class="link" href="functions.html#function_current-date"><code class="literal">CURRENT_DATE</code></a>. The exception is
            that, for <a class="link" href="data-types.html#datetime" title="11.3.1&nbsp;The DATE, DATETIME, and TIMESTAMP Types"><code class="literal">TIMESTAMP</code></a> and
            <a class="link" href="data-types.html#datetime" title="11.3.1&nbsp;The DATE, DATETIME, and TIMESTAMP Types"><code class="literal">DATETIME</code></a> columns, you can specify
            <a class="link" href="functions.html#function_current-timestamp"><code class="literal">CURRENT_TIMESTAMP</code></a> as the default.
            See <a class="xref" href="data-types.html#timestamp-initialization" title="11.3.5&nbsp;Automatic Initialization and Updating for TIMESTAMP and DATETIME">Section&nbsp;11.3.5, “Automatic Initialization and Updating for TIMESTAMP and DATETIME”</a>.
        </p><p style="color:blue;">有一个例外，默认子句中指定的默认值必须是文字常量；它不能是函数或表达式。例如，这意味着您不能将日期列的默认值设置为函数的值，例如now（）或current_date。例外情况是，对于timestamp和datetime列，可以将current_timestamp指定为默认值。见第11.3.5节“时间戳和日期时间的自动初始化和更新”。</p><p></p><p>
            The <a class="link" href="data-types.html#blob" title="11.4.3&nbsp;The BLOB and TEXT Types"><code class="literal">BLOB</code></a>,
            <a class="link" href="data-types.html#blob" title="11.4.3&nbsp;The BLOB and TEXT Types"><code class="literal">TEXT</code></a>,
            <code class="literal">GEOMETRY</code>, and
            <a class="link" href="data-types.html#json" title="11.6&nbsp;The JSON Data Type"><code class="literal">JSON</code></a> data types cannot be
            assigned a default value.
        </p><p style="color:blue;">无法为blob、文本、几何体和json数据类型分配默认值。</p><p></p>
        </div>
        <div class="simplesect">
            <div class="titlepage">
                <div>
                    <div class="simple">
                        <h3 class="title"><a name="data-types-defaults-implicit"></a>Handling of Implicit Defaults</h3>

                    </div>

                </div>

            </div>
            <p>
                If a data type specification includes no explicit
                <code class="literal">DEFAULT</code> value, MySQL determines the default
                value as follows:
            </p><p style="color:blue;">如果数据类型规范不包含显式默认值，mysql将按如下方式确定默认值：</p><p></p><p>
            If the column can take <code class="literal">NULL</code> as a value, the
            column is defined with an explicit <code class="literal">DEFAULT
            NULL</code> clause.
        </p><p style="color:blue;">如果列可以接受null作为值，则使用显式的default null子句定义该列。</p><p></p><p>
            If the column cannot take <code class="literal">NULL</code> as a value,
            MySQL defines the column with no explicit
            <code class="literal">DEFAULT</code> clause. Exception: If the column is
            defined as part of a <code class="literal">PRIMARY KEY</code> but not
            explicitly as <code class="literal">NOT NULL</code>, MySQL creates it as a
            <code class="literal">NOT NULL</code> column (because <code class="literal">PRIMARY
            KEY</code> columns must be <code class="literal">NOT NULL</code>).
        </p><p style="color:blue;">如果该列不能将null作为值，mysql将不使用显式default子句定义该列。异常：如果列被定义为主键的一部分，但未显式地定义为非空，mysql将其创建为非空列（因为主键列必须不为空）。</p><p></p><p>
            For data entry into a <code class="literal">NOT NULL</code> column that
            has no explicit <code class="literal">DEFAULT</code> clause, if an
            <a class="link" href="sql-syntax.html#insert" title="13.2.5&nbsp;INSERT Syntax"><code class="literal">INSERT</code></a> or
            <a class="link" href="sql-syntax.html#replace" title="13.2.8&nbsp;REPLACE Syntax"><code class="literal">REPLACE</code></a> statement includes no
            value for the column, or an
            <a class="link" href="sql-syntax.html#update" title="13.2.11&nbsp;UPDATE Syntax"><code class="literal">UPDATE</code></a> statement sets the column
            to <code class="literal">NULL</code>, MySQL handles the column according
            to the SQL mode in effect at the time:
        </p><p style="color:blue;">对于没有显式default子句的not null列中的数据输入，如果insert或replace语句不包含该列的值，或者update语句将该列设置为null，mysql将根据当时有效的sql模式处理该列：</p><p></p>
            <div class="itemizedlist">
                <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                    If strict SQL mode is enabled, an error occurs for
                    transactional tables and the statement is rolled back. For
                    nontransactional tables, an error occurs, but if this
                    happens for the second or subsequent row of a multiple-row
                    statement, the preceding rows will have been inserted.
                </p><p style="color:blue;">如果启用了strict sql模式，则事务表将出错并回滚该语句。对于非事务表，会发生错误，但如果对多行语句的第二行或后续行发生这种情况，则会插入前面的行。</p><p></p></li><li class="listitem"><p>
                    If strict mode is not enabled, MySQL sets the column to the
                    implicit default value for the column data type.
                </p><p style="color:blue;">如果没有启用strict模式，mysql会将列设置为列数据类型的隐式默认值。</p><p></p></li></ul>
            </div>
            <p>
                Suppose that a table <code class="literal">t</code> is defined as follows:
            </p><p style="color:blue;">假设表t的定义如下：</p><p></p><pre data-lang="sql" class="programlisting">CREATE TABLE t (i INT NOT NULL);
</pre><p>
            In this case, <code class="literal">i</code> has no explicit default, so
            in strict mode each of the following statements produce an error
            and no row is inserted. When not using strict mode, only the
            third statement produces an error; the implicit default is
            inserted for the first two statements, but the third fails
            because <a class="link" href="functions.html#function_default"><code class="literal">DEFAULT(i)</code></a> cannot produce
            a value:
        </p><p style="color:blue;">在本例中，我没有显式的默认值，因此在严格模式下，下面的每个语句都会产生一个错误，并且不会插入任何行。不使用strict模式时，只有第三条语句产生错误；前两条语句插入隐式默认值，但第三条语句失败，因为默认值（i）无法产生值：</p><p></p><pre data-lang="sql" class="programlisting">INSERT INTO t VALUES();
INSERT INTO t VALUES(DEFAULT);
INSERT INTO t VALUES(DEFAULT(i));
</pre><p>
            See <a class="xref" href="server-administration.html#sql-mode" title="5.1.10&nbsp;Server SQL Modes">Section&nbsp;5.1.10, “Server SQL Modes”</a>.
        </p><p style="color:blue;">参见第5.1.10节“服务器SQL模式”。</p><p></p><p>
            For a given table, the <a class="link" href="sql-syntax.html#show-create-table" title="13.7.5.10&nbsp;SHOW CREATE TABLE Syntax"><code class="literal">SHOW CREATE
            TABLE</code></a> statement displays which columns have an
            explicit <code class="literal">DEFAULT</code> clause.
        </p><p style="color:blue;">对于给定的表，show create table语句显示哪些列具有显式default子句。</p><p></p><p>
            Implicit defaults are defined as follows:
        </p><p style="color:blue;">隐式默认值定义如下：</p><p></p>
            <div class="itemizedlist">
                <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                    For numeric types, the default is <code class="literal">0</code>, with
                    the exception that for integer or floating-point types
                    declared with the <code class="literal">AUTO_INCREMENT</code>
                    attribute, the default is the next value in the sequence.
                </p><p style="color:blue;">对于数值类型，默认值为0，但对于使用auto_increment属性声明的整数或浮点类型，默认值是序列中的下一个值。</p><p></p></li><li class="listitem"><p>
                    For date and time types other than
                    <a class="link" href="data-types.html#datetime" title="11.3.1&nbsp;The DATE, DATETIME, and TIMESTAMP Types"><code class="literal">TIMESTAMP</code></a>, the default is the
                    appropriate <span class="quote">“<span class="quote">zero</span>”</span> value for the type. This is
                    also true for <a class="link" href="data-types.html#datetime" title="11.3.1&nbsp;The DATE, DATETIME, and TIMESTAMP Types"><code class="literal">TIMESTAMP</code></a> if
                    the
                    <a class="link" href="server-administration.html#sysvar_explicit_defaults_for_timestamp"><code class="literal">explicit_defaults_for_timestamp</code></a>
                    system variable is enabled (see
                    <a class="xref" href="server-administration.html#server-system-variables" title="5.1.7&nbsp;Server System Variables">Section&nbsp;5.1.7, “Server System Variables”</a>). Otherwise, for
                    the first <a class="link" href="data-types.html#datetime" title="11.3.1&nbsp;The DATE, DATETIME, and TIMESTAMP Types"><code class="literal">TIMESTAMP</code></a> column in
                    a table, the default value is the current date and time. See
                    <a class="xref" href="data-types.html#date-and-time-types" title="11.3&nbsp;Date and Time Types">Section&nbsp;11.3, “Date and Time Types”</a>.
                </p><p style="color:blue;">对于时间戳以外的日期和时间类型，默认值是该类型的适当“零”值。如果启用了explicit_defaults_for_timestamp系统变量，则timestamp也是如此（请参阅第5.1.7节“服务器系统变量”）。否则，对于表中的第一个时间戳列，默认值是当前日期和时间。见第11.3节“日期和时间类型”。</p><p></p></li><li class="listitem"><p>
                    For string types other than
                    <a class="link" href="data-types.html#enum" title="11.4.4&nbsp;The ENUM Type"><code class="literal">ENUM</code></a>, the default value is
                    the empty string. For <a class="link" href="data-types.html#enum" title="11.4.4&nbsp;The ENUM Type"><code class="literal">ENUM</code></a>,
                    the default is the first enumeration value.
                </p><p style="color:blue;">对于枚举以外的字符串类型，默认值为空字符串。对于枚举，默认值是第一个枚举值。</p><p></p></li></ul>
            </div>

        </div>

    </div>

    <div class="section">

        <div class="titlepage">
            <div>
                <div>
                    <h2 class="title" style="clear: both"><a name="storage-requirements"></a>11.8&nbsp;Data Type Storage Requirements</h2>

                </div>

            </div>

        </div>
        <a class="indexterm" name="idm140286858411936"></a><a class="indexterm" name="idm140286858410480"></a>
        <div class="itemizedlist">
            <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><a class="xref" href="data-types.html#data-types-storage-reqs-innodb" title="InnoDB Table Storage Requirements">InnoDB Table Storage Requirements</a></p><p style="color:blue;">InnoDB表存储要求</p><p></p></li><li class="listitem"><p><a class="xref" href="data-types.html#data-types-storage-reqs-ndb" title="NDB Table Storage Requirements">NDB Table Storage Requirements</a></p><p style="color:blue;">ndb表存储要求</p><p></p></li><li class="listitem"><p><a class="xref" href="data-types.html#data-types-storage-reqs-numeric" title="Numeric Type Storage Requirements">Numeric Type Storage Requirements</a></p><p style="color:blue;">数字型存储要求</p><p></p></li><li class="listitem"><p><a class="xref" href="data-types.html#data-types-storage-reqs-date-time" title="Date and Time Type Storage Requirements">Date and Time Type Storage Requirements</a></p><p style="color:blue;">日期和时间类型存储要求</p><p></p></li><li class="listitem"><p><a class="xref" href="data-types.html#data-types-storage-reqs-strings" title="String Type Storage Requirements">String Type Storage Requirements</a></p><p style="color:blue;">字符串类型存储要求</p><p></p></li><li class="listitem"><p><a class="xref" href="data-types.html#data-types-storage-reqs-gis" title="Spatial Type Storage Requirements">Spatial Type Storage Requirements</a></p><p style="color:blue;">空间类型存储要求</p><p></p></li><li class="listitem"><p><a class="xref" href="data-types.html#data-types-storage-reqs-json" title="JSON Storage Requirements">JSON Storage Requirements</a></p><p style="color:blue;">JSON存储要求</p><p></p></li></ul>
        </div>
        <p>
            The storage requirements for table data on disk depend on several
            factors. Different storage engines represent data types and store
            raw data differently. Table data might be compressed, either for a
            column or an entire row, complicating the calculation of storage
            requirements for a table or column.
        </p><p style="color:blue;">磁盘上表数据的存储要求取决于几个因素。不同的存储引擎表示不同的数据类型并以不同的方式存储原始数据。表数据可能会被压缩，不管是一列还是整行，这会使表或列的存储需求计算复杂化。</p><p></p><p>
        Despite differences in storage layout on disk, the internal MySQL
        APIs that communicate and exchange information about table rows
        use a consistent data structure that applies across all storage
        engines.
    </p><p style="color:blue;">尽管磁盘上的存储布局有所不同，但是内部mysql api用于通信和交换有关表行的信息，它们使用的是适用于所有存储引擎的一致数据结构。</p><p></p><p>
        This section includes guidelines and information for the storage
        requirements for each data type supported by MySQL, including the
        internal format and size for storage engines that use a fixed-size
        representation for data types. Information is listed by category
        or storage engine.
    </p><p style="color:blue;">本节包括mysql支持的每种数据类型的存储要求的指南和信息，包括使用固定大小表示的数据类型的存储引擎的内部格式和大小。信息按类别或存储引擎列出。</p><p></p><a class="indexterm" name="idm140286858399104"></a><p>
        The internal representation of a table has a maximum row size of
        65,535 bytes, even if the storage engine is capable of supporting
        larger rows. This figure excludes
        <a class="link" href="data-types.html#blob" title="11.4.3&nbsp;The BLOB and TEXT Types"><code class="literal">BLOB</code></a> or
        <a class="link" href="data-types.html#blob" title="11.4.3&nbsp;The BLOB and TEXT Types"><code class="literal">TEXT</code></a> columns, which contribute only
        9 to 12 bytes toward this size. For
        <a class="link" href="data-types.html#blob" title="11.4.3&nbsp;The BLOB and TEXT Types"><code class="literal">BLOB</code></a> and
        <a class="link" href="data-types.html#blob" title="11.4.3&nbsp;The BLOB and TEXT Types"><code class="literal">TEXT</code></a> data, the information is
        stored internally in a different area of memory than the row
        buffer. Different storage engines handle the allocation and
        storage of this data in different ways, according to the method
        they use for handling the corresponding types. For more
        information, see <a class="xref" href="storage-engines.html" title="Chapter&nbsp;15&nbsp;Alternative Storage Engines">Chapter&nbsp;15, <i>Alternative Storage Engines</i></a>, and
        <a class="xref" href="optimization.html#column-count-limit" title="8.4.7&nbsp;Limits on Table Column Count and Row Size">Section&nbsp;8.4.7, “Limits on Table Column Count and Row Size”</a>.
    </p><p style="color:blue;">即使存储引擎能够支持较大的行，表的内部表示也有65535字节的最大行大小。此图不包括blob列或文本列，它们对此大小只贡献9到12个字节。对于blob和文本数据，信息存储在内存的不同区域，而不是行缓冲区。不同的存储引擎根据处理相应类型的方法，以不同的方式处理这些数据的分配和存储。有关详细信息，请参阅第15章“替代存储引擎”和第8.4.7节“表列计数和行大小限制”。</p><p></p>
        <div class="simplesect">

            <div class="titlepage">
                <div>

                    <div class="simple">
                        <h3 class="title"><a name="data-types-storage-reqs-innodb"></a>InnoDB Table Storage Requirements</h3>
                    </div>
                </div>
            </div>
            <a class="indexterm" name="idm140286858389344"></a><a class="indexterm" name="idm140286858387856"></a><p>
            See <a class="xref" href="innodb-storage-engine.html#innodb-row-format" title="14.11&nbsp;InnoDB Row Formats">Section&nbsp;14.11, “InnoDB Row Formats”</a> for information about
            storage requirements for <code class="literal">InnoDB</code> tables.
        </p><p style="color:blue;">有关innodb表的存储要求的信息，请参阅第14.11节“innodb行格式”。</p><p></p>
        </div>

        <div class="simplesect">

            <div class="titlepage">
                <div>

                    <div class="simple">
                        <h3 class="title"><a name="data-types-storage-reqs-ndb"></a>NDB Table Storage Requirements</h3>

                    </div>

                </div>

            </div>
            <a class="indexterm" name="idm140286858383296"></a><a class="indexterm" name="idm140286858381808"></a>
            <div class="important" style="margin-left: 0.5in; margin-right: 0.5in;">

                <div class="admon-title">
                    Important
                </div>
                <p>
                    <a class="link" href="mysql-cluster.html" title="Chapter&nbsp;21&nbsp;MySQL NDB Cluster 7.5 and NDB Cluster 7.6"><code class="literal">NDB</code></a> tables use
                    <span class="firstterm">4-byte alignment</span>; all
                    <a class="link" href="mysql-cluster.html" title="Chapter&nbsp;21&nbsp;MySQL NDB Cluster 7.5 and NDB Cluster 7.6"><code class="literal">NDB</code></a> data storage is done in
                    multiples of 4 bytes. Thus, a column value that would
                    typically take 15 bytes requires 16 bytes in an
                    <a class="link" href="mysql-cluster.html" title="Chapter&nbsp;21&nbsp;MySQL NDB Cluster 7.5 and NDB Cluster 7.6"><code class="literal">NDB</code></a> table. For example, in
                    <a class="link" href="mysql-cluster.html" title="Chapter&nbsp;21&nbsp;MySQL NDB Cluster 7.5 and NDB Cluster 7.6"><code class="literal">NDB</code></a> tables, the
                    <a class="link" href="data-types.html#integer-types" title="11.2.1&nbsp;Integer Types (Exact Value) - INTEGER, INT, SMALLINT, TINYINT, MEDIUMINT, BIGINT"><code class="literal">TINYINT</code></a>,
                    <a class="link" href="data-types.html#integer-types" title="11.2.1&nbsp;Integer Types (Exact Value) - INTEGER, INT, SMALLINT, TINYINT, MEDIUMINT, BIGINT"><code class="literal">SMALLINT</code></a>,
                    <a class="link" href="data-types.html#integer-types" title="11.2.1&nbsp;Integer Types (Exact Value) - INTEGER, INT, SMALLINT, TINYINT, MEDIUMINT, BIGINT"><code class="literal">MEDIUMINT</code></a>, and
                    <a class="link" href="data-types.html#integer-types" title="11.2.1&nbsp;Integer Types (Exact Value) - INTEGER, INT, SMALLINT, TINYINT, MEDIUMINT, BIGINT"><code class="literal">INTEGER</code></a>
                    (<a class="link" href="data-types.html#integer-types" title="11.2.1&nbsp;Integer Types (Exact Value) - INTEGER, INT, SMALLINT, TINYINT, MEDIUMINT, BIGINT"><code class="literal">INT</code></a>) column types each require
                    4 bytes storage per record due to the alignment factor.
                </p><p style="color:blue;">ndb表使用4字节对齐；所有ndb数据存储都是4字节的倍数。因此，通常需要15个字节的列值在ndb表中需要16个字节。例如，在ndb表中，由于对齐因子的原因，tinyint、smallint、mediumint和integer（int）列类型每个记录都需要4字节的存储空间。</p><p></p><p>
                Each <code class="literal">BIT(<em class="replaceable"><code>M</code></em>)</code>
                column takes <em class="replaceable"><code>M</code></em> bits of storage
                space. Although an individual
                <a class="link" href="data-types.html#bit-type" title="11.2.4&nbsp;Bit-Value Type - BIT"><code class="literal">BIT</code></a> column is
                <span class="emphasis"><em>not</em></span> 4-byte aligned,
                <a class="link" href="mysql-cluster.html" title="Chapter&nbsp;21&nbsp;MySQL NDB Cluster 7.5 and NDB Cluster 7.6"><code class="literal">NDB</code></a> reserves 4 bytes (32 bits)
                per row for the first 1-32 bits needed for
                <code class="literal">BIT</code> columns, then another 4 bytes for bits
                33-64, and so on.
            </p><p style="color:blue;">每一位（m）列占用m位存储空间。尽管单个位列不是4字节对齐的，但ndb为位列所需的前1-32位保留每行4字节（32位），然后为位33-64保留另4字节，依此类推。</p><p></p><p>
                While a <code class="literal">NULL</code> itself does not require any
                storage space, <a class="link" href="mysql-cluster.html" title="Chapter&nbsp;21&nbsp;MySQL NDB Cluster 7.5 and NDB Cluster 7.6"><code class="literal">NDB</code></a> reserves 4
                bytes per row if the table definition contains any columns
                defined as <code class="literal">NULL</code>, up to 32
                <code class="literal">NULL</code> columns. (If an NDB Cluster table is
                defined with more than 32 <code class="literal">NULL</code> columns up
                to 64 <code class="literal">NULL</code> columns, then 8 bytes per row
                are reserved.)
            </p><p style="color:blue;">虽然空值本身不需要任何存储空间，但如果表定义包含任何定义为空的列，则ndb会为每行保留4个字节，最多32个空列。（如果一个ndb集群表定义了32个以上的空列，最多64个空列，那么每行保留8个字节。）</p><p></p>
            </div>
            <p>
                Every table using the <a class="link" href="mysql-cluster.html" title="Chapter&nbsp;21&nbsp;MySQL NDB Cluster 7.5 and NDB Cluster 7.6"><code class="literal">NDB</code></a> storage
                engine requires a primary key; if you do not define a primary
                key, a <span class="quote">“<span class="quote">hidden</span>”</span> primary key is created by
                <a class="link" href="mysql-cluster.html" title="Chapter&nbsp;21&nbsp;MySQL NDB Cluster 7.5 and NDB Cluster 7.6"><code class="literal">NDB</code></a>. This hidden primary key
                consumes 31-35 bytes per table record.
            </p><p style="color:blue;">使用ndb存储引擎的每个表都需要一个主键；如果不定义主键，ndb将创建一个“隐藏”主键。这个隐藏的主键每个表记录消耗31-35个字节。</p><p></p><a class="indexterm" name="idm140286858353104"></a><p>
            You can use the <a class="link" href="mysql-cluster.html#mysql-cluster-programs-ndb-size-pl" title="21.4.29&nbsp;ndb_size.pl — NDBCLUSTER Size Requirement Estimator"><span class="command"><strong>ndb_size.pl</strong></span></a> Perl script to
            estimate <a class="link" href="mysql-cluster.html" title="Chapter&nbsp;21&nbsp;MySQL NDB Cluster 7.5 and NDB Cluster 7.6"><code class="literal">NDB</code></a> storage requirements.
            It connects to a current MySQL (not NDB Cluster) database and
            creates a report on how much space that database would require
            if it used the <a class="link" href="mysql-cluster.html" title="Chapter&nbsp;21&nbsp;MySQL NDB Cluster 7.5 and NDB Cluster 7.6"><code class="literal">NDB</code></a> storage engine.
            See <a class="xref" href="mysql-cluster.html#mysql-cluster-programs-ndb-size-pl" title="21.4.29&nbsp;ndb_size.pl — NDBCLUSTER Size Requirement Estimator">Section&nbsp;21.4.29, “<span class="command"><strong>ndb_size.pl</strong></span> — NDBCLUSTER Size Requirement Estimator”</a> for
            more information.
        </p><p style="color:blue;">可以使用ndb_size.pl perl脚本来估计ndb存储需求。它连接到当前的mysql（不是ndb集群）数据库，并创建一个报告，说明如果使用ndb存储引擎，该数据库将需要多少空间。有关详细信息，请参见第21.4.29节“ndb_size.pl-ndbcluster size requirement estimator”。</p><p></p>
        </div>

        <div class="simplesect">

            <div class="titlepage">
                <div>

                    <div class="simple">
                        <h3 class="title"><a name="data-types-storage-reqs-numeric"></a>Numeric Type Storage Requirements</h3>

                    </div>

                </div>

            </div>
            <a class="indexterm" name="idm140286858345552"></a><a class="indexterm" name="idm140286858344064"></a>
            <div class="informaltable">
                <table summary="Storage required for numeric data types."><colgroup><col width="40%"><col width="60%"></colgroup><thead><tr>
                    <th scope="col">Data Type</th>
                    <th scope="col">Storage Required</th>
                </tr></thead><tbody><tr>
                    <td scope="row"><a class="link" href="data-types.html#integer-types" title="11.2.1&nbsp;Integer Types (Exact Value) - INTEGER, INT, SMALLINT, TINYINT, MEDIUMINT, BIGINT"><code class="literal">TINYINT</code></a></td>
                    <td>1 byte</td>
                </tr><tr>
                    <td scope="row"><a class="link" href="data-types.html#integer-types" title="11.2.1&nbsp;Integer Types (Exact Value) - INTEGER, INT, SMALLINT, TINYINT, MEDIUMINT, BIGINT"><code class="literal">SMALLINT</code></a></td>
                    <td>2 bytes</td>
                </tr><tr>
                    <td scope="row"><a class="link" href="data-types.html#integer-types" title="11.2.1&nbsp;Integer Types (Exact Value) - INTEGER, INT, SMALLINT, TINYINT, MEDIUMINT, BIGINT"><code class="literal">MEDIUMINT</code></a></td>
                    <td>3 bytes</td>
                </tr><tr>
                    <td scope="row"><a class="link" href="data-types.html#integer-types" title="11.2.1&nbsp;Integer Types (Exact Value) - INTEGER, INT, SMALLINT, TINYINT, MEDIUMINT, BIGINT"><code class="literal">INT</code></a>,
                        <a class="link" href="data-types.html#integer-types" title="11.2.1&nbsp;Integer Types (Exact Value) - INTEGER, INT, SMALLINT, TINYINT, MEDIUMINT, BIGINT"><code class="literal">INTEGER</code></a></td>
                    <td>4 bytes</td>
                </tr><tr>
                    <td scope="row"><a class="link" href="data-types.html#integer-types" title="11.2.1&nbsp;Integer Types (Exact Value) - INTEGER, INT, SMALLINT, TINYINT, MEDIUMINT, BIGINT"><code class="literal">BIGINT</code></a></td>
                    <td>8 bytes</td>
                </tr><tr>
                    <td scope="row"><code class="literal">FLOAT(<em class="replaceable"><code>p</code></em>)</code></td>
                    <td>4 bytes if 0 &lt;= <em class="replaceable"><code>p</code></em> &lt;= 24, 8 bytes if 25
                        &lt;= <em class="replaceable"><code>p</code></em> &lt;= 53</td>
                </tr><tr>
                    <td scope="row"><a class="link" href="data-types.html#floating-point-types" title="11.2.3&nbsp;Floating-Point Types (Approximate Value) - FLOAT, DOUBLE"><code class="literal">FLOAT</code></a></td>
                    <td>4 bytes</td>
                </tr><tr>
                    <td scope="row"><code class="literal">DOUBLE [PRECISION]</code>,
                        <a class="link" href="data-types.html#floating-point-types" title="11.2.3&nbsp;Floating-Point Types (Approximate Value) - FLOAT, DOUBLE"><code class="literal">REAL</code></a></td>
                    <td>8 bytes</td>
                </tr><tr>
                    <td scope="row"><code class="literal">DECIMAL(<em class="replaceable"><code>M</code></em>,<em class="replaceable"><code>D</code></em>)</code>,
                        <code class="literal">NUMERIC(<em class="replaceable"><code>M</code></em>,<em class="replaceable"><code>D</code></em>)</code></td>
                    <td>Varies; see following discussion</td>
                </tr><tr>
                    <td scope="row"><code class="literal">BIT(<em class="replaceable"><code>M</code></em>)</code></td>
                    <td>approximately (<em class="replaceable"><code>M</code></em>+7)/8 bytes</td>
                </tr></tbody></table>
            </div>
            <p>
                Values for <a class="link" href="data-types.html#fixed-point-types" title="11.2.2&nbsp;Fixed-Point Types (Exact Value) - DECIMAL, NUMERIC"><code class="literal">DECIMAL</code></a> (and
                <a class="link" href="data-types.html#fixed-point-types" title="11.2.2&nbsp;Fixed-Point Types (Exact Value) - DECIMAL, NUMERIC"><code class="literal">NUMERIC</code></a>) columns are represented
                using a binary format that packs nine decimal (base 10) digits
                into four bytes. Storage for the integer and fractional parts of
                each value are determined separately. Each multiple of nine
                digits requires four bytes, and the <span class="quote">“<span class="quote">leftover</span>”</span>
                digits require some fraction of four bytes. The storage required
                for excess digits is given by the following table.
            </p><p style="color:blue;">十进制（和数字）列的值使用二进制格式表示，该格式将九个十进制（以10为基数）数字压缩为四个字节。每个值的整数部分和小数部分的存储分别确定。每9位数字的倍数需要4个字节，“剩余”的数字需要4个字节的一部分。下表给出了多余数字所需的存储空间。</p><p></p>
            <div class="informaltable">
                <table summary="Storage required by excess/leftover digits in DECIMAL values."><colgroup><col width="25%"><col width="25%"></colgroup><thead><tr>
                    <th scope="col">Leftover Digits</th>
                    <th scope="col">Number of Bytes</th>
                </tr></thead><tbody><tr>
                    <td scope="row">0</td>
                    <td>0</td>
                </tr><tr>
                    <td scope="row">1</td>
                    <td>1</td>
                </tr><tr>
                    <td scope="row">2</td>
                    <td>1</td>
                </tr><tr>
                    <td scope="row">3</td>
                    <td>2</td>
                </tr><tr>
                    <td scope="row">4</td>
                    <td>2</td>
                </tr><tr>
                    <td scope="row">5</td>
                    <td>3</td>
                </tr><tr>
                    <td scope="row">6</td>
                    <td>3</td>
                </tr><tr>
                    <td scope="row">7</td>
                    <td>4</td>
                </tr><tr>
                    <td scope="row">8</td>
                    <td>4</td>
                </tr></tbody></table>
            </div>

        </div>
        <div class="simplesect">
            <div class="titlepage">
                <div>
                    <div class="simple">
                        <h3 class="title"><a name="data-types-storage-reqs-date-time"></a>Date and Time Type Storage Requirements</h3>

                    </div>

                </div>

            </div>
            <a class="indexterm" name="idm140286858267184"></a><a class="indexterm" name="idm140286858265696"></a><a class="indexterm" name="idm140286858264208"></a><a class="indexterm" name="idm140286858262720"></a><p>
            For <a class="link" href="data-types.html#time" title="11.3.2&nbsp;The TIME Type"><code class="literal">TIME</code></a>,
            <a class="link" href="data-types.html#datetime" title="11.3.1&nbsp;The DATE, DATETIME, and TIMESTAMP Types"><code class="literal">DATETIME</code></a>, and
            <a class="link" href="data-types.html#datetime" title="11.3.1&nbsp;The DATE, DATETIME, and TIMESTAMP Types"><code class="literal">TIMESTAMP</code></a> columns, the storage
            required for tables created before MySQL 5.6.4 differs from
            tables created from 5.6.4 on. This is due to a change in 5.6.4
            that permits these types to have a fractional part, which
            requires from 0 to 3 bytes.
        </p><p style="color:blue;">对于time、datetime和timestamp列，mysql 5.6.4之前创建的表所需的存储空间与上mysql 5.6.4之前创建的表所需的存储空间不同。这是由于5.6.4中的一个更改，该更改允许这些类型具有小数部分，这需要0到3个字节。</p><p></p>
            <div class="informaltable">
                <table summary="Storage required for date and time data types before MySQL 5.6.4 and as of MySQL 5.6.4."><colgroup><col width="20%"><col width="40%"><col width="40%"></colgroup><thead><tr>
                    <th scope="col">Data Type</th>
                    <th scope="col">Storage Required Before MySQL 5.6.4</th>
                    <th scope="col">Storage Required as of MySQL 5.6.4</th>
                </tr></thead><tbody><tr>
                    <td scope="row"><a class="link" href="data-types.html#year" title="11.3.3&nbsp;The YEAR Type"><code class="literal">YEAR</code></a></td>
                    <td>1 byte</td>
                    <td>1 byte</td>
                </tr><tr>
                    <td scope="row"><a class="link" href="data-types.html#datetime" title="11.3.1&nbsp;The DATE, DATETIME, and TIMESTAMP Types"><code class="literal">DATE</code></a></td>
                    <td>3 bytes</td>
                    <td>3 bytes</td>
                </tr><tr>
                    <td scope="row"><a class="link" href="data-types.html#time" title="11.3.2&nbsp;The TIME Type"><code class="literal">TIME</code></a></td>
                    <td>3 bytes</td>
                    <td>3 bytes + fractional seconds storage</td>
                </tr><tr>
                    <td scope="row"><a class="link" href="data-types.html#datetime" title="11.3.1&nbsp;The DATE, DATETIME, and TIMESTAMP Types"><code class="literal">DATETIME</code></a></td>
                    <td>8 bytes</td>
                    <td>5 bytes + fractional seconds storage</td>
                </tr><tr>
                    <td scope="row"><a class="link" href="data-types.html#datetime" title="11.3.1&nbsp;The DATE, DATETIME, and TIMESTAMP Types"><code class="literal">TIMESTAMP</code></a></td>
                    <td>4 bytes</td>
                    <td>4 bytes + fractional seconds storage</td>
                </tr></tbody></table>
            </div>
            <p>
                As of MySQL 5.6.4, storage for
                <a class="link" href="data-types.html#year" title="11.3.3&nbsp;The YEAR Type"><code class="literal">YEAR</code></a> and
                <a class="link" href="data-types.html#datetime" title="11.3.1&nbsp;The DATE, DATETIME, and TIMESTAMP Types"><code class="literal">DATE</code></a> remains unchanged. However,
                <a class="link" href="data-types.html#time" title="11.3.2&nbsp;The TIME Type"><code class="literal">TIME</code></a>,
                <a class="link" href="data-types.html#datetime" title="11.3.1&nbsp;The DATE, DATETIME, and TIMESTAMP Types"><code class="literal">DATETIME</code></a>, and
                <a class="link" href="data-types.html#datetime" title="11.3.1&nbsp;The DATE, DATETIME, and TIMESTAMP Types"><code class="literal">TIMESTAMP</code></a> are represented
                differently. <a class="link" href="data-types.html#datetime" title="11.3.1&nbsp;The DATE, DATETIME, and TIMESTAMP Types"><code class="literal">DATETIME</code></a> is packed
                more efficiently, requiring 5 rather than 8 bytes for the
                nonfractional part, and all three parts have a fractional part
                that requires from 0 to 3 bytes, depending on the fractional
                seconds precision of stored values.
            </p><p style="color:blue;">从mysql 5.6.4开始，年份和日期的存储保持不变。但是，时间、日期时间和时间戳的表示方式不同。DateTime的打包效率更高，非实用部分需要5个字节而不是8个字节，而且所有三个部分都有一个需要0到3个字节的小数部分，具体取决于存储值的小数秒精度。</p><p></p>
            <div class="informaltable">
                <table summary="Required storage for fractional seconds precision."><colgroup><col width="50%"><col width="50%"></colgroup><thead><tr>
                    <th scope="col">Fractional Seconds Precision</th>
                    <th scope="col">Storage Required</th>
                </tr></thead><tbody><tr>
                    <td scope="row">0</td>
                    <td>0 bytes</td>
                </tr><tr>
                    <td scope="row">1, 2</td>
                    <td>1 byte</td>
                </tr><tr>
                    <td scope="row">3, 4</td>
                    <td>2 bytes</td>
                </tr><tr>
                    <td scope="row">5, 6</td>
                    <td>3 bytes</td>
                </tr></tbody></table>
            </div>
            <p>
                For example, <a class="link" href="data-types.html#time" title="11.3.2&nbsp;The TIME Type"><code class="literal">TIME(0)</code></a>,
                <a class="link" href="data-types.html#time" title="11.3.2&nbsp;The TIME Type"><code class="literal">TIME(2)</code></a>,
                <a class="link" href="data-types.html#time" title="11.3.2&nbsp;The TIME Type"><code class="literal">TIME(4)</code></a>, and
                <a class="link" href="data-types.html#time" title="11.3.2&nbsp;The TIME Type"><code class="literal">TIME(6)</code></a> use 3, 4, 5, and 6 bytes,
                respectively. <a class="link" href="data-types.html#time" title="11.3.2&nbsp;The TIME Type"><code class="literal">TIME</code></a> and
                <a class="link" href="data-types.html#time" title="11.3.2&nbsp;The TIME Type"><code class="literal">TIME(0)</code></a> are equivalent and
                require the same storage.
            </p><p style="color:blue;">例如，time（0）、time（2）、time（4）和time（6）分别使用3、4、5和6字节。时间和时间（0）是等价的，需要相同的存储空间。</p><p></p><p>
            For details about internal representation of temporal values,
            see <a class="ulink" href="https://dev.mysql.com/doc/internals/en/algorithms.html" target="_top">MySQL
            Internals: Important Algorithms and Structures</a>.
        </p><p style="color:blue;">有关时态值的内部表示的详细信息，请参见mysql内部：重要算法和结构。</p><p></p>
        </div>
        <div class="simplesect">
            <div class="titlepage">
                <div>
                    <div class="simple">
                        <h3 class="title"><a name="data-types-storage-reqs-strings"></a>String Type Storage Requirements</h3>

                    </div>

                </div>

            </div>
            <a class="indexterm" name="idm140286858194432"></a><a class="indexterm" name="idm140286858192944"></a><p>
            In the following table, <em class="replaceable"><code>M</code></em> represents
            the declared column length in characters for nonbinary string
            types and bytes for binary string types.
            <em class="replaceable"><code>L</code></em> represents the actual length in
            bytes of a given string value.
        </p><p style="color:blue;">在下表中，m表示以字符表示的非二进制字符串类型的列长度，以及以字节表示的二进制字符串类型的列长度。l表示给定字符串值的实际长度（字节）。</p><p></p>
            <div class="informaltable">
                <table summary="Storage required for string types."><colgroup><col width="40%"><col width="60%"></colgroup><thead><tr>
                    <th scope="col">Data Type</th>
                    <th scope="col">Storage Required</th>
                </tr></thead><tbody><tr>
                    <td scope="row"><code class="literal">CHAR(<em class="replaceable"><code>M</code></em>)</code></td>
                    <td>The compact family of InnoDB row formats optimize storage for
                        variable-length character sets. See
                        <a class="xref" href="innodb-storage-engine.html#innodb-compact-row-format-characteristics" title="COMPACT Row Format Storage Characteristics">COMPACT Row Format Storage Characteristics</a>.
                        Otherwise, <em class="replaceable"><code>M</code></em> ×
                        <em class="replaceable"><code>w</code></em> bytes, <code class="literal">&lt;=
                            <em class="replaceable"><code>M</code></em> &lt;=</code> 255, where
                        <em class="replaceable"><code>w</code></em> is the number of bytes
                        required for the maximum-length character in the character
                        set.</td>
                </tr><tr>
                    <td scope="row"><code class="literal">BINARY(<em class="replaceable"><code>M</code></em>)</code></td>
                    <td><em class="replaceable"><code>M</code></em> bytes, 0 <code class="literal">&lt;=
                        <em class="replaceable"><code>M</code></em> &lt;=</code> 255</td>
                </tr><tr>
                    <td scope="row"><code class="literal">VARCHAR(<em class="replaceable"><code>M</code></em>)</code>,
                        <code class="literal">VARBINARY(<em class="replaceable"><code>M</code></em>)</code></td>
                    <td><em class="replaceable"><code>L</code></em> + 1 bytes if column values require 0
                        − 255 bytes, <em class="replaceable"><code>L</code></em> + 2 bytes
                        if values may require more than 255 bytes</td>
                </tr><tr>
                    <td scope="row"><a class="link" href="data-types.html#blob" title="11.4.3&nbsp;The BLOB and TEXT Types"><code class="literal">TINYBLOB</code></a>,
                        <a class="link" href="data-types.html#blob" title="11.4.3&nbsp;The BLOB and TEXT Types"><code class="literal">TINYTEXT</code></a></td>
                    <td><em class="replaceable"><code>L</code></em> + 1 bytes, where
                        <em class="replaceable"><code>L</code></em> &lt;
                        2<sup>8</sup></td>
                </tr><tr>
                    <td scope="row"><a class="link" href="data-types.html#blob" title="11.4.3&nbsp;The BLOB and TEXT Types"><code class="literal">BLOB</code></a>, <a class="link" href="data-types.html#blob" title="11.4.3&nbsp;The BLOB and TEXT Types"><code class="literal">TEXT</code></a></td>
                    <td><em class="replaceable"><code>L</code></em> + 2 bytes, where
                        <em class="replaceable"><code>L</code></em> &lt;
                        2<sup>16</sup></td>
                </tr><tr>
                    <td scope="row"><a class="link" href="data-types.html#blob" title="11.4.3&nbsp;The BLOB and TEXT Types"><code class="literal">MEDIUMBLOB</code></a>,
                        <a class="link" href="data-types.html#blob" title="11.4.3&nbsp;The BLOB and TEXT Types"><code class="literal">MEDIUMTEXT</code></a></td>
                    <td><em class="replaceable"><code>L</code></em> + 3 bytes, where
                        <em class="replaceable"><code>L</code></em> &lt;
                        2<sup>24</sup></td>
                </tr><tr>
                    <td scope="row"><a class="link" href="data-types.html#blob" title="11.4.3&nbsp;The BLOB and TEXT Types"><code class="literal">LONGBLOB</code></a>,
                        <a class="link" href="data-types.html#blob" title="11.4.3&nbsp;The BLOB and TEXT Types"><code class="literal">LONGTEXT</code></a></td>
                    <td><em class="replaceable"><code>L</code></em> + 4 bytes, where
                        <em class="replaceable"><code>L</code></em> &lt;
                        2<sup>32</sup></td>
                </tr><tr>
                    <td scope="row"><code class="literal">ENUM('<em class="replaceable"><code>value1</code></em>','<em class="replaceable"><code>value2</code></em>',...)</code></td>
                    <td>1 or 2 bytes, depending on the number of enumeration values (65,535
                        values maximum)</td>
                </tr><tr>
                    <td scope="row"><code class="literal">SET('<em class="replaceable"><code>value1</code></em>','<em class="replaceable"><code>value2</code></em>',...)</code></td>
                    <td>1, 2, 3, 4, or 8 bytes, depending on the number of set members (64
                        members maximum)</td>
                </tr></tbody></table>
            </div>
            <p>
                Variable-length string types are stored using a length prefix
                plus data. The length prefix requires from one to four bytes
                depending on the data type, and the value of the prefix is
                <em class="replaceable"><code>L</code></em> (the byte length of the string).
                For example, storage for a
                <a class="link" href="data-types.html#blob" title="11.4.3&nbsp;The BLOB and TEXT Types"><code class="literal">MEDIUMTEXT</code></a> value requires
                <em class="replaceable"><code>L</code></em> bytes to store the value plus three
                bytes to store the length of the value.
            </p><p style="color:blue;">可变长度字符串类型使用长度前缀和数据进行存储。长度前缀需要1到4个字节，具体取决于数据类型，前缀的值为L（字符串的字节长度）。例如，存储mediumtext值需要l个字节来存储该值，再加上3个字节来存储该值的长度。</p><p></p><p>
            To calculate the number of bytes used to store a particular
            <a class="link" href="data-types.html#char" title="11.4.1&nbsp;The CHAR and VARCHAR Types"><code class="literal">CHAR</code></a>,
            <a class="link" href="data-types.html#char" title="11.4.1&nbsp;The CHAR and VARCHAR Types"><code class="literal">VARCHAR</code></a>, or
            <a class="link" href="data-types.html#blob" title="11.4.3&nbsp;The BLOB and TEXT Types"><code class="literal">TEXT</code></a> column value, you must take
            into account the character set used for that column and whether
            the value contains multibyte characters. In particular, when
            using a <code class="literal">utf8</code> Unicode character set, you must
            keep in mind that not all characters use the same number of
            bytes. <code class="literal">utf8mb3</code> and <code class="literal">utf8mb4</code>
            character sets can require up to three and four bytes per
            character, respectively. For a breakdown of the storage used for
            different categories of <code class="literal">utf8mb3</code> or
            <code class="literal">utf8mb4</code> characters, see
            <a class="xref" href="charset.html#charset-unicode" title="10.9&nbsp;Unicode Support">Section&nbsp;10.9, “Unicode Support”</a>.
        </p><p style="color:blue;">要计算用于存储特定char、varchar或text列值的字节数，必须考虑该列使用的字符集以及该值是否包含多字节字符。特别是，当使用utf8 unicode字符集时，必须记住并非所有字符都使用相同的字节数。utf8mb3和utf8mb4字符集分别最多需要3和4个字节。有关用于不同类别的utf8mb3或utf8mb4字符的存储的详细信息，请参阅10.9节“Unicode支持”。</p><p></p><a class="indexterm" name="idm140286858126496"></a><a class="indexterm" name="idm140286858125008"></a><a class="indexterm" name="idm140286858123520"></a><p>
            <a class="link" href="data-types.html#char" title="11.4.1&nbsp;The CHAR and VARCHAR Types"><code class="literal">VARCHAR</code></a>,
            <a class="link" href="data-types.html#binary-varbinary" title="11.4.2&nbsp;The BINARY and VARBINARY Types"><code class="literal">VARBINARY</code></a>, and the
            <a class="link" href="data-types.html#blob" title="11.4.3&nbsp;The BLOB and TEXT Types"><code class="literal">BLOB</code></a> and
            <a class="link" href="data-types.html#blob" title="11.4.3&nbsp;The BLOB and TEXT Types"><code class="literal">TEXT</code></a> types are variable-length
            types. For each, the storage requirements depend on these
            factors:
        </p><p style="color:blue;">varchar、varbinary以及blob和text类型都是可变长度类型。对于每种情况，存储要求取决于以下因素：</p><p></p>
            <div class="itemizedlist">
                <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                    The actual length of the column value
                </p><p style="color:blue;">列值的实际长度</p><p></p></li><li class="listitem"><p>
                    The column's maximum possible length
                </p><p style="color:blue;">列的最大可能长度</p><p></p></li><li class="listitem"><p>
                    The character set used for the column, because some
                    character sets contain multibyte characters
                </p><p style="color:blue;">用于列的字符集，因为某些字符集包含多字节字符</p><p></p></li></ul>
            </div>
            <p>
                For example, a <code class="literal">VARCHAR(255)</code> column can hold a
                string with a maximum length of 255 characters. Assuming that
                the column uses the <code class="literal">latin1</code> character set (one
                byte per character), the actual storage required is the length
                of the string (<em class="replaceable"><code>L</code></em>), plus one byte to
                record the length of the string. For the string
                <code class="literal">'abcd'</code>, <em class="replaceable"><code>L</code></em> is 4 and
                the storage requirement is five bytes. If the same column is
                instead declared to use the <code class="literal">ucs2</code> double-byte
                character set, the storage requirement is 10 bytes: The length
                of <code class="literal">'abcd'</code> is eight bytes and the column
                requires two bytes to store lengths because the maximum length
                is greater than 255 (up to 510 bytes).
            </p><p style="color:blue;">例如，VARCHAR（255）列可以保存一个最大长度为255个字符的字符串。假设列使用latin1字符集（每个字符一个字节），实际需要的存储空间是字符串的长度（l），加上一个字节来记录字符串的长度。对于字符串“abcd”，l为4，存储要求为5个字节。如果相同的列被声明为使用UCS2双字节字符集，则存储要求为10字节：“ABCD”的长度为八字节，并且列需要两个字节来存储长度，因为最大长度大于255（最多510字节）。</p><p></p><p>
            The effective maximum number of <span class="emphasis"><em>bytes</em></span> that
            can be stored in a <a class="link" href="data-types.html#char" title="11.4.1&nbsp;The CHAR and VARCHAR Types"><code class="literal">VARCHAR</code></a> or
            <a class="link" href="data-types.html#binary-varbinary" title="11.4.2&nbsp;The BINARY and VARBINARY Types"><code class="literal">VARBINARY</code></a> column is subject to
            the maximum row size of 65,535 bytes, which is shared among all
            columns. For a <a class="link" href="data-types.html#char" title="11.4.1&nbsp;The CHAR and VARCHAR Types"><code class="literal">VARCHAR</code></a> column
            that stores multibyte characters, the effective maximum number
            of <span class="emphasis"><em>characters</em></span> is less. For example,
            <code class="literal">utf8mb3</code> characters can require up to three
            bytes per character, so a <a class="link" href="data-types.html#char" title="11.4.1&nbsp;The CHAR and VARCHAR Types"><code class="literal">VARCHAR</code></a>
            column that uses the <code class="literal">utf8mb3</code> character set
            can be declared to be a maximum of 21,844 characters. See
            <a class="xref" href="optimization.html#column-count-limit" title="8.4.7&nbsp;Limits on Table Column Count and Row Size">Section&nbsp;8.4.7, “Limits on Table Column Count and Row Size”</a>.
        </p><p style="color:blue;">可以存储在VARCHAR或VARDION列中的有效最大字节数受最大列大小的65535字节的影响，这些列在所有列之间共享。对于存储多字节字符的VARCHAR列，有效的最大字符数较少。例如，UTF8Mb3字符需要每个字符最多三字节，因此使用UTF8Mb3字符集的VARCHAR列可以被声明为最多21844个字符。见第8.4.7节，“表格列数和行大小限制”。</p><p></p><p>
            <code class="literal">InnoDB</code> encodes fixed-length fields greater
            than or equal to 768 bytes in length as variable-length fields,
            which can be stored off-page. For example, a
            <code class="literal">CHAR(255)</code> column can exceed 768 bytes if the
            maximum byte length of the character set is greater than 3, as
            it is with <code class="literal">utf8mb4</code>.
        </p><p style="color:blue;">innodb将长度大于或等于768字节的固定长度字段编码为可变长度字段，这些字段可以在页面外存储。例如，如果字符集的最大字节长度大于3，则字符（255）列可以超过768字节，因为它与UTF8Mb4是相同的。</p><p></p><p>
            The <a class="link" href="mysql-cluster.html" title="Chapter&nbsp;21&nbsp;MySQL NDB Cluster 7.5 and NDB Cluster 7.6"><code class="literal">NDB</code></a> storage engine supports
            variable-width columns. This means that a
            <a class="link" href="data-types.html#char" title="11.4.1&nbsp;The CHAR and VARCHAR Types"><code class="literal">VARCHAR</code></a> column in an NDB Cluster
            table requires the same amount of storage as would any other
            storage engine, with the exception that such values are 4-byte
            aligned. Thus, the string <code class="literal">'abcd'</code> stored in a
            <code class="literal">VARCHAR(50)</code> column using the
            <code class="literal">latin1</code> character set requires 8 bytes (rather
            than 5 bytes for the same column value in a
            <code class="literal">MyISAM</code> table).
        </p><p style="color:blue;">ndb存储引擎支持可变宽度列。这意味着ndb集群表中的varchar列需要与任何其他存储引擎相同的存储量，但这些值是4字节对齐的。因此，使用latin1字符集存储在varchar（50）列中的字符串'abcd'需要8个字节（而不是myisam表中相同列值的5个字节）。</p><p></p><p>
            <a class="link" href="data-types.html#blob" title="11.4.3&nbsp;The BLOB and TEXT Types"><code class="literal">TEXT</code></a> and
            <a class="link" href="data-types.html#blob" title="11.4.3&nbsp;The BLOB and TEXT Types"><code class="literal">BLOB</code></a> columns are implemented
            differently in the <a class="link" href="mysql-cluster.html" title="Chapter&nbsp;21&nbsp;MySQL NDB Cluster 7.5 and NDB Cluster 7.6"><code class="literal">NDB</code></a> storage
            engine, wherein each row in a
            <a class="link" href="data-types.html#blob" title="11.4.3&nbsp;The BLOB and TEXT Types"><code class="literal">TEXT</code></a> column is made up of two
            separate parts. One of these is of fixed size (256 bytes), and
            is actually stored in the original table. The other consists of
            any data in excess of 256 bytes, which is stored in a hidden
            table. The rows in this second table are always 2000 bytes long.
            This means that the size of a
            <a class="link" href="data-types.html#blob" title="11.4.3&nbsp;The BLOB and TEXT Types"><code class="literal">TEXT</code></a> column is 256 if
            <em class="replaceable"><code>size</code></em> &lt;= 256 (where
            <em class="replaceable"><code>size</code></em> represents the size of the row);
            otherwise, the size is 256 +
            <em class="replaceable"><code>size</code></em> + (2000 ×
            (<em class="replaceable"><code>size</code></em> − 256) % 2000).
        </p><p style="color:blue;">在ndb存储引擎中，文本列和blob列的实现方式不同，其中文本列中的每一行由两个独立的部分组成。其中一个是固定大小（256字节），实际存储在原始表中。另一个由超过256字节的任何数据组成，这些数据存储在一个隐藏表中。第二个表中的行总是2000字节长。这意味着，如果大小&lt;=256，则文本列的大小为256（其中大小表示行的大小）；否则，大小为256+大小+（2000×（大小−256）%2000）。</p><p></p><a class="indexterm" name="idm140286858081776"></a><p>
            The size of an <a class="link" href="data-types.html#enum" title="11.4.4&nbsp;The ENUM Type"><code class="literal">ENUM</code></a> object is
            determined by the number of different enumeration values. One
            byte is used for enumerations with up to 255 possible values.
            Two bytes are used for enumerations having between 256 and
            65,535 possible values. See <a class="xref" href="data-types.html#enum" title="11.4.4&nbsp;The ENUM Type">Section&nbsp;11.4.4, “The ENUM Type”</a>.
        </p><p style="color:blue;">枚举对象的大小由不同枚举值的数目决定。一个字节用于最多255个可能值的枚举。两个字节用于具有256到65535个可能值的枚举。见第11.4.4节“枚举类型”。</p><p></p><a class="indexterm" name="idm140286858077712"></a><p>
            The size of a <a class="link" href="data-types.html#set" title="11.4.5&nbsp;The SET Type"><code class="literal">SET</code></a> object is
            determined by the number of different set members. If the set
            size is <em class="replaceable"><code>N</code></em>, the object occupies
            <code class="literal">(<em class="replaceable"><code>N</code></em>+7)/8</code> bytes,
            rounded up to 1, 2, 3, 4, or 8 bytes. A
            <a class="link" href="data-types.html#set" title="11.4.5&nbsp;The SET Type"><code class="literal">SET</code></a> can have a maximum of 64
            members. See <a class="xref" href="data-types.html#set" title="11.4.5&nbsp;The SET Type">Section&nbsp;11.4.5, “The SET Type”</a>.
        </p><p style="color:blue;">集合对象的大小由不同集合成员的数目决定。如果设置的大小为n，则对象占用（n+7）/8字节，四舍五入为1、2、3、4或8字节。一个集合最多可以有64个成员。见第11.4.5节“设置类型”。</p><p></p>
        </div>
        <div class="simplesect">
            <div class="titlepage">
                <div>
                    <div class="simple">
                        <h3 class="title"><a name="data-types-storage-reqs-gis"></a>Spatial Type Storage Requirements</h3>

                    </div>

                </div>

            </div>
            <a class="indexterm" name="idm140286858069888"></a><a class="indexterm" name="idm140286858068400"></a><a class="indexterm" name="idm140286858066912"></a><p>
            MySQL stores geometry values using 4 bytes to indicate the SRID
            followed by the WKB representation of the value. The
            <a class="link" href="functions.html#function_length"><code class="literal">LENGTH()</code></a> function returns the
            space in bytes required for value storage.
        </p><p style="color:blue;">mysql使用4个字节存储几何体值，以指示srid后跟值的wkb表示。函数的作用是：返回值存储所需的字节空间。</p><p></p><p>
            For descriptions of WKB and internal storage formats for spatial
            values, see <a class="xref" href="data-types.html#gis-data-formats" title="11.5.3&nbsp;Supported Spatial Data Formats">Section&nbsp;11.5.3, “Supported Spatial Data Formats”</a>.
        </p><p style="color:blue;">有关WKB和空间值的内部存储格式的说明，请参见第11.5.3节“支持的空间数据格式”。</p><p></p>
        </div>
        <div class="simplesect">
            <div class="titlepage">
                <div>
                    <div class="simple">
                        <h3 class="title"><a name="data-types-storage-reqs-json"></a>JSON Storage Requirements</h3>

                    </div>

                </div>

            </div>
            <p>
                In general, the storage requirement for a
                <a class="link" href="data-types.html#json" title="11.6&nbsp;The JSON Data Type"><code class="literal">JSON</code></a> column is approximately the
                same as for a <code class="literal">LONGBLOB</code> or
                <code class="literal">LONGTEXT</code> column; that is, the space consumed
                by a JSON document is roughly the same as it would be for the
                document's string representation stored in a column of one
                of these types. However, there is an overhead imposed by the
                binary encoding, including metadata and dictionaries needed for
                lookup, of the individual values stored in the JSON document.
                For example, a string stored in a JSON document requires 4 to 10
                bytes additional storage, depending on the length of the string
                and the size of the object or array in which it is stored.
            </p><p style="color:blue;">一般来说，JSON列的存储要求与LoBulb或LoType列大致相同；也就是说，JSON文档所占用的空间与存储在这些类型的列中的文档的字符串表示方式大致相同。但是，对于存储在json文档中的各个值，二进制编码（包括查找所需的元数据和字典）会增加开销。例如，json文档中存储的字符串需要4到10个字节的额外存储，这取决于字符串的长度以及存储它的对象或数组的大小。</p><p></p><p>
            In addition, MySQL imposes a limit on the size of any JSON
            document stored in a <code class="literal">JSON</code> column such that it
            cannot be any larger than the value of
            <a class="link" href="server-administration.html#sysvar_max_allowed_packet"><code class="literal">max_allowed_packet</code></a>.
        </p><p style="color:blue;">此外，mysql对存储在json列中的任何json文档的大小进行了限制，使其不能大于max_allowed_packet的值。</p><p></p>
        </div>

    </div>
    <div class="section">
        <div class="titlepage">
            <div>
                <div>
                    <h2 class="title" style="clear: both"><a name="choosing-types"></a>11.9&nbsp;Choosing the Right Type for a Column</h2>

                </div>

            </div>

        </div>
        <a class="indexterm" name="idm140286858053248"></a><a class="indexterm" name="idm140286858051792"></a><p>
        For optimum storage, you should try to use the most precise type
        in all cases. For example, if an integer column is used for values
        in the range from <code class="literal">1</code> to
        <code class="literal">99999</code>, <code class="literal">MEDIUMINT UNSIGNED</code> is
        the best type. Of the types that represent all the required
        values, this type uses the least amount of storage.
    </p><p style="color:blue;">为了获得最佳的存储，您应该在所有情况下尝试使用最精确的类型。例如，如果整数列用于1到99999范围内的值，则mediumint unsigned是最佳类型。在表示所有必需值的类型中，此类型使用的存储量最少。</p><p></p><p>
        All basic calculations (<code class="literal">+</code>,
        <code class="literal">-</code>, <code class="literal">*</code>, and
        <code class="literal">/</code>) with <a class="link" href="data-types.html#fixed-point-types" title="11.2.2&nbsp;Fixed-Point Types (Exact Value) - DECIMAL, NUMERIC"><code class="literal">DECIMAL</code></a>
        columns are done with precision of 65 decimal (base 10) digits.
        See <a class="xref" href="data-types.html#numeric-type-overview" title="11.1.1&nbsp;Numeric Type Overview">Section&nbsp;11.1.1, “Numeric Type Overview”</a>.
    </p><p style="color:blue;">所有带小数列的基本计算（+、-、*和/）均以65位小数（以10位为基数）的精度完成。见第11.1.1节“数字类型概述”。</p><p></p><p>
        If accuracy is not too important or if speed is the highest
        priority, the <a class="link" href="data-types.html#floating-point-types" title="11.2.3&nbsp;Floating-Point Types (Approximate Value) - FLOAT, DOUBLE"><code class="literal">DOUBLE</code></a> type may be
        good enough. For high precision, you can always convert to a
        fixed-point type stored in a
        <a class="link" href="data-types.html#integer-types" title="11.2.1&nbsp;Integer Types (Exact Value) - INTEGER, INT, SMALLINT, TINYINT, MEDIUMINT, BIGINT"><code class="literal">BIGINT</code></a>. This enables you to do all
        calculations with 64-bit integers and then convert results back to
        floating-point values as necessary.
    </p><p style="color:blue;">如果精度不太重要，或者速度是最高优先级，那么双精度就足够了。为了获得高精度，您始终可以转换为存储在bigint中的定点类型。这使您能够使用64位整数进行所有计算，然后根据需要将结果转换回浮点值。</p><p></p>
    </div>
    <div class="section">
        <div class="titlepage">
            <div>
                <div>
                    <h2 class="title" style="clear: both"><a name="other-vendor-data-types"></a>11.10&nbsp;Using Data Types from Other Database Engines</h2>

                </div>

            </div>

        </div>
        <a class="indexterm" name="idm140286858037808"></a><a class="indexterm" name="idm140286858036352"></a><a class="indexterm" name="idm140286858034864"></a><a class="indexterm" name="idm140286858033376"></a><a class="indexterm" name="idm140286858031888"></a><p>
        To facilitate the use of code written for SQL implementations from
        other vendors, MySQL maps data types as shown in the following
        table. These mappings make it easier to import table definitions
        from other database systems into MySQL.
    </p><p style="color:blue;">为了方便使用其他供应商为sql实现编写的代码，mysql映射数据类型，如下表所示。这些映射使从其他数据库系统将表定义导入mysql变得更容易。</p><p></p>
        <div class="informaltable">
            <table summary="Mapping of MySQL data types to data types from other vendors."><colgroup><col width="35%"><col width="55%"></colgroup><thead><tr>
                <th scope="col">Other Vendor Type</th>
                <th scope="col">MySQL Type</th>
            </tr></thead><tbody><tr>
                <td scope="row"><a class="link" href="data-types.html#integer-types" title="11.2.1&nbsp;Integer Types (Exact Value) - INTEGER, INT, SMALLINT, TINYINT, MEDIUMINT, BIGINT"><code class="literal">BOOL</code></a></td>
                <td><a class="link" href="data-types.html#integer-types" title="11.2.1&nbsp;Integer Types (Exact Value) - INTEGER, INT, SMALLINT, TINYINT, MEDIUMINT, BIGINT"><code class="literal">TINYINT</code></a></td>
            </tr><tr>
                <td scope="row"><a class="link" href="data-types.html#integer-types" title="11.2.1&nbsp;Integer Types (Exact Value) - INTEGER, INT, SMALLINT, TINYINT, MEDIUMINT, BIGINT"><code class="literal">BOOLEAN</code></a></td>
                <td><a class="link" href="data-types.html#integer-types" title="11.2.1&nbsp;Integer Types (Exact Value) - INTEGER, INT, SMALLINT, TINYINT, MEDIUMINT, BIGINT"><code class="literal">TINYINT</code></a></td>
            </tr><tr>
                <td scope="row"><code class="literal">CHARACTER VARYING(<em class="replaceable"><code>M</code></em>)</code></td>
                <td><code class="literal">VARCHAR(<em class="replaceable"><code>M</code></em>)</code></td>
            </tr><tr>
                <td scope="row"><a class="link" href="data-types.html#fixed-point-types" title="11.2.2&nbsp;Fixed-Point Types (Exact Value) - DECIMAL, NUMERIC"><code class="literal">FIXED</code></a></td>
                <td><a class="link" href="data-types.html#fixed-point-types" title="11.2.2&nbsp;Fixed-Point Types (Exact Value) - DECIMAL, NUMERIC"><code class="literal">DECIMAL</code></a></td>
            </tr><tr>
                <td scope="row"><a class="link" href="data-types.html#floating-point-types" title="11.2.3&nbsp;Floating-Point Types (Approximate Value) - FLOAT, DOUBLE"><code class="literal">FLOAT4</code></a></td>
                <td><a class="link" href="data-types.html#floating-point-types" title="11.2.3&nbsp;Floating-Point Types (Approximate Value) - FLOAT, DOUBLE"><code class="literal">FLOAT</code></a></td>
            </tr><tr>
                <td scope="row"><a class="link" href="data-types.html#floating-point-types" title="11.2.3&nbsp;Floating-Point Types (Approximate Value) - FLOAT, DOUBLE"><code class="literal">FLOAT8</code></a></td>
                <td><a class="link" href="data-types.html#floating-point-types" title="11.2.3&nbsp;Floating-Point Types (Approximate Value) - FLOAT, DOUBLE"><code class="literal">DOUBLE</code></a></td>
            </tr><tr>
                <td scope="row"><a class="link" href="data-types.html#integer-types" title="11.2.1&nbsp;Integer Types (Exact Value) - INTEGER, INT, SMALLINT, TINYINT, MEDIUMINT, BIGINT"><code class="literal">INT1</code></a></td>
                <td><a class="link" href="data-types.html#integer-types" title="11.2.1&nbsp;Integer Types (Exact Value) - INTEGER, INT, SMALLINT, TINYINT, MEDIUMINT, BIGINT"><code class="literal">TINYINT</code></a></td>
            </tr><tr>
                <td scope="row"><a class="link" href="data-types.html#integer-types" title="11.2.1&nbsp;Integer Types (Exact Value) - INTEGER, INT, SMALLINT, TINYINT, MEDIUMINT, BIGINT"><code class="literal">INT2</code></a></td>
                <td><a class="link" href="data-types.html#integer-types" title="11.2.1&nbsp;Integer Types (Exact Value) - INTEGER, INT, SMALLINT, TINYINT, MEDIUMINT, BIGINT"><code class="literal">SMALLINT</code></a></td>
            </tr><tr>
                <td scope="row"><a class="link" href="data-types.html#integer-types" title="11.2.1&nbsp;Integer Types (Exact Value) - INTEGER, INT, SMALLINT, TINYINT, MEDIUMINT, BIGINT"><code class="literal">INT3</code></a></td>
                <td><a class="link" href="data-types.html#integer-types" title="11.2.1&nbsp;Integer Types (Exact Value) - INTEGER, INT, SMALLINT, TINYINT, MEDIUMINT, BIGINT"><code class="literal">MEDIUMINT</code></a></td>
            </tr><tr>
                <td scope="row"><a class="link" href="data-types.html#integer-types" title="11.2.1&nbsp;Integer Types (Exact Value) - INTEGER, INT, SMALLINT, TINYINT, MEDIUMINT, BIGINT"><code class="literal">INT4</code></a></td>
                <td><a class="link" href="data-types.html#integer-types" title="11.2.1&nbsp;Integer Types (Exact Value) - INTEGER, INT, SMALLINT, TINYINT, MEDIUMINT, BIGINT"><code class="literal">INT</code></a></td>
            </tr><tr>
                <td scope="row"><code class="literal">INT8</code></td>
                <td><a class="link" href="data-types.html#integer-types" title="11.2.1&nbsp;Integer Types (Exact Value) - INTEGER, INT, SMALLINT, TINYINT, MEDIUMINT, BIGINT"><code class="literal">BIGINT</code></a></td>
            </tr><tr>
                <td scope="row"><code class="literal">LONG VARBINARY</code></td>
                <td><a class="link" href="data-types.html#blob" title="11.4.3&nbsp;The BLOB and TEXT Types"><code class="literal">MEDIUMBLOB</code></a></td>
            </tr><tr>
                <td scope="row"><code class="literal">LONG VARCHAR</code></td>
                <td><a class="link" href="data-types.html#blob" title="11.4.3&nbsp;The BLOB and TEXT Types"><code class="literal">MEDIUMTEXT</code></a></td>
            </tr><tr>
                <td scope="row"><code class="literal">LONG</code></td>
                <td><a class="link" href="data-types.html#blob" title="11.4.3&nbsp;The BLOB and TEXT Types"><code class="literal">MEDIUMTEXT</code></a></td>
            </tr><tr>
                <td scope="row"><a class="link" href="data-types.html#integer-types" title="11.2.1&nbsp;Integer Types (Exact Value) - INTEGER, INT, SMALLINT, TINYINT, MEDIUMINT, BIGINT"><code class="literal">MIDDLEINT</code></a></td>
                <td><a class="link" href="data-types.html#integer-types" title="11.2.1&nbsp;Integer Types (Exact Value) - INTEGER, INT, SMALLINT, TINYINT, MEDIUMINT, BIGINT"><code class="literal">MEDIUMINT</code></a></td>
            </tr><tr>
                <td scope="row"><a class="link" href="data-types.html#fixed-point-types" title="11.2.2&nbsp;Fixed-Point Types (Exact Value) - DECIMAL, NUMERIC"><code class="literal">NUMERIC</code></a></td>
                <td><a class="link" href="data-types.html#fixed-point-types" title="11.2.2&nbsp;Fixed-Point Types (Exact Value) - DECIMAL, NUMERIC"><code class="literal">DECIMAL</code></a></td>
            </tr></tbody></table>
        </div>
        <p>
            Data type mapping occurs at table creation time, after which the
            original type specifications are discarded. If you create a table
            with types used by other vendors and then issue a
            <code class="literal">DESCRIBE <em class="replaceable"><code>tbl_name</code></em></code>
            statement, MySQL reports the table structure using the equivalent
            MySQL types. For example:
        </p><p style="color:blue;">数据类型映射在表创建时发生，之后将丢弃原始类型规范。如果使用其他供应商使用的类型创建表，然后发出describe tbl_name语句，mysql将使用等效的mysql类型报告表结构。例如：</p><p></p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>CREATE TABLE t (a BOOL, b FLOAT8, c LONG VARCHAR, d NUMERIC);</code></strong>
Query OK, 0 rows affected (0.00 sec)

mysql&gt; <strong class="userinput"><code>DESCRIBE t;</code></strong>
+-------+---------------+------+-----+---------+-------+
| Field | Type          | Null | Key | Default | Extra |
+-------+---------------+------+-----+---------+-------+
| a     | tinyint(1)    | YES  |     | NULL    |       |
| b     | double        | YES  |     | NULL    |       |
| c     | mediumtext    | YES  |     | NULL    |       |
| d     | decimal(10,0) | YES  |     | NULL    |       |
+-------+---------------+------+-----+---------+-------+
4 rows in set (0.01 sec)
</pre>
    </div>

</div>
<div class="copyright-footer">

</div>
<div class="navfooter">
    <hr>
    <table width="100%" summary="Navigation footer">
        <tbody><tr>
            <td width="40%" align="left"><a accesskey="p" href="charset.html">Prev</a></td>
            <td width="20%" align="center"><a accesskey="u" href="">Up</a></td>
            <td width="40%" align="right">&nbsp;<a accesskey="n" href="functions.html">Next</a></td>
        </tr>
        <tr>
            <td width="40%" align="left" valign="top">Chapter&nbsp;10 Character Sets, Collations, Unicode</td>
            <td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td>
            <td width="40%" align="right" valign="top">Chapter&nbsp;12 Functions and Operators</td>
        </tr>
        </tbody></table>
</div>


</body></html>