<html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
    <title>Chapter&nbsp;16 Replication</title>
    <link rel="stylesheet" href="mvl.css" type="text/css">
    <meta name="generator" content="DocBook XSL Stylesheets + chunker.py v1.9.2">
    <link rel="start" href="index.html" title="{book-title}">
    <link rel="up" href="" title="">
    <link rel="prev" href="storage-engines.html" title="Chapter&nbsp;15 Alternative Storage Engines">
    <link rel="next" href="group-replication.html" title="Chapter&nbsp;17 Group Replication">
    <script src="https://code.jquery.com/jquery-3.3.1.min.js"></script><script src="https://code.jquery.com/jquery-3.3.1.min.js"></script><script src="https://code.jquery.com/jquery-3.3.1.min.js"></script></head>
<body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF">
<div class="navheader">
    <table width="100%" summary="Navigation header">
        <tbody><tr>
            <th colspan="3" align="center">Chapter&nbsp;16 Replication</th>
        </tr>
        <tr>
            <td width="20%" align="left"><a accesskey="p" href="storage-engines.html">Prev</a>&nbsp;</td>
            <th width="60%" align="center"></th>
            <td width="20%" align="right">&nbsp;<a accesskey="n" href="group-replication.html">Next</a></td>
        </tr>
        </tbody></table>
    <hr>
</div>
<div class="chapter">
    <div class="titlepage">
        <div>
            <div>
                <h1 class="title"><a name="replication"></a>Chapter&nbsp;16&nbsp;Replication</h1>

            </div>

        </div>

    </div>
    <div class="toc">
        <p><b>Table of Contents</b></p><p style="color:blue;">目录</p><dl class="toc"><dt><span class="section"><a href="replication.html#replication-configuration">16.1 Configuring Replication</a></span></dt><dd><dl><dt><span class="section"><a href="replication.html#binlog-replication-configuration-overview">16.1.1 Binary Log File Position Based Replication Configuration Overview</a></span></dt><dt><span class="section"><a href="replication.html#replication-howto">16.1.2 Setting Up Binary Log File Position Based Replication</a></span></dt><dt><span class="section"><a href="replication.html#replication-gtids">16.1.3 Replication with Global Transaction Identifiers</a></span></dt><dt><span class="section"><a href="replication.html#replication-multi-source">16.1.4 MySQL Multi-Source Replication</a></span></dt><dt><span class="section"><a href="replication.html#replication-mode-change-online">16.1.5 Changing Replication Modes on Online Servers</a></span></dt><dt><span class="section"><a href="replication.html#replication-options">16.1.6 Replication and Binary Logging Options and Variables</a></span></dt><dt><span class="section"><a href="replication.html#replication-administration">16.1.7 Common Replication Administration Tasks</a></span></dt></dl></dd><dt><span class="section"><a href="replication.html#replication-implementation">16.2 Replication Implementation</a></span></dt><dd><dl><dt><span class="section"><a href="replication.html#replication-formats">16.2.1 Replication Formats</a></span></dt><dt><span class="section"><a href="replication.html#replication-implementation-details">16.2.2 Replication Implementation Details</a></span></dt><dt><span class="section"><a href="replication.html#replication-channels">16.2.3 Replication Channels</a></span></dt><dt><span class="section"><a href="replication.html#slave-logs">16.2.4 Replication Relay and Status Logs</a></span></dt><dt><span class="section"><a href="replication.html#replication-rules">16.2.5 How Servers Evaluate Replication Filtering Rules</a></span></dt></dl></dd><dt><span class="section"><a href="replication.html#replication-solutions">16.3 Replication Solutions</a></span></dt><dd><dl><dt><span class="section"><a href="replication.html#replication-solutions-backups">16.3.1 Using Replication for Backups</a></span></dt><dt><span class="section"><a href="replication.html#replication-solutions-unexpected-slave-halt">16.3.2 Handling an Unexpected Halt of a Replication Slave</a></span></dt><dt><span class="section"><a href="replication.html#replication-solutions-diffengines">16.3.3 Using Replication with Different Master and Slave Storage Engines</a></span></dt><dt><span class="section"><a href="replication.html#replication-solutions-scaleout">16.3.4 Using Replication for Scale-Out</a></span></dt><dt><span class="section"><a href="replication.html#replication-solutions-partitioning">16.3.5 Replicating Different Databases to Different Slaves</a></span></dt><dt><span class="section"><a href="replication.html#replication-solutions-performance">16.3.6 Improving Replication Performance</a></span></dt><dt><span class="section"><a href="replication.html#replication-solutions-switch">16.3.7 Switching Masters During Failover</a></span></dt><dt><span class="section"><a href="replication.html#replication-solutions-encrypted-connections">16.3.8 Setting Up Replication to Use Encrypted Connections</a></span></dt><dt><span class="section"><a href="replication.html#replication-semisync">16.3.9 Semisynchronous Replication</a></span></dt><dt><span class="section"><a href="replication.html#replication-delayed">16.3.10 Delayed Replication</a></span></dt></dl></dd><dt><span class="section"><a href="replication.html#replication-notes">16.4 Replication Notes and Tips</a></span></dt><dd><dl><dt><span class="section"><a href="replication.html#replication-features">16.4.1 Replication Features and Issues</a></span></dt><dt><span class="section"><a href="replication.html#replication-compatibility">16.4.2 Replication Compatibility Between MySQL Versions</a></span></dt><dt><span class="section"><a href="replication.html#replication-upgrade">16.4.3 Upgrading a Replication Setup</a></span></dt><dt><span class="section"><a href="replication.html#replication-problems">16.4.4 Troubleshooting Replication</a></span></dt><dt><span class="section"><a href="replication.html#replication-bugs">16.4.5 How to Report Replication Bugs or Problems</a></span></dt></dl></dd></dl>
    </div>
    <a class="indexterm" name="idm140286802222784"></a><a class="indexterm" name="idm140286802221712"></a><a class="indexterm" name="idm140286802220224"></a><a class="indexterm" name="idm140286802218720"></a><p>
    Replication enables data from one MySQL database server (the master)
    to be copied to one or more MySQL database servers (the slaves).
    Replication is asynchronous by default; slaves do not need to be
    connected permanently to receive updates from the master. Depending
    on the configuration, you can replicate all databases, selected
    databases, or even selected tables within a database.
</p><p style="color:blue;">复制允许将来自一个mysql数据库服务器（主服务器）的数据复制到一个或多个mysql数据库服务器（从服务器）。默认情况下，复制是异步的；不需要永久连接从服务器就可以从主服务器接收更新。根据配置的不同，可以复制数据库中的所有数据库、选定的数据库，甚至选定的表。</p><p>
    Advantages of replication in MySQL include:
</p><p style="color:blue;">MySQL中复制的优点包括：</p>
    <div class="itemizedlist">
        <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            Scale-out solutions - spreading the load among multiple slaves
            to improve performance. In this environment, all writes and
            updates must take place on the master server. Reads, however,
            may take place on one or more slaves. This model can improve the
            performance of writes (since the master is dedicated to
            updates), while dramatically increasing read speed across an
            increasing number of slaves.
        </p><p style="color:blue;">扩展解决方案-在多个从属服务器之间分散负载以提高性能。在此环境中，所有写入和更新都必须在主服务器上进行。但是，读取可能发生在一个或多个奴隶上。此模型可以提高写入的性能（因为主服务器专用于更新），同时在越来越多的从服务器上显著提高读取速度。</p></li><li class="listitem"><p>
            Data security - because data is replicated to the slave, and the
            slave can pause the replication process, it is possible to run
            backup services on the slave without corrupting the
            corresponding master data.
        </p><p style="color:blue;">数据安全-因为数据被复制到从机，并且从机可以暂停复制过程，所以可以在从机上运行备份服务，而不会损坏相应的主数据。</p></li><li class="listitem"><p>
            Analytics - live data can be created on the master, while the
            analysis of the information can take place on the slave without
            affecting the performance of the master.
        </p><p style="color:blue;">分析-可以在主服务器上创建实时数据，而信息分析可以在从服务器上进行，而不会影响主服务器的性能。</p></li><li class="listitem"><p>
            Long-distance data distribution - you can use replication to
            create a local copy of data for a remote site to use, without
            permanent access to the master.
        </p><p style="color:blue;">远程数据分发-您可以使用复制为远程站点创建要使用的数据的本地副本，而无需永久访问主站点。</p></li></ul>
    </div>
    <p>
        For information on how to use replication in such scenarios, see
        <a class="xref" href="replication.html#replication-solutions" title="16.3&nbsp;Replication Solutions">Section&nbsp;16.3, “Replication Solutions”</a>.
    </p><p style="color:blue;">有关如何在这种情况下使用复制的信息，请参阅第16.3节“复制解决方案”。</p><p>
    MySQL 5.7 supports different methods of replication.
    The traditional method is based on replicating events from the
    master's binary log, and requires the log files and positions in
    them to be synchronized between master and slave. The newer method
    based on <span class="firstterm">global transaction
    identifiers</span> (GTIDs) is transactional and therefore does
    not require working with log files or positions within these files,
    which greatly simplifies many common replication tasks. Replication
    using GTIDs guarantees consistency between master and slave as long
    as all transactions committed on the master have also been applied
    on the slave. For more information about GTIDs and GTID-based
    replication in MySQL, see <a class="xref" href="replication.html#replication-gtids" title="16.1.3&nbsp;Replication with Global Transaction Identifiers">Section&nbsp;16.1.3, “Replication with Global Transaction Identifiers”</a>. For
    information on using binary log file position based replication, see
    <a class="xref" href="replication.html#replication-configuration" title="16.1&nbsp;Configuring Replication">Section&nbsp;16.1, “Configuring Replication”</a>.
</p><p style="color:blue;">mysql 5.7支持不同的复制方法。传统的方法是从主机的二进制日志中复制事件，并要求日志文件和其中的位置在主机和从机之间同步。基于全局事务标识符（gtid）的新方法是事务性的，因此不需要处理日志文件或这些文件中的位置，这大大简化了许多常见的复制任务。使用gtid的复制可以保证主服务器和从服务器之间的一致性，只要主服务器上提交的所有事务也应用于从服务器上。有关mysql中gtid和基于gtid的复制的更多信息，请参阅16.1.3节“使用全局事务标识符的复制”。有关使用基于二进制日志文件位置的复制的信息，请参阅第16.1节“配置复制”。</p><p>
    Replication in MySQL supports different types of synchronization.
    The original type of synchronization is one-way, asynchronous
    replication, in which one server acts as the master, while one or
    more other servers act as slaves. This is in contrast to the
    <span class="emphasis"><em>synchronous</em></span> replication which is a
    characteristic of NDB Cluster (see <a class="xref" href="mysql-cluster.html" title="Chapter&nbsp;21&nbsp;MySQL NDB Cluster 7.5 and NDB Cluster 7.6">Chapter&nbsp;21, <i>MySQL NDB Cluster 7.5 and NDB Cluster 7.6</i></a>).
    In MySQL 5.7, semisynchronous replication is supported
    in addition to the built-in asynchronous replication. With
    semisynchronous replication, a commit performed on the master blocks
    before returning to the session that performed the transaction until
    at least one slave acknowledges that it has received and logged the
    events for the transaction; see
    <a class="xref" href="replication.html#replication-semisync" title="16.3.9&nbsp;Semisynchronous Replication">Section&nbsp;16.3.9, “Semisynchronous Replication”</a>. MySQL 5.7 also
    supports delayed replication such that a slave server deliberately
    lags behind the master by at least a specified amount of time; see
    <a class="xref" href="replication.html#replication-delayed" title="16.3.10&nbsp;Delayed Replication">Section&nbsp;16.3.10, “Delayed Replication”</a>. For scenarios where
    <span class="emphasis"><em>synchronous</em></span> replication is required, use NDB
    Cluster (see <a class="xref" href="mysql-cluster.html" title="Chapter&nbsp;21&nbsp;MySQL NDB Cluster 7.5 and NDB Cluster 7.6">Chapter&nbsp;21, <i>MySQL NDB Cluster 7.5 and NDB Cluster 7.6</i></a>).
</p><p style="color:blue;">mysql中的复制支持不同类型的同步。最初的同步类型是单向异步复制，其中一个服务器充当主服务器，而一个或多个其他服务器充当从服务器。这与同步复制不同，同步复制是ndb集群的一个特点（参见第21章mysql ndb cluster 7.5和ndb cluster 7.6）。在mysql 5.7中，除了内置的异步复制之外，还支持半同步复制。在半同步复制中，在返回执行事务的会话之前，在主块上执行的一种提交操作，直到至少有一个从块承认它已接收并记录了事务的事件为止；见16.3.9节，“半同步复制”。mysql 5.7还支持延迟复制，因此从服务器故意将主服务器延迟至少一段指定的时间；请参阅第16.3.10节“延迟复制”。对于需要同步复制的场景，请使用ndb cluster（参见第21章mysql ndb cluster 7.5和ndb cluster 7.6）。</p><p>
    There are a number of solutions available for setting up replication
    between servers, and the best method to use depends on the presence
    of data and the engine types you are using. For more information on
    the available options, see <a class="xref" href="replication.html#replication-howto" title="16.1.2&nbsp;Setting Up Binary Log File Position Based Replication">Section&nbsp;16.1.2, “Setting Up Binary Log File Position Based Replication”</a>.
</p><p style="color:blue;">有许多解决方案可用于设置服务器之间的复制，最佳方法取决于数据的存在和您使用的引擎类型。有关可用选项的更多信息，请参阅第16.1.2节“设置基于二进制日志文件位置的复制”。</p><p>
    There are two core types of replication format, Statement Based
    Replication (SBR), which replicates entire SQL statements, and Row
    Based Replication (RBR), which replicates only the changed rows. You
    can also use a third variety, Mixed Based Replication (MBR). For
    more information on the different replication formats, see
    <a class="xref" href="replication.html#replication-formats" title="16.2.1&nbsp;Replication Formats">Section&nbsp;16.2.1, “Replication Formats”</a>.
</p><p style="color:blue;">复制格式有两种核心类型：基于语句的复制（sbr），它复制整个sql语句；基于行的复制（rbr），它只复制更改的行。您还可以使用第三种，基于混合的复制（mbr）。有关不同复制格式的详细信息，请参阅第16.2.1节“复制格式”。</p><p>
    Replication is controlled through a number of different options and
    variables. For more information, see
    <a class="xref" href="replication.html#replication-options" title="16.1.6&nbsp;Replication and Binary Logging Options and Variables">Section&nbsp;16.1.6, “Replication and Binary Logging Options and Variables”</a>.
</p><p style="color:blue;">复制是通过许多不同的选项和变量来控制的。有关更多信息，请参阅第16.1.6节“复制和二进制日志选项和变量”。</p><p>
    You can use replication to solve a number of different problems,
    including performance, supporting the backup of different databases,
    and as part of a larger solution to alleviate system failures. For
    information on how to address these issues, see
    <a class="xref" href="replication.html#replication-solutions" title="16.3&nbsp;Replication Solutions">Section&nbsp;16.3, “Replication Solutions”</a>.
</p><p style="color:blue;">您可以使用复制来解决许多不同的问题，包括性能、支持不同数据库的备份，以及作为减轻系统故障的更大解决方案的一部分。有关如何解决这些问题的信息，请参阅第16.3节“复制解决方案”。</p><p>
    For notes and tips on how different data types and statements are
    treated during replication, including details of replication
    features, version compatibility, upgrades, and potential problems
    and their resolution, see <a class="xref" href="replication.html#replication-notes" title="16.4&nbsp;Replication Notes and Tips">Section&nbsp;16.4, “Replication Notes and Tips”</a>. For
    answers to some questions often asked by those who are new to MySQL
    Replication, see <a class="xref" href="faqs.html#faqs-replication" title="A.14&nbsp;MySQL 5.7 FAQ: Replication">Section&nbsp;A.14, “MySQL 5.7 FAQ: Replication”</a>.
</p><p style="color:blue;">有关复制过程中如何处理不同数据类型和语句的说明和提示，包括复制功能、版本兼容性、升级和潜在问题及其解决方法的详细信息，请参阅第16.4节“复制说明和提示”。对于那些不熟悉mysql复制的人经常问的一些问题的答案，请参见a.14节，“mysql 5.7常见问题解答：复制”。</p><p>
    For detailed information on the implementation of replication, how
    replication works, the process and contents of the binary log,
    background threads and the rules used to decide how statements are
    recorded and replicated, see
    <a class="xref" href="replication.html#replication-implementation" title="16.2&nbsp;Replication Implementation">Section&nbsp;16.2, “Replication Implementation”</a>.
</p><p style="color:blue;">有关复制的实现、复制的工作方式、二进制日志的过程和内容、后台线程以及用于确定如何记录和复制语句的规则的详细信息，请参阅第16.2节“复制实现”。</p>
    <div class="section">

        <div class="titlepage">
            <div>
                <div>
                    <h2 class="title" style="clear: both"><a name="replication-configuration"></a>16.1&nbsp;Configuring Replication</h2>

                </div>

            </div>

        </div>

        <div class="toc">
            <dl class="toc"><dt><span class="section"><a href="replication.html#binlog-replication-configuration-overview">16.1.1 Binary Log File Position Based Replication Configuration Overview</a></span></dt><dt><span class="section"><a href="replication.html#replication-howto">16.1.2 Setting Up Binary Log File Position Based Replication</a></span></dt><dt><span class="section"><a href="replication.html#replication-gtids">16.1.3 Replication with Global Transaction Identifiers</a></span></dt><dt><span class="section"><a href="replication.html#replication-multi-source">16.1.4 MySQL Multi-Source Replication</a></span></dt><dt><span class="section"><a href="replication.html#replication-mode-change-online">16.1.5 Changing Replication Modes on Online Servers</a></span></dt><dt><span class="section"><a href="replication.html#replication-options">16.1.6 Replication and Binary Logging Options and Variables</a></span></dt><dt><span class="section"><a href="replication.html#replication-administration">16.1.7 Common Replication Administration Tasks</a></span></dt></dl>
        </div>
        <p>
            This section describes how to configure the different types of
            replication available in MySQL and includes the setup and
            configuration required for a replication environment, including
            step-by-step instructions for creating a new replication
            environment. The major components of this section are:
        </p><p style="color:blue;">本节介绍如何配置MySQL中可用的不同类型的复制，并包括复制环境所需的设置和配置，包括创建新复制环境的逐步说明。本节的主要内容包括：</p>
        <div class="itemizedlist">
            <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                For a guide to setting up two or more servers for replication
                using binary log file positions,
                <a class="xref" href="replication.html#replication-howto" title="16.1.2&nbsp;Setting Up Binary Log File Position Based Replication">Section&nbsp;16.1.2, “Setting Up Binary Log File Position Based Replication”</a>, deals with the
                configuration of the servers and provides methods for copying
                data between the master and slaves.
            </p><p style="color:blue;">有关使用二进制日志文件位置为复制设置两个或多个服务器的指南，请参阅第16.1.2节“设置基于二进制日志文件位置的复制”，该节介绍服务器的配置，并提供在主服务器和从服务器之间复制数据的方法。</p></li><li class="listitem"><p>
                For a guide to setting up two or more servers for replication
                using GTID transactions, <a class="xref" href="replication.html#replication-gtids" title="16.1.3&nbsp;Replication with Global Transaction Identifiers">Section&nbsp;16.1.3, “Replication with Global Transaction Identifiers”</a>,
                deals with the configuration of the servers.
            </p><p style="color:blue;">有关使用gtid事务设置两个或多个服务器进行复制的指南，请参阅第16.1.3节“使用全局事务标识符进行复制”，其中介绍了服务器的配置。</p></li><li class="listitem"><p>
                Events in the binary log are recorded using a number of formats.
                These are referred to as statement-based replication (SBR) or
                row-based replication (RBR). A third type, mixed-format
                replication (MIXED), uses SBR or RBR replication automatically
                to take advantage of the benefits of both SBR and RBR formats
                when appropriate. The different formats are discussed in
                <a class="xref" href="replication.html#replication-formats" title="16.2.1&nbsp;Replication Formats">Section&nbsp;16.2.1, “Replication Formats”</a>.
            </p><p style="color:blue;">二进制日志中的事件使用多种格式记录。它们被称为基于语句的复制（sbr）或基于行的复制（rbr）。第三种类型，混合格式复制（mixed），在适当的时候自动使用sbr或rbr复制来利用sbr和rbr格式的优点。第16.2.1节“复制格式”讨论了不同的格式。</p></li><li class="listitem"><p>
                Detailed information on the different configuration options and
                variables that apply to replication is provided in
                <a class="xref" href="replication.html#replication-options" title="16.1.6&nbsp;Replication and Binary Logging Options and Variables">Section&nbsp;16.1.6, “Replication and Binary Logging Options and Variables”</a>.
            </p><p style="color:blue;">有关应用于复制的不同配置选项和变量的详细信息，请参阅第16.1.6节“复制和二进制日志选项和变量”。</p></li><li class="listitem"><p>
                Once started, the replication process should require little
                administration or monitoring. However, for advice on common
                tasks that you may want to execute, see
                <a class="xref" href="replication.html#replication-administration" title="16.1.7&nbsp;Common Replication Administration Tasks">Section&nbsp;16.1.7, “Common Replication Administration Tasks”</a>.
            </p><p style="color:blue;">一旦启动，复制过程应该只需要很少的管理或监视。但是，有关可能要执行的常见任务的建议，请参阅第16.1.7节“常见复制管理任务”。</p></li></ul>
        </div>
        <div class="section">
            <div class="titlepage">
                <div>
                    <div>
                        <h3 class="title"><a name="binlog-replication-configuration-overview"></a>16.1.1&nbsp;Binary Log File Position Based Replication Configuration Overview</h3>

                    </div>

                </div>

            </div>
            <p>
                This section describes replication between MySQL servers based on
                the binary log file position method, where the MySQL instance
                operating as the master (the source of the database changes)
                writes updates and changes as <span class="quote">“<span class="quote">events</span>”</span> to the binary
                log. The information in the binary log is stored in different
                logging formats according to the database changes being recorded.
                Slaves are configured to read the binary log from the master and
                to execute the events in the binary log on the slave's local
                database.
            </p><p style="color:blue;">本节介绍基于二进制日志文件位置方法的MySQL服务器之间的复制，在这种方法中，作为主服务器（数据库更改的源）操作的MySQL实例将更新和更改作为“事件”写入二进制日志。二进制日志中的信息根据记录的数据库更改以不同的日志格式存储。从服务器被配置为从主服务器读取二进制日志，并在从服务器的本地数据库上执行二进制日志中的事件。</p><p>
            Each slave receives a copy of the entire contents of the binary
            log. It is the responsibility of the slave to decide which
            statements in the binary log should be executed. Unless you
            specify otherwise, all events in the master binary log are
            executed on the slave. If required, you can configure the slave to
            process only events that apply to particular databases or tables.
        </p><p style="color:blue;">每个从机接收二进制日志的全部内容的副本。从机负责决定二进制日志中的哪些语句应该执行。除非另有说明，否则主二进制日志中的所有事件都在从系统上执行。如果需要，您可以将从机配置为仅处理应用于特定数据库或表的事件。</p>
            <div class="important" style="margin-left: 0.5in; margin-right: 0.5in;">

                <div class="admon-title">
                    Important
                </div>
                <p>
                    You cannot configure the master to log only certain events.
                </p><p style="color:blue;">不能将主服务器配置为只记录某些事件。</p>
            </div>
            <p>
                Each slave keeps a record of the binary log coordinates: the file
                name and position within the file that it has read and processed
                from the master. This means that multiple slaves can be connected
                to the master and executing different parts of the same binary
                log. Because the slaves control this process, individual slaves
                can be connected and disconnected from the server without
                affecting the master's operation. Also, because each slave records
                the current position within the binary log, it is possible for
                slaves to be disconnected, reconnect and then resume processing.
            </p><p style="color:blue;">每个从机都保存一个二进制日志坐标的记录：从主机读取和处理的文件中的文件名和位置。这意味着可以将多个从机连接到主机并执行同一二进制日志的不同部分。由于从机控制此进程，因此可以在不影响主机操作的情况下连接和断开各个从机与服务器的连接。另外，由于每个从机记录二进制日志中的当前位置，因此可以断开从机连接，重新连接，然后恢复处理。</p><p>
            The master and each slave must be configured with a unique ID
            (using the <a class="link" href="replication.html#option_mysqld_server-id"><code class="option">server-id</code></a> option). In
            addition, each slave must be configured with information about the
            master host name, log file name, and position within that file.
            These details can be controlled from within a MySQL session using
            the <a class="link" href="sql-syntax.html#change-master-to" title="13.4.2.1&nbsp;CHANGE MASTER TO Syntax"><code class="literal">CHANGE MASTER TO</code></a> statement on
            the slave. The details are stored within the slave's master
            info repository, which can be either a file or a table (see
            <a class="xref" href="replication.html#slave-logs" title="16.2.4&nbsp;Replication Relay and Status Logs">Section&nbsp;16.2.4, “Replication Relay and Status Logs”</a>).
        </p><p style="color:blue;">主设备和每个从设备必须配置一个唯一的id（使用服务器id选项）。此外，每个从机必须配置有关主主机名、日志文件名和该文件中位置的信息。这些细节可以在mysql会话中使用从机上的change master to语句进行控制。详细信息存储在从机的主信息存储库中，可以是文件或表（请参阅第16.2.4节“复制中继和状态日志”）。</p>
        </div>
        <div class="section">
            <div class="titlepage">
                <div>
                    <div>
                        <h3 class="title"><a name="replication-howto"></a>16.1.2&nbsp;Setting Up Binary Log File Position Based Replication</h3>

                    </div>

                </div>

            </div>
            <div class="toc">
                <dl class="toc"><dt><span class="section"><a href="replication.html#replication-howto-masterbaseconfig">16.1.2.1 Setting the Replication Master Configuration</a></span></dt><dt><span class="section"><a href="replication.html#replication-howto-repuser">16.1.2.2 Creating a User for Replication</a></span></dt><dt><span class="section"><a href="replication.html#replication-howto-masterstatus">16.1.2.3 Obtaining the Replication Master Binary Log Coordinates</a></span></dt><dt><span class="section"><a href="replication.html#replication-snapshot-method">16.1.2.4 Choosing a Method for Data Snapshots</a></span></dt><dt><span class="section"><a href="replication.html#replication-setup-slaves">16.1.2.5 Setting Up Replication Slaves</a></span></dt><dt><span class="section"><a href="replication.html#replication-howto-additionalslaves">16.1.2.6 Adding Slaves to a Replication Environment</a></span></dt></dl>
            </div>
            <p>
                This section describes how to set up a MySQL server to use binary
                log file position based replication. There are a number of
                different methods for setting up replication, and the exact method
                to use depends on how you are setting up replication, and whether
                you already have data within your master database.
            </p><p style="color:blue;">本节介绍如何设置MySQL服务器以使用基于二进制日志文件位置的复制。设置复制有许多不同的方法，具体使用的方法取决于设置复制的方式，以及主数据库中是否已经有数据。</p><p>
            There are some generic tasks that are common to all setups:
        </p><p style="color:blue;">所有设置都有一些通用任务：</p>
            <div class="itemizedlist">
                <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                    On the master, you must enable binary logging and configure a
                    unique server ID. This might require a server restart. See
                    <a class="xref" href="replication.html#replication-howto-masterbaseconfig" title="16.1.2.1&nbsp;Setting the Replication Master Configuration">Section&nbsp;16.1.2.1, “Setting the Replication Master Configuration”</a>.
                </p><p style="color:blue;">在主服务器上，必须启用二进制日志记录并配置唯一的服务器ID。这可能需要重新启动服务器。请参阅第16.1.2.1节“设置复制主配置”。</p></li><li class="listitem"><p>
                    On each slave that you want to connect to the master, you must
                    configure a unique server ID. This might require a server
                    restart. See
                    <a class="xref" href="replication.html#replication-howto-slavebaseconfig" title="16.1.2.5.1&nbsp;Setting the Replication Slave Configuration">Section&nbsp;16.1.2.5.1, “Setting the Replication Slave Configuration”</a>.
                </p><p style="color:blue;">在每个要连接到主服务器的从属服务器上，必须配置唯一的服务器ID。这可能需要重新启动服务器。参见第16.1.2.5.1节“设置复制从机配置”。</p></li><li class="listitem"><p>
                    Optionally, create a separate user for your slaves to use
                    during authentication with the master when reading the binary
                    log for replication. See
                    <a class="xref" href="replication.html#replication-howto-repuser" title="16.1.2.2&nbsp;Creating a User for Replication">Section&nbsp;16.1.2.2, “Creating a User for Replication”</a>.
                </p><p style="color:blue;">（可选）为从属服务器创建一个单独的用户，以便在读取复制的二进制日志时与主服务器进行身份验证时使用。参见第16.1.2.2节“创建复制用户”。</p></li><li class="listitem"><p>
                    Before creating a data snapshot or starting the replication
                    process, on the master you should record the current position
                    in the binary log. You need this information when configuring
                    the slave so that the slave knows where within the binary log
                    to start executing events. See
                    <a class="xref" href="replication.html#replication-howto-masterstatus" title="16.1.2.3&nbsp;Obtaining the Replication Master Binary Log Coordinates">Section&nbsp;16.1.2.3, “Obtaining the Replication Master Binary Log Coordinates”</a>.
                </p><p style="color:blue;">在创建数据快照或启动复制过程之前，应在主服务器上记录二进制日志中的当前位置。在配置从服务器时需要此信息，以便从服务器知道二进制日志中从何处开始执行事件。见第16.1.2.3节，“获取复制主二进制日志坐标”。</p></li><li class="listitem"><p>
                    If you already have data on the master and want to use it to
                    synchronize the slave, you need to create a data snapshot to
                    copy the data to the slave. The storage engine you are using
                    has an impact on how you create the snapshot. When you are
                    using <a class="link" href="storage-engines.html#myisam-storage-engine" title="15.2&nbsp;The MyISAM Storage Engine"><code class="literal">MyISAM</code></a>, you must stop
                    processing statements on the master to obtain a read-lock,
                    then obtain its current binary log coordinates and dump its
                    data, before permitting the master to continue executing
                    statements. If you do not stop the execution of statements,
                    the data dump and the master status information will not
                    match, resulting in inconsistent or corrupted databases on the
                    slaves. For more information on replicating a
                    <a class="link" href="storage-engines.html#myisam-storage-engine" title="15.2&nbsp;The MyISAM Storage Engine"><code class="literal">MyISAM</code></a> master, see
                    <a class="xref" href="replication.html#replication-howto-masterstatus" title="16.1.2.3&nbsp;Obtaining the Replication Master Binary Log Coordinates">Section&nbsp;16.1.2.3, “Obtaining the Replication Master Binary Log Coordinates”</a>. If you are
                    using <a class="link" href="innodb-storage-engine.html" title="Chapter&nbsp;14&nbsp;The InnoDB Storage Engine"><code class="literal">InnoDB</code></a>, you do not need a
                    read-lock and a transaction that is long enough to transfer
                    the data snapshot is sufficient. For more information, see
                    <a class="xref" href="innodb-storage-engine.html#innodb-and-mysql-replication" title="14.19&nbsp;InnoDB and MySQL Replication">Section&nbsp;14.19, “InnoDB and MySQL Replication”</a>.
                </p><p style="color:blue;">如果主设备上已经有数据，并且要使用它来同步从设备，则需要创建一个数据快照来将数据复制到从设备上。正在使用的存储引擎会影响创建快照的方式。在使用myisam时，必须停止处理master上的语句以获取读锁，然后获取其当前的二进制日志坐标并转储其数据，然后才允许master继续执行语句。如果不停止语句的执行，数据转储和主状态信息将不匹配，从而导致从机上的数据库不一致或损坏。有关复制myisam主机的更多信息，请参阅第16.1.2.3节“获取复制主机二进制日志坐标”。如果您使用的是innodb，那么您不需要读锁，一个足够长的事务来传输数据快照就足够了。有关更多信息，请参阅14.19节，“InnoDB和MySQL复制”。</p></li><li class="listitem"><p>
                    Configure the slave with settings for connecting to the
                    master, such as the host name, login credentials, and binary
                    log file name and position. See
                    <a class="xref" href="replication.html#replication-howto-slaveinit" title="16.1.2.5.2&nbsp;Setting the Master Configuration on the Slave">Section&nbsp;16.1.2.5.2, “Setting the Master Configuration on the Slave”</a>.
                </p><p style="color:blue;">使用连接到主服务器的设置（如主机名、登录凭据和二进制日志文件名和位置）配置从服务器。见第16.1.2.5.2节，“在从机上设置主配置”。</p></li></ul>
            </div>
            <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">
                <div class="admon-title">
                    Note
                </div>
                <p>
                    Certain steps within the setup process require the
                    <a class="link" href="security.html#priv_super"><code class="literal">SUPER</code></a> privilege. If you do not
                    have this privilege, it might not be possible to enable
                    replication.
                </p><p style="color:blue;">安装过程中的某些步骤需要超级权限。如果您没有此权限，则可能无法启用复制。</p>
            </div>
            <p>
                After configuring the basic options, select your scenario:
            </p><p style="color:blue;">配置基本选项后，选择场景：</p>
            <div class="itemizedlist">
                <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                    To set up replication for a fresh installation of a master and
                    slaves that contain no data, see
                    <a class="xref" href="replication.html#replication-howto-newservers" title="16.1.2.5.3&nbsp;Setting Up Replication between a New Master and Slaves">Section&nbsp;16.1.2.5.3, “Setting Up Replication between a New Master and Slaves”</a>.
                </p><p style="color:blue;">要为不包含数据的主设备和从设备的新安装设置复制，请参阅第16.1.2.5.3节“在新主设备和从设备之间设置复制”。</p></li><li class="listitem"><p>
                    To set up replication of a new master using the data from an
                    existing MySQL server, see
                    <a class="xref" href="replication.html#replication-howto-existingdata" title="16.1.2.5.4&nbsp;Setting Up Replication with Existing Data">Section&nbsp;16.1.2.5.4, “Setting Up Replication with Existing Data”</a>.
                </p><p style="color:blue;">要使用现有MySQL服务器的数据设置新主机的复制，请参阅第16.1.2.5.4节，“用现有数据设置复制”。</p></li><li class="listitem"><p>
                    To add replication slaves to an existing replication
                    environment, see
                    <a class="xref" href="replication.html#replication-howto-additionalslaves" title="16.1.2.6&nbsp;Adding Slaves to a Replication Environment">Section&nbsp;16.1.2.6, “Adding Slaves to a Replication Environment”</a>.
                </p><p style="color:blue;">若要将复制奴隶添加到现有复制环境中，请参阅第16.1.2.6节，“向复制环境添加奴隶”。</p></li></ul>
            </div>
            <p>
                Before administering MySQL replication servers, read this entire
                chapter and try all statements mentioned in
                <a class="xref" href="sql-syntax.html#replication-master-sql" title="13.4.1&nbsp;SQL Statements for Controlling Master Servers">Section&nbsp;13.4.1, “SQL Statements for Controlling Master Servers”</a>, and
                <a class="xref" href="sql-syntax.html#replication-slave-sql" title="13.4.2&nbsp;SQL Statements for Controlling Slave Servers">Section&nbsp;13.4.2, “SQL Statements for Controlling Slave Servers”</a>. Also familiarize yourself
                with the replication startup options described in
                <a class="xref" href="replication.html#replication-options" title="16.1.6&nbsp;Replication and Binary Logging Options and Variables">Section&nbsp;16.1.6, “Replication and Binary Logging Options and Variables”</a>.
            </p><p style="color:blue;">在管理mysql复制服务器之前，请阅读整个章节，并尝试第13.4.1节“控制主服务器的sql语句”和第13.4.2节“控制从服务器的sql语句”中提到的所有语句。还要熟悉第16.1.6节“复制和二进制日志选项和变量”中描述的复制启动选项。</p>
            <div class="section">

                <div class="titlepage">
                    <div>
                        <div>
                            <h4 class="title"><a name="replication-howto-masterbaseconfig"></a>16.1.2.1&nbsp;Setting the Replication Master Configuration</h4>
                        </div>
                    </div>
                </div>
                <p>
                    To configure a master to use binary log file position based
                    replication, you must enable binary logging and establish a
                    unique server ID. If this has not already been done, a server
                    restart is required.
                </p><p style="color:blue;">若要将主服务器配置为使用基于二进制日志文件位置的复制，必须启用二进制日志记录并建立唯一的服务器ID。如果尚未完成此操作，则需要重新启动服务器。</p><p>
                Binary logging <span class="emphasis"><em>must</em></span> be enabled on the
                master because the binary log is the basis for replicating
                changes from the master to its slaves. If binary logging is not
                enabled on the master using the <code class="literal">log-bin</code>
                option, replication is not possible.
            </p><p style="color:blue;">必须在主服务器上启用二进制日志记录，因为二进制日志是将更改从主服务器复制到从服务器的基础。如果没有在主机上使用log bin选项启用二进制日志记录，则无法进行复制。</p><p>
                Each server within a replication group must be configured with a
                unique server ID. This ID is used to identify individual servers
                within the group, and must be a positive integer between 1 and
                (2<sup>32</sup>)−1. How you organize and
                select the numbers is your choice.
            </p><p style="color:blue;">复制组中的每个服务器都必须配置唯一的服务器ID。此ID用于标识组中的各个服务器，并且必须是介于1和（232）–1之间的正整数。如何组织和选择数字是你的选择。</p><p>
                To configure the binary log and server ID options, shut down the
                MySQL server and edit the <code class="filename">my.cnf</code> or
                <code class="filename">my.ini</code> file. Within the
                <code class="literal">[mysqld]</code> section of the configuration file,
                add the <code class="literal">log-bin</code> and
                <code class="literal">server-id</code> options. If these options already
                exist, but are commented out, uncomment the options and alter
                them according to your needs. For example, to enable binary
                logging using a log file name prefix of
                <code class="literal">mysql-bin</code>, and configure a server ID of 1,
                use these lines:
            </p><p style="color:blue;">要配置二进制日志和服务器ID选项，请关闭MySQL服务器并编辑my.cnf或my.ini文件。在配置文件的[mysqld]部分中，添加日志箱和服务器id选项。如果这些选项已经存在，但是被注释掉，取消注释选项并根据您的需要修改它们。例如，要使用mysql bin的日志文件名前缀启用二进制日志记录，并将服务器ID配置为1，请使用以下行：</p><pre data-lang="ini" class="programlisting">[mysqld]
log-bin=mysql-bin
server-id=1
</pre><p>
                After making the changes, restart the server.
            </p><p style="color:blue;">进行更改后，重新启动服务器。</p>
                <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">

                    <div class="admon-title">
                        Note
                    </div>
                    <p>
                        The following options have an impact on this procedure:
                    </p><p style="color:blue;">以下选项会影响此过程：</p>
                    <div class="itemizedlist">
                        <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                            if you omit <a class="link" href="replication.html#option_mysqld_server-id"><code class="option">server-id</code></a> (or
                            set it explicitly to its default value of 0), the master
                            refuses any connections from slaves.
                        </p><p style="color:blue;">如果省略服务器ID（或将其显式设置为默认值0），则主服务器将拒绝从服务器的任何连接。</p></li><li class="listitem"><p>
                            For the greatest possible durability and consistency in a
                            replication setup using
                            <a class="link" href="innodb-storage-engine.html" title="Chapter&nbsp;14&nbsp;The InnoDB Storage Engine"><code class="literal">InnoDB</code></a> with transactions, you
                            should use
                            <code class="literal">innodb_flush_log_at_trx_commit=1</code> and
                            <code class="literal">sync_binlog=1</code> in the master
                            <code class="filename">my.cnf</code> file.
                        </p><p style="color:blue;">为了在使用innodb with transactions的复制设置中获得最大的持久性和一致性，应该在主my.cnf文件中使用innodb_flush_log_at_trx_commit=1和sync_binlog=1。</p></li><li class="listitem"><p>
                            Ensure that the
                            <a class="link" href="server-administration.html#option_mysqld_skip-networking"><code class="option">skip-networking</code></a> option is
                            not enabled on your replication master. If networking has
                            been disabled, the slave cannot communicate with the
                            master and replication fails.
                        </p><p style="color:blue;">确保复制主机上未启用跳过网络选项。如果已禁用网络，则从机无法与主机通信，复制失败。</p></li></ul>
                    </div>

                </div>

            </div>
            <div class="section">
                <div class="titlepage">
                    <div>
                        <div>
                            <h4 class="title"><a name="replication-howto-repuser"></a>16.1.2.2&nbsp;Creating a User for Replication</h4>

                        </div>

                    </div>

                </div>
                <p>
                    Each slave connects to the master using a MySQL user name and
                    password, so there must be a user account on the master that the
                    slave can use to connect. The user name is specified by the
                    <code class="literal">MASTER_USER</code> option on the <code class="literal">CHANGE
                    MASTER TO</code> command when you set up a replication slave.
                    Any account can be used for this operation, providing it has
                    been granted the <a class="link" href="security.html#priv_replication-slave"><code class="literal">REPLICATION
                    SLAVE</code></a> privilege. You can choose to create a different
                    account for each slave, or connect to the master using the same
                    account for each slave.
                </p><p style="color:blue;">每个从机使用mysql用户名和密码连接到主机，因此主机上必须有一个用户帐户，从机可以使用该帐户进行连接。设置复制从机时，用户名由“将主机更改为”命令上的“主用户”选项指定。任何帐户都可以用于此操作，前提是它已被授予复制从属权限。您可以选择为每个从机创建一个不同的帐户，或者为每个从机使用相同的帐户连接到主机。</p><p>
                Although you do not have to create an account specifically for
                replication, you should be aware that the replication user name
                and password are stored in plain text in the master info
                repository file or table (see
                <a class="xref" href="replication.html#slave-logs-status" title="16.2.4.2&nbsp;Slave Status Logs">Section&nbsp;16.2.4.2, “Slave Status Logs”</a>). Therefore, you may want to
                create a separate account that has privileges only for the
                replication process, to minimize the possibility of compromise
                to other accounts.
            </p><p style="color:blue;">尽管您不必创建专门用于复制的帐户，但您应该知道复制用户名和密码以纯文本形式存储在主信息存储库文件或表中（请参阅第16.2.4.2节“从属状态日志”）。因此，您可能需要创建一个单独的帐户，该帐户只对复制过程具有权限，以将危害其他帐户的可能性降至最低。</p><p>
                To create a new account, use <a class="link" href="sql-syntax.html#create-user" title="13.7.1.2&nbsp;CREATE USER Syntax"><code class="literal">CREATE
                USER</code></a>. To grant this account the privileges required
                for replication, use the <a class="link" href="sql-syntax.html#grant" title="13.7.1.4&nbsp;GRANT Syntax"><code class="literal">GRANT</code></a>
                statement. If you create an account solely for the purposes of
                replication, that account needs only the
                <a class="link" href="security.html#priv_replication-slave"><code class="literal">REPLICATION SLAVE</code></a>
                privilege. For example, to set up a new user,
                <code class="literal">repl</code>, that can connect for replication from
                any host within the <code class="literal">example.com</code> domain, issue
                these statements on the master:
            </p><p style="color:blue;">若要创建新帐户，请使用“创建用户”。要授予此帐户复制所需的权限，请使用GRANT语句。如果只为复制目的创建帐户，则该帐户只需要复制从属权限。例如，要设置一个新用户repl，该用户可以从example.com域中的任何主机连接以进行复制，请在主机上发出以下语句：</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>CREATE USER 'repl'@'%.example.com' IDENTIFIED BY '<em class="replaceable"><code>password</code></em>';</code></strong>
mysql&gt; <strong class="userinput"><code>GRANT REPLICATION SLAVE ON *.* TO 'repl'@'%.example.com';</code></strong>
</pre><p>
                See <a class="xref" href="sql-syntax.html#account-management-sql" title="13.7.1&nbsp;Account Management Statements">Section&nbsp;13.7.1, “Account Management Statements”</a>, for more
                information on statements for manipulation of user accounts.
            </p><p style="color:blue;">有关操纵用户帐户的报表的更多信息，请参阅第13.7.1节“帐户管理报表”。</p>
            </div>
            <div class="section">
                <div class="titlepage">
                    <div>
                        <div>
                            <h4 class="title"><a name="replication-howto-masterstatus"></a>16.1.2.3&nbsp;Obtaining the Replication Master Binary Log Coordinates</h4>

                        </div>

                    </div>

                </div>
                <p>
                    To configure the slave to start the replication process at the
                    correct point, you need to note the master's current coordinates
                    within its binary log.
                </p><p style="color:blue;">要将从属服务器配置为在正确的点启动复制过程，需要在其二进制日志中记录主服务器的当前坐标。</p>
                <div class="warning" style="margin-left: 0.5in; margin-right: 0.5in;">

                    <div class="admon-title">
                        Warning
                    </div>
                    <p>
                        This procedure uses <a class="link" href="sql-syntax.html#flush-tables-with-read-lock"><code class="literal">FLUSH TABLES WITH
                        READ LOCK</code></a>, which blocks
                        <a class="link" href="sql-syntax.html#commit" title="13.3.1&nbsp;START TRANSACTION, COMMIT, and ROLLBACK Syntax"><code class="literal">COMMIT</code></a> operations for
                        <a class="link" href="innodb-storage-engine.html" title="Chapter&nbsp;14&nbsp;The InnoDB Storage Engine"><code class="literal">InnoDB</code></a> tables.
                    </p><p style="color:blue;">这个过程使用带读锁的flush表，它阻止innodb表的提交操作。</p>
                </div>
                <p>
                    If you are planning to shut down the master to create a data
                    snapshot, you can optionally skip this procedure and instead
                    store a copy of the binary log index file along with the data
                    snapshot. In that situation, the master creates a new binary log
                    file on restart. The master binary log coordinates where the
                    slave must start the replication process are therefore the start
                    of that new file, which is the next binary log file on the
                    master following after the files that are listed in the copied
                    binary log index file.
                </p><p style="color:blue;">如果计划关闭主机以创建数据快照，则可以选择跳过此过程，而将二进制日志索引文件的副本与数据快照一起存储。在这种情况下，主服务器在重新启动时创建一个新的二进制日志文件。因此，从服务器必须启动复制过程的主二进制日志坐标是该新文件的开始，它是在复制的二进制日志索引文件中列出的文件之后主服务器上的下一个二进制日志文件。</p><p>
                To obtain the master binary log coordinates, follow these steps:
            </p><p style="color:blue;">要获取主二进制日志坐标，请执行以下步骤：</p>
                <div class="orderedlist">
                    <ol class="orderedlist" type="1"><li class="listitem"><p>
                        Start a session on the master by connecting to it with the
                        command-line client, and flush all tables and block write
                        statements by executing the <a class="link" href="sql-syntax.html#flush-tables-with-read-lock"><code class="literal">FLUSH
                        TABLES WITH READ LOCK</code></a> statement:
                    </p><p style="color:blue;">使用命令行客户机连接到主服务器上启动会话，并通过执行带有read lock语句的flush tables来刷新所有表和block write语句：</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>FLUSH TABLES WITH READ LOCK;</code></strong>
</pre>
                        <div class="warning" style="margin-left: 0.5in; margin-right: 0.5in;">

                            <div class="admon-title">
                                Warning
                            </div>
                            <p>
                                Leave the client from which you issued the
                                <a class="link" href="sql-syntax.html#flush-tables"><code class="literal">FLUSH TABLES</code></a> statement
                                running so that the read lock remains in effect. If you
                                exit the client, the lock is released.
                            </p><p style="color:blue;">让发出flush tables语句的客户机继续运行，以便读锁保持有效。如果退出客户端，则释放锁。</p>
                        </div>
                    </li><li class="listitem"><p>
                        In a different session on the master, use the
                        <a class="link" href="sql-syntax.html#show-master-status" title="13.7.5.23&nbsp;SHOW MASTER STATUS Syntax"><code class="literal">SHOW MASTER STATUS</code></a> statement
                        to determine the current binary log file name and position:
                    </p><p style="color:blue;">在主服务器上的其他会话中，使用show master status语句确定当前二进制日志文件名和位置：</p><pre data-lang="sql" class="programlisting">mysql &gt; <strong class="userinput"><code>SHOW MASTER STATUS;</code></strong>
+------------------+----------+--------------+------------------+
| File             | Position | Binlog_Do_DB | Binlog_Ignore_DB |
+------------------+----------+--------------+------------------+
| mysql-bin.000003 | 73       | test         | manual,mysql     |
+------------------+----------+--------------+------------------+
</pre><p>
                        The <code class="literal">File</code> column shows the name of the log
                        file and the <code class="literal">Position</code> column shows the
                        position within the file. In this example, the binary log
                        file is <code class="literal">mysql-bin.000003</code> and the position
                        is 73. Record these values. You need them later when you are
                        setting up the slave. They represent the replication
                        coordinates at which the slave should begin processing new
                        updates from the master.
                    </p><p style="color:blue;">“文件”列显示日志文件的名称，“位置”列显示文件中的位置。在本例中，二进制日志文件是mysql-bin.000003，位置是73。记录这些值。你需要他们以后当你设置奴隶。它们表示从机开始处理来自主机的新更新的复制坐标。</p><p>
                        If the master has been running previously without binary
                        logging enabled, the log file name and position values
                        displayed by <a class="link" href="sql-syntax.html#show-master-status" title="13.7.5.23&nbsp;SHOW MASTER STATUS Syntax"><code class="literal">SHOW MASTER
                        STATUS</code></a> or <a class="link" href="programs.html#mysqldump" title="4.5.4&nbsp;mysqldump — A Database Backup Program"><span class="command"><strong>mysqldump
            --master-data</strong></span></a> are empty. In that case, the values
                        that you need to use later when specifying the slave's log
                        file and position are the empty string
                        (<code class="literal">''</code>) and <code class="literal">4</code>.
                    </p><p style="color:blue;">如果master以前在未启用二进制日志记录的情况下运行，则show master status或mysqldump--master data显示的日志文件名和位置值为空。在这种情况下，在以后指定从属日志文件和位置时需要使用的值是空字符串（''）和4。</p></li></ol>
                </div>
                <p>
                    You now have the information you need to enable the slave to
                    start reading from the binary log in the correct place to start
                    replication.
                </p><p style="color:blue;">现在，您已经获得了所需的信息，使从属服务器能够在正确的位置开始从二进制日志中读取数据以开始复制。</p><p>
                The next step depends on whether you have existing data on the
                master. Choose one of the following options:
            </p><p style="color:blue;">下一步取决于主控器上是否存在现有数据。选择下列选项之一：</p>
                <div class="itemizedlist">
                    <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                        If you have existing data that needs be to synchronized with
                        the slave before you start replication, leave the client
                        running so that the lock remains in place. This prevents any
                        further changes being made, so that the data copied to the
                        slave is in synchrony with the master. Proceed to
                        <a class="xref" href="replication.html#replication-snapshot-method" title="16.1.2.4&nbsp;Choosing a Method for Data Snapshots">Section&nbsp;16.1.2.4, “Choosing a Method for Data Snapshots”</a>.
                    </p><p style="color:blue;">如果在启动复制之前需要与现有数据同步，请让客户端运行，以便锁保持就位。这将防止进行任何进一步的更改，以便复制到从属服务器的数据与主服务器同步。继续第16.1.2.4节“选择数据快照的方法”。</p></li><li class="listitem"><p>
                        If you are setting up a new master and slave replication
                        group, you can exit the first session to release the read
                        lock. See <a class="xref" href="replication.html#replication-howto-newservers" title="16.1.2.5.3&nbsp;Setting Up Replication between a New Master and Slaves">Section&nbsp;16.1.2.5.3, “Setting Up Replication between a New Master and Slaves”</a> for
                        how to proceed.
                    </p><p style="color:blue;">如果正在设置一个新的主从复制组，则可以退出第一个会话以释放读取锁。有关如何继续，请参阅第16.1.2.5.3节“在新主设备和从设备之间设置复制”。</p></li></ul>
                </div>

            </div>
            <div class="section">
                <div class="titlepage">
                    <div>
                        <div>
                            <h4 class="title"><a name="replication-snapshot-method"></a>16.1.2.4&nbsp;Choosing a Method for Data Snapshots</h4>

                        </div>

                    </div>

                </div>
                <p>
                    If the master database contains existing data it is necessary to
                    copy this data to each slave. There are different ways to dump
                    the data from the master database. The following sections
                    describe possible options.
                </p><p style="color:blue;">如果主数据库包含现有数据，则需要将该数据复制到每个从属。从主数据库转储数据有不同的方法。以下部分描述了可能的选项。</p><p>
                To select the appropriate method of dumping the database, choose
                between these options:
            </p><p style="color:blue;">要选择适当的转储数据库的方法，请在以下选项之间进行选择：</p>
                <div class="itemizedlist">
                    <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                        Use the <a class="link" href="programs.html#mysqldump" title="4.5.4&nbsp;mysqldump — A Database Backup Program"><span class="command"><strong>mysqldump</strong></span></a> tool to create a dump
                        of all the databases you want to replicate. This is the
                        recommended method, especially when using
                        <a class="link" href="innodb-storage-engine.html" title="Chapter&nbsp;14&nbsp;The InnoDB Storage Engine"><code class="literal">InnoDB</code></a>.
                    </p><p style="color:blue;">使用mysqldump工具创建要复制的所有数据库的转储。这是推荐的方法，尤其是在使用innodb时。</p></li><li class="listitem"><p>
                        If your database is stored in binary portable files, you can
                        copy the raw data files to a slave. This can be more
                        efficient than using <a class="link" href="programs.html#mysqldump" title="4.5.4&nbsp;mysqldump — A Database Backup Program"><span class="command"><strong>mysqldump</strong></span></a> and
                        importing the file on each slave, because it skips the
                        overhead of updating indexes as the
                        <code class="literal">INSERT</code> statements are replayed. With
                        storage engines such as <a class="link" href="innodb-storage-engine.html" title="Chapter&nbsp;14&nbsp;The InnoDB Storage Engine"><code class="literal">InnoDB</code></a>
                        this is not recommended.
                    </p><p style="color:blue;">如果数据库存储在二进制可移植文件中，则可以将原始数据文件复制到从属数据库。这比在每个从机上使用mysqldump和导入文件更有效，因为它在回放insert语句时跳过了更新索引的开销。对于InnoDB这样的存储引擎，不建议这样做。</p></li></ul>
                </div>
                <div class="section">
                    <div class="titlepage">
                        <div>
                            <div>
                                <h5 class="title"><a name="replication-howto-mysqldump"></a>16.1.2.4.1&nbsp;Creating a Data Snapshot Using mysqldump</h5>

                            </div>

                        </div>

                    </div>
                    <p>
                        To create a snapshot of the data in an existing master
                        database, use the <a class="link" href="programs.html#mysqldump" title="4.5.4&nbsp;mysqldump — A Database Backup Program"><span class="command"><strong>mysqldump</strong></span></a> tool. Once the
                        data dump has been completed, import this data into the slave
                        before starting the replication process.
                    </p><p style="color:blue;">若要在现有的主数据库中创建数据快照，请使用MySQL转储工具。数据转储完成后，在启动复制过程之前将此数据导入从机。</p><p>
                    The following example dumps all databases to a file named
                    <code class="filename">dbdump.db</code>, and includes the
                    <a class="link" href="programs.html#option_mysqldump_master-data"><code class="option">--master-data</code></a> option which
                    automatically appends the <a class="link" href="sql-syntax.html#change-master-to" title="13.4.2.1&nbsp;CHANGE MASTER TO Syntax"><code class="literal">CHANGE MASTER
                    TO</code></a> statement required on the slave to start the
                    replication process:
                </p><p style="color:blue;">下面的示例将所有数据库转储到一个名为dbdump.db的文件中，并包括--master data选项，该选项自动将change master附加到从属服务器上启动复制过程所需的语句：</p><pre data-lang="terminal" class="programlisting">shell&gt; <strong class="userinput"><code>mysqldump --all-databases --master-data &gt; dbdump.db</code></strong>
</pre>
                    <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">

                        <div class="admon-title">
                            Note
                        </div>
                        <p>
                            If you do not use
                            <a class="link" href="programs.html#option_mysqldump_master-data"><code class="option">--master-data</code></a>, then it is
                            necessary to lock all tables in a separate session manually.
                            See <a class="xref" href="replication.html#replication-howto-masterstatus" title="16.1.2.3&nbsp;Obtaining the Replication Master Binary Log Coordinates">Section&nbsp;16.1.2.3, “Obtaining the Replication Master Binary Log Coordinates”</a>.
                        </p><p style="color:blue;">如果不使用--master data，则需要在单独的会话中手动锁定所有表。见第16.1.2.3节，“获取复制主二进制日志坐标”。</p>
                    </div>
                    <p>
                        It is possible to exclude certain databases from the dump
                        using the <a class="link" href="programs.html#mysqldump" title="4.5.4&nbsp;mysqldump — A Database Backup Program"><span class="command"><strong>mysqldump</strong></span></a> tool. If you want to
                        choose which databases to include in the dump, do not use
                        <a class="link" href="programs.html#option_mysqldump_all-databases"><code class="option">--all-databases</code></a>. Choose one
                        of these options:
                    </p><p style="color:blue;">可以使用mysqldump工具从转储中排除某些数据库。如果要选择要包含在转储中的数据库，请不要使用--all数据库。选择以下选项之一：</p>
                    <div class="itemizedlist">
                        <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                            Exclude all the tables in the database using
                            <a class="link" href="programs.html#option_mysqldump_ignore-table"><code class="option">--ignore-table</code></a> option.


                        </p><p style="color:blue;">使用--ignore table选项排除数据库中的所有表。</p></li><li class="listitem"><p>
                            Name only those databases which you want dumped using the
                            <a class="link" href="programs.html#option_mysqldump_databases"><code class="option">--databases</code></a> option.
                        </p><p style="color:blue;">使用--databases选项仅命名要转储的数据库。</p></li></ul>
                    </div>
                    <p>
                        For more information, see <a class="xref" href="programs.html#mysqldump" title="4.5.4&nbsp;mysqldump — A Database Backup Program">Section&nbsp;4.5.4, “<span class="command"><strong>mysqldump</strong></span> — A Database Backup Program”</a>.
                    </p><p style="color:blue;">有关更多信息，请参阅4.5.4节，“mysqldump-数据库备份程序”。</p><p>
                    To import the data, either copy the dump file to the slave, or
                    access the file from the master when connecting remotely to
                    the slave.
                </p><p style="color:blue;">要导入数据，请将转储文件复制到从机，或在远程连接到从机时从主机访问该文件。</p>
                </div>
                <div class="section">
                    <div class="titlepage">
                        <div>
                            <div>
                                <h5 class="title"><a name="replication-howto-rawdata"></a>16.1.2.4.2&nbsp;Creating a Data Snapshot Using Raw Data Files</h5>

                            </div>

                        </div>

                    </div>
                    <p>
                        This section describes how to create a data snapshot using the
                        raw files which make up the database.



                        Employing this method with a table using a storage engine that
                        has complex caching or logging algorithms requires extra steps
                        to produce a perfect <span class="quote">“<span class="quote">point in time</span>”</span> snapshot:
                        the initial copy command could leave out cache information and
                        logging updates, even if you have acquired a global read lock.
                        How the storage engine responds to this depends on its crash
                        recovery abilities.
                    </p><p style="color:blue;">本节介绍如何使用构成数据库的原始文件创建数据快照。对于使用具有复杂缓存或日志记录算法的存储引擎的表，使用此方法需要额外的步骤来生成完美的“时间点”快照：初始copy命令可能会遗漏缓存信息和日志记录更新，即使您已获得全局读锁。存储引擎对此的响应取决于其崩溃恢复能力。</p><p>
                    If you use <a class="link" href="innodb-storage-engine.html" title="Chapter&nbsp;14&nbsp;The InnoDB Storage Engine"><code class="literal">InnoDB</code></a> tables, you can
                    use the <span class="command"><strong>mysqlbackup</strong></span> command from the MySQL
                    Enterprise Backup component to produce a consistent snapshot.
                    This command records the log name and offset corresponding to
                    the snapshot to be used on the slave. MySQL Enterprise Backup
                    is a commercial product that is included as part of a MySQL
                    Enterprise subscription. See
                    <a class="xref" href="mysql-enterprise.html#mysql-enterprise-backup" title="29.2&nbsp;MySQL Enterprise Backup Overview">Section&nbsp;29.2, “MySQL Enterprise Backup Overview”</a> for detailed
                    information.
                </p><p style="color:blue;">如果使用innodb tables，可以使用mysql企业备份组件中的mysql backup命令生成一致的快照。此命令记录与要在从属服务器上使用的快照相对应的日志名和偏移量。mysql企业备份是作为mysql企业订阅的一部分提供的商业产品。有关详细信息，请参阅第29.2节“MySQL企业备份概述”。</p><p>


                    This method also does not work reliably if the master and
                    slave have different values for
                    <a class="link" href="server-administration.html#sysvar_ft_stopword_file"><code class="literal">ft_stopword_file</code></a>,
                    <a class="link" href="server-administration.html#sysvar_ft_min_word_len"><code class="literal">ft_min_word_len</code></a>, or
                    <a class="link" href="server-administration.html#sysvar_ft_max_word_len"><code class="literal">ft_max_word_len</code></a> and you are
                    copying tables having full-text indexes.
                </p><p style="color:blue;">如果主和从具有不同的ft_stopword_file、ft_min_word_len或ft_max_word_len值，并且您正在复制具有全文索引的表，则此方法也不可靠。</p><p>
                    Assuming the above exceptions do not apply to your database,
                    use the <a class="link" href="glossary.html#glos_cold_backup" title="cold backup">cold backup</a>
                    technique to obtain a reliable binary snapshot of
                    <code class="literal">InnoDB</code> tables: do a
                    <a class="link" href="glossary.html#glos_slow_shutdown" title="slow shutdown">slow shutdown</a> of the
                    MySQL Server, then copy the data files manually.
                </p><p style="color:blue;">假设上述异常不适用于数据库，使用冷备份技术获得innodb表的可靠二进制快照：缓慢关闭mysql服务器，然后手动复制数据文件。</p><p>
                    To create a raw data snapshot of
                    <a class="link" href="storage-engines.html#myisam-storage-engine" title="15.2&nbsp;The MyISAM Storage Engine"><code class="literal">MyISAM</code></a> tables when your MySQL
                    data files exist on a single file system, you can use standard
                    file copy tools such as <span class="command"><strong>cp</strong></span> or
                    <span class="command"><strong>copy</strong></span>, a remote copy tool such as
                    <span class="command"><strong>scp</strong></span> or <span class="command"><strong>rsync</strong></span>, an
                    archiving tool such as <span class="command"><strong>zip</strong></span> or
                    <span class="command"><strong>tar</strong></span>, or a file system snapshot tool such as
                    <span class="command"><strong>dump</strong></span>. If you are replicating only certain
                    databases, copy only those files that relate to those tables.
                    For <code class="literal">InnoDB</code>, all tables in all databases are
                    stored in the <a class="link" href="glossary.html#glos_system_tablespace" title="system tablespace">system
                    tablespace</a> files, unless you have the
                    <a class="link" href="innodb-storage-engine.html#sysvar_innodb_file_per_table"><code class="option">innodb_file_per_table</code></a> option
                    enabled.
                </p><p style="color:blue;">若要在MySQL数据文件存在于单个文件系统上创建MyISAM表的原始数据快照，可以使用标准文件复制工具，如CP或拷贝、远程复制工具（如SCP或RSyc）、归档工具（如ZIP或TAR）或文件系统快照工具（如转储）。如果只复制某些数据库，请只复制与这些表相关的文件。对于innodb，所有数据库中的所有表都存储在系统表空间文件中，除非启用了innodb_file_per_table选项。</p><p>
                    The following files are not required for replication:
                </p><p style="color:blue;">复制不需要以下文件：</p>
                    <div class="itemizedlist">
                        <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                            Files relating to the <code class="literal">mysql</code> database.
                        </p><p style="color:blue;">与mysql数据库相关的文件。</p></li><li class="listitem"><p>
                            The master info repository file, if used (see
                            <a class="xref" href="replication.html#slave-logs" title="16.2.4&nbsp;Replication Relay and Status Logs">Section&nbsp;16.2.4, “Replication Relay and Status Logs”</a>).
                        </p><p style="color:blue;">主信息存储库文件（如果使用）（请参阅第16.2.4节“复制中继和状态日志”）。</p></li><li class="listitem"><p>
                            The master's binary log files, with the exception of the
                            binary log index file if you are going to use this to
                            locate the master binary log coordinates for the slave.
                        </p><p style="color:blue;">主机的二进制日志文件，但二进制日志索引文件除外，如果要使用它来定位从机的主二进制日志坐标。</p></li><li class="listitem"><p>
                            Any relay log files.
                        </p><p style="color:blue;">任何中继日志文件。</p></li></ul>
                    </div>
                    <p>
                        Depending on whether you are using <code class="literal">InnoDB</code>
                        tables or not, choose one of the following:
                    </p><p style="color:blue;">根据您是否在使用innodb表，选择以下选项之一：</p><p>
                    If you are using <a class="link" href="innodb-storage-engine.html" title="Chapter&nbsp;14&nbsp;The InnoDB Storage Engine"><code class="literal">InnoDB</code></a> tables,
                    and also to get the most consistent results with a raw data
                    snapshot, shut down the master server during the process, as
                    follows:
                </p><p style="color:blue;">如果您使用的是innodb表，并且要获得与原始数据快照最一致的结果，请在该过程中关闭主服务器，如下所示：</p>
                    <div class="orderedlist">
                        <ol class="orderedlist" type="1"><li class="listitem"><p>
                            Acquire a read lock and get the master's status. See
                            <a class="xref" href="replication.html#replication-howto-masterstatus" title="16.1.2.3&nbsp;Obtaining the Replication Master Binary Log Coordinates">Section&nbsp;16.1.2.3, “Obtaining the Replication Master Binary Log Coordinates”</a>.
                        </p><p style="color:blue;">获取一个读锁并获取主控的状态。见第16.1.2.3节，“获取复制主二进制日志坐标”。</p></li><li class="listitem"><p>
                            In a separate session, shut down the master server:
                        </p><p style="color:blue;">在单独的会话中，关闭主服务器：</p><pre data-lang="terminal" class="programlisting">shell&gt; <strong class="userinput"><code>mysqladmin shutdown</code></strong>
</pre></li><li class="listitem"><p>
                            Make a copy of the MySQL data files. The following
                            examples show common ways to do this. You need to choose
                            only one of them:
                        </p><p style="color:blue;">复制mysql数据文件。下面的例子展示了实现这一点的常用方法。您只需选择其中一个：</p><pre data-lang="terminal" class="programlisting">shell&gt; <strong class="userinput"><code>tar cf <em class="replaceable"><code>/tmp/db.tar</code></em> <em class="replaceable"><code>./data</code></em></code></strong>
shell&gt; <strong class="userinput"><code>zip -r <em class="replaceable"><code>/tmp/db.zip</code></em> <em class="replaceable"><code>./data</code></em></code></strong>
shell&gt; <strong class="userinput"><code>rsync --recursive <em class="replaceable"><code>./data</code></em> <em class="replaceable"><code>/tmp/dbdata</code></em></code></strong>
</pre></li><li class="listitem"><p>
                            Restart the master server.
                        </p><p style="color:blue;">重新启动主服务器。</p></li></ol>
                    </div>
                    <p>
                        If you are not using <a class="link" href="innodb-storage-engine.html" title="Chapter&nbsp;14&nbsp;The InnoDB Storage Engine"><code class="literal">InnoDB</code></a>
                        tables, you can get a snapshot of the system from a master
                        without shutting down the server as described in the following
                        steps:
                    </p><p style="color:blue;">如果不使用innodb tables，可以从master获取系统的快照，而不必按照以下步骤关闭服务器：</p>
                    <div class="orderedlist">
                        <ol class="orderedlist" type="1"><li class="listitem"><p>
                            Acquire a read lock and get the master's status. See
                            <a class="xref" href="replication.html#replication-howto-masterstatus" title="16.1.2.3&nbsp;Obtaining the Replication Master Binary Log Coordinates">Section&nbsp;16.1.2.3, “Obtaining the Replication Master Binary Log Coordinates”</a>.
                        </p><p style="color:blue;">获取一个读锁并获取主控的状态。见第16.1.2.3节，“获取复制主二进制日志坐标”。</p></li><li class="listitem"><p>
                            Make a copy of the MySQL data files. The following
                            examples show common ways to do this. You need to choose
                            only one of them:
                        </p><p style="color:blue;">复制mysql数据文件。下面的例子展示了实现这一点的常用方法。您只需选择其中一个：</p><pre data-lang="terminal" class="programlisting">shell&gt; <strong class="userinput"><code>tar cf <em class="replaceable"><code>/tmp/db.tar</code></em> <em class="replaceable"><code>./data</code></em></code></strong>
shell&gt; <strong class="userinput"><code>zip -r <em class="replaceable"><code>/tmp/db.zip</code></em> <em class="replaceable"><code>./data</code></em></code></strong>
shell&gt; <strong class="userinput"><code>rsync --recursive <em class="replaceable"><code>./data</code></em> <em class="replaceable"><code>/tmp/dbdata</code></em></code></strong>
</pre></li><li class="listitem"><p>
                            In the client where you acquired the read lock, release
                            the lock:
                        </p><p style="color:blue;">在获取读锁的客户端中，释放锁：</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>UNLOCK TABLES;</code></strong>
</pre></li></ol>
                    </div>
                    <p>
                        Once you have created the archive or copy of the database,
                        copy the files to each slave before starting the slave
                        replication process.
                    </p><p style="color:blue;">一旦创建了数据库的存档或副本，请在启动从机复制过程之前将文件复制到每个从机。</p>
                </div>

            </div>
            <div class="section">
                <div class="titlepage">
                    <div>
                        <div>
                            <h4 class="title"><a name="replication-setup-slaves"></a>16.1.2.5&nbsp;Setting Up Replication Slaves</h4>

                        </div>

                    </div>

                </div>
                <p>
                    The following sections describe how to set up slaves. Before you
                    proceed, ensure that you have:
                </p><p style="color:blue;">以下各节介绍如何设置从属服务器。在继续之前，请确保：</p>
                <div class="itemizedlist">
                    <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                        Configured the MySQL master with the necessary configuration
                        properties. See
                        <a class="xref" href="replication.html#replication-howto-masterbaseconfig" title="16.1.2.1&nbsp;Setting the Replication Master Configuration">Section&nbsp;16.1.2.1, “Setting the Replication Master Configuration”</a>.
                    </p><p style="color:blue;">使用必要的配置属性配置mysql主机。请参阅第16.1.2.1节“设置复制主配置”。</p></li><li class="listitem"><p>
                        Obtained the master status information, or a copy of the
                        master's binary log index file made during a shutdown for
                        the data snapshot. See
                        <a class="xref" href="replication.html#replication-howto-masterstatus" title="16.1.2.3&nbsp;Obtaining the Replication Master Binary Log Coordinates">Section&nbsp;16.1.2.3, “Obtaining the Replication Master Binary Log Coordinates”</a>.
                    </p><p style="color:blue;">获取主状态信息，或在数据快照关闭期间生成的主二进制日志索引文件的副本。见第16.1.2.3节，“获取复制主二进制日志坐标”。</p></li><li class="listitem"><p>
                        On the master, released the read lock:
                    </p><p style="color:blue;">在主机上，释放读锁：</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>UNLOCK TABLES;</code></strong>
</pre></li></ul>
                </div>
                <div class="section">
                    <div class="titlepage">
                        <div>
                            <div>
                                <h5 class="title"><a name="replication-howto-slavebaseconfig"></a>16.1.2.5.1&nbsp;Setting the Replication Slave Configuration</h5>

                            </div>

                        </div>

                    </div>
                    <p>
                        Each replication slave <span class="emphasis"><em>must</em></span> have a unique
                        server ID. If this has not already been done, this part of
                        slave setup requires a server restart.
                    </p><p style="color:blue;">每个复制从属服务器必须具有唯一的服务器ID。如果尚未完成此操作，则此部分从属服务器设置需要重新启动服务器。</p><p>
                    If the slave server ID is not already set, or the current
                    value conflicts with the value that you have chosen for the
                    master server, shut down the slave server and edit the
                    <code class="literal">[mysqld]</code> section of the configuration file
                    to specify a unique server ID. For example:


                </p><p style="color:blue;">如果尚未设置从属服务器ID，或者当前值与为主服务器选择的值冲突，请关闭从属服务器并编辑配置文件的[mysqld]部分以指定唯一的服务器ID。例如：</p><pre data-lang="ini" class="programlisting">[mysqld]
server-id=2
</pre><p>
                    After making the changes, restart the server.
                </p><p style="color:blue;">进行更改后，重新启动服务器。</p><p>
                    If you are setting up multiple slaves, each one must have a
                    unique <a class="link" href="replication.html#option_mysqld_server-id"><code class="option">server-id</code></a> value that
                    differs from that of the master and from any of the other
                    slaves.
                </p><p style="color:blue;">如果要设置多个从属服务器，则每个从属服务器都必须具有与主服务器和任何其他从属服务器不同的唯一服务器ID值。</p>
                    <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">

                        <div class="admon-title">
                            Note
                        </div>
                        <p>
                            If you omit <a class="link" href="replication.html#option_mysqld_server-id"><code class="option">server-id</code></a> (or set
                            it explicitly to its default value of 0), the slave refuses
                            to connect to a master.
                        </p><p style="color:blue;">如果省略服务器id（或将其显式设置为默认值0），则从服务器拒绝连接到主服务器。</p>
                    </div>
                    <p>
                        You do not have to enable binary logging on the slave for
                        replication to be set up. However, if you enable binary
                        logging on the slave, you can use the slave's binary log
                        for data backups and crash recovery, and also use the slave as
                        part of a more complex replication topology. For example,
                        where this slave then acts as a master to other slaves.
                    </p><p style="color:blue;">要设置复制，不必在从机上启用二进制日志记录。但是，如果在从机上启用二进制日志记录，则可以使用从机的二进制日志进行数据备份和崩溃恢复，还可以将从机用作更复杂的复制拓扑的一部分。例如，当这个奴隶充当其他奴隶的主人时。</p>
                </div>
                <div class="section">
                    <div class="titlepage">
                        <div>
                            <div>
                                <h5 class="title"><a name="replication-howto-slaveinit"></a>16.1.2.5.2&nbsp;Setting the Master Configuration on the Slave</h5>

                            </div>

                        </div>

                    </div>
                    <p>
                        To set up the slave to communicate with the master for
                        replication, configure the slave with the necessary connection
                        information. To do this, execute the following statement on
                        the slave, replacing the option values with the actual values
                        relevant to your system:
                    </p><p style="color:blue;">要设置从机与主机通信以进行复制，请使用必要的连接信息配置从机。为此，请在从机上执行以下语句，将选项值替换为与系统相关的实际值：</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>CHANGE MASTER TO</code></strong>
    -&gt;     <strong class="userinput"><code>MASTER_HOST='<em class="replaceable"><code>master_host_name</code></em>',</code></strong>
    -&gt;     <strong class="userinput"><code>MASTER_USER='<em class="replaceable"><code>replication_user_name</code></em>',</code></strong>
    -&gt;     <strong class="userinput"><code>MASTER_PASSWORD='<em class="replaceable"><code>replication_password</code></em>',</code></strong>
    -&gt;     <strong class="userinput"><code>MASTER_LOG_FILE='<em class="replaceable"><code>recorded_log_file_name</code></em>',</code></strong>
    -&gt;     <strong class="userinput"><code>MASTER_LOG_POS=<em class="replaceable"><code>recorded_log_position</code></em>;</code></strong>
</pre>
                    <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">

                        <div class="admon-title">
                            Note
                        </div>
                        <p>
                            Replication cannot use Unix socket files. You must be able
                            to connect to the master MySQL server using TCP/IP.
                        </p><p style="color:blue;">复制不能使用unix套接字文件。您必须能够使用TCP/IP连接到主MySQL服务器。</p>
                    </div>
                    <p>
                        The <a class="link" href="sql-syntax.html#change-master-to" title="13.4.2.1&nbsp;CHANGE MASTER TO Syntax"><code class="literal">CHANGE MASTER TO</code></a> statement
                        has other options as well. For example, it is possible to set
                        up secure replication using SSL. For a full list of options,
                        and information about the maximum permissible length for the
                        string-valued options, see <a class="xref" href="sql-syntax.html#change-master-to" title="13.4.2.1&nbsp;CHANGE MASTER TO Syntax">Section&nbsp;13.4.2.1, “CHANGE MASTER TO Syntax”</a>.
                    </p><p style="color:blue;">change master to语句还有其他选项。例如，可以使用ssl设置安全复制。有关选项的完整列表和字符串值选项的最大允许长度的信息，请参阅第134.2.1节，“更改主语法”。</p><p>
                    The next steps depend on whether you have existing data to
                    import to the slave or not. See
                    <a class="xref" href="replication.html#replication-snapshot-method" title="16.1.2.4&nbsp;Choosing a Method for Data Snapshots">Section&nbsp;16.1.2.4, “Choosing a Method for Data Snapshots”</a> for more
                    information. Choose one of the following:
                </p><p style="color:blue;">接下来的步骤取决于是否存在要导入到奴隶的现有数据。有关详细信息，请参阅第16.1.2.4节“为数据快照选择方法”。选择下列选项之一：</p>
                    <div class="itemizedlist">
                        <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                            If you do not have a snapshot of a database to import, see
                            <a class="xref" href="replication.html#replication-howto-newservers" title="16.1.2.5.3&nbsp;Setting Up Replication between a New Master and Slaves">Section&nbsp;16.1.2.5.3, “Setting Up Replication between a New Master and Slaves”</a>.
                        </p><p style="color:blue;">如果没有要导入的数据库快照，请参阅16.1.2.5.3节“在新主服务器和从服务器之间设置复制”。</p></li><li class="listitem"><p>
                            If you have a snapshot of a database to import, see
                            <a class="xref" href="replication.html#replication-howto-existingdata" title="16.1.2.5.4&nbsp;Setting Up Replication with Existing Data">Section&nbsp;16.1.2.5.4, “Setting Up Replication with Existing Data”</a>.
                        </p><p style="color:blue;">如果您有一个要导入的数据库的快照，请参阅第16.1.2.5.4节，“用现有数据设置复制”。</p></li></ul>
                    </div>

                </div>
                <div class="section">
                    <div class="titlepage">
                        <div>
                            <div>
                                <h5 class="title"><a name="replication-howto-newservers"></a>16.1.2.5.3&nbsp;Setting Up Replication between a New Master and Slaves</h5>

                            </div>

                        </div>

                    </div>
                    <p>
                        When there is no snapshot of a previous database to import,
                        configure the slave to start the replication from the new
                        master.
                    </p><p style="color:blue;">如果没有要导入的前一个数据库的快照，请将从服务器配置为从新主服务器启动复制。</p><p>
                    To set up replication between a master and a new slave:
                </p><p style="color:blue;">要在主服务器和新从服务器之间设置复制，请执行以下操作：</p>
                    <div class="orderedlist">
                        <ol class="orderedlist" type="1"><li class="listitem"><p>
                            Start up the MySQL slave and connect to it.
                        </p><p style="color:blue;">启动mysql从机并连接到它。</p></li><li class="listitem"><p>
                            Execute a <a class="link" href="sql-syntax.html#change-master-to" title="13.4.2.1&nbsp;CHANGE MASTER TO Syntax"><code class="literal">CHANGE MASTER TO</code></a>
                            statement to set the master replication server
                            configuration. See
                            <a class="xref" href="replication.html#replication-howto-slaveinit" title="16.1.2.5.2&nbsp;Setting the Master Configuration on the Slave">Section&nbsp;16.1.2.5.2, “Setting the Master Configuration on the Slave”</a>.
                        </p><p style="color:blue;">执行change master to语句以设置主复制服务器配置。见第16.1.2.5.2节，“在从机上设置主配置”。</p></li></ol>
                    </div>
                    <p>
                        Perform these slave setup steps on each slave.
                    </p><p style="color:blue;">对每个从机执行这些从机设置步骤。</p><p>
                    This method can also be used if you are setting up new servers
                    but have an existing dump of the databases from a different
                    server that you want to load into your replication
                    configuration. By loading the data into a new master, the data
                    is automatically replicated to the slaves.
                </p><p style="color:blue;">如果您正在建立新的服务器，但有一个现有的数据库转储到您要加载到复制配置的不同服务器中，则此方法也可以使用。通过将数据加载到新的主设备中，数据将自动复制到从设备中。</p><p>
                    If you are setting up a new replication environment using the
                    data from a different existing database server to create a new
                    master, run the dump file generated from that server on the
                    new master. The database updates are automatically propagated
                    to the slaves:
                </p><p style="color:blue;">如果正在使用来自不同现有数据库服务器的数据来创建新的复制环境，以创建新的主机，则在新主机上运行从该服务器生成的转储文件。数据库更新将自动传播到从属服务器：</p><pre data-lang="terminal" class="programlisting">shell&gt; <strong class="userinput"><code>mysql -h master &lt; fulldb.dump</code></strong>
</pre>
                </div>
                <div class="section">
                    <div class="titlepage">
                        <div>
                            <div>
                                <h5 class="title"><a name="replication-howto-existingdata"></a>16.1.2.5.4&nbsp;Setting Up Replication with Existing Data</h5>

                            </div>

                        </div>

                    </div>
                    <p>
                        When setting up replication with existing data, transfer the
                        snapshot from the master to the slave before starting
                        replication. The process for importing data to the slave
                        depends on how you created the snapshot of data on the master.
                    </p><p style="color:blue;">在使用现有数据设置复制时，在启动复制之前将快照从主控器转移到从属服务器。将数据导入从属服务器的过程取决于您如何在主服务器上创建数据快照。</p><p>
                    Choose one of the following:
                </p><p style="color:blue;">选择下列选项之一：</p><p>
                    If you used <a class="link" href="programs.html#mysqldump" title="4.5.4&nbsp;mysqldump — A Database Backup Program"><span class="command"><strong>mysqldump</strong></span></a>:
                </p><p style="color:blue;">如果使用mysqldump：</p>
                    <div class="orderedlist">
                        <ol class="orderedlist" type="1"><li class="listitem"><p>
                            Start the slave, using the
                            <a class="link" href="replication.html#option_mysqld_skip-slave-start"><code class="option">--skip-slave-start</code></a> option
                            so that replication does not start.
                        </p><p style="color:blue;">使用--skip slave start选项启动从机，这样复制就不会启动。</p></li><li class="listitem"><p>
                            Import the dump file:
                        </p><p style="color:blue;">导入转储文件：</p><pre data-lang="terminal" class="programlisting">shell&gt; <strong class="userinput"><code>mysql &lt; fulldb.dump</code></strong>
</pre></li></ol>
                    </div>
                    <p>
                        If you created a snapshot using the raw data files:
                    </p><p style="color:blue;">如果使用原始数据文件创建快照：</p>
                    <div class="orderedlist">
                        <ol class="orderedlist" type="1"><li class="listitem"><p>
                            Extract the data files into your slave data directory. For
                            example:
                        </p><p style="color:blue;">将数据文件提取到从属数据目录中。例如：</p><pre data-lang="terminal" class="programlisting">shell&gt; <strong class="userinput"><code>tar xvf dbdump.tar</code></strong>
</pre><p>
                            You may need to set permissions and ownership on the files
                            so that the slave server can access and modify them.
                        </p><p style="color:blue;">您可能需要设置文件的权限和所有权，以便从属服务器可以访问和修改它们。</p></li><li class="listitem"><p>
                            Start the slave, using the
                            <a class="link" href="replication.html#option_mysqld_skip-slave-start"><code class="option">--skip-slave-start</code></a> option
                            so that replication does not start.
                        </p><p style="color:blue;">使用--skip slave start选项启动从机，这样复制就不会启动。</p></li><li class="listitem"><p>
                            Configure the slave with the replication coordinates from
                            the master. This tells the slave the binary log file and
                            position within the file where replication needs to start.
                            Also, configure the slave with the login credentials and
                            host name of the master. For more information on the
                            <a class="link" href="sql-syntax.html#change-master-to" title="13.4.2.1&nbsp;CHANGE MASTER TO Syntax"><code class="literal">CHANGE MASTER TO</code></a> statement
                            required, see
                            <a class="xref" href="replication.html#replication-howto-slaveinit" title="16.1.2.5.2&nbsp;Setting the Master Configuration on the Slave">Section&nbsp;16.1.2.5.2, “Setting the Master Configuration on the Slave”</a>.
                        </p><p style="color:blue;">使用来自主服务器的复制坐标配置从服务器。这将告诉从服务器二进制日志文件和文件中需要启动复制的位置。另外，使用主服务器的登录凭据和主机名配置从服务器。有关将master更改为statement required的更多信息，请参阅16.1.2.5.2节，“在从机上设置master配置”。</p></li><li class="listitem"><p>
                            Start the slave threads:
                        </p><p style="color:blue;">启动从线程：</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>START SLAVE;</code></strong>
</pre></li></ol>
                    </div>
                    <p>
                        After you have performed this procedure, the slave connects to
                        the master and replicates any updates that have occurred on
                        the master since the snapshot was taken.
                    </p><p style="color:blue;">执行此过程后，从服务器将连接到主服务器，并复制自拍摄快照以来在主服务器上发生的任何更新。</p><p>
                    If the <a class="link" href="replication.html#option_mysqld_server-id"><code class="option">server-id</code></a> option for the
                    master is not correctly set, slaves cannot connect to it.
                    Similarly, if you have not set the
                    <a class="link" href="replication.html#option_mysqld_server-id"><code class="option">server-id</code></a> option correctly for
                    the slave, you get the following error in the slave's error
                    log:
                </p><p style="color:blue;">如果未正确设置主服务器的服务器ID选项，则从服务器无法连接到主服务器。同样，如果没有为从属服务器正确设置服务器ID选项，则在从属服务器的错误日志中会出现以下错误：</p><pre data-lang="none" class="programlisting">Warning: You should set server-id to a non-0 value if master_host
is set; we will force server id to 2, but this MySQL server will
not act as a slave.
</pre><p>
                    You also find error messages in the slave's error log if it is
                    not able to replicate for any other reason.
                </p><p style="color:blue;">如果由于任何其他原因无法复制，也可以在从属服务器的错误日志中找到错误消息。</p><p>
                    The slave stores information about the master you have
                    configured in its master info repository. The master info
                    repository can be in the form of files or a table, as
                    determined by the value set for
                    <a class="link" href="replication.html#option_mysqld_master-info-repository"><code class="option">--master-info-repository</code></a>. When
                    a slave uses <code class="option">--master-info-repository=FILE</code>,
                    two files are stored in the data directory, named
                    <code class="filename">master.info</code> and
                    <code class="filename">relay-log.info</code>. If
                    <code class="option">--master-info-repository=TABLE</code> instead, this
                    information is saved in the
                    <code class="literal">master_slave_info</code> table in the
                    <code class="literal">mysql</code> database. In either case, do
                    <span class="emphasis"><em>not</em></span> remove or edit the files or table.
                    Always use the <a class="link" href="sql-syntax.html#change-master-to" title="13.4.2.1&nbsp;CHANGE MASTER TO Syntax"><code class="literal">CHANGE MASTER TO</code></a>
                    statement to change replication parameters. The slave can use
                    the values specified in the statement to update the status
                    files automatically. See <a class="xref" href="replication.html#slave-logs" title="16.2.4&nbsp;Replication Relay and Status Logs">Section&nbsp;16.2.4, “Replication Relay and Status Logs”</a>, for
                    more information.
                </p><p style="color:blue;">从服务器存储有关您在其主信息存储库中配置的主服务器的信息。主信息存储库可以是文件或表的形式，由--master info repository的值集决定。当从机使用--master info repository=file时，有两个文件存储在数据目录中，名为master.info和relay-log.info。如果改为--master info repository=table，则此信息保存在mysql数据库的master_slave_info表中。无论哪种情况，都不要删除或编辑文件或表。始终使用change master to语句更改复制参数。从机可以使用语句中指定的值自动更新状态文件。有关更多信息，请参阅第16.2.4节“复制中继和状态日志”。</p>
                    <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">

                        <div class="admon-title">
                            Note
                        </div>
                        <p>
                            The contents of the master info repository override some of
                            the server options specified on the command line or in
                            <code class="filename">my.cnf</code>. See
                            <a class="xref" href="replication.html#replication-options" title="16.1.6&nbsp;Replication and Binary Logging Options and Variables">Section&nbsp;16.1.6, “Replication and Binary Logging Options and Variables”</a>, for more details.
                        </p><p style="color:blue;">主信息存储库的内容将覆盖在命令行或my.cnf中指定的某些服务器选项。有关更多详细信息，请参阅第16.1.6节“复制和二进制日志记录选项和变量”。</p>
                    </div>
                    <p>
                        A single snapshot of the master suffices for multiple slaves.
                        To set up additional slaves, use the same master snapshot and
                        follow the slave portion of the procedure just described.
                    </p><p style="color:blue;">一个主节点的快照就足够多个从节点使用了。要设置其他从机，请使用相同的主快照并遵循刚才描述的过程的从机部分。</p>
                </div>

            </div>
            <div class="section">
                <div class="titlepage">
                    <div>
                        <div>
                            <h4 class="title"><a name="replication-howto-additionalslaves"></a>16.1.2.6&nbsp;Adding Slaves to a Replication Environment</h4>

                        </div>

                    </div>

                </div>
                <p>
                    You can add another slave to an existing replication
                    configuration without stopping the master. To do this, you can
                    set up the new slave by copying the data directory of an
                    existing slave, and giving the new slave a different server ID
                    (which is user-specified) and server UUID (which is generated at
                    startup).
                </p><p style="color:blue;">可以在不停止主控的情况下向现有复制配置添加另一个从属。为此，可以通过复制现有奴隶的数据目录来设置新的奴隶，并给新的奴隶提供不同的服务器ID（它是用户指定的）和服务器UUID（在启动时生成）。</p><p>
                To duplicate an existing slave:
            </p><p style="color:blue;">复制现有的奴隶：</p>
                <div class="orderedlist">
                    <ol class="orderedlist" type="1"><li class="listitem"><p>
                        Stop the existing slave and record the slave status
                        information, particularly the master binary log file and
                        relay log file positions. You can view the slave status
                        either in the Performance Schema replication tables (see
                        <a class="xref" href="performance-schema.html#performance-schema-replication-tables" title="25.12.11&nbsp;Performance Schema Replication Tables">Section&nbsp;25.12.11, “Performance Schema Replication Tables”</a>), or
                        by issuing <a class="link" href="sql-syntax.html#show-slave-status" title="13.7.5.34&nbsp;SHOW SLAVE STATUS Syntax"><code class="literal">SHOW SLAVE STATUS</code></a>
                        as follows:
                    </p><p style="color:blue;">停止现有的从属文件并记录从属状态信息，特别是主二进制日志文件和中继日志文件位置。您可以在性能模式复制表中查看从属状态（请参阅25.12.11节，“性能模式复制表”），也可以按如下方式发出show slave status：</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>STOP SLAVE;</code></strong>
mysql&gt; <strong class="userinput"><code>SHOW SLAVE STATUS\G</code></strong>
</pre></li><li class="listitem"><p>
                        Shut down the existing slave:
                    </p><p style="color:blue;">关闭现有奴隶：</p><pre data-lang="terminal" class="programlisting">shell&gt; <strong class="userinput"><code>mysqladmin shutdown</code></strong>
</pre></li><li class="listitem"><p>
                        Copy the data directory from the existing slave to the new
                        slave, including the log files and relay log files. You can
                        do this by creating an archive using <span class="command"><strong>tar</strong></span>
                        or <code class="literal">WinZip</code>, or by performing a direct copy
                        using a tool such as <span class="command"><strong>cp</strong></span> or
                        <span class="command"><strong>rsync</strong></span>.
                    </p><p style="color:blue;">将数据目录从现有的奴隶复制到新的奴隶，包括日志文件和中继日志文件。可以通过使用tar或winzip创建归档文件，或者使用cp或rsync等工具执行直接复制来完成此操作。</p>
                        <div class="important" style="margin-left: 0.5in; margin-right: 0.5in;">

                            <div class="admon-title">
                                Important
                            </div>

                            <div class="itemizedlist">
                                <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                                    Before copying, verify that all the files relating to
                                    the existing slave actually are stored in the data
                                    directory. For example, the <code class="literal">InnoDB</code>
                                    system tablespace, undo tablespace, and redo log might
                                    be stored in an alternative location.
                                    <code class="literal">InnoDB</code> tablespace files and
                                    file-per-table tablespaces might have been created in
                                    other directories. The binary logs and relay logs for
                                    the slave might be in their own directories outside
                                    the data directory. Check through the system variables
                                    that are set for the existing slave and look for any
                                    alternative paths that have been specified. If you
                                    find any, copy these directories over as well.
                                </p><p style="color:blue;">在复制之前，验证与现有奴隶相关的所有文件实际上都存储在数据目录中。例如，innodb系统表空间、undo表空间和redo日志可能存储在另一个位置。innodb表空间文件和每个表空间的文件可能是在其他目录中创建的。从机的二进制日志和中继日志可能位于数据目录之外的它们自己的目录中。检查为现有奴隶设置的系统变量，并查找已指定的任何替代路径。如果你找到了，把这些目录也复制过来。</p></li><li class="listitem"><p>
                                    During copying, if files have been used for the master
                                    info and relay log info repositories (see
                                    <a class="xref" href="replication.html#slave-logs" title="16.2.4&nbsp;Replication Relay and Status Logs">Section&nbsp;16.2.4, “Replication Relay and Status Logs”</a>), which is the default in
                                    MySQL 5.7, ensure that you also copy these files from
                                    the existing slave to the new slave. If tables have
                                    been used for the repositories, the tables are in the
                                    data directory.
                                </p><p style="color:blue;">在复制过程中，如果文件已被用于主信息和中继日志信息库（见第16.2.4节，“复制中继和状态日志”），这是MySQL 5.7中的默认值，确保您也将这些文件从现有的奴隶复制到新的奴隶。如果表已用于存储库，则表位于数据目录中。</p></li><li class="listitem"><p>
                                    After copying, delete the
                                    <code class="filename">auto.cnf</code> file from the copy of
                                    the data directory on the new slave, so that the new
                                    slave is started with a different generated server
                                    UUID. The server UUID must be unique.
                                </p><p style="color:blue;">复制后，从新从属服务器上的数据目录副本中删除auto.cnf文件，以便用另一个生成的服务器uuid启动新从属服务器。服务器uuid必须是唯一的。</p></li></ul>
                            </div>

                        </div>
                        <p>
                            A common problem that is encountered when adding new
                            replication slaves is that the new slave fails with a series
                            of warning and error messages like these:
                        </p><p style="color:blue;">添加新复制从属服务器时遇到的一个常见问题是，新从属服务器失败，并显示一系列警告和错误消息，如：</p><pre data-lang="none" class="programlisting">071118 16:44:10 [Warning] Neither --relay-log nor --relay-log-index were used; so
replication may break when this MySQL server acts as a slave and has his hostname
changed!! Please use '--relay-log=<em class="replaceable"><code>new_slave_hostname</code></em>-relay-bin' to avoid this problem.
<span class="errortext">071118 16:44:10 [ERROR] Failed to open the relay log './<em class="replaceable"><code>old_slave_hostname</code></em>-relay-bin.003525'
(relay_log_pos 22940879)</span>
071118 16:44:10 <span class="errortext">[ERROR] Could not find target log during relay log initialization</span>
071118 16:44:10 <span class="errortext">[ERROR] Failed to initialize the master info structure</span>
</pre><p>
                            This situation can occur if the
                            <a class="link" href="replication.html#sysvar_relay_log"><code class="literal">relay_log</code></a> system variable
                            is not specified, as the relay log files contain the host
                            name as part of their file names. This is also true of the
                            relay log index file if the
                            <a class="link" href="replication.html#sysvar_relay_log_index"><code class="literal">relay_log_index</code></a> system
                            variable is not used. For more information about these
                            variables, see <a class="xref" href="replication.html#replication-options" title="16.1.6&nbsp;Replication and Binary Logging Options and Variables">Section&nbsp;16.1.6, “Replication and Binary Logging Options and Variables”</a>.
                        </p><p style="color:blue;">如果未指定RELAY U LOG系统变量，则可能发生这种情况，因为RELAY日志文件包含主机名作为其文件名的一部分。如果不使用RELAY LOG U INDEX系统变量，则RELAY LOG INDEX文件也是如此。有关这些变量的更多信息，请参阅16.1.6节，“复制和二进制日志选项和变量”。</p><p>
                            To avoid this problem, use the same value for
                            <a class="link" href="replication.html#sysvar_relay_log"><code class="literal">relay_log</code></a> on the new slave
                            that was used on the existing slave. If this option was not
                            set explicitly on the existing slave, use
                            <code class="literal"><em class="replaceable"><code>existing_slave_hostname</code></em>-relay-bin</code>.
                            If this is not possible, copy the existing slave's relay log
                            index file to the new slave and set the
                            <a class="link" href="replication.html#sysvar_relay_log_index"><code class="literal">relay_log_index</code></a> system
                            variable on the new slave to match what was used on the
                            existing slave. If this option was not set explicitly on the
                            existing slave, use
                            <code class="literal"><em class="replaceable"><code>existing_slave_hostname</code></em>-relay-bin.index</code>.
                            Alternatively, if you have already tried to start the new
                            slave after following the remaining steps in this section
                            and have encountered errors like those described previously,
                            then perform the following steps:
                        </p><p style="color:blue;">为了避免这个问题，在现有奴隶上使用的新奴隶上使用RelayyLoad的相同值。如果未在现有的从属设备上显式设置此选项，请使用SurvivsSLaveIHEnthel-Relay-Bin。如果这是不可能的，则将现有的从属中继日志索引文件复制到新的从属文件，并将RelayLogLogyCindex系统变量设置在新的奴隶上，以匹配现有奴隶上使用的变量。如果未在现有的从属设备上显式设置此选项，请使用SurvivsSLaveIHEnthel-Relay-BIN索引。或者，如果您在遵循本节中的其余步骤之后已经尝试启动新从属服务器，并且遇到了与前面所述类似的错误，请执行以下步骤：</p>
                        <div class="orderedlist">
                            <ol class="orderedlist" type="a"><li class="listitem"><p>
                                If you have not already done so, issue
                                <a class="link" href="sql-syntax.html#stop-slave" title="13.4.2.7&nbsp;STOP SLAVE Syntax"><code class="literal">STOP SLAVE</code></a> on the new
                                slave.
                            </p><p style="color:blue;">如果您尚未执行此操作，请对新的从属服务器发出停止从属服务器。</p><p>
                                If you have already started the existing slave again,
                                issue <a class="link" href="sql-syntax.html#stop-slave" title="13.4.2.7&nbsp;STOP SLAVE Syntax"><code class="literal">STOP SLAVE</code></a> on the
                                existing slave as well.
                            </p><p style="color:blue;">如果您已经再次启动了现有的奴隶，那么在现有的奴隶上发布停止奴隶。</p></li><li class="listitem"><p>
                                Copy the contents of the existing slave's relay log
                                index file into the new slave's relay log index file,
                                making sure to overwrite any content already in the
                                file.
                            </p><p style="color:blue;">将现有奴隶的中继日志索引文件的内容复制到新奴隶的中继日志索引文件中，确保覆盖文件中已经存在的任何内容。</p></li><li class="listitem"><p>
                                Proceed with the remaining steps in this section.
                            </p><p style="color:blue;">继续执行本节中的其余步骤。</p></li></ol>
                        </div>
                    </li><li class="listitem"><p>
                        When copying is complete, restart the existing slave.
                    </p><p style="color:blue;">复制完成后，重新启动现有的从属文件。</p></li><li class="listitem"><p>
                        On the new slave, edit the configuration and give the new
                        slave a unique server ID (using the
                        <a class="link" href="replication.html#option_mysqld_server-id"><code class="option">server-id</code></a> option) that is not
                        used by the master or any of the existing slaves.
                    </p><p style="color:blue;">在新的奴隶上，编辑配置，并给新的奴隶一个唯一的服务器ID（使用服务器ID选项），不被主或任何现有奴隶使用。</p></li><li class="listitem"><p>
                        Start the new slave server, specifying the
                        <a class="link" href="replication.html#option_mysqld_skip-slave-start"><code class="option">--skip-slave-start</code></a> option so
                        that replication does not start yet. Use the Performance
                        Schema replication tables or issue <a class="link" href="sql-syntax.html#show-slave-status" title="13.7.5.34&nbsp;SHOW SLAVE STATUS Syntax"><code class="literal">SHOW
                        SLAVE STATUS</code></a> to confirm that the new slave has the
                        correct settings when compared with the existing slave. Also
                        display the server ID and server UUID and verify that these
                        are correct and unique for the new slave.
                    </p><p style="color:blue;">启动新的从属服务器，指定--skip slave start选项，以便复制尚未启动。使用性能模式复制表或发出“显示从属”状态，以确认新的从属设备与现有的从属设备相比具有正确的设置。同时显示服务器id和服务器uuid，并验证它们对于新的从机是正确和唯一的。</p></li><li class="listitem"><p>
                        Start the slave threads by issuing a
                        <a class="link" href="sql-syntax.html#start-slave" title="13.4.2.6&nbsp;START SLAVE Syntax"><code class="literal">START SLAVE</code></a> statement:
                    </p><p style="color:blue;">通过发出start slave语句启动从线程：</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>START SLAVE;</code></strong></pre><p>
                        The new slave now uses the information in its master info
                        repository to start the replication process.
                    </p><p style="color:blue;">新的从机现在使用其主信息存储库中的信息来启动复制过程。</p></li></ol>
                </div>

            </div>

        </div>
        <div class="section">
            <div class="titlepage">
                <div>
                    <div>
                        <h3 class="title"><a name="replication-gtids"></a>16.1.3&nbsp;Replication with Global Transaction Identifiers</h3>

                    </div>

                </div>

            </div>
            <div class="toc">
                <dl class="toc"><dt><span class="section"><a href="replication.html#replication-gtids-concepts">16.1.3.1 GTID Format and Storage</a></span></dt><dt><span class="section"><a href="replication.html#replication-gtids-lifecycle">16.1.3.2 GTID Life Cycle</a></span></dt><dt><span class="section"><a href="replication.html#replication-gtids-auto-positioning">16.1.3.3 GTID Auto-Positioning</a></span></dt><dt><span class="section"><a href="replication.html#replication-gtids-howto">16.1.3.4 Setting Up Replication Using GTIDs</a></span></dt><dt><span class="section"><a href="replication.html#replication-gtids-failover">16.1.3.5 Using GTIDs for Failover and Scaleout</a></span></dt><dt><span class="section"><a href="replication.html#replication-gtids-restrictions">16.1.3.6 Restrictions on Replication with GTIDs</a></span></dt><dt><span class="section"><a href="replication.html#replication-gtids-functions">16.1.3.7 Stored Function Examples to Manipulate GTIDs</a></span></dt></dl>
            </div>
            <a class="indexterm" name="idm140286801841872"></a><p>
            This section explains transaction-based replication using
            <span class="firstterm">global transaction identifiers</span>
            (GTIDs). When using GTIDs, each transaction can be identified and
            tracked as it is committed on the originating server and applied by
            any slaves; this means that it is not necessary when using GTIDs to
            refer to log files or positions within those files when starting a
            new slave or failing over to a new master, which greatly simplifies
            these tasks. Because GTID-based replication is completely
            transaction-based, it is simple to determine whether masters and
            slaves are consistent; as long as all transactions committed on a
            master are also committed on a slave, consistency between the two is
            guaranteed. You can use either statement-based or row-based
            replication with GTIDs (see <a class="xref" href="replication.html#replication-formats" title="16.2.1&nbsp;Replication Formats">Section&nbsp;16.2.1, “Replication Formats”</a>);
            however, for best results, we recommend that you use the row-based
            format.
        </p><p style="color:blue;">本节介绍使用全局事务标识符（gtid）的基于事务的复制。当使用gtid时，每个事务都可以在原始服务器上提交并由任何从服务器应用时进行标识和跟踪；这意味着当启动新的从服务器或故障转移到新的主服务器时，使用gtid引用这些文件中的日志文件或位置是不必要的，这大大简化了这些任务。因为基于gtid的复制完全基于事务，所以很容易确定主服务器和从服务器是否一致；只要主服务器上提交的所有事务也提交到从服务器上，就可以保证两者之间的一致性。您可以将基于语句或基于行的复制与gtid一起使用（请参见16.2.1节，“复制格式”）；但是，为了获得最佳结果，我们建议您使用基于行的格式。</p><p>
            GTIDs are always preserved between master and slave. This means that
            you can always determine the source for any transaction applied on
            any slave by examining its binary log. In addition, once a
            transaction with a given GTID is committed on a given server, any
            subsequent transaction having the same GTID is ignored by that
            server. Thus, a transaction committed on the master can be applied
            no more than once on the slave, which helps to guarantee
            consistency.
        </p><p style="color:blue;">GTID始终保留在主设备和从设备之间。这意味着您始终可以通过检查任何从机的二进制日志来确定应用于任何从机的任何事务的源。此外，在给定服务器上提交具有给定gtid的事务后，该服务器将忽略具有相同gtid的任何后续事务。因此，在主服务器上提交的事务只能在从服务器上应用一次，这有助于保证一致性。</p><p>
            This section discusses the following topics:
        </p><p style="color:blue;">本节讨论以下主题：</p>
            <div class="itemizedlist">
                <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                    How GTIDs are defined and created, and how they are represented
                    in a MySQL server (see
                    <a class="xref" href="replication.html#replication-gtids-concepts" title="16.1.3.1&nbsp;GTID Format and Storage">Section&nbsp;16.1.3.1, “GTID Format and Storage”</a>).
                </p><p style="color:blue;">如何定义和创建gtid，以及如何在mysql服务器中表示gtid（参见16.1.3.1节，“gtid格式和存储”）。</p></li><li class="listitem"><p>
                    The life cycle of a GTID (see
                    <a class="xref" href="replication.html#replication-gtids-lifecycle" title="16.1.3.2&nbsp;GTID Life Cycle">Section&nbsp;16.1.3.2, “GTID Life Cycle”</a>).
                </p><p style="color:blue;">GTID的生命周期（见第16.1.3.2节“GTID生命周期”）。</p></li><li class="listitem"><p>
                    The auto-positioning function for synchronizing a slave and
                    master that use GTIDs (see
                    <a class="xref" href="replication.html#replication-gtids-auto-positioning" title="16.1.3.3&nbsp;GTID Auto-Positioning">Section&nbsp;16.1.3.3, “GTID Auto-Positioning”</a>).
                </p><p style="color:blue;">用于同步使用GTID的从机和主机的自动定位功能（见第16.1.3.3节“GTID自动定位”）。</p></li><li class="listitem"><p>
                    A general procedure for setting up and starting GTID-based
                    replication (see <a class="xref" href="replication.html#replication-gtids-howto" title="16.1.3.4&nbsp;Setting Up Replication Using GTIDs">Section&nbsp;16.1.3.4, “Setting Up Replication Using GTIDs”</a>).
                </p><p style="color:blue;">设置和启动基于gtid的复制的一般过程（参见第16.1.3.4节“使用gtid设置复制”）。</p></li><li class="listitem"><p>
                    Suggested methods for provisioning new replication servers when
                    using GTIDs (see <a class="xref" href="replication.html#replication-gtids-failover" title="16.1.3.5&nbsp;Using GTIDs for Failover and Scaleout">Section&nbsp;16.1.3.5, “Using GTIDs for Failover and Scaleout”</a>).
                </p><p style="color:blue;">建议在使用gtid时配置新复制服务器的方法（请参阅16.1.3.5节，“使用gtid进行故障转移和扩展”）。</p></li><li class="listitem"><p>
                    Restrictions and limitations that you should be aware of when
                    using GTID-based replication (see
                    <a class="xref" href="replication.html#replication-gtids-restrictions" title="16.1.3.6&nbsp;Restrictions on Replication with GTIDs">Section&nbsp;16.1.3.6, “Restrictions on Replication with GTIDs”</a>).
                </p><p style="color:blue;">使用基于gtid的复制时应注意的限制和限制（请参阅第16.1.3.6节“使用gtid复制的限制”）。</p></li><li class="listitem"><p>
                    Stored functions that you can use to work with GTIDs (see
                    <a class="xref" href="replication.html#replication-gtids-functions" title="16.1.3.7&nbsp;Stored Function Examples to Manipulate GTIDs">Section&nbsp;16.1.3.7, “Stored Function Examples to Manipulate GTIDs”</a>).
                </p><p style="color:blue;">可用于处理gtid的存储函数（请参阅16.1.3.7节，“操作gtid的存储函数示例”）。</p></li></ul>
            </div>
            <p>
                For information about MySQL Server options and variables relating to
                GTID-based replication, see
                <a class="xref" href="replication.html#replication-options-gtids" title="16.1.6.5&nbsp;Global Transaction ID Options and Variables">Section&nbsp;16.1.6.5, “Global Transaction ID Options and Variables”</a>. See also
                <a class="xref" href="functions.html#gtid-functions" title="12.18&nbsp;Functions Used with Global Transaction Identifiers (GTIDs)">Section&nbsp;12.18, “Functions Used with Global Transaction Identifiers (GTIDs)”</a>, which describes SQL functions
                supported by MySQL 5.7 for use with GTIDs.
            </p><p style="color:blue;">有关与基于gtid的复制相关的mysql服务器选项和变量的信息，请参阅16.1.6.5节“全局事务id选项和变量”。另请参见12.18节，“与全局事务标识符（gtid）一起使用的函数”，其中描述了mysql 5.7支持的用于gtid的sql函数。</p>
            <div class="section">

                <div class="titlepage">
                    <div>
                        <div>
                            <h4 class="title"><a name="replication-gtids-concepts"></a>16.1.3.1&nbsp;GTID Format and Storage</h4>
                        </div>
                    </div>
                </div>
                <a class="indexterm" name="idm140286801820512"></a><p>
                A global transaction identifier (GTID) is a unique identifier
                created and associated with each transaction committed on the
                server of origin (the master). This identifier is unique not only
                to the server on which it originated, but is unique across all
                servers in a given replication topology.
            </p><p style="color:blue;">全局事务标识符（gtid）是在源服务器（主服务器）上创建并与提交的每个事务关联的唯一标识符。此标识符不仅对其发起的服务器是唯一的，而且在给定复制拓扑中的所有服务器上都是唯一的。</p><p>
                GTID assignment distinguishes between client transactions, which
                are committed on the master, and replicated transactions, which
                are reproduced on a slave. When a client transaction is committed
                on the master, it is assigned a new GTID, provided that the
                transaction was written to the binary log. Client transactions are
                guaranteed to have monotonically increasing GTIDs without gaps
                between the generated numbers. If a client transaction is not
                written to the binary log (for example, because the transaction
                was filtered out, or the transaction was read-only), it is not
                assigned a GTID on the server of origin.
            </p><p style="color:blue;">gtid分配区分在主服务器上提交的客户端事务和在从服务器上复制的复制事务。在主服务器上提交客户端事务时，将为其分配一个新的gtid，前提是该事务已写入二进制日志。客户机事务被保证具有单调递增的gtid，而生成的数字之间没有间隙。如果客户端事务未写入二进制日志（例如，因为事务已被筛选出，或者事务是只读的），则不会在源服务器上为其分配gtid。</p><p>
                Replicated transactions retain the same GTID that was assigned to
                the transaction on the server of origin. The GTID is present
                before the replicated transaction begins to execute, and is
                persisted even if the replicated transaction is not written to the
                binary log on the slave, or is filtered out on the slave. The
                MySQL system table <code class="literal">mysql.gtid_executed</code> is used
                to preserve the assigned GTIDs of all the transactions applied on
                a MySQL server, except those that are stored in a currently active
                binary log file.
            </p><p style="color:blue;">复制的事务保留分配给源服务器上事务的相同gtid。gtid在复制的事务开始执行之前存在，即使复制的事务没有写入从机上的二进制日志，或者在从机上被过滤掉，它也会被持久化。执行的mysql系统表mysql.gtid_用于保留mysql服务器上应用的所有事务的已分配gtid，但存储在当前活动的二进制日志文件中的事务除外。</p><p>
                The auto-skip function for GTIDs means that a transaction
                committed on the master can be applied no more than once on the
                slave, which helps to guarantee consistency. Once a transaction
                with a given GTID has been committed on a given server, any
                attempt to execute a subsequent transaction with the same GTID is
                ignored by that server. No error is raised, and no statement in
                the transaction is executed.
            </p><p style="color:blue;">gtids的自动跳过功能意味着在主服务器上提交的事务只能在从服务器上应用一次，这有助于保证一致性。在给定服务器上提交具有给定gtid的事务后，该服务器将忽略执行具有相同gtid的后续事务的任何尝试。不会引发错误，也不会执行事务中的语句。</p><p>
                If a transaction with a given GTID has started to execute on a
                server, but has not yet committed or rolled back, any attempt to
                start a concurrent transaction on the server with the same GTID
                will block. The server neither begins to execute the concurrent
                transaction nor returns control to the client. Once the first
                attempt at the transaction commits or rolls back, concurrent
                sessions that were blocking on the same GTID may proceed. If the
                first attempt rolled back, one concurrent session proceeds to
                attempt the transaction, and any other concurrent sessions that
                were blocking on the same GTID remain blocked. If the first
                attempt committed, all the concurrent sessions stop being blocked,
                and auto-skip all the statements of the transaction.
            </p><p style="color:blue;">如果具有给定gtid的事务已开始在服务器上执行，但尚未提交或回滚，则在具有相同gtid的服务器上启动并发事务的任何尝试都将被阻止。服务器既不开始执行并发事务，也不将控制权返回给客户端。一旦事务的第一次尝试提交或回滚，在同一gtid上阻塞的并发会话可能会继续。如果第一次尝试回滚，则一个并发会话将继续尝试事务，并且在同一gtid上阻塞的任何其他并发会话仍将被阻塞。如果提交了第一次尝试，则所有并发会话将停止被阻止，并自动跳过事务的所有语句。</p><p>
                A GTID is represented as a pair of coordinates, separated by a
                colon character (<code class="literal">:</code>), as shown here:
            </p><p style="color:blue;">gtid表示为一对坐标，用冒号（：）分隔，如下所示：</p><pre data-lang="ini" class="programlisting">GTID = <em class="replaceable"><code>source_id</code></em>:<em class="replaceable"><code>transaction_id</code></em>
</pre><p>
                The <em class="replaceable"><code>source_id</code></em> identifies the
                originating server. Normally, the master's
                <a class="link" href="replication.html#sysvar_server_uuid"><code class="literal">server_uuid</code></a> is used for this
                purpose. The <em class="replaceable"><code>transaction_id</code></em> is a
                sequence number determined by the order in which the transaction
                was committed on the master. For example, the first transaction to
                be committed has <code class="literal">1</code> as its
                <em class="replaceable"><code>transaction_id</code></em>, and the tenth
                transaction to be committed on the same originating server is
                assigned a <em class="replaceable"><code>transaction_id</code></em> of
                <code class="literal">10</code>. It is not possible for a transaction to
                have <code class="literal">0</code> as a sequence number in a GTID. For
                example, the twenty-third transaction to be committed originally
                on the server with the UUID
                <code class="literal">3E11FA47-71CA-11E1-9E33-C80AA9429562</code> has this
                GTID:
            </p><p style="color:blue;">源ID标识源服务器。通常，主服务器的id用于此目的。事务ID是由事务在主服务器上提交的顺序决定的序列号。例如，要提交的第一个事务的事务id为1，而要在同一发起服务器上提交的第十个事务的事务id为10。在gtid中，事务不能将0作为序列号。例如，最初在服务器上提交的第二十三个事务（uuid 3e11fa47-71ca-11e1-9e33-c80aa9429562）具有以下gtid：</p><pre data-lang="none" class="programlisting">3E11FA47-71CA-11E1-9E33-C80AA9429562:23
</pre><p>
                The GTID for a transaction is shown in the output from
                <a class="link" href="programs.html#mysqlbinlog" title="4.6.7&nbsp;mysqlbinlog — Utility for Processing Binary Log Files"><span class="command"><strong>mysqlbinlog</strong></span></a>, and it is used to identify an
                individual transaction in the Performance Schema replication
                status tables, for example,
                <a class="link" href="performance-schema.html#replication-applier-status-by-worker-table" title="25.12.11.6&nbsp;The replication_applier_status_by_worker Table"><code class="literal">replication_applier_status_by_worker</code></a>.
                The value stored by the <a class="link" href="replication.html#sysvar_gtid_next"><code class="literal">gtid_next</code></a>
                system variable (<code class="literal">@@GLOBAL.gtid_next</code>) is a
                single GTID.
            </p><p style="color:blue;">事务的gtid显示在mysqlbinlog的输出中，它用于标识性能架构复制状态表中的单个事务，例如replication_applier_status_by_worker。gtid_next系统变量（@@global.gtid_next）存储的值是单个gtid。</p>
                <div class="simplesect">

                    <div class="titlepage">
                        <div>

                            <div class="simple">
                                <h5 class="title"><a name="replication-gtids-concepts-gtid-sets"></a>GTID Sets</h5>
                            </div>
                        </div>
                    </div>
                    <a class="indexterm" name="idm140286801796544"></a><p>
                    A GTID set is a set comprising one or more single GTIDs or
                    ranges of GTIDs. GTID sets are used in a MySQL server in several
                    ways. For example, the values stored by the
                    <a class="link" href="replication.html#sysvar_gtid_executed"><code class="literal">gtid_executed</code></a> and
                    <a class="link" href="replication.html#sysvar_gtid_purged"><code class="literal">gtid_purged</code></a> system variables
                    are GTID sets. The <a class="link" href="sql-syntax.html#start-slave" title="13.4.2.6&nbsp;START SLAVE Syntax"><code class="literal">START SLAVE</code></a>
                    clauses <code class="literal">UNTIL SQL_BEFORE_GTIDS</code> and
                    <code class="literal">UNTIL SQL_AFTER_GTIDS</code> can be used to make a
                    slave process transactions only up to the first GTID in a GTID
                    set, or stop after the last GTID in a GTID set. The built-in
                    functions <a class="link" href="functions.html#function_gtid-subset"><code class="literal">GTID_SUBSET()</code></a> and
                    <a class="link" href="functions.html#function_gtid-subtract"><code class="literal">GTID_SUBTRACT()</code></a> require GTID sets
                    as input.
                </p><p style="color:blue;">gtid集是包含一个或多个单个gtid或gtid范围的集。gtid集在mysql服务器中有几种使用方式。例如，由执行的gtid_和清除的gtid_系统变量存储的值是gtid集。start slave子句until sql_before_gtids和until sql_after_gtids可用于仅生成gtid集中第一个gtid的从属进程事务，或在gtid集中最后一个gtid之后停止。内置函数gtid_subset（）和gtid_subtract（）需要gtid集作为输入。</p><p>
                    A range of GTIDs originating from the same server can be
                    collapsed into a single expression, as shown here:
                </p><p style="color:blue;">来自同一服务器的一系列gtid可以折叠为一个表达式，如下所示：</p><pre data-lang="none" class="programlisting">3E11FA47-71CA-11E1-9E33-C80AA9429562:1-5
</pre><p>
                    The above example represents the first through fifth
                    transactions originating on the MySQL server whose
                    <a class="link" href="replication.html#sysvar_server_uuid"><code class="literal">server_uuid</code></a> is
                    <code class="literal">3E11FA47-71CA-11E1-9E33-C80AA9429562</code>.
                    Multiple single GTIDs or ranges of GTIDs originating from the
                    same server can also be included in a single expression, with
                    the GTIDs or ranges separated by colons, as in the following
                    example:
                </p><p style="color:blue;">上面的示例表示源自mysql服务器的第一到第五个事务，该服务器的uuid为3e11fa47-71ca-11e1-9e33-c80aa9429562。源于同一服务器的多个单个gtid或gtid范围也可以包含在单个表达式中，gtid或gtid范围用冒号分隔，如下例所示：</p><pre data-lang="none" class="programlisting">3E11FA47-71CA-11E1-9E33-C80AA9429562:1-3:11:47-49
</pre><p>
                    A GTID set can include any combination of single GTIDs and
                    ranges of GTIDs, and it can include GTIDs originating from
                    different servers. This example shows the GTID set stored in the
                    <a class="link" href="replication.html#sysvar_gtid_executed"><code class="literal">gtid_executed</code></a> system variable
                    (<code class="literal">@@GLOBAL.gtid_executed</code>) of a slave that has
                    applied transactions from more than one master:
                </p><p style="color:blue;">gtid集可以包含单个gtid和gtid范围的任意组合，也可以包含来自不同服务器的gtid。此示例显示存储在已从多个主节点应用事务的从节点的gtid_executed系统变量（@@global.gtid_executed）中的gtid集：</p><pre data-lang="none" class="programlisting">2174B383-5441-11E8-B90A-C80AA9429562:1-3, 24DA167-0C0C-11E8-8442-00059A3C7B00:1-19
</pre><p>
                    When GTID sets are returned from server variables, UUIDs are in
                    alphabetical order, and numeric intervals are merged and in
                    ascending order.
                </p><p style="color:blue;">从服务器变量返回gtid集时，uuid按字母顺序排列，数字间隔按升序合并。</p><p>
                    The syntax for a GTID set is as follows:
                </p><p style="color:blue;">gtid集的语法如下：</p><pre data-lang="sql" class="programlisting"><em class="replaceable"><code>gtid_set</code></em>:
    <em class="replaceable"><code>uuid_set</code></em> [, <em class="replaceable"><code>uuid_set</code></em>] ...
    | ''

<em class="replaceable"><code>uuid_set</code></em>:
    <em class="replaceable"><code>uuid</code></em>:<em class="replaceable"><code>interval</code></em>[:<em class="replaceable"><code>interval</code></em>]...

<em class="replaceable"><code>uuid</code></em>:
    <em class="replaceable"><code>hhhhhhhh</code></em>-<em class="replaceable"><code>hhhh</code></em>-<em class="replaceable"><code>hhhh</code></em>-<em class="replaceable"><code>hhhh</code></em>-<em class="replaceable"><code>hhhhhhhhhhhh</code></em>

<em class="replaceable"><code>h</code></em>:
    [0-9|A-F]

<em class="replaceable"><code>interval</code></em>:
    <em class="replaceable"><code>n</code></em>[-<em class="replaceable"><code>n</code></em>]

    (<em class="replaceable"><code>n</code></em> &gt;= 1)
</pre>
                </div>
                <div class="simplesect">
                    <div class="titlepage">
                        <div>
                            <div class="simple">
                                <h5 class="title"><a name="replication-gtids-gtid-executed-table"></a>mysql.gtid_executed Table</h5>

                            </div>

                        </div>

                    </div>
                    <a class="indexterm" name="idm140286801766864"></a><a class="indexterm" name="idm140286801765776"></a><a class="indexterm" name="idm140286801764288"></a><a class="indexterm" name="idm140286801762800"></a><a class="indexterm" name="idm140286801761312"></a><p>
                    GTIDs are stored in a table named
                    <code class="literal">gtid_executed</code>, in the
                    <code class="literal">mysql</code> database. A row in this table contains,
                    for each GTID or set of GTIDs that it represents, the UUID of
                    the originating server, and the starting and ending transaction
                    IDs of the set; for a row referencing only a single GTID, these
                    last two values are the same.
                </p><p style="color:blue;">gtid存储在mysql数据库中名为gtid_executed的表中。此表中的行对于它所表示的每个gtid或gtid集，都包含原始服务器的uuid以及该集的开始和结束事务id；对于仅引用单个gtid的行，最后两个值是相同的。</p><p>
                    The <code class="literal">mysql.gtid_executed</code> table is created (if
                    it does not already exist) when MySQL Server is installed or
                    upgraded, using a <a class="link" href="sql-syntax.html#create-table" title="13.1.18&nbsp;CREATE TABLE Syntax"><code class="literal">CREATE TABLE</code></a>
                    statement similar to that shown here:
                </p><p style="color:blue;">当MySQL服务器安装或升级时，使用与此处所示类似的CREATETABLE语句，创建MySQL .GTIDIY执行表（如果它不存在）。</p><pre data-lang="sql" class="programlisting">CREATE TABLE gtid_executed (
    source_uuid CHAR(36) NOT NULL,
    interval_start BIGINT(20) NOT NULL,
    interval_end BIGINT(20) NOT NULL,
    PRIMARY KEY (source_uuid, interval_start)
)
</pre>
                    <div class="warning" style="margin-left: 0.5in; margin-right: 0.5in;">

                        <div class="admon-title">
                            Warning
                        </div>
                        <p>
                            As with other MySQL system tables, do not attempt to create or
                            modify this table yourself.
                        </p><p style="color:blue;">与其他mysql系统表一样，不要试图自己创建或修改此表。</p>
                    </div>
                    <a class="indexterm" name="idm140286801752144"></a><a class="indexterm" name="idm140286801750640"></a><p>
                    The <code class="literal">mysql.gtid_executed</code> table is provided for
                    internal use by the MySQL server. It enables a slave to use
                    GTIDs when binary logging is disabled on the slave, and it
                    enables retention of the GTID state when the binary logs have
                    been lost. Note that the <code class="literal">mysql.gtid_executed</code>
                    table is cleared if you issue <a class="link" href="sql-syntax.html#reset-master" title="13.4.1.2&nbsp;RESET MASTER Syntax"><code class="literal">RESET
                    MASTER</code></a>.
                </p><p style="color:blue;">gtid_executed表供mysql服务器内部使用。当从机上禁用二进制日志记录时，它允许从机使用gtid；当二进制日志丢失时，它允许保留gtid状态。注意，如果发出reset master，mysql.gtid_executed表将被清除。</p><p>
                    GTIDs are stored in the <code class="literal">mysql.gtid_executed</code>
                    table only when <a class="link" href="replication.html#sysvar_gtid_mode"><code class="literal">gtid_mode</code></a> is
                    <code class="literal">ON</code> or <code class="literal">ON_PERMISSIVE</code>. The
                    point at which GTIDs are stored depends on whether binary
                    logging is enabled or disabled:
                </p><p style="color:blue;">只有当gtid_mode为on或on_permissive时，gtid才会存储在mysql.gtid_executed表中。存储gtid的点取决于启用还是禁用二进制日志记录：</p>
                    <div class="itemizedlist">
                        <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                            If binary logging is disabled (<code class="literal">log_bin</code> is
                            <code class="literal">OFF</code>), or if
                            <a class="link" href="replication.html#sysvar_log_slave_updates"><code class="literal">log_slave_updates</code></a> is
                            disabled, the server stores the GTID belonging to each
                            transaction together with the transaction in the table. In
                            addition, the table is compressed periodically at a
                            user-configurable rate; see
                            <a class="xref" href="replication.html#replication-gtids-gtid-executed-table-compression" title="mysql.gtid_executed Table Compression">mysql.gtid_executed Table Compression</a>,
                            for more information. This situation can only apply on a
                            replication slave where binary logging or slave update
                            logging is disabled. It does not apply on a replication
                            master, because on a master, binary logging must be enabled
                            for replication to take place.
                        </p><p style="color:blue;">如果禁用了二进制日志记录（log_bin为off），或者如果禁用了log_slave_updates，则服务器将属于每个事务的gtid与该事务一起存储在表中。此外，表将以用户可配置的速率定期压缩；有关详细信息，请参阅mysql.gtid_executed table compression。这种情况只能应用于禁用二进制日志记录或从属更新日志记录的复制从属服务器。它不适用于复制主机，因为在主机上，必须启用二进制日志记录才能进行复制。</p></li><li class="listitem"><p>
                            If binary logging is enabled (<code class="literal">log_bin</code> is
                            <code class="literal">ON</code>), whenever the binary log is rotated
                            or the server is shut down, the server writes GTIDs for all
                            transactions that were written into the previous binary log
                            into the <code class="literal">mysql.gtid_executed</code> table. This
                            situation applies on a replication master, or a replication
                            slave where binary logging is enabled.
                        </p><p style="color:blue;">如果启用了二进制日志记录（log_bin处于打开状态），则每当二进制日志被旋转或服务器关闭时，服务器都会将写入上一个二进制日志的所有事务的gtid写入mysql.gtid_executed表中。这种情况适用于启用二进制日志记录的复制主机或复制从机。</p><p>
                            In the event of the server stopping unexpectedly, the set of
                            GTIDs from the current binary log file is not saved in the
                            <code class="literal">mysql.gtid_executed</code> table. These GTIDs
                            are added to the table from the binary log file during
                            recovery. The exception to this is if binary logging is not
                            enabled when the server is restarted. In this situation, the
                            server cannot access the binary log file to recover the
                            GTIDs, so replication cannot be started.
                        </p><p style="color:blue;">如果服务器意外停止，则当前二进制日志文件中的gtid集不会保存在mysql.gtid_executed表中。这些gtid在恢复期间从二进制日志文件添加到表中。如果服务器重新启动时未启用二进制日志记录，则会出现此异常。在这种情况下，服务器无法访问二进制日志文件来恢复gtid，因此无法启动复制。</p><p>
                            When binary logging is enabled, the
                            <code class="literal">mysql.gtid_executed</code> table does not hold a
                            complete record of the GTIDs for all executed transactions.
                            That information is provided by the global value of the
                            <a class="link" href="replication.html#sysvar_gtid_executed"><code class="literal">gtid_executed</code></a> system
                            variable. Always use
                            <code class="literal">@@GLOBAL.gtid_executed</code>, which is updated
                            after every commit, to represent the GTID state for the
                            MySQL server, and do not query the
                            <code class="literal">mysql.gtid_executed</code> table.
                        </p><p style="color:blue;">启用二进制日志记录后，mysql.gtid_executed表不会保存所有已执行事务的gtid的完整记录。该信息由gtid_executed系统变量的全局值提供。始终使用每次提交后更新的@global.gtid_executed来表示mysql服务器的gtid状态，并且不要查询mysql.gtid_executed表。</p></li></ul>
                    </div>

                </div>
                <div class="simplesect">
                    <div class="titlepage">
                        <div>
                            <div class="simple">
                                <h5 class="title"><a name="replication-gtids-gtid-executed-table-compression"></a>mysql.gtid_executed Table Compression</h5>

                            </div>

                        </div>

                    </div>
                    <a class="indexterm" name="idm140286801726064"></a><p>
                    Over the course of time, the
                    <code class="literal">mysql.gtid_executed</code> table can become filled
                    with many rows referring to individual GTIDs that originate on
                    the same server, and whose transaction IDs make up a range,
                    similar to what is shown here:
                </p><p style="color:blue;">经过一段时间后，mysql.gtid戡executed表中可能会填充许多行，这些行引用源自同一服务器的各个gtid，并且其事务id构成一个范围，类似于此处所示：</p><pre data-lang="sql" class="programlisting">+--------------------------------------+----------------+--------------+
| source_uuid                          | interval_start | interval_end |
|--------------------------------------+----------------+--------------|
| 3E11FA47-71CA-11E1-9E33-C80AA9429562 | 37             | 37           |
| 3E11FA47-71CA-11E1-9E33-C80AA9429562 | 38             | 38           |
| 3E11FA47-71CA-11E1-9E33-C80AA9429562 | 39             | 39           |
| 3E11FA47-71CA-11E1-9E33-C80AA9429562 | 40             | 40           |
| 3E11FA47-71CA-11E1-9E33-C80AA9429562 | 41             | 41           |
| 3E11FA47-71CA-11E1-9E33-C80AA9429562 | 42             | 42           |
| 3E11FA47-71CA-11E1-9E33-C80AA9429562 | 43             | 43           |
...
</pre><p>
                    To save space, the MySQL server compresses the
                    <code class="literal">mysql.gtid_executed</code> table periodically by
                    replacing each such set of rows with a single row that spans the
                    entire interval of transaction identifiers, like this:
                </p><p style="color:blue;">为了节省空间，mysql服务器定期压缩mysql.gtid_executed表，方法是用跨整个事务标识符间隔的一行替换每一组这样的行，如下所示：</p><pre data-lang="none" class="programlisting">+--------------------------------------+----------------+--------------+
| source_uuid                          | interval_start | interval_end |
|--------------------------------------+----------------+--------------|
| 3E11FA47-71CA-11E1-9E33-C80AA9429562 | 37             | 43           |
...
</pre><p>
                    You can control the number of transactions that are allowed to
                    elapse before the table is compressed, and thus the compression
                    rate, by setting the
                    <a class="link" href="replication.html#sysvar_gtid_executed_compression_period"><code class="literal">gtid_executed_compression_period</code></a>
                    system variable. This variable's default value is 1000,
                    meaning that by default, compression of the table is performed
                    after each 1000 transactions. Setting
                    <a class="link" href="replication.html#sysvar_gtid_executed_compression_period"><code class="literal">gtid_executed_compression_period</code></a>
                    to 0 prevents the compression from being performed at all, and
                    you should be prepared for a potentially large increase in the
                    amount of disk space that may be required by the
                    <code class="literal">gtid_executed</code> table if you do this.
                </p><p style="color:blue;">通过设置gtid_executed_compression_period系统变量，可以控制表被压缩之前允许经过的事务数，从而控制压缩率。这个变量的默认值是1000，这意味着在默认情况下，表的压缩是在每1000个事务之后执行的。如果将gtid_executed_compression_period设置为0，则根本无法执行压缩，并且您应该做好准备，以应对gtid_executed表可能需要的磁盘空间量可能会大幅增加。</p>
                    <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">

                        <div class="admon-title">
                            Note
                        </div>
                        <p>
                            When binary logging is enabled, the value of
                            <a class="link" href="replication.html#sysvar_gtid_executed_compression_period"><code class="literal">gtid_executed_compression_period</code></a>
                            is <span class="emphasis"><em>not</em></span> used and the
                            <code class="literal">mysql.gtid_executed</code> table is compressed on
                            each binary log rotation.
                        </p><p style="color:blue;">启用二进制日志记录时，不使用gtid_executed_compression_period的值，并在每次二进制日志旋转时压缩mysql.gtid_executed表。</p>
                    </div>
                    <a class="indexterm" name="idm140286801711472"></a><a class="indexterm" name="idm140286801710384"></a><a class="indexterm" name="idm140286801708864"></a><p>
                    Compression of the <code class="literal">mysql.gtid_executed</code> table
                    is performed by a dedicated foreground thread named
                    <code class="literal">thread/sql/compress_gtid_table</code>. This thread
                    is not listed in the output of <a class="link" href="sql-syntax.html#show-processlist" title="13.7.5.29&nbsp;SHOW PROCESSLIST Syntax"><code class="literal">SHOW
                    PROCESSLIST</code></a>, but it can be viewed as a row in the
                    <a class="link" href="performance-schema.html#threads-table" title="25.12.16.3&nbsp;The threads Table"><code class="literal">threads</code></a> table, as shown here:
                </p><p style="color:blue;">mysql.gtid_executed表的压缩由一个名为thread/sql/compress_gtid_table的专用前台线程执行。此线程未列在show processlist的输出中，但可以在threads表中将其视为一行，如下所示：</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT * FROM performance_schema.threads WHERE NAME LIKE '%gtid%'\G</code></strong>
*************************** 1. row ***************************
          THREAD_ID: 26
               NAME: thread/sql/compress_gtid_table
               TYPE: FOREGROUND
     PROCESSLIST_ID: 1
   PROCESSLIST_USER: NULL
   PROCESSLIST_HOST: NULL
     PROCESSLIST_DB: NULL
PROCESSLIST_COMMAND: Daemon
   PROCESSLIST_TIME: 1509
  PROCESSLIST_STATE: Suspending
   PROCESSLIST_INFO: NULL
   PARENT_THREAD_ID: 1
               ROLE: NULL
       INSTRUMENTED: YES
            HISTORY: YES
    CONNECTION_TYPE: NULL
       THREAD_OS_ID: 18677
</pre><p>
                    The <code class="literal">thread/sql/compress_gtid_table</code> thread
                    normally sleeps until
                    <a class="link" href="replication.html#sysvar_gtid_executed_compression_period"><code class="literal">gtid_executed_compression_period</code></a>
                    transactions have been executed, then wakes up to perform
                    compression of the <code class="literal">mysql.gtid_executed</code> table
                    as described previously. It then sleeps until another
                    <a class="link" href="replication.html#sysvar_gtid_executed_compression_period"><code class="literal">gtid_executed_compression_period</code></a>
                    transactions have taken place, then wakes up to perform the
                    compression again, repeating this loop indefinitely. Setting
                    this value to 0 when binary logging is disabled means that the
                    thread always sleeps and never wakes up.
                </p><p style="color:blue;">thread/sql/compress_gtid_table线程通常在执行gtid_executed_compression_period事务之前休眠，然后唤醒以执行mysql.gtid_executed table的压缩，如前所述。然后它会一直休眠，直到发生另一个gtid_executed_compression_period事务，然后醒来再次执行压缩，无限期地重复此循环。当禁用二进制日志记录时，将此值设置为0意味着线程始终处于休眠状态且从不唤醒。</p>
                </div>

            </div>
            <div class="section">
                <div class="titlepage">
                    <div>
                        <div>
                            <h4 class="title"><a name="replication-gtids-lifecycle"></a>16.1.3.2&nbsp;GTID Life Cycle</h4>

                        </div>

                    </div>

                </div>
                <a class="indexterm" name="idm140286801694288"></a><p>
                The life cycle of a GTID consists of the following steps:
            </p><p style="color:blue;">gtid的生命周期包括以下步骤：</p>
                <div class="orderedlist">
                    <ol class="orderedlist" type="1"><li class="listitem"><p>
                        A transaction is executed and committed on the master. This
                        client transaction is assigned a GTID composed of the master's
                        UUID and the smallest nonzero transaction sequence number not
                        yet used on this server. The GTID is written to the master's
                        binary log (immediately preceding the transaction itself in
                        the log). If a client transaction is not written to the binary
                        log (for example, because the transaction was filtered out, or
                        the transaction was read-only), it is not assigned a GTID.
                    </p><p style="color:blue;">事务在主机上执行和提交。此客户端事务被分配一个gtid，该gtid由主机的uuid和此服务器上尚未使用的最小非零事务序列号组成。gtid被写入主机的二进制日志（紧跟在日志中事务本身之前）。如果客户端事务未写入二进制日志（例如，因为事务已被筛选出，或者事务是只读的），则不会为其分配gtid。</p></li><li class="listitem"><p>
                        If a GTID was assigned for the transaction, the GTID is
                        persisted atomically at commit time by writing it to the
                        binary log at the beginning of the transaction (as a
                        <code class="literal">Gtid_log_event</code>). Whenever the binary log is
                        rotated or the server is shut down, the server writes GTIDs
                        for all transactions that were written into the previous
                        binary log file into the
                        <code class="literal">mysql.gtid_executed</code> table.
                    </p><p style="color:blue;">如果为事务分配了gtid，则在提交时通过将gtid写入事务开始时的二进制日志（作为gtid_log_事件）原子地持久化gtid。每当二进制日志被轮换或服务器关闭时，服务器会将写入上一个二进制日志文件的所有事务的gtid写入mysql.gtid_executed表中。</p></li><li class="listitem"><p>
                        If a GTID was assigned for the transaction, the GTID is
                        externalized non-atomically (very shortly after the
                        transaction is committed) by adding it to the set of GTIDs in
                        the <a class="link" href="replication.html#sysvar_gtid_executed"><code class="literal">gtid_executed</code></a> system
                        variable (<code class="literal">@@GLOBAL.gtid_executed</code>). This
                        GTID set contains a representation of the set of all committed
                        GTID transactions, and it is used in replication as a token
                        that represents the server state. With binary logging enabled
                        (as required for the master), the set of GTIDs in the
                        <a class="link" href="replication.html#sysvar_gtid_executed"><code class="literal">gtid_executed</code></a> system variable
                        is a complete record of the transactions applied, but the
                        <code class="literal">mysql.gtid_executed</code> table is not, because
                        the most recent history is still in the current binary log
                        file.
                    </p><p style="color:blue;">如果为事务分配了gtid，则通过将gtid添加到gtid_executed系统变量（@global.gtid_executed）中的gtid集合中，可以非原子地（在提交事务后很快）外部化gtid。此gtid集包含所有提交的gtid事务集的表示形式，在复制中用作表示服务器状态的令牌。在启用二进制日志记录的情况下（根据主文件的要求），gtid_executed系统变量中的gtid集合是应用的事务的完整记录，但mysql.gtid_executed表不是，因为最新的历史记录仍在当前二进制日志文件中。</p></li><li class="listitem"><p>
                        After the binary log data is transmitted to the slave and
                        stored in the slave's relay log (using established
                        mechanisms for this process, see
                        <a class="xref" href="replication.html#replication-implementation" title="16.2&nbsp;Replication Implementation">Section&nbsp;16.2, “Replication Implementation”</a>, for details),
                        the slave reads the GTID and sets the value of its
                        <a class="link" href="replication.html#sysvar_gtid_next"><code class="literal">gtid_next</code></a> system variable as
                        this GTID. This tells the slave that the next transaction must
                        be logged using this GTID. It is important to note that the
                        slave sets <code class="literal">gtid_next</code> in a session context.
                    </p><p style="color:blue;">二进制日志数据传输到从机并存储在从机的中继日志中（使用此过程的既定机制，请参阅第16.2节“复制实现”了解详细信息）之后，从机读取gtid并将其gtid_next系统变量的值设置为此gtid。这告诉从机必须使用这个gtid记录下一个事务。需要注意的是，slave在会话上下文中设置gtid_next。</p></li><li class="listitem"><p>
                        The slave verifies that no thread has yet taken ownership of
                        the GTID in <a class="link" href="replication.html#sysvar_gtid_next"><code class="literal">gtid_next</code></a> in
                        order to process the transaction. By reading and checking the
                        replicated transaction's GTID first, before processing the
                        transaction itself, the slave guarantees not only that no
                        previous transaction having this GTID has been applied on the
                        slave, but also that no other session has already read this
                        GTID but has not yet committed the associated transaction. So
                        if multiple clients attempt to apply the same transaction
                        concurrently, the server resolves this by letting only one of
                        them execute. The <a class="link" href="replication.html#sysvar_gtid_owned"><code class="literal">gtid_owned</code></a>
                        system variable (<code class="literal">@@GLOBAL.gtid_owned</code>) for
                        the slave shows each GTID that is currently in use and the ID
                        of the thread that owns it. If the GTID has already been used,
                        no error is raised, and the auto-skip function is used to
                        ignore the transaction.
                    </p><p style="color:blue;">从机验证没有线程为了处理事务而获得gtid_next中gtid的所有权。通过首先读取和检查复制事务的gtid，在处理事务本身之前，从服务器不仅保证以前没有在从服务器上应用具有此gtid的事务，而且还保证没有其他会话已读取此gtid但尚未提交关联事务。因此，如果多个客户机试图同时应用同一事务，服务器只允许其中一个执行来解决这个问题。从机的gtid_owned系统变量（@@global.gtid_owned）显示当前正在使用的每个gtid以及拥有它的线程的id。如果已经使用了gtid，则不会引发错误，并且使用自动跳过功能忽略事务。</p></li><li class="listitem"><p>
                        If the GTID has not been used, the slave applies the
                        replicated transaction. Because
                        <a class="link" href="replication.html#sysvar_gtid_next"><code class="literal">gtid_next</code></a> is set to the GTID
                        already assigned by the master, the slave does not attempt to
                        generate a new GTID for this transaction, but instead uses the
                        GTID stored in <a class="link" href="replication.html#sysvar_gtid_next"><code class="literal">gtid_next</code></a>.
                    </p><p style="color:blue;">如果尚未使用gtid，则从机应用复制的事务。因为gtid_next设置为主节点已经分配的gtid，所以从节点不尝试为此事务生成新的gtid，而是使用存储在gtid_next中的gtid。</p></li><li class="listitem"><p>
                        If binary logging is enabled on the slave, the GTID is
                        persisted atomically at commit time by writing it to the
                        binary log at the beginning of the transaction (as a
                        <code class="literal">Gtid_log_event</code>). Whenever the binary log is
                        rotated or the server is shut down, the server writes GTIDs
                        for all transactions that were written into the previous
                        binary log file into the
                        <code class="literal">mysql.gtid_executed</code> table.
                    </p><p style="color:blue;">如果在从机上启用了二进制日志记录，则在提交时通过在事务开始时将gtid写入二进制日志（作为gtid_log_事件）以原子方式持久化gtid。每当二进制日志被轮换或服务器关闭时，服务器会将写入上一个二进制日志文件的所有事务的gtid写入mysql.gtid_executed表中。</p></li><li class="listitem"><p>
                        If binary logging is disabled on the slave, the GTID is
                        persisted atomically by writing it directly into the
                        <code class="literal">mysql.gtid_executed</code> table. MySQL appends a
                        statement to the transaction to insert the GTID into the
                        table. In this situation, the
                        <code class="literal">mysql.gtid_executed</code> table is a complete
                        record of the transactions applied on the slave. Note that in
                        MySQL 5.7, the operation to insert the GTID into the table is
                        atomic for DML statements, but not for DDL statements, so if
                        the server exits unexpectedly after a transaction involving
                        DDL statements, the GTID state might become inconsistent. From
                        MySQL 8.0, the operation is atomic for DDL statements as well
                        as for DML statements.
                    </p><p style="color:blue;">如果从机上禁用了二进制日志记录，则通过将gtid直接写入mysql.gtid_executed表，以原子方式持久化gtid。mysql向事务追加一条语句，将gtid插入表中。在这种情况下，mysql.gtid_executed表是应用于从机的事务的完整记录。请注意，在MySQL 5.7中，将GTID插入到表中的操作对于DML语句是原子的，而不是DDL语句的，因此，如果服务器在涉及DDL语句的事务之后意外地退出，则GTID状态可能会变得不一致。在mysql 8.0中，该操作是ddl语句和dml语句的原子操作。</p></li><li class="listitem"><p>
                        Very shortly after the replicated transaction is committed on
                        the slave, the GTID is externalized non-atomically by adding
                        it to the set of GTIDs in the
                        <a class="link" href="replication.html#sysvar_gtid_executed"><code class="literal">gtid_executed</code></a> system variable
                        (<code class="literal">@@GLOBAL.gtid_executed</code>) for the slave. As
                        for the master, this GTID set contains a representation of the
                        set of all committed GTID transactions. If binary logging is
                        disabled on the slave, the
                        <code class="literal">mysql.gtid_executed</code> table is also a
                        complete record of the transactions applied on the slave. If
                        binary logging is enabled on the slave, meaning that some
                        GTIDs are only recorded in the binary log, the set of GTIDs in
                        the <a class="link" href="replication.html#sysvar_gtid_executed"><code class="literal">gtid_executed</code></a> system
                        variable is the only complete record.
                    </p><p style="color:blue;">在从机上提交复制事务后不久，gtid就被非原子地外部化，方法是将其添加到从机的gtid_executed系统变量（@@global.gtid_executed）中的gtid集合中。至于master，这个gtid集包含所有提交的gtid事务集的表示。如果在从机上禁用了二进制日志记录，那么mysql.gtid_executed表也是应用于从机上的事务的完整记录。如果在从系统上启用了二进制日志记录，这意味着某些gtid只记录在二进制日志中，则gtid_executed系统变量中的gtid集合是唯一完整的记录。</p></li></ol>
                </div>
                <p>
                    Client transactions that are completely filtered out on the master
                    are not assigned a GTID, therefore they are not added to the set
                    of transactions in the
                    <a class="link" href="replication.html#sysvar_gtid_executed"><code class="literal">gtid_executed</code></a> system variable, or
                    added to the <code class="literal">mysql.gtid_executed</code> table.
                    However, the GTIDs of replicated transactions that are completely
                    filtered out on the slave are persisted. If binary logging is
                    enabled on the slave, the filtered-out transaction is written to
                    the binary log as a <code class="literal">Gtid_log_event</code> followed by
                    an empty transaction containing only <code class="literal">BEGIN</code> and
                    <code class="literal">COMMIT</code> statements. If binary logging is
                    disabled, the GTID of the filtered-out transaction is written to
                    the <code class="literal">mysql.gtid_executed</code> table. Preserving the
                    GTIDs for filtered-out transactions ensures that the
                    <code class="literal">mysql.gtid_executed</code> table and the set of GTIDs
                    in the <a class="link" href="replication.html#sysvar_gtid_executed"><code class="literal">gtid_executed</code></a> system
                    variable can be compressed. It also ensures that the filtered-out
                    transactions are not retrieved again if the slave reconnects to
                    the master, as explained in
                    <a class="xref" href="replication.html#replication-gtids-auto-positioning" title="16.1.3.3&nbsp;GTID Auto-Positioning">Section&nbsp;16.1.3.3, “GTID Auto-Positioning”</a>.
                </p><p style="color:blue;">在master上完全过滤掉的客户机事务没有分配gtid，因此它们不会添加到gtid_executed系统变量中的事务集，也不会添加到mysql.gtid_executed表中。但是，在从机上完全过滤掉的复制事务的gtid将被持久化。如果在从机上启用了二进制日志记录，则筛选出的事务将作为gtid_log_事件写入二进制日志，然后是只包含begin和commit语句的空事务。如果禁用二进制日志记录，则筛选出的事务的gtid将写入mysql.gtid_executed表。保留筛选出的事务的gtid可以确保可以压缩mysql.gtid_executed表和gtid_executed系统变量中的gtid集。它还确保，如果从机重新连接到主机，则不会再次检索筛选出的事务，如第16.1.3.3节“GTID自动定位”中所述。</p><p>
                On a multithreaded replication slave (with
                <a class="link" href="replication.html#sysvar_slave_parallel_workers"><code class="literal">slave_parallel_workers &gt; 0</code></a> ),
                transactions can be applied in parallel, so replicated
                transactions can commit out of order (unless
                <a class="link" href="replication.html#sysvar_slave_preserve_commit_order"><code class="literal">slave_preserve_commit_order=1</code></a> is
                set). When that happens, the set of GTIDs in the
                <a class="link" href="replication.html#sysvar_gtid_executed"><code class="literal">gtid_executed</code></a> system variable
                will contain multiple GTID ranges with gaps between them. (On a
                master or a single-threaded replication slave, there will be
                monotonically increasing GTIDs without gaps between the numbers.)
                Gaps on multithreaded replication slaves only occur among the most
                recently applied transactions, and are filled in as replication
                progresses. When replication threads are stopped cleanly using the
                <a class="link" href="sql-syntax.html#stop-slave" title="13.4.2.7&nbsp;STOP SLAVE Syntax"><code class="literal">STOP SLAVE</code></a> statement, ongoing
                transactions are applied so that the gaps are filled in. In the
                event of a shutdown such as a server failure or the use of the
                <a class="link" href="sql-syntax.html#kill" title="13.7.6.4&nbsp;KILL Syntax"><code class="literal">KILL</code></a> statement to stop replication
                threads, the gaps might remain.
            </p><p style="color:blue;">在多线程复制从机（slave_parallel_workers&gt;0）上，可以并行应用事务，因此复制的事务可以无序提交（除非设置了slave_preserve_commit_order=1）。发生这种情况时，gtid_executed系统变量中的gtid集合将包含多个gtid范围，它们之间存在间隙。（在主复制或单线程复制从复制上，GTID将单调增加，但数字之间没有间隙。）多线程复制从复制上的间隙仅在最近应用的事务中出现，并在复制过程中填充。当使用stop slave语句完全停止复制线程时，将应用正在进行的事务，以便填补空白。在服务器故障或使用kill语句停止复制线程之类的关机事件中，间隙可能仍然存在。</p>
                <div class="simplesect">

                    <div class="titlepage">
                        <div>

                            <div class="simple">
                                <h5 class="title"><a name="replication-gtids-assign"></a>What changes are assigned a GTID?</h5>
                            </div>
                        </div>
                    </div>
                    <p>
                        The typical scenario is that the server generates a new GTID for
                        a committed transaction. However, GTIDs can also be assigned to
                        other changes besides transactions, and in some cases a single
                        transaction can be assigned multiple GTIDs.
                    </p><p style="color:blue;">典型的场景是服务器为提交的事务生成一个新的gtid。但是，除了事务之外，还可以将gtid分配给其他更改，在某些情况下，一个事务可以分配给多个gtid。</p><p>
                    Every database change (DDL or DML) that is written to the binary
                    log is assigned a GTID. This includes changes that are
                    autocommitted, and changes that are committed using
                    <code class="literal">BEGIN</code> and <code class="literal">COMMIT</code> or
                    <code class="literal">START TRANSACTION</code> statements. A GTID is also
                    assigned to the creation, alteration, or deletion of a database,
                    and of a non-table database object such as a procedure,
                    function, trigger, event, view, user, role, or grant.
                </p><p style="color:blue;">写入二进制日志的每个数据库更改（ddl或dml）都被分配一个gtid。这包括自动提交的更改，以及使用begin和commit或start transaction语句提交的更改。gtid还分配给创建、更改或删除数据库以及非表数据库对象（如过程、函数、触发器、事件、视图、用户、角色或授予）。</p><p>
                    Non-transactional updates as well as transactional updates are
                    assigned GTIDs. In addition, for a non-transactional update, if
                    a disk write failure occurs while attempting to write to the
                    binary log cache and a gap is therefore created in the binary
                    log, the resulting incident log event is assigned a GTID.
                </p><p style="color:blue;">为非事务性更新和事务性更新分配gtid。此外，对于非事务性更新，如果在尝试写入二进制日志缓存时发生磁盘写入故障，并因此在二进制日志中创建了一个间隙，则会为生成的事件日志事件分配一个gtid。</p><p>
                    When a table is automatically dropped by a generated statement
                    in the binary log, a GTID is assigned to the statement.
                    Temporary tables are dropped automatically when a replication
                    slave begins to apply events from a master that has just been
                    started, and when statement-based replication is in use
                    (<a class="link" href="replication.html#sysvar_binlog_format"><code class="literal">binlog_format=STATEMENT</code></a>) and a
                    user session that has open temporary tables disconnects. Tables
                    that use the <a class="link" href="storage-engines.html#memory-storage-engine" title="15.3&nbsp;The MEMORY Storage Engine"><code class="literal">MEMORY</code></a> storage engine
                    are deleted automatically the first time they are accessed after
                    the server is started, because rows might have been lost during
                    the shutdown.
                </p><p style="color:blue;">当二进制日志中生成的语句自动删除表时，将为该语句分配一个gtid。当复制从机开始从刚刚启动的主机应用事件，并且正在使用基于语句的复制（binlog_format=statement）并且打开了临时表的用户会话断开连接时，临时表将自动删除。使用内存存储引擎的表在服务器启动后第一次访问时会自动删除，因为行可能在关闭期间丢失。</p><p>
                    When a transaction is not written to the binary log on the
                    server of origin, the server does not assign a GTID to it. This
                    includes transactions that are rolled back and transactions that
                    are executed while binary logging is disabled on the server of
                    origin, either globally (with <code class="literal">--skip-log-bin</code>
                    specified in the server's configuration) or for the session
                    (<code class="literal">SET @@SESSION.sql_log_bin = 0</code>). This also
                    includes no-op transactions when row-based replication is in use
                    (<a class="link" href="replication.html#sysvar_binlog_format"><code class="literal">binlog_format=ROW</code></a>).
                </p><p style="color:blue;">当事务未写入源服务器上的二进制日志时，服务器不会为其分配gtid。这包括回滚的事务和在源服务器上禁用二进制日志记录时执行的事务，可以是全局的（在服务器配置中指定--skip log bin），也可以是会话的（set@@session.sql_log_bin=0）。当使用基于行的复制时（binlog_format=row），这还包括无操作事务。</p><p>
                    XA transactions are assigned separate GTIDs for the <code class="literal">XA
                    PREPARE</code> phase of the transaction and the <code class="literal">XA
                    COMMIT</code> or <code class="literal">XA ROLLBACK</code> phase of the
                    transaction. XA transactions are persistently prepared so that
                    users can commit them or roll them back in the case of a failure
                    (which in a replication topology might include a failover to
                    another server). The two parts of the transaction are therefore
                    replicated separately, so they must have their own GTIDs, even
                    though a non-XA transaction that is rolled back would not have a
                    GTID.
                </p><p style="color:blue;">XA事务被分配用于事务的XA准备阶段和事务的XA提交或XA回滚阶段的单独GTID。xa事务是持久准备的，这样用户可以在发生故障时提交或回滚它们（在复制拓扑中，可能包括到另一个服务器的故障转移）。因此，事务的两部分是分别复制的，因此它们必须有自己的gtid，即使回滚的非xa事务没有gtid。</p><p>
                    In the following special cases, a single statement can generate
                    multiple transactions, and therefore be assigned multiple GTIDs:
                </p><p style="color:blue;">在以下特殊情况下，单个语句可以生成多个事务，因此可以分配多个gtid：</p>
                    <div class="itemizedlist">
                        <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                            A stored procedure is invoked that commits multiple
                            transactions. One GTID is generated for each transaction
                            that the procedure commits.
                        </p><p style="color:blue;">调用提交多个事务的存储过程。为过程提交的每个事务生成一个gtid。</p></li><li class="listitem"><p>
                            A multi-table <a class="link" href="sql-syntax.html#drop-table" title="13.1.29&nbsp;DROP TABLE Syntax"><code class="literal">DROP TABLE</code></a>
                            statement drops tables of different types.
                        </p><p style="color:blue;">多表DROP TABLE语句删除不同类型的表。</p></li><li class="listitem"><p>
                            A
                            <a class="link" href="sql-syntax.html#create-table-select" title="13.1.18.5&nbsp;CREATE TABLE ... SELECT Syntax"><code class="literal">CREATE
                                TABLE ... SELECT</code></a> statement is issued when
                            row-based replication is in use
                            (<a class="link" href="replication.html#sysvar_binlog_format"><code class="literal">binlog_format=ROW</code></a>). One
                            GTID is generated for the <a class="link" href="sql-syntax.html#create-table" title="13.1.18&nbsp;CREATE TABLE Syntax"><code class="literal">CREATE
                            TABLE</code></a> action and one GTID is generated for the
                            row-insert actions.
                        </p><p style="color:blue;">创建表…当使用基于行的复制时发出select语句（binlog_format=row）。为create table操作生成一个gtid，为row insert操作生成一个gtid。</p></li></ul>
                    </div>

                </div>
                <div class="simplesect">
                    <div class="titlepage">
                        <div>
                            <div class="simple">
                                <h5 class="title"><a name="replication-gtids-gtid-next"></a>The <code class="literal">gtid_next</code> System Variable</h5>

                            </div>

                        </div>

                    </div>
                    <p>
                        By default, for new transactions committed in user sessions, the
                        server automatically generates and assigns a new GTID. When the
                        transaction is applied on a replication slave, the GTID from the
                        server of origin is preserved. You can change this behavior by
                        setting the session value of the
                        <a class="link" href="replication.html#sysvar_gtid_next"><code class="literal">gtid_next</code></a> system variable:
                    </p><p style="color:blue;">默认情况下，对于在用户会话中提交的新事务，服务器会自动生成并分配新的gtid。当事务应用于复制从属服务器时，将保留来自原始服务器的gtid。可以通过设置gtid_next系统变量的会话值来更改此行为：</p>
                    <div class="itemizedlist">
                        <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                            When <a class="link" href="replication.html#sysvar_gtid_next"><code class="literal">gtid_next</code></a> is set to
                            <code class="literal">AUTOMATIC</code>, which is the default, and a
                            transaction is committed and written to the binary log, the
                            server automatically generates and assigns a new GTID. If a
                            transaction is rolled back or not written to the binary log
                            for another reason, the server does not generate and assign
                            a GTID.
                        </p><p style="color:blue;">当gtid_u next设置为automatic（这是默认设置）并且事务被提交并写入二进制日志时，服务器自动生成并分配一个新的gtid。如果事务由于其他原因回滚或未写入二进制日志，则服务器不会生成和分配gtid。</p></li><li class="listitem"><p>
                            If you set <a class="link" href="replication.html#sysvar_gtid_next"><code class="literal">gtid_next</code></a> to a
                            valid GTID (consisting of a UUID and a transaction sequence
                            number, separated by a colon), the server assigns that GTID
                            to your transaction. This GTID is assigned and added to
                            <a class="link" href="replication.html#sysvar_gtid_executed"><code class="literal">gtid_executed</code></a> even when the
                            transaction is not written to the binary log, or when the
                            transaction is empty.
                        </p><p style="color:blue;">如果在有效的gtid（由uuid和事务序列号组成，用冒号分隔）旁边设置gtid，服务器会将该gtid分配给您的事务。即使事务未写入二进制日志或事务为空，也会将此gtid分配并添加到执行的gtid。</p></li></ul>
                    </div>
                    <p>
                        Note that after you set
                        <a class="link" href="replication.html#sysvar_gtid_next"><code class="literal">gtid_next</code></a> to a specific GTID,
                        and the transaction has been committed or rolled back, an
                        explicit <code class="literal">SET @@SESSION.gtid_next</code> statement
                        must be issued before any other statement. You can use this to
                        set the GTID value back to <code class="literal">AUTOMATIC</code> if you
                        do not want to assign any more GTIDs explicitly.
                    </p><p style="color:blue;">请注意，在将gtid设置为特定gtid旁边，并且事务已提交或回滚之后，必须在任何其他语句之前发出显式的set@@session.gtid\u next语句。如果不想显式分配更多的gtid，可以使用此选项将gtid值设置回automatic。</p><p>
                    When replication applier threads apply replicated transactions,
                    they use this technique, setting
                    <code class="literal">@@SESSION.gtid_next</code> explicitly to the GTID of
                    the replicated transaction as assigned on the server of origin.
                    This means the GTID from the server of origin is retained,
                    rather than a new GTID being generated and assigned by the
                    replication slave. It also means the GTID is added to
                    <a class="link" href="replication.html#sysvar_gtid_executed"><code class="literal">gtid_executed</code></a> on the
                    replication slave even when binary logging or slave update
                    logging is disabled on the slave, or when the transaction is a
                    no-op or is filtered out on the slave.
                </p><p style="color:blue;">当复制applier线程应用复制事务时，它们使用此技术，将@@session.gtid_显式地设置在源服务器上分配的复制事务的gtid旁边。这意味着保留来自源服务器的gtid，而不是由复制从属服务器生成和分配新的gtid。这也意味着gtid被添加到在复制从机上执行的gtid中，即使在从机上禁用了二进制日志记录或从机更新日志记录，或者当事务是no op或在从机上被过滤掉时也是如此。</p><p>
                    It is possible for a client to simulate a replicated transaction
                    by setting <code class="literal">@@SESSION.gtid_next</code> to a specific
                    GTID before executing the transaction. This technique is used by
                    <a class="link" href="programs.html#mysqlbinlog" title="4.6.7&nbsp;mysqlbinlog — Utility for Processing Binary Log Files"><span class="command"><strong>mysqlbinlog</strong></span></a> to generate a dump of the binary
                    log that the client can replay to preserve GTIDs. A simulated
                    replicated transaction committed through a client is completely
                    equivalent to a replicated transaction committed through a
                    replication applier thread, and they cannot be distinguished
                    after the fact.
                </p><p style="color:blue;">在执行事务之前，客户端可以通过在特定gtid旁边设置@@session.gtid来模拟复制的事务。mysqlbinlog使用此技术生成二进制日志的转储，客户端可以重播以保留gtid。通过客户端提交的模拟复制事务完全等同于通过复制applier线程提交的复制事务，并且在事后无法区分它们。</p>
                </div>
                <div class="simplesect">
                    <div class="titlepage">
                        <div>
                            <div class="simple">
                                <h5 class="title"><a name="replication-gtids-gtid-purged"></a>The <code class="literal">gtid_purged</code> System Variable</h5>

                            </div>

                        </div>

                    </div>
                    <a class="indexterm" name="idm140286801595776"></a><a class="indexterm" name="idm140286801594288"></a><p>
                    The set of GTIDs in the
                    <a class="link" href="replication.html#sysvar_gtid_purged"><code class="literal">gtid_purged</code></a> system variable
                    (<code class="literal">@@GLOBAL.gtid_purged</code>) contains the GTIDs of
                    all the transactions that have been committed on the server, but
                    do not exist in any binary log file on the server.
                    <a class="link" href="replication.html#sysvar_gtid_purged"><code class="literal">gtid_purged</code></a> is a subset of
                    <a class="link" href="replication.html#sysvar_gtid_executed"><code class="literal">gtid_executed</code></a>. The following
                    categories of GTIDs are in
                    <a class="link" href="replication.html#sysvar_gtid_purged"><code class="literal">gtid_purged</code></a>:
                </p><p style="color:blue;">GTIDIAUPURAGE系统变量中的GTIDS集合（@ @ Gualal.GTIDIPUPED）包含服务器上提交的所有事务的GTIDs，但不存在于服务器上的任何二进制日志文件中。清除的gtid是执行的gtid的子集。清除的GTID中包含以下类别的GTID：</p>
                    <div class="itemizedlist">
                        <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                            GTIDs of replicated transactions that were committed with
                            binary logging disabled on the slave.
                        </p><p style="color:blue;">在从机上禁用二进制日志记录的情况下提交的复制事务的gtid。</p></li><li class="listitem"><p>
                            GTIDs of transactions that were written to a binary log file
                            that has now been purged.
                        </p><p style="color:blue;">写入现在已清除的二进制日志文件的事务的gtid。</p></li><li class="listitem"><p>
                            GTIDs that were added explicitly to the set by the statement
                            <code class="literal">SET @@GLOBAL.gtid_purged</code>.
                        </p><p style="color:blue;">已清除由语句set@@global.gtid明确添加到集合的gtid。</p></li></ul>
                    </div>
                    <p>
                        You can change the value of
                        <a class="link" href="replication.html#sysvar_gtid_purged"><code class="literal">gtid_purged</code></a> in order to record
                        on the server that the transactions in a certain GTID set have
                        been applied, although they do not exist in any binary log on
                        the server. When you add GTIDs to
                        <a class="link" href="replication.html#sysvar_gtid_purged"><code class="literal">gtid_purged</code></a>, they are also
                        added to <a class="link" href="replication.html#sysvar_gtid_executed"><code class="literal">gtid_executed</code></a>. An
                        example use case for this action is when you are restoring a
                        backup of one or more databases on a server, but you do not have
                        the relevant binary logs containing the transactions on the
                        server. In MySQL 5.7, you can only change the value of
                        <a class="link" href="replication.html#sysvar_gtid_purged"><code class="literal">gtid_purged</code></a> when
                        <a class="link" href="replication.html#sysvar_gtid_executed"><code class="literal">gtid_executed</code></a> (and therefore
                        <a class="link" href="replication.html#sysvar_gtid_purged"><code class="literal">gtid_purged</code></a>) is empty. For
                        details of how to do this, see the description for
                        <a class="link" href="replication.html#sysvar_gtid_purged"><code class="literal">gtid_purged</code></a>.
                    </p><p style="color:blue;">您可以更改GTIDIPUPEDGE的值，以便在服务器上记录某个GTID集合中的事务已被应用，尽管它们不存在于服务器上的任何二进制日志中。当您将gtid添加到gtid_清除时，它们也会添加到gtid_执行。此操作的一个示例用例是，当您在服务器上还原一个或多个数据库的备份时，但是您没有包含服务器上事务的相关二进制日志。在mysql 5.7中，当gtid_executed（因此gtid_purged）为空时，只能更改gtid_purged的值。有关如何执行此操作的详细信息，请参阅清除的gtid_的说明。</p><p>
                    The sets of GTIDs in the
                    <a class="link" href="replication.html#sysvar_gtid_executed"><code class="literal">gtid_executed</code></a> and
                    <a class="link" href="replication.html#sysvar_gtid_purged"><code class="literal">gtid_purged</code></a> system variables
                    are initialized when the server starts. Every binary log file
                    begins with the event
                    <code class="literal">Previous_gtids_log_event</code>, which contains the
                    set of GTIDs in all previous binary log files (composed from the
                    GTIDs in the preceding file's
                    <code class="literal">Previous_gtids_log_event</code>, and the GTIDs of
                    every <code class="literal">Gtid_log_event</code> in the preceding file
                    itself). The contents of
                    <code class="literal">Previous_gtids_log_event</code> in the oldest and
                    most recent binary log files are used to compute the
                    <a class="link" href="replication.html#sysvar_gtid_executed"><code class="literal">gtid_executed</code></a> and
                    <a class="link" href="replication.html#sysvar_gtid_purged"><code class="literal">gtid_purged</code></a> sets at server
                    startup:
                </p><p style="color:blue;">当服务器启动时，gtid_executed和gtid_purged系统变量中的gtid集合将被初始化。每个二进制日志文件都以event previous_gtid s_log_event开始，它包含所有先前二进制日志文件中的一组gtid（由先前文件的previous_gtids_log_event中的gtid组成，以及先前文件本身中每个gtid_log_event的gtid组成）。最旧和最新二进制日志文件中以前的gtid_log_事件的内容用于计算服务器启动时执行的gtid_和清除的gtid_集：</p>
                    <div class="itemizedlist">
                        <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                            <a class="link" href="replication.html#sysvar_gtid_executed"><code class="literal">gtid_executed</code></a> is computed
                            as the union of the GTIDs in
                            <code class="literal">Previous_gtids_log_event</code> in the most
                            recent binary log file, the GTIDs of transactions in that
                            binary log file, and the GTIDs stored in the
                            <code class="literal">mysql.gtid_executed</code> table. This GTID set
                            contains all the GTIDs that have been used (or added
                            explicitly to <a class="link" href="replication.html#sysvar_gtid_purged"><code class="literal">gtid_purged</code></a>)
                            on the server, whether or not they are currently in a binary
                            log file on the server. It does not include the GTIDs for
                            transactions that are currently being processed on the
                            server (<code class="literal">@@GLOBAL.gtid_owned</code>).
                        </p><p style="color:blue;">gtid_executed计算为最新二进制日志文件中以前的gtid_log_事件中的gtid、该二进制日志文件中事务的gtid以及存储在mysql.gtid_executed表中的gtid的并集。此gtid集包含已在服务器上使用（或已显式添加到已清除的gtid中）的所有gtid，无论它们当前是否在服务器上的二进制日志文件中。它不包括当前在服务器上处理的事务的gtid（@global.gtid_owned）。</p></li><li class="listitem"><p>
                            <a class="link" href="replication.html#sysvar_gtid_purged"><code class="literal">gtid_purged</code></a> is computed by
                            first adding the GTIDs in
                            <code class="literal">Previous_gtids_log_event</code> in the most
                            recent binary log file and the GTIDs of transactions in that
                            binary log file. This step gives the set of GTIDs that are
                            currently, or were once, recorded in a binary log on the
                            server (<code class="literal">gtids_in_binlog</code>). Next, the GTIDs
                            in <code class="literal">Previous_gtids_log_event</code> in the oldest
                            binary log file are subtracted from
                            <code class="literal">gtids_in_binlog</code>. This step gives the set
                            of GTIDs that are currently recorded in a binary log on the
                            server (<code class="literal">gtids_in_binlog_not_purged</code>).
                            Finally, <code class="literal">gtids_in_binlog_not_purged</code> is
                            subtracted from
                            <a class="link" href="replication.html#sysvar_gtid_executed"><code class="literal">gtid_executed</code></a>. The result
                            is the set of GTIDs that have been used on the server, but
                            are not currently recorded in a binary log file on the
                            server, and this result is used to initialize
                            <a class="link" href="replication.html#sysvar_gtid_purged"><code class="literal">gtid_purged</code></a>.
                        </p><p style="color:blue;">清除的gtid_通过首先在最近的二进制日志文件中添加先前的gtid_log_事件中的gtid和该二进制日志文件中事务的gtid来计算。此步骤提供当前或曾经记录在服务器二进制日志（gtids_in_binlog）中的一组gtid。接下来，从最旧二进制日志文件中的gtids中减去先前的gtids日志事件中的gtids。此步骤提供当前记录在服务器二进制日志中的一组gtid（gtids_in_binlog_not_purged）。最后，从执行的gtid中减去未清除的gtid。结果是服务器上已使用但当前未记录在服务器上二进制日志文件中的一组gtid，此结果用于初始化清除的gtid。</p></li></ul>
                    </div>
                    <p>
                        If binary logs from MySQL 5.7.7 or older are involved in these
                        computations, it is possible for incorrect GTID sets to be
                        computed for <a class="link" href="replication.html#sysvar_gtid_executed"><code class="literal">gtid_executed</code></a> and
                        <a class="link" href="replication.html#sysvar_gtid_purged"><code class="literal">gtid_purged</code></a>, and they remain
                        incorrect even if the server is later restarted. For details,
                        see the description for the
                        <a class="link" href="replication.html#sysvar_binlog_gtid_simple_recovery"><code class="literal">binlog_gtid_simple_recovery</code></a>
                        system variable, which controls how the binary logs are iterated
                        to compute the GTID sets. If one of the situations described
                        there applies on a server, set
                        <a class="link" href="replication.html#sysvar_binlog_gtid_simple_recovery"><code class="literal">binlog_gtid_simple_recovery=FALSE</code></a>
                        in the server's configuration file before starting it. That
                        setting makes the server iterate all the binary log files (not
                        just the newest and oldest) to find where GTID events start to
                        appear. This process could take a long time if the server has a
                        large number of binary log files without GTID events.
                    </p><p style="color:blue;">如果在这些计算中涉及mysql 5.7.7或更早版本的二进制日志，则可能为执行gtid_并清除gtid_而计算不正确的gtid集，并且即使以后重新启动服务器，它们仍然不正确。有关详细信息，请参见binlog_gtid_simple_recovery系统变量的说明，该变量控制如何迭代二进制日志以计算gtid集。如果其中一种情况适用于服务器，请在启动之前在服务器的配置文件中设置binlog_gtid_simple_recovery=false。该设置使服务器遍历所有二进制日志文件（不仅是最新和最旧的），以查找gtid事件开始出现的位置。如果服务器有大量没有gtid事件的二进制日志文件，则此过程可能需要很长时间。</p>
                </div>
                <div class="simplesect">
                    <div class="titlepage">
                        <div>
                            <div class="simple">
                                <h5 class="title"><a name="replication-gtids-execution-history"></a>Resetting the GTID Execution History</h5>

                            </div>

                        </div>

                    </div>
                    <p>
                        If you need to reset the GTID execution history on a server, use
                        the <a class="link" href="sql-syntax.html#reset-master" title="13.4.1.2&nbsp;RESET MASTER Syntax"><code class="literal">RESET MASTER</code></a> statement. For
                        example, you might need to do this after carrying out test
                        queries to verify a replication setup on new GTID-enabled
                        servers, or when you want to join a new server to a replication
                        group but it contains some unwanted local transactions that are
                        not accepted by Group Replication.
                    </p><p style="color:blue;">如果需要重置服务器上的gtid执行历史记录，请使用reset master语句。例如，在执行测试查询以验证启用了gtid的新服务器上的复制设置后，或者在希望将新服务器加入复制组但其中包含一些组复制不接受的不需要的本地事务时，可能需要执行此操作。</p>
                    <div class="warning" style="margin-left: 0.5in; margin-right: 0.5in;">

                        <div class="admon-title">
                            Warning
                        </div>
                        <p>
                            Use <a class="link" href="sql-syntax.html#reset-master" title="13.4.1.2&nbsp;RESET MASTER Syntax"><code class="literal">RESET MASTER</code></a> with caution
                            to avoid losing any wanted GTID execution history and binary
                            log files.
                        </p><p style="color:blue;">小心使用reset master，以避免丢失任何想要的gtid执行历史和二进制日志文件。</p>
                    </div>
                    <p>
                        Before issuing <a class="link" href="sql-syntax.html#reset-master" title="13.4.1.2&nbsp;RESET MASTER Syntax"><code class="literal">RESET MASTER</code></a>,
                        ensure that you have backups of the server's binary log files
                        and binary log index file, if any, and obtain and save the GTID
                        set held in the global value of the
                        <a class="link" href="replication.html#sysvar_gtid_executed"><code class="literal">gtid_executed</code></a> system variable
                        (for example, by issuing a <code class="literal">SELECT
                        @@GLOBAL.gtid_executed</code> statement and saving the
                        results). If you are removing unwanted transactions from that
                        GTID set, use <a class="link" href="programs.html#mysqlbinlog" title="4.6.7&nbsp;mysqlbinlog — Utility for Processing Binary Log Files"><span class="command"><strong>mysqlbinlog</strong></span></a> to examine the
                        contents of the transactions to ensure that they have no value,
                        contain no data that must be saved or replicated, and did not
                        result in data changes on the server.
                    </p><p style="color:blue;">在发出reset master之前，请确保已备份服务器的二进制日志文件和二进制日志索引文件（如果有），并获取和保存保存保存在gtid_executed系统变量的全局值中的gtid集（例如，通过发出select@@global.gtid_executed语句并保存结果）。如果要从该gtid集中删除不需要的事务，请使用mysqlbinlog检查事务的内容，以确保它们没有值，不包含必须保存或复制的数据，并且不会导致服务器上的数据更改。</p><p>
                    When you issue <a class="link" href="sql-syntax.html#reset-master" title="13.4.1.2&nbsp;RESET MASTER Syntax"><code class="literal">RESET MASTER</code></a>, the
                    following reset operations are carried out:
                </p><p style="color:blue;">当您发出重置主机时，将执行以下重置操作：</p>
                    <div class="itemizedlist">
                        <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                            The value of the
                            <a class="link" href="replication.html#sysvar_gtid_purged"><code class="literal">gtid_purged</code></a> system variable
                            is set to an empty string (<code class="literal">''</code>).
                        </p><p style="color:blue;">GTID_清除的系统变量的值设置为空字符串（''）。</p></li><li class="listitem"><p>
                            The global value (but not the session value) of the
                            <a class="link" href="replication.html#sysvar_gtid_executed"><code class="literal">gtid_executed</code></a> system
                            variable is set to an empty string.
                        </p><p style="color:blue;">gtid_executed系统变量的全局值（而不是会话值）设置为空字符串。</p></li><li class="listitem"><p>
                            The <code class="literal">mysql.gtid_executed</code> table is cleared
                            (see
                            <a class="xref" href="replication.html#replication-gtids-gtid-executed-table" title="mysql.gtid_executed Table">mysql.gtid_executed Table</a>).
                        </p><p style="color:blue;">清除mysql.gtid_executed表（请参阅mysql.gtid_executed表）。</p></li><li class="listitem"><p>
                            If the server has binary logging enabled, the existing
                            binary log files are deleted and the binary log index file
                            is cleared.
                        </p><p style="color:blue;">如果服务器启用二进制日志记录，则删除现有的二进制日志文件，并清除二进制日志索引文件。</p></li></ul>
                    </div>
                    <p>
                        Note that <a class="link" href="sql-syntax.html#reset-master" title="13.4.1.2&nbsp;RESET MASTER Syntax"><code class="literal">RESET MASTER</code></a> is the
                        method to reset the GTID execution history even if the server is
                        a replication slave where binary logging is disabled.
                        <a class="link" href="sql-syntax.html#reset-slave" title="13.4.2.4&nbsp;RESET SLAVE Syntax"><code class="literal">RESET SLAVE</code></a> has no effect on the
                        GTID execution history.
                    </p><p style="color:blue;">请注意，reset master是重置gtid执行历史的方法，即使服务器是禁用二进制日志记录的复制从属服务器。重置从机对gtid执行历史没有影响。</p>
                </div>

            </div>
            <div class="section">
                <div class="titlepage">
                    <div>
                        <div>
                            <h4 class="title"><a name="replication-gtids-auto-positioning"></a>16.1.3.3&nbsp;GTID Auto-Positioning</h4>

                        </div>

                    </div>

                </div>
                <a class="indexterm" name="idm140286801517184"></a><p>
                GTIDs replace the file-offset pairs previously required to
                determine points for starting, stopping, or resuming the flow of
                data between master and slave. When GTIDs are in use, all the
                information that the slave needs for synchronizing with the master
                is obtained directly from the replication data stream.
            </p><p style="color:blue;">gtid替换了以前确定主设备和从设备之间数据流的开始、停止或恢复点所需的文件偏移对。使用gtid时，从机与主机同步所需的所有信息都直接从复制数据流中获取。</p><p>
                To start a slave using GTID-based replication, you do not include
                <code class="literal">MASTER_LOG_FILE</code> or
                <code class="literal">MASTER_LOG_POS</code> options in the
                <a class="link" href="sql-syntax.html#change-master-to" title="13.4.2.1&nbsp;CHANGE MASTER TO Syntax"><code class="literal">CHANGE MASTER TO</code></a> statement used to
                direct the slave to replicate from a given master. These options
                specify the name of the log file and the starting position within
                the file, but with GTIDs the slave does not need this nonlocal
                data. Instead, you need to enable the
                <code class="literal">MASTER_AUTO_POSITION</code> option. For full
                instructions to configure and start masters and slaves using
                GTID-based replication, see
                <a class="xref" href="replication.html#replication-gtids-howto" title="16.1.3.4&nbsp;Setting Up Replication Using GTIDs">Section&nbsp;16.1.3.4, “Setting Up Replication Using GTIDs”</a>.
            </p><p style="color:blue;">要使用基于gtid的复制启动从机，在用于指示从机从给定主机复制的change master to语句中不包括master_log_file或master_log_pos选项。这些选项指定日志文件的名称和文件中的起始位置，但是对于gtid，从服务器不需要这些非本地数据。相反，您需要启用master_auto_position选项。有关使用基于gtid的复制配置和启动主设备和从设备的完整说明，请参阅16.1.3.4节“使用gtid设置复制”。</p><p>
                The <code class="literal">MASTER_AUTO_POSITION</code> option is disabled by
                default. If multi-source replication is enabled on the slave, you
                need to set the option for each applicable replication channel.
                Disabling the <code class="literal">MASTER_AUTO_POSITION</code> option again
                makes the slave revert to file-based replication, in which case
                you must also specify one or both of the
                <code class="literal">MASTER_LOG_FILE</code> or
                <code class="literal">MASTER_LOG_POS</code> options.
            </p><p style="color:blue;">默认情况下，“主机自动位置”选项处于禁用状态。如果在从机上启用了多源复制，则需要为每个适用的复制通道设置选项。再次禁用master_auto_position选项将使从机还原为基于文件的复制，在这种情况下，还必须指定一个或两个master_log_file或master_log_pos选项。</p><p>
                When a replication slave has GTIDs enabled
                (<a class="link" href="replication.html#sysvar_gtid_mode"><code class="literal">GTID_MODE=ON</code></a>,
                <code class="literal">ON_PERMISSIVE,</code> or
                <code class="literal">OFF_PERMISSIVE</code> ) and the
                <code class="literal">MASTER_AUTO_POSITION</code> option enabled,
                auto-positioning is activated for connection to the master. The
                master must have <a class="link" href="replication.html#sysvar_gtid_mode"><code class="literal">GTID_MODE=ON</code></a> set
                in order for the connection to succeed. In the initial handshake,
                the slave sends a GTID set containing the transactions that it has
                already received, committed, or both. This GTID set is equal to
                the union of the set of GTIDs in the
                <a class="link" href="replication.html#sysvar_gtid_executed"><code class="literal">gtid_executed</code></a> system variable
                (<code class="literal">@@GLOBAL.gtid_executed</code>), and the set of GTIDs
                recorded in the Performance Schema
                <a class="link" href="performance-schema.html#replication-connection-status-table" title="25.12.11.2&nbsp;The replication_connection_status Table"><code class="literal">replication_connection_status</code></a> table
                as received transactions (the result of the statement
                <code class="literal">SELECT RECEIVED_TRANSACTION_SET FROM
                    PERFORMANCE_SCHEMA.replication_connection_status</code>).
            </p><p style="color:blue;">当复制从机启用了gtid（gtid_mode=on、on_permissive或off_permissive）并且启用了master_auto_position选项时，将激活与主机的连接的自动定位。主服务器必须设置gtid_mode=on，连接才能成功。在初始握手中，从机发送一个gtid集，其中包含它已经接收、提交或两者都已接收到的事务。这个gtid集等于gtid_executed系统变量（@global.gtid_executed）中gtid集的并集，以及性能架构复制连接状态表中记录为已接收事务的GTID集（语句select received_transaction_set from performance_schema.replication_connection_status的结果）。</p><p>
                The master responds by sending all transactions recorded in its
                binary log whose GTID is not included in the GTID set sent by the
                slave. This exchange ensures that the master only sends the
                transactions with a GTID that the slave has not already received
                or committed. If the slave receives transactions from more than
                one master, as in the case of a diamond topology, the auto-skip
                function ensures that the transactions are not applied twice.
            </p><p style="color:blue;">主服务器通过发送记录在其二进制日志中的所有事务进行响应，这些事务的gtid不包括在从服务器发送的gtid集中。此交换确保主服务器只发送GTID为从属服务器尚未接收或提交的事务。如果从机从多个主机接收事务，如菱形拓扑，则自动跳过功能确保事务不会应用两次。</p><p>
                If any of the transactions that should be sent by the master have
                been purged from the master's binary log, or added to the set of
                GTIDs in the <a class="link" href="replication.html#sysvar_gtid_purged"><code class="literal">gtid_purged</code></a> system
                variable by another method, the master sends the error
                <span class="errorname">ER_MASTER_HAS_PURGED_REQUIRED_GTIDS</span> to the
                slave, and replication does not start. The slave cannot recover
                automatically from this error because parts of the transaction
                history that are needed to catch up with the master have been
                purged. Attempting to reconnect without the
                <code class="literal">MASTER_AUTO_POSITION</code> option enabled only
                results in the loss of the purged transactions on the slave. The
                correct approach to recover from this situation is for the slave
                to replicate the missing transactions from another source, or for
                the slave to be replaced by a new slave created from a more recent
                backup. Consider revising the binary log expiration period on the
                master to ensure that the situation does not occur again.
            </p><p style="color:blue;">如果主服务器应发送的任何事务已从主服务器的二进制日志中清除，或通过另一种方法添加到GTID清除的系统变量中的GTID集合中，则主服务器将错误ERU MASTER清除的GTID发送到从服务器，并且复制不会启动。从属服务器无法从该错误中自动恢复，因为追赶主服务器所需的部分事务历史记录已被清除。尝试在未启用“主机自动位置”选项的情况下重新连接只会导致从机上清除的事务丢失。从这种情况恢复的正确方法是，从服务器从另一个源复制丢失的事务，或者将从服务器替换为从最近的备份创建的新从服务器。请考虑修改主机上的二进制日志过期时间，以确保不再发生这种情况。</p><p>
                If during the exchange of transactions it is found that the slave
                has received or committed transactions with the master's UUID in
                the GTID, but the master itself does not have a record of them,
                the master sends the error
                <span class="errorname">ER_SLAVE_HAS_MORE_GTIDS_THAN_MASTER</span> to the
                slave and replication does not start. This situation can occur if
                a master that does not have
                <a class="link" href="replication.html#sysvar_sync_binlog"><code class="literal">sync_binlog=1</code></a> set experiences a
                power failure or operating system crash, and loses committed
                transactions that have not yet been synchronized to the binary log
                file, but have been received by the slave. The master and slave
                can diverge if any clients commit transactions on the master after
                it is restarted, which can lead to the situation where the master
                and slave are using the same GTID for different transactions. The
                correct approach to recover from this situation is to check
                manually whether the master and slave have diverged. If the same
                GTID is now in use for different transactions, you either need to
                perform manual conflict resolution for individual transactions as
                required, or remove either the master or the slave from the
                replication topology. If the issue is only missing transactions on
                the master, you can make the master into a slave instead, allow it
                to catch up with the other servers in the replication topology,
                and then make it a master again if needed.
            </p><p style="color:blue;">如果在事务交换过程中发现从机在gtid中接收或提交了与主机uuid的事务，但主机本身没有这些事务的记录，则主机将错误er_slave_的gtid s_多于u master发送到从机，并且复制不会启动。如果没有sync_binlog=1设置的主服务器发生电源故障或操作系统崩溃，并丢失尚未同步到二进制日志文件但已由从服务器接收的提交事务，则可能会发生这种情况。如果任何客户端在主服务器重新启动后提交事务，则主服务器和从服务器可能会发生分歧，这可能导致主服务器和从服务器对不同的事务使用相同的gtid。从这种情况中恢复的正确方法是手动检查主设备和从设备是否已分离。如果同一个gtid现在用于不同的事务，则需要根据需要对单个事务执行手动冲突解决，或者从复制拓扑中删除主事务或从事务。如果问题只是缺少主服务器上的事务，则可以将主服务器改为从服务器，允许它赶上复制拓扑中的其他服务器，然后根据需要将其重新设置为主服务器。</p>
            </div>
            <div class="section">
                <div class="titlepage">
                    <div>
                        <div>
                            <h4 class="title"><a name="replication-gtids-howto"></a>16.1.3.4&nbsp;Setting Up Replication Using GTIDs</h4>

                        </div>

                    </div>

                </div>
                <a class="indexterm" name="idm140286801487472"></a><p>
                This section describes a process for configuring and starting
                GTID-based replication in MySQL 5.7. This is a
                <span class="quote">“<span class="quote">cold start</span>”</span> procedure that assumes either that you
                are starting the replication master for the first time, or that it
                is possible to stop it; for information about provisioning
                replication slaves using GTIDs from a running master, see
                <a class="xref" href="replication.html#replication-gtids-failover" title="16.1.3.5&nbsp;Using GTIDs for Failover and Scaleout">Section&nbsp;16.1.3.5, “Using GTIDs for Failover and Scaleout”</a>. For information
                about changing GTID mode on servers online, see
                <a class="xref" href="replication.html#replication-mode-change-online" title="16.1.5&nbsp;Changing Replication Modes on Online Servers">Section&nbsp;16.1.5, “Changing Replication Modes on Online Servers”</a>.
            </p><p style="color:blue;">本节介绍在mysql 5.7中配置和启动基于gtid的复制的过程。这是一个“冷启动”过程，假定您是第一次启动复制主服务器，或者可以停止复制主服务器；有关从正在运行的主服务器使用gtid配置复制从服务器的信息，请参阅第16.1.3.5节“使用gtid进行故障转移和扩展”。有关更改联机服务器上的GTID模式的信息，请参阅第16.1.5节“更改联机服务器上的复制模式”。</p><p>
                The key steps in this startup process for the simplest possible
                GTID replication topology, consisting of one master and one slave,
                are as follows:
            </p><p style="color:blue;">对于由一个主节点和一个从节点组成的最简单的gtid复制拓扑，此启动过程中的关键步骤如下：</p>
                <div class="orderedlist">
                    <ol class="orderedlist" type="1"><li class="listitem"><p>
                        If replication is already running, synchronize both servers by
                        making them read-only.
                    </p><p style="color:blue;">如果复制已在运行，请将两个服务器设为只读以同步它们。</p></li><li class="listitem"><p>
                        Stop both servers.
                    </p><p style="color:blue;">停止两台服务器。</p></li><li class="listitem"><p>
                        Restart both servers with GTIDs enabled and the correct
                        options configured.
                    </p><p style="color:blue;">在启用gtid并配置正确选项的情况下重新启动两台服务器。</p><p>
                        The <a class="link" href="programs.html#mysqld" title="4.3.1&nbsp;mysqld — The MySQL Server"><span class="command"><strong>mysqld</strong></span></a> options necessary to start the
                        servers as described are discussed in the example that follows
                        later in this section.
                    </p><p style="color:blue;">启动服务器所需的mysqld选项将在本节后面的示例中讨论。</p></li><li class="listitem"><p>
                        Instruct the slave to use the master as the replication data
                        source and to use auto-positioning. The SQL statements needed
                        to accomplish this step are described in the example that
                        follows later in this section.
                    </p><p style="color:blue;">指示从机使用主机作为复制数据源并使用自动定位。完成此步骤所需的sql语句将在本节后面的示例中介绍。</p></li><li class="listitem"><p>
                        Take a new backup. Binary logs containing transactions without
                        GTIDs cannot be used on servers where GTIDs are enabled, so
                        backups taken before this point cannot be used with your new
                        configuration.
                    </p><p style="color:blue;">换一个新的备份。在启用了gtid的服务器上，不能使用包含没有gtid的事务的二进制日志，因此在此之前进行的备份不能用于新配置。</p></li><li class="listitem"><p>
                        Start the slave, then disable read-only mode on both servers,
                        so that they can accept updates.
                    </p><p style="color:blue;">启动从服务器，然后在两台服务器上禁用只读模式，以便它们可以接受更新。</p></li></ol>
                </div>
                <p>
                    In the following example, two servers are already running as
                    master and slave, using MySQL's binary log position-based
                    replication protocol. If you are starting with new servers, see
                    <a class="xref" href="replication.html#replication-howto-repuser" title="16.1.2.2&nbsp;Creating a User for Replication">Section&nbsp;16.1.2.2, “Creating a User for Replication”</a> for information about
                    adding a specific user for replication connections and
                    <a class="xref" href="replication.html#replication-howto-masterbaseconfig" title="16.1.2.1&nbsp;Setting the Replication Master Configuration">Section&nbsp;16.1.2.1, “Setting the Replication Master Configuration”</a> for
                    information about setting the
                    <a class="link" href="server-administration.html#sysvar_server_id"><code class="literal">server_id</code></a> variable. The following
                    examples show how to store <a class="link" href="programs.html#mysqld" title="4.3.1&nbsp;mysqld — The MySQL Server"><span class="command"><strong>mysqld</strong></span></a> startup
                    options in server's option file, see
                    <a class="xref" href="programs.html#option-files" title="4.2.2.2&nbsp;Using Option Files">Section&nbsp;4.2.2.2, “Using Option Files”</a> for more information. Alternatively
                    you can use startup options when running
                    <a class="link" href="programs.html#mysqld" title="4.3.1&nbsp;mysqld — The MySQL Server"><span class="command"><strong>mysqld</strong></span></a>.
                </p><p style="color:blue;">在下面的示例中，已经有两个服务器作为主服务器和从服务器运行，使用的是mysql基于二进制日志位置的复制协议。如果要从新服务器开始，请参阅第16.1.2.2节“创建复制用户”以获取有关为复制连接添加特定用户的信息，以及第16.1.2.1节“设置复制主配置”以获取有关设置服务器ID变量的信息。以下示例显示了如何将mysqld启动选项存储在服务器的选项文件中，有关详细信息，请参阅第4.2.2.2节“使用选项文件”。或者，您可以在运行mysqld时使用启动选项。</p><p>
                Most of the steps that follow require the use of the MySQL
                <code class="literal">root</code> account or another MySQL user account that
                has the <a class="link" href="security.html#priv_super"><code class="literal">SUPER</code></a> privilege.
                <a class="link" href="programs.html#mysqladmin" title="4.5.2&nbsp;mysqladmin — Client for Administering a MySQL Server"><span class="command"><strong>mysqladmin</strong></span></a> <code class="literal">shutdown</code> requires
                either the <code class="literal">SUPER</code> privilege or the
                <a class="link" href="security.html#priv_shutdown"><code class="literal">SHUTDOWN</code></a> privilege.
            </p><p style="color:blue;">接下来的大多数步骤都需要使用mysql根帐户或具有超级权限的另一个mysql用户帐户。mysqladmin关闭需要超级权限或关闭权限。</p><p><b>Step 1: Synchronize the servers.&nbsp;</b>
                This step is only required when working with servers which are
                already replicating without using GTIDs. For new servers proceed
                to Step 3. Make the servers read-only by setting the
                <a class="link" href="server-administration.html#sysvar_read_only"><code class="literal">read_only</code></a> system variable to
                <code class="literal">ON</code> on each server by issuing the following:
            </p><p style="color:blue;">步骤1：同步服务器。只有在使用已经在不使用gtid的情况下进行复制的服务器时，才需要此步骤。对于新服务器，请执行步骤3。通过在每台服务器上发出以下命令，将READ U ONLY系统变量设置为ON，使服务器成为只读：</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>SET @@GLOBAL.read_only = ON;</code></strong>
</pre><p>
                Wait for all ongoing transactions to commit or roll back. Then,
                allow the slave to catch up with the master. <span class="emphasis"><em>It is
      extremely important that you make sure the slave has processed all
      updates before continuing</em></span>.


            </p><p style="color:blue;">等待所有正在进行的事务提交或回滚。然后，让奴隶赶上主人。在继续之前，确保从属服务器已处理所有更新是非常重要的。</p><p>
                If you use binary logs for anything other than replication, for
                example to do point in time backup and restore, wait until you do
                not need the old binary logs containing transactions without
                GTIDs. Ideally, wait for the server to purge all binary logs, and
                wait for any existing backup to expire.
            </p><p style="color:blue;">如果将二进制日志用于复制以外的任何操作，例如执行时间点备份和还原，请等到不需要包含没有gtid的事务的旧二进制日志。理想情况下，等待服务器清除所有二进制日志，并等待任何现有备份过期。</p>
                <div class="important" style="margin-left: 0.5in; margin-right: 0.5in;">

                    <div class="admon-title">
                        Important
                    </div>
                    <p>
                        It is important to understand that logs containing transactions
                        without GTIDs cannot be used on servers where GTIDs are enabled.
                        Before proceeding, you must be sure that transactions without
                        GTIDs do not exist anywhere in the topology.
                    </p><p style="color:blue;">必须了解，在启用了gtid的服务器上不能使用包含没有gtid的事务的日志。在继续之前，必须确保拓扑中没有GTIDS的事务在任何地方都不存在。</p>
                </div>
                <p><b>Step 2: Stop both servers.&nbsp;</b>
                    Stop each server using <a class="link" href="programs.html#mysqladmin" title="4.5.2&nbsp;mysqladmin — Client for Administering a MySQL Server"><span class="command"><strong>mysqladmin</strong></span></a> as shown
                    here, where <em class="replaceable"><code>username</code></em> is the user name
                    for a MySQL user having sufficient privileges to shut down the
                    server:
                </p><p style="color:blue;">步骤2：停止两台服务器。如图所示，停止使用mysqladmin的每台服务器，其中user name是具有足够权限关闭服务器的mysql用户的用户名：</p><pre data-lang="terminal" class="programlisting">shell&gt; <strong class="userinput"><code>mysqladmin -u<em class="replaceable"><code>username</code></em> -p shutdown</code></strong>
</pre><p>
                Then supply this user's password at the prompt.
            </p><p style="color:blue;">然后在提示下提供此用户的密码。</p><p><b>Step 3: Start both servers with GTIDs enabled.&nbsp;</b>
                To enable GTID-based replication, each server must be started
                with GTID mode enabled by setting the
                <a class="link" href="replication.html#sysvar_gtid_mode"><code class="literal">gtid_mode</code></a> variable to
                <code class="literal">ON</code>, and with the
                <a class="link" href="replication.html#sysvar_enforce_gtid_consistency"><code class="literal">enforce_gtid_consistency</code></a>
                variable enabled to ensure that only statements which are safe
                for GTID-based replication are logged. For example:
            </p><p style="color:blue;">步骤3：在启用gtid的情况下启动两个服务器。要启用基于gtid的复制，必须通过将gtid_mode变量设置为on启用gtid mode，并启用enforce_gtid_consistency变量来启动每个服务器，以确保仅记录对基于gtid的复制安全的语句。例如：</p><pre data-lang="ini" class="programlisting">gtid_mode=ON
enforce-gtid-consistency=ON
</pre><p>
                In addition, you should start slaves with the
                <a class="link" href="replication.html#option_mysqld_skip-slave-start"><code class="option">--skip-slave-start</code></a> option before
                configuring the slave settings. For more information on GTID
                related options and variables, see
                <a class="xref" href="replication.html#replication-options-gtids" title="16.1.6.5&nbsp;Global Transaction ID Options and Variables">Section&nbsp;16.1.6.5, “Global Transaction ID Options and Variables”</a>.
            </p><p style="color:blue;">此外，在配置从机设置之前，应该使用--skip slave start选项启动从机。有关gtid相关选项和变量的更多信息，请参见第16.1.6.5节“全局事务id选项和变量”。</p><p>
                It is not mandatory to have binary logging enabled in order to use
                GTIDs when using the
                <a class="xref" href="replication.html#replication-gtids-gtid-executed-table" title="mysql.gtid_executed Table">mysql.gtid_executed Table</a>. Masters
                must always have binary logging enabled in order to be able to
                replicate. However, slave servers can use GTIDs but without binary
                logging. If you need to disable binary logging on a slave server,
                you can do this by specifying the
                <a class="link" href="replication.html#option_mysqld_log-bin"><code class="option">--skip-log-bin</code></a>
                and <a class="link" href="replication.html#sysvar_log_slave_updates"><code class="option">--log-slave-updates=OFF</code></a> options
                for the slave.
            </p><p style="color:blue;">在使用mysql.gtid_executed表时，不必启用二进制日志记录才能使用gtid。主服务器必须始终启用二进制日志记录才能进行复制。但是，从属服务器可以使用gtid，但不需要二进制日志记录。如果需要在从属服务器上禁用二进制日志记录，可以通过为从属服务器指定--skip log bin和--log slave updates=off选项来执行此操作。</p><p><b>Step 4: Configure the slave to use GTID-based auto-positioning.&nbsp;</b>
                Tell the slave to use the master with GTID based transactions as
                the replication data source, and to use GTID-based
                auto-positioning rather than file-based positioning. Issue a
                <a class="link" href="sql-syntax.html#change-master-to" title="13.4.2.1&nbsp;CHANGE MASTER TO Syntax"><code class="literal">CHANGE MASTER TO</code></a> statement on the
                slave, including the <code class="literal">MASTER_AUTO_POSITION</code>
                option in the statement to tell the slave that the master's
                transactions are identified by GTIDs.
            </p><p style="color:blue;">步骤4：配置从机使用基于gtid的自动定位。告诉从机使用基于gtid事务的主服务器作为复制数据源，并使用基于gtid的自动定位而不是基于文件的定位。在从机上发出一个change master to语句，包括语句中的master_auto_position选项，告诉从机主机的事务由gtid标识。</p><p>
                You may also need to supply appropriate values for the
                master's host name and port number as well as the user name
                and password for a replication user account which can be used by
                the slave to connect to the master; if these have already been set
                prior to Step 1 and no further changes need to be made, the
                corresponding options can safely be omitted from the statement
                shown here.
            </p><p style="color:blue;">您可能还需要为主服务器的主机名和端口号以及复制用户帐户的用户名和密码提供适当的值，从服务器可以使用这些值连接到主服务器；如果在步骤1之前已经设置了这些值，并且不需要做进一步的更改，在这里显示的语句中，可以安全地省略相应的选项。</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>CHANGE MASTER TO</code></strong>
     &gt;     <strong class="userinput"><code>MASTER_HOST = <em class="replaceable"><code>host</code></em>,</code></strong>
     &gt;     <strong class="userinput"><code>MASTER_PORT = <em class="replaceable"><code>port</code></em>,</code></strong>
     &gt;     <strong class="userinput"><code>MASTER_USER = <em class="replaceable"><code>user</code></em>,</code></strong>
     &gt;     <strong class="userinput"><code>MASTER_PASSWORD = <em class="replaceable"><code>password</code></em>,</code></strong>
     &gt;     <strong class="userinput"><code>MASTER_AUTO_POSITION = 1;</code></strong>
</pre><p>
                Neither the <code class="literal">MASTER_LOG_FILE</code> option nor the
                <code class="literal">MASTER_LOG_POS</code> option may be used with
                <code class="literal">MASTER_AUTO_POSITION</code> set equal to 1. Attempting
                to do so causes the <a class="link" href="sql-syntax.html#change-master-to" title="13.4.2.1&nbsp;CHANGE MASTER TO Syntax"><code class="literal">CHANGE MASTER
                TO</code></a> statement to fail with an error.
            </p><p style="color:blue;">master_log_file选项和master_log_pos选项都不能在master_auto_position设置为1时使用。尝试执行此操作将导致change master to语句失败并出现错误。</p><p><b>Step 5: Take a new backup.&nbsp;</b>
                Existing backups that were made before you enabled GTIDs can no
                longer be used on these servers now that you have enabled GTIDs.
                Take a new backup at this point, so that you are not left
                without a usable backup.
            </p><p style="color:blue;">第五步：做一个新的备份。在启用GTIDS之前，在启用GTIDS之前所做的现有备份不能再在这些服务器上使用。此时需要一个新的备份，这样就不会没有可用的备份。</p><p>
                For instance, you can execute <a class="link" href="sql-syntax.html#flush-logs"><code class="literal">FLUSH
                LOGS</code></a> on the server where you are taking backups. Then
                either explicitly take a backup or wait for the next iteration of
                any periodic backup routine you may have set up.
            </p><p style="color:blue;">例如，可以在进行备份的服务器上执行刷新日志。然后显式地进行备份，或者等待您可能设置的任何定期备份例程的下一次迭代。</p><p><b>Step 6: Start the slave and disable read-only mode.&nbsp;</b>
                Start the slave like this:
            </p><p style="color:blue;">步骤6：启动从机并禁用只读模式。像这样启动奴隶：</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>START SLAVE;</code></strong>
</pre><p>
                The following step is only necessary if you configured a server to
                be read-only in Step 1. To allow the server to begin accepting
                updates again, issue the following statement:
            </p><p style="color:blue;">只有在步骤1中将服务器配置为只读时，才需要执行以下步骤。要允许服务器重新开始接受更新，请发出以下语句：</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>SET @@GLOBAL.read_only = OFF;</code></strong>
</pre><p>
                GTID-based replication should now be running, and you can begin
                (or resume) activity on the master as before.
                <a class="xref" href="replication.html#replication-gtids-failover" title="16.1.3.5&nbsp;Using GTIDs for Failover and Scaleout">Section&nbsp;16.1.3.5, “Using GTIDs for Failover and Scaleout”</a>, discusses creation
                of new slaves when using GTIDs.
            </p><p style="color:blue;">基于gtid的复制现在应该正在运行，您可以像以前一样在主服务器上开始（或恢复）活动。第16.1.3.5节“使用gtid进行故障转移和扩展”，讨论了在使用gtid时创建新的从机。</p>
            </div>
            <div class="section">
                <div class="titlepage">
                    <div>
                        <div>
                            <h4 class="title"><a name="replication-gtids-failover"></a>16.1.3.5&nbsp;Using GTIDs for Failover and Scaleout</h4>

                        </div>

                    </div>

                </div>
                <a class="indexterm" name="idm140286801409792"></a><a class="indexterm" name="idm140286801408304"></a><p>
                There are a number of techniques when using MySQL Replication with
                Global Transaction Identifiers (GTIDs) for provisioning a new
                slave which can then be used for scaleout, being promoted to
                master as necessary for failover. This section describes the
                following techniques:
            </p><p style="color:blue;">在使用带有全局事务标识符（gtid）的mysql复制时，有许多技术可用于设置一个新的从机，该从机可用于扩展，并根据故障转移的需要提升为主机。本节介绍以下技术：</p>
                <div class="itemizedlist">
                    <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                        <a class="xref" href="replication.html#replication-gtids-failover-replicate" title="Simple replication">Simple replication</a>
                    </p><p style="color:blue;">简单复制</p></li><li class="listitem"><p>
                        <a class="xref" href="replication.html#replication-gtids-failover-copy" title="Copying data and transactions to the slave">Copying data and transactions to the slave</a>
                    </p><p style="color:blue;">将数据和事务复制到从机</p></li><li class="listitem"><p>
                        <a class="xref" href="replication.html#replication-gtids-failover-empty" title="Injecting empty transactions">Injecting empty transactions</a>
                    </p><p style="color:blue;">注入空事务</p></li><li class="listitem"><p>
                        <a class="xref" href="replication.html#replication-gtids-failover-gtid-purged" title="Excluding transactions with gtid_purged">Excluding transactions with gtid_purged</a>
                    </p><p style="color:blue;">不包括已清除GTID的事务</p></li><li class="listitem"><p>
                        <a class="xref" href="replication.html#replication-gtids-restoring-mysqlbinlog" title="Restoring GTID mode slaves">Restoring GTID mode slaves</a>
                    </p><p style="color:blue;">恢复GTID模式从机</p></li></ul>
                </div>
                <p>
                    Global transaction identifiers were added to MySQL Replication for
                    the purpose of simplifying in general management of the
                    replication data flow and of failover activities in particular.
                    Each identifier uniquely identifies a set of binary log events
                    that together make up a transaction. GTIDs play a key role in
                    applying changes to the database: the server automatically skips
                    any transaction having an identifier which the server recognizes
                    as one that it has processed before. This behavior is critical for
                    automatic replication positioning and correct failover.
                </p><p style="color:blue;">在mysql复制中添加了全局事务标识符，以简化复制数据流的一般管理，特别是故障转移活动的一般管理。每个标识符唯一地标识组成事务的一组二进制日志事件。gtid在将更改应用于数据库中起着关键作用：服务器会自动跳过任何具有标识符的事务，服务器会将其识别为以前处理过的事务。此行为对于自动复制定位和正确的故障转移至关重要。</p><p>
                The mapping between identifiers and sets of events comprising a
                given transaction is captured in the binary log. This poses some
                challenges when provisioning a new server with data from another
                existing server. To reproduce the identifier set on the new
                server, it is necessary to copy the identifiers from the old
                server to the new one, and to preserve the relationship between
                the identifiers and the actual events. This is neccessary for
                restoring a slave that is immediately available as a candidate to
                become a new master on failover or switchover.
            </p><p style="color:blue;">在二进制日志中捕获标识符和包含给定事务的事件集之间的映射。当从另一个现有服务器提供新的服务器时，这带来了一些挑战。要在新服务器上重新生成标识符集，必须将标识符从旧服务器复制到新服务器，并保留标识符与实际事件之间的关系。这对于在故障转移或切换时将立即可用的从机恢复为新的主机是必要的。</p><p><a name="replication-gtids-failover-replicate"></a><b>Simple replication.&nbsp;</b>
                The easiest way to reproduce all identifiers and transactions on
                a new server is to make the new server into the slave of a
                master that has the entire execution history, and enable global
                transaction identifiers on both servers. See
                <a class="xref" href="replication.html#replication-gtids-howto" title="16.1.3.4&nbsp;Setting Up Replication Using GTIDs">Section&nbsp;16.1.3.4, “Setting Up Replication Using GTIDs”</a>, for more information.
            </p><p style="color:blue;">简单的复制。在新服务器上复制所有标识符和事务的最简单方法是将新服务器设置为具有整个执行历史的主服务器的从属服务器，并在两个服务器上启用全局事务标识符。有关更多信息，请参阅第16.1.3.4节“使用gtid设置复制”。</p><p>
                Once replication is started, the new server copies the entire
                binary log from the master and thus obtains all information about
                all GTIDs.
            </p><p style="color:blue;">复制启动后，新服务器将从主服务器复制整个二进制日志，从而获取有关所有gtid的所有信息。</p><p>
                This method is simple and effective, but requires the slave to
                read the binary log from the master; it can sometimes take a
                comparatively long time for the new slave to catch up with the
                master, so this method is not suitable for fast failover or
                restoring from backup. This section explains how to avoid fetching
                all of the execution history from the master by copying binary log
                files to the new server.
            </p><p style="color:blue;">这种方法简单有效，但要求从机从主机读取二进制日志，新的从机有时需要较长的时间才能赶上主机，不适合快速故障切换或从备份恢复。本节说明如何通过将二进制日志文件复制到新服务器来避免从主服务器获取所有执行历史记录。</p><p><a name="replication-gtids-failover-copy"></a><b>Copying data and transactions to the slave.&nbsp;</b>
                Executing the entire transaction history can be time-consuming
                when the source server has processed a large number of
                transactions previously, and this can represent a major
                bottleneck when setting up a new replication slave. To eliminate
                this requirement, a snapshot of the data set, the binary logs
                and the global transaction information the source server
                contains can be imported to the new slave. The source server can
                be either the master or the slave, but you must ensure that the
                source has processed all required transactions before copying
                the data.
            </p><p style="color:blue;">将数据和事务复制到从机。当源服务器以前处理过大量事务时，执行整个事务历史记录可能会非常耗时，这可能是设置新复制从属服务器时的一个主要瓶颈。为了消除这一需求，可以将源服务器包含的数据集、二进制日志和全局事务信息的快照导入到新的从属服务器。源服务器可以是主服务器，也可以是从服务器，但在复制数据之前，必须确保源已处理了所有必需的事务。</p><p>
                There are several variants of this method, the difference being in
                the manner in which data dumps and transactions from binary logs
                are transfered to the slave, as outlined here:
            </p><p style="color:blue;">此方法有多种变体，其区别在于将二进制日志中的数据转储和事务传输到从属日志的方式，如下所述：</p>
                <div class="variablelist">
                    <dl class="variablelist"><dt><span class="term">
          Data Set
</span></dt><dd>
                        <div class="orderedlist">
                            <ol class="orderedlist" type="1"><li class="listitem"><p>
                                Create a dump file using <a class="link" href="programs.html#mysqldump" title="4.5.4&nbsp;mysqldump — A Database Backup Program"><span class="command"><strong>mysqldump</strong></span></a> on
                                the source server. Set the <a class="link" href="programs.html#mysqldump" title="4.5.4&nbsp;mysqldump — A Database Backup Program"><span class="command"><strong>mysqldump</strong></span></a>
                                option <a class="link" href="programs.html#option_mysqldump_master-data"><code class="option">--master-data</code></a>
                                (with the default value of 1) to include a
                                <a class="link" href="sql-syntax.html#change-master-to" title="13.4.2.1&nbsp;CHANGE MASTER TO Syntax"><code class="literal">CHANGE MASTER TO</code></a>
                                statement with binary logging information. Set the
                                <a class="link" href="programs.html#option_mysqldump_set-gtid-purged"><code class="option">--set-gtid-purged</code></a>
                                option to <code class="literal">AUTO</code> (the default) or
                                <code class="literal">ON</code>, to include information about
                                executed transactions in the dump. Then use the
                                <a class="link" href="programs.html#mysql" title="4.5.1&nbsp;mysql — The MySQL Command-Line Client"><span class="command"><strong>mysql</strong></span></a> client to import the dump file
                                on the target server.
                            </p><p style="color:blue;">在源服务器上使用mysqldump创建转储文件。设置mysqldump选项--master data（默认值为1）以包含带有二进制日志信息的change master to语句。将--set gtid purged选项设置为auto（默认）或on，以在转储中包含有关已执行事务的信息。然后使用mysql客户机在目标服务器上导入转储文件。</p></li><li class="listitem"><p>
                                Alternatively, create a data snapshot of the source
                                server using raw data files, then copy these files to
                                the target server, following the instructions in
                                <a class="xref" href="replication.html#replication-snapshot-method" title="16.1.2.4&nbsp;Choosing a Method for Data Snapshots">Section&nbsp;16.1.2.4, “Choosing a Method for Data Snapshots”</a>. If you
                                use <a class="link" href="innodb-storage-engine.html" title="Chapter&nbsp;14&nbsp;The InnoDB Storage Engine"><code class="literal">InnoDB</code></a> tables, you can
                                use the <span class="command"><strong>mysqlbackup</strong></span> command from the
                                MySQL Enterprise Backup component to produce a
                                consistent snapshot. This command records the log name
                                and offset corresponding to the snapshot to be used on
                                the slave. MySQL Enterprise Backup is a commercial
                                product that is included as part of a MySQL Enterprise
                                subscription. See
                                <a class="xref" href="mysql-enterprise.html#mysql-enterprise-backup" title="29.2&nbsp;MySQL Enterprise Backup Overview">Section&nbsp;29.2, “MySQL Enterprise Backup Overview”</a> for detailed
                                information.
                            </p><p style="color:blue;">或者，使用原始数据文件创建源服务器的数据快照，然后按照第16.1.2.4节“选择数据快照的方法”中的说明将这些文件复制到目标服务器。如果使用innodb tables，可以使用mysql企业备份组件中的mysql backup命令生成一致的快照。此命令记录与要在从属服务器上使用的快照相对应的日志名和偏移量。mysql企业备份是作为mysql企业订阅的一部分提供的商业产品。有关详细信息，请参阅第29.2节“MySQL企业备份概述”。</p></li><li class="listitem"><p>
                                Alternatively, stop both the source and target servers,
                                copy the contents of the source's data directory to the
                                new slave's data directory, then restart the slave.
                                If you use this method, the slave must be configured for
                                GTID-based replication, in other words with
                                <a class="link" href="replication.html#sysvar_gtid_mode"><code class="literal">gtid_mode=ON</code></a>. For
                                instructions and important information for this method,
                                see
                                <a class="xref" href="replication.html#replication-howto-additionalslaves" title="16.1.2.6&nbsp;Adding Slaves to a Replication Environment">Section&nbsp;16.1.2.6, “Adding Slaves to a Replication Environment”</a>.
                            </p><p style="color:blue;">或者，停止源服务器和目标服务器，将源数据目录的内容复制到新从属数据目录，然后重新启动从属服务器。如果使用此方法，则必须将从属服务器配置为基于gtid的复制，换句话说，gtid_mode=on。有关此方法的说明和重要信息，请参阅16.1.2.6节“向复制环境添加从属”。</p></li></ol>
                        </div>
                    </dd><dt><span class="term">
          Transaction History
        </span></dt><dd><p>
                        If the source server has a complete transaction history in
                        its binary logs (that is, the GTID set
                        <code class="literal">@@GLOBAL.gtid_purged</code> is empty), you can
                        use these methods.
                    </p><p style="color:blue;">如果源服务器的二进制日志中有完整的事务历史记录（即清除的gtid set@global.gtid为空），则可以使用这些方法。</p>
                        <div class="orderedlist">
                            <ol class="orderedlist" type="1"><li class="listitem"><p>
                                Import the binary logs from the source server to the new
                                slave using <a class="link" href="programs.html#mysqlbinlog" title="4.6.7&nbsp;mysqlbinlog — Utility for Processing Binary Log Files"><span class="command"><strong>mysqlbinlog</strong></span></a>, with the
                                <a class="link" href="programs.html#option_mysqlbinlog_read-from-remote-server"><code class="option">--read-from-remote-server</code></a>
                                and
                                <a class="link" href="programs.html#option_mysqlbinlog_read-from-remote-master"><code class="option">--read-from-remote-master</code></a>
                                options.
                            </p><p style="color:blue;">使用mysqlbinlog将二进制日志从源服务器导入到新的从服务器，并带有--readfromroteserver和--readfromrotemaster选项。</p></li><li class="listitem"><p>
                                Alternatively, copy the source server's binary log files
                                to the slave. You can make copies from the slave using
                                <a class="link" href="programs.html#mysqlbinlog" title="4.6.7&nbsp;mysqlbinlog — Utility for Processing Binary Log Files"><span class="command"><strong>mysqlbinlog</strong></span></a> with the
                                <a class="link" href="programs.html#option_mysqlbinlog_read-from-remote-server"><code class="option">--read-from-remote-server</code></a>
                                and <a class="link" href="programs.html#option_mysqlbinlog_raw"><code class="option">--raw</code></a> options.
                                These can be read into the slave by using
                                <a class="link" href="programs.html#mysqlbinlog" title="4.6.7&nbsp;mysqlbinlog — Utility for Processing Binary Log Files"><span class="command"><strong>mysqlbinlog</strong></span></a> <code class="literal">&gt;</code>
                                <code class="filename"><em class="replaceable"><code>file</code></em></code>
                                (without the <a class="link" href="programs.html#option_mysqlbinlog_raw"><code class="option">--raw</code></a>
                                option) to export the binary log files to SQL files,
                                then passing these files to the <a class="link" href="programs.html#mysql" title="4.5.1&nbsp;mysql — The MySQL Command-Line Client"><span class="command"><strong>mysql</strong></span></a>
                                client for processing. Ensure that all of the binary log
                                files are processed using a single
                                <a class="link" href="programs.html#mysql" title="4.5.1&nbsp;mysql — The MySQL Command-Line Client"><span class="command"><strong>mysql</strong></span></a> process, rather than multiple
                                connections. For example:
                            </p><p style="color:blue;">或者，将源服务器的二进制日志文件复制到从服务器。您可以使用mysqlbinlog和--readfromroteserver和--raw选项从从属服务器进行复制。通过使用mysqlbinlog&gt;file（不带--raw选项）将二进制日志文件导出为sql文件，然后将这些文件传递给mysql客户机进行处理，可以将这些文件读入从机。确保所有二进制日志文件都使用一个mysql进程而不是多个连接进行处理。例如：</p><pre data-lang="terminal" class="programlisting">shell&gt; <strong class="userinput"><code>mysqlbinlog copied-binlog.000001 copied-binlog.000002 | mysql -u root -p</code></strong>
</pre><p>
                                For more information, see
                                <a class="xref" href="programs.html#mysqlbinlog-backup" title="4.6.7.3&nbsp;Using mysqlbinlog to Back Up Binary Log Files">Section&nbsp;4.6.7.3, “Using mysqlbinlog to Back Up Binary Log Files”</a>.
                            </p><p style="color:blue;">有关更多信息，请参阅4.6.7.3节，“使用mysqlbinlog备份二进制日志文件”。</p></li></ol>
                        </div>
                    </dd></dl>
                </div>
                <p>
                    This method has the advantage that a new server is available
                    almost immediately; only those transactions that were committed
                    while the snapshot or dump file was being replayed still need to
                    be obtained from the existing master. This means that the
                    slave's availability is not instantanteous, but only a
                    relatively short amount of time should be required for the slave
                    to catch up with these few remaining transactions.
                </p><p style="color:blue;">此方法的优点是几乎可以立即获得新服务器；只需在快照或转储文件重播时提交的事务仍然需要从现有的主服务器获得。这意味着从机的可用性不是即时的，但只需要相对较短的时间，从机就可以赶上这几个剩余的事务。</p><p>
                Copying over binary logs to the target server in advance is
                usually faster than reading the entire transaction execution
                history from the master in real time. However, it may not always
                be feasible to move these files to the target when required, due
                to size or other considerations. The two remaining methods for
                provisioning a new slave discussed in this section use other means
                to transfer information about transactions to the new slave.
            </p><p style="color:blue;">通过二进制日志提前复制到目标服务器通常比从主服务器实时读取整个事务执行历史记录要快。但是，由于大小或其他原因，在需要时将这些文件移动到目标位置并不总是可行的。本节讨论的其余两种为新从机提供服务的方法使用其他方法将有关事务的信息传输到新从机。</p><p><a name="replication-gtids-failover-empty"></a><b>Injecting empty transactions.&nbsp;</b>
                The master's global
                <a class="link" href="replication.html#sysvar_gtid_executed"><code class="literal">gtid_executed</code></a> variable contains
                the set of all transactions executed on the master. Rather than
                copy the binary logs when taking a snapshot to provision a new
                server, you can instead note the content of
                <code class="literal">gtid_executed</code> on the server from which the
                snapshot was taken. Before adding the new server to the
                replication chain, simply commit an empty transaction on the new
                server for each transaction identifier contained in the
                master's <code class="literal">gtid_executed</code>, like this:
            </p><p style="color:blue;">注入空事务。master的全局gtid_executed变量包含在master上执行的所有事务的集合。在创建快照以配置新服务器时，您不必复制二进制日志，而是可以记录在创建快照的服务器上执行的gtid_的内容。在将新服务器添加到复制链之前，只需在新服务器上为执行的主gtid中包含的每个事务标识符提交一个空事务，如下所示：</p><pre data-lang="sql" class="programlisting">SET GTID_NEXT='aaa-bbb-ccc-ddd:N';

BEGIN;
COMMIT;

SET GTID_NEXT='AUTOMATIC';
</pre><p>
                Once all transaction identifiers have been reinstated in this way
                using empty transactions, you must flush and purge the
                slave's binary logs, as shown here, where
                <em class="replaceable"><code>N</code></em> is the nonzero suffix of the current
                binary log file name:
            </p><p style="color:blue;">使用空事务以这种方式恢复所有事务标识符后，必须刷新并清除从属的二进制日志，如图所示，其中n是当前二进制日志文件名的非零后缀：</p><pre data-lang="sql" class="programlisting">FLUSH LOGS;
PURGE BINARY LOGS TO 'master-bin.00000<em class="replaceable"><code>N</code></em>';
</pre><p>
                You should do this to prevent this server from flooding the
                replication stream with false transactions in the event that it is
                later promoted to master. (The <a class="link" href="sql-syntax.html#flush-logs"><code class="literal">FLUSH
                LOGS</code></a> statement forces the creation of a new binary log
                file; <a class="link" href="sql-syntax.html#purge-binary-logs" title="13.4.1.1&nbsp;PURGE BINARY LOGS Syntax"><code class="literal">PURGE BINARY LOGS</code></a> purges the
                empty transactions, but retains their identifiers.)
            </p><p style="color:blue;">您应该这样做，以防止此服务器在复制流稍后升级为master时用错误事务淹没复制流。（flush logs语句强制创建新的二进制日志文件；purge binary logs清除空事务，但保留其标识符。）</p><p>
                This method creates a server that is essentially a snapshot, but
                in time is able to become a master as its binary log history
                converges with that of the replication stream (that is, as it
                catches up with the master or masters). This outcome is similar in
                effect to that obtained using the remaining provisioning method,
                which we discuss in the next few paragraphs.
            </p><p style="color:blue;">此方法创建的服务器本质上是快照，但随着其二进制日志历史与复制流的日志历史（即，当它赶上一个或多个主服务器时）的收敛，它最终能够成为主服务器。这个结果实际上类似于使用剩余的供应方法获得的结果，我们将在接下来的几段中讨论这个方法。</p><p><a name="replication-gtids-failover-gtid-purged"></a><b>Excluding transactions with gtid_purged.&nbsp;</b>
                The master's global
                <a class="link" href="replication.html#sysvar_gtid_purged"><code class="literal">gtid_purged</code></a> variable contains
                the set of all transactions that have been purged from the
                master's binary log. As with the method discussed
                previously (see
                <a class="xref" href="replication.html#replication-gtids-failover-empty" title="Injecting empty transactions">Injecting empty transactions</a>), you can
                record the value of
                <a class="link" href="replication.html#sysvar_gtid_executed"><code class="literal">gtid_executed</code></a> on the server
                from which the snapshot was taken (in place of copying the
                binary logs to the new server). Unlike the previous method,
                there is no need to commit empty transactions (or to issue
                <a class="link" href="sql-syntax.html#purge-binary-logs" title="13.4.1.1&nbsp;PURGE BINARY LOGS Syntax"><code class="literal">PURGE BINARY LOGS</code></a>); instead, you
                can set <a class="link" href="replication.html#sysvar_gtid_purged"><code class="literal">gtid_purged</code></a> on the
                slave directly, based on the value of
                <a class="link" href="replication.html#sysvar_gtid_executed"><code class="literal">gtid_executed</code></a> on the server
                from which the backup or snapshot was taken.
            </p><p style="color:blue;">不包括已清除GTID的事务。master的global gtid_purged变量包含从master的二进制日志中清除的所有事务的集合。与前面讨论的方法（请参阅注入空事务）一样，您可以记录在获取快照的服务器上执行的gtid_的值（代替将二进制日志复制到新服务器）。与前面的方法不同，不需要提交空事务（或发出清除二进制日志）；相反，您可以根据从服务器上执行备份或快照的gtid_的值，直接在从服务器上设置gtid_purged。</p><p>
                As with the method using empty transactions, this method creates a
                server that is functionally a snapshot, but in time is able to
                become a master as its binary log history converges with that of
                the replication master or group.
            </p><p style="color:blue;">与使用空事务的方法一样，此方法创建的服务器在功能上是一个快照，但随着其二进制日志历史与复制主机或组的日志历史聚合，它可以及时成为主机。</p><p><a name="replication-gtids-restoring-mysqlbinlog"></a><b>Restoring GTID mode slaves.&nbsp;</b>
                When restoring a slave in a GTID based replication setup that
                has encountered an error, injecting an empty transaction may not
                solve the problem because an event does not have a GTID.
            </p><p style="color:blue;">正在还原gtid模式从机。在基于gtid的复制设置中还原遇到错误的从属服务器时，注入空事务可能无法解决问题，因为事件没有gtid。</p><p>
                Use <a class="link" href="programs.html#mysqlbinlog" title="4.6.7&nbsp;mysqlbinlog — Utility for Processing Binary Log Files"><span class="command"><strong>mysqlbinlog</strong></span></a> to find the next transaction,
                which is probably the first transaction in the next log file after
                the event. Copy everything up to the <code class="literal">COMMIT</code> for
                that transaction, being sure to include the <code class="literal">SET
                @@SESSION.GTID_NEXT</code>. Even if you are not using row-based
                replication, you can still run binary log row events in the
                command line client.
            </p><p style="color:blue;">使用mysqlbinlog查找下一个事务，它可能是事件之后下一个日志文件中的第一个事务。复制该事务提交之前的所有内容，确保下一步包括set@@session.gtid。即使不使用基于行的复制，也可以在命令行客户机中运行二进制日志行事件。</p><p>
                Stop the slave and run the transaction you copied. The
                <a class="link" href="programs.html#mysqlbinlog" title="4.6.7&nbsp;mysqlbinlog — Utility for Processing Binary Log Files"><span class="command"><strong>mysqlbinlog</strong></span></a> output sets the delimiter to
                <code class="literal">/*!*/;</code>, so set it back:
            </p><p style="color:blue;">停止从机并运行复制的事务。mysqlbinlog输出将分隔符设置为/*！*/，因此请将其放回：</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>DELIMITER ;</code></strong>
</pre><p>
                Restart replication from the correct position automatically:
            </p><p style="color:blue;">自动从正确位置重新启动复制：</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>SET GTID_NEXT=automatic;</code></strong>
mysql&gt; <strong class="userinput"><code>RESET SLAVE;</code></strong>
mysql&gt; <strong class="userinput"><code>START SLAVE;</code></strong>
</pre>
            </div>
            <div class="section">
                <div class="titlepage">
                    <div>
                        <div>
                            <h4 class="title"><a name="replication-gtids-restrictions"></a>16.1.3.6&nbsp;Restrictions on Replication with GTIDs</h4>

                        </div>

                    </div>

                </div>
                <a class="indexterm" name="idm140286801307440"></a><p>
                Because GTID-based replication is dependent on transactions, some
                features otherwise available in MySQL are not supported when using
                it. This section provides information about restrictions on and
                limitations of replication with GTIDs.
            </p><p style="color:blue;">由于基于gtid的复制依赖于事务，因此使用它时不支持mysql中其他可用功能。本节提供有关gtid复制的限制和限制的信息。</p><p><b>Updates involving nontransactional storage engines.&nbsp;</b>
                When using GTIDs, updates to tables using nontransactional
                storage engines such as <a class="link" href="storage-engines.html#myisam-storage-engine" title="15.2&nbsp;The MyISAM Storage Engine"><code class="literal">MyISAM</code></a>
                cannot be made in the same statement or transaction as updates
                to tables using transactional storage engines such as
                <a class="link" href="innodb-storage-engine.html" title="Chapter&nbsp;14&nbsp;The InnoDB Storage Engine"><code class="literal">InnoDB</code></a>.
            </p><p style="color:blue;">涉及非事务性存储引擎的更新。使用gtid时，使用非事务性存储引擎（如myisam）对表的更新不能与使用事务性存储引擎（如innodb）对表的更新在同一语句或事务中进行。</p><p>
                This restriction is due to the fact that updates to tables that
                use a nontransactional storage engine mixed with updates to tables
                that use a transactional storage engine within the same
                transaction can result in multiple GTIDs being assigned to the
                same transaction.
            </p><p style="color:blue;">此限制是由于对使用非事务性存储引擎的表的更新与对在同一事务中使用事务性存储引擎的表的更新混合在一起会导致将多个gtid分配给同一事务。</p><p>
                Such problems can also occur when the master and the slave use
                different storage engines for their respective versions of the
                same table, where one storage engine is transactional and the
                other is not. Also be aware that triggers that are defined to
                operate on nontransactional tables can be the cause of these
                problems.
            </p><p style="color:blue;">当主服务器和从服务器对同一表的不同版本使用不同的存储引擎时，也会出现这种问题，其中一个存储引擎是事务性的，而另一个不是事务性的。还要注意，定义为在非事务表上操作的触发器可能是这些问题的原因。</p><p>
                In any of the cases just mentioned, the one-to-one correspondence
                between transactions and GTIDs is broken, with the result that
                GTID-based replication cannot function correctly.
            </p><p style="color:blue;">在刚才提到的任何一种情况下，事务和gtid之间的一对一对应关系都会中断，从而导致基于gtid的复制无法正常工作。</p><p><b>CREATE TABLE ... SELECT statements.&nbsp;</b>
                <a class="link" href="sql-syntax.html#create-table-select" title="13.1.18.5&nbsp;CREATE TABLE ... SELECT Syntax"><code class="literal">CREATE
                    TABLE ... SELECT</code></a> statements are not allowed when using
                GTID-based replication. When
                <a class="link" href="replication.html#sysvar_binlog_format"><code class="literal">binlog_format</code></a> is set to
                STATEMENT, a <code class="literal">CREATE TABLE ... SELECT</code>
                statement is recorded in the binary log as one transaction with
                one GTID, but if ROW format is used, the statement is recorded
                as two transactions with two GTIDs. If a master used STATEMENT
                format and a slave used ROW format, the slave would be unable to
                handle the transaction correctly, therefore the <code class="literal">CREATE
                    TABLE ... SELECT</code> statement is disallowed with GTIDs to
                prevent this scenario.
            </p><p style="color:blue;">创建表…选择语句。创建表…使用基于gtid的复制时不允许使用select语句。当binlog_format设置为statement时，创建表…select语句在二进制日志中记录为具有一个gtid的一个事务，但如果使用行格式，则该语句记录为具有两个gtid的两个事务。如果主用语句格式和从用行格式，从用将无法正确处理事务，因此创建表…GTID不允许使用SELECT语句来防止出现这种情况。</p><p><b>Temporary tables.&nbsp;</b>
                <a class="link" href="sql-syntax.html#create-table" title="13.1.18&nbsp;CREATE TABLE Syntax"><code class="literal">CREATE TEMPORARY
                    TABLE</code></a> and
                <a class="link" href="sql-syntax.html#drop-table" title="13.1.29&nbsp;DROP TABLE Syntax"><code class="literal">DROP TEMPORARY
                    TABLE</code></a> statements are not supported inside
                transactions, procedures, functions, and triggers when using
                GTIDs (that is, when the
                <a class="link" href="replication.html#sysvar_enforce_gtid_consistency"><code class="literal">enforce_gtid_consistency</code></a> system
                variable is set to <code class="literal">ON</code>). It is possible to use
                these statements with GTIDs enabled, but only outside of any
                transaction, and only with
                <a class="link" href="server-administration.html#sysvar_autocommit"><code class="literal">autocommit=1</code></a>.
            </p><p style="color:blue;">临时表。使用gtid时（即，当enforce-gtid-consistency系统变量设置为on时），事务、过程、函数和触发器中不支持create-temporary table和drop-temporary table语句。可以在启用gtid的情况下使用这些语句，但只能在任何事务之外使用，并且只能在autocommit=1的情况下使用。</p><p><b>Preventing execution of unsupported statements.&nbsp;</b>
                To prevent execution of statements that would cause GTID-based
                replication to fail, all servers must be started with the
                <a class="link" href="replication.html#sysvar_enforce_gtid_consistency"><code class="option">--enforce-gtid-consistency</code></a> option
                when enabling GTIDs. This causes statements of any of the types
                discussed previously in this section to fail with an error.
            </p><p style="color:blue;">阻止执行不受支持的语句。为了防止执行会导致基于gtid的复制失败的语句，在启用gtid时，所有服务器都必须使用--enforce gtid consistence选项启动。这会导致本节前面讨论的任何类型的语句失败并出现错误。</p><p>
                Note that
                <a class="link" href="replication.html#sysvar_enforce_gtid_consistency"><code class="option">--enforce-gtid-consistency</code></a> only
                takes effect if binary logging takes place for a statement. If
                binary logging is disabled on the server, or if statements are not
                written to the binary log because they are removed by a filter,
                GTID consistency is not checked or enforced for the statements
                that are not logged.
            </p><p style="color:blue;">注意--强制gtid一致性仅在对语句进行二进制日志记录时生效。如果服务器上禁用了二进制日志记录，或者如果语句由于被筛选器删除而未写入二进制日志，则不会对未记录的语句检查或强制执行gtid一致性。</p><p>
                For information about other required startup options when enabling
                GTIDs, see <a class="xref" href="replication.html#replication-gtids-howto" title="16.1.3.4&nbsp;Setting Up Replication Using GTIDs">Section&nbsp;16.1.3.4, “Setting Up Replication Using GTIDs”</a>.
            </p><p style="color:blue;">有关启用gtid时所需的其他启动选项的信息，请参阅第16.1.3.4节“使用gtid设置复制”。</p><p><b>Skipping transactions.&nbsp;</b>
                <a class="link" href="replication.html#sysvar_sql_slave_skip_counter"><code class="literal">sql_slave_skip_counter</code></a> is not
                supported when using GTIDs. If you need to skip transactions,
                use the value of the master's
                <a class="link" href="replication.html#sysvar_gtid_executed"><code class="literal">gtid_executed</code></a> variable instead;
                see <a class="xref" href="replication.html#replication-gtids-failover-empty" title="Injecting empty transactions">Injecting empty transactions</a>, for more
                information.
            </p><p style="color:blue;">正在跳过事务。使用gtid时不支持sql_slave_skip_计数器。如果需要跳过事务，请改用master的gtid_executed变量的值；有关详细信息，请参阅注入空事务。</p><p><b>Ignoring servers.&nbsp;</b>
                The IGNORE_SERVER_IDS option of the <a class="link" href="sql-syntax.html#change-master-to" title="13.4.2.1&nbsp;CHANGE MASTER TO Syntax"><code class="literal">CHANGE
                    MASTER TO</code></a> statement is deprecated when using GTIDs,
                because transactions that have already been applied are
                automatically ignored. Before starting GTID-based replication,
                check for and clear all ignored server ID lists that have
                previously been set on the servers involved. The
                <a class="link" href="sql-syntax.html#show-slave-status" title="13.7.5.34&nbsp;SHOW SLAVE STATUS Syntax"><code class="literal">SHOW SLAVE STATUS</code></a> statement,
                which can be issued for individual channels, displays the list
                of ignored server IDs if there is one. If there is no list, the
                <code class="literal">Replicate_Ignore_Server_Ids</code> field is blank.
            </p><p style="color:blue;">忽略服务器。在使用gtid时，不推荐使用change master to语句的ignore_server_ids选项，因为已经应用的事务将被自动忽略。在启动基于gtid的复制之前，请检查并清除以前在相关服务器上设置的所有忽略的服务器id列表。show slave status语句可以为单个通道发出，它显示忽略的服务器id列表（如果有）。如果没有列表，则replicate_ignore_server_ids字段为空。</p><p><a name="replication-gtids-restrictions-mysqldump"></a><b>GTID mode and mysqldump.&nbsp;</b>
                It is possible to import a dump made using
                <a class="link" href="programs.html#mysqldump" title="4.5.4&nbsp;mysqldump — A Database Backup Program"><span class="command"><strong>mysqldump</strong></span></a> into a MySQL server running with
                GTID mode enabled, provided that there are no GTIDs in the
                target server's binary log.
            </p><p style="color:blue;">gtid模式和mysqldump。如果目标服务器的二进制日志中没有gtid，则可以将使用mysql dump生成的转储导入到启用了gtid模式的mysql服务器中。</p><p><a name="replication-gtids-restrictions-mysql_upgrade"></a><b>GTID mode and mysql_upgrade.&nbsp;</b>
                When the server is running with global transaction identifiers
                (GTIDs) enabled (<a class="link" href="replication.html#sysvar_gtid_mode"><code class="literal">gtid_mode=ON</code></a>),
                do not enable binary logging by <a class="link" href="programs.html#mysql-upgrade" title="4.4.7&nbsp;mysql_upgrade — Check and Upgrade MySQL Tables"><span class="command"><strong>mysql_upgrade</strong></span></a>
                (the <a class="link" href="programs.html#option_mysql_upgrade_write-binlog"><code class="option">--write-binlog</code></a>
                option).
            </p><p style="color:blue;">gtid模式和mysql_升级。当服务器在启用全局事务标识符（gtid）的情况下运行（gtid_mode=on）时，不要通过mysql_upgrade启用二进制日志记录（--write binlog选项）。</p>
            </div>
            <div class="section">
                <div class="titlepage">
                    <div>
                        <div>
                            <h4 class="title"><a name="replication-gtids-functions"></a>16.1.3.7&nbsp;Stored Function Examples to Manipulate GTIDs</h4>

                        </div>

                    </div>

                </div>
                <p>
                    MySQL includes some built-in (native) functions for use with
                    GTID-based replication. These functions are as follows:
                </p><p style="color:blue;">mysql包含一些内置（本机）函数，用于基于gtid的复制。这些功能如下：</p>
                <div class="variablelist">
                    <dl class="variablelist"><dt><span class="term">
          <code class="function">GTID_SUBSET(<em class="replaceable"><code>set1</code></em>,<em class="replaceable"><code>set2</code></em>)</code>
        </span></dt><dd><p>
                        Given two sets of global transaction identifiers
                        <em class="replaceable"><code>set1</code></em> and
                        <em class="replaceable"><code>set2</code></em>, returns true if all GTIDs
                        in <em class="replaceable"><code>set1</code></em> are also in
                        <em class="replaceable"><code>set2</code></em>. Returns false otherwise.
                    </p><p style="color:blue;">给定两组全局事务标识符set1和set2，如果set1中的所有gtid也在set2中，则返回true。否则返回false。</p></dd><dt><span class="term">
          <code class="function">GTID_SUBTRACT(<em class="replaceable"><code>set1</code></em>,<em class="replaceable"><code>set2</code></em>)</code>
        </span></dt><dd><p>
                        Given two sets of global transaction identifiers
                        <em class="replaceable"><code>set1</code></em> and
                        <em class="replaceable"><code>set2</code></em>, returns only those GTIDs
                        from <em class="replaceable"><code>set1</code></em> that are not in
                        <em class="replaceable"><code>set2</code></em>.
                    </p><p style="color:blue;">给定两组全局事务标识符set1和set2，只返回set1中不在set2中的那些gtid。</p></dd><dt><span class="term">
          <code class="function">WAIT_FOR_EXECUTED_GTID_SET(<em class="replaceable"><code>gtid_set</code></em>[,
          <em class="replaceable"><code>timeout</code></em>])</code>
        </span></dt><dd><p>
                        Wait until the server has applied all of the transactions
                        whose global transaction identifiers are contained in
                        <em class="replaceable"><code>gtid_set</code></em>. The optional timeout
                        stops the function from waiting after the specified number
                        of seconds have elapsed.
                    </p><p style="color:blue;">等待服务器应用其全局事务标识符包含在gtid_set中的所有事务。可选超时使函数在指定的秒数之后停止等待。</p></dd><dt><span class="term">
          <code class="function">WAIT_UNTIL_SQL_THREAD_AFTER_GTIDS(<em class="replaceable"><code>gtid_set</code></em>[,
          <em class="replaceable"><code>timeout</code></em>][,<em class="replaceable"><code>channel</code></em>])</code>
        </span></dt><dd><p>
                        Like <code class="function">WAIT_FOR_EXECUTED_GTID_SET(),</code> but
                        for a single started replication channel. Use
                        <code class="function">WAIT_FOR_EXECUTED_GTID_SET()</code> instead to
                        ensure all channels are covered in all states.
                    </p><p style="color:blue;">类似于wait_for_executed_gtid_set（），但对于单个启动的复制通道。使用wait_for_executed_gtid_set（）来确保所有状态下都覆盖所有通道。</p></dd></dl>
                </div>
                <p>
                    For details of these functions, see
                    <a class="xref" href="functions.html#gtid-functions" title="12.18&nbsp;Functions Used with Global Transaction Identifiers (GTIDs)">Section&nbsp;12.18, “Functions Used with Global Transaction Identifiers (GTIDs)”</a>.
                </p><p style="color:blue;">有关这些函数的详细信息，请参阅第12.18节“与全局事务标识符（GTID）一起使用的函数”。</p><p>
                You can define your own stored functions to work with GTIDs. For
                information on defining stored functions, see
                <a class="xref" href="stored-objects.html" title="Chapter&nbsp;23&nbsp;Stored Objects">Chapter&nbsp;23, <i>Stored Objects</i></a>. The following examples show some
                useful stored functions that can be created based on the built-in
                <code class="function">GTID_SUBSET()</code> and
                <code class="function">GTID_SUBTRACT()</code> functions.
            </p><p style="color:blue;">您可以定义自己的存储函数来使用gtid。有关定义存储函数的信息，请参见第23章“存储对象”。以下示例显示了一些有用的存储函数，这些函数可以基于内置的gtid_subset（）和gtid_subtract（）函数创建。</p><p>
                Note that in these stored functions, the delimiter command has
                been used to change the MySQL statement delimiter to a vertical
                bar, as follows:

            </p><p style="color:blue;">注意，在这些存储函数中，delimiter命令用于将mysql语句分隔符更改为竖线，如下所示：</p><pre data-lang="sql" class="programlisting">mysql&gt; delimiter |</pre><p>
            </p><p>
                All of these functions take string representations of GTID sets as
                arguments, so GTID sets must always be quoted when used with them.
            </p><p style="color:blue;">所有这些函数都将gtid集的字符串表示作为参数，因此在与gtid集一起使用时，必须始终引用gtid集。</p><p>
                This function returns nonzero (true) if two GTID sets are the same
                set, even if they are not formatted in the same way.

            </p><p style="color:blue;">如果两个gtid集是同一个集，则此函数返回非零（true），即使它们的格式不相同。</p><pre data-lang="sql" class="programlisting">CREATE FUNCTION GTID_IS_EQUAL(gtid_set_1 LONGTEXT, gtid_set_2 LONGTEXT)
RETURNS INT
  RETURN GTID_SUBSET(gtid_set_1, gtid_set_2) AND GTID_SUBSET(gtid_set_2, gtid_set_1)|</pre><p>
            </p><p>
                This function returns nonzero (true) if two GTID sets are
                disjoint.

            </p><p style="color:blue;">如果两个gtid集不相交，则此函数返回非零（true）。</p><pre data-lang="sql" class="programlisting">CREATE FUNCTION GTID_IS_DISJOINT(gtid_set_1 LONGTEXT, gtid_set_2 LONGTEXT)
RETURNS INT
  RETURN GTID_SUBSET(gtid_set_1, GTID_SUBTRACT(gtid_set_1, gtid_set_2))|</pre><p>
            </p><p>
                This function returns nonzero (true) if two GTID sets are
                disjoint, and <code class="literal">sum</code> is the union of the two sets.

            </p><p style="color:blue;">如果两个gtid集不相交，且sum是两个集的并集，则此函数返回非零（true）。</p><pre data-lang="sql" class="programlisting">CREATE FUNCTION GTID_IS_DISJOINT_UNION(gtid_set_1 LONGTEXT, gtid_set_2 LONGTEXT, sum LONGTEXT)
RETURNS INT
  RETURN GTID_IS_EQUAL(GTID_SUBTRACT(sum, gtid_set_1), gtid_set_2) AND
         GTID_IS_EQUAL(GTID_SUBTRACT(sum, gtid_set_2), gtid_set_1)|</pre><p>
            </p><p>
                This function returns a normalized form of the GTID set, in all
                uppercase, with no whitespace and no duplicates. The UUIDs are
                arranged in alphabetic order and intervals are arranged in numeric
                order.

            </p><p style="color:blue;">此函数返回一个规范化格式的gtid集，全部大写，没有空格和重复项。uuid按字母顺序排列，间隔按数字顺序排列。</p><pre data-lang="sql" class="programlisting">CREATE FUNCTION GTID_NORMALIZE(g LONGTEXT)
RETURNS LONGTEXT
RETURN GTID_SUBTRACT(g, '')|</pre><p>
            </p><p>
                This function returns the union of two GTID sets.

            </p><p style="color:blue;">此函数返回两个gtid集的并集。</p><pre data-lang="sql" class="programlisting">CREATE FUNCTION GTID_UNION(gtid_set_1 LONGTEXT, gtid_set_2 LONGTEXT)
RETURNS LONGTEXT
  RETURN GTID_NORMALIZE(CONCAT(gtid_set_1, ',', gtid_set_2))|</pre><p>
            </p><p>
                This function returns the intersection of two GTID sets.

            </p><p style="color:blue;">此函数返回两个gtid集的交集。</p><pre data-lang="sql" class="programlisting">CREATE FUNCTION GTID_INTERSECTION(gtid_set_1 LONGTEXT, gtid_set_2 LONGTEXT)
RETURNS LONGTEXT
  RETURN GTID_SUBTRACT(gtid_set_1, GTID_SUBTRACT(gtid_set_1, gtid_set_2))|</pre><p>
            </p><p>
                This function returns the symmetric difference between two GTID
                sets, that is, the GTIDs that exist in
                <code class="literal">gtid_set_1</code> but not in
                <code class="literal">gtid_set_2</code>, and also the GTIDs that exist in
                <code class="literal">gtid_set_2</code> but not in
                <code class="literal">gtid_set_1</code>.

            </p><p style="color:blue;">此函数返回两个GTID集之间的对称差，即GTIDYSETIG1中存在的GTIDS，而不是GTIDYSETIG2中的GTIDS，以及GTITYSETIG2中存在的GTIDS，而不是GTIDYSETIG1中存在的GTIDS。</p><pre data-lang="sql" class="programlisting">CREATE FUNCTION GTID_SYMMETRIC_DIFFERENCE(gtid_set_1 LONGTEXT, gtid_set_2 LONGTEXT)
RETURNS LONGTEXT
  RETURN GTID_SUBTRACT(CONCAT(gtid_set_1, ',', gtid_set_2), GTID_INTERSECTION(gtid_set_1, gtid_set_2))|</pre><p>
            </p><p>
                This function removes from a GTID set all the GTIDs from a
                specified origin, and returns the remaining GTIDs, if any. The
                UUID is the identifier used by the server where the transaction
                originated, which is normally the
                <a class="link" href="replication.html#sysvar_server_uuid"><code class="literal">server_uuid</code></a> value.

            </p><p style="color:blue;">此函数从gtid集合中移除指定原点的所有gtid，并返回剩余的gtid（如果有）。uuid是发起事务的服务器使用的标识符，通常是服务器uuid值。</p><pre data-lang="sql" class="programlisting">CREATE FUNCTION GTID_SUBTRACT_UUID(gtid_set LONGTEXT, uuid TEXT)
RETURNS LONGTEXT
  RETURN GTID_SUBTRACT(gtid_set, CONCAT(UUID, ':1-', (1 &lt;&lt; 63) - 2))|</pre><p>
            </p><p>
                This function reverses the previously listed function to return
                only those GTIDs from the GTID set that originate from the server
                with the specified identifier (UUID).

            </p><p style="color:blue;">此函数反转前面列出的函数，以便仅返回来自具有指定标识符（uuid）的服务器的gtid集的gtid。</p><pre data-lang="sql" class="programlisting">CREATE FUNCTION GTID_INTERSECTION_WITH_UUID(gtid_set LONGTEXT, uuid TEXT)
RETURNS LONGTEXT
  RETURN GTID_SUBTRACT(gtid_set, GTID_SUBTRACT_UUID(gtid_set, uuid))|</pre><p>
            </p>
                <div class="example">
                    <a name="idm140286801216560"></a><p class="title"><b>Example&nbsp;16.1&nbsp;Verifying that a replication slave is up to date</b></p><p style="color:blue;">示例16.1验证复制从属服务器是否是最新的</p>
                    <div class="example-contents">
                        <p>
                            The built-in functions <code class="function">GTID_SUBSET</code> and
                            <code class="function">GTID_SUBTRACT</code> can be used to check that a
                            replication slave has applied at least every transaction that a
                            master has applied.
                        </p><p style="color:blue;">内置函数gtid_subset和gtid_subtract可用于检查复制从属服务器是否至少应用了主服务器应用的每个事务。</p><p>
                        To perform this check with <code class="function">GTID_SUBSET</code>,
                        execute the following statement on the slave:

                    </p><p style="color:blue;">要使用gtid_subset执行此检查，请在从机上执行以下语句：</p><pre data-lang="sql" class="programlisting">SELECT GTID_SUBSET(<em class="replaceable"><code>master_gtid_executed</code></em>, <em class="replaceable"><code>slave_gtid_executed</code></em>)</pre><p>

                        If this returns 0 (false), some GTIDs in
                        <em class="replaceable"><code>master_gtid_executed</code></em> are not present
                        in <em class="replaceable"><code>slave_gtid_executed</code></em>, so the master
                        has applied some transactions that the slave has not applied,
                        and the slave is therefore not up to date.
                    </p><p style="color:blue;">如果返回0（假），则执行的从设备中不存在主设备中的某些GTID，因此主设备应用了一些从设备未应用的事务，因此从设备不是最新的。</p><p>
                        To perform the check with <code class="function">GTID_SUBTRACT</code>,
                        execute the following statement on the slave:

                    </p><p style="color:blue;">要使用gtid_subtract执行检查，请在从机上执行以下语句：</p><pre data-lang="sql" class="programlisting">SELECT GTID_SUBTRACT(<em class="replaceable"><code>master_gtid_executed</code></em>, <em class="replaceable"><code>slave_gtid_executed</code></em>)</pre><p>

                        This statement returns any GTIDs that are in
                        <em class="replaceable"><code>master_gtid_executed</code></em> but not in
                        <em class="replaceable"><code>slave_gtid_executed</code></em>. If any GTIDs are
                        returned, the master has applied some transactions that the
                        slave has not applied, and the slave is therefore not up to
                        date.
                    </p><p style="color:blue;">此语句返回所有在master_gtid_executed但不在slave_gtid_executed中的gtid。如果返回了任何gtid，那么主服务器应用了一些从服务器没有应用的事务，因此从服务器不是最新的。</p>
                    </div>

                </div>
                <br class="example-break">
                <div class="example">
                    <a name="idm140286801205568"></a><p class="title"><b>Example&nbsp;16.2&nbsp;Backup and restore scenario</b></p><p style="color:blue;">示例16.2备份和恢复方案</p>
                    <div class="example-contents">
                        <p>
                            The stored functions <code class="function">GTID_IS_EQUAL</code>,
                            <code class="function">GTID_IS_DISJOINT</code>, and
                            <code class="function">GTID_IS_DISJOINT_UNION</code> could be used to
                            verify backup and restore operations involving multiple
                            databases and servers. In this example scenario,
                            <code class="literal">server1</code> contains database
                            <code class="literal">db1</code>, and <code class="literal">server2</code> contains
                            database <code class="literal">db2</code>. The goal is to copy database
                            <code class="literal">db2</code> to <code class="literal">server1</code>, and the
                            result on <code class="literal">server1</code> should be the union of the
                            two databases. The procedure used is to back up
                            <code class="literal">server2</code> using <a class="link" href="programs.html#mysqlpump" title="4.5.6&nbsp;mysqlpump — A Database Backup Program"><span class="command"><strong>mysqlpump</strong></span></a> or
                            <a class="link" href="programs.html#mysqldump" title="4.5.4&nbsp;mysqldump — A Database Backup Program"><span class="command"><strong>mysqldump</strong></span></a>, then restore this backup on
                            <code class="literal">server1</code>.
                        </p><p style="color:blue;">存储函数gtid_等于，gtid_不相交，gtid_不相交联合可用于验证涉及多个数据库和服务器的备份和还原操作。在这个示例场景中，server1包含数据库db1，server2包含数据库db2。目标是将数据库db2复制到server1，server1上的结果应该是两个数据库的联合。使用的过程是使用mysqlpump或mysqldump备份server2，然后在server1上还原此备份。</p><p>
                        Provided the backup program's option
                        <code class="option">--set-gtid-purged</code> was set to
                        <code class="literal">ON</code> or the default of <code class="literal">AUTO</code>,
                        the program's output contains a <code class="literal">SET
                        @@GLOBAL.gtid_purged</code> statement that will add the
                        <a class="link" href="replication.html#sysvar_gtid_executed"><code class="literal">gtid_executed</code></a> set from
                        <code class="literal">server2</code> to the
                        <a class="link" href="replication.html#sysvar_gtid_purged"><code class="literal">gtid_purged</code></a> set on
                        <code class="literal">server1</code>. The
                        <a class="link" href="replication.html#sysvar_gtid_purged"><code class="literal">gtid_purged</code></a> set contains the
                        GTIDs of all the transactions that have been committed on a
                        server but do not exist in any binary log file on the server.
                        When database <code class="literal">db2</code> is copied to
                        <code class="literal">server1</code>, the GTIDs of the transactions
                        committed on <code class="literal">server2</code>, which are not in the
                        binary log files on <code class="literal">server1</code>, must be added to
                        <code class="literal">server1</code>'s
                        <a class="link" href="replication.html#sysvar_gtid_purged"><code class="literal">gtid_purged</code></a> set to make the set
                        complete.
                    </p><p style="color:blue;">如果备份程序的选项set gtid purged设置为on或默认为auto，则程序的输出包含set@@global.gtid_purged语句，该语句将把从服务器2执行的gtid_集添加到服务器1上的gtid_purged集。GTIDIPUPEGUD集包含所有在服务器上提交但不存在于服务器上的任何二进制日志文件中的事务的GTIDs。将数据库db2复制到server1时，server2上提交的事务的gtid（不在server1上的二进制日志文件中）必须添加到server1的gtid_purged集，以使该集完整。</p><p>
                        The stored functions can be used to assist with the following
                        steps in this scenario:
                    </p><p style="color:blue;">在这种情况下，存储的函数可用于帮助执行以下步骤：</p>
                        <div class="itemizedlist">
                            <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                                Use <code class="function">GTID_IS_EQUAL</code> to verify that the
                                backup operation computed the correct GTID set for the
                                <code class="literal">SET @@GLOBAL.gtid_purged</code> statement. On
                                <code class="literal">server2</code>, extract that statement from the
                                <a class="link" href="programs.html#mysqlpump" title="4.5.6&nbsp;mysqlpump — A Database Backup Program"><span class="command"><strong>mysqlpump</strong></span></a> or <a class="link" href="programs.html#mysqldump" title="4.5.4&nbsp;mysqldump — A Database Backup Program"><span class="command"><strong>mysqldump</strong></span></a>
                                output, and store the GTID set into a local variable, such
                                as <code class="varname">$gtid_purged_set</code>. Then execute the
                                following statement:

                            </p><p style="color:blue;">使用gtid_等于验证备份操作是否为set@@global.gtid_清除的语句计算了正确的gtid集。在server2上，从mysqlpump或mysqldump输出中提取该语句，并将gtid集存储到一个局部变量中，例如$gtid_purged_set。然后执行以下语句：</p><pre data-lang="sql" class="programlisting">server2&gt; SELECT GTID_IS_EQUAL($gtid_purged_set, @@GLOBAL.gtid_executed); </pre><p>

                                If the result is 1, the two GTID sets are equal, and the set
                                has been computed correctly.
                            </p><p style="color:blue;">如果结果为1，则两个gtid集相等，并且已正确计算该集。</p></li><li class="listitem"><p>
                                Use <code class="function">GTID_IS_DISJOINT</code> to verify that the
                                GTID set in the <a class="link" href="programs.html#mysqlpump" title="4.5.6&nbsp;mysqlpump — A Database Backup Program"><span class="command"><strong>mysqlpump</strong></span></a> or
                                <a class="link" href="programs.html#mysqldump" title="4.5.4&nbsp;mysqldump — A Database Backup Program"><span class="command"><strong>mysqldump</strong></span></a> output does not overlap with
                                the <a class="link" href="replication.html#sysvar_gtid_executed"><code class="literal">gtid_executed</code></a> set on
                                <code class="literal">server1</code>. If there is any overlap, with
                                identical GTIDs present on both servers for some reason, you
                                will see errors when copying database <code class="literal">db2</code>
                                to <code class="literal">server1</code>. To check, on
                                <code class="literal">server1</code>, extract and store the
                                <a class="link" href="replication.html#sysvar_gtid_purged"><code class="literal">gtid_purged</code></a> set from the
                                output into a local variable as above, then execute the
                                following statement:

                            </p><p style="color:blue;">使用gtid_is_disjoint验证mysqlpump或mysqldump输出中设置的gtid是否与服务器1上执行的gtid_不重叠。如果有任何重叠，由于某种原因，两台服务器上都存在相同的gtid，那么在将数据库db2复制到server1时将看到错误。要检查，请在server1上提取gtid_purged set并将其从输出中存储到一个本地变量中，如下所示，然后执行以下语句：</p><pre data-lang="sql" class="programlisting">server1&gt; SELECT GTID_IS_DISJOINT($gtid_purged_set, @@GLOBAL.gtid_executed); </pre><p>

                                If the result is 1, there is no overlap between the two GTID
                                sets, so no duplicate GTIDs are present.
                            </p><p style="color:blue;">如果结果为1，则两个gtid集之间没有重叠，因此不存在重复的gtid。</p></li><li class="listitem"><p>
                                Use <code class="function">GTID_IS_DISJOINT_UNION</code> to verify
                                that the restore operation resulted in the correct GTID
                                state on <code class="literal">server1</code>. Before restoring the
                                backup, on <code class="literal">server1</code>, obtain the existing
                                <a class="link" href="replication.html#sysvar_gtid_executed"><code class="literal">gtid_executed</code></a> set by
                                executing the following statement:

                            </p><p style="color:blue;">使用gtid_is_disjoint_union验证还原操作是否导致服务器1上的gtid状态正确。在恢复备份之前，在Serv1上，通过执行以下语句获得现有GTIDIY执行集：</p><pre data-lang="sql" class="programlisting">server1&gt; SELECT @@GLOBAL.gtid_executed;</pre><p>

                                Store the result in a local variable
                                <code class="varname">$original_gtid_executed</code>. Also store the
                                <a class="link" href="replication.html#sysvar_gtid_purged"><code class="literal">gtid_purged</code></a> set in a local
                                variable as described above. When the backup from
                                <code class="literal">server2</code> has been restored onto
                                <code class="literal">server1</code>, execute the following statement
                                to verify the GTID state:

                            </p><p style="color:blue;">将结果存储在执行的局部变量$ORIGINAL_gtid_中。还将gtid_清除集存储在一个局部变量中，如上所述。当从server2的备份已还原到server1时，执行以下语句以验证gtid状态：</p><pre data-lang="sql" class="programlisting">server1&gt; SELECT GTID_IS_DISJOINT_UNION($original_gtid_executed,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$gtid_purged_set,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;@@GLOBAL.gtid_executed); </pre><p>

                                If the result is 1, the stored function has verified that
                                the original <a class="link" href="replication.html#sysvar_gtid_executed"><code class="literal">gtid_executed</code></a>
                                set from <code class="literal">server1</code>
                                (<code class="varname">$original_gtid_executed</code>) and the
                                <a class="link" href="replication.html#sysvar_gtid_purged"><code class="literal">gtid_purged</code></a> set that was
                                added from <code class="literal">server2</code>
                                (<code class="varname">$gtid_purged_set</code>) have no overlap, and
                                also that the updated
                                <a class="link" href="replication.html#sysvar_gtid_executed"><code class="literal">gtid_executed</code></a> set on
                                <code class="literal">server1</code> now consists of the previous
                                <a class="link" href="replication.html#sysvar_gtid_executed"><code class="literal">gtid_executed</code></a> set from
                                <code class="literal">server1</code> plus the
                                <a class="link" href="replication.html#sysvar_gtid_purged"><code class="literal">gtid_purged</code></a> set from
                                <code class="literal">server2</code>, which is the desired result.
                                Ensure that this check is carried out before any further
                                transactions take place on <code class="literal">server1</code>,
                                otherwise the new transactions in the
                                <a class="link" href="replication.html#sysvar_gtid_executed"><code class="literal">gtid_executed</code></a> set will
                                cause it to fail.
                            </p><p style="color:blue;">如果结果为1，则存储函数已验证从服务器1执行的原始gtid_执行集（$original_gtid_executed）和从服务器2添加的gtid_清除集（$gtid_pureed_set）没有重叠，而且，更新后的gtid_executed set on server1现在由先前的gtid_executed set from server1加上gtid_purged set from server2组成，这是所需的结果。确保在服务器1上执行任何进一步的事务之前执行此检查，否则gtid_executed set中的新事务将导致它失败。</p></li></ul>
                        </div>

                    </div>

                </div>
                <br class="example-break">
                <div class="example">
                    <a name="idm140286801137232"></a><p class="title"><b>Example&nbsp;16.3&nbsp;Selecting the most up-to-date slave for manual failover</b></p><p style="color:blue;">示例16.3为手动故障切换选择最新的从机</p>
                    <div class="example-contents">
                        <p>
                            The stored function <code class="function">GTID_UNION</code> could be
                            used to identify the most up-to-date replication slave from a
                            set of slaves, in order to perform a manual failover operation
                            after a replication master has stopped unexpectedly. If some of
                            the slaves are experiencing replication lag, this stored
                            function can be used to compute the most up-to-date slave
                            without waiting for all the slaves to apply their existing relay
                            logs, and therefore to minimize the failover time. The function
                            can return the union of the
                            <a class="link" href="replication.html#sysvar_gtid_executed"><code class="literal">gtid_executed</code></a> set on each slave
                            with the set of transactions received by the slave, which is
                            recorded in the Performance Schema table
                            <a class="link" href="performance-schema.html#replication-connection-status-table" title="25.12.11.2&nbsp;The replication_connection_status Table"><code class="literal">replication_connection_status</code></a>. You
                            can compare these results to find which slave's record of
                            transactions is the most up-to-date, even if not all of the
                            transactions have been committed yet.
                        </p><p style="color:blue;">存储的函数gtid_union可用于从一组从机中识别最新的复制从机，以便在复制主机意外停止后执行手动故障转移操作。如果一些奴隶正在经历复制滞后，这个存储函数可以用来计算最新的奴隶，而不必等待所有奴隶应用他们现有的中继日志，并因此使故障转移时间最小化。函数可以返回在每个从机上执行的gtid_与从机接收的事务集的并集，该事务集记录在性能模式表replication_connection_status中。您可以比较这些结果，找出哪个从机的事务记录是最新的，即使还没有提交所有事务。</p><p>
                        On each replication slave, compute the complete record of
                        transactions by issuing the following statement:

                    </p><p style="color:blue;">在每个复制从机上，通过发出以下语句计算事务的完整记录：</p><pre data-lang="sql" class="programlisting">SELECT GTID_UNION(RECEIVED_TRANSACTION_SET, @@GLOBAL.gtid_executed)
&nbsp;&nbsp;&nbsp; FROM performance_schema.replication_connection_status
&nbsp;&nbsp;&nbsp; WHERE channel_name = 'name';</pre><p>

                        You can then compare the results from each slave to see which
                        one has the most up-to-date record of transactions, and use this
                        slave as the new replication master.
                    </p><p style="color:blue;">然后，您可以比较每个从机的结果，以查看哪个具有最新的事务记录，并将此从机用作新的复制主机。</p>
                    </div>

                </div>
                <br class="example-break">
                <div class="example">
                    <a name="idm140286801129920"></a><p class="title"><b>Example&nbsp;16.4&nbsp;Checking for extraneous transactions on a replication slave</b></p><p style="color:blue;">示例16.4检查复制从机上的无关事务</p>
                    <div class="example-contents">
                        <p>
                            The stored function <code class="function">GTID_SUBTRACT_UUID</code>
                            could be used to check whether a replication slave has received
                            transactions that did not originate from its designated master
                            or masters. If it has, there might be an issue with your
                            replication setup, or with a proxy, router, or load balancer.
                            This function works by removing from a GTID set all the GTIDs
                            from a specified originating server, and returning the remaining
                            GTIDs, if any.
                        </p><p style="color:blue;">存储的函数gtid_subtract_uuid可用于检查复制从属服务器是否已接收到不是来自其指定主服务器或主服务器的事务。如果有，则可能是复制设置或代理、路由器或负载平衡器有问题。此函数通过从gtid集中移除指定的原始服务器上的所有gtid并返回剩余的gtid（如果有的话）来工作。</p><p>
                        For a replication slave with a single master, issue the
                        following statement, giving the identifier of the originating
                        replication master, which is normally the
                        <a class="link" href="replication.html#sysvar_server_uuid"><code class="literal">server_uuid</code></a> value:

                    </p><p style="color:blue;">对于具有单个主服务器的复制从属服务器，发出以下语句，给出原始复制主服务器的标识符，该标识符通常是服务器的uuid值：</p><pre data-lang="sql" class="programlisting">SELECT GTID_SUBTRACT_UUID(@@GLOBAL.gtid_executed, server_uuid_of_master);</pre><p>

                        &nbsp; If the result is not empty, the transactions returned are
                        extra transactions that did not originate from the designated
                        master.
                    </p><p style="color:blue;">如果结果不为空，则返回的事务是不是来自指定主服务器的额外事务。</p><p>
                        For a slave in a multi-master replication topology, repeat the
                        function, for example:

                    </p><p style="color:blue;">对于多主复制拓扑中的从机，请重复该功能，例如：</p><pre data-lang="sql" class="programlisting">SELECT GTID_SUBTRACT_UUID(GTID_SUBTRACT_UUID(@@GLOBAL.gtid_executed,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                       server_uuid_of_master_1),
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                        server_uuid_of_master_2);</pre><p>

                        If the result is not empty, the transactions returned are extra
                        transactions that did not originate from any of the designated
                        masters.
                    </p><p style="color:blue;">如果结果不为空，则返回的事务是不是来自任何指定主服务器的额外事务。</p>
                    </div>

                </div>
                <br class="example-break">
                <div class="example">
                    <a name="idm140286801122208"></a><p class="title"><b>Example&nbsp;16.5&nbsp;Verifying that a server in a replication topology is read-only</b></p><p style="color:blue;">示例16.5验证复制拓扑中的服务器是否为只读</p>
                    <div class="example-contents">
                        <p>
                            The stored function
                            <code class="function">GTID_INTERSECTION_WITH_UUID</code> could be used
                            to verify that a server has not originated any GTIDs and is in a
                            read-only state. The function returns only those GTIDs from the
                            GTID set that originate from the server with the specified
                            identifier. If any of the transactions in the server's
                            <a class="link" href="replication.html#sysvar_gtid_executed"><code class="literal">gtid_executed</code></a> set have the
                            server's own identifier, the server itself originated those
                            transactions. You can issue the following statement on the
                            server to check:

                        </p><p style="color:blue;">存储的函数gtid_intersection_with_uuid可用于验证服务器没有发起任何gtid并且处于只读状态。该函数只返回来自具有指定标识符的服务器的gtid集的gtid。如果服务器的gtid_executed集中的任何事务具有服务器自己的标识符，则服务器本身发起这些事务。您可以在服务器上发出以下语句进行检查：</p><pre data-lang="sql" class="programlisting">SELECT GTID_INTERSECTION_WITH_UUID(@@GLOBAL.gtid_executed, my_server_uuid);</pre><p>
                    </p>
                    </div>

                </div>
                <br class="example-break">
                <div class="example">
                    <a name="idm140286801117520"></a><p class="title"><b>Example&nbsp;16.6&nbsp;Validating an additional slave in a multi-master replication setup</b></p><p style="color:blue;">示例16.6验证多主复制设置中的附加从机</p>
                    <div class="example-contents">
                        <p>
                            The stored function
                            <code class="function">GTID_INTERSECTION_WITH_UUID</code> could be used
                            to find out if a slave attached to a multi-master replication
                            setup has applied all the transactions originating from one
                            particular master. In this scenario, <code class="literal">master1</code>
                            and <code class="literal">master2</code> are both masters and slaves and
                            replicate to each other. <code class="literal">master2</code> also has its
                            own replication slave. The replication slave will also receive
                            and apply <code class="literal">master1</code>'s transactions if
                            <code class="literal">master2</code> is configured with
                            <a class="link" href="replication.html#sysvar_log_slave_updates"><code class="literal">log_slave_updates=ON</code></a>, but it
                            will not do so if <code class="literal">master2</code> uses
                            <a class="link" href="replication.html#sysvar_log_slave_updates"><code class="literal">log_slave_updates=OFF</code></a>. Whatever
                            the case, we currently only want to find out if the replication
                            slave is up to date with <code class="literal">master2</code>. In this
                            situation, the stored function
                            <code class="function">GTID_INTERSECTION_WITH_UUID</code> can be used to
                            identify the transactions that <code class="literal">master2</code>
                            originated, discarding the transactions that
                            <code class="literal">master2</code> has replicated from
                            <code class="literal">master1</code>. The built-in function
                            <code class="function">GTID_SUBSET</code> can then be used to compare the
                            result to the <a class="link" href="replication.html#sysvar_gtid_executed"><code class="literal">gtid_executed</code></a> set
                            on the slave. If the slave is up to date with
                            <code class="literal">master2</code>, the
                            <a class="link" href="replication.html#sysvar_gtid_executed"><code class="literal">gtid_executed</code></a> set on the slave
                            contains all the transactions in the intersection set (the
                            transactions that originated from <code class="literal">master2</code>).
                        </p><p style="color:blue;">存储函数gtid_intersection_with_uuid可用于查明连接到多主复制设置的从机是否应用了来自一个特定主机的所有事务。在这个场景中，master1和master2都是master和slaves并相互复制。master2也有自己的复制从机。如果master2配置为log_slave_updates=on，复制从机也将接收并应用master1的事务，但如果master2使用log_slave_updates=off，复制从机将不会这样做。不管是什么情况，我们目前只想知道复制从机是否与master2最新。在这种情况下，存储的函数gtid_intersection_with_uuid可用于标识master2发起的事务，丢弃master2从master1复制的事务。然后，可以使用内置函数gtid_subset将结果与从机上执行的gtid_集进行比较。如果从机是master2的最新版本，则从机上执行的gtid_包含交集中的所有事务（源自master2的事务）。</p><p>
                        To carry out this check, store <code class="literal">master2</code>'s
                        <a class="link" href="replication.html#sysvar_gtid_executed"><code class="literal">gtid_executed</code></a> set,
                        <code class="literal">master2</code>'s server UUID, and the slave's
                        <a class="link" href="replication.html#sysvar_gtid_executed"><code class="literal">gtid_executed</code></a> set, into
                        client-side variables as follows:

                    </p><p style="color:blue;">要执行此检查，请将master2的gtid_executed set、master2的服务器uuid和从机的gtid_executed set存储到客户端变量中，如下所示：</p><pre data-lang="sql" class="programlisting">    $master2_gtid_executed :=
      master2&gt; SELECT @@GLOBAL.gtid_executed;
    $master2_server_uuid :=
      master2&gt; SELECT @@GLOBAL.server_uuid;
    $slave_gtid_executed :=
      slave&gt; SELECT @@GLOBAL.gtid_executed;</pre><p>

                        Then use <code class="function">GTID_INTERSECTION_WITH_UUID</code> and
                        <code class="function">GTID_SUBSET</code> with these variables as input,
                        as follows:

                    </p><p style="color:blue;">然后使用gtid_intersection_with_uuid和gtid_subset作为输入，如下所示：</p><pre data-lang="sql" class="programlisting">SELECT GTID_SUBSET(GTID_INTERSECTION_WITH_UUID($master2_gtid_executed,
                                               $master2_server_uuid),
                                               $slave_gtid_executed);</pre><p>
                    </p><p>
                        The server identifier from <code class="literal">master2</code>
                        (<code class="varname">$master2_server_uuid</code>) is used with
                        <code class="literal">GTID_INTERSECTION_WITH_UUID</code> to identify and
                        return only those GTIDs from <code class="literal">master2</code>'s
                        <a class="link" href="replication.html#sysvar_gtid_executed"><code class="literal">gtid_executed</code></a> set that
                        originated on <code class="literal">master2</code>, omitting those that
                        originated on <code class="literal">master1</code>. The resulting GTID set
                        is then compared with the set of all executed GTIDs on the
                        slave, using <code class="function">GTID_SUBSET</code>. If this statement
                        returns nonzero (true), all the identified GTIDs from
                        <code class="literal">master2</code> (the first set input) are also in the
                        slave's <a class="link" href="replication.html#sysvar_gtid_executed"><code class="literal">gtid_executed</code></a> set (the
                        second set input), meaning that the slave has replicated all the
                        transactions that originated from <code class="literal">master2</code>.
                    </p><p style="color:blue;">master2的服务器标识符（$master2_server_uuid）与gtid_intersection_和_uuid一起使用，以仅标识和返回源自master2的master2的gtid_执行集的gtid，而忽略源自master1的gtid。然后，使用gtid_子集，将得到的gtid集与从机上所有执行的gtid集进行比较。如果此语句返回非零（true），则来自master2的所有标识的gtid（第一个集合输入）也在从机的gtid_executed集合（第二个集合输入）中，这意味着从机复制了来自master2的所有事务。</p>
                    </div>

                </div>
                <br class="example-break">
            </div>

        </div>
        <div class="section">
            <div class="titlepage">
                <div>
                    <div>
                        <h3 class="title"><a name="replication-multi-source"></a>16.1.4&nbsp;MySQL Multi-Source Replication</h3>

                    </div>

                </div>

            </div>
            <div class="toc">
                <dl class="toc"><dt><span class="section"><a href="replication.html#replication-multi-source-configuration">16.1.4.1 Configuring Multi-Source Replication</a></span></dt><dt><span class="section"><a href="replication.html#replication-multi-source-provision-slave">16.1.4.2 Provisioning a Multi-Source Replication Slave for GTID-Based Replication</a></span></dt><dt><span class="section"><a href="replication.html#replication-multi-source-adding-gtid-master">16.1.4.3 Adding GTID-Based Masters to a Multi-Source Replication Slave</a></span></dt><dt><span class="section"><a href="replication.html#replication-multi-source-adding-binlog-master">16.1.4.4 Adding a Binary Log Based Master to a Multi-Source Replication Slave</a></span></dt><dt><span class="section"><a href="replication.html#replication-multi-source-start-slave">16.1.4.5 Starting Multi-Source Replication Slaves</a></span></dt><dt><span class="section"><a href="replication.html#replication-multi-source-stop-slave">16.1.4.6 Stopping Multi-Source Replication Slaves</a></span></dt><dt><span class="section"><a href="replication.html#replication-multi-source-reset-slave">16.1.4.7 Resetting Multi-Source Replication Slaves</a></span></dt><dt><span class="section"><a href="replication.html#replication-multi-source-monitoring">16.1.4.8 Multi-Source Replication Monitoring</a></span></dt></dl>
            </div>
            <a class="indexterm" name="idm140286801080400"></a><a class="indexterm" name="idm140286801079312"></a><a class="indexterm" name="idm140286801077808"></a><a class="indexterm" name="idm140286801076304"></a><p>
            MySQL multi-source replication enables a replication slave to
            receive transactions from multiple immediate masters in parallel.
            Multi-source replication can be used to back up multiple servers to
            a single server, to merge table shards, and consolidate data from
            multiple servers to a single server. Multi-source replication does
            not implement any conflict detection or resolution when applying the
            transactions, and those tasks are left to the application if
            required.
        </p><p style="color:blue;">mysql多源复制允许复制从机并行地从多个直接主机接收事务。多源复制可用于将多个服务器备份到单个服务器，合并表碎片，并将多个服务器的数据合并到单个服务器。应用事务时，多源复制不实现任何冲突检测或解决，如果需要，这些任务将留给应用程序。</p><p>
            In a multi-source replication topology, a slave creates a
            replication channel for each master that it should receive
            transactions from. For more information, see
            <a class="xref" href="replication.html#replication-channels" title="16.2.3&nbsp;Replication Channels">Section&nbsp;16.2.3, “Replication Channels”</a>. The error codes and messages
            that are issued when multi-source replication is enabled specify the
            channel that generated the error.
        </p><p style="color:blue;">在多源复制拓扑中，从服务器为其应该从中接收事务的每个主服务器创建一个复制通道。有关更多信息，请参阅第16.2.3节“复制通道”。启用多源复制时发出的错误代码和消息指定生成错误的通道。</p><p>
            This section provides tutorials on how to configure masters and
            slaves for multi-source replication, how to start, stop and reset
            multi-source slaves, and how to monitor multi-source replication.
        </p><p style="color:blue;">本节提供有关如何为多源复制配置主服务器和从服务器、如何启动、停止和重置多源从服务器以及如何监视多源复制的教程。</p>
            <div class="section">

                <div class="titlepage">
                    <div>
                        <div>
                            <h4 class="title"><a name="replication-multi-source-configuration"></a>16.1.4.1&nbsp;Configuring Multi-Source Replication</h4>
                        </div>
                    </div>
                </div>
                <a class="indexterm" name="idm140286801070672"></a><p>
                A multi-source replication topology requires at least two masters
                and one slave configured. In these tutorials, we will assume you
                have two masters <code class="literal">master1</code> and
                <code class="literal">master2</code>, and a replication slave
                <code class="literal">slavehost</code>. The slave will replicate one
                database from each of the masters, <code class="literal">db1</code> from
                <code class="literal">master1</code> and <code class="literal">db2</code> from
                <code class="literal">master2</code>.
            </p><p style="color:blue;">多源复制拓扑至少需要配置两个主节点和一个从节点。在这些教程中，我们假设您有两个master master1和master2，以及一个复制从slavehost。从服务器将从每个主服务器复制一个数据库，从master1复制db1，从master2复制db2。</p><p>
                Masters in a multi-source replication topology can be configured
                to use either GTID-based replication, or binary log position-based
                replication. See <a class="xref" href="replication.html#replication-gtids-howto" title="16.1.3.4&nbsp;Setting Up Replication Using GTIDs">Section&nbsp;16.1.3.4, “Setting Up Replication Using GTIDs”</a> for how
                to configure a master using GTID-based replication. See
                <a class="xref" href="replication.html#replication-howto-masterbaseconfig" title="16.1.2.1&nbsp;Setting the Replication Master Configuration">Section&nbsp;16.1.2.1, “Setting the Replication Master Configuration”</a> for how to
                configure a master using file position based replication.
            </p><p style="color:blue;">多源复制拓扑中的主节点可以配置为使用基于gtid的复制或基于二进制日志位置的复制。有关如何使用基于gtid的复制配置主机，请参阅16.1.3.4节“使用gtid设置复制”。有关如何使用基于文件位置的复制配置主机，请参阅第16.1.2.1节“设置复制主机配置”。</p><p>
                Slaves in a multi-source replication topology require
                <code class="literal">TABLE</code> repositories for the master info log and
                relay log info log, as specified by the
                <code class="option">--master-info-repository</code> and
                <code class="option">--relay-log-info-repository</code> options. Multi-source
                replication is not compatible with <code class="literal">FILE</code>
                repositories.
            </p><p style="color:blue;">多源复制拓扑中的从属服务器需要主信息日志和中继日志信息日志的表存储库，如--master info repository和--relay log info repository选项所指定。多源复制与文件存储库不兼容。</p><p>
                To modify an existing replication slave that is using a
                <code class="literal">FILE</code> repository for the slave status logs to
                use <code class="literal">TABLE</code> repositories, you can convert the
                existing replication repositories dynamically by using the
                <a class="link" href="programs.html#mysql" title="4.5.1&nbsp;mysql — The MySQL Command-Line Client"><span class="command"><strong>mysql</strong></span></a> client to issue the following statements
                on the slave:
            </p><p style="color:blue;">若要修改现有的复制从属文件，即使用文件存储库为从属状态日志使用表存储库，则可以使用MySQL客户端动态地转换现有复制库，以在从属文件上发布以下语句：</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>STOP SLAVE;</code></strong>
mysql&gt; <strong class="userinput"><code>SET GLOBAL master_info_repository = 'TABLE';</code></strong>
mysql&gt; <strong class="userinput"><code>SET GLOBAL relay_log_info_repository = 'TABLE';</code></strong>
</pre><p>
                Create a suitable user account on all the masters that the slave
                can use to connect. You can use the same account on all the
                masters, or a different account on each. If you create an account
                solely for the purposes of replication, that account needs only
                the <a class="link" href="security.html#priv_replication-slave"><code class="literal">REPLICATION SLAVE</code></a>
                privilege. For example, to set up a new user,
                <code class="literal">ted</code>, that can connect from the replication
                slave <code class="literal">slavehost</code>, use the
                <a class="link" href="programs.html#mysql" title="4.5.1&nbsp;mysql — The MySQL Command-Line Client"><span class="command"><strong>mysql</strong></span></a> client to issue these statements on each
                of the masters:
            </p><p style="color:blue;">在从机可用于连接的所有主机上创建适当的用户帐户。您可以对所有主控形状使用相同的帐户，或对每个主控形状使用不同的帐户。如果只为复制目的创建帐户，则该帐户只需要复制从属权限。例如，要设置一个可以从复制从slavehost连接的新用户ted，请使用mysql客户端在每个主服务器上发出以下语句：</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>CREATE USER 'ted'@'slavehost' IDENTIFIED BY '<em class="replaceable"><code>password</code></em>';</code></strong>
mysql&gt; <strong class="userinput"><code>GRANT REPLICATION SLAVE ON *.* TO 'ted'@'slavehost';</code></strong>
</pre><p>
                For more details, see <a class="xref" href="replication.html#replication-howto-repuser" title="16.1.2.2&nbsp;Creating a User for Replication">Section&nbsp;16.1.2.2, “Creating a User for Replication”</a>.
            </p><p style="color:blue;">有关更多详细信息，请参阅第16.1.2.2节“创建用于复制的用户”。</p>
            </div>
            <div class="section">
                <div class="titlepage">
                    <div>
                        <div>
                            <h4 class="title"><a name="replication-multi-source-provision-slave"></a>16.1.4.2&nbsp;Provisioning a Multi-Source Replication Slave for GTID-Based Replication</h4>

                        </div>

                    </div>

                </div>
                <a class="indexterm" name="idm140286801041936"></a><p>
                If the masters in the multi-source replication topology have
                existing data, it can save time to provision the slave with the
                relevant data before starting replication. In a multi-source
                replication topology, copying the data directory cannot be used to
                provision the slave with data from all of the masters, and you
                might also want to replicate only specific databases from each
                master. The best strategy for provisioning such a slave is
                therefore to use <a class="link" href="programs.html#mysqldump" title="4.5.4&nbsp;mysqldump — A Database Backup Program"><span class="command"><strong>mysqldump</strong></span></a> to create an
                appropriate dump file on each master, then use the
                <a class="link" href="programs.html#mysql" title="4.5.1&nbsp;mysql — The MySQL Command-Line Client"><span class="command"><strong>mysql</strong></span></a> client to import the dump file on the
                slave.
            </p><p style="color:blue;">如果多源复制拓扑中的主控器具有现有数据，则可以在开始复制之前为从属设备提供相关数据节省时间。在多源复制拓扑中，复制数据目录不能用于向从属服务器提供来自所有主服务器的数据，而且您可能还希望仅从每个主服务器复制特定的数据库。因此，提供这种从机的最佳策略是使用mysql dump在每个主机上创建适当的转储文件，然后使用mysql客户机在从机上导入转储文件。</p><p>
                If you are using GTID-based replication, you need to pay attention
                to the <code class="literal">SET @@GLOBAL.gtid_purged</code> statement that
                <a class="link" href="programs.html#mysqldump" title="4.5.4&nbsp;mysqldump — A Database Backup Program"><span class="command"><strong>mysqldump</strong></span></a> places in the dump output. This
                statement transfers the GTIDs for the transactions executed on the
                master to the slave, and the slave requires this information.
                However, for any case more complex than provisioning one new,
                empty slave from one master, you need to check what effect the
                statement will have in the slave's MySQL release, and handle the
                statement accordingly. The following guidance summarizes suitable
                actions, but for more details, see the
                <a class="link" href="programs.html#mysqldump" title="4.5.4&nbsp;mysqldump — A Database Backup Program"><span class="command"><strong>mysqldump</strong></span></a> documentation.
            </p><p style="color:blue;">如果使用基于gtid的复制，则需要注意mysqldump在转储输出中放置的set@@global.gtid戡u清除语句。此语句将在主服务器上执行的事务的gtid传输到从服务器，而从服务器需要此信息。但是，对于任何比从一个主服务器上配置一个新的空从服务器更复杂的情况，您需要检查该语句在从服务器的mysql版本中的作用，并相应地处理该语句。以下指南总结了适当的操作，但有关更多详细信息，请参阅mysqldump文档。</p><p>
                In MySQL 5.6 and 5.7, the <code class="literal">SET
                @@GLOBAL.gtid_purged</code> statement written by
                <a class="link" href="programs.html#mysqldump" title="4.5.4&nbsp;mysqldump — A Database Backup Program"><span class="command"><strong>mysqldump</strong></span></a> replaces the value of
                <a class="link" href="replication.html#sysvar_gtid_purged"><code class="literal">gtid_purged</code></a> on the slave. Also in
                those releases that value can only be changed when the slave's
                record of transactions with GTIDs (the
                <a class="link" href="replication.html#sysvar_gtid_executed"><code class="literal">gtid_executed</code></a> set) is
                empty. In a multi-source replication topology, you must therefore
                remove the <code class="literal">SET @@GLOBAL.gtid_purged</code> statement
                from the dump output before replaying the dump files, because you
                will not be able to apply a second or subsequent dump file
                including this statement. As an alternative to removing the
                <code class="literal">SET @@GLOBAL.gtid_purged</code> statement, if you are
                provisioning the slave with two partial dumps from the same
                master, and the GTID set in the second dump is the same as the
                first (so no new transactions have been executed on the master in
                between the dumps), you can set <a class="link" href="programs.html#mysqldump" title="4.5.4&nbsp;mysqldump — A Database Backup Program"><span class="command"><strong>mysqldump</strong></span></a>'s
                <code class="literal">--set-gtid-purged</code> option to
                <code class="literal">OFF</code> when you output the second dump file, to
                omit the statement.
            </p><p style="color:blue;">在mysql 5.6和5.7中，mysqldump编写的set@@global.gtid撸u purged语句替换了从机上的gtid撸u purged值。同样，在那些版本中，只有当具有gtid的从机事务记录（gtid_executed set）为空时，才能更改该值。因此，在多源复制拓扑中，在重放转储文件之前，必须从转储输出中删除set@@global.gtid_purged语句，因为您将无法应用包括此语句在内的第二个或后续转储文件。作为删除set@@global.gtid_purged语句的替代方法，如果要从同一个主转储中为从属转储设置两个部分转储，并且在第二个转储中设置的gtid与第一个转储中设置的gtid相同（因此在两个转储之间的主转储中没有执行新的事务）。在输出第二个转储文件时，可以将mysqldump的--set gtid purged选项设置为off，以省略该语句。</p><p>
                For MySQL 5.6 and 5.7, these limitations mean all the dump files
                from the masters must be applied in a single operation on a slave
                with an empty <a class="link" href="replication.html#sysvar_gtid_executed"><code class="literal">gtid_executed</code></a> set.
                You can clear a slave's GTID execution history by issuing
                <a class="link" href="sql-syntax.html#reset-master" title="13.4.1.2&nbsp;RESET MASTER Syntax"><code class="literal">RESET MASTER</code></a> on the slave, but if
                you have other, wanted transactions with GTIDs on the slave,
                choose an alternative method of provisioning from those described
                in <a class="xref" href="replication.html#replication-gtids-failover" title="16.1.3.5&nbsp;Using GTIDs for Failover and Scaleout">Section&nbsp;16.1.3.5, “Using GTIDs for Failover and Scaleout”</a>.
            </p><p style="color:blue;">对于mysql 5.6和5.7，这些限制意味着来自主服务器的所有转储文件必须在一个具有空gtid_执行集的从服务器上的单个操作中应用。您可以通过在从机上发出reset master来清除从机的gtid执行历史，但如果您在从机上有其他需要的gtid事务，请从第16.1.3.5节“使用gtid进行故障转移和扩展”中所述的方法中选择一种备用的设置方法。</p><p>
                In the following provisioning example, we assume that the
                <code class="literal">SET @@GLOBAL.gtid_purged</code> statement needs to be
                removed from the files and handled manually. We also assume that
                there are no wanted transactions with GTIDs on the slave before
                provisioning starts.
            </p><p style="color:blue;">在下面的设置示例中，我们假设需要从文件中删除set@@global.gtid戡u清除的语句并手动处理。我们还假设在配置开始之前，从机上没有需要的gtid事务。</p>
                <div class="orderedlist">
                    <ol class="orderedlist" type="1"><li class="listitem"><p>
                        To create dump files for a database named
                        <code class="literal">db1</code> on <code class="literal">master1</code> and a
                        database named <code class="literal">db2</code> on
                        <code class="literal">master2</code>, run <a class="link" href="programs.html#mysqldump" title="4.5.4&nbsp;mysqldump — A Database Backup Program"><span class="command"><strong>mysqldump</strong></span></a>
                        for <code class="literal">master1</code> as follows:
                    </p><p style="color:blue;">要为master1上名为db1的数据库和master2上名为db2的数据库创建转储文件，请运行master1上的mysqldump，如下所示：</p><pre data-lang="shell" class="programlisting"><strong class="userinput"><code>mysqldump -u&lt;<em class="replaceable"><code>user</code></em>&gt; -p&lt;<em class="replaceable"><code>password</code></em>&gt; --single-transaction --triggers --routines --set-gtid-purged=ON --databases db1 &gt; dumpM1.sql </code></strong>
</pre><p>
                        Then run <a class="link" href="programs.html#mysqldump" title="4.5.4&nbsp;mysqldump — A Database Backup Program"><span class="command"><strong>mysqldump</strong></span></a> for
                        <code class="literal">master2</code> as follows:
                    </p><p style="color:blue;">然后运行master2的mysqldump，如下所示：</p><pre data-lang="shell" class="programlisting"><strong class="userinput"><code>mysqldump -u&lt;<em class="replaceable"><code>user</code></em>&gt; -p&lt;<em class="replaceable"><code>password</code></em>&gt; --single-transaction --triggers --routines --set-gtid-purged=ON --databases db2 &gt; dumpM2.sql </code></strong>
</pre></li><li class="listitem"><p>
                        Record the <a class="link" href="replication.html#sysvar_gtid_purged"><code class="literal">gtid_purged</code></a> value
                        that <a class="link" href="programs.html#mysqldump" title="4.5.4&nbsp;mysqldump — A Database Backup Program"><span class="command"><strong>mysqldump</strong></span></a> added to each of the dump
                        files. For example, for dump files created on MySQL 5.6 or
                        5.7, you can extract the value like this:
                    </p><p style="color:blue;">记录mysqldump添加到每个转储文件的gtid_清除值。例如，对于在mysql 5.6或5.7上创建的转储文件，可以如下提取值：</p><pre data-lang="none" class="programlisting"><strong class="userinput"><code>cat dumpM1.sql | grep GTID_PURGED | cut -f2 -d'=' | cut -f2 -d$'\''</code></strong>
<strong class="userinput"><code>cat dumpM2.sql | grep GTID_PURGED | cut -f2 -d'=' | cut -f2 -d$'\'' </code></strong>
</pre><p>
                        The result in each case should be a GTID set, for example:
                    </p><p style="color:blue;">每种情况下的结果都应该是一个gtid集，例如：</p><pre data-lang="none" class="programlisting">master1:   2174B383-5441-11E8-B90A-C80AA9429562:1-1029
master2:   224DA167-0C0C-11E8-8442-00059A3C7B00:1-2695
</pre></li><li class="listitem"><p>
                        Remove the line from each dump file that contains the
                        <code class="literal">SET @@GLOBAL.gtid_purged</code> statement. For
                        example:
                    </p><p style="color:blue;">从包含set@@global.gtid\u清除语句的每个转储文件中删除该行。例如：</p><pre data-lang="shell" class="programlisting"><strong class="userinput"><code>sed '/GTID_PURGED/d' dumpM1.sql &gt; dumpM1_nopurge.sql</code></strong>
<strong class="userinput"><code>sed '/GTID_PURGED/d' dumpM2.sql &gt; dumpM2_nopurge.sql </code></strong>
</pre></li><li class="listitem"><p>
                        Use the <a class="link" href="programs.html#mysql" title="4.5.1&nbsp;mysql — The MySQL Command-Line Client"><span class="command"><strong>mysql</strong></span></a> client to import each edited
                        dump file into the slave. For example:
                    </p><p style="color:blue;">使用mysql客户机将每个编辑过的转储文件导入到从机中。例如：</p><pre data-lang="shell" class="programlisting"><strong class="userinput"><code>mysql -u&lt;<em class="replaceable"><code>user</code></em>&gt; -p&lt;<em class="replaceable"><code>password</code></em>&gt; &lt; dumpM1_nopurge.sql</code></strong>
<strong class="userinput"><code>mysql -u&lt;<em class="replaceable"><code>user</code></em>&gt; -p&lt;<em class="replaceable"><code>password</code></em>&gt; &lt; dumpM2_nopurge.sql </code></strong>
</pre></li><li class="listitem"><p>
                        On the slave, issue <a class="link" href="sql-syntax.html#reset-master" title="13.4.1.2&nbsp;RESET MASTER Syntax"><code class="literal">RESET
                        MASTER</code></a> to clear the GTID execution history
                        (assuming, as explained above, that all the dump files have
                        been imported and that there are no wanted transactions with
                        GTIDs on the slave). Then issue a <code class="literal">SET
                        @@GLOBAL.gtid_purged</code> statement to set the
                        <a class="link" href="replication.html#sysvar_gtid_purged"><code class="literal">gtid_purged</code></a> value to the
                        union of all the GTID sets from all the dump files, as you
                        recorded in Step 2. For example:
                    </p><p style="color:blue;">在从机上，发出reset master以清除gtid执行历史记录（假设如上所述，所有转储文件都已导入，并且从机上不需要gtid事务）。然后发出set@@global.gtid_purged语句，将gtid_purged值设置为所有转储文件中所有gtid集的并集，如您在步骤2中所记录的。例如：</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>RESET MASTER;</code></strong>
mysql&gt; <strong class="userinput"><code>SET @@GLOBAL.gtid_purged = "2174B383-5441-11E8-B90A-C80AA9429562:1-1029, 224DA167-0C0C-11E8-8442-00059A3C7B00:1-2695";</code></strong>
</pre><p>
                        If there are, or might be, overlapping transactions between
                        the GTID sets in the dump files, you can use the stored
                        functions described in
                        <a class="xref" href="replication.html#replication-gtids-functions" title="16.1.3.7&nbsp;Stored Function Examples to Manipulate GTIDs">Section&nbsp;16.1.3.7, “Stored Function Examples to Manipulate GTIDs”</a> to check this
                        beforehand and to calculate the union of all the GTID sets.
                    </p><p style="color:blue;">如果转储文件中的gtid集之间存在或可能存在重叠事务，则可以使用第16.1.3.7节“操作gtid的存储函数示例”中描述的存储函数预先检查此情况，并计算所有gtid集的并集。</p></li></ol>
                </div>

            </div>
            <div class="section">
                <div class="titlepage">
                    <div>
                        <div>
                            <h4 class="title"><a name="replication-multi-source-adding-gtid-master"></a>16.1.4.3&nbsp;Adding GTID-Based Masters to a Multi-Source Replication Slave</h4>

                        </div>

                    </div>

                </div>
                <a class="indexterm" name="idm140286800975760"></a><p>
                These steps assume you have enabled GTIDs for transactions on the
                masters using <a class="link" href="replication.html#sysvar_gtid_mode"><code class="literal">gtid_mode=ON</code></a>,
                created a replication user, ensured that the slave is using
                <code class="literal">TABLE</code> based replication repositories, and
                provisioned the slave with data from the masters if appropriate.
            </p><p style="color:blue;">这些步骤假设您已经使用gtid_mode=on为主服务器上的事务启用了gtid，创建了一个复制用户，确保从服务器使用基于表的复制存储库，并在适当时为从服务器提供来自主服务器的数据。</p><p>
                Use the <a class="link" href="sql-syntax.html#change-master-to" title="13.4.2.1&nbsp;CHANGE MASTER TO Syntax"><code class="literal">CHANGE MASTER TO</code></a> statement
                to configure a replication channel for each master on the
                replication slave (see <a class="xref" href="replication.html#replication-channels" title="16.2.3&nbsp;Replication Channels">Section&nbsp;16.2.3, “Replication Channels”</a>).
                The <code class="literal">FOR CHANNEL</code> clause is used to specify the
                channel. For GTID-based replication, GTID auto-positioning is used
                to synchronize with the master (see
                <a class="xref" href="replication.html#replication-gtids-auto-positioning" title="16.1.3.3&nbsp;GTID Auto-Positioning">Section&nbsp;16.1.3.3, “GTID Auto-Positioning”</a>). The
                <code class="literal">MASTER_AUTO_POSITION</code> option is set to specify
                the use of auto-positioning.
            </p><p style="color:blue;">使用change master to语句为复制从机上的每个主机配置一个复制通道（请参阅16.2.3节，“复制通道”）。for channel子句用于指定通道。对于基于gtid的复制，gtid自动定位用于与主服务器同步（参见第16.1.3.3节“gtid自动定位”）。主机自动定位选项设置为指定自动定位的使用。</p><p>
                For example, to add <code class="literal">master1</code> and
                <code class="literal">master2</code> as masters to the replication slave,
                use the <a class="link" href="programs.html#mysql" title="4.5.1&nbsp;mysql — The MySQL Command-Line Client"><span class="command"><strong>mysql</strong></span></a> client to issue the
                <a class="link" href="sql-syntax.html#change-master-to" title="13.4.2.1&nbsp;CHANGE MASTER TO Syntax"><code class="literal">CHANGE MASTER TO</code></a> statement twice on
                the slave, like this:
            </p><p style="color:blue;">例如，要将master1和master2作为主服务器添加到复制从服务器，请使用mysql客户端在从服务器上发出两次change master to语句，如下所示：</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>CHANGE MASTER TO MASTER_HOST="master1", MASTER_USER="ted", \
MASTER_PASSWORD="<em class="replaceable"><code>password</code></em>", MASTER_AUTO_POSITION=1 FOR CHANNEL "master_1";</code></strong>
mysql&gt; <strong class="userinput"><code>CHANGE MASTER TO MASTER_HOST="master2", MASTER_USER="ted", \
MASTER_PASSWORD="<em class="replaceable"><code>password</code></em>", MASTER_AUTO_POSITION=1 FOR CHANNEL "master_2";</code></strong>
</pre><p>
                For the full syntax of the <a class="link" href="sql-syntax.html#change-master-to" title="13.4.2.1&nbsp;CHANGE MASTER TO Syntax"><code class="literal">CHANGE MASTER
                TO</code></a> statement and other available options, see
                <a class="xref" href="sql-syntax.html#change-master-to" title="13.4.2.1&nbsp;CHANGE MASTER TO Syntax">Section&nbsp;13.4.2.1, “CHANGE MASTER TO Syntax”</a>.
            </p><p style="color:blue;">有关将master更改为statement的完整语法和其他可用选项，请参阅第13.4.2.1节“将master更改为syntax”。</p><p>
                To make the replication slave replicate only database
                <code class="literal">db1</code> from <code class="literal">master1</code>, and only
                database <code class="literal">db2</code> from <code class="literal">master2</code>,
                use the <a class="link" href="programs.html#mysql" title="4.5.1&nbsp;mysql — The MySQL Command-Line Client"><span class="command"><strong>mysql</strong></span></a> client to issue the
                <a class="link" href="sql-syntax.html#change-replication-filter" title="13.4.2.2&nbsp;CHANGE REPLICATION FILTER Syntax"><code class="literal">CHANGE REPLICATION FILTER</code></a> statement
                for each channel, like this:
            </p><p style="color:blue;">要使复制从机只复制master1中的数据库db1和master2中的数据库db2，请使用mysql客户端为每个通道发出change replication filter语句，如下所示：</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>CHANGE REPLICATION FILTER REPLICATE_WILD_DO_TABLE = ('db1.%') FOR CHANNEL "master_1";</code></strong>
mysql&gt; <strong class="userinput"><code>CHANGE REPLICATION FILTER REPLICATE_WILD_DO_TABLE = ('db2.%') FOR CHANNEL "master_2";</code></strong>
</pre><p>
                For the full syntax of the <a class="link" href="sql-syntax.html#change-replication-filter" title="13.4.2.2&nbsp;CHANGE REPLICATION FILTER Syntax"><code class="literal">CHANGE REPLICATION
                FILTER</code></a> statement and other available options, see
                <a class="xref" href="sql-syntax.html#change-replication-filter" title="13.4.2.2&nbsp;CHANGE REPLICATION FILTER Syntax">Section&nbsp;13.4.2.2, “CHANGE REPLICATION FILTER Syntax”</a>.
            </p><p style="color:blue;">有关change replication filter语句和其他可用选项的完整语法，请参阅第13.4.2.2节“更改复制筛选器语法”。</p>
            </div>
            <div class="section">
                <div class="titlepage">
                    <div>
                        <div>
                            <h4 class="title"><a name="replication-multi-source-adding-binlog-master"></a>16.1.4.4&nbsp;Adding a Binary Log Based Master to a Multi-Source Replication Slave</h4>

                        </div>

                    </div>

                </div>
                <a class="indexterm" name="idm140286800944528"></a><p>
                These steps assume that you have enabled binary logging on the
                master using <a class="link" href="replication.html#sysvar_log_bin"><code class="literal">--log-bin</code></a>, the slave
                is using <code class="literal">TABLE</code> based replication repositories,
                and that you have enabled a replication user and noted the current
                binary log position. You need to know the current
                <code class="literal">MASTER_LOG_FILE</code> and
                <code class="literal">MASTER_LOG_POSITION</code>.
            </p><p style="color:blue;">这些步骤假设您已经使用--log bin在主服务器上启用了二进制日志记录，从服务器使用基于表的复制存储库，并且您已经启用了复制用户并记录了当前的二进制日志位置。你需要知道当前的主日志文件和主日志位置。</p><p>
                Use the <a class="link" href="sql-syntax.html#change-master-to" title="13.4.2.1&nbsp;CHANGE MASTER TO Syntax"><code class="literal">CHANGE MASTER TO</code></a> statement
                to configure a replication channel for each master on the
                replication slave (see <a class="xref" href="replication.html#replication-channels" title="16.2.3&nbsp;Replication Channels">Section&nbsp;16.2.3, “Replication Channels”</a>).
                The <code class="literal">FOR CHANNEL</code> clause is used to specify the
                channel. For example, to add <code class="literal">master1</code> and
                <code class="literal">master2</code> as masters to the replication slave,
                use the <a class="link" href="programs.html#mysql" title="4.5.1&nbsp;mysql — The MySQL Command-Line Client"><span class="command"><strong>mysql</strong></span></a> client to issue the
                <a class="link" href="sql-syntax.html#change-master-to" title="13.4.2.1&nbsp;CHANGE MASTER TO Syntax"><code class="literal">CHANGE MASTER TO</code></a> statement
                twice on the slave, like this:
            </p><p style="color:blue;">使用change master to语句为复制从机上的每个主机配置一个复制通道（请参阅16.2.3节，“复制通道”）。for channel子句用于指定通道。例如，要将master1和master2作为主服务器添加到复制从服务器，请使用mysql客户端在从服务器上发出两次change master to语句，如下所示：</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>CHANGE MASTER TO MASTER_HOST="master1", MASTER_USER="ted", MASTER_PASSWORD="<em class="replaceable"><code>password</code></em>", \
MASTER_LOG_FILE='master1-bin.000006', MASTER_LOG_POS=628 FOR CHANNEL "master_1";</code></strong>
mysql&gt; <strong class="userinput"><code>CHANGE MASTER TO MASTER_HOST="master2", MASTER_USER="ted", MASTER_PASSWORD="<em class="replaceable"><code>password</code></em>", \
MASTER_LOG_FILE='master2-bin.000018', MASTER_LOG_POS=104 FOR CHANNEL "master_2";</code></strong>
</pre><p>
                For the full syntax of the <a class="link" href="sql-syntax.html#change-master-to" title="13.4.2.1&nbsp;CHANGE MASTER TO Syntax"><code class="literal">CHANGE MASTER
                TO</code></a> statement and other available options, see
                <a class="xref" href="sql-syntax.html#change-master-to" title="13.4.2.1&nbsp;CHANGE MASTER TO Syntax">Section&nbsp;13.4.2.1, “CHANGE MASTER TO Syntax”</a>.
            </p><p style="color:blue;">有关将master更改为statement的完整语法和其他可用选项，请参阅第13.4.2.1节“将master更改为syntax”。</p><p>
                To make the replication slave replicate only database
                <code class="literal">db1</code> from <code class="literal">master1</code>, and only
                database <code class="literal">db2</code> from <code class="literal">master2</code>,
                use the <a class="link" href="programs.html#mysql" title="4.5.1&nbsp;mysql — The MySQL Command-Line Client"><span class="command"><strong>mysql</strong></span></a> client to issue the
                <a class="link" href="sql-syntax.html#change-replication-filter" title="13.4.2.2&nbsp;CHANGE REPLICATION FILTER Syntax"><code class="literal">CHANGE REPLICATION FILTER</code></a> statement
                for each channel, like this:
            </p><p style="color:blue;">要使复制从机只复制master1中的数据库db1和master2中的数据库db2，请使用mysql客户端为每个通道发出change replication filter语句，如下所示：</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>CHANGE REPLICATION FILTER REPLICATE_WILD_DO_TABLE = ('db1.%') FOR CHANNEL "master_1";</code></strong>
mysql&gt; <strong class="userinput"><code>CHANGE REPLICATION FILTER REPLICATE_WILD_DO_TABLE = ('db2.%') FOR CHANNEL "master_2";</code></strong>
</pre><p>
                For the full syntax of the <a class="link" href="sql-syntax.html#change-replication-filter" title="13.4.2.2&nbsp;CHANGE REPLICATION FILTER Syntax"><code class="literal">CHANGE REPLICATION
                FILTER</code></a> statement and other available options, see
                <a class="xref" href="sql-syntax.html#change-replication-filter" title="13.4.2.2&nbsp;CHANGE REPLICATION FILTER Syntax">Section&nbsp;13.4.2.2, “CHANGE REPLICATION FILTER Syntax”</a>.
            </p><p style="color:blue;">有关change replication filter语句和其他可用选项的完整语法，请参阅第13.4.2.2节“更改复制筛选器语法”。</p>
            </div>
            <div class="section">
                <div class="titlepage">
                    <div>
                        <div>
                            <h4 class="title"><a name="replication-multi-source-start-slave"></a>16.1.4.5&nbsp;Starting Multi-Source Replication Slaves</h4>

                        </div>

                    </div>

                </div>
                <a class="indexterm" name="idm140286800913824"></a><p>
                Once you have added channels for all of the replication masters,
                issue a <a class="link" href="sql-syntax.html#start-slave" title="13.4.2.6&nbsp;START SLAVE Syntax"><code class="literal">START SLAVE</code></a> statement to
                start replication. When you have enabled multiple channels on a
                slave, you can choose to either start all channels, or select a
                specific channel to start. For example, to start the two channels
                separately, use the <a class="link" href="programs.html#mysql" title="4.5.1&nbsp;mysql — The MySQL Command-Line Client"><span class="command"><strong>mysql</strong></span></a> client to issue the
                following statements:
            </p><p style="color:blue;">为所有复制主机添加通道后，发出start slave语句以启动复制。在从机上启用多个通道后，可以选择启动所有通道，或选择要启动的特定通道。例如，要分别启动两个通道，请使用mysql客户端发出以下语句：</p><pre data-lang="sql" class="programlisting">
mysql&gt; <strong class="userinput"><code>START SLAVE FOR CHANNEL "master_1";</code></strong>
mysql&gt; <strong class="userinput"><code>START SLAVE FOR CHANNEL "master_2";</code></strong>
</pre><p>
                For the full syntax of the <a class="link" href="sql-syntax.html#start-slave" title="13.4.2.6&nbsp;START SLAVE Syntax"><code class="literal">START
                SLAVE</code></a> command and other available options, see
                <a class="xref" href="sql-syntax.html#start-slave" title="13.4.2.6&nbsp;START SLAVE Syntax">Section&nbsp;13.4.2.6, “START SLAVE Syntax”</a>.
            </p><p style="color:blue;">有关start slave命令和其他可用选项的完整语法，请参阅13.4.2.6节“start slave语法”。</p><p>
                To verify that both channels have started and are operating
                correctly, you can issue <a class="link" href="sql-syntax.html#show-slave-status" title="13.7.5.34&nbsp;SHOW SLAVE STATUS Syntax"><code class="literal">SHOW SLAVE
                STATUS</code></a> statements on the slave, for example:
            </p><p style="color:blue;">要验证两个通道都已启动且运行正常，可以在从机上发出show slave status语句，例如：</p><pre data-lang="sql" class="programlisting">
mysql&gt; <strong class="userinput"><code>SHOW SLAVE STATUS FOR CHANNEL "master_1"\G</code></strong>
mysql&gt; <strong class="userinput"><code>SHOW SLAVE STATUS FOR CHANNEL "master_2"\G</code></strong>
</pre>
            </div>
            <div class="section">
                <div class="titlepage">
                    <div>
                        <div>
                            <h4 class="title"><a name="replication-multi-source-stop-slave"></a>16.1.4.6&nbsp;Stopping Multi-Source Replication Slaves</h4>

                        </div>

                    </div>

                </div>
                <a class="indexterm" name="idm140286800898864"></a><p>
                The <a class="link" href="sql-syntax.html#stop-slave" title="13.4.2.7&nbsp;STOP SLAVE Syntax"><code class="literal">STOP SLAVE</code></a> statement can be
                used to stop a multi-source replication slave. By default, if you
                use the <a class="link" href="sql-syntax.html#stop-slave" title="13.4.2.7&nbsp;STOP SLAVE Syntax"><code class="literal">STOP SLAVE</code></a> statement on a
                multi-source replication slave all channels are stopped.
                Optionally, use the <code class="literal">FOR CHANNEL
                <em class="replaceable"><code>channel</code></em></code> clause to stop only a
                specific channel.
            </p><p style="color:blue;">stop slave语句可用于停止多源复制从机。默认情况下，如果在多源复制从机上使用stop slave语句，则所有通道都将停止。（可选）使用for channel channel子句仅停止特定通道。</p>
                <div class="itemizedlist">
                    <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                        To stop all currently configured replication channels:
                    </p><p style="color:blue;">要停止当前配置的所有复制通道，请执行以下操作：</p><pre data-lang="sql" class="programlisting"><strong class="userinput"><code>STOP SLAVE;</code></strong>
</pre></li><li class="listitem"><p>
                        To stop only a named channel, use a <code class="literal">FOR CHANNEL
                        <em class="replaceable"><code>channel</code></em></code> clause:
                    </p><p style="color:blue;">要仅停止命名通道，请使用for channel channel子句：</p><pre data-lang="sql" class="programlisting">
<strong class="userinput"><code>STOP SLAVE FOR CHANNEL "master_1";</code></strong>
</pre></li></ul>
                </div>
                <p>
                    For the full syntax of the <a class="link" href="sql-syntax.html#stop-slave" title="13.4.2.7&nbsp;STOP SLAVE Syntax"><code class="literal">STOP
                    SLAVE</code></a> command and other available options, see
                    <a class="xref" href="sql-syntax.html#stop-slave" title="13.4.2.7&nbsp;STOP SLAVE Syntax">Section&nbsp;13.4.2.7, “STOP SLAVE Syntax”</a>.
                </p><p style="color:blue;">有关stop slave命令和其他可用选项的完整语法，请参阅第13.4.2.7节“stop slave语法”。</p>
            </div>
            <div class="section">
                <div class="titlepage">
                    <div>
                        <div>
                            <h4 class="title"><a name="replication-multi-source-reset-slave"></a>16.1.4.7&nbsp;Resetting Multi-Source Replication Slaves</h4>

                        </div>

                    </div>

                </div>
                <a class="indexterm" name="idm140286800883216"></a><p>
                The <a class="link" href="sql-syntax.html#reset-slave" title="13.4.2.4&nbsp;RESET SLAVE Syntax"><code class="literal">RESET SLAVE</code></a> statement can be
                used to reset a multi-source replication slave. By default, if you
                use the <a class="link" href="sql-syntax.html#reset-slave" title="13.4.2.4&nbsp;RESET SLAVE Syntax"><code class="literal">RESET SLAVE</code></a> statement on a
                multi-source replication slave all channels are reset. Optionally,
                use the <code class="literal">FOR CHANNEL
                <em class="replaceable"><code>channel</code></em></code> clause to reset only
                a specific channel.
            </p><p style="color:blue;">reset slave语句可用于重置多源复制从机。默认情况下，如果在多源复制从机上使用reset slave语句，则所有通道都将重置。（可选）使用for channel channel子句仅重置特定通道。</p>
                <div class="itemizedlist">
                    <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                        To reset all currently configured replication channels:
                    </p><p style="color:blue;">要重置当前配置的所有复制通道：</p><pre data-lang="sql" class="programlisting">
<strong class="userinput"><code>RESET SLAVE;</code></strong>
</pre></li><li class="listitem"><p>
                        To reset only a named channel, use a <code class="literal">FOR CHANNEL
                        <em class="replaceable"><code>channel</code></em></code> clause:
                    </p><p style="color:blue;">要仅重置命名通道，请使用for channel channel子句：</p><pre data-lang="sql" class="programlisting"><strong class="userinput"><code>RESET SLAVE FOR CHANNEL "master_1";</code></strong>
</pre></li></ul>
                </div>
                <p>
                    For GTID-based replication, note that <a class="link" href="sql-syntax.html#reset-slave" title="13.4.2.4&nbsp;RESET SLAVE Syntax"><code class="literal">RESET
                    SLAVE</code></a> has no effect on the slave's GTID execution
                    history. If you want to clear this, issue
                    <a class="link" href="sql-syntax.html#reset-master" title="13.4.1.2&nbsp;RESET MASTER Syntax"><code class="literal">RESET MASTER</code></a> on the slave.
                </p><p style="color:blue;">对于基于gtid的复制，请注意reset slave对slave的gtid执行历史没有影响。如果要清除此问题，请在从机上发出reset master。</p><p>
                <a class="link" href="sql-syntax.html#reset-slave" title="13.4.2.4&nbsp;RESET SLAVE Syntax"><code class="literal">RESET SLAVE</code></a> makes the slave forget
                its replication position, and clears the relay log, but it does
                not change any replication connection parameters (such as the
                master host) or replication filters. If you want to remove these
                for a channel, issue <code class="literal">RESET SLAVE ALL</code>.
            </p><p style="color:blue;">reset slave使从机忘记其复制位置，并清除中继日志，但它不会更改任何复制连接参数（如主主机）或复制筛选器。如果要删除通道的这些，请发出reset slave all。</p><p>
                For the full syntax of the <a class="link" href="sql-syntax.html#reset-slave" title="13.4.2.4&nbsp;RESET SLAVE Syntax"><code class="literal">RESET
                SLAVE</code></a> command and other available options, see
                <a class="xref" href="sql-syntax.html#reset-slave" title="13.4.2.4&nbsp;RESET SLAVE Syntax">Section&nbsp;13.4.2.4, “RESET SLAVE Syntax”</a>.
            </p><p style="color:blue;">有关reset slave命令和其他可用选项的完整语法，请参见第13.4.2.4节“reset slave语法”。</p>
            </div>
            <div class="section">
                <div class="titlepage">
                    <div>
                        <div>
                            <h4 class="title"><a name="replication-multi-source-monitoring"></a>16.1.4.8&nbsp;Multi-Source Replication Monitoring</h4>

                        </div>

                    </div>

                </div>
                <a class="indexterm" name="idm140286800862128"></a><a class="indexterm" name="idm140286800860624"></a><p>
                To monitor the status of replication channels the following
                options exist:
            </p><p style="color:blue;">要监视复制通道的状态，存在以下选项：</p>
                <div class="itemizedlist">
                    <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                        Using the replication Performance Schema tables. The first
                        column of these tables is <code class="literal">Channel_Name</code>.
                        This enables you to write complex queries based on
                        <code class="literal">Channel_Name</code> as a key. See
                        <a class="xref" href="performance-schema.html#performance-schema-replication-tables" title="25.12.11&nbsp;Performance Schema Replication Tables">Section&nbsp;25.12.11, “Performance Schema Replication Tables”</a>.
                    </p><p style="color:blue;">使用复制性能架构表。这些表的第一列是channel_name。这使您能够基于通道名称作为密钥编写复杂查询。见25.12.11节，“性能模式复制表”。</p></li><li class="listitem"><p>
                        Using <code class="literal">SHOW SLAVE STATUS FOR CHANNEL
                        <em class="replaceable"><code>channel</code></em></code>. By default, if
                        the <code class="literal">FOR CHANNEL
                        <em class="replaceable"><code>channel</code></em></code> clause is not
                        used, this statement shows the slave status for all channels
                        with one row per channel. The identifier
                        <code class="literal">Channel_name</code> is added as a column in the
                        result set. If a <code class="literal">FOR CHANNEL
                        <em class="replaceable"><code>channel</code></em></code> clause is
                        provided, the results show the status of only the named
                        replication channel.
                    </p><p style="color:blue;">使用显示通道通道的从属状态。默认情况下，如果未使用for channel channel子句，则此语句显示所有通道的从属状态，每个通道一行。标识符通道名称作为列添加到结果集中。如果提供for channel channel子句，则结果仅显示命名复制通道的状态。</p></li></ul>
                </div>
                <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">
                    <div class="admon-title">
                        Note
                    </div>
                    <p>
                        The <a class="link" href="sql-syntax.html#show-variables" title="13.7.5.39&nbsp;SHOW VARIABLES Syntax"><code class="literal">SHOW VARIABLES</code></a> statement does
                        not work with multiple replication channels. The information
                        that was available through these variables has been migrated to
                        the replication performance tables. Using a
                        <a class="link" href="sql-syntax.html#show-variables" title="13.7.5.39&nbsp;SHOW VARIABLES Syntax"><code class="literal">SHOW VARIABLES</code></a> statement in a
                        topology with multiple channels shows the status of only the
                        default channel.
                    </p><p style="color:blue;">show variables语句不适用于多个复制通道。通过这些变量可用的信息已迁移到复制性能表中。在具有多个通道的拓扑中使用show variables语句仅显示默认通道的状态。</p>
                </div>
                <div class="section">
                    <div class="titlepage">
                        <div>
                            <div>
                                <h5 class="title"><a name="replication-multi-source-monitoring-tutorial"></a>16.1.4.8.1&nbsp;Monitoring Channels Using Performance Schema Tables</h5>

                            </div>

                        </div>

                    </div>
                    <a class="indexterm" name="idm140286800845440"></a><p>
                    This section explains how to use the replication Performance
                    Schema tables to monitor channels. You can choose to monitor all
                    channels, or a subset of the existing channels.
                </p><p style="color:blue;">本节说明如何使用复制性能架构表监视通道。您可以选择监视所有信道，或现有信道的子集。</p><p>
                    To monitor the connection status of all channels:
                </p><p style="color:blue;">要监视所有通道的连接状态，请执行以下操作：</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT * FROM replication_connection_status\G;</code></strong>
*************************** 1. row ***************************
CHANNEL_NAME: master_1
GROUP_NAME:
SOURCE_UUID: 046e41f8-a223-11e4-a975-0811960cc264
THREAD_ID: 24
SERVICE_STATE: ON
COUNT_RECEIVED_HEARTBEATS: 0
LAST_HEARTBEAT_TIMESTAMP: 0000-00-00 00:00:00
RECEIVED_TRANSACTION_SET: 046e41f8-a223-11e4-a975-0811960cc264:4-37
LAST_ERROR_NUMBER: 0
LAST_ERROR_MESSAGE:
LAST_ERROR_TIMESTAMP: 0000-00-00 00:00:00
*************************** 2. row ***************************
CHANNEL_NAME: master_2
GROUP_NAME:
SOURCE_UUID: 7475e474-a223-11e4-a978-0811960cc264
THREAD_ID: 26
SERVICE_STATE: ON
COUNT_RECEIVED_HEARTBEATS: 0
LAST_HEARTBEAT_TIMESTAMP: 0000-00-00 00:00:00
RECEIVED_TRANSACTION_SET: 7475e474-a223-11e4-a978-0811960cc264:4-6
LAST_ERROR_NUMBER: 0
LAST_ERROR_MESSAGE:
LAST_ERROR_TIMESTAMP: 0000-00-00 00:00:00
2 rows in set (0.00 sec)
	    </pre><p>
                    In the above output there are two channels enabled, and as shown
                    by the <code class="literal">CHANNEL_NAME</code> field they are called
                    <code class="literal">master_1</code> and <code class="literal">master_2</code>.
                </p><p style="color:blue;">在上述输出中，有两个通道被启用，如通道名称字段所示，它们被称为主机1和主机2。</p><p>
                    The addition of the <code class="literal">CHANNEL_NAME</code> field
                    enables you to query the Performance Schema tables for a
                    specific channel. To monitor the connection status of a named
                    channel, use a <code class="literal">WHERE
                    CHANNEL_NAME=<em class="replaceable"><code>channel</code></em></code>
                    clause:
                </p><p style="color:blue;">通过添加channel_name字段，您可以查询特定通道的性能架构表。要监视命名通道的连接状态，请使用where channel_name=channel子句：</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT * FROM replication_connection_status WHERE CHANNEL_NAME='master_1'\G</code></strong>
*************************** 1. row ***************************
CHANNEL_NAME: master_1
GROUP_NAME:
SOURCE_UUID: 046e41f8-a223-11e4-a975-0811960cc264
THREAD_ID: 24
SERVICE_STATE: ON
COUNT_RECEIVED_HEARTBEATS: 0
LAST_HEARTBEAT_TIMESTAMP: 0000-00-00 00:00:00
RECEIVED_TRANSACTION_SET: 046e41f8-a223-11e4-a975-0811960cc264:4-37
LAST_ERROR_NUMBER: 0
LAST_ERROR_MESSAGE:
LAST_ERROR_TIMESTAMP: 0000-00-00 00:00:00
1 row in set (0.00 sec)
</pre><p>
                    Similarly, the <code class="literal">WHERE
                    CHANNEL_NAME=<em class="replaceable"><code>channel</code></em></code> clause
                    can be used to monitor the other replication Performance Schema
                    tables for a specific channel. For more information, see
                    <a class="xref" href="performance-schema.html#performance-schema-replication-tables" title="25.12.11&nbsp;Performance Schema Replication Tables">Section&nbsp;25.12.11, “Performance Schema Replication Tables”</a>.
                </p><p style="color:blue;">类似地，where channel_name=channel子句可用于监视特定通道的其他复制性能架构表。有关更多信息，请参阅25.12.11节“性能模式复制表”。</p>
                </div>

            </div>

        </div>
        <div class="section">
            <div class="titlepage">
                <div>
                    <div>
                        <h3 class="title"><a name="replication-mode-change-online"></a>16.1.5&nbsp;Changing Replication Modes on Online Servers</h3>

                    </div>

                </div>

            </div>
            <div class="toc">
                <dl class="toc"><dt><span class="section"><a href="replication.html#replication-mode-change-online-concepts">16.1.5.1 Replication Mode Concepts</a></span></dt><dt><span class="section"><a href="replication.html#replication-mode-change-online-enable-gtids">16.1.5.2 Enabling GTID Transactions Online</a></span></dt><dt><span class="section"><a href="replication.html#replication-mode-change-online-disable-gtids">16.1.5.3 Disabling GTID Transactions Online</a></span></dt><dt><span class="section"><a href="replication.html#replication-mode-change-online-verify-transactions">16.1.5.4 Verifying Replication of Anonymous Transactions</a></span></dt></dl>
            </div>
            <a class="indexterm" name="idm140286800828560"></a><p>
            This section describes how to change the mode of replication being
            used without having to take the server offline.
        </p><p style="color:blue;">本节介绍如何更改正在使用的复制模式，而不必使服务器脱机。</p>
            <div class="section">

                <div class="titlepage">
                    <div>
                        <div>
                            <h4 class="title"><a name="replication-mode-change-online-concepts"></a>16.1.5.1&nbsp;Replication Mode Concepts</h4>
                        </div>
                    </div>
                </div>
                <a class="indexterm" name="idm140286800825808"></a><p>
                To be able to safely configure the replication mode of an online
                server it is important to understand some key concepts of
                replication. This section explains these concepts and is essential
                reading before attempting to modify the replication mode of an
                online server.
            </p><p style="color:blue;">为了能够安全地配置在线服务器的复制模式，了解复制的一些关键概念非常重要。本节解释这些概念，并在尝试修改联机服务器的复制模式之前进行必要的阅读。</p><p>
                The modes of replication available in MySQL rely on different
                techniques for identifying transactions which are logged. The
                types of transactions used by replication are as follows:
            </p><p style="color:blue;">mysql中可用的复制模式依赖于识别记录的事务的不同技术。复制使用的事务类型如下：</p>
                <div class="itemizedlist">
                    <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                        GTID transactions are identified by a global transaction
                        identifier (GTID) in the form <code class="literal">UUID:NUMBER</code>.
                        Every GTID transaction in a log is always preceded by a
                        <code class="literal">Gtid_log_event</code>. GTID transactions can be
                        addressed using either the GTID or using the file name and
                        position.
                    </p><p style="color:blue;">gtid事务由全局事务标识符（gtid）标识，格式为uuid:number。日志中的每个gtid事务总是在gtid_log_事件之前。可以使用gtid或使用文件名和位置来处理gtid事务。</p></li><li class="listitem"><p>
                        Anonymous transactions do not have a GTID assigned, and MySQL
                        ensures that every anonymous transaction in a log is preceded
                        by an <code class="literal">Anonymous_gtid_log_event</code>. In previous
                        versions, anonymous transactions were not preceded by any
                        particular event. Anonymous transactions can only be addressed
                        using file name and position.
                    </p><p style="color:blue;">匿名事务没有分配gtid，mysql确保日志中的每个匿名事务前面都有一个匿名的gtid事件。在以前的版本中，匿名事务前面没有任何特定事件。匿名事务只能使用文件名和位置寻址。</p></li></ul>
                </div>
                <p>
                    When using GTIDs you can take advantage of auto-positioning and
                    automatic fail-over, as well as use
                    <a class="link" href="functions.html#function_wait-for-executed-gtid-set"><code class="literal">WAIT_FOR_EXECUTED_GTID_SET()</code></a>,
                    <a class="link" href="server-administration.html#sysvar_session_track_gtids"><code class="literal">session_track_gtids</code></a>, and monitor
                    replicated transactions using Performance Schema tables. With
                    GTIDs enabled you cannot use
                    <a class="link" href="replication.html#sysvar_sql_slave_skip_counter"><code class="literal">sql_slave_skip_counter</code></a>, instead
                    use empty transactions.
                </p><p style="color:blue;">使用gtid时，您可以利用自动定位和自动故障转移，以及使用wait_for_executed_gtid_set（）、session_track_gtid，并使用性能架构表监视复制的事务。在启用gtid的情况下，您不能使用sql_slave_skip_计数器，而是使用空事务。</p><p>
                Transactions in a relay log that was received from a master
                running a previous version of MySQL may not be preceded by any
                particular event at all, but after being replayed and logged in
                the slave's binary log, they are preceded with an
                <code class="literal">Anonymous_gtid_log_event</code>.
            </p><p style="color:blue;">中继日志中从运行早期版本MySQL的主服务器接收的事务之前可能根本不会有任何特定事件，但在重播并记录到从服务器的二进制日志中之后，它们前面会有一个匿名的日志事件。</p><p>
                The ability to configure the replication mode online means that
                the <a class="link" href="replication.html#sysvar_gtid_mode"><code class="literal">gtid_mode</code></a> and
                <a class="link" href="replication.html#sysvar_enforce_gtid_consistency"><code class="literal">enforce_gtid_consistency</code></a>
                variables are now both dynamic and can be set from a top-level
                statement by an account that has privileges sufficient to set
                global system variables. See
                <a class="xref" href="server-administration.html#system-variable-privileges" title="5.1.8.1&nbsp;System Variable Privileges">Section&nbsp;5.1.8.1, “System Variable Privileges”</a>. In previous
                versions, both of these variables could only be configured using
                the appropriate option at server start, meaning that changes to
                the replication mode required a server restart. In all versions
                <a class="link" href="replication.html#sysvar_gtid_mode"><code class="literal">gtid_mode</code></a> could be set to
                <code class="literal">ON</code> or <code class="literal">OFF</code>, which
                corresponded to whether GTIDs were used to identify transactions
                or not. When <a class="link" href="replication.html#sysvar_gtid_mode"><code class="literal">gtid_mode=ON</code></a> it is
                not possible to replicate anonymous transactions, and when
                <a class="link" href="replication.html#sysvar_gtid_mode"><code class="literal">gtid_mode=OFF</code></a> only anonymous
                transactions can be replicated. As of MySQL 5.7.6, the
                <a class="link" href="replication.html#sysvar_gtid_mode"><code class="literal">gtid_mode</code></a> variable has two
                additional states, <code class="literal">OFF_PERMISSIVE</code> and
                <code class="literal">ON_PERMISSIVE</code>. When
                <a class="link" href="replication.html#sysvar_gtid_mode"><code class="literal">gtid_mode=OFF_PERMISSIVE</code></a> then
                <span class="emphasis"><em>new</em></span> transactions are anonymous while
                permitting replicated transactions to be either GTID or anonymous
                transactions. When
                <a class="link" href="replication.html#sysvar_gtid_mode"><code class="literal">gtid_mode=ON_PERMISSIVE</code></a> then
                <span class="emphasis"><em>new</em></span> transactions use GTIDs while permitting
                replicated transactions to be either GTID or anonymous
                transactions. This means it is possible to have a replication
                topology that has servers using both anonymous and GTID
                transactions. For example a master with
                <a class="link" href="replication.html#sysvar_gtid_mode"><code class="literal">gtid_mode=ON</code></a> could be replicating
                to a slave with
                <a class="link" href="replication.html#sysvar_gtid_mode"><code class="literal">gtid_mode=ON_PERMISSIVE</code></a>. The
                valid values for <a class="link" href="replication.html#sysvar_gtid_mode"><code class="literal">gtid_mode</code></a> are as
                follows and in this order:
            </p><p style="color:blue;">联机配置复制模式的能力意味着gtid_mode和enforce_gtid_consistency变量现在都是动态的，并且可以由具有足够权限设置全局系统变量的帐户从顶级语句进行设置。见第5.1.8.1节“系统变量特权”。在以前的版本中，这两个变量只能在服务器启动时使用适当的选项进行配置，这意味着对复制模式的更改需要重新启动服务器。在所有版本中，gtid_模式都可以设置为on或off，这与gtid是否用于标识事务相对应。当gtid_mode=on时，无法复制匿名事务；当gtid_mode=off时，只能复制匿名事务。从mysql 5.7.6开始，gtid_mode变量有两个附加状态：off_permissive和on_permissive。当gtid_mode=off_permissive时，新事务是匿名的，同时允许复制的事务是gtid或匿名事务。当gtid_mode=on_permissive时，新事务使用gtid，同时允许复制事务为gtid或匿名事务。这意味着可以有一个复制拓扑，其中的服务器同时使用匿名和gtid事务。例如，gtid_mode=on的主机可以复制到gtid_mode=on_permissive的从机。gtid_模式的有效值如下所示并按此顺序排列：</p>
                <div class="itemizedlist">
                    <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                        <code class="literal">OFF</code>
                    </p><p style="color:blue;">关闭</p></li><li class="listitem"><p>
                        <code class="literal">OFF_PERMISSIVE</code>
                    </p><p style="color:blue;">允许的</p></li><li class="listitem"><p>
                        <code class="literal">ON_PERMISSIVE</code>
                    </p><p style="color:blue;">论宽容</p></li><li class="listitem"><p>
                        <code class="literal">ON</code>
                    </p><p style="color:blue;">打开</p></li></ul>
                </div>
                <p>
                    It is important to note that the state of
                    <a class="link" href="replication.html#sysvar_gtid_mode"><code class="literal">gtid_mode</code></a> can only be changed by
                    one step at a time based on the above order. For example, if
                    <a class="link" href="replication.html#sysvar_gtid_mode"><code class="literal">gtid_mode</code></a> is currently set to
                    <code class="literal">OFF_PERMISSIVE</code>, it is possible to change to
                    <code class="literal">OFF</code> or <code class="literal">ON_PERMISSIVE</code> but not
                    to <code class="literal">ON</code>. This is to ensure that the process of
                    changing from anonymous transactions to GTID transactions online
                    is correctly handled by the server. When you switch between
                    <a class="link" href="replication.html#sysvar_gtid_mode"><code class="literal">gtid_mode=ON</code></a> and
                    <a class="link" href="replication.html#sysvar_gtid_mode"><code class="literal">gtid_mode=OFF</code></a>, the GTID state (in
                    other words the value of
                    <a class="link" href="replication.html#sysvar_gtid_executed"><code class="literal">gtid_executed</code></a>) is persistent.
                    This ensures that the GTID set that has been applied by the server
                    is always retained, regardless of changes between types of
                    <a class="link" href="replication.html#sysvar_gtid_mode"><code class="literal">gtid_mode</code></a>.
                </p><p style="color:blue;">需要注意的是，gtid_模式的状态一次只能根据上述顺序改变一步。例如，如果gtid_mode当前设置为off_permissive，则可以更改为off或on_permissive，但不能更改为on。这是为了确保服务器正确处理从匿名事务更改为gtid事务联机的过程。当您在gtid_mode=on和gtid_mode=off之间切换时，gtid状态（换句话说，gtid_executed的值）是持久的。这将确保始终保留服务器应用的gtid集，而不考虑gtid_模式类型之间的更改。</p><p>
                As part of the changes introduced by MySQL 5.7.6, the fields
                related to GTIDs have been modified so that they display the
                correct information regardless of the currently selected
                <a class="link" href="replication.html#sysvar_gtid_mode"><code class="literal">gtid_mode</code></a>. This means that fields
                which display GTID sets, such as
                <a class="link" href="replication.html#sysvar_gtid_executed"><code class="literal">gtid_executed</code></a>,
                <a class="link" href="replication.html#sysvar_gtid_purged"><code class="literal">gtid_purged</code></a>,
                <code class="literal">RECEIVED_TRANSACTION_SET</code> in the
                <a class="link" href="performance-schema.html#replication-connection-status-table" title="25.12.11.2&nbsp;The replication_connection_status Table"><code class="literal">replication_connection_status</code></a>
                Performance Schema table, and the GTID related results of
                <a class="link" href="sql-syntax.html#show-slave-status" title="13.7.5.34&nbsp;SHOW SLAVE STATUS Syntax"><code class="literal">SHOW SLAVE STATUS</code></a>, now return the
                empty string when there are no GTIDs present. Fields that display
                a single GTID, such as <code class="literal">CURRENT_TRANSACTION</code> in
                the Performance Schema
                <a class="link" href="performance-schema.html#replication-applier-status-by-worker-table" title="25.12.11.6&nbsp;The replication_applier_status_by_worker Table"><code class="literal">replication_applier_status_by_worker</code></a>
                table, now display <code class="literal">ANONYMOUS</code> when GTID
                transactions are not being used.
            </p><p style="color:blue;">作为mysql 5.7.6引入的更改的一部分，已经修改了与gtid相关的字段，以便它们显示正确的信息，而不管当前选择的gtid_模式是什么。这意味着，当不存在gtid时，显示gtid集的字段（如复制连接状态性能架构表中的gtid_executed、gtid_purged、received_transaction_set）和与gtid相关的show slave status结果将返回空字符串。当不使用gtid事务时，显示单个gtid的字段（例如performance schema replication_applier_status_by_worker表中的current_transaction）现在显示为匿名。</p><p>
                Replication from a master using
                <a class="link" href="replication.html#sysvar_gtid_mode"><code class="literal">gtid_mode=ON</code></a> provides the ability
                to use auto-positioning, configured using the <code class="literal">CHANGE
                MASTER TO MASTER_AUTO_POSITION = 1;</code> statement. The
                replication topology being used impacts on whether it is possible
                to enable auto-positioning or not, as this feature relies on GTIDs
                and is not compatible with anonymous transactions. An error is
                generated if auto-positioning is enabled and an anonymous
                transaction is encountered. It is strongly recommended to ensure
                there are no anonymous transactions remaining in the topology
                before enabling auto-positioning, see
                <a class="xref" href="replication.html#replication-mode-change-online-enable-gtids" title="16.1.5.2&nbsp;Enabling GTID Transactions Online">Section&nbsp;16.1.5.2, “Enabling GTID Transactions Online”</a>. The
                valid combinations of <a class="link" href="replication.html#sysvar_gtid_mode"><code class="literal">gtid_mode</code></a>
                and auto-positioning on master and slave are shown in the
                following table, where the master's
                <a class="link" href="replication.html#sysvar_gtid_mode"><code class="literal">gtid_mode</code></a> is shown on the
                horizontal and the slave's
                <a class="link" href="replication.html#sysvar_gtid_mode"><code class="literal">gtid_mode</code></a> is on the vertical:

            </p><p style="color:blue;">使用gtid_mode=on从主节点复制提供使用自动定位的能力，使用change master to master_auto_position=1；语句进行配置。使用的复制拓扑会影响是否可以启用自动定位，因为此功能依赖于gtid，并且与匿名事务不兼容。如果启用自动定位并遇到匿名事务，则会生成错误。强烈建议在启用自动定位之前，确保拓扑中没有剩余的匿名事务，请参阅16.1.5.2节“启用GTID事务联机”。下表显示了GTID_模式和主从机自动定位的有效组合，其中主从机的GTID_模式水平显示，从机的GTID_模式垂直显示：</p>
                <div class="table">
                    <a name="idm140286800757328"></a><p class="title"><b>Table&nbsp;16.1&nbsp;Valid Combinations of Master and Slave gtid_mode</b></p><p style="color:blue;">表16.1主/从gtid模式的有效组合</p>
                    <div class="table-contents">
                        <table><colgroup><col width="2.03%"><col width="1%"><col width="2.01%"><col width="1.92%"><col width="1.04%"></colgroup><thead><tr>
                            <th scope="col"><p>
                                Master/Slave <a class="link" href="replication.html#sysvar_gtid_mode"><code class="literal">gtid_mode</code></a>
                            </p><p style="color:blue;">主/从gtid_模式</p></th>
                            <th scope="col"><p>
                                <code class="literal">&gt;OFF</code>
                            </p><p style="color:blue;">&gt;关闭</p></th>
                            <th scope="col"><p>
                                <code class="literal">&gt;OFF_PERMISSIVE</code>
                            </p><p style="color:blue;">&gt;允许的</p></th>
                            <th scope="col"><p>
                                <code class="literal">&gt;ON_PERMISSIVE</code>
                            </p><p style="color:blue;">&gt;论宽容</p></th>
                            <th scope="col"><p>
                                <code class="literal">&gt;ON</code>
                            </p><p style="color:blue;">&gt;打开</p></th>
                        </tr></thead><tbody><tr>
                            <td scope="row"><p>
                                <code class="literal">&gt;OFF</code>
                            </p><p style="color:blue;">&gt;关闭</p></td>
                            <td><p>
                                Y
                            </p><p style="color:blue;">是的</p></td>
                            <td><p>
                                Y
                            </p><p style="color:blue;">是的</p></td>
                            <td><p>
                                N
                            </p><p style="color:blue;">n个</p></td>
                            <td><p>
                                N
                            </p><p style="color:blue;">n个</p></td>
                        </tr><tr>
                            <td scope="row"><p>
                                <code class="literal">&gt;OFF_PERMISSIVE</code>
                            </p><p style="color:blue;">&gt;允许的</p></td>
                            <td><p>
                                Y
                            </p><p style="color:blue;">是的</p></td>
                            <td><p>
                                Y
                            </p><p style="color:blue;">是的</p></td>
                            <td><p>
                                Y
                            </p><p style="color:blue;">是的</p></td>
                            <td><p>
                                Y*
                            </p><p style="color:blue;">是的*</p></td>
                        </tr><tr>
                            <td scope="row"><p>
                                <code class="literal">&gt;ON_PERMISSIVE</code>
                            </p><p style="color:blue;">&gt;论宽容</p></td>
                            <td><p>
                                Y
                            </p><p style="color:blue;">是的</p></td>
                            <td><p>
                                Y
                            </p><p style="color:blue;">是的</p></td>
                            <td><p>
                                Y
                            </p><p style="color:blue;">是的</p></td>
                            <td><p>
                                Y*
                            </p><p style="color:blue;">是的*</p></td>
                        </tr><tr>
                            <td scope="row"><p>
                                <code class="literal">&gt;ON</code>
                            </p><p style="color:blue;">&gt;打开</p></td>
                            <td><p>
                                N
                            </p><p style="color:blue;">n个</p></td>
                            <td><p>
                                N
                            </p><p style="color:blue;">n个</p></td>
                            <td><p>
                                Y
                            </p><p style="color:blue;">是的</p></td>
                            <td><p>
                                Y*
                            </p><p style="color:blue;">是的*</p></td>
                        </tr></tbody></table>
                    </div>

                </div>
                <p><br class="table-break">
                </p><p>
                In the above table, the entries are:
            </p><p style="color:blue;">在上表中，条目如下：</p>
                <div class="itemizedlist">
                    <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                        <code class="literal">Y</code>: the
                        <a class="link" href="replication.html#sysvar_gtid_mode"><code class="literal">gtid_mode</code></a> of master and slave
                        is compatible
                    </p><p style="color:blue;">Y:主从GTID_模式兼容</p></li><li class="listitem"><p>
                        <code class="literal">N</code>: the
                        <a class="link" href="replication.html#sysvar_gtid_mode"><code class="literal">gtid_mode</code></a> of master and slave
                        is not compatible
                    </p><p style="color:blue;">N:主从GTID_模式不兼容</p></li><li class="listitem"><p>
                        <code class="literal">*</code>: auto-positioning can be used
                    </p><p style="color:blue;">*：可以使用自动定位</p></li></ul>
                </div>
                <p>
                    The currently selected <a class="link" href="replication.html#sysvar_gtid_mode"><code class="literal">gtid_mode</code></a>
                    also impacts on the <a class="link" href="replication.html#sysvar_gtid_next"><code class="literal">gtid_next</code></a>
                    variable. The following table shows the behavior of the server for
                    the different values of <a class="link" href="replication.html#sysvar_gtid_mode"><code class="literal">gtid_mode</code></a>
                    and <a class="link" href="replication.html#sysvar_gtid_next"><code class="literal">gtid_next</code></a>.
                </p><p style="color:blue;">当前选择的gtid_模式也会影响gtid_下一个变量。下表显示了服务器在gtid_mode和gtid_next的不同值下的行为。</p>
                <div class="table">
                    <a name="idm140286800702160"></a><p class="title"><b>Table&nbsp;16.2&nbsp;Valid Combinations of gtid_mode and gtid_next</b></p><p style="color:blue;">表16.2 gtid_mode和gtid_next的有效组合</p>
                    <div class="table-contents">
                        <table><colgroup><col width="2.03%"><col width="1%"><col width="2.01%"><col width="1.92%"><col width="1.04%"></colgroup><thead><tr>
                            <th scope="col"><p>
                                <a class="link" href="replication.html#sysvar_gtid_next"><code class="literal">gtid_next</code></a>
                            </p><p style="color:blue;">下一个</p></th>
                            <th scope="col"><p>
                                AUTOMATIC
                            </p><p style="color:blue;">自动</p><p>
                                binary log on
                            </p><p style="color:blue;">二进制登录</p></th>
                            <th scope="col"><p>
                                AUTOMATIC
                            </p><p style="color:blue;">自动</p><p>
                                binary log off
                            </p><p style="color:blue;">二进制注销</p></th>
                            <th scope="col"><p>
                                ANONYMOUS
                            </p><p style="color:blue;">匿名的</p></th>
                            <th scope="col"><p>
                                UUID:NUMBER
                            </p><p style="color:blue;">Uuid:编号</p></th>
                        </tr></thead><tbody><tr>
                            <td scope="row"><p>
                                <code class="literal">&gt;OFF</code>
                            </p><p style="color:blue;">&gt;关闭</p></td>
                            <td><p>
                                ANONYMOUS
                            </p><p style="color:blue;">匿名的</p></td>
                            <td><p>
                                ANONYMOUS
                            </p><p style="color:blue;">匿名的</p></td>
                            <td>ANONYMOUS</td>
                            <td><p>
                                Error
                            </p><p style="color:blue;">错误</p></td>
                        </tr><tr>
                            <td scope="row"><p>
                                <code class="literal">&gt;OFF_PERMISSIVE</code>
                            </p><p style="color:blue;">&gt;允许的</p></td>
                            <td><p>
                                ANONYMOUS
                            </p><p style="color:blue;">匿名的</p></td>
                            <td><p>
                                ANONYMOUS
                            </p><p style="color:blue;">匿名的</p></td>
                            <td><p>
                                ANONYMOUS
                            </p><p style="color:blue;">匿名的</p></td>
                            <td><p>
                                UUID:NUMBER
                            </p><p style="color:blue;">Uuid:编号</p></td>
                        </tr><tr>
                            <td scope="row"><p>
                                <code class="literal">&gt;ON_PERMISSIVE</code>
                            </p><p style="color:blue;">&gt;论宽容</p></td>
                            <td><p>
                                New GTID
                            </p><p style="color:blue;">新gtid</p></td>
                            <td><p>
                                ANONYMOUS
                            </p><p style="color:blue;">匿名的</p></td>
                            <td><p>
                                ANONYMOUS
                            </p><p style="color:blue;">匿名的</p></td>
                            <td><p>
                                UUID:NUMBER
                            </p><p style="color:blue;">Uuid:编号</p></td>
                        </tr><tr>
                            <td scope="row"><p>
                                <code class="literal">&gt;ON</code>
                            </p><p style="color:blue;">&gt;打开</p></td>
                            <td><p>
                                New GTID
                            </p><p style="color:blue;">新gtid</p></td>
                            <td><p>
                                ANONYMOUS
                            </p><p style="color:blue;">匿名的</p></td>
                            <td><p>
                                Error
                            </p><p style="color:blue;">错误</p></td>
                            <td><p>
                                UUID:NUMBER
                            </p><p style="color:blue;">Uuid:编号</p></td>
                        </tr></tbody></table>
                    </div>

                </div>
                <br class="table-break"><p>
                In the above table, the entries are:
            </p><p style="color:blue;">在上表中，条目如下：</p>
                <div class="itemizedlist">
                    <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                        <code class="literal">ANONYMOUS</code>: generate an anonymous
                        transaction.
                    </p><p style="color:blue;">匿名：生成匿名事务。</p></li><li class="listitem"><p>
                        <code class="literal">Error</code>: generate an error and fail to
                        execute <code class="literal">SET GTID_NEXT</code>.
                    </p><p style="color:blue;">错误：生成错误并无法执行set gtid_next。</p></li><li class="listitem"><p>
                        <code class="literal">UUID:NUMBER</code>: generate a GTID with the
                        specified UUID:NUMBER.
                    </p><p style="color:blue;">uuid:number:生成具有指定uuid:number的gtid。</p></li><li class="listitem"><p>
                        <code class="literal">New GTID</code>: generate a GTID with an
                        automatically generated number.
                    </p><p style="color:blue;">新的gtid：用自动生成的数字生成一个gtid。</p></li></ul>
                </div>
                <p>
                    When the binary log is off and
                    <a class="link" href="replication.html#sysvar_gtid_next"><code class="literal">gtid_next</code></a> is set to
                    <code class="literal">AUTOMATIC</code>, then no GTID is generated. This is
                    consistent with the behavior of previous versions.


                </p><p style="color:blue;">当二进制日志关闭且gtid_next设置为automatic时，将不会生成gtid。这与以前版本的行为一致。</p>
            </div>
            <div class="section">
                <div class="titlepage">
                    <div>
                        <div>
                            <h4 class="title"><a name="replication-mode-change-online-enable-gtids"></a>16.1.5.2&nbsp;Enabling GTID Transactions Online</h4>

                        </div>

                    </div>

                </div>
                <a class="indexterm" name="idm140286800650176"></a><p>
                This section describes how to enable GTID transactions, and
                optionally auto-positioning, on servers that are already online
                and using anonymous transactions. This procedure does not require
                taking the server offline and is suited to use in production.
                However, if you have the possibility to take the servers offline
                when enabling GTID transactions that process is easier.
            </p><p style="color:blue;">本节介绍如何在已经联机并使用匿名事务的服务器上启用gtid事务和可选的自动定位。此过程不需要使服务器脱机，适合在生产中使用。但是，如果在启用gtid事务时有可能使服务器脱机，则处理起来会更容易。</p><p>
                Before you start, ensure that the servers meet the following
                pre-conditions:
            </p><p style="color:blue;">启动之前，请确保服务器满足以下先决条件：</p>
                <div class="itemizedlist">
                    <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                        <span class="emphasis"><em>All</em></span> servers in your topology must use
                        MySQL 5.7.6 or later. You cannot enable GTID transactions
                        online on any single server unless <span class="emphasis"><em>all</em></span>
                        servers which are in the topology are using this version.
                    </p><p style="color:blue;">拓扑中的所有服务器都必须使用mysql 5.7.6或更高版本。除非拓扑中的所有服务器都使用此版本，否则无法在任何单个服务器上启用GTID事务联机。</p></li><li class="listitem"><p>
                        All servers have <a class="link" href="replication.html#sysvar_gtid_mode"><code class="literal">gtid_mode</code></a>
                        set to the default value <code class="literal">OFF</code>.
                    </p><p style="color:blue;">所有服务器都将gtid_mode设置为默认值off。</p></li></ul>
                </div>
                <p>
                    The following procedure can be paused at any time and later
                    resumed where it was, or reversed by jumping to the corresponding
                    step of
                    <a class="xref" href="replication.html#replication-mode-change-online-disable-gtids" title="16.1.5.3&nbsp;Disabling GTID Transactions Online">Section&nbsp;16.1.5.3, “Disabling GTID Transactions Online”</a>,
                    the online procedure to disable GTIDs. This makes the procedure
                    fault-tolerant because any unrelated issues that may appear in the
                    middle of the procedure can be handled as usual, and then the
                    procedure continued where it was left off.
                </p><p style="color:blue;">以下过程可以随时暂停，然后在其原来的位置继续，或通过跳到16.1.5.3节“在线禁用GTID事务”的相应步骤（在线禁用GTID的过程）进行反向。这使得过程具有容错性，因为任何可能出现在过程中间的无关问题都可以像往常一样处理，然后过程在被中断的地方继续。</p>
                <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">

                    <div class="admon-title">
                        Note
                    </div>
                    <p>
                        It is crucial that you complete every step before continuing to
                        the next step.
                    </p><p style="color:blue;">在继续下一步之前完成每一步是至关重要的。</p>
                </div>
                <p>
                    To enable GTID transactions:
                </p><p style="color:blue;">要启用gtid事务：</p>
                <div class="orderedlist">
                    <ol class="orderedlist" type="1"><li class="listitem"><p>
                        On each server, execute:
                    </p><p style="color:blue;">在每台服务器上执行：</p><pre data-lang="sql" class="programlisting">SET @@GLOBAL.ENFORCE_GTID_CONSISTENCY = WARN;</pre><p>
                        Let the server run for a while with your normal workload and
                        monitor the logs. If this step causes any warnings in the log,
                        adjust your application so that it only uses GTID-compatible
                        features and does not generate any warnings.
                    </p><p style="color:blue;">让服务器在正常工作负载下运行一段时间并监视日志。如果此步骤导致日志中出现任何警告，请调整应用程序，使其仅使用与gtid兼容的功能，而不生成任何警告。</p>
                        <div class="important" style="margin-left: 0.5in; margin-right: 0.5in;">

                            <div class="admon-title">
                                Important
                            </div>
                            <p>
                                This is the first important step. You must ensure that no
                                warnings are being generated in the error logs before going
                                to the next step.
                            </p><p style="color:blue;">这是重要的第一步。在进入下一步之前，必须确保错误日志中没有生成警告。</p>
                        </div>
                    </li><li class="listitem"><p>
                        On each server, execute:
                    </p><p style="color:blue;">在每台服务器上执行：</p><pre data-lang="sql" class="programlisting">SET @@GLOBAL.ENFORCE_GTID_CONSISTENCY = ON;</pre></li><li class="listitem"><p>
                        On each server, execute:
                    </p><p style="color:blue;">在每台服务器上执行：</p><pre data-lang="sql" class="programlisting">SET @@GLOBAL.GTID_MODE = OFF_PERMISSIVE;</pre><p>
                        It does not matter which server executes this statement first,
                        but it is important that all servers complete this step before
                        any server begins the next step.
                    </p><p style="color:blue;">哪个服务器先执行此语句并不重要，但重要的是，所有服务器都必须在任何服务器开始下一步之前完成此步骤。</p></li><li class="listitem"><p>
                        On each server, execute:
                    </p><p style="color:blue;">在每台服务器上执行：</p><pre data-lang="sql" class="programlisting">SET @@GLOBAL.GTID_MODE = ON_PERMISSIVE;</pre><p>
                        It does not matter which server executes this statement first.
                    </p><p style="color:blue;">哪个服务器先执行这个语句并不重要。</p></li><li class="listitem"><p>
                        On each server, wait until the status variable
                        <code class="literal">ONGOING_ANONYMOUS_TRANSACTION_COUNT</code> is
                        zero. This can be checked using:
                    </p><p style="color:blue;">在每台服务器上，等待状态变量continuing_anonymous_transaction_count为零。可以使用以下方法进行检查：</p><pre data-lang="sql" class="programlisting">SHOW STATUS LIKE 'ONGOING_ANONYMOUS_TRANSACTION_COUNT';</pre>
                        <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">

                            <div class="admon-title">
                                Note
                            </div>
                            <p>
                                On a replication slave, it is theoretically possible that
                                this shows zero and then nonzero again. This is not a
                                problem, it suffices that it shows zero once.
                            </p><p style="color:blue;">在复制从机上，理论上有可能显示为零，然后再次显示为非零。这不是问题，只要它显示一次就够了。</p>
                        </div>
                    </li><li class="listitem"><p>
                        Wait for all transactions generated up to step 5 to replicate
                        to all servers. You can do this without stopping updates: the
                        only important thing is that all anonymous transactions get
                        replicated.
                    </p><p style="color:blue;">等待步骤5之前生成的所有事务复制到所有服务器。您可以在不停止更新的情况下执行此操作：唯一重要的是复制所有匿名事务。</p><p>
                        See
                        <a class="xref" href="replication.html#replication-mode-change-online-verify-transactions" title="16.1.5.4&nbsp;Verifying Replication of Anonymous Transactions">Section&nbsp;16.1.5.4, “Verifying Replication of Anonymous Transactions”</a>
                        for one method of checking that all anonymous transactions
                        have replicated to all servers.
                    </p><p style="color:blue;">有关检查所有匿名事务是否已复制到所有服务器的一种方法，请参阅第16.1.5.4节“验证匿名事务的复制”。</p></li><li class="listitem"><p>
                        If you use binary logs for anything other than replication,
                        for example point in time backup and restore, wait until you
                        do not need the old binary logs having transactions without
                        GTIDs.
                    </p><p style="color:blue;">如果将二进制日志用于复制以外的任何操作，例如时间点备份和还原，请等到不需要具有没有gtid的事务的旧二进制日志。</p><p>
                        For instance, after step 6 has completed, you can execute
                        <a class="link" href="sql-syntax.html#flush-logs"><code class="literal">FLUSH LOGS</code></a> on the server where
                        you are taking backups. Then either explicitly take a backup
                        or wait for the next iteration of any periodic backup routine
                        you may have set up.
                    </p><p style="color:blue;">例如，在步骤6完成后，可以在进行备份的服务器上执行刷新日志。然后显式地进行备份，或者等待您可能设置的任何定期备份例程的下一次迭代。</p><p>
                        Ideally, wait for the server to purge all binary logs that
                        existed when step 6 was completed. Also wait for any backup
                        taken before step 6 to expire.
                    </p><p style="color:blue;">理想情况下，等待服务器清除在步骤6完成时存在的所有二进制日志。还要等待步骤6之前执行的任何备份过期。</p>
                        <div class="important" style="margin-left: 0.5in; margin-right: 0.5in;">

                            <div class="admon-title">
                                Important
                            </div>
                            <p>
                                This is the second important point. It is vital to
                                understand that binary logs containing anonymous
                                transactions, without GTIDs cannot be used after the next
                                step. After this step, you must be sure that transactions
                                without GTIDs do not exist anywhere in the topology.
                            </p><p style="color:blue;">这是第二个要点。理解包含匿名事务的二进制日志（没有gtid）在下一步之后不能使用是非常重要的。在此步骤之后，您必须确保拓扑中没有GTIDS的事务不存在于任何地方。</p>
                        </div>
                    </li><li class="listitem"><p>
                        On each server, execute:
                    </p><p style="color:blue;">在每台服务器上执行：</p><pre data-lang="sql" class="programlisting">SET @@GLOBAL.GTID_MODE = ON;</pre></li><li class="listitem"><p>
                        On each server, add <code class="literal">gtid_mode=ON</code> and
                        <code class="literal">enforce_gtid_consistency=ON</code> to
                        <code class="filename">my.cnf</code>.
                    </p><p style="color:blue;">在每台服务器上，将gtid_mode=on和enforce_gtid_consistency=on添加到my.cnf。</p><p>
                        You are now guaranteed that all transactions have a GTID
                        (except transactions generated in step 5 or earlier, which
                        have already been processed). To start using the GTID protocol
                        so that you can later perform automatic fail-over, execute the
                        following on each slave. Optionally, if you use multi-source
                        replication, do this for each channel and include the
                        <code class="literal">FOR CHANNEL
                            <em class="replaceable"><code>channel</code></em></code> clause:
                    </p><p style="color:blue;">现在可以保证所有事务都有一个gtid（步骤5或更早生成的事务除外，这些事务已经被处理过）。要开始使用gtid协议以便以后可以执行自动故障转移，请在每个从机上执行以下操作。（可选）如果使用多源复制，请对每个通道执行此操作，并包括for channel channel子句：</p><pre data-lang="sql" class="programlisting">STOP SLAVE [FOR CHANNEL 'channel'];
CHANGE MASTER TO MASTER_AUTO_POSITION = 1 [FOR CHANNEL 'channel'];
START SLAVE [FOR CHANNEL 'channel'];</pre></li></ol>
                </div>

            </div>
            <div class="section">
                <div class="titlepage">
                    <div>
                        <div>
                            <h4 class="title"><a name="replication-mode-change-online-disable-gtids"></a>16.1.5.3&nbsp;Disabling GTID Transactions Online</h4>

                        </div>

                    </div>

                </div>
                <a class="indexterm" name="idm140286800609008"></a><p>
                This section describes how to disable GTID transactions on servers
                that are already online. This procedure does not require taking
                the server offline and is suited to use in production. However, if
                you have the possibility to take the servers offline when
                disabling GTIDs mode that process is easier.
            </p><p style="color:blue;">本节介绍如何在已联机的服务器上禁用gtid事务。此过程不需要使服务器脱机，适合在生产中使用。但是，如果在禁用gtids模式时有可能使服务器脱机，则该过程更容易。</p><p>
                The process is similar to enabling GTID transactions while the
                server is online, but reversing the steps. The only thing that
                differs is the point at which you wait for logged transactions to
                replicate.
            </p><p style="color:blue;">这个过程类似于在服务器联机时启用gtid事务，但步骤相反。唯一不同的是等待记录的事务复制的时间点。</p><p>
                Before you start, ensure that the servers meet the following
                pre-conditions:
            </p><p style="color:blue;">启动之前，请确保服务器满足以下先决条件：</p>
                <div class="itemizedlist">
                    <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                        <span class="emphasis"><em>All</em></span> servers in your topology must use
                        MySQL 5.7.6 or later. You cannot disable GTID transactions
                        online on any single server unless <span class="emphasis"><em>all</em></span>
                        servers which are in the topology are using this version.
                    </p><p style="color:blue;">拓扑中的所有服务器都必须使用mysql 5.7.6或更高版本。除非拓扑中的所有服务器都使用此版本，否则不能在任何单个服务器上禁用联机GTID事务。</p></li><li class="listitem"><p>
                        All servers have <a class="link" href="replication.html#sysvar_gtid_mode"><code class="literal">gtid_mode</code></a>
                        set to <code class="literal">ON</code>.
                    </p><p style="color:blue;">所有服务器都将gtid_mode设置为on。</p></li></ul>
                </div>
                <div class="orderedlist">
                    <ol class="orderedlist" type="1"><li class="listitem"><p>
                        Execute the following on each slave, and if you using
                        multi-source replication, do it for each channel and include
                        the <code class="literal">FOR CHANNEL</code> channel clause:
                    </p><p style="color:blue;">在每个从机上执行以下操作，如果使用多源复制，则对每个通道执行此操作，并包含for channel channel子句：</p><pre data-lang="sql" class="programlisting">STOP SLAVE [FOR CHANNEL 'channel'];
CHANGE MASTER TO MASTER_AUTO_POSITION = 0, MASTER_LOG_FILE = file, \
MASTER_LOG_POS = position [FOR CHANNEL 'channel'];
START SLAVE [FOR CHANNEL 'channel'];
 </pre></li><li class="listitem"><p>
                        On each server, execute:
                    </p><p style="color:blue;">在每台服务器上执行：</p><pre data-lang="sql" class="programlisting">SET @@GLOBAL.GTID_MODE = ON_PERMISSIVE;</pre></li><li class="listitem"><p>
                        On each server, execute:
                    </p><p style="color:blue;">在每台服务器上执行：</p><pre data-lang="sql" class="programlisting">SET @@GLOBAL.GTID_MODE = OFF_PERMISSIVE;</pre></li><li class="listitem"><p>
                        On each server, wait until the variable @@GLOBAL.GTID_OWNED is
                        equal to the empty string. This can be checked using:
                    </p><p style="color:blue;">在每台服务器上，等待@global.gtid所拥有的变量等于空字符串。可以使用以下方法进行检查：</p><pre data-lang="sql" class="programlisting">SELECT @@GLOBAL.GTID_OWNED;</pre><p>
                        On a replication slave, it is theoretically possible that this
                        is empty and then nonempty again. This is not a problem, it
                        suffices that it is empty once.
                    </p><p style="color:blue;">在复制从机上，理论上可能是空的，然后又是非空的。这不是问题，只要空一次就够了。</p></li><li class="listitem"><p>
                        Wait for all transactions that currently exist in any binary
                        log to replicate to all slaves. See
                        <a class="xref" href="replication.html#replication-mode-change-online-verify-transactions" title="16.1.5.4&nbsp;Verifying Replication of Anonymous Transactions">Section&nbsp;16.1.5.4, “Verifying Replication of Anonymous Transactions”</a>
                        for one method of checking that all anonymous transactions
                        have replicated to all servers.
                    </p><p style="color:blue;">等待当前存在于任何二进制日志中的所有事务复制到所有的奴隶。有关检查所有匿名事务是否已复制到所有服务器的一种方法，请参阅第16.1.5.4节“验证匿名事务的复制”。</p></li><li class="listitem"><p>
                        If you use binary logs for anything else than replication, for
                        example to do point in time backup or restore: wait until you
                        do not need the old binary logs having GTID transactions.
                    </p><p style="color:blue;">如果将二进制日志用于复制以外的任何操作，例如执行时间点备份或还原：请等待，直到不需要具有gtid事务的旧二进制日志。</p><p>
                        For instance, after step 5 has completed, you can execute
                        <a class="link" href="sql-syntax.html#flush-logs"><code class="literal">FLUSH LOGS</code></a> on the server where
                        you are taking the backup. Then either explicitly take a
                        backup or wait for the next iteration of any periodic backup
                        routine you may have set up.
                    </p><p style="color:blue;">例如，在步骤5完成后，可以在进行备份的服务器上执行刷新日志。然后显式地进行备份，或者等待您可能设置的任何定期备份例程的下一次迭代。</p><p>
                        Ideally, wait for the server to purge all binary logs that
                        existed when step 5 was completed. Also wait for any backup
                        taken before step 5 to expire.
                    </p><p style="color:blue;">理想情况下，等待服务器清除在步骤5完成时存在的所有二进制日志。还要等待步骤5之前执行的任何备份过期。</p>
                        <div class="important" style="margin-left: 0.5in; margin-right: 0.5in;">

                            <div class="admon-title">
                                Important
                            </div>
                            <p>
                                This is the one important point during this procedure. It is
                                important to understand that logs containing GTID
                                transactions cannot be used after the next step. Before
                                proceeding you must be sure that GTID transactions do not
                                exist anywhere in the topology.
                            </p><p style="color:blue;">这是这个过程中的一个要点。重要的是要理解，包含gtid事务的日志不能在下一步之后使用。在继续之前，必须确保拓扑中的任何地方都不存在GTID事务。</p>
                        </div>
                    </li><li class="listitem"><p>
                        On each server, execute:
                    </p><p style="color:blue;">在每台服务器上执行：</p><pre data-lang="sql" class="programlisting">SET @@GLOBAL.GTID_MODE = OFF;</pre></li><li class="listitem"><p>
                        On each server, set
                        <a class="link" href="replication.html#sysvar_gtid_mode"><code class="literal">gtid_mode=OFF</code></a> in
                        <code class="filename">my.cnf</code>.
                    </p><p style="color:blue;">在每台服务器上，在my.cnf中设置gtid_mode=off。</p><p>
                        If you want to set
                        <a class="link" href="replication.html#sysvar_enforce_gtid_consistency"><code class="literal">enforce_gtid_consistency=OFF</code></a>,
                        you can do so now. After setting it, you should add
                        <a class="link" href="replication.html#sysvar_enforce_gtid_consistency"><code class="literal">enforce_gtid_consistency=OFF</code></a>
                        to your configuration file.
                    </p><p style="color:blue;">如果要将enforce_gtid_consistency=设置为off，现在可以执行此操作。设置之后，应该将enforce_gtid_consistency=off添加到配置文件中。</p></li></ol>
                </div>
                <p>
                    If you want to downgrade to an earlier version of MySQL, you can
                    do so now, using the normal downgrade procedure.
                </p><p style="color:blue;">如果要降级到MySQL的早期版本，现在可以使用普通的降级过程进行降级。</p>
            </div>
            <div class="section">
                <div class="titlepage">
                    <div>
                        <div>
                            <h4 class="title"><a name="replication-mode-change-online-verify-transactions"></a>16.1.5.4&nbsp;Verifying Replication of Anonymous Transactions</h4>

                        </div>

                    </div>

                </div>
                <a class="indexterm" name="idm140286800575168"></a><p>
                This section explains how to monitor a replication topology and
                verify that all anonymous transactions have been replicated. This
                is helpful when changing the replication mode online as you can
                verify that it is safe to change to GTID transactions.
            </p><p style="color:blue;">本节说明如何监视复制拓扑并验证所有匿名事务都已复制。这在联机更改复制模式时很有用，因为您可以验证更改为gtid事务是否安全。</p><p>
                There are several possible ways to wait for transactions to
                replicate:
            </p><p style="color:blue;">有几种可能的方法可以等待事务复制：</p><p>
                The simplest method, which works regardless of your topology but
                relies on timing is as follows: if you are sure that the slave
                never lags more than N seconds, just wait for a bit more than N
                seconds. Or wait for a day, or whatever time period you consider
                safe for your deployment.
            </p><p style="color:blue;">最简单的方法是：如果确定从机的延迟不会超过n秒，那么只需等待超过n秒。或者等待一天，或者你认为安全的部署时间段。</p><p>
                A safer method in the sense that it does not depend on timing: if
                you only have a master with one or more slaves, do the following:
            </p><p style="color:blue;">一种更安全的方法，因为它不依赖于时间：如果您只有一个具有一个或多个从属服务器的主服务器，请执行以下操作：</p>
                <div class="orderedlist">
                    <ol class="orderedlist" type="1"><li class="listitem"><p>
                        On the master, execute:
                    </p><p style="color:blue;">在主机上执行：</p><pre data-lang="sql" class="programlisting">SHOW MASTER STATUS;</pre><p>
                        Note down the values in the <code class="literal">File</code> and
                        <code class="literal">Position</code> column.
                    </p><p style="color:blue;">记下“文件和位置”列中的值。</p></li><li class="listitem"><p>
                        On every slave, use the file and position information from the
                        master to execute:
                    </p><p style="color:blue;">在每个从机上，使用来自主机的文件和位置信息执行：</p><pre data-lang="sql" class="programlisting">SELECT MASTER_POS_WAIT(file, position);</pre></li></ol>
                </div>
                <p>
                    If you have a master and multiple levels of slaves, or in other
                    words you have slaves of slaves, repeat step 2 on each level,
                    starting from the master, then all the direct slaves, then all the
                    slaves of slaves, and so on.
                </p><p style="color:blue;">如果你有一个主人和多个等级的奴隶，或者换句话说，你有奴隶的奴隶，在每个等级重复步骤2，从主人开始，然后是所有直接的奴隶，然后是所有奴隶的奴隶，等等。</p><p>
                If you use a circular replication topology where multiple servers
                may have write clients, perform step 2 for each master-slave
                connection, until you have completed the full circle. Repeat the
                whole process so that you do the full circle
                <span class="emphasis"><em>twice</em></span>.
            </p><p style="color:blue;">如果使用循环复制拓扑，其中多个服务器可能具有写客户端，请对每个主从连接执行步骤2，直到完成整个循环。重复整个过程，这样你就可以做两次完整的循环。</p><p>
                For example, suppose you have three servers A, B, and C,
                replicating in a circle so that A -&gt; B -&gt; C -&gt; A. The
                procedure is then:
            </p><p style="color:blue;">例如，假设您有三个服务器A、B和C，它们在一个圆圈中进行复制，以便A-&gt;B-&gt;C-&gt;A。</p>
                <div class="itemizedlist">
                    <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                        Do step 1 on A and step 2 on B.
                    </p><p style="color:blue;">执行A上的步骤1和B上的步骤2。</p></li><li class="listitem"><p>
                        Do step 1 on B and step 2 on C.
                    </p><p style="color:blue;">对B执行步骤1，对C执行步骤2。</p></li><li class="listitem"><p>
                        Do step 1 on C and step 2 on A.
                    </p><p style="color:blue;">对C执行步骤1，对A执行步骤2。</p></li><li class="listitem"><p>
                        Do step 1 on A and step 2 on B.
                    </p><p style="color:blue;">执行A上的步骤1和B上的步骤2。</p></li><li class="listitem"><p>
                        Do step 1 on B and step 2 on C.
                    </p><p style="color:blue;">对B执行步骤1，对C执行步骤2。</p></li><li class="listitem"><p>
                        Do step 1 on C and step 2 on A.
                    </p><p style="color:blue;">对C执行步骤1，对A执行步骤2。</p></li></ul>
                </div>

            </div>

        </div>
        <div class="section">
            <div class="titlepage">
                <div>
                    <div>
                        <h3 class="title"><a name="replication-options"></a>16.1.6&nbsp;Replication and Binary Logging Options and Variables</h3>

                    </div>

                </div>

            </div>
            <div class="toc">
                <dl class="toc"><dt><span class="section"><a href="replication.html#replication-options-reference">16.1.6.1 Replication and Binary Logging Option and Variable Reference</a></span></dt><dt><span class="section"><a href="replication.html#replication-options-master">16.1.6.2 Replication Master Options and Variables</a></span></dt><dt><span class="section"><a href="replication.html#replication-options-slave">16.1.6.3 Replication Slave Options and Variables</a></span></dt><dt><span class="section"><a href="replication.html#replication-options-binary-log">16.1.6.4 Binary Logging Options and Variables</a></span></dt><dt><span class="section"><a href="replication.html#replication-options-gtids">16.1.6.5 Global Transaction ID Options and Variables</a></span></dt></dl>
            </div>
            <p>
                The following sections contain information about
                <a class="link" href="programs.html#mysqld" title="4.3.1&nbsp;mysqld — The MySQL Server"><span class="command"><strong>mysqld</strong></span></a> options and server variables that are used
                in replication and for controlling the binary log. Options and
                variables for use on replication masters and replication slaves are
                covered separately, as are options and variables relating to binary
                logging and global transaction identifiers (GTIDs). A set of
                quick-reference tables providing basic information about these
                options and variables is also included.
            </p><p style="color:blue;">以下部分包含有关mysqld选项和用于复制和控制二进制日志的服务器变量的信息。复制主机和复制从机上使用的选项和变量将单独介绍，与二进制日志记录和全局事务标识符（gtid）相关的选项和变量也将单独介绍。还包括一组快速参考表，提供有关这些选项和变量的基本信息。</p><p><a name="option_mysqld_server-id"></a>
            <a class="indexterm" name="idm140286800552848"></a>

            <a class="indexterm" name="idm140286800551392"></a>

            Of particular importance is the
            <a class="link" href="replication.html#option_mysqld_server-id"><code class="option">--server-id</code></a> option.
        </p><p style="color:blue;">特别重要的是--server id选项。</p>
            <div class="informaltable">
                <table frame="box" rules="all" summary="Properties for server-id"><colgroup><col width="30%"><col width="70%"></colgroup><thead><tr><th scope="col">Property</th>
                    <th scope="col">Value</th>
                </tr></thead><tbody><tr><td scope="row"><span class="bold"><strong>Command-Line Format</strong></span></td>
                    <td><code class="literal">--server-id=#</code></td>
                </tr><tr><td scope="row"><span class="bold"><strong>System Variable</strong></span></td>
                    <td><code class="literal"><a class="link" href="server-administration.html#sysvar_server_id">server_id</a></code></td>
                </tr><tr><td scope="row"><span class="bold"><strong>Scope</strong></span></td>
                    <td>Global</td>
                </tr><tr><td scope="row"><span class="bold"><strong>Dynamic</strong></span></td>
                    <td>Yes</td>
                </tr><tr><td scope="row"><span class="bold"><strong>Type</strong></span></td>
                    <td>Integer</td>
                </tr><tr><td scope="row"><span class="bold"><strong>Default Value</strong></span></td>
                    <td><code class="literal">0</code></td>
                </tr><tr><td scope="row"><span class="bold"><strong>Minimum Value</strong></span></td>
                    <td><code class="literal">0</code></td>
                </tr><tr><td scope="row"><span class="bold"><strong>Maximum Value</strong></span></td>
                    <td><code class="literal">4294967295</code></td>
                </tr></tbody></table>
            </div>
            <p>
                This option specifies the server ID that is set in the
                <a class="link" href="server-administration.html#sysvar_server_id"><code class="literal">server_id</code></a> system variable. In MySQL
                5.7, the <code class="option">--server-id</code> option must be specified if
                binary logging is enabled, otherwise the server is not allowed to
                start.
            </p><p style="color:blue;">此选项指定在服务器ID系统变量中设置的服务器ID。在mysql 5.7中，如果启用了二进制日志记录，则必须指定--server id选项，否则不允许启动服务器。</p><p>
            The <code class="literal">server_id</code> system variable is set to 0 by
            default. On a replication master and each replication slave, you
            <span class="emphasis"><em>must</em></span> specify the
            <a class="link" href="replication.html#option_mysqld_server-id"><code class="option">--server-id</code></a> option to establish a
            unique replication ID in the range from 1 to
            2<sup>32</sup> − 1. <span class="quote">“<span class="quote">Unique</span>”</span>,
            means that each ID must be different from every other ID in use by
            any other replication master or slave. For example,
            <code class="literal">server-id=3</code>. For additional information, see
            <a class="xref" href="replication.html#replication-options-master" title="16.1.6.2&nbsp;Replication Master Options and Variables">Section&nbsp;16.1.6.2, “Replication Master Options and Variables”</a>, and
            <a class="xref" href="replication.html#replication-options-slave" title="16.1.6.3&nbsp;Replication Slave Options and Variables">Section&nbsp;16.1.6.3, “Replication Slave Options and Variables”</a>.
        </p><p style="color:blue;">服务器ID系统变量默认设置为0。在复制主机和每个复制从机上，必须指定--server id选项以在1到232-1的范围内建立唯一的复制id。“唯一”意味着每个ID必须与任何其他复制主机或从机使用的每个其他ID不同。例如，服务器id=3。有关更多信息，请参阅第16.1.6.2节“复制主选项和变量”和第16.1.6.3节“复制从选项和变量”。</p><p>
            If the server ID is set to 0, binary logging takes place, but a
            master with a server ID of 0 refuses any connections from slaves,
            and a slave with a server ID of 0 refuses to connect to a master.
            Note that although you can change the server ID dynamically to a
            nonzero value, doing so does not enable replication to start
            immediately. You must change the server ID and then restart the
            server to initialize the replication slave.
        </p><p style="color:blue;">如果服务器ID设置为0，则会进行二进制日志记录，但服务器ID为0的主服务器拒绝从服务器进行任何连接，服务器ID为0的从服务器拒绝连接到主服务器。请注意，尽管您可以将服务器ID动态更改为非零值，但这样做不会使复制立即启动。必须更改服务器ID，然后重新启动服务器以初始化复制从属服务器。</p><p>
            For more information, see
            <a class="xref" href="replication.html#replication-howto-slavebaseconfig" title="16.1.2.5.1&nbsp;Setting the Replication Slave Configuration">Section&nbsp;16.1.2.5.1, “Setting the Replication Slave Configuration”</a>.
        </p><p style="color:blue;">有关更多信息，请参阅第16.1.2.5.1节“设置复制从机配置”。</p><p><a name="sysvar_server_uuid"></a>
            <a class="indexterm" name="idm140286800508048"></a>

            <a class="indexterm" name="idm140286800506624"></a>

            <a class="link" href="replication.html#sysvar_server_uuid"><code class="literal">server_uuid</code></a>
        </p><p style="color:blue;">服务器</p><p>
            In MySQL 5.7, the server generates a true UUID in
            addition to the <a class="link" href="replication.html#option_mysqld_server-id"><code class="option">--server-id</code></a> supplied
            by the user. This is available as the global, read-only variable
            <a class="link" href="replication.html#sysvar_server_uuid"><code class="literal">server_uuid</code></a>.
        </p><p style="color:blue;">在mysql 5.7中，除了用户提供的--server id之外，服务器还生成一个真正的uuid。这可用作全局只读变量服务器。</p>
            <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">

                <div class="admon-title">
                    Note
                </div>
                <p>
                    The presence of the <a class="link" href="replication.html#sysvar_server_uuid"><code class="literal">server_uuid</code></a>
                    system variable in MySQL 5.7 does not change the
                    requirement for setting a unique
                    <a class="link" href="replication.html#option_mysqld_server-id"><code class="option">--server-id</code></a> for each MySQL server
                    as part of preparing and running MySQL replication, as described
                    earlier in this section.
                </p><p style="color:blue;">MySQL5.7中存在SERVER Uuid系统变量并没有改变在准备和运行MySQL复制过程中为每个MySQL服务器设置唯一服务器ID的要求，如本节前面所述。</p>
            </div>
            <div class="informaltable">
                <table frame="box" rules="all" summary="Properties for server_uuid"><colgroup><col width="30%"><col width="70%"></colgroup><thead><tr><th scope="col">Property</th>
                    <th scope="col">Value</th>
                </tr></thead><tbody><tr><td scope="row"><span class="bold"><strong>System Variable</strong></span></td>
                    <td><code class="literal"><a class="link" href="replication.html#sysvar_server_uuid">server_uuid</a></code></td>
                </tr><tr><td scope="row"><span class="bold"><strong>Scope</strong></span></td>
                    <td>Global</td>
                </tr><tr><td scope="row"><span class="bold"><strong>Dynamic</strong></span></td>
                    <td>No</td>
                </tr><tr><td scope="row"><span class="bold"><strong>Type</strong></span></td>
                    <td>String</td>
                </tr></tbody></table>
            </div>
            <p>
                When starting, the MySQL server automatically obtains a UUID as
                follows:
            </p><p style="color:blue;">启动时，mysql服务器自动获取uuid，如下所示：</p>
            <div class="orderedlist">
                <ol class="orderedlist" type="1"><li class="listitem"><p>
                    <a class="indexterm" name="idm140286800478528"></a>

                    Attempt to read and use the UUID written in the file
                    <code class="filename"><em class="replaceable"><code>data_dir</code></em>/auto.cnf</code>
                    (where <em class="replaceable"><code>data_dir</code></em> is the server's
                    data directory).
                </p><p style="color:blue;">尝试读取并使用写入文件data_dir/auto.cnf（其中data_dir是服务器的数据目录）中的uuid。</p></li><li class="listitem"><p>
                    If
                    <code class="filename"><em class="replaceable"><code>data_dir</code></em>/auto.cnf</code>
                    is not found, generate a new UUID and save it to this file,
                    creating the file if necessary.
                </p><p style="color:blue;">如果找不到data_dir/auto.cnf，请生成一个新的uuid并将其保存到该文件中，必要时创建该文件。</p></li></ol>
            </div>
            <p>
                The <code class="filename">auto.cnf</code> file has a format similar to that
                used for <code class="filename">my.cnf</code> or <code class="filename">my.ini</code>
                files. In MySQL 5.7, <code class="filename">auto.cnf</code> has
                only a single <code class="literal">[auto]</code> section containing a single
                <a class="link" href="replication.html#sysvar_server_uuid"><code class="literal">server_uuid</code></a> setting and value; the
                file's contents appear similar to what is shown here:
            </p><p style="color:blue;">auto.cnf文件的格式类似于my.cnf或my.ini文件的格式。在mysql 5.7中，auto.cnf只有一个[auto]节，其中包含一个服务器的id设置和值；文件的内容类似于如下所示：</p><pre data-lang="ini" class="programlisting">[auto]
server_uuid=8a94f357-aab4-11df-86ab-c80aa9429562
</pre>
            <div class="important" style="margin-left: 0.5in; margin-right: 0.5in;">

                <div class="admon-title">
                    Important
                </div>
                <p>
                    The <code class="filename">auto.cnf</code> file is automatically generated;
                    do not attempt to write or modify this file.
                </p><p style="color:blue;">自动生成auto.cnf文件；不要试图写入或修改此文件。</p>
            </div>
            <p>
                When using MySQL replication, masters and slaves know each
                other's UUIDs. The value of a slave's UUID can be seen in
                the output of <a class="link" href="sql-syntax.html#show-slave-hosts" title="13.7.5.33&nbsp;SHOW SLAVE HOSTS Syntax"><code class="literal">SHOW SLAVE HOSTS</code></a>. Once
                <a class="link" href="sql-syntax.html#start-slave" title="13.4.2.6&nbsp;START SLAVE Syntax"><code class="literal">START SLAVE</code></a> has been executed, the
                value of the master's UUID is available on the slave in the
                output of <a class="link" href="sql-syntax.html#show-slave-status" title="13.7.5.34&nbsp;SHOW SLAVE STATUS Syntax"><code class="literal">SHOW SLAVE STATUS</code></a>.
            </p><p style="color:blue;">使用mysql复制时，主服务器和从服务器知道彼此的uuid。从机uuid的值可以在show slave hosts的输出中看到。一旦启动从机被执行，在显示从机状态的输出中，从机的uuid值可用。</p>
            <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">

                <div class="admon-title">
                    Note
                </div>
                <p>
                    Issuing a <a class="link" href="sql-syntax.html#stop-slave" title="13.4.2.7&nbsp;STOP SLAVE Syntax"><code class="literal">STOP SLAVE</code></a> or
                    <a class="link" href="sql-syntax.html#reset-slave" title="13.4.2.4&nbsp;RESET SLAVE Syntax"><code class="literal">RESET SLAVE</code></a> statement does
                    <span class="emphasis"><em>not</em></span> reset the master's UUID as used on
                    the slave.
                </p><p style="color:blue;">发出stop slave或reset slave语句不会像在从机上那样重置主机的uuid。</p>
            </div>
            <p>
                A server's <code class="literal">server_uuid</code> is also used in GTIDs
                for transactions originating on that server. For more information,
                see <a class="xref" href="replication.html#replication-gtids" title="16.1.3&nbsp;Replication with Global Transaction Identifiers">Section&nbsp;16.1.3, “Replication with Global Transaction Identifiers”</a>.
            </p><p style="color:blue;">在gtid中，服务器的服务器uuid也用于该服务器上发起的事务。有关更多信息，请参阅第16.1.3节“使用全局事务标识符复制”。</p><p>
            When starting, the slave I/O thread generates an error and aborts if
            its master's UUID is equal to its own unless the
            <a class="link" href="replication.html#option_mysqld_replicate-same-server-id"><code class="option">--replicate-same-server-id</code></a> option has
            been set. In addition, the slave I/O thread generates a warning if
            either of the following is true:
        </p><p style="color:blue;">启动时，从I/O线程会生成一个错误，如果其主线程的Uuid等于其自身的Uuid，则会中止，除非设置了--replicate same server id选项。此外，如果以下任一项为真，从I/O线程将生成警告：</p>
            <div class="itemizedlist">
                <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                    No master having the expected
                    <a class="link" href="replication.html#sysvar_server_uuid"><code class="literal">server_uuid</code></a> exists.
                </p><p style="color:blue;">没有主服务器存在预期的服务器端UUID。</p></li><li class="listitem"><p>
                    The master's <a class="link" href="replication.html#sysvar_server_uuid"><code class="literal">server_uuid</code></a>
                    has changed, although no <a class="link" href="sql-syntax.html#change-master-to" title="13.4.2.1&nbsp;CHANGE MASTER TO Syntax"><code class="literal">CHANGE MASTER
                    TO</code></a> statement has ever been executed.
                </p><p style="color:blue;">主服务器的uuid已更改，但从未执行过change master to语句。</p></li></ul>
            </div>
            <div class="section">
                <div class="titlepage">
                    <div>
                        <div>
                            <h4 class="title"><a name="replication-options-reference"></a>16.1.6.1&nbsp;Replication and Binary Logging Option and Variable Reference</h4>

                        </div>

                    </div>

                </div>
                <p>
                    The following two lists provide basic information about the MySQL
                    command-line options and system variables applicable to
                    replication and the binary log.
                </p><p style="color:blue;">以下两个列表提供了适用于复制和二进制日志的mysql命令行选项和系统变量的基本信息。</p><p>
                The command-line options and system variables in the following
                list relate to replication masters and replication slaves.
                <a class="xref" href="replication.html#replication-options-master" title="16.1.6.2&nbsp;Replication Master Options and Variables">Section&nbsp;16.1.6.2, “Replication Master Options and Variables”</a>, provides more
                detailed information about options and variables relating to
                replication master servers. For more information about options and
                variables relating to replication slaves, see
                <a class="xref" href="replication.html#replication-options-slave" title="16.1.6.3&nbsp;Replication Slave Options and Variables">Section&nbsp;16.1.6.3, “Replication Slave Options and Variables”</a>.
            </p><p style="color:blue;">下表中的命令行选项和系统变量与复制主机和复制从机相关。第16.1.6.2节“复制主选项和变量”提供了有关复制主服务器的选项和变量的更详细信息。有关与复制从机相关的选项和变量的更多信息，请参阅第16.1.6.3节“复制从机选项和变量”。</p>
                <div class="itemizedlist">
                    <a name="replication-optvar-summary-list"></a><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                    <code class="literal"><a class="link" href="replication.html#option_mysqld_abort-slave-event-count">abort-slave-event-count</a></code>:
                    Option used by mysql-test for debugging and testing of
                    replication
                </p><p style="color:blue;">abort slave event count：mysql test用于调试和测试复制的选项</p></li><li class="listitem"><p>
                    <code class="literal"><a class="link" href="replication.html#sysvar_auto_increment_increment">auto_increment_increment</a></code>:
                    AUTO_INCREMENT columns are incremented by this value
                </p><p style="color:blue;">auto_increment_increment：auto_increment列按此值递增</p></li><li class="listitem"><p>
                    <code class="literal"><a class="link" href="replication.html#sysvar_auto_increment_offset">auto_increment_offset</a></code>:
                    Offset added to AUTO_INCREMENT columns
                </p><p style="color:blue;">auto_increment_offset：添加到auto_increment列的偏移量</p></li><li class="listitem"><p>
                    <code class="literal"><a class="link" href="replication.html#sysvar_binlog_gtid_simple_recovery">binlog_gtid_simple_recovery</a></code>:
                    Controls how binary logs are iterated during GTID recovery
                </p><p style="color:blue;">binlog_gtid_simple_recovery：控制在gtid恢复期间如何迭代二进制日志</p></li><li class="listitem"><p>
                    <code class="literal"><a class="link" href="server-administration.html#statvar_Com_xxx">Com_change_master</a></code>:
                    Count of CHANGE MASTER TO statements
                </p><p style="color:blue;">com_change_master：将master更改为语句的计数</p></li><li class="listitem"><p>
                    <code class="literal"><a class="link" href="server-administration.html#statvar_Com_xxx">Com_show_master_status</a></code>:
                    Count of SHOW MASTER STATUS statements
                </p><p style="color:blue;">显示主机状态：显示主机状态语句的计数</p></li><li class="listitem"><p>
                    <code class="literal"><a class="link" href="server-administration.html#statvar_Com_xxx">Com_show_slave_hosts</a></code>:
                    Count of SHOW SLAVE HOSTS statements
                </p><p style="color:blue;">com_show_slave_hosts:show slave hosts语句的计数</p></li><li class="listitem"><p>
                    <code class="literal"><a class="link" href="server-administration.html#statvar_Com_xxx">Com_show_slave_status</a></code>:
                    Count of SHOW SLAVE STATUS statements
                </p><p style="color:blue;">显示从属状态：显示从属状态语句的计数</p></li><li class="listitem"><p>
                    <code class="literal"><a class="link" href="server-administration.html#statvar_Com_xxx">Com_show_slave_status_nonblocking</a></code>:
                    Count of SHOW SLAVE STATUS NONBLOCKING statements
                </p><p style="color:blue;">com_show_slave_status_nonblocking：显示从属状态非阻塞语句的计数</p></li><li class="listitem"><p>
                    <code class="literal"><a class="link" href="server-administration.html#statvar_Com_xxx">Com_slave_start</a></code>:
                    Count of START SLAVE statements
                </p><p style="color:blue;">com_slave_start:start slave语句的计数</p></li><li class="listitem"><p>
                    <code class="literal"><a class="link" href="server-administration.html#statvar_Com_xxx">Com_slave_stop</a></code>:
                    Count of STOP SLAVE statements
                </p><p style="color:blue;">com_slave_stop：stop slave语句的计数</p></li><li class="listitem"><p>
                    <code class="literal"><a class="link" href="replication.html#option_mysqld_disconnect-slave-event-count">disconnect-slave-event-count</a></code>:
                    Option used by mysql-test for debugging and testing of
                    replication
                </p><p style="color:blue;">disconnect slave event count：mysql test用于调试和测试复制的选项</p></li><li class="listitem"><p>
                    <code class="literal"><a class="link" href="replication.html#sysvar_enforce_gtid_consistency">enforce_gtid_consistency</a></code>:
                    Prevents execution of statements that cannot be logged in a
                    transactionally safe manner
                </p><p style="color:blue;">强制一致性：防止执行无法以事务安全方式记录的语句</p></li><li class="listitem"><p>
                    <code class="literal"><a class="link" href="replication.html#sysvar_executed_gtids_compression_period">executed_gtids_compression_period</a></code>:
                    Renamed to gtid_executed_compression_period
                </p><p style="color:blue;">执行的压缩周期：重命名为执行的压缩周期</p></li><li class="listitem"><p>
                    <code class="literal"><a class="link" href="replication.html#sysvar_expire_logs_days">expire_logs_days</a></code>:
                    Purge binary logs after this many days
                </p><p style="color:blue;">过期日志天数：在此天数之后清除二进制日志</p></li><li class="listitem"><p>
                    <code class="literal"><a class="link" href="replication.html#option_mysqld_gtid-executed-compression-period">gtid-executed-compression-period</a></code>:
                    Compress gtid_executed table each time this many transactions
                    have occurred. 0 means never compress this table. Applies only
                    when binary logging is disabled.
                </p><p style="color:blue;">gtid执行压缩周期：每次发生这么多事务时压缩gtid_执行表。0表示从不压缩此表。仅在禁用二进制日志记录时应用。</p></li><li class="listitem"><p>
                    <code class="literal"><a class="link" href="replication.html#sysvar_gtid_executed">gtid_executed</a></code>:
                    Global: All GTIDs in the binary log (global) or current
                    transaction (session). Read-only.
                </p><p style="color:blue;">gtid_executed:global：二进制日志（global）或当前事务（session）中的所有gtid。只读。</p></li><li class="listitem"><p>
                    <code class="literal"><a class="link" href="replication.html#sysvar_gtid_executed_compression_period">gtid_executed_compression_period</a></code>:
                    Compress gtid_executed table each time this many transactions
                    have occurred. 0 means never compress this table. Applies only
                    when binary logging is disabled.
                </p><p style="color:blue;">gtid_executed_compression_period：每次发生这么多事务时压缩gtid_executed表。0表示从不压缩此表。仅在禁用二进制日志记录时应用。</p></li><li class="listitem"><p>
                    <code class="literal"><a class="link" href="replication.html#sysvar_gtid_mode">gtid_mode</a></code>:
                    Controls whether GTID based logging is enabled and what type
                    of transactions the logs can contain
                </p><p style="color:blue;">gtid_mode：控制是否启用基于gtid的日志记录以及日志可以包含的事务类型</p></li><li class="listitem"><p>
                    <code class="literal"><a class="link" href="replication.html#sysvar_gtid_next">gtid_next</a></code>:
                    Specifies the GTID for the next statement to execute; see
                    documentation for details
                </p><p style="color:blue;">gtid_next：指定要执行的下一条语句的gtid；有关详细信息，请参阅文档</p></li><li class="listitem"><p>
                    <code class="literal"><a class="link" href="replication.html#sysvar_gtid_owned">gtid_owned</a></code>:
                    The set of GTIDs owned by this client (session), or by all
                    clients, together with the thread ID of the owner (global).
                    Read-only.
                </p><p style="color:blue;">拥有的gtid：此客户端（会话）或所有客户端拥有的gtid集，以及所有者（全局）的线程id。只读。</p></li><li class="listitem"><p>
                    <code class="literal"><a class="link" href="replication.html#sysvar_gtid_purged">gtid_purged</a></code>:
                    The set of all GTIDs that have been purged from the binary log
                </p><p style="color:blue;">清除的gtid：从二进制日志中清除的所有gtid的集合</p></li><li class="listitem"><p>
                    <code class="literal"><a class="link" href="replication.html#sysvar_init_slave">init_slave</a></code>:
                    Statements that are executed when a slave connects to a master
                </p><p style="color:blue;">init_slave：从机连接到主机时执行的语句</p></li><li class="listitem"><p>
                    <code class="literal"><a class="link" href="replication.html#sysvar_log_bin_trust_function_creators">log_bin_trust_function_creators</a></code>:
                    If equal to 0 (the default), then when --log-bin is used,
                    creation of a stored function is allowed only to users having
                    the SUPER privilege and only if the function created does not
                    break binary logging
                </p><p style="color:blue;">log_bin_trust_function_creators：如果等于0（默认值），则当使用--log bin时，仅允许具有超级权限的用户创建存储函数，并且仅当创建的函数不中断二进制日志记录时</p></li><li class="listitem"><p>
                    <code class="literal"><a class="link" href="replication.html#sysvar_log_builtin_as_identified_by_password">log_builtin_as_identified_by_password</a></code>:
                    Whether to log CREATE/ALTER USER, GRANT in backward-compatible
                    fashion
                </p><p style="color:blue;">logu builtin_as_identified_by_password：是否记录创建/更改用户，以向后兼容的方式授予</p></li><li class="listitem"><p>
                    <code class="literal"><a class="link" href="replication.html#sysvar_log_statements_unsafe_for_binlog">log_statements_unsafe_for_binlog</a></code>:
                    Disables error 1592 warnings being written to the error log
                </p><p style="color:blue;">LOG U语句不安全：禁用写入错误日志的错误1592警告</p></li><li class="listitem"><p>
                    <code class="literal"><a class="link" href="replication.html#option_mysqld_master-info-file">master-info-file</a></code>:
                    The location and name of the file that remembers the master
                    and where the I/O replication thread is in the master's binary
                    logs
                </p><p style="color:blue;">主信息文件：记住主信息的文件的位置和名称，以及I/O复制线程在主信息的二进制日志中的位置</p></li><li class="listitem"><p>
                    <code class="literal"><a class="link" href="replication.html#option_mysqld_master-info-repository">master-info-repository</a></code>:
                    Whether to write master status information and replication I/O
                    thread location in the master's binary logs to a file or table
                </p><p style="color:blue;">主信息存储库：是否将主状态信息和主二进制日志中的复制I/O线程位置写入文件或表</p></li><li class="listitem"><p>
                    <code class="literal"><a class="link" href="replication.html#option_mysqld_master-retry-count">master-retry-count</a></code>:
                    Number of tries the slave makes to connect to the master
                    before giving up
                </p><p style="color:blue;">主重试计数：在放弃之前，从服务器尝试连接到主服务器的次数</p></li><li class="listitem"><p>
                    <code class="literal"><a class="link" href="replication.html#sysvar_master_info_repository">master_info_repository</a></code>:
                    Whether to write master status information and replication I/O
                    thread location in the master's binary logs to a file or table
                </p><p style="color:blue;">master_info_repository：是否将master状态信息和master二进制日志中的复制i/o线程位置写入文件或表</p></li><li class="listitem"><p>
                    <code class="literal"><a class="link" href="replication.html#sysvar_max_relay_log_size">max_relay_log_size</a></code>:
                    If nonzero, relay log is rotated automatically when its size
                    exceeds this value. If zero, size at which rotation occurs is
                    determined by the value of max_binlog_size.
                </p><p style="color:blue;">最大中继日志大小：如果非零，则当中继日志大小超过此值时，会自动旋转。如果为零，则发生旋转的大小由max_binlog_size的值确定。</p></li><li class="listitem"><p>
                    <code class="literal"><a class="link" href="replication.html#option_mysqld_relay-log-info-repository">relay-log-info-repository</a></code>:
                    Whether to write the replication SQL thread's location in the
                    relay logs to a file or a table
                </p><p style="color:blue;">中继日志信息存储库：是否将中继日志中复制SQL线程的位置写入文件或表</p></li><li class="listitem"><p>
                    <code class="literal"><a class="link" href="replication.html#option_mysqld_relay-log-recovery">relay-log-recovery</a></code>:
                    Enables automatic recovery of relay log files from master at
                    startup
                </p><p style="color:blue;">中继日志恢复：启用启动时从主服务器自动恢复中继日志文件</p></li><li class="listitem"><p>
                    <code class="literal"><a class="link" href="replication.html#sysvar_relay_log">relay_log</a></code>:
                    The location and base name to use for relay logs
                </p><p style="color:blue;">中继日志：用于中继日志的位置和基名称</p></li><li class="listitem"><p>
                    <code class="literal"><a class="link" href="replication.html#sysvar_relay_log_basename">relay_log_basename</a></code>:
                    Complete path to relay log, including file name
                </p><p style="color:blue;">relay_log_basename：中继日志的完整路径，包括文件名</p></li><li class="listitem"><p>
                    <code class="literal"><a class="link" href="replication.html#sysvar_relay_log_index">relay_log_index</a></code>:
                    The location and name to use for the file that keeps a list of
                    the last relay logs
                </p><p style="color:blue;">中继日志索引：用于保存上一个中继日志列表的文件的位置和名称</p></li><li class="listitem"><p>
                    <code class="literal"><a class="link" href="replication.html#sysvar_relay_log_info_file">relay_log_info_file</a></code>:
                    File in which the slave records information about the relay
                    logs
                </p><p style="color:blue;">中继日志信息文件：从机记录中继日志信息的文件</p></li><li class="listitem"><p>
                    <code class="literal"><a class="link" href="replication.html#sysvar_relay_log_info_repository">relay_log_info_repository</a></code>:
                    Whether to write the replication SQL thread's location in the
                    relay logs to a file or a table
                </p><p style="color:blue;">中继日志信息库：是否将中继日志中的复制SQL线程位置写入文件或表</p></li><li class="listitem"><p>
                    <code class="literal"><a class="link" href="replication.html#sysvar_relay_log_purge">relay_log_purge</a></code>:
                    Determines whether relay logs are purged
                </p><p style="color:blue;">中继日志清除：确定是否清除中继日志</p></li><li class="listitem"><p>
                    <code class="literal"><a class="link" href="replication.html#sysvar_relay_log_recovery">relay_log_recovery</a></code>:
                    Whether automatic recovery of relay log files from master at
                    startup is enabled; must be enabled for a crash-safe slave
                </p><p style="color:blue;">中继日志恢复：是否启用了启动时从主服务器自动恢复中继日志文件；必须为安全崩溃从服务器启用</p></li><li class="listitem"><p>
                    <code class="literal"><a class="link" href="replication.html#sysvar_relay_log_space_limit">relay_log_space_limit</a></code>:
                    Maximum space to use for all relay logs
                </p><p style="color:blue;">RelayLogLogySuleSyLime:用于所有中继日志的最大空间</p></li><li class="listitem"><p>
                    <code class="literal"><a class="link" href="replication.html#option_mysqld_replicate-do-db">replicate-do-db</a></code>:
                    Tells the slave SQL thread to restrict replication to the
                    specified database
                </p><p style="color:blue;">replicate do db：告诉从sql线程将复制限制到指定的数据库</p></li><li class="listitem"><p>
                    <code class="literal"><a class="link" href="replication.html#option_mysqld_replicate-do-table">replicate-do-table</a></code>:
                    Tells the slave SQL thread to restrict replication to the
                    specified table
                </p><p style="color:blue;">replicate do table：告诉从sql线程将复制限制到指定的表</p></li><li class="listitem"><p>
                    <code class="literal"><a class="link" href="replication.html#option_mysqld_replicate-ignore-db">replicate-ignore-db</a></code>:
                    Tells the slave SQL thread not to replicate to the specified
                    database
                </p><p style="color:blue;">replicate ignore db：告诉从sql线程不要复制到指定的数据库</p></li><li class="listitem"><p>
                    <code class="literal"><a class="link" href="replication.html#option_mysqld_replicate-ignore-table">replicate-ignore-table</a></code>:
                    Tells the slave SQL thread not to replicate to the specified
                    table
                </p><p style="color:blue;">replicate ignore table：告诉从sql线程不要复制到指定的表</p></li><li class="listitem"><p>
                    <code class="literal"><a class="link" href="replication.html#option_mysqld_replicate-rewrite-db">replicate-rewrite-db</a></code>:
                    Updates to a database with a different name than the original
                </p><p style="color:blue;">replicate rewrite db：使用与原始数据库不同的名称更新数据库</p></li><li class="listitem"><p>
                    <code class="literal"><a class="link" href="replication.html#option_mysqld_replicate-same-server-id">replicate-same-server-id</a></code>:
                    In replication, if enabled, do not skip events having our
                    server id
                </p><p style="color:blue;">复制相同的服务器ID:在复制中，如果启用，则不要跳过具有我们的服务器ID的事件</p></li><li class="listitem"><p>
                    <code class="literal"><a class="link" href="replication.html#option_mysqld_replicate-wild-do-table">replicate-wild-do-table</a></code>:
                    Tells the slave thread to restrict replication to the tables
                    that match the specified wildcard pattern
                </p><p style="color:blue;">replicate wild do table：告诉从线程将复制限制到与指定通配符模式匹配的表</p></li><li class="listitem"><p>
                    <code class="literal"><a class="link" href="replication.html#option_mysqld_replicate-wild-ignore-table">replicate-wild-ignore-table</a></code>:
                    Tells the slave thread not to replicate to the tables that
                    match the given wildcard pattern
                </p><p style="color:blue;">replicate wild ignore table：告诉从线程不要复制到与给定通配符模式匹配的表</p></li><li class="listitem"><p>
                    <code class="literal"><a class="link" href="replication.html#sysvar_report_host">report_host</a></code>:
                    Host name or IP of the slave to be reported to the master
                    during slave registration
                </p><p style="color:blue;">report_host：在从机注册期间要向主机报告的从机的主机名或IP</p></li><li class="listitem"><p>
                    <code class="literal"><a class="link" href="replication.html#sysvar_report_password">report_password</a></code>:
                    An arbitrary password that the slave server should report to
                    the master. Not the same as the password for the MySQL
                    replication user account.
                </p><p style="color:blue;">report_password：从服务器应向主服务器报告的任意密码。与mysql复制用户帐户的密码不同。</p></li><li class="listitem"><p>
                    <code class="literal"><a class="link" href="replication.html#sysvar_report_port">report_port</a></code>:
                    Port for connecting to slave reported to the master during
                    slave registration
                </p><p style="color:blue;">report_port：连接从机的端口，在从机注册期间报告给主机</p></li><li class="listitem"><p>
                    <code class="literal"><a class="link" href="replication.html#sysvar_report_user">report_user</a></code>:
                    An arbitrary user name that a slave server should report to
                    the master. Not the same as the name used with the MySQL
                    replication user account.
                </p><p style="color:blue;">报表用户：从服务器应向主服务器报告的任意用户名。与mysql复制用户帐户使用的名称不同。</p></li><li class="listitem"><p>
                    <code class="literal"><a class="link" href="server-administration.html#statvar_Rpl_semi_sync_master_clients">Rpl_semi_sync_master_clients</a></code>:
                    Number of semisynchronous slaves
                </p><p style="color:blue;">rpl_semi_sync_master_clients:半同步从机的数量</p></li><li class="listitem"><p>
                    <code class="literal"><a class="link" href="replication.html#sysvar_rpl_semi_sync_master_enabled">rpl_semi_sync_master_enabled</a></code>:
                    Whether semisynchronous replication is enabled on the master
                </p><p style="color:blue;">rpl_semi_sync_master_enabled:是否在主机上启用半同步复制</p></li><li class="listitem"><p>
                    <code class="literal"><a class="link" href="server-administration.html#statvar_Rpl_semi_sync_master_net_avg_wait_time">Rpl_semi_sync_master_net_avg_wait_time</a></code>:
                    The average time the master waited for a slave reply
                </p><p style="color:blue;">rpl_semi_sync_master_net_avg_wait_time:主机等待从机应答的平均时间</p></li><li class="listitem"><p>
                    <code class="literal"><a class="link" href="server-administration.html#statvar_Rpl_semi_sync_master_net_wait_time">Rpl_semi_sync_master_net_wait_time</a></code>:
                    The total time the master waited for slave replies
                </p><p style="color:blue;">rpl_semi_sync_master_net_wait_time:主机等待从机回复的总时间</p></li><li class="listitem"><p>
                    <code class="literal"><a class="link" href="server-administration.html#statvar_Rpl_semi_sync_master_net_waits">Rpl_semi_sync_master_net_waits</a></code>:
                    The total number of times the master waited for slave replies
                </p><p style="color:blue;">rpl_semi_sync_master_net_waits：主机等待从机回复的总次数</p></li><li class="listitem"><p>
                    <code class="literal"><a class="link" href="server-administration.html#statvar_Rpl_semi_sync_master_no_times">Rpl_semi_sync_master_no_times</a></code>:
                    Number of times the master turned off semisynchronous
                    replication
                </p><p style="color:blue;">rpl_semi_sync_master_no_times:主机关闭半同步复制的次数</p></li><li class="listitem"><p>
                    <code class="literal"><a class="link" href="server-administration.html#statvar_Rpl_semi_sync_master_no_tx">Rpl_semi_sync_master_no_tx</a></code>:
                    Number of commits not acknowledged successfully
                </p><p style="color:blue;">rpl_semi_sync_master_no_tx:未成功确认提交数</p></li><li class="listitem"><p>
                    <code class="literal"><a class="link" href="server-administration.html#statvar_Rpl_semi_sync_master_status">Rpl_semi_sync_master_status</a></code>:
                    Whether semisynchronous replication is operational on the
                    master
                </p><p style="color:blue;">rpl_semi_sync_master_状态：是否在master上运行半同步复制</p></li><li class="listitem"><p>
                    <code class="literal"><a class="link" href="server-administration.html#statvar_Rpl_semi_sync_master_timefunc_failures">Rpl_semi_sync_master_timefunc_failures</a></code>:
                    Number of times the master failed when calling time functions
                </p><p style="color:blue;">rpl_semi_sync_master_timefunc_failures:调用时间函数时，主机失败的次数</p></li><li class="listitem"><p>
                    <code class="literal"><a class="link" href="replication.html#sysvar_rpl_semi_sync_master_timeout">rpl_semi_sync_master_timeout</a></code>:
                    Number of milliseconds to wait for slave acknowledgment
                </p><p style="color:blue;">rpl_semi_sync_master_timeout:等待从机确认的毫秒数</p></li><li class="listitem"><p>
                    <code class="literal"><a class="link" href="replication.html#sysvar_rpl_semi_sync_master_trace_level">rpl_semi_sync_master_trace_level</a></code>:
                    The semisynchronous replication debug trace level on the
                    master
                </p><p style="color:blue;">rpl_semi_sync_master_trace_level：主机上的半同步复制调试跟踪级别</p></li><li class="listitem"><p>
                    <code class="literal"><a class="link" href="server-administration.html#statvar_Rpl_semi_sync_master_tx_avg_wait_time">Rpl_semi_sync_master_tx_avg_wait_time</a></code>:
                    The average time the master waited for each transaction
                </p><p style="color:blue;">rpl_semi_sync_master_tx_avg_wait_time：主服务器等待每个事务的平均时间</p></li><li class="listitem"><p>
                    <code class="literal"><a class="link" href="server-administration.html#statvar_Rpl_semi_sync_master_tx_wait_time">Rpl_semi_sync_master_tx_wait_time</a></code>:
                    The total time the master waited for transactions
                </p><p style="color:blue;">rpl_semi_sync_master_tx_wait_time:主机等待事务的总时间</p></li><li class="listitem"><p>
                    <code class="literal"><a class="link" href="server-administration.html#statvar_Rpl_semi_sync_master_tx_waits">Rpl_semi_sync_master_tx_waits</a></code>:
                    The total number of times the master waited for transactions
                </p><p style="color:blue;">rpl_semi_sync_master_tx_waits：主服务器等待事务的总次数</p></li><li class="listitem"><p>
                    <code class="literal"><a class="link" href="replication.html#sysvar_rpl_semi_sync_master_wait_for_slave_count">rpl_semi_sync_master_wait_for_slave_count</a></code>:
                    How many slave acknowledgments the master must receive per
                    transaction before proceeding
                </p><p style="color:blue;">rpl_semi_sync_master_wait_for_slave_count:在继续之前，主服务器必须为每个事务接收多少从确认</p></li><li class="listitem"><p>
                    <code class="literal"><a class="link" href="replication.html#sysvar_rpl_semi_sync_master_wait_no_slave">rpl_semi_sync_master_wait_no_slave</a></code>:
                    Whether master waits for timeout even with no slaves
                </p><p style="color:blue;">rpl_semi_sync_master_wait_no_slave：即使没有从机，主机是否等待超时</p></li><li class="listitem"><p>
                    <code class="literal"><a class="link" href="replication.html#sysvar_rpl_semi_sync_master_wait_point">rpl_semi_sync_master_wait_point</a></code>:
                    The wait point for slave transaction receipt acknowledgment
                </p><p style="color:blue;">rpl_semi_sync_master_wait_point：从事务接收确认的等待点</p></li><li class="listitem"><p>
                    <code class="literal"><a class="link" href="server-administration.html#statvar_Rpl_semi_sync_master_wait_pos_backtraverse">Rpl_semi_sync_master_wait_pos_backtraverse</a></code>:
                    The total number of times the master waited for an event with
                    binary coordinates lower than events waited for previously
                </p><p style="color:blue;">rpl_semi_sync_master_wait_pos_backtraverse：主节点等待二进制坐标低于先前等待的事件的总次数</p></li><li class="listitem"><p>
                    <code class="literal"><a class="link" href="server-administration.html#statvar_Rpl_semi_sync_master_wait_sessions">Rpl_semi_sync_master_wait_sessions</a></code>:
                    Number of sessions currently waiting for slave replies
                </p><p style="color:blue;">rpl_semi_sync_master_wait_会话：当前等待从机响应的会话数</p></li><li class="listitem"><p>
                    <code class="literal"><a class="link" href="server-administration.html#statvar_Rpl_semi_sync_master_yes_tx">Rpl_semi_sync_master_yes_tx</a></code>:
                    Number of commits acknowledged successfully
                </p><p style="color:blue;">rpl_semi_sync_master_yes_tx:成功确认的提交数</p></li><li class="listitem"><p>
                    <code class="literal"><a class="link" href="replication.html#sysvar_rpl_semi_sync_slave_enabled">rpl_semi_sync_slave_enabled</a></code>:
                    Whether semisynchronous replication is enabled on slave
                </p><p style="color:blue;">rpl_semi_sync_slave_enabled:是否在slave上启用半同步复制</p></li><li class="listitem"><p>
                    <code class="literal"><a class="link" href="server-administration.html#statvar_Rpl_semi_sync_slave_status">Rpl_semi_sync_slave_status</a></code>:
                    Whether semisynchronous replication is operational on slave
                </p><p style="color:blue;">rpl_semi_sync_slave_状态：半同步复制是否在slave上运行</p></li><li class="listitem"><p>
                    <code class="literal"><a class="link" href="replication.html#sysvar_rpl_semi_sync_slave_trace_level">rpl_semi_sync_slave_trace_level</a></code>:
                    The semisynchronous replication debug trace level on the slave
                </p><p style="color:blue;">rpl_semi_sync_slave_trace_level：从机上的半同步复制调试跟踪级别</p></li><li class="listitem"><p>
                    <code class="literal"><a class="link" href="replication.html#sysvar_rpl_stop_slave_timeout">rpl_stop_slave_timeout</a></code>:
                    Set the number of seconds that STOP SLAVE waits before timing
                    out
                </p><p style="color:blue;">rpl_stop_slave_timeout：设置在超时之前停止从机等待的秒数</p></li><li class="listitem"><p>
                    <code class="literal"><a class="link" href="replication.html#sysvar_server_uuid">server_uuid</a></code>:
                    The server's globally unique ID, automatically (re)generated
                    at server start
                </p><p style="color:blue;">服务器ID：服务器的全局唯一ID，在服务器启动时自动（重新）生成</p></li><li class="listitem"><p>
                    <code class="literal"><a class="link" href="replication.html#option_mysqld_show-slave-auth-info">show-slave-auth-info</a></code>:
                    Show user name and password in SHOW SLAVE HOSTS on this master
                </p><p style="color:blue;">show slave auth info：在此主机上的show slave hosts中显示用户名和密码</p></li><li class="listitem"><p>
                    <code class="literal"><a class="link" href="replication.html#sysvar_simplified_binlog_gtid_recovery">simplified_binlog_gtid_recovery</a></code>:
                    Renamed to binlog_gtid_simple_recovery
                </p><p style="color:blue;">simplified_binlog_gtid_recovery：重命名为binlog_gtid_simple_recovery</p></li><li class="listitem"><p>
                    <code class="literal"><a class="link" href="replication.html#option_mysqld_skip-slave-start">skip-slave-start</a></code>:
                    If set, slave is not autostarted
                </p><p style="color:blue;">跳过从机启动：如果设置，从机不自动启动</p></li><li class="listitem"><p>
                    <code class="literal"><a class="link" href="replication.html#option_mysqld_slave-checkpoint-group">slave-checkpoint-group</a></code>:
                    Maximum number of transactions processed by a multithreaded
                    slave before a checkpoint operation is called to update
                    progress status. Not supported by NDB Cluster.
                </p><p style="color:blue;">从属检查点组：在检查点操作之前调用多线程从属件处理的最大事务数以更新进度状态。ndb群集不支持。</p></li><li class="listitem"><p>
                    <code class="literal"><a class="link" href="replication.html#option_mysqld_slave-checkpoint-period">slave-checkpoint-period</a></code>:
                    Update progress status of multithreaded slave and flush relay
                    log info to disk after this number of milliseconds. Not
                    supported by NDB Cluster.
                </p><p style="color:blue;">从机检查点周期：更新多线程从机的进度状态，并在此毫秒数后将中继日志信息刷新到磁盘。ndb群集不支持。</p></li><li class="listitem"><p>
                    <code class="literal"><a class="link" href="replication.html#option_mysqld_slave-load-tmpdir">slave-load-tmpdir</a></code>:
                    The location where the slave should put its temporary files
                    when replicating a LOAD DATA statement
                </p><p style="color:blue;">slave load tmpdir：当复制load data语句时，slave应将其临时文件放在的位置</p></li><li class="listitem"><p>
                    <code class="literal"><a class="link" href="replication.html#option_mysqld_slave-max-allowed-packet">slave-max-allowed-packet</a></code>:
                    Maximum size, in bytes, of a packet that can be sent from a
                    replication master to a slave; overrides max_allowed_packet
                </p><p style="color:blue;">从属最大允许分组：可从复制主机发送到从属的分组的最大大小（以字节为单位）；重写Max允许的数据包</p></li><li class="listitem"><p>
                    <code class="literal"><a class="link" href="replication.html#option_mysqld_slave-net-timeout">slave-net-timeout</a></code>:
                    Number of seconds to wait for more data from a master/slave
                    connection before aborting the read
                </p><p style="color:blue;">从网超时：在中止读取之前等待来自主/从连接的更多数据的秒数</p></li><li class="listitem"><p>
                    <code class="literal"><a class="link" href="replication.html#option_mysqld_slave-parallel-type">slave-parallel-type</a></code>:
                    Tells the slave to use timestamp information (LOGICAL_CLOCK)
                    or database partioning (DATABASE) to parallelize transactions.
                    The default is LOGICAL_CLOCK.
                </p><p style="color:blue;">从机并行类型：告诉从机使用时间戳信息（逻辑时钟）或数据库分区（数据库）来并行事务。默认值是逻辑时钟。</p></li><li class="listitem"><p>
                    <code class="literal"><a class="link" href="replication.html#option_mysqld_slave-parallel-workers">slave-parallel-workers</a></code>:
                    Number of applier threads for executing replication
                    transactions in parallel. The default is 4 applier threads.
                    Set to 0 to disable slave multithreading. Not supported by
                    MySQL Cluster.
                </p><p style="color:blue;">从属并行工作线程：用于并行执行复制事务的applier线程数。默认为4个applier线程。设置为0可禁用从属多线程。MySQL群集不支持。</p></li><li class="listitem"><p>
                    <code class="literal"><a class="link" href="replication.html#option_mysqld_slave-pending-jobs-size-max">slave-pending-jobs-size-max</a></code>:
                    Maximum size of slave worker queues holding events not yet
                    applied
                </p><p style="color:blue;">从挂起的作业大小MAX：没有应用的事件的从属工作者队列的最大大小</p></li><li class="listitem"><p>
                    <code class="literal"><a class="link" href="replication.html#option_mysqld_slave-rows-search-algorithms">slave-rows-search-algorithms</a></code>:
                    Determines search algorithms used for slave update batching.
                    Any 2 or 3 from the list INDEX_SEARCH, TABLE_SCAN, HASH_SCAN
                </p><p style="color:blue;">从行搜索算法：确定用于从更新批处理的搜索算法。列表索引搜索、表扫描、哈希扫描中的任意2或3</p></li><li class="listitem"><p>
                    <code class="literal"><a class="link" href="replication.html#option_mysqld_slave-skip-errors">slave-skip-errors</a></code>:
                    Tells the slave thread to continue replication when a query
                    returns an error from the provided list
                </p><p style="color:blue;">slave skip errors：告诉从线程在查询从提供的列表返回错误时继续复制</p></li><li class="listitem"><p>
                    <code class="literal"><a class="link" href="replication.html#sysvar_slave_checkpoint_group">slave_checkpoint_group</a></code>:
                    Maximum number of transactions processed by a multithreaded
                    slave before a checkpoint operation is called to update
                    progress status. Not supported by NDB Cluster.
                </p><p style="color:blue;">SLaveXCuffoPositToxGROUP：在检查点操作之前调用多线程从属件处理的最大事务数以更新进度状态。ndb群集不支持。</p></li><li class="listitem"><p>
                    <code class="literal"><a class="link" href="replication.html#sysvar_slave_checkpoint_period">slave_checkpoint_period</a></code>:
                    Update progress status of multithreaded slave and flush relay
                    log info to disk after this number of milliseconds. Not
                    supported by NDB Cluster.
                </p><p style="color:blue;">slave_checkpoint_period：更新多线程从机的进度状态，并在此毫秒数后将中继日志信息刷新到磁盘。ndb群集不支持。</p></li><li class="listitem"><p>
                    <code class="literal"><a class="link" href="replication.html#sysvar_slave_compressed_protocol">slave_compressed_protocol</a></code>:
                    Use compression of master/slave protocol
                </p><p style="color:blue;">从压缩协议：使用主/从压缩协议</p></li><li class="listitem"><p>
                    <code class="literal"><a class="link" href="replication.html#sysvar_slave_exec_mode">slave_exec_mode</a></code>:
                    Allows for switching the slave thread between IDEMPOTENT mode
                    (key and some other errors suppressed) and STRICT mode; STRICT
                    mode is the default, except for NDB Cluster, where IDEMPOTENT
                    is always used
                </p><p style="color:blue;">slave_exec_mode：允许在幂等模式（键和一些其他错误被抑制）和严格模式之间切换从线程；严格模式是默认的，除了ndb集群，在ndb集群中总是使用幂等模式。</p></li><li class="listitem"><p>
                    <code class="literal"><a class="link" href="server-administration.html#statvar_Slave_heartbeat_period">Slave_heartbeat_period</a></code>:
                    The slave's replication heartbeat interval, in seconds
                </p><p style="color:blue;">slave_heartbeat_period：从机的复制心跳间隔，以秒为单位</p></li><li class="listitem"><p>
                    <code class="literal"><a class="link" href="server-administration.html#statvar_Slave_last_heartbeat">Slave_last_heartbeat</a></code>:
                    Shows when the latest heartbeat signal was received, in
                    TIMESTAMP format
                </p><p style="color:blue;">slave_last_heartbeat：以时间戳格式显示何时接收到最新的心跳信号</p></li><li class="listitem"><p>
                    <code class="literal"><a class="link" href="replication.html#sysvar_slave_max_allowed_packet">slave_max_allowed_packet</a></code>:
                    Maximum size, in bytes, of a packet that can be sent from a
                    replication master to a slave; overrides max_allowed_packet
                </p><p style="color:blue;">SLaveMax Max PaleDead分组：可从复制主机发送到从设备的最大大小（以字节为单位）；重写Max允许的数据包</p></li><li class="listitem"><p>
                    <code class="literal"><a class="link" href="server-administration.html#statvar_Slave_open_temp_tables">Slave_open_temp_tables</a></code>:
                    Number of temporary tables that the slave SQL thread currently
                    has open
                </p><p style="color:blue;">slave_open_temp_tables：从SQL线程当前打开的临时表数</p></li><li class="listitem"><p>
                    <code class="literal"><a class="link" href="replication.html#sysvar_slave_parallel_type">slave_parallel_type</a></code>:
                    Tells the slave to use timestamp information (LOGICAL_CLOCK)
                    or database partioning (DATABASE) to parallelize transactions.
                </p><p style="color:blue;">slave_parallel_type：告诉slave使用时间戳信息（逻辑时钟）或数据库分区（数据库）来并行化事务。</p></li><li class="listitem"><p>
                    <code class="literal"><a class="link" href="replication.html#sysvar_slave_parallel_workers">slave_parallel_workers</a></code>:
                    Number of applier threads for executing replication
                    transactions in parallel. A value of 0 disables slave
                    multithreading. Not supported by MySQL Cluster.
                </p><p style="color:blue;">slave_parallel_workers：并行执行复制事务的applier线程数。值为0将禁用从属多线程。MySQL群集不支持。</p></li><li class="listitem"><p>
                    <code class="literal"><a class="link" href="replication.html#sysvar_slave_pending_jobs_size_max">slave_pending_jobs_size_max</a></code>:
                    Maximum size of slave worker queues holding events not yet
                    applied
                </p><p style="color:blue;">SLavePiangsPojsSsiZyMax：保存尚未应用的事件的从属工作者队列的最大大小</p></li><li class="listitem"><p>
                    <code class="literal"><a class="link" href="replication.html#sysvar_slave_preserve_commit_order">slave_preserve_commit_order</a></code>:
                    Ensures that all commits by slave workers happen in the same
                    order as on the master to maintain consistency when using
                    parallel applier threads.
                </p><p style="color:blue;">slave_preserve_commit_order：确保在使用并行applier线程时，slave worker的所有提交都按照与主线程相同的顺序进行，以保持一致性。</p></li><li class="listitem"><p>
                    <code class="literal"><a class="link" href="server-administration.html#statvar_Slave_received_heartbeats">Slave_received_heartbeats</a></code>:
                    Number of heartbeats received by a replication slave since
                    previous reset
                </p><p style="color:blue;">Slave_Received_Heartbeats：自上次重置后复制从属服务器接收的心跳数</p></li><li class="listitem"><p>
                    <code class="literal"><a class="link" href="server-administration.html#statvar_Slave_retried_transactions">Slave_retried_transactions</a></code>:
                    The total number of times since startup that the replication
                    slave SQL thread has retried transactions
                </p><p style="color:blue;">slave_retried_transactions：自启动以来复制slave sql线程重试事务的总次数</p></li><li class="listitem"><p>
                    <code class="literal"><a class="link" href="replication.html#sysvar_slave_rows_search_algorithms">slave_rows_search_algorithms</a></code>:
                    Determines search algorithms used for slave update batching.
                    Any 2 or 3 from the list INDEX_SEARCH, TABLE_SCAN, HASH_SCAN.
                </p><p style="color:blue;">从行搜索算法：确定用于从更新批处理的搜索算法。列表索引搜索、表扫描、哈希扫描中的任意2或3。</p></li><li class="listitem"><p>
                    <code class="literal"><a class="link" href="server-administration.html#statvar_Slave_rows_last_search_algorithm_used">Slave_rows_last_search_algorithm_used</a></code>:
                    Search algorithm most recently used by this slave to locate
                    rows for row-based replication (index, table, or hash scan)
                </p><p style="color:blue;">slave_rows_last_search_algorithm_used:此slave最近使用的搜索算法，用于定位基于行的复制（索引、表或哈希扫描）的行</p></li><li class="listitem"><p>
                    <code class="literal"><a class="link" href="server-administration.html#statvar_Slave_running">Slave_running</a></code>:
                    The state of this server as a replication slave (slave I/O
                    thread status)
                </p><p style="color:blue;">从机运行：此服务器作为复制从机的状态（从机I/O线程状态）</p></li><li class="listitem"><p>
                    <code class="literal"><a class="link" href="replication.html#sysvar_slave_transaction_retries">slave_transaction_retries</a></code>:
                    Number of times the slave SQL thread will retry a transaction
                    in case it failed with a deadlock or elapsed lock wait
                    timeout, before giving up and stopping
                </p><p style="color:blue;">slave_transaction_retries：如果事务因死锁或经过的锁等待超时而失败，则slave sql线程将重试该事务的次数，然后放弃并停止</p></li><li class="listitem"><p>
                    <code class="literal"><a class="link" href="replication.html#sysvar_slave_type_conversions">slave_type_conversions</a></code>:
                    Controls type conversion mode on replication slave. Value is a
                    list of zero or more elements from the list: ALL_LOSSY,
                    ALL_NON_LOSSY. Set to an empty string to disallow type
                    conversions between master and slave.
                </p><p style="color:blue;">从机类型转换：控制复制从机上的类型转换模式。值是列表中零个或多个元素的列表：所有有损，所有无损。设置为空字符串以禁止主和从之间的类型转换。</p></li><li class="listitem"><p>
                    <code class="literal"><a class="link" href="replication.html#sysvar_sql_log_bin">sql_log_bin</a></code>:
                    Controls binary logging for the current session
                </p><p style="color:blue;">sql_log_bin:控制当前会话的二进制日志记录</p></li><li class="listitem"><p>
                    <code class="literal"><a class="link" href="replication.html#sysvar_sql_slave_skip_counter">sql_slave_skip_counter</a></code>:
                    Number of events from the master that a slave server should
                    skip. Not compatible with GTID replication.
                </p><p style="color:blue;">SQL_slave_skip_计数器：从服务器应跳过的主服务器事件数。与gtid复制不兼容。</p></li><li class="listitem"><p>
                    <code class="literal"><a class="link" href="replication.html#sysvar_sync_master_info">sync_master_info</a></code>:
                    Synchronize master.info to disk after every #th event
                </p><p style="color:blue;">同步主机信息：每次事件后将主机信息同步到磁盘</p></li><li class="listitem"><p>
                    <code class="literal"><a class="link" href="replication.html#sysvar_sync_relay_log">sync_relay_log</a></code>:
                    Synchronize relay log to disk after every #th event
                </p><p style="color:blue;">sync_relay_u log：每次事件后将中继日志同步到磁盘</p></li><li class="listitem"><p>
                    <code class="literal"><a class="link" href="replication.html#sysvar_sync_relay_log_info">sync_relay_log_info</a></code>:
                    Synchronize relay.info file to disk after every #th event
                </p><p style="color:blue;">sync_relay_log_info：每次事件后将relay.info文件同步到磁盘</p></li><li class="listitem"><p>
                    <code class="literal"><a class="link" href="replication.html#sysvar_transaction_write_set_extraction">transaction_write_set_extraction</a></code>:
                    Defines the algorithm used to hash the writes extracted during
                    a transaction
                </p><p style="color:blue;">transaction_write_set_extraction：定义用于散列事务期间提取的写入的算法</p></li></ul>
                </div>
                <p>
                    The command-line options and system variables in the following
                    list relate to the binary log.
                    <a class="xref" href="replication.html#replication-options-binary-log" title="16.1.6.4&nbsp;Binary Logging Options and Variables">Section&nbsp;16.1.6.4, “Binary Logging Options and Variables”</a>, provides more
                    detailed information about options and variables relating to
                    binary logging. For additional general information about the
                    binary log, see <a class="xref" href="server-administration.html#binary-log" title="5.4.4&nbsp;The Binary Log">Section&nbsp;5.4.4, “The Binary Log”</a>.
                </p><p style="color:blue;">下表中的命令行选项和系统变量与二进制日志相关。第16.1.6.4节“二进制日志选项和变量”提供了有关二进制日志选项和变量的更详细信息。有关二进制日志的其他一般信息，请参见第5.4.4节“二进制日志”。</p>
                <div class="itemizedlist">
                    <a name="binlog-optvar-summary-list"></a><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                    <code class="literal"><a class="link" href="replication.html#option_mysqld_binlog-checksum">binlog-checksum</a></code>:
                    Enable/disable binary log checksums
                </p><p style="color:blue;">binlog校验和：启用/禁用二进制日志校验和</p></li><li class="listitem"><p>
                    <code class="literal"><a class="link" href="replication.html#option_mysqld_binlog-do-db">binlog-do-db</a></code>:
                    Limits binary logging to specific databases
                </p><p style="color:blue;">binlog do db：将二进制日志记录限制到特定数据库</p></li><li class="listitem"><p>
                    <code class="literal"><a class="link" href="replication.html#sysvar_binlog_format">binlog_format</a></code>:
                    Specifies the format of the binary log
                </p><p style="color:blue;">binlog_format：指定二进制日志的格式</p></li><li class="listitem"><p>
                    <code class="literal"><a class="link" href="replication.html#option_mysqld_binlog-ignore-db">binlog-ignore-db</a></code>:
                    Tells the master that updates to the given database should not
                    be logged to the binary log
                </p><p style="color:blue;">binlog ignore db：告诉主机不应将对给定数据库的更新记录到二进制日志中</p></li><li class="listitem"><p>
                    <code class="literal"><a class="link" href="replication.html#option_mysqld_binlog-row-event-max-size">binlog-row-event-max-size</a></code>:
                    Binary log max event size
                </p><p style="color:blue;">binlog row event max size：二进制日志最大事件大小</p></li><li class="listitem"><p>
                    <code class="literal"><a class="link" href="server-administration.html#statvar_Binlog_cache_disk_use">Binlog_cache_disk_use</a></code>:
                    Number of transactions that used a temporary file instead of
                    the binary log cache
                </p><p style="color:blue;">binlog_cache_disk_use:使用临时文件而不是二进制日志缓存的事务数</p></li><li class="listitem"><p>
                    <code class="literal"><a class="link" href="replication.html#sysvar_binlog_cache_size">binlog_cache_size</a></code>:
                    Size of the cache to hold the SQL statements for the binary
                    log during a transaction
                </p><p style="color:blue;">binlog_cache_size：在事务期间保存二进制日志的sql语句的缓存大小</p></li><li class="listitem"><p>
                    <code class="literal"><a class="link" href="server-administration.html#statvar_Binlog_cache_use">Binlog_cache_use</a></code>:
                    Number of transactions that used the temporary binary log
                    cache
                </p><p style="color:blue;">binlog_cache_use:使用临时二进制日志缓存的事务数</p></li><li class="listitem"><p>
                    <code class="literal"><a class="link" href="replication.html#sysvar_binlog_checksum">binlog_checksum</a></code>:
                    Enable/disable binary log checksums
                </p><p style="color:blue;">binlog_校验和：启用/禁用二进制日志校验和</p></li><li class="listitem"><p>
                    <code class="literal"><a class="link" href="replication.html#sysvar_binlog_direct_non_transactional_updates">binlog_direct_non_transactional_updates</a></code>:
                    Causes updates using statement format to nontransactional
                    engines to be written directly to binary log. See
                    documentation before using.
                </p><p style="color:blue;">binlog_direct_non_transactional_updates：导致使用语句格式对非事务引擎的更新直接写入二进制日志。使用前请参阅文档。</p></li><li class="listitem"><p>
                    <code class="literal"><a class="link" href="replication.html#sysvar_binlog_error_action">binlog_error_action</a></code>:
                    Controls what happens when the server cannot write to the
                    binary log
                </p><p style="color:blue;">binlog_error_action：控制服务器无法写入二进制日志时发生的情况</p></li><li class="listitem"><p>
                    <code class="literal"><a class="link" href="replication.html#sysvar_binlog_group_commit_sync_delay">binlog_group_commit_sync_delay</a></code>:
                    Sets the number of microseconds to wait before synchronizing
                    transactions to disk
                </p><p style="color:blue;">binlog_group_commit_sync_delay：设置将事务同步到磁盘之前等待的微秒数</p></li><li class="listitem"><p>
                    <code class="literal"><a class="link" href="replication.html#sysvar_binlog_group_commit_sync_no_delay_count">binlog_group_commit_sync_no_delay_count</a></code>:
                    Sets the maximum number of transactions to wait for before
                    aborting the current delay specified by
                    binlog_group_commit_sync_delay
                </p><p style="color:blue;">BILogLogyGROPpICONSONSCONCYNOSY DelayyLoCurn:设置在终止由BiLogyGROPpIONCOMPION SCORCYSTROM指定的当前延迟之前等待的事务的最大数量</p></li><li class="listitem"><p>
                    <code class="literal"><a class="link" href="replication.html#sysvar_binlog_max_flush_queue_time">binlog_max_flush_queue_time</a></code>:
                    How long to read transactions before flushing to binary log
                </p><p style="color:blue;">binlog_max_flush_queue_time:刷新到二进制日志之前读取事务的时间</p></li><li class="listitem"><p>
                    <code class="literal"><a class="link" href="replication.html#sysvar_binlog_order_commits">binlog_order_commits</a></code>:
                    Whether to commit in same order as writes to binary log
                </p><p style="color:blue;">binlog_order_commits：是否按写入二进制日志的相同顺序提交</p></li><li class="listitem"><p>
                    <code class="literal"><a class="link" href="replication.html#sysvar_binlog_row_image">binlog_row_image</a></code>:
                    Use full or minimal images when logging row changes
                </p><p style="color:blue;">binlog_row_image：记录行更改时使用完整或最小图像</p></li><li class="listitem"><p>
                    <code class="literal"><a class="link" href="replication.html#sysvar_binlog_rows_query_log_events">binlog_rows_query_log_events</a></code>:
                    When enabled, enables logging of rows query log events when
                    using row-based logging. Disabled by default. Do not enable
                    when producing logs for pre-5.6 slaves/readers.
                </p><p style="color:blue;">binlog_rows_query_log_events：启用时，在使用基于行的日志记录时启用行日志记录查询日志事件。默认情况下禁用。为5.6以前的从机/读卡器生成日志时不要启用。</p></li><li class="listitem"><p>
                    <code class="literal"><a class="link" href="server-administration.html#statvar_Binlog_stmt_cache_disk_use">Binlog_stmt_cache_disk_use</a></code>:
                    Number of nontransactional statements that used a temporary
                    file instead of the binary log statement cache
                </p><p style="color:blue;">binlog_stmt_cache_disk_use:使用临时文件而不是二进制日志语句缓存的非事务语句数</p></li><li class="listitem"><p>
                    <code class="literal"><a class="link" href="replication.html#sysvar_binlog_stmt_cache_size">binlog_stmt_cache_size</a></code>:
                    Size of the cache to hold nontransactional statements for the
                    binary log during a transaction
                </p><p style="color:blue;">binlog_stmt_cache_size：在事务期间保存二进制日志的非事务语句的缓存大小</p></li><li class="listitem"><p>
                    <code class="literal"><a class="link" href="server-administration.html#statvar_Binlog_stmt_cache_use">Binlog_stmt_cache_use</a></code>:
                    Number of statements that used the temporary binary log
                    statement cache
                </p><p style="color:blue;">binlog_stmt_cache_use:使用临时二进制日志语句缓存的语句数</p></li><li class="listitem"><p>
                    <code class="literal"><a class="link" href="replication.html#sysvar_binlog_transaction_dependency_tracking">binlog_transaction_dependency_tracking</a></code>:
                    Source of dependency information (commit timestamps or
                    transaction write sets) from which to assess which
                    transactions can be executed in parallel by slave's
                    multithreaded applier.
                </p><p style="color:blue;">binlog_transaction_dependency_tracking：依赖信息（提交时间戳或事务写入集）的来源，用于评估哪些事务可以由从机的多线程应用程序并行执行。</p></li><li class="listitem"><p>
                    <code class="literal"><a class="link" href="replication.html#sysvar_binlog_transaction_dependency_history_size">binlog_transaction_dependency_history_size</a></code>:
                    Number of row hashes kept for looking up transaction that last
                    updated some row.
                </p><p style="color:blue;">binlog_transaction_dependency_history_size:为查找上次更新某些行的事务而保留的行哈希数。</p></li><li class="listitem"><p>
                    <code class="literal"><a class="link" href="replication.html#sysvar_binlogging_impossible_mode">binlogging_impossible_mode</a></code>:
                    Deprecated and will be removed in a future version. Use the
                    renamed binlog_error_action instead.
                </p><p style="color:blue;">binlogging_impossible_mode:已弃用，将在以后的版本中删除。改用重命名的binlog_error_操作。</p></li><li class="listitem"><p>
                    <code class="literal"><a class="link" href="server-administration.html#statvar_Com_xxx">Com_show_binlog_events</a></code>:
                    Count of SHOW BINLOG EVENTS statements
                </p><p style="color:blue;">com_show_binlog_events:show binlog events语句的计数</p></li><li class="listitem"><p>
                    <code class="literal"><a class="link" href="server-administration.html#statvar_Com_xxx">Com_show_binlogs</a></code>:
                    Count of SHOW BINLOGS statements
                </p><p style="color:blue;">com_show_binlogs:show binlogs语句的计数</p></li><li class="listitem"><p>
                    <code class="literal"><a class="link" href="replication.html#option_mysqld_log-bin">log-bin</a></code>:
                    Specifies the base name for binary log files
                </p><p style="color:blue;">log bin：指定二进制日志文件的基名称</p></li><li class="listitem"><p>
                    <code class="literal"><a class="link" href="replication.html#option_mysqld_log-bin-index">log-bin-index</a></code>:
                    Specifies the name for the binary log index file
                </p><p style="color:blue;">日志箱索引：指定二进制日志索引文件的名称</p></li><li class="listitem"><p>
                    <code class="literal"><a class="link" href="replication.html#sysvar_log_bin">log_bin</a></code>:
                    Whether the binary log is enabled
                </p><p style="color:blue;">log_bin:是否启用二进制日志</p></li><li class="listitem"><p>
                    <code class="literal"><a class="link" href="replication.html#sysvar_log_bin_basename">log_bin_basename</a></code>:
                    Path and base name for binary log files
                </p><p style="color:blue;">log_bin_base name：二进制日志文件的路径和基名称</p></li><li class="listitem"><p>
                    <code class="literal"><a class="link" href="replication.html#sysvar_log_bin_use_v1_row_events">log_bin_use_v1_row_events</a></code>:
                    Whether server is using version 1 binary log row events
                </p><p style="color:blue;">log_bin_use_v1_row_events:服务器是否正在使用版本1二进制日志行事件</p></li><li class="listitem"><p>
                    <code class="literal"><a class="link" href="replication.html#sysvar_log_slave_updates">log_slave_updates</a></code>:
                    Whether the slave should log the updates performed by its SQL
                    thread to its own binary log
                </p><p style="color:blue;">log_slave_updates：从服务器是否应该将其sql线程执行的更新记录到自己的二进制日志中</p></li><li class="listitem"><p>
                    <code class="literal"><a class="link" href="replication.html#option_mysqld_master-verify-checksum">master-verify-checksum</a></code>:
                    Cause master to examine checksums when reading from the binary
                    log
                </p><p style="color:blue;">master verify checksum：使master在读取二进制日志时检查校验和</p></li><li class="listitem"><p>
                    <code class="literal"><a class="link" href="replication.html#sysvar_master_verify_checksum">master_verify_checksum</a></code>:
                    Cause master to read checksums from binary log
                </p><p style="color:blue;">master_verify_校验和：使master从二进制日志中读取校验和</p></li><li class="listitem"><p>
                    <code class="literal"><a class="link" href="replication.html#option_mysqld_max-binlog-dump-events">max-binlog-dump-events</a></code>:
                    Option used by mysql-test for debugging and testing of
                    replication
                </p><p style="color:blue;">max binlog dump events：mysql test用于调试和测试复制的选项</p></li><li class="listitem"><p>
                    <code class="literal"><a class="link" href="replication.html#sysvar_max_binlog_cache_size">max_binlog_cache_size</a></code>:
                    Can be used to restrict the total size used to cache a
                    multi-statement transaction
                </p><p style="color:blue;">max_binlog_cache_size:可用于限制用于缓存多语句事务的总大小</p></li><li class="listitem"><p>
                    <code class="literal"><a class="link" href="replication.html#sysvar_max_binlog_size">max_binlog_size</a></code>:
                    Binary log will be rotated automatically when size exceeds
                    this value
                </p><p style="color:blue;">最大二进制日志大小：当大小超过此值时，二进制日志将自动旋转</p></li><li class="listitem"><p>
                    <code class="literal"><a class="link" href="replication.html#sysvar_max_binlog_stmt_cache_size">max_binlog_stmt_cache_size</a></code>:
                    Can be used to restrict the total size used to cache all
                    nontransactional statements during a transaction
                </p><p style="color:blue;">max_binlog_stmt_cache_size:可用于限制用于在事务期间缓存所有非事务语句的总大小</p></li><li class="listitem"><p>
                    <code class="literal"><a class="link" href="replication.html#option_mysqld_slave-sql-verify-checksum">slave-sql-verify-checksum</a></code>:
                    Cause slave to examine checksums when reading from the relay
                    log
                </p><p style="color:blue;">slave sql verify checksum：使slave在从中继日志读取时检查校验和</p></li><li class="listitem"><p>
                    <code class="literal"><a class="link" href="replication.html#sysvar_slave_sql_verify_checksum">slave_sql_verify_checksum</a></code>:
                    Cause slave to examine checksums when reading from relay log
                </p><p style="color:blue;">slave_sql_verify_checksum：使slave在从中继日志读取时检查校验和</p></li><li class="listitem"><p>
                    <code class="literal"><a class="link" href="replication.html#option_mysqld_sporadic-binlog-dump-fail">sporadic-binlog-dump-fail</a></code>:
                    Option used by mysql-test for debugging and testing of
                    replication
                </p><p style="color:blue;">零星binlog转储失败：mysql test用于调试和测试复制的选项</p></li><li class="listitem"><p>
                    <code class="literal"><a class="link" href="replication.html#sysvar_sync_binlog">sync_binlog</a></code>:
                    Synchronously flush binary log to disk after every #th event
                </p><p style="color:blue;">sync_binlog：每次事件后同步将二进制日志刷新到磁盘</p></li></ul>
                </div>
                <p>
                    For a listing of <span class="emphasis"><em>all</em></span> command-line options,
                    system and status variables used with <a class="link" href="programs.html#mysqld" title="4.3.1&nbsp;mysqld — The MySQL Server"><span class="command"><strong>mysqld</strong></span></a>,
                    see <a class="xref" href="server-administration.html#server-option-variable-reference" title="5.1.3&nbsp;Server Option, System Variable, and Status Variable Reference">Section&nbsp;5.1.3, “Server Option, System Variable, and Status Variable Reference”</a>.
                </p><p style="color:blue;">有关与mysqld一起使用的所有命令行选项、系统和状态变量的列表，请参阅5.1.3节“服务器选项、系统变量和状态变量参考”。</p>
            </div>
            <div class="section">
                <div class="titlepage">
                    <div>
                        <div>
                            <h4 class="title"><a name="replication-options-master"></a>16.1.6.2&nbsp;Replication Master Options and Variables</h4>

                        </div>

                    </div>

                </div>
                <p>
                    This section describes the server options and system variables
                    that you can use on replication master servers. You can specify
                    the options either on the
                    <a class="link" href="programs.html#command-line-options" title="4.2.2.1&nbsp;Using Options on the Command Line">command line</a> or in an
                    <a class="link" href="programs.html#option-files" title="4.2.2.2&nbsp;Using Option Files">option file</a>. You can specify
                    system variable values using
                    <a class="link" href="sql-syntax.html#set-variable" title="13.7.4.1&nbsp;SET Syntax for Variable Assignment"><code class="literal">SET</code></a>.
                </p><p style="color:blue;">本节介绍可以在复制主服务器上使用的服务器选项和系统变量。可以在命令行或选项文件中指定选项。可以使用set指定系统变量值。</p><p>
                On the master and each slave, you must use the
                <a class="link" href="replication.html#option_mysqld_server-id"><code class="option">server-id</code></a> option to establish a
                unique replication ID. For each server, you should pick a unique
                positive integer in the range from 1 to
                2<sup>32</sup> − 1, and each ID must be
                different from every other ID in use by any other replication
                master or slave. Example: <code class="literal">server-id=3</code>.
            </p><p style="color:blue;">在主服务器和每个从服务器上，必须使用“服务器ID”选项来建立唯一的复制ID。对于每个服务器，应选择1到232-1范围内的唯一正整数，并且每个ID必须与任何其他复制主服务器或从服务器使用的每个其他ID不同。示例：服务器ID=3。</p><p>
                For options used on the master for controlling binary logging, see
                <a class="xref" href="replication.html#replication-options-binary-log" title="16.1.6.4&nbsp;Binary Logging Options and Variables">Section&nbsp;16.1.6.4, “Binary Logging Options and Variables”</a>.
            </p><p style="color:blue;">有关主机上用于控制二进制日志记录的选项，请参阅第16.1.6.4节“二进制日志记录选项和变量”。</p>
                <div class="simplesect">

                    <div class="titlepage">
                        <div>

                            <div class="simple">
                                <h5 class="title"><a name="replication-optvars-masters"></a>Startup Options for Replication Masters</h5>
                            </div>
                        </div>
                    </div>
                    <p>
                        The following list describes startup options for controlling
                        replication master servers. Replication-related system variables
                        are discussed later in this section.
                    </p><p style="color:blue;">下表描述了用于控制复制主服务器的启动选项。本节稍后将讨论与复制相关的系统变量。</p>
                    <div class="itemizedlist">
                        <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><a name="option_mysqld_show-slave-auth-info"></a>
                            <a class="indexterm" name="idm140286800091152"></a>

                            <a class="indexterm" name="idm140286800089696"></a>

                            <a class="link" href="replication.html#option_mysqld_show-slave-auth-info"><code class="option">--show-slave-auth-info</code></a>
                        </p><p style="color:blue;">--显示从属身份验证信息</p>
                            <div class="informaltable">
                                <table frame="box" rules="all" summary="Properties for show-slave-auth-info"><colgroup><col width="30%"><col width="70%"></colgroup><thead><tr><th scope="col">Property</th>
                                    <th scope="col">Value</th>
                                </tr></thead><tbody><tr><td scope="row"><span class="bold"><strong>Command-Line Format</strong></span></td>
                                    <td><code class="literal">--show-slave-auth-info[={OFF|ON}]</code></td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Type</strong></span></td>
                                    <td>Boolean</td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Default Value</strong></span></td>
                                    <td><code class="literal">OFF</code></td>
                                </tr></tbody></table>
                            </div>
                            <p>
                                Display slave user names and passwords in the output of
                                <a class="link" href="sql-syntax.html#show-slave-hosts" title="13.7.5.33&nbsp;SHOW SLAVE HOSTS Syntax"><code class="literal">SHOW SLAVE HOSTS</code></a> on the
                                master server for slaves started with the
                                <a class="link" href="replication.html#sysvar_report_user"><code class="option">--report-user</code></a> and
                                <a class="link" href="replication.html#sysvar_report_password"><code class="option">--report-password</code></a> options.
                            </p><p style="color:blue;">在主服务器上的show slave hosts的输出中为使用--report user和--report password选项启动的从机显示从机用户名和密码。</p></li></ul>
                    </div>

                </div>
                <div class="simplesect">
                    <div class="titlepage">
                        <div>
                            <div class="simple">
                                <h5 class="title"><a name="replication-sysvars-masters"></a>System Variables Used on Replication Masters</h5>

                            </div>

                        </div>

                    </div>
                    <p>
                        The following system variables are used to control replication
                        masters:
                    </p><p style="color:blue;">以下系统变量用于控制复制主机：</p>
                    <div class="itemizedlist">
                        <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><a name="sysvar_auto_increment_increment"></a>
                            <a class="indexterm" name="idm140286800065264"></a>

                            <a class="indexterm" name="idm140286800064160"></a>

                            <a class="link" href="replication.html#sysvar_auto_increment_increment"><code class="literal">auto_increment_increment</code></a>
                        </p><p style="color:blue;">自动递增</p>
                            <div class="informaltable">
                                <table frame="box" rules="all" summary="Properties for auto_increment_increment"><colgroup><col width="30%"><col width="70%"></colgroup><thead><tr><th scope="col">Property</th>
                                    <th scope="col">Value</th>
                                </tr></thead><tbody><tr><td scope="row"><span class="bold"><strong>Command-Line Format</strong></span></td>
                                    <td><code class="literal">--auto-increment-increment=#</code></td>
                                </tr><tr><td scope="row"><span class="bold"><strong>System Variable</strong></span></td>
                                    <td><code class="literal"><a class="link" href="replication.html#sysvar_auto_increment_increment">auto_increment_increment</a></code></td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Scope</strong></span></td>
                                    <td>Global, Session</td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Dynamic</strong></span></td>
                                    <td>Yes</td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Type</strong></span></td>
                                    <td>Integer</td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Default Value</strong></span></td>
                                    <td><code class="literal">1</code></td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Minimum Value</strong></span></td>
                                    <td><code class="literal">1</code></td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Maximum Value</strong></span></td>
                                    <td><code class="literal">65535</code></td>
                                </tr></tbody></table>
                            </div>
                            <p>
                                <a class="link" href="replication.html#sysvar_auto_increment_increment"><code class="literal">auto_increment_increment</code></a>
                                and <a class="link" href="replication.html#sysvar_auto_increment_offset"><code class="literal">auto_increment_offset</code></a>
                                are intended for use with master-to-master replication, and
                                can be used to control the operation of
                                <code class="literal">AUTO_INCREMENT</code> columns. Both variables
                                have global and session values, and each can assume an
                                integer value between 1 and 65,535 inclusive. Setting the
                                value of either of these two variables to 0 causes its value
                                to be set to 1 instead. Attempting to set the value of
                                either of these two variables to an integer greater than
                                65,535 or less than 0 causes its value to be set to 65,535
                                instead. Attempting to set the value of
                                <a class="link" href="replication.html#sysvar_auto_increment_increment"><code class="literal">auto_increment_increment</code></a> or
                                <a class="link" href="replication.html#sysvar_auto_increment_offset"><code class="literal">auto_increment_offset</code></a> to a
                                noninteger value produces an error, and the actual value of
                                the variable remains unchanged.
                            </p><p style="color:blue;">auto_increment_increment和auto_increment_offset用于从主复制到主复制，可用于控制auto_increment列的操作。这两个变量都有全局和会话值，并且每个变量都可以假设一个介于1和65535之间的整数值（包括1和65535）。将这两个变量中的任何一个的值设置为0会导致将其值设置为1。如果试图将这两个变量的值设置为大于65535或小于0的整数，则会将其值设置为65535。试图将auto_increment_increment或auto_increment_offset的值设置为非整数值会产生错误，并且变量的实际值保持不变。</p>
                            <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">

                                <div class="admon-title">
                                    Note
                                </div>
                                <p>
                                    <a class="link" href="replication.html#sysvar_auto_increment_increment"><code class="literal">auto_increment_increment</code></a>
                                    is also supported for use with
                                    <a class="link" href="mysql-cluster.html" title="Chapter&nbsp;21&nbsp;MySQL NDB Cluster 7.5 and NDB Cluster 7.6"><code class="literal">NDB</code></a> tables.
                                </p><p style="color:blue;">自动增量也支持与ndb表一起使用。</p>
                            </div>
                            <p>
                                When Group Replication is started on a server, the value of
                                <a class="link" href="replication.html#sysvar_auto_increment_increment"><code class="literal">auto_increment_increment</code></a> is
                                changed to the value of
                                <a class="link" href="group-replication.html#sysvar_group_replication_auto_increment_increment"><code class="literal">group_replication_auto_increment_increment</code></a>,
                                which defaults to 7, and the value of
                                <a class="link" href="replication.html#sysvar_auto_increment_offset"><code class="literal">auto_increment_offset</code></a> is
                                changed to the server ID. The changes are reverted when
                                Group Replication is stopped. These changes are only made
                                and reverted if
                                <a class="link" href="replication.html#sysvar_auto_increment_increment"><code class="literal">auto_increment_increment</code></a>
                                and <a class="link" href="replication.html#sysvar_auto_increment_offset"><code class="literal">auto_increment_offset</code></a>
                                each have their default value of 1. If their values have
                                already been modified from the default, Group Replication
                                does not alter them.
                            </p><p style="color:blue;">在服务器上启动组复制时，自动增量值更改为组复制增量值（默认为7），自动增量偏移值更改为服务器ID。当组复制停止时，更改将还原。仅当“自动增量”和“自动增量偏移”的默认值均为1时，才会进行和还原这些更改。如果已从默认值修改了它们的值，则组复制不会更改它们。</p><p>
                                <a class="link" href="replication.html#sysvar_auto_increment_increment"><code class="literal">auto_increment_increment</code></a>
                                and <a class="link" href="replication.html#sysvar_auto_increment_offset"><code class="literal">auto_increment_offset</code></a>
                                affect <code class="literal">AUTO_INCREMENT</code> column behavior as
                                follows:
                            </p><p style="color:blue;">auto_increment_increment和auto_increment_offset影响auto_increment列的行为，如下所示：</p>
                            <div class="itemizedlist">
                                <ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
                                    <a class="link" href="replication.html#sysvar_auto_increment_increment"><code class="literal">auto_increment_increment</code></a>
                                    controls the interval between successive column values.
                                    For example:
                                </p><p style="color:blue;">自动递增控制连续列值之间的间隔。例如：</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>SHOW VARIABLES LIKE 'auto_inc%';</code></strong>
+--------------------------+-------+
| Variable_name            | Value |
+--------------------------+-------+
| auto_increment_increment | 1     |
| auto_increment_offset    | 1     |
+--------------------------+-------+
2 rows in set (0.00 sec)

mysql&gt; <strong class="userinput"><code>CREATE TABLE autoinc1</code></strong>
    -&gt; <strong class="userinput"><code>(col INT NOT NULL AUTO_INCREMENT PRIMARY KEY);</code></strong>
  Query OK, 0 rows affected (0.04 sec)

mysql&gt; <strong class="userinput"><code>SET @@auto_increment_increment=10;</code></strong>
Query OK, 0 rows affected (0.00 sec)

mysql&gt; <strong class="userinput"><code>SHOW VARIABLES LIKE 'auto_inc%';</code></strong>
+--------------------------+-------+
| Variable_name            | Value |
+--------------------------+-------+
| auto_increment_increment | 10    |
| auto_increment_offset    | 1     |
+--------------------------+-------+
2 rows in set (0.01 sec)

mysql&gt; <strong class="userinput"><code>INSERT INTO autoinc1 VALUES (NULL), (NULL), (NULL), (NULL);</code></strong>
Query OK, 4 rows affected (0.00 sec)
Records: 4  Duplicates: 0  Warnings: 0

mysql&gt; <strong class="userinput"><code>SELECT col FROM autoinc1;</code></strong>
+-----+
| col |
+-----+
|   1 |
|  11 |
|  21 |
|  31 |
+-----+
4 rows in set (0.00 sec)
</pre></li><li class="listitem"><p>
                                    <a class="link" href="replication.html#sysvar_auto_increment_offset"><code class="literal">auto_increment_offset</code></a>
                                    determines the starting point for the
                                    <code class="literal">AUTO_INCREMENT</code> column value. Consider
                                    the following, assuming that these statements are
                                    executed during the same session as the example given in
                                    the description for
                                    <a class="link" href="replication.html#sysvar_auto_increment_increment"><code class="literal">auto_increment_increment</code></a>:
                                </p><p style="color:blue;">auto_increment_offset确定auto_increment列值的起点。考虑以下情况，假设这些语句与auto_increment_increment说明中给出的示例在同一会话中执行：</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>SET @@auto_increment_offset=5;</code></strong>
Query OK, 0 rows affected (0.00 sec)

mysql&gt; <strong class="userinput"><code>SHOW VARIABLES LIKE 'auto_inc%';</code></strong>
+--------------------------+-------+
| Variable_name            | Value |
+--------------------------+-------+
| auto_increment_increment | 10    |
| auto_increment_offset    | 5     |
+--------------------------+-------+
2 rows in set (0.00 sec)

mysql&gt; <strong class="userinput"><code>CREATE TABLE autoinc2</code></strong>
    -&gt; <strong class="userinput"><code>(col INT NOT NULL AUTO_INCREMENT PRIMARY KEY);</code></strong>
Query OK, 0 rows affected (0.06 sec)

mysql&gt; <strong class="userinput"><code>INSERT INTO autoinc2 VALUES (NULL), (NULL), (NULL), (NULL);</code></strong>
Query OK, 4 rows affected (0.00 sec)
Records: 4  Duplicates: 0  Warnings: 0

mysql&gt; <strong class="userinput"><code>SELECT col FROM autoinc2;</code></strong>
+-----+
| col |
+-----+
|   5 |
|  15 |
|  25 |
|  35 |
+-----+
4 rows in set (0.02 sec)
</pre><p>
                                    When the value of
                                    <a class="link" href="replication.html#sysvar_auto_increment_offset"><code class="literal">auto_increment_offset</code></a>
                                    is greater than that of
                                    <a class="link" href="replication.html#sysvar_auto_increment_increment"><code class="literal">auto_increment_increment</code></a>,
                                    the value of
                                    <a class="link" href="replication.html#sysvar_auto_increment_offset"><code class="literal">auto_increment_offset</code></a>
                                    is ignored.
                                </p><p style="color:blue;">当“自动增量补偿”的值大于“自动增量补偿”的值时，将忽略“自动增量补偿”的值。</p></li></ul>
                            </div>
                            <p>
                                If either of these variables is changed, and then new rows
                                inserted into a table containing an
                                <code class="literal">AUTO_INCREMENT</code> column, the results may
                                seem counterintuitive because the series of
                                <code class="literal">AUTO_INCREMENT</code> values is calculated
                                without regard to any values already present in the column,
                                and the next value inserted is the least value in the series
                                that is greater than the maximum existing value in the
                                <code class="literal">AUTO_INCREMENT</code> column. The series is
                                calculated like this:
                            </p><p style="color:blue;">如果更改了这些变量中的任何一个，然后将新行插入到包含自动递增列的表中，则结果可能看起来不太直观，因为自动递增值系列的计算不考虑列中已存在的任何值，插入的下一个值是该系列中的最小值，大于AutoMyAdvestin列中的最大现有值。序列的计算方式如下：</p><p>
                                <code class="literal">auto_increment_offset</code> +
                                <em class="replaceable"><code>N</code></em> ×
                                <code class="literal">auto_increment_increment</code>
                            </p><p style="color:blue;">自动递增补偿+n×自动递增补偿</p><p>
                                where <em class="replaceable"><code>N</code></em> is a positive integer
                                value in the series [1, 2, 3, ...]. For example:
                            </p><p style="color:blue;">其中n是序列[1，2，3，…]中的正整数值。例如：</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>SHOW VARIABLES LIKE 'auto_inc%';</code></strong>
+--------------------------+-------+
| Variable_name            | Value |
+--------------------------+-------+
| auto_increment_increment | 10    |
| auto_increment_offset    | 5     |
+--------------------------+-------+
2 rows in set (0.00 sec)

mysql&gt; <strong class="userinput"><code>SELECT col FROM autoinc1;</code></strong>
+-----+
| col |
+-----+
|   1 |
|  11 |
|  21 |
|  31 |
+-----+
4 rows in set (0.00 sec)

mysql&gt; <strong class="userinput"><code>INSERT INTO autoinc1 VALUES (NULL), (NULL), (NULL), (NULL);</code></strong>
Query OK, 4 rows affected (0.00 sec)
Records: 4  Duplicates: 0  Warnings: 0

mysql&gt; <strong class="userinput"><code>SELECT col FROM autoinc1;</code></strong>
+-----+
| col |
+-----+
|   1 |
|  11 |
|  21 |
|  31 |
|  35 |
|  45 |
|  55 |
|  65 |
+-----+
8 rows in set (0.00 sec)
</pre><p>
                                The values shown for
                                <a class="link" href="replication.html#sysvar_auto_increment_increment"><code class="literal">auto_increment_increment</code></a>
                                and <a class="link" href="replication.html#sysvar_auto_increment_offset"><code class="literal">auto_increment_offset</code></a>
                                generate the series 5 + <em class="replaceable"><code>N</code></em> ×
                                10, that is, [5, 15, 25, 35, 45, ...]. The highest value
                                present in the <code class="literal">col</code> column prior to the
                                <a class="link" href="sql-syntax.html#insert" title="13.2.5&nbsp;INSERT Syntax"><code class="literal">INSERT</code></a> is 31, and the next
                                available value in the <code class="literal">AUTO_INCREMENT</code>
                                series is 35, so the inserted values for
                                <code class="literal">col</code> begin at that point and the results
                                are as shown for the <a class="link" href="sql-syntax.html#select" title="13.2.9&nbsp;SELECT Syntax"><code class="literal">SELECT</code></a>
                                query.
                            </p><p style="color:blue;">显示的“自动增量”和“自动增量”偏移值生成序列5+N×10，即，[5、15、25、35、45，…]。插入前col列中的最大值是31，auto_increment series中的下一个可用值是35，因此col的插入值从该点开始，结果如select查询所示。</p><p>
                                It is not possible to restrict the effects of these two
                                variables to a single table; these variables control the
                                behavior of all <code class="literal">AUTO_INCREMENT</code> columns in
                                <span class="emphasis"><em>all</em></span> tables on the MySQL server. If the
                                global value of either variable is set, its effects persist
                                until the global value is changed or overridden by setting
                                the session value, or until <a class="link" href="programs.html#mysqld" title="4.3.1&nbsp;mysqld — The MySQL Server"><span class="command"><strong>mysqld</strong></span></a> is
                                restarted. If the local value is set, the new value affects
                                <code class="literal">AUTO_INCREMENT</code> columns for all tables
                                into which new rows are inserted by the current user for the
                                duration of the session, unless the values are changed
                                during that session.
                            </p><p style="color:blue;">无法将这两个变量的效果限制为一个表；这些变量控制mysql服务器上所有表中所有自动递增列的行为。如果设置了任一变量的全局值，则其效果将一直持续，直到通过设置会话值更改或重写全局值，或者直到mysqld重新启动。如果设置了本地值，则新值将影响当前用户在会话期间插入新行的所有表的自动递增列，除非在该会话期间更改了这些值。</p><p>
                                The default value of
                                <a class="link" href="replication.html#sysvar_auto_increment_increment"><code class="literal">auto_increment_increment</code></a> is
                                1. See
                                <a class="xref" href="replication.html#replication-features-auto-increment" title="16.4.1.1&nbsp;Replication and AUTO_INCREMENT">Section&nbsp;16.4.1.1, “Replication and AUTO_INCREMENT”</a>.
                            </p><p style="color:blue;">“自动增量”的默认值为1。见第16.4.1.1节“复制和自动增量”。</p></li><li class="listitem"><p><a name="sysvar_auto_increment_offset"></a>
                            <a class="indexterm" name="idm140286799958144"></a>

                            <a class="indexterm" name="idm140286799957104"></a>

                            <a class="link" href="replication.html#sysvar_auto_increment_offset"><code class="literal">auto_increment_offset</code></a>
                        </p><p style="color:blue;">自动增量偏移</p>
                            <div class="informaltable">
                                <table frame="box" rules="all" summary="Properties for auto_increment_offset"><colgroup><col width="30%"><col width="70%"></colgroup><thead><tr><th scope="col">Property</th>
                                    <th scope="col">Value</th>
                                </tr></thead><tbody><tr><td scope="row"><span class="bold"><strong>Command-Line Format</strong></span></td>
                                    <td><code class="literal">--auto-increment-offset=#</code></td>
                                </tr><tr><td scope="row"><span class="bold"><strong>System Variable</strong></span></td>
                                    <td><code class="literal"><a class="link" href="replication.html#sysvar_auto_increment_offset">auto_increment_offset</a></code></td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Scope</strong></span></td>
                                    <td>Global, Session</td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Dynamic</strong></span></td>
                                    <td>Yes</td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Type</strong></span></td>
                                    <td>Integer</td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Default Value</strong></span></td>
                                    <td><code class="literal">1</code></td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Minimum Value</strong></span></td>
                                    <td><code class="literal">1</code></td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Maximum Value</strong></span></td>
                                    <td><code class="literal">65535</code></td>
                                </tr></tbody></table>
                            </div>
                            <p>
                                This variable has a default value of 1. If it is left with
                                its default value, and Group Replication is started on the
                                server, it is changed to the server ID. For more
                                information, see the description for
                                <a class="link" href="replication.html#sysvar_auto_increment_increment"><code class="literal">auto_increment_increment</code></a>.
                            </p><p style="color:blue;">此变量的默认值为1。如果保留默认值，并且在服务器上启动组复制，则将其更改为服务器ID。有关详细信息，请参阅“自动增量”的说明。</p>
                            <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">

                                <div class="admon-title">
                                    Note
                                </div>
                                <p>
                                    <code class="literal">auto_increment_offset</code> is also supported
                                    for use with <a class="link" href="mysql-cluster.html" title="Chapter&nbsp;21&nbsp;MySQL NDB Cluster 7.5 and NDB Cluster 7.6"><code class="literal">NDB</code></a> tables.
                                </p><p style="color:blue;">自动增量偏移也支持与ndb表一起使用。</p>
                            </div>
                        </li><li class="listitem"><p><a name="sysvar_rpl_semi_sync_master_enabled"></a>
                            <a class="indexterm" name="idm140286799918544"></a>

                            <a class="indexterm" name="idm140286799917440"></a>

                            <a class="link" href="replication.html#sysvar_rpl_semi_sync_master_enabled"><code class="literal">rpl_semi_sync_master_enabled</code></a>
                        </p><p style="color:blue;">rpl_semi_sync_master_已启用</p>
                            <div class="informaltable">
                                <table frame="box" rules="all" summary="Properties for rpl_semi_sync_master_enabled"><colgroup><col width="30%"><col width="70%"></colgroup><thead><tr><th scope="col">Property</th>
                                    <th scope="col">Value</th>
                                </tr></thead><tbody><tr><td scope="row"><span class="bold"><strong>Command-Line Format</strong></span></td>
                                    <td><code class="literal">--rpl-semi-sync-master-enabled[={OFF|ON}]</code></td>
                                </tr><tr><td scope="row"><span class="bold"><strong>System Variable</strong></span></td>
                                    <td><code class="literal"><a class="link" href="replication.html#sysvar_rpl_semi_sync_master_enabled">rpl_semi_sync_master_enabled</a></code></td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Scope</strong></span></td>
                                    <td>Global</td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Dynamic</strong></span></td>
                                    <td>Yes</td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Type</strong></span></td>
                                    <td>Boolean</td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Default Value</strong></span></td>
                                    <td><code class="literal">OFF</code></td>
                                </tr></tbody></table>
                            </div>
                            <p>
                                Controls whether semisynchronous replication is enabled on
                                the master. To enable or disable the plugin, set this
                                variable to <code class="literal">ON</code> or <code class="literal">OFF</code>
                                (or 1 or 0), respectively. The default is
                                <code class="literal">OFF</code>.
                            </p><p style="color:blue;">控制是否在主机上启用半同步复制。要启用或禁用插件，请分别将此变量设置为on或off（或1或0）。默认设置为“关闭”。</p><p>
                                This variable is available only if the master-side
                                semisynchronous replication plugin is installed.
                            </p><p style="color:blue;">仅当安装了主端半同步复制插件时，此变量才可用。</p></li><li class="listitem"><p><a name="sysvar_rpl_semi_sync_master_timeout"></a>
                            <a class="indexterm" name="idm140286799886464"></a>

                            <a class="indexterm" name="idm140286799885360"></a>

                            <a class="link" href="replication.html#sysvar_rpl_semi_sync_master_timeout"><code class="literal">rpl_semi_sync_master_timeout</code></a>
                        </p><p style="color:blue;">半同步主机超时</p>
                            <div class="informaltable">
                                <table frame="box" rules="all" summary="Properties for rpl_semi_sync_master_timeout"><colgroup><col width="30%"><col width="70%"></colgroup><thead><tr><th scope="col">Property</th>
                                    <th scope="col">Value</th>
                                </tr></thead><tbody><tr><td scope="row"><span class="bold"><strong>Command-Line Format</strong></span></td>
                                    <td><code class="literal">--rpl-semi-sync-master-timeout=#</code></td>
                                </tr><tr><td scope="row"><span class="bold"><strong>System Variable</strong></span></td>
                                    <td><code class="literal"><a class="link" href="replication.html#sysvar_rpl_semi_sync_master_timeout">rpl_semi_sync_master_timeout</a></code></td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Scope</strong></span></td>
                                    <td>Global</td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Dynamic</strong></span></td>
                                    <td>Yes</td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Type</strong></span></td>
                                    <td>Integer</td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Default Value</strong></span></td>
                                    <td><code class="literal">10000</code></td>
                                </tr></tbody></table>
                            </div>
                            <p>
                                A value in milliseconds that controls how long the master
                                waits on a commit for acknowledgment from a slave before
                                timing out and reverting to asynchronous replication. The
                                default value is 10000 (10 seconds).
                            </p><p style="color:blue;">一个以毫秒为单位的值，用于控制主服务器在超时并还原到异步复制之前等待从服务器提交确认的时间。默认值为10000（10秒）。</p><p>
                                This variable is available only if the master-side
                                semisynchronous replication plugin is installed.
                            </p><p style="color:blue;">仅当安装了主端半同步复制插件时，此变量才可用。</p></li><li class="listitem"><p><a name="sysvar_rpl_semi_sync_master_trace_level"></a>
                            <a class="indexterm" name="idm140286799856160"></a>

                            <a class="indexterm" name="idm140286799855056"></a>

                            <a class="link" href="replication.html#sysvar_rpl_semi_sync_master_trace_level"><code class="literal">rpl_semi_sync_master_trace_level</code></a>
                        </p><p style="color:blue;">RPL_Semi_Sync_Master_Trace_级别</p>
                            <div class="informaltable">
                                <table frame="box" rules="all" summary="Properties for rpl_semi_sync_master_trace_level"><colgroup><col width="30%"><col width="70%"></colgroup><thead><tr><th scope="col">Property</th>
                                    <th scope="col">Value</th>
                                </tr></thead><tbody><tr><td scope="row"><span class="bold"><strong>Command-Line Format</strong></span></td>
                                    <td><code class="literal">--rpl-semi-sync-master-trace-level=#</code></td>
                                </tr><tr><td scope="row"><span class="bold"><strong>System Variable</strong></span></td>
                                    <td><code class="literal"><a class="link" href="replication.html#sysvar_rpl_semi_sync_master_trace_level">rpl_semi_sync_master_trace_level</a></code></td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Scope</strong></span></td>
                                    <td>Global</td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Dynamic</strong></span></td>
                                    <td>Yes</td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Type</strong></span></td>
                                    <td>Integer</td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Default Value</strong></span></td>
                                    <td><code class="literal">32</code></td>
                                </tr></tbody></table>
                            </div>
                            <p>
                                The semisynchronous replication debug trace level on the
                                master. Four levels are defined:
                            </p><p style="color:blue;">主服务器上的半同步复制调试跟踪级别。定义了四个级别：</p>
                            <div class="itemizedlist">
                                <ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
                                    1 = general level (for example, time function failures)
                                </p><p style="color:blue;">1=一般级别（例如，时间功能故障）</p></li><li class="listitem"><p>
                                    16 = detail level (more verbose information)
                                </p><p style="color:blue;">16=详细程度（更多详细信息）</p></li><li class="listitem"><p>
                                    32 = net wait level (more information about network
                                    waits)
                                </p><p style="color:blue;">32=网络等待级别（有关网络等待的更多信息）</p></li><li class="listitem"><p>
                                    64 = function level (information about function entry
                                    and exit)
                                </p><p style="color:blue;">64 =函数级别（关于函数输入和退出的信息）</p></li></ul>
                            </div>
                            <p>
                                This variable is available only if the master-side
                                semisynchronous replication plugin is installed.
                            </p><p style="color:blue;">仅当安装了主端半同步复制插件时，此变量才可用。</p></li><li class="listitem"><p><a name="sysvar_rpl_semi_sync_master_wait_for_slave_count"></a>
                            <a class="indexterm" name="idm140286799822288"></a>

                            <a class="indexterm" name="idm140286799821168"></a>

                            <a class="link" href="replication.html#sysvar_rpl_semi_sync_master_wait_for_slave_count"><code class="literal">rpl_semi_sync_master_wait_for_slave_count</code></a>
                        </p><p style="color:blue;">rpl_semi_sync_master_wait_for_slave_计数</p>
                            <div class="informaltable">
                                <table frame="box" rules="all" summary="Properties for rpl_semi_sync_master_wait_for_slave_count"><colgroup><col width="30%"><col width="70%"></colgroup><thead><tr><th scope="col">Property</th>
                                    <th scope="col">Value</th>
                                </tr></thead><tbody><tr><td scope="row"><span class="bold"><strong>Command-Line Format</strong></span></td>
                                    <td><code class="literal">--rpl-semi-sync-master-wait-for-slave-count=#</code></td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Introduced</strong></span></td>
                                    <td>5.7.3</td>
                                </tr><tr><td scope="row"><span class="bold"><strong>System Variable</strong></span></td>
                                    <td><code class="literal"><a class="link" href="replication.html#sysvar_rpl_semi_sync_master_wait_for_slave_count">rpl_semi_sync_master_wait_for_slave_count</a></code></td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Scope</strong></span></td>
                                    <td>Global</td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Dynamic</strong></span></td>
                                    <td>Yes</td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Type</strong></span></td>
                                    <td>Integer</td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Default Value</strong></span></td>
                                    <td><code class="literal">1</code></td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Minimum Value</strong></span></td>
                                    <td><code class="literal">1</code></td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Maximum Value</strong></span></td>
                                    <td><code class="literal">65535</code></td>
                                </tr></tbody></table>
                            </div>
                            <p>
                                The number of slave acknowledgments the master must receive
                                per transaction before proceeding. By default
                                <code class="literal">rpl_semi_sync_master_wait_for_slave_count</code>
                                is <code class="literal">1</code>, meaning that semisynchronous
                                replication proceeds after receiving a single slave
                                acknowledgment. Performance is best for small values of this
                                variable.
                            </p><p style="color:blue;">在继续之前，主服务器必须接收每个事务的从属确认的数目。默认情况下，rpl_semi_sync_master_wait_for_slave_count为1，这意味着半同步复制在收到单个从机确认后继续进行。此变量的值越小，性能越好。</p><p>
                                For example, if
                                <code class="literal">rpl_semi_sync_master_wait_for_slave_count</code>
                                is <code class="literal">2</code>, then 2 slaves must acknowledge
                                receipt of the transaction before the timeout period
                                configured by
                                <a class="link" href="replication.html#sysvar_rpl_semi_sync_master_timeout"><code class="literal">rpl_semi_sync_master_timeout</code></a>
                                for semisynchronous replication to proceed. If less slaves
                                acknowledge receipt of the transaction during the timeout
                                period, the master reverts to normal replication.
                            </p><p style="color:blue;">例如，如果rpl_semi_sync_master_wait_for_slave_count为2，则2个slave必须在rpl_semi_sync_master_timeout为半同步复制配置的超时时间之前确认收到事务。如果在超时期间收到事务的从属服务器较少，则主服务器将恢复正常复制。</p>
                            <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">

                                <div class="admon-title">
                                    Note
                                </div>
                                <p>
                                    This behavior also depends on
                                    <a class="link" href="replication.html#sysvar_rpl_semi_sync_master_wait_no_slave"><code class="literal">rpl_semi_sync_master_wait_no_slave</code></a>
                                </p><p style="color:blue;">此行为还取决于rpl_semi_sync_master_wait_no_slave</p>
                            </div>
                            <p>
                                This variable is available only if the master-side
                                semisynchronous replication plugin is installed.
                            </p><p style="color:blue;">仅当安装了主端半同步复制插件时，此变量才可用。</p></li><li class="listitem"><p><a name="sysvar_rpl_semi_sync_master_wait_no_slave"></a>
                            <a class="indexterm" name="idm140286799776080"></a>

                            <a class="indexterm" name="idm140286799775040"></a>

                            <a class="link" href="replication.html#sysvar_rpl_semi_sync_master_wait_no_slave"><code class="literal">rpl_semi_sync_master_wait_no_slave</code></a>
                        </p><p style="color:blue;">rpl_semi_sync_master_wait_no_slave半同步主/从</p>
                            <div class="informaltable">
                                <table frame="box" rules="all" summary="Properties for rpl_semi_sync_master_wait_no_slave"><colgroup><col width="30%"><col width="70%"></colgroup><thead><tr><th scope="col">Property</th>
                                    <th scope="col">Value</th>
                                </tr></thead><tbody><tr><td scope="row"><span class="bold"><strong>Command-Line Format</strong></span></td>
                                    <td><code class="literal">--rpl-semi-sync-master-wait-no-slave[={OFF|ON}]</code></td>
                                </tr><tr><td scope="row"><span class="bold"><strong>System Variable</strong></span></td>
                                    <td><code class="literal"><a class="link" href="replication.html#sysvar_rpl_semi_sync_master_wait_no_slave">rpl_semi_sync_master_wait_no_slave</a></code></td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Scope</strong></span></td>
                                    <td>Global</td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Dynamic</strong></span></td>
                                    <td>Yes</td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Type</strong></span></td>
                                    <td>Boolean</td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Default Value</strong></span></td>
                                    <td><code class="literal">ON</code></td>
                                </tr></tbody></table>
                            </div>
                            <p>
                                Controls whether the master waits for the timeout period
                                configured by
                                <a class="link" href="replication.html#sysvar_rpl_semi_sync_master_timeout"><code class="literal">rpl_semi_sync_master_timeout</code></a>
                                to expire, even if the slave count drops to less than the
                                number of slaves configured by
                                <a class="link" href="replication.html#sysvar_rpl_semi_sync_master_wait_for_slave_count"><code class="literal">rpl_semi_sync_master_wait_for_slave_count</code></a>
                                during the timeout period.
                            </p><p style="color:blue;">控制主机是否等待由rpl_semi_sync_master_timeout配置的超时期间过期，即使在超时期间从机计数降至小于由rpl_semi_sync_master_wait_slave_count配置的从机数目。</p><p>
                                When the value of
                                <code class="literal">rpl_semi_sync_master_wait_no_slave</code> is
                                <code class="literal">ON</code> (the default), it is permissible for
                                the slave count to drop to less than
                                <a class="link" href="replication.html#sysvar_rpl_semi_sync_master_wait_for_slave_count"><code class="literal">rpl_semi_sync_master_wait_for_slave_count</code></a>
                                during the timeout period. As long as enough slaves
                                acknowledge the transaction before the timeout period
                                expires, semisynchronous replication continues.
                            </p><p style="color:blue;">当rpl_semi_sync_master_wait_no_slave的值为on（默认值）时，允许从机计数在超时期间下降到小于rpl_semi_sync_master_wait_for_slave计数。只要有足够多的从机在超时期限到期前确认事务，半同步复制就将继续。</p><p>
                                When the value of
                                <code class="literal">rpl_semi_sync_master_wait_no_slave</code> is
                                <code class="literal">OFF</code>, if the slave count drops to less
                                than the number configured in
                                <a class="link" href="replication.html#sysvar_rpl_semi_sync_master_wait_for_slave_count"><code class="literal">rpl_semi_sync_master_wait_for_slave_count</code></a>
                                at any time during the timeout period configured by
                                <a class="link" href="replication.html#sysvar_rpl_semi_sync_master_timeout"><code class="literal">rpl_semi_sync_master_timeout</code></a>,
                                the master reverts to normal replication.
                            </p><p style="color:blue;">当rpl_semi_sync_master_wait_no_slave的值为off时，如果在rpl_semi_sync_master_wait_for_slave_timeout配置的超时期间内的任何时间，从机计数下降到小于rpl_semi_sync_master_wait_for_slave_count中配置的数字，则主机恢复正常复制。</p><p>
                                This variable is available only if the master-side
                                semisynchronous replication plugin is installed.
                            </p><p style="color:blue;">仅当安装了主端半同步复制插件时，此变量才可用。</p></li><li class="listitem"><p><a name="sysvar_rpl_semi_sync_master_wait_point"></a>
                            <a class="indexterm" name="idm140286799735216"></a>

                            <a class="indexterm" name="idm140286799734112"></a>

                            <a class="link" href="replication.html#sysvar_rpl_semi_sync_master_wait_point"><code class="literal">rpl_semi_sync_master_wait_point</code></a>
                        </p><p style="color:blue;">半同步主机等待点</p>
                            <div class="informaltable">
                                <table frame="box" rules="all" summary="Properties for rpl_semi_sync_master_wait_point"><colgroup><col width="30%"><col width="70%"></colgroup><thead><tr><th scope="col">Property</th>
                                    <th scope="col">Value</th>
                                </tr></thead><tbody><tr><td scope="row"><span class="bold"><strong>Command-Line Format</strong></span></td>
                                    <td><code class="literal">--rpl-semi-sync-master-wait-point=value</code></td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Introduced</strong></span></td>
                                    <td>5.7.2</td>
                                </tr><tr><td scope="row"><span class="bold"><strong>System Variable</strong></span></td>
                                    <td><code class="literal"><a class="link" href="replication.html#sysvar_rpl_semi_sync_master_wait_point">rpl_semi_sync_master_wait_point</a></code></td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Scope</strong></span></td>
                                    <td>Global</td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Dynamic</strong></span></td>
                                    <td>Yes</td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Type</strong></span></td>
                                    <td>Enumeration</td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Default Value</strong></span></td>
                                    <td><code class="literal">AFTER_SYNC</code></td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Valid Values</strong></span></td>
                                    <td><p class="valid-value"><code class="literal">AFTER_SYNC</code></p><p style="color:blue;">同步后</p><p class="valid-value"><code class="literal">AFTER_COMMIT</code></p><p style="color:blue;">承诺后</p></td>
                                </tr></tbody></table>
                            </div>
                            <p>
                                This variable controls the point at which a semisynchronous
                                replication master waits for slave acknowledgment of
                                transaction receipt before returning a status to the client
                                that committed the transaction. These values are permitted:
                            </p><p style="color:blue;">此变量控制半同步复制主服务器在向提交事务的客户端返回状态之前等待从服务器确认事务接收的点。允许这些值：</p>
                            <div class="itemizedlist">
                                <ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
                                    <code class="literal">AFTER_SYNC</code> (the default): The master
                                    writes each transaction to its binary log and the slave,
                                    and syncs the binary log to disk. The master waits for
                                    slave acknowledgment of transaction receipt after the
                                    sync. Upon receiving acknowledgment, the master commits
                                    the transaction to the storage engine and returns a
                                    result to the client, which then can proceed.
                                </p><p style="color:blue;">同步后（默认）：主服务器将每个事务写入其二进制日志和从服务器，并将二进制日志同步到磁盘。主服务器在同步后等待从服务器对事务接收的确认。收到确认后，主服务器将事务提交给存储引擎，并将结果返回给客户端，然后客户端可以继续。</p></li><li class="listitem"><p>
                                    <code class="literal">AFTER_COMMIT</code>: The master writes each
                                    transaction to its binary log and the slave, syncs the
                                    binary log, and commits the transaction to the storage
                                    engine. The master waits for slave acknowledgment of
                                    transaction receipt after the commit. Upon receiving
                                    acknowledgment, the master returns a result to the
                                    client, which then can proceed.
                                </p><p style="color:blue;">提交后：主服务器将每个事务写入其二进制日志和从服务器，同步二进制日志，并将事务提交到存储引擎。主服务器在提交后等待从服务器对事务接收的确认。收到确认后，主服务器将结果返回给客户端，然后客户端可以继续。</p></li></ul>
                            </div>
                            <p>
                                The replication characteristics of these settings differ as
                                follows:
                            </p><p style="color:blue;">这些设置的复制特性如下所示：</p>
                            <div class="itemizedlist">
                                <ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
                                    With <code class="literal">AFTER_SYNC</code>, all clients see the
                                    committed transaction at the same time: After it has
                                    been acknowledged by the slave and committed to the
                                    storage engine on the master. Thus, all clients see the
                                    same data on the master.
                                </p><p style="color:blue;">使用after_sync，所有客户端都会同时看到提交的事务：在从属服务器确认并提交到主服务器上的存储引擎之后。因此，所有客户机在主机上都看到相同的数据。</p><p>
                                    In the event of master failure, all transactions
                                    committed on the master have been replicated to the
                                    slave (saved to its relay log). A crash of the master
                                    and failover to the slave is lossless because the slave
                                    is up to date. Note, however, that the master cannot be
                                    restarted in this scenario and must be discarded,
                                    because its binary log might contain uncommitted
                                    transactions that would cause a conflict with the slave
                                    when externalized after binary log recovery.
                                </p><p style="color:blue;">如果主服务器发生故障，主服务器上提交的所有事务都已复制到从服务器（保存到其中继日志）。主服务器崩溃并故障转移到从服务器是无损的，因为从服务器是最新的。但是，请注意，在这种情况下无法重新启动主服务器，必须将其丢弃，因为其二进制日志可能包含未提交的事务，这些事务在二进制日志恢复后外部化时会导致与从服务器发生冲突。</p></li><li class="listitem"><p>
                                    With <code class="literal">AFTER_COMMIT</code>, the client issuing
                                    the transaction gets a return status only after the
                                    server commits to the storage engine and receives slave
                                    acknowledgment. After the commit and before slave
                                    acknowledgment, other clients can see the committed
                                    transaction before the committing client.
                                </p><p style="color:blue;">对于after_commit，只有在服务器提交到存储引擎并收到从机确认之后，发出事务的客户端才会获得返回状态。在提交之后和从机确认之前，其他客户机可以在提交客户机之前看到提交的事务。</p><p>
                                    If something goes wrong such that the slave does not
                                    process the transaction, then in the event of a master
                                    crash and failover to the slave, it is possible that
                                    such clients will see a loss of data relative to what
                                    they saw on the master.
                                </p><p style="color:blue;">如果出了问题，使得从机无法处理事务，那么在主机崩溃并故障转移到从机的情况下，这些客户机可能会看到与它们在主机上看到的数据相关的数据丢失。</p></li></ul>
                            </div>
                            <p>
                                This variable is available only if the master-side
                                semisynchronous replication plugin is installed.
                            </p><p style="color:blue;">仅当安装了主端半同步复制插件时，此变量才可用。</p><p>
                                <a class="link" href="replication.html#sysvar_rpl_semi_sync_master_wait_point"><code class="literal">rpl_semi_sync_master_wait_point</code></a>
                                was added in MySQL 5.7.2. For older versions,
                                semisynchronous master behavior is equivalent to a setting
                                of <code class="literal">AFTER_COMMIT</code>.
                            </p><p style="color:blue;">在mysql 5.7.2中添加了rpl_semi_sync_master_wait_point。对于旧版本，半同步主行为相当于after_commit的设置。</p><p>
                                This change introduces a version compatibility constraint
                                because it increments the semisynchronous interface version:
                                Servers for MySQL 5.7.2 and up do not work with
                                semisynchronous replication plugins from older versions, nor
                                do servers from older versions work with semisynchronous
                                replication plugins for MySQL 5.7.2 and up.
                            </p><p style="color:blue;">此更改引入了版本兼容性约束，因为它增加了半同步接口版本：MySQL 5.7.2及更高版本的服务器不使用旧版本的半同步复制插件，旧版本的服务器也不使用MySQL 5.7.2及更高版本的半同步复制插件。</p></li></ul>
                    </div>

                </div>

            </div>
            <div class="section">
                <div class="titlepage">
                    <div>
                        <div>
                            <h4 class="title"><a name="replication-options-slave"></a>16.1.6.3&nbsp;Replication Slave Options and Variables</h4>

                        </div>

                    </div>

                </div>
                <p>
                    This section explains the server options and system variables that
                    apply to slave replication servers and contains the following:
                </p><p style="color:blue;">本节介绍应用于从属复制服务器的服务器选项和系统变量，其中包含以下内容：</p>
                <div class="itemizedlist">
                    <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><a class="xref" href="replication.html#replication-optvars-slaves" title="Startup Options for Replication Slaves">Startup Options for Replication Slaves</a></p><p style="color:blue;">复制从属服务器的启动选项</p></li><li class="listitem"><p><a class="xref" href="replication.html#replication-options-slave-log-tables" title="Options for Logging Slave Status to Tables">Options for Logging Slave Status to Tables</a></p><p style="color:blue;">用于将从属状态记录到表的选项</p></li><li class="listitem"><p><a class="xref" href="replication.html#replication-sysvars-slaves" title="System Variables Used on Replication Slaves">System Variables Used on Replication Slaves</a></p><p style="color:blue;">复制从机上使用的系统变量</p></li></ul>
                </div>
                <p>
                    Specify the options either on the
                    <a class="link" href="programs.html#command-line-options" title="4.2.2.1&nbsp;Using Options on the Command Line">command line</a> or in an
                    <a class="link" href="programs.html#option-files" title="4.2.2.2&nbsp;Using Option Files">option file</a>. Many of the
                    options can be set while the server is running by using the
                    <a class="link" href="sql-syntax.html#change-master-to" title="13.4.2.1&nbsp;CHANGE MASTER TO Syntax"><code class="literal">CHANGE MASTER TO</code></a> statement. Specify
                    system variable values using
                    <a class="link" href="sql-syntax.html#set-variable" title="13.7.4.1&nbsp;SET Syntax for Variable Assignment"><code class="literal">SET</code></a>.
                </p><p style="color:blue;">在命令行或选项文件中指定选项。当服务器运行时，可以使用change master to语句设置许多选项。使用set指定系统变量值。</p><p><b>Server ID.&nbsp;</b>
                On the master and each slave, you must use the
                <a class="link" href="replication.html#option_mysqld_server-id"><code class="option">server-id</code></a> option to establish a
                unique replication ID in the range from 1 to
                2<sup>32</sup> − 1. <span class="quote">“<span class="quote">Unique</span>”</span>
                means that each ID must be different from every other ID in use
                by any other replication master or slave. Example
                <code class="filename">my.cnf</code> file:
            </p><p style="color:blue;">服务器ID。在主服务器和每个从服务器上，必须使用服务器ID选项在1到232-1的范围内建立唯一的复制ID。“唯一”意味着每个ID必须与任何其他复制主机或从机使用的每个其他ID不同。示例my.cnf文件：</p><pre data-lang="ini" class="programlisting">[mysqld]
server-id=3
</pre>
                <div class="simplesect">

                    <div class="titlepage">
                        <div>

                            <div class="simple">
                                <h5 class="title"><a name="replication-optvars-slaves"></a>Startup Options for Replication Slaves</h5>
                            </div>
                        </div>
                    </div>
                    <p>
                        This section explains startup options for controlling
                        replication slave servers. Many of these options can be set
                        while the server is running by using the
                        <a class="link" href="sql-syntax.html#change-master-to" title="13.4.2.1&nbsp;CHANGE MASTER TO Syntax"><code class="literal">CHANGE MASTER TO</code></a> statement.
                        Others, such as the <code class="option">--replicate-*</code> options, can
                        be set only when the slave server starts. Replication-related
                        system variables are discussed later in this section.
                    </p><p style="color:blue;">本节介绍用于控制复制从属服务器的启动选项。当服务器运行时，可以使用change master to语句设置其中许多选项。其他选项，如--replicate-*选项，只能在从属服务器启动时设置。本节稍后将讨论与复制相关的系统变量。</p>
                    <div class="itemizedlist">
                        <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><a name="option_mysqld_log-slow-slave-statements"></a>
                            <a class="indexterm" name="idm140286799665008"></a>

                            <a class="indexterm" name="idm140286799663552"></a>

                            <a class="link" href="replication.html#option_mysqld_log-slow-slave-statements"><code class="option">--log-slow-slave-statements</code></a>
                        </p><p style="color:blue;">--记录慢从语句</p>
                            <div class="informaltable">
                                <table frame="box" rules="all" summary="Properties for log-slow-slave-statements"><colgroup><col width="30%"><col width="70%"></colgroup><thead><tr><th scope="col">Property</th>
                                    <th scope="col">Value</th>
                                </tr></thead><tbody><tr><td scope="row"><span class="bold"><strong>Command-Line Format</strong></span></td>
                                    <td><code class="literal">--log-slow-slave-statements[={OFF|ON}]</code> (5.7.0)</td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Removed</strong></span></td>
                                    <td>5.7.1</td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Type</strong></span></td>
                                    <td>Boolean</td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Default Value</strong></span></td>
                                    <td><code class="literal">OFF</code></td>
                                </tr></tbody></table>
                            </div>
                            <p>
                                This command-line option was removed in MySQL 5.7.1 and
                                replaced by the
                                <a class="link" href="replication.html#sysvar_log_slow_slave_statements"><code class="literal">log_slow_slave_statements</code></a>
                                system variable. The system variable can be set on the
                                command line or in option files the same way as the option,
                                so there is no need for any changes at server startup, but
                                the system variable also makes it possible to examine or set
                                the value at runtime.
                            </p><p style="color:blue;">这个命令行选项在mysql 5.7.1中被删除，并替换为log_slow_slave_statements系统变量。可以在命令行或选项文件中以与选项相同的方式设置系统变量，因此不需要在服务器启动时进行任何更改，但系统变量还可以在运行时检查或设置该值。</p></li><li class="listitem"><p>
                            <a class="indexterm" name="idm140286799640560"></a>

                            <a class="indexterm" name="idm140286799639072"></a>

                            <a class="link" href="server-administration.html#option_mysqld_log-warnings"><code class="option">--log-warnings[=<em class="replaceable"><code>level</code></em>]</code></a>
                        </p><p style="color:blue;">--日志警告[=级别]</p>
                            <div class="informaltable">
                                <table frame="box" rules="all" summary="Properties for log-warnings"><colgroup><col width="30%"><col width="70%"></colgroup><thead><tr><th scope="col">Property</th>
                                    <th scope="col">Value</th>
                                </tr></thead><tbody><tr><td scope="row"><span class="bold"><strong>Command-Line Format</strong></span></td>
                                    <td><code class="literal">--log-warnings[=#]</code></td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Deprecated</strong></span></td>
                                    <td>5.7.2</td>
                                </tr><tr><td scope="row"><span class="bold"><strong>System Variable</strong></span></td>
                                    <td><code class="literal"><a class="link" href="server-administration.html#sysvar_log_warnings">log_warnings</a></code></td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Scope</strong></span></td>
                                    <td>Global</td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Dynamic</strong></span></td>
                                    <td>Yes</td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Type</strong></span></td>
                                    <td>Integer</td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Default Value</strong></span> (64-bit platforms, &gt;= 5.7.2)</td>
                                    <td><code class="literal">2</code></td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Default Value</strong></span> (64-bit platforms, &lt;= 5.7.1)</td>
                                    <td><code class="literal">1</code></td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Default Value</strong></span> (32-bit platforms, &gt;= 5.7.2)</td>
                                    <td><code class="literal">2</code></td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Default Value</strong></span> (32-bit platforms, &lt;= 5.7.1)</td>
                                    <td><code class="literal">1</code></td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Minimum Value</strong></span></td>
                                    <td><code class="literal">0</code></td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Maximum Value</strong></span> (64-bit platforms)</td>
                                    <td><code class="literal">18446744073709551615</code></td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Maximum Value</strong></span> (32-bit platforms)</td>
                                    <td><code class="literal">4294967295</code></td>
                                </tr></tbody></table>
                            </div>
                            <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">
                                <div class="admon-title">
                                    Note
                                </div>
                                <p>
                                    The <a class="link" href="server-administration.html#sysvar_log_error_verbosity"><code class="literal">log_error_verbosity</code></a>
                                    system variable is preferred over, and should be used
                                    instead of, the
                                    <a class="link" href="server-administration.html#option_mysqld_log-warnings"><code class="option">--log-warnings</code></a> option or
                                    <a class="link" href="server-administration.html#sysvar_log_warnings"><code class="literal">log_warnings</code></a> system
                                    variable. For more information, see the descriptions of
                                    <a class="link" href="server-administration.html#sysvar_log_error_verbosity"><code class="literal">log_error_verbosity</code></a> and
                                    <a class="link" href="server-administration.html#sysvar_log_warnings"><code class="literal">log_warnings</code></a>. The
                                    <a class="link" href="server-administration.html#option_mysqld_log-warnings"><code class="option">--log-warnings</code></a> command-line
                                    option and <a class="link" href="server-administration.html#sysvar_log_warnings"><code class="literal">log_warnings</code></a>
                                    system variable are deprecated and will be removed in a
                                    future MySQL release.
                                </p><p style="color:blue;">与--log warnings选项或logu warnings系统变量相比，logu error_verbosity系统变量是首选的，应该使用它来代替。有关详细信息，请参阅日志详细信息和日志警告的说明。--log warnings命令行选项和logu warnings系统变量已弃用，将在以后的mysql版本中删除。</p>
                            </div>
                            <p>
                                Causes the server to record more messages to the error log
                                about what it is doing. With respect to replication, the
                                server generates warnings that it succeeded in reconnecting
                                after a network or connection failure, and provides
                                information about how each slave thread started. This
                                variable is set to 2 by default. To disable it, set it to 0.
                                The server logs messages about statements that are unsafe
                                for statement-based logging if the value is greater than 0.
                                Aborted connections and access-denied errors for new
                                connection attempts are logged if the value is greater than
                                1. See <a class="xref" href="error-handling.html#communication-errors" title="B.4.2.10&nbsp;Communication Errors and Aborted Connections">Section&nbsp;B.4.2.10, “Communication Errors and Aborted Connections”</a>.
                            </p><p style="color:blue;">使服务器在错误日志中记录有关其正在执行的操作的更多消息。关于复制，服务器在网络或连接失败后生成成功重新连接的警告，并提供有关每个从属线程如何启动的信息。默认情况下，此变量设置为2。若要禁用它，请将其设置为0。如果值大于0，服务器将记录有关对基于语句的日志记录不安全的语句的消息。如果值大于1，则记录新连接尝试的中止连接和拒绝访问错误。参见第B.4.2.10节“通信错误和中断的连接”。</p>
                            <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">

                                <div class="admon-title">
                                    Note
                                </div>
                                <p>
                                    The effects of this option are not limited to replication.
                                    It affects diagnostic messages across a spectrum of server
                                    activities.
                                </p><p style="color:blue;">此选项的效果不限于复制。它影响服务器活动范围内的诊断消息。</p>
                            </div>
                        </li><li class="listitem"><p><a name="option_mysqld_master-info-file"></a>
                            <a class="indexterm" name="idm140286799576976"></a>

                            <a class="indexterm" name="idm140286799575488"></a>

                            <a class="link" href="replication.html#option_mysqld_master-info-file"><code class="option">--master-info-file=<em class="replaceable"><code>file_name</code></em></code></a>
                        </p><p style="color:blue;">--master info file=文件名</p>
                            <div class="informaltable">
                                <table frame="box" rules="all" summary="Properties for master-info-file"><colgroup><col width="30%"><col width="70%"></colgroup><thead><tr><th scope="col">Property</th>
                                    <th scope="col">Value</th>
                                </tr></thead><tbody><tr><td scope="row"><span class="bold"><strong>Command-Line Format</strong></span></td>
                                    <td><code class="literal">--master-info-file=file_name</code></td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Type</strong></span></td>
                                    <td>File name</td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Default Value</strong></span></td>
                                    <td><code class="literal">master.info</code></td>
                                </tr></tbody></table>
                            </div>
                            <p>
                                The name to use for the file in which the slave records
                                information about the master. The default name is
                                <code class="filename">master.info</code> in the data directory. For
                                information about the format of this file, see
                                <a class="xref" href="replication.html#slave-logs-status" title="16.2.4.2&nbsp;Slave Status Logs">Section&nbsp;16.2.4.2, “Slave Status Logs”</a>.
                            </p><p style="color:blue;">用于从机记录主机信息的文件的名称。默认名称是数据目录中的master.info。有关此文件格式的信息，请参阅第16.2.4.2节“从属状态日志”。</p></li><li class="listitem"><p><a name="option_mysqld_master-retry-count"></a>
                            <a class="indexterm" name="idm140286799554688"></a>

                            <a class="indexterm" name="idm140286799553232"></a>

                            <a class="link" href="replication.html#option_mysqld_master-retry-count"><code class="option">--master-retry-count=<em class="replaceable"><code>count</code></em></code></a>
                        </p><p style="color:blue;">--master retry count=计数</p>
                            <div class="informaltable">
                                <table frame="box" rules="all" summary="Properties for master-retry-count"><colgroup><col width="30%"><col width="70%"></colgroup><thead><tr><th scope="col">Property</th>
                                    <th scope="col">Value</th>
                                </tr></thead><tbody><tr><td scope="row"><span class="bold"><strong>Command-Line Format</strong></span></td>
                                    <td><code class="literal">--master-retry-count=#</code></td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Deprecated</strong></span></td>
                                    <td>Yes</td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Type</strong></span></td>
                                    <td>Integer</td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Default Value</strong></span></td>
                                    <td><code class="literal">86400</code></td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Minimum Value</strong></span></td>
                                    <td><code class="literal">0</code></td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Maximum Value</strong></span> (64-bit platforms)</td>
                                    <td><code class="literal">18446744073709551615</code></td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Maximum Value</strong></span> (32-bit platforms)</td>
                                    <td><code class="literal">4294967295</code></td>
                                </tr></tbody></table>
                            </div>
                            <p>
                                The number of times that the slave tries to reconnect to the
                                master before giving up. The default value is 86400 times. A
                                value of 0 means <span class="quote">“<span class="quote">infinite</span>”</span>, and the slave
                                attempts to connect forever. Reconnection attempts are
                                triggered when the slave reaches its connection timeout
                                (specified by the
                                <a class="link" href="replication.html#option_mysqld_slave-net-timeout"><code class="option">--slave-net-timeout</code></a> option)
                                without receiving data or a heartbeat signal from the
                                master. Reconnection is attempted at intervals set by the
                                <code class="literal">MASTER_CONNECT_RETRY</code> option of the
                                <a class="link" href="sql-syntax.html#change-master-to" title="13.4.2.1&nbsp;CHANGE MASTER TO Syntax"><code class="literal">CHANGE MASTER TO</code></a> statement
                                (which defaults to every 60 seconds).
                            </p><p style="color:blue;">从机在放弃前尝试重新连接到主机的次数。默认值为86400次。值为0表示“无限”，而从机尝试永远连接。当从属服务器达到其连接超时（由--slave net timeout选项指定）而不从主服务器接收数据或心跳信号时，将触发重新连接尝试。以change master to语句的master_connect_retry选项设置的间隔尝试重新连接（默认为每60秒一次）。</p><p>
                                This option is deprecated and will be removed in a future
                                MySQL release. Use the <code class="literal">MASTER_RETRY_COUNT</code>
                                option of the <a class="link" href="sql-syntax.html#change-master-to" title="13.4.2.1&nbsp;CHANGE MASTER TO Syntax"><code class="literal">CHANGE MASTER
                                TO</code></a> statement instead.
                            </p><p style="color:blue;">此选项已弃用，将在以后的MySQL版本中删除。改为使用change master to语句的master_retry_count选项。</p></li><li class="listitem"><p><a name="option_mysqld_max-relay-log-size"></a>
                            <a class="indexterm" name="idm140286799515296"></a>

                            <a class="indexterm" name="idm140286799513840"></a>

                            <a class="link" href="replication.html#option_mysqld_max-relay-log-size"><code class="option">--max-relay-log-size=<em class="replaceable"><code>size</code></em></code></a>
                        </p><p style="color:blue;">--最大中继日志大小=大小</p>
                            <div class="informaltable">
                                <table frame="box" rules="all" summary="Properties for max_relay_log_size"><colgroup><col width="30%"><col width="70%"></colgroup><thead><tr><th scope="col">Property</th>
                                    <th scope="col">Value</th>
                                </tr></thead><tbody><tr><td scope="row"><span class="bold"><strong>Command-Line Format</strong></span></td>
                                    <td><code class="literal">--max-relay-log-size=#</code></td>
                                </tr><tr><td scope="row"><span class="bold"><strong>System Variable</strong></span></td>
                                    <td><code class="literal"><a class="link" href="replication.html#sysvar_max_relay_log_size">max_relay_log_size</a></code></td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Scope</strong></span></td>
                                    <td>Global</td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Dynamic</strong></span></td>
                                    <td>Yes</td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Type</strong></span></td>
                                    <td>Integer</td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Default Value</strong></span></td>
                                    <td><code class="literal">0</code></td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Minimum Value</strong></span></td>
                                    <td><code class="literal">0</code></td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Maximum Value</strong></span></td>
                                    <td><code class="literal">1073741824</code></td>
                                </tr></tbody></table>
                            </div>
                            <p>
                                The size at which the server rotates relay log files
                                automatically. If this value is nonzero, the relay log is
                                rotated automatically when its size exceeds this value. If
                                this value is zero (the default), the size at which relay
                                log rotation occurs is determined by the value of
                                <a class="link" href="replication.html#sysvar_max_binlog_size"><code class="literal">max_binlog_size</code></a>. For more
                                information, see <a class="xref" href="replication.html#slave-logs-relaylog" title="16.2.4.1&nbsp;The Slave Relay Log">Section&nbsp;16.2.4.1, “The Slave Relay Log”</a>.
                            </p><p style="color:blue;">服务器自动旋转中继日志文件的大小。如果此值不为零，则当中继日志的大小超过此值时，它会自动旋转。如果该值为零（默认值），则发生中继日志旋转的大小由max_binlog_size的值确定。有关更多信息，请参见第16.2.4.1节“从机继电器日志”。</p></li><li class="listitem"><p><a name="option_mysqld_relay-log-purge"></a>
                            <a class="indexterm" name="idm140286799476720"></a>

                            <a class="indexterm" name="idm140286799475232"></a>

                            <a class="link" href="replication.html#option_mysqld_relay-log-purge"><code class="option">--relay-log-purge={0|1}</code></a>
                        </p><p style="color:blue;">--中继日志清除={0 1}</p>
                            <div class="informaltable">
                                <table frame="box" rules="all" summary="Properties for relay_log_purge"><colgroup><col width="30%"><col width="70%"></colgroup><thead><tr><th scope="col">Property</th>
                                    <th scope="col">Value</th>
                                </tr></thead><tbody><tr><td scope="row"><span class="bold"><strong>Command-Line Format</strong></span></td>
                                    <td><code class="literal">--relay-log-purge[={OFF|ON}]</code></td>
                                </tr><tr><td scope="row"><span class="bold"><strong>System Variable</strong></span></td>
                                    <td><code class="literal"><a class="link" href="replication.html#sysvar_relay_log_purge">relay_log_purge</a></code></td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Scope</strong></span></td>
                                    <td>Global</td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Dynamic</strong></span></td>
                                    <td>Yes</td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Type</strong></span></td>
                                    <td>Boolean</td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Default Value</strong></span></td>
                                    <td><code class="literal">ON</code></td>
                                </tr></tbody></table>
                            </div>
                            <p>
                                Disable or enable automatic purging of relay logs as soon as
                                they are no longer needed. The default value is 1 (enabled).
                                This is a global variable that can be changed dynamically
                                with <code class="literal">SET GLOBAL relay_log_purge =
                                <em class="replaceable"><code>N</code></em></code>. Disabling purging of
                                relay logs when using the
                                <a class="link" href="replication.html#option_mysqld_relay-log-recovery"><code class="option">--relay-log-recovery</code></a> option
                                puts data consistency at risk.
                            </p><p style="color:blue;">一旦不再需要中继日志，就禁用或启用自动清除。默认值为1（启用）。这是一个全局变量，可以使用set global relay_log_purge=n动态更改。使用--relay log recovery选项时禁用清除中继日志会使数据一致性面临风险。</p></li><li class="listitem"><p><a name="option_mysqld_relay-log-recovery"></a>
                            <a class="indexterm" name="idm140286799444960"></a>

                            <a class="indexterm" name="idm140286799443504"></a>

                            <a class="indexterm" name="idm140286799442000"></a>

                            <a class="indexterm" name="idm140286799440928"></a>

                            <a class="link" href="replication.html#option_mysqld_relay-log-recovery"><code class="option">--relay-log-recovery={0|1}</code></a>
                        </p><p style="color:blue;">--中继日志恢复={0 1}</p>
                            <div class="informaltable">
                                <table frame="box" rules="all" summary="Properties for relay-log-recovery"><colgroup><col width="30%"><col width="70%"></colgroup><thead><tr><th scope="col">Property</th>
                                    <th scope="col">Value</th>
                                </tr></thead><tbody><tr><td scope="row"><span class="bold"><strong>Command-Line Format</strong></span></td>
                                    <td><code class="literal">--relay-log-recovery[={OFF|ON}]</code></td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Type</strong></span></td>
                                    <td>Boolean</td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Default Value</strong></span></td>
                                    <td><code class="literal">OFF</code></td>
                                </tr></tbody></table>
                            </div>
                            <p>
                                Enables automatic relay log recovery immediately following
                                server startup. The recovery process creates a new relay log
                                file, initializes the SQL thread position to this new relay
                                log, and initializes the I/O thread to the SQL thread
                                position. Reading of the relay log from the master then
                                continues. This should be used following an unexpected halt
                                of a replication slave to ensure that no possibly corrupted
                                relay logs are processed. The default value is 0 (disabled).
                            </p><p style="color:blue;">在服务器启动后立即启用自动中继日志恢复。恢复过程将创建一个新的中继日志文件，将sql线程位置初始化为此新中继日志，并将i/o线程初始化为sql线程位置。然后继续从主机读取中继日志。这应该在复制从机意外停止后使用，以确保不会处理任何可能损坏的中继日志。默认值为0（禁用）。</p><p>
                                This option can be enabled to make a slave resilient to
                                unexpected halts. See
                                <a class="xref" href="replication.html#replication-solutions-unexpected-slave-halt" title="16.3.2&nbsp;Handling an Unexpected Halt of a Replication Slave">Section&nbsp;16.3.2, “Handling an Unexpected Halt of a Replication Slave”</a>
                                for more information. Enabling the
                                <a class="link" href="replication.html#option_mysqld_relay-log-recovery"><code class="option">--relay-log-recovery</code></a> option
                                when <a class="link" href="replication.html#sysvar_relay_log_purge"><code class="option">relay-log-purge</code></a> is
                                disabled risks reading the relay log from files that were
                                not purged, leading to data inconsistency.
                            </p><p style="color:blue;">可以启用此选项，使从属服务器对意外停止具有弹性。有关更多信息，请参阅16.3.2节，“处理复制从机的意外停止”。禁用中继日志清除时启用--relay log recovery选项可能会从未清除的文件中读取中继日志，从而导致数据不一致。</p><p>
                                When using a multithreaded slave (in other words
                                <a class="link" href="replication.html#sysvar_slave_parallel_workers"><code class="literal">slave_parallel_workers</code></a> is
                                greater than 0), inconsistencies such as gaps can occur in
                                the sequence of transactions that have been executed from
                                the relay log. Enabling the
                                <a class="link" href="replication.html#option_mysqld_relay-log-recovery"><code class="option">--relay-log-recovery</code></a> option
                                when there are inconsistencies causes an error and the
                                option has no effect. The solution in this situation is to
                                issue <a class="link" href="sql-syntax.html#start-slave" title="13.4.2.6&nbsp;START SLAVE Syntax"><code class="literal">START
                                SLAVE UNTIL SQL_AFTER_MTS_GAPS</code></a>, which brings the
                                server to a more consistent state, then issue
                                <a class="link" href="sql-syntax.html#reset-slave" title="13.4.2.4&nbsp;RESET SLAVE Syntax"><code class="literal">RESET SLAVE</code></a> to remove the
                                relay logs. See
                                <a class="xref" href="replication.html#replication-features-transaction-inconsistencies" title="16.4.1.32&nbsp;Replication and Transaction Inconsistencies">Section&nbsp;16.4.1.32, “Replication and Transaction Inconsistencies”</a>
                                for more information.
                            </p><p style="color:blue;">当使用多线程从机（换句话说，从机并行工作机大于0）时，在从中继日志执行的事务序列中可能会出现间隙等不一致。在出现不一致时启用--relay log recovery选项会导致错误，并且该选项无效。在这种情况下，解决方案是发出start slave直到sql_after_mts_gaps，这将使服务器处于更一致的状态，然后发出reset slave以删除中继日志。有关更多信息，请参阅第16.4.1.32节“复制和事务不一致”。</p>
                            <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">

                                <div class="admon-title">
                                    Note
                                </div>
                                <p>
                                    This option does not affect the following Group
                                    Replication channels:
                                </p><p style="color:blue;">此选项不影响以下组复制通道：</p>
                                <div class="itemizedlist">
                                    <ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
                                        <code class="literal">group_replication_applier</code>
                                    </p><p style="color:blue;">组复制应用程序</p></li><li class="listitem"><p>
                                        <code class="literal">group_replication_recovery</code>
                                    </p><p style="color:blue;">组复制恢复</p></li></ul>
                                </div>
                                <p>
                                    Any other channels running on a group are affected, such
                                    as a channel which is replicating from an outside master
                                    or another group.
                                </p><p style="color:blue;">组上运行的任何其他通道都会受到影响，例如从外部主机或其他组复制的通道。</p>
                            </div>
                        </li><li class="listitem"><p><a name="option_mysqld_relay-log-space-limit"></a>
                            <a class="indexterm" name="idm140286799406752"></a>

                            <a class="indexterm" name="idm140286799405296"></a>

                            <a class="link" href="replication.html#option_mysqld_relay-log-space-limit"><code class="option">--relay-log-space-limit=<em class="replaceable"><code>size</code></em></code></a>
                        </p><p style="color:blue;">--中继日志空间限制=大小</p>
                            <div class="informaltable">
                                <table frame="box" rules="all" summary="Properties for relay_log_space_limit"><colgroup><col width="30%"><col width="70%"></colgroup><thead><tr><th scope="col">Property</th>
                                    <th scope="col">Value</th>
                                </tr></thead><tbody><tr><td scope="row"><span class="bold"><strong>Command-Line Format</strong></span></td>
                                    <td><code class="literal">--relay-log-space-limit=#</code></td>
                                </tr><tr><td scope="row"><span class="bold"><strong>System Variable</strong></span></td>
                                    <td><code class="literal"><a class="link" href="replication.html#sysvar_relay_log_space_limit">relay_log_space_limit</a></code></td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Scope</strong></span></td>
                                    <td>Global</td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Dynamic</strong></span></td>
                                    <td>No</td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Type</strong></span></td>
                                    <td>Integer</td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Default Value</strong></span></td>
                                    <td><code class="literal">0</code></td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Minimum Value</strong></span></td>
                                    <td><code class="literal">0</code></td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Maximum Value</strong></span> (64-bit platforms)</td>
                                    <td><code class="literal">18446744073709551615</code></td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Maximum Value</strong></span> (32-bit platforms)</td>
                                    <td><code class="literal">4294967295</code></td>
                                </tr></tbody></table>
                            </div>
                            <p>
                                This option places an upper limit on the total size in bytes
                                of all relay logs on the slave. A value of 0 means <span class="quote">“<span class="quote">no
            limit</span>”</span>. This is useful for a slave server host that
                                has limited disk space. When the limit is reached, the I/O
                                thread stops reading binary log events from the master
                                server until the SQL thread has caught up and deleted some
                                unused relay logs. Note that this limit is not absolute:
                                There are cases where the SQL thread needs more events
                                before it can delete relay logs. In that case, the I/O
                                thread exceeds the limit until it becomes possible for the
                                SQL thread to delete some relay logs because not doing so
                                would cause a deadlock. You should not set
                                <a class="link" href="replication.html#option_mysqld_relay-log-space-limit"><code class="option">--relay-log-space-limit</code></a> to
                                less than twice the value of
                                <a class="link" href="replication.html#option_mysqld_max-relay-log-size"><code class="option">--max-relay-log-size</code></a> (or
                                <a class="link" href="replication.html#sysvar_max_binlog_size"><code class="option">--max-binlog-size</code></a> if
                                <a class="link" href="replication.html#option_mysqld_max-relay-log-size"><code class="option">--max-relay-log-size</code></a> is 0).
                                In that case, there is a chance that the I/O thread waits
                                for free space because
                                <a class="link" href="replication.html#option_mysqld_relay-log-space-limit"><code class="option">--relay-log-space-limit</code></a> is
                                exceeded, but the SQL thread has no relay log to purge and
                                is unable to satisfy the I/O thread. This forces the I/O
                                thread to ignore
                                <a class="link" href="replication.html#option_mysqld_relay-log-space-limit"><code class="option">--relay-log-space-limit</code></a>
                                temporarily.
                            </p><p style="color:blue;">此选项对从机上所有中继日志的总大小（字节）设置上限。值为0表示“无限制”。这对于磁盘空间有限的从属服务器主机非常有用。当达到限制时，I/O线程停止从主服务器读取二进制日志事件，直到SQL线程捕获并删除一些未使用的中继日志。注意，这个限制不是绝对的：在某些情况下，sql线程需要更多的事件才能删除中继日志。在这种情况下，I/O线程超出了限制，直到SQL线程能够删除某些中继日志，因为不这样做将导致死锁。不应将--relay log space limit设置为小于--max relay log size（或--max binlog size，如果--max relay log size为0）值的两倍。在这种情况下，有可能I/O线程等待空闲空间，因为超出了--中继日志空间限制，但SQL线程没有要清除的中继日志，无法满足I/O线程的要求。这将强制I/O线程忽略--临时中继日志空间限制。</p></li><li class="listitem"><p><a name="option_mysqld_replicate-do-db"></a>
                            <a class="indexterm" name="idm140286799359904"></a>

                            <a class="indexterm" name="idm140286799358416"></a>

                            <a class="link" href="replication.html#option_mysqld_replicate-do-db"><code class="option">--replicate-do-db=<em class="replaceable"><code>db_name</code></em></code></a>
                        </p><p style="color:blue;">--复制do db=db_name</p>
                            <div class="informaltable">
                                <table frame="box" rules="all" summary="Properties for replicate-do-db"><colgroup><col width="30%"><col width="70%"></colgroup><thead><tr><th scope="col">Property</th>
                                    <th scope="col">Value</th>
                                </tr></thead><tbody><tr><td scope="row"><span class="bold"><strong>Command-Line Format</strong></span></td>
                                    <td><code class="literal">--replicate-do-db=name</code></td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Type</strong></span></td>
                                    <td>String</td>
                                </tr></tbody></table>
                            </div>
                            <p>
                                Creates a replication filter using the name of a database.
                                Such filters can also be created using
                                <a class="link" href="sql-syntax.html#change-replication-filter" title="13.4.2.2&nbsp;CHANGE REPLICATION FILTER Syntax"><code class="literal">CHANGE
                                    REPLICATION FILTER REPLICATE_DO_DB</code></a>. The precise
                                effect of this filtering depends on whether statement-based
                                or row-based replication is in use, and are described in the
                                next several paragraphs.
                            </p><p style="color:blue;">使用数据库名称创建复制筛选器。也可以使用change replication filter replicate_do_db创建此类筛选器。此筛选的确切效果取决于是否正在使用基于语句的复制或基于行的复制，并将在接下来的几段中进行描述。</p><p>
                            </p>
                            <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">

                                <div class="admon-title">
                                    Note
                                </div>
                                <p>
                                    Replication filters cannot be used on a MySQL server
                                    instance that is configured for Group Replication,
                                    because filtering transactions on some servers would
                                    make the group unable to reach agreement on a consistent
                                    state.
                                </p><p style="color:blue;">无法在为组复制配置的MySQL服务器实例上使用复制筛选器，因为在某些服务器上筛选事务将使组无法就一致状态达成一致。</p>
                            </div>
                            <p>
                            </p><p><b>Statement-based replication.&nbsp;</b>
                                Tell the slave SQL thread to restrict replication to
                                statements where the default database (that is, the one
                                selected by <a class="link" href="sql-syntax.html#use" title="13.8.4&nbsp;USE Syntax"><code class="literal">USE</code></a>) is
                                <em class="replaceable"><code>db_name</code></em>. To specify more than
                                one database, use this option multiple times, once for
                                each database; however, doing so does
                                <span class="emphasis"><em>not</em></span> replicate cross-database
                                statements such as <code class="literal">UPDATE
                                    <em class="replaceable"><code>some_db.some_table</code></em> SET
                                    foo='bar'</code> while a different database (or no
                                database) is selected.
                            </p><p style="color:blue;">基于语句的复制。告诉从sql线程将复制限制为默认数据库（即通过使用选择的数据库）为db_name的语句。若要指定多个数据库，请多次使用此选项，对每个数据库使用一次；但是，这样做不会复制跨数据库语句，例如在选择其他数据库（或没有数据库）时更新某些数据库。某些表集foo='bar'。</p>
                            <div class="warning" style="margin-left: 0.5in; margin-right: 0.5in;">

                                <div class="admon-title">
                                    Warning
                                </div>
                                <p>
                                    To specify multiple databases you
                                    <span class="emphasis"><em>must</em></span> use multiple instances of this
                                    option. Because database names can contain commas, if you
                                    supply a comma separated list then the list will be
                                    treated as the name of a single database.
                                </p><p style="color:blue;">若要指定多个数据库，必须使用此选项的多个实例。因为数据库名称可以包含逗号，所以如果提供逗号分隔的列表，则该列表将被视为单个数据库的名称。</p>
                            </div>
                            <p>
                                An example of what does not work as you might expect when
                                using statement-based replication: If the slave is started
                                with <a class="link" href="replication.html#option_mysqld_replicate-do-db"><code class="option">--replicate-do-db=sales</code></a>
                                and you issue the following statements on the master, the
                                <a class="link" href="sql-syntax.html#update" title="13.2.11&nbsp;UPDATE Syntax"><code class="literal">UPDATE</code></a> statement is
                                <span class="emphasis"><em>not</em></span> replicated:
                            </p><p style="color:blue;">使用基于语句的复制时可能无法正常工作的一个示例：如果从机以--replicate do db=sales启动，并且在主机上发出以下语句，则不会复制update语句：</p><pre data-lang="sql" class="programlisting">USE prices;
UPDATE sales.january SET amount=amount+1000;
</pre><p>
                                The main reason for this <span class="quote">“<span class="quote">check just the default
            database</span>”</span> behavior is that it is difficult from the
                                statement alone to know whether it should be replicated (for
                                example, if you are using multiple-table
                                <a class="link" href="sql-syntax.html#delete" title="13.2.2&nbsp;DELETE Syntax"><code class="literal">DELETE</code></a> statements or
                                multiple-table <a class="link" href="sql-syntax.html#update" title="13.2.11&nbsp;UPDATE Syntax"><code class="literal">UPDATE</code></a>
                                statements that act across multiple databases). It is also
                                faster to check only the default database rather than all
                                databases if there is no need.
                            </p><p style="color:blue;">这种“仅检查默认数据库”行为的主要原因是，仅从语句很难知道是否应该复制它（例如，如果使用多个表删除语句或跨多个数据库执行的多个表更新语句）。如果不需要，只检查默认数据库比检查所有数据库更快。</p><p><b>Row-based replication.&nbsp;</b>
                                Tells the slave SQL thread to restrict replication to
                                database <em class="replaceable"><code>db_name</code></em>. Only tables
                                belonging to <em class="replaceable"><code>db_name</code></em> are
                                changed; the current database has no effect on this.
                                Suppose that the slave is started with
                                <a class="link" href="replication.html#option_mysqld_replicate-do-db"><code class="option">--replicate-do-db=sales</code></a> and
                                row-based replication is in effect, and then the following
                                statements are run on the master:
                            </p><p style="color:blue;">基于行的复制。告诉从SQL线程将复制限制到数据库数据库名称。只更改属于db_name的表；当前数据库对此没有影响。假设从机以--replicate do db=sales启动，并且基于行的复制生效，然后在主机上运行以下语句：</p><pre data-lang="sql" class="programlisting">USE prices;
UPDATE sales.february SET amount=amount+100;
</pre><p>
                                The <code class="literal">february</code> table in the
                                <code class="literal">sales</code> database on the slave is changed in
                                accordance with the <a class="link" href="sql-syntax.html#update" title="13.2.11&nbsp;UPDATE Syntax"><code class="literal">UPDATE</code></a>
                                statement; this occurs whether or not the
                                <a class="link" href="sql-syntax.html#use" title="13.8.4&nbsp;USE Syntax"><code class="literal">USE</code></a> statement was issued.
                                However, issuing the following statements on the master has
                                no effect on the slave when using row-based replication and
                                <a class="link" href="replication.html#option_mysqld_replicate-do-db"><code class="option">--replicate-do-db=sales</code></a>:
                            </p><p style="color:blue;">slave上sales数据库中的二月表根据update语句进行了更改；无论use语句是否发出，都会发生这种情况。但是，在使用基于行的复制和--replicate do db=sales时，在主服务器上发出以下语句对从服务器没有影响：</p><pre data-lang="sql" class="programlisting">USE prices;
UPDATE prices.march SET amount=amount-25;
</pre><p>
                                Even if the statement <code class="literal">USE prices</code> were
                                changed to <code class="literal">USE sales</code>, the
                                <a class="link" href="sql-syntax.html#update" title="13.2.11&nbsp;UPDATE Syntax"><code class="literal">UPDATE</code></a> statement's
                                effects would still not be replicated.
                            </p><p style="color:blue;">即使将语句use prices更改为use sales，update语句的效果也不会被复制。</p><p>
                                Another important difference in how
                                <a class="link" href="replication.html#option_mysqld_replicate-do-db"><code class="option">--replicate-do-db</code></a> is handled
                                in statement-based replication as opposed to row-based
                                replication occurs with regard to statements that refer to
                                multiple databases. Suppose that the slave is started with
                                <a class="link" href="replication.html#option_mysqld_replicate-do-db"><code class="option">--replicate-do-db=db1</code></a>, and
                                the following statements are executed on the master:
                            </p><p style="color:blue;">对于引用多个数据库的语句，在基于语句的复制中处理replicate do db的方式与基于行的复制中处理replicate do db的方式有另一个重要区别。假设从机以--replicate do db=db1启动，并且在主机上执行以下语句：</p><pre data-lang="sql" class="programlisting">USE db1;
UPDATE db1.table1 SET col1 = 10, db2.table2 SET col2 = 20;
</pre><p>
                                If you are using statement-based replication, then both
                                tables are updated on the slave. However, when using
                                row-based replication, only <code class="literal">table1</code> is
                                affected on the slave; since <code class="literal">table2</code> is in
                                a different database, <code class="literal">table2</code> on the slave
                                is not changed by the <a class="link" href="sql-syntax.html#update" title="13.2.11&nbsp;UPDATE Syntax"><code class="literal">UPDATE</code></a>.
                                Now suppose that, instead of the <code class="literal">USE db1</code>
                                statement, a <code class="literal">USE db4</code> statement had been
                                used:
                            </p><p style="color:blue;">如果使用基于语句的复制，则两个表都会在从机上更新。但是，当使用基于行的复制时，从机上只影响表1；因为表2在不同的数据库中，所以从机上的表2不会被更新更改。现在假设使用了use db4语句，而不是use db1语句：</p><pre data-lang="sql" class="programlisting">USE db4;
UPDATE db1.table1 SET col1 = 10, db2.table2 SET col2 = 20;
</pre><p>
                                In this case, the <a class="link" href="sql-syntax.html#update" title="13.2.11&nbsp;UPDATE Syntax"><code class="literal">UPDATE</code></a>
                                statement would have no effect on the slave when using
                                statement-based replication. However, if you are using
                                row-based replication, the
                                <a class="link" href="sql-syntax.html#update" title="13.2.11&nbsp;UPDATE Syntax"><code class="literal">UPDATE</code></a> would change
                                <code class="literal">table1</code> on the slave, but not
                                <code class="literal">table2</code>—in other words, only tables
                                in the database named by
                                <a class="link" href="replication.html#option_mysqld_replicate-do-db"><code class="option">--replicate-do-db</code></a> are
                                changed, and the choice of default database has no effect on
                                this behavior.
                            </p><p style="color:blue;">在这种情况下，当使用基于语句的复制时，update语句对从机没有影响。但是，如果使用基于行的复制，则更新将更改从机上的table1，而不是table2换言之，只更改数据库中名为--replicate do db的表，并且默认数据库的选择对此行为没有影响。</p><p>
                                If you need cross-database updates to work, use
                                <a class="link" href="replication.html#option_mysqld_replicate-wild-do-table"><code class="option">--replicate-wild-do-table=<em class="replaceable"><code>db_name</code></em>.%</code></a>
                                instead. See <a class="xref" href="replication.html#replication-rules" title="16.2.5&nbsp;How Servers Evaluate Replication Filtering Rules">Section&nbsp;16.2.5, “How Servers Evaluate Replication Filtering Rules”</a>.
                            </p><p style="color:blue;">如果需要跨数据库更新，请改用--replicate wild do table=db_name%。请参阅16.2.5节，“服务器如何评估复制筛选规则”。</p>
                            <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">

                                <div class="admon-title">
                                    Note
                                </div>
                                <p>
                                    This option affects replication in the same manner that
                                    <a class="link" href="replication.html#option_mysqld_binlog-do-db"><code class="option">--binlog-do-db</code></a> affects
                                    binary logging, and the effects of the replication format
                                    on how <a class="link" href="replication.html#option_mysqld_replicate-do-db"><code class="option">--replicate-do-db</code></a>
                                    affects replication behavior are the same as those of the
                                    logging format on the behavior of
                                    <a class="link" href="replication.html#option_mysqld_binlog-do-db"><code class="option">--binlog-do-db</code></a>.
                                </p><p style="color:blue;">此选项影响复制的方式与--binlog do db影响二进制日志相同，复制格式对--replicate do db影响复制行为的方式的影响与日志格式对--binlog do db行为的影响相同。</p><p>
                                This option has no effect on
                                <a class="link" href="sql-syntax.html#commit" title="13.3.1&nbsp;START TRANSACTION, COMMIT, and ROLLBACK Syntax"><code class="literal">BEGIN</code></a>,
                                <a class="link" href="sql-syntax.html#commit" title="13.3.1&nbsp;START TRANSACTION, COMMIT, and ROLLBACK Syntax"><code class="literal">COMMIT</code></a>, or
                                <a class="link" href="sql-syntax.html#commit" title="13.3.1&nbsp;START TRANSACTION, COMMIT, and ROLLBACK Syntax"><code class="literal">ROLLBACK</code></a>
                                statements.
                            </p><p style="color:blue;">此选项对begin、commit或rollback语句没有影响。</p>
                            </div>
                        </li><li class="listitem"><p><a name="option_mysqld_replicate-ignore-db"></a>
                            <a class="indexterm" name="idm140286799283952"></a>

                            <a class="indexterm" name="idm140286799282496"></a>

                            <a class="link" href="replication.html#option_mysqld_replicate-ignore-db"><code class="option">--replicate-ignore-db=<em class="replaceable"><code>db_name</code></em></code></a>
                        </p><p style="color:blue;">--复制忽略数据库=数据库名称</p>
                            <div class="informaltable">
                                <table frame="box" rules="all" summary="Properties for replicate-ignore-db"><colgroup><col width="30%"><col width="70%"></colgroup><thead><tr><th scope="col">Property</th>
                                    <th scope="col">Value</th>
                                </tr></thead><tbody><tr><td scope="row"><span class="bold"><strong>Command-Line Format</strong></span></td>
                                    <td><code class="literal">--replicate-ignore-db=name</code></td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Type</strong></span></td>
                                    <td>String</td>
                                </tr></tbody></table>
                            </div>
                            <p>
                                Creates a replication filter using the name of a database.
                                Such filters can also be created using
                                <a class="link" href="sql-syntax.html#change-replication-filter" title="13.4.2.2&nbsp;CHANGE REPLICATION FILTER Syntax"><code class="literal">CHANGE
                                    REPLICATION FILTER REPLICATE_IGNORE_DB</code></a>. As with
                                <a class="link" href="replication.html#option_mysqld_replicate-do-db"><code class="option">--replicate-do-db</code></a>, the
                                precise effect of this filtering depends on whether
                                statement-based or row-based replication is in use, and are
                                described in the next several paragraphs.
                            </p><p style="color:blue;">使用数据库名称创建复制筛选器。也可以使用change replication filter replicate_ignore_db创建此类筛选器。与--replicate do db一样，此筛选的确切效果取决于是使用基于语句的复制还是使用基于行的复制，并将在接下来的几段中进行描述。</p><p>
                            </p>
                            <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">

                                <div class="admon-title">
                                    Note
                                </div>
                                <p>
                                    Replication filters cannot be used on a MySQL server
                                    instance that is configured for Group Replication,
                                    because filtering transactions on some servers would
                                    make the group unable to reach agreement on a consistent
                                    state.
                                </p><p style="color:blue;">无法在为组复制配置的MySQL服务器实例上使用复制筛选器，因为在某些服务器上筛选事务将使组无法就一致状态达成一致。</p>
                            </div>
                            <p>
                            </p><p><b>Statement-based replication.&nbsp;</b>
                                Tells the slave SQL thread not to replicate any statement
                                where the default database (that is, the one selected by
                                <a class="link" href="sql-syntax.html#use" title="13.8.4&nbsp;USE Syntax"><code class="literal">USE</code></a>) is
                                <em class="replaceable"><code>db_name</code></em>.
                            </p><p style="color:blue;">基于语句的复制。告诉从SQL线程不要复制默认数据库（即通过使用选择的数据库）为db_name的任何语句。</p><p><b>Row-based replication.&nbsp;</b>
                                Tells the slave SQL thread not to update any tables in the
                                database <em class="replaceable"><code>db_name</code></em>. The default
                                database has no effect.
                            </p><p style="color:blue;">基于行的复制。告诉从SQL线程不要更新数据库数据库名称中的任何表。默认数据库无效。</p><p>
                                When using statement-based replication, the following
                                example does not work as you might expect. Suppose that the
                                slave is started with
                                <a class="link" href="replication.html#option_mysqld_replicate-ignore-db"><code class="option">--replicate-ignore-db=sales</code></a>
                                and you issue the following statements on the master:
                            </p><p style="color:blue;">使用基于语句的复制时，以下示例可能无法正常工作。假设从机以--replicate ignore db=sales开始，并在主机上发出以下语句：</p><pre data-lang="sql" class="programlisting">USE prices;
UPDATE sales.january SET amount=amount+1000;
</pre><p>
                                The <a class="link" href="sql-syntax.html#update" title="13.2.11&nbsp;UPDATE Syntax"><code class="literal">UPDATE</code></a> statement
                                <span class="emphasis"><em>is</em></span> replicated in such a case because
                                <a class="link" href="replication.html#option_mysqld_replicate-ignore-db"><code class="option">--replicate-ignore-db</code></a> applies
                                only to the default database (determined by the
                                <a class="link" href="sql-syntax.html#use" title="13.8.4&nbsp;USE Syntax"><code class="literal">USE</code></a> statement). Because the
                                <code class="literal">sales</code> database was specified explicitly
                                in the statement, the statement has not been filtered.
                                However, when using row-based replication, the
                                <a class="link" href="sql-syntax.html#update" title="13.2.11&nbsp;UPDATE Syntax"><code class="literal">UPDATE</code></a> statement's
                                effects are <span class="emphasis"><em>not</em></span> propagated to the
                                slave, and the slave's copy of the
                                <code class="literal">sales.january</code> table is unchanged; in this
                                instance,
                                <a class="link" href="replication.html#option_mysqld_replicate-ignore-db"><code class="option">--replicate-ignore-db=sales</code></a>
                                causes <span class="emphasis"><em>all</em></span> changes made to tables in
                                the master's copy of the <code class="literal">sales</code>
                                database to be ignored by the slave.
                            </p><p style="color:blue;">在这种情况下复制update语句是因为--replicate ignore db只应用于默认数据库（由use语句决定）。由于在语句中显式指定了sales数据库，因此尚未筛选该语句。但是，当使用基于行的复制时，update语句的效果不会传播到从机，并且sales.january表的从机副本保持不变；在本例中，-replicate ignore db=sales会导致对sales数据库的主机副本中的表所做的所有更改被从机忽略。</p><p>
                                To specify more than one database to ignore, use this option
                                multiple times, once for each database. Because database
                                names can contain commas, if you supply a comma separated
                                list then the list will be treated as the name of a single
                                database.
                            </p><p style="color:blue;">要指定要忽略的多个数据库，请多次使用此选项，每个数据库一次。因为数据库名称可以包含逗号，所以如果提供逗号分隔的列表，则该列表将被视为单个数据库的名称。</p><p>
                                You should not use this option if you are using
                                cross-database updates and you do not want these updates to
                                be replicated. See <a class="xref" href="replication.html#replication-rules" title="16.2.5&nbsp;How Servers Evaluate Replication Filtering Rules">Section&nbsp;16.2.5, “How Servers Evaluate Replication Filtering Rules”</a>.
                            </p><p style="color:blue;">如果正在使用跨数据库更新，并且不希望复制这些更新，则不应使用此选项。请参阅16.2.5节，“服务器如何评估复制筛选规则”。</p><p>
                                If you need cross-database updates to work, use
                                <a class="link" href="replication.html#option_mysqld_replicate-wild-ignore-table"><code class="option">--replicate-wild-ignore-table=<em class="replaceable"><code>db_name</code></em>.%</code></a>
                                instead. See <a class="xref" href="replication.html#replication-rules" title="16.2.5&nbsp;How Servers Evaluate Replication Filtering Rules">Section&nbsp;16.2.5, “How Servers Evaluate Replication Filtering Rules”</a>.
                            </p><p style="color:blue;">如果需要跨数据库更新，请改用--replicate wild ignore table=db_name%。请参阅16.2.5节，“服务器如何评估复制筛选规则”。</p>
                            <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">

                                <div class="admon-title">
                                    Note
                                </div>
                                <p>
                                    This option affects replication in the same manner that
                                    <a class="link" href="replication.html#option_mysqld_binlog-ignore-db"><code class="option">--binlog-ignore-db</code></a> affects
                                    binary logging, and the effects of the replication format
                                    on how
                                    <a class="link" href="replication.html#option_mysqld_replicate-ignore-db"><code class="option">--replicate-ignore-db</code></a>
                                    affects replication behavior are the same as those of the
                                    logging format on the behavior of
                                    <a class="link" href="replication.html#option_mysqld_binlog-ignore-db"><code class="option">--binlog-ignore-db</code></a>.
                                </p><p style="color:blue;">此选项影响复制的方式与--binlog ignore db影响二进制日志相同，复制格式对--replicate ignore db影响复制行为的方式的影响与日志格式对--binlog ignore db行为的影响相同。</p><p>
                                This option has no effect on
                                <a class="link" href="sql-syntax.html#commit" title="13.3.1&nbsp;START TRANSACTION, COMMIT, and ROLLBACK Syntax"><code class="literal">BEGIN</code></a>,
                                <a class="link" href="sql-syntax.html#commit" title="13.3.1&nbsp;START TRANSACTION, COMMIT, and ROLLBACK Syntax"><code class="literal">COMMIT</code></a>, or
                                <a class="link" href="sql-syntax.html#commit" title="13.3.1&nbsp;START TRANSACTION, COMMIT, and ROLLBACK Syntax"><code class="literal">ROLLBACK</code></a>
                                statements.
                            </p><p style="color:blue;">此选项对begin、commit或rollback语句没有影响。</p>
                            </div>
                        </li><li class="listitem"><p><a name="option_mysqld_replicate-do-table"></a>
                            <a class="indexterm" name="idm140286799232064"></a>

                            <a class="indexterm" name="idm140286799230608"></a>

                            <a class="link" href="replication.html#option_mysqld_replicate-do-table"><code class="option">--replicate-do-table=<em class="replaceable"><code>db_name.tbl_name</code></em></code></a>
                        </p><p style="color:blue;">--复制do table=db_name.tbl_name</p>
                            <div class="informaltable">
                                <table frame="box" rules="all" summary="Properties for replicate-do-table"><colgroup><col width="30%"><col width="70%"></colgroup><thead><tr><th scope="col">Property</th>
                                    <th scope="col">Value</th>
                                </tr></thead><tbody><tr><td scope="row"><span class="bold"><strong>Command-Line Format</strong></span></td>
                                    <td><code class="literal">--replicate-do-table=name</code></td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Type</strong></span></td>
                                    <td>String</td>
                                </tr></tbody></table>
                            </div>
                            <p>
                                Creates a replication filter by telling the slave SQL thread
                                to restrict replication to a given table. To specify more
                                than one table, use this option multiple times, once for
                                each table. This works for both cross-database updates and
                                default database updates, in contrast to
                                <a class="link" href="replication.html#option_mysqld_replicate-do-db"><code class="option">--replicate-do-db</code></a>. See
                                <a class="xref" href="replication.html#replication-rules" title="16.2.5&nbsp;How Servers Evaluate Replication Filtering Rules">Section&nbsp;16.2.5, “How Servers Evaluate Replication Filtering Rules”</a>. You can also create
                                such a filter by issuing a
                                <a class="link" href="sql-syntax.html#change-replication-filter" title="13.4.2.2&nbsp;CHANGE REPLICATION FILTER Syntax"><code class="literal">CHANGE
                                    REPLICATION FILTER REPLICATE_DO_TABLE</code></a> statement.
                            </p><p style="color:blue;">通过告诉从属SQL线程将复制限制到给定表来创建复制筛选器。要指定多个表，请多次使用此选项，每个表一次。这对跨数据库更新和默认数据库更新都有效，与--replicate do db相反。请参阅16.2.5节，“服务器如何评估复制筛选规则”。您还可以通过发出change replication filter replicate_do_table语句来创建这样的筛选器。</p><p>
                            </p>
                            <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">

                                <div class="admon-title">
                                    Note
                                </div>
                                <p>
                                    Replication filters cannot be used on a MySQL server
                                    instance that is configured for Group Replication,
                                    because filtering transactions on some servers would
                                    make the group unable to reach agreement on a consistent
                                    state.
                                </p><p style="color:blue;">无法在为组复制配置的MySQL服务器实例上使用复制筛选器，因为在某些服务器上筛选事务将使组无法就一致状态达成一致。</p>
                            </div>
                            <p>
                            </p><p>
                                This option affects only statements that apply to tables. It
                                does not affect statements that apply only to other database
                                objects, such as stored routines. To filter statements
                                operating on stored routines, use one or more of the
                                <code class="option">--replicate-*-db</code> options.
                            </p><p style="color:blue;">此选项仅影响应用于表的语句。它不影响仅应用于其他数据库对象（如存储例程）的语句。要筛选在存储例程上操作的语句，请使用一个或多个--replicate-*-db选项。</p></li><li class="listitem"><p><a name="option_mysqld_replicate-ignore-table"></a>
                            <a class="indexterm" name="idm140286799208448"></a>

                            <a class="indexterm" name="idm140286799206992"></a>

                            <a class="link" href="replication.html#option_mysqld_replicate-ignore-table"><code class="option">--replicate-ignore-table=<em class="replaceable"><code>db_name.tbl_name</code></em></code></a>
                        </p><p style="color:blue;">--复制忽略表=db_name.tbl_name</p>
                            <div class="informaltable">
                                <table frame="box" rules="all" summary="Properties for replicate-ignore-table"><colgroup><col width="30%"><col width="70%"></colgroup><thead><tr><th scope="col">Property</th>
                                    <th scope="col">Value</th>
                                </tr></thead><tbody><tr><td scope="row"><span class="bold"><strong>Command-Line Format</strong></span></td>
                                    <td><code class="literal">--replicate-ignore-table=name</code></td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Type</strong></span></td>
                                    <td>String</td>
                                </tr></tbody></table>
                            </div>
                            <p>
                                Creates a replication filter by telling the slave SQL thread
                                not to replicate any statement that updates the specified
                                table, even if any other tables might be updated by the same
                                statement. To specify more than one table to ignore, use
                                this option multiple times, once for each table. This works
                                for cross-database updates, in contrast to
                                <a class="link" href="replication.html#option_mysqld_replicate-ignore-db"><code class="option">--replicate-ignore-db</code></a>. See
                                <a class="xref" href="replication.html#replication-rules" title="16.2.5&nbsp;How Servers Evaluate Replication Filtering Rules">Section&nbsp;16.2.5, “How Servers Evaluate Replication Filtering Rules”</a>. You can also create
                                such a filter by issuing a
                                <a class="link" href="sql-syntax.html#change-replication-filter" title="13.4.2.2&nbsp;CHANGE REPLICATION FILTER Syntax"><code class="literal">CHANGE
                                    REPLICATION FILTER REPLICATE_IGNORE_TABLE</code></a>
                                statement.
                            </p><p style="color:blue;">通过告诉从属SQL线程不要复制任何更新指定表的语句来创建复制筛选器，即使任何其他表可能由同一语句更新。要指定要忽略的多个表，请多次使用此选项，每个表一次。这适用于跨数据库更新，而不是--replicate ignore db。请参阅16.2.5节，“服务器如何评估复制筛选规则”。您还可以通过发出change replication filter replicate_ignore_table语句来创建这样的筛选器。</p><p>
                            </p>
                            <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">

                                <div class="admon-title">
                                    Note
                                </div>
                                <p>
                                    Replication filters cannot be used on a MySQL server
                                    instance that is configured for Group Replication,
                                    because filtering transactions on some servers would
                                    make the group unable to reach agreement on a consistent
                                    state.
                                </p><p style="color:blue;">无法在为组复制配置的MySQL服务器实例上使用复制筛选器，因为在某些服务器上筛选事务将使组无法就一致状态达成一致。</p>
                            </div>
                            <p>
                            </p><p>
                                This option affects only statements that apply to tables. It
                                does not affect statements that apply only to other database
                                objects, such as stored routines. To filter statements
                                operating on stored routines, use one or more of the
                                <code class="option">--replicate-*-db</code> options.
                            </p><p style="color:blue;">此选项仅影响应用于表的语句。它不影响仅应用于其他数据库对象（如存储例程）的语句。要筛选在存储例程上操作的语句，请使用一个或多个--replicate-*-db选项。</p></li><li class="listitem"><p><a name="option_mysqld_replicate-rewrite-db"></a>
                            <a class="indexterm" name="idm140286799184720"></a>

                            <a class="indexterm" name="idm140286799183264"></a>

                            <a class="link" href="replication.html#option_mysqld_replicate-rewrite-db"><code class="option">--replicate-rewrite-db=<em class="replaceable"><code>from_name</code></em>-&gt;<em class="replaceable"><code>to_name</code></em></code></a>
                        </p><p style="color:blue;">--复制重写db=from_name-&gt;to_name</p>
                            <div class="informaltable">
                                <table frame="box" rules="all" summary="Properties for replicate-rewrite-db"><colgroup><col width="30%"><col width="70%"></colgroup><thead><tr><th scope="col">Property</th>
                                    <th scope="col">Value</th>
                                </tr></thead><tbody><tr><td scope="row"><span class="bold"><strong>Command-Line Format</strong></span></td>
                                    <td><code class="literal">--replicate-rewrite-db=old_name-&gt;new_name</code></td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Type</strong></span></td>
                                    <td>String</td>
                                </tr></tbody></table>
                            </div>
                            <p>
                                Tells the slave to create a replication filter that
                                translates the default database (that is, the one selected
                                by <a class="link" href="sql-syntax.html#use" title="13.8.4&nbsp;USE Syntax"><code class="literal">USE</code></a>) to
                                <em class="replaceable"><code>to_name</code></em> if it was
                                <em class="replaceable"><code>from_name</code></em> on the master. Only
                                statements involving tables are affected (not statements
                                such as <a class="link" href="sql-syntax.html#create-database" title="13.1.11&nbsp;CREATE DATABASE Syntax"><code class="literal">CREATE DATABASE</code></a>,
                                <a class="link" href="sql-syntax.html#drop-database" title="13.1.22&nbsp;DROP DATABASE Syntax"><code class="literal">DROP DATABASE</code></a>, and
                                <a class="link" href="sql-syntax.html#alter-database" title="13.1.1&nbsp;ALTER DATABASE Syntax"><code class="literal">ALTER DATABASE</code></a>), and only if
                                <em class="replaceable"><code>from_name</code></em> is the default database
                                on the master. To specify multiple rewrites, use this option
                                multiple times. The server uses the first one with a
                                <em class="replaceable"><code>from_name</code></em> value that matches. The
                                database name translation is done
                                <span class="emphasis"><em>before</em></span> the
                                <code class="option">--replicate-*</code> rules are tested. You can
                                also create such a filter by issuing a
                                <a class="link" href="sql-syntax.html#change-replication-filter" title="13.4.2.2&nbsp;CHANGE REPLICATION FILTER Syntax"><code class="literal">CHANGE
                                    REPLICATION FILTER REPLICATE_REWRITE_DB</code></a> statement.
                            </p><p style="color:blue;">告诉从服务器创建一个复制筛选器，该筛选器将默认数据库（即通过使用选择的数据库）转换为从主机上的名称（如果它是从主机上的名称）。只有涉及表的语句才受影响（不包括CREATE DATABASE、DROP DATABASE和ALTER DATABASE等语句），并且只有FROM U NAME是主控上的默认数据库时才受影响。若要指定多个重写，请多次使用此选项。服务器使用第一个具有匹配的from_name值的服务器。数据库名称转换在测试--replicate-*规则之前完成。您还可以通过发出change replication filter replicate_rewrite_db语句来创建这样的筛选器。</p><p>
                            </p>
                            <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">

                                <div class="admon-title">
                                    Note
                                </div>
                                <p>
                                    Replication filters cannot be used on a MySQL server
                                    instance that is configured for Group Replication,
                                    because filtering transactions on some servers would
                                    make the group unable to reach agreement on a consistent
                                    state.
                                </p><p style="color:blue;">无法在为组复制配置的MySQL服务器实例上使用复制筛选器，因为在某些服务器上筛选事务将使组无法就一致状态达成一致。</p>
                            </div>
                            <p>
                            </p><p>
                                Statements in which table names are qualified with database
                                names when using this option do not work with table-level
                                replication filtering options such as
                                <a class="link" href="replication.html#option_mysqld_replicate-do-table"><code class="option">--replicate-do-table</code></a>. Suppose
                                we have a database named <code class="literal">a</code> on the master,
                                one named <code class="literal">b</code> on the slave, each containing
                                a table <code class="literal">t</code>, and have started the master
                                with <code class="option">--replicate-rewrite-db='a-&gt;b'</code>. At a
                                later point in time, we execute
                                <a class="link" href="sql-syntax.html#delete" title="13.2.2&nbsp;DELETE Syntax"><code class="literal">DELETE FROM
                                    a.t</code></a>. In this case, no relevant filtering rule
                                works, for the reasons shown here:
                            </p><p style="color:blue;">使用此选项时表名与数据库名限定在一起的语句不适用于表级复制筛选选项，例如--replicate do table。假设我们在master上有一个名为a的数据库，在slave上有一个名为b的数据库，每个数据库都包含一个表t，并用--replicate rewrite db=”a-&gt;b”启动了master。在稍后的时间点，我们将从a.t.执行delete。在这种情况下，没有相关的筛选规则工作，原因如下：</p>
                            <div class="orderedlist">
                                <ol class="orderedlist" type="1"><li class="listitem"><p>
                                    <code class="option">--replicate-do-table=a.t</code> does not work
                                    because the slave has table <code class="literal">t</code> in
                                    database <code class="literal">b</code>.
                                </p><p style="color:blue;">--replicate do table=A.T不工作，因为从机在数据库B中有表T。</p></li><li class="listitem"><p>
                                    <code class="option">--replicate-do-table=b.t</code> does not match
                                    the original statement and so is ignored.
                                </p><p style="color:blue;">--replicate do table=b.t与原始语句不匹配，因此被忽略。</p></li><li class="listitem"><p>
                                    <code class="option">--replicate-do-table=*.t</code> is handled
                                    identically to
                                    <code class="option">--replicate-do-table=a.t</code>, and thus does
                                    not work, either.
                                </p><p style="color:blue;">--replicate do table=*.t的处理方式与--replicate do table=a.t相同，因此也不起作用。</p></li></ol>
                            </div>
                            <p>
                                Similarly, the <code class="option">--replication-rewrite-db</code>
                                option does not work with cross-database updates.
                            </p><p style="color:blue;">类似地，--replication rewrite db选项不适用于跨数据库更新。</p><p>
                                If you use this option on the command line and the
                                <code class="literal">&gt;</code> character is special to your command
                                interpreter, quote the option value. For example:
                            </p><p style="color:blue;">如果在命令行上使用此选项，&gt;字符对命令解释器是特殊的，请引用选项值。例如：</p><pre data-lang="terminal" class="programlisting">shell&gt; <strong class="userinput"><code>mysqld --replicate-rewrite-db="<em class="replaceable"><code>olddb</code></em>-&gt;<em class="replaceable"><code>newdb</code></em>"</code></strong>
</pre></li><li class="listitem"><p><a name="option_mysqld_replicate-same-server-id"></a>
                            <a class="indexterm" name="idm140286799138608"></a>

                            <a class="indexterm" name="idm140286799137152"></a>

                            <a class="link" href="replication.html#option_mysqld_replicate-same-server-id"><code class="option">--replicate-same-server-id</code></a>
                        </p><p style="color:blue;">--复制相同的服务器ID</p>
                            <div class="informaltable">
                                <table frame="box" rules="all" summary="Properties for replicate-same-server-id"><colgroup><col width="30%"><col width="70%"></colgroup><thead><tr><th scope="col">Property</th>
                                    <th scope="col">Value</th>
                                </tr></thead><tbody><tr><td scope="row"><span class="bold"><strong>Command-Line Format</strong></span></td>
                                    <td><code class="literal">--replicate-same-server-id[={OFF|ON}]</code></td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Type</strong></span></td>
                                    <td>Boolean</td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Default Value</strong></span></td>
                                    <td><code class="literal">OFF</code></td>
                                </tr></tbody></table>
                            </div>
                            <p>
                                To be used on slave servers. Usually you should use the
                                default setting of 0, to prevent infinite loops caused by
                                circular replication. If set to 1, the slave does not skip
                                events having its own server ID. Normally, this is useful
                                only in rare configurations. Cannot be set to 1 if
                                <a class="link" href="replication.html#sysvar_log_slave_updates"><code class="literal">log_slave_updates</code></a> is
                                enabled. By default, the slave I/O thread does not write
                                binary log events to the relay log if they have the slave's
                                server ID (this optimization helps save disk usage). If you
                                want to use
                                <a class="link" href="replication.html#option_mysqld_replicate-same-server-id"><code class="option">--replicate-same-server-id</code></a>,
                                be sure to start the slave with this option before you make
                                the slave read its own events that you want the slave SQL
                                thread to execute.
                            </p><p style="color:blue;">在从属服务器上使用。通常应使用默认设置0，以防止循环复制导致无限循环。如果设置为1，则从服务器不会跳过具有自己服务器ID的事件。通常，这仅在少数配置中有用。如果启用了日志从属更新，则无法将设置为1。默认情况下，如果从属I/O线程具有从属服务器的服务器ID，则不会将二进制日志事件写入中继日志（此优化有助于节省磁盘使用）。如果要使用--replicate same server id，请确保在让从属服务器读取自己希望从属SQL线程执行的事件之前使用此选项启动从属服务器。</p></li><li class="listitem"><p><a name="option_mysqld_replicate-wild-do-table"></a>
                            <a class="indexterm" name="idm140286799115184"></a>

                            <a class="indexterm" name="idm140286799113728"></a>

                            <a class="link" href="replication.html#option_mysqld_replicate-wild-do-table"><code class="option">--replicate-wild-do-table=<em class="replaceable"><code>db_name.tbl_name</code></em></code></a>
                        </p><p style="color:blue;">--复制野生do table=db_name.tbl_name</p>
                            <div class="informaltable">
                                <table frame="box" rules="all" summary="Properties for replicate-wild-do-table"><colgroup><col width="30%"><col width="70%"></colgroup><thead><tr><th scope="col">Property</th>
                                    <th scope="col">Value</th>
                                </tr></thead><tbody><tr><td scope="row"><span class="bold"><strong>Command-Line Format</strong></span></td>
                                    <td><code class="literal">--replicate-wild-do-table=name</code></td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Type</strong></span></td>
                                    <td>String</td>
                                </tr></tbody></table>
                            </div>
                            <p>
                                Creates a replication filter by telling the slave thread to
                                restrict replication to statements where any of the updated
                                tables match the specified database and table name patterns.
                                Patterns can contain the <code class="literal">%</code> and
                                <code class="literal">_</code> wildcard characters, which have the
                                same meaning as for the <a class="link" href="functions.html#operator_like"><code class="literal">LIKE</code></a>
                                pattern-matching operator. To specify more than one table,
                                use this option multiple times, once for each table. This
                                works for cross-database updates. See
                                <a class="xref" href="replication.html#replication-rules" title="16.2.5&nbsp;How Servers Evaluate Replication Filtering Rules">Section&nbsp;16.2.5, “How Servers Evaluate Replication Filtering Rules”</a>. You can also create
                                such a filter by issuing a
                                <a class="link" href="sql-syntax.html#change-replication-filter" title="13.4.2.2&nbsp;CHANGE REPLICATION FILTER Syntax"><code class="literal">CHANGE
                                    REPLICATION FILTER REPLICATE_WILD_DO_TABLE</code></a>
                                statement.
                            </p><p style="color:blue;">通过告诉从线程将复制限制为任何更新的表与指定的数据库和表名模式匹配的语句来创建复制筛选器。模式可以包含%和\通配符，其含义与LIKE模式匹配运算符相同。要指定多个表，请多次使用此选项，每个表一次。这适用于跨数据库更新。请参阅16.2.5节，“服务器如何评估复制筛选规则”。您还可以通过发出change replication filter replicate_wild_do_table语句来创建这样的筛选器。</p><p>
                            </p>
                            <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">

                                <div class="admon-title">
                                    Note
                                </div>
                                <p>
                                    Replication filters cannot be used on a MySQL server
                                    instance that is configured for Group Replication,
                                    because filtering transactions on some servers would
                                    make the group unable to reach agreement on a consistent
                                    state.
                                </p><p style="color:blue;">无法在为组复制配置的MySQL服务器实例上使用复制筛选器，因为在某些服务器上筛选事务将使组无法就一致状态达成一致。</p>
                            </div>
                            <p>
                            </p><p>
                                This option applies to tables, views, and triggers. It does
                                not apply to stored procedures and functions, or events. To
                                filter statements operating on the latter objects, use one
                                or more of the <code class="option">--replicate-*-db</code> options.
                            </p><p style="color:blue;">此选项适用于表、视图和触发器。它不适用于存储过程、函数或事件。要筛选在后一个对象上操作的语句，请使用一个或多个--replicate-*-db选项。</p><p>
                                As an example,
                                <a class="link" href="replication.html#option_mysqld_replicate-wild-do-table"><code class="option">--replicate-wild-do-table=foo%.bar%</code></a>
                                replicates only updates that use a table where the database
                                name starts with <code class="literal">foo</code> and the table name
                                starts with <code class="literal">bar</code>.
                            </p><p style="color:blue;">例如，-replicate wild do table=foo%.bar%只复制使用数据库名称以foo开头、表名称以bar开头的表的更新。</p><p>
                                If the table name pattern is <code class="literal">%</code>, it
                                matches any table name and the option also applies to
                                database-level statements (<a class="link" href="sql-syntax.html#create-database" title="13.1.11&nbsp;CREATE DATABASE Syntax"><code class="literal">CREATE
                                DATABASE</code></a>, <a class="link" href="sql-syntax.html#drop-database" title="13.1.22&nbsp;DROP DATABASE Syntax"><code class="literal">DROP
                                DATABASE</code></a>, and <a class="link" href="sql-syntax.html#alter-database" title="13.1.1&nbsp;ALTER DATABASE Syntax"><code class="literal">ALTER
                                DATABASE</code></a>). For example, if you use
                                <a class="link" href="replication.html#option_mysqld_replicate-wild-do-table"><code class="option">--replicate-wild-do-table=foo%.%</code></a>,
                                database-level statements are replicated if the database
                                name matches the pattern <code class="literal">foo%</code>.
                            </p><p style="color:blue;">如果表名模式为%，则它匹配任何表名，并且该选项也适用于数据库级语句（CREATE DATABASE、DROP DATABASE和ALTER DATABASE）。例如，如果使用--replicate wild do table=foo%.%，如果数据库名称与模式foo%匹配，则复制数据库级语句。</p><p>
                                To include literal wildcard characters in the database or
                                table name patterns, escape them with a backslash. For
                                example, to replicate all tables of a database that is named
                                <code class="literal">my_own%db</code>, but not replicate tables from
                                the <code class="literal">my1ownAABCdb</code> database, you should
                                escape the <code class="literal">_</code> and <code class="literal">%</code>
                                characters like this:
                                <a class="link" href="replication.html#option_mysqld_replicate-wild-do-table"><code class="option">--replicate-wild-do-table=my\_own\%db</code></a>.
                                If you use the option on the command line, you might need to
                                double the backslashes or quote the option value, depending
                                on your command interpreter. For example, with the
                                <span class="command"><strong>bash</strong></span> shell, you would need to type
                                <a class="link" href="replication.html#option_mysqld_replicate-wild-do-table"><code class="option">--replicate-wild-do-table=my\\_own\\%db</code></a>.
                            </p><p style="color:blue;">要在数据库或表名模式中包含文字通配符，请用反斜杠转义它们。例如，若要复制名为my1ownaabcdb的数据库的所有表，但不复制my1ownaabcdb数据库中的表，则应转义如下字符：-replicate wild do table=my own\%db。如果在命令行上使用该选项，则可能需要将反斜杠加倍或引用选项值，具体取决于命令解释器。例如，对于bash shell，您需要键入--replicate wild do table=my\\\%db。</p></li><li class="listitem"><p><a name="option_mysqld_replicate-wild-ignore-table"></a>
                            <a class="indexterm" name="idm140286799073520"></a>

                            <a class="indexterm" name="idm140286799072016"></a>

                            <a class="link" href="replication.html#option_mysqld_replicate-wild-ignore-table"><code class="option">--replicate-wild-ignore-table=<em class="replaceable"><code>db_name.tbl_name</code></em></code></a>
                        </p><p style="color:blue;">--复制wild ignore table=db_name.tbl_name</p>
                            <div class="informaltable">
                                <table frame="box" rules="all" summary="Properties for replicate-wild-ignore-table"><colgroup><col width="30%"><col width="70%"></colgroup><thead><tr><th scope="col">Property</th>
                                    <th scope="col">Value</th>
                                </tr></thead><tbody><tr><td scope="row"><span class="bold"><strong>Command-Line Format</strong></span></td>
                                    <td><code class="literal">--replicate-wild-ignore-table=name</code></td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Type</strong></span></td>
                                    <td>String</td>
                                </tr></tbody></table>
                            </div>
                            <p>
                                Creates a replication filter which keeps the slave thread
                                from replicating a statement in which any table matches the
                                given wildcard pattern. To specify more than one table to
                                ignore, use this option multiple times, once for each table.
                                This works for cross-database updates. See
                                <a class="xref" href="replication.html#replication-rules" title="16.2.5&nbsp;How Servers Evaluate Replication Filtering Rules">Section&nbsp;16.2.5, “How Servers Evaluate Replication Filtering Rules”</a>. You can also create
                                such a filter by issuing a
                                <a class="link" href="sql-syntax.html#change-replication-filter" title="13.4.2.2&nbsp;CHANGE REPLICATION FILTER Syntax"><code class="literal">CHANGE
                                    REPLICATION FILTER REPLICATE_WILD_IGNORE_TABLE</code></a>
                                statement.
                            </p><p style="color:blue;">创建复制筛选器，使从属线程不复制任何表与给定通配符模式匹配的语句。要指定要忽略的多个表，请多次使用此选项，每个表一次。这适用于跨数据库更新。请参阅16.2.5节，“服务器如何评估复制筛选规则”。您还可以通过发出change replication filter replicate_wild_ignore_table语句来创建这样的筛选器。</p><p>
                            </p>
                            <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">

                                <div class="admon-title">
                                    Note
                                </div>
                                <p>
                                    Replication filters cannot be used on a MySQL server
                                    instance that is configured for Group Replication,
                                    because filtering transactions on some servers would
                                    make the group unable to reach agreement on a consistent
                                    state.
                                </p><p style="color:blue;">无法在为组复制配置的MySQL服务器实例上使用复制筛选器，因为在某些服务器上筛选事务将使组无法就一致状态达成一致。</p>
                            </div>
                            <p>
                            </p><p>
                                As an example,
                                <a class="link" href="replication.html#option_mysqld_replicate-wild-ignore-table"><code class="option">--replicate-wild-ignore-table=foo%.bar%</code></a>
                                does not replicate updates that use a table where the
                                database name starts with <code class="literal">foo</code> and the
                                table name starts with <code class="literal">bar</code>.
                            </p><p style="color:blue;">例如，-replicate wild ignore table=foo%.bar%不复制使用数据库名称以foo开头、表名称以bar开头的表的更新。</p><p>
                                For information about how matching works, see the
                                description of the
                                <a class="link" href="replication.html#option_mysqld_replicate-wild-do-table"><code class="option">--replicate-wild-do-table</code></a>
                                option. The rules for including literal wildcard characters
                                in the option value are the same as for
                                <a class="link" href="replication.html#option_mysqld_replicate-wild-ignore-table"><code class="option">--replicate-wild-ignore-table</code></a>
                                as well.
                            </p><p style="color:blue;">有关匹配工作原理的信息，请参阅--replicate wild do table选项的说明。在选项值中包含文字通配符的规则与for-replicate-wild-ignore-table相同。</p></li><li class="listitem"><p><a name="option_mysqld_slave-checkpoint-group"></a>
                            <a class="indexterm" name="idm140286799046272"></a>

                            <a class="indexterm" name="idm140286799044816"></a>

                            <a class="link" href="replication.html#option_mysqld_slave-checkpoint-group"><code class="option">--slave-checkpoint-group=<em class="replaceable"><code>#</code></em></code></a>
                        </p><p style="color:blue;">--从检查点组=#</p>
                            <div class="informaltable">
                                <table frame="box" rules="all" summary="Properties for slave-checkpoint-group"><colgroup><col width="30%"><col width="70%"></colgroup><thead><tr><th scope="col">Property</th>
                                    <th scope="col">Value</th>
                                </tr></thead><tbody><tr><td scope="row"><span class="bold"><strong>Command-Line Format</strong></span></td>
                                    <td><code class="literal">--slave-checkpoint-group=#</code></td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Type</strong></span></td>
                                    <td>Integer</td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Default Value</strong></span></td>
                                    <td><code class="literal">512</code></td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Minimum Value</strong></span></td>
                                    <td><code class="literal">32</code></td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Maximum Value</strong></span></td>
                                    <td><code class="literal">524280</code></td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Block Size</strong></span></td>
                                    <td><code class="literal">8</code></td>
                                </tr></tbody></table>
                            </div>
                            <p>
                                Sets the maximum number of transactions that can be
                                processed by a multithreaded slave before a checkpoint
                                operation is called to update its status as shown by
                                <a class="link" href="sql-syntax.html#show-slave-status" title="13.7.5.34&nbsp;SHOW SLAVE STATUS Syntax"><code class="literal">SHOW SLAVE STATUS</code></a>. Setting
                                this option has no effect on slaves for which multithreading
                                is not enabled.
                            </p><p style="color:blue;">设置多线程从属设备处理的事务的最大数量，在调用检查点操作之前更新其状态，如显示从属状态所示。设置此选项对未启用多线程的从机没有影响。</p>
                            <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">

                                <div class="admon-title">
                                    Note
                                </div>
                                <p>
                                    Multithreaded slaves are not currently supported by NDB
                                    Cluster, which silently ignores the setting for this
                                    option. See
                                    <a class="xref" href="mysql-cluster.html#mysql-cluster-replication-issues" title="21.6.3&nbsp;Known Issues in NDB Cluster Replication">Section&nbsp;21.6.3, “Known Issues in NDB Cluster Replication”</a>, for
                                    more information.
                                </p><p style="color:blue;">ndb集群当前不支持多线程从机，它会自动忽略此选项的设置。有关详细信息，请参阅21.6.3节，“ndb群集复制中的已知问题”。</p>
                            </div>
                            <p>
                                This option works in combination with the
                                <a class="link" href="replication.html#option_mysqld_slave-checkpoint-period"><code class="option">--slave-checkpoint-period</code></a>
                                option in such a way that, when either limit is exceeded,
                                the checkpoint is executed and the counters tracking both
                                the number of transactions and the time elapsed since the
                                last checkpoint are reset.
                            </p><p style="color:blue;">此选项与--slave checkpoint period选项结合使用，当超过任一限制时，将执行检查点，并跟踪事务数和自上次检查点重置以来经过的时间的计数器。</p><p>
                                The minimum allowed value for this option is 32, unless the
                                server was built using
                                <a class="link" href="installing.html#option_cmake_with_debug"><code class="option">-DWITH_DEBUG</code></a>, in which case
                                the minimum value is 1. The effective value is always a
                                multiple of 8; you can set it to a value that is not such a
                                multiple, but the server rounds it down to the next lower
                                multiple of 8 before storing the value.
                                (<span class="emphasis"><em>Exception</em></span>: No such rounding is
                                performed by the debug server.) Regardless of how the server
                                was built, the default value is 512, and the maximum allowed
                                value is 524280.
                            </p><p style="color:blue;">此选项允许的最小值为32，除非服务器是使用-dwith_debug构建的，在这种情况下，最小值为1。有效值始终是8的倍数；您可以将其设置为不是8的倍数，但服务器会在存储该值之前将其舍入到8的下一个较低倍数。（异常：调试服务器不执行这样的舍入）。不管服务器是如何构建的，默认值是512，最大允许值是524280。</p></li><li class="listitem"><p><a name="option_mysqld_slave-checkpoint-period"></a>
                            <a class="indexterm" name="idm140286799008896"></a>

                            <a class="indexterm" name="idm140286799007440"></a>

                            <a class="link" href="replication.html#option_mysqld_slave-checkpoint-period"><code class="option">--slave-checkpoint-period=<em class="replaceable"><code>#</code></em></code></a>
                        </p><p style="color:blue;">--从检查点周期=#</p>
                            <div class="informaltable">
                                <table frame="box" rules="all" summary="Properties for slave-checkpoint-period"><colgroup><col width="30%"><col width="70%"></colgroup><thead><tr><th scope="col">Property</th>
                                    <th scope="col">Value</th>
                                </tr></thead><tbody><tr><td scope="row"><span class="bold"><strong>Command-Line Format</strong></span></td>
                                    <td><code class="literal">--slave-checkpoint-period=#</code></td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Type</strong></span></td>
                                    <td>Integer</td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Default Value</strong></span></td>
                                    <td><code class="literal">300</code></td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Minimum Value</strong></span></td>
                                    <td><code class="literal">1</code></td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Maximum Value</strong></span></td>
                                    <td><code class="literal">4G</code></td>
                                </tr></tbody></table>
                            </div>
                            <p>
                                Sets the maximum time (in milliseconds) that is allowed to
                                pass before a checkpoint operation is called to update the
                                status of a multithreaded slave as shown by
                                <a class="link" href="sql-syntax.html#show-slave-status" title="13.7.5.34&nbsp;SHOW SLAVE STATUS Syntax"><code class="literal">SHOW SLAVE STATUS</code></a>. Setting
                                this option has no effect on slaves for which multithreading
                                is not enabled.
                            </p><p style="color:blue;">设置在调用检查点操作之前允许的最大时间（毫秒），以更新多线程从属设备的状态，如显示从属状态所示。设置此选项对未启用多线程的从机没有影响。</p>
                            <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">

                                <div class="admon-title">
                                    Note
                                </div>
                                <p>
                                    Multithreaded slaves are not currently supported by NDB
                                    Cluster, which silently ignores the setting for this
                                    option. See
                                    <a class="xref" href="mysql-cluster.html#mysql-cluster-replication-issues" title="21.6.3&nbsp;Known Issues in NDB Cluster Replication">Section&nbsp;21.6.3, “Known Issues in NDB Cluster Replication”</a>, for
                                    more information.
                                </p><p style="color:blue;">ndb集群当前不支持多线程从机，它会自动忽略此选项的设置。有关详细信息，请参阅21.6.3节，“ndb群集复制中的已知问题”。</p>
                            </div>
                            <p>
                                This option works in combination with the
                                <a class="link" href="replication.html#option_mysqld_slave-checkpoint-group"><code class="option">--slave-checkpoint-group</code></a>
                                option in such a way that, when either limit is exceeded,
                                the checkpoint is executed and the counters tracking both
                                the number of transactions and the time elapsed since the
                                last checkpoint are reset.
                            </p><p style="color:blue;">此选项与--slave checkpoint group选项结合使用，当超过任一限制时，将执行检查点，并且计数器将跟踪事务数和自上次检查点重置以来经过的时间。</p><p>
                                The minimum allowed value for this option is 1, unless the
                                server was built using
                                <a class="link" href="installing.html#option_cmake_with_debug"><code class="option">-DWITH_DEBUG</code></a>, in which case
                                the minimum value is 0. Regardless of how the server was
                                built, the default value is 300, and the maximum possible
                                value is 4294967296 (4GB).
                            </p><p style="color:blue;">此选项允许的最小值为1，除非服务器是使用-dwith_debug构建的，在这种情况下，最小值为0。不管服务器是如何构建的，默认值是300，最大可能值是4294967296（4GB）。</p></li><li class="listitem"><p><a name="option_mysqld_slave-parallel-workers"></a>
                            <a class="indexterm" name="idm140286798975472"></a>

                            <a class="indexterm" name="idm140286798974016"></a>

                            <a class="link" href="replication.html#option_mysqld_slave-parallel-workers"><code class="option">--slave-parallel-workers</code></a>
                        </p><p style="color:blue;">--从并行工作者</p>
                            <div class="informaltable">
                                <table frame="box" rules="all" summary="Properties for slave-parallel-workers"><colgroup><col width="30%"><col width="70%"></colgroup><thead><tr><th scope="col">Property</th>
                                    <th scope="col">Value</th>
                                </tr></thead><tbody><tr><td scope="row"><span class="bold"><strong>Command-Line Format</strong></span></td>
                                    <td><code class="literal">--slave-parallel-workers=#</code></td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Type</strong></span></td>
                                    <td>Integer</td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Default Value</strong></span></td>
                                    <td><code class="literal">0</code></td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Minimum Value</strong></span></td>
                                    <td><code class="literal">0</code></td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Maximum Value</strong></span></td>
                                    <td><code class="literal">1024</code></td>
                                </tr></tbody></table>
                            </div>
                            <p>
                                Sets the number of slave applier threads for executing
                                replication transactions in parallel. Setting this variable
                                to a number greater than 0 creates a multithreaded slave
                                with this number of applier threads. When set to 0 (the
                                default) parallel execution is disabled and the slave uses a
                                single applier thread.
                            </p><p style="color:blue;">设置并行执行复制事务的从属应用程序线程数。将此变量设置为大于0的数字将创建具有此数量applier线程的多线程从机。当设置为0（默认值）时，并行执行被禁用，从线程使用单个applier线程。</p><p>
                                A multithreaded slave provides parallel execution by using a
                                coordinator thread and the number of applier threads
                                configured by this option. The way which transactions are
                                distributed among applier threads is configured by
                                <a class="link" href="replication.html#option_mysqld_slave-parallel-type"><code class="option">--slave-parallel-type</code></a>. For
                                more information about multithreaded slaves see
                                <a class="link" href="replication.html#sysvar_slave_parallel_workers"><code class="literal">slave-parallel-workers</code></a>.
                            </p><p style="color:blue;">多线程从机通过使用协调线程和此选项配置的applier线程数提供并行执行。事务在applier线程之间的分布方式由--slave parallel type配置。有关多线程从机的更多信息，请参阅从机并行工作机。</p>
                            <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">

                                <div class="admon-title">
                                    Note
                                </div>
                                <p>
                                    Multithreaded slaves are not currently supported by NDB
                                    Cluster, which silently ignores the setting for this
                                    option. See
                                    <a class="xref" href="mysql-cluster.html#mysql-cluster-replication-issues" title="21.6.3&nbsp;Known Issues in NDB Cluster Replication">Section&nbsp;21.6.3, “Known Issues in NDB Cluster Replication”</a>, for
                                    more information.
                                </p><p style="color:blue;">ndb集群当前不支持多线程从机，它会自动忽略此选项的设置。有关详细信息，请参阅21.6.3节，“ndb群集复制中的已知问题”。</p>
                            </div>
                        </li><li class="listitem"><p><a name="option_mysqld_slave-pending-jobs-size-max"></a>
                            <a class="indexterm" name="idm140286798943744"></a>

                            <a class="indexterm" name="idm140286798942288"></a>

                            <a class="link" href="replication.html#option_mysqld_slave-pending-jobs-size-max"><code class="option">--slave-pending-jobs-size-max=<em class="replaceable"><code>#</code></em></code></a>
                        </p><p style="color:blue;">--从挂起作业大小最大值=#</p>
                            <div class="informaltable">
                                <table frame="box" rules="all" summary="Properties for slave-pending-jobs-size-max"><colgroup><col width="30%"><col width="70%"></colgroup><thead><tr><th scope="col">Property</th>
                                    <th scope="col">Value</th>
                                </tr></thead><tbody><tr><td scope="row"><span class="bold"><strong>Command-Line Format</strong></span></td>
                                    <td><code class="literal">--slave-pending-jobs-size-max=#</code></td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Type</strong></span></td>
                                    <td>Integer</td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Default Value</strong></span></td>
                                    <td><code class="literal">16M</code></td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Minimum Value</strong></span></td>
                                    <td><code class="literal">1024</code></td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Maximum Value</strong></span></td>
                                    <td><code class="literal">16EiB</code></td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Block Size</strong></span></td>
                                    <td><code class="literal">1024</code></td>
                                </tr></tbody></table>
                            </div>
                            <p>
                                For multithreaded slaves, this option sets the maximum
                                amount of memory (in bytes) available to slave worker queues
                                holding events not yet applied. Setting this option has no
                                effect on slaves for which multithreading is not enabled.
                            </p><p style="color:blue;">对于多线程的奴隶，这个选项设置了最大的内存量（字节），用于保存尚未应用的事件的从属工作者队列。设置此选项对未启用多线程的从机没有影响。</p><p>
                                The minimum possible value for this option is 1024; the
                                default is 16MB. The maximum possible value is
                                18446744073709551615 (16 exabytes). Values that are not
                                exact multiples of 1024 are rounded down to the next-highest
                                multiple of 1024 prior to being stored.
                            </p><p style="color:blue;">此选项的最小可能值为1024；默认值为16MB。最大可能值为1844 67407370955 1615（16兆字节）。不是1024的精确倍数的值在存储之前向下舍入到1024的次高倍数。</p><p>
                                The value of this variable is a soft limit and can be set to
                                match the normal workload. If an unusually large event
                                exceeds this size, the transaction is held until all the
                                slave workers have empty queues, and then processed. All
                                subsequent transactions are held until the large transaction
                                has been completed.
                            </p><p style="color:blue;">此变量的值是一个软限制，可以设置为与正常工作负载匹配。如果异常大的事件超过此大小，则事务将一直保持，直到所有从属工作进程都有空队列，然后再进行处理。所有后续交易将一直持有，直到大型交易完成。</p></li><li class="listitem"><p><a name="option_mysqld_skip-slave-start"></a>
                            <a class="indexterm" name="idm140286798912032"></a>

                            <a class="indexterm" name="idm140286798910544"></a>

                            <a class="link" href="replication.html#option_mysqld_skip-slave-start"><code class="option">--skip-slave-start</code></a>
                        </p><p style="color:blue;">--跳过从机启动</p>
                            <div class="informaltable">
                                <table frame="box" rules="all" summary="Properties for skip-slave-start"><colgroup><col width="30%"><col width="70%"></colgroup><thead><tr><th scope="col">Property</th>
                                    <th scope="col">Value</th>
                                </tr></thead><tbody><tr><td scope="row"><span class="bold"><strong>Command-Line Format</strong></span></td>
                                    <td><code class="literal">--skip-slave-start[={OFF|ON}]</code></td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Type</strong></span></td>
                                    <td>Boolean</td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Default Value</strong></span></td>
                                    <td><code class="literal">OFF</code></td>
                                </tr></tbody></table>
                            </div>
                            <p>
                                Tells the slave server not to start the slave threads when
                                the server starts. To start the threads later, use a
                                <a class="link" href="sql-syntax.html#start-slave" title="13.4.2.6&nbsp;START SLAVE Syntax"><code class="literal">START SLAVE</code></a> statement.
                            </p><p style="color:blue;">告诉从属服务器在服务器启动时不要启动从属线程。要稍后启动线程，请使用start slave语句。</p></li><li class="listitem"><p><a name="option_mysqld_slave-load-tmpdir"></a>
                            <a class="indexterm" name="idm140286798890320"></a>

                            <a class="indexterm" name="idm140286798888864"></a>

                            <a class="link" href="replication.html#option_mysqld_slave-load-tmpdir"><code class="option">--slave-load-tmpdir=<em class="replaceable"><code>dir_name</code></em></code></a>
                        </p><p style="color:blue;">--从机加载tmpdir=dir_name</p>
                            <div class="informaltable">
                                <table frame="box" rules="all" summary="Properties for slave-load-tmpdir"><colgroup><col width="30%"><col width="70%"></colgroup><thead><tr><th scope="col">Property</th>
                                    <th scope="col">Value</th>
                                </tr></thead><tbody><tr><td scope="row"><span class="bold"><strong>Command-Line Format</strong></span></td>
                                    <td><code class="literal">--slave-load-tmpdir=dir_name</code></td>
                                </tr><tr><td scope="row"><span class="bold"><strong>System Variable</strong></span></td>
                                    <td><code class="literal"><a class="link" href="replication.html#sysvar_slave_load_tmpdir">slave_load_tmpdir</a></code></td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Scope</strong></span></td>
                                    <td>Global</td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Dynamic</strong></span></td>
                                    <td>No</td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Type</strong></span></td>
                                    <td>Directory name</td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Default Value</strong></span></td>
                                    <td><code class="literal">Value of --tmpdir</code></td>
                                </tr></tbody></table>
                            </div>
                            <p>
                                The name of the directory where the slave creates temporary
                                files. This option is by default equal to the value of the
                                <a class="link" href="server-administration.html#sysvar_tmpdir"><code class="literal">tmpdir</code></a> system variable, or
                                the default that applies when that system variable is not
                                specified. When the slave SQL thread replicates a
                                <a class="link" href="sql-syntax.html#load-data" title="13.2.6&nbsp;LOAD DATA Syntax"><code class="literal">LOAD
                                    DATA</code></a> statement, it extracts the file to be loaded
                                from the relay log into temporary files, and then loads
                                these into the table. If the file loaded on the master is
                                huge, the temporary files on the slave are huge, too.
                                Therefore, it might be advisable to use this option to tell
                                the slave to put temporary files in a directory located in
                                some file system that has a lot of available space. In that
                                case, the relay logs are huge as well, so you might also
                                want to use the <a class="link" href="replication.html#sysvar_relay_log"><code class="literal">relay_log</code></a>
                                system variable to place the relay logs in that file system.
                            </p><p style="color:blue;">从机创建临时文件的目录的名称。默认情况下，此选项等于tmpdir系统变量的值，或在未指定该系统变量时应用的默认值。当从sql线程复制load data语句时，它将要从中继日志中加载的文件提取到临时文件中，然后将这些文件加载到表中。如果主服务器上加载的文件很大，那么从服务器上的临时文件也很大。因此，建议使用此选项告诉从属服务器将临时文件放在某个文件系统中的目录中，该目录具有大量可用空间。在这种情况下，中继日志也很大，因此您可能还希望使用relay_log系统变量将中继日志放在该文件系统中。</p><p>
                                The directory specified by this option should be located in
                                a disk-based file system (not a memory-based file system) so
                                that the temporary files used to replicate
                                <a class="link" href="sql-syntax.html#load-data" title="13.2.6&nbsp;LOAD DATA Syntax"><code class="literal">LOAD
                                    DATA</code></a> statements can survive machine restarts. The
                                directory also should not be one that is cleared by the
                                operating system during the system startup process. However,
                                replication can now continue after a restart if the
                                temporary files have been removed.
                            </p><p style="color:blue;">此选项指定的目录应位于基于磁盘的文件系统（而不是基于内存的文件系统）中，以便用于复制加载数据语句的临时文件可以在计算机重新启动后继续存在。目录也不应该是操作系统在系统启动过程中清除的目录。但是，如果临时文件已被删除，则可以在重新启动后继续复制。</p></li><li class="listitem"><p><a name="option_mysqld_slave-max-allowed-packet"></a>
                            <a class="indexterm" name="idm140286798853984"></a>

                            <a class="indexterm" name="idm140286798852944"></a>

                            <a class="link" href="replication.html#option_mysqld_slave-max-allowed-packet"><code class="option">slave-max-allowed-packet=<em class="replaceable"><code>bytes</code></em></code></a>
                        </p><p style="color:blue;">从机最大允许数据包=字节</p>
                            <div class="informaltable">
                                <table frame="box" rules="all" summary="Properties for slave-max-allowed-packet"><colgroup><col width="30%"><col width="70%"></colgroup><thead><tr><th scope="col">Property</th>
                                    <th scope="col">Value</th>
                                </tr></thead><tbody><tr><td scope="row"><span class="bold"><strong>Command-Line Format</strong></span></td>
                                    <td><code class="literal">--slave-max-allowed-packet=#</code></td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Type</strong></span></td>
                                    <td>Integer</td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Default Value</strong></span></td>
                                    <td><code class="literal">1073741824</code></td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Minimum Value</strong></span></td>
                                    <td><code class="literal">1024</code></td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Maximum Value</strong></span></td>
                                    <td><code class="literal">1073741824</code></td>
                                </tr></tbody></table>
                            </div>
                            <p>
                                This option sets the maximum packet size in bytes for the
                                slave SQL and I/O threads, so that large updates using
                                row-based replication do not cause replication to fail
                                because an update exceeded
                                <a class="link" href="server-administration.html#sysvar_max_allowed_packet"><code class="literal">max_allowed_packet</code></a>. (Bug
                                #12400221, Bug #60926)
                            </p><p style="color:blue;">此选项为从属SQL和I/O线程设置最大字节大小，因此使用基于行的复制的大型更新不会导致复制失败，因为更新超过了Max允许的数据包。（错误12400221，错误60926）</p><p>
                                The corresponding server variable
                                <a class="link" href="replication.html#sysvar_slave_max_allowed_packet"><code class="literal">slave_max_allowed_packet</code></a>
                                always has a value that is a positive integer multiple of
                                1024; if you set it to some value that is not such a
                                multiple, the value is automatically rounded down to the
                                next highest multiple of 1024. (For example, if you start
                                the server with
                                <code class="option">--slave-max-allowed-packet=10000</code>, the value
                                used is 9216; setting 0 as the value causes 1024 to be
                                used.) A truncation warning is issued in such cases.
                            </p><p style="color:blue;">对应的服务器变量slave_max_allowed_packet的值始终是1024的正整数倍；如果将其设置为不是1024的某个值，则该值将自动向下舍入到1024的下一个最高倍数。（例如，如果使用--slave max allowed packet=10000启动服务器，则使用的值为9216；设置为0将导致使用1024。）在这种情况下会发出截断警告。</p><p>
                                The maximum (and default) value is 1073741824 (1 GB); the
                                minimum is 1024.
                            </p><p style="color:blue;">最大值（默认值）为1073741824（1 GB），最小值为1024。</p></li><li class="listitem"><p><a name="option_mysqld_slave-net-timeout"></a>
                            <a class="indexterm" name="idm140286798822800"></a>

                            <a class="indexterm" name="idm140286798821344"></a>

                            <a class="link" href="replication.html#option_mysqld_slave-net-timeout"><code class="option">--slave-net-timeout=<em class="replaceable"><code>seconds</code></em></code></a>
                        </p><p style="color:blue;">--从网超时=秒</p>
                            <div class="informaltable">
                                <table frame="box" rules="all" summary="Properties for slave-net-timeout"><colgroup><col width="30%"><col width="70%"></colgroup><thead><tr><th scope="col">Property</th>
                                    <th scope="col">Value</th>
                                </tr></thead><tbody><tr><td scope="row"><span class="bold"><strong>Command-Line Format</strong></span></td>
                                    <td><code class="literal">--slave-net-timeout=#</code></td>
                                </tr><tr><td scope="row"><span class="bold"><strong>System Variable</strong></span></td>
                                    <td><code class="literal"><a class="link" href="replication.html#sysvar_slave_net_timeout">slave_net_timeout</a></code></td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Scope</strong></span></td>
                                    <td>Global</td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Dynamic</strong></span></td>
                                    <td>Yes</td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Type</strong></span></td>
                                    <td>Integer</td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Default Value</strong></span> (&gt;= 5.7.7)</td>
                                    <td><code class="literal">60</code></td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Default Value</strong></span> (&lt;= 5.7.6)</td>
                                    <td><code class="literal">3600</code></td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Minimum Value</strong></span></td>
                                    <td><code class="literal">1</code></td>
                                </tr></tbody></table>
                            </div>
                            <p>
                                The number of seconds to wait for more data or a heartbeat
                                signal from the master before the slave considers the
                                connection broken, aborts the read, and tries to reconnect.
                                The default value is 60 seconds (one minute). Prior to MySQL
                                5.7.7, the default was 3600 seconds (one hour). The first
                                retry occurs immediately after the timeout. The interval
                                between retries is controlled by the
                                <code class="literal">MASTER_CONNECT_RETRY</code> option for the
                                <a class="link" href="sql-syntax.html#change-master-to" title="13.4.2.1&nbsp;CHANGE MASTER TO Syntax"><code class="literal">CHANGE MASTER TO</code></a> statement,
                                and the number of reconnection attempts is limited by the
                                <code class="literal">MASTER_RETRY_COUNT</code> option for the
                                <a class="link" href="sql-syntax.html#change-master-to" title="13.4.2.1&nbsp;CHANGE MASTER TO Syntax"><code class="literal">CHANGE MASTER TO</code></a> statement.
                            </p><p style="color:blue;">在从机认为连接已断开、中止读取并尝试重新连接之前，等待来自主机的更多数据或心跳信号的秒数。默认值为60秒（1分钟）。在mysql 5.7.7之前，默认值是3600秒（1小时）。第一次重试在超时后立即发生。重试间隔由change master to语句的master_connect_retry选项控制，重新连接尝试的次数由change master to语句的master_retry_count选项限制。</p><p>
                                The heartbeat interval, which stops the connection timeout
                                occurring in the absence of data if the connection is still
                                good, is controlled by the
                                <code class="literal">MASTER_HEARTBEAT_PERIOD</code> option for the
                                <a class="link" href="sql-syntax.html#change-master-to" title="13.4.2.1&nbsp;CHANGE MASTER TO Syntax"><code class="literal">CHANGE MASTER TO</code></a> statement.
                                The heartbeat interval defaults to half the value of
                                <a class="link" href="replication.html#option_mysqld_slave-net-timeout"><code class="option">--slave-net-timeout</code></a>, and it
                                is recorded in the master info log and shown in the
                                <a class="link" href="performance-schema.html#replication-connection-configuration-table" title="25.12.11.1&nbsp;The replication_connection_configuration Table"><code class="literal">replication_connection_configuration</code></a>
                                Performance Schema table. Note that a change to the value or
                                default setting of
                                <a class="link" href="replication.html#option_mysqld_slave-net-timeout"><code class="option">--slave-net-timeout</code></a> does not
                                automatically change the heartbeat interval, whether that
                                has been set explicitly or is using a previously calculated
                                default. If the connection timeout is changed, you must also
                                issue <a class="link" href="sql-syntax.html#change-master-to" title="13.4.2.1&nbsp;CHANGE MASTER TO Syntax"><code class="literal">CHANGE MASTER TO</code></a> to
                                adjust the heartbeat interval to an appropriate value so
                                that it occurs before the connection timeout.
                            </p><p style="color:blue;">heartbeat interval是由change master to语句的master_heartbeat_period选项控制的，它在连接仍然良好的情况下停止在没有数据的情况下发生的连接超时。心跳间隔默认为--slave net timeout值的一半，它记录在主信息日志中，并显示在replication_connection_configuration performance schema表中。请注意，对--slave net timeout的值或默认设置的更改不会自动更改心跳间隔，无论是显式设置还是使用先前计算的默认值。如果连接超时被更改，您还必须发出change master来将心跳间隔调整为适当的值，以便在连接超时之前发生。</p></li><li class="listitem"><p><a name="option_mysqld_slave-parallel-type"></a>
                            <a class="indexterm" name="idm140286798774032"></a>

                            <a class="indexterm" name="idm140286798772992"></a>

                            <a class="link" href="replication.html#option_mysqld_slave-parallel-type"><code class="option">--slave-parallel-type=<em class="replaceable"><code>type</code></em></code></a>
                        </p><p style="color:blue;">--从并行类型=类型</p>
                            <div class="informaltable">
                                <table frame="box" rules="all" summary="Properties for slave-parallel-type"><colgroup><col width="30%"><col width="70%"></colgroup><thead><tr><th scope="col">Property</th>
                                    <th scope="col">Value</th>
                                </tr></thead><tbody><tr><td scope="row"><span class="bold"><strong>Command-Line Format</strong></span></td>
                                    <td><code class="literal">--slave-parallel-type=type</code></td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Introduced</strong></span></td>
                                    <td>5.7.2</td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Type</strong></span></td>
                                    <td>Enumeration</td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Default Value</strong></span></td>
                                    <td><code class="literal">DATABASE</code></td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Valid Values</strong></span></td>
                                    <td><p class="valid-value"><code class="literal">DATABASE</code></p><p style="color:blue;">数据库</p><p class="valid-value"><code class="literal">LOGICAL_CLOCK</code></p><p style="color:blue;">逻辑时钟</p></td>
                                </tr></tbody></table>
                            </div>
                            <p>
                                When using a multithreaded slave
                                (<a class="link" href="replication.html#sysvar_slave_parallel_workers"><code class="literal">slave_parallel_workers</code></a> is
                                greater than 0), this option specifies the policy used to
                                decide which transactions are allowed to execute in parallel
                                on the slave. The option has no effect on slaves for which
                                multithreading is not enabled. The possible values are:
                            </p><p style="color:blue;">当使用多线程从机（slave_parallel_workers大于0）时，此选项指定用于确定允许在从机上并行执行哪些事务的策略。该选项对未启用多线程的从机没有影响。可能的值为：</p>
                            <div class="itemizedlist">
                                <ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
                                    <code class="literal">LOGICAL_CLOCK</code>: Transactions that are
                                    part of the same binary log group commit on a master are
                                    applied in parallel on a slave. The dependencies between
                                    transactions are tracked based on their timestamps to
                                    provide additional parallelization where possible. When
                                    this value is set, the
                                    <a class="link" href="replication.html#sysvar_binlog_transaction_dependency_tracking"><code class="literal">binlog_transaction_dependency_tracking</code></a>
                                    system variable can be used on the master to specify
                                    that write sets are used for parallelization in place of
                                    timestamps, if a write set is available for the
                                    transaction and gives improved results compared to
                                    timestamps.
                                </p><p style="color:blue;">逻辑时钟：作为主服务器上相同二进制日志组提交的一部分的事务在从服务器上并行应用。根据事务的时间戳跟踪事务之间的依赖关系，以便在可能的情况下提供额外的并行化。当设置此值时，如果事务的写集可用，并且与时间戳相比给出了更好的结果，则可以在主控上使用binlog_transaction_dependency_tracking系统变量指定将写集用于并行化而不是时间戳。</p></li><li class="listitem"><p>
                                    <code class="literal">DATABASE</code>: Transactions that update
                                    different databases are applied in parallel. This value
                                    is only appropriate if data is partitioned into multiple
                                    databases which are being updated independently and
                                    concurrently on the master. There must be no
                                    cross-database constraints, as such constraints may be
                                    violated on the slave.
                                </p><p style="color:blue;">数据库：并行应用更新不同数据库的事务。此值仅适用于将数据分区为多个数据库的情况，这些数据库在主数据库上独立且并发地进行更新。不能有跨数据库约束，因为在从机上可能会违反这些约束。</p></li></ul>
                            </div>
                            <p>
                                When
                                <a class="link" href="replication.html#sysvar_slave_preserve_commit_order"><code class="literal">slave_preserve_commit_order=1</code></a>
                                is set, you can only use <code class="literal">LOGICAL_CLOCK</code>.
                            </p><p style="color:blue;">当设置slave_preserve_commit_order=1时，只能使用逻辑时钟。</p><p>
                                If your replication topology uses multiple levels of slaves,
                                <code class="literal">LOGICAL_CLOCK</code> may achieve less
                                parallelization for each level the slave is away from the
                                master. You can reduce this effect by using
                                <a class="link" href="replication.html#sysvar_binlog_transaction_dependency_tracking"><code class="literal">binlog_transaction_dependency_tracking</code></a>
                                on the master to specify that write sets are used instead of
                                timestamps for parallelization where possible.
                            </p><p style="color:blue;">如果复制拓扑使用多个级别的从机，则逻辑时钟可能在从机远离主机的每个级别上实现较少的并行化。您可以通过在主机上使用binlog_transaction_dependency_tracking来减少这种影响，以指定在可能的情况下使用写集而不是时间戳进行并行化。</p></li><li class="listitem"><p><a name="option_mysqld_slave-rows-search-algorithms"></a>
                            <a class="indexterm" name="idm140286798734064"></a>

                            <a class="indexterm" name="idm140286798732976"></a>

                            <a class="link" href="replication.html#option_mysqld_slave-rows-search-algorithms"><code class="option">slave-rows-search-algorithms=<em class="replaceable"><code>list</code></em></code></a>
                        </p><p style="color:blue;">从行搜索算法=列表</p>
                            <div class="informaltable">
                                <table frame="box" rules="all" summary="Properties for slave-rows-search-algorithms"><colgroup><col width="30%"><col width="70%"></colgroup><thead><tr><th scope="col">Property</th>
                                    <th scope="col">Value</th>
                                </tr></thead><tbody><tr><td scope="row"><span class="bold"><strong>Command-Line Format</strong></span></td>
                                    <td><code class="literal">--slave-rows-search-algorithms=list</code></td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Type</strong></span></td>
                                    <td>Set</td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Default Value</strong></span></td>
                                    <td><code class="literal">TABLE_SCAN,INDEX_SCAN</code></td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Valid Values</strong></span></td>
                                    <td><p class="valid-value"><code class="literal">TABLE_SCAN,INDEX_SCAN</code></p><p style="color:blue;">表扫描，索引扫描</p><p class="valid-value"><code class="literal">INDEX_SCAN,HASH_SCAN</code></p><p style="color:blue;">索引扫描，哈希扫描</p><p class="valid-value"><code class="literal">TABLE_SCAN,HASH_SCAN</code></p><p style="color:blue;">表扫描，哈希扫描</p><p class="valid-value"><code class="literal">TABLE_SCAN,INDEX_SCAN,HASH_SCAN</code> (equivalent to INDEX_SCAN,HASH_SCAN)</p><p style="color:blue;">表扫描，索引扫描，哈希扫描（相当于索引扫描，哈希扫描）</p></td>
                                </tr></tbody></table>
                            </div>
                            <p>
                                When preparing batches of rows for row-based logging and
                                replication, this option controls how the rows are searched
                                for matches, in particular whether hash scans are used. The
                                option sets the initial value for the
                                <a class="link" href="replication.html#sysvar_slave_rows_search_algorithms"><code class="literal">slave_rows_search_algorithms</code></a>
                                system variable.
                            </p><p style="color:blue;">在为基于行的日志记录和复制准备行批时，此选项控制如何搜索行以查找匹配项，特别是是否使用哈希扫描。该选项设置slave_rows_search_algorithms系统变量的初始值。</p><p>
                                Specify a comma-separated list of the following combinations
                                of 2 values from the list <code class="literal">INDEX_SCAN</code>,
                                <code class="literal">TABLE_SCAN</code>, <code class="literal">HASH_SCAN</code>.
                                For the option, the list need not be quoted, but must
                                contain no spaces, whether or not quotes are used. The
                                recommended combinations (lists) and their effects are shown
                                in the following table:
                            </p><p style="color:blue;">从列表索引扫描、表扫描、哈希扫描中指定以下两个值的组合的逗号分隔列表。对于该选项，不需要引用列表，但无论是否使用引号，都不能包含空格。推荐的组合（列表）及其效果如下表所示：</p>
                            <div class="informaltable">
                                <table summary="How rows are searched for matches, based on the value specified for the --slave-rows-search-algorithms option."><colgroup><col width="25%"><col width="25%"><col width="25%"></colgroup><thead><tr>
                                    <th scope="col">Index used / option value</th>
                                    <th scope="col"><code class="literal">INDEX_SCAN,HASH_SCAN</code></th>
                                    <th scope="col"><code class="literal">INDEX_SCAN,TABLE_SCAN</code></th>
                                </tr></thead><tbody><tr>
                                    <td scope="row"><span class="emphasis"><em>Primary key or unique key</em></span></td>
                                    <td>Index scan</td>
                                    <td>Index scan</td>
                                </tr><tr>
                                    <td scope="row"><span class="emphasis"><em>(Other) Key</em></span></td>
                                    <td>Hash scan over index</td>
                                    <td>Index scan</td>
                                </tr><tr>
                                    <td scope="row"><span class="emphasis"><em>No index</em></span></td>
                                    <td>Hash scan</td>
                                    <td>Table scan</td>
                                </tr></tbody></table>
                            </div>
                            <div class="itemizedlist">
                                <ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
                                    The default value is
                                    <code class="literal">INDEX_SCAN,TABLE_SCAN</code>, which means
                                    that all searches that can use indexes do use them, and
                                    searches without any indexes use table scans.
                                </p><p style="color:blue;">默认值是index_scan，table_scan，这意味着可以使用索引的所有搜索都会使用索引，而不使用任何索引的搜索则使用表扫描。</p></li><li class="listitem"><p>
                                    To use hashing for any searches that do not use a
                                    primary or unique key, set
                                    <code class="literal">INDEX_SCAN,HASH_SCAN</code>. Specifying
                                    <code class="literal">INDEX_SCAN,HASH_SCAN</code> has the same
                                    effect as specifying
                                    <code class="literal">INDEX_SCAN,TABLE_SCAN,HASH_SCAN</code>,
                                    which is allowed.
                                </p><p style="color:blue;">若要对不使用主键或唯一键的任何搜索使用哈希，请设置index_scan、hash_scan。指定index_scan，hash_scan与指定index_scan，table_scan，hash_scan具有相同的效果，这是允许的。</p></li><li class="listitem"><p>
                                    Do not use the combination
                                    <code class="literal">TABLE_SCAN,HASH_SCAN</code>. This setting
                                    forces hashing for all searches. It has no advantage
                                    over <code class="literal">INDEX_SCAN,HASH_SCAN</code>, and it can
                                    lead to <span class="quote">“<span class="quote">record not found</span>”</span> errors or
                                    duplicate key errors in the case of a single event
                                    containing multiple updates to the same row, or updates
                                    that are order-dependent.
                                </p><p style="color:blue;">不要使用组合表扫描、哈希扫描。此设置强制对所有搜索进行哈希运算。与index_scan、hash_scan相比，它没有任何优势，如果一个事件包含对同一行的多个更新，或者更新依赖于顺序，则可能导致“record not found”错误或重复的密钥错误。</p></li></ul>
                            </div>
                            <p>
                                The order in which the algorithms are specified in the list
                                does not make any difference in the order in which they are
                                displayed by a <a class="link" href="sql-syntax.html#select" title="13.2.9&nbsp;SELECT Syntax"><code class="literal">SELECT</code></a> or
                                <a class="link" href="sql-syntax.html#show-variables" title="13.7.5.39&nbsp;SHOW VARIABLES Syntax"><code class="literal">SHOW VARIABLES</code></a> statement.
                            </p><p style="color:blue;">列表中指定算法的顺序与select或show variables语句显示算法的顺序没有任何区别。</p><p>
                                It is possible to specify a single value, but this is not
                                optimal, because setting a single value limits searches to
                                using only that algorithm. In particular, setting
                                <code class="literal">INDEX_SCAN</code> alone is not recommended, as
                                in that case searches are unable to find rows at all if no
                                index is present.
                            </p><p style="color:blue;">可以指定单个值，但这不是最优的，因为设置单个值将搜索限制为仅使用该算法。特别是，不建议单独设置索引扫描，因为在这种情况下，如果不存在索引，搜索根本找不到行。</p></li><li class="listitem"><p><a name="option_mysqld_slave-skip-errors"></a>
                            <a class="indexterm" name="idm140286798671264"></a>

                            <a class="indexterm" name="idm140286798669808"></a>

                            <a class="link" href="replication.html#option_mysqld_slave-skip-errors"><code class="option">--slave-skip-errors=[<em class="replaceable"><code>err_code1</code></em>,<em class="replaceable"><code>err_code2</code></em>,...|all|ddl_exist_errors]</code></a>
                        </p><p style="color:blue;">——从属跳过错误＝[Err.CODE1，ErrE.CODE2，….{所有ddLy存在错误]</p>
                            <div class="informaltable">
                                <table frame="box" rules="all" summary="Properties for slave-skip-errors"><colgroup><col width="30%"><col width="70%"></colgroup><thead><tr><th scope="col">Property</th>
                                    <th scope="col">Value</th>
                                </tr></thead><tbody><tr><td scope="row"><span class="bold"><strong>Command-Line Format</strong></span></td>
                                    <td><code class="literal">--slave-skip-errors=name</code></td>
                                </tr><tr><td scope="row"><span class="bold"><strong>System Variable</strong></span></td>
                                    <td><code class="literal"><a class="link" href="replication.html#sysvar_slave_skip_errors">slave_skip_errors</a></code></td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Scope</strong></span></td>
                                    <td>Global</td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Dynamic</strong></span></td>
                                    <td>No</td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Type</strong></span></td>
                                    <td>String</td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Default Value</strong></span></td>
                                    <td><code class="literal">OFF</code></td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Valid Values</strong></span></td>
                                    <td><p class="valid-value"><code class="literal">OFF</code></p><p style="color:blue;">关闭</p><p class="valid-value"><code class="literal">[list of error codes]</code></p><p style="color:blue;">[错误代码列表]</p><p class="valid-value"><code class="literal">all</code></p><p style="color:blue;">全部的</p><p class="valid-value"><code class="literal">ddl_exist_errors</code></p><p style="color:blue;">存在误差</p></td>
                                </tr></tbody></table>
                            </div>
                            <p>
                                Normally, replication stops when an error occurs on the
                                slave, which gives you the opportunity to resolve the
                                inconsistency in the data manually. This option causes the
                                slave SQL thread to continue replication when a statement
                                returns any of the errors listed in the option value.
                            </p><p style="color:blue;">通常，复制在从机上发生错误时停止，这使您有机会手动解决数据中的不一致性。当语句返回选项值中列出的任何错误时，此选项将导致从SQL线程继续复制。</p><p>
                                Do not use this option unless you fully understand why you
                                are getting errors. If there are no bugs in your replication
                                setup and client programs, and no bugs in MySQL itself, an
                                error that stops replication should never occur.
                                Indiscriminate use of this option results in slaves becoming
                                hopelessly out of synchrony with the master, with you having
                                no idea why this has occurred.
                            </p><p style="color:blue;">除非您完全理解为什么会出现错误，否则不要使用此选项。如果您的复制设置和客户端程序中没有错误，并且mysql本身也没有错误，则永远不会发生停止复制的错误。不分青红皂白地使用这个选项会导致奴隶无法与主人同步，而你不知道为什么会这样。</p><p>
                                For error codes, you should use the numbers provided by the
                                error message in your slave error log and in the output of
                                <a class="link" href="sql-syntax.html#show-slave-status" title="13.7.5.34&nbsp;SHOW SLAVE STATUS Syntax"><code class="literal">SHOW SLAVE STATUS</code></a>.
                                <a class="xref" href="error-handling.html" title="Appendix&nbsp;B&nbsp;Errors, Error Codes, and Common Problems">Appendix&nbsp;B, <i>Errors, Error Codes, and Common Problems</i></a>, lists server error codes.
                            </p><p style="color:blue;">对于错误代码，应使用从错误日志和show slave status输出中错误消息提供的数字。附录B“错误、错误代码和常见问题”列出了服务器错误代码。</p><p>
                                The shorthand value <code class="literal">ddl_exist_errors</code> is
                                equivalent to the error code list
                                <code class="literal">1007,1008,1050,1051,1054,1060,1061,1068,1094,1146</code>.
                            </p><p style="color:blue;">速记值DDLySimultError相当于错误代码列表1007100810501051 1054 10601061068 10941146。</p><p>
                                You can also (but should not) use the very nonrecommended
                                value of <code class="literal">all</code> to cause the slave to ignore
                                all error messages and keeps going regardless of what
                                happens. Needless to say, if you use <code class="literal">all</code>,
                                there are no guarantees regarding the integrity of your
                                data. Please do not complain (or file bug reports) in this
                                case if the slave's data is not anywhere close to what it is
                                on the master. <span class="emphasis"><em>You have been warned</em></span>.
                            </p><p style="color:blue;">您还可以（但不应该）使用all的非常不推荐的值来导致从机忽略所有错误消息，并继续运行，而不管发生了什么。不用说，如果全部使用，就无法保证数据的完整性。请不要抱怨（或文件错误报告）在这种情况下，如果从机的数据不是任何地方接近它在主机上。你被警告了。</p><p>
                                Examples:
                            </p><p style="color:blue;">示例：</p><pre data-lang="terminal" class="programlisting">--slave-skip-errors=1062,1053
--slave-skip-errors=all
--slave-skip-errors=ddl_exist_errors
</pre></li><li class="listitem"><p><a name="option_mysqld_slave-sql-verify-checksum"></a>
                            <a class="indexterm" name="idm140286798624576"></a>

                            <a class="indexterm" name="idm140286798623120"></a>

                            <a class="link" href="replication.html#option_mysqld_slave-sql-verify-checksum"><code class="option">--slave-sql-verify-checksum={0|1}</code></a>
                        </p><p style="color:blue;">--从SQL验证校验和={0 1}</p>
                            <div class="informaltable">
                                <table frame="box" rules="all" summary="Properties for slave-sql-verify-checksum"><colgroup><col width="30%"><col width="70%"></colgroup><thead><tr><th scope="col">Property</th>
                                    <th scope="col">Value</th>
                                </tr></thead><tbody><tr><td scope="row"><span class="bold"><strong>Command-Line Format</strong></span></td>
                                    <td><code class="literal">--slave-sql-verify-checksum[={OFF|ON}]</code></td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Type</strong></span></td>
                                    <td>Boolean</td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Default Value</strong></span></td>
                                    <td><code class="literal">ON</code></td>
                                </tr></tbody></table>
                            </div>
                            <p>
                                When this option is enabled, the slave examines checksums
                                read from the relay log, in the event of a mismatch, the
                                slave stops with an error.
                            </p><p style="color:blue;">启用此选项时，从机检查从中继日志读取的校验和，如果不匹配，则从机停止并出错。</p></li></ul>
                    </div>
                    <p>
                        The following options are used internally by the MySQL test
                        suite for replication testing and debugging. They are not
                        intended for use in a production setting.
                    </p><p style="color:blue;">mysql测试套件在内部使用以下选项进行复制测试和调试。它们不打算在生产环境中使用。</p>
                    <div class="itemizedlist">
                        <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><a name="option_mysqld_abort-slave-event-count"></a>
                            <a class="indexterm" name="idm140286798603008"></a>

                            <a class="indexterm" name="idm140286798601552"></a>

                            <a class="link" href="replication.html#option_mysqld_abort-slave-event-count"><code class="option">--abort-slave-event-count</code></a>
                        </p><p style="color:blue;">--中止从属事件计数</p>
                            <div class="informaltable">
                                <table frame="box" rules="all" summary="Properties for abort-slave-event-count"><colgroup><col width="30%"><col width="70%"></colgroup><thead><tr><th scope="col">Property</th>
                                    <th scope="col">Value</th>
                                </tr></thead><tbody><tr><td scope="row"><span class="bold"><strong>Command-Line Format</strong></span></td>
                                    <td><code class="literal">--abort-slave-event-count=#</code></td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Type</strong></span></td>
                                    <td>Integer</td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Default Value</strong></span></td>
                                    <td><code class="literal">0</code></td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Minimum Value</strong></span></td>
                                    <td><code class="literal">0</code></td>
                                </tr></tbody></table>
                            </div>
                            <p>
                                When this option is set to some positive integer
                                <em class="replaceable"><code>value</code></em> other than 0 (the default)
                                it affects replication behavior as follows: After the slave
                                SQL thread has started, <em class="replaceable"><code>value</code></em> log
                                events are permitted to be executed; after that, the slave
                                SQL thread does not receive any more events, just as if the
                                network connection from the master were cut. The slave
                                thread continues to run, and the output from
                                <a class="link" href="sql-syntax.html#show-slave-status" title="13.7.5.34&nbsp;SHOW SLAVE STATUS Syntax"><code class="literal">SHOW SLAVE STATUS</code></a> displays
                                <code class="literal">Yes</code> in both the
                                <code class="literal">Slave_IO_Running</code> and the
                                <code class="literal">Slave_SQL_Running</code> columns, but no further
                                events are read from the relay log.
                            </p><p style="color:blue;">如果将此选项设置为0以外的正整数值（默认值），则会影响复制行为，如下所示：在从属SQL线程启动后，允许执行值日志事件；在此之后，从属SQL线程不再接收任何事件，就像从主SQL线程断开网络连接一样。从线程继续运行，从show slave status的输出在slave_io_running和slave_sql_running列中都显示yes，但不会从中继日志中读取更多事件。</p></li><li class="listitem"><p><a name="option_mysqld_disconnect-slave-event-count"></a>
                            <a class="indexterm" name="idm140286798574768"></a>

                            <a class="indexterm" name="idm140286798573264"></a>

                            <a class="link" href="replication.html#option_mysqld_disconnect-slave-event-count"><code class="option">--disconnect-slave-event-count</code></a>
                        </p><p style="color:blue;">--断开从属事件计数</p>
                            <div class="informaltable">
                                <table frame="box" rules="all" summary="Properties for disconnect-slave-event-count"><colgroup><col width="30%"><col width="70%"></colgroup><thead><tr><th scope="col">Property</th>
                                    <th scope="col">Value</th>
                                </tr></thead><tbody><tr><td scope="row"><span class="bold"><strong>Command-Line Format</strong></span></td>
                                    <td><code class="literal">--disconnect-slave-event-count=#</code></td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Type</strong></span></td>
                                    <td>Integer</td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Default Value</strong></span></td>
                                    <td><code class="literal">0</code></td>
                                </tr></tbody></table>
                            </div>
                        </li></ul>
                    </div>

                </div>
                <div class="simplesect">
                    <div class="titlepage">
                        <div>
                            <div class="simple">
                                <h5 class="title"><a name="replication-options-slave-log-tables"></a>Options for Logging Slave Status to Tables</h5>

                            </div>

                        </div>

                    </div>
                    <p>
                        MySQL 5.7 supports logging of replication slave
                        status information to tables rather than files. Writing of the
                        master info log and the relay log info log can be configured
                        separately using the two server options listed here:
                    </p><p style="color:blue;">mysql 5.7支持将复制从属状态信息记录到表而不是文件中。可以使用下面列出的两个服务器选项分别配置主信息日志和中继日志信息日志的写入：</p>
                    <div class="itemizedlist">
                        <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><a name="option_mysqld_master-info-repository"></a>
                            <a class="indexterm" name="idm140286798552464"></a>

                            <a class="indexterm" name="idm140286798551008"></a>

                            <a class="link" href="replication.html#option_mysqld_master-info-repository"><code class="option">--master-info-repository={FILE|TABLE}</code></a>
                        </p><p style="color:blue;">--主信息存储库={file table}</p>
                            <div class="informaltable">
                                <table frame="box" rules="all" summary="Properties for master-info-repository"><colgroup><col width="30%"><col width="70%"></colgroup><thead><tr><th scope="col">Property</th>
                                    <th scope="col">Value</th>
                                </tr></thead><tbody><tr><td scope="row"><span class="bold"><strong>Command-Line Format</strong></span></td>
                                    <td><code class="literal">--master-info-repository={FILE|TABLE}</code></td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Type</strong></span></td>
                                    <td>String</td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Default Value</strong></span></td>
                                    <td><code class="literal">FILE</code></td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Valid Values</strong></span></td>
                                    <td><p class="valid-value"><code class="literal">FILE</code></p><p style="color:blue;">文件</p><p class="valid-value"><code class="literal">TABLE</code></p><p style="color:blue;">桌子</p></td>
                                </tr></tbody></table>
                            </div>
                            <p>
                                This option causes the server to write its master info log
                                to a file or a table. The name of the file defaults to
                                <code class="filename">master.info</code>; you can change the name of
                                the file using the
                                <a class="link" href="replication.html#option_mysqld_master-info-file"><code class="option">--master-info-file</code></a> server
                                option.
                            </p><p style="color:blue;">此选项使服务器将其主信息日志写入文件或表。文件名默认为master.info；您可以使用--master info file server选项更改文件名。</p><p>
                                The default value for this option is
                                <code class="literal">FILE</code>. If you use
                                <code class="literal">TABLE</code>, the log is written to the
                                <code class="literal">slave_master_info</code> table in the
                                <code class="literal">mysql</code> database.
                            </p><p style="color:blue;">此选项的默认值为“文件”。如果使用table，日志将写入mysql数据库中的slave_master_info表。</p></li><li class="listitem"><p><a name="option_mysqld_relay-log-info-repository"></a>
                            <a class="indexterm" name="idm140286798522256"></a>

                            <a class="indexterm" name="idm140286798520800"></a>

                            <a class="indexterm" name="idm140286798519296"></a>

                            <a class="indexterm" name="idm140286798518224"></a>

                            <a class="link" href="replication.html#option_mysqld_relay-log-info-repository"><code class="option">--relay-log-info-repository={FILE|TABLE}</code></a>
                        </p><p style="color:blue;">--中继日志信息存储库={file table}</p>
                            <div class="informaltable">
                                <table frame="box" rules="all" summary="Properties for relay-log-info-repository"><colgroup><col width="30%"><col width="70%"></colgroup><thead><tr><th scope="col">Property</th>
                                    <th scope="col">Value</th>
                                </tr></thead><tbody><tr><td scope="row"><span class="bold"><strong>Command-Line Format</strong></span></td>
                                    <td><code class="literal">--relay-log-info-repository={FILE|TABLE}</code></td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Type</strong></span></td>
                                    <td>String</td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Default Value</strong></span></td>
                                    <td><code class="literal">FILE</code></td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Valid Values</strong></span></td>
                                    <td><p class="valid-value"><code class="literal">FILE</code></p><p style="color:blue;">文件</p><p class="valid-value"><code class="literal">TABLE</code></p><p style="color:blue;">桌子</p></td>
                                </tr></tbody></table>
                            </div>
                            <p>
                                This option causes the server to log its relay log info to a
                                file or a table. The name of the file defaults to
                                <code class="filename">relay-log.info</code>; you can change the name
                                of the file using the
                                <a class="link" href="replication.html#sysvar_relay_log_info_file"><code class="literal">relay_log_info_file</code></a> system
                                variable.
                            </p><p style="color:blue;">此选项使服务器将其中继日志信息记录到文件或表中。文件名默认为relay-log.info；可以使用relay-log-info文件系统变量更改文件名。</p><p>
                                The default value for this option is
                                <code class="literal">FILE</code>. If you use
                                <code class="literal">TABLE</code>, the log is written to the
                                <code class="literal">slave_relay_log_info</code> table in the
                                <code class="literal">mysql</code> database.
                            </p><p style="color:blue;">此选项的默认值为“文件”。如果使用table，日志将写入mysql数据库中的slave_relay_log_info表。</p></li></ul>
                    </div>
                    <p>
                        These options can be used to make a replication slave resilient
                        to unexpected halts. See
                        <a class="xref" href="replication.html#replication-solutions-unexpected-slave-halt" title="16.3.2&nbsp;Handling an Unexpected Halt of a Replication Slave">Section&nbsp;16.3.2, “Handling an Unexpected Halt of a Replication Slave”</a>,
                        for more information.
                    </p><p style="color:blue;">这些选项可用于使复制从属服务器对意外停止具有弹性。有关更多信息，请参阅16.3.2节，“处理复制从机的意外停止”。</p><p>
                    The info log tables and their contents are considered local to a
                    given MySQL Server. They are not replicated, and changes to them
                    are not written to the binary log.
                </p><p style="color:blue;">信息日志表及其内容被认为是给定mysql服务器的本地内容。它们不会被复制，对它们的更改也不会写入二进制日志。</p><p>
                    For more information, see <a class="xref" href="replication.html#slave-logs" title="16.2.4&nbsp;Replication Relay and Status Logs">Section&nbsp;16.2.4, “Replication Relay and Status Logs”</a>.
                </p><p style="color:blue;">有关更多信息，请参阅第16.2.4节“复制中继和状态日志”。</p>
                </div>
                <div class="simplesect">
                    <div class="titlepage">
                        <div>
                            <div class="simple">
                                <h5 class="title"><a name="replication-sysvars-slaves"></a>System Variables Used on Replication Slaves</h5>

                            </div>

                        </div>

                    </div>
                    <p>
                        The following list describes system variables for controlling
                        replication slave servers. They can be set at server startup and
                        some of them can be changed at runtime using
                        <a class="link" href="sql-syntax.html#set-variable" title="13.7.4.1&nbsp;SET Syntax for Variable Assignment"><code class="literal">SET</code></a>.
                        Server options used with replication slaves are listed earlier
                        in this section.
                    </p><p style="color:blue;">下表描述了用于控制复制从属服务器的系统变量。它们可以在服务器启动时设置，其中一些可以在运行时使用set进行更改。本节前面列出了用于复制从属服务器的服务器选项。</p>
                    <div class="itemizedlist">
                        <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><a name="sysvar_init_slave"></a>
                            <a class="indexterm" name="idm140286798482656"></a>

                            <a class="indexterm" name="idm140286798481600"></a>

                            <a class="link" href="replication.html#sysvar_init_slave"><code class="literal">init_slave</code></a>
                        </p><p style="color:blue;">初始从机</p>
                            <div class="informaltable">
                                <table frame="box" rules="all" summary="Properties for init_slave"><colgroup><col width="30%"><col width="70%"></colgroup><thead><tr><th scope="col">Property</th>
                                    <th scope="col">Value</th>
                                </tr></thead><tbody><tr><td scope="row"><span class="bold"><strong>Command-Line Format</strong></span></td>
                                    <td><code class="literal">--init-slave=name</code></td>
                                </tr><tr><td scope="row"><span class="bold"><strong>System Variable</strong></span></td>
                                    <td><code class="literal"><a class="link" href="replication.html#sysvar_init_slave">init_slave</a></code></td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Scope</strong></span></td>
                                    <td>Global</td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Dynamic</strong></span></td>
                                    <td>Yes</td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Type</strong></span></td>
                                    <td>String</td>
                                </tr></tbody></table>
                            </div>
                            <p>
                                This variable is similar to
                                <a class="link" href="server-administration.html#sysvar_init_connect"><code class="literal">init_connect</code></a>, but is a
                                string to be executed by a slave server each time the SQL
                                thread starts. The format of the string is the same as for
                                the <a class="link" href="server-administration.html#sysvar_init_connect"><code class="literal">init_connect</code></a> variable.
                                The setting of this variable takes effect for subsequent
                                <a class="link" href="sql-syntax.html#start-slave" title="13.4.2.6&nbsp;START SLAVE Syntax"><code class="literal">START SLAVE</code></a> statements.
                            </p><p style="color:blue;">此变量类似于init_connect，但它是一个字符串，在每次启动sql线程时由从属服务器执行。字符串的格式与init_connect变量的格式相同。此变量的设置对后续的start slave语句生效。</p>
                            <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">

                                <div class="admon-title">
                                    Note
                                </div>
                                <p>
                                    The SQL thread sends an acknowledgment to the client
                                    before it executes
                                    <a class="link" href="replication.html#sysvar_init_slave"><code class="literal">init_slave</code></a>. Therefore, it
                                    is not guaranteed that
                                    <a class="link" href="replication.html#sysvar_init_slave"><code class="literal">init_slave</code></a> has been
                                    executed when <a class="link" href="sql-syntax.html#start-slave" title="13.4.2.6&nbsp;START SLAVE Syntax"><code class="literal">START SLAVE</code></a>
                                    returns. See <a class="xref" href="sql-syntax.html#start-slave" title="13.4.2.6&nbsp;START SLAVE Syntax">Section&nbsp;13.4.2.6, “START SLAVE Syntax”</a>, for more
                                    information.
                                </p><p style="color:blue;">sql线程在执行init_slave之前向客户端发送一个确认。因此，不能保证在启动从机返回时执行了init_slave。有关详细信息，请参阅第13.4.2.6节“启动从机语法”。</p>
                            </div>
                        </li><li class="listitem"><p><a name="sysvar_log_slow_slave_statements"></a>
                            <a class="indexterm" name="idm140286798447200"></a>

                            <a class="indexterm" name="idm140286798445712"></a>

                            <a class="link" href="replication.html#sysvar_log_slow_slave_statements"><code class="literal">log_slow_slave_statements</code></a>
                        </p><p style="color:blue;">log_slow_slave_语句</p>
                            <div class="informaltable">
                                <table frame="box" rules="all" summary="Properties for log_slow_slave_statements"><colgroup><col width="30%"><col width="70%"></colgroup><thead><tr><th scope="col">Property</th>
                                    <th scope="col">Value</th>
                                </tr></thead><tbody><tr><td scope="row"><span class="bold"><strong>Command-Line Format</strong></span></td>
                                    <td><code class="literal">--log-slow-slave-statements[={OFF|ON}]</code></td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Introduced</strong></span></td>
                                    <td>5.7.1</td>
                                </tr><tr><td scope="row"><span class="bold"><strong>System Variable</strong></span></td>
                                    <td><code class="literal"><a class="link" href="replication.html#sysvar_log_slow_slave_statements">log_slow_slave_statements</a></code></td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Scope</strong></span></td>
                                    <td>Global</td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Dynamic</strong></span></td>
                                    <td>Yes</td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Type</strong></span></td>
                                    <td>Boolean</td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Default Value</strong></span></td>
                                    <td><code class="literal">OFF</code></td>
                                </tr></tbody></table>
                            </div>
                            <p>
                                When the slow query log is enabled, this variable enables
                                logging for queries that have taken more than
                                <a class="link" href="server-administration.html#sysvar_long_query_time"><code class="literal">long_query_time</code></a> seconds to
                                execute on the slave. Note that if row-based replication is
                                in use (<a class="link" href="replication.html#sysvar_binlog_format"><code class="literal">binlog_format=ROW</code></a>),
                                <a class="link" href="replication.html#sysvar_log_slow_slave_statements"><code class="literal">log_slow_slave_statements</code></a>
                                has no effect. Queries are only added to the slave's slow
                                query log when they are logged in statement format in the
                                binary log, that is, when
                                <a class="link" href="replication.html#sysvar_binlog_format"><code class="literal">binlog_format=STATEMENT</code></a> is
                                set, or when
                                <a class="link" href="replication.html#sysvar_binlog_format"><code class="literal">binlog_format=MIXED</code></a> is set
                                and the statement is logged in statement format. Slow
                                queries that are logged in row format when
                                <a class="link" href="replication.html#sysvar_binlog_format"><code class="literal">binlog_format=MIXED</code></a> is set,
                                or that are logged when
                                <a class="link" href="replication.html#sysvar_binlog_format"><code class="literal">binlog_format=ROW</code></a> is set,
                                are not added to the slave's slow query log, even if
                                <a class="link" href="replication.html#sysvar_log_slow_slave_statements"><code class="literal">log_slow_slave_statements</code></a>
                                is enabled.
                            </p><p style="color:blue;">当启用慢速查询日志时，此变量将为在从属服务器上执行的查询启用日志记录，这些查询花费了超过long_query_time seconds的时间。请注意，如果正在使用基于行的复制（binlog_format=row），则log_slow_slave_语句无效。只有当查询在二进制日志中以语句格式记录时，即当设置了binlog_format=statement，或当设置了binlog_format=mixed且语句以语句格式记录时，才会将查询添加到从属的慢速查询日志中。设置binlog_format=mixed时以行格式记录的慢查询，或设置binlog_format=row时记录的慢查询，即使启用了log_slow_slave_语句，也不会添加到从机的慢查询日志中。</p><p>
                                Setting
                                <a class="link" href="replication.html#sysvar_log_slow_slave_statements"><code class="literal">log_slow_slave_statements</code></a>
                                has no immediate effect. The state of the variable applies
                                on all subsequent <a class="link" href="sql-syntax.html#start-slave" title="13.4.2.6&nbsp;START SLAVE Syntax"><code class="literal">START SLAVE</code></a>
                                statements. Also note that the global setting for
                                <a class="link" href="server-administration.html#sysvar_long_query_time"><code class="literal">long_query_time</code></a> applies for
                                the lifetime of the SQL thread. If you change that setting,
                                you must stop and restart the slave's SQL thread to
                                implement the change there (for example, by issuing
                                <a class="link" href="sql-syntax.html#stop-slave" title="13.4.2.7&nbsp;STOP SLAVE Syntax"><code class="literal">STOP SLAVE</code></a> and
                                <a class="link" href="sql-syntax.html#start-slave" title="13.4.2.6&nbsp;START SLAVE Syntax"><code class="literal">START SLAVE</code></a> statements with
                                the <code class="literal">SQL_THREAD</code> option).
                            </p><p style="color:blue;">设置log_slow_slave_语句不会立即生效。变量的状态应用于所有后续的start-slave语句。还要注意，long_query_time的全局设置适用于sql线程的生存期。如果更改了该设置，则必须停止并重新启动从机的sql线程，以在其中实现更改（例如，通过使用sql_thread选项发出stop slave和start slave语句）。</p></li><li class="listitem"><p><a name="sysvar_master_info_repository"></a>
                            <a class="indexterm" name="idm140286798396464"></a>

                            <a class="indexterm" name="idm140286798395424"></a>

                            <a class="link" href="replication.html#sysvar_master_info_repository"><code class="literal">master_info_repository</code></a>
                        </p><p style="color:blue;">主信息库</p>
                            <div class="informaltable">
                                <table frame="box" rules="all" summary="Properties for master_info_repository"><colgroup><col width="30%"><col width="70%"></colgroup><thead><tr><th scope="col">Property</th>
                                    <th scope="col">Value</th>
                                </tr></thead><tbody><tr><td scope="row"><span class="bold"><strong>Command-Line Format</strong></span></td>
                                    <td><code class="literal">--master-info-repository={FILE|TABLE}</code></td>
                                </tr><tr><td scope="row"><span class="bold"><strong>System Variable</strong></span></td>
                                    <td><code class="literal"><a class="link" href="replication.html#sysvar_master_info_repository">master_info_repository</a></code></td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Scope</strong></span></td>
                                    <td>Global</td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Dynamic</strong></span></td>
                                    <td>Yes</td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Type</strong></span></td>
                                    <td>String</td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Default Value</strong></span></td>
                                    <td><code class="literal">FILE</code></td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Valid Values</strong></span></td>
                                    <td><p class="valid-value"><code class="literal">FILE</code></p><p style="color:blue;">文件</p><p class="valid-value"><code class="literal">TABLE</code></p><p style="color:blue;">桌子</p></td>
                                </tr></tbody></table>
                            </div>
                            <p>
                                The setting of this variable determines whether the slave
                                logs master status and connection information to a
                                <code class="literal">FILE</code> (<code class="filename">master.info</code>),
                                or to a <code class="literal">TABLE</code>
                                (<code class="literal">mysql.slave_master_info</code>). You can only
                                change the value of this variable when no replication
                                threads are executing.
                            </p><p style="color:blue;">此变量的设置确定从服务器是将主状态和连接信息记录到文件（master.info）还是记录到表（mysql.slave\u master\u info）。只有在没有执行复制线程时，才能更改此变量的值。</p><p>
                                The setting of this variable also has a direct influence on
                                the effect had by the setting of the
                                <a class="link" href="replication.html#sysvar_sync_master_info"><code class="literal">sync_master_info</code></a> system
                                variable; see that variable's description for further
                                information.
                            </p><p style="color:blue;">此变量的设置也会直接影响sync_master_info系统变量的设置所产生的效果；有关详细信息，请参见该变量的说明。</p><p>
                                This variable must be set to <code class="literal">TABLE</code> before
                                configuring multiple replication channels. If you are using
                                multiple replication channels then you cannot set this
                                variable back to <code class="literal">FILE</code>.
                            </p><p style="color:blue;">在配置多个复制通道之前，必须将此变量设置为table。如果使用多个复制通道，则无法将此变量设置回文件。</p></li><li class="listitem"><p><a name="sysvar_max_relay_log_size"></a>
                            <a class="indexterm" name="idm140286798355792"></a>

                            <a class="indexterm" name="idm140286798354752"></a>

                            <a class="link" href="replication.html#sysvar_max_relay_log_size"><code class="literal">max_relay_log_size</code></a>
                        </p><p style="color:blue;">最大继电器日志大小</p>
                            <div class="informaltable">
                                <table frame="box" rules="all" summary="Properties for max_relay_log_size"><colgroup><col width="30%"><col width="70%"></colgroup><thead><tr><th scope="col">Property</th>
                                    <th scope="col">Value</th>
                                </tr></thead><tbody><tr><td scope="row"><span class="bold"><strong>Command-Line Format</strong></span></td>
                                    <td><code class="literal">--max-relay-log-size=#</code></td>
                                </tr><tr><td scope="row"><span class="bold"><strong>System Variable</strong></span></td>
                                    <td><code class="literal"><a class="link" href="replication.html#sysvar_max_relay_log_size">max_relay_log_size</a></code></td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Scope</strong></span></td>
                                    <td>Global</td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Dynamic</strong></span></td>
                                    <td>Yes</td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Type</strong></span></td>
                                    <td>Integer</td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Default Value</strong></span></td>
                                    <td><code class="literal">0</code></td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Minimum Value</strong></span></td>
                                    <td><code class="literal">0</code></td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Maximum Value</strong></span></td>
                                    <td><code class="literal">1073741824</code></td>
                                </tr></tbody></table>
                            </div>
                            <p>
                                If a write by a replication slave to its relay log causes
                                the current log file size to exceed the value of this
                                variable, the slave rotates the relay logs (closes the
                                current file and opens the next one). If
                                <a class="link" href="replication.html#sysvar_max_relay_log_size"><code class="literal">max_relay_log_size</code></a> is 0,
                                the server uses
                                <a class="link" href="replication.html#sysvar_max_binlog_size"><code class="literal">max_binlog_size</code></a> for both
                                the binary log and the relay log. If
                                <a class="link" href="replication.html#sysvar_max_relay_log_size"><code class="literal">max_relay_log_size</code></a> is
                                greater than 0, it constrains the size of the relay log,
                                which enables you to have different sizes for the two logs.
                                You must set
                                <a class="link" href="replication.html#sysvar_max_relay_log_size"><code class="literal">max_relay_log_size</code></a> to
                                between 4096 bytes and 1GB (inclusive), or to 0. The default
                                value is 0. See
                                <a class="xref" href="replication.html#replication-implementation-details" title="16.2.2&nbsp;Replication Implementation Details">Section&nbsp;16.2.2, “Replication Implementation Details”</a>.
                            </p><p style="color:blue;">如果复制从属服务器对其中继日志的写入导致当前日志文件大小超过此变量的值，则从属服务器会旋转中继日志（关闭当前文件并打开下一个文件）。如果max_relay_log_size为0，服务器将对二进制日志和中继日志使用max_binlog_size。如果max_relay_log_size大于0，则它会限制中继日志的大小，这使您可以为两个日志设置不同的大小。必须将max_relay_log_size设置为4096字节到1GB（含）之间，或设置为0。默认值为0。参见第16.2.2节“复制实现详细信息”。</p></li><li class="listitem"><p><a name="sysvar_relay_log"></a>
                            <a class="link" href="replication.html#sysvar_relay_log"><code class="literal">relay_log</code></a>
                        </p><p style="color:blue;">继电器日志</p><a class="indexterm" name="idm140286798312896"></a><a class="indexterm" name="idm140286798311808"></a>
                            <div class="informaltable">
                                <table frame="box" rules="all" summary="Properties for relay_log"><colgroup><col width="30%"><col width="70%"></colgroup><thead><tr><th scope="col">Property</th>
                                    <th scope="col">Value</th>
                                </tr></thead><tbody><tr><td scope="row"><span class="bold"><strong>Command-Line Format</strong></span></td>
                                    <td><code class="literal">--relay-log=file_name</code></td>
                                </tr><tr><td scope="row"><span class="bold"><strong>System Variable</strong></span></td>
                                    <td><code class="literal"><a class="link" href="replication.html#sysvar_relay_log">relay_log</a></code></td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Scope</strong></span></td>
                                    <td>Global</td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Dynamic</strong></span></td>
                                    <td>No</td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Type</strong></span></td>
                                    <td>File name</td>
                                </tr></tbody></table>
                            </div>
                            <p>
                                The base name for relay log files. For the default
                                replication channel, the default base name for relay logs is
                                <code class="filename"><em class="replaceable"><code>host_name</code></em>-relay-bin</code>.
                                For non-default replication channels, the default base name
                                for relay logs is
                                <code class="filename"><em class="replaceable"><code>host_name</code></em>-relay-bin-<em class="replaceable"><code>channel</code></em></code>,
                                where <em class="replaceable"><code>channel</code></em> is the name of the
                                replication channel recorded in this relay log.
                            </p><p style="color:blue;">中继日志文件的基名称。对于默认复制通道，中继日志的默认基名称为host_name-relay-bin。对于非默认复制通道，中继日志的默认基名称为host_name-relay-bin-channel，其中channel是此中继日志中记录的复制通道的名称。</p><p>
                                The server writes the file in the data directory unless the
                                base name is given with a leading absolute path name to
                                specify a different directory. The server creates relay log
                                files in sequence by adding a numeric suffix to the base
                                name.
                            </p><p style="color:blue;">服务器在数据目录中写入文件，除非为基名指定了前导绝对路径名以指定其他目录。服务器通过在基名称中添加数字后缀，按顺序创建中继日志文件。</p><p>
                                Due to the manner in which MySQL parses server options, if
                                you specify this variable at server startup, you must supply
                                a value; <span class="emphasis"><em>the default base name is used only if the
            option is not actually specified</em></span>. If you specify
                                the <a class="link" href="replication.html#sysvar_relay_log"><code class="literal">relay_log</code></a> system
                                variable at server startup without specifying a value,
                                unexpected behavior is likely to result; this behavior
                                depends on the other options used, the order in which they
                                are specified, and whether they are specified on the command
                                line or in an option file. For more information about how
                                MySQL handles server options, see
                                <a class="xref" href="programs.html#program-options" title="4.2.2&nbsp;Specifying Program Options">Section&nbsp;4.2.2, “Specifying Program Options”</a>.
                            </p><p style="color:blue;">由于mysql解析服务器选项的方式，如果在服务器启动时指定此变量，则必须提供一个值；只有在未实际指定该选项时，才使用默认基名。如果在服务器启动时未指定值而指定中继日志系统变量，则可能会导致意外行为；此行为取决于使用的其他选项、指定顺序以及是在命令行还是在选项文件中指定。有关MySQL如何处理服务器选项的详细信息，请参阅第4.2.2节“指定程序选项”。</p><p>
                                If you specify this variable, the value specified is also
                                used as the base name for the relay log index file. You can
                                override this behavior by specifying a different relay log
                                index file base name using the
                                <a class="link" href="replication.html#sysvar_relay_log_index"><code class="literal">relay_log_index</code></a> system
                                variable.
                            </p><p style="color:blue;">如果指定此变量，则指定的值也将用作中继日志索引文件的基名称。可以通过使用RELAY LOG U INDEX系统变量指定不同的中继日志索引文件基名称来覆盖此行为。</p><p>
                                When the server reads an entry from the index file, it
                                checks whether the entry contains a relative path. If it
                                does, the relative part of the path is replaced with the
                                absolute path set using the
                                <a class="link" href="replication.html#sysvar_relay_log"><code class="literal">relay_log</code></a> system variable.
                                An absolute path remains unchanged; in such a case, the
                                index must be edited manually to enable the new path or
                                paths to be used.
                            </p><p style="color:blue;">当服务器从索引文件中读取条目时，它会检查该条目是否包含相对路径。如果是，则使用RELAY U LOG系统变量将路径的相对部分替换为绝对路径集。绝对路径保持不变；在这种情况下，必须手动编辑索引才能使用新路径。</p><p>
                                You may find the <a class="link" href="replication.html#sysvar_relay_log"><code class="literal">relay_log</code></a>
                                system variable useful in performing the following tasks:
                            </p><p style="color:blue;">您可能会发现RELAY U LOG系统变量在执行以下任务时非常有用：</p>
                            <div class="itemizedlist">
                                <ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
                                    Creating relay logs whose names are independent of host
                                    names.
                                </p><p style="color:blue;">创建名称独立于主机名的中继日志。</p></li><li class="listitem"><p>
                                    If you need to put the relay logs in some area other
                                    than the data directory because your relay logs tend to
                                    be very large and you do not want to decrease
                                    <a class="link" href="replication.html#sysvar_max_relay_log_size"><code class="literal">max_relay_log_size</code></a>.
                                </p><p style="color:blue;">如果您需要将中继日志放在数据目录以外的某个区域，因为您的中继日志往往很大，并且您不希望减小最大中继日志大小。</p></li><li class="listitem"><p>
                                    To increase speed by using load-balancing between disks.
                                </p><p style="color:blue;">通过在磁盘之间使用负载平衡来提高速度。</p></li></ul>
                            </div>
                            <p>
                                You can obtain the relay log file name (and path) from the
                                <a class="link" href="replication.html#sysvar_relay_log_basename"><code class="literal">relay_log_basename</code></a> system
                                variable.
                            </p><p style="color:blue;">可以从RELAY LOG_BASENAME系统变量中获取中继日志文件名（和路径）。</p></li><li class="listitem"><p><a name="sysvar_relay_log_basename"></a>
                            <a class="indexterm" name="idm140286798269024"></a>

                            <a class="indexterm" name="idm140286798267984"></a>

                            <a class="link" href="replication.html#sysvar_relay_log_basename"><code class="literal">relay_log_basename</code></a>
                        </p><p style="color:blue;">中继日志基名称</p>
                            <div class="informaltable">
                                <table frame="box" rules="all" summary="Properties for relay_log_basename"><colgroup><col width="30%"><col width="70%"></colgroup><thead><tr><th scope="col">Property</th>
                                    <th scope="col">Value</th>
                                </tr></thead><tbody><tr><td scope="row"><span class="bold"><strong>System Variable</strong></span></td>
                                    <td><code class="literal"><a class="link" href="replication.html#sysvar_relay_log_basename">relay_log_basename</a></code></td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Scope</strong></span></td>
                                    <td>Global</td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Dynamic</strong></span></td>
                                    <td>No</td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Type</strong></span></td>
                                    <td>File name</td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Default Value</strong></span></td>
                                    <td><code class="literal">datadir + '/' + hostname + '-relay-bin'</code></td>
                                </tr></tbody></table>
                            </div>
                            <p>
                                Holds the name and complete path to the relay log file. This
                                variable is set by the server and is read only.
                            </p><p style="color:blue;">保存中继日志文件的名称和完整路径。此变量由服务器设置，并且是只读的。</p></li><li class="listitem"><p><a name="sysvar_relay_log_index"></a>
                            <a class="link" href="replication.html#sysvar_relay_log_index"><code class="literal">relay_log_index</code></a>
                        </p><p style="color:blue;">中继日志索引</p><a class="indexterm" name="idm140286798241504"></a><a class="indexterm" name="idm140286798240416"></a>
                            <div class="informaltable">
                                <table frame="box" rules="all" summary="Properties for relay_log_index"><colgroup><col width="30%"><col width="70%"></colgroup><thead><tr><th scope="col">Property</th>
                                    <th scope="col">Value</th>
                                </tr></thead><tbody><tr><td scope="row"><span class="bold"><strong>Command-Line Format</strong></span></td>
                                    <td><code class="literal">--relay-log-index=file_name</code></td>
                                </tr><tr><td scope="row"><span class="bold"><strong>System Variable</strong></span></td>
                                    <td><code class="literal"><a class="link" href="replication.html#sysvar_relay_log_index">relay_log_index</a></code></td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Scope</strong></span></td>
                                    <td>Global</td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Dynamic</strong></span></td>
                                    <td>No</td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Type</strong></span></td>
                                    <td>File name</td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Default Value</strong></span></td>
                                    <td><code class="literal">*host_name*-relay-bin.index</code></td>
                                </tr></tbody></table>
                            </div>
                            <p>
                                The name for the relay log index file. For the default
                                replication channel, the default name is
                                <code class="filename"><em class="replaceable"><code>host_name</code></em>-relay-bin.index</code>.
                                For non-default replication channels, the default name is
                                <code class="filename"><em class="replaceable"><code>host_name</code></em>-relay-bin-<em class="replaceable"><code>channel</code></em>.index</code>,
                                where <em class="replaceable"><code>channel</code></em> is the name of the
                                replication channel recorded in this relay log index.
                            </p><p style="color:blue;">中继日志索引文件的名称。对于默认复制通道，默认名称为host_name-relay-bin.index。对于非默认复制通道，默认名称为host_name-relay-bin-channel.index，其中channel是此中继日志索引中记录的复制通道的名称。</p><p>
                                The server writes the file in the data directory unless the
                                name is given with a leading absolute path name to specify a
                                different directory. name.
                            </p><p style="color:blue;">服务器将文件写入数据目录，除非该文件名具有前导绝对路径名以指定其他目录。名字。</p><p>
                                Due to the manner in which MySQL parses server options, if
                                you specify this variable at server startup, you must supply
                                a value; <span class="emphasis"><em>the default base name is used only if the
            option is not actually specified</em></span>. If you specify
                                the <a class="link" href="replication.html#sysvar_relay_log_index"><code class="literal">relay_log_index</code></a> system
                                variable at server startup without specifying a value,
                                unexpected behavior is likely to result; this behavior
                                depends on the other options used, the order in which they
                                are specified, and whether they are specified on the command
                                line or in an option file. For more information about how
                                MySQL handles server options, see
                                <a class="xref" href="programs.html#program-options" title="4.2.2&nbsp;Specifying Program Options">Section&nbsp;4.2.2, “Specifying Program Options”</a>.
                            </p><p style="color:blue;">由于mysql解析服务器选项的方式，如果在服务器启动时指定此变量，则必须提供一个值；只有在未实际指定该选项时，才使用默认基名。如果在服务器启动时未指定值而指定RELAY U LOG U INDEX系统变量，则可能会导致意外行为；此行为取决于使用的其他选项、指定它们的顺序以及它们是在命令行还是在选项文件中指定。有关MySQL如何处理服务器选项的详细信息，请参阅第4.2.2节“指定程序选项”。</p></li><li class="listitem"><p><a name="sysvar_relay_log_info_file"></a>
                            <a class="link" href="replication.html#sysvar_relay_log_info_file"><code class="literal">relay_log_info_file</code></a>
                        </p><p style="color:blue;">中继日志信息文件</p><a class="indexterm" name="idm140286798205152"></a><a class="indexterm" name="idm140286798204112"></a>
                            <div class="informaltable">
                                <table frame="box" rules="all" summary="Properties for relay_log_info_file"><colgroup><col width="30%"><col width="70%"></colgroup><thead><tr><th scope="col">Property</th>
                                    <th scope="col">Value</th>
                                </tr></thead><tbody><tr><td scope="row"><span class="bold"><strong>Command-Line Format</strong></span></td>
                                    <td><code class="literal">--relay-log-info-file=file_name</code></td>
                                </tr><tr><td scope="row"><span class="bold"><strong>System Variable</strong></span></td>
                                    <td><code class="literal"><a class="link" href="replication.html#sysvar_relay_log_info_file">relay_log_info_file</a></code></td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Scope</strong></span></td>
                                    <td>Global</td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Dynamic</strong></span></td>
                                    <td>No</td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Type</strong></span></td>
                                    <td>File name</td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Default Value</strong></span></td>
                                    <td><code class="literal">relay-log.info</code></td>
                                </tr></tbody></table>
                            </div>
                            <p>
                                The name of the file in which the slave records information
                                about the relay logs, when
                                <a class="link" href="replication.html#sysvar_relay_log_info_repository"><code class="literal">relay_log_info_repository=FILE</code></a>.
                                If
                                <a class="link" href="replication.html#sysvar_relay_log_info_repository"><code class="literal">relay_log_info_repository=TABLE</code></a>,
                                it is the file name that would be used in case the
                                repository was changed to <code class="literal">FILE</code>). The
                                default name is <code class="filename">relay-log.info</code> in the
                                data directory.
                            </p><p style="color:blue;">当relay-log-info-repository=file时，从机记录有关中继日志信息的文件的名称。如果relay_log_info_repository=table，则是存储库更改为file时将使用的文件名。默认名称是数据目录中的relay-log.info。</p></li><li class="listitem"><p><a name="sysvar_relay_log_info_repository"></a>
                            <a class="indexterm" name="idm140286798173024"></a>

                            <a class="indexterm" name="idm140286798171920"></a>

                            <a class="link" href="replication.html#sysvar_relay_log_info_repository"><code class="literal">relay_log_info_repository</code></a>
                        </p><p style="color:blue;">中继日志信息库</p>
                            <div class="informaltable">
                                <table frame="box" rules="all" summary="Properties for relay_log_info_repository"><colgroup><col width="30%"><col width="70%"></colgroup><thead><tr><th scope="col">Property</th>
                                    <th scope="col">Value</th>
                                </tr></thead><tbody><tr><td scope="row"><span class="bold"><strong>Command-Line Format</strong></span></td>
                                    <td><code class="literal">--relay-log-info-repository=value</code></td>
                                </tr><tr><td scope="row"><span class="bold"><strong>System Variable</strong></span></td>
                                    <td><code class="literal"><a class="link" href="replication.html#sysvar_relay_log_info_repository">relay_log_info_repository</a></code></td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Scope</strong></span></td>
                                    <td>Global</td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Dynamic</strong></span></td>
                                    <td>Yes</td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Type</strong></span></td>
                                    <td>String</td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Default Value</strong></span></td>
                                    <td><code class="literal">FILE</code></td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Valid Values</strong></span></td>
                                    <td><p class="valid-value"><code class="literal">FILE</code></p><p style="color:blue;">文件</p><p class="valid-value"><code class="literal">TABLE</code></p><p style="color:blue;">桌子</p></td>
                                </tr></tbody></table>
                            </div>
                            <p>
                                This variable determines whether the slave's position
                                in the relay logs is written to a <code class="literal">FILE</code>
                                (<code class="filename">relay-log.info</code>) or to a
                                <code class="literal">TABLE</code>
                                (<code class="literal">mysql.slave_relay_log_info</code>). You can
                                only change the value of this variable when no replication
                                threads are executing.
                            </p><p style="color:blue;">此变量确定从服务器在中继日志中的位置是写入文件（relay log.info）还是写入表（mysql.slave_relay_log_info）。只有在没有执行复制线程时，才能更改此变量的值。</p><p>
                                The setting of this variable also has a direct influence on
                                the effect had by the setting of the
                                <a class="link" href="replication.html#sysvar_sync_relay_log_info"><code class="literal">sync_relay_log_info</code></a> system
                                variable; see that variable's description for further
                                information.
                            </p><p style="color:blue;">此变量的设置也会直接影响sync_relay_log_info系统变量的设置所产生的效果；有关详细信息，请参见该变量的说明。</p><p>
                                This variable must be set to <code class="literal">TABLE</code> before
                                configuring multiple replication channels. If you are using
                                multiple replication channels then you cannot set this
                                variable back to <code class="literal">FILE</code>.
                            </p><p style="color:blue;">在配置多个复制通道之前，必须将此变量设置为table。如果使用多个复制通道，则无法将此变量设置回文件。</p></li><li class="listitem"><p><a name="sysvar_relay_log_purge"></a>
                            <a class="indexterm" name="idm140286798132224"></a>

                            <a class="indexterm" name="idm140286798131216"></a>

                            <a class="link" href="replication.html#sysvar_relay_log_purge"><code class="literal">relay_log_purge</code></a>
                        </p><p style="color:blue;">继电器日志清除</p>
                            <div class="informaltable">
                                <table frame="box" rules="all" summary="Properties for relay_log_purge"><colgroup><col width="30%"><col width="70%"></colgroup><thead><tr><th scope="col">Property</th>
                                    <th scope="col">Value</th>
                                </tr></thead><tbody><tr><td scope="row"><span class="bold"><strong>Command-Line Format</strong></span></td>
                                    <td><code class="literal">--relay-log-purge[={OFF|ON}]</code></td>
                                </tr><tr><td scope="row"><span class="bold"><strong>System Variable</strong></span></td>
                                    <td><code class="literal"><a class="link" href="replication.html#sysvar_relay_log_purge">relay_log_purge</a></code></td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Scope</strong></span></td>
                                    <td>Global</td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Dynamic</strong></span></td>
                                    <td>Yes</td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Type</strong></span></td>
                                    <td>Boolean</td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Default Value</strong></span></td>
                                    <td><code class="literal">ON</code></td>
                                </tr></tbody></table>
                            </div>
                            <p>
                                Disables or enables automatic purging of relay log files as
                                soon as they are not needed any more. The default value is 1
                                (<code class="literal">ON</code>).
                            </p><p style="color:blue;">在不再需要中继日志文件时禁用或启用自动清除。默认值为1（开）。</p></li><li class="listitem"><p><a name="sysvar_relay_log_recovery"></a>
                            <a class="indexterm" name="idm140286798102288"></a>

                            <a class="indexterm" name="idm140286798100800"></a>

                            <a class="link" href="replication.html#sysvar_relay_log_recovery"><code class="literal">relay_log_recovery</code></a>
                        </p><p style="color:blue;">中继日志恢复</p>
                            <div class="informaltable">
                                <table frame="box" rules="all" summary="Properties for relay_log_recovery"><colgroup><col width="30%"><col width="70%"></colgroup><thead><tr><th scope="col">Property</th>
                                    <th scope="col">Value</th>
                                </tr></thead><tbody><tr><td scope="row"><span class="bold"><strong>Command-Line Format</strong></span></td>
                                    <td><code class="literal">--relay-log-recovery[={OFF|ON}]</code></td>
                                </tr><tr><td scope="row"><span class="bold"><strong>System Variable</strong></span></td>
                                    <td><code class="literal"><a class="link" href="replication.html#sysvar_relay_log_recovery">relay_log_recovery</a></code></td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Scope</strong></span></td>
                                    <td>Global</td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Dynamic</strong></span></td>
                                    <td>No</td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Type</strong></span></td>
                                    <td>Boolean</td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Default Value</strong></span></td>
                                    <td><code class="literal">OFF</code></td>
                                </tr></tbody></table>
                            </div>
                            <p>
                                Enables automatic relay log recovery immediately following
                                server startup. The recovery process creates a new relay log
                                file, initializes the SQL thread position to this new relay
                                log, and initializes the I/O thread to the SQL thread
                                position. Reading of the relay log from the master then
                                continues. This global variable is read-only; its value can
                                be changed by starting the slave with the
                                <a class="link" href="replication.html#option_mysqld_relay-log-recovery"><code class="option">--relay-log-recovery</code></a> option,
                                which should be used following an unexpected halt of a
                                replication slave to ensure that no possibly corrupted relay
                                logs are processed. See
                                <a class="xref" href="replication.html#replication-solutions-unexpected-slave-halt" title="16.3.2&nbsp;Handling an Unexpected Halt of a Replication Slave">Section&nbsp;16.3.2, “Handling an Unexpected Halt of a Replication Slave”</a>
                                for more information.
                            </p><p style="color:blue;">在服务器启动后立即启用自动中继日志恢复。恢复过程将创建一个新的中继日志文件，将sql线程位置初始化为此新中继日志，并将i/o线程初始化为sql线程位置。然后继续从主机读取中继日志。此全局变量是只读的；可以通过使用--relay log recovery选项启动从机来更改其值，该选项应在复制从机意外停止后使用，以确保不会处理任何可能已损坏的中继日志。有关更多信息，请参阅16.3.2节，“处理复制从机的意外停止”。</p><p>
                                This variable also interacts with
                                <a class="link" href="replication.html#sysvar_relay_log_purge"><code class="option">relay-log-purge</code></a>, which
                                controls purging of logs when they are no longer needed.
                                Enabling the
                                <a class="link" href="replication.html#option_mysqld_relay-log-recovery"><code class="option">--relay-log-recovery</code></a> option
                                when <a class="link" href="replication.html#sysvar_relay_log_purge"><code class="option">relay-log-purge</code></a> is
                                disabled risks reading the relay log from files that were
                                not purged, leading to data inconsistency.
                            </p><p style="color:blue;">此变量还与中继日志清除交互，中继日志清除在不再需要日志时控制日志的清除。禁用中继日志清除时启用--relay log recovery选项可能会从未清除的文件中读取中继日志，从而导致数据不一致。</p><p>
                                When <code class="literal">relay_log_recovery</code> is enabled and
                                the slave has stopped due to errors encountered while
                                running in multithreaded mode, you can use
                                <a class="link" href="sql-syntax.html#start-slave" title="13.4.2.6&nbsp;START SLAVE Syntax"><code class="literal">START SLAVE
                                    UNTIL SQL_AFTER_MTS_GAPS</code></a> to ensure that all gaps
                                are processed before switching back to single-threaded mode
                                or executing a <code class="literal">CHANGE MASTER TO</code>
                                statement.
                            </p><p style="color:blue;">如果启用了relay_log_recovery，并且由于在多线程模式下运行时遇到错误，从机已停止，则可以使用start slave直到sql_after_mts_gaps，以确保在切换回单线程模式或执行change master to语句之前处理所有间隙。</p></li><li class="listitem"><p><a name="sysvar_relay_log_space_limit"></a>
                            <a class="indexterm" name="idm140286798063664"></a>

                            <a class="indexterm" name="idm140286798062624"></a>

                            <a class="link" href="replication.html#sysvar_relay_log_space_limit"><code class="literal">relay_log_space_limit</code></a>
                        </p><p style="color:blue;">继电器日志空间限制</p>
                            <div class="informaltable">
                                <table frame="box" rules="all" summary="Properties for relay_log_space_limit"><colgroup><col width="30%"><col width="70%"></colgroup><thead><tr><th scope="col">Property</th>
                                    <th scope="col">Value</th>
                                </tr></thead><tbody><tr><td scope="row"><span class="bold"><strong>Command-Line Format</strong></span></td>
                                    <td><code class="literal">--relay-log-space-limit=#</code></td>
                                </tr><tr><td scope="row"><span class="bold"><strong>System Variable</strong></span></td>
                                    <td><code class="literal"><a class="link" href="replication.html#sysvar_relay_log_space_limit">relay_log_space_limit</a></code></td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Scope</strong></span></td>
                                    <td>Global</td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Dynamic</strong></span></td>
                                    <td>No</td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Type</strong></span></td>
                                    <td>Integer</td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Default Value</strong></span></td>
                                    <td><code class="literal">0</code></td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Minimum Value</strong></span></td>
                                    <td><code class="literal">0</code></td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Maximum Value</strong></span> (64-bit platforms)</td>
                                    <td><code class="literal">18446744073709551615</code></td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Maximum Value</strong></span> (32-bit platforms)</td>
                                    <td><code class="literal">4294967295</code></td>
                                </tr></tbody></table>
                            </div>
                            <p>
                                The maximum amount of space to use for all relay logs.
                            </p><p style="color:blue;">用于所有中继日志的最大空间量。</p></li><li class="listitem"><p><a name="sysvar_report_host"></a>
                            <a class="indexterm" name="idm140286798024912"></a>

                            <a class="indexterm" name="idm140286798023904"></a>

                            <a class="link" href="replication.html#sysvar_report_host"><code class="literal">report_host</code></a>
                        </p><p style="color:blue;">报告宿主</p>
                            <div class="informaltable">
                                <table frame="box" rules="all" summary="Properties for report_host"><colgroup><col width="30%"><col width="70%"></colgroup><thead><tr><th scope="col">Property</th>
                                    <th scope="col">Value</th>
                                </tr></thead><tbody><tr><td scope="row"><span class="bold"><strong>Command-Line Format</strong></span></td>
                                    <td><code class="literal">--report-host=host_name</code></td>
                                </tr><tr><td scope="row"><span class="bold"><strong>System Variable</strong></span></td>
                                    <td><code class="literal"><a class="link" href="replication.html#sysvar_report_host">report_host</a></code></td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Scope</strong></span></td>
                                    <td>Global</td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Dynamic</strong></span></td>
                                    <td>No</td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Type</strong></span></td>
                                    <td>String</td>
                                </tr></tbody></table>
                            </div>
                            <p>
                                The host name or IP address of the slave to be reported to
                                the master during slave registration. This value appears in
                                the output of <a class="link" href="sql-syntax.html#show-slave-hosts" title="13.7.5.33&nbsp;SHOW SLAVE HOSTS Syntax"><code class="literal">SHOW SLAVE
                                HOSTS</code></a> on the master server. Leave the value unset
                                if you do not want the slave to register itself with the
                                master.
                            </p><p style="color:blue;">要在从机注册期间向主机报告的从机的主机名或IP地址。此值显示在主服务器上的“显示从属主机”的输出中。如果不希望从机向主机注册，请保留未设置的值。</p>
                            <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">

                                <div class="admon-title">
                                    Note
                                </div>
                                <p>
                                    It is not sufficient for the master to simply read the IP
                                    address of the slave from the TCP/IP socket after the
                                    slave connects. Due to NAT and other routing issues, that
                                    IP may not be valid for connecting to the slave from the
                                    master or other hosts.
                                </p><p style="color:blue;">在从机连接之后，主机仅仅从TCP/IP套接字读取从机的IP地址是不够的。由于NAT和其他路由问题，该IP可能无法从主机或其他主机连接到从机。</p>
                            </div>
                        </li><li class="listitem"><p><a name="sysvar_report_password"></a>
                            <a class="indexterm" name="idm140286797996272"></a>

                            <a class="indexterm" name="idm140286797995216"></a>

                            <a class="link" href="replication.html#sysvar_report_password"><code class="literal">report_password</code></a>
                        </p><p style="color:blue;">报告密码</p>
                            <div class="informaltable">
                                <table frame="box" rules="all" summary="Properties for report_password"><colgroup><col width="30%"><col width="70%"></colgroup><thead><tr><th scope="col">Property</th>
                                    <th scope="col">Value</th>
                                </tr></thead><tbody><tr><td scope="row"><span class="bold"><strong>Command-Line Format</strong></span></td>
                                    <td><code class="literal">--report-password=name</code></td>
                                </tr><tr><td scope="row"><span class="bold"><strong>System Variable</strong></span></td>
                                    <td><code class="literal"><a class="link" href="replication.html#sysvar_report_password">report_password</a></code></td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Scope</strong></span></td>
                                    <td>Global</td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Dynamic</strong></span></td>
                                    <td>No</td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Type</strong></span></td>
                                    <td>String</td>
                                </tr></tbody></table>
                            </div>
                            <p>
                                The account password of the slave to be reported to the
                                master during slave registration. This value appears in the
                                output of <a class="link" href="sql-syntax.html#show-slave-hosts" title="13.7.5.33&nbsp;SHOW SLAVE HOSTS Syntax"><code class="literal">SHOW SLAVE HOSTS</code></a> on
                                the master server if the master was started with
                                <a class="link" href="replication.html#option_mysqld_show-slave-auth-info"><code class="option">--show-slave-auth-info</code></a>.
                            </p><p style="color:blue;">在从机注册期间要向主机报告的从机的帐户密码。如果主服务器上的show slave hosts以--show slave auth info启动，则该值将显示在主服务器上的show slave hosts的输出中。</p><p>
                                Although the name of this variable might imply otherwise,
                                <a class="link" href="replication.html#sysvar_report_password"><code class="literal">report_password</code></a> is not
                                connected to the MySQL user privilege system and so is not
                                necessarily (or even likely to be) the same as the password
                                for the MySQL replication user account.
                            </p><p style="color:blue;">尽管此变量的名称可能意味着另一种情况，但是report_password没有连接到mysql用户权限系统，因此不一定（甚至可能）与mysql复制用户帐户的密码相同。</p></li><li class="listitem"><p><a name="sysvar_report_port"></a>
                            <a class="indexterm" name="idm140286797965904"></a>

                            <a class="indexterm" name="idm140286797964848"></a>

                            <a class="link" href="replication.html#sysvar_report_port"><code class="literal">report_port</code></a>
                        </p><p style="color:blue;">报告端口</p>
                            <div class="informaltable">
                                <table frame="box" rules="all" summary="Properties for report_port"><colgroup><col width="30%"><col width="70%"></colgroup><thead><tr><th scope="col">Property</th>
                                    <th scope="col">Value</th>
                                </tr></thead><tbody><tr><td scope="row"><span class="bold"><strong>Command-Line Format</strong></span></td>
                                    <td><code class="literal">--report-port=port_num</code></td>
                                </tr><tr><td scope="row"><span class="bold"><strong>System Variable</strong></span></td>
                                    <td><code class="literal"><a class="link" href="replication.html#sysvar_report_port">report_port</a></code></td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Scope</strong></span></td>
                                    <td>Global</td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Dynamic</strong></span></td>
                                    <td>No</td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Type</strong></span></td>
                                    <td>Integer</td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Default Value</strong></span></td>
                                    <td><code class="literal">[slave_port]</code></td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Minimum Value</strong></span></td>
                                    <td><code class="literal">0</code></td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Maximum Value</strong></span></td>
                                    <td><code class="literal">65535</code></td>
                                </tr></tbody></table>
                            </div>
                            <p>
                                The TCP/IP port number for connecting to the slave, to be
                                reported to the master during slave registration. Set this
                                only if the slave is listening on a nondefault port or if
                                you have a special tunnel from the master or other clients
                                to the slave. If you are not sure, do not use this option.
                            </p><p style="color:blue;">连接到从机的TCP/IP端口号，在从机注册期间报告给主机。仅当从属服务器正在监听非默认端口，或者您有从主服务器或其他客户端到从属服务器的特殊通道时，才设置此选项。如果不确定，请不要使用此选项。</p><p>
                                The default value for this option is the port number
                                actually used by the slave. This is also the default value
                                displayed by <a class="link" href="sql-syntax.html#show-slave-hosts" title="13.7.5.33&nbsp;SHOW SLAVE HOSTS Syntax"><code class="literal">SHOW SLAVE
                                HOSTS</code></a>.
                            </p><p style="color:blue;">此选项的默认值是从机实际使用的端口号。这也是show slave hosts显示的默认值。</p></li><li class="listitem"><p><a name="sysvar_report_user"></a>
                            <a class="indexterm" name="idm140286797928480"></a>

                            <a class="indexterm" name="idm140286797927424"></a>

                            <a class="link" href="replication.html#sysvar_report_user"><code class="literal">report_user</code></a>
                        </p><p style="color:blue;">报告用户</p>
                            <div class="informaltable">
                                <table frame="box" rules="all" summary="Properties for report_user"><colgroup><col width="30%"><col width="70%"></colgroup><thead><tr><th scope="col">Property</th>
                                    <th scope="col">Value</th>
                                </tr></thead><tbody><tr><td scope="row"><span class="bold"><strong>Command-Line Format</strong></span></td>
                                    <td><code class="literal">--report-user=name</code></td>
                                </tr><tr><td scope="row"><span class="bold"><strong>System Variable</strong></span></td>
                                    <td><code class="literal"><a class="link" href="replication.html#sysvar_report_user">report_user</a></code></td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Scope</strong></span></td>
                                    <td>Global</td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Dynamic</strong></span></td>
                                    <td>No</td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Type</strong></span></td>
                                    <td>String</td>
                                </tr></tbody></table>
                            </div>
                            <p>
                                The account user name of the slave to be reported to the
                                master during slave registration. This value appears in the
                                output of <a class="link" href="sql-syntax.html#show-slave-hosts" title="13.7.5.33&nbsp;SHOW SLAVE HOSTS Syntax"><code class="literal">SHOW SLAVE HOSTS</code></a> on
                                the master server if the master was started with
                                <a class="link" href="replication.html#option_mysqld_show-slave-auth-info"><code class="option">--show-slave-auth-info</code></a>.
                            </p><p style="color:blue;">在从机注册期间要向主机报告的从机的帐户用户名。如果主服务器上的show slave hosts以--show slave auth info启动，则该值将显示在主服务器上的show slave hosts的输出中。</p><p>
                                Although the name of this variable might imply otherwise,
                                <a class="link" href="replication.html#sysvar_report_user"><code class="literal">report_user</code></a> is not
                                connected to the MySQL user privilege system and so is not
                                necessarily (or even likely to be) the same as the name of
                                the MySQL replication user account.
                            </p><p style="color:blue;">尽管此变量的名称可能意味着另一种情况，但是report_user没有连接到mysql用户权限系统，因此不一定（甚至可能）与mysql复制用户帐户的名称相同。</p></li><li class="listitem"><p><a name="sysvar_rpl_semi_sync_slave_enabled"></a>
                            <a class="indexterm" name="idm140286797898128"></a>

                            <a class="indexterm" name="idm140286797897024"></a>

                            <a class="link" href="replication.html#sysvar_rpl_semi_sync_slave_enabled"><code class="literal">rpl_semi_sync_slave_enabled</code></a>
                        </p><p style="color:blue;">已启用RPL_Semi_Sync_Slave_</p>
                            <div class="informaltable">
                                <table frame="box" rules="all" summary="Properties for rpl_semi_sync_slave_enabled"><colgroup><col width="30%"><col width="70%"></colgroup><thead><tr><th scope="col">Property</th>
                                    <th scope="col">Value</th>
                                </tr></thead><tbody><tr><td scope="row"><span class="bold"><strong>Command-Line Format</strong></span></td>
                                    <td><code class="literal">--rpl-semi-sync-slave-enabled[={OFF|ON}]</code></td>
                                </tr><tr><td scope="row"><span class="bold"><strong>System Variable</strong></span></td>
                                    <td><code class="literal"><a class="link" href="replication.html#sysvar_rpl_semi_sync_slave_enabled">rpl_semi_sync_slave_enabled</a></code></td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Scope</strong></span></td>
                                    <td>Global</td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Dynamic</strong></span></td>
                                    <td>Yes</td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Type</strong></span></td>
                                    <td>Boolean</td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Default Value</strong></span></td>
                                    <td><code class="literal">OFF</code></td>
                                </tr></tbody></table>
                            </div>
                            <p>
                                Controls whether semisynchronous replication is enabled on
                                the slave. To enable or disable the plugin, set this
                                variable to <code class="literal">ON</code> or <code class="literal">OFF</code>
                                (or 1 or 0), respectively. The default is
                                <code class="literal">OFF</code>.
                            </p><p style="color:blue;">控制是否在从机上启用半同步复制。要启用或禁用插件，请分别将此变量设置为on或off（或1或0）。默认设置为“关闭”。</p><p>
                                This variable is available only if the slave-side
                                semisynchronous replication plugin is installed.
                            </p><p style="color:blue;">只有在安装了从端半同步复制插件时，此变量才可用。</p></li><li class="listitem"><p><a name="sysvar_rpl_semi_sync_slave_trace_level"></a>
                            <a class="indexterm" name="idm140286797866048"></a>

                            <a class="indexterm" name="idm140286797864944"></a>

                            <a class="link" href="replication.html#sysvar_rpl_semi_sync_slave_trace_level"><code class="literal">rpl_semi_sync_slave_trace_level</code></a>
                        </p><p style="color:blue;">半同步从跟踪级别</p>
                            <div class="informaltable">
                                <table frame="box" rules="all" summary="Properties for rpl_semi_sync_slave_trace_level"><colgroup><col width="30%"><col width="70%"></colgroup><thead><tr><th scope="col">Property</th>
                                    <th scope="col">Value</th>
                                </tr></thead><tbody><tr><td scope="row"><span class="bold"><strong>Command-Line Format</strong></span></td>
                                    <td><code class="literal">--rpl-semi-sync-slave-trace-level=#</code></td>
                                </tr><tr><td scope="row"><span class="bold"><strong>System Variable</strong></span></td>
                                    <td><code class="literal"><a class="link" href="replication.html#sysvar_rpl_semi_sync_slave_trace_level">rpl_semi_sync_slave_trace_level</a></code></td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Scope</strong></span></td>
                                    <td>Global</td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Dynamic</strong></span></td>
                                    <td>Yes</td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Type</strong></span></td>
                                    <td>Integer</td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Default Value</strong></span></td>
                                    <td><code class="literal">32</code></td>
                                </tr></tbody></table>
                            </div>
                            <p>
                                The semisynchronous replication debug trace level on the
                                slave. See
                                <a class="link" href="replication.html#sysvar_rpl_semi_sync_master_trace_level"><code class="literal">rpl_semi_sync_master_trace_level</code></a>
                                for the permissible values.
                            </p><p style="color:blue;">从机上的半同步复制调试跟踪级别。有关允许的值，请参见RPL_Semi_Sync_Master_Trace_Level。</p><p>
                                This variable is available only if the slave-side
                                semisynchronous replication plugin is installed.
                            </p><p style="color:blue;">只有在安装了从端半同步复制插件时，此变量才可用。</p></li><li class="listitem"><p><a name="sysvar_rpl_stop_slave_timeout"></a>
                            <a class="indexterm" name="idm140286797834896"></a>

                            <a class="indexterm" name="idm140286797833408"></a>

                            <a class="link" href="replication.html#sysvar_rpl_stop_slave_timeout"><code class="literal">rpl_stop_slave_timeout</code></a>
                        </p><p style="color:blue;">rpl_stop_slave_超时</p>
                            <div class="informaltable">
                                <table frame="box" rules="all" summary="Properties for rpl_stop_slave_timeout"><colgroup><col width="30%"><col width="70%"></colgroup><thead><tr><th scope="col">Property</th>
                                    <th scope="col">Value</th>
                                </tr></thead><tbody><tr><td scope="row"><span class="bold"><strong>Command-Line Format</strong></span></td>
                                    <td><code class="literal">--rpl-stop-slave-timeout=seconds</code></td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Introduced</strong></span></td>
                                    <td>5.7.2</td>
                                </tr><tr><td scope="row"><span class="bold"><strong>System Variable</strong></span></td>
                                    <td><code class="literal"><a class="link" href="replication.html#sysvar_rpl_stop_slave_timeout">rpl_stop_slave_timeout</a></code></td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Scope</strong></span></td>
                                    <td>Global</td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Dynamic</strong></span></td>
                                    <td>Yes</td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Type</strong></span></td>
                                    <td>Integer</td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Default Value</strong></span></td>
                                    <td><code class="literal">31536000</code></td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Minimum Value</strong></span></td>
                                    <td><code class="literal">2</code></td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Maximum Value</strong></span></td>
                                    <td><code class="literal">31536000</code></td>
                                </tr></tbody></table>
                            </div>
                            <p>
                                You can control the length of time (in seconds) that
                                <a class="link" href="sql-syntax.html#stop-slave" title="13.4.2.7&nbsp;STOP SLAVE Syntax"><code class="literal">STOP SLAVE</code></a> waits before
                                timing out by setting this variable. This can be used to
                                avoid deadlocks between <code class="literal">STOP SLAVE</code> and
                                other slave SQL statements using different client
                                connections to the slave.
                            </p><p style="color:blue;">通过设置此变量，可以控制在超时之前停止从机等待的时间长度（以秒为单位）。这可以用来避免stop slave和其他slave sql语句之间的死锁，这些语句使用到slave的不同客户端连接。</p><p>
                                The maximum and default value of
                                <code class="literal">rpl_stop_slave_timeout</code> is 31536000
                                seconds (1 year). The minimum is 2 seconds. Changes to this
                                variable take effect for subsequent
                                <a class="link" href="sql-syntax.html#stop-slave" title="13.4.2.7&nbsp;STOP SLAVE Syntax"><code class="literal">STOP SLAVE</code></a> statements.
                            </p><p style="color:blue;">RPLSL StestaveExtIOUT的最大值和默认值为31536000秒（1年）。最少2秒。对该变量的更改将对后续的stop slave语句生效。</p><p>
                                This variable affects only the client that issues a
                                <code class="literal">STOP SLAVE</code> statement. When the timeout is
                                reached, the issuing client returns an error message stating
                                that the command execution is incomplete. The client then
                                stops waiting for the slave threads to stop, but the slave
                                threads continue to try to stop, and the <code class="literal">STOP
                                SLAVE</code> instruction remains in effect. Once the
                                slave threads are no longer busy, the <code class="literal">STOP
                                SLAVE</code> statement is executed and the slave stops.
                            </p><p style="color:blue;">此变量仅影响发出stop slave语句的客户端。当达到超时时，发出命令的客户端返回一条错误消息，指出命令执行不完整。然后，客户机停止等待从线程停止，但从线程继续尝试停止，停止从指令保持有效。一旦从线程不再繁忙，就执行stop slave语句并停止从线程。</p></li><li class="listitem"><p><a name="sysvar_slave_checkpoint_group"></a>
                            <a class="indexterm" name="idm140286797789024"></a>

                            <a class="indexterm" name="idm140286797787536"></a>

                            <a class="link" href="replication.html#sysvar_slave_checkpoint_group"><code class="literal">slave_checkpoint_group</code></a>
                        </p><p style="color:blue;">从属检查点组</p>
                            <div class="informaltable">
                                <table frame="box" rules="all" summary="Properties for slave_checkpoint_group"><colgroup><col width="30%"><col width="70%"></colgroup><thead><tr><th scope="col">Property</th>
                                    <th scope="col">Value</th>
                                </tr></thead><tbody><tr><td scope="row"><span class="bold"><strong>Command-Line Format</strong></span></td>
                                    <td><code class="literal">--slave-checkpoint-group=#</code></td>
                                </tr><tr><td scope="row"><span class="bold"><strong>System Variable</strong></span></td>
                                    <td><code class="literal"><a class="link" href="replication.html#sysvar_slave_checkpoint_group">slave_checkpoint_group</a></code></td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Scope</strong></span></td>
                                    <td>Global</td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Dynamic</strong></span></td>
                                    <td>Yes</td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Type</strong></span></td>
                                    <td>Integer</td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Default Value</strong></span></td>
                                    <td><code class="literal">512</code></td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Minimum Value</strong></span></td>
                                    <td><code class="literal">32</code></td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Maximum Value</strong></span></td>
                                    <td><code class="literal">524280</code></td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Block Size</strong></span></td>
                                    <td><code class="literal">8</code></td>
                                </tr></tbody></table>
                            </div>
                            <p>
                                Sets the maximum number of transactions that can be
                                processed by a multithreaded slave before a checkpoint
                                operation is called to update its status as shown by
                                <a class="link" href="sql-syntax.html#show-slave-status" title="13.7.5.34&nbsp;SHOW SLAVE STATUS Syntax"><code class="literal">SHOW SLAVE STATUS</code></a>. Setting
                                this variable has no effect on slaves for which
                                multithreading is not enabled. Setting this variable has no
                                immediate effect. The state of the variable applies on all
                                subsequent <a class="link" href="sql-syntax.html#start-slave" title="13.4.2.6&nbsp;START SLAVE Syntax"><code class="literal">START SLAVE</code></a>
                                commands.
                            </p><p style="color:blue;">设置多线程从属设备处理的事务的最大数量，在调用检查点操作之前更新其状态，如显示从属状态所示。设置此变量对未启用多线程的从机没有影响。设置此变量不会立即生效。变量的状态应用于所有后续的从机启动命令。</p>
                            <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">

                                <div class="admon-title">
                                    Note
                                </div>
                                <p>
                                    Multithreaded slaves are not currently supported by NDB
                                    Cluster, which silently ignores the setting for this
                                    variable. See
                                    <a class="xref" href="mysql-cluster.html#mysql-cluster-replication-issues" title="21.6.3&nbsp;Known Issues in NDB Cluster Replication">Section&nbsp;21.6.3, “Known Issues in NDB Cluster Replication”</a>, for
                                    more information.
                                </p><p style="color:blue;">ndb集群当前不支持多线程从机，它会自动忽略此变量的设置。有关详细信息，请参阅21.6.3节，“ndb群集复制中的已知问题”。</p>
                            </div>
                            <p>
                                This variable works in combination with the
                                <a class="link" href="replication.html#sysvar_slave_checkpoint_period"><code class="literal">slave_checkpoint_period</code></a>
                                system variable in such a way that, when either limit is
                                exceeded, the checkpoint is executed and the counters
                                tracking both the number of transactions and the time
                                elapsed since the last checkpoint are reset.
                            </p><p style="color:blue;">此变量与slave_checkpoint_period系统变量结合使用，当超过任一限制时，将执行检查点，并跟踪事务数和自上次检查点重置以来经过的时间的计数器。</p><p>
                                The minimum allowed value for this variable is 32, unless
                                the server was built using
                                <a class="link" href="installing.html#option_cmake_with_debug"><code class="option">-DWITH_DEBUG</code></a>, in which case
                                the minimum value is 1. The effective value is always a
                                multiple of 8; you can set it to a value that is not such a
                                multiple, but the server rounds it down to the next lower
                                multiple of 8 before storing the value.
                                (<span class="emphasis"><em>Exception</em></span>: No such rounding is
                                performed by the debug server.) Regardless of how the server
                                was built, the default value is 512, and the maximum allowed
                                value is 524280.
                            </p><p style="color:blue;">此变量允许的最小值为32，除非服务器是使用-dwith_debug构建的，在这种情况下，最小值为1。有效值始终是8的倍数；您可以将其设置为不是8的倍数，但服务器会在存储该值之前将其舍入到8的下一个较低倍数。（异常：调试服务器不执行这样的舍入）。不管服务器是如何构建的，默认值是512，最大允许值是524280。</p></li><li class="listitem"><p><a name="sysvar_slave_checkpoint_period"></a>
                            <a class="indexterm" name="idm140286797741648"></a>

                            <a class="indexterm" name="idm140286797740160"></a>

                            <a class="link" href="replication.html#sysvar_slave_checkpoint_period"><code class="literal">slave_checkpoint_period</code></a>
                        </p><p style="color:blue;">从检查点期间</p>
                            <div class="informaltable">
                                <table frame="box" rules="all" summary="Properties for slave_checkpoint_period"><colgroup><col width="30%"><col width="70%"></colgroup><thead><tr><th scope="col">Property</th>
                                    <th scope="col">Value</th>
                                </tr></thead><tbody><tr><td scope="row"><span class="bold"><strong>Command-Line Format</strong></span></td>
                                    <td><code class="literal">--slave-checkpoint-period=#</code></td>
                                </tr><tr><td scope="row"><span class="bold"><strong>System Variable</strong></span></td>
                                    <td><code class="literal"><a class="link" href="replication.html#sysvar_slave_checkpoint_period">slave_checkpoint_period</a></code></td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Scope</strong></span></td>
                                    <td>Global</td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Dynamic</strong></span></td>
                                    <td>Yes</td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Type</strong></span></td>
                                    <td>Integer</td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Default Value</strong></span></td>
                                    <td><code class="literal">300</code></td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Minimum Value</strong></span></td>
                                    <td><code class="literal">1</code></td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Maximum Value</strong></span></td>
                                    <td><code class="literal">4G</code></td>
                                </tr></tbody></table>
                            </div>
                            <p>
                                Sets the maximum time (in milliseconds) that is allowed to
                                pass before a checkpoint operation is called to update the
                                status of a multithreaded slave as shown by
                                <a class="link" href="sql-syntax.html#show-slave-status" title="13.7.5.34&nbsp;SHOW SLAVE STATUS Syntax"><code class="literal">SHOW SLAVE STATUS</code></a>. Setting
                                this variable has no effect on slaves for which
                                multithreading is not enabled. Setting this variable takes
                                effect for all replication channels immediately, including
                                running channels.
                            </p><p style="color:blue;">设置在调用检查点操作之前允许的最大时间（毫秒），以更新多线程从属设备的状态，如显示从属状态所示。设置此变量对未启用多线程的从机没有影响。设置此变量将立即对所有复制通道（包括正在运行的通道）生效。</p>
                            <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">

                                <div class="admon-title">
                                    Note
                                </div>
                                <p>
                                    Multithreaded slaves are not currently supported by NDB
                                    Cluster, which silently ignores the setting for this
                                    variable. See
                                    <a class="xref" href="mysql-cluster.html#mysql-cluster-replication-issues" title="21.6.3&nbsp;Known Issues in NDB Cluster Replication">Section&nbsp;21.6.3, “Known Issues in NDB Cluster Replication”</a>, for
                                    more information.
                                </p><p style="color:blue;">ndb集群当前不支持多线程从机，它会自动忽略此变量的设置。有关详细信息，请参阅21.6.3节，“ndb群集复制中的已知问题”。</p>
                            </div>
                            <p>
                                This variable works in combination with the
                                <a class="link" href="replication.html#sysvar_slave_checkpoint_group"><code class="literal">slave_checkpoint_group</code></a>
                                system variable in such a way that, when either limit is
                                exceeded, the checkpoint is executed and the counters
                                tracking both the number of transactions and the time
                                elapsed since the last checkpoint are reset.
                            </p><p style="color:blue;">此变量与slave_checkpoint_group系统变量结合使用，当超过任一限制时，将执行检查点，并跟踪事务数和自上次检查点重置以来经过的时间的计数器。</p><p>
                                The minimum allowed value for this variable is 1, unless the
                                server was built using
                                <a class="link" href="installing.html#option_cmake_with_debug"><code class="option">-DWITH_DEBUG</code></a>, in which case
                                the minimum value is 0. Regardless of how the server was
                                built, the default value is 300, and the maximum possible
                                value is 4294967296 (4GB).
                            </p><p style="color:blue;">此变量允许的最小值为1，除非服务器是使用-dwith_debug构建的，在这种情况下，最小值为0。不管服务器是如何构建的，默认值是300，最大可能值是4294967296（4GB）。</p></li><li class="listitem"><p><a name="sysvar_slave_compressed_protocol"></a>
                            <a class="indexterm" name="idm140286797699312"></a>

                            <a class="indexterm" name="idm140286797698208"></a>

                            <a class="link" href="replication.html#sysvar_slave_compressed_protocol"><code class="literal">slave_compressed_protocol</code></a>
                        </p><p style="color:blue;">从压缩协议</p>
                            <div class="informaltable">
                                <table frame="box" rules="all" summary="Properties for slave_compressed_protocol"><colgroup><col width="30%"><col width="70%"></colgroup><thead><tr><th scope="col">Property</th>
                                    <th scope="col">Value</th>
                                </tr></thead><tbody><tr><td scope="row"><span class="bold"><strong>Command-Line Format</strong></span></td>
                                    <td><code class="literal">--slave-compressed-protocol[={OFF|ON}]</code></td>
                                </tr><tr><td scope="row"><span class="bold"><strong>System Variable</strong></span></td>
                                    <td><code class="literal"><a class="link" href="replication.html#sysvar_slave_compressed_protocol">slave_compressed_protocol</a></code></td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Scope</strong></span></td>
                                    <td>Global</td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Dynamic</strong></span></td>
                                    <td>Yes</td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Type</strong></span></td>
                                    <td>Boolean</td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Default Value</strong></span></td>
                                    <td><code class="literal">OFF</code></td>
                                </tr></tbody></table>
                            </div>
                            <p>
                                Whether to use compression of the master/slave protocol if
                                both master and slave support it. If this variable is
                                disabled (the default), connections are uncompressed.
                                Changes to this variable take effect on subsequent
                                connection attempts; this includes after issuing a
                                <a class="link" href="sql-syntax.html#start-slave" title="13.4.2.6&nbsp;START SLAVE Syntax"><code class="literal">START SLAVE</code></a> statement, as
                                well as reconnections made by a running I/O thread (for
                                example, after setting the
                                <code class="literal">MASTER_RETRY_COUNT</code> option for the
                                <a class="link" href="sql-syntax.html#change-master-to" title="13.4.2.1&nbsp;CHANGE MASTER TO Syntax"><code class="literal">CHANGE MASTER TO</code></a> statement).
                                See also <a class="xref" href="programs.html#connection-compression-control" title="4.2.5&nbsp;Connection Compression Control">Section&nbsp;4.2.5, “Connection Compression Control”</a>.
                            </p><p style="color:blue;">如果主/从协议都支持，是否使用主/从协议的压缩。如果禁用此变量（默认设置），则连接未压缩。对该变量的更改将影响后续的连接尝试；这包括在发出start slave语句之后，以及由正在运行的I/O线程进行的重新连接（例如，在为change master to语句设置master_retry_count选项之后）。另见第4.2.5节“连接压缩控制”。</p></li><li class="listitem"><p><a name="sysvar_slave_exec_mode"></a>
                            <a class="indexterm" name="idm140286797665680"></a>

                            <a class="indexterm" name="idm140286797664672"></a>

                            <a class="link" href="replication.html#sysvar_slave_exec_mode"><code class="literal">slave_exec_mode</code></a>
                        </p><p style="color:blue;">从执行模式</p>
                            <div class="informaltable">
                                <table frame="box" rules="all" summary="Properties for slave_exec_mode"><colgroup><col width="30%"><col width="70%"></colgroup><thead><tr><th scope="col">Property</th>
                                    <th scope="col">Value</th>
                                </tr></thead><tbody><tr><td scope="row"><span class="bold"><strong>Command-Line Format</strong></span></td>
                                    <td><code class="literal">--slave-exec-mode=mode</code></td>
                                </tr><tr><td scope="row"><span class="bold"><strong>System Variable</strong></span></td>
                                    <td><code class="literal"><a class="link" href="replication.html#sysvar_slave_exec_mode">slave_exec_mode</a></code></td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Scope</strong></span></td>
                                    <td>Global</td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Dynamic</strong></span></td>
                                    <td>Yes</td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Type</strong></span></td>
                                    <td>Enumeration</td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Default Value</strong></span></td>
                                    <td><p class="valid-value"><code class="literal">IDEMPOTENT</code> (NDB)</p><p style="color:blue;">等幂（ndb）</p><p class="valid-value"><code class="literal">STRICT</code> (Other)</p><p style="color:blue;">严格（其他）</p></td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Valid Values</strong></span></td>
                                    <td><p class="valid-value"><code class="literal">IDEMPOTENT</code></p><p style="color:blue;">等幂的</p><p class="valid-value"><code class="literal">STRICT</code></p><p style="color:blue;">严格的</p></td>
                                </tr></tbody></table>
                            </div>
                            <p>
                                Controls how a slave thread resolves conflicts and errors
                                during replication. <code class="literal">IDEMPOTENT</code> mode
                                causes suppression of duplicate-key and no-key-found errors;
                                <code class="literal">STRICT</code> means no such suppression takes
                                place.
                            </p><p style="color:blue;">控制从线程在复制期间如何解决冲突和错误。等幂模式导致重复密钥被抑制，并且没有发现密钥错误；strict表示没有发生这种抑制。</p><p>
                                <code class="literal">IDEMPOTENT</code> mode is intended for use in
                                multi-master replication, circular replication, and some
                                other special replication scenarios for NDB Cluster
                                Replication. (See
                                <a class="xref" href="mysql-cluster.html#mysql-cluster-replication-multi-master" title="21.6.10&nbsp;NDB Cluster Replication: Multi-Master and Circular Replication">Section&nbsp;21.6.10, “NDB Cluster Replication: Multi-Master and Circular Replication”</a>,
                                and
                                <a class="xref" href="mysql-cluster.html#mysql-cluster-replication-conflict-resolution" title="21.6.11&nbsp;NDB Cluster Replication Conflict Resolution">Section&nbsp;21.6.11, “NDB Cluster Replication Conflict Resolution”</a>,
                                for more information.) NDB Cluster ignores any value
                                explicitly set for
                                <a class="link" href="replication.html#sysvar_slave_exec_mode"><code class="literal">slave_exec_mode</code></a>, and always
                                treats it as <code class="literal">IDEMPOTENT</code>.
                            </p><p style="color:blue;">等幂模式适用于多主复制、循环复制和其他一些用于ndb群集复制的特殊复制方案。（有关详细信息，请参阅第21.6.10节“NDB群集复制：多主复制和循环复制”和第21.6.11节“NDB群集复制冲突解决”）NDB群集忽略为从属执行模式显式设置的任何值，并始终将其视为等幂。</p><p>
                                In MySQL Server 5.7, <code class="literal">STRICT</code>
                                mode is the default value.
                            </p><p style="color:blue;">在MySQLServer5.7中，strict mode是默认值。</p><p>
                                For storage engines other than
                                <a class="link" href="mysql-cluster.html" title="Chapter&nbsp;21&nbsp;MySQL NDB Cluster 7.5 and NDB Cluster 7.6"><code class="literal">NDB</code></a>,
                                <span class="emphasis"><em><code class="literal">IDEMPOTENT</code> mode should be used
            only when you are absolutely sure that duplicate-key errors
            and key-not-found errors can safely be ignored</em></span>.
                                It is meant to be used in fail-over scenarios for NDB
                                Cluster where multi-master replication or circular
                                replication is employed, and is not recommended for use in
                                other cases.
                            </p><p style="color:blue;">对于ndb以外的存储引擎，只有在绝对确定可以安全地忽略重复密钥错误和未找到密钥错误时，才应使用等幂模式。它用于使用多主复制或循环复制的ndb集群的故障转移场景，不建议在其他情况下使用。</p></li><li class="listitem"><p><a name="sysvar_slave_load_tmpdir"></a>
                            <a class="indexterm" name="idm140286797619408"></a>

                            <a class="indexterm" name="idm140286797618368"></a>

                            <a class="link" href="replication.html#sysvar_slave_load_tmpdir"><code class="literal">slave_load_tmpdir</code></a>
                        </p><p style="color:blue;">从加载</p>
                            <div class="informaltable">
                                <table frame="box" rules="all" summary="Properties for slave-load-tmpdir"><colgroup><col width="30%"><col width="70%"></colgroup><thead><tr><th scope="col">Property</th>
                                    <th scope="col">Value</th>
                                </tr></thead><tbody><tr><td scope="row"><span class="bold"><strong>Command-Line Format</strong></span></td>
                                    <td><code class="literal">--slave-load-tmpdir=dir_name</code></td>
                                </tr><tr><td scope="row"><span class="bold"><strong>System Variable</strong></span></td>
                                    <td><code class="literal"><a class="link" href="replication.html#sysvar_slave_load_tmpdir">slave_load_tmpdir</a></code></td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Scope</strong></span></td>
                                    <td>Global</td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Dynamic</strong></span></td>
                                    <td>No</td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Type</strong></span></td>
                                    <td>Directory name</td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Default Value</strong></span></td>
                                    <td><code class="literal">Value of --tmpdir</code></td>
                                </tr></tbody></table>
                            </div>
                            <p>
                                The name of the directory where the slave creates temporary
                                files. Setting this variable takes effect for all
                                replication channels immediately, including running
                                channels. This system variable is by default equal to the
                                value of the <a class="link" href="server-administration.html#sysvar_tmpdir"><code class="literal">tmpdir</code></a> system
                                variable, or the default that applies when that system
                                variable is not specified.
                            </p><p style="color:blue;">从机创建临时文件的目录的名称。设置此变量将立即对所有复制通道（包括正在运行的通道）生效。默认情况下，此系统变量等于tmpdir系统变量的值，或者当未指定该系统变量时应用的默认值。</p><p>
                                When the slave SQL thread replicates a
                                <a class="link" href="sql-syntax.html#load-data" title="13.2.6&nbsp;LOAD DATA Syntax"><code class="literal">LOAD
                                    DATA</code></a> statement, it extracts the file to be loaded
                                from the relay log into temporary files, and then loads
                                these into the table. If the file loaded on the master is
                                huge, the temporary files on the slave are huge, too.
                                Therefore, it might be advisable to use this option to tell
                                the slave to put temporary files in a directory located in
                                some file system that has a lot of available space. In that
                                case, the relay logs are huge as well, so you might also
                                want to use the <a class="link" href="replication.html#sysvar_relay_log"><code class="literal">relay_log</code></a>
                                system variable to place the relay logs in that file system.
                            </p><p style="color:blue;">当从sql线程复制load data语句时，它将要从中继日志中加载的文件提取到临时文件中，然后将这些文件加载到表中。如果主服务器上加载的文件很大，那么从服务器上的临时文件也很大。因此，建议使用此选项告诉从属服务器将临时文件放在某个文件系统中的目录中，该目录具有大量可用空间。在这种情况下，中继日志也很大，因此您可能还希望使用relay_log系统变量将中继日志放在该文件系统中。</p><p>
                                The directory specified by this option should be located in
                                a disk-based file system (not a memory-based file system) so
                                that the temporary files used to replicate
                                <a class="link" href="sql-syntax.html#load-data" title="13.2.6&nbsp;LOAD DATA Syntax"><code class="literal">LOAD DATA</code></a> can survive machine
                                restarts. The directory also should not be one that is
                                cleared by the operating system during the system startup
                                process. However, replication can now continue after a
                                restart if the temporary files have been removed.
                            </p><p style="color:blue;">此选项指定的目录应位于基于磁盘的文件系统（而不是基于内存的文件系统）中，以便用于复制加载数据的临时文件可以在计算机重新启动后继续存在。目录也不应该是操作系统在系统启动过程中清除的目录。但是，如果临时文件已被删除，则可以在重新启动后继续复制。</p></li><li class="listitem"><p><a name="sysvar_slave_max_allowed_packet"></a>
                            <a class="indexterm" name="idm140286797582960"></a>

                            <a class="indexterm" name="idm140286797581856"></a>

                            <a class="link" href="replication.html#sysvar_slave_max_allowed_packet"><code class="literal">slave_max_allowed_packet</code></a>
                        </p><p style="color:blue;">允许的从数据包</p>
                            <div class="informaltable">
                                <table frame="box" rules="all" summary="Properties for slave_max_allowed_packet"><colgroup><col width="30%"><col width="70%"></colgroup><thead><tr><th scope="col">Property</th>
                                    <th scope="col">Value</th>
                                </tr></thead><tbody><tr><td scope="row"><span class="bold"><strong>Command-Line Format</strong></span></td>
                                    <td><code class="literal">--slave-max-allowed-packet=#</code></td>
                                </tr><tr><td scope="row"><span class="bold"><strong>System Variable</strong></span></td>
                                    <td><code class="literal"><a class="link" href="replication.html#sysvar_slave_max_allowed_packet">slave_max_allowed_packet</a></code></td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Scope</strong></span></td>
                                    <td>Global</td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Dynamic</strong></span></td>
                                    <td>Yes</td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Type</strong></span></td>
                                    <td>Integer</td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Default Value</strong></span></td>
                                    <td><code class="literal">1073741824</code></td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Minimum Value</strong></span></td>
                                    <td><code class="literal">1024</code></td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Maximum Value</strong></span></td>
                                    <td><code class="literal">1073741824</code></td>
                                </tr></tbody></table>
                            </div>
                            <p>
                                This variable sets the maximum packet size for the slave SQL
                                and I/O threads, so that large updates using row-based
                                replication do not cause replication to fail because an
                                update exceeded
                                <a class="link" href="server-administration.html#sysvar_max_allowed_packet"><code class="literal">max_allowed_packet</code></a>. Setting
                                this variable takes effect for all replication channels
                                immediately, including running channels.
                            </p><p style="color:blue;">此变量设置从属SQL和I/O线程的最大包大小，因此使用基于行的复制的大型更新不会导致复制失败，因为更新超过了Max允许的数据包。设置此变量将立即对所有复制通道（包括正在运行的通道）生效。</p><p>
                                This global variable always has a value that is a positive
                                integer multiple of 1024; if you set it to some value that
                                is not, the value is rounded down to the next highest
                                multiple of 1024 for it is stored or used; setting
                                <code class="literal">slave_max_allowed_packet</code> to 0 causes 1024
                                to be used. (A truncation warning is issued in all such
                                cases.) The default and maximum value is 1073741824 (1 GB);
                                the minimum is 1024.
                            </p><p style="color:blue;">此全局变量的值始终是1024的正整数倍；如果将其设置为非正整数倍，则该值将向下舍入到1024的下一个最大倍数，以便存储或使用；将slave_max_allowed_packet设置为0将使用1024。（在所有这些情况下都发出截断警告）默认值和最大值是1073741824（1 GB），最小值是1024。</p><p>
                                <code class="literal">slave_max_allowed_packet</code> can also be set
                                at startup, using the
                                <a class="link" href="replication.html#option_mysqld_slave-max-allowed-packet"><code class="option">--slave-max-allowed-packet</code></a>
                                option.
                            </p><p style="color:blue;">也可以在启动时使用--slave max allowed packet选项设置slave_max_allowed_packet。</p></li><li class="listitem"><p><a name="sysvar_slave_net_timeout"></a>
                            <a class="indexterm" name="idm140286797542048"></a>

                            <a class="indexterm" name="idm140286797541008"></a>

                            <a class="link" href="replication.html#sysvar_slave_net_timeout"><code class="literal">slave_net_timeout</code></a>
                        </p><p style="color:blue;">从网络超时</p>
                            <div class="informaltable">
                                <table frame="box" rules="all" summary="Properties for slave-net-timeout"><colgroup><col width="30%"><col width="70%"></colgroup><thead><tr><th scope="col">Property</th>
                                    <th scope="col">Value</th>
                                </tr></thead><tbody><tr><td scope="row"><span class="bold"><strong>Command-Line Format</strong></span></td>
                                    <td><code class="literal">--slave-net-timeout=#</code></td>
                                </tr><tr><td scope="row"><span class="bold"><strong>System Variable</strong></span></td>
                                    <td><code class="literal"><a class="link" href="replication.html#sysvar_slave_net_timeout">slave_net_timeout</a></code></td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Scope</strong></span></td>
                                    <td>Global</td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Dynamic</strong></span></td>
                                    <td>Yes</td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Type</strong></span></td>
                                    <td>Integer</td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Default Value</strong></span> (&gt;= 5.7.7)</td>
                                    <td><code class="literal">60</code></td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Default Value</strong></span> (&lt;= 5.7.6)</td>
                                    <td><code class="literal">3600</code></td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Minimum Value</strong></span></td>
                                    <td><code class="literal">1</code></td>
                                </tr></tbody></table>
                            </div>
                            <p>
                                The number of seconds to wait for more data or a heartbeat
                                signal from the master before the slave considers the
                                connection broken, aborts the read, and tries to reconnect.
                                Setting this variable has no immediate effect. The state of
                                the variable applies on all subsequent
                                <a class="link" href="sql-syntax.html#start-slave" title="13.4.2.6&nbsp;START SLAVE Syntax"><code class="literal">START SLAVE</code></a> commands.
                            </p><p style="color:blue;">在从机认为连接已断开、中止读取并尝试重新连接之前，等待来自主机的更多数据或心跳信号的秒数。设置此变量不会立即生效。变量的状态应用于所有后续的从机启动命令。</p><p>
                                The default value is 60 seconds (one minute). Prior to MySQL
                                5.7.7, the default was 3600 seconds (one hour). The first
                                retry occurs immediately after the timeout. The interval
                                between retries is controlled by the
                                <code class="literal">MASTER_CONNECT_RETRY</code> option for the
                                <a class="link" href="sql-syntax.html#change-master-to" title="13.4.2.1&nbsp;CHANGE MASTER TO Syntax"><code class="literal">CHANGE MASTER TO</code></a> statement,
                                and the number of reconnection attempts is limited by the
                                <code class="literal">MASTER_RETRY_COUNT</code> option for the
                                <a class="link" href="sql-syntax.html#change-master-to" title="13.4.2.1&nbsp;CHANGE MASTER TO Syntax"><code class="literal">CHANGE MASTER TO</code></a> statement.
                            </p><p style="color:blue;">默认值为60秒（1分钟）。在mysql 5.7.7之前，默认值是3600秒（1小时）。第一次重试在超时后立即发生。重试间隔由change master to语句的master_connect_retry选项控制，重新连接尝试的次数由change master to语句的master_retry_count选项限制。</p><p>
                                The heartbeat interval, which stops the connection timeout
                                occurring in the absence of data if the connection is still
                                good, is controlled by the
                                <code class="literal">MASTER_HEARTBEAT_PERIOD</code> option for the
                                <a class="link" href="sql-syntax.html#change-master-to" title="13.4.2.1&nbsp;CHANGE MASTER TO Syntax"><code class="literal">CHANGE MASTER TO</code></a> statement.
                                The heartbeat interval defaults to half the value of
                                <a class="link" href="replication.html#sysvar_slave_net_timeout"><code class="literal">slave_net_timeout</code></a>, and it
                                is recorded in the master info log and shown in the
                                <a class="link" href="performance-schema.html#replication-connection-configuration-table" title="25.12.11.1&nbsp;The replication_connection_configuration Table"><code class="literal">replication_connection_configuration</code></a>
                                Performance Schema table. Note that a change to the value or
                                default setting of
                                <a class="link" href="replication.html#sysvar_slave_net_timeout"><code class="literal">slave_net_timeout</code></a> does not
                                automatically change the heartbeat interval, whether that
                                has been set explicitly or is using a previously calculated
                                default. If the connection timeout is changed, you must also
                                issue <a class="link" href="sql-syntax.html#change-master-to" title="13.4.2.1&nbsp;CHANGE MASTER TO Syntax"><code class="literal">CHANGE MASTER TO</code></a> to
                                adjust the heartbeat interval to an appropriate value so
                                that it occurs before the connection timeout.
                            </p><p style="color:blue;">heartbeat interval是由change master to语句的master_heartbeat_period选项控制的，它在连接仍然良好的情况下停止在没有数据的情况下发生的连接超时。心跳间隔默认为slave_net_timeout值的一半，并记录在master info日志中，并显示在replication_connection_configuration performance schema表中。请注意，对slave_net_timeout的值或默认设置的更改不会自动更改心跳间隔，无论是显式设置还是使用先前计算的默认值。如果连接超时被更改，您还必须发出change master来将心跳间隔调整为适当的值，以便在连接超时之前发生。</p></li><li class="listitem"><p><a name="sysvar_slave_parallel_type"></a>
                            <a class="indexterm" name="idm140286797491888"></a>

                            <a class="indexterm" name="idm140286797490848"></a>

                            <a class="link" href="replication.html#sysvar_slave_parallel_type"><code class="literal">slave_parallel_type=<em class="replaceable"><code>type</code></em></code></a>
                        </p><p style="color:blue;">slave_parallel_type=类型</p>
                            <div class="informaltable">
                                <table frame="box" rules="all" summary="Properties for slave-parallel-type"><colgroup><col width="30%"><col width="70%"></colgroup><thead><tr><th scope="col">Property</th>
                                    <th scope="col">Value</th>
                                </tr></thead><tbody><tr><td scope="row"><span class="bold"><strong>Command-Line Format</strong></span></td>
                                    <td><code class="literal">--slave-parallel-type=type</code></td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Introduced</strong></span></td>
                                    <td>5.7.2</td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Type</strong></span></td>
                                    <td>Enumeration</td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Default Value</strong></span></td>
                                    <td><code class="literal">DATABASE</code></td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Valid Values</strong></span></td>
                                    <td><p class="valid-value"><code class="literal">DATABASE</code></p><p style="color:blue;">数据库</p><p class="valid-value"><code class="literal">LOGICAL_CLOCK</code></p><p style="color:blue;">逻辑时钟</p></td>
                                </tr></tbody></table>
                            </div>
                            <p>
                                When using a multithreaded slave
                                (<a class="link" href="replication.html#sysvar_slave_parallel_workers"><code class="literal">slave_parallel_workers</code></a> is
                                greater than 0), this variable specifies the policy used to
                                decide which transactions are allowed to execute in parallel
                                on the slave. The variable has no effect on slaves for which
                                multithreading is not enabled. The possible values are:
                            </p><p style="color:blue;">当使用多线程从机（slave_parallel_workers大于0）时，此变量指定用于确定允许在从机上并行执行哪些事务的策略。该变量对未启用多线程的从机没有影响。可能的值为：</p>
                            <div class="itemizedlist">
                                <ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
                                    <code class="literal">LOGICAL_CLOCK</code>: Transactions that are
                                    part of the same binary log group commit on a master are
                                    applied in parallel on a slave. The dependencies between
                                    transactions are tracked based on their timestamps to
                                    provide additional parallelization where possible. When
                                    this value is set, the
                                    <a class="link" href="replication.html#sysvar_binlog_transaction_dependency_tracking"><code class="literal">binlog_transaction_dependency_tracking</code></a>
                                    system variable can be used on the master to specify
                                    that write sets are used for parallelization in place of
                                    timestamps, if a write set is available for the
                                    transaction and gives improved results compared to
                                    timestamps.
                                </p><p style="color:blue;">逻辑时钟：作为主服务器上相同二进制日志组提交的一部分的事务在从服务器上并行应用。根据事务的时间戳跟踪事务之间的依赖关系，以便在可能的情况下提供额外的并行化。当设置此值时，如果事务的写集可用，并且与时间戳相比给出了更好的结果，则可以在主控上使用binlog_transaction_dependency_tracking系统变量指定将写集用于并行化而不是时间戳。</p></li><li class="listitem"><p>
                                    <code class="literal">DATABASE</code>: Transactions that update
                                    different databases are applied in parallel. This value
                                    is only appropriate if data is partitioned into multiple
                                    databases which are being updated independently and
                                    concurrently on the master. There must be no
                                    cross-database constraints, as such constraints may be
                                    violated on the slave.
                                </p><p style="color:blue;">数据库：并行应用更新不同数据库的事务。此值仅适用于将数据分区为多个数据库的情况，这些数据库在主数据库上独立且并发地进行更新。不能有跨数据库约束，因为在从机上可能会违反这些约束。</p></li></ul>
                            </div>
                            <p>
                                When
                                <a class="link" href="replication.html#sysvar_slave_preserve_commit_order"><code class="literal">slave_preserve_commit_order=1</code></a>
                                is set, you can only use <code class="literal">LOGICAL_CLOCK</code>.
                            </p><p style="color:blue;">当设置slave_preserve_commit_order=1时，只能使用逻辑时钟。</p><p>
                                If your replication topology uses multiple levels of slaves,
                                <code class="literal">LOGICAL_CLOCK</code> may achieve less
                                parallelization for each level the slave is away from the
                                master. You can reduce this effect by using
                                <a class="link" href="replication.html#sysvar_binlog_transaction_dependency_tracking"><code class="literal">binlog_transaction_dependency_tracking</code></a>
                                on the master to specify that write sets are used instead of
                                timestamps for parallelization where possible.
                            </p><p style="color:blue;">如果复制拓扑使用多个级别的从机，则逻辑时钟可能在从机远离主机的每个级别上实现较少的并行化。您可以通过在主机上使用binlog_transaction_dependency_tracking来减少这种影响，以指定在可能的情况下使用写集而不是时间戳进行并行化。</p></li><li class="listitem"><p><a name="sysvar_slave_parallel_workers"></a>
                            <a class="indexterm" name="idm140286797451632"></a>

                            <a class="indexterm" name="idm140286797450592"></a>

                            <a class="link" href="replication.html#sysvar_slave_parallel_workers"><code class="literal">slave_parallel_workers</code></a>
                        </p><p style="color:blue;">平行工人</p>
                            <div class="informaltable">
                                <table frame="box" rules="all" summary="Properties for slave_parallel_workers"><colgroup><col width="30%"><col width="70%"></colgroup><thead><tr><th scope="col">Property</th>
                                    <th scope="col">Value</th>
                                </tr></thead><tbody><tr><td scope="row"><span class="bold"><strong>Command-Line Format</strong></span></td>
                                    <td><code class="literal">--slave-parallel-workers=#</code></td>
                                </tr><tr><td scope="row"><span class="bold"><strong>System Variable</strong></span></td>
                                    <td><code class="literal"><a class="link" href="replication.html#sysvar_slave_parallel_workers">slave_parallel_workers</a></code></td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Scope</strong></span></td>
                                    <td>Global</td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Dynamic</strong></span></td>
                                    <td>Yes</td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Type</strong></span></td>
                                    <td>Integer</td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Default Value</strong></span></td>
                                    <td><code class="literal">0</code></td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Minimum Value</strong></span></td>
                                    <td><code class="literal">0</code></td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Maximum Value</strong></span></td>
                                    <td><code class="literal">1024</code></td>
                                </tr></tbody></table>
                            </div>
                            <p>
                                Sets the number of slave applier threads for executing
                                replication transactions in parallel. Setting this variable
                                to a number greater than 0 creates a multithreaded slave
                                with this number of applier threads. When set to 0 (the
                                default) parallel execution is disabled and the slave uses a
                                single applier thread. Setting
                                <a class="link" href="replication.html#sysvar_slave_parallel_workers"><code class="literal">slave_parallel_workers</code></a> has
                                no immediate effect. The state of the variable applies on
                                all subsequent <a class="link" href="sql-syntax.html#start-slave" title="13.4.2.6&nbsp;START SLAVE Syntax"><code class="literal">START SLAVE</code></a>
                                statements.
                            </p><p style="color:blue;">设置并行执行复制事务的从属应用程序线程数。将此变量设置为大于0的数字将创建具有此数量applier线程的多线程从机。当设置为0（默认值）时，并行执行被禁用，从线程使用单个applier线程。设置slave_parallel_workers没有立即的效果。变量的状态应用于所有后续的start-slave语句。</p>
                            <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">

                                <div class="admon-title">
                                    Note
                                </div>
                                <p>
                                    Multithreaded slaves are not currently supported by NDB
                                    Cluster, which silently ignores the setting for this
                                    variable. See
                                    <a class="xref" href="mysql-cluster.html#mysql-cluster-replication-issues" title="21.6.3&nbsp;Known Issues in NDB Cluster Replication">Section&nbsp;21.6.3, “Known Issues in NDB Cluster Replication”</a>, for
                                    more information.
                                </p><p style="color:blue;">ndb集群当前不支持多线程从机，它会自动忽略此变量的设置。有关详细信息，请参阅21.6.3节，“ndb群集复制中的已知问题”。</p>
                            </div>
                            <p>
                                A multithreaded slave provides parallel execution by using a
                                coordinator thread and the number of applier threads
                                configured by this variable. The way which transactions are
                                distributed among applier threads is configured by
                                <a class="link" href="replication.html#sysvar_slave_parallel_type"><code class="literal">slave_parallel_type</code></a>. The
                                transactions that the slave applies in parallel may commit
                                out of order, unless
                                <a class="link" href="replication.html#sysvar_slave_preserve_commit_order"><code class="literal">slave_preserve_commit_order=1</code></a>.
                                Therefore, checking for the most recently executed
                                transaction does not guarantee that all previous
                                transactions from the master have been executed on the
                                slave. This has implications for logging and recovery when
                                using a multithreaded slave. For example, on a multithreaded
                                slave the <a class="link" href="sql-syntax.html#start-slave" title="13.4.2.6&nbsp;START SLAVE Syntax"><code class="literal">START
                                SLAVE UNTIL</code></a> statement only supports using
                                <code class="literal">SQL_AFTER_MTS_GAPS</code>.
                            </p><p style="color:blue;">多线程从机通过使用协调线程和此变量配置的applier线程数提供并行执行。事务在applier线程之间的分布方式由slave_parallel_类型配置。从机并行应用的事务可能会无序提交，除非从机保留提交顺序=1。因此，检查最近执行的事务并不能保证来自主服务器的所有以前的事务都在从服务器上执行。这对使用多线程从机时的日志记录和恢复有影响。例如，在多线程从机上，start slave until语句仅支持使用sqlu after_mts_gaps。</p><p>
                                In MySQL 5.7.5 and later, retrying of transactions is
                                supported when multithreading is enabled on a slave. In
                                previous versions,
                                <a class="link" href="replication.html#sysvar_slave_transaction_retries"><code class="literal">slave_transaction_retries</code></a>
                                was treated as equal to 0 when using multithreaded slaves.
                            </p><p style="color:blue;">在mysql 5.7.5及更高版本中，当在从机上启用多线程时，支持事务重试。在以前的版本中，当使用多线程从机时，从机事务重试被视为等于0。</p></li><li class="listitem"><p><a name="sysvar_slave_pending_jobs_size_max"></a>
                            <a class="indexterm" name="idm140286797404016"></a>

                            <a class="indexterm" name="idm140286797402560"></a>

                            <a class="link" href="replication.html#sysvar_slave_pending_jobs_size_max"><code class="literal">slave_pending_jobs_size_max</code></a>
                        </p><p style="color:blue;">从机等待的作业大小最大</p>
                            <div class="informaltable">
                                <table frame="box" rules="all" summary="Properties for slave_pending_jobs_size_max"><colgroup><col width="30%"><col width="70%"></colgroup><thead><tr><th scope="col">Property</th>
                                    <th scope="col">Value</th>
                                </tr></thead><tbody><tr><td scope="row"><span class="bold"><strong>Command-Line Format</strong></span></td>
                                    <td><code class="literal">--slave-pending-jobs-size-max=#</code></td>
                                </tr><tr><td scope="row"><span class="bold"><strong>System Variable</strong></span></td>
                                    <td><code class="literal"><a class="link" href="replication.html#sysvar_slave_pending_jobs_size_max">slave_pending_jobs_size_max</a></code></td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Scope</strong></span></td>
                                    <td>Global</td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Dynamic</strong></span></td>
                                    <td>Yes</td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Type</strong></span></td>
                                    <td>Integer</td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Default Value</strong></span></td>
                                    <td><code class="literal">16M</code></td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Minimum Value</strong></span></td>
                                    <td><code class="literal">1024</code></td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Maximum Value</strong></span></td>
                                    <td><code class="literal">16EiB</code></td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Block Size</strong></span></td>
                                    <td><code class="literal">1024</code></td>
                                </tr></tbody></table>
                            </div>
                            <p>
                                For multithreaded slaves, this variable sets the maximum
                                amount of memory (in bytes) available to slave worker queues
                                holding events not yet applied. Setting this variable has no
                                effect on slaves for which multithreading is not enabled.
                                Setting this variable has no immediate effect. The state of
                                the variable applies on all subsequent
                                <a class="link" href="sql-syntax.html#start-slave" title="13.4.2.6&nbsp;START SLAVE Syntax"><code class="literal">START SLAVE</code></a> commands.
                            </p><p style="color:blue;">对于多线程的奴隶，这个变量设置了最大的内存量（字节），用于保存尚未应用的事件的从属工作者队列。设置此变量对未启用多线程的从机没有影响。设置此变量不会立即生效。变量的状态应用于所有后续的从机启动命令。</p><p>
                                The minimum possible value for this variable is 1024; the
                                default is 16MB. The maximum possible value is
                                18446744073709551615 (16 exabytes). Values that are not
                                exact multiples of 1024 are rounded down to the next-highest
                                multiple of 1024 prior to being stored.
                            </p><p style="color:blue;">此变量的最小可能值为1024；默认值为16MB。最大可能值为1844 67407370955 1615（16兆字节）。不是1024的精确倍数的值在存储之前向下舍入到1024的次高倍数。</p><p>
                                The value of this variable is a soft limit and can be set to
                                match the normal workload. If an unusually large event
                                exceeds this size, the transaction is held until all the
                                slave workers have empty queues, and then processed. All
                                subsequent transactions are held until the large transaction
                                has been completed.
                            </p><p style="color:blue;">此变量的值是一个软限制，可以设置为与正常工作负载匹配。如果异常大的事件超过此大小，则事务将一直保持，直到所有从属工作进程都有空队列，然后再进行处理。所有后续交易将一直持有，直到大型交易完成。</p></li><li class="listitem"><p><a name="sysvar_slave_preserve_commit_order"></a>
                            <a class="indexterm" name="idm140286797362304"></a>

                            <a class="indexterm" name="idm140286797360848"></a>

                            <a class="link" href="replication.html#sysvar_slave_preserve_commit_order"><code class="literal">slave_preserve_commit_order</code></a>
                        </p><p style="color:blue;">奴隶保留承诺令</p>
                            <div class="informaltable">
                                <table frame="box" rules="all" summary="Properties for slave_preserve_commit_order"><colgroup><col width="30%"><col width="70%"></colgroup><thead><tr><th scope="col">Property</th>
                                    <th scope="col">Value</th>
                                </tr></thead><tbody><tr><td scope="row"><span class="bold"><strong>Command-Line Format</strong></span></td>
                                    <td><code class="literal">--slave-preserve-commit-order[={OFF|ON}]</code></td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Introduced</strong></span></td>
                                    <td>5.7.5</td>
                                </tr><tr><td scope="row"><span class="bold"><strong>System Variable</strong></span></td>
                                    <td><code class="literal"><a class="link" href="replication.html#sysvar_slave_preserve_commit_order">slave_preserve_commit_order</a></code></td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Scope</strong></span></td>
                                    <td>Global</td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Dynamic</strong></span></td>
                                    <td>Yes</td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Type</strong></span></td>
                                    <td>Boolean</td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Default Value</strong></span></td>
                                    <td><code class="literal">OFF</code></td>
                                </tr></tbody></table>
                            </div>
                            <p>
                                For multithreaded slaves, the setting 1 for this variable
                                ensures that transactions are externalized on the slave in
                                the same order as they appear in the slave's relay log,
                                and prevents gaps in the sequence of transactions that have
                                been executed from the relay log. This variable has no
                                effect on slaves for which multithreading is not enabled.
                                Note that
                                <a class="link" href="replication.html#sysvar_slave_preserve_commit_order"><code class="literal">slave_preserve_commit_order=1</code></a>
                                does not preserve the order of non-transactional DML
                                updates, so these might commit before transactions that
                                precede them in the relay log, which might result in gaps.
                            </p><p style="color:blue;">对于多线程从机，此变量的设置1确保事务在从机上外部化的顺序与它们在从机的中继日志中显示的顺序相同，并防止从中继日志执行的事务序列中出现间隙。此变量对未启用多线程的从机没有影响。请注意，slave_preserve_commit_order=1不保留非事务性dml更新的顺序，因此这些更新可能在中继日志中它们之前的事务之前提交，这可能会导致间隙。</p><p>
                                <a class="link" href="replication.html#sysvar_slave_preserve_commit_order"><code class="literal">slave_preserve_commit_order=1</code></a>
                                requires that <a class="link" href="replication.html#option_mysqld_log-bin"><code class="option">--log-bin</code></a> and
                                <a class="link" href="replication.html#sysvar_log_slave_updates"><code class="option">--log-slave-updates</code></a> are
                                enabled on the slave, and
                                <code class="option">--slave-parallel-type</code> is set to
                                <code class="literal">LOGICAL_CLOCK</code>. Before changing this
                                variable, all replication threads (for all replication
                                channels if you are using multiple replication channels)
                                must be stopped.
                            </p><p style="color:blue;">slave_preserve_commit_order=1要求在从机上启用--log bin和--log slave更新，并且--slave parallel type设置为逻辑时钟。在更改此变量之前，必须停止所有复制线程（如果使用多个复制通道，则为所有复制通道）。</p><p>
                                With
                                <a class="link" href="replication.html#sysvar_slave_preserve_commit_order"><code class="literal">slave_preserve_commit_order</code></a>
                                enabled, the executing thread waits until all previous
                                transactions are committed before committing. While the
                                slave thread is waiting for other workers to commit their
                                transactions it reports its status as <code class="literal">Waiting for
                                preceding transaction to commit</code>. (Prior to MySQL
                                5.7.8, this was shown as <code class="literal">Waiting for its turn to
                                commit</code>.) Enabling this mode on a multithreaded
                                slave ensures that it never enters a state that the master
                                was not in. This supports the use of replication for read
                                scale-out. See
                                <a class="xref" href="replication.html#replication-solutions-scaleout" title="16.3.4&nbsp;Using Replication for Scale-Out">Section&nbsp;16.3.4, “Using Replication for Scale-Out”</a>.
                            </p><p style="color:blue;">在启用slave_preserve_commit_order的情况下，执行线程在提交之前等待所有以前的事务提交。当从线程等待其他工作线程提交其事务时，它将其状态报告为等待前一个事务提交。（在mysql 5.7.8之前，这显示为等待提交）在多线程从机上启用此模式可确保它永远不会进入主机不在的状态。这支持将复制用于读取扩展。参见第16.3.4节“使用复制进行横向扩展”。</p><p>
                                If
                                <a class="link" href="replication.html#sysvar_slave_preserve_commit_order"><code class="literal">slave_preserve_commit_order=0</code></a>
                                is set, the transactions that the slave applies in parallel
                                may commit out of order. Therefore, checking for the most
                                recently executed transaction does not guarantee that all
                                previous transactions from the master have been executed on
                                the slave. There is a chance of gaps in the sequence of
                                transactions that have been executed from the slave's relay
                                log. This has implications for logging and recovery when
                                using a multithreaded slave. Note that the setting
                                <a class="link" href="replication.html#sysvar_slave_preserve_commit_order"><code class="literal">slave_preserve_commit_order=1</code></a>
                                prevents gaps, but does not prevent master log position lag
                                (where <code class="literal">Exec_master_log_pos</code> is behind the
                                position up to which transactions have been executed). See
                                <a class="xref" href="replication.html#replication-features-transaction-inconsistencies" title="16.4.1.32&nbsp;Replication and Transaction Inconsistencies">Section&nbsp;16.4.1.32, “Replication and Transaction Inconsistencies”</a>
                                for more information.
                            </p><p style="color:blue;">如果设置slave_preserve_commit_order=0，则slave并行应用的事务可能会无序提交。因此，检查最近执行的事务并不能保证来自主服务器的所有以前的事务都在从服务器上执行。在从机的中继日志中执行的事务序列中可能存在间隙。这对使用多线程从机时的日志记录和恢复有影响。请注意，设置slave_preserve_commit_order=1可防止出现间隙，但不防止主日志位置滞后（其中exec_master_log_pos位于执行事务的位置之后）。有关更多信息，请参阅第16.4.1.32节“复制和事务不一致”。</p></li><li class="listitem"><p><a name="sysvar_slave_rows_search_algorithms"></a>
                            <a class="indexterm" name="idm140286797313088"></a>

                            <a class="indexterm" name="idm140286797311984"></a>

                            <a class="link" href="replication.html#sysvar_slave_rows_search_algorithms"><code class="literal">slave_rows_search_algorithms</code></a>
                        </p><p style="color:blue;">从行搜索算法</p>
                            <div class="informaltable">
                                <table frame="box" rules="all" summary="Properties for slave_rows_search_algorithms"><colgroup><col width="30%"><col width="70%"></colgroup><thead><tr><th scope="col">Property</th>
                                    <th scope="col">Value</th>
                                </tr></thead><tbody><tr><td scope="row"><span class="bold"><strong>Command-Line Format</strong></span></td>
                                    <td><code class="literal">--slave-rows-search-algorithms=value</code></td>
                                </tr><tr><td scope="row"><span class="bold"><strong>System Variable</strong></span></td>
                                    <td><code class="literal"><a class="link" href="replication.html#sysvar_slave_rows_search_algorithms">slave_rows_search_algorithms</a></code></td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Scope</strong></span></td>
                                    <td>Global</td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Dynamic</strong></span></td>
                                    <td>Yes</td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Type</strong></span></td>
                                    <td>Set</td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Default Value</strong></span></td>
                                    <td><code class="literal">TABLE_SCAN,INDEX_SCAN</code></td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Valid Values</strong></span></td>
                                    <td><p class="valid-value"><code class="literal">TABLE_SCAN,INDEX_SCAN</code></p><p style="color:blue;">表扫描，索引扫描</p><p class="valid-value"><code class="literal">INDEX_SCAN,HASH_SCAN</code></p><p style="color:blue;">索引扫描，哈希扫描</p><p class="valid-value"><code class="literal">TABLE_SCAN,HASH_SCAN</code></p><p style="color:blue;">表扫描，哈希扫描</p><p class="valid-value"><code class="literal">TABLE_SCAN,INDEX_SCAN,HASH_SCAN</code> (equivalent to INDEX_SCAN,HASH_SCAN)</p><p style="color:blue;">表扫描，索引扫描，哈希扫描（相当于索引扫描，哈希扫描）</p></td>
                                </tr></tbody></table>
                            </div>
                            <p>
                                When preparing batches of rows for row-based logging and
                                replication, this variable controls how the rows are
                                searched for matches, in particular whether hash scans are
                                used. Setting this variable takes effect for all replication
                                channels immediately, including running channels. The
                                initial setting for the system variable can be specified
                                using the
                                <a class="link" href="replication.html#option_mysqld_slave-rows-search-algorithms"><code class="option">--slave-rows-search-algorithms</code></a>
                                option.
                            </p><p style="color:blue;">在为基于行的日志记录和复制准备行批时，此变量控制如何搜索行以查找匹配项，特别是是否使用哈希扫描。设置此变量将立即对所有复制通道（包括正在运行的通道）生效。可以使用--slave rows search algorithms选项指定系统变量的初始设置。</p><p>
                                Specify a comma-separated list of the following combinations
                                of 2 values from the list <code class="literal">INDEX_SCAN</code>,
                                <code class="literal">TABLE_SCAN</code>, <code class="literal">HASH_SCAN</code>.
                                For the system variable, the value is expected as a string,
                                so the value must be quoted. In addition, the value must not
                                contain any spaces. The recommended combinations (lists) and
                                their effects are shown in the following table:
                            </p><p style="color:blue;">从列表索引扫描、表扫描、哈希扫描中指定以下两个值的组合的逗号分隔列表。对于系统变量，该值应为字符串，因此必须引用该值。此外，该值不能包含任何空格。推荐的组合（列表）及其效果如下表所示：</p>
                            <div class="informaltable">
                                <table summary="How rows are searched for matches, based on the value specified for the --slave-rows-search-algorithms option."><colgroup><col width="25%"><col width="25%"><col width="25%"></colgroup><thead><tr>
                                    <th scope="col">Index used / option value</th>
                                    <th scope="col"><code class="literal">INDEX_SCAN,HASH_SCAN</code></th>
                                    <th scope="col"><code class="literal">INDEX_SCAN,TABLE_SCAN</code></th>
                                </tr></thead><tbody><tr>
                                    <td scope="row"><span class="emphasis"><em>Primary key or unique key</em></span></td>
                                    <td>Index scan</td>
                                    <td>Index scan</td>
                                </tr><tr>
                                    <td scope="row"><span class="emphasis"><em>(Other) Key</em></span></td>
                                    <td>Hash scan over index</td>
                                    <td>Index scan</td>
                                </tr><tr>
                                    <td scope="row"><span class="emphasis"><em>No index</em></span></td>
                                    <td>Hash scan</td>
                                    <td>Table scan</td>
                                </tr></tbody></table>
                            </div>
                            <div class="itemizedlist">
                                <ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
                                    The default value is
                                    <code class="literal">INDEX_SCAN,TABLE_SCAN</code>, which means
                                    that all searches that can use indexes do use them, and
                                    searches without any indexes use table scans.
                                </p><p style="color:blue;">默认值是index_scan，table_scan，这意味着可以使用索引的所有搜索都会使用索引，而不使用任何索引的搜索则使用表扫描。</p></li><li class="listitem"><p>
                                    To use hashing for any searches that do not use a
                                    primary or unique key, set
                                    <code class="literal">INDEX_SCAN,HASH_SCAN</code>. Specifying
                                    <code class="literal">INDEX_SCAN,HASH_SCAN</code> has the same
                                    effect as specifying
                                    <code class="literal">INDEX_SCAN,TABLE_SCAN,HASH_SCAN</code>,
                                    which is allowed.
                                </p><p style="color:blue;">若要对不使用主键或唯一键的任何搜索使用哈希，请设置index_scan、hash_scan。指定index_scan，hash_scan与指定index_scan，table_scan，hash_scan具有相同的效果，这是允许的。</p></li><li class="listitem"><p>
                                    Do not use the combination
                                    <code class="literal">TABLE_SCAN,HASH_SCAN</code>. This setting
                                    forces hashing for all searches. It has no advantage
                                    over <code class="literal">INDEX_SCAN,HASH_SCAN</code>, and it can
                                    lead to <span class="quote">“<span class="quote">record not found</span>”</span> errors or
                                    duplicate key errors in the case of a single event
                                    containing multiple updates to the same row, or updates
                                    that are order-dependent.
                                </p><p style="color:blue;">不要使用组合表扫描、哈希扫描。此设置强制对所有搜索进行哈希运算。与index_scan、hash_scan相比，它没有任何优势，如果一个事件包含对同一行的多个更新，或者更新依赖于顺序，则可能导致“record not found”错误或重复的密钥错误。</p></li></ul>
                            </div>
                            <p>
                                The order in which the algorithms are specified in the list
                                does not make any difference in the order in which they are
                                displayed by a <a class="link" href="sql-syntax.html#select" title="13.2.9&nbsp;SELECT Syntax"><code class="literal">SELECT</code></a> or
                                <a class="link" href="sql-syntax.html#show-variables" title="13.7.5.39&nbsp;SHOW VARIABLES Syntax"><code class="literal">SHOW VARIABLES</code></a> statement.
                            </p><p style="color:blue;">列表中指定算法的顺序与select或show variables语句显示算法的顺序没有任何区别。</p><p>
                                It is possible to specify a single value, but this is not
                                optimal, because setting a single value limits searches to
                                using only that algorithm. In particular, setting
                                <code class="literal">INDEX_SCAN</code> alone is not recommended, as
                                in that case searches are unable to find rows at all if no
                                index is present.
                            </p><p style="color:blue;">可以指定单个值，但这不是最优的，因为设置单个值将搜索限制为仅使用该算法。特别是，不建议单独设置索引扫描，因为在这种情况下，如果不存在索引，搜索根本找不到行。</p></li><li class="listitem"><p><a name="sysvar_slave_skip_errors"></a>
                            <a class="indexterm" name="idm140286797241424"></a>

                            <a class="indexterm" name="idm140286797240384"></a>

                            <a class="link" href="replication.html#sysvar_slave_skip_errors"><code class="literal">slave_skip_errors</code></a>
                        </p><p style="color:blue;">从跳过错误</p>
                            <div class="informaltable">
                                <table frame="box" rules="all" summary="Properties for slave-skip-errors"><colgroup><col width="30%"><col width="70%"></colgroup><thead><tr><th scope="col">Property</th>
                                    <th scope="col">Value</th>
                                </tr></thead><tbody><tr><td scope="row"><span class="bold"><strong>Command-Line Format</strong></span></td>
                                    <td><code class="literal">--slave-skip-errors=name</code></td>
                                </tr><tr><td scope="row"><span class="bold"><strong>System Variable</strong></span></td>
                                    <td><code class="literal"><a class="link" href="replication.html#sysvar_slave_skip_errors">slave_skip_errors</a></code></td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Scope</strong></span></td>
                                    <td>Global</td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Dynamic</strong></span></td>
                                    <td>No</td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Type</strong></span></td>
                                    <td>String</td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Default Value</strong></span></td>
                                    <td><code class="literal">OFF</code></td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Valid Values</strong></span></td>
                                    <td><p class="valid-value"><code class="literal">OFF</code></p><p style="color:blue;">关闭</p><p class="valid-value"><code class="literal">[list of error codes]</code></p><p style="color:blue;">[错误代码列表]</p><p class="valid-value"><code class="literal">all</code></p><p style="color:blue;">全部的</p><p class="valid-value"><code class="literal">ddl_exist_errors</code></p><p style="color:blue;">存在误差</p></td>
                                </tr></tbody></table>
                            </div>
                            <p>
                                Normally, replication stops when an error occurs on the
                                slave, which gives you the opportunity to resolve the
                                inconsistency in the data manually. This variable causes the
                                slave SQL thread to continue replication when a statement
                                returns any of the errors listed in the variable value.
                            </p><p style="color:blue;">通常，复制在从机上发生错误时停止，这使您有机会手动解决数据中的不一致性。当语句返回变量值中列出的任何错误时，此变量将导致从SQL线程继续复制。</p></li><li class="listitem"><p><a name="sysvar_slave_sql_verify_checksum"></a>
                            <a class="indexterm" name="idm140286797205584"></a>

                            <a class="indexterm" name="idm140286797204480"></a>

                            <a class="link" href="replication.html#sysvar_slave_sql_verify_checksum"><code class="literal">slave_sql_verify_checksum</code></a>
                        </p><p style="color:blue;">从SQL校验和</p>
                            <div class="informaltable">
                                <table frame="box" rules="all" summary="Properties for slave_sql_verify_checksum"><colgroup><col width="30%"><col width="70%"></colgroup><thead><tr><th scope="col">Property</th>
                                    <th scope="col">Value</th>
                                </tr></thead><tbody><tr><td scope="row"><span class="bold"><strong>Command-Line Format</strong></span></td>
                                    <td><code class="literal">--slave-sql-verify-checksum[={OFF|ON}]</code></td>
                                </tr><tr><td scope="row"><span class="bold"><strong>System Variable</strong></span></td>
                                    <td><code class="literal"><a class="link" href="replication.html#sysvar_slave_sql_verify_checksum">slave_sql_verify_checksum</a></code></td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Scope</strong></span></td>
                                    <td>Global</td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Dynamic</strong></span></td>
                                    <td>Yes</td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Type</strong></span></td>
                                    <td>Boolean</td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Default Value</strong></span></td>
                                    <td><code class="literal">ON</code></td>
                                </tr></tbody></table>
                            </div>
                            <p>
                                Cause the slave SQL thread to verify data using the
                                checksums read from the relay log. In the event of a
                                mismatch, the slave stops with an error. Setting this
                                variable takes effect for all replication channels
                                immediately, including running channels.
                            </p><p style="color:blue;">使从sql线程使用从中继日志中读取的校验和来验证数据。在不匹配的情况下，从机会因错误而停止。设置此变量将立即对所有复制通道（包括正在运行的通道）生效。</p>
                            <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">

                                <div class="admon-title">
                                    Note
                                </div>
                                <p>
                                    The slave I/O thread always reads checksums if possible
                                    when accepting events from over the network.
                                </p><p style="color:blue;">如果可能的话，从I/O线程在接受来自网络的事件时总是读取校验和。</p>
                            </div>
                        </li><li class="listitem"><p><a name="sysvar_slave_transaction_retries"></a>
                            <a class="indexterm" name="idm140286797175072"></a>

                            <a class="indexterm" name="idm140286797173968"></a>

                            <a class="link" href="replication.html#sysvar_slave_transaction_retries"><code class="literal">slave_transaction_retries</code></a>
                        </p><p style="color:blue;">从事务重试</p>
                            <div class="informaltable">
                                <table frame="box" rules="all" summary="Properties for slave_transaction_retries"><colgroup><col width="30%"><col width="70%"></colgroup><thead><tr><th scope="col">Property</th>
                                    <th scope="col">Value</th>
                                </tr></thead><tbody><tr><td scope="row"><span class="bold"><strong>Command-Line Format</strong></span></td>
                                    <td><code class="literal">--slave-transaction-retries=#</code></td>
                                </tr><tr><td scope="row"><span class="bold"><strong>System Variable</strong></span></td>
                                    <td><code class="literal"><a class="link" href="replication.html#sysvar_slave_transaction_retries">slave_transaction_retries</a></code></td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Scope</strong></span></td>
                                    <td>Global</td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Dynamic</strong></span></td>
                                    <td>Yes</td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Type</strong></span></td>
                                    <td>Integer</td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Default Value</strong></span></td>
                                    <td><code class="literal">10</code></td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Minimum Value</strong></span></td>
                                    <td><code class="literal">0</code></td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Maximum Value</strong></span> (64-bit platforms)</td>
                                    <td><code class="literal">18446744073709551615</code></td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Maximum Value</strong></span> (32-bit platforms)</td>
                                    <td><code class="literal">4294967295</code></td>
                                </tr></tbody></table>
                            </div>
                            <p>
                                If a replication slave SQL thread fails to execute a
                                transaction because of an
                                <a class="link" href="innodb-storage-engine.html" title="Chapter&nbsp;14&nbsp;The InnoDB Storage Engine"><code class="literal">InnoDB</code></a> deadlock or because the
                                transaction's execution time exceeded
                                <a class="link" href="innodb-storage-engine.html" title="Chapter&nbsp;14&nbsp;The InnoDB Storage Engine"><code class="literal">InnoDB</code></a>'s
                                <a class="link" href="innodb-storage-engine.html#sysvar_innodb_lock_wait_timeout"><code class="literal">innodb_lock_wait_timeout</code></a> or
                                <a class="link" href="mysql-cluster.html" title="Chapter&nbsp;21&nbsp;MySQL NDB Cluster 7.5 and NDB Cluster 7.6"><code class="literal">NDB</code></a>'s
                                <a class="link" href="mysql-cluster.html#ndbparam-ndbd-transactiondeadlockdetectiontimeout"><code class="literal">TransactionDeadlockDetectionTimeout</code></a>
                                or
                                <a class="link" href="mysql-cluster.html#ndbparam-ndbd-transactioninactivetimeout"><code class="literal">TransactionInactiveTimeout</code></a>,
                                it automatically retries
                                <a class="link" href="replication.html#sysvar_slave_transaction_retries"><code class="literal">slave_transaction_retries</code></a>
                                times before stopping with an error. Transactions with a
                                non-temporary error are not retried.
                            </p><p style="color:blue;">如果复制从属SQL线程由于InnoDB死锁或由于事务的执行时间超过InnoDB的InnoDB锁等待超时或NDB的TransactionDeadlockDetectionTimeout或TransactionActiveTimeout而无法执行事务，则它会在停止之前自动重试从属事务重试次数，并出现错误。不重试具有非临时错误的事务。</p><p>
                                The default value for
                                <a class="link" href="replication.html#sysvar_slave_transaction_retries"><code class="literal">slave_transaction_retries</code></a>
                                is 10. Setting the variable to 0 disables automatic retrying
                                of transactions. Setting the variable takes effect for all
                                replication channels immediately, including running
                                channels.
                            </p><p style="color:blue;">slave_transaction_retries的默认值是10。将变量设置为0将禁用事务的自动重试。设置该变量将立即对所有复制通道（包括正在运行的通道）生效。</p><p>
                                As of MySQL 5.7.5, retrying of transactions is supported
                                when multithreading is enabled on a slave. In previous
                                versions,
                                <a class="link" href="replication.html#sysvar_slave_transaction_retries"><code class="literal">slave_transaction_retries</code></a>
                                was treated as equal to 0 when using multithreaded slaves.
                            </p><p style="color:blue;">从mysql 5.7.5开始，当在从机上启用多线程时，支持重试事务。在以前的版本中，当使用多线程从机时，从机事务重试被视为等于0。</p><p>
                                The Performance Schema table
                                <a class="link" href="performance-schema.html#replication-applier-status-table" title="25.12.11.4&nbsp;The replication_applier_status Table"><code class="literal">replication_applier_status</code></a>
                                shows the number of retries that took place on each
                                replication channel, in the
                                <code class="literal">COUNT_TRANSACTIONS_RETRIES</code> column.
                            </p><p style="color:blue;">性能架构表replication_applier_status在count_transactions_retries列中显示每个复制通道上的重试次数。</p></li><li class="listitem"><p><a name="sysvar_slave_type_conversions"></a>
                            <a class="indexterm" name="idm140286797120464"></a>

                            <a class="indexterm" name="idm140286797119424"></a>

                            <a class="link" href="replication.html#sysvar_slave_type_conversions"><code class="literal">slave_type_conversions</code></a>
                        </p><p style="color:blue;">从类型转换</p>
                            <div class="informaltable">
                                <table frame="box" rules="all" summary="Properties for slave_type_conversions"><colgroup><col width="30%"><col width="70%"></colgroup><thead><tr><th scope="col">Property</th>
                                    <th scope="col">Value</th>
                                </tr></thead><tbody><tr><td scope="row"><span class="bold"><strong>Command-Line Format</strong></span></td>
                                    <td><code class="literal">--slave-type-conversions=set</code></td>
                                </tr><tr><td scope="row"><span class="bold"><strong>System Variable</strong></span></td>
                                    <td><code class="literal"><a class="link" href="replication.html#sysvar_slave_type_conversions">slave_type_conversions</a></code></td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Scope</strong></span></td>
                                    <td>Global</td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Dynamic</strong></span></td>
                                    <td>No</td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Type</strong></span></td>
                                    <td>Set</td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Default Value</strong></span></td>
                                    <td><code class="literal"></code></td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Valid Values</strong></span> (&gt;= 5.7.2)</td>
                                    <td><p class="valid-value"><code class="literal">ALL_LOSSY</code></p><p style="color:blue;">全部损失</p><p class="valid-value"><code class="literal">ALL_NON_LOSSY</code></p><p style="color:blue;">全无损失</p><p class="valid-value"><code class="literal">ALL_SIGNED</code></p><p style="color:blue;">所有签名</p><p class="valid-value"><code class="literal">ALL_UNSIGNED</code></p><p style="color:blue;">全部未签名</p></td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Valid Values</strong></span> (&lt;= 5.7.1)</td>
                                    <td><p class="valid-value"><code class="literal">ALL_LOSSY</code></p><p style="color:blue;">全部损失</p><p class="valid-value"><code class="literal">ALL_NON_LOSSY</code></p><p style="color:blue;">全无损失</p></td>
                                </tr></tbody></table>
                            </div>
                            <p>
                                Controls the type conversion mode in effect on the slave
                                when using row-based replication. In MySQL 5.7.2 and later,
                                its value is a comma-delimited set of zero or more elements
                                from the list: <code class="literal">ALL_LOSSY</code>,
                                <code class="literal">ALL_NON_LOSSY</code>,
                                <code class="literal">ALL_SIGNED</code>,
                                <code class="literal">ALL_UNSIGNED</code>. Set this variable to an
                                empty string to disallow type conversions between the master
                                and the slave. Setting this variable takes effect for all
                                replication channels immediately, including running
                                channels.
                            </p><p style="color:blue;">控制在使用基于行的复制时对从机有效的类型转换模式。在mysql 5.7.2及更高版本中，它的值是一个逗号分隔的列表中零个或多个元素的集合：all_lossy，all_non_lossy，all_signed，all_unsigned。将此变量设置为空字符串，以禁止主和从之间的类型转换。设置此变量将立即对所有复制通道（包括正在运行的通道）生效。</p><p>
                                <code class="literal">ALL_SIGNED</code> and
                                <code class="literal">ALL_UNSIGNED</code> were added in MySQL 5.7.2
                                (Bug#15831300). For additional information on type
                                conversion modes applicable to attribute promotion and
                                demotion in row-based replication, see
                                <a class="xref" href="replication.html#replication-features-attribute-promotion" title="Row-based replication: attribute promotion and demotion">Row-based replication: attribute promotion and demotion</a>.
                            </p><p style="color:blue;">在mysql 5.7.2中添加了all_signed和all_unsigned（错误15831300）。有关适用于基于行的复制中属性提升和降级的类型转换模式的其他信息，请参阅基于行的复制：属性提升和降级。</p></li><li class="listitem"><p><a name="sysvar_sql_slave_skip_counter"></a>
                            <a class="indexterm" name="idm140286797073952"></a>

                            <a class="indexterm" name="idm140286797072912"></a>

                            <a class="link" href="replication.html#sysvar_sql_slave_skip_counter"><code class="literal">sql_slave_skip_counter</code></a>
                        </p><p style="color:blue;">sql_slave_skip_计数器</p>
                            <div class="informaltable">
                                <table frame="box" rules="all" summary="Properties for sql_slave_skip_counter"><colgroup><col width="30%"><col width="70%"></colgroup><thead><tr><th scope="col">Property</th>
                                    <th scope="col">Value</th>
                                </tr></thead><tbody><tr><td scope="row"><span class="bold"><strong>System Variable</strong></span></td>
                                    <td><code class="literal"><a class="link" href="replication.html#sysvar_sql_slave_skip_counter">sql_slave_skip_counter</a></code></td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Scope</strong></span></td>
                                    <td>Global</td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Dynamic</strong></span></td>
                                    <td>Yes</td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Type</strong></span></td>
                                    <td>Integer</td>
                                </tr></tbody></table>
                            </div>
                            <p>
                                The number of events from the master that a slave server
                                should skip. Setting the option has no immediate effect. The
                                variable applies to the next <a class="link" href="sql-syntax.html#start-slave" title="13.4.2.6&nbsp;START SLAVE Syntax"><code class="literal">START
                                SLAVE</code></a> statement; the next
                                <a class="link" href="sql-syntax.html#start-slave" title="13.4.2.6&nbsp;START SLAVE Syntax"><code class="literal">START SLAVE</code></a> statement also
                                changes the value back to 0. When this variable is set to a
                                nonzero value and there are multiple replication channels
                                configured, the <a class="link" href="sql-syntax.html#start-slave" title="13.4.2.6&nbsp;START SLAVE Syntax"><code class="literal">START SLAVE</code></a>
                                statement can only be used with the <code class="literal">FOR CHANNEL
                                <em class="replaceable"><code>channel</code></em></code> clause.
                            </p><p style="color:blue;">从服务器应跳过的主服务器事件数。设置该选项不会立即生效。变量应用于下一个start slave语句；下一个start slave语句也将值更改回0。当此变量设置为非零值并且配置了多个复制通道时，start slave语句只能与for channel channel子句一起使用。</p><p>
                                This option is incompatible with GTID-based replication, and
                                must not be set to a nonzero value when
                                <a class="link" href="replication.html#sysvar_gtid_mode"><code class="literal">gtid_mode=ON</code></a>. If you need
                                to skip transactions when employing GTIDs, use
                                <a class="link" href="replication.html#sysvar_gtid_executed"><code class="literal">gtid_executed</code></a> from the
                                master instead. See
                                <a class="xref" href="replication.html#replication-gtids-failover-empty" title="Injecting empty transactions">Injecting empty transactions</a>, for
                                information about how to do this.
                            </p><p style="color:blue;">此选项与基于gtid的复制不兼容，并且在gtid_mode=on时不能设置为非零值。如果在使用gtid时需要跳过事务，请改用从主节点执行的gtid。有关如何执行此操作的信息，请参阅注入空事务。</p>
                            <div class="important" style="margin-left: 0.5in; margin-right: 0.5in;">

                                <div class="admon-title">
                                    Important
                                </div>
                                <p>
                                    If skipping the number of events specified by setting this
                                    variable would cause the slave to begin in the middle of
                                    an event group, the slave continues to skip until it finds
                                    the beginning of the next event group and begins from that
                                    point. For more information, see
                                    <a class="xref" href="sql-syntax.html#set-global-sql-slave-skip-counter" title="13.4.2.5&nbsp;SET GLOBAL sql_slave_skip_counter Syntax">Section&nbsp;13.4.2.5, “SET GLOBAL sql_slave_skip_counter Syntax”</a>.
                                </p><p style="color:blue;">如果跳过通过设置此变量指定的事件数将导致从属服务器从事件组的中间开始，则从属服务器将继续跳过，直到找到下一个事件组的开始并从该点开始。有关详细信息，请参阅第13.4.2.5节“设置全局SQL从属跳过计数器语法”。</p>
                            </div>
                        </li><li class="listitem"><p><a name="sysvar_sync_master_info"></a>
                            <a class="indexterm" name="idm140286797040096"></a>

                            <a class="indexterm" name="idm140286797039088"></a>

                            <a class="link" href="replication.html#sysvar_sync_master_info"><code class="literal">sync_master_info</code></a>
                        </p><p style="color:blue;">同步主机信息</p>
                            <div class="informaltable">
                                <table frame="box" rules="all" summary="Properties for sync_master_info"><colgroup><col width="30%"><col width="70%"></colgroup><thead><tr><th scope="col">Property</th>
                                    <th scope="col">Value</th>
                                </tr></thead><tbody><tr><td scope="row"><span class="bold"><strong>Command-Line Format</strong></span></td>
                                    <td><code class="literal">--sync-master-info=#</code></td>
                                </tr><tr><td scope="row"><span class="bold"><strong>System Variable</strong></span></td>
                                    <td><code class="literal"><a class="link" href="replication.html#sysvar_sync_master_info">sync_master_info</a></code></td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Scope</strong></span></td>
                                    <td>Global</td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Dynamic</strong></span></td>
                                    <td>Yes</td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Type</strong></span></td>
                                    <td>Integer</td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Default Value</strong></span></td>
                                    <td><code class="literal">10000</code></td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Minimum Value</strong></span></td>
                                    <td><code class="literal">0</code></td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Maximum Value</strong></span> (64-bit platforms)</td>
                                    <td><code class="literal">18446744073709551615</code></td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Maximum Value</strong></span> (32-bit platforms)</td>
                                    <td><code class="literal">4294967295</code></td>
                                </tr></tbody></table>
                            </div>
                            <p>
                                The effects of this variable on a replication slave depend
                                on whether the slave's
                                <a class="link" href="replication.html#sysvar_master_info_repository"><code class="literal">master_info_repository</code></a> is
                                set to <code class="literal">FILE</code> or <code class="literal">TABLE</code>,
                                as explained in the following paragraphs.
                            </p><p style="color:blue;">此变量对复制从属服务器的影响取决于从属服务器的master_info_存储库是否设置为file或table，如下文所述。</p><p><b>master_info_repository = FILE.&nbsp;</b>
                                If the value of <code class="literal">sync_master_info</code> is
                                greater than 0, the slave synchronizes its
                                <code class="filename">master.info</code> file to disk (using
                                <code class="literal">fdatasync()</code>) after every
                                <code class="literal">sync_master_info</code> events. If it is 0,
                                the MySQL server performs no synchronization of the
                                <code class="filename">master.info</code> file to disk; instead,
                                the server relies on the operating system to flush its
                                contents periodically as with any other file.
                            </p><p style="color:blue;">master_info_repository=文件。如果sync_master_info的值大于0，则从机在每次sync_master_info事件后都会将其master.info文件同步到磁盘（使用fdatasync（））。如果为0，则mysql服务器不执行master.info文件到磁盘的同步；相反，服务器依赖于操作系统定期刷新其内容，与任何其他文件一样。</p><p><b>master_info_repository = TABLE.&nbsp;</b>
                                If the value of <code class="literal">sync_master_info</code> is
                                greater than 0, the slave updates its master info
                                repository table after every
                                <code class="literal">sync_master_info</code> events. If it is 0,
                                the table is never updated.
                            </p><p style="color:blue;">master_info_repository=表。如果sync_master_info的值大于0，则从机在每次sync_master_info事件后更新其master info存储库表。如果为0，则永远不会更新表。</p><p>
                                The default value for <code class="literal">sync_master_info</code> is
                                10000. Setting this variable takes effect for all
                                replication channels immediately, including running
                                channels.
                            </p><p style="color:blue;">同步主机信息的默认值是10000。设置此变量将立即对所有复制通道（包括正在运行的通道）生效。</p></li><li class="listitem"><p><a name="sysvar_sync_relay_log"></a>
                            <a class="indexterm" name="idm140286796989296"></a>

                            <a class="indexterm" name="idm140286796988240"></a>

                            <a class="link" href="replication.html#sysvar_sync_relay_log"><code class="literal">sync_relay_log</code></a>
                        </p><p style="color:blue;">同步继电器日志</p>
                            <div class="informaltable">
                                <table frame="box" rules="all" summary="Properties for sync_relay_log"><colgroup><col width="30%"><col width="70%"></colgroup><thead><tr><th scope="col">Property</th>
                                    <th scope="col">Value</th>
                                </tr></thead><tbody><tr><td scope="row"><span class="bold"><strong>Command-Line Format</strong></span></td>
                                    <td><code class="literal">--sync-relay-log=#</code></td>
                                </tr><tr><td scope="row"><span class="bold"><strong>System Variable</strong></span></td>
                                    <td><code class="literal"><a class="link" href="replication.html#sysvar_sync_relay_log">sync_relay_log</a></code></td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Scope</strong></span></td>
                                    <td>Global</td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Dynamic</strong></span></td>
                                    <td>Yes</td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Type</strong></span></td>
                                    <td>Integer</td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Default Value</strong></span></td>
                                    <td><code class="literal">10000</code></td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Minimum Value</strong></span></td>
                                    <td><code class="literal">0</code></td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Maximum Value</strong></span> (64-bit platforms)</td>
                                    <td><code class="literal">18446744073709551615</code></td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Maximum Value</strong></span> (32-bit platforms)</td>
                                    <td><code class="literal">4294967295</code></td>
                                </tr></tbody></table>
                            </div>
                            <p>
                                If the value of this variable is greater than 0, the MySQL
                                server synchronizes its relay log to disk (using
                                <code class="literal">fdatasync()</code>) after every
                                <code class="literal">sync_relay_log</code> events are written to the
                                relay log. Setting this variable takes effect for all
                                replication channels immediately, including running
                                channels.
                            </p><p style="color:blue;">如果此变量的值大于0，则MySQL服务器会在每次将sync_relay_日志事件写入中继日志后将其中继日志同步到磁盘（使用fdatasync（））。设置此变量将立即对所有复制通道（包括正在运行的通道）生效。</p><p>
                                Setting <code class="literal">sync_relay_log</code> to 0 causes no
                                synchronization to be done to disk; in this case, the server
                                relies on the operating system to flush the relay log's
                                contents from time to time as for any other file.
                            </p><p style="color:blue;">将sync_relay_log设置为0将不会对磁盘执行同步；在这种情况下，服务器依赖于操作系统不时刷新中继日志的内容，就像刷新任何其他文件一样。</p><p>
                                A value of 1 is the safest choice because in the event of a
                                crash you lose at most one event from the relay log.
                                However, it is also the slowest choice (unless the disk has
                                a battery-backed cache, which makes synchronization very
                                fast).
                            </p><p style="color:blue;">值1是最安全的选择，因为在发生崩溃的情况下，从中继日志中最多丢失一个事件。但是，这也是最慢的选择（除非磁盘有电池支持的缓存，这使得同步非常快）。</p></li><li class="listitem"><p><a name="sysvar_sync_relay_log_info"></a>
                            <a class="indexterm" name="idm140286796946768"></a>

                            <a class="indexterm" name="idm140286796945728"></a>

                            <a class="link" href="replication.html#sysvar_sync_relay_log_info"><code class="literal">sync_relay_log_info</code></a>
                        </p><p style="color:blue;">同步中继日志信息</p>
                            <div class="informaltable">
                                <table frame="box" rules="all" summary="Properties for sync_relay_log_info"><colgroup><col width="30%"><col width="70%"></colgroup><thead><tr><th scope="col">Property</th>
                                    <th scope="col">Value</th>
                                </tr></thead><tbody><tr><td scope="row"><span class="bold"><strong>Command-Line Format</strong></span></td>
                                    <td><code class="literal">--sync-relay-log-info=#</code></td>
                                </tr><tr><td scope="row"><span class="bold"><strong>System Variable</strong></span></td>
                                    <td><code class="literal"><a class="link" href="replication.html#sysvar_sync_relay_log_info">sync_relay_log_info</a></code></td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Scope</strong></span></td>
                                    <td>Global</td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Dynamic</strong></span></td>
                                    <td>Yes</td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Type</strong></span></td>
                                    <td>Integer</td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Default Value</strong></span></td>
                                    <td><code class="literal">10000</code></td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Minimum Value</strong></span></td>
                                    <td><code class="literal">0</code></td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Maximum Value</strong></span> (64-bit platforms)</td>
                                    <td><code class="literal">18446744073709551615</code></td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Maximum Value</strong></span> (32-bit platforms)</td>
                                    <td><code class="literal">4294967295</code></td>
                                </tr></tbody></table>
                            </div>
                            <p>
                                The default value for <code class="literal">sync_relay_log_info</code>
                                is 10000. Setting this variable takes effect for all
                                replication channels immediately, including running
                                channels.
                            </p><p style="color:blue;">sync_relay_log_info的默认值为10000。设置此变量将立即对所有复制通道（包括正在运行的通道）生效。</p><p>
                                The effects of this variable on the replication slave depend
                                on the server's
                                <a class="link" href="replication.html#sysvar_relay_log_info_repository"><code class="literal">relay_log_info_repository</code></a>
                                setting (<code class="literal">FILE</code> or
                                <code class="literal">TABLE</code>). If the setting is
                                <code class="literal">TABLE</code>, the effects of the variable also
                                depend on whether the storage engine used by the relay log
                                info table is transactional (such as
                                <a class="link" href="innodb-storage-engine.html" title="Chapter&nbsp;14&nbsp;The InnoDB Storage Engine"><code class="literal">InnoDB</code></a>) or not transactional
                                (<a class="link" href="storage-engines.html#myisam-storage-engine" title="15.2&nbsp;The MyISAM Storage Engine"><code class="literal">MyISAM</code></a>). The effects of these
                                factors on the behavior of the server for
                                <code class="literal">sync_relay_log_info</code> values of zero and
                                greater than zero are as follows:
                            </p><p style="color:blue;">此变量对复制从属服务器的影响取决于服务器的中继日志信息库设置（文件或表）。如果设置为table，那么变量的效果还取决于relay log info表使用的存储引擎是事务性的（例如innodb）还是非事务性的（myisam）。这些因素对sync_relay_log_info值为零且大于零的服务器行为的影响如下：</p>
                            <div class="variablelist">
                                <dl class="variablelist"><dt><span class="term">
                <code class="literal">sync_relay_log_info = 0</code>
</span></dt><dd>
                                    <div class="itemizedlist">
                                        <ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
                                            If
                                            <a class="link" href="replication.html#sysvar_relay_log_info_repository"><code class="literal">relay_log_info_repository</code></a>
                                            is set to <code class="literal">FILE</code>, the MySQL
                                            server performs no synchronization of the
                                            <code class="filename">relay-log.info</code> file to disk;
                                            instead, the server relies on the operating system
                                            to flush its contents periodically as with any
                                            other file.
                                        </p><p style="color:blue;">如果relay_log_info_repository设置为file，mysql服务器将不执行relay-log.info文件到磁盘的同步；相反，服务器依赖于操作系统定期刷新其内容，与任何其他文件一样。</p></li><li class="listitem"><p>
                                            If
                                            <a class="link" href="replication.html#sysvar_relay_log_info_repository"><code class="literal">relay_log_info_repository</code></a>
                                            is set to <code class="literal">TABLE</code>, and the
                                            storage engine for that table is transactional,
                                            the table is updated after each transaction. (The
                                            <code class="literal">sync_relay_log_info</code> setting is
                                            effectively ignored in this case.)
                                        </p><p style="color:blue;">如果relay_log_info_repository设置为table，并且该表的存储引擎是事务性的，则在每个事务之后都会更新该表。（在这种情况下，会有效忽略sync_relay_log_info设置。）</p></li><li class="listitem"><p>
                                            If
                                            <a class="link" href="replication.html#sysvar_relay_log_info_repository"><code class="literal">relay_log_info_repository</code></a>
                                            is set to <code class="literal">TABLE</code>, and the
                                            storage engine for that table is not
                                            transactional, the table is never updated.
                                        </p><p style="color:blue;">如果relay_log_info_repository设置为table，并且该表的存储引擎不是事务性的，则永远不会更新该表。</p></li></ul>
                                    </div>
                                </dd><dt><span class="term">
                <code class="literal">sync_relay_log_info =
                <em class="replaceable"><code>N</code></em> &gt; 0</code>
</span></dt><dd>
                                    <div class="itemizedlist">
                                        <ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
                                            If
                                            <a class="link" href="replication.html#sysvar_relay_log_info_repository"><code class="literal">relay_log_info_repository</code></a>
                                            is set to <code class="literal">FILE</code>, the slave
                                            synchronizes its
                                            <code class="filename">relay-log.info</code> file to disk
                                            (using <code class="literal">fdatasync()</code>) after every
                                            <em class="replaceable"><code>N</code></em> transactions.
                                        </p><p style="color:blue;">如果relay_log_info_repository设置为file，则在每N个事务之后，从机将其relay-log.info文件同步到磁盘（使用fdatasync（））。</p></li><li class="listitem"><p>
                                            If
                                            <a class="link" href="replication.html#sysvar_relay_log_info_repository"><code class="literal">relay_log_info_repository</code></a>
                                            is set to <code class="literal">TABLE</code>, and the
                                            storage engine for that table is transactional,
                                            the table is updated after each transaction. (The
                                            <code class="literal">sync_relay_log_info</code> setting is
                                            effectively ignored in this case.)
                                        </p><p style="color:blue;">如果relay_log_info_repository设置为table，并且该表的存储引擎是事务性的，则在每个事务之后都会更新该表。（在这种情况下，会有效忽略sync_relay_log_info设置。）</p></li><li class="listitem"><p>
                                            If
                                            <a class="link" href="replication.html#sysvar_relay_log_info_repository"><code class="literal">relay_log_info_repository</code></a>
                                            is set to <code class="literal">TABLE</code>, and the
                                            storage engine for that table is not
                                            transactional, the table is updated after every
                                            <em class="replaceable"><code>N</code></em> events.
                                        </p><p style="color:blue;">如果将relay_log_info_repository设置为table，并且该表的存储引擎不是事务性的，则该表将在每n个事件之后更新。</p></li></ul>
                                    </div>
                                </dd></dl>
                            </div>
                        </li></ul>
                    </div>

                </div>

            </div>
            <div class="section">
                <div class="titlepage">
                    <div>
                        <div>
                            <h4 class="title"><a name="replication-options-binary-log"></a>16.1.6.4&nbsp;Binary Logging Options and Variables</h4>

                        </div>

                    </div>

                </div>
                <div class="itemizedlist">
                    <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><a class="xref" href="replication.html#replication-optvars-binlog" title="Startup Options Used with Binary Logging">Startup Options Used with Binary Logging</a></p><p style="color:blue;">用于二进制日志记录的启动选项</p></li><li class="listitem"><p><a class="xref" href="replication.html#replication-sysvars-binlog" title="System Variables Used with Binary Logging">System Variables Used with Binary Logging</a></p><p style="color:blue;">二进制日志使用的系统变量</p></li></ul>
                </div>
                <p>
                    You can use the <a class="link" href="programs.html#mysqld" title="4.3.1&nbsp;mysqld — The MySQL Server"><span class="command"><strong>mysqld</strong></span></a> options and system
                    variables that are described in this section to affect the
                    operation of the binary log as well as to control which statements
                    are written to the binary log. For additional information about
                    the binary log, see <a class="xref" href="server-administration.html#binary-log" title="5.4.4&nbsp;The Binary Log">Section&nbsp;5.4.4, “The Binary Log”</a>. For additional
                    information about using MySQL server options and system variables,
                    see <a class="xref" href="server-administration.html#server-options" title="5.1.6&nbsp;Server Command Options">Section&nbsp;5.1.6, “Server Command Options”</a>, and
                    <a class="xref" href="server-administration.html#server-system-variables" title="5.1.7&nbsp;Server System Variables">Section&nbsp;5.1.7, “Server System Variables”</a>.
                </p><p style="color:blue;">您可以使用本节中描述的mysqld选项和系统变量来影响二进制日志的操作，并控制将哪些语句写入二进制日志。有关二进制日志的更多信息，请参见第5.4.4节“二进制日志”。有关使用mysql服务器选项和系统变量的更多信息，请参阅第5.1.6节“服务器命令选项”和第5.1.7节“服务器系统变量”。</p>
                <div class="simplesect">

                    <div class="titlepage">
                        <div>

                            <div class="simple">
                                <h5 class="title"><a name="replication-optvars-binlog"></a>Startup Options Used with Binary Logging</h5>
                            </div>
                        </div>
                    </div>
                    <p>
                        The following list describes startup options for enabling and
                        configuring the binary log. System variables used with binary
                        logging are discussed later in this section.
                    </p><p style="color:blue;">下表描述了启用和配置二进制日志的启动选项。本节后面将讨论与二进制日志记录一起使用的系统变量。</p>
                    <div class="itemizedlist">
                        <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><a name="option_mysqld_binlog-row-event-max-size"></a>
                            <a class="indexterm" name="idm140286796861728"></a>

                            <a class="indexterm" name="idm140286796860272"></a>

                            <a class="link" href="replication.html#option_mysqld_binlog-row-event-max-size"><code class="option">--binlog-row-event-max-size=<em class="replaceable"><code>N</code></em></code></a>
                        </p><p style="color:blue;">--binlog row event max size=n</p>
                            <div class="informaltable">
                                <table frame="box" rules="all" summary="Properties for binlog-row-event-max-size"><colgroup><col width="30%"><col width="70%"></colgroup><thead><tr><th scope="col">Property</th>
                                    <th scope="col">Value</th>
                                </tr></thead><tbody><tr><td scope="row"><span class="bold"><strong>Command-Line Format</strong></span></td>
                                    <td><code class="literal">--binlog-row-event-max-size=#</code></td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Type</strong></span></td>
                                    <td>Integer</td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Default Value</strong></span></td>
                                    <td><code class="literal">8192</code></td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Minimum Value</strong></span></td>
                                    <td><code class="literal">256</code></td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Maximum Value</strong></span> (64-bit platforms)</td>
                                    <td><code class="literal">18446744073709551615</code></td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Maximum Value</strong></span> (32-bit platforms)</td>
                                    <td><code class="literal">4294967295</code></td>
                                </tr></tbody></table>
                            </div>
                            <p>
                                Specify the maximum size of a row-based binary log event, in
                                bytes. Rows are grouped into events smaller than this size
                                if possible. The value should be a multiple of 256. The
                                default is 8192. See <a class="xref" href="replication.html#replication-formats" title="16.2.1&nbsp;Replication Formats">Section&nbsp;16.2.1, “Replication Formats”</a>.
                            </p><p style="color:blue;">以字节为单位指定基于行的二进制日志事件的最大大小。如果可能，行将分组为小于此大小的事件。该值应为256的倍数。默认值为8192。见第16.2.1节“复制格式”。</p></li><li class="listitem"><p><a name="option_mysqld_log-bin"></a>
                            <a class="indexterm" name="idm140286796830624"></a>

                            <a class="indexterm" name="idm140286796829168"></a>

                            <a class="link" href="replication.html#option_mysqld_log-bin"><code class="option">--log-bin[=<em class="replaceable"><code>base_name</code></em>]</code></a>
                        </p><p style="color:blue;">--日志箱[=基本名称]</p>
                            <div class="informaltable">
                                <table frame="box" rules="all" summary="Properties for log-bin"><colgroup><col width="30%"><col width="70%"></colgroup><thead><tr><th scope="col">Property</th>
                                    <th scope="col">Value</th>
                                </tr></thead><tbody><tr><td scope="row"><span class="bold"><strong>Command-Line Format</strong></span></td>
                                    <td><code class="literal">--log-bin=file_name</code></td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Type</strong></span></td>
                                    <td>File name</td>
                                </tr></tbody></table>
                            </div>
                            <p>
                                Enables binary logging. With binary logging enabled, the
                                server logs all statements that change data to the binary
                                log, which is used for backup and replication. The binary
                                log is a sequence of files with a base name and numeric
                                extension. For information on the format and management of
                                the binary log, see <a class="xref" href="server-administration.html#binary-log" title="5.4.4&nbsp;The Binary Log">Section&nbsp;5.4.4, “The Binary Log”</a>.
                            </p><p style="color:blue;">启用二进制日志记录。启用二进制日志记录后，服务器将所有更改数据的语句记录到二进制日志中，该日志用于备份和复制。二进制日志是一系列具有基名称和数字扩展名的文件。有关二进制日志的格式和管理的信息，请参阅第5.4.4节“二进制日志”。</p><p>
                                If you supply a value for the <code class="option">--log-bin</code>
                                option, the value is used as the base name for the log
                                sequence. The server creates binary log files in sequence by
                                adding a numeric suffix to the base name. In MySQL 5.7, the
                                base name defaults to
                                <code class="filename"><em class="replaceable"><code>host_name</code></em>-bin</code>,
                                using the name of the host machine. It is recommended that
                                you specify a base name, so that you can continue to use the
                                same binary log file names regardless of changes to the
                                default name.
                            </p><p style="color:blue;">如果为--log bin选项提供一个值，则该值将用作日志序列的基名称。服务器通过在基名中添加数字后缀，按顺序创建二进制日志文件。在mysql 5.7中，基本名称默认为host-name-bin，使用主机的名称。建议您指定一个基名称，以便可以继续使用相同的二进制日志文件名，而不必考虑对默认名称的更改。</p><p>
                                The default location for binary log files is the data
                                directory. You can use the <code class="option">--log-bin</code> option
                                to specify an alternative location, by adding a leading
                                absolute path name to the base name to specify a different
                                directory. When the server reads an entry from the binary
                                log index file, which tracks the binary log files that have
                                been used, it checks whether the entry contains a relative
                                path. If it does, the relative part of the path is replaced
                                with the absolute path set using the
                                <code class="option">--log-bin</code> option. An absolute path recorded
                                in the binary log index file remains unchanged; in such a
                                case, the index file must be edited manually to enable a new
                                path or paths to be used. (In older versions of MySQL,
                                manual intervention was required whenever relocating the
                                binary log or relay log files.) (Bug #11745230, Bug #12133)
                            </p><p style="color:blue;">二进制日志文件的默认位置是数据目录。您可以使用--log bin选项指定一个替代位置，方法是将前导绝对路径名添加到基名称以指定其他目录。当服务器从跟踪已使用的二进制日志文件的二进制日志索引文件中读取条目时，它将检查该条目是否包含相对路径。如果是，则使用--log bin选项将路径的相对部分替换为绝对路径集。记录在二进制日志索引文件中的绝对路径保持不变；在这种情况下，必须手动编辑索引文件才能使用新路径。（在旧版本的mysql中，每当重新定位二进制日志或中继日志文件时，都需要手动干预。）</p><p>
                                Setting this option causes the
                                <a class="link" href="replication.html#sysvar_log_bin"><code class="literal">log_bin</code></a> system variable to
                                be set to <code class="literal">ON</code> (or <code class="literal">1</code>),
                                and not to the base name. The binary log file base name and
                                any specified path are available as the
                                <a class="link" href="replication.html#sysvar_log_bin_basename"><code class="literal">log_bin_basename</code></a> system
                                variable.
                            </p><p style="color:blue;">设置此选项将导致LOG U BIN系统变量设置为ON（或1），而不是基名。二进制日志文件基名和任何指定的路径都可用作LOG BIN BASENAME系统变量。</p><p>
                                If you specify the <code class="option">--log-bin</code> option without
                                also specifying a
                                <a class="link" href="replication.html#option_mysqld_server-id"><code class="option">--server-id</code></a>, the server is
                                not allowed to start. (Bug #11763963, Bug #56739)
                            </p><p style="color:blue;">如果指定--log bin选项时不同时指定--server id，则不允许启动服务器。（错误11763963，错误56739）</p><p>
                                When GTIDs are in use on the server, if binary logging is
                                not enabled when restarting the server after an abnormal
                                shutdown, some GTIDs are likely to be lost, causing
                                replication to fail. In a normal shutdown, the set of GTIDs
                                from the current binary log file is saved in the
                                <code class="literal">mysql.gtid_executed</code> table. Following an
                                abnormal shutdown where this did not happen, during recovery
                                the GTIDs are added to the table from the binary log file,
                                provided that binary logging is still enabled. If binary
                                logging is disabled for the server restart, the server
                                cannot access the binary log file to recover the GTIDs, so
                                replication cannot be started. Binary logging can be
                                disabled safely after a normal shutdown.
                            </p><p style="color:blue;">在服务器上使用gtid时，如果在异常关机后重新启动服务器时未启用二进制日志记录，则可能会丢失某些gtid，从而导致复制失败。在正常关机时，当前二进制日志文件中的gtid集保存在mysql.gtid_executed表中。在没有发生这种情况的异常关闭之后，在恢复期间，gtid将从二进制日志文件添加到表中，前提是仍然启用了二进制日志记录。如果服务器重新启动时禁用了二进制日志记录，则服务器无法访问二进制日志文件以恢复gtid，因此无法启动复制。在正常关机后，可以安全地禁用二进制日志记录。</p></li><li class="listitem"><p><a name="option_mysqld_log-bin-index"></a>
                            <a class="indexterm" name="idm140286796798848"></a>

                            <a class="indexterm" name="idm140286796797360"></a>

                            <a class="link" href="replication.html#option_mysqld_log-bin-index"><code class="option">--log-bin-index[=<em class="replaceable"><code>file_name</code></em>]</code></a>
                        </p><p style="color:blue;">--日志箱索引[=文件名]</p>
                            <div class="informaltable">
                                <table frame="box" rules="all" summary="Properties for log-bin-index"><colgroup><col width="30%"><col width="70%"></colgroup><thead><tr><th scope="col">Property</th>
                                    <th scope="col">Value</th>
                                </tr></thead><tbody><tr><td scope="row"><span class="bold"><strong>Command-Line Format</strong></span></td>
                                    <td><code class="literal">--log-bin-index=file_name</code></td>
                                </tr><tr><td scope="row"><span class="bold"><strong>System Variable</strong></span></td>
                                    <td><code class="literal"><a class="link" href="replication.html#sysvar_log_bin_index">log_bin_index</a></code></td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Scope</strong></span></td>
                                    <td>Global</td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Dynamic</strong></span></td>
                                    <td>No</td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Type</strong></span></td>
                                    <td>File name</td>
                                </tr></tbody></table>
                            </div>
                            <p>
                                The name for the binary log index file, which contains the
                                names of the binary log files. By default, it has the same
                                location and base name as the value specified for the binary
                                log files using the <a class="link" href="replication.html#option_mysqld_log-bin"><code class="option">--log-bin</code></a>
                                option, plus the extension <code class="filename">.index</code>. If
                                you do not specify <a class="link" href="replication.html#option_mysqld_log-bin"><code class="option">--log-bin</code></a>,
                                the default binary log index file name is
                                <code class="filename">binlog.index</code>. If you omit the file name
                                and do not specify one with
                                <a class="link" href="replication.html#option_mysqld_log-bin"><code class="option">--log-bin</code></a>, the default binary
                                log index file name is
                                <code class="filename"><em class="replaceable"><code>host_name</code></em>-bin.index</code>,
                                using the name of the host machine.
                            </p><p style="color:blue;">二进制日志索引文件的名称，其中包含二进制日志文件的名称。默认情况下，它的位置和基名称与使用--log bin选项为二进制日志文件指定的值相同，加上扩展名.index。如果未指定--log bin，则默认的二进制日志索引文件名为binlog.index。如果省略文件名而不使用--log bin指定文件名，则默认的二进制日志索引文件名为host_name-bin.index，使用主机的名称。</p><p>
                                For information on the format and management of the binary
                                log, see <a class="xref" href="server-administration.html#binary-log" title="5.4.4&nbsp;The Binary Log">Section&nbsp;5.4.4, “The Binary Log”</a>.
                            </p><p style="color:blue;">有关二进制日志的格式和管理的信息，请参阅第5.4.4节“二进制日志”。</p></li></ul>
                    </div>
                    <p><b>Statement selection options.&nbsp;</b>
                        The options in the following list affect which statements are
                        written to the binary log, and thus sent by a replication
                        master server to its slaves. There are also options for slave
                        servers that control which statements received from the master
                        should be executed or ignored. For details, see
                        <a class="xref" href="replication.html#replication-options-slave" title="16.1.6.3&nbsp;Replication Slave Options and Variables">Section&nbsp;16.1.6.3, “Replication Slave Options and Variables”</a>.
                    </p><p style="color:blue;">语句选择选项。以下列表中的选项影响哪些语句被写入二进制日志，从而由复制主服务器发送到其从属服务器。对于从属服务器，还有一些选项可以控制从主服务器接收到的语句应该被执行或忽略。有关详细信息，请参阅第16.1.6.3节“复制从机选项和变量”。</p>
                    <div class="itemizedlist">
                        <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><a name="option_mysqld_binlog-do-db"></a>
                            <a class="indexterm" name="idm140286796762416"></a>

                            <a class="indexterm" name="idm140286796760928"></a>

                            <a class="link" href="replication.html#option_mysqld_binlog-do-db"><code class="option">--binlog-do-db=<em class="replaceable"><code>db_name</code></em></code></a>
                        </p><p style="color:blue;">--binlog do db=db_名称</p>
                            <div class="informaltable">
                                <table frame="box" rules="all" summary="Properties for binlog-do-db"><colgroup><col width="30%"><col width="70%"></colgroup><thead><tr><th scope="col">Property</th>
                                    <th scope="col">Value</th>
                                </tr></thead><tbody><tr><td scope="row"><span class="bold"><strong>Command-Line Format</strong></span></td>
                                    <td><code class="literal">--binlog-do-db=name</code></td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Type</strong></span></td>
                                    <td>String</td>
                                </tr></tbody></table>
                            </div>
                            <p>
                                This option affects binary logging in a manner similar to
                                the way that
                                <a class="link" href="replication.html#option_mysqld_replicate-do-db"><code class="option">--replicate-do-db</code></a> affects
                                replication.
                            </p><p style="color:blue;">此选项影响二进制日志记录的方式与replicate do db影响复制的方式类似。</p><p>
                                The effects of this option depend on whether the
                                statement-based or row-based logging format is in use, in
                                the same way that the effects of
                                <a class="link" href="replication.html#option_mysqld_replicate-do-db"><code class="option">--replicate-do-db</code></a> depend on
                                whether statement-based or row-based replication is in use.
                                You should keep in mind that the format used to log a given
                                statement may not necessarily be the same as that indicated
                                by the value of
                                <a class="link" href="replication.html#sysvar_binlog_format"><code class="literal">binlog_format</code></a>. For example,
                                DDL statements such as <a class="link" href="sql-syntax.html#create-table" title="13.1.18&nbsp;CREATE TABLE Syntax"><code class="literal">CREATE
                                TABLE</code></a> and <a class="link" href="sql-syntax.html#alter-table" title="13.1.8&nbsp;ALTER TABLE Syntax"><code class="literal">ALTER
                                TABLE</code></a> are always logged as statements, without
                                regard to the logging format in effect, so the following
                                statement-based rules for <code class="option">--binlog-do-db</code>
                                always apply in determining whether or not the statement is
                                logged.
                            </p><p style="color:blue;">此选项的效果取决于是否使用基于语句或基于行的日志记录格式，就像--replicate do db的效果取决于是否使用基于语句或基于行的复制一样。您应该记住，用于记录给定语句的格式不一定与binlog_format的值所指示的格式相同。例如，CREATE TABLE和ALTER TABLE等DDL语句始终作为语句记录，而不考虑实际的日志格式，因此--binlog do db的以下基于语句的规则始终适用于确定是否记录该语句。</p><p><b>Statement-based logging.&nbsp;</b>
                                Only those statements are written to the binary log where
                                the default database (that is, the one selected by
                                <a class="link" href="sql-syntax.html#use" title="13.8.4&nbsp;USE Syntax"><code class="literal">USE</code></a>) is
                                <em class="replaceable"><code>db_name</code></em>. To specify more than
                                one database, use this option multiple times, once for
                                each database; however, doing so does
                                <span class="emphasis"><em>not</em></span> cause cross-database statements
                                such as <code class="literal">UPDATE
                                    <em class="replaceable"><code>some_db.some_table</code></em> SET
                                    foo='bar'</code> to be logged while a different
                                database (or no database) is selected.
                            </p><p style="color:blue;">基于语句的日志记录。只有这些语句才会写入二进制日志，其中默认数据库（即通过使用选择的数据库）是db_name。若要指定多个数据库，请多次使用此选项，对每个数据库使用一次；但是，这样做不会导致跨数据库语句（如update some_db.some_table set foo='bar'）被记录，同时选择其他数据库（或不选择数据库）。</p>
                            <div class="warning" style="margin-left: 0.5in; margin-right: 0.5in;">

                                <div class="admon-title">
                                    Warning
                                </div>
                                <p>
                                    To specify multiple databases you
                                    <span class="emphasis"><em>must</em></span> use multiple instances of this
                                    option. Because database names can contain commas, the
                                    list will be treated as the name of a single database if
                                    you supply a comma-separated list.
                                </p><p style="color:blue;">若要指定多个数据库，必须使用此选项的多个实例。由于数据库名称可以包含逗号，如果提供逗号分隔的列表，则该列表将被视为单个数据库的名称。</p>
                            </div>
                            <p>
                                An example of what does not work as you might expect when
                                using statement-based logging: If the server is started with
                                <a class="link" href="replication.html#option_mysqld_binlog-do-db"><code class="option">--binlog-do-db=sales</code></a> and you
                                issue the following statements, the
                                <a class="link" href="sql-syntax.html#update" title="13.2.11&nbsp;UPDATE Syntax"><code class="literal">UPDATE</code></a> statement is
                                <span class="emphasis"><em>not</em></span> logged:
                            </p><p style="color:blue;">使用基于语句的日志记录时可能无法正常工作的一个示例：如果服务器以--binlog do db=sales启动并发出以下语句，则不会记录update语句：</p><pre data-lang="sql" class="programlisting">USE prices;
UPDATE sales.january SET amount=amount+1000;
</pre><p>
                                The main reason for this <span class="quote">“<span class="quote">just check the default
            database</span>”</span> behavior is that it is difficult from the
                                statement alone to know whether it should be replicated (for
                                example, if you are using multiple-table
                                <a class="link" href="sql-syntax.html#delete" title="13.2.2&nbsp;DELETE Syntax"><code class="literal">DELETE</code></a> statements or
                                multiple-table <a class="link" href="sql-syntax.html#update" title="13.2.11&nbsp;UPDATE Syntax"><code class="literal">UPDATE</code></a>
                                statements that act across multiple databases). It is also
                                faster to check only the default database rather than all
                                databases if there is no need.
                            </p><p style="color:blue;">这种“只检查默认数据库”行为的主要原因是，仅从语句很难知道是否应该复制它（例如，如果使用多个表删除语句或跨多个数据库执行的多个表更新语句）。如果不需要，只检查默认数据库比检查所有数据库更快。</p><p>
                                Another case which may not be self-evident occurs when a
                                given database is replicated even though it was not
                                specified when setting the option. If the server is started
                                with <code class="option">--binlog-do-db=sales</code>, the following
                                <a class="link" href="sql-syntax.html#update" title="13.2.11&nbsp;UPDATE Syntax"><code class="literal">UPDATE</code></a> statement is logged
                                even though <code class="literal">prices</code> was not included when
                                setting <code class="option">--binlog-do-db</code>:
                            </p><p style="color:blue;">另一种可能并非不言而喻的情况发生在复制给定数据库时，即使在设置选项时未指定该数据库。如果服务器以--binlog do db=sales启动，则即使在设置--binlog do db时未包含价格，也会记录以下更新语句：</p><pre data-lang="sql" class="programlisting">
USE sales;
UPDATE prices.discounts SET percentage = percentage + 10;
</pre><p>
                                Because <code class="literal">sales</code> is the default database
                                when the <a class="link" href="sql-syntax.html#update" title="13.2.11&nbsp;UPDATE Syntax"><code class="literal">UPDATE</code></a> statement is
                                issued, the <a class="link" href="sql-syntax.html#update" title="13.2.11&nbsp;UPDATE Syntax"><code class="literal">UPDATE</code></a> is logged.
                            </p><p style="color:blue;">因为发出update语句时sales是默认数据库，所以会记录更新。</p><p><b>Row-based logging.&nbsp;</b>
                                Logging is restricted to database
                                <em class="replaceable"><code>db_name</code></em>. Only changes to tables
                                belonging to <em class="replaceable"><code>db_name</code></em> are
                                logged; the default database has no effect on this.
                                Suppose that the server is started with
                                <a class="link" href="replication.html#option_mysqld_binlog-do-db"><code class="option">--binlog-do-db=sales</code></a> and
                                row-based logging is in effect, and then the following
                                statements are executed:
                            </p><p style="color:blue;">基于行的日志记录。日志记录仅限于数据库数据库数据库名称。只记录对属于db_name的表的更改；默认数据库对此没有影响。假设服务器以--binlog do db=sales启动，并且基于行的日志记录生效，然后执行以下语句：</p><pre data-lang="sql" class="programlisting">USE prices;
UPDATE sales.february SET amount=amount+100;
</pre><p>
                                The changes to the <code class="literal">february</code> table in the
                                <code class="literal">sales</code> database are logged in accordance
                                with the <a class="link" href="sql-syntax.html#update" title="13.2.11&nbsp;UPDATE Syntax"><code class="literal">UPDATE</code></a> statement;
                                this occurs whether or not the
                                <a class="link" href="sql-syntax.html#use" title="13.8.4&nbsp;USE Syntax"><code class="literal">USE</code></a> statement was issued.
                                However, when using the row-based logging format and
                                <a class="link" href="replication.html#option_mysqld_binlog-do-db"><code class="option">--binlog-do-db=sales</code></a>, changes
                                made by the following <a class="link" href="sql-syntax.html#update" title="13.2.11&nbsp;UPDATE Syntax"><code class="literal">UPDATE</code></a>
                                are not logged:
                            </p><p style="color:blue;">sales数据库中二月表的更改是根据update语句记录的；无论use语句是否发出，都会发生这种情况。但是，当使用基于行的日志格式和--binlog do db=sales时，不会记录以下更新所做的更改：</p><pre data-lang="sql" class="programlisting">USE prices;
UPDATE prices.march SET amount=amount-25;
</pre><p>
                                Even if the <code class="literal">USE prices</code> statement were
                                changed to <code class="literal">USE sales</code>, the
                                <a class="link" href="sql-syntax.html#update" title="13.2.11&nbsp;UPDATE Syntax"><code class="literal">UPDATE</code></a> statement's
                                effects would still not be written to the binary log.
                            </p><p style="color:blue;">即使use prices语句更改为use sales，update语句的效果也不会写入二进制日志。</p><p>
                                Another important difference in
                                <a class="link" href="replication.html#option_mysqld_binlog-do-db"><code class="option">--binlog-do-db</code></a> handling for
                                statement-based logging as opposed to the row-based logging
                                occurs with regard to statements that refer to multiple
                                databases. Suppose that the server is started with
                                <a class="link" href="replication.html#option_mysqld_binlog-do-db"><code class="option">--binlog-do-db=db1</code></a>, and the
                                following statements are executed:
                            </p><p style="color:blue;">对于引用多个数据库的语句，基于语句日志记录的binlog do db处理与基于行日志记录的binlog do db处理有另一个重要区别。假设服务器以--binlog do db=db1启动，并执行以下语句：</p><pre data-lang="sql" class="programlisting">USE db1;
UPDATE db1.table1 SET col1 = 10, db2.table2 SET col2 = 20;
</pre><p>
                                If you are using statement-based logging, the updates to
                                both tables are written to the binary log. However, when
                                using the row-based format, only the changes to
                                <code class="literal">table1</code> are logged;
                                <code class="literal">table2</code> is in a different database, so it
                                is not changed by the <a class="link" href="sql-syntax.html#update" title="13.2.11&nbsp;UPDATE Syntax"><code class="literal">UPDATE</code></a>.
                                Now suppose that, instead of the <code class="literal">USE db1</code>
                                statement, a <code class="literal">USE db4</code> statement had been
                                used:
                            </p><p style="color:blue;">如果使用基于语句的日志记录，则对两个表的更新都将写入二进制日志。但是，当使用基于行的格式时，只记录对table1的更改；table2在不同的数据库中，因此更新不会更改它。现在假设使用了use db4语句，而不是use db1语句：</p><pre data-lang="sql" class="programlisting">USE db4;
UPDATE db1.table1 SET col1 = 10, db2.table2 SET col2 = 20;
</pre><p>
                                In this case, the <a class="link" href="sql-syntax.html#update" title="13.2.11&nbsp;UPDATE Syntax"><code class="literal">UPDATE</code></a>
                                statement is not written to the binary log when using
                                statement-based logging. However, when using row-based
                                logging, the change to <code class="literal">table1</code> is logged,
                                but not that to <code class="literal">table2</code>—in other
                                words, only changes to tables in the database named by
                                <a class="link" href="replication.html#option_mysqld_binlog-do-db"><code class="option">--binlog-do-db</code></a> are logged,
                                and the choice of default database has no effect on this
                                behavior.
                            </p><p style="color:blue;">在这种情况下，当使用基于语句的日志记录时，update语句不会写入二进制日志。但是，当使用基于行的日志记录时，将记录对table1的更改，而不是对table2的更改换句话说，只记录对数据库中名为--binlog do db的表的更改，并且默认数据库的选择对此行为没有影响。</p></li><li class="listitem"><p><a name="option_mysqld_binlog-ignore-db"></a>
                            <a class="indexterm" name="idm140286796685680"></a>

                            <a class="indexterm" name="idm140286796684192"></a>

                            <a class="link" href="replication.html#option_mysqld_binlog-ignore-db"><code class="option">--binlog-ignore-db=<em class="replaceable"><code>db_name</code></em></code></a>
                        </p><p style="color:blue;">--binlog ignore db=db_名称</p>
                            <div class="informaltable">
                                <table frame="box" rules="all" summary="Properties for binlog-ignore-db"><colgroup><col width="30%"><col width="70%"></colgroup><thead><tr><th scope="col">Property</th>
                                    <th scope="col">Value</th>
                                </tr></thead><tbody><tr><td scope="row"><span class="bold"><strong>Command-Line Format</strong></span></td>
                                    <td><code class="literal">--binlog-ignore-db=name</code></td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Type</strong></span></td>
                                    <td>String</td>
                                </tr></tbody></table>
                            </div>
                            <p>
                                This option affects binary logging in a manner similar to
                                the way that
                                <a class="link" href="replication.html#option_mysqld_replicate-ignore-db"><code class="option">--replicate-ignore-db</code></a> affects
                                replication.
                            </p><p style="color:blue;">此选项影响二进制日志记录的方式与--replicate ignore db影响复制的方式类似。</p><p>
                                The effects of this option depend on whether the
                                statement-based or row-based logging format is in use, in
                                the same way that the effects of
                                <a class="link" href="replication.html#option_mysqld_replicate-ignore-db"><code class="option">--replicate-ignore-db</code></a> depend
                                on whether statement-based or row-based replication is in
                                use. You should keep in mind that the format used to log a
                                given statement may not necessarily be the same as that
                                indicated by the value of
                                <a class="link" href="replication.html#sysvar_binlog_format"><code class="literal">binlog_format</code></a>. For example,
                                DDL statements such as <a class="link" href="sql-syntax.html#create-table" title="13.1.18&nbsp;CREATE TABLE Syntax"><code class="literal">CREATE
                                TABLE</code></a> and <a class="link" href="sql-syntax.html#alter-table" title="13.1.8&nbsp;ALTER TABLE Syntax"><code class="literal">ALTER
                                TABLE</code></a> are always logged as statements, without
                                regard to the logging format in effect, so the following
                                statement-based rules for
                                <code class="option">--binlog-ignore-db</code> always apply in
                                determining whether or not the statement is logged.
                            </p><p style="color:blue;">此选项的效果取决于是否使用基于语句或基于行的日志记录格式，就像--replicate ignore db的效果取决于是否使用基于语句或基于行的复制一样。您应该记住，用于记录给定语句的格式不一定与binlog_format的值所指示的格式相同。例如，CREATE TABLE和ALTER TABLE等DDL语句始终作为语句记录，而不考虑实际的日志格式，因此--binlog ignore db的以下基于语句的规则始终适用于确定是否记录该语句。</p><p><b>Statement-based logging.&nbsp;</b>
                                Tells the server to not log any statement where the
                                default database (that is, the one selected by
                                <a class="link" href="sql-syntax.html#use" title="13.8.4&nbsp;USE Syntax"><code class="literal">USE</code></a>) is
                                <em class="replaceable"><code>db_name</code></em>.
                            </p><p style="color:blue;">基于语句的日志记录。告诉服务器不要记录默认数据库（即通过使用选择的数据库）为db_name的任何语句。</p><p>
                                Prior to MySQL 5.7.2, this option caused any statements
                                containing fully qualified table names not to be logged if
                                there was no default database specified (that is, when
                                <a class="link" href="sql-syntax.html#select" title="13.2.9&nbsp;SELECT Syntax"><code class="literal">SELECT</code></a>
                                <a class="link" href="functions.html#function_database"><code class="literal">DATABASE()</code></a> returned
                                <code class="literal">NULL</code>). In MySQL 5.7.2 and later, when
                                there is no default database, no
                                <code class="option">--binlog-ignore-db</code> options are applied, and
                                such statements are always logged. (Bug #11829838, Bug
                                #60188)
                            </p><p style="color:blue;">在mysql 5.7.2之前，如果没有指定默认数据库（即，当select database（）返回空值时），此选项会导致不记录任何包含完全限定表名的语句。在mysql 5.7.2及更高版本中，如果没有默认数据库，则应用no--binlog ignore db选项，并且始终记录此类语句。（错误11829838，错误60188）</p><p><b>Row-based format.&nbsp;</b>
                                Tells the server not to log updates to any tables in the
                                database <em class="replaceable"><code>db_name</code></em>. The current
                                database has no effect.
                            </p><p style="color:blue;">基于行的格式。告诉服务器不要将更新记录到数据库数据库名称中的任何表。当前数据库无效。</p><p>
                                When using statement-based logging, the following example
                                does not work as you might expect. Suppose that the server
                                is started with
                                <a class="link" href="replication.html#option_mysqld_binlog-ignore-db"><code class="option">--binlog-ignore-db=sales</code></a> and
                                you issue the following statements:
                            </p><p style="color:blue;">当使用基于语句的日志记录时，以下示例可能无法正常工作。假设服务器以--binlog ignore db=sales启动，并发出以下语句：</p><pre data-lang="sql" class="programlisting">USE prices;
UPDATE sales.january SET amount=amount+1000;
</pre><p>
                                The <a class="link" href="sql-syntax.html#update" title="13.2.11&nbsp;UPDATE Syntax"><code class="literal">UPDATE</code></a> statement
                                <span class="emphasis"><em>is</em></span> logged in such a case because
                                <a class="link" href="replication.html#option_mysqld_binlog-ignore-db"><code class="option">--binlog-ignore-db</code></a> applies
                                only to the default database (determined by the
                                <a class="link" href="sql-syntax.html#use" title="13.8.4&nbsp;USE Syntax"><code class="literal">USE</code></a> statement). Because the
                                <code class="literal">sales</code> database was specified explicitly
                                in the statement, the statement has not been filtered.
                                However, when using row-based logging, the
                                <a class="link" href="sql-syntax.html#update" title="13.2.11&nbsp;UPDATE Syntax"><code class="literal">UPDATE</code></a> statement's
                                effects are <span class="emphasis"><em>not</em></span> written to the binary
                                log, which means that no changes to the
                                <code class="literal">sales.january</code> table are logged; in this
                                instance,
                                <a class="link" href="replication.html#option_mysqld_binlog-ignore-db"><code class="option">--binlog-ignore-db=sales</code></a>
                                causes <span class="emphasis"><em>all</em></span> changes made to tables in
                                the master's copy of the <code class="literal">sales</code>
                                database to be ignored for purposes of binary logging.
                            </p><p style="color:blue;">在这种情况下记录update语句是因为--binlog ignore db只应用于默认数据库（由use语句确定）。由于在语句中显式指定了sales数据库，因此尚未筛选该语句。但是，当使用基于行的日志记录时，update语句的效果不会写入二进制日志，这意味着不会记录对sales.january表的任何更改；在本例中，-binlog ignore db=sales会导致出于二进制日志记录的目的而忽略对sales数据库主副本中的表所做的所有更改。</p><p>
                                To specify more than one database to ignore, use this option
                                multiple times, once for each database. Because database
                                names can contain commas, the list will be treated as the
                                name of a single database if you supply a comma-separated
                                list.
                            </p><p style="color:blue;">要指定要忽略的多个数据库，请多次使用此选项，每个数据库一次。由于数据库名称可以包含逗号，如果提供逗号分隔的列表，则该列表将被视为单个数据库的名称。</p><p>
                                You should not use this option if you are using
                                cross-database updates and you do not want these updates to
                                be logged.
                            </p><p style="color:blue;">如果正在使用跨数据库更新，并且不希望记录这些更新，则不应使用此选项。</p></li></ul>
                    </div>
                    <p><a name="replication-optvars-binlog-checksums"></a><b>Checksum options.&nbsp;</b>
                        MySQL supports reading and writing of binary log checksums.
                        These are enabled using the two options listed here:
                    </p><p style="color:blue;">校验和选项。mysql支持二进制日志校验和的读写。使用下面列出的两个选项启用这些选项：</p>
                    <div class="itemizedlist">
                        <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><a name="option_mysqld_binlog-checksum"></a>
                            <a class="indexterm" name="idm140286796635488"></a>

                            <a class="indexterm" name="idm140286796634000"></a>

                            <a class="link" href="replication.html#option_mysqld_binlog-checksum"><code class="option">--binlog-checksum={NONE|CRC32}</code></a>
                        </p><p style="color:blue;">--binlog校验和={无crc32}</p>
                            <div class="informaltable">
                                <table frame="box" rules="all" summary="Properties for binlog-checksum"><colgroup><col width="30%"><col width="70%"></colgroup><thead><tr><th scope="col">Property</th>
                                    <th scope="col">Value</th>
                                </tr></thead><tbody><tr><td scope="row"><span class="bold"><strong>Command-Line Format</strong></span></td>
                                    <td><code class="literal">--binlog-checksum=type</code></td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Type</strong></span></td>
                                    <td>String</td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Default Value</strong></span></td>
                                    <td><code class="literal">CRC32</code></td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Valid Values</strong></span></td>
                                    <td><p class="valid-value"><code class="literal">NONE</code></p><p style="color:blue;">无</p><p class="valid-value"><code class="literal">CRC32</code></p><p style="color:blue;">CRC32型</p></td>
                                </tr></tbody></table>
                            </div>
                            <p>
                                Enabling this option causes the master to write checksums
                                for events written to the binary log. Set to
                                <code class="literal">NONE</code> to disable, or the name of the
                                algorithm to be used for generating checksums; currently,
                                only CRC32 checksums are supported, and CRC32 is the
                                default. You cannot change the setting for this option
                                within a transaction.
                            </p><p style="color:blue;">启用此选项将导致主机为写入二进制日志的事件写入校验和。设置为“无”将禁用，或用于生成校验和的算法的名称；当前，仅支持CRC32校验和，默认为CRC32。不能在事务中更改此选项的设置。</p></li><li class="listitem"><p><a name="option_mysqld_master-verify-checksum"></a>
                            <a class="indexterm" name="idm140286796609552"></a>

                            <a class="indexterm" name="idm140286796608096"></a>

                            <a class="link" href="replication.html#option_mysqld_master-verify-checksum"><code class="option">--master-verify-checksum={0|1}</code></a>
                        </p><p style="color:blue;">--主验证校验和={0 1}</p>
                            <div class="informaltable">
                                <table frame="box" rules="all" summary="Properties for master-verify-checksum"><colgroup><col width="30%"><col width="70%"></colgroup><thead><tr><th scope="col">Property</th>
                                    <th scope="col">Value</th>
                                </tr></thead><tbody><tr><td scope="row"><span class="bold"><strong>Command-Line Format</strong></span></td>
                                    <td><code class="literal">--master-verify-checksum[={OFF|ON}]</code></td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Type</strong></span></td>
                                    <td>Boolean</td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Default Value</strong></span></td>
                                    <td><code class="literal">OFF</code></td>
                                </tr></tbody></table>
                            </div>
                            <p>
                                Enabling this option causes the master to verify events from
                                the binary log using checksums, and to stop with an error in
                                the event of a mismatch. Disabled by default.
                            </p><p style="color:blue;">启用此选项将导致主机使用校验和验证二进制日志中的事件，并在不匹配的情况下因错误而停止。默认情况下禁用。</p></li></ul>
                    </div>
                    <p>
                        To control reading of checksums by the slave (from the relay)
                        log, use the
                        <a class="link" href="replication.html#option_mysqld_slave-sql-verify-checksum"><code class="option">--slave-sql-verify-checksum</code></a>
                        option.
                    </p><p style="color:blue;">要控制从（从中继）日志读取校验和，请使用--slave sql verify checksum选项。</p><p><b>Testing and debugging options.&nbsp;</b>
                    The following binary log options are used in replication
                    testing and debugging. They are not intended for use in normal
                    operations.
                </p><p style="color:blue;">测试和调试选项。以下二进制日志选项用于复制测试和调试。它们不打算在正常操作中使用。</p>
                    <div class="itemizedlist">
                        <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><a name="option_mysqld_max-binlog-dump-events"></a>
                            <a class="indexterm" name="idm140286796584944"></a>

                            <a class="indexterm" name="idm140286796583488"></a>

                            <a class="link" href="replication.html#option_mysqld_max-binlog-dump-events"><code class="option">--max-binlog-dump-events=<em class="replaceable"><code>N</code></em></code></a>
                        </p><p style="color:blue;">--最大binlog转储事件数=n</p>
                            <div class="informaltable">
                                <table frame="box" rules="all" summary="Properties for max-binlog-dump-events"><colgroup><col width="30%"><col width="70%"></colgroup><thead><tr><th scope="col">Property</th>
                                    <th scope="col">Value</th>
                                </tr></thead><tbody><tr><td scope="row"><span class="bold"><strong>Command-Line Format</strong></span></td>
                                    <td><code class="literal">--max-binlog-dump-events=#</code></td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Type</strong></span></td>
                                    <td>Integer</td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Default Value</strong></span></td>
                                    <td><code class="literal">0</code></td>
                                </tr></tbody></table>
                            </div>
                            <p>
                                This option is used internally by the MySQL test suite for
                                replication testing and debugging.
                            </p><p style="color:blue;">mysql测试套件在内部使用此选项进行复制测试和调试。</p></li><li class="listitem"><p><a name="option_mysqld_sporadic-binlog-dump-fail"></a>
                            <a class="indexterm" name="idm140286796564176"></a>

                            <a class="indexterm" name="idm140286796562720"></a>

                            <a class="link" href="replication.html#option_mysqld_sporadic-binlog-dump-fail"><code class="option">--sporadic-binlog-dump-fail</code></a>
                        </p><p style="color:blue;">--零星binlog转储失败</p>
                            <div class="informaltable">
                                <table frame="box" rules="all" summary="Properties for sporadic-binlog-dump-fail"><colgroup><col width="30%"><col width="70%"></colgroup><thead><tr><th scope="col">Property</th>
                                    <th scope="col">Value</th>
                                </tr></thead><tbody><tr><td scope="row"><span class="bold"><strong>Command-Line Format</strong></span></td>
                                    <td><code class="literal">--sporadic-binlog-dump-fail[={OFF|ON}]</code></td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Type</strong></span></td>
                                    <td>Boolean</td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Default Value</strong></span></td>
                                    <td><code class="literal">OFF</code></td>
                                </tr></tbody></table>
                            </div>
                            <p>
                                This option is used internally by the MySQL test suite for
                                replication testing and debugging.
                            </p><p style="color:blue;">mysql测试套件在内部使用此选项进行复制测试和调试。</p></li></ul>
                    </div>

                </div>
                <div class="simplesect">
                    <div class="titlepage">
                        <div>
                            <div class="simple">
                                <h5 class="title"><a name="replication-sysvars-binlog"></a>System Variables Used with Binary Logging</h5>

                            </div>

                        </div>

                    </div>
                    <p>
                        The following list describes system variables for controlling
                        binary logging. They can be set at server startup and some of
                        them can be changed at runtime using
                        <a class="link" href="sql-syntax.html#set-variable" title="13.7.4.1&nbsp;SET Syntax for Variable Assignment"><code class="literal">SET</code></a>.
                        Server options used to control binary logging are listed earlier
                        in this section.
                    </p><p style="color:blue;">下表描述了用于控制二进制日志记录的系统变量。它们可以在服务器启动时设置，其中一些可以在运行时使用set进行更改。本节前面列出了用于控制二进制日志记录的服务器选项。</p>
                    <div class="itemizedlist">
                        <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><a name="sysvar_binlog_cache_size"></a>
                            <a class="indexterm" name="idm140286796540080"></a>

                            <a class="indexterm" name="idm140286796539040"></a>

                            <a class="link" href="replication.html#sysvar_binlog_cache_size"><code class="literal">binlog_cache_size</code></a>
                        </p><p style="color:blue;">binlog_缓存大小</p>
                            <div class="informaltable">
                                <table frame="box" rules="all" summary="Properties for binlog_cache_size"><colgroup><col width="30%"><col width="70%"></colgroup><thead><tr><th scope="col">Property</th>
                                    <th scope="col">Value</th>
                                </tr></thead><tbody><tr><td scope="row"><span class="bold"><strong>Command-Line Format</strong></span></td>
                                    <td><code class="literal">--binlog-cache-size=#</code></td>
                                </tr><tr><td scope="row"><span class="bold"><strong>System Variable</strong></span></td>
                                    <td><code class="literal"><a class="link" href="replication.html#sysvar_binlog_cache_size">binlog_cache_size</a></code></td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Scope</strong></span></td>
                                    <td>Global</td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Dynamic</strong></span></td>
                                    <td>Yes</td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Type</strong></span></td>
                                    <td>Integer</td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Default Value</strong></span></td>
                                    <td><code class="literal">32768</code></td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Minimum Value</strong></span></td>
                                    <td><code class="literal">4096</code></td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Maximum Value</strong></span> (64-bit platforms)</td>
                                    <td><code class="literal">18446744073709551615</code></td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Maximum Value</strong></span> (32-bit platforms)</td>
                                    <td><code class="literal">4294967295</code></td>
                                </tr></tbody></table>
                            </div>
                            <p>
                                The size of the cache to hold changes to the binary log
                                during a transaction. A binary log cache is allocated for
                                each client if the server supports any transactional storage
                                engines and if the server has the binary log enabled
                                (<a class="link" href="replication.html#option_mysqld_log-bin"><code class="option">--log-bin</code></a> option). If you
                                often use large transactions, you can increase this cache
                                size to get better performance. The
                                <a class="link" href="server-administration.html#statvar_Binlog_cache_use"><code class="literal">Binlog_cache_use</code></a> and
                                <a class="link" href="server-administration.html#statvar_Binlog_cache_disk_use"><code class="literal">Binlog_cache_disk_use</code></a>
                                status variables can be useful for tuning the size of this
                                variable. See <a class="xref" href="server-administration.html#binary-log" title="5.4.4&nbsp;The Binary Log">Section&nbsp;5.4.4, “The Binary Log”</a>.
                            </p><p style="color:blue;">在事务期间保存对二进制日志更改的缓存大小。如果服务器支持任何事务性存储引擎，并且服务器启用了二进制日志（--log bin选项），则为每个客户端分配一个二进制日志缓存。如果您经常使用大型事务，可以增加此缓存大小以获得更好的性能。binlog_cache_use和binlog_cache_disk_use状态变量可用于调整此变量的大小。见第5.4.4节“二进制日志”。</p><p>
                                <code class="literal">binlog_cache_size</code> sets the size for the
                                transaction cache only; the size of the statement cache is
                                governed by the
                                <a class="link" href="replication.html#sysvar_binlog_stmt_cache_size"><code class="literal">binlog_stmt_cache_size</code></a>
                                system variable.
                            </p><p style="color:blue;">binlog_cache_size仅设置事务缓存的大小；语句缓存的大小由binlog_stmt_cache_size系统变量控制。</p></li><li class="listitem"><p><a name="sysvar_binlog_checksum"></a>
                            <a class="indexterm" name="idm140286796494128"></a>

                            <a class="indexterm" name="idm140286796493120"></a>

                            <a class="link" href="replication.html#sysvar_binlog_checksum"><code class="literal">binlog_checksum</code></a>
                        </p><p style="color:blue;">binlog_校验和</p>
                            <div class="informaltable">
                                <table frame="box" rules="all" summary="Properties for binlog_checksum"><colgroup><col width="30%"><col width="70%"></colgroup><thead><tr><th scope="col">Property</th>
                                    <th scope="col">Value</th>
                                </tr></thead><tbody><tr><td scope="row"><span class="bold"><strong>Command-Line Format</strong></span></td>
                                    <td><code class="literal">--binlog-checksum=name</code></td>
                                </tr><tr><td scope="row"><span class="bold"><strong>System Variable</strong></span></td>
                                    <td><code class="literal"><a class="link" href="replication.html#sysvar_binlog_checksum">binlog_checksum</a></code></td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Scope</strong></span></td>
                                    <td>Global</td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Dynamic</strong></span></td>
                                    <td>Yes</td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Type</strong></span></td>
                                    <td>String</td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Default Value</strong></span></td>
                                    <td><code class="literal">CRC32</code></td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Valid Values</strong></span></td>
                                    <td><p class="valid-value"><code class="literal">NONE</code></p><p style="color:blue;">无</p><p class="valid-value"><code class="literal">CRC32</code></p><p style="color:blue;">CRC32型</p></td>
                                </tr></tbody></table>
                            </div>
                            <p>
                                When enabled, this variable causes the master to write a
                                checksum for each event in the binary log.
                                <code class="literal">binlog_checksum</code> supports the values
                                <code class="literal">NONE</code> (disabled) and
                                <code class="literal">CRC32</code>. The default is
                                <code class="literal">CRC32</code>. You cannot change the value of
                                <code class="literal">binlog_checksum</code> within a transaction.
                            </p><p style="color:blue;">启用时，此变量会导致主机为二进制日志中的每个事件写入校验和。binlog_校验和支持值none（disabled）和crc32。默认为CRC32。不能在事务中更改binlog_校验和的值。</p><p>
                                When <code class="literal">binlog_checksum</code> is disabled (value
                                <code class="literal">NONE</code>), the server verifies that it is
                                writing only complete events to the binary log by writing
                                and checking the event length (rather than a checksum) for
                                each event.
                            </p><p style="color:blue;">当binlog_校验和被禁用（值为none）时，服务器通过写入并检查每个事件的事件长度（而不是校验和）来验证它是否只将完整的事件写入二进制日志。</p><p>
                                Changing the value of this variable causes the binary log to
                                be rotated; checksums are always written to an entire binary
                                log file, and never to only part of one.
                            </p><p style="color:blue;">更改此变量的值将导致二进制日志旋转；校验和始终写入整个二进制日志文件，而不只是其中的一部分。</p><p>
                                Setting this variable on the master to a value unrecognized
                                by the slave causes the slave to set its own
                                <code class="literal">binlog_checksum</code> value to
                                <code class="literal">NONE</code>, and to stop replication with an
                                error. (Bug #13553750, Bug #61096) If backward compatibility
                                with older slaves is a concern, you may want to set the
                                value explicitly to <code class="literal">NONE</code>.
                            </p><p style="color:blue;">将主服务器上的此变量设置为从属服务器无法识别的值，将导致从属服务器将其自身的binlog_校验和值设置为none，并因错误而停止复制。（Bug 13553750，Bug 61096）如果担心与旧的从机的向后兼容性，则可能需要将该值显式设置为None。</p></li><li class="listitem"><p><a name="sysvar_binlog_direct_non_transactional_updates"></a>
                            <a class="indexterm" name="idm140286796451120"></a>

                            <a class="indexterm" name="idm140286796450080"></a>

                            <a class="link" href="replication.html#sysvar_binlog_direct_non_transactional_updates"><code class="literal">binlog_direct_non_transactional_updates</code></a>
                        </p><p style="color:blue;">binlog_direct_non_transactional_更新</p>
                            <div class="informaltable">
                                <table frame="box" rules="all" summary="Properties for binlog_direct_non_transactional_updates"><colgroup><col width="30%"><col width="70%"></colgroup><thead><tr><th scope="col">Property</th>
                                    <th scope="col">Value</th>
                                </tr></thead><tbody><tr><td scope="row"><span class="bold"><strong>Command-Line Format</strong></span></td>
                                    <td><code class="literal">--binlog-direct-non-transactional-updates[={OFF|ON}]</code></td>
                                </tr><tr><td scope="row"><span class="bold"><strong>System Variable</strong></span></td>
                                    <td><code class="literal"><a class="link" href="replication.html#sysvar_binlog_direct_non_transactional_updates">binlog_direct_non_transactional_updates</a></code></td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Scope</strong></span></td>
                                    <td>Global, Session</td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Dynamic</strong></span></td>
                                    <td>Yes</td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Type</strong></span></td>
                                    <td>Boolean</td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Default Value</strong></span></td>
                                    <td><code class="literal">OFF</code></td>
                                </tr></tbody></table>
                            </div>
                            <p>
                                Due to concurrency issues, a slave can become inconsistent
                                when a transaction contains updates to both transactional
                                and nontransactional tables. MySQL tries to preserve
                                causality among these statements by writing nontransactional
                                statements to the transaction cache, which is flushed upon
                                commit. However, problems arise when modifications done to
                                nontransactional tables on behalf of a transaction become
                                immediately visible to other connections because these
                                changes may not be written immediately into the binary log.
                            </p><p style="color:blue;">由于并发问题，当事务包含对事务表和非事务表的更新时，从表可能会变得不一致。mysql试图通过将非事务语句写入事务缓存（提交时刷新）来保留这些语句之间的因果关系。但是，当对代表事务的非事务表所做的修改立即对其他连接可见时，就会出现问题，因为这些更改可能不会立即写入二进制日志。</p><p>
                                The
                                <a class="link" href="replication.html#sysvar_binlog_direct_non_transactional_updates"><code class="literal">binlog_direct_non_transactional_updates</code></a>
                                variable offers one possible workaround to this issue. By
                                default, this variable is disabled. Enabling
                                <a class="link" href="replication.html#sysvar_binlog_direct_non_transactional_updates"><code class="literal">binlog_direct_non_transactional_updates</code></a>
                                causes updates to nontransactional tables to be written
                                directly to the binary log, rather than to the transaction
                                cache.
                            </p><p style="color:blue;">binlog_direct_non_transactional_updates变量提供了解决此问题的一种可能方法。默认情况下，此变量被禁用。启用binlog_direct_non_transactional_updates会导致对非事务表的更新直接写入二进制日志，而不是写入事务缓存。</p><p>
            <span class="emphasis"><em><a class="link" href="replication.html#sysvar_binlog_direct_non_transactional_updates"><code class="literal">binlog_direct_non_transactional_updates</code></a>
            works only for statements that are replicated using the
            statement-based binary logging format</em></span>; that is,
                                it works only when the value of
                                <a class="link" href="replication.html#sysvar_binlog_format"><code class="literal">binlog_format</code></a> is
                                <code class="literal">STATEMENT</code>, or when
                                <a class="link" href="replication.html#sysvar_binlog_format"><code class="literal">binlog_format</code></a> is
                                <code class="literal">MIXED</code> and a given statement is being
                                replicated using the statement-based format. This variable
                                has no effect when the binary log format is
                                <code class="literal">ROW</code>, or when
                                <a class="link" href="replication.html#sysvar_binlog_format"><code class="literal">binlog_format</code></a> is set to
                                <code class="literal">MIXED</code> and a given statement is replicated
                                using the row-based format.
                            </p><p style="color:blue;">binlog_direct_non_transactional_updates仅适用于使用基于语句的二进制日志格式复制的语句；也就是说，它仅在binlog_format的值为statement或binlog_format是mixed且使用基于语句的格式复制给定语句时工作。当二进制日志格式为row，或者binlog_format设置为mixed，并且使用基于行的格式复制给定语句时，此变量无效。</p>
                            <div class="important" style="margin-left: 0.5in; margin-right: 0.5in;">

                                <div class="admon-title">
                                    Important
                                </div>
                                <p>
                                    Before enabling this variable, you must make certain that
                                    there are no dependencies between transactional and
                                    nontransactional tables; an example of such a dependency
                                    would be the statement <code class="literal">INSERT INTO myisam_table
                                    SELECT * FROM innodb_table</code>. Otherwise, such
                                    statements are likely to cause the slave to diverge from
                                    the master.
                                </p><p style="color:blue;">在启用此变量之前，必须确保事务表和非事务表之间不存在依赖关系；这种依赖关系的一个例子是从innodb_table插入myisam_table select*语句。否则，这些语句可能会导致从机与主机分离。</p>
                            </div>
                            <p>
                                This variable has no effect when the binary log format is
                                <code class="literal">ROW</code> or <code class="literal">MIXED</code>.
                            </p><p style="color:blue;">当二进制日志格式为row或mixed时，此变量不起作用。</p></li><li class="listitem"><p><a name="sysvar_binlog_error_action"></a>
                            <a class="indexterm" name="idm140286796405120"></a>

                            <a class="indexterm" name="idm140286796404080"></a>

                            <a class="link" href="replication.html#sysvar_binlog_error_action"><code class="literal">binlog_error_action</code></a>
                        </p><p style="color:blue;">binlog_error_操作</p>
                            <div class="informaltable">
                                <table frame="box" rules="all" summary="Properties for binlog_error_action"><colgroup><col width="30%"><col width="70%"></colgroup><thead><tr><th scope="col">Property</th>
                                    <th scope="col">Value</th>
                                </tr></thead><tbody><tr><td scope="row"><span class="bold"><strong>Command-Line Format</strong></span></td>
                                    <td><code class="literal">--binlog-error-action[=value]</code></td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Introduced</strong></span></td>
                                    <td>5.7.6</td>
                                </tr><tr><td scope="row"><span class="bold"><strong>System Variable</strong></span></td>
                                    <td><code class="literal"><a class="link" href="replication.html#sysvar_binlog_error_action">binlog_error_action</a></code></td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Scope</strong></span></td>
                                    <td>Global</td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Dynamic</strong></span></td>
                                    <td>Yes</td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Type</strong></span></td>
                                    <td>Enumeration</td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Default Value</strong></span> (&gt;= 5.7.7)</td>
                                    <td><code class="literal">ABORT_SERVER</code></td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Default Value</strong></span> (&lt;= 5.7.6)</td>
                                    <td><code class="literal">IGNORE_ERROR</code></td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Valid Values</strong></span></td>
                                    <td><p class="valid-value"><code class="literal">IGNORE_ERROR</code></p><p style="color:blue;">忽略错误</p><p class="valid-value"><code class="literal">ABORT_SERVER</code></p><p style="color:blue;">中止服务器</p></td>
                                </tr></tbody></table>
                            </div>
                            <p>
                                Controls what happens when the server encounters an error
                                such as not being able to write to, flush or synchronize the
                                binary log, which can cause the master's binary log to
                                become inconsistent and replication slaves to lose
                                synchronization.
                            </p><p style="color:blue;">控制当服务器遇到错误（例如无法写入、刷新或同步二进制日志）时发生的操作，该错误可能导致主服务器的二进制日志不一致，并且复制从属服务器失去同步。</p><p>
                                In MySQL 5.7.7 and later, this variable defaults to
                                <code class="literal">ABORT_SERVER</code>, which makes the server halt
                                logging and shut down whenever it encounters such an error
                                with the binary log. On restart, recovery proceeds as in the
                                case of an unexpected server halt (see
                                <a class="xref" href="replication.html#replication-solutions-unexpected-slave-halt" title="16.3.2&nbsp;Handling an Unexpected Halt of a Replication Slave">Section&nbsp;16.3.2, “Handling an Unexpected Halt of a Replication Slave”</a>).
                            </p><p style="color:blue;">在mysql 5.7.7及更高版本中，此变量默认为abort_server，这使得服务器在遇到二进制日志错误时停止日志记录并关闭。重新启动时，恢复将继续进行，如同意外服务器停止一样（请参阅第16.3.2节“处理复制从机的意外停止”）。</p><p>
                                When <code class="literal">binlog_error_action</code> is set to
                                <code class="literal">IGNORE_ERROR</code>, if the server encounters
                                such an error it continues the ongoing transaction, logs the
                                error then halts logging, and continues performing updates.
                                To resume binary logging
                                <a class="link" href="replication.html#sysvar_log_bin"><code class="literal">log_bin</code></a> must be enabled
                                again, which requires a server restart. This setting
                                provides backward compatibility with older versions of
                                MySQL.
                            </p><p style="color:blue;">当binlog_error_action设置为ignore_error时，如果服务器遇到此类错误，它将继续进行中的事务，记录错误，然后停止日志记录，并继续执行更新。要恢复二进制日志记录，必须再次启用日志，这需要重新启动服务器。此设置提供与旧版本MySQL的向后兼容性。</p><p>
                                In previous releases this variable was named
                                <code class="literal">binlogging_impossible_mode</code>.
                            </p><p style="color:blue;">在以前的版本中，这个变量被命名为binlogging_impossible_mode。</p></li><li class="listitem"><p><a name="sysvar_binlog_format"></a>
                            <a class="indexterm" name="idm140286796358240"></a>

                            <a class="indexterm" name="idm140286796357184"></a>

                            <a class="link" href="replication.html#sysvar_binlog_format"><code class="literal">binlog_format</code></a>
                        </p><p style="color:blue;">binlog_格式</p>
                            <div class="informaltable">
                                <table frame="box" rules="all" summary="Properties for binlog_format"><colgroup><col width="30%"><col width="70%"></colgroup><thead><tr><th scope="col">Property</th>
                                    <th scope="col">Value</th>
                                </tr></thead><tbody><tr><td scope="row"><span class="bold"><strong>Command-Line Format</strong></span></td>
                                    <td><code class="literal">--binlog-format=format</code></td>
                                </tr><tr><td scope="row"><span class="bold"><strong>System Variable</strong></span></td>
                                    <td><code class="literal"><a class="link" href="replication.html#sysvar_binlog_format">binlog_format</a></code></td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Scope</strong></span></td>
                                    <td>Global, Session</td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Dynamic</strong></span></td>
                                    <td>Yes</td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Type</strong></span></td>
                                    <td>Enumeration</td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Default Value</strong></span> (&gt;= 5.7.7)</td>
                                    <td><code class="literal">ROW</code></td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Default Value</strong></span> (&lt;= 5.7.6)</td>
                                    <td><code class="literal">STATEMENT</code></td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Valid Values</strong></span></td>
                                    <td><p class="valid-value"><code class="literal">ROW</code></p><p style="color:blue;">行</p><p class="valid-value"><code class="literal">STATEMENT</code></p><p style="color:blue;">陈述</p><p class="valid-value"><code class="literal">MIXED</code></p><p style="color:blue;">混合的</p></td>
                                </tr></tbody></table>
                            </div>
                            <p>
                                This variable sets the binary logging format, and can be any
                                one of <code class="literal">STATEMENT</code>, <code class="literal">ROW</code>,
                                or <code class="literal">MIXED</code>. See
                                <a class="xref" href="replication.html#replication-formats" title="16.2.1&nbsp;Replication Formats">Section&nbsp;16.2.1, “Replication Formats”</a>.
                            </p><p style="color:blue;">此变量设置二进制日志记录格式，可以是语句、行或混合格式中的任何一种。见第16.2.1节“复制格式”。</p><p>
                                <a class="link" href="replication.html#sysvar_binlog_format"><code class="literal">binlog_format</code></a> can be set at
                                startup or at runtime, except that under some conditions,
                                changing this variable at runtime is not possible or causes
                                replication to fail, as described later.
                            </p><p style="color:blue;">binlog_格式可以在启动或运行时设置，但在某些情况下，无法在运行时更改此变量或导致复制失败，如后所述。</p><p>
                                Prior to MySQL 5.7.7, the default format was
                                <code class="literal">STATEMENT</code>. In MySQL 5.7.7 and later the
                                default is <code class="literal">ROW</code>.
                                <span class="emphasis"><em>Exception</em></span>: In NDB Cluster, the default
                                is <code class="literal">MIXED</code>; statement-based replication is
                                not supported for NDB Cluster.
                            </p><p style="color:blue;">在mysql 5.7.7之前，默认格式是statement。在mysql 5.7.7及更高版本中，默认值是row。异常：在ndb集群中，默认值为mixed；ndb集群不支持基于语句的复制。</p><p>
                                Setting the session value of this system variable is a
                                restricted operation. The session user must have privileges
                                sufficient to set restricted session variables. See
                                <a class="xref" href="server-administration.html#system-variable-privileges" title="5.1.8.1&nbsp;System Variable Privileges">Section&nbsp;5.1.8.1, “System Variable Privileges”</a>.
                            </p><p style="color:blue;">设置此系统变量的会话值是受限制的操作。会话用户必须具有足够的权限来设置受限制的会话变量。见第5.1.8.1节“系统变量特权”。</p><p>
                                The rules governing when changes to this variable take
                                effect and how long the effect lasts are the same as for
                                other MySQL server system variables. For more information,
                                see <a class="xref" href="sql-syntax.html#set-variable" title="13.7.4.1&nbsp;SET Syntax for Variable Assignment">Section&nbsp;13.7.4.1, “SET Syntax for Variable Assignment”</a>.
                            </p><p style="color:blue;">控制对该变量的更改何时生效以及效果持续多长时间的规则与其他mysql服务器系统变量相同。有关详细信息，请参阅第13.7.4.1节“设置变量赋值语法”。</p><p>
                                When <code class="literal">MIXED</code> is specified, statement-based
                                replication is used, except for cases where only row-based
                                replication is guaranteed to lead to proper results. For
                                example, this happens when statements contain user-defined
                                functions (UDF) or the <a class="link" href="functions.html#function_uuid"><code class="literal">UUID()</code></a>
                                function.
                            </p><p style="color:blue;">当指定mixed时，将使用基于语句的复制，但只有基于行的复制才能保证得到正确的结果的情况除外。例如，当语句包含用户定义函数（UDF）或uuid（）函数时，就会发生这种情况。</p><p>
                                For details of how stored programs (stored procedures and
                                functions, triggers, and events) are handled when each
                                binary logging format is set, see
                                <a class="xref" href="stored-objects.html#stored-programs-logging" title="23.7&nbsp;Stored Program Binary Logging">Section&nbsp;23.7, “Stored Program Binary Logging”</a>.
                            </p><p style="color:blue;">有关设置每个二进制日志格式时如何处理存储程序（存储过程和函数、触发器和事件）的详细信息，请参阅23.7节“存储程序二进制日志”。</p><p>
                                There are exceptions when you cannot switch the replication
                                format at runtime:
                            </p><p style="color:blue;">在运行时无法切换复制格式时会出现异常：</p>
                            <div class="itemizedlist">
                                <ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
                                    From within a stored function or a trigger.
                                </p><p style="color:blue;">从存储的函数或触发器中。</p></li><li class="listitem"><p>
                                    If the session is currently in row-based replication
                                    mode and has open temporary tables.
                                </p><p style="color:blue;">如果会话当前处于基于行的复制模式并且具有打开的临时表。</p></li><li class="listitem"><p>
                                    From within a transaction.
                                </p><p style="color:blue;">在交易中。</p></li></ul>
                            </div>
                            <p>
                                Trying to switch the format in those cases results in an
                                error.
                            </p><p style="color:blue;">在这些情况下尝试切换格式会导致错误。</p><p>
                                Changing the logging format on a replication master does not
                                cause a replication slave to change its logging format to
                                match. Switching the replication format while replication is
                                ongoing can cause issues if a replication slave has binary
                                logging enabled, and the change results in the slave using
                                <code class="literal">STATEMENT</code> format logging while the master
                                is using <code class="literal">ROW</code> or <code class="literal">MIXED</code>
                                format logging. A replication slave is not able to convert
                                binary log entries received in <code class="literal">ROW</code>
                                logging format to <code class="literal">STATEMENT</code> format for
                                use in its own binary log, so this situation can cause
                                replication to fail. For more information, see
                                <a class="xref" href="server-administration.html#binary-log-setting" title="5.4.4.2&nbsp;Setting The Binary Log Format">Section&nbsp;5.4.4.2, “Setting The Binary Log Format”</a>.
                            </p><p style="color:blue;">更改复制主机上的日志格式不会导致复制从机更改其日志格式以匹配。如果复制从机启用了二进制日志记录，则在复制进行中切换复制格式可能会导致问题，并且当主机使用行或混合格式日志记录时，此更改会导致从机使用语句格式日志记录。复制从属服务器无法将以行日志格式接收的二进制日志项转换为语句格式，以便在其自身的二进制日志中使用，因此这种情况可能会导致复制失败。有关更多信息，请参阅第5.4.4.2节“设置二进制日志格式”。</p><p>
                                The binary log format affects the behavior of the following
                                server options:
                            </p><p style="color:blue;">二进制日志格式影响以下服务器选项的行为：</p>
                            <div class="itemizedlist">
                                <ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
                                    <a class="link" href="replication.html#option_mysqld_replicate-do-db"><code class="option">--replicate-do-db</code></a>
                                </p><p style="color:blue;">--复制数据库</p></li><li class="listitem"><p>
                                    <a class="link" href="replication.html#option_mysqld_replicate-ignore-db"><code class="option">--replicate-ignore-db</code></a>
                                </p><p style="color:blue;">--复制忽略数据库</p></li><li class="listitem"><p>
                                    <a class="link" href="replication.html#option_mysqld_binlog-do-db"><code class="option">--binlog-do-db</code></a>
                                </p><p style="color:blue;">--binlog数据库</p></li><li class="listitem"><p>
                                    <a class="link" href="replication.html#option_mysqld_binlog-ignore-db"><code class="option">--binlog-ignore-db</code></a>
                                </p><p style="color:blue;">--binlog忽略数据库</p></li></ul>
                            </div>
                            <p>
                                These effects are discussed in detail in the descriptions of
                                the individual options.
                            </p><p style="color:blue;">这些影响将在各个选项的描述中详细讨论。</p></li><li class="listitem"><p><a name="sysvar_binlog_group_commit_sync_delay"></a>
                            <a class="indexterm" name="idm140286796288176"></a>

                            <a class="indexterm" name="idm140286796287136"></a>

                            <a class="link" href="replication.html#sysvar_binlog_group_commit_sync_delay"><code class="literal">binlog_group_commit_sync_delay</code></a>
                        </p><p style="color:blue;">binlog_group_commit_sync_延迟</p>
                            <div class="informaltable">
                                <table frame="box" rules="all" summary="Properties for binlog_group_commit_sync_delay"><colgroup><col width="30%"><col width="70%"></colgroup><thead><tr><th scope="col">Property</th>
                                    <th scope="col">Value</th>
                                </tr></thead><tbody><tr><td scope="row"><span class="bold"><strong>Command-Line Format</strong></span></td>
                                    <td><code class="literal">--binlog-group-commit-sync-delay=#</code></td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Introduced</strong></span></td>
                                    <td>5.7.5</td>
                                </tr><tr><td scope="row"><span class="bold"><strong>System Variable</strong></span></td>
                                    <td><code class="literal"><a class="link" href="replication.html#sysvar_binlog_group_commit_sync_delay">binlog_group_commit_sync_delay</a></code></td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Scope</strong></span></td>
                                    <td>Global</td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Dynamic</strong></span></td>
                                    <td>Yes</td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Type</strong></span></td>
                                    <td>Integer</td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Default Value</strong></span></td>
                                    <td><code class="literal">0</code></td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Minimum Value</strong></span></td>
                                    <td><code class="literal">0</code></td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Maximum Value</strong></span></td>
                                    <td><code class="literal">1000000</code></td>
                                </tr></tbody></table>
                            </div>
                            <p>
                                Controls how many microseconds the binary log commit waits
                                before synchronizing the binary log file to disk. By default
                                <a class="link" href="replication.html#sysvar_binlog_group_commit_sync_delay"><code class="literal">binlog_group_commit_sync_delay</code></a>
                                is set to 0, meaning that there is no delay. Setting
                                <a class="link" href="replication.html#sysvar_binlog_group_commit_sync_delay"><code class="literal">binlog_group_commit_sync_delay</code></a>
                                to a microsecond delay enables more transactions to be
                                synchronized together to disk at once, reducing the overall
                                time to commit a group of transactions because the larger
                                groups require fewer time units per group.
                            </p><p style="color:blue;">控制在将二进制日志文件同步到磁盘之前，二进制日志提交等待的微秒数。默认情况下，binlog_group_commit_sync_delay设置为0，这意味着没有延迟。将binlog_group_commit_sync_delay设置为微秒延迟可以同时将更多事务同步到磁盘，从而减少提交一组事务的总时间，因为较大的组对每个组所需的时间单位较少。</p><p>
                                When <a class="link" href="replication.html#sysvar_sync_binlog"><code class="literal">sync_binlog=0</code></a> or
                                <a class="link" href="replication.html#sysvar_sync_binlog"><code class="literal">sync_binlog=1</code></a> is set, the
                                delay specified by
                                <a class="link" href="replication.html#sysvar_binlog_group_commit_sync_delay"><code class="literal">binlog_group_commit_sync_delay</code></a>
                                is applied for every binary log commit group before
                                synchronization (or in the case of
                                <a class="link" href="replication.html#sysvar_sync_binlog"><code class="literal">sync_binlog=0</code></a>, before
                                proceeding). When
                                <a class="link" href="replication.html#sysvar_sync_binlog"><code class="literal">sync_binlog</code></a> is set to a
                                value <span class="emphasis"><em>n</em></span> greater than 1, the delay is
                                applied after every <span class="emphasis"><em>n</em></span> binary log commit
                                groups.
                            </p><p style="color:blue;">当设置sync_binlog=0或sync_binlog=1时，由binlog_group_commit_sync_delay指定的延迟将在同步之前（或在sync_binlog=0的情况下，在继续之前）应用于每个二进制日志提交组。当sync_binlog设置为大于1的值n时，将在每n个二进制日志提交组之后应用延迟。</p><p>
                                Setting
                                <a class="link" href="replication.html#sysvar_binlog_group_commit_sync_delay"><code class="literal">binlog_group_commit_sync_delay</code></a>
                                can increase the number of parallel committing transactions
                                on any server that has (or might have after a failover) a
                                replication slave, and therefore can increase parallel
                                execution on the replication slaves. To benefit from this
                                effect, the slave servers must have
                                <a class="link" href="replication.html#sysvar_slave_parallel_type"><code class="literal">slave_parallel_type=LOGICAL_CLOCK</code></a>
                                set, and the effect is more significant when
                                <a class="link" href="replication.html#sysvar_binlog_transaction_dependency_tracking"><code class="literal">binlog_transaction_dependency_tracking=COMMIT_ORDER</code></a>
                                is also set. It is important to take into account both the
                                master's throughput and the slaves' throughput when you are
                                tuning the setting for
                                <a class="link" href="replication.html#sysvar_binlog_group_commit_sync_delay"><code class="literal">binlog_group_commit_sync_delay</code></a>.
                            </p><p style="color:blue;">设置binlog_group_commit_sync_delay可以增加具有（或在故障转移后可能具有）复制从属服务器的任何服务器上的并行提交事务数，因此可以增加复制从属服务器上的并行执行。要受益于此效果，从属服务器必须设置slave_parallel_type=logical_clock，并且在还设置binlog_transaction_dependency_tracking=commit_order时效果更显著。在调整binlog_group_commit_sync_delay的设置时，必须同时考虑主设备的吞吐量和从设备的吞吐量。</p><p>
                                Setting
                                <a class="link" href="replication.html#sysvar_binlog_group_commit_sync_delay"><code class="literal">binlog_group_commit_sync_delay</code></a>
                                can also reduce the number of <code class="literal">fsync()</code>
                                calls to the binary log on any server (master or slave) that
                                has a binary log.
                            </p><p style="color:blue;">设置binlog_group_commit_sync_delay还可以减少对具有二进制日志的任何服务器（主服务器或从服务器）上的二进制日志的fsync（）调用数。</p><p>
                                Note that setting
                                <a class="link" href="replication.html#sysvar_binlog_group_commit_sync_delay"><code class="literal">binlog_group_commit_sync_delay</code></a>
                                increases the latency of transactions on the server, which
                                might affect client applications. Also, on highly concurrent
                                workloads, it is possible for the delay to increase
                                contention and therefore reduce throughput. Typically, the
                                benefits of setting a delay outweigh the drawbacks, but
                                tuning should always be carried out to determine the optimal
                                setting.
                            </p><p style="color:blue;">请注意，设置binlog_group_commit_sync_delay会增加服务器上事务的延迟，这可能会影响客户端应用程序。此外，在高度并发的工作负载上，延迟可能会增加争用，从而降低吞吐量。通常，设置延迟的好处大于缺点，但应始终执行调整以确定最佳设置。</p></li><li class="listitem"><p><a name="sysvar_binlog_group_commit_sync_no_delay_count"></a>
                            <a class="indexterm" name="idm140286796228400"></a>

                            <a class="indexterm" name="idm140286796227312"></a>

                            <a class="link" href="replication.html#sysvar_binlog_group_commit_sync_no_delay_count"><code class="literal">binlog_group_commit_sync_no_delay_count</code></a>
                        </p><p style="color:blue;">binlog_group_commit_sync_no_delay_计数</p>
                            <div class="informaltable">
                                <table frame="box" rules="all" summary="Properties for binlog_group_commit_sync_no_delay_count"><colgroup><col width="30%"><col width="70%"></colgroup><thead><tr><th scope="col">Property</th>
                                    <th scope="col">Value</th>
                                </tr></thead><tbody><tr><td scope="row"><span class="bold"><strong>Command-Line Format</strong></span></td>
                                    <td><code class="literal">--binlog-group-commit-sync-no-delay-count=#</code></td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Introduced</strong></span></td>
                                    <td>5.7.5</td>
                                </tr><tr><td scope="row"><span class="bold"><strong>System Variable</strong></span></td>
                                    <td><code class="literal"><a class="link" href="replication.html#sysvar_binlog_group_commit_sync_no_delay_count">binlog_group_commit_sync_no_delay_count</a></code></td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Scope</strong></span></td>
                                    <td>Global</td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Dynamic</strong></span></td>
                                    <td>Yes</td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Type</strong></span></td>
                                    <td>Integer</td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Default Value</strong></span></td>
                                    <td><code class="literal">0</code></td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Minimum Value</strong></span></td>
                                    <td><code class="literal">0</code></td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Maximum Value</strong></span></td>
                                    <td><code class="literal">1000000</code></td>
                                </tr></tbody></table>
                            </div>
                            <p>
                                The maximum number of transactions to wait for before
                                aborting the current delay as specified by
                                <a class="link" href="replication.html#sysvar_binlog_group_commit_sync_delay"><code class="literal">binlog_group_commit_sync_delay</code></a>.
                                If
                                <a class="link" href="replication.html#sysvar_binlog_group_commit_sync_delay"><code class="literal">binlog_group_commit_sync_delay</code></a>
                                is set to 0, then this option has no effect.
                            </p><p style="color:blue;">在由BiLogyGROPpUnjySycCyLead指定的中止当前延迟之前等待的事务的最大数量。如果binlog_group_commit_sync_delay设置为0，则此选项无效。</p></li><li class="listitem"><p><a name="sysvar_binlogging_impossible_mode"></a>
                            <a class="indexterm" name="idm140286796187504"></a>

                            <a class="indexterm" name="idm140286796186400"></a>

                            <a class="link" href="replication.html#sysvar_binlogging_impossible_mode"><code class="literal">binlogging_impossible_mode</code></a>
                        </p><p style="color:blue;">无法存储模式</p>
                            <div class="informaltable">
                                <table frame="box" rules="all" summary="Properties for binlogging_impossible_mode"><colgroup><col width="30%"><col width="70%"></colgroup><thead><tr><th scope="col">Property</th>
                                    <th scope="col">Value</th>
                                </tr></thead><tbody><tr><td scope="row"><span class="bold"><strong>Command-Line Format</strong></span></td>
                                    <td><code class="literal">--binlogging-impossible-mode[=value]</code></td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Introduced</strong></span></td>
                                    <td>5.7.5</td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Deprecated</strong></span></td>
                                    <td>Yes (removed in 5.7.6)</td>
                                </tr><tr><td scope="row"><span class="bold"><strong>System Variable</strong></span></td>
                                    <td><code class="literal"><a class="link" href="replication.html#sysvar_binlogging_impossible_mode">binlogging_impossible_mode</a></code></td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Scope</strong></span></td>
                                    <td>Global, Session</td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Dynamic</strong></span></td>
                                    <td>Yes</td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Type</strong></span></td>
                                    <td>Enumeration</td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Default Value</strong></span></td>
                                    <td><code class="literal">IGNORE_ERROR</code></td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Valid Values</strong></span></td>
                                    <td><p class="valid-value"><code class="literal">IGNORE_ERROR</code></p><p style="color:blue;">忽略错误</p><p class="valid-value"><code class="literal">ABORT_SERVER</code></p><p style="color:blue;">中止服务器</p></td>
                                </tr></tbody></table>
                            </div>
                            <p>
                                This option was removed in MySQL 5.7.6. Use
                                <a class="link" href="replication.html#sysvar_binlog_error_action"><code class="literal">binlog_error_action</code></a> to
                                control what happens when the server cannot write to the
                                binary log.
                            </p><p style="color:blue;">在mysql 5.7.6中删除了此选项。使用binlog_error_操作控制服务器无法写入二进制日志时发生的情况。</p></li><li class="listitem"><p><a name="sysvar_binlog_max_flush_queue_time"></a>
                            <a class="indexterm" name="idm140286796146960"></a>

                            <a class="indexterm" name="idm140286796145856"></a>

                            <a class="link" href="replication.html#sysvar_binlog_max_flush_queue_time"><code class="literal">binlog_max_flush_queue_time</code></a>
                        </p><p style="color:blue;">binlog_max_flush_queue_时间</p>
                            <div class="informaltable">
                                <table frame="box" rules="all" summary="Properties for binlog_max_flush_queue_time"><colgroup><col width="30%"><col width="70%"></colgroup><thead><tr><th scope="col">Property</th>
                                    <th scope="col">Value</th>
                                </tr></thead><tbody><tr><td scope="row"><span class="bold"><strong>Command-Line Format</strong></span></td>
                                    <td><code class="literal">--binlog-max-flush-queue-time=#</code></td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Deprecated</strong></span></td>
                                    <td>5.7.9</td>
                                </tr><tr><td scope="row"><span class="bold"><strong>System Variable</strong></span></td>
                                    <td><code class="literal"><a class="link" href="replication.html#sysvar_binlog_max_flush_queue_time">binlog_max_flush_queue_time</a></code></td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Scope</strong></span></td>
                                    <td>Global</td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Dynamic</strong></span></td>
                                    <td>Yes</td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Type</strong></span></td>
                                    <td>Integer</td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Default Value</strong></span></td>
                                    <td><code class="literal">0</code></td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Minimum Value</strong></span></td>
                                    <td><code class="literal">0</code></td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Maximum Value</strong></span></td>
                                    <td><code class="literal">100000</code></td>
                                </tr></tbody></table>
                            </div>
                            <p>
                                Formerly, this controlled the time in microseconds to
                                continue reading transactions from the flush queue before
                                proceeding with group commit. In MySQL 5.7,
                                this variable no longer has any effect.
                            </p><p style="color:blue;">以前，这控制了在继续进行组提交之前从刷新队列继续读取事务的时间（以微秒为单位）。在mysql 5.7中，这个变量不再有任何作用。</p><p>
                                <code class="literal">binlog_max_flush_queue_time</code> is deprecated
                                as of MySQL 5.7.9, and is marked for eventual removal in a
                                future MySQL release.
                            </p><p style="color:blue;">从mysql 5.7.9开始，binlog_max_flush_queue_time已被弃用，并标记为在将来的mysql版本中最终删除。</p></li><li class="listitem"><p><a name="sysvar_binlog_order_commits"></a>
                            <a class="indexterm" name="idm140286796107376"></a>

                            <a class="indexterm" name="idm140286796106336"></a>

                            <a class="link" href="replication.html#sysvar_binlog_order_commits"><code class="literal">binlog_order_commits</code></a>
                        </p><p style="color:blue;">binlog_order_提交</p>
                            <div class="informaltable">
                                <table frame="box" rules="all" summary="Properties for binlog_order_commits"><colgroup><col width="30%"><col width="70%"></colgroup><thead><tr><th scope="col">Property</th>
                                    <th scope="col">Value</th>
                                </tr></thead><tbody><tr><td scope="row"><span class="bold"><strong>Command-Line Format</strong></span></td>
                                    <td><code class="literal">--binlog-order-commits[={OFF|ON}]</code></td>
                                </tr><tr><td scope="row"><span class="bold"><strong>System Variable</strong></span></td>
                                    <td><code class="literal"><a class="link" href="replication.html#sysvar_binlog_order_commits">binlog_order_commits</a></code></td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Scope</strong></span></td>
                                    <td>Global</td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Dynamic</strong></span></td>
                                    <td>Yes</td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Type</strong></span></td>
                                    <td>Boolean</td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Default Value</strong></span></td>
                                    <td><code class="literal">ON</code></td>
                                </tr></tbody></table>
                            </div>
                            <p>
                                When this variable is enabled on a replication master (which
                                is the default), transaction commit instructions issued to
                                storage engines are serialized on a single thread, so that
                                transactions are always committed in the same order as they
                                are written to the binary log. Disabling this variable
                                permits transaction commit instructions to be issued using
                                multiple threads. Used in combination with binary log group
                                commit, this prevents the commit rate of a single
                                transaction being a bottleneck to throughput, and might
                                therefore produce a performance improvement.
                            </p><p style="color:blue;">当在复制主机上启用此变量（这是默认设置）时，向存储引擎发出的事务提交指令将在单个线程上序列化，以便事务始终按写入二进制日志的相同顺序提交。禁用此变量允许使用多个线程发出事务提交指令。与二进制日志组提交结合使用，可以防止单个事务的提交速率成为吞吐量的瓶颈，因此可能会提高性能。</p><p>
                                Transactions are written to the binary log at the point when
                                all the storage engines involved have confirmed that the
                                transaction is prepared to commit. The binary log group
                                commit logic then commits a group of transactions after
                                their binary log write has taken place. When
                                <a class="link" href="replication.html#sysvar_binlog_order_commits"><code class="literal">binlog_order_commits</code></a> is
                                disabled, because multiple threads are used for this
                                process, transactions in a commit group might be committed
                                in a different order from their order in the binary log.
                                (Transactions from a single client always commit in
                                chronological order.) In many cases this does not matter, as
                                operations carried out in separate transactions should
                                produce consistent results, and if that is not the case, a
                                single transaction ought to be used instead.
                            </p><p style="color:blue;">当所有涉及的存储引擎都已确认事务已准备好提交时，事务将写入二进制日志。然后，二进制日志组提交逻辑在二进制日志写入之后提交一组事务。当binlog_order_commits被禁用时，由于此进程使用多个线程，提交组中的事务可能会以不同于二进制日志中事务顺序的顺序提交。（来自单个客户机的事务总是按时间顺序提交）在许多情况下，这无关紧要，因为在单独事务中执行的操作应产生一致的结果，如果不是这样，则应使用单个事务。</p><p>
                                If you want to ensure that the transaction history on the
                                master and on a multithreaded replication slave remains
                                identical, set
                                <a class="link" href="replication.html#sysvar_slave_preserve_commit_order"><code class="literal">slave_preserve_commit_order=1</code></a>
                                on the replication slave.
                            </p><p style="color:blue;">如果要确保主服务器和多线程复制从服务器上的事务历史记录保持相同，请在复制从服务器上设置slave_preserve_commit_order=1。</p></li><li class="listitem"><p><a name="sysvar_binlog_row_image"></a>
                            <a class="indexterm" name="idm140286796073120"></a>

                            <a class="indexterm" name="idm140286796072064"></a>

                            <a class="link" href="replication.html#sysvar_binlog_row_image"><code class="literal">binlog_row_image</code></a>
                        </p><p style="color:blue;">binlog_row_图像</p>
                            <div class="informaltable">
                                <table frame="box" rules="all" summary="Properties for binlog_row_image"><colgroup><col width="30%"><col width="70%"></colgroup><thead><tr><th scope="col">Property</th>
                                    <th scope="col">Value</th>
                                </tr></thead><tbody><tr><td scope="row"><span class="bold"><strong>Command-Line Format</strong></span></td>
                                    <td><code class="literal">--binlog-row-image=image_type</code></td>
                                </tr><tr><td scope="row"><span class="bold"><strong>System Variable</strong></span></td>
                                    <td><code class="literal"><a class="link" href="replication.html#sysvar_binlog_row_image">binlog_row_image</a></code></td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Scope</strong></span></td>
                                    <td>Global, Session</td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Dynamic</strong></span></td>
                                    <td>Yes</td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Type</strong></span></td>
                                    <td>Enumeration</td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Default Value</strong></span></td>
                                    <td><code class="literal">full</code></td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Valid Values</strong></span></td>
                                    <td><p class="valid-value"><code class="literal">full</code> (Log all columns)</p><p style="color:blue;">完整（记录所有列）</p><p class="valid-value"><code class="literal">minimal</code> (Log only changed columns, and columns needed to identify rows)</p><p style="color:blue;">最小值（仅记录更改的列，以及标识行所需的列）</p><p class="valid-value"><code class="literal">noblob</code> (Log all columns, except for unneeded BLOB and TEXT columns)</p><p style="color:blue;">noblob（记录所有列，不需要的blob列和文本列除外）</p></td>
                                </tr></tbody></table>
                            </div>
                            <p>
                                For MySQL row-based replication, this variable determines
                                how row images are written to the binary log.
                            </p><p style="color:blue;">对于mysql基于行的复制，此变量确定如何将行图像写入二进制日志。</p><p>
                                In MySQL row-based replication, each row change event
                                contains two images, a <span class="quote">“<span class="quote">before</span>”</span> image whose
                                columns are matched against when searching for the row to be
                                updated, and an <span class="quote">“<span class="quote">after</span>”</span> image containing the
                                changes. Normally, MySQL logs full rows (that is, all
                                columns) for both the before and after images. However, it
                                is not strictly necessary to include every column in both
                                images, and we can often save disk, memory, and network
                                usage by logging only those columns which are actually
                                required.
                            </p><p style="color:blue;">在mysql基于行的复制中，每个行更改事件都包含两个图像，一个是搜索要更新的行时与其列匹配的“before”图像，另一个是包含更改的“after”图像。通常，mysql会记录前后图像的整行（即所有列）。但是，并不一定要在两个映像中都包含每一列，而且我们通常可以通过只记录那些实际需要的列来节省磁盘、内存和网络使用量。</p>
                            <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">

                                <div class="admon-title">
                                    Note
                                </div>
                                <p>
                                    When deleting a row, only the before image is logged,
                                    since there are no changed values to propagate following
                                    the deletion. When inserting a row, only the after image
                                    is logged, since there is no existing row to be matched.
                                    Only when updating a row are both the before and after
                                    images required, and both written to the binary log.
                                </p><p style="color:blue;">删除行时，只记录前一个映像，因为删除后没有要传播的更改值。插入行时，只记录后图像，因为没有匹配的现有行。只有更新行时，才需要前后图像，并且都写入二进制日志。</p>
                            </div>
                            <p>
                                For the before image, it is necessary only that the minimum
                                set of columns required to uniquely identify rows is logged.
                                If the table containing the row has a primary key, then only
                                the primary key column or columns are written to the binary
                                log. Otherwise, if the table has a unique key all of whose
                                columns are <code class="literal">NOT NULL</code>, then only the
                                columns in the unique key need be logged. (If the table has
                                neither a primary key nor a unique key without any
                                <code class="literal">NULL</code> columns, then all columns must be
                                used in the before image, and logged.) In the after image,
                                it is necessary to log only the columns which have actually
                                changed.
                            </p><p style="color:blue;">对于前一个映像，只需要记录唯一标识行所需的最小列集。如果包含该行的表具有主键，则只有主键列写入二进制日志。否则，如果表具有唯一键，且其所有列都不为空，则只需要记录唯一键中的列。（如果表既没有主键也没有不带任何空列的唯一键，则所有列都必须在前一个映像中使用并记录。）在后一个映像中，只需要记录实际更改的列。</p><p>
                                You can cause the server to log full or minimal rows using
                                the <code class="literal">binlog_row_image</code> system variable.
                                This variable actually takes one of three possible values,
                                as shown in the following list:
                            </p><p style="color:blue;">您可以使用binlog_row_image系统变量使服务器记录满行或最小行。此变量实际上采用三个可能值之一，如下表所示：</p>
                            <div class="itemizedlist">
                                <ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
                                    <code class="literal">full</code>: Log all columns in both the
                                    before image and the after image.
                                </p><p style="color:blue;">完整：记录前映像和后映像中的所有列。</p></li><li class="listitem"><p>
                                    <code class="literal">minimal</code>: Log only those columns in
                                    the before image that are required to identify the row
                                    to be changed; log only those columns in the after image
                                    where a value was specified by the SQL statement, or
                                    generated by auto-increment.
                                </p><p style="color:blue;">最小值：只记录前一个映像中标识要更改的行所需的列；只记录后一个映像中由SQL语句指定值或由自动增量生成值的列。</p></li><li class="listitem"><p>
                                    <code class="literal">noblob</code>: Log all columns (same as
                                    <code class="literal">full</code>), except for
                                    <a class="link" href="data-types.html#blob" title="11.4.3&nbsp;The BLOB and TEXT Types"><code class="literal">BLOB</code></a> and
                                    <a class="link" href="data-types.html#blob" title="11.4.3&nbsp;The BLOB and TEXT Types"><code class="literal">TEXT</code></a> columns that are not
                                    required to identify rows, or that have not changed.
                                </p><p style="color:blue;">noblob：记录所有列（与完整列相同），但blob列和文本列不需要标识行或未更改。</p></li></ul>
                            </div>
                            <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">
                                <div class="admon-title">
                                    Note
                                </div>
                                <p>
                                    This variable is not supported by NDB Cluster; setting it
                                    has no effect on the logging of
                                    <a class="link" href="mysql-cluster.html" title="Chapter&nbsp;21&nbsp;MySQL NDB Cluster 7.5 and NDB Cluster 7.6"><code class="literal">NDB</code></a> tables.
                                </p><p style="color:blue;">ndb cluster不支持此变量；设置此变量不会影响ndb表的日志记录。</p>
                            </div>
                            <p>
                                The default value is <code class="literal">full</code>.
                            </p><p style="color:blue;">默认值为full。</p><p>
                                When using <code class="literal">minimal</code> or
                                <code class="literal">noblob</code>, deletes and updates are
                                guaranteed to work correctly for a given table if and only
                                if the following conditions are true for both the source and
                                destination tables:
                            </p><p style="color:blue;">当使用minimal或noblob时，只有在源表和目标表都满足以下条件时，才能保证对给定表的删除和更新正常工作：</p>
                            <div class="itemizedlist">
                                <ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
                                    All columns must be present and in the same order; each
                                    column must use the same data type as its counterpart in
                                    the other table.
                                </p><p style="color:blue;">所有列必须以相同的顺序出现；每个列必须使用与其在另一个表中的对应项相同的数据类型。</p></li><li class="listitem"><p>
                                    The tables must have identical primary key definitions.
                                </p><p style="color:blue;">表必须具有相同的主键定义。</p></li></ul>
                            </div>
                            <p>
                                (In other words, the tables must be identical with the
                                possible exception of indexes that are not part of the
                                tables' primary keys.)
                            </p><p style="color:blue;">（换句话说，表必须与不属于表主键的索引的可能例外相同。）</p><p>
                                If these conditions are not met, it is possible that the
                                primary key column values in the destination table may prove
                                insufficient to provide a unique match for a delete or
                                update. In this event, no warning or error is issued; the
                                master and slave silently diverge, thus breaking
                                consistency.
                            </p><p style="color:blue;">如果不满足这些条件，则可能证明目标表中的主键列值不足以为删除或更新提供唯一匹配。在这种情况下，不会发出警告或错误；主设备和从设备会自动分离，从而破坏一致性。</p><p>
                                Setting this variable has no effect when the binary logging
                                format is <code class="literal">STATEMENT</code>. When
                                <a class="link" href="replication.html#sysvar_binlog_format"><code class="literal">binlog_format</code></a> is
                                <code class="literal">MIXED</code>, the setting for
                                <code class="literal">binlog_row_image</code> is applied to changes
                                that are logged using row-based format, but this setting no
                                effect on changes logged as statements.
                            </p><p style="color:blue;">当二进制日志格式为语句时，设置此变量无效。混合binlog_格式时，binlog_row_image的设置将应用于使用基于行的格式记录的更改，但此设置不会影响记录为语句的更改。</p><p>
                                Setting <code class="literal">binlog_row_image</code> on either the
                                global or session level does not cause an implicit commit;
                                this means that this variable can be changed while a
                                transaction is in progress without affecting the
                                transaction.
                            </p><p style="color:blue;">在全局或会话级别上设置binlog_row_image不会导致隐式提交；这意味着可以在事务进行时更改此变量，而不会影响事务。</p></li><li class="listitem"><p><a name="sysvar_binlog_rows_query_log_events"></a>
                            <a class="indexterm" name="idm140286796007968"></a>

                            <a class="indexterm" name="idm140286796006864"></a>

                            <code class="literal">binlog_rows_query_log_events</code>
                        </p><p style="color:blue;">binlog_rows_query_log_事件</p>
                            <div class="informaltable">
                                <table frame="box" rules="all" summary="Properties for binlog_rows_query_log_events"><colgroup><col width="30%"><col width="70%"></colgroup><thead><tr><th scope="col">Property</th>
                                    <th scope="col">Value</th>
                                </tr></thead><tbody><tr><td scope="row"><span class="bold"><strong>Command-Line Format</strong></span></td>
                                    <td><code class="literal">--binlog-rows-query-log-events[={OFF|ON}]</code></td>
                                </tr><tr><td scope="row"><span class="bold"><strong>System Variable</strong></span></td>
                                    <td><code class="literal"><a class="link" href="replication.html#sysvar_binlog_rows_query_log_events">binlog_rows_query_log_events</a></code></td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Scope</strong></span></td>
                                    <td>Global, Session</td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Dynamic</strong></span></td>
                                    <td>Yes</td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Type</strong></span></td>
                                    <td>Boolean</td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Default Value</strong></span></td>
                                    <td><code class="literal">OFF</code></td>
                                </tr></tbody></table>
                            </div>
                            <p>
                                This system variable affects row-based logging only. When
                                enabled, it causes the server to write informational log
                                events such as row query log events into its binary log.
                                This information can be used for debugging and related
                                purposes, such as obtaining the original query issued on the
                                master when it cannot be reconstructed from the row updates.
                            </p><p style="color:blue;">此系统变量仅影响基于行的日志记录。启用时，它会导致服务器将信息日志事件（如行查询日志事件）写入其二进制日志。此信息可用于调试和相关目的，例如在无法从行更新重建主查询时获取在主查询上发出的原始查询。</p><p>
                                These informational events are normally ignored by MySQL
                                programs reading the binary log and so cause no issues when
                                replicating or restoring from backup. To view them, increase
                                the verbosity level by using mysqlbinlog's
                                <a class="link" href="programs.html#option_mysqlbinlog_verbose"><code class="option">--verbose</code></a> option twice,
                                either as <code class="option">-vv</code> or <code class="option">--verbose
                                --verbose</code>.
                            </p><p style="color:blue;">这些信息事件通常被读取二进制日志的mysql程序忽略，因此在从备份复制或还原时不会造成问题。要查看它们，请使用mysqlbinlog的--verbose选项两次（作为-vv或--verbose--verbose）来增加详细级别。</p></li><li class="listitem"><p><a name="sysvar_binlog_stmt_cache_size"></a>
                            <a class="indexterm" name="idm140286795976224"></a>

                            <a class="indexterm" name="idm140286795975184"></a>

                            <a class="link" href="replication.html#sysvar_binlog_stmt_cache_size"><code class="literal">binlog_stmt_cache_size</code></a>
                        </p><p style="color:blue;">binlog_stmt_cache_大小</p>
                            <div class="informaltable">
                                <table frame="box" rules="all" summary="Properties for binlog_stmt_cache_size"><colgroup><col width="30%"><col width="70%"></colgroup><thead><tr><th scope="col">Property</th>
                                    <th scope="col">Value</th>
                                </tr></thead><tbody><tr><td scope="row"><span class="bold"><strong>Command-Line Format</strong></span></td>
                                    <td><code class="literal">--binlog-stmt-cache-size=#</code></td>
                                </tr><tr><td scope="row"><span class="bold"><strong>System Variable</strong></span></td>
                                    <td><code class="literal"><a class="link" href="replication.html#sysvar_binlog_stmt_cache_size">binlog_stmt_cache_size</a></code></td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Scope</strong></span></td>
                                    <td>Global</td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Dynamic</strong></span></td>
                                    <td>Yes</td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Type</strong></span></td>
                                    <td>Integer</td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Default Value</strong></span></td>
                                    <td><code class="literal">32768</code></td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Minimum Value</strong></span></td>
                                    <td><code class="literal">4096</code></td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Maximum Value</strong></span> (64-bit platforms)</td>
                                    <td><code class="literal">18446744073709551615</code></td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Maximum Value</strong></span> (32-bit platforms)</td>
                                    <td><code class="literal">4294967295</code></td>
                                </tr></tbody></table>
                            </div>
                            <p>
                                This variable determines the size of the cache for the
                                binary log to hold nontransactional statements issued during
                                a transaction. Separate binary log transaction and statement
                                caches are allocated for each client if the server supports
                                any transactional storage engines and if the server has the
                                binary log enabled (<a class="link" href="replication.html#option_mysqld_log-bin"><code class="option">--log-bin</code></a>
                                option). If you often use large nontransactional statements
                                during transactions, you can increase this cache size to get
                                better performance. The
                                <a class="link" href="server-administration.html#statvar_Binlog_stmt_cache_use"><code class="literal">Binlog_stmt_cache_use</code></a> and
                                <a class="link" href="server-administration.html#statvar_Binlog_stmt_cache_disk_use"><code class="literal">Binlog_stmt_cache_disk_use</code></a>
                                status variables can be useful for tuning the size of this
                                variable. See <a class="xref" href="server-administration.html#binary-log" title="5.4.4&nbsp;The Binary Log">Section&nbsp;5.4.4, “The Binary Log”</a>.
                            </p><p style="color:blue;">此变量确定二进制日志的缓存大小，以便保存在事务期间发出的非事务语句。如果服务器支持任何事务存储引擎，并且服务器启用了二进制日志（--log bin选项），则为每个客户端分配单独的二进制日志事务和语句缓存。如果在事务期间经常使用大型非事务语句，则可以增加此缓存大小以获得更好的性能。binlog_stmt_cache_use和binlog_stmt_cache_disk_use状态变量可用于调整此变量的大小。见第5.4.4节“二进制日志”。</p><p>
                                The <a class="link" href="replication.html#sysvar_binlog_cache_size"><code class="literal">binlog_cache_size</code></a>
                                system variable sets the size for the transaction cache.
                            </p><p style="color:blue;">BINLOG U CACHE U SIZE系统变量设置事务缓存的大小。</p></li><li class="listitem"><p><a name="sysvar_binlog_transaction_dependency_tracking"></a>
                            <a class="indexterm" name="idm140286795930832"></a>

                            <a class="indexterm" name="idm140286795929792"></a>

                            <a class="link" href="replication.html#sysvar_binlog_transaction_dependency_tracking"><code class="literal">binlog_transaction_dependency_tracking</code></a>
                        </p><p style="color:blue;">binlog_事务依赖项跟踪</p>
                            <div class="informaltable">
                                <table frame="box" rules="all" summary="Properties for binlog_transaction_dependency_tracking"><colgroup><col width="30%"><col width="70%"></colgroup><thead><tr><th scope="col">Property</th>
                                    <th scope="col">Value</th>
                                </tr></thead><tbody><tr><td scope="row"><span class="bold"><strong>Command-Line Format</strong></span></td>
                                    <td><code class="literal">--binlog-transaction-dependency-tracking=value</code></td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Introduced</strong></span></td>
                                    <td>5.7.22</td>
                                </tr><tr><td scope="row"><span class="bold"><strong>System Variable</strong></span></td>
                                    <td><code class="literal"><a class="link" href="replication.html#sysvar_binlog_transaction_dependency_tracking">binlog_transaction_dependency_tracking</a></code></td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Scope</strong></span></td>
                                    <td>Global</td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Dynamic</strong></span></td>
                                    <td>Yes</td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Type</strong></span></td>
                                    <td>Enumeration</td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Default Value</strong></span></td>
                                    <td><code class="literal">COMMIT_ORDER</code></td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Valid Values</strong></span></td>
                                    <td><p class="valid-value"><code class="literal">COMMIT_ORDER</code></p><p style="color:blue;">提交订单</p><p class="valid-value"><code class="literal">WRITESET</code></p><p style="color:blue;">书写集</p><p class="valid-value"><code class="literal">WRITESET_SESSION</code></p><p style="color:blue;">写入会话</p></td>
                                </tr></tbody></table>
                            </div>
                            <p>
                                The source of dependency information that the master uses to
                                determine which transactions can be executed in parallel by
                                the slave's multithreaded applier. This variable can
                                take one of the three values described in the following
                                list:
                            </p><p style="color:blue;">主服务器用来确定哪些事务可以由从服务器的多线程应用程序并行执行的依赖信息源。此变量可以采用以下列表中描述的三个值之一：</p>
                            <div class="itemizedlist">
                                <ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
                                    <code class="literal">COMMIT_ORDER</code>: Dependency information
                                    is generated from the master's commit timestamps.
                                    This is the default. This mode is also used for any
                                    transactions without write sets, even if this
                                    variable's is <code class="literal">WRITESET</code> or
                                    <code class="literal">WRITESET_SESSION</code>; this is also the
                                    case for transactions updating tables without primary
                                    keys and transactions updating tables having foreign key
                                    constraints.
                                </p><p style="color:blue;">提交顺序：依赖关系信息由主服务器的提交时间戳生成。这是默认设置。此模式也适用于没有写集的任何事务，即使此变量是writeset或writeset_会话；对于没有主键的事务更新表和具有外键约束的事务更新表也是如此。</p></li><li class="listitem"><p>
                                    <code class="literal">WRITESET</code>: Dependency information is
                                    generated from the master's write set, and any
                                    transactions which write different tuples can be
                                    parallelized.
                                </p><p style="color:blue;">write set：依赖信息是从主写集生成的，任何写不同元组的事务都可以并行化。</p></li><li class="listitem"><p>
                                    <code class="literal">WRITESET_SESSION</code>: Dependency
                                    information is generated from the master's write
                                    set, but no two updates from the same session can be
                                    reordered.
                                </p><p style="color:blue;">write set_session：依赖项信息是从主控写入集生成的，但不能对同一会话中的两个更新重新排序。</p></li></ul>
                            </div>
                            <p>
                                <code class="literal">WRITESET</code> and
                                <code class="literal">WRITESET_SESSION</code> modes do not deliver any
                                transaction dependencies that are newer than those that
                                would have been returned in <code class="literal">COMMIT_ORDER</code>
                                mode.
                            </p><p style="color:blue;">writeset和writeset_会话模式不会传递比commit_order模式下返回的事务依赖项更新的任何事务依赖项。</p><p>
                                The value of this variable cannot be set to anything other
                                than <code class="literal">COMMIT_ORDER</code> if
                                <a class="link" href="replication.html#sysvar_transaction_write_set_extraction"><code class="literal">transaction_write_set_extraction</code></a>
                                is <code class="literal">OFF</code>. You should also note that the
                                value of <code class="literal">transaction_write_set_extraction</code>
                                cannot be changed if the current value of
                                <code class="literal">binlog_transaction_dependency_tracking</code> is
                                <code class="literal">WRITESET</code> or
                                <code class="literal">WRITESET_SESSION</code>.
                            </p><p style="color:blue;">如果关闭事务写入设置提取，则此变量的值不能设置为除提交顺序之外的任何其他值。还应注意，如果binlog_transaction_dependency_tracking的当前值是write set或writeset_session，则无法更改transaction_write_set_extraction的值。</p><p>
                                The number of row hashes to be kept and checked for the
                                latest transaction to have changed a given row is determined
                                by the value of
                                <a class="link" href="replication.html#sysvar_binlog_transaction_dependency_history_size"><code class="literal">binlog_transaction_dependency_history_size</code></a>.
                            </p><p style="color:blue;">要保留并检查最新事务是否已更改给定行的行哈希数由binlog_transaction_dependency_history_size的值确定。</p></li><li class="listitem"><p><a name="sysvar_binlog_transaction_dependency_history_size"></a>
                            <a class="indexterm" name="idm140286795875296"></a>

                            <a class="indexterm" name="idm140286795874176"></a>

                            <a class="link" href="replication.html#sysvar_binlog_transaction_dependency_history_size"><code class="literal">binlog_transaction_dependency_history_size</code></a>
                        </p><p style="color:blue;">binlog_事务依赖关系历史记录大小</p>
                            <div class="informaltable">
                                <table frame="box" rules="all" summary="Properties for binlog_transaction_dependency_history_size"><colgroup><col width="30%"><col width="70%"></colgroup><thead><tr><th scope="col">Property</th>
                                    <th scope="col">Value</th>
                                </tr></thead><tbody><tr><td scope="row"><span class="bold"><strong>Command-Line Format</strong></span></td>
                                    <td><code class="literal">--binlog-transaction-dependency-history-size=#</code></td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Introduced</strong></span></td>
                                    <td>5.7.22</td>
                                </tr><tr><td scope="row"><span class="bold"><strong>System Variable</strong></span></td>
                                    <td><code class="literal"><a class="link" href="replication.html#sysvar_binlog_transaction_dependency_history_size">binlog_transaction_dependency_history_size</a></code></td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Scope</strong></span></td>
                                    <td>Global</td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Dynamic</strong></span></td>
                                    <td>Yes</td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Type</strong></span></td>
                                    <td>Integer</td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Default Value</strong></span></td>
                                    <td><code class="literal">25000</code></td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Minimum Value</strong></span></td>
                                    <td><code class="literal">1</code></td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Maximum Value</strong></span></td>
                                    <td><code class="literal">1000000</code></td>
                                </tr></tbody></table>
                            </div>
                            <p>
                                Sets an upper limit on the number of row hashes which are
                                kept in memory and used for looking up the transaction that
                                last modified a given row. Once this number of hashes has
                                been reached, the history is purged.
                            </p><p style="color:blue;">设置保留在内存中并用于查找上次修改给定行的事务的行哈希数的上限。一旦达到此哈希数，将清除历史记录。</p></li><li class="listitem"><p><a name="sysvar_expire_logs_days"></a>
                            <a class="indexterm" name="idm140286795836864"></a>

                            <a class="indexterm" name="idm140286795835808"></a>

                            <a class="link" href="replication.html#sysvar_expire_logs_days"><code class="literal">expire_logs_days</code></a>
                        </p><p style="color:blue;">日志过期天数</p>
                            <div class="informaltable">
                                <table frame="box" rules="all" summary="Properties for expire_logs_days"><colgroup><col width="30%"><col width="70%"></colgroup><thead><tr><th scope="col">Property</th>
                                    <th scope="col">Value</th>
                                </tr></thead><tbody><tr><td scope="row"><span class="bold"><strong>Command-Line Format</strong></span></td>
                                    <td><code class="literal">--expire-logs-days=#</code></td>
                                </tr><tr><td scope="row"><span class="bold"><strong>System Variable</strong></span></td>
                                    <td><code class="literal"><a class="link" href="replication.html#sysvar_expire_logs_days">expire_logs_days</a></code></td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Scope</strong></span></td>
                                    <td>Global</td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Dynamic</strong></span></td>
                                    <td>Yes</td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Type</strong></span></td>
                                    <td>Integer</td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Default Value</strong></span></td>
                                    <td><code class="literal">0</code></td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Minimum Value</strong></span></td>
                                    <td><code class="literal">0</code></td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Maximum Value</strong></span></td>
                                    <td><code class="literal">99</code></td>
                                </tr></tbody></table>
                            </div>
                            <p>
                                The number of days for automatic binary log file removal.
                                The default is 0, which means <span class="quote">“<span class="quote">no automatic
            removal.</span>”</span> Possible removals happen at startup and
                                when the binary log is flushed. Log flushing occurs as
                                indicated in <a class="xref" href="server-administration.html#server-logs" title="5.4&nbsp;MySQL Server Logs">Section&nbsp;5.4, “MySQL Server Logs”</a>.
                            </p><p style="color:blue;">自动删除二进制日志文件的天数。默认值为0，这意味着“没有自动删除”。可能的删除发生在启动和刷新二进制日志时。日志刷新如5.4节“MySQL服务器日志”所示。</p><p>
                                To remove binary log files manually, use the
                                <a class="link" href="sql-syntax.html#purge-binary-logs" title="13.4.1.1&nbsp;PURGE BINARY LOGS Syntax"><code class="literal">PURGE BINARY LOGS</code></a> statement.
                                See <a class="xref" href="sql-syntax.html#purge-binary-logs" title="13.4.1.1&nbsp;PURGE BINARY LOGS Syntax">Section&nbsp;13.4.1.1, “PURGE BINARY LOGS Syntax”</a>.
                            </p><p style="color:blue;">要手动删除二进制日志文件，请使用purge binary logs语句。见第13.4.1.1节“清除二进制日志语法”。</p></li><li class="listitem"><p><a name="sysvar_log_backward_compatible_user_definitions"></a>
                            <a class="indexterm" name="idm140286795797840"></a>

                            <a class="indexterm" name="idm140286795796720"></a>

                            <a class="link" href="replication.html#sysvar_log_backward_compatible_user_definitions"><code class="literal">log_backward_compatible_user_definitions</code></a>
                        </p><p style="color:blue;">日志向后兼容用户定义</p>
                            <div class="informaltable">
                                <table frame="box" rules="all" summary="Properties for log_backward_compatible_user_definitions"><colgroup><col width="30%"><col width="70%"></colgroup><thead><tr><th scope="col">Property</th>
                                    <th scope="col">Value</th>
                                </tr></thead><tbody><tr><td scope="row"><span class="bold"><strong>Command-Line Format</strong></span></td>
                                    <td><code class="literal">--log-backward-compatible-user-definitions[={OFF|ON}]</code></td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Introduced</strong></span></td>
                                    <td>5.7.6</td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Removed</strong></span></td>
                                    <td>5.7.9</td>
                                </tr><tr><td scope="row"><span class="bold"><strong>System Variable</strong></span></td>
                                    <td><code class="literal"><a class="link" href="replication.html#sysvar_log_backward_compatible_user_definitions">log_backward_compatible_user_definitions</a></code></td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Scope</strong></span></td>
                                    <td>Global</td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Dynamic</strong></span></td>
                                    <td>Yes</td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Type</strong></span></td>
                                    <td>Boolean</td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Default Value</strong></span></td>
                                    <td><code class="literal">OFF</code></td>
                                </tr></tbody></table>
                            </div>
                            <p>
                                Whether to log the
                                <em class="replaceable"><code>user_specification</code></em> part of
                                <a class="link" href="sql-syntax.html#create-user" title="13.7.1.2&nbsp;CREATE USER Syntax"><code class="literal">CREATE USER</code></a>,
                                <a class="link" href="sql-syntax.html#alter-user" title="13.7.1.1&nbsp;ALTER USER Syntax"><code class="literal">ALTER USER</code></a>, and
                                <a class="link" href="sql-syntax.html#grant" title="13.7.1.4&nbsp;GRANT Syntax"><code class="literal">GRANT</code></a> statements in
                                backward-compatible (pre-5.7.6) fashion:
                            </p><p style="color:blue;">是否以向后兼容（5.7.6之前）的方式记录create user、alter user和grant语句的user_规范部分：</p>
                            <div class="itemizedlist">
                                <ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
                                    By default, this variable is disabled. The server writes
                                    user specifications as
                                    <code class="literal"><em class="replaceable"><code>user</code></em> IDENTIFIED WITH
                                        <em class="replaceable"><code>auth_plugin</code></em> AS
                                        '<em class="replaceable"><code>auth_string</code></em>'</code>.
                                </p><p style="color:blue;">默认情况下，此变量被禁用。服务器将用户规范作为用户写入，并将auth_plugin标识为“auth_string”。</p></li><li class="listitem"><p>
                                    When enabled, the server writes user specifications as
                                    <code class="literal"><em class="replaceable"><code>user</code></em> IDENTIFIED BY
                                        PASSWORD
                                        '<em class="replaceable"><code>auth_string</code></em>'</code>.
                                    Enabling this variable ensures better compatibility for
                                    cross-version replication.
                                </p><p style="color:blue;">启用时，服务器将用户规范写入为由密码“auth_string”标识的用户。启用此变量可确保跨版本复制的更好兼容性。</p></li></ul>
                            </div>
                            <p>
                                This variable was removed in MySQL 5.7.9 and replaced by
                                <a class="link" href="replication.html#sysvar_log_builtin_as_identified_by_password"><code class="literal">log_builtin_as_identified_by_password</code></a>.
                            </p><p style="color:blue;">这个变量在mysql 5.7.9中被删除，并替换为log_builtin_as_identified_by_password。</p></li><li class="listitem"><p><a name="sysvar_log_bin"></a>
                            <a class="indexterm" name="idm140286795751424"></a>

                            <a class="indexterm" name="idm140286795750384"></a>

                            <a class="link" href="replication.html#sysvar_log_bin"><code class="literal">log_bin</code></a>
                        </p><p style="color:blue;">木箱</p>
                            <div class="informaltable">
                                <table frame="box" rules="all" summary="Properties for log_bin"><colgroup><col width="30%"><col width="70%"></colgroup><thead><tr><th scope="col">Property</th>
                                    <th scope="col">Value</th>
                                </tr></thead><tbody><tr><td scope="row"><span class="bold"><strong>System Variable</strong></span></td>
                                    <td><code class="literal"><a class="link" href="replication.html#sysvar_log_bin">log_bin</a></code></td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Scope</strong></span></td>
                                    <td>Global</td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Dynamic</strong></span></td>
                                    <td>No</td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Type</strong></span></td>
                                    <td>Boolean</td>
                                </tr></tbody></table>
                            </div>
                            <p>
                                Whether the binary log is enabled. If the
                                <a class="link" href="replication.html#option_mysqld_log-bin"><code class="option">--log-bin</code></a> option is used,
                                then the value of this variable is <code class="literal">ON</code>;
                                otherwise it is <code class="literal">OFF</code>. This variable
                                reports only on the status of binary logging (enabled or
                                disabled); it does not actually report the value to which
                                <a class="link" href="replication.html#option_mysqld_log-bin"><code class="option">--log-bin</code></a> is set.
                            </p><p style="color:blue;">是否启用二进制日志。如果使用--log bin选项，则该变量的值为on；否则为off。此变量仅报告二进制日志记录（启用或禁用）的状态；它实际上不报告设置--log bin的值。</p><p>
                                See <a class="xref" href="server-administration.html#binary-log" title="5.4.4&nbsp;The Binary Log">Section&nbsp;5.4.4, “The Binary Log”</a>.
                            </p><p style="color:blue;">见第5.4.4节“二进制日志”。</p></li><li class="listitem"><p><a name="sysvar_log_bin_basename"></a>
                            <a class="indexterm" name="idm140286795723872"></a>

                            <a class="indexterm" name="idm140286795722816"></a>

                            <a class="link" href="replication.html#sysvar_log_bin_basename"><code class="literal">log_bin_basename</code></a>
                        </p><p style="color:blue;">日志基名称</p>
                            <div class="informaltable">
                                <table frame="box" rules="all" summary="Properties for log_bin_basename"><colgroup><col width="30%"><col width="70%"></colgroup><thead><tr><th scope="col">Property</th>
                                    <th scope="col">Value</th>
                                </tr></thead><tbody><tr><td scope="row"><span class="bold"><strong>System Variable</strong></span></td>
                                    <td><code class="literal"><a class="link" href="replication.html#sysvar_log_bin_basename">log_bin_basename</a></code></td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Scope</strong></span></td>
                                    <td>Global</td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Dynamic</strong></span></td>
                                    <td>No</td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Type</strong></span></td>
                                    <td>File name</td>
                                </tr></tbody></table>
                            </div>
                            <p>
                                Holds the base name and path for the binary log files, which
                                can be set with the <a class="link" href="replication.html#option_mysqld_log-bin"><code class="option">--log-bin</code></a>
                                server option. In MySQL 5.7, the default base name is the
                                name of the host machine with the suffix
                                <code class="literal">-bin</code>. The default location is the data
                                directory.
                            </p><p style="color:blue;">保存二进制日志文件的基本名称和路径，可以使用--log bin server选项设置。在mysql 5.7中，默认的基名是主机名，后缀为-bin。默认位置是数据目录。</p></li><li class="listitem"><p><a name="sysvar_log_bin_index"></a>
                            <a class="indexterm" name="idm140286795698976"></a>

                            <a class="indexterm" name="idm140286795697920"></a>

                            <a class="link" href="replication.html#sysvar_log_bin_index"><code class="literal">log_bin_index</code></a>
                        </p><p style="color:blue;">日志索引</p>
                            <div class="informaltable">
                                <table frame="box" rules="all" summary="Properties for log-bin-index"><colgroup><col width="30%"><col width="70%"></colgroup><thead><tr><th scope="col">Property</th>
                                    <th scope="col">Value</th>
                                </tr></thead><tbody><tr><td scope="row"><span class="bold"><strong>Command-Line Format</strong></span></td>
                                    <td><code class="literal">--log-bin-index=file_name</code></td>
                                </tr><tr><td scope="row"><span class="bold"><strong>System Variable</strong></span></td>
                                    <td><code class="literal"><a class="link" href="replication.html#sysvar_log_bin_index">log_bin_index</a></code></td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Scope</strong></span></td>
                                    <td>Global</td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Dynamic</strong></span></td>
                                    <td>No</td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Type</strong></span></td>
                                    <td>File name</td>
                                </tr></tbody></table>
                            </div>
                            <p>
                                Holds the base name and path for the binary log index file,
                                which can be set with the
                                <a class="link" href="replication.html#option_mysqld_log-bin-index"><code class="option">--log-bin-index</code></a> server
                                option.
                            </p><p style="color:blue;">保存二进制日志索引文件的基名称和路径，可以使用--log bin index server选项设置。</p></li><li class="listitem"><p><a name="sysvar_log_bin_trust_function_creators"></a>
                            <a class="indexterm" name="idm140286795671760"></a>

                            <a class="indexterm" name="idm140286795670656"></a>

                            <a class="link" href="replication.html#sysvar_log_bin_trust_function_creators"><code class="literal">log_bin_trust_function_creators</code></a>
                        </p><p style="color:blue;">Log_Bin_Trust_Function_创建者</p>
                            <div class="informaltable">
                                <table frame="box" rules="all" summary="Properties for log_bin_trust_function_creators"><colgroup><col width="30%"><col width="70%"></colgroup><thead><tr><th scope="col">Property</th>
                                    <th scope="col">Value</th>
                                </tr></thead><tbody><tr><td scope="row"><span class="bold"><strong>Command-Line Format</strong></span></td>
                                    <td><code class="literal">--log-bin-trust-function-creators[={OFF|ON}]</code></td>
                                </tr><tr><td scope="row"><span class="bold"><strong>System Variable</strong></span></td>
                                    <td><code class="literal"><a class="link" href="replication.html#sysvar_log_bin_trust_function_creators">log_bin_trust_function_creators</a></code></td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Scope</strong></span></td>
                                    <td>Global</td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Dynamic</strong></span></td>
                                    <td>Yes</td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Type</strong></span></td>
                                    <td>Boolean</td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Default Value</strong></span></td>
                                    <td><code class="literal">OFF</code></td>
                                </tr></tbody></table>
                            </div>
                            <p>
                                This variable applies when binary logging is enabled. It
                                controls whether stored function creators can be trusted not
                                to create stored functions that will cause unsafe events to
                                be written to the binary log. If set to 0 (the default),
                                users are not permitted to create or alter stored functions
                                unless they have the <a class="link" href="security.html#priv_super"><code class="literal">SUPER</code></a>
                                privilege in addition to the <a class="link" href="security.html#priv_create-routine"><code class="literal">CREATE
                                ROUTINE</code></a> or <a class="link" href="security.html#priv_alter-routine"><code class="literal">ALTER
                                ROUTINE</code></a> privilege. A setting of 0 also enforces
                                the restriction that a function must be declared with the
                                <code class="literal">DETERMINISTIC</code> characteristic, or with the
                                <code class="literal">READS SQL DATA</code> or <code class="literal">NO
                                SQL</code> characteristic. If the variable is set to 1,
                                MySQL does not enforce these restrictions on stored function
                                creation. This variable also applies to trigger creation.
                                See <a class="xref" href="stored-objects.html#stored-programs-logging" title="23.7&nbsp;Stored Program Binary Logging">Section&nbsp;23.7, “Stored Program Binary Logging”</a>.
                            </p><p style="color:blue;">启用二进制日志记录时应用此变量。它控制是否可以信任存储函数创建者，而不创建将导致不安全事件写入二进制日志的存储函数。如果设置为0（默认值），则不允许用户创建或更改存储函数，除非用户除了具有“创建例程”或“更改例程”权限外，还具有“超级”权限。设置为0还强制执行以下限制：必须使用确定性特征、读取SQL数据或不使用SQL特征声明函数。如果变量设置为1，mysql不会对存储函数的创建实施这些限制。此变量也适用于触发器创建。参见第23.7节“存储程序二进制日志”。</p></li><li class="listitem"><p><a name="sysvar_log_bin_use_v1_row_events"></a>
                            <a class="indexterm" name="idm140286795635168"></a>

                            <a class="indexterm" name="idm140286795634064"></a>

                            <a class="link" href="replication.html#sysvar_log_bin_use_v1_row_events"><code class="literal">log_bin_use_v1_row_events</code></a>
                        </p><p style="color:blue;">日志文件使用v1行事件</p>
                            <div class="informaltable">
                                <table frame="box" rules="all" summary="Properties for log_bin_use_v1_row_events"><colgroup><col width="30%"><col width="70%"></colgroup><thead><tr><th scope="col">Property</th>
                                    <th scope="col">Value</th>
                                </tr></thead><tbody><tr><td scope="row"><span class="bold"><strong>Command-Line Format</strong></span></td>
                                    <td><code class="literal">--log-bin-use-v1-row-events[={OFF|ON}]</code></td>
                                </tr><tr><td scope="row"><span class="bold"><strong>System Variable</strong></span></td>
                                    <td><code class="literal"><a class="link" href="replication.html#sysvar_log_bin_use_v1_row_events">log_bin_use_v1_row_events</a></code></td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Scope</strong></span></td>
                                    <td>Global</td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Dynamic</strong></span></td>
                                    <td>No</td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Type</strong></span></td>
                                    <td>Boolean</td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Default Value</strong></span></td>
                                    <td><code class="literal">OFF</code></td>
                                </tr></tbody></table>
                            </div>
                            <p>
                                Whether Version 2 binary logging is in use. If this variable
                                is 0 (disabled, the default), Version 2 binary log events
                                are in use. If this variable is 1 (enabled), the server
                                writes the binary log using Version 1 logging events (the
                                only version of binary log events used in previous
                                releases), and thus produces a binary log that can be read
                                by older slaves.
                            </p><p style="color:blue;">是否正在使用版本2二进制日志记录。如果此变量为0（禁用，默认值），则使用版本2二进制日志事件。如果此变量为1（已启用），则服务器使用版本1日志事件（以前版本中使用的唯一版本的二进制日志事件）写入二进制日志，从而生成可由较旧的从属服务器读取的二进制日志。</p><p>
                                MySQL 5.7 uses Version 2 binary log row events
                                by default. However, Version 2 events cannot be read by
                                MySQL Server releases prior to MySQL 5.6.6. Enabling
                                <a class="link" href="replication.html#sysvar_log_bin_use_v1_row_events"><code class="literal">log_bin_use_v1_row_events</code></a>
                                causes <a class="link" href="programs.html#mysqld" title="4.3.1&nbsp;mysqld — The MySQL Server"><span class="command"><strong>mysqld</strong></span></a> to write the binary log
                                using Version 1 logging events.
                            </p><p style="color:blue;">mysql 5.7默认使用版本2二进制日志行事件。但是，5.6.6之前的mysql服务器版本无法读取版本2事件。启用log_bin_use_v1_row_events会导致mysqld使用版本1日志事件写入二进制日志。</p><p>
                                This variable is read-only at runtime. To switch between
                                Version 1 and Version 2 binary event binary logging, it is
                                necessary to set
                                <a class="link" href="replication.html#sysvar_log_bin_use_v1_row_events"><code class="literal">log_bin_use_v1_row_events</code></a>
                                at server startup.
                            </p><p style="color:blue;">此变量在运行时为只读。若要在版本1和版本2二进制事件日志记录之间切换，必须在服务器启动时设置Log_bin_Use_v1_Row_Events。</p><p>
                                Other than when performing upgrades of NDB Cluster
                                Replication,
                                <a class="link" href="replication.html#sysvar_log_bin_use_v1_row_events"><code class="literal">log_bin_use_v1_row_events</code></a>
                                is chiefly of interest when setting up replication conflict
                                detection and resolution using
                                <code class="literal">NDB$EPOCH_TRANS()</code> as the conflict
                                detection function, which requires Version 2 binary log row
                                events. Thus, this variable and
                                <a class="link" href="mysql-cluster.html#option_mysqld_ndb-log-transaction-id"><code class="option">--ndb-log-transaction-id</code></a> are
                                not compatible.
                            </p><p style="color:blue;">除了在执行ndb群集复制的升级时，在使用ndb$epoch_trans（）作为冲突检测函数设置复制冲突检测和解决时，主要关心的是log_bin_use_v1_row_events，这需要版本2的二进制日志行事件。因此，此变量与--ndb日志事务ID不兼容。</p>
                            <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">

                                <div class="admon-title">
                                    Note
                                </div>
                                <p>
                                    MySQL NDB Cluster 7.5 uses Version 2 binary log row events
                                    by default. You should keep this mind when planning
                                    upgrades or downgrades, and for setups using NDB Cluster
                                    Replication.
                                </p><p style="color:blue;">mysql ndb cluster 7.5默认使用版本2二进制日志行事件。在计划升级或降级以及使用ndb群集复制进行设置时，应记住这一点。</p>
                            </div>
                            <p>
                                For more information, see
                                <a class="xref" href="mysql-cluster.html#mysql-cluster-replication-conflict-resolution" title="21.6.11&nbsp;NDB Cluster Replication Conflict Resolution">Section&nbsp;21.6.11, “NDB Cluster Replication Conflict Resolution”</a>.
                            </p><p style="color:blue;">有关更多信息，请参阅21.6.11节“NDB群集复制冲突解决”。</p></li><li class="listitem"><p><a name="sysvar_log_builtin_as_identified_by_password"></a>
                            <a class="indexterm" name="idm140286795594336"></a>

                            <a class="indexterm" name="idm140286795593296"></a>

                            <a class="link" href="replication.html#sysvar_log_builtin_as_identified_by_password"><code class="literal">log_builtin_as_identified_by_password</code></a>
                        </p><p style="color:blue;">以密码识别的方式登录</p>
                            <div class="informaltable">
                                <table frame="box" rules="all" summary="Properties for log_builtin_as_identified_by_password"><colgroup><col width="30%"><col width="70%"></colgroup><thead><tr><th scope="col">Property</th>
                                    <th scope="col">Value</th>
                                </tr></thead><tbody><tr><td scope="row"><span class="bold"><strong>Command-Line Format</strong></span></td>
                                    <td><code class="literal">--log-builtin-as-identified-by-password[={OFF|ON}]</code></td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Introduced</strong></span></td>
                                    <td>5.7.9</td>
                                </tr><tr><td scope="row"><span class="bold"><strong>System Variable</strong></span></td>
                                    <td><code class="literal"><a class="link" href="replication.html#sysvar_log_builtin_as_identified_by_password">log_builtin_as_identified_by_password</a></code></td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Scope</strong></span></td>
                                    <td>Global</td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Dynamic</strong></span></td>
                                    <td>Yes</td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Type</strong></span></td>
                                    <td>Boolean</td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Default Value</strong></span></td>
                                    <td><code class="literal">OFF</code></td>
                                </tr></tbody></table>
                            </div>
                            <p>
                                This variable affects binary logging of user-management
                                statements. When enabled, the variable has the following
                                effects:
                            </p><p style="color:blue;">此变量影响用户管理语句的二进制日志记录。启用时，变量具有以下效果：</p>
                            <div class="itemizedlist">
                                <ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
                                    Binary logging for <a class="link" href="sql-syntax.html#create-user" title="13.7.1.2&nbsp;CREATE USER Syntax"><code class="literal">CREATE
                                    USER</code></a> statements involving built-in
                                    authentication plugins rewrites the statements to
                                    include an <code class="literal">IDENTIFIED BY PASSWORD</code>
                                    clause.
                                </p><p style="color:blue;">包含内置身份验证插件的create user语句的二进制日志将重写该语句以包含一个identified by password子句。</p></li><li class="listitem"><p>
                                    <a class="link" href="sql-syntax.html#set-password" title="13.7.1.7&nbsp;SET PASSWORD Syntax"><code class="literal">SET PASSWORD</code></a> statements
                                    are logged as <a class="link" href="sql-syntax.html#set-password" title="13.7.1.7&nbsp;SET PASSWORD Syntax"><code class="literal">SET
                                    PASSWORD</code></a> statements, rather than being
                                    rewritten to <a class="link" href="sql-syntax.html#alter-user" title="13.7.1.1&nbsp;ALTER USER Syntax"><code class="literal">ALTER USER</code></a>
                                    statements.
                                </p><p style="color:blue;">set password语句被记录为set password语句，而不是被重写以更改用户语句。</p></li><li class="listitem"><p>
                                    <a class="link" href="sql-syntax.html#set-password" title="13.7.1.7&nbsp;SET PASSWORD Syntax"><code class="literal">SET PASSWORD</code></a> statements
                                    are changed to log the hash of the password instead of
                                    the supplied cleartext (unencrypted) password.
                                </p><p style="color:blue;">set password语句被更改为记录密码的哈希值，而不是提供的明文（未加密）密码。</p></li></ul>
                            </div>
                            <p>
                                Enabling this variable ensures better compatibility for
                                cross-version replication with 5.6 and pre-5.7.6 slaves, and
                                for applications that expect this syntax in the binary log.
                            </p><p style="color:blue;">启用此变量可确保与5.6版和5.7.6版以前的从属版本的跨版本复制以及希望在二进制日志中使用此语法的应用程序具有更好的兼容性。</p><p>
                                This variable was added in MySQL 5.7.9. It replaces the
                                <a class="link" href="replication.html#sysvar_log_backward_compatible_user_definitions"><code class="literal">log_backward_compatible_user_definitions</code></a>
                                variable.
                            </p><p style="color:blue;">这个变量是在mysql 5.7.9中添加的。它替换log_backward_compatible_user_definitions变量。</p></li><li class="listitem"><p><a name="sysvar_log_slave_updates"></a>
                            <a class="link" href="replication.html#sysvar_log_slave_updates"><code class="literal">log_slave_updates</code></a>

                            <a class="indexterm" name="idm140286795548496"></a>

                            <a class="indexterm" name="idm140286795547456"></a>
                        </p><p style="color:blue;">日志从更新</p>
                            <div class="informaltable">
                                <table frame="box" rules="all" summary="Properties for log_slave_updates"><colgroup><col width="30%"><col width="70%"></colgroup><thead><tr><th scope="col">Property</th>
                                    <th scope="col">Value</th>
                                </tr></thead><tbody><tr><td scope="row"><span class="bold"><strong>Command-Line Format</strong></span></td>
                                    <td><code class="literal">--log-slave-updates[={OFF|ON}]</code></td>
                                </tr><tr><td scope="row"><span class="bold"><strong>System Variable</strong></span></td>
                                    <td><code class="literal"><a class="link" href="replication.html#sysvar_log_slave_updates">log_slave_updates</a></code></td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Scope</strong></span></td>
                                    <td>Global</td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Dynamic</strong></span></td>
                                    <td>No</td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Type</strong></span></td>
                                    <td>Boolean</td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Default Value</strong></span></td>
                                    <td><code class="literal">OFF</code></td>
                                </tr></tbody></table>
                            </div>
                            <p>
                                Whether updates received by a slave server from a master
                                server should be logged to the slave's own binary log.
                            </p><p style="color:blue;">从服务器从主服务器接收到的更新是否应记录到从服务器自己的二进制日志中。</p><p>
                                Normally, a slave does not log to its own binary log any
                                updates that are received from a master server. Enabling
                                this variable causes the slave to write the updates
                                performed by its SQL thread to its own binary log. For this
                                option to have any effect, the slave must also be started
                                with the <a class="link" href="replication.html#option_mysqld_log-bin"><code class="option">--log-bin</code></a> option to
                                enable binary logging. See
                                <a class="xref" href="replication.html#replication-options" title="16.1.6&nbsp;Replication and Binary Logging Options and Variables">Section&nbsp;16.1.6, “Replication and Binary Logging Options and Variables”</a>.
                            </p><p style="color:blue;">通常，从服务器不会将从主服务器接收到的任何更新记录到自己的二进制日志中。启用此变量会导致从属服务器将其SQL线程执行的更新写入其自己的二进制日志。要使此选项产生任何效果，还必须使用--log bin选项启动从属服务器，以启用二进制日志记录。见16.1.6节，“复制和二进制日志选项和变量”。</p><p>
                                <a class="link" href="replication.html#sysvar_log_slave_updates"><code class="literal">log_slave_updates</code></a> is
                                enabled when you want to chain replication servers. For
                                example, you might want to set up replication servers using
                                this arrangement:
                            </p><p style="color:blue;">如果要链接复制服务器，则会启用日志从属更新。例如，您可能希望使用以下安排设置复制服务器：</p><pre data-lang="none" class="programlisting">A -&gt; B -&gt; C
</pre><p>
                                Here, <code class="literal">A</code> serves as the master for the
                                slave <code class="literal">B</code>, and <code class="literal">B</code> serves
                                as the master for the slave <code class="literal">C</code>. For this
                                to work, <code class="literal">B</code> must be both a master
                                <span class="emphasis"><em>and</em></span> a slave. You must start both
                                <code class="literal">A</code> and <code class="literal">B</code> with
                                <a class="link" href="replication.html#option_mysqld_log-bin"><code class="option">--log-bin</code></a> to enable binary
                                logging, and <code class="literal">B</code> with
                                <a class="link" href="replication.html#sysvar_log_slave_updates"><code class="literal">log_slave_updates</code></a> enabled
                                so that updates received from <code class="literal">A</code> are
                                logged by <code class="literal">B</code> to its binary log.
                            </p><p style="color:blue;">在这里，a作为从机b的主机，b作为从机c的主机。要实现这一点，b必须既是主机又是从机。必须同时用--log bin启动A和B以启用二进制日志记录，而用log_slave_updates启动B以使B将从A接收到的更新记录到其二进制日志中。</p></li><li class="listitem"><p><a name="sysvar_log_statements_unsafe_for_binlog"></a>
                            <a class="indexterm" name="idm140286795504976"></a>

                            <a class="indexterm" name="idm140286795503872"></a>

                            <a class="link" href="replication.html#sysvar_log_statements_unsafe_for_binlog"><code class="literal">log_statements_unsafe_for_binlog</code></a>
                        </p><p style="color:blue;">日志语句不安全</p>
                            <div class="informaltable">
                                <table frame="box" rules="all" summary="Properties for log_statements_unsafe_for_binlog"><colgroup><col width="30%"><col width="70%"></colgroup><thead><tr><th scope="col">Property</th>
                                    <th scope="col">Value</th>
                                </tr></thead><tbody><tr><td scope="row"><span class="bold"><strong>Command-Line Format</strong></span></td>
                                    <td><code class="literal">--log-statements-unsafe-for-binlog[={OFF|ON}]</code></td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Introduced</strong></span></td>
                                    <td>5.7.11</td>
                                </tr><tr><td scope="row"><span class="bold"><strong>System Variable</strong></span></td>
                                    <td><code class="literal"><a class="link" href="replication.html#sysvar_log_statements_unsafe_for_binlog">log_statements_unsafe_for_binlog</a></code></td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Scope</strong></span></td>
                                    <td>Global</td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Dynamic</strong></span></td>
                                    <td>Yes</td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Type</strong></span></td>
                                    <td>Boolean</td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Default Value</strong></span></td>
                                    <td><code class="literal">ON</code></td>
                                </tr></tbody></table>
                            </div>
                            <p>
                                If error 1592 is encountered, controls whether the generated
                                warnings are added to the error log or not.
                            </p><p style="color:blue;">如果遇到错误1592，则控制是否将生成的警告添加到错误日志中。</p></li><li class="listitem"><p><a name="sysvar_master_verify_checksum"></a>
                            <a class="indexterm" name="idm140286795472864"></a>

                            <a class="indexterm" name="idm140286795471824"></a>

                            <a class="link" href="replication.html#sysvar_master_verify_checksum"><code class="literal">master_verify_checksum</code></a>
                        </p><p style="color:blue;">主校验和</p>
                            <div class="informaltable">
                                <table frame="box" rules="all" summary="Properties for master_verify_checksum"><colgroup><col width="30%"><col width="70%"></colgroup><thead><tr><th scope="col">Property</th>
                                    <th scope="col">Value</th>
                                </tr></thead><tbody><tr><td scope="row"><span class="bold"><strong>Command-Line Format</strong></span></td>
                                    <td><code class="literal">--master-verify-checksum[={OFF|ON}]</code></td>
                                </tr><tr><td scope="row"><span class="bold"><strong>System Variable</strong></span></td>
                                    <td><code class="literal"><a class="link" href="replication.html#sysvar_master_verify_checksum">master_verify_checksum</a></code></td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Scope</strong></span></td>
                                    <td>Global</td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Dynamic</strong></span></td>
                                    <td>Yes</td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Type</strong></span></td>
                                    <td>Boolean</td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Default Value</strong></span></td>
                                    <td><code class="literal">OFF</code></td>
                                </tr></tbody></table>
                            </div>
                            <p>
                                Enabling this variable causes the master to examine
                                checksums when reading from the binary log.
                                <code class="literal">master_verify_checksum</code> is disabled by
                                default; in this case, the master uses the event length from
                                the binary log to verify events, so that only complete
                                events are read from the binary log.
                            </p><p style="color:blue;">启用此变量会导致主机在读取二进制日志时检查校验和。默认情况下，master_verify_校验和处于禁用状态；在这种情况下，master使用二进制日志中的事件长度来验证事件，以便仅从二进制日志中读取完整的事件。</p></li><li class="listitem"><p><a name="sysvar_max_binlog_cache_size"></a>
                            <a class="indexterm" name="idm140286795442640"></a>

                            <a class="indexterm" name="idm140286795441600"></a>

                            <a class="link" href="replication.html#sysvar_max_binlog_cache_size"><code class="literal">max_binlog_cache_size</code></a>
                        </p><p style="color:blue;">最大缓存大小</p>
                            <div class="informaltable">
                                <table frame="box" rules="all" summary="Properties for max_binlog_cache_size"><colgroup><col width="30%"><col width="70%"></colgroup><thead><tr><th scope="col">Property</th>
                                    <th scope="col">Value</th>
                                </tr></thead><tbody><tr><td scope="row"><span class="bold"><strong>Command-Line Format</strong></span></td>
                                    <td><code class="literal">--max-binlog-cache-size=#</code></td>
                                </tr><tr><td scope="row"><span class="bold"><strong>System Variable</strong></span></td>
                                    <td><code class="literal"><a class="link" href="replication.html#sysvar_max_binlog_cache_size">max_binlog_cache_size</a></code></td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Scope</strong></span></td>
                                    <td>Global</td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Dynamic</strong></span></td>
                                    <td>Yes</td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Type</strong></span></td>
                                    <td>Integer</td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Default Value</strong></span></td>
                                    <td><code class="literal">18446744073709551615</code></td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Minimum Value</strong></span></td>
                                    <td><code class="literal">4096</code></td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Maximum Value</strong></span></td>
                                    <td><code class="literal">18446744073709551615</code></td>
                                </tr></tbody></table>
                            </div>
                            <p>
                                If a transaction requires more than this many bytes of
                                memory, the server generates a <span class="errortext">Multi-statement
            transaction required more than 'max_binlog_cache_size' bytes
            of storage</span> error. The minimum value is 4096. The
                                maximum possible value is 16EB (exabytes). The maximum
                                recommended value is 4GB; this is due to the fact that MySQL
                                currently cannot work with binary log positions greater than
                                4GB.
                            </p><p style="color:blue;">如果一个事务需要的内存超过这个字节数，服务器将生成一个多语句事务，需要的存储错误超过“max_binlog_cache_size”字节数。最小值为4096。最大可能值为16EB（EXABYTEs）。最大推荐值是4GB；这是因为MySQL目前不能使用大于4GB的二进制日志位置。</p><p>
                                <code class="literal">max_binlog_cache_size</code> sets the size for
                                the transaction cache only; the upper limit for the
                                statement cache is governed by the
                                <a class="link" href="replication.html#sysvar_max_binlog_stmt_cache_size"><code class="literal">max_binlog_stmt_cache_size</code></a>
                                system variable.
                            </p><p style="color:blue;">max_binlog_cache_size仅设置事务缓存的大小；语句缓存的上限由max_binlog_stmt_cache_size系统变量控制。</p><p>
                                The visibility to sessions of
                                <code class="literal">max_binlog_cache_size</code> matches that of the
                                <a class="link" href="replication.html#sysvar_binlog_cache_size"><code class="literal">binlog_cache_size</code></a> system
                                variable; in other words, changing its value affects only
                                new sessions that are started after the value is changed.
                            </p><p style="color:blue;">max_binlog_cache_size的会话可见性与binlog_cache_size系统变量的会话可见性匹配；换言之，更改其值仅影响更改该值后启动的新会话。</p></li><li class="listitem"><p><a name="sysvar_max_binlog_size"></a>
                            <a class="indexterm" name="idm140286795401200"></a>

                            <a class="indexterm" name="idm140286795400192"></a>

                            <a class="link" href="replication.html#sysvar_max_binlog_size"><code class="literal">max_binlog_size</code></a>
                        </p><p style="color:blue;">最大值</p>
                            <div class="informaltable">
                                <table frame="box" rules="all" summary="Properties for max_binlog_size"><colgroup><col width="30%"><col width="70%"></colgroup><thead><tr><th scope="col">Property</th>
                                    <th scope="col">Value</th>
                                </tr></thead><tbody><tr><td scope="row"><span class="bold"><strong>Command-Line Format</strong></span></td>
                                    <td><code class="literal">--max-binlog-size=#</code></td>
                                </tr><tr><td scope="row"><span class="bold"><strong>System Variable</strong></span></td>
                                    <td><code class="literal"><a class="link" href="replication.html#sysvar_max_binlog_size">max_binlog_size</a></code></td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Scope</strong></span></td>
                                    <td>Global</td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Dynamic</strong></span></td>
                                    <td>Yes</td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Type</strong></span></td>
                                    <td>Integer</td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Default Value</strong></span></td>
                                    <td><code class="literal">1073741824</code></td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Minimum Value</strong></span></td>
                                    <td><code class="literal">4096</code></td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Maximum Value</strong></span></td>
                                    <td><code class="literal">1073741824</code></td>
                                </tr></tbody></table>
                            </div>
                            <p>
                                If a write to the binary log causes the current log file
                                size to exceed the value of this variable, the server
                                rotates the binary logs (closes the current file and opens
                                the next one). The minimum value is 4096 bytes. The maximum
                                and default value is 1GB.
                            </p><p style="color:blue;">如果对二进制日志的写入导致当前日志文件大小超过此变量的值，则服务器会旋转二进制日志（关闭当前文件并打开下一个文件）。最小值为4096字节。最大值和默认值为1GB。</p><p>
                                A transaction is written in one chunk to the binary log, so
                                it is never split between several binary logs. Therefore, if
                                you have big transactions, you might see binary log files
                                larger than
                                <a class="link" href="replication.html#sysvar_max_binlog_size"><code class="literal">max_binlog_size</code></a>.
                            </p><p style="color:blue;">事务以一个块的形式写入二进制日志，因此它永远不会在多个二进制日志之间分割。因此，如果有大型事务，可能会看到二进制日志文件大于最大binlog大小。</p><p>
                                If <a class="link" href="replication.html#sysvar_max_relay_log_size"><code class="literal">max_relay_log_size</code></a> is 0,
                                the value of
                                <a class="link" href="replication.html#sysvar_max_binlog_size"><code class="literal">max_binlog_size</code></a> applies to
                                relay logs as well.
                            </p><p style="color:blue;">如果max_relay_log_size为0，那么max_binlog_size的值也适用于中继日志。</p></li><li class="listitem"><p><a name="sysvar_max_binlog_stmt_cache_size"></a>
                            <a class="indexterm" name="idm140286795360800"></a>

                            <a class="indexterm" name="idm140286795359696"></a>

                            <a class="link" href="replication.html#sysvar_max_binlog_stmt_cache_size"><code class="literal">max_binlog_stmt_cache_size</code></a>
                        </p><p style="color:blue;">最大缓存大小</p>
                            <div class="informaltable">
                                <table frame="box" rules="all" summary="Properties for max_binlog_stmt_cache_size"><colgroup><col width="30%"><col width="70%"></colgroup><thead><tr><th scope="col">Property</th>
                                    <th scope="col">Value</th>
                                </tr></thead><tbody><tr><td scope="row"><span class="bold"><strong>Command-Line Format</strong></span></td>
                                    <td><code class="literal">--max-binlog-stmt-cache-size=#</code></td>
                                </tr><tr><td scope="row"><span class="bold"><strong>System Variable</strong></span></td>
                                    <td><code class="literal"><a class="link" href="replication.html#sysvar_max_binlog_stmt_cache_size">max_binlog_stmt_cache_size</a></code></td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Scope</strong></span></td>
                                    <td>Global</td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Dynamic</strong></span></td>
                                    <td>Yes</td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Type</strong></span></td>
                                    <td>Integer</td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Default Value</strong></span></td>
                                    <td><code class="literal">18446744073709547520</code></td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Minimum Value</strong></span></td>
                                    <td><code class="literal">4096</code></td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Maximum Value</strong></span></td>
                                    <td><code class="literal">18446744073709547520</code></td>
                                </tr></tbody></table>
                            </div>
                            <p>
                                If nontransactional statements within a transaction require
                                more than this many bytes of memory, the server generates an
                                error. The minimum value is 4096. The maximum and default
                                values are 4GB on 32-bit platforms and 16EB (exabytes) on
                                64-bit platforms.
                            </p><p style="color:blue;">如果事务中的非transaction语句需要的内存超过这个字节数，服务器将生成一个错误。最小值为4096。在64位平台上，最大和默认值是32位平台上的4GB和16EB（EXABYTES）。</p><p>
                                <code class="literal">max_binlog_stmt_cache_size</code> sets the size
                                for the statement cache only; the upper limit for the
                                transaction cache is governed exclusively by the
                                <a class="link" href="replication.html#sysvar_max_binlog_cache_size"><code class="literal">max_binlog_cache_size</code></a>
                                system variable.
                            </p><p style="color:blue;">max_binlog_stmt_cache_size仅设置语句缓存的大小；事务缓存的上限由max_binlog_cache_size系统变量独占控制。</p></li><li class="listitem"><p><a name="sysvar_sql_log_bin"></a>
                            <a class="indexterm" name="idm140286795322448"></a>

                            <a class="indexterm" name="idm140286795321440"></a>

                            <a class="link" href="replication.html#sysvar_sql_log_bin"><code class="literal">sql_log_bin</code></a>
                        </p><p style="color:blue;">SQL日志库</p>
                            <div class="informaltable">
                                <table frame="box" rules="all" summary="Properties for sql_log_bin"><colgroup><col width="30%"><col width="70%"></colgroup><thead><tr><th scope="col">Property</th>
                                    <th scope="col">Value</th>
                                </tr></thead><tbody><tr><td scope="row"><span class="bold"><strong>System Variable</strong></span></td>
                                    <td><code class="literal"><a class="link" href="replication.html#sysvar_sql_log_bin">sql_log_bin</a></code></td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Scope</strong></span></td>
                                    <td>Session</td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Dynamic</strong></span></td>
                                    <td>Yes</td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Type</strong></span></td>
                                    <td>Boolean</td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Default Value</strong></span></td>
                                    <td><code class="literal">ON</code></td>
                                </tr></tbody></table>
                            </div>
                            <p>
                                This variable controls whether logging to the binary log is
                                enabled for the current session (assuming that the binary
                                log itself is enabled). The default value is
                                <code class="literal">ON</code>. To disable or enable binary logging
                                for the current session, set the session
                                <a class="link" href="replication.html#sysvar_sql_log_bin"><code class="literal">sql_log_bin</code></a> variable to
                                <code class="literal">OFF</code> or <code class="literal">ON</code>.
                            </p><p style="color:blue;">此变量控制是否为当前会话启用对二进制日志的日志记录（假设启用了二进制日志本身）。默认值为“开”。要禁用或启用当前会话的二进制日志记录，请将session sql_log_bin变量设置为off或on。</p><p>
                                Set this variable to <code class="literal">OFF</code> for a session to
                                temporarily disable binary logging while making changes to
                                the master you do not want replicated to the slave.
                            </p><p style="color:blue;">将此变量设置为“关”，以便会话在更改不希望复制到从属服务器的主服务器时临时禁用二进制日志记录。</p><p>
                                Setting the session value of this system variable is a
                                restricted operation. The session user must have privileges
                                sufficient to set restricted session variables. See
                                <a class="xref" href="server-administration.html#system-variable-privileges" title="5.1.8.1&nbsp;System Variable Privileges">Section&nbsp;5.1.8.1, “System Variable Privileges”</a>.
                            </p><p style="color:blue;">设置此系统变量的会话值是受限制的操作。会话用户必须具有足够的权限来设置受限制的会话变量。见第5.1.8.1节“系统变量特权”。</p><p>
                                It is not possible to set the session value of
                                <a class="link" href="replication.html#sysvar_sql_log_bin"><code class="literal">sql_log_bin</code></a> within a
                                transaction or subquery.
                            </p><p style="color:blue;">无法在事务或子查询中设置SQL日志的会话值。</p><p>
            <span class="emphasis"><em>Setting this variable to <code class="literal">OFF</code>
            prevents GTIDs from being assigned to transactions in the
            binary log</em></span>. If you are using GTIDs for
                                replication, this means that even when binary logging is
                                later enabled again, the GTIDs written into the log from
                                this point do not account for any transactions that occurred
                                in the meantime, so in effect those transactions are lost.
                            </p><p style="color:blue;">将此变量设置为off可防止将gtid分配给二进制日志中的事务。如果您使用gtid进行复制，这意味着即使稍后再次启用二进制日志记录，从此点写入日志的gtid也不会考虑在此期间发生的任何事务，因此实际上这些事务都会丢失。</p><p>
                                The global <a class="link" href="replication.html#sysvar_sql_log_bin"><code class="literal">sql_log_bin</code></a>
                                variable is read only and cannot be modified. The global
                                scope is deprecated and will be removed in a future MySQL
                                release.
                            </p><p style="color:blue;">全局sql_log_bin变量是只读的，不能修改。全局作用域已弃用，将在以后的mysql版本中删除。</p></li><li class="listitem"><p><a name="sysvar_sync_binlog"></a>
                            <a class="indexterm" name="idm140286795284816"></a>

                            <a class="indexterm" name="idm140286795283760"></a>

                            <a class="link" href="replication.html#sysvar_sync_binlog"><code class="literal">sync_binlog</code></a>
                        </p><p style="color:blue;">同步日志</p>
                            <div class="informaltable">
                                <table frame="box" rules="all" summary="Properties for sync_binlog"><colgroup><col width="30%"><col width="70%"></colgroup><thead><tr><th scope="col">Property</th>
                                    <th scope="col">Value</th>
                                </tr></thead><tbody><tr><td scope="row"><span class="bold"><strong>Command-Line Format</strong></span></td>
                                    <td><code class="literal">--sync-binlog=#</code></td>
                                </tr><tr><td scope="row"><span class="bold"><strong>System Variable</strong></span></td>
                                    <td><code class="literal"><a class="link" href="replication.html#sysvar_sync_binlog">sync_binlog</a></code></td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Scope</strong></span></td>
                                    <td>Global</td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Dynamic</strong></span></td>
                                    <td>Yes</td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Type</strong></span></td>
                                    <td>Integer</td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Default Value</strong></span> (&gt;= 5.7.7)</td>
                                    <td><code class="literal">1</code></td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Default Value</strong></span> (&lt;= 5.7.6)</td>
                                    <td><code class="literal">0</code></td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Minimum Value</strong></span></td>
                                    <td><code class="literal">0</code></td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Maximum Value</strong></span></td>
                                    <td><code class="literal">4294967295</code></td>
                                </tr></tbody></table>
                            </div>
                            <p>
                                Controls how often the MySQL server synchronizes the binary
                                log to disk.
                            </p><p style="color:blue;">控制MySQL服务器将二进制日志同步到磁盘的频率。</p>
                            <div class="itemizedlist">
                                <ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
                                    <a class="link" href="replication.html#sysvar_sync_binlog"><code class="literal">sync_binlog=0</code></a>: Disables
                                    synchronization of the binary log to disk by the MySQL
                                    server. Instead, the MySQL server relies on the
                                    operating system to flush the binary log to disk from
                                    time to time as it does for any other file. This setting
                                    provides the best performance, but in the event of a
                                    power failure or operating system crash, it is possible
                                    that the server has committed transactions that have not
                                    been synchronized to the binary log.
                                </p><p style="color:blue;">sync_binlog=0:禁用MySQL服务器将二进制日志同步到磁盘。相反，mysql服务器依赖于操作系统不时地将二进制日志刷新到磁盘，就像它对任何其他文件所做的那样。此设置提供最佳性能，但在电源故障或操作系统崩溃的情况下，服务器可能提交了未同步到二进制日志的事务。</p></li><li class="listitem"><p>
                                    <a class="link" href="replication.html#sysvar_sync_binlog"><code class="literal">sync_binlog=1</code></a>: Enables
                                    synchronization of the binary log to disk before
                                    transactions are committed. This is the safest setting
                                    but can have a negative impact on performance due to the
                                    increased number of disk writes. In the event of a power
                                    failure or operating system crash, transactions that are
                                    missing from the binary log are only in a prepared
                                    state. This permits the automatic recovery routine to
                                    roll back the transactions, which guarantees that no
                                    transaction is lost from the binary log.
                                </p><p style="color:blue;">sync_binlog=1:在提交事务之前启用二进制日志到磁盘的同步。这是最安全的设置，但由于磁盘写入次数增加，可能会对性能产生负面影响。在电源故障或操作系统崩溃的情况下，二进制日志中丢失的事务仅处于准备状态。这允许自动恢复例程回滚事务，从而保证不会从二进制日志中丢失任何事务。</p></li><li class="listitem"><p>
                                    <a class="link" href="replication.html#sysvar_sync_binlog"><code class="literal">sync_binlog=<em class="replaceable"><code>N</code></em></code></a>,
                                    where <em class="replaceable"><code>N</code></em> is a value other than
                                    0 or 1: The binary log is synchronized to disk after
                                    <code class="literal">N</code> binary log commit groups have been
                                    collected. In the event of a power failure or operating
                                    system crash, it is possible that the server has
                                    committed transactions that have not been flushed to the
                                    binary log. This setting can have a negative impact on
                                    performance due to the increased number of disk writes.
                                    A higher value improves performance, but with an
                                    increased risk of data loss.
                                </p><p style="color:blue;">sync_binlog=n，其中n是0或1以外的值：收集n个二进制日志提交组后，二进制日志将同步到磁盘。在电源故障或操作系统崩溃的情况下，服务器可能提交了尚未刷新到二进制日志的事务。由于磁盘写入次数增加，此设置可能会对性能产生负面影响。较高的值可以提高性能，但会增加数据丢失的风险。</p></li></ul>
                            </div>
                            <p>
                                For the greatest possible durability and consistency in a
                                replication setup that uses <code class="literal">InnoDB</code> with
                                transactions, use these settings:
                            </p><p style="color:blue;">为了在将InnoDB用于事务的复制设置中获得最大的持久性和一致性，请使用以下设置：</p>
                            <div class="itemizedlist">
                                <ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
                                    <a class="link" href="replication.html#sysvar_sync_binlog"><code class="literal">sync_binlog=1</code></a>.
                                </p><p style="color:blue;">sync_binlog=1。</p></li><li class="listitem"><p>
                                    <a class="link" href="innodb-storage-engine.html#sysvar_innodb_flush_log_at_trx_commit"><code class="literal">innodb_flush_log_at_trx_commit=1</code></a>.
                                </p><p style="color:blue;">innodb_flush_log_at_trx_commit=1。</p></li></ul>
                            </div>
                            <div class="caution" style="margin-left: 0.5in; margin-right: 0.5in;">
                                <div class="admon-title">
                                    Caution
                                </div>
                                <p>
                                    Many operating systems and some disk hardware fool the
                                    flush-to-disk operation. They may tell
                                    <a class="link" href="programs.html#mysqld" title="4.3.1&nbsp;mysqld — The MySQL Server"><span class="command"><strong>mysqld</strong></span></a> that the flush has taken place,
                                    even though it has not. In this case, the durability of
                                    transactions is not guaranteed even with the recommended
                                    settings, and in the worst case, a power outage can
                                    corrupt <code class="literal">InnoDB</code> data. Using a
                                    battery-backed disk cache in the SCSI disk controller or
                                    in the disk itself speeds up file flushes, and makes the
                                    operation safer. You can also try to disable the caching
                                    of disk writes in hardware caches.
                                </p><p style="color:blue;">许多操作系统和一些磁盘硬件欺骗了磁盘刷新操作。他们可能会告诉mysqld，已经发生了冲水，尽管还没有。在这种情况下，即使使用推荐的设置，也不能保证事务的持久性，在最坏的情况下，断电可能会损坏innodb数据。在SCSI磁盘控制器或磁盘本身中使用电池备份的磁盘缓存可以加快文件刷新速度，并使操作更安全。也可以尝试禁用硬件缓存中磁盘写入的缓存。</p>
                            </div>
                        </li><li class="listitem"><p><a name="sysvar_transaction_write_set_extraction"></a>
                            <a class="indexterm" name="idm140286795226832"></a>

                            <a class="indexterm" name="idm140286795225792"></a>

                            <a class="link" href="replication.html#sysvar_transaction_write_set_extraction"><code class="literal">transaction_write_set_extraction</code></a>
                        </p><p style="color:blue;">事务写入集提取</p>
                            <div class="informaltable">
                                <table frame="box" rules="all" summary="Properties for transaction_write_set_extraction"><colgroup><col width="30%"><col width="70%"></colgroup><thead><tr><th scope="col">Property</th>
                                    <th scope="col">Value</th>
                                </tr></thead><tbody><tr><td scope="row"><span class="bold"><strong>Command-Line Format</strong></span></td>
                                    <td><code class="literal">--transaction-write-set-extraction[=value]</code></td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Introduced</strong></span></td>
                                    <td>5.7.6</td>
                                </tr><tr><td scope="row"><span class="bold"><strong>System Variable</strong></span></td>
                                    <td><code class="literal"><a class="link" href="replication.html#sysvar_transaction_write_set_extraction">transaction_write_set_extraction</a></code></td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Scope</strong></span></td>
                                    <td>Global, Session</td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Dynamic</strong></span></td>
                                    <td>Yes</td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Type</strong></span></td>
                                    <td>Enumeration</td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Default Value</strong></span></td>
                                    <td><code class="literal">OFF</code></td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Valid Values</strong></span> (&gt;= 5.7.14)</td>
                                    <td><p class="valid-value"><code class="literal">OFF</code></p><p style="color:blue;">关闭</p><p class="valid-value"><code class="literal">MURMUR32</code></p><p style="color:blue;">杂音32</p><p class="valid-value"><code class="literal">XXHASH64</code></p><p style="color:blue;">xxhash64号</p></td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Valid Values</strong></span> (&lt;= 5.7.13)</td>
                                    <td><p class="valid-value"><code class="literal">OFF</code></p><p style="color:blue;">关闭</p><p class="valid-value"><code class="literal">MURMUR32</code></p><p style="color:blue;">杂音32</p></td>
                                </tr></tbody></table>
                            </div>
                            <p>
                                Defines the algorithm used to generate a hash identifying
                                the writes associated with a transaction. If you are using
                                Group Replication, the hash value is used for distributed
                                conflict detection and handling. On 64-bit systems running
                                Group Replication, we recommend setting this to
                                <code class="literal">XXHASH64</code> in order to avoid unnecessary
                                hash collisions which result in certification failures and
                                the roll back of user transactions. See
                                <a class="xref" href="group-replication.html#group-replication-requirements" title="17.7.1&nbsp;Group Replication Requirements">Section&nbsp;17.7.1, “Group Replication Requirements”</a>.
                            </p><p style="color:blue;">定义用于生成哈希的算法，该哈希标识与事务关联的写入。如果使用组复制，则哈希值用于分布式冲突检测和处理。在运行组复制的64位系统上，建议将其设置为xxhash64，以避免不必要的哈希冲突，从而导致证书失败和用户事务回滚。见第17.7.1节“组复制要求”。</p>
                            <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">

                                <div class="admon-title">
                                    Note
                                </div>
                                <p>
                                    The value of this variable cannot be changed when
                                    <a class="link" href="replication.html#sysvar_binlog_transaction_dependency_tracking"><code class="literal">binlog_transaction_dependency_tracking</code></a>
                                    is set to either of <code class="literal">WRITESET</code> or
                                    <code class="literal">WRITESET_SESSION</code>.
                                </p><p style="color:blue;">当binlog_transaction_dependency_tracking设置为writeset或writeset_session时，无法更改此变量的值。</p>
                            </div>
                        </li></ul>
                    </div>

                </div>

            </div>
            <div class="section">
                <div class="titlepage">
                    <div>
                        <div>
                            <h4 class="title"><a name="replication-options-gtids"></a>16.1.6.5&nbsp;Global Transaction ID Options and Variables</h4>

                        </div>

                    </div>

                </div>
                <div class="itemizedlist">
                    <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><a class="xref" href="replication.html#replication-optvars-gtids" title="Startup Options Used with GTID Replication">Startup Options Used with GTID Replication</a></p><p style="color:blue;">用于gtid复制的启动选项</p></li><li class="listitem"><p><a class="xref" href="replication.html#replication-sysvars-gtids" title="System Variables Used with GTID Replication">System Variables Used with GTID Replication</a></p><p style="color:blue;">用于gtid复制的系统变量</p></li></ul>
                </div>
                <p>
                    The MySQL Server options and system variables described in this
                    section are used to monitor and control Global Transaction
                    Identifiers (GTIDs).
                </p><p style="color:blue;">本节中描述的mysql服务器选项和系统变量用于监视和控制全局事务标识符（gtid）。</p><p>
                For additional information, see
                <a class="xref" href="replication.html#replication-gtids" title="16.1.3&nbsp;Replication with Global Transaction Identifiers">Section&nbsp;16.1.3, “Replication with Global Transaction Identifiers”</a>.
            </p><p style="color:blue;">有关更多信息，请参阅第16.1.3节“使用全局事务标识符复制”。</p>
                <div class="simplesect">

                    <div class="titlepage">
                        <div>

                            <div class="simple">
                                <h5 class="title"><a name="replication-optvars-gtids"></a>Startup Options Used with GTID Replication</h5>
                            </div>
                        </div>
                    </div>
                    <p>
                        The following server startup options are used with GTID-based
                        replication:
                    </p><p style="color:blue;">以下服务器启动选项用于基于gtid的复制：</p>
                    <div class="itemizedlist">
                        <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><a name="option_mysqld_gtid-executed-compression-period"></a>
                            <a class="indexterm" name="idm140286795171296"></a>

                            <a class="indexterm" name="idm140286795170256"></a>

                            <a class="link" href="replication.html#option_mysqld_gtid-executed-compression-period"><code class="option">--gtid-executed-compression-period
                            </code></a>
                        </p><p style="color:blue;">--GTID执行压缩周期</p>
                            <div class="informaltable">
                                <table frame="box" rules="all" summary="Properties for gtid-executed-compression-period"><colgroup><col width="30%"><col width="70%"></colgroup><thead><tr><th scope="col">Property</th>
                                    <th scope="col">Value</th>
                                </tr></thead><tbody><tr><td scope="row"><span class="bold"><strong>Command-Line Format</strong></span></td>
                                    <td><code class="literal">--gtid-executed-compression-period=#</code></td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Introduced</strong></span></td>
                                    <td>5.7.6</td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Type</strong></span></td>
                                    <td>Integer</td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Default Value</strong></span></td>
                                    <td><code class="literal">1000</code></td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Minimum Value</strong></span></td>
                                    <td><code class="literal">0</code></td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Maximum Value</strong></span></td>
                                    <td><code class="literal">4294967295</code></td>
                                </tr></tbody></table>
                            </div>
                            <p>
                                Compress the <code class="literal">mysql.gtid_executed</code> table
                                each time this many transactions have taken place. A setting
                                of 0 means that this table is not compressed. No compression
                                of the table occurs when binary logging is enabled,
                                therefore the option has no effect unless
                                <a class="link" href="replication.html#sysvar_log_bin"><code class="literal">log_bin</code></a> is
                                <code class="literal">OFF</code>.
                            </p><p style="color:blue;">每次发生这么多事务时，压缩mysql.gtid_executed表。设置为0表示此表未压缩。启用二进制日志记录时，不会对表进行压缩，因此，除非关闭“日志存储”选项，否则该选项无效。</p><p>
                                See
                                <a class="xref" href="replication.html#replication-gtids-gtid-executed-table-compression" title="mysql.gtid_executed Table Compression">mysql.gtid_executed Table Compression</a>,
                                for more information.
                            </p><p style="color:blue;">有关详细信息，请参见mysql.gtid_executed table compression。</p><p>
                                In MySQL version 5.7.5, this variable was added as
                                <a class="link" href="replication.html#sysvar_executed_gtids_compression_period"><code class="literal">executed_gtids_compression_period</code></a>
                                and in MySQL version 5.7.6 it was renamed to
                                <code class="literal">gtid_executed_compression_period</code>.
                            </p><p style="color:blue;">在mysql版本5.7.5中，这个变量被添加为executed_-gtids_compression_period，在mysql版本5.7.6中，它被重命名为gtid_-executed_compression_period。</p></li></ul>
                    </div>

                </div>
                <div class="simplesect">
                    <div class="titlepage">
                        <div>
                            <div class="simple">
                                <h5 class="title"><a name="replication-sysvars-gtids"></a>System Variables Used with GTID Replication</h5>

                            </div>

                        </div>

                    </div>
                    <p>
                        The following system variables are used with GTID-based
                        replication:
                    </p><p style="color:blue;">以下系统变量用于基于gtid的复制：</p>
                    <div class="itemizedlist">
                        <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><a name="sysvar_binlog_gtid_simple_recovery"></a>
                            <a class="indexterm" name="idm140286795133552"></a>

                            <a class="indexterm" name="idm140286795132512"></a>

                            <a class="link" href="replication.html#sysvar_binlog_gtid_simple_recovery"><code class="literal">binlog_gtid_simple_recovery</code></a>
                        </p><p style="color:blue;">binlog_gtid_简单恢复</p>
                            <div class="informaltable">
                                <table frame="box" rules="all" summary="Properties for binlog_gtid_simple_recovery"><colgroup><col width="30%"><col width="70%"></colgroup><thead><tr><th scope="col">Property</th>
                                    <th scope="col">Value</th>
                                </tr></thead><tbody><tr><td scope="row"><span class="bold"><strong>Command-Line Format</strong></span></td>
                                    <td><code class="literal">--binlog-gtid-simple-recovery[={OFF|ON}]</code></td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Introduced</strong></span></td>
                                    <td>5.7.6</td>
                                </tr><tr><td scope="row"><span class="bold"><strong>System Variable</strong></span></td>
                                    <td><code class="literal"><a class="link" href="replication.html#sysvar_binlog_gtid_simple_recovery">binlog_gtid_simple_recovery</a></code></td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Scope</strong></span></td>
                                    <td>Global</td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Dynamic</strong></span></td>
                                    <td>No</td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Type</strong></span></td>
                                    <td>Boolean</td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Default Value</strong></span> (&gt;= 5.7.7)</td>
                                    <td><code class="literal">ON</code></td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Default Value</strong></span> (&lt;= 5.7.6)</td>
                                    <td><code class="literal">OFF</code></td>
                                </tr></tbody></table>
                            </div>
                            <p>
                                This variable controls how binary log files are iterated
                                during the search for GTIDs when MySQL starts or restarts.
                            </p><p style="color:blue;">此变量控制在MySQL启动或重新启动时搜索GTID期间二进制日志文件的迭代方式。</p><p>
                                When
                                <a class="link" href="replication.html#sysvar_binlog_gtid_simple_recovery"><code class="literal">binlog_gtid_simple_recovery=TRUE</code></a>,
                                which is the default from MySQL 5.7.7, the values of
                                <a class="link" href="replication.html#sysvar_gtid_executed"><code class="literal">gtid_executed</code></a> and
                                <a class="link" href="replication.html#sysvar_gtid_purged"><code class="literal">gtid_purged</code></a> are computed at
                                startup based on the values of
                                <code class="literal">Previous_gtids_log_event</code> in the most
                                recent and oldest binary log files. For a description of the
                                computation, see
                                <a class="xref" href="replication.html#replication-gtids-gtid-purged" title="The gtid_purged System Variable">The <code class="literal">gtid_purged</code> System Variable</a>. This
                                setting accesses only two binary log files during server
                                restart. If all binary logs on the server were generated
                                using MySQL 5.7.8 or later and you are using MySQL 5.7.8 or
                                later,
                                <a class="link" href="replication.html#sysvar_binlog_gtid_simple_recovery"><code class="literal">binlog_gtid_simple_recovery=TRUE</code></a>
                                can always safely be used.


                            </p><p style="color:blue;">当binlog_gtid_simple_recovery=true（这是mysql 5.7.7的默认值）时，启动时将根据最近和最旧二进制日志文件中以前的“gtid_log_”事件的值计算执行的gtid_和清除的gtid_的值。有关计算的说明，请参见gtid_purged系统变量。此设置在服务器重新启动期间仅访问两个二进制日志文件。如果服务器上的所有二进制日志都是使用mysql 5.7.8或更高版本生成的，并且您使用的是mysql 5.7.8或更高版本，则binlog_gtid_simple_recovery=true始终可以安全使用。</p><p>
                                With
                                <a class="link" href="replication.html#sysvar_binlog_gtid_simple_recovery"><code class="literal">binlog_gtid_simple_recovery=TRUE</code></a>,
                                <a class="link" href="replication.html#sysvar_gtid_executed"><code class="literal">gtid_executed</code></a> and
                                <a class="link" href="replication.html#sysvar_gtid_purged"><code class="literal">gtid_purged</code></a> might be
                                initialized incorrectly in the following two situations:
                            </p><p style="color:blue;">当binlog_gtid_simple_recovery=true时，在以下两种情况下，执行gtid_并清除gtid_可能会被错误初始化：</p>
                            <div class="itemizedlist">
                                <ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
                                    The newest binary log was generated by MySQL 5.7.5 or
                                    earlier, and <a class="link" href="replication.html#sysvar_gtid_mode"><code class="literal">gtid_mode</code></a>
                                    was <code class="literal">ON</code> for some binary logs but
                                    <code class="literal">OFF</code> for the newest binary log.
                                </p><p style="color:blue;">最新的二进制日志是由mysql 5.7.5或更早版本生成的，对于某些二进制日志，gtid_模式是打开的，但是对于最新的二进制日志，gtid_模式是关闭的。</p></li><li class="listitem"><p>
                                    A <code class="literal">SET @@GLOBAL.gtid_purged</code> statement
                                    was issued on MySQL 5.7.7 or earlier, and the binary log
                                    that was active at the time of the <code class="literal">SET
                                    @@GLOBAL.gtid_purged</code> statement has not yet
                                    been purged.


                                </p><p style="color:blue;">在MySQL 5.7.7或更早版本上发出了set@@global.gtid清除语句，在set@@global.gtid清除语句时处于活动状态的二进制日志尚未清除。</p></li></ul>
                            </div>
                            <p>
                                If an incorrect GTID set is computed in either situation, it
                                will remain incorrect even if the server is later restarted
                                with
                                <a class="link" href="replication.html#sysvar_binlog_gtid_simple_recovery"><code class="literal">binlog_gtid_simple_recovery=FALSE</code></a>.
                                If either of these situations apply on the server, set
                                <a class="link" href="replication.html#sysvar_binlog_gtid_simple_recovery"><code class="literal">binlog_gtid_simple_recovery=FALSE</code></a>
                                before starting or restarting the server. To check for the
                                second situation, if you are using MySQL 5.7.7 or earlier,
                                after issuing a <code class="literal">SET @@GLOBAL.gtid_purged</code>
                                statement note down the current binary log file name, which
                                can be checked using <a class="link" href="sql-syntax.html#show-master-status" title="13.7.5.23&nbsp;SHOW MASTER STATUS Syntax"><code class="literal">SHOW MASTER
                                STATUS</code></a>. If the server is restarted before this
                                file has been purged, then you should set
                                <a class="link" href="replication.html#sysvar_binlog_gtid_simple_recovery"><code class="literal">binlog_gtid_simple_recovery=FALSE</code></a>.
                            </p><p style="color:blue;">如果在这两种情况下都计算了不正确的gtid集，则即使稍后使用binlog_gtid_simple_recovery=false重新启动服务器，它也将保持不正确。如果这两种情况中的任何一种适用于服务器，请在启动或重新启动服务器之前将binlog_gtid_simple_recovery设置为false。要检查第二种情况，如果您使用的是mysql 5.7.7或更早版本，请在发出set@@global.gtid戡purged语句后记下当前二进制日志文件名，可以使用show master status检查该文件名。如果在清除此文件之前重新启动服务器，则应将binlog_gtid_simple_recovery设置为false。</p><p>
                                When
                                <a class="link" href="replication.html#sysvar_binlog_gtid_simple_recovery"><code class="literal">binlog_gtid_simple_recovery=FALSE</code></a>
                                is set, the method of computing
                                <a class="link" href="replication.html#sysvar_gtid_executed"><code class="literal">gtid_executed</code></a> and
                                <a class="link" href="replication.html#sysvar_gtid_purged"><code class="literal">gtid_purged</code></a> as described in
                                <a class="xref" href="replication.html#replication-gtids-gtid-purged" title="The gtid_purged System Variable">The <code class="literal">gtid_purged</code> System Variable</a> is changed
                                to iterate the binary log files as follows:
                            </p><p style="color:blue;">当设置binlog_gtid_simple_recovery=false时，gtid_purged系统变量中描述的计算gtid_executed和gtid_purged的方法将更改为按如下方式迭代二进制日志文件：</p>
                            <div class="itemizedlist">
                                <ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
                                    Instead of using the value of
                                    <code class="literal">Previous_gtids_log_event</code> and GTID log
                                    events from the newest binary log file, the computation
                                    for <a class="link" href="replication.html#sysvar_gtid_executed"><code class="literal">gtid_executed</code></a>
                                    iterates from the newest binary log file, and uses the
                                    value of <code class="literal">Previous_gtids_log_event</code> and
                                    any GTID log events from the first binary log file where
                                    it finds a <code class="literal">Previous_gtids_log_event</code>
                                    value. If the server's most recent binary log files do
                                    not have GTID log events, for example if
                                    <a class="link" href="replication.html#sysvar_gtid_mode"><code class="literal">gtid_mode=ON</code></a> was used
                                    but the server was later changed to
                                    <a class="link" href="replication.html#sysvar_gtid_mode"><code class="literal">gtid_mode=OFF</code></a>, this
                                    process can take a long time.
                                </p><p style="color:blue;">不使用最新二进制日志文件中的previous gtids_log_event和gtid log events的值，gtid_executed的计算将从最新二进制日志文件迭代，并使用previous_gtids_log_event的值和从第一个二进制日志文件中找到previous_gtids_log_event值的任何gtid log events。如果服务器的最新二进制日志文件没有gtid日志事件，例如，如果使用了gtid_mode=on，但服务器后来更改为gtid_mode=off，则此过程可能需要很长时间。</p></li><li class="listitem"><p>
                                    Instead of using the value of
                                    <code class="literal">Previous_gtids_log_event</code> from the
                                    oldest binary log file, the computation for
                                    <a class="link" href="replication.html#sysvar_gtid_purged"><code class="literal">gtid_purged</code></a> iterates
                                    from the oldest binary log file, and uses the value of
                                    <code class="literal">Previous_gtids_log_event</code> from the
                                    first binary log file where it finds either a nonempty
                                    <code class="literal">Previous_gtids_log_event</code> value, or at
                                    least one GTID log event (indicating that the use of
                                    GTIDs starts at that point). If the server's older
                                    binary log files do not have GTID log events, for
                                    example if <a class="link" href="replication.html#sysvar_gtid_mode"><code class="literal">gtid_mode=ON</code></a>
                                    was only set recently on the server, this process can
                                    take a long time.
                                </p><p style="color:blue;">GTID清除的计算不使用最旧二进制日志文件中先前的GTID日志事件的值，而是从最旧的二进制日志文件进行迭代，并使用第一个二进制日志文件中先前的GTID日志事件的值，在第一个二进制日志文件中找到非空的先前的GTID日志事件值，或至少一个gtid日志事件（指示gtid的使用从该点开始）。如果服务器的旧二进制日志文件没有gtid日志事件，例如，如果gtid_mode=on只是最近在服务器上设置的，则此过程可能需要很长时间。</p></li></ul>
                            </div>
                            <p>
                                In MySQL version 5.7.5, this variable was added as
                                <code class="literal">simplified_binlog_gtid_recovery</code> and in
                                MySQL version 5.7.6 it was renamed to
                                <code class="literal">binlog_gtid_simple_recovery</code>.
                            </p><p style="color:blue;">在mysql版本5.7.5中，这个变量被添加为simplified_binlog_gtid_recovery，在mysql版本5.7.6中，它被重命名为binlog_gtid_simple_recovery。</p></li><li class="listitem"><p><a name="sysvar_enforce_gtid_consistency"></a>
                            <a class="link" href="replication.html#sysvar_enforce_gtid_consistency"><code class="literal">enforce_gtid_consistency</code></a>
                        </p><p style="color:blue;">执行一致性</p><a class="indexterm" name="idm140286795051008"></a><a class="indexterm" name="idm140286795049904"></a>
                            <div class="informaltable">
                                <table frame="box" rules="all" summary="Properties for enforce_gtid_consistency"><colgroup><col width="30%"><col width="70%"></colgroup><thead><tr><th scope="col">Property</th>
                                    <th scope="col">Value</th>
                                </tr></thead><tbody><tr><td scope="row"><span class="bold"><strong>Command-Line Format</strong></span></td>
                                    <td><code class="literal">--enforce-gtid-consistency[=value]</code></td>
                                </tr><tr><td scope="row"><span class="bold"><strong>System Variable</strong></span></td>
                                    <td><code class="literal"><a class="link" href="replication.html#sysvar_enforce_gtid_consistency">enforce_gtid_consistency</a></code></td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Scope</strong></span></td>
                                    <td>Global</td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Dynamic</strong></span> (&gt;= 5.7.6)</td>
                                    <td>Yes</td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Dynamic</strong></span> (&lt;= 5.7.5)</td>
                                    <td>No</td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Type</strong></span> (&gt;= 5.7.6)</td>
                                    <td>Enumeration</td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Type</strong></span> (&lt;= 5.7.5)</td>
                                    <td>Boolean</td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Default Value</strong></span></td>
                                    <td><code class="literal">OFF</code></td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Valid Values</strong></span></td>
                                    <td><p class="valid-value"><code class="literal">OFF</code></p><p style="color:blue;">关闭</p><p class="valid-value"><code class="literal">ON</code></p><p style="color:blue;">打开（放）</p><p class="valid-value"><code class="literal">WARN</code></p><p style="color:blue;">警告</p></td>
                                </tr></tbody></table>
                            </div>
                            <p>
                                Depending on the value of this variable, the server enforces
                                GTID consistency by allowing execution of only statements
                                that can be safely logged using a GTID. You
                                <span class="emphasis"><em>must</em></span> set this variable to
                                <code class="literal">ON</code> before enabling GTID based
                                replication.
                            </p><p style="color:blue;">根据此变量的值，服务器只允许执行可以使用gtid安全记录的语句，从而增强gtid的一致性。在启用基于gtid的复制之前，必须将此变量设置为on。</p><p>
                                The values that
                                <a class="link" href="replication.html#sysvar_enforce_gtid_consistency"><code class="literal">enforce_gtid_consistency</code></a>
                                can be configured to are:
                            </p><p style="color:blue;">可将强制实现一致性的值配置为：</p>
                            <div class="itemizedlist">
                                <ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
                                    <code class="literal">OFF</code>: all transactions are allowed to
                                    violate GTID consistency.
                                </p><p style="color:blue;">关闭：允许所有事务违反gtid一致性。</p></li><li class="listitem"><p>
                                    <code class="literal">ON</code>: no transaction is allowed to
                                    violate GTID consistency.
                                </p><p style="color:blue;">on:不允许任何事务违反gtid一致性。</p></li><li class="listitem"><p>
                                    <code class="literal">WARN</code>: all transactions are allowed to
                                    violate GTID consistency, but a warning is generated in
                                    this case. <code class="literal">WARN</code> was added in MySQL
                                    5.7.6.
                                </p><p style="color:blue;">警告：允许所有事务违反gtid一致性，但在这种情况下会生成警告。在mysql 5.7.6中添加了warn。</p></li></ul>
                            </div>
                            <p>
                                Only statements that can be logged using GTID safe
                                statements can be logged when
                                <a class="link" href="replication.html#sysvar_enforce_gtid_consistency"><code class="literal">enforce_gtid_consistency</code></a> is
                                set to <code class="literal">ON</code>, so the operations listed here
                                cannot be used with this option:
                            </p><p style="color:blue;">当“强制gtid一致性”设置为“开”时，只能记录使用gtid safe语句的语句，因此此处列出的操作不能与此选项一起使用：</p>
                            <div class="itemizedlist">
                                <ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
                                    <a class="link" href="sql-syntax.html#create-table-select" title="13.1.18.5&nbsp;CREATE TABLE ... SELECT Syntax"><code class="literal">CREATE
                                        TABLE ... SELECT</code></a> statements
                                </p><p style="color:blue;">创建表…选择语句</p></li><li class="listitem"><p>
                                    <a class="link" href="sql-syntax.html#create-table" title="13.1.18&nbsp;CREATE TABLE Syntax"><code class="literal">CREATE
                                        TEMPORARY TABLE</code></a> or
                                    <a class="link" href="sql-syntax.html#drop-table" title="13.1.29&nbsp;DROP TABLE Syntax"><code class="literal">DROP
                                        TEMPORARY TABLE</code></a> statements inside transactions
                                </p><p style="color:blue;">在事务中创建临时表或删除临时表语句</p></li><li class="listitem"><p>
                                    Transactions or statements that update both
                                    transactional and nontransactional tables. There is an
                                    exception that nontransactional DML is allowed in the
                                    same transaction or in the same statement as
                                    transactional DML, if all
                                    <span class="emphasis"><em>nontransactional</em></span> tables are
                                    temporary.
                                </p><p style="color:blue;">同时更新事务表和非事务表的事务或语句。如果所有非事务表都是临时表，则允许非事务dml与事务dml在同一事务或同一语句中使用。</p></li></ul>
                            </div>
                            <p>
                                <a class="link" href="replication.html#sysvar_enforce_gtid_consistency"><code class="option">--enforce-gtid-consistency</code></a>
                                only takes effect if binary logging takes place for a
                                statement. If binary logging is disabled on the server, or
                                if statements are not written to the binary log because they
                                are removed by a filter, GTID consistency is not checked or
                                enforced for the statements that are not logged.
                            </p><p style="color:blue;">--强制gtid一致性仅在对语句执行二进制日志记录时生效。如果服务器上禁用了二进制日志记录，或者如果语句由于被筛选器删除而未写入二进制日志，则不会对未记录的语句检查或强制执行gtid一致性。</p><p>
                                For more information, see
                                <a class="xref" href="replication.html#replication-gtids-restrictions" title="16.1.3.6&nbsp;Restrictions on Replication with GTIDs">Section&nbsp;16.1.3.6, “Restrictions on Replication with GTIDs”</a>.
                            </p><p style="color:blue;">有关更多信息，请参阅16.1.3.6节，“使用GTID复制的限制”。</p><p>
                                Prior to MySQL 5.7.6, the boolean
                                <a class="link" href="replication.html#sysvar_enforce_gtid_consistency"><code class="literal">enforce_gtid_consistency</code></a>
                                defaulted to <code class="literal">OFF</code>. To maintain
                                compatibility with previous releases, in MySQL 5.7.6 the
                                enumeration defaults to <code class="literal">OFF</code>, and setting
                                <a class="link" href="replication.html#sysvar_enforce_gtid_consistency"><code class="option">--enforce-gtid-consistency</code></a>
                                without a value is interpreted as setting the value to
                                <code class="literal">ON</code>. The variable also has multiple
                                textual aliases for the values:
                                <code class="literal">0=OFF=FALSE</code>,
                                <code class="literal">1=ON=TRUE</code>,<code class="literal">2=WARN</code>. This
                                differs from other enumeration types but maintains
                                compatibility with the boolean type used in previous
                                versions. These changes impact on what is returned by the
                                variable. Using <code class="literal">SELECT
                                @@ENFORCE_GTID_CONSISTENCY</code>, <code class="literal">SHOW
                                VARIABLES LIKE 'ENFORCE_GTID_CONSISTENCY'</code>, and
                                <code class="literal">SELECT * FROM INFORMATION_SCHEMA.VARIABLES WHERE
                                    'VARIABLE_NAME' = 'ENFORCE_GTID_CONSISTENCY'</code>, all
                                return the textual form, not the numeric form. This is an
                                incompatible change, since
                                <code class="literal">@@ENFORCE_GTID_CONSISTENCY</code> returns the
                                numeric form for booleans but returns the textual form for
                                <code class="literal">SHOW</code> and the Information Schema.
                            </p><p style="color:blue;">在mysql 5.7.6之前，boolean-enforce-gtid-consistence默认为off。为了保持与早期版本的兼容性，在mysql 5.7.6中，枚举默认为off，并且设置--enforce gtid consistence without a value被解释为将该值设置为on。变量还有多个文本别名：0=off=false，1=on=true，2=warn。这与其他枚举类型不同，但与以前版本中使用的布尔类型保持兼容。这些更改会影响变量返回的内容。使用select@@enforce\u gtid_consistence，显示“enforce\u gtid_consistence”之类的变量，并从信息架构中选择*变量，其中“variable_name”=“enforce_gtid_consistence”都返回文本形式，而不是数字形式。这是一个不兼容的更改，因为@@Enforce\u gtid\u Consistency返回布尔值的数字形式，但返回Show和信息架构的文本形式。</p></li><li class="listitem"><p><a name="sysvar_executed_gtids_compression_period"></a>
                            <a class="link" href="replication.html#sysvar_executed_gtids_compression_period"><code class="literal">executed_gtids_compression_period</code></a>
                        </p><p style="color:blue;">执行的压缩周期</p><a class="indexterm" name="idm140286794977184"></a><a class="indexterm" name="idm140286794976080"></a>
                            <div class="informaltable">
                                <table frame="box" rules="all" summary="Properties for executed_gtids_compression_period"><colgroup><col width="30%"><col width="70%"></colgroup><thead><tr><th scope="col">Property</th>
                                    <th scope="col">Value</th>
                                </tr></thead><tbody><tr><td scope="row"><span class="bold"><strong>Command-Line Format</strong></span></td>
                                    <td><code class="literal">--executed-gtids-compression-period=#</code></td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Introduced</strong></span></td>
                                    <td>5.7.5</td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Removed</strong></span></td>
                                    <td>5.7.6</td>
                                </tr><tr><td scope="row"><span class="bold"><strong>System Variable</strong></span></td>
                                    <td><code class="literal"><a class="link" href="replication.html#sysvar_executed_gtids_compression_period">executed_gtids_compression_period</a></code></td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Scope</strong></span></td>
                                    <td>Global</td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Dynamic</strong></span></td>
                                    <td>Yes</td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Type</strong></span></td>
                                    <td>Integer</td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Default Value</strong></span></td>
                                    <td><code class="literal">1000</code></td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Minimum Value</strong></span></td>
                                    <td><code class="literal">0</code></td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Maximum Value</strong></span></td>
                                    <td><code class="literal">4294967295</code></td>
                                </tr></tbody></table>
                            </div>
                            <p>
                                Renamed to
                                <a class="link" href="replication.html#sysvar_gtid_executed_compression_period"><code class="literal">gtid_executed_compression_period</code></a>.
                            </p><p style="color:blue;">重命名为gtid_executed_compression_period。</p></li><li class="listitem"><p><a name="sysvar_gtid_executed"></a>
                            <a class="indexterm" name="idm140286794936400"></a>

                            <a class="indexterm" name="idm140286794935344"></a>

                            <a class="link" href="replication.html#sysvar_gtid_executed"><code class="literal">gtid_executed</code></a>
                        </p><p style="color:blue;">GTID_已执行</p>
                            <div class="informaltable">
                                <table frame="box" rules="all" summary="Properties for gtid_executed"><colgroup><col width="30%"><col width="70%"></colgroup><thead><tr><th scope="col">Property</th>
                                    <th scope="col">Value</th>
                                </tr></thead><tbody><tr><td scope="row"><span class="bold"><strong>System Variable</strong></span> (&gt;= 5.7.7)</td>
                                    <td><code class="literal"><a class="link" href="replication.html#sysvar_gtid_executed">gtid_executed</a></code></td>
                                </tr><tr><td scope="row"><span class="bold"><strong>System Variable</strong></span></td>
                                    <td><code class="literal"><a class="link" href="replication.html#sysvar_gtid_executed">gtid_executed</a></code></td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Scope</strong></span> (&gt;= 5.7.7)</td>
                                    <td>Global</td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Scope</strong></span></td>
                                    <td>Global, Session</td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Dynamic</strong></span> (&gt;= 5.7.7)</td>
                                    <td>No</td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Dynamic</strong></span></td>
                                    <td>No</td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Type</strong></span></td>
                                    <td>String</td>
                                </tr></tbody></table>
                            </div>
                            <p>
                                When used with global scope, this variable contains a
                                representation of the set of all transactions executed on
                                the server and GTIDs that have been set by a
                                <a class="link" href="sql-syntax.html#set-variable" title="13.7.4.1&nbsp;SET Syntax for Variable Assignment"><code class="literal">SET</code></a>
                                <a class="link" href="replication.html#sysvar_gtid_purged"><code class="literal">gtid_purged</code></a> statement. This
                                is the same as the value of the
                                <code class="literal">Executed_Gtid_Set</code> column in the output of
                                <a class="link" href="sql-syntax.html#show-master-status" title="13.7.5.23&nbsp;SHOW MASTER STATUS Syntax"><code class="literal">SHOW MASTER STATUS</code></a> and
                                <a class="link" href="sql-syntax.html#show-slave-status" title="13.7.5.34&nbsp;SHOW SLAVE STATUS Syntax"><code class="literal">SHOW SLAVE STATUS</code></a>. The value
                                of this variable is a GTID set, see
                                <a class="xref" href="replication.html#replication-gtids-concepts-gtid-sets" title="GTID Sets">GTID Sets</a> for
                                more information.
                            </p><p style="color:blue;">与全局作用域一起使用时，此变量包含在服务器上执行的所有事务集的表示，以及由SET GTID清除语句设置的GTID。这与show master status和show slave status输出中的executed_gtid_set列的值相同。此变量的值是一个gtid集，有关详细信息，请参见gtid集。</p><p>
                                When the server starts,
                                <code class="literal">@@GLOBAL.gtid_executed</code> is initialized.
                                See
                                <a class="link" href="replication.html#sysvar_binlog_gtid_simple_recovery"><code class="literal">binlog_gtid_simple_recovery</code></a>
                                for more information on how binary logs are iterated to
                                populate <a class="link" href="replication.html#sysvar_gtid_executed"><code class="literal">gtid_executed</code></a>.
                                GTIDs are then added to the set as transactions are
                                executed, or if any
                                <a class="link" href="sql-syntax.html#set-variable" title="13.7.4.1&nbsp;SET Syntax for Variable Assignment"><code class="literal">SET</code></a>
                                <a class="link" href="replication.html#sysvar_gtid_purged"><code class="literal">gtid_purged</code></a> statement is
                                executed.
                            </p><p style="color:blue;">当服务器启动时，将初始化@global.gtid_executed。请参阅binlog_gtid_simple_recovery，以获取有关如何迭代二进制日志以填充执行的gtid_的更多信息。然后，当执行事务时，或者如果执行了SET GTID清除的语句，则将GTID添加到集合中。</p><p>
                                The set of transactions that can be found in the binary logs
                                at any given time is equal to
                                <a class="link" href="functions.html#function_gtid-subtract"><code class="literal">GTID_SUBTRACT(@@GLOBAL.gtid_executed,
                                    @@GLOBAL.gtid_purged)</code></a>; that is, to all
                                transactions in the binary log that have not yet been
                                purged.
                            </p><p style="color:blue;">在任何给定时间都可以在二进制日志中找到的事务集等于gtid_subtract（@@global.gtid_executed，@global.gtid_purged）；即二进制日志中尚未清除的所有事务。</p><p>
                                Issuing <a class="link" href="sql-syntax.html#reset-master" title="13.4.1.2&nbsp;RESET MASTER Syntax"><code class="literal">RESET MASTER</code></a> causes
                                the global value (but not the session value) of this
                                variable to be reset to an empty string. GTIDs are not
                                otherwise removed from this set other than when the set is
                                cleared due to <code class="literal">RESET MASTER</code>.
                            </p><p style="color:blue;">发出reset master会将此变量的全局值（而不是会话值）重置为空字符串。除非由于重置主设备而清除集合，否则不会从此集合中删除GTID。</p><p>
                                Prior to MySQL 5.7.7, this variable could also be used with
                                session scope, where it contained a representation of the
                                set of transactions that are written to the cache in the
                                current session. The session scope was deprecated in MySQL
                                5.7.7.
                            </p><p style="color:blue;">在mysql 5.7.7之前，这个变量还可以用于session scope，其中包含当前会话中写入缓存的事务集的表示。mysql 5.7.7不赞成使用会话作用域。</p></li><li class="listitem"><p><a name="sysvar_gtid_executed_compression_period"></a>
                            <a class="indexterm" name="idm140286794885744"></a>

                            <a class="indexterm" name="idm140286794884704"></a>

                            <a class="link" href="replication.html#sysvar_gtid_executed_compression_period"><code class="literal">gtid_executed_compression_period</code></a>
                        </p><p style="color:blue;">执行压缩期间</p>
                            <div class="informaltable">
                                <table frame="box" rules="all" summary="Properties for gtid_executed_compression_period"><colgroup><col width="30%"><col width="70%"></colgroup><thead><tr><th scope="col">Property</th>
                                    <th scope="col">Value</th>
                                </tr></thead><tbody><tr><td scope="row"><span class="bold"><strong>Introduced</strong></span></td>
                                    <td>5.7.6</td>
                                </tr><tr><td scope="row"><span class="bold"><strong>System Variable</strong></span> (&gt;= 5.7.6)</td>
                                    <td><code class="literal"><a class="link" href="replication.html#sysvar_gtid_executed_compression_period">gtid_executed_compression_period</a></code></td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Scope</strong></span> (&gt;= 5.7.6)</td>
                                    <td>Global</td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Dynamic</strong></span> (&gt;= 5.7.6)</td>
                                    <td>Yes</td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Type</strong></span></td>
                                    <td>Integer</td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Default Value</strong></span></td>
                                    <td><code class="literal">1000</code></td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Minimum Value</strong></span></td>
                                    <td><code class="literal">0</code></td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Maximum Value</strong></span></td>
                                    <td><code class="literal">4294967295</code></td>
                                </tr></tbody></table>
                            </div>
                            <p>
                                Compress the <code class="literal">mysql.gtid_executed</code> table
                                each time this many transactions have been processed. A
                                setting of 0 means that this table is not compressed. Since
                                no compression of the table occurs when using the binary
                                log, setting the value of the variable has no effect unless
                                binary logging is disabled.
                            </p><p style="color:blue;">每次处理这么多事务时，压缩mysql.gtid_executed表。设置为0表示此表未压缩。由于使用二进制日志时不会压缩表，因此除非禁用二进制日志记录，否则设置变量的值无效。</p><p>
                                See
                                <a class="xref" href="replication.html#replication-gtids-gtid-executed-table-compression" title="mysql.gtid_executed Table Compression">mysql.gtid_executed Table Compression</a>,
                                for more information.
                            </p><p style="color:blue;">有关详细信息，请参见mysql.gtid_executed table compression。</p><p>
                                In MySQL version 5.7.5, this variable was added as
                                <code class="literal">executed_gtids_compression_period</code> and in
                                MySQL version 5.7.6 it was renamed to
                                <code class="literal">gtid_executed_compression_period</code>.
                            </p><p style="color:blue;">在mysql版本5.7.5中，这个变量被添加为executed_-gtids_compression_period，在mysql版本5.7.6中，它被重命名为gtid_-executed_compression_period。</p></li><li class="listitem"><p><a name="sysvar_gtid_mode"></a>
                            <a class="link" href="replication.html#sysvar_gtid_mode"><code class="literal">gtid_mode</code></a>
                        </p><p style="color:blue;">GTID U模式</p><a class="indexterm" name="idm140286794844752"></a><a class="indexterm" name="idm140286794843664"></a>
                            <div class="informaltable">
                                <table frame="box" rules="all" summary="Properties for gtid_mode"><colgroup><col width="30%"><col width="70%"></colgroup><thead><tr><th scope="col">Property</th>
                                    <th scope="col">Value</th>
                                </tr></thead><tbody><tr><td scope="row"><span class="bold"><strong>Command-Line Format</strong></span></td>
                                    <td><code class="literal">--gtid-mode=MODE</code></td>
                                </tr><tr><td scope="row"><span class="bold"><strong>System Variable</strong></span></td>
                                    <td><code class="literal"><a class="link" href="replication.html#sysvar_gtid_mode">gtid_mode</a></code></td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Scope</strong></span></td>
                                    <td>Global</td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Dynamic</strong></span> (&gt;= 5.7.6)</td>
                                    <td>Yes</td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Dynamic</strong></span> (&lt;= 5.7.5)</td>
                                    <td>No</td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Type</strong></span></td>
                                    <td>Enumeration</td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Default Value</strong></span></td>
                                    <td><code class="literal">OFF</code></td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Valid Values</strong></span> (&gt;= 5.7.6)</td>
                                    <td><p class="valid-value"><code class="literal">OFF</code></p><p style="color:blue;">关闭</p><p class="valid-value"><code class="literal">OFF_PERMISSIVE</code></p><p style="color:blue;">允许的</p><p class="valid-value"><code class="literal">ON_PERMISSIVE</code></p><p style="color:blue;">论宽容</p><p class="valid-value"><code class="literal">ON</code></p><p style="color:blue;">打开</p></td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Valid Values</strong></span> (&lt;= 5.7.5)</td>
                                    <td><p class="valid-value"><code class="literal">OFF</code></p><p style="color:blue;">关闭</p><p class="valid-value"><code class="literal">UPGRADE_STEP_1</code></p><p style="color:blue;">升级步骤1</p><p class="valid-value"><code class="literal">UPGRADE_STEP_2</code></p><p style="color:blue;">升级步骤2</p><p class="valid-value"><code class="literal">ON</code></p><p style="color:blue;">打开</p></td>
                                </tr></tbody></table>
                            </div>
                            <p>
                                Controls whether GTID based logging is enabled and what type
                                of transactions the logs can contain. Prior to MySQL 5.7.6,
                                this variable was read-only and was set using
                                <a class="link" href="replication.html#sysvar_gtid_mode"><code class="option">--gtid-mode</code></a> at server startup
                                only. Prior to MySQL 5.7.5, starting the server with
                                <a class="link" href="replication.html#sysvar_gtid_mode"><code class="option">--gtid-mode=ON</code></a> required that
                                the server also be started with the
                                <a class="link" href="replication.html#option_mysqld_log-bin"><code class="option">--log-bin</code></a> and
                                <a class="link" href="replication.html#sysvar_log_slave_updates"><code class="option">--log-slave-updates</code></a> options.
                                As of MySQL 5.7.5, this is no longer a requirement. See
                                <a class="xref" href="replication.html#replication-gtids-gtid-executed-table" title="mysql.gtid_executed Table">mysql.gtid_executed Table</a>.
                            </p><p style="color:blue;">控制是否启用基于gtid的日志记录以及日志可以包含的事务类型。在MySQL5.7.6之前，此变量是只读的，仅在服务器启动时使用--gtid模式设置。在mysql 5.7.5之前，使用--gtid mode=on启动服务器需要使用--log bin和--log slave更新选项启动服务器。从mysql 5.7.5开始，这不再是一个要求。参见mysql.gtid_executed表。</p><p>
                                MySQL 5.7.6 enables this variable to be set dynamically. You
                                must have privileges sufficient to set global system
                                variables. See <a class="xref" href="server-administration.html#system-variable-privileges" title="5.1.8.1&nbsp;System Variable Privileges">Section&nbsp;5.1.8.1, “System Variable Privileges”</a>.
                                <a class="link" href="replication.html#sysvar_enforce_gtid_consistency"><code class="literal">enforce_gtid_consistency</code></a>
                                must be true before you can set
                                <a class="link" href="replication.html#sysvar_gtid_mode"><code class="literal">gtid_mode=ON</code></a>. Before
                                modifying this variable, see
                                <a class="xref" href="replication.html#replication-mode-change-online" title="16.1.5&nbsp;Changing Replication Modes on Online Servers">Section&nbsp;16.1.5, “Changing Replication Modes on Online Servers”</a>.
                            </p><p style="color:blue;">mysql 5.7.6允许动态设置此变量。您必须具有足够的权限来设置全局系统变量。见第5.1.8.1节“系统变量特权”。在将gtid_mode设置为“开”之前，“强制”gtid_consistence必须为true。在修改此变量之前，请参阅第16.1.5节“更改联机服务器上的复制模式”。</p><p>
                                Transactions logged in MySQL 5.7.6 and later can be either
                                anonymous or use GTIDs. Anonymous transactions rely on
                                binary log file and position to identify specific
                                transactions. GTID transactions have a unique identifier
                                that is used to refer to transactions. The
                                <code class="literal">OFF_PERMISSIVE</code> and
                                <code class="literal">ON_PERMISSIVE</code> modes added in MySQL 5.7.6
                                permit a mix of these transaction types in the topology. The
                                different modes are now:
                            </p><p style="color:blue;">mysql 5.7.6及更高版本中记录的事务可以是匿名的，也可以使用gtid。匿名事务依赖二进制日志文件和位置来标识特定事务。gtid事务具有用于引用事务的唯一标识符。mysql 5.7.6中添加的off-permissive和on-permissive模式允许在拓扑中混合使用这些事务类型。不同的模式现在是：</p>
                            <div class="itemizedlist">
                                <ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
                                    <code class="literal">OFF</code>: Both new and replicated
                                    transactions must be anonymous.
                                </p><p style="color:blue;">关闭：新事务和复制事务都必须是匿名的。</p></li><li class="listitem"><p>
                                    <code class="literal">OFF_PERMISSIVE</code>: New transactions are
                                    anonymous. Replicated transactions can be either
                                    anonymous or GTID transactions.
                                </p><p style="color:blue;">允许关闭：新交易是匿名的。复制的事务可以是匿名事务或gtid事务。</p></li><li class="listitem"><p>
                                    <code class="literal">ON_PERMISSIVE</code>: New transactions are
                                    GTID transactions. Replicated transactions can be either
                                    anonymous or GTID transactions.
                                </p><p style="color:blue;">on_permissive:新事务是gtid事务。复制的事务可以是匿名事务或gtid事务。</p></li><li class="listitem"><p>
                                    <code class="literal">ON</code>: Both new and replicated
                                    transactions must be GTID transactions.
                                </p><p style="color:blue;">on:新事务和复制事务都必须是gtid事务。</p></li></ul>
                            </div>
                            <p>
                                Changes from one value to another can only be one step at a
                                time. For example, if
                                <a class="link" href="replication.html#sysvar_gtid_mode"><code class="literal">gtid_mode</code></a> is currently set
                                to <code class="literal">OFF_PERMISSIVE</code>, it is possible to
                                change to <code class="literal">OFF</code> or
                                <code class="literal">ON_PERMISSIVE</code> but not to
                                <code class="literal">ON</code>.
                            </p><p style="color:blue;">从一个值到另一个值的更改一次只能是一个步骤。例如，如果gtid_mode当前设置为off_permissive，则可以更改为off或on_permissive，但不能更改为on。</p><p>
                                In MySQL 5.7.6 and later, the values of
                                <a class="link" href="replication.html#sysvar_gtid_purged"><code class="literal">gtid_purged</code></a> and
                                <a class="link" href="replication.html#sysvar_gtid_executed"><code class="literal">gtid_executed</code></a> are
                                persistent regardless of the value of
                                <a class="link" href="replication.html#sysvar_gtid_mode"><code class="literal">gtid_mode</code></a>. Therefore even
                                after changing the value of
                                <a class="link" href="replication.html#sysvar_gtid_mode"><code class="literal">gtid_mode</code></a>, these variables
                                contain the correct values. In MySQL 5.7.5 and earlier, the
                                values of <a class="link" href="replication.html#sysvar_gtid_purged"><code class="literal">gtid_purged</code></a> and
                                <a class="link" href="replication.html#sysvar_gtid_executed"><code class="literal">gtid_executed</code></a> are not
                                persistent while
                                <a class="link" href="replication.html#sysvar_gtid_mode"><code class="literal">gtid_mode=OFF</code></a>. Therefore,
                                after changing <a class="link" href="replication.html#sysvar_gtid_mode"><code class="literal">gtid_mode</code></a> to
                                <code class="literal">OFF</code>, once all binary logs containing
                                GTIDs are purged, the values of these variables are lost.
                            </p><p style="color:blue;">在mysql 5.7.6及更高版本中，清除的gtid_和执行的gtid_的值是持久的，而不管gtid_mode的值是什么。因此，即使在更改gtid_mode的值之后，这些变量也包含正确的值。在mysql 5.7.5和更早版本中，当gtid_mode=off时，清除的gtid_和执行的gtid_的值不是持久的。因此，在将gtid_mode更改为off之后，一旦清除包含gtid的所有二进制日志，这些变量的值就会丢失。</p></li><li class="listitem"><p><a name="sysvar_gtid_next"></a>
                            <a class="indexterm" name="idm140286794766080"></a>

                            <a class="indexterm" name="idm140286794765024"></a>

                            <a class="link" href="replication.html#sysvar_gtid_next"><code class="literal">gtid_next</code></a>
                        </p><p style="color:blue;">下一个</p>
                            <div class="informaltable">
                                <table frame="box" rules="all" summary="Properties for gtid_next"><colgroup><col width="30%"><col width="70%"></colgroup><thead><tr><th scope="col">Property</th>
                                    <th scope="col">Value</th>
                                </tr></thead><tbody><tr><td scope="row"><span class="bold"><strong>System Variable</strong></span></td>
                                    <td><code class="literal"><a class="link" href="replication.html#sysvar_gtid_next">gtid_next</a></code></td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Scope</strong></span></td>
                                    <td>Session</td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Dynamic</strong></span></td>
                                    <td>Yes</td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Type</strong></span></td>
                                    <td>Enumeration</td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Default Value</strong></span></td>
                                    <td><code class="literal">AUTOMATIC</code></td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Valid Values</strong></span></td>
                                    <td><p class="valid-value"><code class="literal">AUTOMATIC</code></p><p style="color:blue;">自动</p><p class="valid-value"><code class="literal">ANONYMOUS</code></p><p style="color:blue;">匿名的</p><p class="valid-value"><code class="literal">UUID:NUMBER</code></p><p style="color:blue;">Uuid:编号</p></td>
                                </tr></tbody></table>
                            </div>
                            <p>
                                This variable is used to specify whether and how the next
                                GTID is obtained.
                            </p><p style="color:blue;">此变量用于指定是否以及如何获取下一个gtid。</p><p>
                                Setting the session value of this system variable is a
                                restricted operation. The session user must have privileges
                                sufficient to set restricted session variables. See
                                <a class="xref" href="server-administration.html#system-variable-privileges" title="5.1.8.1&nbsp;System Variable Privileges">Section&nbsp;5.1.8.1, “System Variable Privileges”</a>.
                            </p><p style="color:blue;">设置此系统变量的会话值是受限制的操作。会话用户必须具有足够的权限来设置受限制的会话变量。见第5.1.8.1节“系统变量特权”。</p><p>
                                <code class="literal">gtid_next</code> can take any of the following
                                values:
                            </p><p style="color:blue;">gtid_next可以采用以下任何值：</p>
                            <div class="itemizedlist">
                                <ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
                                    <code class="literal">AUTOMATIC</code>: Use the next
                                    automatically-generated global transaction ID.
                                </p><p style="color:blue;">自动：使用下一个自动生成的全局事务ID。</p></li><li class="listitem"><p>
                                    <code class="literal">ANONYMOUS</code>: Transactions do not have
                                    global identifiers, and are identified by file and
                                    position only.
                                </p><p style="color:blue;">匿名：事务没有全局标识符，仅通过文件和位置标识。</p></li><li class="listitem"><p>
                                    A global transaction ID in
                                    <em class="replaceable"><code>UUID</code></em>:<em class="replaceable"><code>NUMBER</code></em>
                                    format.
                                </p><p style="color:blue;">uuid:number格式的全局事务ID。</p></li></ul>
                            </div>
                            <p>
                                Exactly which of the above options are valid depends on the
                                setting of <a class="link" href="replication.html#sysvar_gtid_mode"><code class="literal">gtid_mode</code></a>, see
                                <a class="xref" href="replication.html#replication-mode-change-online-concepts" title="16.1.5.1&nbsp;Replication Mode Concepts">Section&nbsp;16.1.5.1, “Replication Mode Concepts”</a>
                                for more information. Setting this variable has no effect if
                                <a class="link" href="replication.html#sysvar_gtid_mode"><code class="literal">gtid_mode</code></a> is
                                <code class="literal">OFF</code>.
                            </p><p style="color:blue;">以上哪个选项是有效的取决于gtid_mode的设置，有关更多信息，请参见第16.1.5.1节“复制模式概念”。如果gtid_mode关闭，则设置此变量无效。</p><p>
                                After this variable has been set to
                                <em class="replaceable"><code>UUID</code></em>:<em class="replaceable"><code>NUMBER</code></em>,
                                and a transaction has been committed or rolled back, an
                                explicit <code class="literal">SET GTID_NEXT</code> statement must
                                again be issued before any other statement.
                            </p><p style="color:blue;">在将此变量设置为uuid:number并提交或回滚事务之后，必须在任何其他语句之前再次发出显式set gtid_next语句。</p><p>
                                In MySQL 5.7.5 and later, <code class="literal">DROP TABLE</code> or
                                <code class="literal">DROP TEMPORARY TABLE</code> fails with an
                                explicit error when used on a combination of nontemporary
                                tables with temporary tables, or of temporary tables using
                                transactional storage engines with temporary tables using
                                nontransactional storage engines. Prior to MySQL 5.7.5, when
                                GTIDs were enabled but <code class="literal">gtid_next</code> was not
                                <code class="literal">AUTOMATIC</code>, <a class="link" href="sql-syntax.html#drop-table" title="13.1.29&nbsp;DROP TABLE Syntax"><code class="literal">DROP
                                TABLE</code></a> did not work correctly when used with either
                                of these combinations of tables. (Bug #17620053)
                            </p><p style="color:blue;">在mysql 5.7.5及更高版本中，当将drop table或drop temporary table用于非临时表和临时表的组合时，或用于使用事务性存储引擎的临时表和使用非事务性存储引擎的临时表的组合时，drop table或drop temporary table将失败，并显示错误。在mysql 5.7.5之前，当gtid被启用，但gtid_next不是自动的时，drop table在与这些表的组合一起使用时不能正常工作。（错误17620053）</p><p>
                                In MySQL 5.7.1, you cannot execute any of the statements
                                <a class="link" href="sql-syntax.html#change-master-to" title="13.4.2.1&nbsp;CHANGE MASTER TO Syntax"><code class="literal">CHANGE MASTER TO</code></a>,
                                <a class="link" href="sql-syntax.html#start-slave" title="13.4.2.6&nbsp;START SLAVE Syntax"><code class="literal">START SLAVE</code></a>,
                                <a class="link" href="sql-syntax.html#stop-slave" title="13.4.2.7&nbsp;STOP SLAVE Syntax"><code class="literal">STOP SLAVE</code></a>,
                                <a class="link" href="sql-syntax.html#repair-table" title="13.7.2.5&nbsp;REPAIR TABLE Syntax"><code class="literal">REPAIR TABLE</code></a>,
                                <a class="link" href="sql-syntax.html#optimize-table" title="13.7.2.4&nbsp;OPTIMIZE TABLE Syntax"><code class="literal">OPTIMIZE TABLE</code></a>,
                                <a class="link" href="sql-syntax.html#analyze-table" title="13.7.2.1&nbsp;ANALYZE TABLE Syntax"><code class="literal">ANALYZE TABLE</code></a>,
                                <a class="link" href="sql-syntax.html#check-table" title="13.7.2.2&nbsp;CHECK TABLE Syntax"><code class="literal">CHECK TABLE</code></a>,
                                <a class="link" href="sql-syntax.html#create-server" title="13.1.17&nbsp;CREATE SERVER Syntax"><code class="literal">CREATE SERVER</code></a>,
                                <a class="link" href="sql-syntax.html#alter-server" title="13.1.7&nbsp;ALTER SERVER Syntax"><code class="literal">ALTER SERVER</code></a>,
                                <a class="link" href="sql-syntax.html#drop-server" title="13.1.28&nbsp;DROP SERVER Syntax"><code class="literal">DROP SERVER</code></a>,
                                <a class="link" href="sql-syntax.html#cache-index" title="13.7.6.2&nbsp;CACHE INDEX Syntax"><code class="literal">CACHE INDEX</code></a>,
                                <a class="link" href="sql-syntax.html#load-index" title="13.7.6.5&nbsp;LOAD INDEX INTO CACHE Syntax"><code class="literal">LOAD INDEX INTO
                                    CACHE</code></a>, <a class="link" href="sql-syntax.html#flush" title="13.7.6.3&nbsp;FLUSH Syntax"><code class="literal">FLUSH</code></a>, or
                                <a class="link" href="sql-syntax.html#reset" title="13.7.6.6&nbsp;RESET Syntax"><code class="literal">RESET</code></a> when
                                <a class="link" href="replication.html#sysvar_gtid_next"><code class="literal">gtid_next</code></a> is set to any
                                value other than <code class="literal">AUTOMATIC</code>; in such
                                cases, the statement fails with an error. Such statements
                                are <span class="emphasis"><em>not</em></span> disallowed in MySQL 5.7.2 and
                                later. (Bug #16062608, Bug #16715809, Bug #69045) (Bug
                                #16062608)
                            </p><p style="color:blue;">在mysql 5.7.1中，当gtid爨next设置为除automatic以外的任何值时，不能执行change master to、start slave、stop slave、repair table、optimize table、analyze table、check table、create server、alter server、drop server、cache index、load index into cache、flush或reset语句；在这种情况下，语句失败的原因是一个错误。mysql 5.7.2及更高版本中不允许使用此类语句。（错误16062608，错误16715809，错误69045）（错误16062608）</p></li><li class="listitem"><p><a name="sysvar_gtid_owned"></a>
                            <a class="indexterm" name="idm140286794694800"></a>

                            <a class="indexterm" name="idm140286794693744"></a>

                            <a class="link" href="replication.html#sysvar_gtid_owned"><code class="literal">gtid_owned</code></a>
                        </p><p style="color:blue;">GTID拥有</p>
                            <div class="informaltable">
                                <table frame="box" rules="all" summary="Properties for gtid_owned"><colgroup><col width="30%"><col width="70%"></colgroup><thead><tr><th scope="col">Property</th>
                                    <th scope="col">Value</th>
                                </tr></thead><tbody><tr><td scope="row"><span class="bold"><strong>System Variable</strong></span></td>
                                    <td><code class="literal"><a class="link" href="replication.html#sysvar_gtid_owned">gtid_owned</a></code></td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Scope</strong></span></td>
                                    <td>Global, Session</td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Dynamic</strong></span></td>
                                    <td>No</td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Type</strong></span></td>
                                    <td>String</td>
                                </tr></tbody></table>
                            </div>
                            <p>
                                This read-only variable is primarily for internal use. Its
                                contents depend on its scope.
                            </p><p style="color:blue;">此只读变量主要用于内部使用。它的内容取决于它的范围。</p>
                            <div class="itemizedlist">
                                <ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
                                    When used with global scope,
                                    <a class="link" href="replication.html#sysvar_gtid_owned"><code class="literal">gtid_owned</code></a> holds a list
                                    of all the GTIDs that are currently in use on the
                                    server, with the IDs of the threads that own them. This
                                    variable is mainly useful for a multi-threaded
                                    replication slave to check whether a transaction is
                                    already being applied on another thread. An applier
                                    thread takes ownership of a transaction's GTID all the
                                    time it is processing the transaction, so
                                    <code class="literal">@@global.gtid_owned</code> shows the GTID
                                    and owner for the duration of processing. When a
                                    transaction has been committed (or rolled back), the
                                    applier thread releases ownership of the GTID.
                                </p><p style="color:blue;">当与全局作用域一起使用时，gtid所拥有的包含当前在服务器上使用的所有gtid的列表，以及拥有它们的线程的id。此变量主要用于多线程复制从机检查事务是否已应用于另一个线程。applier线程在处理事务的过程中始终拥有事务的gtid，因此@global.gtid\u owned显示处理期间的gtid和所有者。当事务被提交（或回滚）时，applier线程释放gtid的所有权。</p></li><li class="listitem"><p>
                                    When used with session scope,
                                    <a class="link" href="replication.html#sysvar_gtid_owned"><code class="literal">gtid_owned</code></a> holds a
                                    single GTID that is currently in use by and owned by
                                    this session. This variable is mainly useful for testing
                                    and debugging the use of GTIDs when the client has
                                    explicitly assigned a GTID for the transaction by
                                    setting <a class="link" href="replication.html#sysvar_gtid_next"><code class="literal">gtid_next</code></a>. In
                                    this case, <code class="literal">@@session.gtid_owned</code>
                                    displays the GTID all the time the client is processing
                                    the transaction, until the transaction has been
                                    committed (or rolled back). When the client has finished
                                    processing the transaction, the variable is cleared. If
                                    <a class="link" href="replication.html#sysvar_gtid_next"><code class="literal">gtid_next=AUTOMATIC</code></a> is
                                    used for the session,
                                    <a class="link" href="replication.html#sysvar_gtid_owned"><code class="literal">gtid_owned</code></a> is only
                                    populated briefly during the execution of the commit
                                    statement for the transaction, so it cannot be observed
                                    from the session concerned, although it will be listed
                                    if <code class="literal">@@global.gtid_owned</code> is read at the
                                    right point. If you have a requirement to track the
                                    GTIDs that are handled by a client in a session, you can
                                    enable the session state tracker controlled by the
                                    <a class="link" href="server-administration.html#sysvar_session_track_gtids"><code class="literal">session_track_gtids</code></a>
                                    system variable.
                                </p><p style="color:blue;">当与会话作用域一起使用时，gtid拥有的是当前由该会话使用和拥有的单个gtid。此变量主要用于测试和调试在客户端为事务显式分配gtid（通过设置gtid_next）时gtid的使用。在这种情况下，@@session.gtid_owned在客户机处理事务时始终显示gtid，直到提交（或回滚）事务为止。当客户机处理完事务后，变量将被清除。如果会话使用gtid_next=automatic，则gtid_owned只在事务的commit语句执行期间短暂填充，因此无法从相关会话中观察到它，尽管如果在正确的位置读取@global.gtid_owned，则会列出它。如果需要跟踪会话中由客户端处理的GTID，可以启用由会话跟踪GTID系统变量控制的会话状态跟踪器。</p></li></ul>
                            </div>
                        </li><li class="listitem"><p><a name="sysvar_gtid_purged"></a>
                            <a class="indexterm" name="idm140286794657792"></a>

                            <a class="indexterm" name="idm140286794656784"></a>

                            <a class="link" href="replication.html#sysvar_gtid_purged"><code class="literal">gtid_purged</code></a>
                        </p><p style="color:blue;">GTID_已清除</p>
                            <div class="informaltable">
                                <table frame="box" rules="all" summary="Properties for gtid_purged"><colgroup><col width="30%"><col width="70%"></colgroup><thead><tr><th scope="col">Property</th>
                                    <th scope="col">Value</th>
                                </tr></thead><tbody><tr><td scope="row"><span class="bold"><strong>System Variable</strong></span></td>
                                    <td><code class="literal"><a class="link" href="replication.html#sysvar_gtid_purged">gtid_purged</a></code></td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Scope</strong></span></td>
                                    <td>Global</td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Dynamic</strong></span></td>
                                    <td>Yes</td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Type</strong></span></td>
                                    <td>String</td>
                                </tr></tbody></table>
                            </div>
                            <p>
                                The global value of the
                                <a class="link" href="replication.html#sysvar_gtid_purged"><code class="literal">gtid_purged</code></a> system variable
                                (<code class="literal">@@GLOBAL.gtid_purged</code>) is a GTID set
                                consisting of the GTIDs of all the transactions that have
                                been committed on the server, but do not exist in any binary
                                log file on the server.
                                <a class="link" href="replication.html#sysvar_gtid_purged"><code class="literal">gtid_purged</code></a> is a subset of
                                <a class="link" href="replication.html#sysvar_gtid_executed"><code class="literal">gtid_executed</code></a>. The
                                following categories of GTIDs are in
                                <a class="link" href="replication.html#sysvar_gtid_purged"><code class="literal">gtid_purged</code></a>:
                            </p><p style="color:blue;">GTIDIAUPURAGE系统变量的全局值（@ @ Global .GTIDIPUPED）是由服务器上提交的所有事务的GTIDs组成的GTID集，但不存在于服务器上的任何二进制日志文件中。清除的gtid是执行的gtid的子集。清除的GTID中包含以下类别的GTID：</p>
                            <div class="itemizedlist">
                                <ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
                                    GTIDs of replicated transactions that were committed
                                    with binary logging disabled on the slave.
                                </p><p style="color:blue;">在从机上禁用二进制日志记录的情况下提交的复制事务的gtid。</p></li><li class="listitem"><p>
                                    GTIDs of transactions that were written to a binary log
                                    file that has now been purged.
                                </p><p style="color:blue;">写入现在已清除的二进制日志文件的事务的gtid。</p></li><li class="listitem"><p>
                                    GTIDs that were added explicitly to the set by the
                                    statement <code class="literal">SET @@GLOBAL.gtid_purged</code>.
                                </p><p style="color:blue;">已清除由语句set@@global.gtid明确添加到集合的gtid。</p></li></ul>
                            </div>
                            <p>
                                When the server starts or restarts, the global value of
                                <a class="link" href="replication.html#sysvar_gtid_purged"><code class="literal">gtid_purged</code></a> is initialized
                                to a set of GTIDs. For information on how this GTID set is
                                computed, see
                                <a class="xref" href="replication.html#replication-gtids-gtid-purged" title="The gtid_purged System Variable">The <code class="literal">gtid_purged</code> System Variable</a>. If binary
                                logs from MySQL 5.7.7 or older are present on the server,
                                you might need to set
                                <a class="link" href="replication.html#sysvar_binlog_gtid_simple_recovery"><code class="literal">binlog_gtid_simple_recovery=FALSE</code></a>
                                in the server's configuration file to produce the correct
                                computation. See the description for
                                <a class="link" href="replication.html#sysvar_binlog_gtid_simple_recovery"><code class="literal">binlog_gtid_simple_recovery</code></a>
                                for details of the situations in which this setting is
                                needed.
                            </p><p style="color:blue;">当服务器启动或重新启动时，清除的gtid_的全局值初始化为一组gtid。有关如何计算该gtid集的信息，请参见gtid_purged系统变量。如果服务器上存在来自mysql 5.7.7或更高版本的二进制日志，则可能需要在服务器的配置文件中设置binlog_gtid_simple_recovery=false以生成正确的计算。有关需要此设置的情况的详细信息，请参阅binlog_gtid_simple_recovery的说明。</p><p>
                                Issuing <a class="link" href="sql-syntax.html#reset-master" title="13.4.1.2&nbsp;RESET MASTER Syntax"><code class="literal">RESET MASTER</code></a> causes
                                the value of <a class="link" href="replication.html#sysvar_gtid_purged"><code class="literal">gtid_purged</code></a> to
                                be reset to an empty string.
                            </p><p style="color:blue;">发出reset master将导致清除的gtid_的值重置为空字符串。</p><p>
                                You can set the value of
                                <a class="link" href="replication.html#sysvar_gtid_purged"><code class="literal">gtid_purged</code></a> in order to
                                record on the server that the transactions in a certain GTID
                                set have been applied, although they do not exist in any
                                binary log on the server. An example use case for this
                                action is when you are restoring a backup of one or more
                                databases on a server, but you do not have the relevant
                                binary logs containing the transactions on the server.
                            </p><p style="color:blue;">您可以设置GTIDIPUPEDGE的值，以便在服务器上记录某个GTID集合中的事务已被应用，尽管它们不存在于服务器上的任何二进制日志中。此操作的一个示例用例是，当您在服务器上还原一个或多个数据库的备份时，但是您没有包含服务器上事务的相关二进制日志。</p><p>
                                In MySQL 5.7, it is possible to update the value of
                                <a class="link" href="replication.html#sysvar_gtid_purged"><code class="literal">gtid_purged</code></a> only when
                                <a class="link" href="replication.html#sysvar_gtid_executed"><code class="literal">gtid_executed</code></a> is the empty
                                string, and therefore
                                <a class="link" href="replication.html#sysvar_gtid_purged"><code class="literal">gtid_purged</code></a> is the empty
                                string. This is the case either when replication has not
                                been started previously, or when replication did not
                                previously use GTIDs. Prior to MySQL 5.7.6,
                                <a class="link" href="replication.html#sysvar_gtid_purged"><code class="literal">gtid_purged</code></a> was also
                                settable only when
                                <a class="link" href="replication.html#sysvar_gtid_mode"><code class="literal">gtid_mode=ON</code></a>. In MySQL
                                5.7.6 and later,
                                <a class="link" href="replication.html#sysvar_gtid_purged"><code class="literal">gtid_purged</code></a> is settable
                                regardless of the value of
                                <a class="link" href="replication.html#sysvar_gtid_mode"><code class="literal">gtid_mode</code></a>.
                            </p><p style="color:blue;">在mysql 5.7中，只有当gtid_executed为空字符串时，才可以更新gtid_purged的值，因此gtid_purged为空字符串。如果以前没有启动复制，或者复制以前没有使用gtid，则会出现这种情况。在mysql 5.7.6之前，gtid_purged也只能在gtid_mode=on时设置。在mysql 5.7.6及更高版本中，清除的gtid_是可设置的，与gtid_mode的值无关。</p><p>
                                To replace the value of
                                <a class="link" href="replication.html#sysvar_gtid_purged"><code class="literal">gtid_purged</code></a> with your
                                specified GTID set, use the following statement:
                            </p><p style="color:blue;">要用指定的gtid集替换清除的gtid的值，请使用以下语句：</p><pre data-lang="sql" class="programlisting">SET @@GLOBAL.gtid_purged = 'gtid_set'</pre>
                            <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">

                                <div class="admon-title">
                                    Note
                                </div>
                                <p>
                                    If you are using MySQL 5.7.7 or earlier, after issuing a
                                    <code class="literal">SET @@GLOBAL.gtid_purged</code> statement, you
                                    might need to set
                                    <a class="link" href="replication.html#sysvar_binlog_gtid_simple_recovery"><code class="literal">binlog_gtid_simple_recovery=FALSE</code></a>
                                    in the server's configuration file before restarting the
                                    server, otherwise
                                    <a class="link" href="replication.html#sysvar_gtid_purged"><code class="literal">gtid_purged</code></a> can be
                                    computed incorrectly. See the description for
                                    <a class="link" href="replication.html#sysvar_binlog_gtid_simple_recovery"><code class="literal">binlog_gtid_simple_recovery</code></a>
                                    for details of the situations in which this setting is
                                    needed. If all binary logs on the server were generated
                                    using MySQL 5.7.8 or later and you are using MySQL 5.7.8
                                    or later,
                                    <a class="link" href="replication.html#sysvar_binlog_gtid_simple_recovery"><code class="literal">binlog_gtid_simple_recovery=TRUE</code></a>
                                    (which is the default setting from MySQL 5.7.7) can always
                                    safely be used.
                                </p><p style="color:blue;">如果您使用的是mysql 5.7.7或更早版本，在发出set@@global.gtid_purged语句后，可能需要在重新启动服务器之前，在服务器的配置文件中设置binlog_gtid_simple_recovery=false，否则，清除的gtid_可能计算不正确。有关需要此设置的情况的详细信息，请参阅binlog_gtid_simple_recovery的说明。如果服务器上的所有二进制日志都是使用mysql 5.7.8或更高版本生成的，并且您使用的是mysql 5.7.8或更高版本，那么binlog_gtid_simple_recovery=true（这是mysql 5.7.7的默认设置）始终可以安全地使用。</p>
                            </div>
                        </li><li class="listitem"><p><a name="sysvar_simplified_binlog_gtid_recovery"></a>
                            <a class="indexterm" name="idm140286794595264"></a>

                            <a class="indexterm" name="idm140286794594224"></a>

                            <a class="link" href="replication.html#sysvar_simplified_binlog_gtid_recovery"><code class="literal">simplified_binlog_gtid_recovery</code></a>
                        </p><p style="color:blue;">简化的恢复</p>
                            <div class="informaltable">
                                <table frame="box" rules="all" summary="Properties for simplified_binlog_gtid_recovery"><colgroup><col width="30%"><col width="70%"></colgroup><thead><tr><th scope="col">Property</th>
                                    <th scope="col">Value</th>
                                </tr></thead><tbody><tr><td scope="row"><span class="bold"><strong>Command-Line Format</strong></span></td>
                                    <td><code class="literal">--simplified-binlog-gtid-recovery[={OFF|ON}]</code></td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Introduced</strong></span></td>
                                    <td>5.7.5</td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Deprecated</strong></span></td>
                                    <td>Yes (removed in 5.7.6)</td>
                                </tr><tr><td scope="row"><span class="bold"><strong>System Variable</strong></span></td>
                                    <td><code class="literal"><a class="link" href="replication.html#sysvar_simplified_binlog_gtid_recovery">simplified_binlog_gtid_recovery</a></code></td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Scope</strong></span></td>
                                    <td>Global</td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Dynamic</strong></span></td>
                                    <td>No</td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Type</strong></span></td>
                                    <td>Boolean</td>
                                </tr><tr><td scope="row"><span class="bold"><strong>Default Value</strong></span></td>
                                    <td><code class="literal">OFF</code></td>
                                </tr></tbody></table>
                            </div>
                            <p>
                                Renamed to
                                <a class="link" href="replication.html#sysvar_binlog_gtid_simple_recovery"><code class="literal">binlog_gtid_simple_recovery</code></a>.
                            </p><p style="color:blue;">重命名为binlog_gtid_simple_recovery。</p></li></ul>
                    </div>

                </div>

            </div>

        </div>
        <div class="section">
            <div class="titlepage">
                <div>
                    <div>
                        <h3 class="title"><a name="replication-administration"></a>16.1.7&nbsp;Common Replication Administration Tasks</h3>

                    </div>

                </div>

            </div>
            <div class="toc">
                <dl class="toc"><dt><span class="section"><a href="replication.html#replication-administration-status">16.1.7.1 Checking Replication Status</a></span></dt><dt><span class="section"><a href="replication.html#replication-administration-pausing">16.1.7.2 Pausing Replication on the Slave</a></span></dt></dl>
            </div>
            <p>
                Once replication has been started it executes without requiring
                much regular administration. This section describes how to check
                the status of replication and how to pause a slave.
            </p><p style="color:blue;">一旦复制启动，它就可以执行，而不需要太多的常规管理。本节介绍如何检查复制的状态以及如何暂停从机。</p>
            <div class="section">

                <div class="titlepage">
                    <div>
                        <div>
                            <h4 class="title"><a name="replication-administration-status"></a>16.1.7.1&nbsp;Checking Replication Status</h4>
                        </div>
                    </div>
                </div>
                <p>
                    The most common task when managing a replication process is to
                    ensure that replication is taking place and that there have been
                    no errors between the slave and the master.
                </p><p style="color:blue;">管理复制过程时最常见的任务是确保复制正在进行，并且从机和主机之间没有错误。</p><p>
                The <a class="link" href="sql-syntax.html#show-slave-status" title="13.7.5.34&nbsp;SHOW SLAVE STATUS Syntax"><code class="literal">SHOW SLAVE STATUS</code></a> statement,
                which you must execute on each slave, provides information about
                the configuration and status of the connection between the slave
                server and the master server. From MySQL 5.7, the Performance
                Schema has replication tables that provide this information in a
                more accessible form. See
                <a class="xref" href="performance-schema.html#performance-schema-replication-tables" title="25.12.11&nbsp;Performance Schema Replication Tables">Section&nbsp;25.12.11, “Performance Schema Replication Tables”</a>.
            </p><p style="color:blue;">show slave status语句必须在每个从服务器上执行，它提供了关于从服务器和主服务器之间连接的配置和状态的信息。在mysql 5.7中，性能模式具有以更易访问的形式提供此信息的复制表。见25.12.11节，“性能模式复制表”。</p><p>
                The <a class="link" href="sql-syntax.html#show-status" title="13.7.5.35&nbsp;SHOW STATUS Syntax"><code class="literal">SHOW STATUS</code></a> statement also
                provided some information relating specifically to replication
                slaves. As of MySQL version 5.7.5, the following status
                variables previously monitored using <a class="link" href="sql-syntax.html#show-status" title="13.7.5.35&nbsp;SHOW STATUS Syntax"><code class="literal">SHOW
                STATUS</code></a> were deprecated and moved to the Performance
                Schema replication tables:
            </p><p style="color:blue;">show status语句还提供了一些特定于复制从属服务器的信息。从mysql版本5.7.5开始，以前使用show status监视的以下状态变量已弃用，并移到性能架构复制表中：</p>
                <div class="itemizedlist">
                    <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                        <a class="link" href="server-administration.html#statvar_Slave_retried_transactions"><code class="literal">Slave_retried_transactions</code></a>
                    </p><p style="color:blue;">从重试的事务</p></li><li class="listitem"><p>
                        <a class="link" href="server-administration.html#statvar_Slave_last_heartbeat"><code class="literal">Slave_last_heartbeat</code></a>
                    </p><p style="color:blue;">从心跳</p></li><li class="listitem"><p>
                        <a class="link" href="server-administration.html#statvar_Slave_received_heartbeats"><code class="literal">Slave_received_heartbeats</code></a>
                    </p><p style="color:blue;">从接收到心跳</p></li><li class="listitem"><p>
                        <a class="link" href="server-administration.html#statvar_Slave_heartbeat_period"><code class="literal">Slave_heartbeat_period</code></a>
                    </p><p style="color:blue;">从心跳周期</p></li><li class="listitem"><p>
                        <a class="link" href="server-administration.html#statvar_Slave_running"><code class="literal">Slave_running</code></a>
                    </p><p style="color:blue;">从运行</p></li></ul>
                </div>
                <p>
                    The replication heartbeat information shown in the Performance
                    Schema replication tables lets you check that the replication
                    connection is active even if the master has not sent events to
                    the slave recently. The master sends a heartbeat signal to a
                    slave if there are no updates to, and no unsent events in, the
                    binary log for a longer period than the heartbeat interval. The
                    <code class="literal">MASTER_HEARTBEAT_PERIOD</code> setting on the master
                    (set by the <a class="link" href="sql-syntax.html#change-master-to" title="13.4.2.1&nbsp;CHANGE MASTER TO Syntax"><code class="literal">CHANGE MASTER
                    TO</code></a> statement) specifies the frequency of the
                    heartbeat, which defaults to half of the connection timeout
                    interval for the slave
                    (<a class="link" href="replication.html#sysvar_slave_net_timeout"><code class="literal">slave_net_timeout</code></a>). The
                    <a class="link" href="performance-schema.html#replication-connection-status-table" title="25.12.11.2&nbsp;The replication_connection_status Table"><code class="literal">replication_connection_status</code></a>
                    Performance Schema table shows when the most recent heartbeat
                    signal was received by a replication slave, and how many
                    heartbeat signals it has received.
                </p><p style="color:blue;">性能架构复制表中显示的复制心跳信息允许您检查复制连接是否处于活动状态，即使主机最近没有向从机发送事件。如果二进制日志在超过心跳间隔的更长时间内没有更新，也没有未发送事件，则主服务器会向从服务器发送心跳信号。主设备上的master_heartbeat_period设置（由change master to语句设置）指定心跳的频率，该频率默认为从设备的连接超时间隔（slave_net_timeout）的一半。replication_connection_status performance schema表显示复制从机何时接收到最新的心跳信号，以及它接收到了多少心跳信号。</p><p>
                If you are using the <a class="link" href="sql-syntax.html#show-slave-status" title="13.7.5.34&nbsp;SHOW SLAVE STATUS Syntax"><code class="literal">SHOW SLAVE
                STATUS</code></a> statement to check on the status of an
                individual slave, the statement provides the following
                information:
            </p><p style="color:blue;">如果使用show slave status语句检查单个从机的状态，则该语句提供以下信息：</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>SHOW SLAVE STATUS\G</code></strong>
*************************** 1. row ***************************
               Slave_IO_State: Waiting for master to send event
                  Master_Host: master1
                  Master_User: root
                  Master_Port: 3306
                Connect_Retry: 60
              Master_Log_File: mysql-bin.000004
          Read_Master_Log_Pos: 931
               Relay_Log_File: slave1-relay-bin.000056
                Relay_Log_Pos: 950
        Relay_Master_Log_File: mysql-bin.000004
             Slave_IO_Running: Yes
            Slave_SQL_Running: Yes
              Replicate_Do_DB:
          Replicate_Ignore_DB:
           Replicate_Do_Table:
       Replicate_Ignore_Table:
      Replicate_Wild_Do_Table:
  Replicate_Wild_Ignore_Table:
                   Last_Errno: 0
                   Last_Error:
                 Skip_Counter: 0
          Exec_Master_Log_Pos: 931
              Relay_Log_Space: 1365
              Until_Condition: None
               Until_Log_File:
                Until_Log_Pos: 0
           Master_SSL_Allowed: No
           Master_SSL_CA_File:
           Master_SSL_CA_Path:
              Master_SSL_Cert:
            Master_SSL_Cipher:
               Master_SSL_Key:
        Seconds_Behind_Master: 0
Master_SSL_Verify_Server_Cert: No
                Last_IO_Errno: 0
                Last_IO_Error:
               Last_SQL_Errno: 0
               Last_SQL_Error:
  Replicate_Ignore_Server_Ids: 0
</pre><p>
                The key fields from the status report to examine are:
            </p><p style="color:blue;">要检查的状态报告中的关键字段包括：</p>
                <div class="itemizedlist">
                    <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                        <code class="literal">Slave_IO_State</code>: The current status of the
                        slave. See <a class="xref" href="optimization.html#slave-io-thread-states" title="8.14.5&nbsp;Replication Slave I/O Thread States">Section&nbsp;8.14.5, “Replication Slave I/O Thread States”</a>, and
                        <a class="xref" href="optimization.html#slave-sql-thread-states" title="8.14.6&nbsp;Replication Slave SQL Thread States">Section&nbsp;8.14.6, “Replication Slave SQL Thread States”</a>, for more
                        information.
                    </p><p style="color:blue;">从机状态：从机的当前状态。有关详细信息，请参阅第8.14.5节“复制从属I/O线程状态”和第8.14.6节“复制从属SQL线程状态”。</p></li><li class="listitem"><p>
                        <code class="literal">Slave_IO_Running</code>: Whether the I/O thread
                        for reading the master's binary log is running. Normally,
                        you want this to be <code class="literal">Yes</code> unless you have
                        not yet started replication or have explicitly stopped it
                        with <a class="link" href="sql-syntax.html#stop-slave" title="13.4.2.7&nbsp;STOP SLAVE Syntax"><code class="literal">STOP SLAVE</code></a>.
                    </p><p style="color:blue;">从IO运行：用于读取主二进制日志的I/O线程是否正在运行。通常，除非尚未启动复制或已使用stop slave显式停止复制，否则您希望此值为yes。</p></li><li class="listitem"><p>
                        <code class="literal">Slave_SQL_Running</code>: Whether the SQL thread
                        for executing events in the relay log is running. As with
                        the I/O thread, this should normally be
                        <code class="literal">Yes</code>.
                    </p><p style="color:blue;">slave_sql_running：中继日志中用于执行事件的sql线程是否正在运行。与I/O线程一样，这通常应该是yes。</p></li><li class="listitem"><p>
                        <code class="literal">Last_IO_Error</code>,
                        <code class="literal">Last_SQL_Error</code>: The last errors
                        registered by the I/O and SQL threads when processing the
                        relay log. Ideally these should be blank, indicating no
                        errors.
                    </p><p style="color:blue;">last_i o_error，last_sql_error：处理中继日志时I/O和SQL线程注册的最后一个错误。理想情况下，这些应该是空白的，表示没有错误。</p></li><li class="listitem"><p>
                        <code class="literal">Seconds_Behind_Master</code>: The number of
                        seconds that the slave SQL thread is behind processing the
                        master binary log. A high number (or an increasing one) can
                        indicate that the slave is unable to handle events from the
                        master in a timely fashion.
                    </p><p style="color:blue;">seconds_behind_master：从SQL线程处理主二进制日志的秒数。较高的数字（或增加的数字）可能表示从机无法及时处理来自主机的事件。</p><p>
                        A value of 0 for <code class="literal">Seconds_Behind_Master</code>
                        can usually be interpreted as meaning that the slave has
                        caught up with the master, but there are some cases where
                        this is not strictly true. For example, this can occur if
                        the network connection between master and slave is broken
                        but the slave I/O thread has not yet noticed this—that
                        is, <a class="link" href="replication.html#sysvar_slave_net_timeout"><code class="literal">slave_net_timeout</code></a> has
                        not yet elapsed.
                    </p><p style="color:blue;">在主机后面秒数为0的值通常可以解释为从机已赶上主机，但在某些情况下，这并不严格。例如，如果主机和从机之间的网络连接断开，但从机I/O线程尚未注意到这一点，即从机网络超时尚未过去，则会发生这种情况。</p><p>
                        It is also possible that transient values for
                        <code class="literal">Seconds_Behind_Master</code> may not reflect the
                        situation accurately. When the slave SQL thread has caught
                        up on I/O, <code class="literal">Seconds_Behind_Master</code> displays
                        0; but when the slave I/O thread is still queuing up a new
                        event, <code class="literal">Seconds_Behind_Master</code> may show a
                        large value until the SQL thread finishes executing the new
                        event. This is especially likely when the events have old
                        timestamps; in such cases, if you execute
                        <a class="link" href="sql-syntax.html#show-slave-status" title="13.7.5.34&nbsp;SHOW SLAVE STATUS Syntax"><code class="literal">SHOW SLAVE STATUS</code></a> several
                        times in a relatively short period, you may see this value
                        change back and forth repeatedly between 0 and a relatively
                        large value.
                    </p><p style="color:blue;">也有可能秒数的瞬变值不能准确反映情况。当从属SQL线程赶上I/O时，seconds_behind_master显示0；但是当从属I/O线程仍在排队等待新事件时，seconds_behind_master可能会显示一个大值，直到SQL线程完成执行新事件。这在事件具有旧时间戳时尤其可能；在这种情况下，如果在相对较短的时间内多次执行show slave status，则可能会看到该值在0和相对较大的值之间反复变化。</p></li></ul>
                </div>
                <p>
                    Several pairs of fields provide information about the progress
                    of the slave in reading events from the master binary log and
                    processing them in the relay log:
                </p><p style="color:blue;">几个字段对提供了从机从主二进制日志读取事件并在中继日志中处理这些事件的进度信息：</p>
                <div class="itemizedlist">
                    <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                        (<code class="literal">Master_Log_file</code>,
                        <code class="literal">Read_Master_Log_Pos</code>): Coordinates in the
                        master binary log indicating how far the slave I/O thread
                        has read events from that log.
                    </p><p style="color:blue;">（master_log_file，read_master_log_pos）：主二进制日志中的坐标，指示从I/O线程从该日志读取事件的距离。</p></li><li class="listitem"><p>
                        (<code class="literal">Relay_Master_Log_File</code>,
                        <code class="literal">Exec_Master_Log_Pos</code>): Coordinates in the
                        master binary log indicating how far the slave SQL thread
                        has executed events received from that log.
                    </p><p style="color:blue;">（relay_master_log_file，exec_master_log_pos）：主二进制日志中的坐标，指示从SQL线程执行从该日志接收到的事件的距离。</p></li><li class="listitem"><p>
                        (<code class="literal">Relay_Log_File</code>,
                        <code class="literal">Relay_Log_Pos</code>): Coordinates in the slave
                        relay log indicating how far the slave SQL thread has
                        executed the relay log. These correspond to the preceding
                        coordinates, but are expressed in slave relay log
                        coordinates rather than master binary log coordinates.
                    </p><p style="color:blue;">（relay_log_file，relay_log_pos）：从属中继日志中的坐标，指示从属SQL线程执行中继日志的距离。它们对应于前面的坐标，但用从中继日志坐标而不是主二进制日志坐标表示。</p></li></ul>
                </div>
                <p>
                    On the master, you can check the status of connected slaves
                    using <a class="link" href="sql-syntax.html#show-processlist" title="13.7.5.29&nbsp;SHOW PROCESSLIST Syntax"><code class="literal">SHOW PROCESSLIST</code></a> to examine
                    the list of running processes. Slave connections have
                    <code class="literal">Binlog Dump</code> in the <code class="literal">Command</code>
                    field:
                </p><p style="color:blue;">在主节点上，可以使用show processlist检查正在运行的进程列表，检查已连接从节点的状态。从连接在命令字段中有binlog转储：</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>SHOW PROCESSLIST \G;</code></strong>
*************************** 4. row ***************************
     Id: 10
   User: root
   Host: slave1:58371
     db: NULL
Command: Binlog Dump
   Time: 777
  State: Has sent all binlog to slave; waiting for binlog to be updated
   Info: NULL
</pre><p>
                Because it is the slave that drives the replication process,
                very little information is available in this report.
            </p><p style="color:blue;">因为驱动复制过程的是从机，所以本报告中几乎没有可用的信息。</p><p>
                For slaves that were started with the
                <a class="link" href="replication.html#sysvar_report_host"><code class="option">--report-host</code></a> option and are
                connected to the master, the <a class="link" href="sql-syntax.html#show-slave-hosts" title="13.7.5.33&nbsp;SHOW SLAVE HOSTS Syntax"><code class="literal">SHOW SLAVE
                HOSTS</code></a> statement on the master shows basic information
                about the slaves. The output includes the ID of the slave
                server, the value of the
                <a class="link" href="replication.html#sysvar_report_host"><code class="option">--report-host</code></a> option, the
                connecting port, and master ID:
            </p><p style="color:blue;">对于使用--report host选项启动并连接到主服务器的从属服务器，主服务器上的show slave hosts语句显示有关从属服务器的基本信息。输出包括从属服务器的ID、--report host选项的值、连接端口和主ID：</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>SHOW SLAVE HOSTS;</code></strong>
+-----------+--------+------+-------------------+-----------+
| Server_id | Host   | Port | Rpl_recovery_rank | Master_id |
+-----------+--------+------+-------------------+-----------+
|        10 | slave1 | 3306 |                 0 |         1 |
+-----------+--------+------+-------------------+-----------+
1 row in set (0.00 sec)
</pre>
            </div>
            <div class="section">
                <div class="titlepage">
                    <div>
                        <div>
                            <h4 class="title"><a name="replication-administration-pausing"></a>16.1.7.2&nbsp;Pausing Replication on the Slave</h4>

                        </div>

                    </div>

                </div>
                <p>
                    You can stop and start replication on the slave using the
                    <a class="link" href="sql-syntax.html#stop-slave" title="13.4.2.7&nbsp;STOP SLAVE Syntax"><code class="literal">STOP SLAVE</code></a> and
                    <a class="link" href="sql-syntax.html#start-slave" title="13.4.2.6&nbsp;START SLAVE Syntax"><code class="literal">START SLAVE</code></a> statements.
                </p><p style="color:blue;">您可以使用stop slave和start slave语句在从机上停止和启动复制。</p><p>
                To stop processing of the binary log from the master, use
                <a class="link" href="sql-syntax.html#stop-slave" title="13.4.2.7&nbsp;STOP SLAVE Syntax"><code class="literal">STOP SLAVE</code></a>:
            </p><p style="color:blue;">要停止从主机处理二进制日志，请使用stop slave：</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>STOP SLAVE;</code></strong>
</pre><p>
                When replication is stopped, the slave I/O thread stops reading
                events from the master binary log and writing them to the relay
                log, and the SQL thread stops reading events from the relay log
                and executing them. You can pause the I/O or SQL thread
                individually by specifying the thread type:
            </p><p style="color:blue;">当复制停止时，从I/O线程停止从主二进制日志读取事件并将其写入中继日志，而SQL线程停止从中继日志读取事件并执行它们。通过指定线程类型，可以分别暂停I/O或SQL线程：</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>STOP SLAVE IO_THREAD;</code></strong>
mysql&gt; <strong class="userinput"><code>STOP SLAVE SQL_THREAD;</code></strong>
</pre><p>
                To start execution again, use the <a class="link" href="sql-syntax.html#start-slave" title="13.4.2.6&nbsp;START SLAVE Syntax"><code class="literal">START
                SLAVE</code></a> statement:
            </p><p style="color:blue;">要再次开始执行，请使用start slave语句：</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>START SLAVE;</code></strong>
</pre><p>
                To start a particular thread, specify the thread type:
            </p><p style="color:blue;">要启动特定线程，请指定线程类型：</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>START SLAVE IO_THREAD;</code></strong>
mysql&gt; <strong class="userinput"><code>START SLAVE SQL_THREAD;</code></strong>
</pre><p>
                For a slave that performs updates only by processing events from
                the master, stopping only the SQL thread can be useful if you
                want to perform a backup or other task. The I/O thread will
                continue to read events from the master but they are not
                executed. This makes it easier for the slave to catch up when
                you restart the SQL thread.
            </p><p style="color:blue;">对于仅通过处理来自主服务器的事件来执行更新的从服务器，如果要执行备份或其他任务，则仅停止SQL线程可能很有用。I/O线程将继续从主机读取事件，但它们不会被执行。这使得在重新启动sql线程时，从线程更容易赶上。</p><p>
                Stopping only the I/O thread enables the events in the relay log
                to be executed by the SQL thread up to the point where the relay
                log ends. This can be useful when you want to pause execution to
                catch up with events already received from the master, when you
                want to perform administration on the slave but also ensure that
                it has processed all updates to a specific point. This method
                can also be used to pause event receipt on the slave while you
                conduct administration on the master. Stopping the I/O thread
                but permitting the SQL thread to run helps ensure that there is
                not a massive backlog of events to be executed when replication
                is started again.
            </p><p style="color:blue;">只有停止I/O线程，SQL线程才能执行中继日志中的事件，直到中继日志结束为止。当您希望暂停执行以赶上已从主服务器接收到的事件时，当您希望对从服务器执行管理时，这将非常有用，同时还可以确保它已处理到特定点的所有更新。此方法还可用于在对主服务器进行管理时暂停从服务器上的事件接收。停止I/O线程但允许SQL线程运行有助于确保在重新启动复制时不会有大量待执行的事件积压。</p>
            </div>

        </div>

    </div>
    <div class="section">
        <div class="titlepage">
            <div>
                <div>
                    <h2 class="title" style="clear: both"><a name="replication-implementation"></a>16.2&nbsp;Replication Implementation</h2>

                </div>

            </div>

        </div>
        <div class="toc">
            <dl class="toc"><dt><span class="section"><a href="replication.html#replication-formats">16.2.1 Replication Formats</a></span></dt><dt><span class="section"><a href="replication.html#replication-implementation-details">16.2.2 Replication Implementation Details</a></span></dt><dt><span class="section"><a href="replication.html#replication-channels">16.2.3 Replication Channels</a></span></dt><dt><span class="section"><a href="replication.html#slave-logs">16.2.4 Replication Relay and Status Logs</a></span></dt><dt><span class="section"><a href="replication.html#replication-rules">16.2.5 How Servers Evaluate Replication Filtering Rules</a></span></dt></dl>
        </div>
        <a class="indexterm" name="idm140286794468240"></a><p>
        Replication is based on the master server keeping track of all
        changes to its databases (updates, deletes, and so on) in its binary
        log. The binary log serves as a written record of all events that
        modify database structure or content (data) from the moment the
        server was started. Typically, <a class="link" href="sql-syntax.html#select" title="13.2.9&nbsp;SELECT Syntax"><code class="literal">SELECT</code></a>
        statements are not recorded because they modify neither database
        structure nor content.
    </p><p style="color:blue;">复制是基于主服务器在其二进制日志中跟踪对其数据库的所有更改（更新、删除等）。二进制日志用作服务器启动时修改数据库结构或内容（数据）的所有事件的书面记录。通常，不会记录select语句，因为它们既不修改数据库结构，也不修改内容。</p><p>
        Each slave that connects to the master requests a copy of the binary
        log. That is, it pulls the data from the master, rather than the
        master pushing the data to the slave. The slave also executes the
        events from the binary log that it receives. This has the effect of
        repeating the original changes just as they were made on the master.
        Tables are created or their structure modified, and data is
        inserted, deleted, and updated according to the changes that were
        originally made on the master.
    </p><p style="color:blue;">连接到主服务器的每个从服务器都请求二进制日志的副本。也就是说，它从主设备中提取数据，而不是主设备将数据推送到从设备。从服务器还执行它从二进制日志接收到的事件。这会产生重复原始更改的效果，就像对主控形状所做的更改一样。创建表或修改表的结构，并根据最初在主控形状上所做的更改插入、删除和更新数据。</p><p>
        Because each slave is independent, the replaying of the changes from
        the master's binary log occurs independently on each slave that is
        connected to the master. In addition, because each slave receives a
        copy of the binary log only by requesting it from the master, the
        slave is able to read and update the copy of the database at its own
        pace and can start and stop the replication process at will without
        affecting the ability to update to the latest database status on
        either the master or slave side.
    </p><p style="color:blue;">因为每个从机都是独立的，所以从主机二进制日志中进行的更改的重放在连接到主机的每个从机上都是独立的。此外，由于每个从机只能通过向主机请求来接收二进制日志的副本，因此从机能够以自己的速度读取和更新数据库副本，并且可以随意启动和停止复制过程，而不影响在主机或从机端更新到最新数据库状态的能力。</p><p>
        For more information on the specifics of the replication
        implementation, see
        <a class="xref" href="replication.html#replication-implementation-details" title="16.2.2&nbsp;Replication Implementation Details">Section&nbsp;16.2.2, “Replication Implementation Details”</a>.
    </p><p style="color:blue;">有关复制实现的详细信息，请参阅第16.2.2节“复制实现详细信息”。</p><p>
        Masters and slaves report their status in respect of the replication
        process regularly so that you can monitor them. See
        <a class="xref" href="optimization.html#thread-information" title="8.14&nbsp;Examining Thread Information">Section&nbsp;8.14, “Examining Thread Information”</a>, for descriptions of all
        replicated-related states.
    </p><p style="color:blue;">主服务器和从服务器定期报告它们在复制过程中的状态，以便您可以监视它们。有关所有复制的相关状态的描述，请参见第8.14节“检查线程信息”。</p><p>
        The master binary log is written to a local relay log on the slave
        before it is processed. The slave also records information about the
        current position with the master's binary log and the local relay
        log. See <a class="xref" href="replication.html#slave-logs" title="16.2.4&nbsp;Replication Relay and Status Logs">Section&nbsp;16.2.4, “Replication Relay and Status Logs”</a>.
    </p><p style="color:blue;">主二进制日志在被处理之前被写入从机上的本地中继日志。从机还用主机的二进制日志和本地中继日志记录有关当前位置的信息。见第16.2.4节“复制中继和状态日志”。</p><p>
        Database changes are filtered on the slave according to a set of
        rules that are applied according to the various configuration
        options and variables that control event evaluation. For details on
        how these rules are applied, see
        <a class="xref" href="replication.html#replication-rules" title="16.2.5&nbsp;How Servers Evaluate Replication Filtering Rules">Section&nbsp;16.2.5, “How Servers Evaluate Replication Filtering Rules”</a>.
    </p><p style="color:blue;">根据根据控制事件计算的各种配置选项和变量应用的一组规则，数据库更改将在从属服务器上进行筛选。有关如何应用这些规则的详细信息，请参阅第16.2.5节“服务器如何评估复制筛选规则”。</p>
        <div class="section">

            <div class="titlepage">
                <div>
                    <div>
                        <h3 class="title"><a name="replication-formats"></a>16.2.1&nbsp;Replication Formats</h3>
                    </div>
                </div>
            </div>

            <div class="toc">
                <dl class="toc"><dt><span class="section"><a href="replication.html#replication-sbr-rbr">16.2.1.1 Advantages and Disadvantages of Statement-Based and Row-Based
Replication</a></span></dt><dt><span class="section"><a href="replication.html#replication-rbr-usage">16.2.1.2 Usage of Row-Based Logging and Replication</a></span></dt><dt><span class="section"><a href="replication.html#replication-rbr-safe-unsafe">16.2.1.3 Determination of Safe and Unsafe Statements in Binary Logging</a></span></dt></dl>
            </div>
            <p>
                Replication works because events written to the binary log are
                read from the master and then processed on the slave. The events
                are recorded within the binary log in different formats according
                to the type of event. The different replication formats used
                correspond to the binary logging format used when the events were
                recorded in the master's binary log. The correlation between
                binary logging formats and the terms used during replication are:
            </p><p style="color:blue;">复制工作是因为写入二进制日志的事件是从主服务器读取的，然后在从服务器上进行处理。事件根据事件类型以不同的格式记录在二进制日志中。使用的不同复制格式对应于将事件记录到主机的二进制日志中时使用的二进制日志记录格式。二进制日志记录格式与复制期间使用的术语之间的相关性为：</p>
            <div class="itemizedlist">
                <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                    When using statement-based binary logging, the master writes
                    SQL statements to the binary log. Replication of the master to
                    the slave works by executing the SQL statements on the slave.
                    This is called <span class="firstterm">statement-based
          replication</span> (which can be abbreviated as
                    <span class="firstterm">SBR</span>), which corresponds
                    to the MySQL statement-based binary logging format.
                </p><p style="color:blue;">使用基于语句的二进制日志记录时，主服务器将SQL语句写入二进制日志。将主服务器复制到从服务器的工作方式是在从服务器上执行sql语句。这称为基于语句的复制（可以缩写为sbr），它对应于基于mysql语句的二进制日志格式。</p></li><li class="listitem"><p>
                    When using row-based logging, the master writes
                    <span class="firstterm">events</span> to the binary log
                    that indicate how individual table rows are changed.
                    Replication of the master to the slave works by copying the
                    events representing the changes to the table rows to the
                    slave. This is called <span class="firstterm">row-based
          replication</span> (which can be abbreviated as
                    <span class="firstterm">RBR</span>).
                </p><p style="color:blue;">使用基于行的日志记录时，主控将事件写入二进制日志，指示如何更改单个表行。将表示对表行的更改的事件复制到从机，可以将主机复制到从机。这称为基于行的复制（可以缩写为rbr）。</p></li><li class="listitem"><p>
                    You can also configure MySQL to use a mix of both
                    statement-based and row-based logging, depending on which is
                    most appropriate for the change to be logged. This is called
                    <span class="firstterm">mixed-format logging</span>.
                    When using mixed-format logging, a statement-based log is used
                    by default. Depending on certain statements, and also the
                    storage engine being used, the log is automatically switched
                    to row-based in particular cases. Replication using the mixed
                    format is referred to as
                    <span class="firstterm">mixed-based replication</span>
                    or <span class="firstterm">mixed-format
          replication</span>. For more information, see
                    <a class="xref" href="server-administration.html#binary-log-mixed" title="5.4.4.3&nbsp;Mixed Binary Logging Format">Section&nbsp;5.4.4.3, “Mixed Binary Logging Format”</a>.
                </p><p style="color:blue;">您还可以将mysql配置为同时使用基于语句和基于行的日志记录，这取决于哪个最适合记录更改。这称为混合格式日志记录。使用混合格式日志记录时，默认情况下使用基于语句的日志。根据某些语句以及正在使用的存储引擎，日志在特定情况下会自动切换到基于行的日志。使用混合格式的复制称为基于混合格式的复制或混合格式的复制。有关更多信息，请参阅第5.4.4.3节“混合二进制日志格式”。</p></li></ul>
            </div>
            <p>
                Prior to MySQL 5.7.7, statement-based format was the default. In
                MySQL 5.7.7 and later, row-based format is the default.
            </p><p style="color:blue;">在mysql 5.7.7之前，基于语句的格式是默认的。在mysql 5.7.7及更高版本中，基于行的格式是默认的。</p><p><b>NDB Cluster.&nbsp;</b>
            The default binary logging format in MySQL NDB Cluster 7.5 is
            <code class="literal">MIXED</code>. You should note that NDB Cluster
            Replication always uses row-based replication, and that the
            <a class="link" href="mysql-cluster.html" title="Chapter&nbsp;21&nbsp;MySQL NDB Cluster 7.5 and NDB Cluster 7.6"><code class="literal">NDB</code></a> storage engine is incompatible
            with statement-based replication. See
            <a class="xref" href="mysql-cluster.html#mysql-cluster-replication-general" title="21.6.2&nbsp;General Requirements for NDB Cluster Replication">Section&nbsp;21.6.2, “General Requirements for NDB Cluster Replication”</a>, for more
            information.
        </p><p style="color:blue;">ndb集群。mysql ndb cluster 7.5中的默认二进制日志记录格式是mixed。您应该注意，ndb集群复制始终使用基于行的复制，并且ndb存储引擎与基于语句的复制不兼容。有关详细信息，请参阅21.6.2节，“ndb群集复制的一般要求”。</p><p>
            When using <code class="literal">MIXED</code> format, the binary logging
            format is determined in part by the storage engine being used and
            the statement being executed. For more information on mixed-format
            logging and the rules governing the support of different logging
            formats, see <a class="xref" href="server-administration.html#binary-log-mixed" title="5.4.4.3&nbsp;Mixed Binary Logging Format">Section&nbsp;5.4.4.3, “Mixed Binary Logging Format”</a>.
        </p><p style="color:blue;">使用混合格式时，二进制日志记录格式部分由正在使用的存储引擎和正在执行的语句决定。有关混合格式日志记录和不同日志记录格式支持规则的更多信息，请参阅第5.4.4.3节“混合二进制日志记录格式”。</p><p>
            The logging format in a running MySQL server is controlled by
            setting the <a class="link" href="replication.html#sysvar_binlog_format"><code class="literal">binlog_format</code></a> server
            system variable. This variable can be set with session or global
            scope. The rules governing when and how the new setting takes
            effect are the same as for other MySQL server system variables.
            Setting the variable for the current session lasts only until the
            end of that session, and the change is not visible to other
            sessions. Setting the variable globally takes effect for clients
            that connect after the change, but not for any current client
            sessions, including the session where the variable setting was
            changed. To make the global system variable setting permanent so
            that it applies across server restarts, you must set it in an
            option file. For more information, see
            <a class="xref" href="sql-syntax.html#set-variable" title="13.7.4.1&nbsp;SET Syntax for Variable Assignment">Section&nbsp;13.7.4.1, “SET Syntax for Variable Assignment”</a>.
        </p><p style="color:blue;">运行中的mysql服务器中的日志格式由设置binlog_format server系统变量控制。可以使用会话或全局范围设置此变量。控制新设置生效的时间和方式的规则与其他mysql服务器系统变量相同。为当前会话设置变量仅持续到该会话结束，其他会话看不到更改。全局设置变量对更改后连接的客户端生效，但对任何当前客户端会话（包括更改变量设置的会话）无效。要使全局系统变量设置永久，以便在服务器重新启动时应用，必须在选项文件中进行设置。有关详细信息，请参阅第13.7.4.1节“设置变量赋值语法”。</p><p>
            There are conditions under which you cannot change the binary
            logging format at runtime or doing so causes replication to fail.
            See <a class="xref" href="server-administration.html#binary-log-setting" title="5.4.4.2&nbsp;Setting The Binary Log Format">Section&nbsp;5.4.4.2, “Setting The Binary Log Format”</a>.
        </p><p style="color:blue;">在某些情况下，您不能在运行时更改二进制日志记录格式，否则会导致复制失败。见第5.4.4.2节“设置二进制日志格式”。</p><p>
            Changing the global <a class="link" href="replication.html#sysvar_binlog_format"><code class="literal">binlog_format</code></a>
            value requires privileges sufficient to set global system
            variables. Changing the session
            <a class="link" href="replication.html#sysvar_binlog_format"><code class="literal">binlog_format</code></a> value requires
            privileges sufficient to set restricted session system variables.
            See <a class="xref" href="server-administration.html#system-variable-privileges" title="5.1.8.1&nbsp;System Variable Privileges">Section&nbsp;5.1.8.1, “System Variable Privileges”</a>.
        </p><p style="color:blue;">更改全局binlog_格式值需要足够的权限来设置全局系统变量。更改会话binlog_格式值需要足够的权限来设置受限制的会话系统变量。见第5.1.8.1节“系统变量特权”。</p><p>
            The statement-based and row-based replication formats have
            different issues and limitations. For a comparison of their
            relative advantages and disadvantages, see
            <a class="xref" href="replication.html#replication-sbr-rbr" title="16.2.1.1&nbsp;Advantages and Disadvantages of Statement-Based and Row-Based Replication">Section&nbsp;16.2.1.1, “Advantages and Disadvantages of Statement-Based and Row-Based
                Replication”</a>.
        </p><p style="color:blue;">基于语句和基于行的复制格式有不同的问题和限制。有关它们的相对优缺点的比较，请参见第16.2.1.1节“基于语句和基于行的复制的优缺点”。</p><p>
            With statement-based replication, you may encounter issues with
            replicating stored routines or triggers. You can avoid these
            issues by using row-based replication instead. For more
            information, see <a class="xref" href="stored-objects.html#stored-programs-logging" title="23.7&nbsp;Stored Program Binary Logging">Section&nbsp;23.7, “Stored Program Binary Logging”</a>.
        </p><p style="color:blue;">对于基于语句的复制，您可能会遇到复制存储例程或触发器的问题。您可以使用基于行的复制来避免这些问题。有关更多信息，请参阅第23.7节“存储程序二进制日志记录”。</p>
            <div class="section">

                <div class="titlepage">
                    <div>
                        <div>
                            <h4 class="title"><a name="replication-sbr-rbr"></a>16.2.1.1&nbsp;Advantages and Disadvantages of Statement-Based and Row-Based
                                Replication</h4>
                        </div>
                    </div>
                </div>
                <a class="indexterm" name="idm140286794426848"></a><a class="indexterm" name="idm140286794425392"></a><p>
                Each binary logging format has advantages and disadvantages. For
                most users, the mixed replication format should provide the best
                combination of data integrity and performance. If, however, you
                want to take advantage of the features specific to the
                statement-based or row-based replication format when performing
                certain tasks, you can use the information in this section,
                which provides a summary of their relative advantages and
                disadvantages, to determine which is best for your needs.
            </p><p style="color:blue;">每种二进制日志格式各有利弊。对于大多数用户来说，混合复制格式应该提供数据完整性和性能的最佳组合。但是，如果要在执行某些任务时利用特定于基于语句或基于行的复制格式的功能，则可以使用本节中的信息来确定哪个最适合您的需要，这些信息提供了它们相对优缺点的摘要。</p>
                <div class="itemizedlist">
                    <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                        <a class="link" href="replication.html#replication-sbr-rbr-sbr-advantages" title="Advantages of statement-based replication">Advantages
                            of statement-based replication</a>
                    </p><p style="color:blue;">基于语句的复制的优势</p></li><li class="listitem"><p>
                        <a class="link" href="replication.html#replication-sbr-rbr-sbr-disadvantages" title="Disadvantages of statement-based replication">Disadvantages
                            of statement-based replication</a>
                    </p><p style="color:blue;">基于语句的复制的缺点</p></li><li class="listitem"><p>
                        <a class="link" href="replication.html#replication-sbr-rbr-rbr-advantages" title="Advantages of row-based replication">Advantages
                            of row-based replication</a>
                    </p><p style="color:blue;">基于行的复制的优势</p></li><li class="listitem"><p>
                        <a class="link" href="replication.html#replication-sbr-rbr-rbr-disadvantages" title="Disadvantages of row-based replication">Disadvantages
                            of row-based replication</a>
                    </p><p style="color:blue;">基于行的复制的缺点</p></li></ul>
                </div>
                <h5><a name="replication-sbr-rbr-sbr-advantages"></a>Advantages of statement-based replication</h5>
                <a class="indexterm" name="idm140286794414144"></a>
                <div class="itemizedlist">
                    <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                        Proven technology.
                    </p><p style="color:blue;">成熟的技术。</p></li><li class="listitem"><p>
                        Less data written to log files. When updates or deletes
                        affect many rows, this results in <span class="emphasis"><em>much</em></span>
                        less storage space required for log files. This also means
                        that taking and restoring from backups can be accomplished
                        more quickly.
                    </p><p style="color:blue;">写入日志文件的数据更少。当更新或删除影响许多行时，这将导致日志文件所需的存储空间大大减少。这也意味着从备份中获取和恢复可以更快地完成。</p></li><li class="listitem"><p>
                        Log files contain all statements that made any changes, so
                        they can be used to audit the database.
                    </p><p style="color:blue;">日志文件包含进行任何更改的所有语句，因此可以使用它们来审核数据库。</p></li></ul>
                </div>
                <h5><a name="replication-sbr-rbr-sbr-disadvantages"></a>Disadvantages of statement-based replication</h5>
                <a class="indexterm" name="idm140286794407792"></a>
                <div class="itemizedlist">
                    <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><b>Statements that are unsafe for SBR.&nbsp;</b><a class="indexterm" name="idm140286794405136"></a><a class="indexterm" name="idm140286794403616"></a>
                        Not all statements which modify data (such as
                        <a class="link" href="sql-syntax.html#insert" title="13.2.5&nbsp;INSERT Syntax"><code class="literal">INSERT</code></a>
                        <a class="link" href="sql-syntax.html#delete" title="13.2.2&nbsp;DELETE Syntax"><code class="literal">DELETE</code></a>,
                        <a class="link" href="sql-syntax.html#update" title="13.2.11&nbsp;UPDATE Syntax"><code class="literal">UPDATE</code></a>, and
                        <a class="link" href="sql-syntax.html#replace" title="13.2.8&nbsp;REPLACE Syntax"><code class="literal">REPLACE</code></a> statements) can be
                        replicated using statement-based replication. Any
                        nondeterministic behavior is difficult to replicate when
                        using statement-based replication. Examples of such Data
                        Modification Language (DML) statements include the
                        following:
                    </p><p style="color:blue;">对sbr不安全的语句。并非所有修改数据的语句（如insert delete、update和replace语句）都可以使用基于语句的复制进行复制。使用基于语句的复制时，很难复制任何不确定的行为。此类数据修改语言（DML）语句的示例包括：</p>
                        <div class="itemizedlist">
                            <ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
                                A statement that depends on a UDF or stored program that
                                is nondeterministic, since the value returned by such a
                                UDF or stored program or depends on factors other than
                                the parameters supplied to it. (Row-based replication,
                                however, simply replicates the value returned by the UDF
                                or stored program, so its effect on table rows and data
                                is the same on both the master and slave.) See
                                <a class="xref" href="replication.html#replication-features-invoked" title="16.4.1.16&nbsp;Replication of Invoked Features">Section&nbsp;16.4.1.16, “Replication of Invoked Features”</a>, for more
                                information.
                            </p><p style="color:blue;">一种依赖于不确定的自定义项或存储程序的语句，因为这种自定义项或存储程序返回的值或依赖于提供给它的参数以外的因子。（但是，基于行的复制只是复制UDF或存储程序返回的值，因此它对表行和数据的影响在主程序和从程序上都是相同的。）有关详细信息，请参阅第16.4.1.16节“被调用功能的复制”。</p></li><li class="listitem"><p>
                                <a class="link" href="sql-syntax.html#delete" title="13.2.2&nbsp;DELETE Syntax"><code class="literal">DELETE</code></a> and
                                <a class="link" href="sql-syntax.html#update" title="13.2.11&nbsp;UPDATE Syntax"><code class="literal">UPDATE</code></a> statements that
                                use a <code class="literal">LIMIT</code> clause without an
                                <code class="literal">ORDER BY</code> are nondeterministic. See
                                <a class="xref" href="replication.html#replication-features-limit" title="16.4.1.17&nbsp;Replication and LIMIT">Section&nbsp;16.4.1.17, “Replication and LIMIT”</a>.
                            </p><p style="color:blue;">使用LIMIT子句而不使用ORDER BY的DELETE和UPDATE语句是不确定的。见第16.4.1.17节“复制和限制”。</p></li><li class="listitem"><p>
                                Deterministic UDFs must be applied on the slaves.
                            </p><p style="color:blue;">必须对从机应用确定性UDF。</p></li><li class="listitem"><p>
                                Statements using any of the following functions cannot
                                be replicated properly using statement-based
                                replication:
                            </p><p style="color:blue;">无法使用基于语句的复制正确复制使用以下任何函数的语句：</p>
                                <div class="itemizedlist">
                                    <ul class="itemizedlist" style="list-style-type: square; "><li class="listitem"><p>
                                        <a class="link" href="functions.html#function_load-file"><code class="literal">LOAD_FILE()</code></a>
                                    </p><p style="color:blue;">加载文件（）</p></li><li class="listitem"><p>
                                        <a class="link" href="functions.html#function_uuid"><code class="literal">UUID()</code></a>,
                                        <a class="link" href="functions.html#function_uuid-short"><code class="literal">UUID_SHORT()</code></a>
                                    </p><p style="color:blue;">uuid（），uuid_short（）</p></li><li class="listitem"><p>
                                        <a class="link" href="functions.html#function_user"><code class="literal">USER()</code></a>
                                    </p><p style="color:blue;">用户（）</p></li><li class="listitem"><p>
                                        <a class="link" href="functions.html#function_found-rows"><code class="literal">FOUND_ROWS()</code></a>
                                    </p><p style="color:blue;">找到行（）</p></li><li class="listitem"><p>
                                        <a class="link" href="functions.html#function_sysdate"><code class="literal">SYSDATE()</code></a> (unless
                                        both the master and the slave are started with the
                                        <a class="link" href="server-administration.html#option_mysqld_sysdate-is-now"><code class="option">--sysdate-is-now</code></a>
                                        option)
                                    </p><p style="color:blue;">sysdate（）（除非主设备和从设备都是用--sysdate is now选项启动的）</p></li><li class="listitem"><p>
                                        <a class="link" href="functions.html#function_get-lock"><code class="literal">GET_LOCK()</code></a>
                                    </p><p style="color:blue;">获取锁（）</p></li><li class="listitem"><p>
                                        <a class="link" href="functions.html#function_is-free-lock"><code class="literal">IS_FREE_LOCK()</code></a>
                                    </p><p style="color:blue;">是否有锁（）</p></li><li class="listitem"><p>
                                        <a class="link" href="functions.html#function_is-used-lock"><code class="literal">IS_USED_LOCK()</code></a>
                                    </p><p style="color:blue;">是否使用了锁（）</p></li><li class="listitem"><p>
                                        <a class="link" href="functions.html#function_master-pos-wait"><code class="literal">MASTER_POS_WAIT()</code></a>
                                    </p><p style="color:blue;">主人等待（）</p></li><li class="listitem"><p>
                                        <a class="link" href="functions.html#function_rand"><code class="literal">RAND()</code></a>
                                    </p><p style="color:blue;">兰德（）</p></li><li class="listitem"><p>
                                        <a class="link" href="functions.html#function_release-lock"><code class="literal">RELEASE_LOCK()</code></a>
                                    </p><p style="color:blue;">解除锁定（）</p></li><li class="listitem"><p>
                                        <a class="link" href="functions.html#function_sleep"><code class="literal">SLEEP()</code></a>
                                    </p><p style="color:blue;">睡眠（）</p></li><li class="listitem"><p>
                                        <a class="link" href="functions.html#function_version"><code class="literal">VERSION()</code></a>
                                    </p><p style="color:blue;">版本（）</p></li></ul>
                                </div>
                                <p>
                                    However, all other functions are replicated correctly
                                    using statement-based replication, including
                                    <a class="link" href="functions.html#function_now"><code class="literal">NOW()</code></a> and so forth.
                                </p><p style="color:blue;">但是，使用基于语句的复制可以正确复制所有其他函数，包括now（）等。</p><p>
                                    For more information, see
                                    <a class="xref" href="replication.html#replication-features-functions" title="16.4.1.15&nbsp;Replication and System Functions">Section&nbsp;16.4.1.15, “Replication and System Functions”</a>.
                                </p><p style="color:blue;">有关更多信息，请参阅第16.4.1.15节“复制和系统功能”。</p></li></ul>
                        </div>
                        <p>
                            Statements that cannot be replicated correctly using
                            statement-based replication are logged with a warning like
                            the one shown here:
                        </p><p style="color:blue;">使用基于语句的复制无法正确复制的语句将记录一条警告，如下所示：</p><pre data-lang="none" class="programlisting">[Warning] Statement is not safe to log in statement format.
</pre><p>
                            A similar warning is also issued to the client in such
                            cases. The client can display it using
                            <a class="link" href="sql-syntax.html#show-warnings" title="13.7.5.40&nbsp;SHOW WARNINGS Syntax"><code class="literal">SHOW WARNINGS</code></a>.
                        </p><p style="color:blue;">在这种情况下，也会向客户发出类似的警告。客户端可以使用“显示警告”来显示它。</p></li><li class="listitem"><p>
                        <a class="link" href="sql-syntax.html#insert" title="13.2.5&nbsp;INSERT Syntax"><code class="literal">INSERT ...
                            SELECT</code></a> requires a greater number of row-level
                        locks than with row-based replication.
                    </p><p style="color:blue;">插入…与基于行的复制相比，select需要更多的行级锁。</p></li><li class="listitem"><p>
                        <a class="link" href="sql-syntax.html#update" title="13.2.11&nbsp;UPDATE Syntax"><code class="literal">UPDATE</code></a> statements that
                        require a table scan (because no index is used in the
                        <code class="literal">WHERE</code> clause) must lock a greater number
                        of rows than with row-based replication.
                    </p><p style="color:blue;">需要表扫描的UPDATE语句（因为WHERE子句中没有使用索引）必须锁定比基于行的复制更多的行。</p></li><li class="listitem"><p>
                        For <a class="link" href="innodb-storage-engine.html" title="Chapter&nbsp;14&nbsp;The InnoDB Storage Engine"><code class="literal">InnoDB</code></a>: An
                        <a class="link" href="sql-syntax.html#insert" title="13.2.5&nbsp;INSERT Syntax"><code class="literal">INSERT</code></a> statement that uses
                        <code class="literal">AUTO_INCREMENT</code> blocks other
                        nonconflicting <a class="link" href="sql-syntax.html#insert" title="13.2.5&nbsp;INSERT Syntax"><code class="literal">INSERT</code></a>
                        statements.
                    </p><p style="color:blue;">对于innodb：使用auto_increment的insert语句会阻塞其他不冲突的insert语句。</p></li><li class="listitem"><p>
                        For complex statements, the statement must be evaluated and
                        executed on the slave before the rows are updated or
                        inserted. With row-based replication, the slave only has to
                        modify the affected rows, not execute the full statement.
                    </p><p style="color:blue;">对于复杂的语句，在更新或插入行之前，必须对该语句求值并在从属语句上执行。对于基于行的复制，从机只需修改受影响的行，而不必执行完整的语句。</p></li><li class="listitem"><p>
                        If there is an error in evaluation on the slave,
                        particularly when executing complex statements,
                        statement-based replication may slowly increase the margin
                        of error across the affected rows over time. See
                        <a class="xref" href="replication.html#replication-features-slaveerrors" title="16.4.1.27&nbsp;Slave Errors During Replication">Section&nbsp;16.4.1.27, “Slave Errors During Replication”</a>.
                    </p><p style="color:blue;">如果在从机上求值时出错，特别是在执行复杂语句时，基于语句的复制可能会随着时间的推移缓慢地增加受影响行的错误范围。见16.4.1.27节，“复制过程中的从属错误”。</p></li><li class="listitem"><p>
                        Stored functions execute with the same
                        <a class="link" href="functions.html#function_now"><code class="literal">NOW()</code></a> value as the calling
                        statement. However, this is not true of stored procedures.
                    </p><p style="color:blue;">存储函数使用与调用语句相同的now（）值执行。但是，存储过程不是这样的。</p></li><li class="listitem"><p>
                        Deterministic UDFs must be applied on the slaves.
                    </p><p style="color:blue;">必须对从机应用确定性UDF。</p></li><li class="listitem"><p>
                        Table definitions must be (nearly) identical on master and
                        slave. See
                        <a class="xref" href="replication.html#replication-features-differing-tables" title="16.4.1.10&nbsp;Replication with Differing Table Definitions on Master and Slave">Section&nbsp;16.4.1.10, “Replication with Differing Table Definitions on Master and Slave”</a>, for
                        more information.
                    </p><p style="color:blue;">主表和从表的定义必须（几乎）相同。有关更多信息，请参阅16.4.1.10节，“在主设备和从设备上使用不同表定义的复制”。</p></li></ul>
                </div>
                <h5><a name="replication-sbr-rbr-rbr-advantages"></a>Advantages of row-based replication</h5>
                <a class="indexterm" name="idm140286794331040"></a>
                <div class="itemizedlist">
                    <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                        All changes can be replicated. This is the safest form of
                        replication.
                    </p><p style="color:blue;">所有更改都可以复制。这是最安全的复制形式。</p>
                        <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">

                            <div class="admon-title">
                                Note
                            </div>
                            <p>
                                Statements that update the information in the
                                <code class="literal">mysql</code> system database—such as
                                <a class="link" href="sql-syntax.html#grant" title="13.7.1.4&nbsp;GRANT Syntax"><code class="literal">GRANT</code></a>,
                                <a class="link" href="sql-syntax.html#revoke" title="13.7.1.6&nbsp;REVOKE Syntax"><code class="literal">REVOKE</code></a> and the manipulation
                                of triggers, stored routines (including stored
                                procedures), and views—are all replicated to slaves
                                using statement-based replication.
                            </p><p style="color:blue;">更新mysql系统数据库中信息的语句（如grant、revoke和触发器的操作、存储例程（包括存储过程）和视图）都使用基于语句的复制复制复制到从服务器。</p><p>
                            For statements such as
                            <a class="link" href="sql-syntax.html#create-table" title="13.1.18&nbsp;CREATE TABLE Syntax"><code class="literal">CREATE TABLE
                                ... SELECT</code></a>, a <code class="literal">CREATE</code>
                            statement is generated from the table definition and
                            replicated using statement-based format, while the row
                            insertions are replicated using row-based format.
                        </p><p style="color:blue;">对于CREATE TABLE等语句…选择，则从表定义生成一个CREATE语句并使用基于语句的格式复制，而行插入则使用基于行的格式复制。</p>
                        </div>
                    </li><li class="listitem"><p>
                        Fewer row locks are required on the master, which thus
                        achieves higher concurrency, for the following types of
                        statements:
                    </p><p style="color:blue;">对于以下类型的语句，在master上需要更少的行锁，从而获得更高的并发性：</p>
                        <div class="itemizedlist">
                            <ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
                                <a class="link" href="sql-syntax.html#insert-select" title="13.2.5.1&nbsp;INSERT ... SELECT Syntax"><code class="literal">INSERT
                                    ... SELECT</code></a>
                            </p><p style="color:blue;">插入…选择</p></li><li class="listitem"><p>
                                <a class="link" href="sql-syntax.html#insert" title="13.2.5&nbsp;INSERT Syntax"><code class="literal">INSERT</code></a> statements with
                                <code class="literal">AUTO_INCREMENT</code>
                            </p><p style="color:blue;">插入自动递增语句</p></li><li class="listitem"><p>
                                <a class="link" href="sql-syntax.html#update" title="13.2.11&nbsp;UPDATE Syntax"><code class="literal">UPDATE</code></a> or
                                <a class="link" href="sql-syntax.html#delete" title="13.2.2&nbsp;DELETE Syntax"><code class="literal">DELETE</code></a> statements with
                                <code class="literal">WHERE</code> clauses that do not use keys or
                                do not change most of the examined rows.
                            </p><p style="color:blue;">使用不使用键或不更改大多数检查行的where子句更新或删除语句。</p></li></ul>
                        </div>
                    </li><li class="listitem"><p>
                        Fewer row locks are required on the slave for any
                        <a class="link" href="sql-syntax.html#insert" title="13.2.5&nbsp;INSERT Syntax"><code class="literal">INSERT</code></a>,
                        <a class="link" href="sql-syntax.html#update" title="13.2.11&nbsp;UPDATE Syntax"><code class="literal">UPDATE</code></a>, or
                        <a class="link" href="sql-syntax.html#delete" title="13.2.2&nbsp;DELETE Syntax"><code class="literal">DELETE</code></a> statement.
                    </p><p style="color:blue;">对于任何INSERT、UPDATE或DELETE语句，从语句上需要的行锁更少。</p></li></ul>
                </div>
                <h5><a name="replication-sbr-rbr-rbr-disadvantages"></a>Disadvantages of row-based replication</h5>
                <a class="indexterm" name="idm140286794305296"></a>
                <div class="itemizedlist">
                    <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                        RBR can generate more data that must be logged. To replicate
                        a DML statement (such as an
                        <a class="link" href="sql-syntax.html#update" title="13.2.11&nbsp;UPDATE Syntax"><code class="literal">UPDATE</code></a> or
                        <a class="link" href="sql-syntax.html#delete" title="13.2.2&nbsp;DELETE Syntax"><code class="literal">DELETE</code></a> statement),
                        statement-based replication writes only the statement to the
                        binary log. By contrast, row-based replication writes each
                        changed row to the binary log. If the statement changes many
                        rows, row-based replication may write significantly more
                        data to the binary log; this is true even for statements
                        that are rolled back. This also means that making and
                        restoring a backup can require more time. In addition, the
                        binary log is locked for a longer time to write the data,
                        which may cause concurrency problems. Use
                        <a class="link" href="replication.html#sysvar_binlog_row_image"><code class="literal">binlog_row_image=minimal</code></a> to
                        reduce the disadvantage considerably.
                    </p><p style="color:blue;">rbr可以生成更多必须记录的数据。要复制DML语句（如UPDATE或DELETE语句），基于语句的复制只将该语句写入二进制日志。相反，基于行的复制将每个更改的行写入二进制日志。如果语句更改了许多行，基于行的复制可能会向二进制日志中写入更多的数据；即使是回滚的语句也是如此。这也意味着制作和恢复备份可能需要更多的时间。此外，二进制日志被锁定较长时间以写入数据，这可能会导致并发问题。使用binlog_row_image=minimal可以大大减少缺点。</p></li><li class="listitem"><p>
                        Deterministic UDFs that generate large
                        <a class="link" href="data-types.html#blob" title="11.4.3&nbsp;The BLOB and TEXT Types"><code class="literal">BLOB</code></a> values take longer to
                        replicate with row-based replication than with
                        statement-based replication. This is because the
                        <a class="link" href="data-types.html#blob" title="11.4.3&nbsp;The BLOB and TEXT Types"><code class="literal">BLOB</code></a> column value is logged,
                        rather than the statement generating the data.
                    </p><p style="color:blue;">与基于语句的复制相比，使用基于行的复制来复制生成大blob值的确定性udf所需的时间更长。这是因为记录了blob列值，而不是生成数据的语句。</p></li><li class="listitem"><p>
                        You cannot see on the slave what statements were received
                        from the master and executed. However, you can see what data
                        was changed using <a class="link" href="programs.html#mysqlbinlog" title="4.6.7&nbsp;mysqlbinlog — Utility for Processing Binary Log Files"><span class="command"><strong>mysqlbinlog</strong></span></a> with the
                        options
                        <a class="link" href="programs.html#option_mysqlbinlog_base64-output"><code class="option">--base64-output=DECODE-ROWS</code></a>
                        and <a class="link" href="programs.html#option_mysqlbinlog_verbose"><code class="option">--verbose</code></a>.
                    </p><p style="color:blue;">在从机上看不到从主机接收并执行的语句。但是，您可以使用mysqlbinlog查看更改了哪些数据，选项是--base64 output=decode-rows和--verbose。</p><p>
                        Alternatively, use the
                        <a class="link" href="replication.html#sysvar_binlog_rows_query_log_events"><code class="literal">binlog_rows_query_log_events</code></a>
                        variable, which if enabled adds a
                        <code class="literal">Rows_query</code> event with the statement to
                        <a class="link" href="programs.html#mysqlbinlog" title="4.6.7&nbsp;mysqlbinlog — Utility for Processing Binary Log Files"><span class="command"><strong>mysqlbinlog</strong></span></a> output when the
                        <code class="literal">-vv</code> option is used.
                    </p><p style="color:blue;">或者，使用binlog_rows_query_log_events变量，如果启用该变量，则会在使用-vv选项时将带有语句的rows_query事件添加到mysqlbinlog输出中。</p></li><li class="listitem"><p>
                        For tables using the <a class="link" href="storage-engines.html#myisam-storage-engine" title="15.2&nbsp;The MyISAM Storage Engine"><code class="literal">MyISAM</code></a>
                        storage engine, a stronger lock is required on the slave for
                        <a class="link" href="sql-syntax.html#insert" title="13.2.5&nbsp;INSERT Syntax"><code class="literal">INSERT</code></a> statements when
                        applying them as row-based events to the binary log than
                        when applying them as statements. This means that concurrent
                        inserts on <a class="link" href="storage-engines.html#myisam-storage-engine" title="15.2&nbsp;The MyISAM Storage Engine"><code class="literal">MyISAM</code></a> tables are
                        not supported when using row-based replication.
                    </p><p style="color:blue;">对于使用myisam存储引擎的表，在将slave for insert语句作为基于行的事件应用于二进制日志时，需要比将其作为语句应用时更强的锁。这意味着在使用基于行的复制时，不支持对myisam表进行并发插入。</p></li></ul>
                </div>

            </div>
            <div class="section">
                <div class="titlepage">
                    <div>
                        <div>
                            <h4 class="title"><a name="replication-rbr-usage"></a>16.2.1.2&nbsp;Usage of Row-Based Logging and Replication</h4>

                        </div>

                    </div>

                </div>
                <p>
                    MySQL uses statement-based logging (SBL), row-based logging
                    (RBL) or mixed-format logging. The type of binary log used
                    impacts the size and efficiency of logging.Therefore the choice
                    between row-based replication (RBR) or statement-based
                    replication (SBR) depends on your application and environment.



                    This section describes known issues when using a row-based
                    format log, and describes some best practices using it in
                    replication.
                </p><p style="color:blue;">mysql使用基于语句的日志（sbl）、基于行的日志（rbl）或混合格式日志。使用的二进制日志类型会影响日志的大小和效率，因此在基于行的复制（rbr）和基于语句的复制（sbr）之间的选择取决于您的应用程序和环境。本节介绍使用基于行的格式日志时的已知问题，并介绍在复制中使用该日志的一些最佳实践。</p><p>
                For additional information, see
                <a class="xref" href="replication.html#replication-formats" title="16.2.1&nbsp;Replication Formats">Section&nbsp;16.2.1, “Replication Formats”</a>, and
                <a class="xref" href="replication.html#replication-sbr-rbr" title="16.2.1.1&nbsp;Advantages and Disadvantages of Statement-Based and Row-Based Replication">Section&nbsp;16.2.1.1, “Advantages and Disadvantages of Statement-Based and Row-Based
                    Replication”</a>.
            </p><p style="color:blue;">有关更多信息，请参阅第16.2.1节“复制格式”和第16.2.1.1节“基于语句和基于行的复制的优缺点”。</p><p>
                For information about issues specific to NDB Cluster Replication
                (which depends on row-based replication), see
                <a class="xref" href="mysql-cluster.html#mysql-cluster-replication-issues" title="21.6.3&nbsp;Known Issues in NDB Cluster Replication">Section&nbsp;21.6.3, “Known Issues in NDB Cluster Replication”</a>.
            </p><p style="color:blue;">有关特定于ndb群集复制（取决于基于行的复制）的问题的信息，请参阅21.6.3节“ndb群集复制中的已知问题”。</p>
                <div class="itemizedlist">
                    <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><a name="replication-rbr-usage-temptables"></a><b>Row-based logging of temporary tables.&nbsp;</b>
                        As noted in
                        <a class="xref" href="replication.html#replication-features-temptables" title="16.4.1.29&nbsp;Replication and Temporary Tables">Section&nbsp;16.4.1.29, “Replication and Temporary Tables”</a>,
                        temporary tables are not replicated when using row-based
                        format. When using mixed format logging,
                        <span class="quote">“<span class="quote">safe</span>”</span> statements involving temporary tables
                        are logged using statement-based format. For more
                        information, see <a class="xref" href="replication.html#replication-sbr-rbr" title="16.2.1.1&nbsp;Advantages and Disadvantages of Statement-Based and Row-Based Replication">Section&nbsp;16.2.1.1, “Advantages and Disadvantages of Statement-Based and Row-Based
                            Replication”</a>.
                    </p><p style="color:blue;">临时表的基于行的日志记录。如第16.4.1.29节“复制和临时表”所述，使用基于行的格式时不复制临时表。使用混合格式日志记录时，涉及临时表的“安全”语句将使用基于语句的格式记录。有关更多信息，请参阅第16.2.1.1节“基于语句和基于行的复制的优缺点”。</p><p>
                        Temporary tables are not replicated when using row-based
                        format because there is no need. In addition, because
                        temporary tables can be read only from the thread which
                        created them, there is seldom if ever any benefit obtained
                        from replicating them, even when using statement-based
                        format.
                    </p><p style="color:blue;">使用基于行的格式时不复制临时表，因为不需要。此外，由于临时表只能从创建它们的线程中读取，因此即使使用基于语句的格式，复制临时表也几乎没有任何好处。</p><p>
                        You can switch from statement-based to row-based binary
                        logging format at runtime even when temporary tables have
                        been created. From MySQL 5.7.25, the MySQL server tracks the
                        logging mode that was in effect when each temporary table
                        was created. When a given client session ends, the server
                        logs a <code class="literal">DROP TEMPORARY TABLE IF EXISTS</code>
                        statement for each temporary table that still exists and was
                        created when statement-based binary logging was in use. If
                        row-based or mixed format binary logging was in use when the
                        table was created, the <code class="literal">DROP TEMPORARY TABLE IF
                        EXISTS</code> statement is not logged. In previous
                        releases, the <code class="literal">DROP TEMPORARY TABLE IF
                        EXISTS</code> statement was logged regardless of the
                        logging mode that was in effect.
                    </p><p style="color:blue;">即使创建了临时表，也可以在运行时从基于语句的日志记录格式切换到基于行的二进制日志记录格式。从mysql 5.7.25开始，mysql服务器跟踪创建每个临时表时生效的日志记录模式。当给定的客户端会话结束时，服务器为存在的临时表记录当前临时表的下拉临时表，并在使用基于语句的二进制日志记录时创建该表。如果在创建表时使用了基于行或混合格式的二进制日志记录，则不会记录DROP临时表if exists语句。在以前的版本中，drop temporary table if exists语句将被记录，而不考虑有效的日志记录模式。</p><p>
                        Nontransactional DML statements involving temporary tables
                        are allowed when using
                        <a class="link" href="replication.html#sysvar_binlog_format"><code class="literal">binlog_format=ROW</code></a>, as long
                        as any nontransactional tables affected by the statements
                        are temporary tables (Bug #14272672).
                    </p><p style="color:blue;">当使用binlog_format=row时，只要受语句影响的任何非事务表都是临时表，就允许使用涉及临时表的非事务dml语句（错误14272672）。</p></li><li class="listitem"><p><b>RBL and synchronization of nontransactional tables.&nbsp;</b>
                        When many rows are affected, the set of changes is split
                        into several events; when the statement commits, all of
                        these events are written to the binary log. When executing
                        on the slave, a table lock is taken on all tables
                        involved, and then the rows are applied in batch mode.
                        Depending on the engine used for the slave's copy of the
                        table, this may or may not be effective.


                    </p><p style="color:blue;">非事务表的rbl和同步。当许多行受到影响时，更改集被拆分为多个事件；当语句提交时，所有这些事件都将写入二进制日志。在从机上执行时，将对所有涉及的表执行表锁，然后以批处理模式应用行。根据用于从机复制表的引擎，这可能有效，也可能无效。</p></li><li class="listitem"><p><b>Latency and binary log size.&nbsp;</b>
                        RBL writes changes for each row to the binary log and so
                        its size can increase quite rapidly. This can
                        significantly increase the time required to make changes
                        on the slave that match those on the master. You should be
                        aware of the potential for this delay in your
                        applications.
                    </p><p style="color:blue;">延迟和二进制日志大小。rbl将每一行的更改写入二进制日志，因此其大小可以快速增加。这会显著增加在从属服务器上进行与主服务器上的更改相匹配的更改所需的时间。你应该意识到在你的应用程序中这种延迟的可能性。</p></li><li class="listitem"><p><b>Reading the binary log.&nbsp;</b>
                        <a class="link" href="programs.html#mysqlbinlog" title="4.6.7&nbsp;mysqlbinlog — Utility for Processing Binary Log Files"><span class="command"><strong>mysqlbinlog</strong></span></a> displays row-based events
                        in the binary log using the <code class="literal">BINLOG</code>
                        statement (see <a class="xref" href="sql-syntax.html#binlog" title="13.7.6.1&nbsp;BINLOG Syntax">Section&nbsp;13.7.6.1, “BINLOG Syntax”</a>). This statement
                        displays an event as a base 64-encoded string, the meaning
                        of which is not evident. When invoked with the
                        <a class="link" href="programs.html#option_mysqlbinlog_base64-output"><code class="option">--base64-output=DECODE-ROWS</code></a>
                        and <a class="link" href="programs.html#option_mysqlbinlog_verbose"><code class="option">--verbose</code></a> options,
                        <a class="link" href="programs.html#mysqlbinlog" title="4.6.7&nbsp;mysqlbinlog — Utility for Processing Binary Log Files"><span class="command"><strong>mysqlbinlog</strong></span></a> formats the contents of the
                        binary log to be human readable. When binary log events
                        were written in row-based format and you want to read or
                        recover from a replication or database failure you can use
                        this command to read contents of the binary log. For more
                        information, see <a class="xref" href="programs.html#mysqlbinlog-row-events" title="4.6.7.2&nbsp;mysqlbinlog Row Event Display">Section&nbsp;4.6.7.2, “mysqlbinlog Row Event Display”</a>.
                    </p><p style="color:blue;">读取二进制日志。mysqlbinlog使用binlog语句在二进制日志中显示基于行的事件（参见13.7.6.1节，“binlog语法”）。此语句将事件显示为基64编码的字符串，其含义不明显。当使用--base64 output=decode-rows和--verbose选项调用时，mysqlbinlog将二进制日志的内容格式化为可读的。如果二进制日志事件是以基于行的格式写入的，并且您希望从复制或数据库故障中读取或恢复，则可以使用此命令读取二进制日志的内容。有关更多信息，请参阅4.6.7.2节，“mysqlbinlog行事件显示”。</p></li><li class="listitem"><p><b>Binary log execution errors and slave_exec_mode.&nbsp;</b>
                        Using
                        <a class="link" href="replication.html#sysvar_slave_exec_mode"><code class="literal">slave_exec_mode=IDEMPOTENT</code></a>
                        is generally only useful with MySQL NDB Cluster
                        replication, for which <code class="literal">IDEMPOTENT</code> is
                        the default value. (See
                        <a class="xref" href="mysql-cluster.html#mysql-cluster-replication-multi-master" title="21.6.10&nbsp;NDB Cluster Replication: Multi-Master and Circular Replication">Section&nbsp;21.6.10, “NDB Cluster Replication: Multi-Master and Circular Replication”</a>).
                        When <a class="link" href="replication.html#sysvar_slave_exec_mode"><code class="literal">slave_exec_mode</code></a> is
                        <code class="literal">IDEMPOTENT</code>, a failure to apply changes
                        from RBL because the original row cannot be found does not
                        trigger an error or cause replication to fail. This means
                        that it is possible that updates are not applied on the
                        slave, so that the master and slave are no longer
                        synchronized. Latency issues and use of nontransactional
                        tables with RBR when
                        <a class="link" href="replication.html#sysvar_slave_exec_mode"><code class="literal">slave_exec_mode</code></a> is
                        <code class="literal">IDEMPOTENT</code> can cause the master and
                        slave to diverge even further. For more information about
                        <a class="link" href="replication.html#sysvar_slave_exec_mode"><code class="literal">slave_exec_mode</code></a>, see
                        <a class="xref" href="server-administration.html#server-system-variables" title="5.1.7&nbsp;Server System Variables">Section&nbsp;5.1.7, “Server System Variables”</a>.
                    </p><p style="color:blue;">二进制日志执行错误和从执行模式。使用slave_exec_mode=idempotent通常仅适用于mysql ndb集群复制，对于该复制，idempotent是默认值。（见第21.6.10节，“ndb集群复制：多主和循环复制”）。当slave_exec_mode为等幂时，由于找不到原始行而无法应用来自rbl的更改不会触发错误或导致复制失败。这意味着可能不会在从机上应用更新，因此主机和从机不再同步。当slave_exec_u模式为等幂时，延迟问题和使用带有rbr的非事务表可能会导致主从进一步分离。有关从机执行模式的更多信息，请参阅第5.1.7节“服务器系统变量”。</p><p>
                        For other scenarios, setting
                        <a class="link" href="replication.html#sysvar_slave_exec_mode"><code class="literal">slave_exec_mode</code></a> to
                        <code class="literal">STRICT</code> is normally sufficient; this is
                        the default value for storage engines other than
                        <a class="link" href="mysql-cluster.html" title="Chapter&nbsp;21&nbsp;MySQL NDB Cluster 7.5 and NDB Cluster 7.6"><code class="literal">NDB</code></a>.
                    </p><p style="color:blue;">对于其他情况，将slave_exec_mode设置为strict通常就足够了；这是ndb以外的存储引擎的默认值。</p></li><li class="listitem"><p><b>Filtering based on server ID not supported.&nbsp;</b>
                        You can filter based on server ID by using the
                        <code class="literal">IGNORE_SERVER_IDS</code> option for the
                        <a class="link" href="sql-syntax.html#change-master-to" title="13.4.2.1&nbsp;CHANGE MASTER TO Syntax"><code class="literal">CHANGE MASTER TO</code></a> statement.
                        This option works with statement-based and row-based
                        logging formats. Another method to filter out changes on
                        some slaves is to use a <code class="literal">WHERE</code> clause
                        that includes the relation <code class="literal">@@server_id &lt;&gt;
                            <em class="replaceable"><code>id_value</code></em></code> clause with
                        <a class="link" href="sql-syntax.html#update" title="13.2.11&nbsp;UPDATE Syntax"><code class="literal">UPDATE</code></a> and
                        <a class="link" href="sql-syntax.html#delete" title="13.2.2&nbsp;DELETE Syntax"><code class="literal">DELETE</code></a> statements. For
                        example, <code class="literal">WHERE @@server_id &lt;&gt; 1</code>.
                        However, this does not work correctly with row-based
                        logging. To use the
                        <a class="link" href="server-administration.html#sysvar_server_id"><code class="literal">server_id</code></a> system variable
                        for statement filtering, use statement-based logging.
                    </p><p style="color:blue;">不支持基于服务器ID的筛选。您可以使用change master to语句的ignore_server_ids选项根据服务器id进行筛选。此选项适用于基于语句和基于行的日志记录格式。另一种筛选某些从属服务器上的更改的方法是使用一个where子句，该子句包含relation@server\u id&lt;&gt;id\u value子句和update和delete语句。例如，其中@@server\u id&lt;&gt;1。但是，这在基于行的日志记录中不能正确工作。要使用服务器ID系统变量进行语句筛选，请使用基于语句的日志记录。</p></li><li class="listitem"><p><b>Database-level replication options.&nbsp;</b>
                        The effects of the
                        <a class="link" href="replication.html#option_mysqld_replicate-do-db"><code class="option">--replicate-do-db</code></a>,
                        <a class="link" href="replication.html#option_mysqld_replicate-ignore-db"><code class="option">--replicate-ignore-db</code></a>, and
                        <a class="link" href="replication.html#option_mysqld_replicate-rewrite-db"><code class="option">--replicate-rewrite-db</code></a>
                        options differ considerably depending on whether row-based
                        or statement-based logging is used. Therefore, it is
                        recommended to avoid database-level options and instead
                        use table-level options such as
                        <a class="link" href="replication.html#option_mysqld_replicate-do-table"><code class="option">--replicate-do-table</code></a> and
                        <a class="link" href="replication.html#option_mysqld_replicate-ignore-table"><code class="option">--replicate-ignore-table</code></a>.
                        For more information about these options and the impact
                        replication format has on how they operate, see
                        <a class="xref" href="replication.html#replication-options" title="16.1.6&nbsp;Replication and Binary Logging Options and Variables">Section&nbsp;16.1.6, “Replication and Binary Logging Options and Variables”</a>.
                    </p><p style="color:blue;">数据库级复制选项。--replicate do db、--replicate ignore db和--replicate rewrite db选项的效果差别很大，这取决于使用的是基于行的日志记录还是基于语句的日志记录。因此，建议避免使用数据库级选项，而是使用表级选项，例如--replicate do table和--replicate ignore table。有关这些选项以及复制格式对其操作方式的影响的更多信息，请参阅16.1.6节“复制和二进制日志选项和变量”。</p></li><li class="listitem"><p><b>RBL, nontransactional tables, and stopped slaves.&nbsp;</b>
                        When using row-based logging, if the slave server is
                        stopped while a slave thread is updating a
                        nontransactional table, the slave database can reach an
                        inconsistent state. For this reason, it is recommended
                        that you use a transactional storage engine such as
                        <a class="link" href="innodb-storage-engine.html" title="Chapter&nbsp;14&nbsp;The InnoDB Storage Engine"><code class="literal">InnoDB</code></a> for all tables
                        replicated using the row-based format. Use of
                        <a class="link" href="sql-syntax.html#stop-slave" title="13.4.2.7&nbsp;STOP SLAVE Syntax"><code class="literal">STOP SLAVE</code></a> or
                        <a class="link" href="sql-syntax.html#stop-slave" title="13.4.2.7&nbsp;STOP SLAVE Syntax"><code class="literal">STOP SLAVE
                            SQL_THREAD</code></a> prior to shutting down the slave
                        MySQL server helps prevent issues from occurring, and is
                        always recommended regardless of the logging format or
                        storage engine you use.
                    </p><p style="color:blue;">RBL、非事务表和停止的从机。使用基于行的日志记录时，如果从服务器在从线程更新非事务表时停止，则从数据库可能会达到不一致的状态。因此，建议对使用基于行格式复制的所有表使用事务性存储引擎，如innodb。在关闭从属mysql服务器之前使用stop slave或stop slave sql_线程有助于防止问题发生，并且无论使用何种日志格式或存储引擎，始终建议您使用。</p></li></ul>
                </div>

            </div>
            <div class="section">
                <div class="titlepage">
                    <div>
                        <div>
                            <h4 class="title"><a name="replication-rbr-safe-unsafe"></a>16.2.1.3&nbsp;Determination of Safe and Unsafe Statements in Binary Logging</h4>

                        </div>

                    </div>

                </div>
                <a class="indexterm" name="idm140286794210624"></a><a class="indexterm" name="idm140286794209168"></a><a class="indexterm" name="idm140286794207664"></a><p>
                The <span class="quote">“<span class="quote">safeness</span>”</span> of a statement in MySQL Replication,
                refers to whether the statement and its effects can be
                replicated correctly using statement-based format. If this is
                true of the statement, we refer to the statement as
                <span class="firstterm">safe</span>; otherwise, we refer
                to it as <span class="firstterm">unsafe</span>.
            </p><p style="color:blue;">mysql复制中语句的“安全性”是指是否可以使用基于语句的格式正确复制语句及其效果。如果这个语句是真的，我们称它为安全的；否则，我们称它为不安全的。</p><p>
                In general, a statement is safe if it deterministic, and unsafe
                if it is not. However, certain nondeterministic functions are
                <span class="emphasis"><em>not</em></span> considered unsafe (see
                <a class="xref" href="replication.html#replication-rbr-safe-unsafe-not" title="Nondeterministic functions not considered unsafe">Nondeterministic functions not considered unsafe</a>, later in this
                section). In addition, statements using results from
                floating-point math functions—which are
                hardware-dependent—are always considered unsafe (see
                <a class="xref" href="replication.html#replication-features-floatvalues" title="16.4.1.12&nbsp;Replication and Floating-Point Values">Section&nbsp;16.4.1.12, “Replication and Floating-Point Values”</a>).
            </p><p style="color:blue;">一般来说，如果语句是确定性的，那么它是安全的；如果语句不是确定性的，那么它是不安全的。但是，某些不确定函数不被认为是不安全的（参见本节后面的不确定函数不被认为是不安全的）。此外，使用与硬件相关的浮点数学函数的结果的语句总是被认为是不安全的（请参阅第16.4.1.12节“复制和浮点值”）。</p><p><b>Handling of safe and unsafe statements.&nbsp;</b>
                A statement is treated differently depending on whether the
                statement is considered safe, and with respect to the binary
                logging format (that is, the current value of
                <a class="link" href="replication.html#sysvar_binlog_format"><code class="literal">binlog_format</code></a>).
            </p><p style="color:blue;">安全和不安全声明的处理。根据语句是否被认为是安全的，以及二进制日志格式（即binlog_格式的当前值），对语句的处理是不同的。</p>
                <div class="itemizedlist">
                    <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                        When using row-based logging, no distinction is made in the
                        treatment of safe and unsafe statements.
                    </p><p style="color:blue;">当使用基于行的日志记录时，在处理安全和不安全语句方面没有区别。</p></li><li class="listitem"><p>
                        When using mixed-format logging, statements flagged as
                        unsafe are logged using the row-based format; statements
                        regarded as safe are logged using the statement-based
                        format.
                    </p><p style="color:blue;">使用混合格式日志记录时，标记为不安全的语句将使用基于行的格式记录；被视为安全的语句将使用基于语句的格式记录。</p></li><li class="listitem"><p>
                        When using statement-based logging, statements flagged as
                        being unsafe generate a warning to this effect. Safe
                        statements are logged normally.
                    </p><p style="color:blue;">使用基于语句的日志记录时，标记为不安全的语句将生成此效果的警告。安全声明记录正常。</p></li></ul>
                </div>
                <p>
                    Each statement flagged as unsafe generates a warning. Formerly,
                    if a large number of such statements were executed on the
                    master, this could lead to excessively large error log files. To
                    prevent this, MySQL 5.7 provides a warning suppression
                    mechanism, which behaves as follows: Whenever the 50 most recent
                    <a class="link" href="error-handling.html#error_er_binlog_unsafe_statement"><code class="literal">ER_BINLOG_UNSAFE_STATEMENT</code></a>
                    warnings have been generated more than 50 times in any 50-second
                    period, warning suppression is enabled. When activated, this
                    causes such warnings not to be written to the error log;
                    instead, for each 50 warnings of this type, a note <code class="literal">The
                    last warning was repeated <em class="replaceable"><code>N</code></em> times in
                    last <em class="replaceable"><code>S</code></em> seconds</code> is written
                    to the error log. This continues as long as the 50 most recent
                    such warnings were issued in 50 seconds or less; once the rate
                    has decreased below this threshold, the warnings are once again
                    logged normally. Warning suppression has no effect on how the
                    safety of statements for statement-based logging is determined,
                    nor on how warnings are sent to the client. MySQL clients still
                    receive one warning for each such statement.
                </p><p style="color:blue;">每个标记为不安全的语句都会生成警告。以前，如果在主机上执行大量这样的语句，则可能导致错误日志文件过大。为了防止这种情况，mysql 5.7提供了一种警告抑制机制，其行为如下：每当在任何50秒内生成50次以上的最近的er_binlog_unsafe_语句警告时，就会启用警告抑制。激活时，这将导致此类警告不会写入错误日志；相反，对于每50个此类警告，最后一个警告在过去的s秒内重复n次的注释将写入错误日志。只要在50秒或更短的时间内发出50个最新的此类警告，这种情况就会持续；一旦速率降低到该阈值以下，警告就会再次正常记录。警告抑制不会影响基于语句的日志记录语句的安全性的确定方式，也不会影响警告如何发送到客户端。mysql客户机仍然会收到每一个这样的语句的警告。</p><p>
                For more information, see <a class="xref" href="replication.html#replication-formats" title="16.2.1&nbsp;Replication Formats">Section&nbsp;16.2.1, “Replication Formats”</a>.
            </p><p style="color:blue;">有关更多信息，请参见第16.2.1节“复制格式”。</p><p><b>Statements considered unsafe.&nbsp;</b><a class="indexterm" name="idm140286794187792"></a>
                Statements with the following characteristics are considered
                unsafe:
            </p><p style="color:blue;">被认为不安全的陈述。具有以下特征的语句被认为是不安全的：</p>
                <div class="itemizedlist">
                    <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><b>Statements containing system functions that may return a different value
                        on slave.&nbsp;</b>
                        These functions include
                        <a class="link" href="functions.html#function_found-rows"><code class="literal">FOUND_ROWS()</code></a>,
                        <a class="link" href="functions.html#function_get-lock"><code class="literal">GET_LOCK()</code></a>,
                        <a class="link" href="functions.html#function_is-free-lock"><code class="literal">IS_FREE_LOCK()</code></a>,
                        <a class="link" href="functions.html#function_is-used-lock"><code class="literal">IS_USED_LOCK()</code></a>,
                        <a class="link" href="functions.html#function_load-file"><code class="literal">LOAD_FILE()</code></a>,
                        <a class="link" href="functions.html#function_master-pos-wait"><code class="literal">MASTER_POS_WAIT()</code></a>,
                        <a class="link" href="functions.html#function_password"><code class="literal">PASSWORD()</code></a>,
                        <a class="link" href="functions.html#function_rand"><code class="literal">RAND()</code></a>,
                        <a class="link" href="functions.html#function_release-lock"><code class="literal">RELEASE_LOCK()</code></a>,
                        <a class="link" href="functions.html#function_row-count"><code class="literal">ROW_COUNT()</code></a>,
                        <a class="link" href="functions.html#function_session-user"><code class="literal">SESSION_USER()</code></a>,
                        <a class="link" href="functions.html#function_sleep"><code class="literal">SLEEP()</code></a>,
                        <a class="link" href="functions.html#function_sysdate"><code class="literal">SYSDATE()</code></a>,
                        <a class="link" href="functions.html#function_system-user"><code class="literal">SYSTEM_USER()</code></a>,
                        <a class="link" href="functions.html#function_user"><code class="literal">USER()</code></a>,
                        <a class="link" href="functions.html#function_uuid"><code class="literal">UUID()</code></a>, and
                        <a class="link" href="functions.html#function_uuid-short"><code class="literal">UUID_SHORT()</code></a>.
                    </p><p style="color:blue;">包含系统函数的语句，这些函数可能在从机上返回不同的值。这些函数包括found_rows（），get_lock（），is_free_lock（），is_used_lock（），load_file（），master_pos_wait（），password（），rand（），release_lock（），row_count（），session_user（），sleep（），sysdate（），system_user（），user（），uuid（）和uuid_short（）。</p><p><a name="replication-rbr-safe-unsafe-not"></a><b>Nondeterministic functions not considered unsafe.&nbsp;</b>
                        Although these functions are not deterministic, they are
                        treated as safe for purposes of logging and replication:
                        <a class="link" href="functions.html#function_connection-id"><code class="literal">CONNECTION_ID()</code></a>,
                        <a class="link" href="functions.html#function_curdate"><code class="literal">CURDATE()</code></a>,
                        <a class="link" href="functions.html#function_current-date"><code class="literal">CURRENT_DATE()</code></a>,
                        <a class="link" href="functions.html#function_current-time"><code class="literal">CURRENT_TIME()</code></a>,
                        <a class="link" href="functions.html#function_current-timestamp"><code class="literal">CURRENT_TIMESTAMP()</code></a>,
                        <a class="link" href="functions.html#function_curtime"><code class="literal">CURTIME()</code></a>,,
                        <a class="link" href="functions.html#function_last-insert-id"><code class="literal">LAST_INSERT_ID()</code></a>,
                        <a class="link" href="functions.html#function_localtime"><code class="literal">LOCALTIME()</code></a>,
                        <a class="link" href="functions.html#function_localtimestamp"><code class="literal">LOCALTIMESTAMP()</code></a>,
                        <a class="link" href="functions.html#function_now"><code class="literal">NOW()</code></a>,
                        <a class="link" href="functions.html#function_unix-timestamp"><code class="literal">UNIX_TIMESTAMP()</code></a>,
                        <a class="link" href="functions.html#function_utc-date"><code class="literal">UTC_DATE()</code></a>,
                        <a class="link" href="functions.html#function_utc-time"><code class="literal">UTC_TIME()</code></a>, and
                        <a class="link" href="functions.html#function_utc-timestamp"><code class="literal">UTC_TIMESTAMP()</code></a>.
                    </p><p style="color:blue;">不确定函数不被认为是不安全的。尽管这些函数不是确定的，但在记录和复制时，它们被视为安全的：connection_id（）、curdate（）、current_date（）、current_time（）、current_timestamp（）、curtime（）、last_insert_id（）、localtime（）、localtimestamp（）、now（）、unix_timestamp（）、utc_date（）、utc_time（）和utc_timestamp（）。</p><p>
                        For more information, see
                        <a class="xref" href="replication.html#replication-features-functions" title="16.4.1.15&nbsp;Replication and System Functions">Section&nbsp;16.4.1.15, “Replication and System Functions”</a>.
                    </p><p style="color:blue;">有关更多信息，请参阅第16.4.1.15节“复制和系统功能”。</p></li><li class="listitem"><p><b>References to system variables.&nbsp;</b>
                        Most system variables are not replicated correctly using
                        the statement-based format. See
                        <a class="xref" href="replication.html#replication-features-variables" title="16.4.1.37&nbsp;Replication and Variables">Section&nbsp;16.4.1.37, “Replication and Variables”</a>. For
                        exceptions, see <a class="xref" href="server-administration.html#binary-log-mixed" title="5.4.4.3&nbsp;Mixed Binary Logging Format">Section&nbsp;5.4.4.3, “Mixed Binary Logging Format”</a>.
                    </p><p style="color:blue;">对系统变量的引用。大多数系统变量没有使用基于语句的格式正确复制。见第16.4.1.37节“复制和变量”。有关例外情况，请参阅第5.4.4.3节“混合二进制日志格式”。</p></li><li class="listitem"><p><b>UDFs.&nbsp;</b>
                        Since we have no control over what a UDF does, we must
                        assume that it is executing unsafe statements.
                    </p><p style="color:blue;">自定义项。由于我们无法控制udf的功能，因此必须假设它正在执行不安全的语句。</p></li><li class="listitem"><p><b>Fulltext plugin.&nbsp;</b>
                        This plugin may behave differently on different MySQL
                        servers; therefore, statements depending on it could have
                        different results. For this reason, all statements relying
                        on the fulltext plugin are treated as unsafe (Bug
                        #11756280, Bug #48183).
                    </p><p style="color:blue;">全文插件。这个插件在不同的mysql服务器上可能有不同的行为；因此，依赖它的语句可能有不同的结果。因此，所有依赖于全文插件的语句都被视为不安全的（错误11756280，错误48183）。</p></li><li class="listitem"><p><b>Trigger or stored program updates a table having an AUTO_INCREMENT
                        column.&nbsp;</b>
                        This is unsafe because the order in which the rows are
                        updated may differ on the master and the slave.
                    </p><p style="color:blue;">触发器或存储程序更新具有自动递增列的表。这是不安全的，因为行的更新顺序在主行和从行上可能不同。</p><p>
                        In addition, an <a class="link" href="sql-syntax.html#insert" title="13.2.5&nbsp;INSERT Syntax"><code class="literal">INSERT</code></a> into a
                        table that has a composite primary key containing an
                        <code class="literal">AUTO_INCREMENT</code> column that is not the
                        first column of this composite key is unsafe.
                    </p><p style="color:blue;">此外，如果向表中插入的复合主键包含的自动递增列不是此复合键的第一列，则插入是不安全的。</p><p>
                        For more information, see
                        <a class="xref" href="replication.html#replication-features-auto-increment" title="16.4.1.1&nbsp;Replication and AUTO_INCREMENT">Section&nbsp;16.4.1.1, “Replication and AUTO_INCREMENT”</a>.
                    </p><p style="color:blue;">有关更多信息，请参阅第16.4.1.1节“复制和自动增量”。</p></li><li class="listitem"><p><b>INSERT ... ON DUPLICATE KEY UPDATE statements on tables with multiple
                        primary or unique keys.&nbsp;</b>
                        When executed against a table that contains more than one
                        primary or unique key, this statement is considered
                        unsafe, being sensitive to the order in which the storage
                        engine checks the keys, which is not deterministic, and on
                        which the choice of rows updated by the MySQL Server
                        depends.
                    </p><p style="color:blue;">插入…具有多个主键或唯一键的表上的重复键更新语句。当对包含多个主键或唯一键的表执行时，此语句被认为是不安全的，它对存储引擎检查键的顺序（不确定）敏感，并且MySQL服务器更新的行的选择依赖于此顺序。</p><p>
                        An
                        <a class="link" href="sql-syntax.html#insert-on-duplicate" title="13.2.5.2&nbsp;INSERT ... ON DUPLICATE KEY UPDATE Syntax"><code class="literal">INSERT
                            ... ON DUPLICATE KEY UPDATE</code></a> statement against a
                        table having more than one unique or primary key is marked
                        as unsafe for statement-based replication. (Bug #11765650,
                        Bug #58637)
                    </p><p style="color:blue;">插入…对具有多个唯一键或主键的表执行的on duplicate key update语句对于基于语句的复制被标记为不安全。（错误11765650，错误58637）</p></li><li class="listitem"><p><b>Updates using LIMIT.&nbsp;</b>
                        The order in which rows are retrieved is not specified,
                        and is therefore considered unsafe. See
                        <a class="xref" href="replication.html#replication-features-limit" title="16.4.1.17&nbsp;Replication and LIMIT">Section&nbsp;16.4.1.17, “Replication and LIMIT”</a>.
                    </p><p style="color:blue;">使用限制更新。未指定检索行的顺序，因此被视为不安全。见第16.4.1.17节“复制和限制”。</p></li><li class="listitem"><p><b>Accesses or references log tables.&nbsp;</b>
                        The contents of the system log table may differ between
                        master and slave.
                    </p><p style="color:blue;">访问或引用日志表。主系统和从系统日志表的内容可能不同。</p></li><li class="listitem"><p><b>Nontransactional operations after transactional operations.&nbsp;</b>
                        Within a transaction, allowing any nontransactional reads
                        or writes to execute after any transactional reads or
                        writes is considered unsafe.
                    </p><p style="color:blue;">事务操作之后的非事务操作。在事务中，允许在任何事务性读写被认为不安全之后执行任何非事务性读写。</p><p>
                        For more information, see
                        <a class="xref" href="replication.html#replication-features-transactions" title="16.4.1.33&nbsp;Replication and Transactions">Section&nbsp;16.4.1.33, “Replication and Transactions”</a>.
                    </p><p style="color:blue;">有关更多信息，请参阅第16.4.1.33节“复制和事务”。</p></li><li class="listitem"><p><b>Accesses or references self-logging tables.&nbsp;</b>
                        All reads and writes to self-logging tables are considered
                        unsafe. Within a transaction, any statement following a
                        read or write to self-logging tables is also considered
                        unsafe.
                    </p><p style="color:blue;">访问或引用自记录表。对自记录表的所有读写都被认为是不安全的。在事务中，读或写自记录表之后的任何语句也被认为是不安全的。</p></li><li class="listitem"><p><b>LOAD DATA statements.&nbsp;</b>
                        <a class="link" href="sql-syntax.html#load-data" title="13.2.6&nbsp;LOAD DATA Syntax"><code class="literal">LOAD DATA</code></a> is treated as
                        unsafe and when
                        <a class="link" href="replication.html#sysvar_binlog_format"><code class="literal">binlog_format=mixed</code></a> the
                        statement is logged in row-based format. When
                        <a class="link" href="replication.html#sysvar_binlog_format"><code class="literal">binlog_format=statement</code></a>
                        <a class="link" href="sql-syntax.html#load-data" title="13.2.6&nbsp;LOAD DATA Syntax"><code class="literal">LOAD DATA</code></a> does not generate
                        a warning, unlike other unsafe statements.
                    </p><p style="color:blue;">加载数据语句。加载数据被视为不安全，当binlog_format=mixed时，语句将以基于行的格式记录。当binlog_format=语句加载数据不生成警告时，与其他不安全语句不同。</p></li><li class="listitem"><p><b>XA transactions.&nbsp;</b>
                        If two XA transactions committed in parallel on the master
                        are being prepared on the slave in the inverse order,
                        locking dependencies can occur with statement-based
                        replication that cannot be safely resolved, and it is
                        possible for replication to fail with deadlock on the
                        slave. When
                        <a class="link" href="replication.html#sysvar_binlog_format"><code class="literal">binlog_format=STATEMENT</code></a>
                        is set, DML statements inside XA transactions are flagged
                        as being unsafe and generate a warning. When
                        <a class="link" href="replication.html#sysvar_binlog_format"><code class="literal">binlog_format=MIXED</code></a> or
                        <a class="link" href="replication.html#sysvar_binlog_format"><code class="literal">binlog_format=ROW</code></a> is set,
                        DML statements inside XA transactions are logged using
                        row-based replication, and the potential issue is not
                        present.
                    </p><p style="color:blue;">xa事务。如果在主服务器上并行提交的两个xa事务正以相反的顺序在从服务器上准备，则基于语句的复制可能会发生锁定依赖性，而这种依赖性无法安全地解决，并且复制可能会在从服务器上死锁的情况下失败。当设置binlog_format=语句时，xa事务中的dml语句将被标记为不安全并生成警告。当设置binlog_format=mixed或binlog_format=row时，使用基于行的复制记录xa事务中的dml语句，并且不存在潜在的问题。</p></li></ul>
                </div>
                <p>
                    For additional information, see
                    <a class="xref" href="replication.html#replication-features" title="16.4.1&nbsp;Replication Features and Issues">Section&nbsp;16.4.1, “Replication Features and Issues”</a>.
                </p><p style="color:blue;">有关更多信息，请参阅第16.4.1节“复制功能和问题”。</p>
            </div>

        </div>
        <div class="section">
            <div class="titlepage">
                <div>
                    <div>
                        <h3 class="title"><a name="replication-implementation-details"></a>16.2.2&nbsp;Replication Implementation Details</h3>

                    </div>

                </div>

            </div>
            <p>
                MySQL replication capabilities are implemented using three
                threads, one on the master server and two on the slave:
            </p><p style="color:blue;">mysql复制功能使用三个线程实现，一个在主服务器上，两个在从服务器上：</p>
            <div class="itemizedlist">
                <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><b>Binlog dump thread.&nbsp;</b>
                    The master creates a thread to send the binary log contents
                    to a slave when the slave connects. This thread can be
                    identified in the output of <a class="link" href="sql-syntax.html#show-processlist" title="13.7.5.29&nbsp;SHOW PROCESSLIST Syntax"><code class="literal">SHOW
                        PROCESSLIST</code></a> on the master as the <code class="literal">Binlog
                        Dump</code> thread.
                </p><p style="color:blue;">binlog转储线程。主服务器创建一个线程，在从服务器连接时将二进制日志内容发送到从服务器。此线程可以在主机上的show processlist输出中标识为binlog转储线程。</p><p>
                    The binary log dump thread acquires a lock on the master's
                    binary log for reading each event that is to be sent to the
                    slave. As soon as the event has been read, the lock is
                    released, even before the event is sent to the slave.
                </p><p style="color:blue;">二进制日志转储线程获取主机二进制日志上的一个锁，用于读取要发送到从机的每个事件。一旦事件被读取，锁就会被释放，甚至在事件被发送到从机之前。</p></li><li class="listitem"><p><b>Slave I/O thread.&nbsp;</b>
                    When a <a class="link" href="sql-syntax.html#start-slave" title="13.4.2.6&nbsp;START SLAVE Syntax"><code class="literal">START SLAVE</code></a> statement
                    is issued on a slave server, the slave creates an I/O
                    thread, which connects to the master and asks it to send the
                    updates recorded in its binary logs.
                </p><p style="color:blue;">从I/O线程。当在从服务器上发出start slave语句时，从服务器创建一个I/O线程，该线程连接到主服务器并要求主服务器发送记录在其二进制日志中的更新。</p><p>
                    The slave I/O thread reads the updates that the master's
                    <code class="literal">Binlog Dump</code> thread sends (see previous
                    item) and copies them to local files that comprise the slave's
                    relay log.
                </p><p style="color:blue;">从I/O线程读取主BINLog转储线程发送的更新（见上一项），并将它们复制到构成从服务器中继日志的本地文件。</p><p>
                    The state of this thread is shown as
                    <code class="literal">Slave_IO_running</code> in the output of
                    <a class="link" href="sql-syntax.html#show-slave-status" title="13.7.5.34&nbsp;SHOW SLAVE STATUS Syntax"><code class="literal">SHOW SLAVE STATUS</code></a> or as
                    <a class="link" href="server-administration.html#statvar_Slave_running"><code class="literal">Slave_running</code></a> in the output
                    of <a class="link" href="sql-syntax.html#show-status" title="13.7.5.35&nbsp;SHOW STATUS Syntax"><code class="literal">SHOW STATUS</code></a>.
                </p><p style="color:blue;">此线程的状态显示为在显示从状态的输出中运行的从状态或在显示状态的输出中运行的从状态。</p></li><li class="listitem"><p><b>Slave SQL thread.&nbsp;</b>
                    The slave creates an SQL thread to read the relay log that
                    is written by the slave I/O thread and execute the events
                    contained therein.
                </p><p style="color:blue;">从SQL线程。从机创建一个sql线程来读取由从机i/o线程编写的中继日志，并执行其中包含的事件。</p></li></ul>
            </div>
            <p>
                In the preceding description, there are three threads per
                master/slave connection. A master that has multiple slaves creates
                one binary log dump thread for each currently connected slave, and
                each slave has its own I/O and SQL threads.
            </p><p style="color:blue;">在前面的描述中，每个主/从连接有三个线程。具有多个从机的主机为每个当前连接的从机创建一个二进制日志转储线程，每个从机都有自己的I/O和SQL线程。</p><p>
            A slave uses two threads to separate reading updates from the
            master and executing them into independent tasks. Thus, the task
            of reading statements is not slowed down if statement execution is
            slow. For example, if the slave server has not been running for a
            while, its I/O thread can quickly fetch all the binary log
            contents from the master when the slave starts, even if the SQL
            thread lags far behind. If the slave stops before the SQL thread
            has executed all the fetched statements, the I/O thread has at
            least fetched everything so that a safe copy of the statements is
            stored locally in the slave's relay logs, ready for execution the
            next time that the slave starts.
        </p><p style="color:blue;">从机使用两个线程将读取更新与主机分离，并将它们执行为独立的任务。因此，如果语句执行缓慢，则读取语句的任务不会减慢。例如，如果从服务器有一段时间没有运行，那么当从服务器启动时，它的I/O线程可以快速地从主服务器获取所有二进制日志内容，即使SQL线程远远落后于主服务器。如果从机在SQL线程执行所有获取的语句之前停止，则I/O线程至少已获取所有内容，以便将语句的安全副本存储在从机的中继日志中，以便下次从机启动时执行。</p><p>
            The <a class="link" href="sql-syntax.html#show-processlist" title="13.7.5.29&nbsp;SHOW PROCESSLIST Syntax"><code class="literal">SHOW PROCESSLIST</code></a> statement
            provides information that tells you what is happening on the
            master and on the slave regarding replication. For information on
            master states, see <a class="xref" href="optimization.html#master-thread-states" title="8.14.4&nbsp;Replication Master Thread States">Section&nbsp;8.14.4, “Replication Master Thread States”</a>. For
            slave states, see <a class="xref" href="optimization.html#slave-io-thread-states" title="8.14.5&nbsp;Replication Slave I/O Thread States">Section&nbsp;8.14.5, “Replication Slave I/O Thread States”</a>, and
            <a class="xref" href="optimization.html#slave-sql-thread-states" title="8.14.6&nbsp;Replication Slave SQL Thread States">Section&nbsp;8.14.6, “Replication Slave SQL Thread States”</a>.
        </p><p style="color:blue;">show processlist语句提供有关复制的信息，告诉您主服务器和从服务器上发生了什么。有关主线程状态的信息，请参阅第8.14.4节“复制主线程状态”。对于从机状态，请参阅第8.14.5节“复制从机I/O线程状态”和第8.14.6节“复制从机SQL线程状态”。</p><p>
            The following example illustrates how the three threads show up in
            the output from <a class="link" href="sql-syntax.html#show-processlist" title="13.7.5.29&nbsp;SHOW PROCESSLIST Syntax"><code class="literal">SHOW PROCESSLIST</code></a>.
        </p><p style="color:blue;">下面的示例演示了这三个线程如何显示在show processlist的输出中。</p><p>
            On the master server, the output from <a class="link" href="sql-syntax.html#show-processlist" title="13.7.5.29&nbsp;SHOW PROCESSLIST Syntax"><code class="literal">SHOW
            PROCESSLIST</code></a> looks like this:
        </p><p style="color:blue;">在主服务器上，show processlist的输出如下所示：</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>SHOW PROCESSLIST\G</code></strong>
*************************** 1. row ***************************
     Id: 2
   User: root
   Host: localhost:32931
     db: NULL
Command: Binlog Dump
   Time: 94
  State: Has sent all binlog to slave; waiting for binlog to
         be updated
   Info: NULL
</pre><p>
            Here, thread 2 is a <code class="literal">Binlog Dump</code> replication
            thread that services a connected slave. The
            <code class="literal">State</code> information indicates that all
            outstanding updates have been sent to the slave and that the
            master is waiting for more updates to occur. If you see no
            <code class="literal">Binlog Dump</code> threads on a master server, this
            means that replication is not running; that is, no slaves are
            currently connected.
        </p><p style="color:blue;">这里，线程2是一个binlog转储复制线程，它为连接的从机提供服务。状态信息表明所有未完成的更新都已发送到从属服务器，并且主服务器正在等待更多的更新发生。如果在主服务器上看不到binlog转储线程，这意味着复制没有运行；也就是说，当前没有连接从服务器。</p><p>
            On a slave server, the output from <a class="link" href="sql-syntax.html#show-processlist" title="13.7.5.29&nbsp;SHOW PROCESSLIST Syntax"><code class="literal">SHOW
            PROCESSLIST</code></a> looks like this:
        </p><p style="color:blue;">在从属服务器上，show processlist的输出如下所示：</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>SHOW PROCESSLIST\G</code></strong>
*************************** 1. row ***************************
     Id: 10
   User: system user
   Host:
     db: NULL
Command: Connect
   Time: 11
  State: Waiting for master to send event
   Info: NULL
*************************** 2. row ***************************
     Id: 11
   User: system user
   Host:
     db: NULL
Command: Connect
   Time: 11
  State: Has read all relay log; waiting for the slave I/O
         thread to update it
   Info: NULL
</pre><p>
            The <code class="literal">State</code> information indicates that thread 10
            is the I/O thread that is communicating with the master server,
            and thread 11 is the SQL thread that is processing the updates
            stored in the relay logs. At the time that
            <a class="link" href="sql-syntax.html#show-processlist" title="13.7.5.29&nbsp;SHOW PROCESSLIST Syntax"><code class="literal">SHOW PROCESSLIST</code></a> was run, both
            threads were idle, waiting for further updates.
        </p><p style="color:blue;">状态信息表明线程10是与主服务器通信的I/O线程，线程11是处理中继日志中存储的更新的SQL线程。在运行show processlist时，两个线程都处于空闲状态，等待进一步的更新。</p><p>
            The value in the <code class="literal">Time</code> column can show how late
            the slave is compared to the master. See
            <a class="xref" href="faqs.html#faqs-replication" title="A.14&nbsp;MySQL 5.7 FAQ: Replication">Section&nbsp;A.14, “MySQL 5.7 FAQ: Replication”</a>. If sufficient time elapses on
            the master side without activity on the <code class="literal">Binlog
            Dump</code> thread, the master determines that the slave is no
            longer connected. As for any other client connection, the timeouts
            for this depend on the values of
            <code class="option">net_write_timeout</code> and
            <code class="option">net_retry_count</code>; for more information about
            these, see <a class="xref" href="server-administration.html#server-system-variables" title="5.1.7&nbsp;Server System Variables">Section&nbsp;5.1.7, “Server System Variables”</a>.
        </p><p style="color:blue;">时间列中的值可以显示从设备与主设备相比的延迟时间。参见A.14节，“MySQL 5.7常见问题解答：复制”。如果主服务器端经过足够的时间而binlog转储线程没有活动，则主服务器将确定从服务器不再连接。对于任何其他客户端连接，超时取决于net_write_timeout和net_retry_count的值；有关这些值的更多信息，请参阅第5.1.7节“服务器系统变量”。</p><p>
            The <a class="link" href="sql-syntax.html#show-slave-status" title="13.7.5.34&nbsp;SHOW SLAVE STATUS Syntax"><code class="literal">SHOW SLAVE STATUS</code></a> statement
            provides additional information about replication processing on a
            slave server. See
            <a class="xref" href="replication.html#replication-administration-status" title="16.1.7.1&nbsp;Checking Replication Status">Section&nbsp;16.1.7.1, “Checking Replication Status”</a>.
        </p><p style="color:blue;">show slave status语句提供了有关从服务器上的复制处理的附加信息。见第16.1.7.1节“检查复制状态”。</p>
        </div>
        <div class="section">
            <div class="titlepage">
                <div>
                    <div>
                        <h3 class="title"><a name="replication-channels"></a>16.2.3&nbsp;Replication Channels</h3>

                    </div>

                </div>

            </div>
            <div class="toc">
                <dl class="toc"><dt><span class="section"><a href="replication.html#channels-commands-single-channel">16.2.3.1 Commands for Operations on a Single Channel</a></span></dt><dt><span class="section"><a href="replication.html#channels-with-prev-replication">16.2.3.2 Compatibility with Previous Replication Statements</a></span></dt><dt><span class="section"><a href="replication.html#channels-startup-options">16.2.3.3 Startup Options and Replication Channels</a></span></dt><dt><span class="section"><a href="replication.html#channels-naming-conventions">16.2.3.4 Replication Channel Naming Conventions</a></span></dt></dl>
            </div>
            <a class="indexterm" name="idm140286794055792"></a><a class="indexterm" name="idm140286794054720"></a><p>
            MySQL 5.7.6 introduces the concept of a replication channel, which
            represents the path of transactions flowing from a master to a
            slave. This section describes how channels can be used in a
            replication topology, and the impact they have on single-source
            replication.
        </p><p style="color:blue;">mysql 5.7.6引入了复制通道的概念，它表示事务从主服务器流向从服务器的路径。本节介绍如何在复制拓扑中使用通道，以及通道对单源复制的影响。</p><p>
            To provide compatibity with previous versions, the MySQL server
            automatically creates on startup a default channel whose name is the
            empty string (<code class="literal">""</code>). This channel is always
            present; it cannot be created or destroyed by the user. If no other
            channels (having nonempty names) have been created, replication
            statements act on the default channel only, so that all replication
            statements from older slaves function as expected (see
            <a class="xref" href="replication.html#channels-with-prev-replication" title="16.2.3.2&nbsp;Compatibility with Previous Replication Statements">Section&nbsp;16.2.3.2, “Compatibility with Previous Replication Statements”</a>. Statements
            applying to replication channels as described in this section can be
            used only when there is at least one named channel.
        </p><p style="color:blue;">为了提供与以前版本的兼容性，mysql服务器在启动时自动创建一个名为空字符串（“”）的默认通道。此通道始终存在；用户无法创建或销毁它。如果未创建其他通道（具有非空名称），则复制语句仅作用于默认通道，以便来自较旧从属服务器的所有复制语句都按预期工作（请参阅第16.2.3.2节“与以前的复制语句的兼容性”）。如本节所述，应用于复制通道的语句只能在至少有一个命名通道时使用。</p><p>
            A replication channel encompasses the path of transactions
            transmitted from a master to a slave. In multi-source replication a
            slave opens multiple channels, one per master, and each channel has
            its own relay log and applier (SQL) threads. Once transactions are
            received by a replication channel's receiver (I/O) thread, they
            are added to the channel's relay log file and passed through to
            an applier thread. This enables channels to function independently.
        </p><p style="color:blue;">复制通道包含从主服务器传输到从服务器的事务路径。在多源复制中，从机打开多个通道，每个主机一个，每个通道都有自己的中继日志和applier（sql）线程。一旦复制通道的接收器（I/O）线程接收到事务，它们将被添加到通道的中继日志文件中，并传递到applier线程。这使得频道能够独立工作。</p><p>
            A replication channel is also associated with a host name and port.
            You can assign multiple channels to the same combination of host
            name and port; in MySQL 5.7, the maximum number of
            channels that can be added to one slave in a multi-source
            replication topology is 256. Each replication channel must have a
            unique (nonempty) name (see
            <a class="xref" href="replication.html#channels-naming-conventions" title="16.2.3.4&nbsp;Replication Channel Naming Conventions">Section&nbsp;16.2.3.4, “Replication Channel Naming Conventions”</a>). Channels can be
            configured independently.
        </p><p style="color:blue;">复制通道还与主机名和端口关联。可以将多个信道分配给主机名称和端口的相同组合；在MySQL 5.7中，可以在多源复制拓扑中添加到一个从属的最大信道数为256。每个复制通道必须有一个唯一的（非空的）名称（请参阅第16.2.3.4节，“复制通道命名约定”）。通道可以独立配置。</p>
            <div class="section">

                <div class="titlepage">
                    <div>
                        <div>
                            <h4 class="title"><a name="channels-commands-single-channel"></a>16.2.3.1&nbsp;Commands for Operations on a Single Channel</h4>
                        </div>
                    </div>
                </div>
                <a class="indexterm" name="idm140286794046256"></a><a class="indexterm" name="idm140286794044768"></a><p>
                To enable MySQL replication operations to act on individual
                replication channels, use the <code class="literal">FOR CHANNEL
                <em class="replaceable"><code>channel</code></em></code> clause with the
                following replication statements:
            </p><p style="color:blue;">要使mysql复制操作能够作用于单个复制通道，请将for channel channel子句与以下复制语句一起使用：</p>
                <div class="itemizedlist">
                    <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                        <a class="link" href="sql-syntax.html#change-master-to" title="13.4.2.1&nbsp;CHANGE MASTER TO Syntax"><code class="literal">CHANGE MASTER TO</code></a>
                    </p><p style="color:blue;">将主控形状更改为</p></li><li class="listitem"><p>
                        <a class="link" href="sql-syntax.html#start-slave" title="13.4.2.6&nbsp;START SLAVE Syntax"><code class="literal">START SLAVE</code></a>
                    </p><p style="color:blue;">启动从机</p></li><li class="listitem"><p>
                        <a class="link" href="sql-syntax.html#stop-slave" title="13.4.2.7&nbsp;STOP SLAVE Syntax"><code class="literal">STOP SLAVE</code></a>
                    </p><p style="color:blue;">停止从机</p></li><li class="listitem"><p>
                        <a class="link" href="sql-syntax.html#show-relaylog-events" title="13.7.5.32&nbsp;SHOW RELAYLOG EVENTS Syntax"><code class="literal">SHOW RELAYLOG EVENTS</code></a>
                    </p><p style="color:blue;">显示relaylog事件</p></li><li class="listitem"><p>
                        <a class="link" href="sql-syntax.html#flush" title="13.7.6.3&nbsp;FLUSH Syntax"><code class="literal">FLUSH RELAY
                            LOGS</code></a>
                    </p><p style="color:blue;">刷新中继日志</p></li><li class="listitem"><p>
                        <a class="link" href="sql-syntax.html#show-slave-status" title="13.7.5.34&nbsp;SHOW SLAVE STATUS Syntax"><code class="literal">SHOW SLAVE STATUS</code></a>
                    </p><p style="color:blue;">显示从属状态</p></li><li class="listitem"><p>
                        <a class="link" href="sql-syntax.html#reset-slave" title="13.4.2.4&nbsp;RESET SLAVE Syntax"><code class="literal">RESET SLAVE</code></a>
                    </p><p style="color:blue;">复位从机</p></li></ul>
                </div>
                <p>
                    Similarly, an additional <code class="literal">channel</code> parameter is
                    introduced for the following functions:
                </p><p style="color:blue;">类似地，为以下功能引入了附加信道参数：</p>
                <div class="itemizedlist">
                    <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                        <a class="link" href="functions.html#function_master-pos-wait"><code class="literal">MASTER_POS_WAIT()</code></a>
                    </p><p style="color:blue;">主人等待（）</p></li><li class="listitem"><p>
                        <a class="link" href="functions.html#function_wait-until-sql-thread-after-gtids"><code class="literal">WAIT_UNTIL_SQL_THREAD_AFTER_GTIDS()</code></a>
                    </p><p style="color:blue;">在gtids（）之后等待sql线程</p></li></ul>
                </div>
                <p>
                    The following statements are disallowed for the
                    <code class="literal">group_replication_recovery</code> channel:
                </p><p style="color:blue;">以下语句不允许用于组复制恢复通道：</p>
                <div class="itemizedlist">
                    <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                        <a class="link" href="sql-syntax.html#start-slave" title="13.4.2.6&nbsp;START SLAVE Syntax"><code class="literal">START SLAVE</code></a>
                    </p><p style="color:blue;">启动从机</p></li><li class="listitem"><p>
                        <a class="link" href="sql-syntax.html#stop-slave" title="13.4.2.7&nbsp;STOP SLAVE Syntax"><code class="literal">STOP SLAVE</code></a>
                    </p><p style="color:blue;">停止从机</p></li></ul>
                </div>
                <p>
                    The following statements are disallowed for the
                    <code class="literal">group_replication_applier</code> channel:
                </p><p style="color:blue;">以下语句不允许用于组复制应用程序通道：</p>
                <div class="itemizedlist">
                    <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                        <a class="link" href="sql-syntax.html#start-slave" title="13.4.2.6&nbsp;START SLAVE Syntax"><code class="literal">START SLAVE</code></a>
                    </p><p style="color:blue;">启动从机</p></li><li class="listitem"><p>
                        <a class="link" href="sql-syntax.html#stop-slave" title="13.4.2.7&nbsp;STOP SLAVE Syntax"><code class="literal">STOP SLAVE</code></a>
                    </p><p style="color:blue;">停止从机</p></li><li class="listitem"><p>
                        <a class="link" href="sql-syntax.html#show-slave-status" title="13.7.5.34&nbsp;SHOW SLAVE STATUS Syntax"><code class="literal">SHOW SLAVE STATUS</code></a>
                    </p><p style="color:blue;">显示从属状态</p></li><li class="listitem"><p>
                        <a class="link" href="sql-syntax.html#flush" title="13.7.6.3&nbsp;FLUSH Syntax"><code class="literal">FLUSH RELAY
                            LOGS</code></a>
                    </p><p style="color:blue;">刷新中继日志</p></li></ul>
                </div>

            </div>
            <div class="section">
                <div class="titlepage">
                    <div>
                        <div>
                            <h4 class="title"><a name="channels-with-prev-replication"></a>16.2.3.2&nbsp;Compatibility with Previous Replication Statements</h4>

                        </div>

                    </div>

                </div>
                <a class="indexterm" name="idm140286794005632"></a><p>
                When a replication slave has multiple channels and a <code class="literal">FOR
                CHANNEL <em class="replaceable"><code>channel</code></em></code> option is not
                specified, a valid statement generally acts on all available
                channels, with some specific exceptions.
            </p><p style="color:blue;">当复制从机具有多个通道且未指定for channel通道选项时，有效语句通常作用于所有可用通道，但某些特定的例外情况除外。</p><p>
                For example, the following statements behave as expected for all
                except certain Group Replication channels:
            </p><p style="color:blue;">例如，除某些组复制通道外，以下语句的行为与预期一致：</p>
                <div class="itemizedlist">
                    <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                        <a class="link" href="sql-syntax.html#start-slave" title="13.4.2.6&nbsp;START SLAVE Syntax"><code class="literal">START SLAVE</code></a> starts replication
                        threads for all channels, except the
                        <code class="literal">group_replication_recovery</code> and
                        <code class="literal">group_replication_applier</code> channels.
                    </p><p style="color:blue;">start slave为所有通道启动复制线程，除了组复制恢复和组复制应用程序通道。</p></li><li class="listitem"><p>
                        <a class="link" href="sql-syntax.html#stop-slave" title="13.4.2.7&nbsp;STOP SLAVE Syntax"><code class="literal">STOP SLAVE</code></a> stops replication
                        threads for all channels, except the
                        <code class="literal">group_replication_recovery</code> and
                        <code class="literal">group_replication_applier</code> channels.
                    </p><p style="color:blue;">stop slave停止所有通道的复制线程，除了组复制恢复和组复制应用程序通道。</p></li><li class="listitem"><p>
                        <a class="link" href="sql-syntax.html#show-slave-status" title="13.7.5.34&nbsp;SHOW SLAVE STATUS Syntax"><code class="literal">SHOW SLAVE STATUS</code></a> reports the
                        status for all channels, except the
                        <code class="literal">group_replication_applier</code> channel.
                    </p><p style="color:blue;">显示从属状态报告除组复制应用程序通道外的所有通道的状态。</p></li><li class="listitem"><p>
                        <a class="link" href="sql-syntax.html#flush" title="13.7.6.3&nbsp;FLUSH Syntax"><code class="literal">FLUSH RELAY
                            LOGS</code></a> flushes the relay logs for all channels, except
                        the <code class="literal">group_replication_applier</code> channel.
                    </p><p style="color:blue;">刷新中继日志刷新所有通道（组复制应用程序通道除外）的中继日志。</p></li><li class="listitem"><p>
                        <a class="link" href="sql-syntax.html#reset-slave" title="13.4.2.4&nbsp;RESET SLAVE Syntax"><code class="literal">RESET
                            SLAVE</code></a> resets all channels.
                    </p><p style="color:blue;">重设从机重设所有通道。</p></li></ul>
                </div>
                <div class="warning" style="margin-left: 0.5in; margin-right: 0.5in;">
                    <div class="admon-title">
                        Warning
                    </div>
                    <p>
                        Use <code class="literal">RESET SLAVE</code> with caution as this
                        statement deletes all existing channels, purges their relay log
                        files, and recreates only the default channel.
                    </p><p style="color:blue;">使用重置奴隶谨慎，因为这个语句删除所有现有的渠道，清除他们的中继日志文件，并重新创建只有默认的通道。</p>
                </div>
                <p>
                    Some replication statements cannot operate on all channels. In
                    this case, error 1964 <span class="errortext">Multiple channels exist on the
      slave. Please provide channel name as an argument.</span> is
                    generated. The following statements and functions generate this
                    error when used in a multi-source replication topology and a
                    <code class="literal">FOR CHANNEL <em class="replaceable"><code>channel</code></em></code>
                    option is not used to specify which channel to act on:
                </p><p style="color:blue;">某些复制语句不能在所有通道上操作。在这种情况下，在从属设备上存在错误1964多个信道。请提供通道名称作为参数。是生成的。当在多源复制拓扑中使用以下语句和函数时，将生成此错误，并且不使用for channel channel选项指定要对哪个通道执行操作：</p>
                <div class="itemizedlist">
                    <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                        <a class="link" href="sql-syntax.html#show-relaylog-events" title="13.7.5.32&nbsp;SHOW RELAYLOG EVENTS Syntax"><code class="literal">SHOW RELAYLOG EVENTS</code></a>
                    </p><p style="color:blue;">显示relaylog事件</p></li><li class="listitem"><p>
                        <a class="link" href="sql-syntax.html#change-master-to" title="13.4.2.1&nbsp;CHANGE MASTER TO Syntax"><code class="literal">CHANGE MASTER TO</code></a>
                    </p><p style="color:blue;">将主控形状更改为</p></li><li class="listitem"><p>
                        <a class="link" href="functions.html#function_master-pos-wait"><code class="literal">MASTER_POS_WAIT()</code></a>
                    </p><p style="color:blue;">主人等待（）</p></li><li class="listitem"><p>
                        <a class="link" href="functions.html#function_wait-until-sql-thread-after-gtids"><code class="literal">WAIT_UNTIL_SQL_THREAD_AFTER_GTIDS()</code></a>
                    </p><p style="color:blue;">在gtids（）之后等待sql线程</p></li></ul>
                </div>
                <p>
                    Note that a default channel always exists in a single source
                    replication topology, where statements and functions behave as in
                    previous versions of MySQL.
                </p><p style="color:blue;">请注意，默认的通道始终存在于单个源复制拓扑中，其中语句和函数的行为与MySQL的以前版本一样。</p>
            </div>
            <div class="section">
                <div class="titlepage">
                    <div>
                        <div>
                            <h4 class="title"><a name="channels-startup-options"></a>16.2.3.3&nbsp;Startup Options and Replication Channels</h4>

                        </div>

                    </div>

                </div>
                <a class="indexterm" name="idm140286793972832"></a><a class="indexterm" name="idm140286793971344"></a><p>
                This section describes startup options which are impacted by the
                addition of replication channels.
            </p><p style="color:blue;">本节介绍受复制通道添加影响的启动选项。</p><p>
                The following startup options <span class="emphasis"><em>must</em></span> be
                configured correctly to use multi-source replication.
            </p><p style="color:blue;">必须正确配置以下启动选项才能使用多源复制。</p>
                <div class="itemizedlist">
                    <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                        <a class="link" href="replication.html#sysvar_relay_log_info_repository"><code class="literal">--relay-log-info-repository</code></a>
                    </p><p style="color:blue;">--中继日志信息存储库</p><p>
                        This must be set to <code class="literal">TABLE</code>. If this option
                        is set to <code class="literal">FILE</code>, attempting to add more
                        sources to a slave fails with
                        <a class="link" href="error-handling.html#error_er_slave_new_channel_wrong_repository"><code class="literal">ER_SLAVE_NEW_CHANNEL_WRONG_REPOSITORY</code></a>.
                    </p><p style="color:blue;">必须将其设置为table。如果此选项设置为“文件”，则尝试向从属服务器添加更多源将失败，因为er_slave_new_channel_wrong_repository。</p></li><li class="listitem"><p>
                        <code class="option">--master-info-repository</code>
                    </p><p style="color:blue;">--主信息存储库</p><p>
                        This must be set to <code class="literal">TABLE</code>. If this option
                        is set to <code class="literal">FILE</code>, attempting to add more
                        sources to a slave fails with
                        <a class="link" href="error-handling.html#error_er_slave_new_channel_wrong_repository"><code class="literal">ER_SLAVE_NEW_CHANNEL_WRONG_REPOSITORY</code></a>.
                    </p><p style="color:blue;">必须将其设置为table。如果此选项设置为“文件”，则尝试向从属服务器添加更多源将失败，因为er_slave_new_channel_wrong_repository。</p></li></ul>
                </div>
                <p>
                    The following startup options now affect <span class="emphasis"><em>all</em></span>
                    channels in a replication topology.
                </p><p style="color:blue;">以下启动选项现在影响复制拓扑中的所有通道。</p>
                <div class="itemizedlist">
                    <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                        <a class="link" href="replication.html#sysvar_log_slave_updates"><code class="literal">--log-slave-updates</code></a>
                    </p><p style="color:blue;">--日志从更新</p><p>
                        All transactions received by the slave (even from multiple
                        sources) are written in the binary log.
                    </p><p style="color:blue;">从机接收的所有事务（甚至来自多个源）都写入二进制日志。</p></li><li class="listitem"><p>
                        <a class="link" href="replication.html#sysvar_relay_log_purge"><code class="literal">--relay-log-purge</code></a>
                    </p><p style="color:blue;">--继电器日志清除</p><p>
                        When set, each channel purges its own relay log automatically.
                    </p><p style="color:blue;">设置后，每个通道都会自动清除自己的中继日志。</p></li><li class="listitem"><p>
                        <a class="link" href="replication.html#sysvar_slave_transaction_retries"><code class="literal">--slave_transaction_retries</code></a>
                    </p><p style="color:blue;">--从事务重试</p><p>
                        Applier threads of all channels retry transactions.
                    </p><p style="color:blue;">所有通道的applier线程重试事务。</p></li><li class="listitem"><p>
                        <a class="link" href="replication.html#option_mysqld_skip-slave-start"><code class="option">--skip-slave-start</code></a>
                    </p><p style="color:blue;">--跳过从机启动</p><p>
                        No replication threads start on any channels.
                    </p><p style="color:blue;">任何通道上都不会启动复制线程。</p></li><li class="listitem"><p>
                        <a class="link" href="replication.html#sysvar_slave_skip_errors"><code class="literal">--slave-skip-errors</code></a>
                    </p><p style="color:blue;">--从跳过错误</p><p>
                        Execution continues and errors are skipped for all channels.
                    </p><p style="color:blue;">继续执行并跳过所有通道的错误。</p></li></ul>
                </div>
                <p>
                    The values set for the following startup options apply on each
                    channel; since these are <a class="link" href="programs.html#mysqld" title="4.3.1&nbsp;mysqld — The MySQL Server"><span class="command"><strong>mysqld</strong></span></a> startup
                    options, they are applied on every channel.
                </p><p style="color:blue;">为以下启动选项设置的值适用于每个通道；因为这些是mysqld启动选项，所以它们适用于每个通道。</p>
                <div class="itemizedlist">
                    <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                        <code class="option">--max-relay-log-size=<em class="replaceable"><code>size</code></em></code>
                    </p><p style="color:blue;">--最大中继日志大小=大小</p><p>
                        Maximum size of the individual relay log file for each
                        channel; after reaching this limit, the file is rotated.
                    </p><p style="color:blue;">每个通道的单个中继日志文件的最大大小；在达到此限制后，文件被旋转。</p></li><li class="listitem"><p>
                        <code class="option">--relay-log-space-limit=<em class="replaceable"><code>size</code></em></code>
                    </p><p style="color:blue;">--中继日志空间限制=大小</p><p>
                        Upper limit for the total size of all relay logs combined, for
                        each individual channel. For <em class="replaceable"><code>N</code></em>
                        channels, the combined size of these logs is limited to
                        <a class="link" href="replication.html#sysvar_relay_log_space_limit"><code class="literal">relay_log_space_limit *
                            <em class="replaceable"><code>N</code></em></code></a>.
                    </p><p style="color:blue;">每个单独通道的所有中继日志组合的总大小的上限。对于n个信道，这些日志的组合大小限制为中继日志空间限制*n。</p></li><li class="listitem"><p>
                        <code class="option">--slave-parallel-workers=<em class="replaceable"><code>value</code></em></code>
                    </p><p style="color:blue;">--从并行工作机=值</p><p>
                        Number of slave parallel workers per channel.
                    </p><p style="color:blue;">每个通道的从属并行工作线程数。</p></li><li class="listitem"><p>
                        <code class="option">--slave-checkpoint-group</code>
                    </p><p style="color:blue;">--从检查点组</p><p>
                        Waiting time by an I/O thread for each source.
                    </p><p style="color:blue;">每个源的I/O线程等待时间。</p></li><li class="listitem"><p>
                        <code class="option">--relay-log-index=filename</code>
                    </p><p style="color:blue;">--中继日志索引=文件名</p><p>
                        Base name for each channel's relay log index file. See
                        <a class="xref" href="replication.html#channels-naming-conventions" title="16.2.3.4&nbsp;Replication Channel Naming Conventions">Section&nbsp;16.2.3.4, “Replication Channel Naming Conventions”</a>.
                    </p><p style="color:blue;">每个通道的中继日志索引文件的基名称。见第16.2.3.4节“复制通道命名约定”。</p></li><li class="listitem"><p>
                        <code class="option">--relay-log=filename</code>
                    </p><p style="color:blue;">--中继日志=文件名</p><p>
                        Denotes the base name of each channel's relay log file.
                        See <a class="xref" href="replication.html#channels-naming-conventions" title="16.2.3.4&nbsp;Replication Channel Naming Conventions">Section&nbsp;16.2.3.4, “Replication Channel Naming Conventions”</a>.
                    </p><p style="color:blue;">表示每个通道的中继日志文件的基名称。见第16.2.3.4节“复制通道命名约定”。</p></li><li class="listitem"><p>
                        <code class="option">--slave_net-timeout=N</code>
                    </p><p style="color:blue;">--从网络超时=n</p><p>
                        This value is set per channel, so that each channel waits for
                        <em class="replaceable"><code>N</code></em> seconds to check for a broken
                        connection.
                    </p><p style="color:blue;">此值是为每个通道设置的，因此每个通道等待n秒以检查连接是否断开。</p></li><li class="listitem"><p>
                        <code class="option">--slave-skip-counter=N</code>
                    </p><p style="color:blue;">--从跳过计数器=n</p><p>
                        This value is set per channel, so that each channel skips
                        <em class="replaceable"><code>N</code></em> events from its master.
                    </p><p style="color:blue;">这个值是为每个通道设置的，因此每个通道从其主节点跳过n个事件。</p></li></ul>
                </div>

            </div>
            <div class="section">
                <div class="titlepage">
                    <div>
                        <div>
                            <h4 class="title"><a name="channels-naming-conventions"></a>16.2.3.4&nbsp;Replication Channel Naming Conventions</h4>

                        </div>

                    </div>

                </div>
                <a class="indexterm" name="idm140286793922688"></a><p>
                This section describes how naming conventions are impacted by
                replication channels.
            </p><p style="color:blue;">本节介绍命名约定如何受复制通道的影响。</p><p>
                Each replication channel has a unique name which is a string with
                a maximum length of 64 characters and is case insensitive. Because
                channel names are used in slave tables, the character set used for
                these is always UTF-8. Although you are generally free to use any
                name for channels, the following names are reserved:
            </p><p style="color:blue;">每个复制通道都有一个唯一的名称，它是一个字符串，最大长度为64个字符，并且大小写不敏感。因为在从表中使用通道名，所以用于这些表的字符集始终是utf-8。尽管您通常可以自由使用频道的任何名称，但保留以下名称：</p>
                <div class="itemizedlist">
                    <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                        <code class="literal">group_replication_applier</code>
                    </p><p style="color:blue;">组复制应用程序</p></li><li class="listitem"><p>
                        <code class="literal">group_replication_recovery</code>
                    </p><p style="color:blue;">组复制恢复</p></li></ul>
                </div>
                <p>
                    The name you choose for a replication channel also influences the
                    file names used by a multi-source replication slave. The relay log
                    files and index files for each channel are named
                    <code class="filename"><em class="replaceable"><code>relay_log_basename</code></em>-<em class="replaceable"><code>channel</code></em>.xxxxxx</code>,
                    where <em class="replaceable"><code>relay_log_basename</code></em> is a base name
                    specified using the <a class="link" href="replication.html#sysvar_relay_log"><code class="literal">relay_log</code></a>
                    system variable, and <em class="replaceable"><code>channel</code></em> is the
                    name of the channel logged to this file. If you do not specify the
                    <a class="link" href="replication.html#sysvar_relay_log"><code class="literal">relay_log</code></a> system variable, a
                    default file name is used that also includes the name of the
                    channel.
                </p><p style="color:blue;">为复制通道选择的名称也会影响多源复制从属服务器使用的文件名。每个通道的中继日志文件和索引文件名为relay_log_base name-channel.xxxxxx，其中relay_log_basename是使用relay_log系统变量指定的基名，channel是记录到此文件的通道的名称。如果未指定RELAY U LOG系统变量，则使用默认文件名，该文件名还包括通道的名称。</p>
            </div>

        </div>
        <div class="section">
            <div class="titlepage">
                <div>
                    <div>
                        <h3 class="title"><a name="slave-logs"></a>16.2.4&nbsp;Replication Relay and Status Logs</h3>

                    </div>

                </div>

            </div>
            <div class="toc">
                <dl class="toc"><dt><span class="section"><a href="replication.html#slave-logs-relaylog">16.2.4.1 The Slave Relay Log</a></span></dt><dt><span class="section"><a href="replication.html#slave-logs-status">16.2.4.2 Slave Status Logs</a></span></dt></dl>
            </div>
            <a class="indexterm" name="idm140286793909616"></a><a class="indexterm" name="idm140286793908160"></a><a class="indexterm" name="idm140286793906672"></a><a class="indexterm" name="idm140286793905584"></a><a class="indexterm" name="idm140286793904496"></a><a class="indexterm" name="idm140286793903408"></a><a class="indexterm" name="idm140286793902320"></a><a class="indexterm" name="idm140286793901232"></a><a class="indexterm" name="idm140286793900144"></a><a class="indexterm" name="idm140286793899072"></a><p>
            During replication, a slave server creates several logs that hold
            the binary log events relayed from the master to the slave, and to
            record information about the current status and location within
            the relay log. There are three types of logs used in the process,
            listed here:
        </p><p style="color:blue;">在复制过程中，从服务器创建多个日志，保存从主服务器转发到从服务器的二进制日志事件，并在中继日志中记录有关当前状态和位置的信息。此过程中使用了三种类型的日志，如下所示：</p>
            <div class="itemizedlist">
                <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                    The <span class="firstterm">master info log</span>
                    contains status and current configuration information for the
                    slave's connection to the master. This log holds
                    information on the master host name, login credentials, and
                    coordinates indicating how far the slave has read from the
                    master's binary log.
                </p><p style="color:blue;">主信息日志包含从机与主机连接的状态和当前配置信息。此日志保存有关主主机名、登录凭据和坐标的信息，这些信息指示从主机的二进制日志读取的距离。</p><p>
                    This log can be written to the
                    <code class="literal">mysql.slave_master_info</code> table instead of a
                    file, by starting the slave with
                    <a class="link" href="replication.html#option_mysqld_master-info-repository"><code class="option">--master-info-repository=TABLE</code></a>.
                </p><p style="color:blue;">通过使用--master info repository=table启动slave，可以将此日志写入mysql.slave_master_info表，而不是文件。</p></li><li class="listitem"><p>
                    The <span class="emphasis"><em>relay log</em></span> consists of the events read
                    from the binary log of the master and written by the slave I/O
                    thread. Events in the relay log are executed on the slave as
                    part of the SQL thread.
                </p><p style="color:blue;">中继日志由从主I/O线程从二进制日志读取并写入的事件组成。中继日志中的事件作为sql线程的一部分在从机上执行。</p></li><li class="listitem"><p>
                    The <span class="firstterm">relay log info log</span>
                    holds status information about the execution point within the
                    slave's relay log.
                </p><p style="color:blue;">中继日志信息日志保存从服务器的中继日志中有关执行点的状态信息。</p><p>
                    This log can be written to the
                    <code class="literal">mysql.slave_relay_log_info</code> table instead of
                    a file by starting the slave with
                    <a class="link" href="replication.html#option_mysqld_relay-log-info-repository"><code class="option">--relay-log-info-repository=TABLE</code></a>.
                </p><p style="color:blue;">通过使用--relay log info repository=table启动从服务器，可以将此日志写入mysql.slave_relay_log_info表，而不是文件。</p></li></ul>
            </div>
            <p>
                When tables are used for the slave status logs, a warning is given
                if <a class="link" href="programs.html#mysqld" title="4.3.1&nbsp;mysqld — The MySQL Server"><span class="command"><strong>mysqld</strong></span></a> is unable to initialize the
                replication logging tables, but the slave is allowed to continue
                starting. This situation is most likely to occur when upgrading
                from a version of MySQL that does not support slave logging tables
                to one in which they are supported.
            </p><p style="color:blue;">当表用于从机状态日志时，如果mysqld无法初始化复制日志表，但允许从机继续启动，则会发出警告。当从不支持从日志记录表的mysql版本升级到支持从日志记录表的版本时，最有可能发生这种情况。</p>
            <div class="important" style="margin-left: 0.5in; margin-right: 0.5in;">

                <div class="admon-title">
                    Important
                </div>
                <p>
                    Do not attempt to update or insert rows in the
                    <code class="literal">slave_master_info</code> or
                    <code class="literal">slave_relay_log_info</code> table manually. Doing so
                    can cause undefined behavior, and is not supported.
                </p><p style="color:blue;">请勿尝试手动更新或插入slave_master_info或slave_relay_log_info表中的行。这样做会导致未定义的行为，并且不受支持。</p>
            </div>
            <p>
                Execution of any statement requiring a write lock on either or
                both of the <code class="literal">slave_master_info</code> and
                <code class="literal">slave_relay_log_info</code> tables is disallowed while
                replication is ongoing, while statements that perform only reads
                are permitted at any time.
            </p><p style="color:blue;">当复制正在进行时，不允许执行任何需要在slave_master_info和slave_relay_log_info表中的一个或两个表上设置写锁的语句，而允许在任何时候执行仅执行读取的语句。</p><p>
            If you set <a class="link" href="replication.html#sysvar_master_info_repository"><code class="literal">master_info_repository</code></a>
            and <a class="link" href="replication.html#sysvar_relay_log_info_repository"><code class="literal">relay_log_info_repository</code></a> to
            <code class="literal">TABLE</code>, the
            <code class="literal">mysql.slave_master_info</code> and
            <code class="literal">mysql.slave_relay_log_info</code> tables are created
            using the transactional storage engine
            <a class="link" href="innodb-storage-engine.html" title="Chapter&nbsp;14&nbsp;The InnoDB Storage Engine"><code class="literal">InnoDB</code></a>. As a table, updates to the
            relay log info log are committed together with the transactions,
            meaning that the slave's progress information recorded in that log
            is always consistent with what has been applied to the database,
            even in the event of an unexpected server halt. The
            <a class="link" href="replication.html#option_mysqld_relay-log-recovery"><code class="option">--relay-log-recovery</code></a> option must be
            enabled on the slave to guarantee resilience. For more details,
            see <a class="xref" href="replication.html#replication-solutions-unexpected-slave-halt" title="16.3.2&nbsp;Handling an Unexpected Halt of a Replication Slave">Section&nbsp;16.3.2, “Handling an Unexpected Halt of a Replication Slave”</a>.
        </p><p style="color:blue;">如果将master_info_repository和relay_log_info_repository设置为table，那么mysql.slave_master_info和mysql.slave_relay_log_info表将使用事务存储引擎innodb创建。作为一个表，对中继日志信息日志的更新与事务一起提交，这意味着该日志中记录的从属进程信息始终与应用于数据库的内容一致，即使在服务器意外停止的情况下也是如此。必须在从属服务器上启用--relay log recovery选项以确保恢复能力。有关更多详细信息，请参阅16.3.2节，“处理复制从机的意外停止”。</p>
            <div class="section">

                <div class="titlepage">
                    <div>
                        <div>
                            <h4 class="title"><a name="slave-logs-relaylog"></a>16.2.4.1&nbsp;The Slave Relay Log</h4>
                        </div>
                    </div>
                </div>
                <p>
                    The relay log, like the binary log, consists of a set of
                    numbered files containing events that describe database changes,
                    and an index file that contains the names of all used relay log
                    files.
                </p><p style="color:blue;">中继日志和二进制日志一样，由一组包含描述数据库更改的事件的编号文件和一个包含所有已用中继日志文件名称的索引文件组成。</p><p>
                The term <span class="quote">“<span class="quote">relay log file</span>”</span> generally denotes an
                individual numbered file containing database events. The term
                <span class="quote">“<span class="quote">relay log</span>”</span> collectively denotes the set of
                numbered relay log files plus the index file.
            </p><p style="color:blue;">术语“中继日志文件”通常表示包含数据库事件的单个编号文件。术语“中继日志”共同表示编号的中继日志文件集和索引文件。</p><p>
                Relay log files have the same format as binary log files and can
                be read using <a class="link" href="programs.html#mysqlbinlog" title="4.6.7&nbsp;mysqlbinlog — Utility for Processing Binary Log Files"><span class="command"><strong>mysqlbinlog</strong></span></a> (see
                <a class="xref" href="programs.html#mysqlbinlog" title="4.6.7&nbsp;mysqlbinlog — Utility for Processing Binary Log Files">Section&nbsp;4.6.7, “<span class="command"><strong>mysqlbinlog</strong></span> — Utility for Processing Binary Log Files”</a>).
            </p><p style="color:blue;">中继日志文件的格式与二进制日志文件的格式相同，可以使用mysqlbinlog读取（请参阅4.6.7节，“mysqlbinlog-处理二进制日志文件的实用程序”）。</p><p>
                By default, relay log file names have the form
                <code class="filename"><em class="replaceable"><code>host_name</code></em>-relay-bin.<em class="replaceable"><code>nnnnnn</code></em></code>
                in the data directory, where
                <em class="replaceable"><code>host_name</code></em> is the name of the slave
                server host and <em class="replaceable"><code>nnnnnn</code></em> is a sequence
                number. Successive relay log files are created using successive
                sequence numbers, beginning with <code class="literal">000001</code>. The
                slave uses an index file to track the relay log files currently
                in use. The default relay log index file name is
                <code class="filename"><em class="replaceable"><code>host_name</code></em>-relay-bin.index</code>
                in the data directory.
            </p><p style="color:blue;">默认情况下，中继日志文件名的格式为host_name-relay-bin.nnnnnn，其中host_name是从属服务器主机的名称，nnnnnn是序列号。使用从000001开始的连续序列号创建连续的中继日志文件。从服务器使用索引文件跟踪当前使用的中继日志文件。数据目录中的默认中继日志索引文件名为host_name-relay-bin.index。</p><p>
                The default relay log file and relay log index file names can be
                overridden with, respectively, the
                <a class="link" href="replication.html#sysvar_relay_log"><code class="literal">relay_log</code></a> and
                <a class="link" href="replication.html#sysvar_relay_log_index"><code class="literal">relay_log_index</code></a> system
                variables (see <a class="xref" href="replication.html#replication-options" title="16.1.6&nbsp;Replication and Binary Logging Options and Variables">Section&nbsp;16.1.6, “Replication and Binary Logging Options and Variables”</a>).
            </p><p style="color:blue;">默认中继日志文件和中继日志索引文件名可以分别用中继日志和中继日志索引系统变量覆盖（请参阅第16.1.6节“复制和二进制日志选项和变量”）。</p><p>
                If a slave uses the default host-based relay log file names,
                changing a slave's host name after replication has been set up
                can cause replication to fail with the errors <span class="errortext">Failed
        to open the relay log</span> and <span class="errortext">Could not find
        target log during relay log initialization</span>. This is
                a known issue (see Bug #2122). If you anticipate that a slave's
                host name might change in the future (for example, if networking
                is set up on the slave such that its host name can be modified
                using DHCP), you can avoid this issue entirely by using the
                <a class="link" href="replication.html#sysvar_relay_log"><code class="literal">relay_log</code></a> and
                <a class="link" href="replication.html#sysvar_relay_log_index"><code class="literal">relay_log_index</code></a> system
                variables to specify relay log file names explicitly when you
                initially set up the slave. This will make the names independent
                of server host name changes.
            </p><p style="color:blue;">如果从属服务器使用默认的基于主机的中继日志文件名，则在设置复制后更改从属服务器的主机名可能会导致复制失败，并出现错误：无法打开中继日志，并且在中继日志初始化期间找不到目标日志。这是一个已知问题（请参阅Bug 2122）。如果您预计从机的主机名将来可能会更改（例如，如果在从机上设置了网络，以便可以使用DHCP修改其主机名），则可以使用RELAY U LOG和RELAY U LOG U INDEX系统变量在最初设置从机时显式指定中继日志文件名，从而完全避免此问题。这将使名称独立于服务器主机名更改。</p><p>
                If you encounter the issue after replication has already begun,
                one way to work around it is to stop the slave server, prepend
                the contents of the old relay log index file to the new one, and
                then restart the slave. On a Unix system, this can be done as
                shown here:
            </p><p style="color:blue;">如果在复制已经开始后遇到此问题，解决此问题的一种方法是停止从属服务器，将旧中继日志索引文件的内容预先发送到新的中继日志索引文件，然后重新启动从属服务器。在Unix系统上，可以执行以下操作：</p><pre data-lang="terminal" class="programlisting">shell&gt; <strong class="userinput"><code>cat <em class="replaceable"><code>new_relay_log_name</code></em>.index &gt;&gt; <em class="replaceable"><code>old_relay_log_name</code></em>.index</code></strong>
shell&gt; <strong class="userinput"><code>mv <em class="replaceable"><code>old_relay_log_name</code></em>.index <em class="replaceable"><code>new_relay_log_name</code></em>.index</code></strong>
</pre><p>
                A slave server creates a new relay log file under the following
                conditions:
            </p><p style="color:blue;">从属服务器在以下条件下创建新的中继日志文件：</p>
                <div class="itemizedlist">
                    <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                        Each time the I/O thread starts.
                    </p><p style="color:blue;">每次I/O线程启动时。</p></li><li class="listitem"><p>
                        When the logs are flushed (for example, with
                        <a class="link" href="sql-syntax.html#flush-logs"><code class="literal">FLUSH LOGS</code></a> or
                        <a class="link" href="programs.html#mysqladmin" title="4.5.2&nbsp;mysqladmin — Client for Administering a MySQL Server"><span class="command"><strong>mysqladmin flush-logs</strong></span></a>).
                    </p><p style="color:blue;">刷新日志时（例如，使用刷新日志或mysqladmin刷新日志）。</p></li><li class="listitem"><p>
                        When the size of the current relay log file becomes
                        <span class="quote">“<span class="quote">too large,</span>”</span> determined as follows:
                    </p><p style="color:blue;">当当前中继日志文件的大小变得“太大”时，确定如下：</p>
                        <div class="itemizedlist">
                            <ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
                                If the value of
                                <a class="link" href="replication.html#sysvar_max_relay_log_size"><code class="literal">max_relay_log_size</code></a> is
                                greater than 0, that is the maximum relay log file size.
                            </p><p style="color:blue;">如果Max的RelayyLogLogyStand的值大于0，那就是最大的中继日志文件大小。</p></li><li class="listitem"><p>
                                If the value of
                                <a class="link" href="replication.html#sysvar_max_relay_log_size"><code class="literal">max_relay_log_size</code></a> is
                                0, <a class="link" href="replication.html#sysvar_max_binlog_size"><code class="literal">max_binlog_size</code></a>
                                determines the maximum relay log file size.
                            </p><p style="color:blue;">如果Max的RelayyLogLogyStand的值为0，则Max SnLogLogyStand确定最大中继日志文件大小。</p></li></ul>
                        </div>
                    </li></ul>
                </div>
                <p>
                    The SQL thread automatically deletes each relay log file after
                    it has executed all events in the file and no longer needs it.
                    There is no explicit mechanism for deleting relay logs because
                    the SQL thread takes care of doing so. However,
                    <a class="link" href="sql-syntax.html#flush-logs"><code class="literal">FLUSH LOGS</code></a> rotates relay logs,
                    which influences when the SQL thread deletes them.
                </p><p style="color:blue;">sql线程在执行了每个中继日志文件中的所有事件并且不再需要它之后，会自动删除该文件。由于sql线程负责删除中继日志，因此没有显式的删除机制。但是，刷新日志会旋转中继日志，这会影响sql线程删除它们的时间。</p>
            </div>
            <div class="section">
                <div class="titlepage">
                    <div>
                        <div>
                            <h4 class="title"><a name="slave-logs-status"></a>16.2.4.2&nbsp;Slave Status Logs</h4>

                        </div>

                    </div>

                </div>
                <p>
                    A replication slave server creates two logs. By default, these
                    logs are files named <code class="filename">master.info</code> and
                    <code class="filename">relay-log.info</code> and created in the data
                    directory. The names and locations of these files can be changed
                    by using the <a class="link" href="replication.html#option_mysqld_master-info-file"><code class="option">--master-info-file</code></a>
                    option and <a class="link" href="replication.html#sysvar_relay_log_info_file"><code class="literal">relay_log_info_file</code></a>
                    system variable, respectively. Either or both of these logs can
                    also be written to tables in the <code class="literal">mysql</code>
                    database by starting the server with the appropriate option: use
                    <a class="link" href="replication.html#option_mysqld_master-info-repository"><code class="option">--master-info-repository</code></a> to have
                    the master info log written to the
                    <code class="literal">mysql.slave_master_info</code> table, and use
                    <a class="link" href="replication.html#option_mysqld_relay-log-info-repository"><code class="option">--relay-log-info-repository</code></a> to
                    have the relay log info log written to the
                    <code class="literal">mysql.slave_relay_log_info</code> table. See
                    <a class="xref" href="replication.html#replication-options" title="16.1.6&nbsp;Replication and Binary Logging Options and Variables">Section&nbsp;16.1.6, “Replication and Binary Logging Options and Variables”</a>.
                </p><p style="color:blue;">复制从属服务器创建两个日志。默认情况下，这些日志是在数据目录中创建的名为master.info和relay-log.info的文件。这些文件的名称和位置可以分别使用--master info file选项和relay_log_info_file系统变量进行更改。通过使用适当的选项启动服务器，也可以将其中一个或两个日志写入mysql数据库中的表：使用--master info repository将master info日志写入mysql.slave_master_info表，并使用--relay log info repository将中继日志信息日志写入mysql.slave_relay_log_info表。见16.1.6节，“复制和二进制日志选项和变量”。</p><p>
                The two status logs contain information similar to that shown in
                the output of the <a class="link" href="sql-syntax.html#show-slave-status" title="13.7.5.34&nbsp;SHOW SLAVE STATUS Syntax"><code class="literal">SHOW SLAVE
                STATUS</code></a> statement, which is discussed in
                <a class="xref" href="sql-syntax.html#replication-slave-sql" title="13.4.2&nbsp;SQL Statements for Controlling Slave Servers">Section&nbsp;13.4.2, “SQL Statements for Controlling Slave Servers”</a>. Because the status logs
                are stored on disk, they survive a slave server's shutdown.
                The next time the slave starts up, it reads the two logs to
                determine how far it has proceeded in reading binary logs from
                the master and in processing its own relay logs.
            </p><p style="color:blue;">这两个状态日志包含的信息与show slave status语句输出中显示的信息类似，该语句在13.4.2节“控制从服务器的sql语句”中讨论。因为状态日志存储在磁盘上，所以它们在从属服务器关闭后仍然存在。下一次从机启动时，它读取两个日志，以确定从主机读取二进制日志和处理自己的中继日志的进度。</p><p>
                Access to the master info log file or table should be restricted
                because it contains the password for connecting to the master.
                See <a class="xref" href="security.html#password-logging" title="6.1.2.3&nbsp;Passwords and Logging">Section&nbsp;6.1.2.3, “Passwords and Logging”</a>.
            </p><p style="color:blue;">应限制对主信息日志文件或表的访问，因为它包含连接到主信息的密码。见第6.1.2.3节“密码和日志”。</p><p>
                If you set
                <a class="link" href="replication.html#sysvar_master_info_repository"><code class="literal">master_info_repository</code></a> and
                <a class="link" href="replication.html#sysvar_relay_log_info_repository"><code class="literal">relay_log_info_repository</code></a> to
                <code class="literal">TABLE</code>, the
                <code class="literal">mysql.slave_master_info</code> and
                <code class="literal">mysql.slave_relay_log_info</code> tables are created
                using the <a class="link" href="innodb-storage-engine.html" title="Chapter&nbsp;14&nbsp;The InnoDB Storage Engine"><code class="literal">InnoDB</code></a> transactional
                storage engine. As a table, updates to the relay log info log
                are committed together with the transactions, meaning that the
                slave's progress information recorded in that log is always
                consistent with what has been applied to the database, even in
                the event of an unexpected server halt. The
                <a class="link" href="replication.html#option_mysqld_relay-log-recovery"><code class="option">--relay-log-recovery</code></a> option must
                be enabled on the slave to guarantee resilience. For more
                details, see
                <a class="xref" href="replication.html#replication-solutions-unexpected-slave-halt" title="16.3.2&nbsp;Handling an Unexpected Halt of a Replication Slave">Section&nbsp;16.3.2, “Handling an Unexpected Halt of a Replication Slave”</a>.
            </p><p style="color:blue;">如果将master_info_repository和relay_log_info_repository设置为table，那么mysql.slave_master_info和mysql.slave_relay_log_info表将使用innodb事务存储引擎创建。作为一个表，对中继日志信息日志的更新与事务一起提交，这意味着该日志中记录的从属进程信息始终与应用于数据库的内容一致，即使在服务器意外停止的情况下也是如此。必须在从属服务器上启用--relay log recovery选项以确保恢复能力。有关更多详细信息，请参阅16.3.2节，“处理复制从机的意外停止”。</p><p>
                One additional slave status log is created primarily for
                internal use, and holds status information about worker threads
                on a multithreaded replication slave. This slave worker log
                includes the names and positions for the relay log file and
                master binary log file for each worker thread. If the relay log
                info log for the slave is created as a table, the slave worker
                log is written to the <code class="literal">mysql.slave_worker_info</code>
                table. If the relay log info log is written to a file, the slave
                worker log is written to the
                <code class="filename">worker-relay-log.info</code> file. For external
                use, status information for worker threads is presented in the
                Performance Schema
                <a class="link" href="performance-schema.html#replication-applier-status-by-worker-table" title="25.12.11.6&nbsp;The replication_applier_status_by_worker Table"><code class="literal">replication_applier_status_by_worker</code></a>
                table.
            </p><p style="color:blue;">另外一个从机状态日志主要是为内部使用而创建的，它保存多线程复制从机上工作线程的状态信息。此从属工作日志包括每个工作线程的中继日志文件和主二进制日志文件的名称和位置。如果将从机的中继日志信息日志创建为表，则从机工作日志将写入mysql.slave_worker_info表。如果中继日志信息日志写入文件，则从工作日志写入worker-relay-log.info文件。对于外部使用，工作线程的状态信息显示在performance schema replication_applier_status_by_worker表中。</p><p>
                The slave I/O thread updates the master info log. The following
                table shows the correspondence between the lines in the
                <code class="filename">master.info</code> file, the columns in the
                <code class="literal">mysql.slave_master_info</code> table, and the
                columns displayed by <a class="link" href="sql-syntax.html#show-slave-status" title="13.7.5.34&nbsp;SHOW SLAVE STATUS Syntax"><code class="literal">SHOW SLAVE
                STATUS</code></a>.
            </p><p style="color:blue;">从I/O线程更新主信息日志。下表显示了master.info文件中的行、mysql.slave_master_info表中的列和show slave status显示的列之间的对应关系。</p>
                <div class="informaltable">
                    <table summary="The correspondence between the lines in the master.info file, the columns in the mysql.slave_master_info table, and the columns displayed by SHOW SLAVE STATUS."><colgroup><col width="16%"><col width="31%"><col width="40%"><col width="18%"></colgroup><thead><tr>
                        <th scope="col"><code class="filename">master.info</code> File Line</th>
                        <th scope="col"><code class="literal">slave_master_info</code> Table Column</th>
                        <th scope="col"><code class="literal">SHOW SLAVE STATUS</code> Column</th>
                        <th scope="col">Description</th>
                    </tr></thead><tbody><tr>
                        <td scope="row">1</td>
                        <td><code class="literal">Number_of_lines</code></td>
                        <td>[None]</td>
                        <td>Number of lines in the file, or columns in the table</td>
                    </tr><tr>
                        <td scope="row">2</td>
                        <td><code class="literal">Master_log_name</code></td>
                        <td><code class="literal">Master_Log_File</code></td>
                        <td>The name of the master binary log currently being read from the master</td>
                    </tr><tr>
                        <td scope="row">3</td>
                        <td><code class="literal">Master_log_pos</code></td>
                        <td><code class="literal">Read_Master_Log_Pos</code></td>
                        <td>The current position within the master binary log that have been read
                            from the master</td>
                    </tr><tr>
                        <td scope="row">4</td>
                        <td><code class="literal">Host</code></td>
                        <td><code class="literal">Master_Host</code></td>
                        <td>The host name of the master</td>
                    </tr><tr>
                        <td scope="row">5</td>
                        <td><code class="literal">User_name</code></td>
                        <td><code class="literal">Master_User</code></td>
                        <td>The user name used to connect to the master</td>
                    </tr><tr>
                        <td scope="row">6</td>
                        <td><code class="literal">User_password</code></td>
                        <td>Password (not shown by <a class="link" href="sql-syntax.html#show-slave-status" title="13.7.5.34&nbsp;SHOW SLAVE STATUS Syntax"><code class="literal">SHOW SLAVE STATUS</code></a>)</td>
                        <td>The password used to connect to the master</td>
                    </tr><tr>
                        <td scope="row">7</td>
                        <td><code class="literal">Port</code></td>
                        <td><code class="literal">Master_Port</code></td>
                        <td>The network port used to connect to the master</td>
                    </tr><tr>
                        <td scope="row">8</td>
                        <td><code class="literal">Connect_retry</code></td>
                        <td><code class="literal">Connect_Retry</code></td>
                        <td>The period (in seconds) that the slave will wait before trying to
                            reconnect to the master</td>
                    </tr><tr>
                        <td scope="row">9</td>
                        <td><code class="literal">Enabled_ssl</code></td>
                        <td><code class="literal">Master_SSL_Allowed</code></td>
                        <td>Indicates whether the server supports SSL connections</td>
                    </tr><tr>
                        <td scope="row">10</td>
                        <td><code class="literal">Ssl_ca</code></td>
                        <td><code class="literal">Master_SSL_CA_File</code></td>
                        <td>The file used for the Certificate Authority (CA) certificate</td>
                    </tr><tr>
                        <td scope="row">11</td>
                        <td><code class="literal">Ssl_capath</code></td>
                        <td><code class="literal">Master_SSL_CA_Path</code></td>
                        <td>The path to the Certificate Authority (CA) certificates</td>
                    </tr><tr>
                        <td scope="row">12</td>
                        <td><code class="literal">Ssl_cert</code></td>
                        <td><code class="literal">Master_SSL_Cert</code></td>
                        <td>The name of the SSL certificate file</td>
                    </tr><tr>
                        <td scope="row">13</td>
                        <td><code class="literal">Ssl_cipher</code></td>
                        <td><code class="literal">Master_SSL_Cipher</code></td>
                        <td>The list of possible ciphers used in the handshake for the SSL
                            connection</td>
                    </tr><tr>
                        <td scope="row">14</td>
                        <td><code class="literal">Ssl_key</code></td>
                        <td><code class="literal">Master_SSL_Key</code></td>
                        <td>The name of the SSL key file</td>
                    </tr><tr>
                        <td scope="row">15</td>
                        <td><code class="literal">Ssl_verify_server_cert</code></td>
                        <td><code class="literal">Master_SSL_Verify_Server_Cert</code></td>
                        <td>Whether to verify the server certificate</td>
                    </tr><tr>
                        <td scope="row">16</td>
                        <td><code class="literal">Heartbeat</code></td>
                        <td>[None]</td>
                        <td>Interval between replication heartbeats, in seconds</td>
                    </tr><tr>
                        <td scope="row">17</td>
                        <td><code class="literal">Bind</code></td>
                        <td><code class="literal">Master_Bind</code></td>
                        <td>Which of the slave's network interfaces should be used for
                            connecting to the master</td>
                    </tr><tr>
                        <td scope="row">18</td>
                        <td><code class="literal">Ignored_server_ids</code></td>
                        <td><code class="literal">Replicate_Ignore_Server_Ids</code></td>
                        <td>The list of server IDs to be ignored. Note that for
                            <code class="literal">Ignored_server_ids</code> the list of server
                            IDs is preceded by the total number of server IDs to
                            ignore.</td>
                    </tr><tr>
                        <td scope="row">19</td>
                        <td><code class="literal">Uuid</code></td>
                        <td><code class="literal">Master_UUID</code></td>
                        <td>The master's unique ID</td>
                    </tr><tr>
                        <td scope="row">20</td>
                        <td><code class="literal">Retry_count</code></td>
                        <td><code class="literal">Master_Retry_Count</code></td>
                        <td>Maximum number of reconnection attempts permitted</td>
                    </tr><tr>
                        <td scope="row">21</td>
                        <td><code class="literal">Ssl_crl</code></td>
                        <td>[None]</td>
                        <td>Path to an SSL certificate revocation-list file</td>
                    </tr><tr>
                        <td scope="row">22</td>
                        <td><code class="literal">Ssl_crl_path</code></td>
                        <td>[None]</td>
                        <td>Path to a directory containing SSL certificate revocation-list files</td>
                    </tr><tr>
                        <td scope="row">23</td>
                        <td><code class="literal">Enabled_auto_position</code></td>
                        <td><code class="literal">Auto_position</code></td>
                        <td>If autopositioning is in use or not</td>
                    </tr><tr>
                        <td scope="row">24</td>
                        <td><code class="literal">Channel_name</code></td>
                        <td><code class="literal">Channel_name</code></td>
                        <td>The name of the replication channel</td>
                    </tr><tr>
                        <td scope="row">25</td>
                        <td><code class="literal">Tls_Version</code></td>
                        <td><code class="literal">Master_TLS_Version</code></td>
                        <td>TLS version on master</td>
                    </tr></tbody></table>
                </div>
                <p>
                    The slave SQL thread updates the relay log info log. The
                    <code class="filename">relay-log.info</code> file includes a line count
                    and a replication delay value. The following table shows the
                    correspondence between the lines in the
                    <code class="filename">relay-log.info</code> file, the columns in the
                    <code class="literal">mysql.slave_relay_log_info</code> table, and the
                    columns displayed by <a class="link" href="sql-syntax.html#show-slave-status" title="13.7.5.34&nbsp;SHOW SLAVE STATUS Syntax"><code class="literal">SHOW SLAVE
                    STATUS</code></a>.
                </p><p style="color:blue;">从sql线程更新中继日志信息日志。relay-log.info文件包含一个行计数和一个复制延迟值。下表显示了relay-log.info文件中的行、mysql.slave_relay_log_info表中的列和show slave status显示的列之间的对应关系。</p>
                <div class="informaltable">
                    <table summary="The correspondence between the lines in the relay-log.info file, the columns in the mysql.slave_relay_log_info table, and the columns displayed by SHOW SLAVE STATUS."><colgroup><col width="15%"><col width="30%"><col width="40%"><col width="20%"></colgroup><thead><tr>
                        <th scope="col">Line in <code class="filename">relay-log.info</code></th>
                        <th scope="col"><code class="literal">slave_relay_log_info</code> Table Column</th>
                        <th scope="col"><code class="literal">SHOW SLAVE STATUS</code> Column</th>
                        <th scope="col">Description</th>
                    </tr></thead><tbody><tr>
                        <td scope="row">1</td>
                        <td><code class="literal">Number_of_lines</code></td>
                        <td>[None]</td>
                        <td>Number of lines in the file or columns in the table</td>
                    </tr><tr>
                        <td scope="row">2</td>
                        <td><code class="literal">Relay_log_name</code></td>
                        <td><code class="literal">Relay_Log_File</code></td>
                        <td>The name of the current relay log file</td>
                    </tr><tr>
                        <td scope="row">3</td>
                        <td><code class="literal">Relay_log_pos</code></td>
                        <td><code class="literal">Relay_Log_Pos</code></td>
                        <td>The current position within the relay log file; events up to this
                            position have been executed on the slave database</td>
                    </tr><tr>
                        <td scope="row">4</td>
                        <td><code class="literal">Master_log_name</code></td>
                        <td><code class="literal">Relay_Master_Log_File</code></td>
                        <td>The name of the master binary log file from which the events in the
                            relay log file were read</td>
                    </tr><tr>
                        <td scope="row">5</td>
                        <td><code class="literal">Master_log_pos</code></td>
                        <td><code class="literal">Exec_Master_Log_Pos</code></td>
                        <td>The equivalent position within the master's binary log file of events
                            that have already been executed</td>
                    </tr><tr>
                        <td scope="row">6</td>
                        <td><code class="literal">Sql_delay</code></td>
                        <td><code class="literal">SQL_Delay</code></td>
                        <td>The number of seconds that the slave must lag the master</td>
                    </tr><tr>
                        <td scope="row">7</td>
                        <td><code class="literal">Number_of_workers</code></td>
                        <td>[None]</td>
                        <td>The number of slave worker threads for executing replication events
                            (transactions) in parallel</td>
                    </tr><tr>
                        <td scope="row">8</td>
                        <td><code class="literal">Id</code></td>
                        <td>[None]</td>
                        <td>ID used for internal purposes; currently this is always 1</td>
                    </tr><tr>
                        <td scope="row">9</td>
                        <td><code class="literal">Channel_name</code></td>
                        <td>Channel_name</td>
                        <td>The name of the replication channel</td>
                    </tr></tbody></table>
                </div>
                <p>
                    In versions of MySQL prior to MySQL 5.6, the
                    <code class="filename">relay-log.info</code> file does not include a line
                    count or a delay value (and the
                    <code class="literal">slave_relay_log_info</code> table is not available).
                </p><p style="color:blue;">在mysql 5.6之前的mysql版本中，relay-log.info文件不包含行计数或延迟值（slave_relay_log_info表不可用）。</p>
                <div class="informaltable">
                    <table summary="The correspondence between lines in the relay-log.info file and items that appear in the Status column."><colgroup><col width="15%"><col width="35%"><col width="50%"></colgroup><thead><tr>
                        <th scope="col">Line</th>
                        <th scope="col">Status Column</th>
                        <th scope="col">Description</th>
                    </tr></thead><tbody><tr>
                        <td scope="row">1</td>
                        <td><code class="literal">Relay_Log_File</code></td>
                        <td>The name of the current relay log file</td>
                    </tr><tr>
                        <td scope="row">2</td>
                        <td><code class="literal">Relay_Log_Pos</code></td>
                        <td>The current position within the relay log file; events up to this
                            position have been executed on the slave database</td>
                    </tr><tr>
                        <td scope="row">3</td>
                        <td><code class="literal">Relay_Master_Log_File</code></td>
                        <td>The name of the master binary log file from which the events in the
                            relay log file were read</td>
                    </tr><tr>
                        <td scope="row">4</td>
                        <td><code class="literal">Exec_Master_Log_Pos</code></td>
                        <td>The equivalent position within the master's binary log file of events
                            that have already been executed</td>
                    </tr></tbody></table>
                </div>
                <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">
                    <div class="admon-title">
                        Note
                    </div>
                    <p>
                        If you downgrade a slave server to a version older than MySQL
                        5.6, the older server does not read the
                        <code class="filename">relay-log.info</code> file correctly. To address
                        this, modify the file in a text editor by deleting the initial
                        line containing the number of lines.
                    </p><p style="color:blue;">如果将从属服务器降级到mysql 5.6之前的版本，则旧服务器无法正确读取relay-log.info文件。要解决此问题，请在文本编辑器中通过删除包含行数的初始行来修改文件。</p>
                </div>
                <p>
                    The contents of the <code class="filename">relay-log.info</code> file and
                    the states shown by the <a class="link" href="sql-syntax.html#show-slave-status" title="13.7.5.34&nbsp;SHOW SLAVE STATUS Syntax"><code class="literal">SHOW SLAVE
                    STATUS</code></a> statement might not match if the
                    <code class="filename">relay-log.info</code> file has not been flushed to
                    disk. Ideally, you should only view
                    <code class="filename">relay-log.info</code> on a slave that is offline
                    (that is, <code class="literal">mysqld</code> is not running). For a
                    running system, you can use <a class="link" href="sql-syntax.html#show-slave-status" title="13.7.5.34&nbsp;SHOW SLAVE STATUS Syntax"><code class="literal">SHOW SLAVE
                    STATUS</code></a>, or query the
                    <code class="literal">slave_master_info</code> and
                    <code class="literal">slave_relay_log_info</code> tables if you are
                    writing the status logs to tables.
                </p><p style="color:blue;">如果没有将relay-log.info文件刷新到磁盘，则relay-log.info文件的内容和show slave status语句显示的状态可能不匹配。理想情况下，您应该只在离线的从机上查看relay-log.info（也就是说，mysqld没有运行）。对于正在运行的系统，如果要将状态日志写入表，则可以使用show slave status或查询slave_master_info和slave_relay_log_info表。</p><p>
                When you back up the slave's data, you should back up these
                two status logs, along with the relay log files. The status logs
                are needed to resume replication after you restore the data from
                the slave. If you lose the relay logs but still have the relay
                log info log, you can check it to determine how far the SQL
                thread has executed in the master binary logs. Then you can use
                <a class="link" href="sql-syntax.html#change-master-to" title="13.4.2.1&nbsp;CHANGE MASTER TO Syntax"><code class="literal">CHANGE MASTER TO</code></a> with the
                <code class="literal">MASTER_LOG_FILE</code> and
                <code class="literal">MASTER_LOG_POS</code> options to tell the slave to
                re-read the binary logs from that point. Of course, this
                requires that the binary logs still exist on the master.
            </p><p style="color:blue;">备份从机数据时，应备份这两个状态日志以及中继日志文件。从从属服务器还原数据后，需要状态日志来恢复复制。如果丢失了中继日志，但仍有中继日志信息日志，则可以检查该日志以确定SQL线程在主二进制日志中执行的距离。然后，您可以使用change master to with the master_log_file和master_log_pos选项，告诉从服务器从此点重新读取二进制日志。当然，这要求二进制日志仍然存在于主机上。</p>
            </div>

        </div>
        <div class="section">
            <div class="titlepage">
                <div>
                    <div>
                        <h3 class="title"><a name="replication-rules"></a>16.2.5&nbsp;How Servers Evaluate Replication Filtering Rules</h3>

                    </div>

                </div>

            </div>
            <div class="toc">
                <dl class="toc"><dt><span class="section"><a href="replication.html#replication-rules-db-options">16.2.5.1 Evaluation of Database-Level Replication and Binary Logging Options</a></span></dt><dt><span class="section"><a href="replication.html#replication-rules-table-options">16.2.5.2 Evaluation of Table-Level Replication Options</a></span></dt><dt><span class="section"><a href="replication.html#replication-rules-examples">16.2.5.3 Replication Rule Application</a></span></dt></dl>
            </div>
            <p>
                If a master server does not write a statement to its binary log,
                the statement is not replicated. If the server does log the
                statement, the statement is sent to all slaves and each slave
                determines whether to execute it or ignore it.
            </p><p style="color:blue;">如果主服务器未将语句写入其二进制日志，则不会复制该语句。如果服务器确实记录了该语句，则该语句将发送给所有从机，每个从机决定是执行还是忽略它。</p><p>
            On the master, you can control which databases to log changes for
            by using the <a class="link" href="replication.html#option_mysqld_binlog-do-db"><code class="option">--binlog-do-db</code></a> and
            <a class="link" href="replication.html#option_mysqld_binlog-ignore-db"><code class="option">--binlog-ignore-db</code></a> options to
            control binary logging. For a description of the rules that
            servers use in evaluating these options, see
            <a class="xref" href="replication.html#replication-rules-db-options" title="16.2.5.1&nbsp;Evaluation of Database-Level Replication and Binary Logging Options">Section&nbsp;16.2.5.1, “Evaluation of Database-Level Replication and Binary Logging Options”</a>. You should not use
            these options to control which databases and tables are
            replicated. Instead, use filtering on the slave to control the
            events that are executed on the slave.
        </p><p style="color:blue;">在master上，可以使用--binlog do db和--binlog ignore db选项控制二进制日志记录，从而控制要记录更改的数据库。有关服务器在评估这些选项时使用的规则的说明，请参阅第16.2.5.1节“数据库级复制和二进制日志记录选项的评估”。不应使用这些选项来控制复制哪些数据库和表。相反，在从机上使用过滤来控制在从机上执行的事件。</p><p>
            On the slave side, decisions about whether to execute or ignore
            statements received from the master are made according to the
            <code class="option">--replicate-*</code> options that the slave was started
            with. (See <a class="xref" href="replication.html#replication-options" title="16.1.6&nbsp;Replication and Binary Logging Options and Variables">Section&nbsp;16.1.6, “Replication and Binary Logging Options and Variables”</a>.) The filters
            governed by these options can also be set dynamically using the
            <code class="literal">CHANGE REPLICATION FILTER</code> statement. The rules
            governing such filters are the same whether they are created on
            startup using <code class="option">--replicate-*</code> options or while the
            slave server is running by <code class="literal">CHANGE REPLICATION
            FILTER</code>. Note that replication filters cannot be used on
            a MySQL server instance that is configured for Group Replication,
            because filtering transactions on some servers would make the
            group unable to reach agreement on a consistent state.
        </p><p style="color:blue;">在从机端，决定是执行还是忽略从主机接收的语句是根据从机启动时使用的--replicate-*选项做出的。（请参阅16.1.6节，“复制和二进制日志选项和变量”。）由这些选项控制的筛选器也可以使用change replication filter语句动态设置。无论是在启动时使用--replicate-*选项创建这些筛选器，还是在从属服务器运行时使用change replication filter，管理这些筛选器的规则都是相同的。注意，不能在为组复制配置的mysql服务器实例上使用复制筛选器，因为在某些服务器上筛选事务将使组无法就一致状态达成一致。</p><p>
            In the simplest case, when there are no
            <code class="option">--replicate-*</code> options, the slave executes all
            statements that it receives from the master. Otherwise, the result
            depends on the particular options given.
        </p><p style="color:blue;">在最简单的情况下，当没有--replicate-*选项时，从机执行从主机接收的所有语句。否则，结果取决于给定的特定选项。</p><p>
            Database-level options
            (<a class="link" href="replication.html#option_mysqld_replicate-do-db"><code class="option">--replicate-do-db</code></a>,
            <a class="link" href="replication.html#option_mysqld_replicate-ignore-db"><code class="option">--replicate-ignore-db</code></a>) are checked
            first; see <a class="xref" href="replication.html#replication-rules-db-options" title="16.2.5.1&nbsp;Evaluation of Database-Level Replication and Binary Logging Options">Section&nbsp;16.2.5.1, “Evaluation of Database-Level Replication and Binary Logging Options”</a>, for a
            description of this process. If no database-level options are
            used, option checking proceeds to any table-level options that may
            be in use (see <a class="xref" href="replication.html#replication-rules-table-options" title="16.2.5.2&nbsp;Evaluation of Table-Level Replication Options">Section&nbsp;16.2.5.2, “Evaluation of Table-Level Replication Options”</a>,
            for a discussion of these). If one or more database-level options
            are used but none are matched, the statement is not replicated.
        </p><p style="color:blue;">首先选中数据库级选项（--replicate do db，--replicate ignore db）；有关此过程的说明，请参阅第16.2.5.1节“数据库级复制和二进制日志记录选项的评估”。如果未使用任何数据库级选项，则选项检查将转到可能正在使用的任何表级选项（有关这些选项的讨论，请参阅第16.2.5.2节“表级复制选项的评估”）。如果使用了一个或多个数据库级选项，但没有匹配的选项，则不复制该语句。</p><p>
            For statements affecting databases only (that is,
            <a class="link" href="sql-syntax.html#create-database" title="13.1.11&nbsp;CREATE DATABASE Syntax"><code class="literal">CREATE DATABASE</code></a>,
            <a class="link" href="sql-syntax.html#drop-database" title="13.1.22&nbsp;DROP DATABASE Syntax"><code class="literal">DROP DATABASE</code></a>, and
            <a class="link" href="sql-syntax.html#alter-database" title="13.1.1&nbsp;ALTER DATABASE Syntax"><code class="literal">ALTER DATABASE</code></a>), database-level
            options always take precedence over any
            <a class="link" href="replication.html#option_mysqld_replicate-wild-do-table"><code class="option">--replicate-wild-do-table</code></a> options.
            In other words, for such statements,
            <a class="link" href="replication.html#option_mysqld_replicate-wild-do-table"><code class="option">--replicate-wild-do-table</code></a> options
            are checked if and only if there are no database-level options
            that apply. This is a change in behavior from previous versions of
            MySQL, where the statement
            <a class="link" href="sql-syntax.html#create-database" title="13.1.11&nbsp;CREATE DATABASE Syntax"><code class="literal">CREATE DATABASE
                dbx</code></a> was not replicated if the slave had been started
            with <a class="link" href="replication.html#option_mysqld_replicate-do-db"><code class="option">--replicate-do-db=dbx</code></a>
            <a class="link" href="replication.html#option_mysqld_replicate-wild-do-table"><code class="option">--replicate-wild-do-table=db%.t1</code></a>.
            (Bug #46110)
        </p><p style="color:blue;">对于仅影响数据库的语句（即CREATE DATABASE、DROP DATABASE和ALTER DATABASE），数据库级选项始终优先于任何--REPLETE WILD do table选项。换言之，对于此类语句，-replicate wild do table options在且仅当没有应用的数据库级选项时才被选中。这是MySQL以前版本的行为变化，在MySQL中，如果从机是以--replicate do db=dbx--replicate wild do table=db%.t1启动的，则不会复制CREATE DATABASE dbx语句。（错误46110）</p><p>
            To make it easier to determine what effect an option set will
            have, it is recommended that you avoid mixing <span class="quote">“<span class="quote">do</span>”</span>
            and <span class="quote">“<span class="quote">ignore</span>”</span> options, or wildcard and nonwildcard
            options.
        </p><p style="color:blue;">为了更容易确定选项集会产生什么效果，建议避免混合“DO”和“忽略”选项，或者通配符和非通配符选项。</p><p>
            If any <a class="link" href="replication.html#option_mysqld_replicate-rewrite-db"><code class="option">--replicate-rewrite-db</code></a>
            options were specified, they are applied before the
            <code class="option">--replicate-*</code> filtering rules are tested.
        </p><p style="color:blue;">如果指定了任何--replicate rewrite db选项，则在测试--replicate-*筛选规则之前应用这些选项。</p><a class="indexterm" name="idm140286793542576"></a><a class="indexterm" name="idm140286793541072"></a>
            <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">

                <div class="admon-title">
                    Note
                </div>
                <p>
                    All replication filtering options follow the same rules for case
                    sensitivity that apply to names of databases and tables
                    elsewhere in the MySQL server, including the effects of the
                    <a class="link" href="server-administration.html#sysvar_lower_case_table_names"><code class="literal">lower_case_table_names</code></a> system
                    variable.
                </p><p style="color:blue;">对于区分大小写，所有复制筛选选项都遵循适用于mysql服务器中其他数据库和表的名称的相同规则，包括小写字母table的系统变量的效果。</p>
            </div>
            <div class="section">
                <div class="titlepage">
                    <div>
                        <div>
                            <h4 class="title"><a name="replication-rules-db-options"></a>16.2.5.1&nbsp;Evaluation of Database-Level Replication and Binary Logging Options</h4>

                        </div>

                    </div>

                </div>
                <p>
                    When evaluating replication options, the slave begins by
                    checking to see whether there are any
                    <a class="link" href="replication.html#option_mysqld_replicate-do-db"><code class="option">--replicate-do-db</code></a> or
                    <a class="link" href="replication.html#option_mysqld_replicate-ignore-db"><code class="option">--replicate-ignore-db</code></a> options
                    that apply. When using
                    <a class="link" href="replication.html#option_mysqld_binlog-do-db"><code class="option">--binlog-do-db</code></a> or
                    <a class="link" href="replication.html#option_mysqld_binlog-ignore-db"><code class="option">--binlog-ignore-db</code></a>, the process
                    is similar, but the options are checked on the master.
                </p><p style="color:blue;">在评估复制选项时，从服务器首先检查是否有应用的--replicate do db或--replicate ignore db选项。当使用--binlog do db或--binlog ignore db时，过程类似，但在master上选中了选项。</p><p>
                The database that is checked for a match depends on the binary
                log format of the statement that is being handled. If the
                statement has been logged using the row format, the database
                where data is to be changed is the database that is checked. If
                the statement has been logged using the statement format, the
                default database (specified with a
                <a class="link" href="sql-syntax.html#use" title="13.8.4&nbsp;USE Syntax"><code class="literal">USE</code></a> statement) is the database
                that is checked.
            </p><p style="color:blue;">检查是否匹配的数据库取决于正在处理的语句的二进制日志格式。如果已使用行格式记录语句，则要更改数据的数据库是已检查的数据库。如果已使用语句格式记录语句，则默认数据库（使用use语句指定）是选中的数据库。</p>
                <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">

                    <div class="admon-title">
                        Note
                    </div>
                    <p>
                        Only DML statements can be logged using the row format. DDL
                        statements are always logged as statements, even when
                        <a class="link" href="replication.html#sysvar_binlog_format"><code class="literal">binlog_format=ROW</code></a>. All DDL
                        statements are therefore always filtered according to the
                        rules for statement-based replication. This means that you
                        must select the default database explicitly with a
                        <a class="link" href="sql-syntax.html#use" title="13.8.4&nbsp;USE Syntax"><code class="literal">USE</code></a> statement in order for a
                        DDL statement to be applied.
                    </p><p style="color:blue;">只能使用行格式记录DML语句。DDL语句总是作为语句记录，即使binlog_format=row。因此，所有ddl语句总是根据基于语句的复制规则进行筛选。这意味着您必须使用use语句显式地选择默认数据库，以便应用ddl语句。</p>
                </div>
                <p>
                    For replication, the steps involved are listed here:
                </p><p style="color:blue;">对于复制，所涉及的步骤如下所示：</p>
                <div class="orderedlist">
                    <ol class="orderedlist" type="1"><li class="listitem"><p>
                        Which logging format is used?
                    </p><p style="color:blue;">使用哪种日志格式？</p>
                        <div class="itemizedlist">
                            <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><b>STATEMENT.&nbsp;</b>
                                Test the default database.
                            </p><p style="color:blue;">陈述。测试默认数据库。</p></li><li class="listitem"><p><b>ROW.&nbsp;</b>
                                Test the database affected by the changes.
                            </p><p style="color:blue;">划船。测试受更改影响的数据库。</p></li></ul>
                        </div>
                    </li><li class="listitem"><p>
                        Are there any
                        <a class="link" href="replication.html#option_mysqld_replicate-do-db"><code class="option">--replicate-do-db</code></a> options?
                    </p><p style="color:blue;">有没有——复制数据库选项？</p>
                        <div class="itemizedlist">
                            <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><b>Yes.&nbsp;</b>
                                Does the database match any of them?

                            </p><p style="color:blue;">对。数据库与其中任何一个匹配吗？</p>
                                <div class="itemizedlist">
                                    <ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p><b>Yes.&nbsp;</b>
                                        Continue to Step 4.
                                    </p><p style="color:blue;">对。继续执行步骤4。</p></li><li class="listitem"><p><b>No.&nbsp;</b>
                                        Ignore the update and exit.
                                    </p><p style="color:blue;">不，忽略更新并退出。</p></li></ul>
                                </div>
                                <p>
                                </p></li><li class="listitem"><p><b>No.&nbsp;</b>
                                Continue to step 3.
                            </p><p style="color:blue;">不，继续第3步。</p></li></ul>
                        </div>
                    </li><li class="listitem"><p>
                        Are there any
                        <a class="link" href="replication.html#option_mysqld_replicate-ignore-db"><code class="option">--replicate-ignore-db</code></a>
                        options?
                    </p><p style="color:blue;">是否有--复制忽略数据库选项？</p>
                        <div class="itemizedlist">
                            <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><b>Yes.&nbsp;</b>
                                Does the database match any of them?

                            </p><p style="color:blue;">对。数据库与其中任何一个匹配吗？</p>
                                <div class="itemizedlist">
                                    <ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p><b>Yes.&nbsp;</b>
                                        Ignore the update and exit.
                                    </p><p style="color:blue;">对。忽略更新并退出。</p></li><li class="listitem"><p><b>No.&nbsp;</b>
                                        Continue to step 4.
                                    </p><p style="color:blue;">不，继续第4步。</p></li></ul>
                                </div>
                                <p>
                                </p></li><li class="listitem"><p><b>No.&nbsp;</b>
                                Continue to step 4.
                            </p><p style="color:blue;">不，继续第4步。</p></li></ul>
                        </div>
                    </li><li class="listitem"><p>
                        Proceed to checking the table-level replication options, if
                        there are any. For a description of how these options are
                        checked, see
                        <a class="xref" href="replication.html#replication-rules-table-options" title="16.2.5.2&nbsp;Evaluation of Table-Level Replication Options">Section&nbsp;16.2.5.2, “Evaluation of Table-Level Replication Options”</a>.
                    </p><p style="color:blue;">继续检查表级复制选项（如果有）。有关如何选中这些选项的说明，请参阅第16.2.5.2节“表级复制选项的评估”。</p>
                        <div class="important" style="margin-left: 0.5in; margin-right: 0.5in;">

                            <div class="admon-title">
                                Important
                            </div>
                            <p>
                                A statement that is still permitted at this stage is not
                                yet actually executed. The statement is not executed until
                                all table-level options (if any) have also been checked,
                                and the outcome of that process permits execution of the
                                statement.
                            </p><p style="color:blue;">在此阶段仍然允许的语句尚未实际执行。在检查完所有表级选项（如果有的话）之后，才执行该语句，并且该过程的结果允许执行该语句。</p>
                        </div>
                    </li></ol>
                </div>
                <p>
                    For binary logging, the steps involved are listed here:
                </p><p style="color:blue;">对于二进制日志记录，所涉及的步骤如下所示：</p>
                <div class="orderedlist">
                    <ol class="orderedlist" type="1"><li class="listitem"><p>
                        Are there any <a class="link" href="replication.html#option_mysqld_binlog-do-db"><code class="option">--binlog-do-db</code></a>
                        or <a class="link" href="replication.html#option_mysqld_binlog-ignore-db"><code class="option">--binlog-ignore-db</code></a>
                        options?
                    </p><p style="color:blue;">是否有--binlog do db或--binlog ignore db选项？</p>
                        <div class="itemizedlist">
                            <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><b>Yes.&nbsp;</b>
                                Continue to step 2.
                            </p><p style="color:blue;">对。继续执行步骤2。</p></li><li class="listitem"><p><b>No.&nbsp;</b>
                                Log the statement and exit.
                            </p><p style="color:blue;">不，记录语句并退出。</p></li></ul>
                        </div>
                    </li><li class="listitem"><p>
                        Is there a default database (has any database been selected
                        by <a class="link" href="sql-syntax.html#use" title="13.8.4&nbsp;USE Syntax"><code class="literal">USE</code></a>)?
                    </p><p style="color:blue;">是否有默认数据库（是否已使用选择了任何数据库）？</p>
                        <div class="itemizedlist">
                            <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><b>Yes.&nbsp;</b>
                                Continue to step 3.
                            </p><p style="color:blue;">对。继续执行步骤3。</p></li><li class="listitem"><p><b>No.&nbsp;</b>
                                Ignore the statement and exit.
                            </p><p style="color:blue;">不，忽略声明并退出。</p></li></ul>
                        </div>
                    </li><li class="listitem"><p>
                        There is a default database. Are there any
                        <a class="link" href="replication.html#option_mysqld_binlog-do-db"><code class="option">--binlog-do-db</code></a> options?
                    </p><p style="color:blue;">有一个默认数据库。有什么--binlog do db选项吗？</p>
                        <div class="itemizedlist">
                            <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><b>Yes.&nbsp;</b>
                                Do any of them match the database?

                            </p><p style="color:blue;">对。有没有和数据库匹配的？</p>
                                <div class="itemizedlist">
                                    <ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p><b>Yes.&nbsp;</b>
                                        Log the statement and exit.
                                    </p><p style="color:blue;">对。记录语句并退出。</p></li><li class="listitem"><p><b>No.&nbsp;</b>
                                        Ignore the statement and exit.
                                    </p><p style="color:blue;">不，忽略声明并退出。</p></li></ul>
                                </div>
                                <p>
                                </p></li><li class="listitem"><p><b>No.&nbsp;</b>
                                Continue to step 4.
                            </p><p style="color:blue;">不，继续第4步。</p></li></ul>
                        </div>
                    </li><li class="listitem"><p>
                        Do any of the
                        <a class="link" href="replication.html#option_mysqld_binlog-ignore-db"><code class="option">--binlog-ignore-db</code></a> options
                        match the database?
                    </p><p style="color:blue;">是否有任何--binlog ignore db选项与数据库匹配？</p>
                        <div class="itemizedlist">
                            <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><b>Yes.&nbsp;</b>
                                Ignore the statement and exit.
                            </p><p style="color:blue;">对。忽略语句并退出。</p></li><li class="listitem"><p><b>No.&nbsp;</b>
                                Log the statement and exit.
                            </p><p style="color:blue;">不，记录语句并退出。</p></li></ul>
                        </div>
                    </li></ol>
                </div>
                <div class="important" style="margin-left: 0.5in; margin-right: 0.5in;">
                    <div class="admon-title">
                        Important
                    </div>
                    <p>
                        For statement-based logging, an exception is made in the rules
                        just given for the <a class="link" href="sql-syntax.html#create-database" title="13.1.11&nbsp;CREATE DATABASE Syntax"><code class="literal">CREATE
                        DATABASE</code></a>, <a class="link" href="sql-syntax.html#alter-database" title="13.1.1&nbsp;ALTER DATABASE Syntax"><code class="literal">ALTER
                        DATABASE</code></a>, and <a class="link" href="sql-syntax.html#drop-database" title="13.1.22&nbsp;DROP DATABASE Syntax"><code class="literal">DROP
                        DATABASE</code></a> statements. In those cases, the database
                        being <span class="emphasis"><em>created, altered, or dropped</em></span>
                        replaces the default database when determining whether to log
                        or ignore updates.
                    </p><p style="color:blue;">对于基于语句的日志记录，在刚才为create database、alter database和drop database语句指定的规则中发生异常。在这些情况下，在确定是否记录或忽略更新时，正在创建、更改或删除的数据库将替换默认数据库。</p>
                </div>
                <p>
                    <a class="link" href="replication.html#option_mysqld_binlog-do-db"><code class="option">--binlog-do-db</code></a> can sometimes mean
                    <span class="quote">“<span class="quote">ignore other databases</span>”</span>. For example, when using
                    statement-based logging, a server running with only
                    <a class="link" href="replication.html#option_mysqld_binlog-do-db"><code class="option">--binlog-do-db=sales</code></a> does not
                    write to the binary log statements for which the default
                    database differs from <code class="literal">sales</code>. When using
                    row-based logging with the same option, the server logs only
                    those updates that change data in <code class="literal">sales</code>.
                </p><p style="color:blue;">--binlog do db有时意味着“忽略其他数据库”。例如，当使用基于语句的日志记录时，仅使用--binlog do db=sales运行的服务器不会写入默认数据库与sales不同的二进制日志语句。当使用基于行的日志记录和相同的选项时，服务器只记录那些更改销售数据的更新。</p>
            </div>
            <div class="section">
                <div class="titlepage">
                    <div>
                        <div>
                            <h4 class="title"><a name="replication-rules-table-options"></a>16.2.5.2&nbsp;Evaluation of Table-Level Replication Options</h4>

                        </div>

                    </div>

                </div>
                <p>
                    The slave checks for and evaluates table options only if either
                    of the following two conditions is true:
                </p><p style="color:blue;">仅当以下两个条件中的任何一个为真时，slave才检查和计算表选项：</p>
                <div class="itemizedlist">
                    <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                        No matching database options were found.
                    </p><p style="color:blue;">找不到匹配的数据库选项。</p></li><li class="listitem"><p>
                        One or more database options were found, and were evaluated
                        to arrive at an <span class="quote">“<span class="quote">execute</span>”</span> condition according
                        to the rules described in the previous section (see
                        <a class="xref" href="replication.html#replication-rules-db-options" title="16.2.5.1&nbsp;Evaluation of Database-Level Replication and Binary Logging Options">Section&nbsp;16.2.5.1, “Evaluation of Database-Level Replication and Binary Logging Options”</a>).
                    </p><p style="color:blue;">找到一个或多个数据库选项，并根据上一节中描述的规则对其进行评估以达到“执行”条件（请参阅第16.2.5.1节“数据库级复制和二进制日志记录选项的评估”）。</p></li></ul>
                </div>
                <p>
                    First, as a preliminary condition, the slave checks whether
                    statement-based replication is enabled. If so, and the statement
                    occurs within a stored function, the slave executes the
                    statement and exits. If row-based replication is enabled, the
                    slave does not know whether a statement occurred within a stored
                    function on the master, so this condition does not apply.
                </p><p style="color:blue;">首先，作为一个初步条件，从机检查是否启用了基于语句的复制。如果是这样，并且语句发生在存储的函数内，则从属执行语句并退出。如果启用了基于行的复制，则从机不知道是否在主机上的存储函数中发生语句，因此此条件不适用。</p>
                <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">

                    <div class="admon-title">
                        Note
                    </div>
                    <p>
                        For statement-based replication, replication events represent
                        statements (all changes making up a given event are associated
                        with a single SQL statement); for row-based replication, each
                        event represents a change in a single table row (thus a single
                        statement such as <code class="literal">UPDATE mytable SET mycol =
                        1</code> may yield many row-based events). When viewed in
                        terms of events, the process of checking table options is the
                        same for both row-based and statement-based replication.
                    </p><p style="color:blue;">对于基于语句的复制，复制事件表示语句（构成给定事件的所有更改都与单个sql语句相关联）；对于基于行的复制，每个事件表示单个表行中的更改（因此，update mytable set mycol=1等单个语句可能会生成多个基于行的事件）。从事件的角度来看，对基于行和基于语句的复制，检查表选项的过程是相同的。</p>
                </div>
                <p>
                    Having reached this point, if there are no table options, the
                    slave simply executes all events. If there are any
                    <a class="link" href="replication.html#option_mysqld_replicate-do-table"><code class="option">--replicate-do-table</code></a> or
                    <a class="link" href="replication.html#option_mysqld_replicate-wild-do-table"><code class="option">--replicate-wild-do-table</code></a>
                    options, the event must match one of these if it is to be
                    executed; otherwise, it is ignored. If there are any
                    <a class="link" href="replication.html#option_mysqld_replicate-ignore-table"><code class="option">--replicate-ignore-table</code></a> or
                    <a class="link" href="replication.html#option_mysqld_replicate-wild-ignore-table"><code class="option">--replicate-wild-ignore-table</code></a>
                    options, all events are executed except those that match any of
                    these options.
                </p><p style="color:blue;">到达这一点后，如果没有表选项，从机只执行所有事件。如果有任何--replicate do table或--replicate wild do table选项，则如果要执行该事件，则该事件必须与这些选项之一匹配；否则，将忽略该事件。如果有任何--replicate ignore table或--replicate wild ignore table选项，则执行所有事件，但与这些选项匹配的事件除外。</p><p>
                The following steps describe this evaluation in more detail. The
                starting point is the end of the evaluation of the
                database-level options, as described in
                <a class="xref" href="replication.html#replication-rules-db-options" title="16.2.5.1&nbsp;Evaluation of Database-Level Replication and Binary Logging Options">Section&nbsp;16.2.5.1, “Evaluation of Database-Level Replication and Binary Logging Options”</a>.
            </p><p style="color:blue;">以下步骤将更详细地描述此评估。如第16.2.5.1节“数据库级复制和二进制日志选项评估”所述，起点是数据库级选项评估的终点。</p>
                <div class="orderedlist">
                    <ol class="orderedlist" type="1"><li class="listitem"><p>
                        Are there any table replication options?
                    </p><p style="color:blue;">是否有表复制选项？</p>
                        <div class="itemizedlist">
                            <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><b>Yes.&nbsp;</b>
                                Continue to step 2.
                            </p><p style="color:blue;">对。继续执行步骤2。</p></li><li class="listitem"><p><b>No.&nbsp;</b>
                                Execute the update and exit.
                            </p><p style="color:blue;">不，执行更新并退出。</p></li></ul>
                        </div>
                    </li><li class="listitem"><p>
                        Which logging format is used?
                    </p><p style="color:blue;">使用哪种日志格式？</p>
                        <div class="itemizedlist">
                            <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><b>STATEMENT.&nbsp;</b>
                                Carry out the remaining steps for each statement that
                                performs an update.
                            </p><p style="color:blue;">陈述。对执行更新的每个语句执行其余步骤。</p></li><li class="listitem"><p><b>ROW.&nbsp;</b>
                                Carry out the remaining steps for each update of a
                                table row.
                            </p><p style="color:blue;">划船。执行表行每次更新的其余步骤。</p></li></ul>
                        </div>
                    </li><li class="listitem"><p>
                        Are there any
                        <a class="link" href="replication.html#option_mysqld_replicate-do-table"><code class="option">--replicate-do-table</code></a> options?
                    </p><p style="color:blue;">是否有--复制do表选项？</p>
                        <div class="itemizedlist">
                            <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><b>Yes.&nbsp;</b>
                                Does the table match any of them?
                            </p><p style="color:blue;">对。这张桌子和他们中的任何一张匹配吗？</p>
                                <div class="itemizedlist">
                                    <ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p><b>Yes.&nbsp;</b>
                                        Execute the update and exit.
                                    </p><p style="color:blue;">对。执行更新和退出。</p></li><li class="listitem"><p><b>No.&nbsp;</b>
                                        Continue to step 4.
                                    </p><p style="color:blue;">不，继续第4步。</p></li></ul>
                                </div>
                            </li><li class="listitem"><p><b>No.&nbsp;</b>
                                Continue to step 4.
                            </p><p style="color:blue;">不，继续第4步。</p></li></ul>
                        </div>
                    </li><li class="listitem"><p>
                        Are there any
                        <a class="link" href="replication.html#option_mysqld_replicate-ignore-table"><code class="option">--replicate-ignore-table</code></a>
                        options?
                    </p><p style="color:blue;">是否有--复制忽略表选项？</p>
                        <div class="itemizedlist">
                            <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><b>Yes.&nbsp;</b>
                                Does the table match any of them?
                            </p><p style="color:blue;">对。这张桌子和他们中的任何一张匹配吗？</p>
                                <div class="itemizedlist">
                                    <ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p><b>Yes.&nbsp;</b>
                                        Ignore the update and exit.
                                    </p><p style="color:blue;">对。忽略更新并退出。</p></li><li class="listitem"><p><b>No.&nbsp;</b>
                                        Continue to step 5.
                                    </p><p style="color:blue;">不，继续第5步。</p></li></ul>
                                </div>
                            </li><li class="listitem"><p><b>No.&nbsp;</b>
                                Continue to step 5.
                            </p><p style="color:blue;">不，继续第5步。</p></li></ul>
                        </div>
                    </li><li class="listitem"><p>
                        Are there any
                        <a class="link" href="replication.html#option_mysqld_replicate-wild-do-table"><code class="option">--replicate-wild-do-table</code></a>
                        options?
                    </p><p style="color:blue;">有——复制野生do表选项吗？</p>
                        <div class="itemizedlist">
                            <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><b>Yes.&nbsp;</b>
                                Does the table match any of them?
                            </p><p style="color:blue;">对。这张桌子和他们中的任何一张匹配吗？</p>
                                <div class="itemizedlist">
                                    <ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p><b>Yes.&nbsp;</b>
                                        Execute the update and exit.
                                    </p><p style="color:blue;">对。执行更新和退出。</p></li><li class="listitem"><p><b>No.&nbsp;</b>
                                        Continue to step 6.
                                    </p><p style="color:blue;">不，继续第6步。</p></li></ul>
                                </div>
                            </li><li class="listitem"><p><b>No.&nbsp;</b>
                                Continue to step 6.
                            </p><p style="color:blue;">不，继续第6步。</p></li></ul>
                        </div>
                    </li><li class="listitem"><p>
                        Are there any
                        <a class="link" href="replication.html#option_mysqld_replicate-wild-ignore-table"><code class="option">--replicate-wild-ignore-table</code></a>
                        options?
                    </p><p style="color:blue;">是否有--复制野生忽略表选项？</p>
                        <div class="itemizedlist">
                            <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><b>Yes.&nbsp;</b>
                                Does the table match any of them?
                            </p><p style="color:blue;">对。这张桌子和他们中的任何一张匹配吗？</p>
                                <div class="itemizedlist">
                                    <ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p><b>Yes.&nbsp;</b>
                                        Ignore the update and exit.
                                    </p><p style="color:blue;">对。忽略更新并退出。</p></li><li class="listitem"><p><b>No.&nbsp;</b>
                                        Continue to step 7.
                                    </p><p style="color:blue;">不，继续第7步。</p></li></ul>
                                </div>
                            </li><li class="listitem"><p><b>No.&nbsp;</b>
                                Continue to step 7.
                            </p><p style="color:blue;">不，继续第7步。</p></li></ul>
                        </div>
                    </li><li class="listitem"><p>
                        Is there another table to be tested?
                    </p><p style="color:blue;">还有桌子要测试吗？</p>
                        <div class="itemizedlist">
                            <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><b>Yes.&nbsp;</b>
                                Go back to step 3.
                            </p><p style="color:blue;">对。回到步骤3。</p></li><li class="listitem"><p><b>No.&nbsp;</b>
                                Continue to step 8.
                            </p><p style="color:blue;">不，继续第8步。</p></li></ul>
                        </div>
                    </li><li class="listitem"><p>
                        Are there any
                        <a class="link" href="replication.html#option_mysqld_replicate-do-table"><code class="option">--replicate-do-table</code></a> or
                        <a class="link" href="replication.html#option_mysqld_replicate-wild-do-table"><code class="option">--replicate-wild-do-table</code></a>
                        options?
                    </p><p style="color:blue;">是否有--replicate do table或--replicate wild do table选项？</p>
                        <div class="itemizedlist">
                            <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><b>Yes.&nbsp;</b>
                                Ignore the update and exit.
                            </p><p style="color:blue;">对。忽略更新并退出。</p></li><li class="listitem"><p><b>No.&nbsp;</b>
                                Execute the update and exit.
                            </p><p style="color:blue;">不，执行更新并退出。</p></li></ul>
                        </div>
                    </li></ol>
                </div>
                <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">
                    <div class="admon-title">
                        Note
                    </div>
                    <p>
                        Statement-based replication stops if a single SQL statement
                        operates on both a table that is included by a
                        <a class="link" href="replication.html#option_mysqld_replicate-do-table"><code class="option">--replicate-do-table</code></a> or
                        <a class="link" href="replication.html#option_mysqld_replicate-wild-do-table"><code class="option">--replicate-wild-do-table</code></a>
                        option, and another table that is ignored by a
                        <a class="link" href="replication.html#option_mysqld_replicate-ignore-table"><code class="option">--replicate-ignore-table</code></a> or
                        <a class="link" href="replication.html#option_mysqld_replicate-wild-ignore-table"><code class="option">--replicate-wild-ignore-table</code></a>
                        option. The slave must either execute or ignore the complete
                        statement (which forms a replication event), and it cannot
                        logically do this. This also applies to row-based replication
                        for DDL statements, because DDL statements are always logged
                        as statements, without regard to the logging format in effect.
                        The only type of statement that can update both an included
                        and an ignored table and still be replicated successfully is a
                        DML statement that has been logged with
                        <a class="link" href="replication.html#sysvar_binlog_format"><code class="literal">binlog_format=ROW</code></a>.
                    </p><p style="color:blue;">如果单个SQL语句同时对--replicate do table或--replicate wild do table选项包含的表和--replicate ignore table或--replicate wild ignore table选项忽略的另一个表执行操作，则基于语句的复制将停止。从机必须执行或忽略complete语句（它形成复制事件），并且在逻辑上不能这样做。这也适用于ddl语句的基于行的复制，因为ddl语句总是作为语句记录，而不考虑有效的日志格式。唯一一种既能更新包含表又能更新被忽略表且仍能成功复制的语句是用binlog_format=row记录的dml语句。</p>
                </div>

            </div>
            <div class="section">
                <div class="titlepage">
                    <div>
                        <div>
                            <h4 class="title"><a name="replication-rules-examples"></a>16.2.5.3&nbsp;Replication Rule Application</h4>

                        </div>

                    </div>

                </div>
                <p>
                    This section provides additional explanation and examples of
                    usage for different combinations of replication filtering
                    options.
                </p><p style="color:blue;">本节提供了复制筛选选项的不同组合的其他说明和使用示例。</p><p>
                Some typical combinations of replication filter rule types are
                given in the following table:
            </p><p style="color:blue;">复制筛选器规则类型的一些典型组合如下表所示：</p>
                <div class="informaltable">
                    <table summary="Typical combinations of replication filter rule types and the outcome of each."><colgroup><col width="40%"><col width="60%"></colgroup><thead><tr>
                        <th scope="col">Condition (Types of Options)</th>
                        <th scope="col">Outcome</th>
                    </tr></thead><tbody><tr>
                        <td scope="row">No <code class="option">--replicate-*</code> options at all:</td>
                        <td>The slave executes all events that it receives from the master.</td>
                    </tr><tr>
                        <td scope="row"><code class="option">--replicate-*-db</code> options, but no table options:</td>
                        <td>The slave accepts or ignores events using the database options. It
                            executes all events permitted by those options because
                            there are no table restrictions.</td>
                    </tr><tr>
                        <td scope="row"><code class="option">--replicate-*-table</code> options, but no database options:</td>
                        <td>All events are accepted at the database-checking stage because there are
                            no database conditions. The slave executes or ignores
                            events based solely on the table options.</td>
                    </tr><tr>
                        <td scope="row">A combination of database and table options:</td>
                        <td>The slave accepts or ignores events using the database options. Then it
                            evaluates all events permitted by those options according
                            to the table options. This can sometimes lead to results
                            that seem counterintuitive, and that may be different
                            depending on whether you are using statement-based or
                            row-based replication; see the text for an example.</td>
                    </tr></tbody></table>
                </div>
                <p>
                    A more complex example follows, in which we examine the outcomes
                    for both statement-based and row-based settings.
                </p><p style="color:blue;">下面是一个更复杂的示例，我们将检查基于语句和基于行的设置的结果。</p><p>
                Suppose that we have two tables <code class="literal">mytbl1</code> in
                database <code class="literal">db1</code> and <code class="literal">mytbl2</code> in
                database <code class="literal">db2</code> on the master, and the slave is
                running with the following options (and no other replication
                filtering options):
            </p><p style="color:blue;">假设我们在主数据库db1中有两个表mytbl1，在数据库db2中有两个表mytbl2，从数据库运行时有以下选项（没有其他复制筛选选项）：</p><pre data-lang="ini" class="programlisting">replicate-ignore-db = db1
replicate-do-table  = db2.tbl2
</pre><p>
                Now we execute the following statements on the master:
            </p><p style="color:blue;">现在我们在master上执行以下语句：</p><pre data-lang="sql" class="programlisting">USE db1;
INSERT INTO db2.tbl2 VALUES (1);
</pre><p>
                The results on the slave vary considerably depending on the
                binary log format, and may not match initial expectations in
                either case.
            </p><p style="color:blue;">从属服务器上的结果因二进制日志格式的不同而有很大差异，并且在这两种情况下都可能与初始预期不匹配。</p><p><b>Statement-based replication.&nbsp;</b>
                The <code class="literal">USE</code> statement causes
                <code class="literal">db1</code> to be the default database. Thus the
                <a class="link" href="replication.html#option_mysqld_replicate-ignore-db"><code class="option">--replicate-ignore-db</code></a> option
                matches, <span class="emphasis"><em>and the
          <a class="link" href="sql-syntax.html#insert" title="13.2.5&nbsp;INSERT Syntax"><code class="literal">INSERT</code></a> statement is
          ignored</em></span>. The table options are not checked.
            </p><p style="color:blue;">基于语句的复制。use语句使db1成为默认数据库。因此--replicate ignore db选项匹配，insert语句被忽略。表选项未选中。</p><p><b>Row-based replication.&nbsp;</b>
                The default database has no effect on how the slave reads
                database options when using row-based replication. Thus, the
                <a class="link" href="sql-syntax.html#use" title="13.8.4&nbsp;USE Syntax"><code class="literal">USE</code></a> statement makes no
                difference in how the
                <a class="link" href="replication.html#option_mysqld_replicate-ignore-db"><code class="option">--replicate-ignore-db</code></a> option is
                handled: the database specified by this option does not match
                the database where the <a class="link" href="sql-syntax.html#insert" title="13.2.5&nbsp;INSERT Syntax"><code class="literal">INSERT</code></a>
                statement changes data, so the slave proceeds to check the
                table options. The table specified by
                <a class="link" href="replication.html#option_mysqld_replicate-do-table"><code class="option">--replicate-do-table</code></a> matches
                the table to be updated, <span class="emphasis"><em>and the row is
          inserted</em></span>.
            </p><p style="color:blue;">基于行的复制。当使用基于行的复制时，默认数据库对从机读取数据库选项的方式没有影响。因此，use语句在--replicate ignore db选项的处理方式上没有区别：此选项指定的数据库与insert语句更改数据的数据库不匹配，因此从数据库继续检查表选项。由--replicate do table指定的表与要更新的表匹配，并插入行。</p>
            </div>

        </div>

    </div>
    <div class="section">
        <div class="titlepage">
            <div>
                <div>
                    <h2 class="title" style="clear: both"><a name="replication-solutions"></a>16.3&nbsp;Replication Solutions</h2>

                </div>

            </div>

        </div>
        <div class="toc">
            <dl class="toc"><dt><span class="section"><a href="replication.html#replication-solutions-backups">16.3.1 Using Replication for Backups</a></span></dt><dt><span class="section"><a href="replication.html#replication-solutions-unexpected-slave-halt">16.3.2 Handling an Unexpected Halt of a Replication Slave</a></span></dt><dt><span class="section"><a href="replication.html#replication-solutions-diffengines">16.3.3 Using Replication with Different Master and Slave Storage Engines</a></span></dt><dt><span class="section"><a href="replication.html#replication-solutions-scaleout">16.3.4 Using Replication for Scale-Out</a></span></dt><dt><span class="section"><a href="replication.html#replication-solutions-partitioning">16.3.5 Replicating Different Databases to Different Slaves</a></span></dt><dt><span class="section"><a href="replication.html#replication-solutions-performance">16.3.6 Improving Replication Performance</a></span></dt><dt><span class="section"><a href="replication.html#replication-solutions-switch">16.3.7 Switching Masters During Failover</a></span></dt><dt><span class="section"><a href="replication.html#replication-solutions-encrypted-connections">16.3.8 Setting Up Replication to Use Encrypted Connections</a></span></dt><dt><span class="section"><a href="replication.html#replication-semisync">16.3.9 Semisynchronous Replication</a></span></dt><dt><span class="section"><a href="replication.html#replication-delayed">16.3.10 Delayed Replication</a></span></dt></dl>
        </div>
        <p>
            Replication can be used in many different environments for a range
            of purposes. This section provides general notes and advice on using
            replication for specific solution types.
        </p><p style="color:blue;">复制可以在许多不同的环境中用于一系列目的。本节提供有关针对特定解决方案类型使用复制的一般说明和建议。</p><p>
        For information on using replication in a backup environment,
        including notes on the setup, backup procedure, and files to back
        up, see <a class="xref" href="replication.html#replication-solutions-backups" title="16.3.1&nbsp;Using Replication for Backups">Section&nbsp;16.3.1, “Using Replication for Backups”</a>.
    </p><p style="color:blue;">有关在备份环境中使用复制的信息，包括有关设置、备份过程和要备份的文件的说明，请参阅第16.3.1节“将复制用于备份”。</p><p>
        For advice and tips on using different storage engines on the master
        and slaves, see <a class="xref" href="replication.html#replication-solutions-diffengines" title="16.3.3&nbsp;Using Replication with Different Master and Slave Storage Engines">Section&nbsp;16.3.3, “Using Replication with Different Master and Slave Storage Engines”</a>.
    </p><p style="color:blue;">有关在主存储引擎和从存储引擎上使用不同存储引擎的建议和提示，请参阅16.3.3节，“使用不同主存储引擎和从存储引擎的复制”。</p><p>
        Using replication as a scale-out solution requires some changes in
        the logic and operation of applications that use the solution. See
        <a class="xref" href="replication.html#replication-solutions-scaleout" title="16.3.4&nbsp;Using Replication for Scale-Out">Section&nbsp;16.3.4, “Using Replication for Scale-Out”</a>.
    </p><p style="color:blue;">使用复制作为扩展解决方案需要对使用该解决方案的应用程序的逻辑和操作进行一些更改。参见第16.3.4节“使用复制进行横向扩展”。</p><p>
        For performance or data distribution reasons, you may want to
        replicate different databases to different replication slaves. See
        <a class="xref" href="replication.html#replication-solutions-partitioning" title="16.3.5&nbsp;Replicating Different Databases to Different Slaves">Section&nbsp;16.3.5, “Replicating Different Databases to Different Slaves”</a>
    </p><p style="color:blue;">出于性能或数据分发的原因，您可能希望将不同的数据库复制到不同的复制从属服务器。参见第16.3.5节“将不同的数据库复制到不同的从机”</p><p>
        As the number of replication slaves increases, the load on the
        master can increase and lead to reduced performance (because of the
        need to replicate the binary log to each slave). For tips on
        improving your replication performance, including using a single
        secondary server as a replication master, see
        <a class="xref" href="replication.html#replication-solutions-performance" title="16.3.6&nbsp;Improving Replication Performance">Section&nbsp;16.3.6, “Improving Replication Performance”</a>.
    </p><p style="color:blue;">随着复制从属服务器数量的增加，主服务器上的负载可能会增加并导致性能降低（因为需要将二进制日志复制到每个从属服务器）。有关提高复制性能（包括将单个辅助服务器用作复制主机）的提示，请参阅16.3.6节“提高复制性能”。</p><p>
        For guidance on switching masters, or converting slaves into masters
        as part of an emergency failover solution, see
        <a class="xref" href="replication.html#replication-solutions-switch" title="16.3.7&nbsp;Switching Masters During Failover">Section&nbsp;16.3.7, “Switching Masters During Failover”</a>.
    </p><p style="color:blue;">有关切换主设备或将从设备转换为主设备（作为紧急故障转移解决方案的一部分）的指导，请参阅第16.3.7节“故障转移期间切换主设备”。</p><p>
        To secure your replication communication, you can encrypt the
        communication channel. For step-by-step instructions, see
        <a class="xref" href="replication.html#replication-solutions-encrypted-connections" title="16.3.8&nbsp;Setting Up Replication to Use Encrypted Connections">Section&nbsp;16.3.8, “Setting Up Replication to Use Encrypted Connections”</a>.
    </p><p style="color:blue;">为了保护复制通信，可以加密通信通道。有关分步说明，请参阅第16.3.8节“设置复制以使用加密连接”。</p>
        <div class="section">

            <div class="titlepage">
                <div>
                    <div>
                        <h3 class="title"><a name="replication-solutions-backups"></a>16.3.1&nbsp;Using Replication for Backups</h3>

                    </div>

                </div>

            </div>

            <div class="toc">
                <dl class="toc"><dt><span class="section"><a href="replication.html#replication-solutions-backups-mysqldump">16.3.1.1 Backing Up a Slave Using mysqldump</a></span></dt><dt><span class="section"><a href="replication.html#replication-solutions-backups-rawdata">16.3.1.2 Backing Up Raw Data from a Slave</a></span></dt><dt><span class="section"><a href="replication.html#replication-solutions-backups-read-only">16.3.1.3 Backing Up a Master or Slave by Making It Read Only</a></span></dt></dl>
            </div>
            <p>
                To use replication as a backup solution, replicate data from the
                master to a slave, and then back up the data slave. The slave can
                be paused and shut down without affecting the running operation of
                the master, so you can produce an effective snapshot of
                <span class="quote">“<span class="quote">live</span>”</span> data that would otherwise require the master
                to be shut down.
            </p><p style="color:blue;">要使用复制作为备份解决方案，请将数据从主服务器复制到从服务器，然后备份数据从服务器。在不影响主设备运行操作的情况下，可以暂停和关闭从设备，因此您可以生成“实时”数据的有效快照，否则将需要关闭主设备。</p><p>
            How you back up a database depends on its size and whether you are
            backing up only the data, or the data and the replication slave
            state so that you can rebuild the slave in the event of failure.
            There are therefore two choices:
        </p><p style="color:blue;">如何备份数据库取决于数据库的大小，以及是否只备份数据，或者数据和复制从机状态，以便在发生故障时重建从机。因此有两种选择：</p>
            <div class="itemizedlist">
                <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                    If you are using replication as a solution to enable you to
                    back up the data on the master, and the size of your database
                    is not too large, the <a class="link" href="programs.html#mysqldump" title="4.5.4&nbsp;mysqldump — A Database Backup Program"><span class="command"><strong>mysqldump</strong></span></a> tool may be
                    suitable. See
                    <a class="xref" href="replication.html#replication-solutions-backups-mysqldump" title="16.3.1.1&nbsp;Backing Up a Slave Using mysqldump">Section&nbsp;16.3.1.1, “Backing Up a Slave Using mysqldump”</a>.
                </p><p style="color:blue;">如果使用复制作为解决方案使您能够备份主服务器上的数据，并且数据库的大小不太大，那么mysqldump工具可能是合适的。参见第16.3.1.1节“使用mysqldump备份从机”。</p></li><li class="listitem"><p>
                    For larger databases, where <a class="link" href="programs.html#mysqldump" title="4.5.4&nbsp;mysqldump — A Database Backup Program"><span class="command"><strong>mysqldump</strong></span></a> would
                    be impractical or inefficient, you can back up the raw data
                    files instead. Using the raw data files option also means that
                    you can back up the binary and relay logs that will enable you
                    to recreate the slave in the event of a slave failure. For
                    more information, see
                    <a class="xref" href="replication.html#replication-solutions-backups-rawdata" title="16.3.1.2&nbsp;Backing Up Raw Data from a Slave">Section&nbsp;16.3.1.2, “Backing Up Raw Data from a Slave”</a>.
                </p><p style="color:blue;">对于更大的数据库，mysqldump将不切实际或效率低下，您可以备份原始数据文件。使用raw data files选项还意味着您可以备份二进制和中继日志，以便在从属服务器出现故障时重新创建从属服务器。有关更多信息，请参阅第16.3.1.2节“从机备份原始数据”。</p></li></ul>
            </div>
            <p>
                Another backup strategy, which can be used for either master or
                slave servers, is to put the server in a read-only state. The
                backup is performed against the read-only server, which then is
                changed back to its usual read/write operational status. See
                <a class="xref" href="replication.html#replication-solutions-backups-read-only" title="16.3.1.3&nbsp;Backing Up a Master or Slave by Making It Read Only">Section&nbsp;16.3.1.3, “Backing Up a Master or Slave by Making It Read Only”</a>.
            </p><p style="color:blue;">另一种备份策略，可用于主服务器或从服务器，是将服务器置于只读状态。对只读服务器执行备份，然后将其更改回其通常的读/写操作状态。见16.3.1.3节，“通过使主设备或从设备只读来备份主设备或从设备”。</p>
            <div class="section">

                <div class="titlepage">
                    <div>
                        <div>
                            <h4 class="title"><a name="replication-solutions-backups-mysqldump"></a>16.3.1.1&nbsp;Backing Up a Slave Using mysqldump</h4>
                        </div>
                    </div>
                </div>
                <p>
                    Using <a class="link" href="programs.html#mysqldump" title="4.5.4&nbsp;mysqldump — A Database Backup Program"><span class="command"><strong>mysqldump</strong></span></a> to create a copy of a
                    database enables you to capture all of the data in the database
                    in a format that enables the information to be imported into
                    another instance of MySQL Server (see
                    <a class="xref" href="programs.html#mysqldump" title="4.5.4&nbsp;mysqldump — A Database Backup Program">Section&nbsp;4.5.4, “<span class="command"><strong>mysqldump</strong></span> — A Database Backup Program”</a>). Because the format of the
                    information is SQL statements, the file can easily be
                    distributed and applied to running servers in the event that you
                    need access to the data in an emergency. However, if the size of
                    your data set is very large, <a class="link" href="programs.html#mysqldump" title="4.5.4&nbsp;mysqldump — A Database Backup Program"><span class="command"><strong>mysqldump</strong></span></a> may be
                    impractical.
                </p><p style="color:blue;">通过使用mysqldump创建数据库副本，您可以以某种格式捕获数据库中的所有数据，该格式允许将信息导入mysql server的另一个实例（请参阅4.5.4节，“mysqldump-数据库备份程序”）。因为信息的格式是sql语句，所以在紧急情况下需要访问数据时，可以很容易地将文件分发并应用到正在运行的服务器。但是，如果数据集的大小非常大，那么mysqldump可能不切实际。</p><p>
                When using <a class="link" href="programs.html#mysqldump" title="4.5.4&nbsp;mysqldump — A Database Backup Program"><span class="command"><strong>mysqldump</strong></span></a>, you should stop
                replication on the slave before starting the dump process to
                ensure that the dump contains a consistent set of data:
            </p><p style="color:blue;">使用mysqldump时，应在启动转储进程之前停止从机上的复制，以确保转储包含一致的数据集：</p>
                <div class="orderedlist">
                    <ol class="orderedlist" type="1"><li class="listitem"><p>
                        Stop the slave from processing requests. You can stop
                        replication completely on the slave using
                        <a class="link" href="programs.html#mysqladmin" title="4.5.2&nbsp;mysqladmin — Client for Administering a MySQL Server"><span class="command"><strong>mysqladmin</strong></span></a>:
                    </p><p style="color:blue;">停止从机处理请求。您可以使用mysqladmin完全停止从机上的复制：</p><pre data-lang="terminal" class="programlisting">shell&gt; <strong class="userinput"><code>mysqladmin stop-slave</code></strong></pre><p>
                        Alternatively, you can stop only the slave SQL thread to
                        pause event execution:
                    </p><p style="color:blue;">或者，您可以仅停止从属SQL线程以暂停事件执行：</p><pre data-lang="terminal" class="programlisting">shell&gt; <strong class="userinput"><code>mysql -e 'STOP SLAVE SQL_THREAD;'</code></strong></pre><p>
                        This enables the slave to continue to receive data change
                        events from the master's binary log and store them in the
                        relay logs using the I/O thread, but prevents the slave from
                        executing these events and changing its data. Within busy
                        replication environments, permitting the I/O thread to run
                        during backup may speed up the catch-up process when you
                        restart the slave SQL thread.
                    </p><p style="color:blue;">这使得从机能够继续从主机的二进制日志接收数据更改事件，并使用I/O线程将其存储在中继日志中，但是防止从机执行这些事件并更改其数据。在繁忙的复制环境中，允许在备份期间运行I/O线程可能会在重新启动从属SQL线程时加快追赶过程。</p></li><li class="listitem"><p>
                        Run <a class="link" href="programs.html#mysqldump" title="4.5.4&nbsp;mysqldump — A Database Backup Program"><span class="command"><strong>mysqldump</strong></span></a> to dump your databases. You
                        may either dump all databases or select databases to be
                        dumped. For example, to dump all databases:
                    </p><p style="color:blue;">运行mysqldump转储数据库。您可以转储所有数据库，也可以选择要转储的数据库。例如，要转储所有数据库：</p><pre data-lang="terminal" class="programlisting">shell&gt; <strong class="userinput"><code>mysqldump --all-databases &gt; fulldb.dump</code></strong></pre></li><li class="listitem"><p>
                        Once the dump has completed, start slave operations again:
                    </p><p style="color:blue;">转储完成后，再次启动从属操作：</p><pre data-lang="terminal" class="programlisting">shell&gt; <strong class="userinput"><code>mysqladmin start-slave</code></strong></pre></li></ol>
                </div>
                <p>
                    In the preceding example, you may want to add login credentials
                    (user name, password) to the commands, and bundle the process up
                    into a script that you can run automatically each day.
                </p><p style="color:blue;">在前面的示例中，您可能希望将登录凭据（用户名、密码）添加到命令中，并将该进程捆绑到可以每天自动运行的脚本中。</p><p>
                If you use this approach, make sure you monitor the slave
                replication process to ensure that the time taken to run the
                backup does not affect the slave's ability to keep up with
                events from the master. See
                <a class="xref" href="replication.html#replication-administration-status" title="16.1.7.1&nbsp;Checking Replication Status">Section&nbsp;16.1.7.1, “Checking Replication Status”</a>. If the
                slave is unable to keep up, you may want to add another slave
                and distribute the backup process. For an example of how to
                configure this scenario, see
                <a class="xref" href="replication.html#replication-solutions-partitioning" title="16.3.5&nbsp;Replicating Different Databases to Different Slaves">Section&nbsp;16.3.5, “Replicating Different Databases to Different Slaves”</a>.
            </p><p style="color:blue;">如果使用此方法，请确保监视从属复制过程，以确保运行备份所用的时间不会影响从属服务器跟上来自主服务器的事件的能力。见第16.1.7.1节“检查复制状态”。如果从机无法跟上，则可能需要添加另一个从机并分发备份进程。有关如何配置此方案的示例，请参阅第16.3.5节“将不同的数据库复制到不同的从机”。</p>
            </div>
            <div class="section">
                <div class="titlepage">
                    <div>
                        <div>
                            <h4 class="title"><a name="replication-solutions-backups-rawdata"></a>16.3.1.2&nbsp;Backing Up Raw Data from a Slave</h4>

                        </div>

                    </div>

                </div>
                <p>
                    To guarantee the integrity of the files that are copied, backing
                    up the raw data files on your MySQL replication slave should
                    take place while your slave server is shut down. If the MySQL
                    server is still running, background tasks may still be updating
                    the database files, particularly those involving storage engines
                    with background processes such as <code class="literal">InnoDB</code>.
                    With <code class="literal">InnoDB</code>, these problems should be
                    resolved during crash recovery, but since the slave server can
                    be shut down during the backup process without affecting the
                    execution of the master it makes sense to take advantage of this
                    capability.
                </p><p style="color:blue;">为了保证复制的文件的完整性，应该在从属服务器关闭时备份mysql复制从属服务器上的原始数据文件。如果mysql服务器仍在运行，后台任务可能仍在更新数据库文件，特别是那些涉及到带有innodb等后台进程的存储引擎的文件。对于innodb，这些问题应该在崩溃恢复期间解决，但是由于在备份过程中可以关闭从属服务器，而不会影响主服务器的执行，因此利用这一功能是有意义的。</p><p>
                To shut down the server and back up the files:
            </p><p style="color:blue;">要关闭服务器并备份文件，请执行以下操作：</p>
                <div class="orderedlist">
                    <ol class="orderedlist" type="1"><li class="listitem"><p>
                        Shut down the slave MySQL server:
                    </p><p style="color:blue;">关闭从属MySQL服务器：</p><pre data-lang="terminal" class="programlisting">shell&gt; <strong class="userinput"><code>mysqladmin shutdown</code></strong></pre></li><li class="listitem"><p>
                        Copy the data files. You can use any suitable copying or
                        archive utility, including <span class="command"><strong>cp</strong></span>,
                        <span class="command"><strong>tar</strong></span> or <span class="command"><strong>WinZip</strong></span>. For
                        example, assuming that the data directory is located under
                        the current directory, you can archive the entire directory
                        as follows:
                    </p><p style="color:blue;">复制数据文件。您可以使用任何合适的复制或存档实用程序，包括cp、tar或winzip。例如，假设数据目录位于当前目录下，则可以按如下方式存档整个目录：</p><pre data-lang="terminal" class="programlisting">shell&gt; <strong class="userinput"><code>tar cf /tmp/dbbackup.tar ./data</code></strong></pre></li><li class="listitem"><p>
                        Start the MySQL server again. Under Unix:
                    </p><p style="color:blue;">重新启动mysql服务器。在Unix下：</p><pre data-lang="terminal" class="programlisting">shell&gt; <strong class="userinput"><code>mysqld_safe &amp;</code></strong></pre><p>
                        Under Windows:
                    </p><p style="color:blue;">在Windows下：</p><pre data-lang="terminal" class="programlisting">C:\&gt; <strong class="userinput"><code>"C:\Program Files\MySQL\MySQL Server 5.7\bin\mysqld"</code></strong></pre></li></ol>
                </div>
                <p>
                    Normally you should back up the entire data directory for the
                    slave MySQL server. If you want to be able to restore the data
                    and operate as a slave (for example, in the event of failure of
                    the slave), then in addition to the slave's data, you should
                    also back up the slave status files, the master info and relay
                    log info repositories, and the relay log files. These files are
                    needed to resume replication after you restore the slave's
                    data.
                </p><p style="color:blue;">通常，您应该备份从属mysql服务器的整个数据目录。如果您希望能够还原数据并作为从机操作（例如，在从机发生故障的情况下），那么除了从机的数据之外，还应该备份从机状态文件、主信息和中继日志信息存储库以及中继日志文件。恢复从机的数据后，需要这些文件来恢复复制。</p><p>
                If you lose the relay logs but still have the
                <code class="filename">relay-log.info</code> file, you can check it to
                determine how far the SQL thread has executed in the master
                binary logs. Then you can use <a class="link" href="sql-syntax.html#change-master-to" title="13.4.2.1&nbsp;CHANGE MASTER TO Syntax"><code class="literal">CHANGE MASTER
                TO</code></a> with the <code class="literal">MASTER_LOG_FILE</code> and
                <code class="literal">MASTER_LOG_POS</code> options to tell the slave to
                re-read the binary logs from that point. This requires that the
                binary logs still exist on the master server.
            </p><p style="color:blue;">如果丢失了中继日志，但仍有relay-log.info文件，则可以检查该文件以确定SQL线程在主二进制日志中执行的距离。然后，您可以使用change master to with the master_log_file和master_log_pos选项，告诉从服务器从此点重新读取二进制日志。这要求二进制日志仍然存在于主服务器上。</p><p>
                If your slave is replicating <a class="link" href="sql-syntax.html#load-data" title="13.2.6&nbsp;LOAD DATA Syntax"><code class="literal">LOAD
                DATA</code></a> statements, you should also back up any
                <code class="filename">SQL_LOAD-*</code> files that exist in the
                directory that the slave uses for this purpose. The slave needs
                these files to resume replication of any interrupted
                <a class="link" href="sql-syntax.html#load-data" title="13.2.6&nbsp;LOAD DATA Syntax"><code class="literal">LOAD DATA</code></a> operations. The
                location of this directory is the value of the
                <a class="link" href="replication.html#option_mysqld_slave-load-tmpdir"><code class="option">--slave-load-tmpdir</code></a> option. If
                the server was not started with that option, the directory
                location is the value of the
                <a class="link" href="server-administration.html#sysvar_tmpdir"><code class="literal">tmpdir</code></a> system variable.
            </p><p style="color:blue;">如果您的奴隶正在复制Load DATA语句，那么您也应该备份在该目录中使用的任何SqLyLoad -*文件。从机需要这些文件来恢复任何中断的加载数据操作的复制。此目录的位置是--slave load tmpdir选项的值。如果服务器不是使用该选项启动的，则目录位置是tmpdir系统变量的值。</p>
            </div>
            <div class="section">
                <div class="titlepage">
                    <div>
                        <div>
                            <h4 class="title"><a name="replication-solutions-backups-read-only"></a>16.3.1.3&nbsp;Backing Up a Master or Slave by Making It Read Only</h4>

                        </div>

                    </div>

                </div>
                <p>
                    It is possible to back up either master or slave servers in a
                    replication setup by acquiring a global read lock and
                    manipulating the <a class="link" href="server-administration.html#sysvar_read_only"><code class="literal">read_only</code></a>
                    system variable to change the read-only state of the server to
                    be backed up:
                </p><p style="color:blue;">在复制设置中，可以通过获取全局读锁并操纵read_only系统变量来更改要备份的服务器的只读状态，从而备份主服务器或从服务器：</p>
                <div class="orderedlist">
                    <ol class="orderedlist" type="1"><li class="listitem"><p>
                        Make the server read-only, so that it processes only
                        retrievals and blocks updates.
                    </p><p style="color:blue;">使服务器只读，以便它只处理检索和阻止更新。</p></li><li class="listitem"><p>
                        Perform the backup.
                    </p><p style="color:blue;">执行备份。</p></li><li class="listitem"><p>
                        Change the server back to its normal read/write state.
                    </p><p style="color:blue;">将服务器更改回其正常读/写状态。</p></li></ol>
                </div>
                <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">
                    <div class="admon-title">
                        Note
                    </div>
                    <p>
                        The instructions in this section place the server to be backed
                        up in a state that is safe for backup methods that get the
                        data from the server, such as <a class="link" href="programs.html#mysqldump" title="4.5.4&nbsp;mysqldump — A Database Backup Program"><span class="command"><strong>mysqldump</strong></span></a>
                        (see <a class="xref" href="programs.html#mysqldump" title="4.5.4&nbsp;mysqldump — A Database Backup Program">Section&nbsp;4.5.4, “<span class="command"><strong>mysqldump</strong></span> — A Database Backup Program”</a>). You should not attempt to
                        use these instructions to make a binary backup by copying
                        files directly because the server may still have modified data
                        cached in memory and not flushed to disk.
                    </p><p style="color:blue;">本节中的说明将要备份的服务器置于一种安全的状态，这种状态适用于从服务器获取数据的备份方法，例如mysqldump（请参阅4.5.4节，“mysqldump-数据库备份程序”）。您不应该试图使用这些指令通过直接复制文件来进行二进制备份，因为服务器可能仍有修改过的数据缓存在内存中，而没有刷新到磁盘。</p>
                </div>
                <p>
                    The following instructions describe how to do this for a master
                    server and for a slave server. For both scenarios discussed
                    here, suppose that you have the following replication setup:
                </p><p style="color:blue;">以下说明描述了如何对主服务器和从服务器执行此操作。对于这里讨论的两种情况，假设您有以下复制设置：</p>
                <div class="itemizedlist">
                    <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                        A master server M1
                    </p><p style="color:blue;">主服务器m1</p></li><li class="listitem"><p>
                        A slave server S1 that has M1 as its master
                    </p><p style="color:blue;">以m1为主服务器的从服务器s1</p></li><li class="listitem"><p>
                        A client C1 connected to M1
                    </p><p style="color:blue;">连接到m1的客户端c1</p></li><li class="listitem"><p>
                        A client C2 connected to S1
                    </p><p style="color:blue;">连接到s1的客户端c2</p></li></ul>
                </div>
                <p>
                    In either scenario, the statements to acquire the global read
                    lock and manipulate the
                    <a class="link" href="server-administration.html#sysvar_read_only"><code class="literal">read_only</code></a> variable are
                    performed on the server to be backed up and do not propagate to
                    any slaves of that server.
                </p><p style="color:blue;">在这两种情况下，获取全局读锁和操作只读变量的语句都在要备份的服务器上执行，不会传播到该服务器的任何从属服务器。</p><p>
        <span class="bold"><strong>Scenario 1: Backup with a Read-Only
        Master</strong></span>
            </p><p style="color:blue;">场景1：使用只读主机进行备份</p><p>
                Put the master M1 in a read-only state by executing these
                statements on it:
            </p><p style="color:blue;">通过对主m1执行以下语句，使其处于只读状态：</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>FLUSH TABLES WITH READ LOCK;</code></strong>
mysql&gt; <strong class="userinput"><code>SET GLOBAL read_only = ON;</code></strong>
</pre><p>
                While M1 is in a read-only state, the following properties are
                true:
            </p><p style="color:blue;">当m1处于只读状态时，以下属性为真：</p>
                <div class="itemizedlist">
                    <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                        Requests for updates sent by C1 to M1 will block because the
                        server is in read-only mode.
                    </p><p style="color:blue;">C1向M1发送的更新请求将被阻止，因为服务器处于只读模式。</p></li><li class="listitem"><p>
                        Requests for query results sent by C1 to M1 will succeed.
                    </p><p style="color:blue;">C1向M1发送的查询结果请求将成功。</p></li><li class="listitem"><p>
                        Making a backup on M1 is safe.
                    </p><p style="color:blue;">在M1上备份是安全的。</p></li><li class="listitem"><p>
                        Making a backup on S1 is not safe. This server is still
                        running, and might be processing the binary log or update
                        requests coming from client C2
                    </p><p style="color:blue;">在s1上备份是不安全的。此服务器仍在运行，可能正在处理来自客户端c2的二进制日志或更新请求</p></li></ul>
                </div>
                <p>
                    While M1 is read only, perform the backup. For example, you can
                    use <a class="link" href="programs.html#mysqldump" title="4.5.4&nbsp;mysqldump — A Database Backup Program"><span class="command"><strong>mysqldump</strong></span></a>.
                </p><p style="color:blue;">当m1为只读时，执行备份。例如，可以使用mysqldump。</p><p>
                After the backup operation on M1 completes, restore M1 to its
                normal operational state by executing these statements:
            </p><p style="color:blue;">在m1上的备份操作完成后，通过执行以下语句将m1还原到其正常操作状态：</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>SET GLOBAL read_only = OFF;</code></strong>
mysql&gt; <strong class="userinput"><code>UNLOCK TABLES;</code></strong>
</pre><p>
                Although performing the backup on M1 is safe (as far as the
                backup is concerned), it is not optimal for performance because
                clients of M1 are blocked from executing updates.
            </p><p style="color:blue;">尽管在m1上执行备份是安全的（就备份而言），但它对性能不是最佳的，因为m1的客户端被阻止执行更新。</p><p>
                This strategy applies to backing up a master server in a
                replication setup, but can also be used for a single server in a
                nonreplication setting.
            </p><p style="color:blue;">此策略适用于在复制设置中备份主服务器，但也可用于非复制设置中的单个服务器。</p><p>
        <span class="bold"><strong>Scenario 2: Backup with a Read-Only
        Slave</strong></span>
            </p><p style="color:blue;">场景2：使用只读从机进行备份</p><p>
                Put the slave S1 in a read-only state by executing these
                statements on it:
            </p><p style="color:blue;">通过对从机s1执行以下语句，使其处于只读状态：</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>FLUSH TABLES WITH READ LOCK;</code></strong>
mysql&gt; <strong class="userinput"><code>SET GLOBAL read_only = ON;</code></strong>
</pre><p>
                While S1 is in a read-only state, the following properties are
                true:
            </p><p style="color:blue;">当s1处于只读状态时，以下属性为真：</p>
                <div class="itemizedlist">
                    <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                        The master M1 will continue to operate, so making a backup
                        on the master is not safe.
                    </p><p style="color:blue;">主m1将继续运行，因此在主m1上备份是不安全的。</p></li><li class="listitem"><p>
                        The slave S1 is stopped, so making a backup on the slave S1
                        is safe.
                    </p><p style="color:blue;">从机s1停止，因此在从机s1上进行备份是安全的。</p></li></ul>
                </div>
                <p>
                    These properties provide the basis for a popular backup
                    scenario: Having one slave busy performing a backup for a while
                    is not a problem because it does not affect the entire network,
                    and the system is still running during the backup. In
                    particular, clients can still perform updates on the master
                    server, which remains unaffected by backup activity on the
                    slave.
                </p><p style="color:blue;">这些属性为流行的备份方案提供了基础：让一个从机忙着执行备份一段时间不是问题，因为它不会影响整个网络，而且系统在备份期间仍在运行。特别是，客户机仍然可以在主服务器上执行更新，而主服务器不受从服务器上备份活动的影响。</p><p>
                While S1 is read only, perform the backup. For example, you can
                use <a class="link" href="programs.html#mysqldump" title="4.5.4&nbsp;mysqldump — A Database Backup Program"><span class="command"><strong>mysqldump</strong></span></a>.
            </p><p style="color:blue;">当s1为只读时，执行备份。例如，可以使用mysqldump。</p><p>
                After the backup operation on S1 completes, restore S1 to its
                normal operational state by executing these statements:
            </p><p style="color:blue;">在s1上的备份操作完成后，通过执行以下语句将s1还原到其正常操作状态：</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>SET GLOBAL read_only = OFF;</code></strong>
mysql&gt; <strong class="userinput"><code>UNLOCK TABLES;</code></strong>
</pre><p>
                After the slave is restored to normal operation, it again
                synchronizes to the master by catching up with any outstanding
                updates from the binary log of the master.
            </p><p style="color:blue;">在从机恢复到正常操作后，它再次通过从主机的二进制日志中捕获任何未完成的更新来与主机同步。</p>
            </div>

        </div>
        <div class="section">
            <div class="titlepage">
                <div>
                    <div>
                        <h3 class="title"><a name="replication-solutions-unexpected-slave-halt"></a>16.3.2&nbsp;Handling an Unexpected Halt of a Replication Slave</h3>

                    </div>

                </div>

            </div>
            <a class="indexterm" name="idm140286793226464"></a><a class="indexterm" name="idm140286793225392"></a><a class="indexterm" name="idm140286793223904"></a><p>
            In order for replication to be resilient to unexpected halts of
            the server (sometimes described as crash-safe) it must be possible
            for the slave to recover its state before halting. This section
            describes the impact of an unexpected halt of a slave during
            replication and how to configure a slave for the best chance of
            recovery to continue replication.
        </p><p style="color:blue;">为了使复制能够对服务器的意外中断（有时称为崩溃安全）具有弹性，从服务器必须能够在停止之前恢复其状态。本节介绍复制过程中从机意外停止的影响，以及如何配置从机以获得继续复制的最佳恢复机会。</p><p>
            After an unexpected halt of a replication slave, upon restart the
            slave's SQL thread must recover which transactions have been
            executed already. The information required for recovery is stored
            in the slave's relay log info log. In older MySQL Server versions,
            this log could only be created as a file in the data directory
            that was updated after the transaction had been applied. This held
            the risk of losing synchrony with the master depending at which
            stage of processing a transaction the slave halted at, or even
            corruption of the file itself. In MySQL 5.7 you can
            instead use an <a class="link" href="innodb-storage-engine.html" title="Chapter&nbsp;14&nbsp;The InnoDB Storage Engine"><code class="literal">InnoDB</code></a> table to store
            the relay log info log. By using this transactional storage engine
            the information is always recoverable upon restart. As a table,
            updates to the relay log info log are committed together with the
            transactions, meaning that the slave's progress information
            recorded in that log is always consistent with what has been
            applied to the database, even in the event of an unexpected server
            halt.
        </p><p style="color:blue;">复制从机意外停止后，在重新启动从机的SQL线程时，必须恢复已执行的事务。恢复所需的信息存储在从机的中继日志信息日志中。在较旧的mysql服务器版本中，此日志只能作为应用事务后更新的数据目录中的文件创建。这就存在着与主服务器失去同步的风险，这取决于从服务器在处理事务的哪个阶段停止，甚至是文件本身的损坏。在mysql 5.7中，您可以使用innodb表来存储中继日志信息日志。通过使用此事务性存储引擎，信息在重新启动时总是可以恢复的。作为一个表，对中继日志信息日志的更新与事务一起提交，这意味着该日志中记录的从属进程信息始终与应用于数据库的内容一致，即使在服务器意外停止的情况下也是如此。</p><p>
            To configure MySQL 5.7 to store the relay log info
            log as an <a class="link" href="innodb-storage-engine.html" title="Chapter&nbsp;14&nbsp;The InnoDB Storage Engine"><code class="literal">InnoDB</code></a> table, set the
            system variable
            <a class="link" href="replication.html#sysvar_relay_log_info_repository"><code class="literal">relay_log_info_repository</code></a> to
            <code class="literal">TABLE</code>. The server then stores information
            required for the recovery of the slave's SQL thread in the
            <code class="literal">mysql.slave_relay_log_info</code> table. For further
            information on the slave logs, see <a class="xref" href="replication.html#slave-logs" title="16.2.4&nbsp;Replication Relay and Status Logs">Section&nbsp;16.2.4, “Replication Relay and Status Logs”</a>.
        </p><p style="color:blue;">要将mysql 5.7配置为将中继日志信息日志存储为innodb表，请将系统变量relay-log-info-repository设置为table。然后，服务器将从机的SQL线程恢复所需的信息存储在mysql.slave_relay_log_info表中。有关从属日志的更多信息，请参阅第16.2.4节“复制中继和状态日志”。</p><p>
            Exactly how a replication slave recovers from an unexpected halt
            is influenced by the chosen method of replication, whether the
            slave is single-threaded or multithreaded, the setting of
            variables such as
            <a class="link" href="replication.html#sysvar_relay_log_recovery"><code class="literal">relay_log_recovery</code></a>, and whether
            features such as <code class="literal">MASTER_AUTO_POSITION</code> are being
            used.
        </p><p style="color:blue;">复制从机从意外停止中恢复的确切方式受所选复制方法、从机是单线程还是多线程、中继日志恢复等变量的设置以及是否正在使用主自动位置等功能的影响。</p><p>
            The following table shows the impact of these different factors on
            how a single-threaded slave recovers from an unexpected halt.
        </p><p style="color:blue;">下表显示了这些不同因素对单线程从属服务器如何从意外停止中恢复的影响。</p>
            <div class="table">
                <a name="idm140286793210416"></a><p class="title"><b>Table&nbsp;16.3&nbsp;Factors Influencing Single-threaded Replication Slave Recovery</b></p><p style="color:blue;">表16.3影响单线程复制从机恢复的因素</p>
                <div class="table-contents">
                    <table frame="all"><colgroup><col width="1.0%" align="center"><col width="1.0%" align="center"><col width="1.0%" align="center"><col width="1.0%" align="center"><col width="1.0%" align="center"><col width="1.0%" align="center"><col width="1.0%" align="center"></colgroup><thead><tr>
                        <th scope="col"><p>
                            GTID
                        </p><p style="color:blue;">GTID号</p></th>
                        <th scope="col"><p>
                            MASTER_AUTO_POSITION
                        </p><p style="color:blue;">主自动位置</p></th>
                        <th scope="col"><p>
                            <a class="link" href="replication.html#sysvar_relay_log_recovery"><code class="literal">relay_log_recovery</code></a>
                        </p><p style="color:blue;">中继日志恢复</p></th>
                        <th scope="col"><p>
                            <a class="link" href="replication.html#sysvar_relay_log_info_repository"><code class="literal">relay_log_info_repository</code></a>
                        </p><p style="color:blue;">中继日志信息库</p></th>
                        <th scope="col"><p>
                            Crash type
                        </p><p style="color:blue;">碰撞类型</p></th>
                        <th scope="col"><p>
                            Recovery guaranteed
                        </p><p style="color:blue;">保证恢复</p></th>
                        <th scope="col"><p>
                            Relay log impact
                        </p><p style="color:blue;">中继日志影响</p></th>
                    </tr></thead><tbody><tr valign="middle">
                        <td scope="row"><p>
                            OFF
                        </p><p style="color:blue;">关闭</p></td>
                        <td><p>
                            Any
                        </p><p style="color:blue;">任何</p></td>
                        <td><p>
                            1
                        </p><p style="color:blue;">1个</p></td>
                        <td><p>
                            TABLE
                        </p><p style="color:blue;">表</p></td>
                        <td><p>
                            Server
                        </p><p style="color:blue;">服务器</p></td>
                        <td><p>
                            Yes
                        </p><p style="color:blue;">是的</p></td>
                        <td><p>
                            Lost
                        </p><p style="color:blue;">迷路的</p></td>
                    </tr><tr valign="middle">
                        <td scope="row"><p>
                            OFF
                        </p><p style="color:blue;">关闭</p></td>
                        <td><p>
                            Any
                        </p><p style="color:blue;">任何</p></td>
                        <td><p>
                            1
                        </p><p style="color:blue;">1个</p></td>
                        <td><p>
                            Any
                        </p><p style="color:blue;">任何</p></td>
                        <td><p>
                            OS
                        </p><p style="color:blue;">操作系统</p></td>
                        <td><p>
                            No
                        </p><p style="color:blue;">不</p></td>
                        <td><p>
                            Lost
                        </p><p style="color:blue;">迷路的</p></td>
                    </tr><tr valign="middle">
                        <td scope="row"><p>
                            OFF
                        </p><p style="color:blue;">关闭</p></td>
                        <td><p>
                            Any
                        </p><p style="color:blue;">任何</p></td>
                        <td><p>
                            0
                        </p><p style="color:blue;">0个</p></td>
                        <td><p>
                            TABLE
                        </p><p style="color:blue;">表</p></td>
                        <td><p>
                            Server
                        </p><p style="color:blue;">服务器</p></td>
                        <td><p>
                            Yes
                        </p><p style="color:blue;">是的</p></td>
                        <td><p>
                            Remains
                        </p><p style="color:blue;">遗骸</p></td>
                    </tr><tr valign="middle">
                        <td scope="row"><p>
                            OFF
                        </p><p style="color:blue;">关闭</p></td>
                        <td><p>
                            Any
                        </p><p style="color:blue;">任何</p></td>
                        <td><p>
                            0
                        </p><p style="color:blue;">0个</p></td>
                        <td><p>
                            TABLE
                        </p><p style="color:blue;">表</p></td>
                        <td><p>
                            OS
                        </p><p style="color:blue;">操作系统</p></td>
                        <td><p>
                            No
                        </p><p style="color:blue;">不</p></td>
                        <td><p>
                            Remains
                        </p><p style="color:blue;">遗骸</p></td>
                    </tr><tr valign="middle">
                        <td scope="row"><p>
                            ON
                        </p><p style="color:blue;">打开</p></td>
                        <td><p>
                            ON
                        </p><p style="color:blue;">打开</p></td>
                        <td><p>
                            1
                        </p><p style="color:blue;">1个</p></td>
                        <td><p>
                            Any
                        </p><p style="color:blue;">任何</p></td>
                        <td><p>
                            Any
                        </p><p style="color:blue;">任何</p></td>
                        <td><p>
                            Yes
                        </p><p style="color:blue;">是的</p></td>
                        <td><p>
                            Lost
                        </p><p style="color:blue;">迷路的</p></td>
                    </tr><tr valign="middle">
                        <td scope="row"><p>
                            ON
                        </p><p style="color:blue;">打开</p></td>
                        <td><p>
                            OFF
                        </p><p style="color:blue;">关闭</p></td>
                        <td><p>
                            0
                        </p><p style="color:blue;">零</p></td>
                        <td><p>
                            TABLE
                        </p><p style="color:blue;">表</p></td>
                        <td><p>
                            Server
                        </p><p style="color:blue;">服务器</p></td>
                        <td><p>
                            Yes
                        </p><p style="color:blue;">是的</p></td>
                        <td><p>
                            Remains
                        </p><p style="color:blue;">遗骸</p></td>
                    </tr><tr valign="middle">
                        <td scope="row"><p>
                            ON
                        </p><p style="color:blue;">打开</p></td>
                        <td><p>
                            OFF
                        </p><p style="color:blue;">关闭</p></td>
                        <td><p>
                            0
                        </p><p style="color:blue;">0个</p></td>
                        <td><p>
                            Any
                        </p><p style="color:blue;">任何</p></td>
                        <td><p>
                            OS
                        </p><p style="color:blue;">操作系统</p></td>
                        <td><p>
                            No
                        </p><p style="color:blue;">不</p></td>
                        <td><p>
                            Remains
                        </p><p style="color:blue;">遗骸</p></td>
                    </tr></tbody></table>
                </div>

            </div>
            <br class="table-break"><p>
            As the table shows, when using a single-threaded slave the
            following configurations are most resilient to unexpected halts:
        </p><p style="color:blue;">如表所示，当使用单线程从机时，以下配置对意外中断最具弹性：</p>
            <div class="itemizedlist">
                <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                    When using GTIDs and <code class="literal">MASTER_AUTO_POSITION</code>,
                    set <a class="link" href="replication.html#sysvar_relay_log_recovery"><code class="literal">relay_log_recovery=1</code></a>.
                    With this configuration the setting of
                    <a class="link" href="replication.html#sysvar_relay_log_info_repository"><code class="literal">relay_log_info_repository</code></a> and
                    other variables does not impact on recovery. Note that to
                    guarantee recovery,
                    <a class="link" href="replication.html#sysvar_sync_binlog"><code class="literal">sync_binlog=1</code></a> (which is the
                    default) must also be set on the slave, so that the slave's
                    binary log is synchronized to disk at each write. Otherwise,
                    committed transactions might not be present in the slave's
                    binary log.

                </p><p style="color:blue;">当使用gtid和master_auto_位置时，设置relay_log_recovery=1。使用此配置，中继日志信息库和其他变量的设置不会影响恢复。请注意，为了保证恢复，还必须在从机上设置sync_binlog=1（这是默认值），以便在每次写入时将从机的二进制日志同步到磁盘。否则，提交的事务可能不会出现在从属服务器的二进制日志中。</p></li><li class="listitem"><p>
                    When using file position based replication, set
                    <a class="link" href="replication.html#sysvar_relay_log_recovery"><code class="literal">relay_log_recovery=1</code></a> and
                    <a class="link" href="replication.html#sysvar_relay_log_info_repository"><code class="literal">relay_log_info_repository=TABLE</code></a>.

                </p><p style="color:blue;">使用基于文件位置的复制时，请设置relay_log_recovery=1和relay_log_info_repository=table。</p>
                    <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">

                        <div class="admon-title">
                            Note
                        </div>
                        <p>
                            During recovery the relay log is lost.
                        </p><p style="color:blue;">在恢复过程中，继电器日志丢失。</p>
                    </div>
                    <p>
                    </p></li></ul>
            </div>
            <p>
                The following table shows the impact of these different factors on
                how a multithreaded slave recovers from an unexpected halt.
            </p><p style="color:blue;">下表显示了这些不同因素对多线程从属服务器如何从意外停止中恢复的影响。</p>
            <div class="table">
                <a name="idm140286793120864"></a><p class="title"><b>Table&nbsp;16.4&nbsp;Factors Influencing Multithreaded Replication Slave Recovery</b></p><p style="color:blue;">表16.4影响多线程复制从机恢复的因素</p>
                <div class="table-contents">
                    <table frame="all"><colgroup><col width="1.0%" align="center"><col width="1.0%" align="center"><col width="1.0%" align="center"><col width="1.0%" align="center"><col width="1.0%" align="center"><col width="1.0%" align="center"><col width="1.0%" align="center"><col width="1.0%" align="center"></colgroup><thead><tr>
                        <th scope="col"><p>
                            GTID
                        </p><p style="color:blue;">GTID号</p></th>
                        <th scope="col"><p>
                            <a class="link" href="replication.html#sysvar_sync_relay_log"><code class="literal">sync_relay_log</code></a>
                        </p><p style="color:blue;">同步继电器日志</p></th>
                        <th scope="col"><p>
                            <code class="literal">MASTER_AUTO_POSITION</code>
                        </p><p style="color:blue;">主自动位置</p></th>
                        <th scope="col"><p>
                            <a class="link" href="replication.html#sysvar_relay_log_recovery"><code class="literal">relay_log_recovery</code></a>
                        </p><p style="color:blue;">中继日志恢复</p></th>
                        <th scope="col"><p>
                            <a class="link" href="replication.html#sysvar_relay_log_info_repository"><code class="literal">relay_log_info_repository</code></a>
                        </p><p style="color:blue;">中继日志信息库</p></th>
                        <th scope="col"><p>
                            Crash type
                        </p><p style="color:blue;">碰撞类型</p></th>
                        <th scope="col"><p>
                            Recovery guaranteed
                        </p><p style="color:blue;">保证恢复</p></th>
                        <th scope="col"><p>
                            Relay log impact
                        </p><p style="color:blue;">中继日志影响</p></th>
                    </tr></thead><tbody><tr valign="middle">
                        <td scope="row"><p>
                            OFF
                        </p><p style="color:blue;">关闭</p></td>
                        <td><p>
                            1
                        </p><p style="color:blue;">1个</p></td>
                        <td><p>
                            Any
                        </p><p style="color:blue;">任何</p></td>
                        <td><p>
                            1
                        </p><p style="color:blue;">1个</p></td>
                        <td><p>
                            TABLE
                        </p><p style="color:blue;">桌子</p></td>
                        <td><p>
                            Any
                        </p><p style="color:blue;">任何</p></td>
                        <td><p>
                            Yes
                        </p><p style="color:blue;">是的</p></td>
                        <td><p>
                            Lost
                        </p><p style="color:blue;">迷路的</p></td>
                    </tr><tr valign="middle">
                        <td scope="row"><p>
                            OFF
                        </p><p style="color:blue;">关闭</p></td>
                        <td><p>
                            &gt;1
                        </p><p style="color:blue;">&gt; 1</p></td>
                        <td><p>
                            Any
                        </p><p style="color:blue;">任何</p></td>
                        <td><p>
                            1
                        </p><p style="color:blue;">一</p></td>
                        <td><p>
                            TABLE
                        </p><p style="color:blue;">桌子</p></td>
                        <td><p>
                            Server
                        </p><p style="color:blue;">服务器</p></td>
                        <td><p>
                            Yes
                        </p><p style="color:blue;">是的</p></td>
                        <td><p>
                            Lost
                        </p><p style="color:blue;">迷路的</p></td>
                    </tr><tr valign="middle">
                        <td scope="row"><p>
                            OFF
                        </p><p style="color:blue;">关闭</p></td>
                        <td><p>
                            &gt;1
                        </p><p style="color:blue;">&gt; 1</p></td>
                        <td><p>
                            Any
                        </p><p style="color:blue;">任何</p></td>
                        <td><p>
                            1
                        </p><p style="color:blue;">1个</p></td>
                        <td><p>
                            Any
                        </p><p style="color:blue;">任何</p></td>
                        <td><p>
                            OS
                        </p><p style="color:blue;">操作系统</p></td>
                        <td><p>
                            No
                        </p><p style="color:blue;">不</p></td>
                        <td><p>
                            Lost
                        </p><p style="color:blue;">迷路的</p></td>
                    </tr><tr valign="middle">
                        <td scope="row"><p>
                            OFF
                        </p><p style="color:blue;">关闭</p></td>
                        <td><p>
                            1
                        </p><p style="color:blue;">1个</p></td>
                        <td><p>
                            Any
                        </p><p style="color:blue;">任何</p></td>
                        <td><p>
                            0
                        </p><p style="color:blue;">0个</p></td>
                        <td><p>
                            TABLE
                        </p><p style="color:blue;">桌子</p></td>
                        <td><p>
                            Server
                        </p><p style="color:blue;">服务器</p></td>
                        <td><p>
                            Yes
                        </p><p style="color:blue;">是的</p></td>
                        <td><p>
                            Remains
                        </p><p style="color:blue;">遗骸</p></td>
                    </tr><tr valign="middle">
                        <td scope="row"><p>
                            OFF
                        </p><p style="color:blue;">关闭</p></td>
                        <td><p>
                            1
                        </p><p style="color:blue;">一</p></td>
                        <td><p>
                            Any
                        </p><p style="color:blue;">任何</p></td>
                        <td><p>
                            0
                        </p><p style="color:blue;">0个</p></td>
                        <td><p>
                            TABLE
                        </p><p style="color:blue;">桌子</p></td>
                        <td><p>
                            OS
                        </p><p style="color:blue;">操作系统</p></td>
                        <td><p>
                            No
                        </p><p style="color:blue;">不</p></td>
                        <td><p>
                            Remains
                        </p><p style="color:blue;">遗骸</p></td>
                    </tr><tr valign="middle">
                        <td scope="row"><p>
                            ON
                        </p><p style="color:blue;">打开</p></td>
                        <td>Any</td>
                        <td><p>
                            ON
                        </p><p style="color:blue;">打开</p></td>
                        <td><p>
                            1
                        </p><p style="color:blue;">1个</p></td>
                        <td><p>
                            Any
                        </p><p style="color:blue;">任何</p></td>
                        <td><p>
                            Any
                        </p><p style="color:blue;">任何</p></td>
                        <td><p>
                            Yes
                        </p><p style="color:blue;">是的</p></td>
                        <td><p>
                            Lost
                        </p><p style="color:blue;">迷路的</p></td>
                    </tr><tr valign="middle">
                        <td scope="row"><p>
                            ON
                        </p><p style="color:blue;">打开</p></td>
                        <td><p>
                            1
                        </p><p style="color:blue;">1个</p></td>
                        <td><p>
                            OFF
                        </p><p style="color:blue;">关闭</p></td>
                        <td><p>
                            0
                        </p><p style="color:blue;">0个</p></td>
                        <td><p>
                            TABLE
                        </p><p style="color:blue;">桌子</p></td>
                        <td><p>
                            Server
                        </p><p style="color:blue;">服务器</p></td>
                        <td><p>
                            Yes
                        </p><p style="color:blue;">是的</p></td>
                        <td><p>
                            Remains
                        </p><p style="color:blue;">遗骸</p></td>
                    </tr><tr valign="middle">
                        <td scope="row"><p>
                            ON
                        </p><p style="color:blue;">打开</p></td>
                        <td><p>
                            1
                        </p><p style="color:blue;">一</p></td>
                        <td><p>
                            OFF
                        </p><p style="color:blue;">关闭</p></td>
                        <td><p>
                            0
                        </p><p style="color:blue;">0个</p></td>
                        <td><p>
                            Any
                        </p><p style="color:blue;">任何</p></td>
                        <td><p>
                            OS
                        </p><p style="color:blue;">操作系统</p></td>
                        <td><p>
                            No
                        </p><p style="color:blue;">不</p></td>
                        <td><p>
                            Remains
                        </p><p style="color:blue;">遗骸</p></td>
                    </tr></tbody></table>
                </div>

            </div>
            <br class="table-break"><p>
            As the table shows, when using a multithreaded slave the following
            configurations are most resilient to unexpected halts:
        </p><p style="color:blue;">如表所示，当使用多线程从机时，以下配置对意外中断最具弹性：</p>
            <div class="itemizedlist">
                <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                    When using GTIDs and
                    <code class="literal">MASTER_AUTO_POSITION=ON</code>, set
                    <a class="link" href="replication.html#sysvar_relay_log_recovery"><code class="literal">relay_log_recovery=1</code></a>. With
                    this configuration the setting of
                    <a class="link" href="replication.html#sysvar_relay_log_info_repository"><code class="literal">relay_log_info_repository</code></a> and
                    other variables does not impact on recovery. From MySQL 5.7.28
                    a multithreaded slave automatically skips relay log recovery
                    when <code class="literal">MASTER_AUTO_POSITION</code> is set to
                    <code class="literal">ON</code>, so the setting for
                    <a class="link" href="replication.html#sysvar_relay_log_recovery"><code class="literal">relay_log_recovery</code></a> makes no
                    difference.

                </p><p style="color:blue;">当使用gtid和master_auto_position=on时，设置relay_log_recovery=1。使用此配置，中继日志信息库和其他变量的设置不会影响恢复。从mysql 5.7.28开始，当master_auto_position设置为on时，多线程从机自动跳过中继日志恢复，因此中继日志恢复的设置没有区别。</p></li><li class="listitem"><p>
                    When using file position based replication, set
                    <a class="link" href="replication.html#sysvar_relay_log_recovery"><code class="literal">relay_log_recovery=1</code></a>,
                    <a class="link" href="replication.html#sysvar_sync_relay_log"><code class="literal">sync_relay_log=1</code></a>, and
                    <a class="link" href="replication.html#sysvar_relay_log_info_repository"><code class="literal">relay_log_info_repository=TABLE</code></a>.

                </p><p style="color:blue;">使用基于文件位置的复制时，请设置relay_log_recovery=1、sync_relay_log=1和relay_log_info_repository=table。</p>
                    <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">

                        <div class="admon-title">
                            Note
                        </div>
                        <p>
                            During recovery the relay log is lost.
                        </p><p style="color:blue;">在恢复过程中，继电器日志丢失。</p>
                    </div>
                    <p>
                    </p></li></ul>
            </div>
            <p>
                It is important to note the impact of
                <a class="link" href="replication.html#sysvar_sync_relay_log"><code class="literal">sync_relay_log=1</code></a>, which requires
                a write of to the relay log per transaction. Although this setting
                is the most resilient to an unexpected halt, with at most one
                unwritten transaction being lost, it also has the potential to
                greatly increase the load on storage. Without
                <a class="link" href="replication.html#sysvar_sync_relay_log"><code class="literal">sync_relay_log=1</code></a>, the effect of
                an unexpected halt depends on how the relay log is handled by the
                operating system. Also note that when
                <a class="link" href="replication.html#sysvar_relay_log_recovery"><code class="literal">relay_log_recovery=0</code></a>, the next
                time the slave is started after an unexpected halt the relay log
                is processed as part of recovery. After this process completes,
                the relay log is deleted.
            </p><p style="color:blue;">重要的是要注意sync_relay_log=1的影响，它要求每个事务向中继日志写入。尽管此设置对意外停止最具弹性，最多会丢失一个未写入的事务，但它也有可能大大增加存储负载。如果sync_relay_log=1，则意外停止的效果取决于操作系统如何处理中继日志。还要注意，当relay_log_recovery=0时，在意外停止后下次启动从属服务器时，作为恢复的一部分处理中继日志。此过程完成后，将删除中继日志。</p><p>
            An unexpected halt of a multithreaded replication slave using the
            recommended file position based replication configuration above
            may result in a relay log with transaction inconsistencies (gaps
            in the sequence of transactions) caused by the unexpected halt.
            See
            <a class="xref" href="replication.html#replication-features-transaction-inconsistencies" title="16.4.1.32&nbsp;Replication and Transaction Inconsistencies">Section&nbsp;16.4.1.32, “Replication and Transaction Inconsistencies”</a>.
            In MySQL 5.7.13 and later, if the relay log recovery process
            encounters such transaction inconsistencies they are filled and
            the recovery process continues automatically. In MySQL versions
            prior to MySQL 5.7.13, this process was not automatic and required
            starting the server with
            <a class="link" href="replication.html#sysvar_relay_log_recovery"><code class="literal">relay_log_recovery=0</code></a>, starting
            the slave with <a class="link" href="sql-syntax.html#start-slave" title="13.4.2.6&nbsp;START SLAVE Syntax"><code class="literal">START
            SLAVE UNTIL SQL_AFTER_MTS_GAPS</code></a> to fix any transaction
            inconsistencies, and then restarting the slave with
            <a class="link" href="replication.html#sysvar_relay_log_recovery"><code class="literal">relay_log_recovery=1</code></a>.
        </p><p style="color:blue;">使用上述建议的基于文件位置的复制配置意外停止多线程复制从属服务器可能会导致中继日志中的事务不一致（事务序列中的间隙）由意外停止引起。见第16.4.1.32节，“复制和事务不一致”。在mysql 5.7.13及更高版本中，如果中继日志恢复过程遇到此类事务不一致，则它们将被填充，恢复过程将自动继续。在MySQL 5.7.13之前的MySQL版本中，此过程不是自动的，需要以relay_log_recovery=0启动服务器，以start slave启动从属服务器，直到sql_after_mts_gaps修复任何事务不一致，然后以relay_log_recovery=1重新启动从属服务器。</p><p>
            When you are using multi-source replication and
            <a class="link" href="replication.html#sysvar_relay_log_recovery"><code class="literal">relay_log_recovery=1</code></a>, after
            restarting due to an unexpected halt all replication channels go
            through the relay log recovery process. Any inconsistencies found
            in the relay log due to an unexpected halt of a multithreaded
            slave are filled.
        </p><p style="color:blue;">当您使用多源复制且中继日志恢复=1时，由于意外停止而重新启动后，所有复制通道都将通过中继日志恢复过程。由于多线程从属服务器意外停止而在中继日志中发现的任何不一致都将被填充。</p>
        </div>
        <div class="section">
            <div class="titlepage">
                <div>
                    <div>
                        <h3 class="title"><a name="replication-solutions-diffengines"></a>16.3.3&nbsp;Using Replication with Different Master and Slave Storage Engines</h3>

                    </div>

                </div>

            </div>
            <p>
                It does not matter for the replication process whether the source
                table on the master and the replicated table on the slave use
                different engine types. In fact, the
                <a class="link" href="server-administration.html#sysvar_default_storage_engine"><code class="literal">default_storage_engine</code></a> and
                <a class="link" href="server-administration.html#sysvar_storage_engine"><code class="literal">storage_engine</code></a> system variables
                are not replicated.
            </p><p style="color:blue;">对于复制过程来说，主表上的源表和从表上的复制表是否使用不同的引擎类型并不重要。实际上，不会复制默认的存储引擎和存储引擎系统变量。</p><p>
            This provides a number of benefits in the replication process in
            that you can take advantage of different engine types for
            different replication scenarios. For example, in a typical
            scale-out scenario (see
            <a class="xref" href="replication.html#replication-solutions-scaleout" title="16.3.4&nbsp;Using Replication for Scale-Out">Section&nbsp;16.3.4, “Using Replication for Scale-Out”</a>), you want to use
            <code class="literal">InnoDB</code> tables on the master to take advantage
            of the transactional functionality, but use
            <code class="literal">MyISAM</code> on the slaves where transaction support
            is not required because the data is only read. When using
            replication in a data-logging environment you may want to use the
            <code class="literal">Archive</code> storage engine on the slave.
        </p><p style="color:blue;">这在复制过程中提供了许多好处，因为您可以针对不同的复制方案利用不同的引擎类型。例如，在典型的横向扩展场景中（请参阅第16.3.4节“使用复制进行横向扩展”），您希望在主服务器上使用innodb表来利用事务功能，但在不需要事务支持的从属服务器上使用myisam，因为只读取数据。在数据日志环境中使用复制时，您可能希望在从属服务器上使用存档存储引擎。</p><p>
            Configuring different engines on the master and slave depends on
            how you set up the initial replication process:
        </p><p style="color:blue;">在主服务器和从服务器上配置不同的引擎取决于您如何设置初始复制过程：</p>
            <div class="itemizedlist">
                <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                    If you used <a class="link" href="programs.html#mysqldump" title="4.5.4&nbsp;mysqldump — A Database Backup Program"><span class="command"><strong>mysqldump</strong></span></a> to create the
                    database snapshot on your master, you could edit the dump file
                    text to change the engine type used on each table.
                </p><p style="color:blue;">如果使用mysqldump在主服务器上创建数据库快照，则可以编辑转储文件文本以更改每个表上使用的引擎类型。</p><p>
                    Another alternative for <a class="link" href="programs.html#mysqldump" title="4.5.4&nbsp;mysqldump — A Database Backup Program"><span class="command"><strong>mysqldump</strong></span></a> is to
                    disable engine types that you do not want to use on the slave
                    before using the dump to build the data on the slave. For
                    example, you can add the
                    <a class="link" href="innodb-storage-engine.html#option_mysqld_innodb"><code class="option">--skip-federated</code></a>
                    option on your slave to disable the
                    <code class="literal">FEDERATED</code> engine. If a specific engine does
                    not exist for a table to be created, MySQL will use the
                    default engine type, usually <code class="literal">MyISAM</code>. (This
                    requires that the
                    <a class="link" href="server-administration.html#sqlmode_no_engine_substitution"><code class="literal">NO_ENGINE_SUBSTITUTION</code></a> SQL
                    mode is not enabled.) If you want to disable additional
                    engines in this way, you may want to consider building a
                    special binary to be used on the slave that only supports the
                    engines you want.
                </p><p style="color:blue;">mysqldump的另一种替代方法是在使用转储在从属服务器上构建数据之前禁用不想在从属服务器上使用的引擎类型。例如，可以在从机上添加--skip联邦选项来禁用联邦引擎。如果要创建一个表不存在特定的引擎，MySQL将使用默认的引擎类型，通常是MyISAM。（这要求不启用“无引擎替换”SQL模式。）如果要以这种方式禁用其他引擎，可以考虑在仅支持所需引擎的从属服务器上生成要使用的特殊二进制文件。</p></li><li class="listitem"><p>
                    If you are using raw data files (a binary backup) to set up
                    the slave, you will be unable to change the initial table
                    format. Instead, use <a class="link" href="sql-syntax.html#alter-table" title="13.1.8&nbsp;ALTER TABLE Syntax"><code class="literal">ALTER
                    TABLE</code></a> to change the table types after the slave has
                    been started.
                </p><p style="color:blue;">如果使用原始数据文件（二进制备份）设置从机，则无法更改初始表格式。相反，使用alter table在从机启动后更改表类型。</p></li><li class="listitem"><p>
                    For new master/slave replication setups where there are
                    currently no tables on the master, avoid specifying the engine
                    type when creating new tables.
                </p><p style="color:blue;">对于新的主/从复制设置（其中主上当前没有表），请在创建新表时避免指定引擎类型。</p></li></ul>
            </div>
            <p>
                If you are already running a replication solution and want to
                convert your existing tables to another engine type, follow these
                steps:
            </p><p style="color:blue;">如果已经运行复制解决方案，并希望将现有表转换为另一种引擎类型，请执行以下步骤：</p>
            <div class="orderedlist">
                <ol class="orderedlist" type="1"><li class="listitem"><p>
                    Stop the slave from running replication updates:
                </p><p style="color:blue;">停止从机运行复制更新：</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>STOP SLAVE;</code></strong>
</pre><p>
                    This will enable you to change engine types without
                    interruptions.
                </p><p style="color:blue;">这将使您能够在不中断的情况下更改引擎类型。</p></li><li class="listitem"><p>
                    Execute an <code class="literal">ALTER TABLE ...
                    ENGINE='<em class="replaceable"><code>engine_type</code></em>'</code> for
                    each table to be changed.
                </p><p style="color:blue;">执行alter表…要更改的每个表的“engine=”engine\u type“。</p></li><li class="listitem"><p>
                    Start the slave replication process again:
                </p><p style="color:blue;">再次启动从复制过程：</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>START SLAVE;</code></strong>
</pre></li></ol>
            </div>
            <p>
                Although the
                <a class="link" href="server-administration.html#sysvar_default_storage_engine"><code class="literal">default_storage_engine</code></a> variable
                is not replicated, be aware that <a class="link" href="sql-syntax.html#create-table" title="13.1.18&nbsp;CREATE TABLE Syntax"><code class="literal">CREATE
                TABLE</code></a> and <a class="link" href="sql-syntax.html#alter-table" title="13.1.8&nbsp;ALTER TABLE Syntax"><code class="literal">ALTER TABLE</code></a>
                statements that include the engine specification will be correctly
                replicated to the slave. For example, if you have a CSV table and
                you execute:
            </p><p style="color:blue;">尽管未复制默认的存储引擎变量，但请注意，包含引擎规范的CREATE TABLE和ALTER TABLE语句将正确地复制到从机。例如，如果您有一个csv表并执行：</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>ALTER TABLE csvtable Engine='MyISAM';</code></strong>
</pre><p>
            The above statement will be replicated to the slave and the engine
            type on the slave will be converted to <code class="literal">MyISAM</code>,
            even if you have previously changed the table type on the slave to
            an engine other than CSV. If you want to retain engine differences
            on the master and slave, you should be careful to use the
            <a class="link" href="server-administration.html#sysvar_default_storage_engine"><code class="literal">default_storage_engine</code></a> variable
            on the master when creating a new table. For example, instead of:
        </p><p style="color:blue;">上面的语句将复制到从机，并且从机上的引擎类型将转换为myisam，即使您以前已将从机上的表类型更改为csv以外的引擎。如果要在主表和从表上保留引擎差异，则在创建新表时应小心在主表上使用默认的存储引擎变量。例如，而不是：</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>CREATE TABLE tablea (columna int) Engine=MyISAM;</code></strong>
</pre><p>
            Use this format:
        </p><p style="color:blue;">使用此格式：</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>SET default_storage_engine=MyISAM;</code></strong>
mysql&gt; <strong class="userinput"><code>CREATE TABLE tablea (columna int);</code></strong>
</pre><p>
            When replicated, the
            <a class="link" href="server-administration.html#sysvar_default_storage_engine"><code class="literal">default_storage_engine</code></a> variable
            will be ignored, and the <a class="link" href="sql-syntax.html#create-table" title="13.1.18&nbsp;CREATE TABLE Syntax"><code class="literal">CREATE
            TABLE</code></a> statement will execute on the slave using the
            slave's default engine.
        </p><p style="color:blue;">复制时，默认的存储引擎变量将被忽略，并且create table语句将使用从机的默认引擎在从机上执行。</p>
        </div>
        <div class="section">
            <div class="titlepage">
                <div>
                    <div>
                        <h3 class="title"><a name="replication-solutions-scaleout"></a>16.3.4&nbsp;Using Replication for Scale-Out</h3>

                    </div>

                </div>

            </div>
            <p>
                You can use replication as a scale-out solution; that is, where
                you want to split up the load of database queries across multiple
                database servers, within some reasonable limitations.
            </p><p style="color:blue;">您可以使用复制作为扩展解决方案；也就是说，您希望在一些合理的限制内跨多个数据库服务器分割数据库查询的负载。</p><p>
            Because replication works from the distribution of one master to
            one or more slaves, using replication for scale-out works best in
            an environment where you have a high number of reads and low
            number of writes/updates. Most websites fit into this category,
            where users are browsing the website, reading articles, posts, or
            viewing products. Updates only occur during session management, or
            when making a purchase or adding a comment/message to a forum.
        </p><p style="color:blue;">因为复制是从一个主服务器分发到一个或多个从服务器的，所以使用复制进行横向扩展在您具有大量读取和少量写入/更新的环境中最有效。大多数网站都属于这一类，用户在其中浏览网站、阅读文章、发帖或查看产品。更新仅在会话管理期间发生，或者在购买或向论坛添加评论/消息时发生。</p><p>
            Replication in this situation enables you to distribute the reads
            over the replication slaves, while still enabling your web servers
            to communicate with the replication master when a write is
            required. You can see a sample replication layout for this
            scenario in <a class="xref" href="replication.html#figure_replication-scaleout" title="Figure&nbsp;16.1&nbsp;Using Replication to Improve Performance During Scale-Out">Figure&nbsp;16.1, “Using Replication to Improve Performance During Scale-Out”</a>.
        </p><p style="color:blue;">在这种情况下，复制使您能够通过复制从属服务器分发读操作，同时在需要写操作时仍然使您的web服务器能够与复制主服务器通信。您可以在图16.1“使用复制来提高扩展期间的性能”中看到此场景的复制布局示例。</p>
            <div class="figure">
                <a name="figure_replication-scaleout"></a><p class="title"><b>Figure&nbsp;16.1&nbsp;Using Replication to Improve Performance During Scale-Out</b></p><p style="color:blue;">图16.1在扩展期间使用复制来提高性能</p>
                <div class="figure-contents">

                    <div class="mediaobject">
                        <img src="images/scaleout.png" width="687" height="341" alt="Incoming requests from clients are directed to a load balancer, which distributes client data among a number of web clients. Writes made by web clients are directed to a single MySQL master server, and reads made by web clients are directed to one of three MySQL slave servers. Replication takes place from the MySQL master server to the three MySQL slave servers.">
                    </div>

                </div>

            </div>
            <br class="figure-break"><p>
            If the part of your code that is responsible for database access
            has been properly abstracted/modularized, converting it to run
            with a replicated setup should be very smooth and easy. Change the
            implementation of your database access to send all writes to the
            master, and to send reads to either the master or a slave. If your
            code does not have this level of abstraction, setting up a
            replicated system gives you the opportunity and motivation to
            clean it up. Start by creating a wrapper library or module that
            implements the following functions:
        </p><p style="color:blue;">如果负责数据库访问的代码部分已经被正确地抽象/模块化，那么将其转换为使用复制的设置运行应该非常顺利和容易。更改数据库访问的实现，将所有写操作发送到主服务器，并将读操作发送到主服务器或从服务器。如果您的代码没有这种抽象级别，那么设置一个复制的系统将为您提供清理它的机会和动力。首先创建实现以下功能的包装库或模块：</p>
            <div class="itemizedlist">
                <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                    <code class="literal">safe_writer_connect()</code>
                </p><p style="color:blue;">安全写入程序连接（）</p></li><li class="listitem"><p>
                    <code class="literal">safe_reader_connect()</code>
                </p><p style="color:blue;">安全读卡器连接（）</p></li><li class="listitem"><p>
                    <code class="literal">safe_reader_statement()</code>
                </p><p style="color:blue;">安全读卡器语句（）</p></li><li class="listitem"><p>
                    <code class="literal">safe_writer_statement()</code>
                </p><p style="color:blue;">安全写入语句（）</p></li></ul>
            </div>
            <p>
                <code class="literal">safe_</code> in each function name means that the
                function takes care of handling all error conditions. You can use
                different names for the functions. The important thing is to have
                a unified interface for connecting for reads, connecting for
                writes, doing a read, and doing a write.
            </p><p style="color:blue;">每个函数名中的safe意味着该函数负责处理所有错误条件。可以为函数使用不同的名称。重要的是要有一个统一的接口来连接读、写、读、写。</p><p>
            Then convert your client code to use the wrapper library. This may
            be a painful and scary process at first, but it pays off in the
            long run. All applications that use the approach just described
            are able to take advantage of a master/slave configuration, even
            one involving multiple slaves. The code is much easier to
            maintain, and adding troubleshooting options is trivial. You need
            modify only one or two functions (for example, to log how long
            each statement took, or which statement among those issued gave
            you an error).
        </p><p style="color:blue;">然后将客户机代码转换为使用包装器库。起初，这可能是一个痛苦而可怕的过程，但从长远来看，这是值得的。使用上述方法的所有应用程序都能够利用主/从配置，甚至包括涉及多个从配置的主/从配置。代码更容易维护，添加故障排除选项也很简单。您只需要修改一个或两个函数（例如，记录每条语句花费的时间，或者发出的语句中哪个语句给了您一个错误）。</p><p>
            If you have written a lot of code, you may want to automate the
            conversion task by using the <a class="link" href="programs.html#replace-utility" title="4.8.3&nbsp;replace — A String-Replacement Utility"><span class="command"><strong>replace</strong></span></a> utility
            that comes with standard MySQL distributions, or write your own
            conversion script. Ideally, your code uses consistent programming
            style conventions. If not, then you are probably better off
            rewriting it anyway, or at least going through and manually
            regularizing it to use a consistent style.
        </p><p style="color:blue;">如果您已经编写了很多代码，那么您可能希望通过使用标准mysql发行版附带的replace实用程序自动执行转换任务，或者编写自己的转换脚本。理想情况下，您的代码使用一致的编程风格约定。如果不是，那么你最好还是重写它，或者至少通过手动调整它来使用一致的样式。</p>
        </div>
        <div class="section">
            <div class="titlepage">
                <div>
                    <div>
                        <h3 class="title"><a name="replication-solutions-partitioning"></a>16.3.5&nbsp;Replicating Different Databases to Different Slaves</h3>

                    </div>

                </div>

            </div>
            <p>
                There may be situations where you have a single master and want to
                replicate different databases to different slaves. For example,
                you may want to distribute different sales data to different
                departments to help spread the load during data analysis. A sample
                of this layout is shown in
                <a class="xref" href="replication.html#figure_replication-multi-db" title="Figure&nbsp;16.2&nbsp;Using Replication to Replicate Databases to Separate Replication Slaves">Figure&nbsp;16.2, “Using Replication to Replicate Databases to Separate Replication Slaves”</a>.
            </p><p style="color:blue;">在某些情况下，您可能只有一个主服务器，并且希望将不同的数据库复制到不同的从服务器。例如，您可能希望将不同的销售数据分发到不同的部门，以帮助在数据分析期间分散负载。此布局的示例如图16.2所示，“使用复制来复制数据库以分离复制从机”。</p>
            <div class="figure">
                <a name="figure_replication-multi-db"></a><p class="title"><b>Figure&nbsp;16.2&nbsp;Using Replication to Replicate Databases to Separate Replication Slaves</b></p><p style="color:blue;">图16.2使用复制将数据库复制到单独的复制从机</p>
                <div class="figure-contents">

                    <div class="mediaobject">
                        <img src="images/multi-db.png" width="424" height="178" alt="The MySQL master server has three databases, databaseA, databaseB, and databaseC. DatabaseA is replicated only to MySQL Slave 1, DatabaseB is replicated only to MySQL Slave 2, and DatabaseC is replicated only to MySQL Slave 3.">
                    </div>

                </div>

            </div>
            <br class="figure-break"><p>
            You can achieve this separation by configuring the master and
            slaves as normal, and then limiting the binary log statements that
            each slave processes by using the
            <a class="link" href="replication.html#option_mysqld_replicate-wild-do-table"><code class="option">--replicate-wild-do-table</code></a>
            configuration option on each slave.
        </p><p style="color:blue;">通过将主和从配置为正常，然后在每个从上使用--replicate wild do table配置选项限制每个从进程的二进制日志语句，可以实现这种分离。</p>
            <div class="important" style="margin-left: 0.5in; margin-right: 0.5in;">

                <div class="admon-title">
                    Important
                </div>
                <p>
                    You should <span class="emphasis"><em>not</em></span> use
                    <a class="link" href="replication.html#option_mysqld_replicate-do-db"><code class="option">--replicate-do-db</code></a> for this
                    purpose when using statement-based replication, since
                    statement-based replication causes this option's affects to
                    vary according to the database that is currently selected. This
                    applies to mixed-format replication as well, since this enables
                    some updates to be replicated using the statement-based format.
                </p><p style="color:blue;">在使用基于语句的复制时，不应为此目的使用--replicate do db，因为基于语句的复制会导致此选项的影响因当前选定的数据库而异。这也适用于混合格式复制，因为这允许使用基于语句的格式复制某些更新。</p><p>
                However, it should be safe to use
                <a class="link" href="replication.html#option_mysqld_replicate-do-db"><code class="option">--replicate-do-db</code></a> for this
                purpose if you are using row-based replication only, since in
                this case the currently selected database has no effect on the
                option's operation.
            </p><p style="color:blue;">但是，如果您只使用基于行的复制，那么使用--replicate do db应该是安全的，因为在这种情况下，当前选择的数据库对选项的操作没有影响。</p>
            </div>
            <p>
                For example, to support the separation as shown in
                <a class="xref" href="replication.html#figure_replication-multi-db" title="Figure&nbsp;16.2&nbsp;Using Replication to Replicate Databases to Separate Replication Slaves">Figure&nbsp;16.2, “Using Replication to Replicate Databases to Separate Replication Slaves”</a>, you should
                configure each replication slave as follows, before executing
                <a class="link" href="sql-syntax.html#start-slave" title="13.4.2.6&nbsp;START SLAVE Syntax"><code class="literal">START SLAVE</code></a>:
            </p><p style="color:blue;">例如，为了支持如图16.2所示的分离，“使用复制来复制数据库以分离复制从机”，在执行start slave之前，应按如下方式配置每个复制从机：</p>
            <div class="itemizedlist">
                <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                    Replication slave 1 should use
                    <code class="option">--replicate-wild-do-table=databaseA.%</code>.
                </p><p style="color:blue;">复制从机1应使用--replicate wild do table=databasea。%。</p></li><li class="listitem"><p>
                    Replication slave 2 should use
                    <code class="option">--replicate-wild-do-table=databaseB.%</code>.
                </p><p style="color:blue;">复制从机2应使用--replicate wild do table=databaseb。%。</p></li><li class="listitem"><p>
                    Replication slave 3 should use
                    <code class="option">--replicate-wild-do-table=databaseC.%</code>.
                </p><p style="color:blue;">复制从机3应使用--replicate wild do table=databasec。%。</p></li></ul>
            </div>
            <p>
                Each slave in this configuration receives the entire binary log
                from the master, but executes only those events from the binary
                log that apply to the databases and tables included by the
                <a class="link" href="replication.html#option_mysqld_replicate-wild-do-table"><code class="option">--replicate-wild-do-table</code></a> option in
                effect on that slave.
            </p><p style="color:blue;">此配置中的每个从属服务器都从主服务器接收整个二进制日志，但仅执行应用于该从属服务器上--replicate wild do table选项包含的数据库和表的二进制日志中的事件。</p><p>
            If you have data that must be synchronized to the slaves before
            replication starts, you have a number of choices:
        </p><p style="color:blue;">如果在复制开始之前必须将数据同步到从属服务器，则有许多选择：</p>
            <div class="itemizedlist">
                <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                    Synchronize all the data to each slave, and delete the
                    databases, tables, or both that you do not want to keep.
                </p><p style="color:blue;">将所有数据同步到每个从机，并删除不希望保留的数据库、表或两者。</p></li><li class="listitem"><p>
                    Use <a class="link" href="programs.html#mysqldump" title="4.5.4&nbsp;mysqldump — A Database Backup Program"><span class="command"><strong>mysqldump</strong></span></a> to create a separate dump
                    file for each database and load the appropriate dump file on
                    each slave.
                </p><p style="color:blue;">使用mysqldump为每个数据库创建一个单独的转储文件，并在每个从机上加载相应的转储文件。</p></li><li class="listitem"><p>
                    Use a raw data file dump and include only the specific files
                    and databases that you need for each slave.
                </p><p style="color:blue;">使用原始数据文件转储，并仅包含每个从机所需的特定文件和数据库。</p>
                    <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">

                        <div class="admon-title">
                            Note
                        </div>
                        <p>
                            This does not work with <a class="link" href="innodb-storage-engine.html" title="Chapter&nbsp;14&nbsp;The InnoDB Storage Engine"><code class="literal">InnoDB</code></a>
                            databases unless you use
                            <a class="link" href="innodb-storage-engine.html#sysvar_innodb_file_per_table"><code class="literal">innodb_file_per_table</code></a>.
                        </p><p style="color:blue;">除非使用innodb file_per_表，否则这不适用于innodb数据库。</p>
                    </div>
                </li></ul>
            </div>

        </div>
        <div class="section">
            <div class="titlepage">
                <div>
                    <div>
                        <h3 class="title"><a name="replication-solutions-performance"></a>16.3.6&nbsp;Improving Replication Performance</h3>

                    </div>

                </div>

            </div>
            <p>
                As the number of slaves connecting to a master increases, the
                load, although minimal, also increases, as each slave uses a
                client connection to the master. Also, as each slave must receive
                a full copy of the master binary log, the network load on the
                master may also increase and create a bottleneck.
            </p><p style="color:blue;">随着连接到主服务器的从属服务器数量的增加，负载虽然最小，但也会随着每个从属服务器使用到主服务器的客户端连接而增加。此外，由于每个从机必须接收主二进制日志的完整副本，因此主机上的网络负载也可能增加并造成瓶颈。</p><p>
            If you are using a large number of slaves connected to one master,
            and that master is also busy processing requests (for example, as
            part of a scale-out solution), then you may want to improve the
            performance of the replication process.
        </p><p style="color:blue;">如果正在使用连接到一个主服务器的大量从属服务器，而该主服务器也正忙于处理请求（例如，作为扩展解决方案的一部分），则可能需要提高复制进程的性能。</p><p>
            One way to improve the performance of the replication process is
            to create a deeper replication structure that enables the master
            to replicate to only one slave, and for the remaining slaves to
            connect to this primary slave for their individual replication
            requirements. A sample of this structure is shown in
            <a class="xref" href="replication.html#figure_replication-performance" title="Figure&nbsp;16.3&nbsp;Using an Additional Replication Host to Improve Performance">Figure&nbsp;16.3, “Using an Additional Replication Host to Improve Performance”</a>.
        </p><p style="color:blue;">提高复制过程性能的一种方法是创建一个更深层的复制结构，使主服务器能够只复制到一个从服务器，并使其余的从服务器连接到这个主服务器以满足其各自的复制需求。此结构的示例如图16.3所示，“使用附加复制主机来提高性能”。</p>
            <div class="figure">
                <a name="figure_replication-performance"></a><p class="title"><b>Figure&nbsp;16.3&nbsp;Using an Additional Replication Host to Improve Performance</b></p><p style="color:blue;">图16.3使用额外的复制主机来提高性能</p>
                <div class="figure-contents">

                    <div class="mediaobject">
                        <img src="images/submaster-performance.png" width="534" height="179" alt="The server MySQL Master 1 replicates to the server MySQL Master 2, which in turn replicates to the servers MySQL Slave 1, MySQL Slave 2, and MySQL Slave 3.">
                    </div>

                </div>

            </div>
            <br class="figure-break"><p>
            For this to work, you must configure the MySQL instances as
            follows:
        </p><p style="color:blue;">为此，必须按如下方式配置mysql实例：</p>
            <div class="itemizedlist">
                <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                    Master 1 is the primary master where all changes and updates
                    are written to the database. Binary logging should be enabled
                    on this machine.
                </p><p style="color:blue;">master 1是将所有更改和更新写入数据库的主master。应在此计算机上启用二进制日志记录。</p></li><li class="listitem"><p>
                    Master 2 is the slave to the Master 1 that provides the
                    replication functionality to the remainder of the slaves in
                    the replication structure. Master 2 is the only machine
                    permitted to connect to Master 1. Master 2 also has binary
                    logging enabled, and the
                    <a class="link" href="replication.html#sysvar_log_slave_updates"><code class="literal">log_slave_updates</code></a> system
                    variable enabled so that replication instructions from Master
                    1 are also written to Master 2's binary log so that they can
                    then be replicated to the true slaves.
                </p><p style="color:blue;">主2是主1的从机，它为复制结构中的其余从机提供复制功能。主机2是唯一允许连接到主机1的机器。master 2还启用了二进制日志记录，log_slave_会更新启用的系统变量，以便来自master 1的复制指令也会写入master 2的二进制日志，以便它们可以复制到真正的从机。</p></li><li class="listitem"><p>
                    Slave 1, Slave 2, and Slave 3 act as slaves to Master 2, and
                    replicate the information from Master 2, which actually
                    consists of the upgrades logged on Master 1.
                </p><p style="color:blue;">从机1、从机2和从机3充当从机2，并从主机2复制信息，主机2实际上包括登录到主机1的升级。</p></li></ul>
            </div>
            <p>
                The above solution reduces the client load and the network
                interface load on the primary master, which should improve the
                overall performance of the primary master when used as a direct
                database solution.
            </p><p style="color:blue;">上述解决方案减少了主主机上的客户端负载和网络接口负载，在用作直接数据库解决方案时，主主机的总体性能应该会得到提高。</p><p>
            If your slaves are having trouble keeping up with the replication
            process on the master, there are a number of options available:
        </p><p style="color:blue;">如果您的从属服务器无法跟上主服务器上的复制过程，则有许多可用的选项：</p>
            <div class="itemizedlist">
                <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                    If possible, put the relay logs and the data files on
                    different physical drives. To do this, set the
                    <a class="link" href="replication.html#sysvar_relay_log"><code class="literal">relay_log</code></a> system variable to
                    specify the location of the relay log.
                </p><p style="color:blue;">如果可能，将中继日志和数据文件放在不同的物理驱动器上。为此，请设置RELAY U LOG系统变量以指定中继日志的位置。</p></li><li class="listitem"><p>
                    If the slaves are significantly slower than the master, you
                    may want to divide up the responsibility for replicating
                    different databases to different slaves. See
                    <a class="xref" href="replication.html#replication-solutions-partitioning" title="16.3.5&nbsp;Replicating Different Databases to Different Slaves">Section&nbsp;16.3.5, “Replicating Different Databases to Different Slaves”</a>.
                </p><p style="color:blue;">如果从机比主机慢得多，则可能需要划分将不同数据库复制到不同从机的责任。参见第16.3.5节“将不同的数据库复制到不同的从机”。</p></li><li class="listitem"><p>
                    If your master makes use of transactions and you are not
                    concerned about transaction support on your slaves, use
                    <code class="literal">MyISAM</code> or another nontransactional engine
                    on the slaves. See
                    <a class="xref" href="replication.html#replication-solutions-diffengines" title="16.3.3&nbsp;Using Replication with Different Master and Slave Storage Engines">Section&nbsp;16.3.3, “Using Replication with Different Master and Slave Storage Engines”</a>.
                </p><p style="color:blue;">如果您的主服务器使用事务，而您不关心从服务器上的事务支持，请在从服务器上使用myisam或其他非事务引擎。参见第16.3.3节，“使用不同主存储引擎和从存储引擎的复制”。</p></li><li class="listitem"><p>
                    If your slaves are not acting as masters, and you have a
                    potential solution in place to ensure that you can bring up a
                    master in the event of failure, then you can disable the
                    <a class="link" href="replication.html#sysvar_log_slave_updates"><code class="literal">log_slave_updates</code></a> system
                    variable on the slaves. This prevents <span class="quote">“<span class="quote">dumb</span>”</span>
                    slaves from also logging events they have executed into their
                    own binary log.
                </p><p style="color:blue;">如果您的从机不充当主机，并且您有一个潜在的解决方案来确保在发生故障时可以启动主机，则可以禁用从机上的LOG U SLAVE U UPDATES系统变量。这可以防止“哑”从机也将它们执行的事件记录到自己的二进制日志中。</p></li></ul>
            </div>

        </div>
        <div class="section">
            <div class="titlepage">
                <div>
                    <div>
                        <h3 class="title"><a name="replication-solutions-switch"></a>16.3.7&nbsp;Switching Masters During Failover</h3>

                    </div>

                </div>

            </div>
            <p>
                You can tell a slave to change to a new master using the
                <a class="link" href="sql-syntax.html#change-master-to" title="13.4.2.1&nbsp;CHANGE MASTER TO Syntax"><code class="literal">CHANGE MASTER TO</code></a> statement. The
                slave does not check whether the databases on the master are
                compatible with those on the slave; it simply begins reading and
                executing events from the specified coordinates in the new
                master's binary log. In a failover situation, all the servers
                in the group are typically executing the same events from the same
                binary log file, so changing the source of the events should not
                affect the structure or integrity of the database, provided that
                you exercise care in making the change.
            </p><p style="color:blue;">您可以使用change master to语句告诉从属服务器更改为新的主服务器。从服务器不检查主服务器上的数据库是否与从服务器上的数据库兼容；它只是从新主机二进制日志中指定的坐标开始读取和执行事件。在故障转移情况下，组中的所有服务器通常从同一个二进制日志文件执行相同的事件，因此更改事件源不应影响数据库的结构或完整性，前提是您在进行更改时要小心。</p><p>
            Slaves should be run with the
            <a class="link" href="replication.html#option_mysqld_log-bin"><code class="option">--log-bin</code></a> option, and if not using
            GTIDs then they should also be run without enabling the
            <a class="link" href="replication.html#sysvar_log_slave_updates"><code class="literal">log_slave_updates</code></a> system
            variable. In this way, the slave is ready to become a master
            without restarting the slave <a class="link" href="programs.html#mysqld" title="4.3.1&nbsp;mysqld — The MySQL Server"><span class="command"><strong>mysqld</strong></span></a>. Assume
            that you have the structure shown in
            <a class="xref" href="replication.html#figure_replication-redundancy-before" title="Figure&nbsp;16.4&nbsp;Redundancy Using Replication, Initial Structure">Figure&nbsp;16.4, “Redundancy Using Replication, Initial Structure”</a>.
        </p><p style="color:blue;">从系统应该使用--log bin选项运行，如果不使用gtid，那么它们也应该在不启用log slave_updates系统变量的情况下运行。这样，从机就可以成为主机，而无需重新启动从机mysqld。假设您拥有图16.4“使用复制的冗余，初始结构”所示的结构。</p>
            <div class="figure">
                <a name="figure_replication-redundancy-before"></a><p class="title"><b>Figure&nbsp;16.4&nbsp;Redundancy Using Replication, Initial Structure</b></p><p style="color:blue;">图16.4使用复制的冗余，初始结构</p>
                <div class="figure-contents">

                    <div class="mediaobject">
                        <img src="images/redundancy-before.png" width="504" height="353" alt="Two web clients direct both database reads and database writes to a single MySQL master server. The MySQL master server replicates to MySQL Slave 1, MySQL Slave 2, and MySQL Slave 3.">
                    </div>

                </div>

            </div>
            <br class="figure-break"><p>
            In this diagram, the <code class="literal">MySQL Master</code> holds the
            master database, the <code class="literal">MySQL Slave</code> hosts are
            replication slaves, and the <code class="literal">Web Client</code> machines
            are issuing database reads and writes. Web clients that issue only
            reads (and would normally be connected to the slaves) are not
            shown, as they do not need to switch to a new server in the event
            of failure. For a more detailed example of a read/write scale-out
            replication structure, see
            <a class="xref" href="replication.html#replication-solutions-scaleout" title="16.3.4&nbsp;Using Replication for Scale-Out">Section&nbsp;16.3.4, “Using Replication for Scale-Out”</a>.
        </p><p style="color:blue;">在这个图中，mysql master保存主数据库，mysql slave主机是复制从机，web客户机发出数据库读写操作。不会显示只发出读操作（通常连接到从服务器）的Web客户端，因为它们在发生故障时不需要切换到新服务器。有关读/写扩展复制结构的更详细示例，请参阅第16.3.4节“使用复制进行扩展”。</p><p>
            Each MySQL Slave (<code class="literal">Slave 1</code>, <code class="literal">Slave
            2</code>, and <code class="literal">Slave 3</code>) is a slave running
            with <a class="link" href="replication.html#option_mysqld_log-bin"><code class="option">--log-bin</code></a> and without enabling
            the <a class="link" href="replication.html#sysvar_log_slave_updates"><code class="literal">log_slave_updates</code></a> system
            variable. Because updates received by a slave from the master are
            not logged in the binary log unless
            <a class="link" href="replication.html#sysvar_log_slave_updates"><code class="literal">log_slave_updates</code></a> is enabled, the
            binary log on each slave is empty initially. If for some reason
            <code class="literal">MySQL Master</code> becomes unavailable, you can pick
            one of the slaves to become the new master. For example, if you
            pick <code class="literal">Slave 1</code>, all <code class="literal">Web
            Clients</code> should be redirected to <code class="literal">Slave
            1</code>, which writes the updates to its binary log.
            <code class="literal">Slave 2</code> and <code class="literal">Slave 3</code> should
            then replicate from <code class="literal">Slave 1</code>.
        </p><p style="color:blue;">每个mysql slave（slave 1、slave 2和slave 3）都是一个使用--log bin运行的slave，而不启用logu slave_updates系统变量。因为从机从主机接收到的更新不会记录在二进制日志中，除非启用了log_slave_updates，否则每个从机上的二进制日志最初都是空的。如果由于某种原因mysql master变得不可用，您可以选择其中一个从机成为新的主机。例如，如果选择slave 1，则所有web客户端都应重定向到slave1，slave1将更新写入其二进制日志。从机2和从机3应该从从机1复制。</p><p>
            The reason for running the slave without
            <a class="link" href="replication.html#sysvar_log_slave_updates"><code class="literal">log_slave_updates</code></a> enabled is to
            prevent slaves from receiving updates twice in case you cause one
            of the slaves to become the new master. If <code class="literal">Slave
            1</code> has <a class="link" href="replication.html#sysvar_log_slave_updates"><code class="literal">log_slave_updates</code></a>
            enabled, it writes any updates that it receives from
            <code class="literal">Master</code> in its own binary log. This means that,
            when <code class="literal">Slave 2</code> changes from
            <code class="literal">Master</code> to <code class="literal">Slave 1</code> as its
            master, it may receive updates from <code class="literal">Slave 1</code>
            that it has already received from <code class="literal">Master</code>.
        </p><p style="color:blue;">在未启用Log_Slave_Updates的情况下运行从机的原因是为了防止从机接收两次更新，以防您导致其中一个从机成为新的主机。如果slave 1启用了log_slave_updates，它将从master收到的任何更新写入自己的二进制日志。这意味着，当从机2从主机变为从机1作为其主机时，它可以从从机1接收已经从主机接收到的更新。</p><p>
            Make sure that all slaves have processed any statements in their
            relay log. On each slave, issue <code class="literal">STOP SLAVE
            IO_THREAD</code>, then check the output of
            <a class="link" href="sql-syntax.html#show-processlist" title="13.7.5.29&nbsp;SHOW PROCESSLIST Syntax"><code class="literal">SHOW PROCESSLIST</code></a> until you see
            <code class="literal">Has read all relay log</code>. When this is true for
            all slaves, they can be reconfigured to the new setup. On the
            slave <code class="literal">Slave 1</code> being promoted to become the
            master, issue <a class="link" href="sql-syntax.html#stop-slave" title="13.4.2.7&nbsp;STOP SLAVE Syntax"><code class="literal">STOP SLAVE</code></a> and
            <a class="link" href="sql-syntax.html#reset-master" title="13.4.1.2&nbsp;RESET MASTER Syntax"><code class="literal">RESET MASTER</code></a>.
        </p><p style="color:blue;">确保所有从机都已处理其中继日志中的任何语句。在每个从机上，发出stop slave io_thread，然后检查show processlist的输出，直到您看到has read all relay log。如果对所有从机都是这样，则可以将它们重新配置为新的设置。在从机1被提升为主机时，发出停止从机和复位主机。</p><p>
            On the other slaves <code class="literal">Slave 2</code> and <code class="literal">Slave
            3</code>, use <a class="link" href="sql-syntax.html#stop-slave" title="13.4.2.7&nbsp;STOP SLAVE Syntax"><code class="literal">STOP SLAVE</code></a> and
            <code class="literal">CHANGE MASTER TO MASTER_HOST='Slave1'</code> (where
            <code class="literal">'Slave1'</code> represents the real host name of
            <code class="literal">Slave 1</code>). To use <code class="literal">CHANGE MASTER
            TO</code>, add all information about how to connect to
            <code class="literal">Slave 1</code> from <code class="literal">Slave 2</code> or
            <code class="literal">Slave 3</code> (<em class="replaceable"><code>user</code></em>,
            <em class="replaceable"><code>password</code></em>,
            <em class="replaceable"><code>port</code></em>). When issuing the <code class="literal">CHANGE
            MASTER TO</code> statement in this, there is no need to specify
            the name of the <code class="literal">Slave 1</code> binary log file or log
            position to read from, since the first binary log file and
            position 4, are the defaults. Finally, execute
            <a class="link" href="sql-syntax.html#start-slave" title="13.4.2.6&nbsp;START SLAVE Syntax"><code class="literal">START SLAVE</code></a> on <code class="literal">Slave
            2</code> and <code class="literal">Slave 3</code>.
        </p><p style="color:blue;">在其他从机slave 2和从机3上，使用stop slave并将master更改为master_host='slave1'（其中'slave1'表示从机1的真实主机名）。若要使用“将主服务器更改为”，请添加有关如何从从从服务器2或从服务器3（用户、密码、端口）连接到从服务器1的所有信息。在这里发出change master to语句时，不需要指定slave 1二进制日志文件的名称或要读取的日志位置，因为第一个二进制日志文件和位置4是默认值。最后，在从机2和从机3上执行start slave。</p><p>
            Once the new replication setup is in place, you need to tell each
            <code class="literal">Web Client</code> to direct its statements to
            <code class="literal">Slave 1</code>. From that point on, all updates
            statements sent by <code class="literal">Web Client</code> to <code class="literal">Slave
            1</code> are written to the binary log of <code class="literal">Slave
            1</code>, which then contains every update statement sent to
            <code class="literal">Slave 1</code> since <code class="literal">Master</code> died.
        </p><p style="color:blue;">一旦新的复制设置就位，就需要告诉每个web客户机将其语句定向到slave 1。从那时起，web客户机发送给slave 1的所有updates语句都被写入slave1的二进制日志，然后该日志包含自master死亡以来发送给slave1的每个update语句。</p><p>
            The resulting server structure is shown in
            <a class="xref" href="replication.html#figure_replication-redundancy-after" title="Figure&nbsp;16.5&nbsp;Redundancy Using Replication, After Master Failure">Figure&nbsp;16.5, “Redundancy Using Replication, After Master Failure”</a>.
        </p><p style="color:blue;">最终的服务器结构如图16.5“主故障后使用复制的冗余”所示。</p>
            <div class="figure">
                <a name="figure_replication-redundancy-after"></a><p class="title"><b>Figure&nbsp;16.5&nbsp;Redundancy Using Replication, After Master Failure</b></p><p style="color:blue;">图16.5主故障后使用复制的冗余</p>
                <div class="figure-contents">

                    <div class="mediaobject">
                        <img src="images/redundancy-after.png" width="538" height="432" alt="The MySQL master server has failed, and is no longer connected into the replication topology. The two web clients now direct both database reads and database writes to MySQL Slave 1, which is the new master. MySQL Slave 1 replicates to MySQL Slave 2 and MySQL Slave 3.">
                    </div>

                </div>

            </div>
            <br class="figure-break"><p>
            When <code class="literal">Master</code> becomes available again, you should
            make it a slave of <code class="literal">Slave 1</code>. To do this, issue
            on <code class="literal">Master</code> the same <a class="link" href="sql-syntax.html#change-master-to" title="13.4.2.1&nbsp;CHANGE MASTER TO Syntax"><code class="literal">CHANGE
            MASTER TO</code></a> statement as that issued on <code class="literal">Slave
            2</code> and <code class="literal">Slave 3</code> previously.
            <code class="literal">Master</code> then becomes a slave of <code class="literal">S1ave
            1</code> and picks up the <code class="literal">Web Client</code> writes
            that it missed while it was offline.
        </p><p style="color:blue;">当master再次可用时，您应该使其成为slave 1的slave。为此，在master上发出与先前在slave 2和slave 3上发出的相同的change master to语句。然后，master成为s1ave 1的一个从机，并接收它在脱机时丢失的web客户端写的内容。</p><p>
            To make <code class="literal">Master</code> a master again, use the
            preceding procedure as if <code class="literal">Slave 1</code> was
            unavailable and <code class="literal">Master</code> was to be the new
            master. During this procedure, do not forget to run
            <a class="link" href="sql-syntax.html#reset-master" title="13.4.1.2&nbsp;RESET MASTER Syntax"><code class="literal">RESET MASTER</code></a> on
            <code class="literal">Master</code> before making <code class="literal">Slave
            1</code>, <code class="literal">Slave 2</code>, and <code class="literal">Slave
            3</code> slaves of <code class="literal">Master</code>. If you fail to do
            this, the slaves may pick up stale writes from the <code class="literal">Web
            Client</code> applications dating from before the point at
            which <code class="literal">Master</code> became unavailable.
        </p><p style="color:blue;">要使master再次成为master，请使用前面的过程，就好像slave 1不可用，master将成为新的master一样。在此过程中，不要忘记在将从机1、从机2和从机3从机设为主机上运行重置主机。如果您不这样做，从服务器可能会从Web客户端应用程序中获取过时的写操作，这些写操作可以追溯到主服务器不可用之前。</p><p>
            You should be aware that there is no synchronization between
            slaves, even when they share the same master, and thus some slaves
            might be considerably ahead of others. This means that in some
            cases the procedure outlined in the previous example might not
            work as expected. In practice, however, relay logs on all slaves
            should be relatively close together.
        </p><p style="color:blue;">你应该知道，奴隶之间没有同步，即使他们共享同一个主人，因此有些奴隶可能远远领先于其他奴隶。这意味着在某些情况下，前面示例中概述的过程可能无法按预期工作。然而，实际上，所有从机上的中继日志应该相对靠近。</p><p>
            One way to keep applications informed about the location of the
            master is to have a dynamic DNS entry for the master. With
            <code class="literal">bind</code> you can use <code class="filename">nsupdate</code>
            to update the DNS dynamically.
        </p><p style="color:blue;">让应用程序了解主服务器位置的一种方法是为主服务器设置一个动态dns条目。使用bind，您可以使用nsupdate动态更新dns。</p>
        </div>
        <div class="section">
            <div class="titlepage">
                <div>
                    <div>
                        <h3 class="title"><a name="replication-solutions-encrypted-connections"></a>16.3.8&nbsp;Setting Up Replication to Use Encrypted Connections</h3>

                    </div>

                </div>

            </div>
            <p>
                To use an encrypted connection for the transfer of the binary log
                required during replication, both the master and the slave servers
                must support encrypted network connections. If either server does
                not support encrypted connections (because it has not been
                compiled or configured for them), replication through an encrypted
                connection is not possible.
            </p><p style="color:blue;">要使用加密连接传输复制期间所需的二进制日志，主服务器和从服务器都必须支持加密的网络连接。如果任一服务器不支持加密连接（因为尚未为它们编译或配置加密连接），则无法通过加密连接进行复制。</p><p>
            Setting up encrypted connections for replication is similar to
            doing so for client/server connections. You must obtain (or
            create) a suitable security certificate that you can use on the
            master, and a similar certificate (from the same certificate
            authority) on each slave. You must also obtain suitable key files.
        </p><p style="color:blue;">为复制设置加密连接类似于为客户端/服务器连接设置加密连接。您必须获得（或创建）一个可以在主服务器上使用的合适的安全证书，以及每个从服务器上的类似证书（来自同一证书颁发机构）。您还必须获得合适的密钥文件。</p><p>
            For more information on setting up a server and client for
            encrypted connections, see
            <a class="xref" href="security.html#using-encrypted-connections" title="6.3.1&nbsp;Configuring MySQL to Use Encrypted Connections">Section&nbsp;6.3.1, “Configuring MySQL to Use Encrypted Connections”</a>.
        </p><p style="color:blue;">有关为加密连接设置服务器和客户端的详细信息，请参阅6.3.1节“将MySQL配置为使用加密连接”。</p><p>
            To enable encrypted connections on the master, you must create or
            obtain suitable certificate and key files, and then add the
            following configuration options to the master's configuration
            within the <code class="literal">[mysqld]</code> section of the master's
            <code class="filename">my.cnf</code> file, changing the file names as
            necessary:
        </p><p style="color:blue;">要在主机上启用加密连接，必须创建或获取适当的证书和密钥文件，然后在主机的my.cnf文件的[mysqld]部分中向主机的配置添加以下配置选项，并根据需要更改文件名：</p><pre data-lang="ini" class="programlisting">[mysqld]
ssl-ca=cacert.pem
ssl-cert=server-cert.pem
ssl-key=server-key.pem
</pre><p>
            The paths to the files may be relative or absolute; we recommend
            that you always use complete paths for this purpose.
        </p><p style="color:blue;">文件的路径可以是相对的或绝对的；我们建议您始终为此目的使用完整的路径。</p><p>
            The options are as follows:
        </p><p style="color:blue;">选项如下：</p>
            <div class="itemizedlist">
                <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                    <a class="link" href="programs.html#option_general_ssl-ca"><code class="option">--ssl-ca</code></a>: The path name of the
                    Certificate Authority (CA) certificate file.
                    (<code class="option">--ssl-capath</code> is similar but specifies the
                    path name of a directory of CA certificate files.)
                </p><p style="color:blue;">--ssl ca：证书颁发机构（ca）证书文件的路径名。（-ssl ca path类似，但指定ca证书文件目录的路径名。）</p></li><li class="listitem"><p>
                    <a class="link" href="programs.html#option_general_ssl-cert"><code class="option">--ssl-cert</code></a>: The path name of
                    the server public key certificate file. This certificate can
                    be sent to the client and authenticated against the CA
                    certificate that it has.
                </p><p style="color:blue;">--ssl cert：服务器公钥证书文件的路径名。此证书可以发送到客户端，并根据其拥有的CA证书进行身份验证。</p></li><li class="listitem"><p>
                    <a class="link" href="programs.html#option_general_ssl-key"><code class="option">--ssl-key</code></a>: The path name of
                    the server private key file.
                </p><p style="color:blue;">--ssl key：服务器私钥文件的路径名。</p></li></ul>
            </div>
            <p>
                To enable encrypted connections on the slave, use the
                <a class="link" href="sql-syntax.html#change-master-to" title="13.4.2.1&nbsp;CHANGE MASTER TO Syntax"><code class="literal">CHANGE MASTER TO</code></a> statement. You can
                either name the slave certificate and SSL private key files
                required for the encrypted connection in the
                <code class="literal">[client]</code> section of the slave's
                <code class="filename">my.cnf</code> file, or you can explicitly specify
                that information using the <a class="link" href="sql-syntax.html#change-master-to" title="13.4.2.1&nbsp;CHANGE MASTER TO Syntax"><code class="literal">CHANGE MASTER
                TO</code></a> statement. For more information on the
                <a class="link" href="sql-syntax.html#change-master-to" title="13.4.2.1&nbsp;CHANGE MASTER TO Syntax"><code class="literal">CHANGE MASTER TO</code></a>
                statement, see <a class="xref" href="sql-syntax.html#change-master-to" title="13.4.2.1&nbsp;CHANGE MASTER TO Syntax">Section&nbsp;13.4.2.1, “CHANGE MASTER TO Syntax”</a>.
            </p><p style="color:blue;">要在从属服务器上启用加密连接，请使用change master to语句。您可以在从机的my.cnf文件的[client]部分中命名加密连接所需的从机证书和ssl私钥文件，也可以使用change master to语句显式指定该信息。有关将master更改为语句的更多信息，请参阅第13.4.2.1节“将master更改为语法”。</p>
            <div class="itemizedlist">
                <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                    To name the slave certificate and key files using an option
                    file, add the following lines to the
                    <code class="literal">[client]</code> section of the slave's
                    <code class="filename">my.cnf</code> file, changing the file names as
                    necessary:
                </p><p style="color:blue;">要使用选项文件命名从属证书和密钥文件，请将以下行添加到从属的my.cnf文件的[客户端]部分，并根据需要更改文件名：</p><pre data-lang="ini" class="programlisting">[client]
ssl-ca=cacert.pem
ssl-cert=client-cert.pem
ssl-key=client-key.pem
</pre></li><li class="listitem"><p>
                    Restart the slave server, using the
                    <a class="link" href="replication.html#option_mysqld_skip-slave-start"><code class="option">--skip-slave-start</code></a> option to
                    prevent the slave from connecting to the master. Use
                    <a class="link" href="sql-syntax.html#change-master-to" title="13.4.2.1&nbsp;CHANGE MASTER TO Syntax"><code class="literal">CHANGE MASTER TO</code></a> to specify the
                    master configuration, and add the
                    <code class="literal">MASTER_SSL</code> option to connect using
                    encryption:
                </p><p style="color:blue;">重新启动从属服务器，使用--skip slave start选项防止从属服务器连接到主服务器。使用change master指定主配置，并添加master_ssl选项以使用加密进行连接：</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>CHANGE MASTER TO</code></strong>
    -&gt; <strong class="userinput"><code>MASTER_HOST='master_hostname',</code></strong>
    -&gt; <strong class="userinput"><code>MASTER_USER='repl',</code></strong>
    -&gt; <strong class="userinput"><code>MASTER_PASSWORD='<em class="replaceable"><code>password</code></em>',</code></strong>
    -&gt; <strong class="userinput"><code>MASTER_SSL=1;</code></strong>
</pre><p>
                    Setting <code class="literal">MASTER_SSL=1</code> for a replication
                    connection and then setting no further
                    <code class="literal">MASTER_SSL_<em class="replaceable"><code>xxx</code></em></code>
                    options corresponds to setting
                    <code class="literal">--ssl-mode=REQUIRED</code> for the client, as
                    described in <a class="xref" href="programs.html#encrypted-connection-options" title="Command Options for Encrypted Connections">Command Options for Encrypted Connections</a>.
                    With <code class="literal">MASTER_SSL=1</code>, the connection attempt
                    only succeeds if an encrypted connection can be established. A
                    replication connection does not fall back to an unencrypted
                    connection, so there is no setting corresponding to the
                    <code class="literal">--ssl-mode=PREFERRED</code> setting for
                    replication. If <code class="literal">MASTER_SSL=0</code> is set, this
                    corresponds to <code class="literal">--ssl-mode=DISABLED</code>.
                </p><p style="color:blue;">为复制连接设置master_ssl=1，然后不再设置master_ssl_xxx选项，这与客户端所需的设置--ssl mode=相对应，如加密连接的命令选项中所述。如果master_ssl=1，则只有在可以建立加密连接时，连接尝试才会成功。复制连接不会返回到未加密的连接，因此没有对应于复制的--ssl mode=首选设置的设置。如果设置了master_ssl=0，则对应于--ssl mode=disabled。</p></li><li class="listitem"><p>
                    To name the slave certificate and SSL private key files using
                    the <a class="link" href="sql-syntax.html#change-master-to" title="13.4.2.1&nbsp;CHANGE MASTER TO Syntax"><code class="literal">CHANGE MASTER TO</code></a> statement,
                    if you did not do this in the slave's
                    <code class="filename">my.cnf</code> file, add the appropriate
                    <code class="literal">MASTER_SSL_<em class="replaceable"><code>xxx</code></em></code>
                    options:
                </p><p style="color:blue;">要使用change master to语句命名从属证书和ssl私钥文件，如果您没有在从属的my.cnf文件中执行此操作，请添加相应的master_ssl_xxx选项：</p><pre data-lang="sql" class="programlisting">    -&gt; <strong class="userinput"><code>MASTER_SSL_CA = 'ca_file_name',</code></strong>
    -&gt; <strong class="userinput"><code>MASTER_SSL_CAPATH = 'ca_directory_name',</code></strong>
    -&gt; <strong class="userinput"><code>MASTER_SSL_CERT = 'cert_file_name',</code></strong>
    -&gt; <strong class="userinput"><code>MASTER_SSL_KEY = 'key_file_name',</code></strong>
</pre><p>
                    These options correspond to the
                    <code class="literal">--ssl-<em class="replaceable"><code>xxx</code></em></code>
                    options with the same names, as described in
                    <a class="xref" href="programs.html#encrypted-connection-options" title="Command Options for Encrypted Connections">Command Options for Encrypted Connections</a>. For these
                    options to take effect, <code class="literal">MASTER_SSL=1</code> must
                    also be set. For a replication connection, specifying a value
                    for either of <code class="literal"> MASTER_SSL_CA</code> or
                    <code class="literal">MASTER_SSL_CAPATH</code>, or specifying these
                    options in the slave's <code class="filename">my.cnf</code> file,
                    corresponds to setting
                    <code class="literal">--ssl-mode=VERIFY_CA</code>. The connection
                    attempt only succeeds if a valid matching Certificate
                    Authority (CA) certificate is found using the specified
                    information.
                </p><p style="color:blue;">这些选项对应于具有相同名称的--ssl xxx选项，如加密连接的命令选项中所述。要使这些选项生效，还必须设置master_ssl=1。对于复制连接，指定master_ssl_ca或master_ssl_capath的值，或在从机的my.cnf文件中指定这些选项，对应于设置--ssl mode=verify_ca。只有使用指定的信息找到有效的匹配证书颁发机构（ca）证书时，连接尝试才会成功。</p></li><li class="listitem"><p>
                    To activate host name identity verification, add the
                    <code class="literal">MASTER_SSL_VERIFY_SERVER_CERT</code> option:
                </p><p style="color:blue;">要激活主机名身份验证，请添加master_ssl_verify_server_cert选项：</p><pre data-lang="sql" class="programlisting">    -&gt; <strong class="userinput"><code>MASTER_SSL_VERIFY_SERVER_CERT=1,</code></strong>
</pre><p>
                    This option corresponds to the
                    <code class="literal">--ssl-verify-server-cert</code> option, which is
                    deprecated as of MySQL 5.7.11 and is removed in MySQL 8.0. For
                    a replication connection, specifying
                    <code class="literal">MASTER_SSL_VERIFY_SERVER_CERT=1</code> corresponds
                    to setting <code class="literal">--ssl-mode=VERIFY_IDENTITY</code>, as
                    described in <a class="xref" href="programs.html#encrypted-connection-options" title="Command Options for Encrypted Connections">Command Options for Encrypted Connections</a>.
                    For this option to take effect,
                    <code class="literal">MASTER_SSL=1</code> must also be set. Host name
                    identity verification does not work with self-signed
                    certificates.
                </p><p style="color:blue;">此选项对应于--ssl verify server cert选项，该选项从mysql 5.7.11开始就被弃用，并在mysql 8.0中被删除。对于复制连接，指定master_ssl_verify_server_cert=1对应于设置--ssl mode=verify_identity，如加密连接的命令选项中所述。要使此选项生效，还必须设置master_ssl=1。主机名身份验证不适用于自签名证书。</p></li><li class="listitem"><p>
                    To activate certificate revocation list (CRL) checks, add the
                    <code class="literal">MASTER_SSL_CRL</code> or
                    <code class="literal">MASTER_SSL_CRLPATH</code> option:
                </p><p style="color:blue;">要激活证书吊销列表（CRL）检查，请添加master_ssl_crl或master_ssl_crlpath选项：</p><pre data-lang="sql" class="programlisting">    -&gt; <strong class="userinput"><code>MASTER_SSL_CRL = 'crl_file_name',</code></strong>
    -&gt; <strong class="userinput"><code>MASTER_SSL_CRLPATH = 'crl_directory_name',</code></strong></pre><p>
                    These options correspond to the
                    <code class="literal">--ssl-<em class="replaceable"><code>xxx</code></em></code>
                    options with the same names, as described in
                    <a class="xref" href="programs.html#encrypted-connection-options" title="Command Options for Encrypted Connections">Command Options for Encrypted Connections</a>. If they are
                    not specified, no CRL checking takes place.
                </p><p style="color:blue;">这些选项对应于具有相同名称的--ssl xxx选项，如加密连接的命令选项中所述。如果未指定，则不进行CRL检查。</p></li><li class="listitem"><p>
                    To specify lists of ciphers and encryption protocols permitted
                    by the slave for the replication connection, add the
                    <code class="literal">MASTER_SSL_CIPHER</code> and
                    <code class="literal">MASTER_TLS_VERSION</code> options:
                </p><p style="color:blue;">要为复制连接指定从机允许的密码和加密协议列表，请添加master_ssl_cipher和master_tls_version选项：</p><pre data-lang="sql" class="programlisting">    -&gt; <strong class="userinput"><code>MASTER_SSL_CIPHER = 'cipher_list',</code></strong>
    -&gt; <strong class="userinput"><code>MASTER_TLS_VERSION = 'protocol_list',</code></strong></pre><p>
                    The <code class="literal">MASTER_SSL_CIPHER</code> option specifies the
                    list of ciphers permitted by the slave for the replication
                    connection, with one or more cipher names separated by colons.
                    The <code class="literal">MASTER_TLS_VERSION</code> option specifies the
                    encryption protocols permitted by the slave for the
                    replication connection. The format is like that for the
                    <a class="link" href="server-administration.html#sysvar_tls_version"><code class="literal">tls_version</code></a> system variable,
                    with one or more comma-separated protocol versions. The
                    protocols and ciphers that you can use in these lists depend
                    on the SSL library used to compile MySQL. For information
                    about the formats and permitted values, see
                    <a class="xref" href="security.html#encrypted-connection-protocols-ciphers" title="6.3.2&nbsp;Encrypted Connection TLS Protocols and Ciphers">Section&nbsp;6.3.2, “Encrypted Connection TLS Protocols and Ciphers”</a>.
                </p><p style="color:blue;">master_ssl_cipher选项指定从机允许用于复制连接的密码列表，其中一个或多个密码名用冒号分隔。master_tls_version选项指定复制连接的从机所允许的加密协议。格式与TLS U VERSION系统变量的格式类似，使用一个或多个逗号分隔的协议版本。可以在这些列表中使用的协议和密码取决于用于编译mysql的ssl库。有关格式和允许值的信息，请参阅第6.3.2节“加密连接TLS协议和密码”。</p></li><li class="listitem"><p>
                    After the master information has been updated, start the slave
                    replication process:
                </p><p style="color:blue;">更新主信息后，启动从复制过程：</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>START SLAVE;</code></strong>
</pre><p>
                    You can use the <a class="link" href="sql-syntax.html#show-slave-status" title="13.7.5.34&nbsp;SHOW SLAVE STATUS Syntax"><code class="literal">SHOW SLAVE
                    STATUS</code></a> statement to confirm that an encrypted
                    connection was established successfully.
                </p><p style="color:blue;">可以使用show slave status语句确认已成功建立加密连接。</p></li><li class="listitem"><p>
                    Requiring encrypted connections on the slave does not ensure
                    that the master requires encrypted connections from slaves. If
                    you want to ensure that the master only accepts replication
                    slaves that connect using encrypted connections, create a
                    replication user account on the master using the
                    <code class="literal">REQUIRE SSL</code> option, then grant that user
                    the <a class="link" href="security.html#priv_replication-slave"><code class="literal">REPLICATION SLAVE</code></a>
                    privilege. For example:
                </p><p style="color:blue;">在从机上要求加密连接不能确保主机要求从机进行加密连接。如果要确保主服务器仅接受使用加密连接进行连接的复制从属服务器，请使用“需要SSL”选项在主服务器上创建复制用户帐户，然后授予该用户复制从属服务器权限。例如：</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>CREATE USER 'repl'@'%.example.com' IDENTIFIED BY '<em class="replaceable"><code>password</code></em>'</code></strong>
    -&gt; <strong class="userinput"><code>REQUIRE SSL;</code></strong>
mysql&gt; <strong class="userinput"><code>GRANT REPLICATION SLAVE ON *.*</code></strong>
    -&gt; <strong class="userinput"><code>TO 'repl'@'%.example.com';</code></strong>
</pre><p>
                    If you have an existing replication user account on the
                    master, you can add <code class="literal">REQUIRE SSL</code> to it with
                    this statement:
                </p><p style="color:blue;">如果在主服务器上有一个现有的复制用户帐户，则可以用该语句向其添加需要SSL的内容：</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>ALTER USER 'repl'@'%.example.com' REQUIRE SSL;</code></strong>
</pre></li></ul>
            </div>

        </div>
        <div class="section">
            <div class="titlepage">
                <div>
                    <div>
                        <h3 class="title"><a name="replication-semisync"></a>16.3.9&nbsp;Semisynchronous Replication</h3>

                    </div>

                </div>

            </div>
            <div class="toc">
                <dl class="toc"><dt><span class="section"><a href="replication.html#replication-semisync-interface">16.3.9.1 Semisynchronous Replication Administrative Interface</a></span></dt><dt><span class="section"><a href="replication.html#replication-semisync-installation">16.3.9.2 Semisynchronous Replication Installation and Configuration</a></span></dt><dt><span class="section"><a href="replication.html#replication-semisync-monitoring">16.3.9.3 Semisynchronous Replication Monitoring</a></span></dt></dl>
            </div>
            <a class="indexterm" name="idm140286792678208"></a><a class="indexterm" name="idm140286792677152"></a><p>
            In addition to the built-in asynchronous replication, MySQL
            5.7 supports an interface to semisynchronous
            replication that is implemented by plugins. This section discusses
            what semisynchronous replication is and how it works. The
            following sections cover the administrative interface to
            semisynchronous replication and how to install, configure, and
            monitor it.
        </p><p style="color:blue;">除了内置的异步复制之外，mysql 5.7还支持通过插件实现的半同步复制接口。本节讨论什么是半同步复制以及它是如何工作的。以下各节介绍半同步复制的管理接口以及如何安装、配置和监视它。</p><p>
            MySQL replication by default is asynchronous. The master writes
            events to its binary log but does not know whether or when a slave
            has retrieved and processed them. With asynchronous replication,
            if the master crashes, transactions that it has committed might
            not have been transmitted to any slave. Consequently, failover
            from master to slave in this case may result in failover to a
            server that is missing transactions relative to the master.
        </p><p style="color:blue;">默认情况下，mysql复制是异步的。主服务器将事件写入其二进制日志，但不知道从服务器是否或何时检索并处理它们。对于异步复制，如果主服务器崩溃，它提交的事务可能不会传输到任何从服务器。因此，在这种情况下，从主服务器到从服务器的故障转移可能导致到服务器的故障转移，该服务器缺少与主服务器相关的事务。</p><p>
            Semisynchronous replication can be used as an alternative to
            asynchronous replication:
        </p><p style="color:blue;">半同步复制可用作异步复制的替代：</p>
            <div class="itemizedlist">
                <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                    A slave indicates whether it is semisynchronous-capable when
                    it connects to the master.
                </p><p style="color:blue;">从机在连接到主机时指示它是否具有半同步能力。</p></li><li class="listitem"><p>
                    If semisynchronous replication is enabled on the master side
                    and there is at least one semisynchronous slave, a thread that
                    performs a transaction commit on the master blocks and waits
                    until at least one semisynchronous slave acknowledges that it
                    has received all events for the transaction, or until a
                    timeout occurs.
                </p><p style="color:blue;">如果在主端启用了半同步复制，并且至少有一个半同步从机，则在主块上执行事务提交并等待至少一个半同步从机确认已收到事务的所有事件，或等待超时发生。</p></li><li class="listitem"><p>
                    The slave acknowledges receipt of a transaction's events only
                    after the events have been written to its relay log and
                    flushed to disk.
                </p><p style="color:blue;">从服务器只在事件写入其中继日志并刷新到磁盘后才确认收到事务的事件。</p></li><li class="listitem"><p>
                    If a timeout occurs without any slave having acknowledged the
                    transaction, the master reverts to asynchronous replication.
                    When at least one semisynchronous slave catches up, the master
                    returns to semisynchronous replication.
                </p><p style="color:blue;">如果在没有任何从机确认事务的情况下发生超时，则主机将恢复为异步复制。当至少一个半同步从机赶上时，主机返回到半同步复制。</p></li><li class="listitem"><p>
                    Semisynchronous replication must be enabled on both the master
                    and slave sides. If semisynchronous replication is disabled on
                    the master, or enabled on the master but on no slaves, the
                    master uses asynchronous replication.
                </p><p style="color:blue;">必须在主端和从端都启用半同步复制。如果在主服务器上禁用了半同步复制，或者在主服务器上启用了半同步复制，但没有从服务器，则主服务器使用异步复制。</p></li></ul>
            </div>
            <p>
                While the master is blocking (waiting for acknowledgment from a
                slave), it does not return to the session that performed the
                transaction. When the block ends, the master returns to the
                session, which then can proceed to execute other statements. At
                this point, the transaction has committed on the master side, and
                receipt of its events has been acknowledged by at least one slave.
            </p><p style="color:blue;">当主服务器正在阻塞（等待从服务器的确认）时，它不会返回到执行事务的会话。当块结束时，master返回会话，然后会话可以继续执行其他语句。此时，事务已在主端提交，并且至少有一个从机已确认收到其事件。</p><p>
            The number of slave acknowledgments the master must receive per
            transaction before proceeding is configurable using the
            <a class="link" href="replication.html#sysvar_rpl_semi_sync_master_wait_for_slave_count"><code class="literal">rpl_semi_sync_master_wait_for_slave_count</code></a>
            system variable. The default value is 1.
        </p><p style="color:blue;">在继续之前，主服务器必须在每个事务中接收的从属确认的数量可以使用rpl_semi_sync_master_wait_for_slave_count系统变量进行配置。默认值为1。</p><p>
            Blocking also occurs after rollbacks that are written to the
            binary log, which occurs when a transaction that modifies
            nontransactional tables is rolled back. The rolled-back
            transaction is logged even though it has no effect for
            transactional tables because the modifications to the
            nontransactional tables cannot be rolled back and must be sent to
            slaves.
        </p><p style="color:blue;">阻塞也发生在写入二进制日志的回滚之后，当修改非事务表的事务回滚时发生。回滚的事务将被记录，即使它对事务表没有任何影响，因为对非事务表的修改不能回滚，必须发送到从属表。</p><p>
            For statements that do not occur in transactional context (that
            is, when no transaction has been started with
            <a class="link" href="sql-syntax.html#commit" title="13.3.1&nbsp;START TRANSACTION, COMMIT, and ROLLBACK Syntax"><code class="literal">START
                TRANSACTION</code></a> or
            <a class="link" href="sql-syntax.html#set-variable" title="13.7.4.1&nbsp;SET Syntax for Variable Assignment"><code class="literal">SET autocommit =
                0</code></a>), autocommit is enabled and each statement commits
            implicitly. With semisynchronous replication, the master blocks
            for each such statement, just as it does for explicit transaction
            commits.
        </p><p style="color:blue;">对于不发生在事务上下文中的语句（即，当没有使用start transaction或set autocommit=0启动任何事务时），将启用autocommit，并且每个语句都隐式提交。对于半同步复制，每一个这样的语句的主块，就像显式事务提交一样。</p><p>
            To understand what the <span class="quote">“<span class="quote">semi</span>”</span> in
            <span class="quote">“<span class="quote">semisynchronous replication</span>”</span> means, compare it with
            asynchronous and fully synchronous replication:
        </p><p style="color:blue;">要了解“半同步复制”中的“半”是什么意思，请将其与异步复制和完全同步复制进行比较：</p>
            <div class="itemizedlist">
                <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                    With asynchronous replication, the master writes events to its
                    binary log and slaves request them when they are ready. There
                    is no guarantee that any event will ever reach any slave.
                </p><p style="color:blue;">对于异步复制，主服务器将事件写入其二进制日志，而从服务器则在事件准备好时请求它们。无法保证任何事件都会到达任何奴隶。</p></li><li class="listitem"><p>
                    With fully synchronous replication, when a master commits a
                    transaction, all slaves also will have committed the
                    transaction before the master returns to the session that
                    performed the transaction. The drawback of this is that there
                    might be a lot of delay to complete a transaction.
                </p><p style="color:blue;">对于完全同步复制，当主服务器提交事务时，所有从服务器也将在主服务器返回到执行事务的会话之前提交事务。这样做的缺点是，完成一个事务可能会有很多延迟。</p></li><li class="listitem"><p>
                    Semisynchronous replication falls between asynchronous and
                    fully synchronous replication. The master waits only until at
                    least one slave has received and logged the events. It does
                    not wait for all slaves to acknowledge receipt, and it
                    requires only receipt, not that the events have been fully
                    executed and committed on the slave side.
                </p><p style="color:blue;">半同步复制介于异步复制和完全同步复制之间。主服务器只等待至少一个从服务器接收并记录事件。它并不等待所有的从机确认接收，它只需要接收，而不是事件已经在从机端完全执行和提交。</p></li></ul>
            </div>
            <p>
                Compared to asynchronous replication, semisynchronous replication
                provides improved data integrity because when a commit returns
                successfully, it is known that the data exists in at least two
                places. Until a semisynchronous master receives acknowledgment
                from the number of slaves configured by
                <a class="link" href="replication.html#sysvar_rpl_semi_sync_master_wait_for_slave_count"><code class="literal">rpl_semi_sync_master_wait_for_slave_count</code></a>,
                the transaction is on hold and not committed.
            </p><p style="color:blue;">与异步复制相比，半同步复制提供了改进的数据完整性，因为当提交成功返回时，已知数据至少存在于两个地方。在半同步主机从rpl_semi_sync_master_wait_for_slave_count配置的从机数量收到确认之前，事务处于等待状态且未提交。</p><p>
            Semisynchronous replication also places a rate limit on busy
            sessions by constraining the speed at which binary log events can
            be sent from master to slave. When one user is too busy, this will
            slow it down, which is useful in some deployment situations.
        </p><p style="color:blue;">半同步复制还通过限制二进制日志事件从主服务器发送到从服务器的速度来限制繁忙会话的速率。当一个用户太忙时，这将减慢速度，这在某些部署情况下非常有用。</p><p>
            Semisynchronous replication does have some performance impact
            because commits are slower due to the need to wait for slaves.
            This is the tradeoff for increased data integrity. The amount of
            slowdown is at least the TCP/IP roundtrip time to send the commit
            to the slave and wait for the acknowledgment of receipt by the
            slave. This means that semisynchronous replication works best for
            close servers communicating over fast networks, and worst for
            distant servers communicating over slow networks.
        </p><p style="color:blue;">半同步复制确实有一些性能影响，因为提交由于需要等待从机而变慢。这是提高数据完整性的折衷方案。减速的量至少是向从机发送提交并等待从机确认接收的TCP/IP往返时间。这意味着半同步复制对于通过快速网络进行通信的封闭服务器最有效，而对于通过慢速网络进行通信的远程服务器最差。</p><p>
            The
            <a class="link" href="replication.html#sysvar_rpl_semi_sync_master_wait_point"><code class="literal">rpl_semi_sync_master_wait_point</code></a>
            system variable controls the point at which a semisynchronous
            replication master waits for slave acknowledgment of transaction
            receipt before returning a status to the client that committed the
            transaction. These values are permitted:
        </p><p style="color:blue;">rpl_semi_sync_master_wait_point系统变量控制半同步复制主机在向提交事务的客户端返回状态之前等待从机确认事务接收的点。允许这些值：</p>
            <div class="itemizedlist">
                <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                    <code class="literal">AFTER_SYNC</code> (the default): The master writes
                    each transaction to its binary log and the slave, and syncs
                    the binary log to disk. The master waits for slave
                    acknowledgment of transaction receipt after the sync. Upon
                    receiving acknowledgment, the master commits the transaction
                    to the storage engine and returns a result to the client,
                    which then can proceed.
                </p><p style="color:blue;">同步后（默认）：主服务器将每个事务写入其二进制日志和从服务器，并将二进制日志同步到磁盘。主服务器在同步后等待从服务器对事务接收的确认。收到确认后，主服务器将事务提交给存储引擎，并将结果返回给客户端，然后客户端可以继续。</p></li><li class="listitem"><p>
                    <code class="literal">AFTER_COMMIT</code>: The master writes each
                    transaction to its binary log and the slave, syncs the binary
                    log, and commits the transaction to the storage engine. The
                    master waits for slave acknowledgment of transaction receipt
                    after the commit. Upon receiving acknowledgment, the master
                    returns a result to the client, which then can proceed.
                </p><p style="color:blue;">提交后：主服务器将每个事务写入其二进制日志和从服务器，同步二进制日志，并将事务提交到存储引擎。主服务器在提交后等待从服务器对事务接收的确认。收到确认后，主服务器将结果返回给客户端，然后客户端可以继续。</p></li></ul>
            </div>
            <p>
                The replication characteristics of these settings differ as
                follows:
            </p><p style="color:blue;">这些设置的复制特性如下所示：</p>
            <div class="itemizedlist">
                <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                    With <code class="literal">AFTER_SYNC</code>, all clients see the
                    committed transaction at the same time: After it has been
                    acknowledged by the slave and committed to the storage engine
                    on the master. Thus, all clients see the same data on the
                    master.
                </p><p style="color:blue;">使用after_sync，所有客户端都会同时看到提交的事务：在从属服务器确认并提交到主服务器上的存储引擎之后。因此，所有客户机在主机上都看到相同的数据。</p><p>
                    In the event of master failure, all transactions committed on
                    the master have been replicated to the slave (saved to its
                    relay log). A crash of the master and failover to the slave is
                    lossless because the slave is up to date.
                </p><p style="color:blue;">如果主服务器发生故障，主服务器上提交的所有事务都已复制到从服务器（保存到其中继日志）。主服务器崩溃并故障转移到从服务器是无损的，因为从服务器是最新的。</p></li><li class="listitem"><p>
                    With <code class="literal">AFTER_COMMIT</code>, the client issuing the
                    transaction gets a return status only after the server commits
                    to the storage engine and receives slave acknowledgment. After
                    the commit and before slave acknowledgment, other clients can
                    see the committed transaction before the committing client.
                </p><p style="color:blue;">对于after_commit，只有在服务器提交到存储引擎并收到从机确认之后，发出事务的客户端才会获得返回状态。在提交之后和从机确认之前，其他客户机可以在提交客户机之前看到提交的事务。</p><p>
                    If something goes wrong such that the slave does not process
                    the transaction, then in the event of a master crash and
                    failover to the slave, it is possible that such clients will
                    see a loss of data relative to what they saw on the master.
                </p><p style="color:blue;">如果出了问题，使得从机无法处理事务，那么在主机崩溃并故障转移到从机的情况下，这些客户机可能会看到与它们在主机上看到的数据相关的数据丢失。</p></li></ul>
            </div>
            <div class="section">
                <div class="titlepage">
                    <div>
                        <div>
                            <h4 class="title"><a name="replication-semisync-interface"></a>16.3.9.1&nbsp;Semisynchronous Replication Administrative Interface</h4>

                        </div>

                    </div>

                </div>
                <a class="indexterm" name="idm140286958274784"></a><p>
                The administrative interface to semisynchronous replication has
                several components:
            </p><p style="color:blue;">半同步复制的管理接口有几个组件：</p>
                <div class="itemizedlist">
                    <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                        Two plugins implement semisynchronous capability. There is
                        one plugin for the master side and one for the slave side.
                    </p><p style="color:blue;">两个插件实现半同步功能。主端和从端各有一个插件。</p></li><li class="listitem"><p>
                        System variables control plugin behavior. Some examples:
                    </p><p style="color:blue;">系统变量控制插件行为。一些例子：</p>
                        <div class="itemizedlist">
                            <ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
                                <a class="link" href="replication.html#sysvar_rpl_semi_sync_master_enabled"><code class="literal">rpl_semi_sync_master_enabled</code></a>
                            </p><p style="color:blue;">rpl_semi_sync_master_已启用</p><p>
                                Controls whether semisynchronous replication is enabled
                                on the master. To enable or disable the plugin, set this
                                variable to 1 or 0, respectively. The default is 0
                                (off).
                            </p><p style="color:blue;">控制是否在主机上启用半同步复制。要启用或禁用插件，请分别将此变量设置为1或0。默认值为0（关闭）。</p></li><li class="listitem"><p>
                                <a class="link" href="replication.html#sysvar_rpl_semi_sync_master_timeout"><code class="literal">rpl_semi_sync_master_timeout</code></a>
                            </p><p style="color:blue;">半同步主机超时</p><p>
                                A value in milliseconds that controls how long the
                                master waits on a commit for acknowledgment from a slave
                                before timing out and reverting to asynchronous
                                replication. The default value is 10000 (10 seconds).
                            </p><p style="color:blue;">一个以毫秒为单位的值，用于控制主服务器在超时并还原到异步复制之前等待从服务器提交确认的时间。默认值为10000（10秒）。</p></li><li class="listitem"><p>
                                <a class="link" href="replication.html#sysvar_rpl_semi_sync_slave_enabled"><code class="literal">rpl_semi_sync_slave_enabled</code></a>
                            </p><p style="color:blue;">已启用RPL_Semi_Sync_Slave_</p><p>
                                Similar to
                                <a class="link" href="replication.html#sysvar_rpl_semi_sync_master_enabled"><code class="literal">rpl_semi_sync_master_enabled</code></a>,
                                but controls the slave plugin.
                            </p><p style="color:blue;">类似于rpl_semi_sync_master_enabled，但控制从插件。</p></li></ul>
                        </div>
                        <p>
                            All
                            <code class="literal">rpl_semi_sync_<em class="replaceable"><code>xxx</code></em></code>
                            system variables are described at
                            <a class="xref" href="server-administration.html#server-system-variables" title="5.1.7&nbsp;Server System Variables">Section&nbsp;5.1.7, “Server System Variables”</a>.
                        </p><p style="color:blue;">所有rpl_semi_sync_xxx系统变量在第5.1.7节“服务器系统变量”中进行了说明。</p></li><li class="listitem"><p>
                        Status variables enable semisynchronous replication
                        monitoring. Some examples:
                    </p><p style="color:blue;">状态变量启用半同步复制监视。一些例子：</p>
                        <div class="itemizedlist">
                            <ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
                                <a class="link" href="server-administration.html#statvar_Rpl_semi_sync_master_clients"><code class="literal">Rpl_semi_sync_master_clients</code></a>
                            </p><p style="color:blue;">rpl_semi_sync_master_客户端</p><p>
                                The number of semisynchronous slaves.
                            </p><p style="color:blue;">半同步从机的数量。</p></li><li class="listitem"><p>
                                <a class="link" href="server-administration.html#statvar_Rpl_semi_sync_master_status"><code class="literal">Rpl_semi_sync_master_status</code></a>
                            </p><p style="color:blue;">半同步主机状态</p><p>
                                Whether semisynchronous replication currently is
                                operational on the master. The value is 1 if the plugin
                                has been enabled and a commit acknowledgment has not
                                occurred. It is 0 if the plugin is not enabled or the
                                master has fallen back to asynchronous replication due
                                to commit acknowledgment timeout.
                            </p><p style="color:blue;">半同步复制当前是否在主服务器上运行。如果插件已启用且未发生提交确认，则该值为1。如果插件未启用，或者由于提交确认超时，主机已返回到异步复制，则为0。</p></li><li class="listitem"><p>
                                <a class="link" href="server-administration.html#statvar_Rpl_semi_sync_master_no_tx"><code class="literal">Rpl_semi_sync_master_no_tx</code></a>
                            </p><p style="color:blue;">半同步主机</p><p>
                                The number of commits that were not acknowledged
                                successfully by a slave.
                            </p><p style="color:blue;">从属服务器未成功确认的提交数。</p></li><li class="listitem"><p>
                                <a class="link" href="server-administration.html#statvar_Rpl_semi_sync_master_yes_tx"><code class="literal">Rpl_semi_sync_master_yes_tx</code></a>
                            </p><p style="color:blue;">半同步主机</p><p>
                                The number of commits that were acknowledged
                                successfully by a slave.
                            </p><p style="color:blue;">从属服务器成功确认的提交数。</p></li><li class="listitem"><p>
                                <a class="link" href="server-administration.html#statvar_Rpl_semi_sync_slave_status"><code class="literal">Rpl_semi_sync_slave_status</code></a>
                            </p><p style="color:blue;">半同步从机状态</p><p>
                                Whether semisynchronous replication currently is
                                operational on the slave. This is 1 if the plugin has
                                been enabled and the slave I/O thread is running, 0
                                otherwise.
                            </p><p style="color:blue;">半同步复制当前是否在从机上运行。如果插件已启用且从属I/O线程正在运行，则为1；否则为0。</p></li></ul>
                        </div>
                        <p>
                            All
                            <code class="literal">Rpl_semi_sync_<em class="replaceable"><code>xxx</code></em></code>
                            status variables are described at
                            <a class="xref" href="server-administration.html#server-status-variables" title="5.1.9&nbsp;Server Status Variables">Section&nbsp;5.1.9, “Server Status Variables”</a>.
                        </p><p style="color:blue;">所有rpl_semi_sync_xxx状态变量在第5.1.9节“服务器状态变量”中描述。</p></li></ul>
                </div>
                <p>
                    The system and status variables are available only if the
                    appropriate master or slave plugin has been installed with
                    <a class="link" href="sql-syntax.html#install-plugin" title="13.7.3.3&nbsp;INSTALL PLUGIN Syntax"><code class="literal">INSTALL PLUGIN</code></a>.
                </p><p style="color:blue;">只有在安装了相应的主插件或从插件后，系统和状态变量才可用。</p>
            </div>
            <div class="section">
                <div class="titlepage">
                    <div>
                        <div>
                            <h4 class="title"><a name="replication-semisync-installation"></a>16.3.9.2&nbsp;Semisynchronous Replication Installation and Configuration</h4>

                        </div>

                    </div>

                </div>
                <a class="indexterm" name="idm140286792587312"></a><a class="indexterm" name="idm140286792585856"></a><p>
                Semisynchronous replication is implemented using plugins, so the
                plugins must be installed into the server to make them
                available. After a plugin has been installed, you control it by
                means of the system variables associated with it. These system
                variables are unavailable until the associated plugin has been
                installed.
            </p><p style="color:blue;">半同步复制是使用插件实现的，因此必须将插件安装到服务器中以使其可用。安装插件后，您可以通过与其关联的系统变量来控制它。在安装相关插件之前，这些系统变量不可用。</p><p>
                This section describes how to install the semisynchronous
                replication plugins. For general information about installing
                plugins, see <a class="xref" href="server-administration.html#plugin-loading" title="5.5.1&nbsp;Installing and Uninstalling Plugins">Section&nbsp;5.5.1, “Installing and Uninstalling Plugins”</a>.
            </p><p style="color:blue;">本节介绍如何安装半同步复制插件。有关安装插件的一般信息，请参阅第5.5.1节“安装和卸载插件”。</p><p>
                To use semisynchronous replication, the following requirements
                must be satisfied:
            </p><p style="color:blue;">要使用半同步复制，必须满足以下要求：</p>
                <div class="itemizedlist">
                    <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                        The capability of installing plugins requires a MySQL server
                        that supports dynamic loading. To verify this, check that
                        the value of the
                        <a class="link" href="server-administration.html#sysvar_have_dynamic_loading"><code class="literal">have_dynamic_loading</code></a> system
                        variable is <code class="literal">YES</code>. Binary distributions
                        should support dynamic loading.
                    </p><p style="color:blue;">安装插件的功能需要支持动态加载的mysql服务器。要验证这一点，请检查have_dynamic_loading系统变量的值是否为yes。二进制分布应该支持动态加载。</p></li><li class="listitem"><p>
                        Replication must already be working, see
                        <a class="xref" href="replication.html#replication-configuration" title="16.1&nbsp;Configuring Replication">Section&nbsp;16.1, “Configuring Replication”</a>.
                    </p><p style="color:blue;">复制必须已在工作，请参阅第16.1节“配置复制”。</p></li><li class="listitem"><p>
                        There must not be multiple replication channels configured.
                        Semisynchronous replication is only compatible with the
                        default replication channel. See
                        <a class="xref" href="replication.html#replication-channels" title="16.2.3&nbsp;Replication Channels">Section&nbsp;16.2.3, “Replication Channels”</a>.
                    </p><p style="color:blue;">不能配置多个复制通道。半同步复制仅与默认复制通道兼容。见第16.2.3节“复制通道”。</p></li></ul>
                </div>
                <p>
                    To set up semisynchronous replication, use the following
                    instructions. The <a class="link" href="sql-syntax.html#install-plugin" title="13.7.3.3&nbsp;INSTALL PLUGIN Syntax"><code class="literal">INSTALL PLUGIN</code></a>,
                    <a class="link" href="sql-syntax.html#set-variable" title="13.7.4.1&nbsp;SET Syntax for Variable Assignment"><code class="literal">SET
                        GLOBAL</code></a>, <a class="link" href="sql-syntax.html#stop-slave" title="13.4.2.7&nbsp;STOP SLAVE Syntax"><code class="literal">STOP SLAVE</code></a>, and
                    <a class="link" href="sql-syntax.html#start-slave" title="13.4.2.6&nbsp;START SLAVE Syntax"><code class="literal">START SLAVE</code></a> statements mentioned
                    here require the <a class="link" href="security.html#priv_super"><code class="literal">SUPER</code></a> privilege.
                </p><p style="color:blue;">要设置半同步复制，请使用以下说明。这里提到的install plugin、set global、stop slave和start slave语句需要超级特权。</p><p>
                MySQL distributions include semisynchronous replication plugin
                files for the master side and the slave side.
            </p><p style="color:blue;">mysql发行版包括主端和从端的半同步复制插件文件。</p><p>
                To be usable by a master or slave server, the appropriate plugin
                library file must be located in the MySQL plugin directory (the
                directory named by the
                <a class="link" href="server-administration.html#sysvar_plugin_dir"><code class="literal">plugin_dir</code></a> system variable). If
                necessary, configure the plugin directory location by setting
                the value of <a class="link" href="server-administration.html#sysvar_plugin_dir"><code class="literal">plugin_dir</code></a> at
                server startup.
            </p><p style="color:blue;">要使主服务器或从服务器可用，相应的插件库文件必须位于mysql plugin目录（由plugin_dir系统变量命名的目录）中。如有必要，通过在服务器启动时设置plugin dir的值来配置插件目录位置。</p><p>
                The plugin library file base names are
                <code class="literal">semisync_master</code> and
                <code class="literal">semisync_slave</code>. The file name suffix differs
                per platform (for example, <code class="filename">.so</code> for Unix and
                Unix-like systems, <code class="filename">.dll</code> for Windows).
            </p><p style="color:blue;">插件库文件的基本名称是semisync_master和semisync_slave。每个平台的文件名后缀不同（例如，.so对于unix和类unix系统，.dll对于windows）。</p><p>
                The master plugin library file must be present in the plugin
                directory of the master server. The slave plugin library file
                must be present in the plugin directory of each slave server.
            </p><p style="color:blue;">主插件库文件必须存在于主服务器的插件目录中。从属插件库文件必须存在于每个从属服务器的插件目录中。</p><p>
                To load the plugins, use the <a class="link" href="sql-syntax.html#install-plugin" title="13.7.3.3&nbsp;INSTALL PLUGIN Syntax"><code class="literal">INSTALL
                PLUGIN</code></a> statement on the master and on each slave that
                is to be semisynchronous (adjust the <code class="filename">.so</code>
                suffix for your platform as necessary).
            </p><p style="color:blue;">要加载插件，请在主机和每个半同步的从机上使用install plugin语句（根据需要调整平台的.so后缀）。</p><p>
                On the master:
            </p><p style="color:blue;">在主人身上：</p><pre data-lang="sql" class="programlisting">INSTALL PLUGIN rpl_semi_sync_master SONAME 'semisync_master.so';
</pre><p>
                On each slave:
            </p><p style="color:blue;">在每个从机上：</p><pre data-lang="sql" class="programlisting">INSTALL PLUGIN rpl_semi_sync_slave SONAME 'semisync_slave.so';
</pre><p>
                If an attempt to install a plugin results in an error on Linux
                similar to that shown here, you must install
                <code class="literal">libimf</code>:
            </p><p style="color:blue;">如果试图在Linux上安装插件导致类似于此处所示的错误，则必须安装libimf：</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>INSTALL PLUGIN rpl_semi_sync_master SONAME 'semisync_master.so';</code></strong>
ERROR 1126 (HY000): Can't open shared library
'/usr/local/mysql/lib/plugin/semisync_master.so'
(errno: 22 libimf.so: cannot open shared object file:
No such file or directory)
</pre><p>
                You can obtain <code class="literal">libimf</code> from
                <a class="ulink" href="https://dev.mysql.com/downloads/os-linux.html" target="_top">https://dev.mysql.com/downloads/os-linux.html</a>.
            </p><p style="color:blue;">您可以从https://dev.mysql.com/downloads/os-linux.html获得libimf。</p><p>
                To see which plugins are installed, use the
                <a class="link" href="sql-syntax.html#show-plugins" title="13.7.5.25&nbsp;SHOW PLUGINS Syntax"><code class="literal">SHOW PLUGINS</code></a> statement, or query
                the <a class="link" href="information-schema.html#plugins-table" title="24.17&nbsp;The INFORMATION_SCHEMA PLUGINS Table"><code class="literal">INFORMATION_SCHEMA.PLUGINS</code></a>
                table.
            </p><p style="color:blue;">要查看安装了哪些插件，请使用show plugins语句，或查询information_schema.plugins表。</p><p>
                To verify plugin installation, examine the
                <a class="link" href="information-schema.html#plugins-table" title="24.17&nbsp;The INFORMATION_SCHEMA PLUGINS Table"><code class="literal">INFORMATION_SCHEMA.PLUGINS</code></a> table or
                use the <a class="link" href="sql-syntax.html#show-plugins" title="13.7.5.25&nbsp;SHOW PLUGINS Syntax"><code class="literal">SHOW PLUGINS</code></a> statement
                (see <a class="xref" href="server-administration.html#obtaining-plugin-information" title="5.5.2&nbsp;Obtaining Server Plugin Information">Section&nbsp;5.5.2, “Obtaining Server Plugin Information”</a>). For
                example:
            </p><p style="color:blue;">要验证插件安装，请检查information\u schema.plugins表或使用show plugins语句（请参阅第5.5.2节“获取服务器插件信息”）。例如：</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT PLUGIN_NAME, PLUGIN_STATUS</code></strong>
       <strong class="userinput"><code>FROM INFORMATION_SCHEMA.PLUGINS</code></strong>
       <strong class="userinput"><code>WHERE PLUGIN_NAME LIKE '%semi%';</code></strong>
+----------------------+---------------+
| PLUGIN_NAME          | PLUGIN_STATUS |
+----------------------+---------------+
| rpl_semi_sync_master | ACTIVE        |
+----------------------+---------------+
</pre><p>
                If the plugin failed to initialize, check the server error log
                for diagnostic messages.
            </p><p style="color:blue;">如果插件未能初始化，请检查服务器错误日志中的诊断消息。</p><p>
                After a semisynchronous replication plugin has been installed,
                it is disabled by default. The plugins must be enabled both on
                the master side and the slave side to enable semisynchronous
                replication. If only one side is enabled, replication will be
                asynchronous.
            </p><p style="color:blue;">安装半同步复制插件后，默认情况下会禁用该插件。必须在主端和从端同时启用插件才能启用半同步复制。如果只启用了一侧，则复制将是异步的。</p><p>
                To control whether an installed plugin is enabled, set the
                appropriate system variables. You can set these variables at
                runtime using <a class="link" href="sql-syntax.html#set-variable" title="13.7.4.1&nbsp;SET Syntax for Variable Assignment"><code class="literal">SET
                GLOBAL</code></a>, or at server startup on the command line or in
                an option file.
            </p><p style="color:blue;">要控制是否启用已安装的插件，请设置适当的系统变量。可以在运行时使用set global设置这些变量，也可以在服务器启动时在命令行或选项文件中设置这些变量。</p><p>
                At runtime, these master-side system variables are available:
            </p><p style="color:blue;">在运行时，这些主端系统变量可用：</p><pre data-lang="sql" class="programlisting">SET GLOBAL rpl_semi_sync_master_enabled = {0|1};
SET GLOBAL rpl_semi_sync_master_timeout = <em class="replaceable"><code>N</code></em>;
</pre><p>
                On the slave side, this system variable is available:
            </p><p style="color:blue;">在从机端，此系统变量可用：</p><pre data-lang="sql" class="programlisting">SET GLOBAL rpl_semi_sync_slave_enabled = {0|1};
</pre><p>
                For
                <a class="link" href="replication.html#sysvar_rpl_semi_sync_master_enabled"><code class="literal">rpl_semi_sync_master_enabled</code></a> or
                <a class="link" href="replication.html#sysvar_rpl_semi_sync_slave_enabled"><code class="literal">rpl_semi_sync_slave_enabled</code></a>,
                the value should be 1 to enable semisynchronous replication or 0
                to disable it. By default, these variables are set to 0.
            </p><p style="color:blue;">对于启用rpl_semi_sync_master_或启用rpl_semi_sync_slave_，值应为1以启用半同步复制，或为0以禁用它。默认情况下，这些变量设置为0。</p><p>
                For
                <a class="link" href="replication.html#sysvar_rpl_semi_sync_master_timeout"><code class="literal">rpl_semi_sync_master_timeout</code></a>,
                the value <em class="replaceable"><code>N</code></em> is given in milliseconds.
                The default value is 10000 (10 seconds).
            </p><p style="color:blue;">对于rpl_semi_sync_master_timeout，值n以毫秒为单位。默认值为10000（10秒）。</p><p>
                If you enable semisynchronous replication on a slave at runtime,
                you must also start the slave I/O thread (stopping it first if
                it is already running) to cause the slave to connect to the
                master and register as a semisynchronous slave:
            </p><p style="color:blue;">如果在运行时在从机上启用半同步复制，则还必须启动从机I/O线程（如果它已在运行，则首先停止它），以使从机连接到主机并注册为半同步从机：</p><pre data-lang="sql" class="programlisting">STOP SLAVE IO_THREAD;
START SLAVE IO_THREAD;
</pre><p>
                If the I/O thread is already running and you do not restart it,
                the slave continues to use asynchronous replication.
            </p><p style="color:blue;">如果I/O线程已经在运行，而您没有重新启动它，则从机将继续使用异步复制。</p><p>
                At server startup, the variables that control semisynchronous
                replication can be set as command-line options or in an option
                file. A setting listed in an option file takes effect each time
                the server starts. For example, you can set the variables in
                <code class="filename">my.cnf</code> files on the master and slave sides
                as follows.
            </p><p style="color:blue;">在服务器启动时，控制半同步复制的变量可以设置为命令行选项或在选项文件中。选项文件中列出的设置在每次服务器启动时生效。例如，您可以在my.cnf文件的主端和从端设置变量，如下所示。</p><p>
                On the master:
            </p><p style="color:blue;">在主人身上：</p><pre data-lang="ini" class="programlisting">[mysqld]
rpl_semi_sync_master_enabled=1
rpl_semi_sync_master_timeout=1000 # 1 second
</pre><p>
                On each slave:
            </p><p style="color:blue;">在每个从机上：</p><pre data-lang="ini" class="programlisting">[mysqld]
rpl_semi_sync_slave_enabled=1
</pre>
            </div>
            <div class="section">
                <div class="titlepage">
                    <div>
                        <div>
                            <h4 class="title"><a name="replication-semisync-monitoring"></a>16.3.9.3&nbsp;Semisynchronous Replication Monitoring</h4>

                        </div>

                    </div>

                </div>
                <a class="indexterm" name="idm140286792521392"></a><p>
                The plugins for the semisynchronous replication capability
                expose several system and status variables that you can examine
                to determine its configuration and operational state.
            </p><p style="color:blue;">半同步复制功能的插件公开了几个系统和状态变量，您可以检查这些变量以确定其配置和操作状态。</p><p>
                The system variable reflect how semisynchronous replication is
                configured. To check their values, use <a class="link" href="sql-syntax.html#show-variables" title="13.7.5.39&nbsp;SHOW VARIABLES Syntax"><code class="literal">SHOW
                VARIABLES</code></a>:
            </p><p style="color:blue;">系统变量反映了如何配置半同步复制。要检查其值，请使用show variables：</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>SHOW VARIABLES LIKE 'rpl_semi_sync%';</code></strong>
</pre><p>
                The status variables enable you to monitor the operation of
                semisynchronous replication. To check their values, use
                <a class="link" href="sql-syntax.html#show-status" title="13.7.5.35&nbsp;SHOW STATUS Syntax"><code class="literal">SHOW STATUS</code></a>:
            </p><p style="color:blue;">状态变量使您能够监视半同步复制的操作。要检查其值，请使用“显示状态”：</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>SHOW STATUS LIKE 'Rpl_semi_sync%';</code></strong>
</pre><p>
                When the master switches between asynchronous or semisynchronous
                replication due to commit-blocking timeout or a slave catching
                up, it sets the value of the
                <a class="link" href="server-administration.html#statvar_Rpl_semi_sync_master_status"><code class="literal">Rpl_semi_sync_master_status</code></a>
                status variable appropriately. Automatic fallback from
                semisynchronous to asynchronous replication on the master means
                that it is possible for the
                <a class="link" href="replication.html#sysvar_rpl_semi_sync_master_enabled"><code class="literal">rpl_semi_sync_master_enabled</code></a>
                system variable to have a value of 1 on the master side even
                when semisynchronous replication is in fact not operational at
                the moment. You can monitor the
                <a class="link" href="server-administration.html#statvar_Rpl_semi_sync_master_status"><code class="literal">Rpl_semi_sync_master_status</code></a>
                status variable to determine whether the master currently is
                using asynchronous or semisynchronous replication.
            </p><p style="color:blue;">当主服务器由于提交阻塞超时或从服务器捕获而在异步或半同步复制之间切换时，它会相应地设置rpl_semi_sync_master_status变量的值。从主服务器上的半同步复制到异步复制的自动回退意味着，即使半同步复制目前实际上不起作用，rpl_semi_sync_master_enabled系统变量在主服务器端的值也可能为1。您可以监视rpl_semi_sync_master_status变量，以确定主机当前是使用异步复制还是半同步复制。</p><p>
                To see how many semisynchronous slaves are connected, check
                <a class="link" href="server-administration.html#statvar_Rpl_semi_sync_master_clients"><code class="literal">Rpl_semi_sync_master_clients</code></a>.
            </p><p style="color:blue;">要查看连接了多少个半同步从机，请检查rpl_semi_sync_master_客户端。</p><p>
                The number of commits that have been acknowledged successfully
                or unsuccessfully by slaves are indicated by the
                <a class="link" href="server-administration.html#statvar_Rpl_semi_sync_master_yes_tx"><code class="literal">Rpl_semi_sync_master_yes_tx</code></a>
                and <a class="link" href="server-administration.html#statvar_Rpl_semi_sync_master_no_tx"><code class="literal">Rpl_semi_sync_master_no_tx</code></a>
                variables.
            </p><p style="color:blue;">从系统已成功或未成功确认的提交数由rpl_semi_sync_master_yes_tx和rpl_semi_sync_master_no_tx变量指示。</p><p>
                On the slave side,
                <a class="link" href="server-administration.html#statvar_Rpl_semi_sync_slave_status"><code class="literal">Rpl_semi_sync_slave_status</code></a>
                indicates whether semisynchronous replication currently is
                operational.
            </p><p style="color:blue;">在从机端，rpl_semi_sync_slave_status指示半同步复制当前是否可操作。</p>
            </div>

        </div>
        <div class="section">
            <div class="titlepage">
                <div>
                    <div>
                        <h3 class="title"><a name="replication-delayed"></a>16.3.10&nbsp;Delayed Replication</h3>

                    </div>

                </div>

            </div>
            <a class="indexterm" name="idm140286792499584"></a><a class="indexterm" name="idm140286792498512"></a><p>
            MySQL 5.7 supports delayed replication such that a
            slave server deliberately lags behind the master by at least a
            specified amount of time. The default delay is 0 seconds. Use the
            <code class="literal">MASTER_DELAY</code> option for
            <a class="link" href="sql-syntax.html#change-master-to" title="13.4.2.1&nbsp;CHANGE MASTER TO Syntax"><code class="literal">CHANGE MASTER TO</code></a> to set the delay
            to <em class="replaceable"><code>N</code></em> seconds:
        </p><p style="color:blue;">mysql 5.7支持延迟复制，因此从服务器故意将主服务器延迟至少一段指定的时间。默认延迟为0秒。使用“更改主控”的“主控延迟”选项将延迟设置为N秒：</p><pre data-lang="sql" class="programlisting">CHANGE MASTER TO MASTER_DELAY = <em class="replaceable"><code>N</code></em>;
</pre><p>
            An event received from the master is not executed until at least
            <em class="replaceable"><code>N</code></em> seconds later than its execution on
            the master. The exceptions are that there is no delay for format
            description events or log file rotation events, which affect only
            the internal state of the SQL thread.
        </p><p style="color:blue;">从主服务器接收到的事件在其在主服务器上执行之后至少n秒才执行。例外情况是格式描述事件或日志文件旋转事件没有延迟，这些事件只影响sql线程的内部状态。</p><p>
            Delayed replication can be used for several purposes:
        </p><p style="color:blue;">延迟复制可用于多种目的：</p>
            <div class="itemizedlist">
                <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                    To protect against user mistakes on the master. A DBA can roll
                    back a delayed slave to the time just before the disaster.
                </p><p style="color:blue;">防止用户在主机上出错。dba可以将延迟的从机回滚到灾难发生前的时间。</p></li><li class="listitem"><p>
                    To test how the system behaves when there is a lag. For
                    example, in an application, a lag might be caused by a heavy
                    load on the slave. However, it can be difficult to generate
                    this load level. Delayed replication can simulate the lag
                    without having to simulate the load. It can also be used to
                    debug conditions related to a lagging slave.
                </p><p style="color:blue;">测试系统在有延迟时的行为。例如，在应用程序中，延迟可能是由从机上的重载引起的。但是，很难生成此负载级别。延迟复制可以模拟延迟，而无需模拟负载。它还可用于调试与滞后从机相关的条件。</p></li><li class="listitem"><p>
                    To inspect what the database looked like long ago, without
                    having to reload a backup. For example, if the delay is one
                    week and the DBA needs to see what the database looked like
                    before the last few days' worth of development, the delayed
                    slave can be inspected.
                </p><p style="color:blue;">检查数据库的外观，而不必重新加载备份。例如，如果延迟是一周，并且dba需要在最后几天的开发之前查看数据库的外观，那么可以检查延迟的从机。</p></li></ul>
            </div>
            <p>
                <a class="link" href="sql-syntax.html#start-slave" title="13.4.2.6&nbsp;START SLAVE Syntax"><code class="literal">START SLAVE</code></a> and
                <a class="link" href="sql-syntax.html#stop-slave" title="13.4.2.7&nbsp;STOP SLAVE Syntax"><code class="literal">STOP SLAVE</code></a> take effect immediately
                and ignore any delay. <a class="link" href="sql-syntax.html#reset-slave" title="13.4.2.4&nbsp;RESET SLAVE Syntax"><code class="literal">RESET SLAVE</code></a>
                resets the delay to 0.
            </p><p style="color:blue;">启动从机和停止从机立即生效并忽略任何延迟。重置从机将延迟重置为0。</p><p>
            <a class="link" href="sql-syntax.html#show-slave-status" title="13.7.5.34&nbsp;SHOW SLAVE STATUS Syntax"><code class="literal">SHOW SLAVE STATUS</code></a> has three fields
            that provide information about the delay:
        </p><p style="color:blue;">Show Slave Status有三个字段提供有关延迟的信息：</p>
            <div class="itemizedlist">
                <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                    <code class="literal">SQL_Delay</code>: A nonnegative integer indicating
                    the number of seconds that the slave must lag the master.
                </p><p style="color:blue;">sql_delay：非负整数，表示从机必须滞后于主机的秒数。</p></li><li class="listitem"><p>
                    <code class="literal">SQL_Remaining_Delay</code>: When
                    <code class="literal">Slave_SQL_Running_State</code> is <code class="literal">Waiting
                    until MASTER_DELAY seconds after master executed
                    event</code>, this field contains an integer indicating the
                    number of seconds left of the delay. At other times, this
                    field is <code class="literal">NULL</code>.
                </p><p style="color:blue;">sql_remaining_delay：当slave_sql_running_state在master_delay seconds之后等待master_delay seconds时，此字段包含一个整数，指示延迟剩余的秒数。其他时候，此字段为空。</p></li><li class="listitem"><p>
                    <code class="literal">Slave_SQL_Running_State</code>: A string
                    indicating the state of the SQL thread (analogous to
                    <code class="literal">Slave_IO_State</code>). The value is identical to
                    the <code class="literal">State</code> value of the SQL thread as
                    displayed by <a class="link" href="sql-syntax.html#show-processlist" title="13.7.5.29&nbsp;SHOW PROCESSLIST Syntax"><code class="literal">SHOW PROCESSLIST</code></a>.
                </p><p style="color:blue;">slave_sql_running_state：表示SQL线程状态的字符串（类似于slave_io_state）。该值与show processlist显示的sql线程的状态值相同。</p></li></ul>
            </div>
            <p>
                When the slave SQL thread is waiting for the delay to elapse
                before executing an event, <a class="link" href="sql-syntax.html#show-processlist" title="13.7.5.29&nbsp;SHOW PROCESSLIST Syntax"><code class="literal">SHOW
                PROCESSLIST</code></a> displays its <code class="literal">State</code> value
                as <code class="literal">Waiting until MASTER_DELAY seconds after master
                executed event</code>.
            </p><p style="color:blue;">当从sql线程在执行事件之前等待延迟时间过去时，show processlist将其状态值显示为在主执行事件后等待主延迟秒。</p>
        </div>

    </div>
    <div class="section">
        <div class="titlepage">
            <div>
                <div>
                    <h2 class="title" style="clear: both"><a name="replication-notes"></a>16.4&nbsp;Replication Notes and Tips</h2>

                </div>

            </div>

        </div>
        <div class="toc">
            <dl class="toc"><dt><span class="section"><a href="replication.html#replication-features">16.4.1 Replication Features and Issues</a></span></dt><dt><span class="section"><a href="replication.html#replication-compatibility">16.4.2 Replication Compatibility Between MySQL Versions</a></span></dt><dt><span class="section"><a href="replication.html#replication-upgrade">16.4.3 Upgrading a Replication Setup</a></span></dt><dt><span class="section"><a href="replication.html#replication-problems">16.4.4 Troubleshooting Replication</a></span></dt><dt><span class="section"><a href="replication.html#replication-bugs">16.4.5 How to Report Replication Bugs or Problems</a></span></dt></dl>
        </div>
        <div class="section">
            <div class="titlepage">
                <div>
                    <div>
                        <h3 class="title"><a name="replication-features"></a>16.4.1&nbsp;Replication Features and Issues</h3>

                    </div>

                </div>

            </div>
            <div class="toc">
                <dl class="toc"><dt><span class="section"><a href="replication.html#replication-features-auto-increment">16.4.1.1 Replication and AUTO_INCREMENT</a></span></dt><dt><span class="section"><a href="replication.html#replication-features-blackhole">16.4.1.2 Replication and BLACKHOLE Tables</a></span></dt><dt><span class="section"><a href="replication.html#replication-features-charset">16.4.1.3 Replication and Character Sets</a></span></dt><dt><span class="section"><a href="replication.html#replication-features-checksum-table">16.4.1.4 Replication and CHECKSUM TABLE</a></span></dt><dt><span class="section"><a href="replication.html#replication-features-create-if-not-exists">16.4.1.5 Replication of CREATE ... IF NOT EXISTS Statements</a></span></dt><dt><span class="section"><a href="replication.html#replication-features-create-select">16.4.1.6 Replication of CREATE TABLE ... SELECT Statements</a></span></dt><dt><span class="section"><a href="replication.html#replication-features-create-alter-drop-server">16.4.1.7 Replication of CREATE SERVER, ALTER SERVER, and DROP SERVER</a></span></dt><dt><span class="section"><a href="replication.html#replication-features-current-user">16.4.1.8 Replication of CURRENT_USER()</a></span></dt><dt><span class="section"><a href="replication.html#replication-features-drop-if-exists">16.4.1.9 Replication of DROP ... IF EXISTS Statements</a></span></dt><dt><span class="section"><a href="replication.html#replication-features-differing-tables">16.4.1.10 Replication with Differing Table Definitions on Master and Slave</a></span></dt><dt><span class="section"><a href="replication.html#replication-features-directory">16.4.1.11 Replication and DIRECTORY Table Options</a></span></dt><dt><span class="section"><a href="replication.html#replication-features-floatvalues">16.4.1.12 Replication and Floating-Point Values</a></span></dt><dt><span class="section"><a href="replication.html#replication-features-fractional-seconds">16.4.1.13 Replication and Fractional Seconds Support</a></span></dt><dt><span class="section"><a href="replication.html#replication-features-flush">16.4.1.14 Replication and FLUSH</a></span></dt><dt><span class="section"><a href="replication.html#replication-features-functions">16.4.1.15 Replication and System Functions</a></span></dt><dt><span class="section"><a href="replication.html#replication-features-invoked">16.4.1.16 Replication of Invoked Features</a></span></dt><dt><span class="section"><a href="replication.html#replication-features-limit">16.4.1.17 Replication and LIMIT</a></span></dt><dt><span class="section"><a href="replication.html#replication-features-load-data">16.4.1.18 Replication and LOAD DATA</a></span></dt><dt><span class="section"><a href="replication.html#replication-features-max-allowed-packet">16.4.1.19 Replication and max_allowed_packet</a></span></dt><dt><span class="section"><a href="replication.html#replication-features-memory">16.4.1.20 Replication and MEMORY Tables</a></span></dt><dt><span class="section"><a href="replication.html#replication-features-mysqldb">16.4.1.21 Replication of the mysql System Database</a></span></dt><dt><span class="section"><a href="replication.html#replication-features-optimizer">16.4.1.22 Replication and the Query Optimizer</a></span></dt><dt><span class="section"><a href="replication.html#replication-features-partitioning">16.4.1.23 Replication and Partitioning</a></span></dt><dt><span class="section"><a href="replication.html#replication-features-repair-table">16.4.1.24 Replication and REPAIR TABLE</a></span></dt><dt><span class="section"><a href="replication.html#replication-features-reserved-words">16.4.1.25 Replication and Reserved Words</a></span></dt><dt><span class="section"><a href="replication.html#replication-features-shutdowns">16.4.1.26 Replication and Master or Slave Shutdowns</a></span></dt><dt><span class="section"><a href="replication.html#replication-features-slaveerrors">16.4.1.27 Slave Errors During Replication</a></span></dt><dt><span class="section"><a href="replication.html#replication-features-sql-mode">16.4.1.28 Replication and Server SQL Mode</a></span></dt><dt><span class="section"><a href="replication.html#replication-features-temptables">16.4.1.29 Replication and Temporary Tables</a></span></dt><dt><span class="section"><a href="replication.html#replication-features-timeout">16.4.1.30 Replication Retries and Timeouts</a></span></dt><dt><span class="section"><a href="replication.html#replication-features-timezone">16.4.1.31 Replication and Time Zones</a></span></dt><dt><span class="section"><a href="replication.html#replication-features-transaction-inconsistencies">16.4.1.32 Replication and Transaction Inconsistencies</a></span></dt><dt><span class="section"><a href="replication.html#replication-features-transactions">16.4.1.33 Replication and Transactions</a></span></dt><dt><span class="section"><a href="replication.html#replication-features-triggers">16.4.1.34 Replication and Triggers</a></span></dt><dt><span class="section"><a href="replication.html#replication-features-truncate">16.4.1.35 Replication and TRUNCATE TABLE</a></span></dt><dt><span class="section"><a href="replication.html#replication-features-user-names">16.4.1.36 Replication and User Name Length</a></span></dt><dt><span class="section"><a href="replication.html#replication-features-variables">16.4.1.37 Replication and Variables</a></span></dt><dt><span class="section"><a href="replication.html#replication-features-views">16.4.1.38 Replication and Views</a></span></dt></dl>
            </div>
            <a class="indexterm" name="idm140286792465504"></a><a class="indexterm" name="idm140286792464048"></a><a class="indexterm" name="idm140286792462976"></a><a class="indexterm" name="idm140286792461488"></a><a class="indexterm" name="idm140286792460416"></a><a class="indexterm" name="idm140286792459344"></a><p>
            The following sections provide information about what is supported
            and what is not in MySQL replication, and about specific issues
            and situations that may occur when replicating certain statements.
        </p><p style="color:blue;">以下各节提供有关mysql复制中支持的内容和不支持的内容的信息，以及有关复制某些语句时可能出现的特定问题和情况的信息。</p><p>
            Statement-based replication depends on compatibility at the SQL
            level between the master and slave. In other words, successful
            statement-based replication requires that any SQL features used be
            supported by both the master and the slave servers. If you use a
            feature on the master server that is available only in the current
            version of MySQL, you cannot replicate to a slave that uses an
            earlier version of MySQL. Such incompatibilities can also occur
            within a release series as well as between versions.
        </p><p style="color:blue;">基于语句的复制依赖于主服务器和从服务器之间SQL级别的兼容性。换句话说，成功的基于语句的复制要求主服务器和从服务器都支持所使用的任何sql特性。如果在主服务器上使用仅在当前版本的mysql中可用的功能，则无法复制到使用早期版本mysql的从属服务器。这样的不兼容也可能发生在发行版系列中以及版本之间。</p><p>
            If you are planning to use statement-based replication between
            MySQL 5.7 and a previous MySQL release series, it is
            a good idea to consult the edition of the <em class="citetitle">MySQL
            Reference Manual</em> corresponding to the earlier release
            series for information regarding the replication characteristics
            of that series.
        </p><p style="color:blue;">如果您计划在mysql 5.7和以前的mysql发行版系列之间使用基于语句的复制，那么最好参考与以前的发行版系列相对应的mysql参考手册版本，以获取有关该系列复制特性的信息。</p><p>
            With MySQL's statement-based replication, there may be issues with
            replicating stored routines or triggers. You can avoid these
            issues by using MySQL's row-based replication instead. For a
            detailed list of issues, see
            <a class="xref" href="stored-objects.html#stored-programs-logging" title="23.7&nbsp;Stored Program Binary Logging">Section&nbsp;23.7, “Stored Program Binary Logging”</a>. For more information
            about row-based logging and row-based replication, see
            <a class="xref" href="server-administration.html#binary-log-formats" title="5.4.4.1&nbsp;Binary Logging Formats">Section&nbsp;5.4.4.1, “Binary Logging Formats”</a>, and
            <a class="xref" href="replication.html#replication-formats" title="16.2.1&nbsp;Replication Formats">Section&nbsp;16.2.1, “Replication Formats”</a>.
        </p><p style="color:blue;">使用mysql的基于语句的复制，复制存储例程或触发器可能会出现问题。您可以使用mysql的基于行的复制来避免这些问题。有关问题的详细列表，请参阅第23.7节“存储程序二进制日志记录”。有关基于行的日志记录和基于行的复制的详细信息，请参阅第5.4.4.1节“二进制日志记录格式”和第16.2.1节“复制格式”。</p><p>
            For additional information specific to replication and
            <code class="literal">InnoDB</code>, see
            <a class="xref" href="innodb-storage-engine.html#innodb-and-mysql-replication" title="14.19&nbsp;InnoDB and MySQL Replication">Section&nbsp;14.19, “InnoDB and MySQL Replication”</a>. For information
            relating to replication with NDB Cluster, see
            <a class="xref" href="mysql-cluster.html#mysql-cluster-replication" title="21.6&nbsp;NDB Cluster Replication">Section&nbsp;21.6, “NDB Cluster Replication”</a>.
        </p><p style="color:blue;">有关复制和innodb的更多信息，请参阅14.19节“innodb和mysql复制”。有关使用ndb群集复制的信息，请参阅21.6节“ndb群集复制”。</p>
            <div class="section">

                <div class="titlepage">
                    <div>
                        <div>
                            <h4 class="title"><a name="replication-features-auto-increment"></a>16.4.1.1&nbsp;Replication and AUTO_INCREMENT</h4>
                        </div>
                    </div>
                </div>
                <a class="indexterm" name="idm140286792448624"></a><a class="indexterm" name="idm140286792447136"></a><a class="indexterm" name="idm140286792445648"></a><a class="indexterm" name="idm140286792444160"></a><a class="indexterm" name="idm140286792442672"></a><a class="indexterm" name="idm140286792441184"></a><p>
                Statement-based replication of
                <code class="literal">AUTO_INCREMENT</code>,
                <a class="link" href="functions.html#function_last-insert-id"><code class="literal">LAST_INSERT_ID()</code></a>, and
                <a class="link" href="data-types.html#datetime" title="11.3.1&nbsp;The DATE, DATETIME, and TIMESTAMP Types"><code class="literal">TIMESTAMP</code></a> values is done
                correctly, subject to the following exceptions:
            </p><p style="color:blue;">基于语句的auto_increment、last_insert_id（）和timestamp值复制正确完成，但有以下异常：</p>
                <div class="itemizedlist">
                    <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                        When using statement-based replication prior to MySQL 5.7.1,
                        <code class="literal">AUTO_INCREMENT</code> columns in tables on the
                        slave must match the same columns on the master; that is,
                        <code class="literal">AUTO_INCREMENT</code> columns must be replicated
                        to <code class="literal">AUTO_INCREMENT</code> columns.
                    </p><p style="color:blue;">在mysql 5.7.1之前使用基于语句的复制时，从表中的auto_increment列必须与主表中的相同列匹配，即auto_increment列必须复制到auto_increment列。</p></li><li class="listitem"><p>
                        A statement invoking a trigger or function that causes an
                        update to an <code class="literal">AUTO_INCREMENT</code> column is not
                        replicated correctly using statement-based replication.
                        These statements are marked as unsafe. (Bug #45677)
                    </p><p style="color:blue;">使用基于语句的复制无法正确复制调用触发器或函数的语句，该语句会导致对自动递增列的更新。这些语句被标记为不安全。（错误45677）</p></li><li class="listitem"><p>
                        An <a class="link" href="sql-syntax.html#insert" title="13.2.5&nbsp;INSERT Syntax"><code class="literal">INSERT</code></a> into a table that
                        has a composite primary key that includes an
                        <code class="literal">AUTO_INCREMENT</code> column that is not the
                        first column of this composite key is not safe for
                        statement-based logging or replication. These statements are
                        marked as unsafe. (Bug #11754117, Bug #45670)
                    </p><p style="color:blue;">如果向表中插入的复合主键包含不是此复合键第一列的自动递增列，则对基于语句的日志记录或复制不安全。这些语句被标记为不安全。（错误11754117，错误45670）</p><p>
                        This issue does not affect tables using the
                        <a class="link" href="innodb-storage-engine.html" title="Chapter&nbsp;14&nbsp;The InnoDB Storage Engine"><code class="literal">InnoDB</code></a> storage engine, since an
                        <code class="literal">InnoDB</code> table with an
                        <a class="link" href="glossary.html#glos_auto_increment" title="auto-increment">AUTO_INCREMENT</a>
                        column requires at least one key where the auto-increment
                        column is the only or leftmost column.
                    </p><p style="color:blue;">此问题不影响使用innodb存储引擎的表，因为具有auto_increment列的innodb表至少需要一个键，其中auto increment列是唯一或最左边的列。</p></li><li class="listitem"><p>
                        Adding an <code class="literal">AUTO_INCREMENT</code> column to a
                        table with <a class="link" href="sql-syntax.html#alter-table" title="13.1.8&nbsp;ALTER TABLE Syntax"><code class="literal">ALTER TABLE</code></a> might
                        not produce the same ordering of the rows on the slave and
                        the master. This occurs because the order in which the rows
                        are numbered depends on the specific storage engine used for
                        the table and the order in which the rows were inserted. If
                        it is important to have the same order on the master and
                        slave, the rows must be ordered before assigning an
                        <code class="literal">AUTO_INCREMENT</code> number. Assuming that you
                        want to add an <code class="literal">AUTO_INCREMENT</code> column to a
                        table <code class="literal">t1</code> that has columns
                        <code class="literal">col1</code> and <code class="literal">col2</code>, the
                        following statements produce a new table
                        <code class="literal">t2</code> identical to <code class="literal">t1</code> but
                        with an <code class="literal">AUTO_INCREMENT</code> column:
                    </p><p style="color:blue;">向具有alter table的表中添加auto_increment列可能不会在从机和主机上产生相同的行顺序。这是因为行的编号顺序取决于用于表的特定存储引擎以及行的插入顺序。如果在主从机上有相同的顺序很重要，则在分配自动递增数之前必须对行进行排序。假设要将auto_increment列添加到具有col1和col2列的表t1中，则以下语句将生成与t1相同但具有auto_increment列的新表t2：</p><pre data-lang="sql" class="programlisting">CREATE TABLE t2 LIKE t1;
ALTER TABLE t2 ADD id INT AUTO_INCREMENT PRIMARY KEY;
INSERT INTO t2 SELECT * FROM t1 ORDER BY col1, col2;
</pre>
                        <div class="important" style="margin-left: 0.5in; margin-right: 0.5in;">

                            <div class="admon-title">
                                Important
                            </div>
                            <p>
                                To guarantee the same ordering on both master and slave,
                                the <code class="literal">ORDER BY</code> clause must name
                                <span class="emphasis"><em>all</em></span> columns of <code class="literal">t1</code>.
                            </p><p style="color:blue;">为了保证主从机上的顺序相同，ORDERBY子句必须命名T1的所有列。</p>
                        </div>
                        <p>
                            The instructions just given are subject to the limitations
                            of <a class="link" href="sql-syntax.html#create-table-like" title="13.1.18.4&nbsp;CREATE TABLE ... LIKE Syntax"><code class="literal">CREATE
                            TABLE ... LIKE</code></a>: Foreign key definitions are
                            ignored, as are the <code class="literal">DATA DIRECTORY</code> and
                            <code class="literal">INDEX DIRECTORY</code> table options. If a table
                            definition includes any of those characteristics, create
                            <code class="literal">t2</code> using a <a class="link" href="sql-syntax.html#create-table" title="13.1.18&nbsp;CREATE TABLE Syntax"><code class="literal">CREATE
                            TABLE</code></a> statement that is identical to the one used
                            to create <code class="literal">t1</code>, but with the addition of
                            the <code class="literal">AUTO_INCREMENT</code> column.
                        </p><p style="color:blue;">刚刚给出的指令受创建表的限制…like：外键定义被忽略，数据目录和索引目录表选项也被忽略。如果表定义包含这些特性中的任何一个，则使用与用于创建T1的语句相同的CREATETABLE语句创建T2，但添加了auto_increment列。</p><p>
                            Regardless of the method used to create and populate the
                            copy having the <code class="literal">AUTO_INCREMENT</code> column,
                            the final step is to drop the original table and then rename
                            the copy:
                        </p><p style="color:blue;">无论用于创建和填充具有“自动递增”列的副本的方法如何，最后一步是删除原始表，然后重命名副本：</p><pre data-lang="sql" class="programlisting">DROP t1;
ALTER TABLE t2 RENAME t1;
</pre><p>
                            See also <a class="xref" href="error-handling.html#alter-table-problems" title="B.4.6.1&nbsp;Problems with ALTER TABLE">Section&nbsp;B.4.6.1, “Problems with ALTER TABLE”</a>.
                        </p><p style="color:blue;">另请参见第B.4.6.1节“alter table的问题”。</p></li></ul>
                </div>

            </div>
            <div class="section">
                <div class="titlepage">
                    <div>
                        <div>
                            <h4 class="title"><a name="replication-features-blackhole"></a>16.4.1.2&nbsp;Replication and BLACKHOLE Tables</h4>

                        </div>

                    </div>

                </div>
                <a class="indexterm" name="idm140286792400128"></a><a class="indexterm" name="idm140286792398640"></a><a class="indexterm" name="idm140286792397152"></a><a class="indexterm" name="idm140286792395664"></a><p>
                The <a class="link" href="storage-engines.html#blackhole-storage-engine" title="15.6&nbsp;The BLACKHOLE Storage Engine"><code class="literal">BLACKHOLE</code></a> storage engine
                accepts data but discards it and does not store it. When
                performing binary logging, all inserts to such tables are always
                logged, regardless of the logging format in use. Updates and
                deletes are handled differently depending on whether statement
                based or row based logging is in use. With the statement based
                logging format, all statements affecting
                <code class="literal">BLACKHOLE</code> tables are logged, but their
                effects ignored. When using row-based logging, updates and
                deletes to such tables are simply skipped—they are not
                written to the binary log. A warning is logged whenever this
                occurs (Bug #13004581).
            </p><p style="color:blue;">黑洞存储引擎接受数据，但丢弃数据，不存储数据。在执行二进制日志记录时，总是记录对此类表的所有插入，而不管使用何种日志记录格式。根据使用的是基于语句的日志记录还是基于行的日志记录，更新和删除的处理方式不同。使用基于语句的日志记录格式，会记录所有影响黑洞表的语句，但忽略它们的影响。使用基于行的日志记录时，只需跳过对此类表的更新和删除，它们不会写入二进制日志。每当发生这种情况时，都会记录一个警告（Bug 13004581）。</p><p>
                For this reason we recommend when you replicate to tables using
                the <a class="link" href="storage-engines.html#blackhole-storage-engine" title="15.6&nbsp;The BLACKHOLE Storage Engine"><code class="literal">BLACKHOLE</code></a> storage engine that
                you have the <a class="link" href="replication.html#sysvar_binlog_format"><code class="literal">binlog_format</code></a>
                server variable set to <code class="literal">STATEMENT</code>, and not to
                either <code class="literal">ROW</code> or <code class="literal">MIXED</code>.
            </p><p style="color:blue;">因此，我们建议在使用黑洞存储引擎复制到表时，将binlog_format server变量设置为statement，而不是row或mixed。</p>
            </div>
            <div class="section">
                <div class="titlepage">
                    <div>
                        <div>
                            <h4 class="title"><a name="replication-features-charset"></a>16.4.1.3&nbsp;Replication and Character Sets</h4>

                        </div>

                    </div>

                </div>
                <a class="indexterm" name="idm140286792384352"></a><a class="indexterm" name="idm140286792382864"></a><p>
                The following applies to replication between MySQL servers that
                use different character sets:
            </p><p style="color:blue;">以下内容适用于使用不同字符集的MySQL服务器之间的复制：</p>
                <div class="itemizedlist">
                    <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                        If the master has databases with a character set different
                        from the global
                        <a class="link" href="server-administration.html#sysvar_character_set_server"><code class="literal">character_set_server</code></a> value,
                        you should design your <a class="link" href="sql-syntax.html#create-table" title="13.1.18&nbsp;CREATE TABLE Syntax"><code class="literal">CREATE
                        TABLE</code></a> statements so that they do not implicitly
                        rely on the database default character set. A good
                        workaround is to state the character set and collation
                        explicitly in <a class="link" href="sql-syntax.html#create-table" title="13.1.18&nbsp;CREATE TABLE Syntax"><code class="literal">CREATE TABLE</code></a>
                        statements.
                    </p><p style="color:blue;">如果主数据库的字符集与全局字符集服务器值不同，则应设计CREATE TABLE语句，使其不隐式依赖于数据库默认字符集。一个好的解决方法是在CREATETABLE语句中显式地声明字符集和排序规则。</p></li></ul>
                </div>

            </div>
            <div class="section">
                <div class="titlepage">
                    <div>
                        <div>
                            <h4 class="title"><a name="replication-features-checksum-table"></a>16.4.1.4&nbsp;Replication and CHECKSUM TABLE</h4>

                        </div>

                    </div>

                </div>
                <a class="indexterm" name="idm140286792374288"></a><a class="indexterm" name="idm140286792372784"></a><p>
                <a class="link" href="sql-syntax.html#checksum-table" title="13.7.2.3&nbsp;CHECKSUM TABLE Syntax"><code class="literal">CHECKSUM TABLE</code></a> returns a checksum
                that is calculated row by row, using a method that depends on
                the table row storage format. The storage format is not
                guaranteed to remain the same between MySQL versions, so the
                checksum value might change following an upgrade.
            </p><p style="color:blue;">checksum table使用依赖于表行存储格式的方法返回逐行计算的校验和。不能保证MySQL版本之间的存储格式保持不变，因此在升级后校验和值可能会更改。</p>
            </div>
            <div class="section">
                <div class="titlepage">
                    <div>
                        <div>
                            <h4 class="title"><a name="replication-features-create-if-not-exists"></a>16.4.1.5&nbsp;Replication of CREATE ... IF NOT EXISTS Statements</h4>

                        </div>

                    </div>

                </div>
                <a class="indexterm" name="idm140286792368032"></a><a class="indexterm" name="idm140286792366528"></a><p>
                MySQL applies these rules when various <code class="literal">CREATE ... IF
                NOT EXISTS</code> statements are replicated:
            </p><p style="color:blue;">MySQL在各种创建…如果不存在，则复制语句：</p>
                <div class="itemizedlist">
                    <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                        Every
                        <a class="link" href="sql-syntax.html#create-database" title="13.1.11&nbsp;CREATE DATABASE Syntax"><code class="literal">CREATE
                            DATABASE IF NOT EXISTS</code></a> statement is replicated,
                        whether or not the database already exists on the master.
                    </p><p style="color:blue;">复制每个创建数据库（如果不存在语句），无论数据库是否已经存在于主机上。</p></li><li class="listitem"><p>
                        Similarly, every
                        <a class="link" href="sql-syntax.html#create-table" title="13.1.18&nbsp;CREATE TABLE Syntax"><code class="literal">CREATE TABLE
                            IF NOT EXISTS</code></a> statement without a
                        <a class="link" href="sql-syntax.html#select" title="13.2.9&nbsp;SELECT Syntax"><code class="literal">SELECT</code></a> is replicated, whether
                        or not the table already exists on the master. This includes
                        <a class="link" href="sql-syntax.html#create-table-like" title="13.1.18.4&nbsp;CREATE TABLE ... LIKE Syntax"><code class="literal">CREATE
                            TABLE IF NOT EXISTS ... LIKE</code></a>. Replication of
                        <a class="link" href="sql-syntax.html#create-table-select" title="13.1.18.5&nbsp;CREATE TABLE ... SELECT Syntax"><code class="literal">CREATE
                            TABLE IF NOT EXISTS ... SELECT</code></a> follows somewhat
                        different rules; see
                        <a class="xref" href="replication.html#replication-features-create-select" title="16.4.1.6&nbsp;Replication of CREATE TABLE ... SELECT Statements">Section&nbsp;16.4.1.6, “Replication of CREATE TABLE ... SELECT Statements”</a>, for
                        more information.
                    </p><p style="color:blue;">类似地，如果不存在选择，则复制每个创建表（如果不存在）语句，无论该表是否已经存在于主控器上。如果不存在，这包括创建表…就像。如果不存在，则复制创建表…select遵循一些不同的规则；请参阅16.4.1.6节，“创建表的复制…”有关详细信息，请选择“语句”。</p></li><li class="listitem"><p>
                        <a class="link" href="sql-syntax.html#create-event" title="13.1.12&nbsp;CREATE EVENT Syntax"><code class="literal">CREATE EVENT
                            IF NOT EXISTS</code></a> is always replicated, whether or not
                        the event named in the statement already exists on the
                        master.
                    </p><p style="color:blue;">如果不存在，则始终复制创建事件，无论该语句中命名的事件是否已经存在于主目录中。</p></li></ul>
                </div>

            </div>
            <div class="section">
                <div class="titlepage">
                    <div>
                        <div>
                            <h4 class="title"><a name="replication-features-create-select"></a>16.4.1.6&nbsp;Replication of CREATE TABLE ... SELECT Statements</h4>

                        </div>

                    </div>

                </div>
                <a class="indexterm" name="idm140286792350864"></a><a class="indexterm" name="idm140286792349408"></a><p>
                This section discusses how MySQL replicates
                <a class="link" href="sql-syntax.html#create-table-select" title="13.1.18.5&nbsp;CREATE TABLE ... SELECT Syntax"><code class="literal">CREATE
                    TABLE ... SELECT</code></a> statements.
            </p><p style="color:blue;">本节讨论mysql如何复制create table…选择语句。</p><p>
                MySQL 5.7 does not allow a
                <a class="link" href="sql-syntax.html#create-table-select" title="13.1.18.5&nbsp;CREATE TABLE ... SELECT Syntax"><code class="literal">CREATE
                    TABLE ... SELECT</code></a> statement to make any changes in
                tables other than the table that is created by the statement.
                Some older versions of MySQL permitted these statements to do
                so; this means that, when using statement-based replication
                between a MySQL 5.6 or later slave and a master running a
                previous version of MySQL, a
                <a class="link" href="sql-syntax.html#create-table-select" title="13.1.18.5&nbsp;CREATE TABLE ... SELECT Syntax"><code class="literal">CREATE
                    TABLE ... SELECT</code></a> statement causing changes in other
                tables on the master fails on the slave, causing replication to
                stop. To prevent this from happening, you should use row-based
                replication, rewrite the offending statement before running it
                on the master, or upgrade the master to MySQL 5.7.
                (If you choose to upgrade the master, keep in mind that such a
                <a class="link" href="sql-syntax.html#create-table-select" title="13.1.18.5&nbsp;CREATE TABLE ... SELECT Syntax"><code class="literal">CREATE
                    TABLE ... SELECT</code></a> statement fails following the upgrade
                unless it is rewritten to remove any side effects on other
                tables.) This is not an issue when using row-based replication,
                because the statement is logged as a <a class="link" href="sql-syntax.html#create-table" title="13.1.18&nbsp;CREATE TABLE Syntax"><code class="literal">CREATE
                TABLE</code></a> statement with any changes to table data logged
                as row-insert events, rather than as the entire
                <a class="link" href="sql-syntax.html#create-table-select" title="13.1.18.5&nbsp;CREATE TABLE ... SELECT Syntax"><code class="literal">CREATE
                    TABLE ... SELECT</code></a>.
            </p><p style="color:blue;">mysql 5.7不允许创建表…select语句可对语句创建的表以外的表进行任何更改。一些旧版本的mysql允许这些语句这样做；这意味着，当在mysql 5.6或更高版本的从机和运行mysql以前版本的主机之间使用基于语句的复制时，创建表……导致主机上其他表更改的select语句在从机上失败，导致复制停止。为了防止这种情况发生，您应该使用基于行的复制，在主服务器上运行之前重写有问题的语句，或者将主服务器升级到mysql 5.7。（如果您选择升级master，请记住这样一个创建表…除非重写select语句以删除对其他表的任何副作用，否则在升级后该语句将失败。）使用基于行的复制时，这不是问题，因为该语句将作为create table语句记录，对表数据的任何更改将记录为行插入事件，而不是整个create table…选择。</p><p>
                These behaviors are not dependent on MySQL version:
            </p><p style="color:blue;">这些行为不依赖于mysql版本：</p>
                <div class="itemizedlist">
                    <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                        <a class="link" href="sql-syntax.html#create-table-select" title="13.1.18.5&nbsp;CREATE TABLE ... SELECT Syntax"><code class="literal">CREATE
                            TABLE ... SELECT</code></a> always performs an implicit
                        commit (<a class="xref" href="sql-syntax.html#implicit-commit" title="13.3.3&nbsp;Statements That Cause an Implicit Commit">Section&nbsp;13.3.3, “Statements That Cause an Implicit Commit”</a>).
                    </p><p style="color:blue;">创建表…select始终执行隐式提交（第13.3.3节，“导致隐式提交的语句”）。</p></li><li class="listitem"><p>
                        If destination table does not exist, logging occurs as
                        follows. It does not matter whether <code class="literal">IF NOT
                        EXISTS</code> is present.
                    </p><p style="color:blue;">如果目标表不存在，则日志记录如下所示。是否不存在并不重要。</p>
                        <div class="itemizedlist">
                            <ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
                                <code class="literal">STATEMENT</code> or <code class="literal">MIXED</code>
                                format: The statement is logged as written.
                            </p><p style="color:blue;">语句或混合格式：语句以书面形式记录。</p></li><li class="listitem"><p>
                                <code class="literal">ROW</code> format: The statement is logged
                                as a <a class="link" href="sql-syntax.html#create-table" title="13.1.18&nbsp;CREATE TABLE Syntax"><code class="literal">CREATE TABLE</code></a>
                                statement followed by a series of insert-row events.
                            </p><p style="color:blue;">行格式：该语句记录为CREATETABLE语句，后跟一系列插入行事件。</p></li></ul>
                        </div>
                    </li><li class="listitem"><p>
                        If the statement fails, nothing is logged. This includes the
                        case that the destination table exists and <code class="literal">IF NOT
                        EXISTS</code> is not given.
                    </p><p style="color:blue;">如果语句失败，则不记录任何内容。这包括目标表存在和不存在的情况。</p></li></ul>
                </div>
                <p>
                    When the destination table exists and <code class="literal">IF NOT
                    EXISTS</code> is given, MySQL 5.7 ignores the
                    statement completely; nothing is inserted or logged.
                </p><p style="color:blue;">当目标表存在且如果不存在时，MySQL 5.7完全忽略该语句；没有插入或记录任何内容。</p>
            </div>
            <div class="section">
                <div class="titlepage">
                    <div>
                        <div>
                            <h4 class="title"><a name="replication-features-create-alter-drop-server"></a>16.4.1.7&nbsp;Replication of CREATE SERVER, ALTER SERVER, and DROP SERVER</h4>

                        </div>

                    </div>

                </div>
                <p>
                    The statements <a class="link" href="sql-syntax.html#create-server" title="13.1.17&nbsp;CREATE SERVER Syntax"><code class="literal">CREATE SERVER</code></a>,
                    <a class="link" href="sql-syntax.html#alter-server" title="13.1.7&nbsp;ALTER SERVER Syntax"><code class="literal">ALTER SERVER</code></a>, and
                    <a class="link" href="sql-syntax.html#drop-server" title="13.1.28&nbsp;DROP SERVER Syntax"><code class="literal">DROP SERVER</code></a> are not written to
                    the binary log, regardless of the binary logging format that is
                    in use.
                </p><p style="color:blue;">无论使用何种二进制日志格式，CREATE SERVER、ALTER SERVER和DROP SERVER语句都不会写入二进制日志。</p>
            </div>
            <div class="section">
                <div class="titlepage">
                    <div>
                        <div>
                            <h4 class="title"><a name="replication-features-current-user"></a>16.4.1.8&nbsp;Replication of CURRENT_USER()</h4>

                        </div>

                    </div>

                </div>
                <p>
                    The following statements support use of the
                    <a class="link" href="functions.html#function_current-user"><code class="literal">CURRENT_USER()</code></a> function to take
                    the place of the name of, and possibly the host for, an affected
                    user or a definer:
                </p><p style="color:blue;">以下语句支持使用current_user（）函数代替受影响用户或定义者的名称，并可能代替其宿主：</p>
                <div class="itemizedlist">
                    <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                        <a class="link" href="sql-syntax.html#drop-user" title="13.7.1.3&nbsp;DROP USER Syntax"><code class="literal">DROP USER</code></a>
                    </p><p style="color:blue;">删除用户</p></li><li class="listitem"><p>
                        <a class="link" href="sql-syntax.html#rename-user" title="13.7.1.5&nbsp;RENAME USER Syntax"><code class="literal">RENAME USER</code></a>
                    </p><p style="color:blue;">重命名用户</p></li><li class="listitem"><p>
                        <a class="link" href="sql-syntax.html#grant" title="13.7.1.4&nbsp;GRANT Syntax"><code class="literal">GRANT</code></a>
                    </p><p style="color:blue;">授予</p></li><li class="listitem"><p>
                        <a class="link" href="sql-syntax.html#revoke" title="13.7.1.6&nbsp;REVOKE Syntax"><code class="literal">REVOKE</code></a>
                    </p><p style="color:blue;">撤销</p></li><li class="listitem"><p>
                        <a class="link" href="sql-syntax.html#create-function" title="13.1.13&nbsp;CREATE FUNCTION Syntax"><code class="literal">CREATE FUNCTION</code></a>
                    </p><p style="color:blue;">创建函数</p></li><li class="listitem"><p>
                        <a class="link" href="sql-syntax.html#create-procedure" title="13.1.16&nbsp;CREATE PROCEDURE and CREATE FUNCTION Syntax"><code class="literal">CREATE PROCEDURE</code></a>
                    </p><p style="color:blue;">创建过程</p></li><li class="listitem"><p>
                        <a class="link" href="sql-syntax.html#create-trigger" title="13.1.20&nbsp;CREATE TRIGGER Syntax"><code class="literal">CREATE TRIGGER</code></a>
                    </p><p style="color:blue;">创建触发器</p></li><li class="listitem"><p>
                        <a class="link" href="sql-syntax.html#create-event" title="13.1.12&nbsp;CREATE EVENT Syntax"><code class="literal">CREATE EVENT</code></a>
                    </p><p style="color:blue;">创建事件</p></li><li class="listitem"><p>
                        <a class="link" href="sql-syntax.html#create-view" title="13.1.21&nbsp;CREATE VIEW Syntax"><code class="literal">CREATE VIEW</code></a>
                    </p><p style="color:blue;">创建视图</p></li><li class="listitem"><p>
                        <a class="link" href="sql-syntax.html#alter-event" title="13.1.2&nbsp;ALTER EVENT Syntax"><code class="literal">ALTER EVENT</code></a>
                    </p><p style="color:blue;">更改事件</p></li><li class="listitem"><p>
                        <a class="link" href="sql-syntax.html#alter-view" title="13.1.10&nbsp;ALTER VIEW Syntax"><code class="literal">ALTER VIEW</code></a>
                    </p><p style="color:blue;">修改视图</p></li><li class="listitem"><p>
                        <a class="link" href="sql-syntax.html#set-password" title="13.7.1.7&nbsp;SET PASSWORD Syntax"><code class="literal">SET PASSWORD</code></a>
                    </p><p style="color:blue;">设置密码</p></li></ul>
                </div>
                <p>
                    When binary logging is enabled and
                    <a class="link" href="functions.html#function_current-user"><code class="literal">CURRENT_USER()</code></a> or
                    <a class="link" href="functions.html#function_current-user"><code class="literal">CURRENT_USER</code></a> is used as
                    the definer in any of these statements, MySQL Server ensures
                    that the statement is applied to the same user on both the
                    master and the slave when the statement is replicated. In some
                    cases, such as statements that change passwords, the function
                    reference is expanded before it is written to the binary log, so
                    that the statement includes the user name. For all other cases,
                    the name of the current user on the master is replicated to the
                    slave as metadata, and the slave applies the statement to the
                    current user named in the metadata, rather than to the current
                    user on the slave.
                </p><p style="color:blue;">当启用二进制日志记录并且在这些语句中使用current_user（）或current_user作为定义者时，mysql server确保在复制该语句时，该语句应用于主用户和从用户上的同一用户。在某些情况下，例如更改密码的语句，在将函数引用写入二进制日志之前将其展开，以便该语句包含用户名。对于所有其他情况，主节点上当前用户的名称将作为元数据复制到从节点，从节点将语句应用于元数据中命名的当前用户，而不是从节点上的当前用户。</p>
            </div>
            <div class="section">
                <div class="titlepage">
                    <div>
                        <div>
                            <h4 class="title"><a name="replication-features-drop-if-exists"></a>16.4.1.9&nbsp;Replication of DROP ... IF EXISTS Statements</h4>

                        </div>

                    </div>

                </div>
                <a class="indexterm" name="idm140286792287296"></a><a class="indexterm" name="idm140286792285808"></a><p>
                The <a class="link" href="sql-syntax.html#drop-database" title="13.1.22&nbsp;DROP DATABASE Syntax"><code class="literal">DROP DATABASE
                IF EXISTS</code></a>,
                <a class="link" href="sql-syntax.html#drop-table" title="13.1.29&nbsp;DROP TABLE Syntax"><code class="literal">DROP TABLE IF
                    EXISTS</code></a>, and
                <a class="link" href="sql-syntax.html#drop-view" title="13.1.32&nbsp;DROP VIEW Syntax"><code class="literal">DROP VIEW IF
                    EXISTS</code></a> statements are always replicated, even if the
                database, table, or view to be dropped does not exist on the
                master. This is to ensure that the object to be dropped no
                longer exists on either the master or the slave, once the slave
                has caught up with the master.
            </p><p style="color:blue;">如果存在主数据库中不存在的数据库、表或视图，则如果存在语句，则存在下拉数据库，如果存在，则丢弃表。这是为了确保被丢弃的对象不再存在于主或从上，一旦奴隶赶上了主。</p><p>
                <code class="literal">DROP ... IF EXISTS</code> statements for stored
                programs (stored procedures and functions, triggers, and events)
                are also replicated, even if the stored program to be dropped
                does not exist on the master.
            </p><p style="color:blue;">放下…如果存在存储程序（存储过程和函数、触发器和事件）的语句也被复制，即使要删除的存储程序也不存在于主控器上。</p>
            </div>
            <div class="section">
                <div class="titlepage">
                    <div>
                        <div>
                            <h4 class="title"><a name="replication-features-differing-tables"></a>16.4.1.10&nbsp;Replication with Differing Table Definitions on Master and Slave</h4>

                        </div>

                    </div>

                </div>
                <a class="indexterm" name="idm140286792277264"></a><p>
                Source and target tables for replication do not have to be
                identical. A table on the master can have more or fewer columns
                than the slave's copy of the table. In addition, corresponding
                table columns on the master and the slave can use different data
                types, subject to certain conditions.
            </p><p style="color:blue;">复制的源表和目标表不必相同。主表的列数可以多于或少于从表的副本。此外，主从机上对应的表列可以使用不同的数据类型，但要满足一定的条件。</p>
                <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">

                    <div class="admon-title">
                        Note
                    </div>
                    <p>
                        Replication between tables which are partitioned differently
                        from one another is not supported. See
                        <a class="xref" href="replication.html#replication-features-partitioning" title="16.4.1.23&nbsp;Replication and Partitioning">Section&nbsp;16.4.1.23, “Replication and Partitioning”</a>.
                    </p><p style="color:blue;">不支持在分区不同的表之间进行复制。见第16.4.1.23节“复制和分区”。</p>
                </div>
                <p>
                    In all cases where the source and target tables do not have
                    identical definitions, the database and table names must be the
                    same on both the master and the slave. Additional conditions are
                    discussed, with examples, in the following two sections.
                </p><p style="color:blue;">在源表和目标表没有相同定义的所有情况下，主表和从表上的数据库和表名必须相同。以下两节将讨论附加条件，并举例说明。</p>
                <div class="section">

                    <div class="titlepage">
                        <div>
                            <div>
                                <h5 class="title"><a name="replication-features-more-columns"></a>16.4.1.10.1&nbsp;Replication with More Columns on Master or Slave</h5>
                            </div>
                        </div>
                    </div>
                    <p>
                        You can replicate a table from the master to the slave such
                        that the master and slave copies of the table have differing
                        numbers of columns, subject to the following conditions:
                    </p><p style="color:blue;">可以将表从主副本复制到从副本，以便表的主副本和从副本具有不同的列数，但必须满足以下条件：</p>
                    <div class="itemizedlist">
                        <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                            Columns common to both versions of the table must be
                            defined in the same order on the master and the slave.
                        </p><p style="color:blue;">必须在主表和从表上以相同的顺序定义表的两个版本共有的列。</p><p>
                            (This is true even if both tables have the same number of
                            columns.)
                        </p><p style="color:blue;">（即使两个表的列数相同，也是如此。）</p></li><li class="listitem"><p>
                            Columns common to both versions of the table must be
                            defined before any additional columns.
                        </p><p style="color:blue;">必须在任何其他列之前定义表的两个版本共有的列。</p><p>
                            This means that executing an <a class="link" href="sql-syntax.html#alter-table" title="13.1.8&nbsp;ALTER TABLE Syntax"><code class="literal">ALTER
                            TABLE</code></a> statement on the slave where a new column
                            is inserted into the table within the range of columns
                            common to both tables causes replication to fail, as shown
                            in the following example:
                        </p><p style="color:blue;">这意味着，在从机上执行alter table语句，在两个表共用的列范围内将新列插入表中，将导致复制失败，如下例所示：</p><p>
                            Suppose that a table <code class="literal">t</code>, existing on the
                            master and the slave, is defined by the following
                            <a class="link" href="sql-syntax.html#create-table" title="13.1.18&nbsp;CREATE TABLE Syntax"><code class="literal">CREATE TABLE</code></a> statement:
                        </p><p style="color:blue;">假设存在于主和从表上的表T由下面的CREATETABLE语句定义：</p><pre data-lang="sql" class="programlisting">CREATE TABLE t (
    c1 INT,
    c2 INT,
    c3 INT
);
</pre><p>
                            Suppose that the <a class="link" href="sql-syntax.html#alter-table" title="13.1.8&nbsp;ALTER TABLE Syntax"><code class="literal">ALTER
                            TABLE</code></a> statement shown here is executed on the
                            slave:
                        </p><p style="color:blue;">假设此处所示的alter table语句是在从机上执行的：</p><pre data-lang="sql" class="programlisting">ALTER TABLE t ADD COLUMN cnew1 INT AFTER c3;
</pre><p>
                            The previous <a class="link" href="sql-syntax.html#alter-table" title="13.1.8&nbsp;ALTER TABLE Syntax"><code class="literal">ALTER TABLE</code></a> is
                            permitted on the slave because the columns
                            <code class="literal">c1</code>, <code class="literal">c2</code>, and
                            <code class="literal">c3</code> that are common to both versions of
                            table <code class="literal">t</code> remain grouped together in both
                            versions of the table, before any columns that differ.
                        </p><p style="color:blue;">上一个alter表在从机上是允许的，因为表t的两个版本共用的列c1、c2和c3在表的两个版本中都保持在一起，在任何不同的列之前。</p><p>
                            However, the following <a class="link" href="sql-syntax.html#alter-table" title="13.1.8&nbsp;ALTER TABLE Syntax"><code class="literal">ALTER
                            TABLE</code></a> statement cannot be executed on the slave
                            without causing replication to break:
                        </p><p style="color:blue;">但是，在不导致复制中断的情况下，无法在从机上执行以下alter table语句：</p><pre data-lang="sql" class="programlisting">ALTER TABLE t ADD COLUMN cnew2 INT AFTER c2;
</pre><p>
                            Replication fails after execution on the slave of the
                            <a class="link" href="sql-syntax.html#alter-table" title="13.1.8&nbsp;ALTER TABLE Syntax"><code class="literal">ALTER TABLE</code></a> statement just
                            shown, because the new column <code class="literal">cnew2</code>
                            comes between columns common to both versions of
                            <code class="literal">t</code>.
                        </p><p style="color:blue;">在刚刚显示的alter table语句的从机上执行后，复制失败，因为新列cnew2位于两个版本的t的公共列之间。</p></li><li class="listitem"><p>
                            Each <span class="quote">“<span class="quote">extra</span>”</span> column in the version of the
                            table having more columns must have a default value.
                        </p><p style="color:blue;">表版本中每一个“额外”列包含更多列必须有一个默认值。</p><p>
                            A column's default value is determined by a number of
                            factors, including its type, whether it is defined with a
                            <code class="literal">DEFAULT</code> option, whether it is declared
                            as <code class="literal">NULL</code>, and the server SQL mode in
                            effect at the time of its creation; for more information,
                            see <a class="xref" href="data-types.html#data-type-defaults" title="11.7&nbsp;Data Type Default Values">Section&nbsp;11.7, “Data Type Default Values”</a>).
                        </p><p style="color:blue;">列的默认值由许多因素决定，包括其类型、是否使用默认选项定义、是否声明为空以及创建时有效的服务器SQL模式；有关详细信息，请参阅第11.7节“数据类型默认值”）。</p></li></ul>
                    </div>
                    <p>
                        In addition, when the slave's copy of the table has more
                        columns than the master's copy, each column common to the
                        tables must use the same data type in both tables.
                    </p><p style="color:blue;">此外，当表的从属副本的列数多于主副本的列数时，表的公共列必须在两个表中使用相同的数据类型。</p><p><b>Examples.&nbsp;</b>
                    The following examples illustrate some valid and invalid
                    table definitions:
                </p><p style="color:blue;">例子。以下示例说明了一些有效和无效的表定义：</p><p><b>More columns on the master.&nbsp;</b>
                    The following table definitions are valid and replicate
                    correctly:
                </p><p style="color:blue;">母版上有更多列。下表定义有效且复制正确：</p><pre data-lang="sql" class="programlisting">master&gt; <strong class="userinput"><code>CREATE TABLE t1 (c1 INT, c2 INT, c3 INT);</code></strong>
slave&gt;  <strong class="userinput"><code>CREATE TABLE t1 (c1 INT, c2 INT);</code></strong>
</pre><p>
                    The following table definitions would raise an error because
                    the definitions of the columns common to both versions of the
                    table are in a different order on the slave than they are on
                    the master:
                </p><p style="color:blue;">以下表定义将引发错误，因为表的两个版本共用的列的定义在从属服务器上的顺序与在主服务器上的顺序不同：</p><pre data-lang="sql" class="programlisting">master&gt; <strong class="userinput"><code>CREATE TABLE t1 (c1 INT, c2 INT, c3 INT);</code></strong>
slave&gt;  <strong class="userinput"><code>CREATE TABLE t1 (c2 INT, c1 INT);</code></strong>
</pre><p>
                    The following table definitions would also raise an error
                    because the definition of the extra column on the master
                    appears before the definitions of the columns common to both
                    versions of the table:
                </p><p style="color:blue;">以下表定义也会引发错误，因为主控形状上额外列的定义出现在表的两个版本通用列的定义之前：</p><pre data-lang="sql" class="programlisting">master&gt; <strong class="userinput"><code>CREATE TABLE t1 (c3 INT, c1 INT, c2 INT);</code></strong>
slave&gt;  <strong class="userinput"><code>CREATE TABLE t1 (c1 INT, c2 INT);</code></strong>
</pre><p><b>More columns on the slave.&nbsp;</b>
                    The following table definitions are valid and replicate
                    correctly:
                </p><p style="color:blue;">更多关于奴隶的专栏。下表定义有效且复制正确：</p><pre data-lang="sql" class="programlisting">master&gt; <strong class="userinput"><code>CREATE TABLE t1 (c1 INT, c2 INT);</code></strong>
slave&gt;  <strong class="userinput"><code>CREATE TABLE t1 (c1 INT, c2 INT, c3 INT);</code></strong>
                  </pre><p>
                    The following definitions raise an error because the columns
                    common to both versions of the table are not defined in the
                    same order on both the master and the slave:
                </p><p style="color:blue;">以下定义引发错误，因为主表和从表的两个版本共用的列的定义顺序不同：</p><pre data-lang="sql" class="programlisting">master&gt; <strong class="userinput"><code>CREATE TABLE t1 (c1 INT, c2 INT);</code></strong>
slave&gt;  <strong class="userinput"><code>CREATE TABLE t1 (c2 INT, c1 INT, c3 INT);</code></strong>
</pre><p>
                    The following table definitions also raise an error because
                    the definition for the extra column in the slave's version of
                    the table appears before the definitions for the columns which
                    are common to both versions of the table:
                </p><p style="color:blue;">以下表定义也会引发错误，因为从属版本表中额外列的定义出现在两个版本表通用的列的定义之前：</p><pre data-lang="sql" class="programlisting">master&gt; <strong class="userinput"><code>CREATE TABLE t1 (c1 INT, c2 INT);</code></strong>
slave&gt;  <strong class="userinput"><code>CREATE TABLE t1 (c3 INT, c1 INT, c2 INT);</code></strong>
</pre><p>
                    The following table definitions fail because the slave's
                    version of the table has additional columns compared to the
                    master's version, and the two versions of the table use
                    different data types for the common column
                    <code class="literal">c2</code>:
                </p><p style="color:blue;">以下表定义失败，因为与主版本相比，从版本的表有其他列，并且两个版本的表对公共列C2使用不同的数据类型：</p><pre data-lang="sql" class="programlisting">master&gt; <strong class="userinput"><code>CREATE TABLE t1 (c1 INT, c2 BIGINT);</code></strong>
slave&gt;  <strong class="userinput"><code>CREATE TABLE t1 (c1 INT, c2 INT, c3 INT);</code></strong>
</pre>
                </div>
                <div class="section">
                    <div class="titlepage">
                        <div>
                            <div>
                                <h5 class="title"><a name="replication-features-different-data-types"></a>16.4.1.10.2&nbsp;Replication of Columns Having Different Data Types</h5>

                            </div>

                        </div>

                    </div>
                    <a class="indexterm" name="idm140286792218704"></a><a class="indexterm" name="idm140286792217216"></a><a class="indexterm" name="idm140286792215728"></a><a class="indexterm" name="idm140286792214240"></a><p>
                    Corresponding columns on the master's and the
                    slave's copies of the same table ideally should have the
                    same data type. However, this is not always strictly enforced,
                    as long as certain conditions are met.
                </p><p style="color:blue;">理想情况下，同一表的主副本和从副本上的相应列应该具有相同的数据类型。但是，只要满足某些条件，这并不总是严格执行的。</p><p>
                    It is usually possible to replicate from a column of a given
                    data type to another column of the same type and same size or
                    width, where applicable, or larger. For example, you can
                    replicate from a <code class="literal">CHAR(10)</code> column to another
                    <code class="literal">CHAR(10)</code>, or from a
                    <code class="literal">CHAR(10)</code> column to a
                    <code class="literal">CHAR(25)</code> column without any problems. In
                    certain cases, it also possible to replicate from a column
                    having one data type (on the master) to a column having a
                    different data type (on the slave); when the data type of the
                    master's version of the column is promoted to a type that
                    is the same size or larger on the slave, this is known as
                    <span class="firstterm">attribute promotion</span>.
                </p><p style="color:blue;">通常可以从给定数据类型的列复制到相同类型、相同大小或宽度（如果适用）或更大的列。例如，您可以从char（10）列复制到另一个char（10）列，或者从char（10）列复制到char（25）列，而不会出现任何问题。在某些情况下，还可以从具有一个数据类型（在主数据类型上）的列复制到具有不同数据类型（在从数据类型上）的列；当主数据版本的列的数据类型升级到具有相同大小或更大的从数据类型时，这称为属性升级。</p><p>
                    Attribute promotion can be used with both statement-based and
                    row-based replication, and is not dependent on the storage
                    engine used by either the master or the slave. However, the
                    choice of logging format does have an effect on the type
                    conversions that are permitted; the particulars are discussed
                    later in this section.
                </p><p style="color:blue;">属性提升既可以用于基于语句的复制，也可以用于基于行的复制，并且不依赖于主复制或从复制使用的存储引擎。但是，日志格式的选择确实会影响允许的类型转换；本节稍后将讨论详细信息。</p>
                    <div class="important" style="margin-left: 0.5in; margin-right: 0.5in;">

                        <div class="admon-title">
                            Important
                        </div>
                        <p>
                            Whether you use statement-based or row-based replication,
                            the slave's copy of the table cannot contain more
                            columns than the master's copy if you wish to employ
                            attribute promotion.
                        </p><p style="color:blue;">无论使用基于语句的复制还是基于行的复制，如果希望采用属性提升，则表的从属副本不能包含比主副本更多的列。</p>
                    </div>
                    <p><b>Statement-based replication.&nbsp;</b>
                        When using statement-based replication, a simple rule of
                        thumb to follow is, <span class="quote">“<span class="quote">If the statement run on the
            master would also execute successfully on the slave, it
            should also replicate successfully</span>”</span>. In other words,
                        if the statement uses a value that is compatible with the
                        type of a given column on the slave, the statement can be
                        replicated. For example, you can insert any value that fits
                        in a <code class="literal">TINYINT</code> column into a
                        <code class="literal">BIGINT</code> column as well; it follows that,
                        even if you change the type of a <code class="literal">TINYINT</code>
                        column in the slave's copy of a table to
                        <code class="literal">BIGINT</code>, any insert into that column on
                        the master that succeeds should also succeed on the slave,
                        since it is impossible to have a legal
                        <code class="literal">TINYINT</code> value that is large enough to
                        exceed a <code class="literal">BIGINT</code> column.
                    </p><p style="color:blue;">基于语句的复制。当使用基于语句的复制时，一个简单的经验法则是，“如果在主服务器上运行的语句也能在从服务器上成功执行，那么它也应该成功复制”。换句话说，如果语句使用的值与从机上给定列的类型兼容，则可以复制该语句。例如，您也可以将tinyint列中适合的任何值插入bigint列中；因此，即使您将表的从属副本中tinyint列的类型更改为bigint，在主表中成功插入该列的任何操作也应在从属表中成功，因为合法的tinyint值不可能超过bigint列。</p><p>
                    Prior to MySQL 5.7.1, when using statement-based replication,
                    <code class="literal">AUTO_INCREMENT</code> columns were required to be
                    the same on both the master and the slave; otherwise, updates
                    could be applied to the wrong table on the slave. (Bug
                    #12669186)
                </p><p style="color:blue;">在mysql 5.7.1之前，当使用基于语句的复制时，主表和从表上的auto_increment列必须相同；否则，可能会对从表上的错误表应用更新。（错误12669186）</p><p><a name="replication-features-attribute-promotion"></a><b>Row-based replication: attribute promotion and demotion.&nbsp;</b>
                    Row-based replication supports attribute promotion and
                    demotion between smaller data types and larger types. It is
                    also possible to specify whether or not to permit lossy
                    (truncated) or non-lossy conversions of demoted column
                    values, as explained later in this section.
                </p><p style="color:blue;">基于行的复制：属性提升和降级。基于行的复制支持较小数据类型和较大类型之间的属性提升和降级。还可以指定是否允许降级列值的有损（截断）或无损转换，如本节后面所述。</p><p><b>Lossy and non-lossy conversions.&nbsp;</b>
                    In the event that the target type cannot represent the value
                    being inserted, a decision must be made on how to handle the
                    conversion. If we permit the conversion but truncate (or
                    otherwise modify) the source value to achieve a
                    <span class="quote">“<span class="quote">fit</span>”</span> in the target column, we make what is
                    known as a <span class="firstterm">lossy
            conversion</span>. A conversion which does not require
                    truncation or similar modifications to fit the source column
                    value in the target column is a
                    <span class="firstterm">non-lossy</span> conversion.
                </p><p style="color:blue;">有损和无损转换。如果目标类型不能表示要插入的值，则必须决定如何处理转换。如果我们允许转换，但截断（或以其他方式修改）源值以在目标列中实现“匹配”，我们将进行所谓的有损转换。不需要截断或类似修改以使源列值适合目标列的转换是非有损转换。</p><p><b>Type conversion modes (slave_type_conversions variable).&nbsp;</b>
                    The setting of the <code class="literal">slave_type_conversions</code>
                    global server variable controls the type conversion mode
                    used on the slave. This variable takes a set of values from
                    the following table, which shows the effects of each mode on
                    the slave's type-conversion behavior:
                </p><p style="color:blue;">类型转换模式（slave_type_conversions变量）。slave_type_conversions全局服务器变量的设置控制从机上使用的类型转换模式。此变量从下表中获取一组值，显示每个模式对从属类型转换行为的影响：</p>
                    <div class="informaltable">
                        <table summary="Type conversion modes for the slave_type_conversions global server variable and the effects of each mode on the slave's type-conversion behavior."><colgroup><col width="35%"><col width="65%"></colgroup><thead><tr>
                            <th scope="col">Mode</th>
                            <th scope="col">Effect</th>
                        </tr></thead><tbody><tr>
                            <td scope="row"><code class="literal">ALL_LOSSY</code></td>
                            <td><p>
                                In this mode, type conversions that would mean loss of
                                information are permitted.
                            </p><p style="color:blue;">在这种模式下，允许进行意味着信息丢失的类型转换。</p><p>
                                This does not imply that non-lossy conversions are
                                permitted, merely that only cases requiring either
                                lossy conversions or no conversion at all are
                                permitted; for example, enabling
                                <span class="emphasis"><em>only</em></span> this mode permits an
                                <code class="literal">INT</code> column to be converted to
                                <code class="literal">TINYINT</code> (a lossy conversion), but
                                not a <code class="literal">TINYINT</code> column to an
                                <code class="literal">INT</code> column (non-lossy). Attempting
                                the latter conversion in this case would cause
                                replication to stop with an error on the slave.
                            </p><p style="color:blue;">这并不意味着允许非有损转换，而仅仅是只允许需要有损转换或根本不允许转换的情况；例如，仅启用此模式允许将int列转换为tinyint（有损转换），而不允许将tinyint列转换为int列（无损）。在这种情况下尝试后一种转换将导致复制停止，并在从机上出现错误。</p></td>
                        </tr><tr>
                            <td scope="row"><code class="literal">ALL_NON_LOSSY</code></td>
                            <td><p>
                                This mode permits conversions that do not require
                                truncation or other special handling of the source
                                value; that is, it permits conversions where the
                                target type has a wider range than the source type.
                            </p><p style="color:blue;">此模式允许不需要截断或对源值进行其他特殊处理的转换；也就是说，它允许目标类型的范围比源类型的范围宽的转换。</p><p>
                                Setting this mode has no bearing on whether lossy
                                conversions are permitted; this is controlled with the
                                <code class="literal">ALL_LOSSY</code> mode. If only
                                <code class="literal">ALL_NON_LOSSY</code> is set, but not
                                <code class="literal">ALL_LOSSY</code>, then attempting a
                                conversion that would result in the loss of data (such
                                as <code class="literal">INT</code> to
                                <code class="literal">TINYINT</code>, or
                                <code class="literal">CHAR(25)</code> to
                                <code class="literal">VARCHAR(20)</code>) causes the slave to
                                stop with an error.
                            </p><p style="color:blue;">设置此模式与是否允许有损转换没有关系；这是由全有损模式控制的。如果只设置了all-non-lossy，而不是all-lossy，则尝试导致数据丢失的转换（例如int到tinyint，或char（25）到varchar（20））将导致从机停止并出现错误。</p></td>
                        </tr><tr>
                            <td scope="row"><code class="literal">ALL_LOSSY,ALL_NON_LOSSY</code></td>
                            <td><p>
                                When this mode is set, all supported type conversions
                                are permitted, whether or not they are lossy
                                conversions.
                            </p><p style="color:blue;">设置此模式时，允许所有受支持的类型转换，无论它们是否是有损转换。</p></td>
                        </tr><tr>
                            <td scope="row"><code class="literal">ALL_SIGNED</code></td>
                            <td><p>
                                Treat promoted integer types as signed values (the
                                default behavior).
                            </p><p style="color:blue;">将提升的整数类型视为有符号值（默认行为）。</p></td>
                        </tr><tr>
                            <td scope="row"><code class="literal">ALL_UNSIGNED</code></td>
                            <td><p>
                                Treat promoted integer types as unsigned values.
                            </p><p style="color:blue;">将提升的整数类型视为无符号值。</p></td>
                        </tr><tr>
                            <td scope="row"><code class="literal">ALL_SIGNED,ALL_UNSIGNED</code></td>
                            <td><p>
                                Treat promoted integer types as signed if possible,
                                otherwise as unsigned.
                            </p><p style="color:blue;">如果可能，将提升整数类型视为有符号，否则视为无符号。</p></td>
                        </tr><tr>
                            <td scope="row">[<span class="emphasis"><em>empty</em></span>]</td>
                            <td><p>
                                When <code class="literal">slave_type_conversions</code> is not
                                set, no attribute promotion or demotion is permitted;
                                this means that all columns in the source and target
                                tables must be of the same types.
                            </p><p style="color:blue;">如果未设置slave_type_转换，则不允许提升或降级属性；这意味着源表和目标表中的所有列必须属于相同的类型。</p><p>
                                This mode is the default.
                            </p><p style="color:blue;">此模式是默认模式。</p></td>
                        </tr></tbody></table>
                    </div>
                    <p>
                        When an integer type is promoted, its signedness is not
                        preserved. By default, the slave treats all such values as
                        signed. Beginning with MySQL 5.7.2, you can control this
                        behavior using <code class="literal">ALL_SIGNED</code>,
                        <code class="literal">ALL_UNSIGNED</code>, or both. (Bug#15831300)
                        <code class="literal">ALL_SIGNED</code> tells the slave to treat all
                        promoted integer types as signed;
                        <code class="literal">ALL_UNSIGNED</code> instructs it to treat these as
                        unsigned. Specifying both causes the slave to treat the value
                        as signed if possible, otherwise to treat it as unsigned; the
                        order in which they are listed is not significant. Neither
                        <code class="literal">ALL_SIGNED</code> nor
                        <code class="literal">ALL_UNSIGNED</code> has any effect if at least one
                        of <code class="literal">ALL_LOSSY</code> or
                        <code class="literal">ALL_NONLOSSY</code> is not also used.
                    </p><p style="color:blue;">提升整数类型时，不保留其有符号性。默认情况下，从机将所有这些值视为有符号的。从mysql 5.7.2开始，您可以使用all-signed、all-unsigned或两者来控制此行为。（bug 15831300）all_signed告诉从机将所有提升的整数类型视为有符号；all_unsigned指示它将这些类型视为无符号。如果可能的话，指定这两个值会导致从机将该值视为有符号，否则将其视为无符号；它们的列出顺序并不重要。如果所有有损或所有无损中的至少一个没有被使用，则所有无符号或所有无符号都没有任何效果。</p><p>
                    Changing the type conversion mode requires restarting the
                    slave with the new <code class="literal">slave_type_conversions</code>
                    setting.
                </p><p style="color:blue;">更改类型转换模式需要使用新的从机类型转换设置重新启动从机。</p><p><b>Supported conversions.&nbsp;</b>
                    Supported conversions between different but similar data
                    types are shown in the following list:
                </p><p style="color:blue;">支持的转换。不同但相似的数据类型之间支持的转换显示在以下列表中：</p>
                    <div class="itemizedlist">
                        <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                            Between any of the integer types
                            <a class="link" href="data-types.html#integer-types" title="11.2.1&nbsp;Integer Types (Exact Value) - INTEGER, INT, SMALLINT, TINYINT, MEDIUMINT, BIGINT"><code class="literal">TINYINT</code></a>,
                            <a class="link" href="data-types.html#integer-types" title="11.2.1&nbsp;Integer Types (Exact Value) - INTEGER, INT, SMALLINT, TINYINT, MEDIUMINT, BIGINT"><code class="literal">SMALLINT</code></a>,
                            <a class="link" href="data-types.html#integer-types" title="11.2.1&nbsp;Integer Types (Exact Value) - INTEGER, INT, SMALLINT, TINYINT, MEDIUMINT, BIGINT"><code class="literal">MEDIUMINT</code></a>,
                            <a class="link" href="data-types.html#integer-types" title="11.2.1&nbsp;Integer Types (Exact Value) - INTEGER, INT, SMALLINT, TINYINT, MEDIUMINT, BIGINT"><code class="literal">INT</code></a>, and
                            <a class="link" href="data-types.html#integer-types" title="11.2.1&nbsp;Integer Types (Exact Value) - INTEGER, INT, SMALLINT, TINYINT, MEDIUMINT, BIGINT"><code class="literal">BIGINT</code></a>.
                        </p><p style="color:blue;">在任何整数类型tinyint、smallint、mediumint、int和bigint之间。</p><p>
                            This includes conversions between the signed and unsigned
                            versions of these types.
                        </p><p style="color:blue;">这包括这些类型的有符号和无符号版本之间的转换。</p><p>
                            Lossy conversions are made by truncating the source value
                            to the maximum (or minimum) permitted by the target
                            column. For ensuring non-lossy conversions when going from
                            unsigned to signed types, the target column must be large
                            enough to accommodate the range of values in the source
                            column. For example, you can demote <code class="literal">TINYINT
                            UNSIGNED</code> non-lossily to
                            <code class="literal">SMALLINT</code>, but not to
                            <code class="literal">TINYINT</code>.
                        </p><p style="color:blue;">通过将源值截断为目标列所允许的最大值（或最小值）来进行有损转换。为了确保从无符号类型转换为有符号类型时的无损耗转换，目标列必须足够大，以容纳源列中的值范围。例如，可以非有损地将tinyint unsigned降级为smallint，但不能降级为tinyint。</p></li><li class="listitem"><p>
                            Between any of the decimal types
                            <a class="link" href="data-types.html#fixed-point-types" title="11.2.2&nbsp;Fixed-Point Types (Exact Value) - DECIMAL, NUMERIC"><code class="literal">DECIMAL</code></a>,
                            <a class="link" href="data-types.html#floating-point-types" title="11.2.3&nbsp;Floating-Point Types (Approximate Value) - FLOAT, DOUBLE"><code class="literal">FLOAT</code></a>,
                            <a class="link" href="data-types.html#floating-point-types" title="11.2.3&nbsp;Floating-Point Types (Approximate Value) - FLOAT, DOUBLE"><code class="literal">DOUBLE</code></a>, and
                            <a class="link" href="data-types.html#fixed-point-types" title="11.2.2&nbsp;Fixed-Point Types (Exact Value) - DECIMAL, NUMERIC"><code class="literal">NUMERIC</code></a>.
                        </p><p style="color:blue;">在十进制类型decimal、float、double和numeric之间。</p><p>
                            <code class="literal">FLOAT</code> to <code class="literal">DOUBLE</code> is a
                            non-lossy conversion; <code class="literal">DOUBLE</code> to
                            <code class="literal">FLOAT</code> can only be handled lossily. A
                            conversion from
                            <code class="literal">DECIMAL(<em class="replaceable"><code>M</code></em>,<em class="replaceable"><code>D</code></em>)</code>
                            to
                            <code class="literal">DECIMAL(<em class="replaceable"><code>M'</code></em>,<em class="replaceable"><code>D'</code></em>)</code>
                            where <code class="literal"><em class="replaceable"><code>D'</code></em> &gt;=
                            <em class="replaceable"><code>D</code></em></code> and
                            <code class="literal">(<em class="replaceable"><code>M'</code></em>-<em class="replaceable"><code>D'</code></em>)
                                &gt;=
                                (<em class="replaceable"><code>M</code></em>-<em class="replaceable"><code>D</code></em></code>)
                            is non-lossy; for any case where
                            <code class="literal"><em class="replaceable"><code>M'</code></em> &lt;
                                <em class="replaceable"><code>M</code></em></code>,
                            <code class="literal"><em class="replaceable"><code>D'</code></em> &lt;
                                <em class="replaceable"><code>D</code></em></code>, or both, only a
                            lossy conversion can be made.
                        </p><p style="color:blue;">float-to-double是无损耗转换；double-to-float只能有损耗地处理。从decimal（m，d）到decimal（m'，d'）的转换，其中d'&gt;=d和（m'-d'）&gt;=（m-d）是非有损的；对于m'<m，d'<d或两者都是的任何情况，只能进行有损转换。<p></m，d'<d或两者都是的任何情况，只能进行有损转换。<p></p><p>
                            For any of the decimal types, if a value to be stored
                            cannot be fit in the target type, the value is rounded
                            down according to the rounding rules defined for the
                            server elsewhere in the documentation. See
                            <a class="xref" href="functions.html#precision-math-rounding" title="12.22.4&nbsp;Rounding Behavior">Section&nbsp;12.22.4, “Rounding Behavior”</a>, for information
                            about how this is done for decimal types.
                        </p><p style="color:blue;">对于任何十进制类型，如果要存储的值不适合目标类型，则该值将根据文档中其他地方为服务器定义的舍入规则向下舍入。请参阅第12.22.4节“舍入行为”，了解如何对十进制类型执行此操作。</p></li><li class="listitem"><p>
                            Between any of the string types
                            <a class="link" href="data-types.html#char" title="11.4.1&nbsp;The CHAR and VARCHAR Types"><code class="literal">CHAR</code></a>,
                            <a class="link" href="data-types.html#char" title="11.4.1&nbsp;The CHAR and VARCHAR Types"><code class="literal">VARCHAR</code></a>, and
                            <a class="link" href="data-types.html#blob" title="11.4.3&nbsp;The BLOB and TEXT Types"><code class="literal">TEXT</code></a>, including conversions
                            between different widths.
                        </p><p style="color:blue;">在任何字符串类型char、varchar和text之间，包括不同宽度之间的转换。</p><p>
                            Conversion of a <code class="literal">CHAR</code>,
                            <code class="literal">VARCHAR</code>, or <code class="literal">TEXT</code> to
                            a <code class="literal">CHAR</code>, <code class="literal">VARCHAR</code>, or
                            <code class="literal">TEXT</code> column the same size or larger is
                            never lossy. Lossy conversion is handled by inserting only
                            the first <em class="replaceable"><code>N</code></em> characters of the
                            string on the slave, where <em class="replaceable"><code>N</code></em> is
                            the width of the target column.
                        </p><p style="color:blue;">将char、varchar或text转换为相同大小或更大的char、varchar或text列永远不会有损失。有损转换是通过在从列上只插入字符串的前n个字符来处理的，其中n是目标列的宽度。</p>
                            <div class="important" style="margin-left: 0.5in; margin-right: 0.5in;">

                                <div class="admon-title">
                                    Important
                                </div>
                                <p>
                                    Replication between columns using different character
                                    sets is not supported.
                                </p><p style="color:blue;">不支持使用不同字符集的列之间的复制。</p>
                            </div>
                        </li><li class="listitem"><p>
                            Between any of the binary data types
                            <a class="link" href="data-types.html#binary-varbinary" title="11.4.2&nbsp;The BINARY and VARBINARY Types"><code class="literal">BINARY</code></a>,
                            <a class="link" href="data-types.html#binary-varbinary" title="11.4.2&nbsp;The BINARY and VARBINARY Types"><code class="literal">VARBINARY</code></a>, and
                            <a class="link" href="data-types.html#blob" title="11.4.3&nbsp;The BLOB and TEXT Types"><code class="literal">BLOB</code></a>, including conversions
                            between different widths.
                        </p><p style="color:blue;">在任何二进制数据类型binary、varbinary和blob之间，包括不同宽度之间的转换。</p><p>
                            Conversion of a <code class="literal">BINARY</code>,
                            <code class="literal">VARBINARY</code>, or <code class="literal">BLOB</code>
                            to a <code class="literal">BINARY</code>,
                            <code class="literal">VARBINARY</code>, or <code class="literal">BLOB</code>
                            column the same size or larger is never lossy. Lossy
                            conversion is handled by inserting only the first
                            <em class="replaceable"><code>N</code></em> bytes of the string on the
                            slave, where <em class="replaceable"><code>N</code></em> is the width of
                            the target column.
                        </p><p style="color:blue;">将binary、varbinary或blob转换为大小相同或更大的binary、varbinary或blob列永远不会有损失。有损转换的处理方法是只在从机上插入字符串的前n个字节，其中n是目标列的宽度。</p></li><li class="listitem"><p>
                            Between any 2 <a class="link" href="data-types.html#bit-type" title="11.2.4&nbsp;Bit-Value Type - BIT"><code class="literal">BIT</code></a> columns
                            of any 2 sizes.
                        </p><p style="color:blue;">在任意2个大小的任意2位列之间。</p><p>
                            When inserting a value from a
                            <code class="literal">BIT(<em class="replaceable"><code>M</code></em>)</code>
                            column into a
                            <code class="literal">BIT(<em class="replaceable"><code>M'</code></em>)</code>
                            column, where <code class="literal"><em class="replaceable"><code>M'</code></em> &gt;
                            <em class="replaceable"><code>M</code></em></code>, the most
                            significant bits of the
                            <code class="literal">BIT(<em class="replaceable"><code>M'</code></em>)</code>
                            columns are cleared (set to zero) and the
                            <em class="replaceable"><code>M</code></em> bits of the
                            <code class="literal">BIT(<em class="replaceable"><code>M</code></em>)</code> value
                            are set as the least significant bits of the
                            <code class="literal">BIT(<em class="replaceable"><code>M'</code></em>)</code>
                            column.
                        </p><p style="color:blue;">将位（m）列中的值插入位（m'）列时，其中m'&gt;m，位（m'）列的最高有效位被清除（设置为零），位（m）值的m位被设置为位（m'）列的最低有效位。</p><p>
                            When inserting a value from a source
                            <code class="literal">BIT(<em class="replaceable"><code>M</code></em>)</code>
                            column into a target
                            <code class="literal">BIT(<em class="replaceable"><code>M'</code></em>)</code>
                            column, where <code class="literal"><em class="replaceable"><code>M'</code></em> &lt;
                            <em class="replaceable"><code>M</code></em></code>, the maximum
                            possible value for the
                            <code class="literal">BIT(<em class="replaceable"><code>M'</code></em>)</code>
                            column is assigned; in other words, an
                            <span class="quote">“<span class="quote">all-set</span>”</span> value is assigned to the target
                            column.
                        </p><p style="color:blue;">当从源位（m）列插入一个值到目标位（m’）列时，m′m，分配给位（m’）列的最大可能值；换句话说，一个“全组”值被分配给目标列。</p></li></ul>
                    </div>
                    <p>
                        Conversions between types not in the previous list are not
                        permitted.
                    </p><p style="color:blue;">不允许在前一列表中未列出的类型之间进行转换。</p>
                </div>

            </div>
            <div class="section">
                <div class="titlepage">
                    <div>
                        <div>
                            <h4 class="title"><a name="replication-features-directory"></a>16.4.1.11&nbsp;Replication and DIRECTORY Table Options</h4>

                        </div>

                    </div>

                </div>
                <a class="indexterm" name="idm140286792072368"></a><a class="indexterm" name="idm140286792070880"></a><a class="indexterm" name="idm140286792069392"></a><a class="indexterm" name="idm140286792067904"></a><a class="indexterm" name="idm140286792066416"></a><p>
                If a <code class="literal">DATA DIRECTORY</code> or <code class="literal">INDEX
                DIRECTORY</code> table option is used in a
                <a class="link" href="sql-syntax.html#create-table" title="13.1.18&nbsp;CREATE TABLE Syntax"><code class="literal">CREATE TABLE</code></a> statement on the
                master server, the table option is also used on the slave. This
                can cause problems if no corresponding directory exists in the
                slave host file system or if it exists but is not accessible to
                the slave server. This can be overridden by using the
                <a class="link" href="server-administration.html#sqlmode_no_dir_in_create"><code class="literal">NO_DIR_IN_CREATE</code></a> server SQL
                mode on the slave, which causes the slave to ignore the
                <code class="literal">DATA DIRECTORY</code> and <code class="literal">INDEX
                DIRECTORY</code> table options when replicating
                <a class="link" href="sql-syntax.html#create-table" title="13.1.18&nbsp;CREATE TABLE Syntax"><code class="literal">CREATE TABLE</code></a> statements. The
                result is that <code class="literal">MyISAM</code> data and index files
                are created in the table's database directory.
            </p><p style="color:blue;">如果在主服务器上的CREATETABLE语句中使用数据目录或索引目录表选项，则在从服务器上也使用TABLE选项。如果在从属主机文件系统中不存在相应的目录，或者如果存在，但不能从从属服务器访问，则可能导致问题。这可以通过在从属服务器上使用CREATE SERVER SQL模式中的no_dir_来覆盖，这将导致在复制CREATE TABLE语句时，从属服务器忽略数据目录和索引目录表选项。结果是myisam数据和索引文件创建在表的数据库目录中。</p><p>
                For more information, see <a class="xref" href="server-administration.html#sql-mode" title="5.1.10&nbsp;Server SQL Modes">Section&nbsp;5.1.10, “Server SQL Modes”</a>.
            </p><p style="color:blue;">有关更多信息，请参阅第5.1.10节“服务器SQL模式”。</p>
            </div>
            <div class="section">
                <div class="titlepage">
                    <div>
                        <div>
                            <h4 class="title"><a name="replication-features-floatvalues"></a>16.4.1.12&nbsp;Replication and Floating-Point Values</h4>

                        </div>

                    </div>

                </div>
                <a class="indexterm" name="idm140286792053888"></a><a class="indexterm" name="idm140286792052384"></a><p>
                With statement-based replication, values are converted from
                decimal to binary. Because conversions between decimal and
                binary representations of them may be approximate, comparisons
                involving floating-point values are inexact. This is true for
                operations that use floating-point values explicitly, or that
                use values that are converted to floating-point implicitly.
                Comparisons of floating-point values might yield different
                results on master and slave servers due to differences in
                computer architecture, the compiler used to build MySQL, and so
                forth. See <a class="xref" href="functions.html#type-conversion" title="12.2&nbsp;Type Conversion in Expression Evaluation">Section&nbsp;12.2, “Type Conversion in Expression Evaluation”</a>, and
                <a class="xref" href="error-handling.html#problems-with-float" title="B.4.4.8&nbsp;Problems with Floating-Point Values">Section&nbsp;B.4.4.8, “Problems with Floating-Point Values”</a>.
            </p><p style="color:blue;">使用基于语句的复制，值将从十进制转换为二进制。因为它们的十进制和二进制表示之间的转换可能是近似的，所以涉及浮点值的比较是不精确的。对于显式使用浮点值或隐式使用转换为浮点值的操作，这是正确的。由于计算机体系结构、用于构建mysql的编译器等方面的差异，在主服务器和从服务器上比较浮点值可能会产生不同的结果。参见第12.2节“表达式求值中的类型转换”和第B.4.4.8节“浮点值问题”。</p>
            </div>
            <div class="section">
                <div class="titlepage">
                    <div>
                        <div>
                            <h4 class="title"><a name="replication-features-fractional-seconds"></a>16.4.1.13&nbsp;Replication and Fractional Seconds Support</h4>

                        </div>

                    </div>

                </div>
                <a class="indexterm" name="idm140286792047120"></a><a class="indexterm" name="idm140286792045632"></a><p>
                MySQL 5.7 permits fractional seconds for
                <a class="link" href="data-types.html#time" title="11.3.2&nbsp;The TIME Type"><code class="literal">TIME</code></a>,
                <a class="link" href="data-types.html#datetime" title="11.3.1&nbsp;The DATE, DATETIME, and TIMESTAMP Types"><code class="literal">DATETIME</code></a>, and
                <a class="link" href="data-types.html#datetime" title="11.3.1&nbsp;The DATE, DATETIME, and TIMESTAMP Types"><code class="literal">TIMESTAMP</code></a> values, with up to
                microseconds (6 digits) precision. See
                <a class="xref" href="data-types.html#fractional-seconds" title="11.3.6&nbsp;Fractional Seconds in Time Values">Section&nbsp;11.3.6, “Fractional Seconds in Time Values”</a>.
            </p><p style="color:blue;">mysql 5.7允许时间、日期时间和时间戳值的小数秒，精度可达微秒（6位）。见第11.3.6节“时间值的小数秒”。</p><p>
                There may be problems replicating from a master server that
                understands fractional seconds to an older slave (MySQL 5.6.3
                and earlier) that does not:
            </p><p style="color:blue;">从能够理解小数秒的主服务器复制到较旧的从属服务器（mysql 5.6.3及更早版本）时可能会出现以下问题：</p>
                <div class="itemizedlist">
                    <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                        For <a class="link" href="sql-syntax.html#create-table" title="13.1.18&nbsp;CREATE TABLE Syntax"><code class="literal">CREATE TABLE</code></a> statements
                        containing columns that have an
                        <em class="replaceable"><code>fsp</code></em> (fractional seconds
                        precision) value greater than 0, replication will fail due
                        to parser errors.
                    </p><p style="color:blue;">对于包含FSP（小数秒精度）值大于0的列的CREATE TABLE语句，复制将由于解析器错误而失败。</p></li><li class="listitem"><p>
                        Statements that use temporal data types with an
                        <em class="replaceable"><code>fsp</code></em> value of 0 will work for with
                        statement-based logging but not row-based logging. In the
                        latter case, the data types have binary formats and type
                        codes on the master that differ from those on the slave.
                    </p><p style="color:blue;">使用fsp值为0的时态数据类型的语句适用于基于语句的日志记录，但不适用于基于行的日志记录。在后一种情况下，数据类型在主机上具有与从机上不同的二进制格式和类型代码。</p></li><li class="listitem"><p>
                        Some expression results will differ on master and slave.
                        Examples: On the master, the <code class="literal">timestamp</code>
                        system variable returns a value that includes a microseconds
                        fractional part; on the slave, it returns an integer. On the
                        master, functions that return a result that includes the
                        current time (such as
                        <a class="link" href="functions.html#function_curtime"><code class="literal">CURTIME()</code></a>,
                        <a class="link" href="functions.html#function_sysdate"><code class="literal">SYSDATE()</code></a>, or
                        <a class="link" href="functions.html#function_utc-timestamp"><code class="literal">UTC_TIMESTAMP()</code></a>) interpret an
                        argument as an <em class="replaceable"><code>fsp</code></em> value and the
                        return value includes a fractional seconds part of that many
                        digits. On the slave, these functions permit an argument but
                        ignore it.
                    </p><p style="color:blue;">某些表达式的结果在主和从上会有所不同。示例：在master上，timestamp系统变量返回一个包含微秒小数部分的值；在slave上，它返回一个整数。在master上，返回包含当前时间的结果的函数（例如curtime（）、sysdate（）或utc_timestamp（））将参数解释为fsp值，并且返回值包含该多个数字的小数秒部分。在从机上，这些函数允许一个参数，但忽略它。</p></li></ul>
                </div>

            </div>
            <div class="section">
                <div class="titlepage">
                    <div>
                        <div>
                            <h4 class="title"><a name="replication-features-flush"></a>16.4.1.14&nbsp;Replication and FLUSH</h4>

                        </div>

                    </div>

                </div>
                <a class="indexterm" name="idm140286792026672"></a><a class="indexterm" name="idm140286792025184"></a><p>
                Some forms of the <a class="link" href="sql-syntax.html#flush" title="13.7.6.3&nbsp;FLUSH Syntax"><code class="literal">FLUSH</code></a> statement
                are not logged because they could cause problems if replicated
                to a slave: <a class="link" href="sql-syntax.html#flush-logs"><code class="literal">FLUSH LOGS</code></a> and
                <a class="link" href="sql-syntax.html#flush-tables-with-read-lock"><code class="literal">FLUSH TABLES WITH READ LOCK</code></a>. For
                a syntax example, see <a class="xref" href="sql-syntax.html#flush" title="13.7.6.3&nbsp;FLUSH Syntax">Section&nbsp;13.7.6.3, “FLUSH Syntax”</a>. The
                <a class="link" href="sql-syntax.html#flush-tables"><code class="literal">FLUSH TABLES</code></a>,
                <a class="link" href="sql-syntax.html#analyze-table" title="13.7.2.1&nbsp;ANALYZE TABLE Syntax"><code class="literal">ANALYZE TABLE</code></a>,
                <a class="link" href="sql-syntax.html#optimize-table" title="13.7.2.4&nbsp;OPTIMIZE TABLE Syntax"><code class="literal">OPTIMIZE TABLE</code></a>, and
                <a class="link" href="sql-syntax.html#repair-table" title="13.7.2.5&nbsp;REPAIR TABLE Syntax"><code class="literal">REPAIR TABLE</code></a> statements are
                written to the binary log and thus replicated to slaves. This is
                not normally a problem because these statements do not modify
                table data.
            </p><p style="color:blue;">某些形式的flush语句不会被记录，因为它们在复制到从机时可能会导致问题：flush logs和flush tables with read lock。有关语法示例，请参见第13.7.6.3节“刷新语法”。flush tables、analyze table、optimize table和repair table语句将写入二进制日志，并因此复制到从机。这通常不是问题，因为这些语句不修改表数据。</p><p>
                However, this behavior can cause difficulties under certain
                circumstances. If you replicate the privilege tables in the
                <code class="literal">mysql</code> database and update those tables
                directly without using <a class="link" href="sql-syntax.html#grant" title="13.7.1.4&nbsp;GRANT Syntax"><code class="literal">GRANT</code></a>, you
                must issue a <a class="link" href="sql-syntax.html#flush-privileges"><code class="literal">FLUSH PRIVILEGES</code></a> on
                the slaves to put the new privileges into effect. In addition,
                if you use <a class="link" href="sql-syntax.html#flush-tables"><code class="literal">FLUSH TABLES</code></a> when
                renaming a <code class="literal">MyISAM</code> table that is part of a
                <code class="literal">MERGE</code> table, you must issue
                <a class="link" href="sql-syntax.html#flush-tables"><code class="literal">FLUSH TABLES</code></a> manually on the
                slaves. These statements are written to the binary log unless
                you specify <code class="literal">NO_WRITE_TO_BINLOG</code> or its alias
                <code class="literal">LOCAL</code>.
            </p><p style="color:blue;">但是，在某些情况下，这种行为会造成困难。如果复制mysql数据库中的特权表，并在不使用grant的情况下直接更新这些表，则必须对从机发出flush权限，以使新权限生效。此外，如果在重命名作为合并表一部分的myisam表时使用刷新表，则必须在从表上手动发出刷新表。除非您指定不写入二进制日志或其别名为local，否则这些语句将写入二进制日志。</p>
            </div>
            <div class="section">
                <div class="titlepage">
                    <div>
                        <div>
                            <h4 class="title"><a name="replication-features-functions"></a>16.4.1.15&nbsp;Replication and System Functions</h4>

                        </div>

                    </div>

                </div>
                <a class="indexterm" name="idm140286792003056"></a><a class="indexterm" name="idm140286792001568"></a><p>
                Certain functions do not replicate well under some conditions:
            </p><p style="color:blue;">在某些情况下，某些函数不能很好地复制：</p>
                <div class="itemizedlist">
                    <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                        The <a class="link" href="functions.html#function_user"><code class="literal">USER()</code></a>,
                        <a class="link" href="functions.html#function_current-user"><code class="literal">CURRENT_USER()</code></a> (or
                        <a class="link" href="functions.html#function_current-user"><code class="literal">CURRENT_USER</code></a>),
                        <a class="link" href="functions.html#function_uuid"><code class="literal">UUID()</code></a>,
                        <a class="link" href="functions.html#function_version"><code class="literal">VERSION()</code></a>, and
                        <a class="link" href="functions.html#function_load-file"><code class="literal">LOAD_FILE()</code></a> functions are
                        replicated without change and thus do not work reliably on
                        the slave unless row-based replication is enabled. (See
                        <a class="xref" href="replication.html#replication-formats" title="16.2.1&nbsp;Replication Formats">Section&nbsp;16.2.1, “Replication Formats”</a>.)
                    </p><p style="color:blue;">user（）、current_user（）（或current_user）、uuid（）、version（）和load_file（）函数将在不做更改的情况下复制，因此除非启用基于行的复制，否则无法在从机上可靠工作。（见第16.2.1节，“复制格式”。）</p><p>
                        <a class="link" href="functions.html#function_user"><code class="literal">USER()</code></a> and
                        <a class="link" href="functions.html#function_current-user"><code class="literal">CURRENT_USER()</code></a> are
                        automatically replicated using row-based replication when
                        using <code class="literal">MIXED</code> mode, and generate a warning
                        in <code class="literal">STATEMENT</code> mode. (See also
                        <a class="xref" href="replication.html#replication-features-current-user" title="16.4.1.8&nbsp;Replication of CURRENT_USER()">Section&nbsp;16.4.1.8, “Replication of CURRENT_USER()”</a>.) This
                        is also true for <a class="link" href="functions.html#function_version"><code class="literal">VERSION()</code></a>
                        and <a class="link" href="functions.html#function_rand"><code class="literal">RAND()</code></a>.
                    </p><p style="color:blue;">当使用混合模式时，用户（）和当前用户（）将使用基于行的复制自动复制，并在语句模式下生成警告。（另请参见16.4.1.8节，“复制当前用户（）”）对于version（）和rand（）也是如此。</p></li><li class="listitem"><p>
                        For <a class="link" href="functions.html#function_now"><code class="literal">NOW()</code></a>, the binary log
                        includes the timestamp. This means that the value
                        <span class="emphasis"><em>as returned by the call to this function on the
            master</em></span> is replicated to the slave. To avoid
                        unexpected results when replicating between MySQL servers in
                        different time zones, set the time zone on both master and
                        slave. See also
                        <a class="xref" href="replication.html#replication-features-timezone" title="16.4.1.31&nbsp;Replication and Time Zones">Section&nbsp;16.4.1.31, “Replication and Time Zones”</a>
                    </p><p style="color:blue;">对于now（），二进制日志包含时间戳。这意味着在主节点上调用此函数返回的值将复制到从节点。为了避免在不同时区的mysql服务器之间进行复制时出现意外结果，请在主服务器和从服务器上设置时区。另见第16.4.1.31节“复制和时区”</p><p>
                        To explain the potential problems when replicating between
                        servers which are in different time zones, suppose that the
                        master is located in New York, the slave is located in
                        Stockholm, and both servers are using local time. Suppose
                        further that, on the master, you create a table
                        <code class="literal">mytable</code>, perform an
                        <a class="link" href="sql-syntax.html#insert" title="13.2.5&nbsp;INSERT Syntax"><code class="literal">INSERT</code></a> statement on this
                        table, and then select from the table, as shown here:
                    </p><p style="color:blue;">为了解释在不同时区的服务器之间进行复制时可能出现的问题，假设主服务器位于纽约，从服务器位于斯德哥尔摩，并且两台服务器都使用本地时间。进一步假设，在master上创建一个表mytable，在此表上执行insert语句，然后从表中选择，如下所示：</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>CREATE TABLE mytable (mycol TEXT);</code></strong>
Query OK, 0 rows affected (0.06 sec)

mysql&gt; <strong class="userinput"><code>INSERT INTO mytable VALUES ( NOW() );</code></strong>
Query OK, 1 row affected (0.00 sec)

mysql&gt; <strong class="userinput"><code>SELECT * FROM mytable;</code></strong>
+---------------------+
| mycol               |
+---------------------+
| 2009-09-01 12:00:00 |
+---------------------+
1 row in set (0.00 sec)
</pre><p>
                        Local time in Stockholm is 6 hours later than in New York;
                        so, if you issue <code class="literal">SELECT NOW()</code> on the
                        slave at that exact same instant, the value
                        <code class="literal">2009-09-01 18:00:00</code> is returned. For this
                        reason, if you select from the slave's copy of
                        <code class="literal">mytable</code> after the
                        <a class="link" href="sql-syntax.html#create-table" title="13.1.18&nbsp;CREATE TABLE Syntax"><code class="literal">CREATE TABLE</code></a> and
                        <a class="link" href="sql-syntax.html#insert" title="13.2.5&nbsp;INSERT Syntax"><code class="literal">INSERT</code></a> statements just shown
                        have been replicated, you might expect
                        <code class="literal">mycol</code> to contain the value
                        <code class="literal">2009-09-01 18:00:00</code>. However, this is not
                        the case; when you select from the slave's copy of
                        <code class="literal">mytable</code>, you obtain exactly the same
                        result as on the master:
                    </p><p style="color:blue;">斯德哥尔摩当地时间比纽约晚6小时；因此，如果在同一时刻对从机发出select now（），则返回值2009-09-01 18:00:00。因此，如果在复制了刚才显示的create table和insert语句之后从mytable的从机副本中进行选择，您可能希望mycol包含值2009-09-01 18:00:00。但是，情况并非如此；当您从MyTable的从机副本中进行选择时，将获得与在主机上完全相同的结果：</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT * FROM mytable;</code></strong>
+---------------------+
| mycol               |
+---------------------+
| 2009-09-01 12:00:00 |
+---------------------+
1 row in set (0.00 sec)
</pre><p>
                        Unlike <a class="link" href="functions.html#function_now"><code class="literal">NOW()</code></a>, the
                        <a class="link" href="functions.html#function_sysdate"><code class="literal">SYSDATE()</code></a> function is not
                        replication-safe because it is not affected by <code class="literal">SET
                        TIMESTAMP</code> statements in the binary log and is
                        nondeterministic if statement-based logging is used. This is
                        not a problem if row-based logging is used.
                    </p><p style="color:blue;">与now（）不同，sysdate（）函数不是复制安全的，因为它不受二进制日志中set timestamp语句的影响，并且如果使用基于语句的日志记录，则它是不确定的。如果使用基于行的日志记录，这不是问题。</p><p>
                        An alternative is to use the
                        <a class="link" href="server-administration.html#option_mysqld_sysdate-is-now"><code class="option">--sysdate-is-now</code></a> option to
                        cause <a class="link" href="functions.html#function_sysdate"><code class="literal">SYSDATE()</code></a> to be an
                        alias for <a class="link" href="functions.html#function_now"><code class="literal">NOW()</code></a>. This must be
                        done on the master and the slave to work correctly. In such
                        cases, a warning is still issued by this function, but can
                        safely be ignored as long as
                        <a class="link" href="server-administration.html#option_mysqld_sysdate-is-now"><code class="option">--sysdate-is-now</code></a> is used on
                        both the master and the slave.
                    </p><p style="color:blue;">另一种方法是使用--sysdate is now选项使sysdate（）成为now（）的别名。这必须在主从机上完成才能正常工作。在这种情况下，此函数仍会发出警告，但只要在主服务器和从服务器上都使用-sysdate，就可以安全地忽略此警告。</p><p>
                        <a class="link" href="functions.html#function_sysdate"><code class="literal">SYSDATE()</code></a> is automatically
                        replicated using row-based replication when using
                        <code class="literal">MIXED</code> mode, and generates a warning in
                        <code class="literal">STATEMENT</code> mode.
                    </p><p style="color:blue;">使用混合模式时，sysdate（）将使用基于行的复制自动复制，并在语句模式下生成警告。</p><p>
                        See also <a class="xref" href="replication.html#replication-features-timezone" title="16.4.1.31&nbsp;Replication and Time Zones">Section&nbsp;16.4.1.31, “Replication and Time Zones”</a>.
                    </p><p style="color:blue;">另见第16.4.1.31节“复制和时区”。</p></li><li class="listitem"><p>
            <span class="emphasis"><em>The following restriction applies to
            statement-based replication only, not to row-based
            replication.</em></span> The
                        <a class="link" href="functions.html#function_get-lock"><code class="literal">GET_LOCK()</code></a>,
                        <a class="link" href="functions.html#function_release-lock"><code class="literal">RELEASE_LOCK()</code></a>,
                        <a class="link" href="functions.html#function_is-free-lock"><code class="literal">IS_FREE_LOCK()</code></a>, and
                        <a class="link" href="functions.html#function_is-used-lock"><code class="literal">IS_USED_LOCK()</code></a> functions that
                        handle user-level locks are replicated without the slave
                        knowing the concurrency context on the master. Therefore,
                        these functions should not be used to insert into a master
                        table because the content on the slave would differ. For
                        example, do not issue a statement such as <code class="literal">INSERT
                        INTO mytable VALUES(GET_LOCK(...))</code>.
                    </p><p style="color:blue;">以下限制仅适用于基于语句的复制，而不适用于基于行的复制。get_lock（）、release_lock（）、is_free_lock（）、is_used_lock（）函数用于处理用户级锁，这些函数在从机不知道主机上的并发上下文的情况下进行复制。因此，不应使用这些函数插入主表，因为从表上的内容会有所不同。例如，不要发出insert into mytable values（get_lock（…））之类的语句。</p><p>
                        These functions are automatically replicated using row-based
                        replication when using <code class="literal">MIXED</code> mode, and
                        generate a warning in <code class="literal">STATEMENT</code> mode.
                    </p><p style="color:blue;">当使用混合模式时，这些函数将使用基于行的复制自动复制，并在语句模式下生成警告。</p></li></ul>
                </div>
                <p>
                    As a workaround for the preceding limitations when
                    statement-based replication is in effect, you can use the
                    strategy of saving the problematic function result in a user
                    variable and referring to the variable in a later statement. For
                    example, the following single-row
                    <a class="link" href="sql-syntax.html#insert" title="13.2.5&nbsp;INSERT Syntax"><code class="literal">INSERT</code></a> is problematic due to the
                    reference to the <a class="link" href="functions.html#function_uuid"><code class="literal">UUID()</code></a> function:
                </p><p style="color:blue;">在基于语句的复制生效时，可以使用将有问题的函数结果保存到用户变量中并在以后的语句中引用该变量的策略来解决上述限制。例如，由于对uuid（）函数的引用，以下单行插入有问题：</p><pre data-lang="sql" class="programlisting">INSERT INTO t VALUES(UUID());
</pre><p>
                To work around the problem, do this instead:
            </p><p style="color:blue;">要解决此问题，请执行以下操作：</p><pre data-lang="sql" class="programlisting">SET @my_uuid = UUID();
INSERT INTO t VALUES(@my_uuid);
</pre><p>
                That sequence of statements replicates because the value of
                <code class="literal">@my_uuid</code> is stored in the binary log as a
                user-variable event prior to the
                <a class="link" href="sql-syntax.html#insert" title="13.2.5&nbsp;INSERT Syntax"><code class="literal">INSERT</code></a> statement and is available
                for use in the <a class="link" href="sql-syntax.html#insert" title="13.2.5&nbsp;INSERT Syntax"><code class="literal">INSERT</code></a>.
            </p><p style="color:blue;">因为@my_uid的值在insert语句之前作为用户变量事件存储在二进制日志中，并且可以在insert语句中使用，所以可以复制该语句序列。</p><p>
                The same idea applies to multiple-row inserts, but is more
                cumbersome to use. For a two-row insert, you can do this:
            </p><p style="color:blue;">同样的想法也适用于多行插入，但使用起来更麻烦。对于两行插入，可以执行以下操作：</p><pre data-lang="sql" class="programlisting">SET @my_uuid1 = UUID(); @my_uuid2 = UUID();
INSERT INTO t VALUES(@my_uuid1),(@my_uuid2);
</pre><p>
                However, if the number of rows is large or unknown, the
                workaround is difficult or impracticable. For example, you
                cannot convert the following statement to one in which a given
                individual user variable is associated with each row:
            </p><p style="color:blue;">但是，如果行数很大或未知，则解决方法很难或不可行。例如，不能将以下语句转换为给定的单个用户变量与每行关联的语句：</p><pre data-lang="sql" class="programlisting">INSERT INTO t2 SELECT UUID(), * FROM t1;
</pre><p>
                Within a stored function, <a class="link" href="functions.html#function_rand"><code class="literal">RAND()</code></a>
                replicates correctly as long as it is invoked only once during
                the execution of the function. (You can consider the function
                execution timestamp and random number seed as implicit inputs
                that are identical on the master and slave.)
            </p><p style="color:blue;">在存储的函数中，只要在函数执行期间仅调用一次rand（）就可以正确复制。（可以将函数执行时间戳和随机数种子视为在主节点和从节点上相同的隐式输入。）</p><p>
                The <a class="link" href="functions.html#function_found-rows"><code class="literal">FOUND_ROWS()</code></a> and
                <a class="link" href="functions.html#function_row-count"><code class="literal">ROW_COUNT()</code></a> functions are not
                replicated reliably using statement-based replication. A
                workaround is to store the result of the function call in a user
                variable, and then use that in the
                <a class="link" href="sql-syntax.html#insert" title="13.2.5&nbsp;INSERT Syntax"><code class="literal">INSERT</code></a> statement. For example, if
                you wish to store the result in a table named
                <code class="literal">mytable</code>, you might normally do so like this:
            </p><p style="color:blue;">使用基于语句的复制无法可靠地复制找到的_rows（）和row_count（）函数。解决方法是将函数调用的结果存储在用户变量中，然后在INSERT语句中使用该结果。例如，如果希望将结果存储在名为mytable的表中，通常可以这样做：</p><pre data-lang="sql" class="programlisting">SELECT SQL_CALC_FOUND_ROWS FROM mytable LIMIT 1;
INSERT INTO mytable VALUES( FOUND_ROWS() );
</pre><p>
                However, if you are replicating <code class="literal">mytable</code>, you
                should use <a class="link" href="sql-syntax.html#select-into" title="13.2.9.1&nbsp;SELECT ... INTO Syntax"><code class="literal">SELECT
                ... INTO</code></a>, and then store the variable in the table,
                like this:
            </p><p style="color:blue;">但是，如果要复制mytable，则应使用select…输入，然后将变量存储在表中，如下所示：</p><pre data-lang="sql" class="programlisting">SELECT SQL_CALC_FOUND_ROWS INTO @found_rows FROM mytable LIMIT 1;
INSERT INTO mytable VALUES(@found_rows);
</pre><p>
                In this way, the user variable is replicated as part of the
                context, and applied on the slave correctly.
            </p><p style="color:blue;">这样，用户变量作为上下文的一部分被复制，并正确地应用于从机。</p><p>
                These functions are automatically replicated using row-based
                replication when using <code class="literal">MIXED</code> mode, and
                generate a warning in <code class="literal">STATEMENT</code> mode. (Bug
                #12092, Bug #30244)
            </p><p style="color:blue;">当使用混合模式时，这些函数将使用基于行的复制自动复制，并在语句模式下生成警告。（错误12092，错误30244）</p><p>
                Prior to MySQL 5.7.3, the value of
                <a class="link" href="functions.html#function_last-insert-id"><code class="literal">LAST_INSERT_ID()</code></a> was not
                replicated correctly if any filtering options such as
                <a class="link" href="replication.html#option_mysqld_replicate-ignore-db"><code class="option">--replicate-ignore-db</code></a> and
                <a class="link" href="replication.html#option_mysqld_replicate-do-table"><code class="option">--replicate-do-table</code></a> were enabled
                on the slave. (Bug #17234370, BUG# 69861)
            </p><p style="color:blue;">在mysql 5.7.3之前，如果在从机上启用了诸如--replicate ignore db和--replicate do table之类的筛选选项，则last_insert_id（）的值不会正确复制。（错误17234370，错误69861）</p>
            </div>
            <div class="section">
                <div class="titlepage">
                    <div>
                        <div>
                            <h4 class="title"><a name="replication-features-invoked"></a>16.4.1.16&nbsp;Replication of Invoked Features</h4>

                        </div>

                    </div>

                </div>
                <a class="indexterm" name="idm140286791909008"></a><a class="indexterm" name="idm140286791907520"></a><a class="indexterm" name="idm140286791906032"></a><a class="indexterm" name="idm140286791904544"></a><a class="indexterm" name="idm140286791903056"></a><a class="indexterm" name="idm140286791901568"></a><a class="indexterm" name="idm140286791900080"></a><p>
                Replication of invoked features such as user-defined functions
                (UDFs) and stored programs (stored procedures and functions,
                triggers, and events) provides the following characteristics:
            </p><p style="color:blue;">复制被调用的功能（如用户定义函数（UDF）和存储程序（存储过程和函数、触发器和事件））提供以下特性：</p>
                <div class="itemizedlist">
                    <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                        The effects of the feature are always replicated.
                    </p><p style="color:blue;">功能的效果总是复制的。</p></li><li class="listitem"><p>
                        The following statements are replicated using
                        statement-based replication:
                    </p><p style="color:blue;">使用基于语句的复制复制复制以下语句：</p>
                        <div class="itemizedlist">
                            <ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
                                <a class="link" href="sql-syntax.html#create-event" title="13.1.12&nbsp;CREATE EVENT Syntax"><code class="literal">CREATE EVENT</code></a>
                            </p><p style="color:blue;">创建事件</p></li><li class="listitem"><p>
                                <a class="link" href="sql-syntax.html#alter-event" title="13.1.2&nbsp;ALTER EVENT Syntax"><code class="literal">ALTER EVENT</code></a>
                            </p><p style="color:blue;">更改事件</p></li><li class="listitem"><p>
                                <a class="link" href="sql-syntax.html#drop-event" title="13.1.23&nbsp;DROP EVENT Syntax"><code class="literal">DROP EVENT</code></a>
                            </p><p style="color:blue;">丢弃事件</p></li><li class="listitem"><p>
                                <a class="link" href="sql-syntax.html#create-procedure" title="13.1.16&nbsp;CREATE PROCEDURE and CREATE FUNCTION Syntax"><code class="literal">CREATE PROCEDURE</code></a>
                            </p><p style="color:blue;">创建过程</p></li><li class="listitem"><p>
                                <a class="link" href="sql-syntax.html#drop-procedure" title="13.1.27&nbsp;DROP PROCEDURE and DROP FUNCTION Syntax"><code class="literal">DROP PROCEDURE</code></a>
                            </p><p style="color:blue;">下降程序</p></li><li class="listitem"><p>
                                <a class="link" href="sql-syntax.html#create-function" title="13.1.13&nbsp;CREATE FUNCTION Syntax"><code class="literal">CREATE FUNCTION</code></a>
                            </p><p style="color:blue;">创建函数</p></li><li class="listitem"><p>
                                <a class="link" href="sql-syntax.html#drop-function" title="13.1.24&nbsp;DROP FUNCTION Syntax"><code class="literal">DROP FUNCTION</code></a>
                            </p><p style="color:blue;">滴函数</p></li><li class="listitem"><p>
                                <a class="link" href="sql-syntax.html#create-trigger" title="13.1.20&nbsp;CREATE TRIGGER Syntax"><code class="literal">CREATE TRIGGER</code></a>
                            </p><p style="color:blue;">创建触发器</p></li><li class="listitem"><p>
                                <a class="link" href="sql-syntax.html#drop-trigger" title="13.1.31&nbsp;DROP TRIGGER Syntax"><code class="literal">DROP TRIGGER</code></a>
                            </p><p style="color:blue;">删除触发器</p></li></ul>
                        </div>
                        <p>
                            However, the <span class="emphasis"><em>effects</em></span> of features
                            created, modified, or dropped using these statements are
                            replicated using row-based replication.
                        </p><p style="color:blue;">但是，使用这些语句创建、修改或删除的功能的效果将使用基于行的复制进行复制。</p>
                        <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">

                            <div class="admon-title">
                                Note
                            </div>
                            <p>
                                Attempting to replicate invoked features using
                                statement-based replication produces the warning
                                <span class="errortext">Statement is not safe to log in statement
              format</span>. For example, trying to replicate a UDF
                                with statement-based replication generates this warning
                                because it currently cannot be determined by the MySQL
                                server whether the UDF is deterministic. If you are
                                absolutely certain that the invoked feature's effects are
                                deterministic, you can safely disregard such warnings.
                            </p><p style="color:blue;">尝试使用基于语句的复制复制调用的功能时，将生成警告语句，该语句不安全，无法以语句格式登录。例如，尝试使用基于语句的复制复制udf会生成此警告，因为mysql服务器目前无法确定udf是否是确定性的。如果您完全确定被调用功能的效果是确定的，那么可以安全地忽略此类警告。</p>
                        </div>
                    </li><li class="listitem"><p>
                        <a class="indexterm" name="idm140286791874528"></a>

                        <a class="indexterm" name="idm140286791873040"></a>

                        <a class="indexterm" name="idm140286791871552"></a>

                        <a class="indexterm" name="idm140286791870064"></a>

                        In the case of <a class="link" href="sql-syntax.html#create-event" title="13.1.12&nbsp;CREATE EVENT Syntax"><code class="literal">CREATE EVENT</code></a>
                        and <a class="link" href="sql-syntax.html#alter-event" title="13.1.2&nbsp;ALTER EVENT Syntax"><code class="literal">ALTER EVENT</code></a>:
                    </p><p style="color:blue;">在create event和alter event的情况下：</p>
                        <div class="itemizedlist">
                            <ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
                                The status of the event is set to
                                <code class="literal">SLAVESIDE_DISABLED</code> on the slave
                                regardless of the state specified (this does not apply
                                to <a class="link" href="sql-syntax.html#drop-event" title="13.1.23&nbsp;DROP EVENT Syntax"><code class="literal">DROP EVENT</code></a>).
                            </p><p style="color:blue;">无论指定的状态如何，事件的状态都设置为从机上的slaveside_disabled（这不适用于删除事件）。</p></li><li class="listitem"><p>
                                The master on which the event was created is identified
                                on the slave by its server ID. The
                                <code class="literal">ORIGINATOR</code> column in
                                <a class="link" href="information-schema.html#events-table" title="24.8&nbsp;The INFORMATION_SCHEMA EVENTS Table"><code class="literal">INFORMATION_SCHEMA.EVENTS</code></a>
                                and the <code class="literal">originator</code> column in
                                <code class="literal">mysql.event</code> store this information.
                                See <a class="xref" href="information-schema.html#events-table" title="24.8&nbsp;The INFORMATION_SCHEMA EVENTS Table">Section&nbsp;24.8, “The INFORMATION_SCHEMA EVENTS Table”</a>, and
                                <a class="xref" href="sql-syntax.html#show-events" title="13.7.5.18&nbsp;SHOW EVENTS Syntax">Section&nbsp;13.7.5.18, “SHOW EVENTS Syntax”</a>, for more information.
                            </p><p style="color:blue;">创建事件的主服务器通过其服务器ID在从属服务器上标识。information_schema.events中的originator列和mysql.event中的originator列存储此信息。有关详细信息，请参见第24.8节“信息模式事件表”和第13.7.5.18节“显示事件语法”。</p></li></ul>
                        </div>
                    </li><li class="listitem"><p>
                        The feature implementation resides on the slave in a
                        renewable state so that if the master fails, the slave can
                        be used as the master without loss of event processing.
                    </p><p style="color:blue;">功能实现驻留在处于可更新状态的从机上，以便在主机发生故障时，可以将从机用作主机，而不会丢失事件处理。</p></li></ul>
                </div>
                <p>
                    To determine whether there are any scheduled events on a MySQL
                    server that were created on a different server (that was acting
                    as a replication master), query the
                    <a class="link" href="information-schema.html#events-table" title="24.8&nbsp;The INFORMATION_SCHEMA EVENTS Table"><code class="literal">INFORMATION_SCHEMA.EVENTS</code></a> table in
                    a manner similar to what is shown here:
                </p><p style="color:blue;">要确定MySQL服务器上是否有在其他服务器（充当复制主服务器）上创建的计划事件，请以类似于此处所示的方式查询information_schema.events表：</p><pre data-lang="sql" class="programlisting">SELECT EVENT_SCHEMA, EVENT_NAME
    FROM INFORMATION_SCHEMA.EVENTS
    WHERE STATUS = 'SLAVESIDE_DISABLED';
</pre><p>
                Alternatively, you can use the <a class="link" href="sql-syntax.html#show-events" title="13.7.5.18&nbsp;SHOW EVENTS Syntax"><code class="literal">SHOW
                EVENTS</code></a> statement, like this:
            </p><p style="color:blue;">或者，可以使用show events语句，如下所示：</p><pre data-lang="sql" class="programlisting">SHOW EVENTS
    WHERE STATUS = 'SLAVESIDE_DISABLED';
</pre><p>
                When promoting a replication slave having such events to a
                replication master, you must enable each event using
                <a class="link" href="sql-syntax.html#alter-event" title="13.1.2&nbsp;ALTER EVENT Syntax"><code class="literal">ALTER EVENT
                    <em class="replaceable"><code>event_name</code></em> ENABLE</code></a>, where
                <em class="replaceable"><code>event_name</code></em> is the name of the event.
            </p><p style="color:blue;">当将具有此类事件的复制从机升级到复制主机时，必须使用alter event event_name enable启用每个事件，其中event_name是事件的名称。</p><p>
                If more than one master was involved in creating events on this
                slave, and you wish to identify events that were created only on
                a given master having the server ID
                <em class="replaceable"><code>master_id</code></em>, modify the previous query
                on the <a class="link" href="information-schema.html#events-table" title="24.8&nbsp;The INFORMATION_SCHEMA EVENTS Table"><code class="literal">EVENTS</code></a> table to include the
                <code class="literal">ORIGINATOR</code> column, as shown here:
            </p><p style="color:blue;">如果在此从属服务器上创建事件涉及多个主服务器，并且您希望标识仅在具有服务器ID主服务器ID的给定主服务器上创建的事件，请修改Events表上的上一个查询以包括Originator列，如下所示：</p><pre data-lang="sql" class="programlisting">SELECT EVENT_SCHEMA, EVENT_NAME, ORIGINATOR
    FROM INFORMATION_SCHEMA.EVENTS
    WHERE STATUS = 'SLAVESIDE_DISABLED'
    AND   ORIGINATOR = '<em class="replaceable"><code>master_id</code></em>'
</pre><p>
                You can employ <code class="literal">ORIGINATOR</code> with the
                <a class="link" href="sql-syntax.html#show-events" title="13.7.5.18&nbsp;SHOW EVENTS Syntax"><code class="literal">SHOW EVENTS</code></a> statement in a
                similar fashion:
            </p><p style="color:blue;">您可以采用类似的方式雇用具有Show Events语句的发起者：</p><pre data-lang="sql" class="programlisting">SHOW EVENTS
    WHERE STATUS = 'SLAVESIDE_DISABLED'
    AND   ORIGINATOR = '<em class="replaceable"><code>master_id</code></em>'
</pre><p>
                Before enabling events that were replicated from the master, you
                should disable the MySQL Event Scheduler on the slave (using a
                statement such as <code class="literal">SET GLOBAL event_scheduler =
                OFF;</code>), run any necessary <a class="link" href="sql-syntax.html#alter-event" title="13.1.2&nbsp;ALTER EVENT Syntax"><code class="literal">ALTER
                EVENT</code></a> statements, restart the server, then re-enable
                the Event Scheduler on the slave afterward (using a statement
                such as <code class="literal">SET GLOBAL event_scheduler = ON;</code>)-
            </p><p style="color:blue;">在启用从主服务器复制的事件之前，应禁用从服务器上的mysql事件计划程序（使用set global event_scheduler=off；）运行任何必要的alter event语句，重新启动服务器，然后在从机上重新启用事件调度程序（使用set global event_scheduler=on；）语句）-</p><p>
                If you later demote the new master back to being a replication
                slave, you must disable manually all events enabled by the
                <a class="link" href="sql-syntax.html#alter-event" title="13.1.2&nbsp;ALTER EVENT Syntax"><code class="literal">ALTER EVENT</code></a> statements. You can
                do this by storing in a separate table the event names from the
                <a class="link" href="sql-syntax.html#select" title="13.2.9&nbsp;SELECT Syntax"><code class="literal">SELECT</code></a> statement shown
                previously, or using <a class="link" href="sql-syntax.html#alter-event" title="13.1.2&nbsp;ALTER EVENT Syntax"><code class="literal">ALTER EVENT</code></a>
                statements to rename the events with a common prefix such as
                <code class="literal">replicated_</code> to identify them.
            </p><p style="color:blue;">如果以后将新主服务器降级为复制从服务器，则必须手动禁用alter event语句启用的所有事件。您可以通过将前面显示的select语句中的事件名称存储在单独的表中，或者使用alter event语句重命名带有公共前缀（如replicated_u）的事件来标识它们。</p><p>
                If you rename the events, then when demoting this server back to
                being a replication slave, you can identify the events by
                querying the <a class="link" href="information-schema.html#events-table" title="24.8&nbsp;The INFORMATION_SCHEMA EVENTS Table"><code class="literal">EVENTS</code></a> table, as shown
                here:
            </p><p style="color:blue;">如果重命名事件，则将此服务器降级回复制从属服务器时，可以通过查询事件表来标识事件，如下所示：</p><pre data-lang="sql" class="programlisting">SELECT CONCAT(EVENT_SCHEMA, '.', EVENT_NAME) AS 'Db.Event'
      FROM INFORMATION_SCHEMA.EVENTS
      WHERE INSTR(EVENT_NAME, 'replicated_') = 1;
</pre>
            </div>
            <div class="section">
                <div class="titlepage">
                    <div>
                        <div>
                            <h4 class="title"><a name="replication-features-limit"></a>16.4.1.17&nbsp;Replication and LIMIT</h4>

                        </div>

                    </div>

                </div>
                <a class="indexterm" name="idm140286791826288"></a><a class="indexterm" name="idm140286791824800"></a><p>
                Statement-based replication of <code class="literal">LIMIT</code> clauses
                in <a class="link" href="sql-syntax.html#delete" title="13.2.2&nbsp;DELETE Syntax"><code class="literal">DELETE</code></a>,
                <a class="link" href="sql-syntax.html#update" title="13.2.11&nbsp;UPDATE Syntax"><code class="literal">UPDATE</code></a>, and
                <a class="link" href="sql-syntax.html#insert-select" title="13.2.5.1&nbsp;INSERT ... SELECT Syntax"><code class="literal">INSERT ...
                    SELECT</code></a> statements is unsafe since the order of the
                rows affected is not defined. (Such statements can be replicated
                correctly with statement-based replication only if they also
                contain an <code class="literal">ORDER BY</code> clause.) When such a
                statement is encountered:
            </p><p style="color:blue;">基于语句复制delete、update和insert中的限制子句…select语句不安全，因为未定义受影响行的顺序。（只有当这些语句还包含ORDER BY子句时，才能使用基于语句的复制正确复制这些语句。）遇到此类语句时：</p>
                <div class="itemizedlist">
                    <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                        When using <code class="literal">STATEMENT</code> mode, a warning that
                        the statement is not safe for statement-based replication is
                        now issued.
                    </p><p style="color:blue;">当使用语句模式时，现在会发出一个警告，说明该语句对于基于语句的复制不安全。</p><p>
                        When using <code class="literal">STATEMENT</code> mode, warnings are
                        issued for DML statements containing
                        <code class="literal">LIMIT</code> even when they also have an
                        <code class="literal">ORDER BY</code> clause (and so are made
                        deterministic). This is a known issue. (Bug #42851)
                    </p><p style="color:blue;">当使用语句模式时，即使DML语句还具有ORDERBY子句（因此具有确定性），也会对包含LIMIT的DML语句发出警告。这是一个众所周知的问题。（错误42851）</p></li><li class="listitem"><p>
                        When using <code class="literal">MIXED</code> mode, the statement is
                        now automatically replicated using row-based mode.
                    </p><p style="color:blue;">使用混合模式时，语句现在将使用基于行的模式自动复制。</p></li></ul>
                </div>

            </div>
            <div class="section">
                <div class="titlepage">
                    <div>
                        <div>
                            <h4 class="title"><a name="replication-features-load-data"></a>16.4.1.18&nbsp;Replication and LOAD DATA</h4>

                        </div>

                    </div>

                </div>
                <a class="indexterm" name="idm140286791809824"></a><a class="indexterm" name="idm140286791808336"></a><p>
                <a class="link" href="sql-syntax.html#load-data" title="13.2.6&nbsp;LOAD DATA Syntax"><code class="literal">LOAD DATA</code></a> is considered unsafe
                for statement-based logging (see
                <a class="xref" href="replication.html#replication-rbr-safe-unsafe" title="16.2.1.3&nbsp;Determination of Safe and Unsafe Statements in Binary Logging">Section&nbsp;16.2.1.3, “Determination of Safe and Unsafe Statements in Binary Logging”</a>). When
                <a class="link" href="replication.html#sysvar_binlog_format"><code class="literal">binlog_format=MIXED</code></a> is set, the
                statement is logged in row-based format. When
                <a class="link" href="replication.html#sysvar_binlog_format"><code class="literal">binlog_format=STATEMENT</code></a> is set,
                note that <a class="link" href="sql-syntax.html#load-data" title="13.2.6&nbsp;LOAD DATA Syntax"><code class="literal">LOAD DATA</code></a> does not
                generate a warning, unlike other unsafe statements.
            </p><p style="color:blue;">对于基于语句的日志记录，负载数据被认为是不安全的（参见第16.2.1.3节，“二进制日志中安全和不安全语句的确定”）。当设置binlog_format=mixed时，语句将以基于行的格式记录。当设置binlog_format=语句时，请注意，与其他不安全的语句不同，加载数据不会生成警告。</p><p>
                When <a class="link" href="programs.html#mysqlbinlog" title="4.6.7&nbsp;mysqlbinlog — Utility for Processing Binary Log Files"><span class="command"><strong>mysqlbinlog</strong></span></a> reads log events for
                <a class="link" href="sql-syntax.html#load-data" title="13.2.6&nbsp;LOAD DATA Syntax"><code class="literal">LOAD DATA</code></a> statements logged in
                statement-based format, a generated local file is created in a
                temporary directory. These temporary files are not automatically
                removed by <a class="link" href="programs.html#mysqlbinlog" title="4.6.7&nbsp;mysqlbinlog — Utility for Processing Binary Log Files"><span class="command"><strong>mysqlbinlog</strong></span></a> or any other MySQL
                program. If you do use <a class="link" href="sql-syntax.html#load-data" title="13.2.6&nbsp;LOAD DATA Syntax"><code class="literal">LOAD DATA</code></a>
                statements with statement-based binary logging, you should
                delete the temporary files yourself after you no longer need the
                statement log. For more information, see
                <a class="xref" href="programs.html#mysqlbinlog" title="4.6.7&nbsp;mysqlbinlog — Utility for Processing Binary Log Files">Section&nbsp;4.6.7, “<span class="command"><strong>mysqlbinlog</strong></span> — Utility for Processing Binary Log Files”</a>.
            </p><p style="color:blue;">当mysqlbinlog读取以基于语句格式记录的加载数据语句的日志事件时，将在临时目录中创建生成的本地文件。mysqlbinlog或任何其他mysql程序不会自动删除这些临时文件。如果使用基于语句的二进制日志加载数据语句，则应在不再需要语句日志后自行删除临时文件。有关更多信息，请参阅4.6.7节，“mysqlbinlog-用于处理二进制日志文件的实用程序”。</p>
            </div>
            <div class="section">
                <div class="titlepage">
                    <div>
                        <div>
                            <h4 class="title"><a name="replication-features-max-allowed-packet"></a>16.4.1.19&nbsp;Replication and max_allowed_packet</h4>

                        </div>

                    </div>

                </div>
                <a class="indexterm" name="idm140286791792896"></a><a class="indexterm" name="idm140286791791408"></a><p>
                <a class="link" href="server-administration.html#sysvar_max_allowed_packet"><code class="literal">max_allowed_packet</code></a> sets an
                upper limit on the size of any single message between the MySQL
                server and clients, including replication slaves. If you are
                replicating large column values (such as might be found in
                <a class="link" href="data-types.html#blob" title="11.4.3&nbsp;The BLOB and TEXT Types"><code class="literal">TEXT</code></a> or
                <a class="link" href="data-types.html#blob" title="11.4.3&nbsp;The BLOB and TEXT Types"><code class="literal">BLOB</code></a> columns) and
                <a class="link" href="server-administration.html#sysvar_max_allowed_packet"><code class="literal">max_allowed_packet</code></a> is too small
                on the master, the master fails with an error, and the slave
                shuts down the I/O thread. If
                <a class="link" href="server-administration.html#sysvar_max_allowed_packet"><code class="literal">max_allowed_packet</code></a> is too small
                on the slave, this also causes the slave to stop the I/O thread.
            </p><p style="color:blue;">max_allowed_packet设置mysql服务器和客户端（包括复制从机）之间任何单个消息的大小上限。如果要复制大的列值（例如可能在文本列或blob列中找到的值），并且主机上的max_allowed_packet太小，则主机将失败并出现错误，而从机将关闭I/O线程。如果从机上的max_allowed_packet太小，也会导致从机停止I/O线程。</p><p>
                Row-based replication currently sends all columns and column
                values for updated rows from the master to the slave, including
                values of columns that were not actually changed by the update.
                This means that, when you are replicating large column values
                using row-based replication, you must take care to set
                <a class="link" href="server-administration.html#sysvar_max_allowed_packet"><code class="literal">max_allowed_packet</code></a> large enough
                to accommodate the largest row in any table to be replicated,
                even if you are replicating updates only, or you are inserting
                only relatively small values.
            </p><p style="color:blue;">基于行的复制当前将更新行的所有列和列值从主行发送到从行，包括更新未实际更改的列的值。这意味着，当使用基于行的复制复制大列值时，必须注意将max_allowed_packet设置为足够大，以容纳要复制的任何表中的最大行，即使您只复制更新，或者只插入相对较小的值。</p>
            </div>
            <div class="section">
                <div class="titlepage">
                    <div>
                        <div>
                            <h4 class="title"><a name="replication-features-memory"></a>16.4.1.20&nbsp;Replication and MEMORY Tables</h4>

                        </div>

                    </div>

                </div>
                <a class="indexterm" name="idm140286791779472"></a><a class="indexterm" name="idm140286791777984"></a><p>
                When a master server shuts down and restarts, its
                <a class="link" href="storage-engines.html#memory-storage-engine" title="15.3&nbsp;The MEMORY Storage Engine"><code class="literal">MEMORY</code></a> tables become empty. To
                replicate this effect to slaves, the first time that the master
                uses a given <a class="link" href="storage-engines.html#memory-storage-engine" title="15.3&nbsp;The MEMORY Storage Engine"><code class="literal">MEMORY</code></a> table after
                startup, it logs an event that notifies slaves that the table
                must be emptied by writing a
                <a class="link" href="sql-syntax.html#delete" title="13.2.2&nbsp;DELETE Syntax"><code class="literal">DELETE</code></a> statement for that table
                to the binary log. This generated event is identifiable by a
                comment in the binary log, and if GTIDs are in use on the
                server, it has a GTID assigned.
            </p><p style="color:blue;">当主服务器关闭并重新启动时，其内存表将变为空。要将此效果复制到从服务器，在主服务器启动后第一次使用给定的内存表时，它会记录一个事件，通知从服务器必须通过将该表的delete语句写入二进制日志来清空该表。此生成的事件可以通过二进制日志中的注释来标识，如果服务器上正在使用gtid，则会分配gtid。</p><p>
                When a slave server shuts down and restarts, its
                <a class="link" href="storage-engines.html#memory-storage-engine" title="15.3&nbsp;The MEMORY Storage Engine"><code class="literal">MEMORY</code></a> tables become empty. This
                causes the slave to be out of synchrony with the master and may
                lead to other failures or cause the slave to stop:
            </p><p style="color:blue;">当从属服务器关闭并重新启动时，其内存表将变为空。这会导致从机与主机不同步，并可能导致其他故障或导致从机停止：</p>
                <div class="itemizedlist">
                    <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                        Row-format updates and deletes received from the master may
                        fail with <code class="literal">Can't find record in
                        '<em class="replaceable"><code>memory_table</code></em>'</code>.
                    </p><p style="color:blue;">从主机接收的行格式更新和删除可能失败，在“内存表”中找不到记录。</p></li><li class="listitem"><p>
                        Statements such as
                        <a class="link" href="sql-syntax.html#insert-select" title="13.2.5.1&nbsp;INSERT ... SELECT Syntax"><code class="literal">INSERT INTO
                            ... SELECT FROM
                            <em class="replaceable"><code>memory_table</code></em></code></a> may insert
                        a different set of rows on the master and slave.
                    </p><p style="color:blue;">语句，如插入到…select from memory_table可以在主从机上插入一组不同的行。</p></li></ul>
                </div>
                <p>
                    The safe way to restart a slave that is replicating
                    <a class="link" href="storage-engines.html#memory-storage-engine" title="15.3&nbsp;The MEMORY Storage Engine"><code class="literal">MEMORY</code></a> tables is to first drop or
                    delete all rows from the <a class="link" href="storage-engines.html#memory-storage-engine" title="15.3&nbsp;The MEMORY Storage Engine"><code class="literal">MEMORY</code></a>
                    tables on the master and wait until those changes have
                    replicated to the slave. Then it is safe to restart the slave.
                </p><p style="color:blue;">重新启动复制内存表的从机的安全方法是，首先从主机上的内存表中删除所有行，然后等待这些更改复制到从机。那么重启从机是安全的。</p><p>
                An alternative restart method may apply in some cases. When
                <a class="link" href="replication.html#sysvar_binlog_format"><code class="literal">binlog_format=ROW</code></a>, you can
                prevent the slave from stopping if you set
                <a class="link" href="replication.html#sysvar_slave_exec_mode"><code class="literal">slave_exec_mode=IDEMPOTENT</code></a>
                before you start the slave again. This allows the slave to
                continue to replicate, but its
                <a class="link" href="storage-engines.html#memory-storage-engine" title="15.3&nbsp;The MEMORY Storage Engine"><code class="literal">MEMORY</code></a> tables will still be
                different from those on the master. This can be okay if the
                application logic is such that the contents of
                <a class="link" href="storage-engines.html#memory-storage-engine" title="15.3&nbsp;The MEMORY Storage Engine"><code class="literal">MEMORY</code></a> tables can be safely lost
                (for example, if the <a class="link" href="storage-engines.html#memory-storage-engine" title="15.3&nbsp;The MEMORY Storage Engine"><code class="literal">MEMORY</code></a> tables
                are used for caching).
                <a class="link" href="replication.html#sysvar_slave_exec_mode"><code class="literal">slave_exec_mode=IDEMPOTENT</code></a>
                applies globally to all tables, so it may hide other replication
                errors in non-<a class="link" href="storage-engines.html#memory-storage-engine" title="15.3&nbsp;The MEMORY Storage Engine"><code class="literal">MEMORY</code></a> tables.
            </p><p style="color:blue;">在某些情况下，可以采用另一种重启方法。当binlog_format=row时，如果在再次启动从机之前将slave_exec_mode=idempotent设置为slave，则可以防止从机停止。这允许从机继续复制，但其内存表仍将与主机上的内存表不同。如果应用程序逻辑使得内存表的内容可以安全地丢失（例如，如果内存表用于缓存），则可以这样做。slave_exec_mode=idempotent全局应用于所有表，因此它可能隐藏非内存表中的其他复制错误。</p><p>
                (The method just described is not applicable in NDB Cluster,
                where <a class="link" href="replication.html#sysvar_slave_exec_mode"><code class="literal">slave_exec_mode</code></a> is always
                <code class="literal">IDEMPOTENT</code>, and cannot be changed.)
            </p><p style="color:blue;">（刚才描述的方法不适用于ndb集群，在ndb集群中，slave_exec_模式始终是等幂的，并且不能更改。）</p><p>
                The size of <a class="link" href="storage-engines.html#memory-storage-engine" title="15.3&nbsp;The MEMORY Storage Engine"><code class="literal">MEMORY</code></a> tables is
                limited by the value of the
                <a class="link" href="server-administration.html#sysvar_max_heap_table_size"><code class="literal">max_heap_table_size</code></a> system
                variable, which is not replicated (see
                <a class="xref" href="replication.html#replication-features-variables" title="16.4.1.37&nbsp;Replication and Variables">Section&nbsp;16.4.1.37, “Replication and Variables”</a>). A change in
                <code class="literal">max_heap_table_size</code> takes effect for
                <code class="literal">MEMORY</code> tables that are created or updated
                using <a class="link" href="sql-syntax.html#alter-table" title="13.1.8&nbsp;ALTER TABLE Syntax"><code class="literal">ALTER TABLE
                ... ENGINE = MEMORY</code></a> or <a class="link" href="sql-syntax.html#truncate-table" title="13.1.34&nbsp;TRUNCATE TABLE Syntax"><code class="literal">TRUNCATE
                TABLE</code></a> following the change, or for all
                <a class="link" href="storage-engines.html#memory-storage-engine" title="15.3&nbsp;The MEMORY Storage Engine"><code class="literal">MEMORY</code></a> tables following a server
                restart. If you increase the value of this variable on the
                master without doing so on the slave, it becomes possible for a
                table on the master to grow larger than its counterpart on the
                slave, leading to inserts that succeed on the master but fail on
                the slave with <span class="errortext">Table is full</span> errors. This
                is a known issue (Bug #48666). In such cases, you must set the
                global value of
                <a class="link" href="server-administration.html#sysvar_max_heap_table_size"><code class="literal">max_heap_table_size</code></a> on the
                slave as well as on the master, then restart replication. It is
                also recommended that you restart both the master and slave
                MySQL servers, to insure that the new value takes complete
                (global) effect on each of them.
            </p><p style="color:blue;">内存表的大小受未复制的max_heap_table_size系统变量的值限制（请参阅第16.4.1.37节“复制和变量”）。最大堆表大小的更改对使用alter table创建或更新的内存表生效…引擎=更改后的内存或截断表，或服务器重新启动后的所有内存表。如果不在从机上增加此变量的值，则主机上的表可能会比从机上的对应表更大，从而导致插入在主机上成功但在从机上失败的表是完全错误的。这是一个已知问题（Bug 48666）。在这种情况下，必须在从机和主机上设置max_heap_table_size的全局值，然后重新启动复制。还建议您重新启动主和从mysql服务器，以确保新值对每个服务器都产生完全（全局）影响。</p><p>
                See <a class="xref" href="storage-engines.html#memory-storage-engine" title="15.3&nbsp;The MEMORY Storage Engine">Section&nbsp;15.3, “The MEMORY Storage Engine”</a>, for more
                information about <a class="link" href="storage-engines.html#memory-storage-engine" title="15.3&nbsp;The MEMORY Storage Engine"><code class="literal">MEMORY</code></a> tables.
            </p><p style="color:blue;">有关内存表的更多信息，请参阅第15.3节“内存存储引擎”。</p>
            </div>
            <div class="section">
                <div class="titlepage">
                    <div>
                        <div>
                            <h4 class="title"><a name="replication-features-mysqldb"></a>16.4.1.21&nbsp;Replication of the mysql System Database</h4>

                        </div>

                    </div>

                </div>
                <a class="indexterm" name="idm140286791735072"></a><a class="indexterm" name="idm140286791733616"></a><a class="indexterm" name="idm140286791732128"></a><a class="indexterm" name="idm140286791730640"></a><p>
                Data modification statements made to tables in the
                <code class="literal">mysql</code> database are replicated according to
                the value of <a class="link" href="replication.html#sysvar_binlog_format"><code class="literal">binlog_format</code></a>; if
                this value is <code class="literal">MIXED</code>, these statements are
                replicated using row-based format. However, statements that
                would normally update this information indirectly—such
                <a class="link" href="sql-syntax.html#grant" title="13.7.1.4&nbsp;GRANT Syntax"><code class="literal">GRANT</code></a>,
                <a class="link" href="sql-syntax.html#revoke" title="13.7.1.6&nbsp;REVOKE Syntax"><code class="literal">REVOKE</code></a>, and statements
                manipulating triggers, stored routines, and views—are
                replicated to slaves using statement-based replication.
            </p><p style="color:blue;">对mysql数据库中的表所做的数据修改语句将根据binlog_format的值进行复制；如果该值是混合的，则这些语句将使用基于行的格式进行复制。但是，通常会间接更新此信息的语句（例如，GRANT、REVOKE和操作触发器、存储例程和视图的语句）将使用基于语句的复制复制复制到从机。</p>
            </div>
            <div class="section">
                <div class="titlepage">
                    <div>
                        <div>
                            <h4 class="title"><a name="replication-features-optimizer"></a>16.4.1.22&nbsp;Replication and the Query Optimizer</h4>

                        </div>

                    </div>

                </div>
                <a class="indexterm" name="idm140286791721552"></a><a class="indexterm" name="idm140286791720064"></a><p>
                It is possible for the data on the master and slave to become
                different if a statement is written in such a way that the data
                modification is nondeterministic; that is, left up the query
                optimizer. (In general, this is not a good practice, even
                outside of replication.) Examples of nondeterministic statements
                include <a class="link" href="sql-syntax.html#delete" title="13.2.2&nbsp;DELETE Syntax"><code class="literal">DELETE</code></a> or
                <a class="link" href="sql-syntax.html#update" title="13.2.11&nbsp;UPDATE Syntax"><code class="literal">UPDATE</code></a> statements that use
                <code class="literal">LIMIT</code> with no <code class="literal">ORDER BY</code>
                clause; see <a class="xref" href="replication.html#replication-features-limit" title="16.4.1.17&nbsp;Replication and LIMIT">Section&nbsp;16.4.1.17, “Replication and LIMIT”</a>, for a
                detailed discussion of these.
            </p><p style="color:blue;">如果语句的编写方式使得数据修改是不确定的，那么主服务器和从服务器上的数据可能会不同；也就是说，查询优化器是不确定的。（一般来说，这不是一个好的实践，即使是在复制之外）不确定语句的示例包括使用无ORDER BY子句的LIMIT的DELETE或UPDATE语句；有关这些语句的详细讨论，请参见第16.4.1.17节“复制和限制”。</p>
            </div>
            <div class="section">
                <div class="titlepage">
                    <div>
                        <div>
                            <h4 class="title"><a name="replication-features-partitioning"></a>16.4.1.23&nbsp;Replication and Partitioning</h4>

                        </div>

                    </div>

                </div>
                <a class="indexterm" name="idm140286791711936"></a><a class="indexterm" name="idm140286791710448"></a><p>
                Replication is supported between partitioned tables as long as
                they use the same partitioning scheme and otherwise have the
                same structure except where an exception is specifically allowed
                (see <a class="xref" href="replication.html#replication-features-differing-tables" title="16.4.1.10&nbsp;Replication with Differing Table Definitions on Master and Slave">Section&nbsp;16.4.1.10, “Replication with Differing Table Definitions on Master and Slave”</a>).
            </p><p style="color:blue;">分区表之间支持复制，只要它们使用相同的分区方案，或者具有相同的结构，除非特别允许出现异常（请参阅16.4.1.10节，“在主表和从表上使用不同表定义的复制”）。</p><p>
                Replication between tables having different partitioning is
                generally not supported. This because statements (such as
                <a class="link" href="sql-syntax.html#alter-table-partition-operations" title="13.1.8.1&nbsp;ALTER TABLE Partition Operations"><code class="literal">ALTER
                    TABLE ... DROP PARTITION</code></a>) acting directly on
                partitions in such cases may produce different results on master
                and slave. In the case where a table is partitioned on the
                master but not on the slave, any statements operating on
                partitions on the master's copy of the slave fail on the
                slave. When the slave's copy of the table is partitioned
                but the master's copy is not, statements acting on
                partitions cannot be run on the master without causing errors
                there.
            </p><p style="color:blue;">通常不支持具有不同分区的表之间的复制。这是因为语句（如alter table…在这种情况下直接作用于分区上的分区可能对主从产生不同的结果。如果表是在主服务器上分区的，而不是在从服务器上分区，那么在从服务器的主服务器副本上的分区上操作的任何语句都会在从服务器上失败。当表的从机副本被分区但主机副本没有分区时，在分区上操作的语句不能在主机上运行而不会在主机上导致错误。</p><p>
                Due to these dangers of causing replication to fail entirely (on
                account of failed statements) and of inconsistencies (when the
                result of a partition-level SQL statement produces different
                results on master and slave), we recommend that insure that the
                partitioning of any tables to be replicated from the master is
                matched by the slave's versions of these tables.
            </p><p style="color:blue;">由于这些危险会导致复制完全失败（由于语句失败）和不一致（当分区级sql语句的结果在master和slave上产生不同的结果时），我们建议确保要从主表复制的任何表的分区与这些表的从表版本匹配。</p>
            </div>
            <div class="section">
                <div class="titlepage">
                    <div>
                        <div>
                            <h4 class="title"><a name="replication-features-repair-table"></a>16.4.1.24&nbsp;Replication and REPAIR TABLE</h4>

                        </div>

                    </div>

                </div>
                <a class="indexterm" name="idm140286791703216"></a><a class="indexterm" name="idm140286791701712"></a><p>
                When used on a corrupted or otherwise damaged table, it is
                possible for the <a class="link" href="sql-syntax.html#repair-table" title="13.7.2.5&nbsp;REPAIR TABLE Syntax"><code class="literal">REPAIR TABLE</code></a>
                statement to delete rows that cannot be recovered. However, any
                such modifications of table data performed by this statement are
                not replicated, which can cause master and slave to lose
                synchronization. For this reason, in the event that a table on
                the master becomes damaged and you use
                <a class="link" href="sql-syntax.html#repair-table" title="13.7.2.5&nbsp;REPAIR TABLE Syntax"><code class="literal">REPAIR TABLE</code></a> to repair it, you
                should first stop replication (if it is still running) before
                using <a class="link" href="sql-syntax.html#repair-table" title="13.7.2.5&nbsp;REPAIR TABLE Syntax"><code class="literal">REPAIR TABLE</code></a>, then
                afterward compare the master's and slave's copies of
                the table and be prepared to correct any discrepancies manually,
                before restarting replication.
            </p><p style="color:blue;">在损坏或其他损坏的表上使用时，repair table语句可以删除无法恢复的行。但是，此语句执行的任何此类表数据修改都不会被复制，这可能会导致主数据和从数据失去同步。因此，如果主服务器上的某个表损坏，而您使用repair table进行修复，则应先停止复制（如果它仍在运行），然后再使用repair table，然后比较主服务器和从服务器的表副本，并准备手动更正任何差异，在重新启动复制之前。</p>
            </div>
            <div class="section">
                <div class="titlepage">
                    <div>
                        <div>
                            <h4 class="title"><a name="replication-features-reserved-words"></a>16.4.1.25&nbsp;Replication and Reserved Words</h4>

                        </div>

                    </div>

                </div>
                <a class="indexterm" name="idm140286791694128"></a><a class="indexterm" name="idm140286791692640"></a><p>
                You can encounter problems when you attempt to replicate from an
                older master to a newer slave and you make use of identifiers on
                the master that are reserved words in the newer MySQL version
                running on the slave. An example of this is using a table column
                named <code class="literal">virtual</code> on a 5.6 master that is
                replicating to a 5.7 or higher slave because
                <code class="literal">VIRTUAL</code> is a reserved word beginning in MySQL
                5.7. Replication can fail in such cases with Error 1064
                <span class="errortext">You have an error in your SQL syntax...</span>,
                <span class="emphasis"><em>even if a database or table named using the reserved
        word or a table having a column named using the reserved word is
        excluded from replication</em></span>. This is due to the fact
                that each SQL event must be parsed by the slave prior to
                execution, so that the slave knows which database object or
                objects would be affected; only after the event is parsed can
                the slave apply any filtering rules defined by
                <a class="link" href="replication.html#option_mysqld_replicate-do-db"><code class="option">--replicate-do-db</code></a>,
                <a class="link" href="replication.html#option_mysqld_replicate-do-table"><code class="option">--replicate-do-table</code></a>,
                <a class="link" href="replication.html#option_mysqld_replicate-ignore-db"><code class="option">--replicate-ignore-db</code></a>, and
                <a class="link" href="replication.html#option_mysqld_replicate-ignore-table"><code class="option">--replicate-ignore-table</code></a>.
            </p><p style="color:blue;">当您试图从较旧的主服务器复制到较新的从服务器时，您可能会遇到一些问题，并且您使用主服务器上的标识符，这些标识符是在较新的mysql版本中在从服务器上运行的保留字。这方面的一个例子是在5.6主服务器上使用名为virtual的表列，该表列正在复制到5.7或更高版本的从服务器，因为virtual是以mysql 5.7开头的保留字。在这种情况下，复制可能会失败，出现错误1064 SQL语法中有错误…，即使使用保留字命名的数据库或表或使用保留字命名的列的表被排除在复制之外。这是因为在执行之前，每个SQL事件都必须由从属服务器解析，以便从属服务器知道哪些数据库对象会受到影响；只有在解析事件之后，从属服务器才能应用由--replicate do db，-replicate do table，-replicate ignore db和--replicate ignore table定义的任何筛选规则。</p><p>
                To work around the problem of database, table, or column names
                on the master which would be regarded as reserved words by the
                slave, do one of the following:
            </p><p style="color:blue;">若要解决主服务器上的数据库、表或列名（将被从服务器视为保留字）问题，请执行以下操作之一：</p>
                <div class="itemizedlist">
                    <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                        Use one or more <a class="link" href="sql-syntax.html#alter-table" title="13.1.8&nbsp;ALTER TABLE Syntax"><code class="literal">ALTER TABLE</code></a>
                        statements on the master to change the names of any database
                        objects where these names would be considered reserved words
                        on the slave, and change any SQL statements that use the old
                        names to use the new names instead.
                    </p><p style="color:blue;">在主服务器上使用一个或多个alter table语句更改任何数据库对象的名称，这些名称将被视为从服务器上的保留字，并更改任何使用旧名称的sql语句以使用新名称。</p></li><li class="listitem"><p>
                        In any SQL statements using these database object names,
                        write the names as quoted identifiers using backtick
                        characters (<code class="literal">`</code>).
                    </p><p style="color:blue;">在使用这些数据库对象名的任何SQL语句中，使用倒勾字符（`）将名称作为带引号的标识符写入。</p></li></ul>
                </div>
                <p>
                    For listings of reserved words by MySQL version, see
                    <a class="ulink" href="http://dev.mysql.com/doc/mysqld-version-reference/en/mysqld-version-reference-optvar.html" target="_top">Reserved
                        Words</a>, in the <em class="citetitle">MySQL Server Version
                    Reference</em>. For identifier quoting rules, see
                    <a class="xref" href="language-structure.html#identifiers" title="9.2&nbsp;Schema Object Names">Section&nbsp;9.2, “Schema Object Names”</a>.
                </p><p style="color:blue;">有关MySQL版本保留字的列表，请参阅MySQL Server版本参考中的保留字。有关标识符引用规则，请参见第9.2节“架构对象名称”。</p>
            </div>
            <div class="section">
                <div class="titlepage">
                    <div>
                        <div>
                            <h4 class="title"><a name="replication-features-shutdowns"></a>16.4.1.26&nbsp;Replication and Master or Slave Shutdowns</h4>

                        </div>

                    </div>

                </div>
                <a class="indexterm" name="idm140286791674800"></a><a class="indexterm" name="idm140286791673312"></a><a class="indexterm" name="idm140286791671824"></a><a class="indexterm" name="idm140286791670336"></a><p>
                It is safe to shut down a master server and restart it later.
                When a slave loses its connection to the master, the slave tries
                to reconnect immediately and retries periodically if that fails.
                The default is to retry every 60 seconds. This may be changed
                with the <a class="link" href="sql-syntax.html#change-master-to" title="13.4.2.1&nbsp;CHANGE MASTER TO Syntax"><code class="literal">CHANGE MASTER TO</code></a>
                statement. A slave also is able to deal with network
                connectivity outages. However, the slave notices the network
                outage only after receiving no data from the master for
                <a class="link" href="replication.html#sysvar_slave_net_timeout"><code class="literal">slave_net_timeout</code></a> seconds. If
                your outages are short, you may want to decrease
                <a class="link" href="replication.html#sysvar_slave_net_timeout"><code class="literal">slave_net_timeout</code></a>. See
                <a class="xref" href="replication.html#replication-solutions-unexpected-slave-halt" title="16.3.2&nbsp;Handling an Unexpected Halt of a Replication Slave">Section&nbsp;16.3.2, “Handling an Unexpected Halt of a Replication Slave”</a>.
            </p><p style="color:blue;">关闭主服务器并在以后重新启动它是安全的。当从机失去与主机的连接时，从机会立即尝试重新连接，如果连接失败，则会定期重试。默认值是每60秒重试一次。这可以用change master to语句更改。从机还能够处理网络连接中断。但是，从机只有在从机网络超时秒数没有从主机接收到数据后才注意到网络中断。如果停机时间较短，则可能需要减少从网络超时时间。请参阅16.3.2节，“处理复制从机的意外停止”。</p><p>
                An unclean shutdown (for example, a crash) on the master side
                can result in the master binary log having a final position less
                than the most recent position read by the slave, due to the
                master binary log file not being flushed. This can cause the
                slave not to be able to replicate when the master comes back up.
                Setting
                <a class="link" href="replication.html#sysvar_sync_binlog"><code class="literal">sync_binlog=1</code></a> in the
                master <code class="filename">my.cnf</code> file helps to minimize this
                problem because it causes the master to flush its binary log
                more frequently. For the greatest possible durability and
                consistency in a replication setup using
                <code class="literal">InnoDB</code> with transactions, you should also set
                <a class="link" href="innodb-storage-engine.html#sysvar_innodb_flush_log_at_trx_commit"><code class="literal">innodb_flush_log_at_trx_commit=1</code></a>.
                With this setting, the contents of the <code class="literal">InnoDB</code>
                redo log buffer are written out to the log file at each
                transaction commit and the log file is flushed to disk. Note
                that the durability of transactions is still not guaranteed with
                this setting, because operating systems or disk hardware may
                tell <a class="link" href="programs.html#mysqld" title="4.3.1&nbsp;mysqld — The MySQL Server"><span class="command"><strong>mysqld</strong></span></a> that the flush-to-disk operation
                has taken place, even though it has not.
            </p><p style="color:blue;">由于主二进制日志文件未被刷新，主二进制日志的最终位置可能小于从二进制日志读取的最新位置（例如，崩溃）。这可能导致从机在主机恢复时无法复制。在master my.cnf文件中设置sync_binlog=1有助于最小化此问题，因为它会导致主机更频繁地刷新其二进制日志。为了在使用innodb with transactions的复制设置中获得最大的持久性和一致性，还应该将innodb_flush_log_设置为_trx_commit=1。通过这个设置，InnoDB重做日志缓冲区的内容在每次事务提交时都会被写到日志文件中，并且日志文件会被刷新到磁盘。请注意，使用此设置仍然无法保证事务的持久性，因为操作系统或磁盘硬件可能会告诉mysqld已执行了磁盘刷新操作，即使它尚未执行。</p><p>
                Shutting down a slave cleanly is safe because it keeps track of
                where it left off. However, be careful that the slave does not
                have temporary tables open; see
                <a class="xref" href="replication.html#replication-features-temptables" title="16.4.1.29&nbsp;Replication and Temporary Tables">Section&nbsp;16.4.1.29, “Replication and Temporary Tables”</a>. Unclean
                shutdowns might produce problems, especially if the disk cache
                was not flushed to disk before the problem occurred:
            </p><p style="color:blue;">干净地关闭一个从属服务器是安全的，因为它可以跟踪它关闭的位置。但是，请注意从机没有打开临时表；请参阅第16.4.1.29节“复制和临时表”。不干净的关机可能会产生问题，特别是在出现问题之前没有将磁盘缓存刷新到磁盘：</p>
                <div class="itemizedlist">
                    <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                        For transactions, the slave commits and then updates
                        <code class="filename">relay-log.info</code>. If a crash occurs
                        between these two operations, relay log processing will have
                        proceeded further than the information file indicates and
                        the slave will re-execute the events from the last
                        transaction in the relay log after it has been restarted.
                    </p><p style="color:blue;">对于事务，从服务器提交并更新relay-log.info。如果这两个操作之间发生崩溃，中继日志处理将比信息文件指示的更进一步，并且从服务器将在中继日志中的最后一个事务重新启动后重新执行事件。</p></li><li class="listitem"><p>
                        A similar problem can occur if the slave updates
                        <code class="filename">relay-log.info</code> but the server host
                        crashes before the write has been flushed to disk. To
                        minimize the chance of this occurring, set
                        <a class="link" href="replication.html#sysvar_sync_relay_log_info"><code class="literal">sync_relay_log_info=1</code></a> in
                        the slave <code class="filename">my.cnf</code> file. Setting
                        <a class="link" href="replication.html#sysvar_sync_relay_log_info"><code class="literal">sync_relay_log_info</code></a> to 0
                        causes no writes to be forced to disk and the server relies
                        on the operating system to flush the file from time to time.
                    </p><p style="color:blue;">如果从机更新relay-log.info，但服务器主机在写入磁盘之前崩溃，则可能会出现类似的问题。要将发生这种情况的可能性降至最低，请在slave my.cnf文件中设置sync_relay_log_info=1。将sync_relay_log_info设置为0不会强制写入磁盘，服务器依赖于操作系统不时刷新文件。</p></li></ul>
                </div>
                <p>
                    The fault tolerance of your system for these types of problems
                    is greatly increased if you have a good uninterruptible power
                    supply.
                </p><p style="color:blue;">如果您有一个良好的不间断电源，您的系统对这些类型的问题的容错能力将大大提高。</p>
            </div>
            <div class="section">
                <div class="titlepage">
                    <div>
                        <div>
                            <h4 class="title"><a name="replication-features-slaveerrors"></a>16.4.1.27&nbsp;Slave Errors During Replication</h4>

                        </div>

                    </div>

                </div>
                <a class="indexterm" name="idm140286791645504"></a><a class="indexterm" name="idm140286791644016"></a><a class="indexterm" name="idm140286791642528"></a><a class="indexterm" name="idm140286791641040"></a><p>
                If a statement produces the same error (identical error code) on
                both the master and the slave, the error is logged, but
                replication continues.
            </p><p style="color:blue;">如果一条语句在主服务器和从服务器上都产生相同的错误（相同的错误代码），则会记录该错误，但复制将继续。</p><p>
                If a statement produces different errors on the master and the
                slave, the slave SQL thread terminates, and the slave writes a
                message to its error log and waits for the database
                administrator to decide what to do about the error. This
                includes the case that a statement produces an error on the
                master or the slave, but not both. To address the issue, connect
                to the slave manually and determine the cause of the problem.
                <a class="link" href="sql-syntax.html#show-slave-status" title="13.7.5.34&nbsp;SHOW SLAVE STATUS Syntax"><code class="literal">SHOW SLAVE STATUS</code></a> is useful for
                this. Then fix the problem and run <a class="link" href="sql-syntax.html#start-slave" title="13.4.2.6&nbsp;START SLAVE Syntax"><code class="literal">START
                SLAVE</code></a>. For example, you might need to create a
                nonexistent table before you can start the slave again.

            </p><p style="color:blue;">如果一条语句在主从机上产生不同的错误，则从机sql线程终止，从机将一条消息写入其错误日志，并等待数据库管理员决定如何处理该错误。这包括一个语句在主从机上产生错误的情况，但不能同时在主从机上产生错误。要解决此问题，请手动连接到从属服务器并确定问题的原因。显示从属状态对此很有用。然后解决问题并运行start slave。例如，在重新启动奴隶之前，您可能需要创建一个不存在的表。</p>
                <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">

                    <div class="admon-title">
                        Note
                    </div>
                    <p>
                        If a temporary error is recorded in the slave's error log,
                        you do not necessarily have to take any action suggested in
                        the quoted error message. Temporary errors should be handled
                        by the client retrying the transaction. For example, if the
                        slave SQL thread records a temporary error relating to a
                        deadlock, you do not need to restart the transaction
                        manually on the slave, unless the slave SQL thread
                        subsequently terminates with a nontemporary error message.
                    </p><p style="color:blue;">如果一个临时错误记录在从机的错误日志中，则不一定要执行引用的错误消息中建议的任何操作。临时错误应由重新尝试事务的客户端处理。例如，如果从属sql线程记录了与死锁相关的临时错误，则不需要在从属sql线程上手动重新启动事务，除非从属sql线程随后以非临时错误消息终止。</p>
                </div>
                <p>
                </p><p>
                If this error code validation behavior is not desirable, some or
                all errors can be masked out (ignored) with the
                <a class="link" href="replication.html#option_mysqld_slave-skip-errors"><code class="option">--slave-skip-errors</code></a> option.
            </p><p style="color:blue;">如果不需要此错误代码验证行为，可以使用--slave skip errors选项屏蔽（忽略）部分或所有错误。</p><p>
                For nontransactional storage engines such as
                <code class="literal">MyISAM</code>, it is possible to have a statement
                that only partially updates a table and returns an error code.
                This can happen, for example, on a multiple-row insert that has
                one row violating a key constraint, or if a long update
                statement is killed after updating some of the rows. If that
                happens on the master, the slave expects execution of the
                statement to result in the same error code. If it does not, the
                slave SQL thread stops as described previously.
            </p><p style="color:blue;">对于非事务性存储引擎（如myisam），可以有一个只更新部分表并返回错误代码的语句。例如，在一行违反键约束的多行插入中，或者在更新某些行后终止长update语句时，可能会发生这种情况。如果这种情况发生在主服务器上，则从服务器希望语句的执行会导致相同的错误代码。如果没有，则从sql线程将停止，如前所述。</p><p>
                If you are replicating between tables that use different storage
                engines on the master and slave, keep in mind that the same
                statement might produce a different error when run against one
                version of the table, but not the other, or might cause an error
                for one version of the table, but not the other. For example,
                since <code class="literal">MyISAM</code> ignores foreign key constraints,
                an <a class="link" href="sql-syntax.html#insert" title="13.2.5&nbsp;INSERT Syntax"><code class="literal">INSERT</code></a> or
                <a class="link" href="sql-syntax.html#update" title="13.2.11&nbsp;UPDATE Syntax"><code class="literal">UPDATE</code></a> statement accessing an
                <code class="literal">InnoDB</code> table on the master might cause a
                foreign key violation but the same statement performed on a
                <code class="literal">MyISAM</code> version of the same table on the slave
                would produce no such error, causing replication to stop.
            </p><p style="color:blue;">如果要在主从机上使用不同存储引擎的表之间进行复制，请记住，当对一个版本的表（而不是另一个版本）运行同一语句时，可能会产生不同的错误，或者可能会对一个版本的表（而不是另一个版本）造成错误。例如，由于myisam忽略外键约束，一个insert或update语句访问主机上的innodb表可能会导致外键冲突，但是在从机上同一个表的myisam版本上执行的相同语句不会产生这样的错误，从而导致复制停止。</p>
            </div>
            <div class="section">
                <div class="titlepage">
                    <div>
                        <div>
                            <h4 class="title"><a name="replication-features-sql-mode"></a>16.4.1.28&nbsp;Replication and Server SQL Mode</h4>

                        </div>

                    </div>

                </div>
                <a class="indexterm" name="idm140286791623968"></a><a class="indexterm" name="idm140286791622480"></a><a class="indexterm" name="idm140286791620992"></a><a class="indexterm" name="idm140286791619504"></a><a class="indexterm" name="idm140286791618016"></a><a class="indexterm" name="idm140286791616528"></a><p>
                Using different server SQL mode settings on the master and the
                slave may cause the same <a class="link" href="sql-syntax.html#insert" title="13.2.5&nbsp;INSERT Syntax"><code class="literal">INSERT</code></a>
                statements to be handled differently on the master and the
                slave, leading the master and slave to diverge. For best
                results, you should always use the same server SQL mode on the
                master and on the slave. This advice applies whether you are
                using statement-based or row-based replication.
            </p><p style="color:blue;">在主服务器和从服务器上使用不同的服务器SQL模式设置可能会导致主服务器和从服务器上处理相同的INSERT语句的方式不同，从而导致主服务器和从服务器出现分歧。为了获得最佳结果，您应该始终在主服务器和从服务器上使用相同的服务器sql模式。无论您使用的是基于语句的复制还是基于行的复制，此建议都适用。</p><p>
                If you are replicating partitioned tables, using different SQL
                modes on the master and the slave is likely to cause issues. At
                a minimum, this is likely to cause the distribution of data
                among partitions to be different in the master's and slave's
                copies of a given table. It may also cause inserts into
                partitioned tables that succeed on the master to fail on the
                slave.
            </p><p style="color:blue;">如果要复制分区表，则在主表和从表上使用不同的SQL模式可能会导致问题。至少，这可能会导致给定表的主副本和从副本中分区之间的数据分布不同。它还可能导致插入到分区表中的操作在主表上成功，而在从表上失败。</p><p>
                For more information, see <a class="xref" href="server-administration.html#sql-mode" title="5.1.10&nbsp;Server SQL Modes">Section&nbsp;5.1.10, “Server SQL Modes”</a>. In
                particular, see <a class="xref" href="server-administration.html#sql-mode-changes" title="SQL Mode Changes in MySQL 5.7">SQL Mode Changes in MySQL 5.7</a>, which
                describes changes in MySQL 5.7, so that you can assess whether
                your applications will be affected.
            </p><p style="color:blue;">有关更多信息，请参阅第5.1.10节“服务器SQL模式”。特别是，请参阅mysql 5.7中的sql模式更改，其中描述了mysql 5.7中的更改，以便您可以评估应用程序是否会受到影响。</p>
            </div>
            <div class="section">
                <div class="titlepage">
                    <div>
                        <div>
                            <h4 class="title"><a name="replication-features-temptables"></a>16.4.1.29&nbsp;Replication and Temporary Tables</h4>

                        </div>

                    </div>

                </div>
                <a class="indexterm" name="idm140286791608928"></a><a class="indexterm" name="idm140286791607472"></a><a class="indexterm" name="idm140286791605984"></a><p>
                The discussion in the following paragraphs does not apply when
                <a class="link" href="replication.html#sysvar_binlog_format"><code class="literal">binlog_format=ROW</code></a> because, in
                that case, temporary tables are not replicated; this means that
                there are never any temporary tables on the slave to be lost in
                the event of an unplanned shutdown by the slave. The remainder
                of this section applies only when using statement-based or
                mixed-format replication. Loss of replicated temporary tables on
                the slave can be an issue, whenever
                <a class="link" href="replication.html#sysvar_binlog_format"><code class="literal">binlog_format</code></a> is
                <code class="literal">STATEMENT</code> or <code class="literal">MIXED</code>, for
                statements involving temporary tables that can be logged safely
                using statement-based format. For more information about
                row-based replication and temporary tables, see
                <a class="xref" href="replication.html#replication-rbr-usage-temptables" title="Row-based logging of temporary tables">Row-based logging of temporary tables</a>.
            </p><p style="color:blue;">当binlog_format=row时，以下段落中的讨论不适用，因为在这种情况下，不会复制临时表；这意味着在从属服务器意外关闭时，从属服务器上永远不会丢失任何临时表。本节的其余部分仅适用于使用基于语句或混合格式复制的情况。当binlog_格式为statement或mixed时，对于涉及可以使用基于语句的格式安全记录的临时表的语句，在从机上丢失复制的临时表可能是一个问题。有关基于行的复制和临时表的详细信息，请参阅临时表的基于行的日志记录。</p><p><b>Safe slave shutdown when using temporary tables.&nbsp;</b>
                Temporary tables are replicated except in the case where you
                stop the slave server (not just the slave threads) and you
                have replicated temporary tables that are open for use in
                updates that have not yet been executed on the slave. If you
                stop the slave server, the temporary tables needed by those
                updates are no longer available when the slave is restarted.
                To avoid this problem, do not shut down the slave while it has
                temporary tables open. Instead, use the following procedure:
            </p><p style="color:blue;">使用临时表时安全从机关机。临时表将被复制，除非您停止从服务器（而不仅仅是从线程），并且您复制了在尚未在从服务器上执行的更新中使用的打开的临时表。如果停止从属服务器，则在重新启动从属服务器时，这些更新所需的临时表不再可用。要避免此问题，请不要在从属服务器打开临时表时关闭它。相反，使用以下步骤：</p>
                <div class="orderedlist">
                    <ol class="orderedlist" type="1"><li class="listitem"><p>
                        Issue a <code class="literal">STOP SLAVE SQL_THREAD</code> statement.
                    </p><p style="color:blue;">发出stop slave sql_thread语句。</p></li><li class="listitem"><p>
                        Use <a class="link" href="sql-syntax.html#show-status" title="13.7.5.35&nbsp;SHOW STATUS Syntax"><code class="literal">SHOW STATUS</code></a> to check the
                        value of the
                        <a class="link" href="server-administration.html#statvar_Slave_open_temp_tables"><code class="literal">Slave_open_temp_tables</code></a>
                        variable.
                    </p><p style="color:blue;">使用show status检查slave_open_temp_tables变量的值。</p></li><li class="listitem"><p>
                        If the value is not 0, restart the slave SQL thread with
                        <code class="literal">START SLAVE SQL_THREAD</code> and repeat the
                        procedure later.
                    </p><p style="color:blue;">如果该值不为0，请使用start slave sql_thread重新启动从属sql线程，稍后重复该过程。</p></li><li class="listitem"><p>
                        When the value is 0, issue a <a class="link" href="programs.html#mysqladmin" title="4.5.2&nbsp;mysqladmin — Client for Administering a MySQL Server"><span class="command"><strong>mysqladmin
            shutdown</strong></span></a> command to stop the slave.
                    </p><p style="color:blue;">当值为0时，发出mysqladmin shutdown命令以停止从机。</p></li></ol>
                </div>
                <p><b>Temporary tables and replication options.&nbsp;</b>
                    By default, all temporary tables are replicated; this happens
                    whether or not there are any matching
                    <a class="link" href="replication.html#option_mysqld_replicate-do-db"><code class="option">--replicate-do-db</code></a>,
                    <a class="link" href="replication.html#option_mysqld_replicate-do-table"><code class="option">--replicate-do-table</code></a>, or
                    <a class="link" href="replication.html#option_mysqld_replicate-wild-do-table"><code class="option">--replicate-wild-do-table</code></a>
                    options in effect. However, the
                    <a class="link" href="replication.html#option_mysqld_replicate-ignore-table"><code class="option">--replicate-ignore-table</code></a> and
                    <a class="link" href="replication.html#option_mysqld_replicate-wild-ignore-table"><code class="option">--replicate-wild-ignore-table</code></a>
                    options are honored for temporary tables. The exception is
                    that to enable correct removal of temporary tables at the end
                    of a session, a replication slave always replicates a
                    <code class="literal">DROP TEMPORARY TABLE IF EXISTS</code> statement,
                    regardless of any exclusion rules that would normally apply
                    for the specified table.
                </p><p style="color:blue;">临时表和复制选项。默认情况下，所有临时表都会被复制；无论是否有任何匹配的--replicate do db，-replicate do table或--replicate wild do table选项生效，都会发生这种情况。但是，对于临时表，可以使用--replicate ignore table和--replicate wild ignore table选项。例外情况是，为了在会话结束时正确删除临时表，复制从机总是复制DROP临时表if exists语句，而不管通常应用于指定表的任何排除规则如何。</p><p>
                A recommended practice when using statement-based or
                mixed-format replication is to designate a prefix for exclusive
                use in naming temporary tables that you do not want replicated,
                then employ a
                <a class="link" href="replication.html#option_mysqld_replicate-wild-ignore-table"><code class="option">--replicate-wild-ignore-table</code></a>
                option to match that prefix. For example, you might give all
                such tables names beginning with <code class="literal">norep</code> (such
                as <code class="literal">norepmytable</code>,
                <code class="literal">norepyourtable</code>, and so on), then use
                <a class="link" href="replication.html#option_mysqld_replicate-wild-ignore-table"><code class="option">--replicate-wild-ignore-table=norep%</code></a>
                to prevent them from being replicated.
            </p><p style="color:blue;">使用基于语句或混合格式的复制时，建议您指定一个前缀，以便在命名不希望复制的临时表时独占使用，然后使用--replicate wild ignore table选项来匹配该前缀。例如，您可以以norep开头给出所有此类表的名称（例如norepmytable、norepyourtable等等），然后使用--replicate wild ignore table=norep%来防止它们被复制。</p>
            </div>
            <div class="section">
                <div class="titlepage">
                    <div>
                        <div>
                            <h4 class="title"><a name="replication-features-timeout"></a>16.4.1.30&nbsp;Replication Retries and Timeouts</h4>

                        </div>

                    </div>

                </div>
                <a class="indexterm" name="idm140286791573568"></a><a class="indexterm" name="idm140286791572080"></a><a class="indexterm" name="idm140286791570592"></a><a class="indexterm" name="idm140286791569520"></a><a class="indexterm" name="idm140286791568032"></a><p>
                The global system variable
                <a class="link" href="replication.html#sysvar_slave_transaction_retries"><code class="literal">slave_transaction_retries</code></a>
                affects replication as follows: If the slave SQL thread fails to
                execute a transaction because of an <code class="literal">InnoDB</code>
                deadlock or because it exceeded the <code class="literal">InnoDB</code>
                <a class="link" href="innodb-storage-engine.html#sysvar_innodb_lock_wait_timeout"><code class="literal">innodb_lock_wait_timeout</code></a> value,
                or the <a class="link" href="mysql-cluster.html" title="Chapter&nbsp;21&nbsp;MySQL NDB Cluster 7.5 and NDB Cluster 7.6"><code class="literal">NDB</code></a>
                <code class="literal">TransactionDeadlockDetectionTimeout</code> or
                <code class="literal">TransactionInactiveTimeout</code> value, the slave
                automatically retries the transaction
                <a class="link" href="replication.html#sysvar_slave_transaction_retries"><code class="literal">slave_transaction_retries</code></a> times
                before stopping with an error. The default value is 10. The
                total retry count can be seen in the output of
                <a class="link" href="sql-syntax.html#show-status" title="13.7.5.35&nbsp;SHOW STATUS Syntax"><code class="literal">SHOW STATUS</code></a>; see
                <a class="xref" href="server-administration.html#server-status-variables" title="5.1.9&nbsp;Server Status Variables">Section&nbsp;5.1.9, “Server Status Variables”</a>.
            </p><p style="color:blue;">全局系统变量slave_transaction_retries对复制的影响如下：如果slave sql线程由于innodb死锁或超过innodb innodb lock_wait_超时值或ndb transactiondeadlockdetectiontimeout或transactionactivetimeout值而无法执行事务，从机自动重试事务从机重试次，然后停止并出现错误。默认值为10。总重试次数可以在显示状态的输出中看到；请参阅第5.1.9节“服务器状态变量”。</p>
            </div>
            <div class="section">
                <div class="titlepage">
                    <div>
                        <div>
                            <h4 class="title"><a name="replication-features-timezone"></a>16.4.1.31&nbsp;Replication and Time Zones</h4>

                        </div>

                    </div>

                </div>
                <a class="indexterm" name="idm140286791555120"></a><a class="indexterm" name="idm140286791553632"></a><p>
                By default, master and slave servers assume that they are in the
                same time zone. If you are replicating between servers in
                different time zones, the time zone must be set on both master
                and slave. Otherwise, statements depending on the local time on
                the master are not replicated properly, such as statements that
                use the <a class="link" href="functions.html#function_now"><code class="literal">NOW()</code></a> or
                <a class="link" href="functions.html#function_from-unixtime"><code class="literal">FROM_UNIXTIME()</code></a> functions. Set
                the time zone in which MySQL server runs by using the
                <a class="link" href="programs.html#option_mysqld_safe_timezone"><code class="option">--timezone=<em class="replaceable"><code>timezone_name</code></em></code></a>
                option of the <code class="filename">mysqld_safe</code> script or by
                setting the <code class="literal">TZ</code> environment variable. See also
                <a class="xref" href="replication.html#replication-features-functions" title="16.4.1.15&nbsp;Replication and System Functions">Section&nbsp;16.4.1.15, “Replication and System Functions”</a>.
            </p><p style="color:blue;">默认情况下，主服务器和从服务器假定它们位于同一时区。如果要在不同时区的服务器之间进行复制，则必须在主服务器和从服务器上设置时区。否则，依赖于主服务器上本地时间的语句将无法正确复制，例如使用now（）或from unixtime（）函数的语句。通过使用mysqld_safe脚本的--time zone=timezone_name选项或通过设置tz环境变量来设置mysql服务器运行的时区。另见第16.4.1.15节“复制和系统功能”。</p>
            </div>
            <div class="section">
                <div class="titlepage">
                    <div>
                        <div>
                            <h4 class="title"><a name="replication-features-transaction-inconsistencies"></a>16.4.1.32&nbsp;Replication and Transaction Inconsistencies</h4>

                        </div>

                    </div>

                </div>
                <p>
                    Inconsistencies in the sequence of transactions that have been
                    executed from the relay log can occur depending on your
                    replication configuration. This section explains how to avoid
                    inconsistencies and solve any problems they cause.
                </p><p style="color:blue;">根据您的复制配置，从中继日志执行的事务序列可能会出现不一致。本节说明如何避免不一致并解决它们引起的任何问题。</p><p>
                The following types of inconsistencies can exist:
            </p><p style="color:blue;">以下类型的不一致可能存在：</p>
                <div class="itemizedlist">
                    <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                        <span class="emphasis"><em>Half-applied transactions</em></span>. A
                        transaction which updates non-transactional tables has
                        applied some but not all of its changes.
                    </p><p style="color:blue;">半应用的事务。更新非事务表的事务已应用了部分但不是全部更改。</p></li><li class="listitem"><p>
                        <span class="emphasis"><em>Gaps</em></span>. A gap is a transaction that has
                        not been fully applied, even though some transaction later
                        in the sequence has been applied. Gaps can only appear when
                        using a multithreaded slave. To avoid gaps occurring, set
                        <a class="link" href="replication.html#sysvar_slave_preserve_commit_order"><code class="literal">slave_preserve_commit_order=1</code></a>,
                        which requires
                        <a class="link" href="replication.html#sysvar_slave_parallel_type"><code class="literal">slave_parallel_type=LOGICAL_CLOCK</code></a>,
                        and that <a class="link" href="replication.html#sysvar_log_bin"><code class="literal">log-bin</code></a> and
                        <a class="link" href="replication.html#sysvar_log_slave_updates"><code class="literal">log-slave-updates</code></a> are also
                        enabled. Note that
                        <a class="link" href="replication.html#sysvar_slave_preserve_commit_order"><code class="literal">slave_preserve_commit_order=1</code></a>
                        does not preserve the order of non-transactional DML
                        updates, so these might commit before transactions that
                        precede them in the relay log, which might result in gaps.
                    </p><p style="color:blue;">差距。gap是一个尚未完全应用的事务，即使序列中的某些事务已应用。间隙只能在使用多线程从机时出现。为避免出现间隙，请设置slave_preserve_commit_order=1，这需要slave_parallel_type=logical_clock，并且还启用了日志bin和日志slave更新。请注意，slave_preserve_commit_order=1不保留非事务性dml更新的顺序，因此这些更新可能在中继日志中它们之前的事务之前提交，这可能会导致间隙。</p></li><li class="listitem"><p>
                        <span class="emphasis"><em>Master log position lag</em></span>. Even in the
                        absence of gaps, it is possible that transactions after
                        <code class="literal">Exec_master_log_pos</code> have been applied.
                        That is, all transactions up to point <code class="literal">N</code>
                        have been applied, and no transactions after
                        <code class="literal">N</code> have been applied, but
                        <code class="literal">Exec_master_log_pos</code> has a value smaller
                        than <code class="literal">N</code>. In this situation,
                        <code class="literal">Exec_master_log_pos</code> is a <span class="quote">“<span class="quote">low-water
            mark</span>”</span> of the transactions applied, and lags behind
                        the position of the most recently applied transaction. This
                        can only happen on multithreaded slaves. Enabling
                        <a class="link" href="replication.html#sysvar_slave_preserve_commit_order"><code class="literal">slave_preserve_commit_order</code></a>
                        does not prevent master log position lag.
                    </p><p style="color:blue;">主记录位置滞后。即使在没有间隙的情况下，也有可能应用exec_master_log_pos之后的事务。也就是说，截至n点的所有交易都已应用，且n之后没有交易应用，但exec_master_log_pos的值小于n。在这种情况下，exec_master_log_pos是所应用交易的“低水位线”，并且落后于最近应用的交易的位置。这只能在多线程从机上发生。启用slave_preserve_commit_order不会阻止主日志位置延迟。</p></li></ul>
                </div>
                <p>
                    The following scenarios are relevant to the existence of
                    half-applied transactions, gaps, and master log position lag:
                </p><p style="color:blue;">下面的场景与半应用事务、间隙和主日志位置滞后的存在有关：</p>
                <div class="orderedlist">
                    <ol class="orderedlist" type="1"><li class="listitem"><p>
                        While slave threads are running, there may be gaps and
                        half-applied transactions.
                    </p><p style="color:blue;">当从线程运行时，可能存在间隙和半应用的事务。</p></li><li class="listitem"><p>
                        <a class="link" href="programs.html#mysqld" title="4.3.1&nbsp;mysqld — The MySQL Server"><span class="command"><strong>mysqld</strong></span></a> shuts down. Both clean and unclean
                        shutdown abort ongoing transactions and may leave gaps and
                        half-applied transactions.
                    </p><p style="color:blue;">mysqld关闭。干净和不干净的关机都会中止正在进行的事务，并可能留下间隙和半应用的事务。</p></li><li class="listitem"><p>
                        <a class="link" href="sql-syntax.html#kill" title="13.7.6.4&nbsp;KILL Syntax"><code class="literal">KILL</code></a> of replication threads
                        (the SQL thread when using a single-threaded slave, the
                        coordinator thread when using a multithreaded slave). This
                        aborts ongoing transactions and may leave gaps and
                        half-applied transactions.
                    </p><p style="color:blue;">终止复制线程（使用单线程从线程时的SQL线程，使用多线程从线程时的协调线程）。这将中止正在进行的事务，并可能留下间隙和半应用的事务。</p></li><li class="listitem"><p>
                        Error in applier threads. This may leave gaps. If the error
                        is in a mixed transaction, that transaction is half-applied.
                        When using a multithreaded slave, workers which have not
                        received an error complete their queues, so it may take time
                        to stop all threads.
                    </p><p style="color:blue;">应用程序线程出错。这可能会留下空白。如果错误在混合事务中，则该事务将被应用一半。当使用多线程从机时，未收到错误的工作程序将完成其队列，因此可能需要时间来停止所有线程。</p></li><li class="listitem"><p>
                        <a class="link" href="sql-syntax.html#stop-slave" title="13.4.2.7&nbsp;STOP SLAVE Syntax"><code class="literal">STOP SLAVE</code></a> when using a
                        multithreaded slave. After issuing <a class="link" href="sql-syntax.html#stop-slave" title="13.4.2.7&nbsp;STOP SLAVE Syntax"><code class="literal">STOP
                        SLAVE</code></a>, the slave waits for any gaps to be filled
                        and then updates <code class="literal">Exec_master_log_pos</code>.
                        This ensures it never leaves gaps or master log position
                        lag, unless any of the cases above applies, in other words,
                        before <a class="link" href="sql-syntax.html#stop-slave" title="13.4.2.7&nbsp;STOP SLAVE Syntax"><code class="literal">STOP SLAVE</code></a> completes,
                        either an error happens, or another thread issues
                        <a class="link" href="sql-syntax.html#kill" title="13.7.6.4&nbsp;KILL Syntax"><code class="literal">KILL</code></a>, or the server restarts.
                        In these cases, <a class="link" href="sql-syntax.html#stop-slave" title="13.4.2.7&nbsp;STOP SLAVE Syntax"><code class="literal">STOP SLAVE</code></a>
                        returns successfully.
                    </p><p style="color:blue;">使用多线程从机时停止从机。在发出stop slave命令后，slave将等待填补任何空白，然后更新exec_master_log_pos。这将确保它不会留下空白或主日志位置延迟，除非上述任何情况适用，换句话说，在stop slave完成之前，发生错误或其他线程发出kill命令，或者服务器重新启动。在这些情况下，stop slave返回成功。</p></li><li class="listitem"><p>
                        If the last transaction in the relay log is only
                        half-received and the multithreaded slave coordinator has
                        started to schedule the transaction to a worker, then
                        <a class="link" href="sql-syntax.html#stop-slave" title="13.4.2.7&nbsp;STOP SLAVE Syntax"><code class="literal">STOP SLAVE</code></a> waits up to 60
                        seconds for the transaction to be received. After this
                        timeout, the coordinator gives up and aborts the
                        transaction. If the transaction is mixed, it may be left
                        half-completed.
                    </p><p style="color:blue;">如果中继日志中的最后一个事务仅接收到一半，并且多线程从属协调器已开始将该事务调度给工作进程，则停止从属将等待60秒以接收该事务。在此超时之后，协调器将放弃并中止事务。如果事务是混合的，则可能只完成一半。</p></li><li class="listitem"><p>
                        <a class="link" href="sql-syntax.html#stop-slave" title="13.4.2.7&nbsp;STOP SLAVE Syntax"><code class="literal">STOP SLAVE</code></a> when using a
                        single-threaded slave. If the ongoing transaction only
                        updates transactional tables, it is rolled back and
                        <a class="link" href="sql-syntax.html#stop-slave" title="13.4.2.7&nbsp;STOP SLAVE Syntax"><code class="literal">STOP SLAVE</code></a> stops immediately.
                        If the ongoing transaction is mixed,
                        <a class="link" href="sql-syntax.html#stop-slave" title="13.4.2.7&nbsp;STOP SLAVE Syntax"><code class="literal">STOP SLAVE</code></a> waits up to 60
                        seconds for the transaction to complete. After this timeout,
                        it aborts the transaction, so it may be left half-completed.
                    </p><p style="color:blue;">使用单线程从属服务器时停止从属服务器。如果正在进行的事务仅更新事务表，则回滚该事务并立即停止从属事务。如果正在进行的事务是混合的，则stop slave将等待事务完成60秒。在此超时之后，它将中止事务，因此它可能只完成一半。</p></li></ol>
                </div>
                <p>
                    The global variable
                    <a class="link" href="replication.html#sysvar_rpl_stop_slave_timeout"><code class="literal">rpl_stop_slave_timeout</code></a> is
                    unrelated to the process of stopping the replication threads. It
                    only makes the client that issues <a class="link" href="sql-syntax.html#stop-slave" title="13.4.2.7&nbsp;STOP SLAVE Syntax"><code class="literal">STOP
                    SLAVE</code></a> return to the client, but the replication
                    threads continue to try to stop.
                </p><p style="color:blue;">全局变量rpl_stop_slave_timeout与停止复制线程的过程无关。它只会使发出stop slave的客户机返回到客户机，但复制线程会继续尝试停止。</p><p>
                If a replication channel has gaps, it has the following
                consequences:
            </p><p style="color:blue;">如果复制通道存在间隙，则会产生以下后果：</p>
                <div class="orderedlist">
                    <ol class="orderedlist" type="1"><li class="listitem"><p>
                        The slave database is in a state that may never have existed
                        on the master.
                    </p><p style="color:blue;">从属数据库处于一个可能不存在于主机上的状态。</p></li><li class="listitem"><p>
                        The field <code class="literal">Exec_master_log_pos</code> in
                        <a class="link" href="sql-syntax.html#show-slave-status" title="13.7.5.34&nbsp;SHOW SLAVE STATUS Syntax"><code class="literal">SHOW SLAVE STATUS</code></a> is only a
                        <span class="quote">“<span class="quote">low-water mark</span>”</span>. In other words, transactions
                        appearing before the position are guaranteed to have
                        committed, but transactions after the position may have
                        committed or not.
                    </p><p style="color:blue;">显示从属状态的exec_master_log_pos字段只是一个“低水位线”。换言之，在头寸之前出现的交易被保证已提交，但头寸之后的交易可能已提交或未提交。</p></li><li class="listitem"><p>
                        <a class="link" href="sql-syntax.html#change-master-to" title="13.4.2.1&nbsp;CHANGE MASTER TO Syntax"><code class="literal">CHANGE MASTER TO</code></a> statements
                        for that channel fail with an error, unless the applier
                        threads are running and the <a class="link" href="sql-syntax.html#change-master-to" title="13.4.2.1&nbsp;CHANGE MASTER TO Syntax"><code class="literal">CHANGE
                        MASTER TO</code></a> statement only sets receiver options.
                    </p><p style="color:blue;">除非applier线程正在运行且change master to语句仅设置接收器选项，否则该通道的change master to语句将失败并出现错误。</p></li><li class="listitem"><p>
                        If <a class="link" href="programs.html#mysqld" title="4.3.1&nbsp;mysqld — The MySQL Server"><span class="command"><strong>mysqld</strong></span></a> is started with
                        <a class="link" href="replication.html#option_mysqld_relay-log-recovery"><code class="option">--relay-log-recovery</code></a>, no
                        recovery is done for that channel, and a warning is printed.
                    </p><p style="color:blue;">如果mysqld以--relay log recovery启动，则不会对该通道执行任何恢复，并会打印警告。</p></li><li class="listitem"><p>
                        If <a class="link" href="programs.html#mysqldump" title="4.5.4&nbsp;mysqldump — A Database Backup Program"><span class="command"><strong>mysqldump</strong></span></a> is used with
                        <a class="link" href="programs.html#option_mysqldump_dump-slave"><code class="option">--dump-slave</code></a>, it does not
                        record the existence of gaps; thus it prints
                        <a class="link" href="sql-syntax.html#change-master-to" title="13.4.2.1&nbsp;CHANGE MASTER TO Syntax"><code class="literal">CHANGE MASTER TO</code></a> with
                        <code class="literal">RELAY_LOG_POS</code> set to the <span class="quote">“<span class="quote">low-water
            mark</span>”</span> position in
                        <code class="literal">Exec_master_log_pos</code>.
                    </p><p style="color:blue;">如果MySQL LoIP与“转储从机”一起使用，则不记录存在间隙，因此将RealMaster打印到RelayyLogLogPOS设置为Excel中的“低水位标记”位置。</p><p>
                        After applying the dump on another server, and starting the
                        replication threads, transactions appearing after the
                        position are replicated again. Note that this is harmless if
                        GTIDs are enabled (however, in that case it is not
                        recommended to use
                        <a class="link" href="programs.html#option_mysqldump_dump-slave"><code class="option">--dump-slave</code></a>).
                    </p><p style="color:blue;">在另一台服务器上应用转储并启动复制线程后，将再次复制位置后出现的事务。注意，如果启用了gtid，这是无害的（但是，在这种情况下，不建议使用--dump slave）。</p></li></ol>
                </div>
                <p>
                    If a replication channel has master log position lag but no
                    gaps, cases 2 to 5 above apply, but case 1 does not.
                </p><p style="color:blue;">如果复制通道具有主日志位置延迟但没有间隙，则应用上面的情况2到5，但情况1不适用。</p><p>
                The master log position information is persisted in binary
                format in the internal table
                <code class="literal">mysql.slave_worker_info</code>.
                <a class="link" href="sql-syntax.html#start-slave" title="13.4.2.6&nbsp;START SLAVE Syntax"><code class="literal">START SLAVE
                    [SQL_THREAD]</code></a> always consults this information so that
                it applies only the correct transactions. This remains true even
                if <a class="link" href="replication.html#sysvar_slave_parallel_workers"><code class="literal">slave_parallel_workers</code></a> has
                been changed to 0 before <a class="link" href="sql-syntax.html#start-slave" title="13.4.2.6&nbsp;START SLAVE Syntax"><code class="literal">START
                SLAVE</code></a>, and even if <a class="link" href="sql-syntax.html#start-slave" title="13.4.2.6&nbsp;START SLAVE Syntax"><code class="literal">START
                SLAVE</code></a> is used with <code class="literal">UNTIL</code> clauses.
                <a class="link" href="sql-syntax.html#start-slave" title="13.4.2.6&nbsp;START SLAVE Syntax"><code class="literal">START SLAVE UNTIL
                    SQL_AFTER_MTS_GAPS</code></a> only applies as many transactions
                as needed in order to fill in the gaps. If
                <a class="link" href="sql-syntax.html#start-slave" title="13.4.2.6&nbsp;START SLAVE Syntax"><code class="literal">START SLAVE</code></a> is used with
                <code class="literal">UNTIL</code> clauses that tell it to stop before it
                has consumed all the gaps, then it leaves remaining gaps.
            </p><p style="color:blue;">主日志位置信息以二进制格式保存在内部表mysql.slave_worker_info中。start slave[sql_thread]总是参考这个信息，以便它只应用正确的事务。即使slave_parallel_workers在start slave之前已更改为0，即使start slave与until子句一起使用，也仍然如此。启动slave，直到sql_after_mts_gaps只应用所需的尽可能多的事务来填补这些空白。如果start slave与until子句一起使用，该子句告诉它在耗尽所有间隙之前停止，那么它将留下剩余的间隙。</p>
                <div class="warning" style="margin-left: 0.5in; margin-right: 0.5in;">

                    <div class="admon-title">
                        Warning
                    </div>
                    <p>
                        <a class="link" href="sql-syntax.html#reset-slave" title="13.4.2.4&nbsp;RESET SLAVE Syntax"><code class="literal">RESET SLAVE</code></a> removes the relay
                        logs and resets the replication position. Thus issuing
                        <a class="link" href="sql-syntax.html#reset-slave" title="13.4.2.4&nbsp;RESET SLAVE Syntax"><code class="literal">RESET SLAVE</code></a> on a slave with
                        gaps means the slave loses any information about the gaps,
                        without correcting the gaps.
                    </p><p style="color:blue;">reset slave删除中继日志并重置复制位置。因此，在带有间隙的从机上发出reset slave意味着该从机将丢失有关间隙的任何信息，而不更正间隙。</p>
                </div>

            </div>
            <div class="section">
                <div class="titlepage">
                    <div>
                        <div>
                            <h4 class="title"><a name="replication-features-transactions"></a>16.4.1.33&nbsp;Replication and Transactions</h4>

                        </div>

                    </div>

                </div>
                <a class="indexterm" name="idm140286791463328"></a><a class="indexterm" name="idm140286791461840"></a><p><b>Mixing transactional and nontransactional statements within the same
                transaction.&nbsp;</b>
                In general, you should avoid transactions that update both
                transactional and nontransactional tables in a replication
                environment. You should also avoid using any statement that
                accesses both transactional (or temporary) and
                nontransactional tables and writes to any of them.
            </p><p style="color:blue;">在同一事务中混合事务性事务和非事务性语句。通常，应避免在复制环境中同时更新事务表和非事务表的事务。还应避免使用同时访问事务表（或临时表）和非事务表并对其中任何表进行写入的任何语句。</p><p>
                The server uses these rules for binary logging:
            </p><p style="color:blue;">服务器使用以下规则进行二进制日志记录：</p>
                <div class="itemizedlist">
                    <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                        If the initial statements in a transaction are
                        nontransactional, they are written to the binary log
                        immediately. The remaining statements in the transaction are
                        cached and not written to the binary log until the
                        transaction is committed. (If the transaction is rolled
                        back, the cached statements are written to the binary log
                        only if they make nontransactional changes that cannot be
                        rolled back. Otherwise, they are discarded.)
                    </p><p style="color:blue;">如果事务中的初始语句是非事务性的，则它们会立即写入二进制日志。事务中的其余语句将被缓存，在提交事务之前不会写入二进制日志。（如果事务被回滚，缓存的语句只有在进行无法回滚的非事务更改时才会写入二进制日志。否则，它们将被丢弃。）</p></li><li class="listitem"><p>
                        For statement-based logging, logging of nontransactional
                        statements is affected by the
                        <a class="link" href="replication.html#sysvar_binlog_direct_non_transactional_updates"><code class="literal">binlog_direct_non_transactional_updates</code></a>
                        system variable. When this variable is
                        <code class="literal">OFF</code> (the default), logging is as just
                        described. When this variable is <code class="literal">ON</code>,
                        logging occurs immediately for nontransactional statements
                        occurring anywhere in the transaction (not just initial
                        nontransactional statements). Other statements are kept in
                        the transaction cache and logged when the transaction
                        commits.
                        <a class="link" href="replication.html#sysvar_binlog_direct_non_transactional_updates"><code class="literal">binlog_direct_non_transactional_updates</code></a>
                        has no effect for row-format or mixed-format binary logging.
                    </p><p style="color:blue;">对于基于语句的日志记录，非事务语句的日志记录受binlog_direct_non_transactional_updates系统变量的影响。当此变量处于关闭状态（默认值）时，日志记录如前所述。当此变量处于启用状态时，对于发生在事务中任何位置的非事务语句（不仅仅是初始非事务语句），都会立即进行日志记录。其他语句保存在事务缓存中，并在事务提交时记录。binlog_direct_non_transactional_updates对行格式或混合格式二进制日志记录没有影响。</p></li></ul>
                </div>
                <p><a name="replication-features-transactions-trx-nontrx-mixed"></a><b>Transactional, nontransactional, and mixed statements.&nbsp;</b><a class="indexterm" name="idm140286791449936"></a>
                    To apply those rules, the server considers a statement
                    nontransactional if it changes only nontransactional tables,
                    and transactional if it changes only transactional tables. A
                    statement that references both nontransactional and
                    transactional tables and updates <span class="emphasis"><em>any</em></span> of
                    the tables involved, is considered a <span class="quote">“<span class="quote">mixed</span>”</span>
                    statement. (In some past MySQL versions, only a statement that
                    updated <span class="emphasis"><em>both</em></span> nontransactional and
                    transactional tables was considered mixed.) Mixed statements,
                    like transactional statements, are cached and logged when the
                    transaction commits.
                </p><p style="color:blue;">事务性、非事务性和混合语句。为了应用这些规则，如果只更改非事务表，服务器将考虑语句非事务性；如果只更改事务表，服务器将考虑语句事务性。同时引用非事务表和事务表并更新任何相关表的语句被视为“混合”语句。（在过去的mysql版本中，只有同时更新非事务表和事务表的语句才被认为是混合语句。）混合语句与事务语句一样，在事务提交时被缓存和记录。</p><p>
                A mixed statement that updates a transactional table is
                considered unsafe if the statement also performs either of the
                following actions:
            </p><p style="color:blue;">如果更新事务表的混合语句还执行以下任一操作，则该语句被视为不安全：</p>
                <div class="itemizedlist">
                    <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                        Updates or reads a temporary table
                    </p><p style="color:blue;">更新或读取临时表</p></li><li class="listitem"><p>
                        Reads a nontransactional table and the transaction isolation
                        level is less than REPEATABLE_READ
                    </p><p style="color:blue;">读取非事务表，并且事务隔离级别小于可重复读取</p></li></ul>
                </div>
                <p>
                    A mixed statement following the update of a transactional table
                    within a transaction is considered unsafe if it performs either
                    of the following actions:
                </p><p style="color:blue;">在事务中更新事务表之后执行以下任一操作的混合语句被视为不安全：</p>
                <div class="itemizedlist">
                    <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                        Updates any table and reads from any temporary table
                    </p><p style="color:blue;">更新任何表并从任何临时表中读取</p></li><li class="listitem"><p>
                        Updates a nontransactional table and
                        <a class="link" href="replication.html#sysvar_binlog_direct_non_transactional_updates"><code class="literal">binlog_direct_non_transactional_updates</code></a>
                        is OFF
                    </p><p style="color:blue;">更新非事务表，binlog_direct_non_transactional_updates关闭</p></li></ul>
                </div>
                <p>
                    For more information, see
                    <a class="xref" href="replication.html#replication-rbr-safe-unsafe" title="16.2.1.3&nbsp;Determination of Safe and Unsafe Statements in Binary Logging">Section&nbsp;16.2.1.3, “Determination of Safe and Unsafe Statements in Binary Logging”</a>.
                </p><p style="color:blue;">有关更多信息，请参阅第16.2.1.3节“二进制日志中安全和不安全语句的确定”。</p>
                <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">

                    <div class="admon-title">
                        Note
                    </div>
                    <p>
                        A mixed statement is unrelated to mixed binary logging format.
                    </p><p style="color:blue;">混合语句与混合二进制日志格式无关。</p>
                </div>
                <p>
                    In situations where transactions mix updates to transactional
                    and nontransactional tables, the order of statements in the
                    binary log is correct, and all needed statements are written to
                    the binary log even in case of a
                    <a class="link" href="sql-syntax.html#commit" title="13.3.1&nbsp;START TRANSACTION, COMMIT, and ROLLBACK Syntax"><code class="literal">ROLLBACK</code></a>.
                    However, when a second connection updates the nontransactional
                    table before the first connection transaction is complete,
                    statements can be logged out of order because the second
                    connection update is written immediately after it is performed,
                    regardless of the state of the transaction being performed by
                    the first connection.
                </p><p style="color:blue;">在事务混合更新事务表和非事务表的情况下，二进制日志中语句的顺序是正确的，并且即使在回滚的情况下，所有需要的语句都会写入二进制日志。但是，当第二个连接在第一个连接事务完成之前更新非事务表时，语句可能会按顺序注销，因为第二个连接更新在执行后立即写入，而不管第一个连接执行的事务的状态如何。</p><p><b>Using different storage engines on master and slave.&nbsp;</b>
                It is possible to replicate transactional tables on the master
                using nontransactional tables on the slave. For example, you
                can replicate an <code class="literal">InnoDB</code> master table as a
                <code class="literal">MyISAM</code> slave table. However, if you do
                this, there are problems if the slave is stopped in the middle
                of a <a class="link" href="sql-syntax.html#commit" title="13.3.1&nbsp;START TRANSACTION, COMMIT, and ROLLBACK Syntax"><code class="literal">BEGIN</code></a>
                ... <a class="link" href="sql-syntax.html#commit" title="13.3.1&nbsp;START TRANSACTION, COMMIT, and ROLLBACK Syntax"><code class="literal">COMMIT</code></a> block because the
                slave restarts at the beginning of the
                <a class="link" href="sql-syntax.html#commit" title="13.3.1&nbsp;START TRANSACTION, COMMIT, and ROLLBACK Syntax"><code class="literal">BEGIN</code></a> block.
            </p><p style="color:blue;">在主从机上使用不同的存储引擎。可以使用从机上的非事务表在主机上复制事务表。例如，可以将innodb主表复制为myisam从表。然而，如果你这样做，有问题，如果奴隶被停止在一个开始…提交块，因为从机在开始块的开头重新启动。</p><p>
                It is also safe to replicate transactions from
                <a class="link" href="storage-engines.html#myisam-storage-engine" title="15.2&nbsp;The MyISAM Storage Engine"><code class="literal">MyISAM</code></a> tables on the master to
                transactional tables—such as tables that use the
                <a class="link" href="innodb-storage-engine.html" title="Chapter&nbsp;14&nbsp;The InnoDB Storage Engine"><code class="literal">InnoDB</code></a> storage engine—on the
                slave. In such cases, an
                <a class="link" href="server-administration.html#sysvar_autocommit"><code class="literal">AUTOCOMMIT=1</code></a>
                statement issued on the master is replicated, thus enforcing
                <code class="literal">AUTOCOMMIT</code> mode on the slave.
            </p><p style="color:blue;">将事务从主服务器上的myisam表复制到事务表（如在从服务器上使用innodb存储引擎的表）也是安全的。在这种情况下，将复制在主机上发出的autocommit=1语句，从而在从机上强制执行autocommit模式。</p><p>
                When the storage engine type of the slave is nontransactional,
                transactions on the master that mix updates of transactional and
                nontransactional tables should be avoided because they can cause
                inconsistency of the data between the master transactional table
                and the slave nontransactional table. That is, such transactions
                can lead to master storage engine-specific behavior with the
                possible effect of replication going out of synchrony. MySQL
                does not issue a warning about this currently, so extra care
                should be taken when replicating transactional tables from the
                master to nontransactional tables on the slaves.
            </p><p style="color:blue;">当从机的存储引擎类型为非事务性时，应避免主机上混合更新事务性表和非事务性表的事务，因为它们可能导致主事务性表和从机非事务性表之间的数据不一致。也就是说，这样的事务可能会导致主存储引擎特定的行为，并可能导致复制不同步。mysql目前不会对此发出警告，因此在将事务表从主表复制到从表上的非事务表时应格外小心。</p><p><b>Changing the binary logging format within transactions.&nbsp;</b>
                The <a class="link" href="replication.html#sysvar_binlog_format"><code class="literal">binlog_format</code></a> and
                <a class="link" href="replication.html#sysvar_binlog_checksum"><code class="literal">binlog_checksum</code></a> system
                variables are read-only as long as a transaction is in
                progress.
            </p><p style="color:blue;">更改事务中的二进制日志格式。只要事务正在进行，binlog_格式和binlog_校验和系统变量都是只读的。</p><p>
                Every transaction (including
                <a class="link" href="server-administration.html#sysvar_autocommit"><code class="literal">autocommit</code></a> transactions) is
                recorded in the binary log as though it starts with a
                <a class="link" href="sql-syntax.html#commit" title="13.3.1&nbsp;START TRANSACTION, COMMIT, and ROLLBACK Syntax"><code class="literal">BEGIN</code></a>
                statement, and ends with either a
                <a class="link" href="sql-syntax.html#commit" title="13.3.1&nbsp;START TRANSACTION, COMMIT, and ROLLBACK Syntax"><code class="literal">COMMIT</code></a> or a
                <a class="link" href="sql-syntax.html#commit" title="13.3.1&nbsp;START TRANSACTION, COMMIT, and ROLLBACK Syntax"><code class="literal">ROLLBACK</code></a>
                statement. This is even true for statements affecting tables
                that use a nontransactional storage engine (such as
                <a class="link" href="storage-engines.html#myisam-storage-engine" title="15.2&nbsp;The MyISAM Storage Engine"><code class="literal">MyISAM</code></a>).
            </p><p style="color:blue;">每个事务（包括自动提交事务）都记录在二进制日志中，就好像它以begin语句开始，以commit或rollback语句结束一样。对于影响使用非事务存储引擎（如myisam）的表的语句，这甚至是正确的。</p>
                <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">

                    <div class="admon-title">
                        Note
                    </div>
                    <p>
                        For restrictions that apply specifically to XA transactions,
                        see <a class="xref" href="sql-syntax.html#xa-restrictions" title="13.3.7.3&nbsp;Restrictions on XA Transactions">Section&nbsp;13.3.7.3, “Restrictions on XA Transactions”</a>.
                    </p><p style="color:blue;">有关专门适用于XA交易的限制，请参见第13.3.7.3节“对XA交易的限制”。</p>
                </div>

            </div>
            <div class="section">
                <div class="titlepage">
                    <div>
                        <div>
                            <h4 class="title"><a name="replication-features-triggers"></a>16.4.1.34&nbsp;Replication and Triggers</h4>

                        </div>

                    </div>

                </div>
                <a class="indexterm" name="idm140286791408400"></a><a class="indexterm" name="idm140286791406912"></a><p>
                With statement-based replication, triggers executed on the
                master also execute on the slave. With row-based replication,
                triggers executed on the master do not execute on the slave.
                Instead, the row changes on the master resulting from trigger
                execution are replicated and applied on the slave.
            </p><p style="color:blue;">对于基于语句的复制，在主服务器上执行的触发器也在从服务器上执行。对于基于行的复制，在主服务器上执行的触发器不会在从服务器上执行。相反，由触发器执行导致的主节点上的行更改将被复制并应用到从节点上。</p><p>
                This behavior is by design. If under row-based replication the
                slave applied the triggers as well as the row changes caused by
                them, the changes would in effect be applied twice on the slave,
                leading to different data on the master and the slave.
            </p><p style="color:blue;">这种行为是故意的。如果在基于行的复制下，从机应用了触发器以及触发器引起的行更改，则这些更改实际上将在从机上应用两次，从而导致主机和从机上的数据不同。</p><p>
                If you want triggers to execute on both the master and the
                slave—perhaps because you have different triggers on the
                master and slave—you must use statement-based replication.
                However, to enable slave-side triggers, it is not necessary to
                use statement-based replication exclusively. It is sufficient to
                switch to statement-based replication only for those statements
                where you want this effect, and to use row-based replication the
                rest of the time.
            </p><p style="color:blue;">如果希望触发器同时在主服务器和从服务器上执行，可能是因为主服务器和从服务器上有不同的触发器，所以必须使用基于语句的复制。但是，要启用从机端触发器，不必专门使用基于语句的复制。只对需要这种效果的语句切换到基于语句的复制，其余时间使用基于行的复制就足够了。</p><p>
                A statement invoking a trigger (or function) that causes an
                update to an <code class="literal">AUTO_INCREMENT</code> column is not
                replicated correctly using statement-based replication. MySQL
                5.7 marks such statements as unsafe. (Bug #45677)
            </p><p style="color:blue;">使用基于语句的复制无法正确复制调用触发器（或函数）的语句，该语句会导致对自动递增列的更新。mysql 5.7将此类语句标记为不安全。（错误45677）</p><p>
                A trigger can have triggers for different combinations of
                trigger event (<a class="link" href="sql-syntax.html#insert" title="13.2.5&nbsp;INSERT Syntax"><code class="literal">INSERT</code></a>,
                <a class="link" href="sql-syntax.html#update" title="13.2.11&nbsp;UPDATE Syntax"><code class="literal">UPDATE</code></a>,
                <a class="link" href="sql-syntax.html#delete" title="13.2.2&nbsp;DELETE Syntax"><code class="literal">DELETE</code></a>) and action time
                (<code class="literal">BEFORE</code>, <code class="literal">AFTER</code>), but
                before MySQL 5.7.2 cannot have multiple triggers that have the
                same trigger event and action time. MySQL 5.7.2 lifts this
                limitation and multiple triggers are permitted. This change has
                replication implications for upgrades and downgrades.
            </p><p style="color:blue;">触发器可以具有触发器事件（insert、update、delete）和操作时间（before、after）的不同组合，但mysql 5.7.2之前不能有多个触发器具有相同的触发器事件和操作时间。mysql 5.7.2解除了这个限制，允许使用多个触发器。此更改对升级和降级具有复制影响。</p><p>
                For brevity, <span class="quote">“<span class="quote">multiple triggers</span>”</span> here is shorthand
                for <span class="quote">“<span class="quote">multiple triggers that have the same trigger event
        and action time.</span>”</span>
            </p><p style="color:blue;">为简洁起见，这里的“多重触发器”是“具有相同触发器事件和操作时间的多重触发器”的简写。</p><p>
                <span class="bold"><strong>Upgrades.</strong></span> Suppose that you
                upgrade an old server that does not support multiple triggers to
                MySQL 5.7.2 or higher. If the new server is a replication master
                and has old slaves that do not support multiple triggers, an
                error occurs on those slaves if a trigger is created on the
                master for a table that already has a trigger with the same
                trigger event and action time. To avoid this problem, upgrade
                the slaves first, then upgrade the master.
            </p><p style="color:blue;">升级。假设您将不支持多个触发器的旧服务器升级到mysql 5.7.2或更高版本。如果新服务器是复制主服务器，并且有不支持多个触发器的旧从服务器，则如果在主服务器上为已具有相同触发器事件和操作时间的表创建了触发器，则在这些从服务器上会发生错误。要避免此问题，请先升级从属服务器，然后升级主服务器。</p><p>
                <span class="bold"><strong>Downgrades.</strong></span> If you downgrade a
                server that supports multiple triggers to an older version that
                does not, the downgrade has these effects:
            </p><p style="color:blue;">降级。如果将支持多个触发器的服务器降级到不支持多个触发器的旧版本，则降级会产生以下效果：</p>
                <div class="itemizedlist">
                    <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                        For each table that has triggers, all trigger definitions
                        remain in the <code class="filename">.TRG</code> file for the table.
                        However, if there are multiple triggers with the same
                        trigger event and action time, the server executes only one
                        of them when the trigger event occurs. For information about
                        <code class="literal">.TRG</code> files, see the Table Trigger Storage
                        section of the MySQL Server Doxygen documentation, available
                        at <a class="ulink" href="https://dev.mysql.com/doc/index-other.html" target="_top">https://dev.mysql.com/doc/index-other.html</a>.
                    </p><p style="color:blue;">对于每个具有触发器的表，所有触发器定义都保留在该表的.trg文件中。但是，如果有多个触发器具有相同的触发器事件和操作时间，则服务器在触发器事件发生时仅执行其中一个触发器。有关.trg文件的信息，请参阅mysql server doxygen文档的“表触发器存储”部分，该文档位于https://dev.mysql.com/doc/index-other.html。</p></li><li class="listitem"><p>
                        If triggers for the table are added or dropped subsequent to
                        the downgrade, the server rewrites the table's
                        <code class="filename">.TRG</code> file. The rewritten file retains
                        only one trigger per combination of trigger event and action
                        time; the others are lost.
                    </p><p style="color:blue;">如果在降级之后添加或删除了表的触发器，服务器将重写表的.trg文件。重写的文件在触发器事件和操作时间的组合中只保留一个触发器；其他触发器将丢失。</p></li></ul>
                </div>
                <p>
                    To avoid these problems, modify your triggers before
                    downgrading. For each table that has multiple triggers per
                    combination of trigger event and action time, convert each such
                    set of triggers to a single trigger as follows:
                </p><p style="color:blue;">要避免这些问题，请在降级之前修改触发器。对于每个触发器事件和操作时间组合具有多个触发器的表，请按如下所示将每个这样的触发器集转换为单个触发器：</p>
                <div class="orderedlist">
                    <ol class="orderedlist" type="1"><li class="listitem"><p>
                        For each trigger, create a stored routine that contains all
                        the code in the trigger. Values accessed using
                        <code class="literal">NEW</code> and <code class="literal">OLD</code> can be
                        passed to the routine using parameters. If the trigger needs
                        a single result value from the code, you can put the code in
                        a stored function and have the function return the value. If
                        the trigger needs multiple result values from the code, you
                        can put the code in a stored procedure and return the values
                        using <code class="literal">OUT</code> parameters.
                    </p><p style="color:blue;">对于每个触发器，创建一个包含触发器中所有代码的存储例程。使用new和old访问的值可以使用参数传递给例程。如果触发器需要来自代码的单个结果值，则可以将代码放入存储的函数中，并让函数返回该值。如果触发器需要来自代码的多个结果值，则可以将代码放入存储过程并使用out参数返回值。</p></li><li class="listitem"><p>
                        Drop all triggers for the table.
                    </p><p style="color:blue;">删除表的所有触发器。</p></li><li class="listitem"><p>
                        Create one new trigger for the table that invokes the stored
                        routines just created. The effect for this trigger is thus
                        the same as the multiple triggers it replaces.
                    </p><p style="color:blue;">为调用刚创建的存储例程的表创建一个新触发器。因此，此触发器的效果与它替换的多个触发器的效果相同。</p></li></ol>
                </div>

            </div>
            <div class="section">
                <div class="titlepage">
                    <div>
                        <div>
                            <h4 class="title"><a name="replication-features-truncate"></a>16.4.1.35&nbsp;Replication and TRUNCATE TABLE</h4>

                        </div>

                    </div>

                </div>
                <a class="indexterm" name="idm140286791377888"></a><a class="indexterm" name="idm140286791376400"></a><p>
                <a class="link" href="sql-syntax.html#truncate-table" title="13.1.34&nbsp;TRUNCATE TABLE Syntax"><code class="literal">TRUNCATE TABLE</code></a> is normally
                regarded as a DML statement, and so would be expected to be
                logged and replicated using row-based format when the binary
                logging mode is <code class="literal">ROW</code> or
                <code class="literal">MIXED</code>. However this caused issues when
                logging or replicating, in <code class="literal">STATEMENT</code> or
                <code class="literal">MIXED</code> mode, tables that used transactional
                storage engines such as <a class="link" href="innodb-storage-engine.html" title="Chapter&nbsp;14&nbsp;The InnoDB Storage Engine"><code class="literal">InnoDB</code></a> when
                the transaction isolation level was <code class="literal">READ
                COMMITTED</code> or <code class="literal">READ UNCOMMITTED</code>,
                which precludes statement-based logging.
            </p><p style="color:blue;">truncate table通常被视为dml语句，因此在二进制日志模式为row或mixed时，应该使用基于行的格式记录和复制。但是，这会在以语句或混合模式记录或复制使用事务存储引擎（如innodb）的表（在事务隔离级别为read committed或read uncommitted时）时引起问题，从而排除基于语句的日志记录。</p><p>
                <a class="link" href="sql-syntax.html#truncate-table" title="13.1.34&nbsp;TRUNCATE TABLE Syntax"><code class="literal">TRUNCATE TABLE</code></a> is treated for
                purposes of logging and replication as DDL rather than DML so
                that it can be logged and replicated as a statement. However,
                the effects of the statement as applicable to
                <a class="link" href="innodb-storage-engine.html" title="Chapter&nbsp;14&nbsp;The InnoDB Storage Engine"><code class="literal">InnoDB</code></a> and other transactional
                tables on replication slaves still follow the rules described in
                <a class="xref" href="sql-syntax.html#truncate-table" title="13.1.34&nbsp;TRUNCATE TABLE Syntax">Section&nbsp;13.1.34, “TRUNCATE TABLE Syntax”</a> governing such tables. (Bug
                #36763)
            </p><p style="color:blue;">为了记录和复制，truncate table被视为ddl而不是dml，这样它就可以作为语句记录和复制。但是，如果该语句适用于innodb和其他事务表，则对复制从机的影响仍然遵循13.1.34节“truncate table syntax”中描述的规则。（错误36763）</p>
            </div>
            <div class="section">
                <div class="titlepage">
                    <div>
                        <div>
                            <h4 class="title"><a name="replication-features-user-names"></a>16.4.1.36&nbsp;Replication and User Name Length</h4>

                        </div>

                    </div>

                </div>
                <a class="indexterm" name="idm140286791362224"></a><a class="indexterm" name="idm140286791360768"></a><p>
                The maximum length of MySQL user names was increased from 16
                characters to 32 characters in MySQL 5.7.8. Replication of user
                names longer than 16 characters to a slave that supports only
                shorter user names will fail. However, this should occur only
                when replicating from a newer master to an older slave, which is
                not a recommended configuration.
            </p><p style="color:blue;">在MySQL 5.7.8中，MySQL用户名的最大长度从16个字符增加到32个字符。将超过16个字符的用户名复制到只支持较短用户名的从属服务器将失败。但是，只有在从较新的主设备复制到较旧的从设备时才会发生这种情况，这不是建议的配置。</p>
            </div>
            <div class="section">
                <div class="titlepage">
                    <div>
                        <div>
                            <h4 class="title"><a name="replication-features-variables"></a>16.4.1.37&nbsp;Replication and Variables</h4>

                        </div>

                    </div>

                </div>
                <a class="indexterm" name="idm140286791357200"></a><a class="indexterm" name="idm140286791355712"></a><a class="indexterm" name="idm140286791354224"></a><a class="indexterm" name="idm140286791352736"></a><a class="indexterm" name="idm140286791351248"></a><p>
                System variables are not replicated correctly when using
                <code class="literal">STATEMENT</code> mode, except for the following
                variables when they are used with session scope:
            </p><p style="color:blue;">使用语句模式时，系统变量不会正确复制，但与会话作用域一起使用时，以下变量除外：</p>
                <div class="itemizedlist">
                    <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                        <a class="link" href="replication.html#sysvar_auto_increment_increment"><code class="literal">auto_increment_increment</code></a>
                    </p><p style="color:blue;">自动递增</p></li><li class="listitem"><p>
                        <a class="link" href="replication.html#sysvar_auto_increment_offset"><code class="literal">auto_increment_offset</code></a>
                    </p><p style="color:blue;">自动增量偏移</p></li><li class="listitem"><p>
                        <a class="link" href="server-administration.html#sysvar_character_set_client"><code class="literal">character_set_client</code></a>
                    </p><p style="color:blue;">字符集客户端</p></li><li class="listitem"><p>
                        <a class="link" href="server-administration.html#sysvar_character_set_connection"><code class="literal">character_set_connection</code></a>
                    </p><p style="color:blue;">字符集连接</p></li><li class="listitem"><p>
                        <a class="link" href="server-administration.html#sysvar_character_set_database"><code class="literal">character_set_database</code></a>
                    </p><p style="color:blue;">字符集数据库</p></li><li class="listitem"><p>
                        <a class="link" href="server-administration.html#sysvar_character_set_server"><code class="literal">character_set_server</code></a>
                    </p><p style="color:blue;">字符集服务器</p></li><li class="listitem"><p>
                        <a class="link" href="server-administration.html#sysvar_collation_connection"><code class="literal">collation_connection</code></a>
                    </p><p style="color:blue;">排序规则连接</p></li><li class="listitem"><p>
                        <a class="link" href="server-administration.html#sysvar_collation_database"><code class="literal">collation_database</code></a>
                    </p><p style="color:blue;">排序规则数据库</p></li><li class="listitem"><p>
                        <a class="link" href="server-administration.html#sysvar_collation_server"><code class="literal">collation_server</code></a>
                    </p><p style="color:blue;">排序规则服务器</p></li><li class="listitem"><p>
                        <a class="link" href="server-administration.html#sysvar_foreign_key_checks"><code class="literal">foreign_key_checks</code></a>
                    </p><p style="color:blue;">外国支票</p></li><li class="listitem"><p>
                        <a class="link" href="server-administration.html#sysvar_identity"><code class="literal">identity</code></a>
                    </p><p style="color:blue;">身份</p></li><li class="listitem"><p>
                        <a class="link" href="server-administration.html#sysvar_last_insert_id"><code class="literal">last_insert_id</code></a>
                    </p><p style="color:blue;">上次插入的ID</p></li><li class="listitem"><p>
                        <a class="link" href="server-administration.html#sysvar_lc_time_names"><code class="literal">lc_time_names</code></a>
                    </p><p style="color:blue;">LC U时间名称</p></li><li class="listitem"><p>
                        <a class="link" href="server-administration.html#sysvar_pseudo_thread_id"><code class="literal">pseudo_thread_id</code></a>
                    </p><p style="color:blue;">伪线程ID</p></li><li class="listitem"><p>
                        <a class="link" href="server-administration.html#sysvar_sql_auto_is_null"><code class="literal">sql_auto_is_null</code></a>
                    </p><p style="color:blue;">sql_auto_为空</p></li><li class="listitem"><p>
                        <a class="link" href="server-administration.html#sysvar_time_zone"><code class="literal">time_zone</code></a>
                    </p><p style="color:blue;">时区</p></li><li class="listitem"><p>
                        <a class="link" href="server-administration.html#sysvar_timestamp"><code class="literal">timestamp</code></a>
                    </p><p style="color:blue;">时间戳</p></li><li class="listitem"><p>
                        <a class="link" href="server-administration.html#sysvar_unique_checks"><code class="literal">unique_checks</code></a>
                    </p><p style="color:blue;">独特的支票</p></li></ul>
                </div>
                <p>
                    When <code class="literal">MIXED</code> mode is used, the variables in the
                    preceding list, when used with session scope, cause a switch
                    from statement-based to row-based logging. See
                    <a class="xref" href="server-administration.html#binary-log-mixed" title="5.4.4.3&nbsp;Mixed Binary Logging Format">Section&nbsp;5.4.4.3, “Mixed Binary Logging Format”</a>.
                </p><p style="color:blue;">当使用混合模式时，前面列表中的变量与会话作用域一起使用时，将导致从基于语句的日志记录切换到基于行的日志记录。见第5.4.4.3节，“混合二进制日志格式”。</p><p>
                <a class="link" href="server-administration.html#sysvar_sql_mode"><code class="literal">sql_mode</code></a> is also replicated
                except for the
                <a class="link" href="server-administration.html#sqlmode_no_dir_in_create"><code class="literal">NO_DIR_IN_CREATE</code></a> mode; the
                slave always preserves its own value for
                <a class="link" href="server-administration.html#sqlmode_no_dir_in_create"><code class="literal">NO_DIR_IN_CREATE</code></a>, regardless
                of changes to it on the master. This is true for all replication
                formats.
            </p><p style="color:blue;">除了创建模式中的no_dir_之外，还复制sql_mode；无论在主节点上对其进行了什么更改，从节点始终为创建模式中的no_dir_保留自己的值。所有复制格式都是这样。</p><p>
                However, when <a class="link" href="programs.html#mysqlbinlog" title="4.6.7&nbsp;mysqlbinlog — Utility for Processing Binary Log Files"><span class="command"><strong>mysqlbinlog</strong></span></a> parses a
                <code class="literal">SET @@sql_mode =
                    <em class="replaceable"><code>mode</code></em></code> statement, the full
                <em class="replaceable"><code>mode</code></em> value, including
                <a class="link" href="server-administration.html#sqlmode_no_dir_in_create"><code class="literal">NO_DIR_IN_CREATE</code></a>, is passed to
                the receiving server. For this reason, replication of such a
                statement may not be safe when <code class="literal">STATEMENT</code> mode
                is in use.
            </p><p style="color:blue;">但是，当mysqlbinlog解析set@@sql_mode=mode语句时，完整的mode值（包括create中的no_dir_）将传递给接收服务器。因此，当使用语句模式时，此类语句的复制可能不安全。</p><p>
                The <a class="link" href="server-administration.html#sysvar_default_storage_engine"><code class="literal">default_storage_engine</code></a> and
                <a class="link" href="server-administration.html#sysvar_storage_engine"><code class="literal">storage_engine</code></a> system variables
                are not replicated, regardless of the logging mode; this is
                intended to facilitate replication between different storage
                engines.
            </p><p style="color:blue;">无论日志记录模式如何，都不会复制默认的存储引擎和存储引擎系统变量；这是为了方便不同存储引擎之间的复制。</p><p>
                The <a class="link" href="server-administration.html#sysvar_read_only"><code class="literal">read_only</code></a> system variable
                is not replicated. In addition, the enabling this variable has
                different effects with regard to temporary tables, table
                locking, and the <a class="link" href="sql-syntax.html#set-password" title="13.7.1.7&nbsp;SET PASSWORD Syntax"><code class="literal">SET PASSWORD</code></a>
                statement in different MySQL versions.
            </p><p style="color:blue;">不复制只读系统变量。此外，在不同的mysql版本中，启用此变量对于临时表、表锁定和set password语句有不同的效果。</p><p>
                The <a class="link" href="server-administration.html#sysvar_max_heap_table_size"><code class="literal">max_heap_table_size</code></a> system
                variable is not replicated. Increasing the value of this
                variable on the master without doing so on the slave can lead
                eventually to <span class="errortext">Table is full</span> errors on the
                slave when trying to execute
                <a class="link" href="sql-syntax.html#insert" title="13.2.5&nbsp;INSERT Syntax"><code class="literal">INSERT</code></a> statements on a
                <a class="link" href="storage-engines.html#memory-storage-engine" title="15.3&nbsp;The MEMORY Storage Engine"><code class="literal">MEMORY</code></a> table on the master that is
                thus permitted to grow larger than its counterpart on the slave.
                For more information, see
                <a class="xref" href="replication.html#replication-features-memory" title="16.4.1.20&nbsp;Replication and MEMORY Tables">Section&nbsp;16.4.1.20, “Replication and MEMORY Tables”</a>.
            </p><p style="color:blue;">未复制max_heap_table_size系统变量。在主从机上增加这个变量的值而不在主从机上这样做，最终会导致在主从机上执行INSERT语句时，主从机上出现完全错误，这样就允许主从机上的INSERT语句比主从机上的对应语句增长得更大。有关更多信息，请参阅第16.4.1.20节“复制和内存表”。</p><p>
                In statement-based replication, session variables are not
                replicated properly when used in statements that update tables.
                For example, the following sequence of statements will not
                insert the same data on the master and the slave:
            </p><p style="color:blue;">在基于语句的复制中，当在更新表的语句中使用会话变量时，不会正确复制会话变量。例如，以下语句序列不会在主服务器和从服务器上插入相同的数据：</p><pre data-lang="sql" class="programlisting">SET max_join_size=1000;
INSERT INTO mytable VALUES(@@max_join_size);
</pre><p>
                This does not apply to the common sequence:
            </p><p style="color:blue;">这不适用于通用序列：</p><pre data-lang="sql" class="programlisting">SET time_zone=...;
INSERT INTO mytable VALUES(CONVERT_TZ(..., ..., @@time_zone));
</pre><p>
                Replication of session variables is not a problem when row-based
                replication is being used, in which case, session variables are
                always replicated safely. See
                <a class="xref" href="replication.html#replication-formats" title="16.2.1&nbsp;Replication Formats">Section&nbsp;16.2.1, “Replication Formats”</a>.
            </p><p style="color:blue;">当使用基于行的复制时，会话变量的复制不是问题，在这种情况下，会话变量总是安全地复制的。见第16.2.1节“复制格式”。</p><p>
                The following session variables are written to the binary log
                and honored by the replication slave when parsing the binary
                log, regardless of the logging format:
            </p><p style="color:blue;">无论日志格式如何，在分析二进制日志时，复制从属服务器都会将以下会话变量写入二进制日志并接受它们：</p>
                <div class="itemizedlist">
                    <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                        <a class="link" href="server-administration.html#sysvar_sql_mode"><code class="literal">sql_mode</code></a>
                    </p><p style="color:blue;">SQL模式</p></li><li class="listitem"><p>
                        <a class="link" href="server-administration.html#sysvar_foreign_key_checks"><code class="literal">foreign_key_checks</code></a>
                    </p><p style="color:blue;">外国支票</p></li><li class="listitem"><p>
                        <a class="link" href="server-administration.html#sysvar_unique_checks"><code class="literal">unique_checks</code></a>
                    </p><p style="color:blue;">独特的支票</p></li><li class="listitem"><p>
                        <a class="link" href="server-administration.html#sysvar_character_set_client"><code class="literal">character_set_client</code></a>
                    </p><p style="color:blue;">字符集客户端</p></li><li class="listitem"><p>
                        <a class="link" href="server-administration.html#sysvar_collation_connection"><code class="literal">collation_connection</code></a>
                    </p><p style="color:blue;">排序规则连接</p></li><li class="listitem"><p>
                        <a class="link" href="server-administration.html#sysvar_collation_database"><code class="literal">collation_database</code></a>
                    </p><p style="color:blue;">排序规则数据库</p></li><li class="listitem"><p>
                        <a class="link" href="server-administration.html#sysvar_collation_server"><code class="literal">collation_server</code></a>
                    </p><p style="color:blue;">排序规则服务器</p></li><li class="listitem"><p>
                        <a class="link" href="server-administration.html#sysvar_sql_auto_is_null"><code class="literal">sql_auto_is_null</code></a>
                    </p><p style="color:blue;">sql_auto_为空</p></li></ul>
                </div>
                <div class="important" style="margin-left: 0.5in; margin-right: 0.5in;">
                    <div class="admon-title">
                        Important
                    </div>
                    <p>
                        Even though session variables relating to character sets and
                        collations are written to the binary log, replication between
                        different character sets is not supported.
                    </p><p style="color:blue;">即使将与字符集和排序规则相关的会话变量写入二进制日志，也不支持不同字符集之间的复制。</p>
                </div>
                <p>
                    To help reduce possible confusion, we recommend that you always
                    use the same setting for the
                    <a class="link" href="server-administration.html#sysvar_lower_case_table_names"><code class="literal">lower_case_table_names</code></a> system
                    variable on both master and slave, especially when you are
                    running MySQL on platforms with case-sensitive file systems.
                </p><p style="color:blue;">为了帮助减少可能出现的混淆，我们建议您在主系统和从系统上始终对小写字母表名系统变量使用相同的设置，特别是在具有区分大小写文件系统的平台上运行mysql时。</p>
            </div>
            <div class="section">
                <div class="titlepage">
                    <div>
                        <div>
                            <h4 class="title"><a name="replication-features-views"></a>16.4.1.38&nbsp;Replication and Views</h4>

                        </div>

                    </div>

                </div>
                <a class="indexterm" name="idm140286791263600"></a><a class="indexterm" name="idm140286791262112"></a><p>
                Views are always replicated to slaves. Views are filtered by
                their own name, not by the tables they refer to. This means that
                a view can be replicated to the slave even if the view contains
                a table that would normally be filtered out by
                <code class="option">replication-ignore-table</code> rules. Care should
                therefore be taken to ensure that views do not replicate table
                data that would normally be filtered for security reasons.
            </p><p style="color:blue;">视图总是复制到从属视图。视图按其自身的名称过滤，而不是按其引用的表过滤。这意味着，即使视图包含通常由复制忽略表规则过滤掉的表，也可以将视图复制到从属视图。因此，应注意确保视图不会复制出于安全原因通常会被筛选的表数据。</p><p>
                Replication from a table to a same-named view is supported using
                statement-based logging, but not when using row-based logging.
                Trying to do so when row-based logging is in effect causes an
                error. (Bug #11752707, Bug #43975)
            </p><p style="color:blue;">使用基于语句的日志记录支持从表到同一命名视图的复制，但使用基于行的日志记录时不支持。当基于行的日志记录生效时尝试这样做会导致错误。（错误11752707，错误43975）</p>
            </div>

        </div>
        <div class="section">
            <div class="titlepage">
                <div>
                    <div>
                        <h3 class="title"><a name="replication-compatibility"></a>16.4.2&nbsp;Replication Compatibility Between MySQL Versions</h3>

                    </div>

                </div>

            </div>
            <p>
                MySQL supports replication from one release series to the next
                higher release series. For example, you can replicate from a
                master running MySQL 5.6 to a slave running MySQL 5.7, from a
                master running MySQL 5.7 to a slave running MySQL 8.0, and so on.
                However, you may encounter difficulties when replicating from an
                older master to a newer slave if the master uses statements or
                relies on behavior no longer supported in the version of MySQL
                used on the slave. For example, foreign key names longer than 64
                characters are no longer supported from MySQL 8.0.
            </p><p style="color:blue;">MySQL支持从一个发行版系列复制到下一个更高版本系列。例如，可以从运行mysql 5.6的主服务器复制到运行mysql 5.7的从服务器，从运行mysql 5.7的主服务器复制到运行mysql 8.0的从服务器，等等。但是，如果主服务器使用语句或依赖从服务器上使用的mysql版本不再支持的行为，则在从服务器上从较旧的主服务器复制到较新的从服务器时可能会遇到困难。例如，mysql 8.0不再支持超过64个字符的外键名。</p><p>
            The use of more than two MySQL Server versions is not supported in
            replication setups involving multiple masters, regardless of the
            number of master or slave MySQL servers. This restriction applies
            not only to release series, but to version numbers within the same
            release series as well. For example, if you are using a chained or
            circular replication setup, you cannot use MySQL
            5.7.22, MySQL 5.7.23, and MySQL
            5.7.24 concurrently, although you could use any two
            of these releases together.
        </p><p style="color:blue;">在涉及多个主服务器的复制设置中，不支持使用两个以上的mysql服务器版本，而不管mysql主服务器或从服务器的数量如何。此限制不仅适用于发行版系列，还适用于同一发行版系列中的版本号。例如，如果使用链式或循环复制设置，则不能同时使用mysql 5.7.22、mysql 5.7.23和mysql 5.7.24，尽管可以同时使用其中的任何两个版本。</p>
            <div class="important" style="margin-left: 0.5in; margin-right: 0.5in;">

                <div class="admon-title">
                    Important
                </div>
                <p>
                    It is strongly recommended to use the most recent release
                    available within a given MySQL release series because
                    replication (and other) capabilities are continually being
                    improved. It is also recommended to upgrade masters and slaves
                    that use early releases of a release series of MySQL to GA
                    (production) releases when the latter become available for that
                    release series.
                </p><p style="color:blue;">强烈建议在给定的mysql版本系列中使用最新版本，因为复制（和其他）功能正在不断改进。还建议将使用mysql发布系列的早期版本的主版本和从版本升级到ga（生产）版本（当后者可用于该发布系列时）。</p>
            </div>
            <p>
                Replication from newer masters to older slaves may be possible,
                but is generally not supported. This is due to a number of
                factors:
            </p><p style="color:blue;">可以从较新的主服务器复制到较旧的从服务器，但通常不受支持。这是由许多因素造成的：</p>
            <div class="itemizedlist">
                <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><b>Binary log format changes.&nbsp;</b>
                    The binary log format can change between major releases.
                    While we attempt to maintain backward compatibility, this is
                    not always possible.
                </p><p style="color:blue;">二进制日志格式更改。二进制日志格式可以在主要版本之间更改。虽然我们试图保持向后兼容，但这并不总是可能的。</p><p>
                    This also has significant implications for upgrading
                    replication servers; see
                    <a class="xref" href="replication.html#replication-upgrade" title="16.4.3&nbsp;Upgrading a Replication Setup">Section&nbsp;16.4.3, “Upgrading a Replication Setup”</a>, for more information.
                </p><p style="color:blue;">这对升级复制服务器也有重大影响；有关更多信息，请参阅第16.4.3节“升级复制设置”。</p></li><li class="listitem"><p>
                    For more information about row-based replication, see
                    <a class="xref" href="replication.html#replication-formats" title="16.2.1&nbsp;Replication Formats">Section&nbsp;16.2.1, “Replication Formats”</a>.
                </p><p style="color:blue;">有关基于行的复制的更多信息，请参阅第16.2.1节“复制格式”。</p></li><li class="listitem"><p><b>SQL incompatibilities.&nbsp;</b>
                    You cannot replicate from a newer master to an older slave
                    using statement-based replication if the statements to be
                    replicated use SQL features available on the master but not
                    on the slave.
                </p><p style="color:blue;">SQL不兼容。如果要复制的语句使用主服务器上可用的SQL功能，而不是从服务器上可用的SQL功能，则不能使用基于语句的复制从较新的主服务器复制到较旧的从服务器。</p><p>
                    However, if both the master and the slave support row-based
                    replication, and there are no data definition statements to be
                    replicated that depend on SQL features found on the master but
                    not on the slave, you can use row-based replication to
                    replicate the effects of data modification statements even if
                    the DDL run on the master is not supported on the slave.
                </p><p style="color:blue;">但是，如果主服务器和从服务器都支持基于行的复制，并且没有要复制的数据定义语句依赖于主服务器（而不是从服务器）上的SQL功能，则可以使用基于行的复制复制数据修改语句的效果，即使主服务器上运行的DDL不受奴隶。</p></li></ul>
            </div>
            <p>
                For more information on potential replication issues, see
                <a class="xref" href="replication.html#replication-features" title="16.4.1&nbsp;Replication Features and Issues">Section&nbsp;16.4.1, “Replication Features and Issues”</a>.
            </p><p style="color:blue;">有关潜在复制问题的更多信息，请参阅第16.4.1节“复制功能和问题”。</p>
        </div>
        <div class="section">
            <div class="titlepage">
                <div>
                    <div>
                        <h3 class="title"><a name="replication-upgrade"></a>16.4.3&nbsp;Upgrading a Replication Setup</h3>

                    </div>

                </div>

            </div>
            <p>
                When you upgrade servers that participate in a replication setup,
                the procedure for upgrading depends on the current server versions
                and the version to which you are upgrading. This section provides
                information about how upgrading affects replication. For general
                information about upgrading MySQL, see <a class="xref" href="installing.html#upgrading" title="2.11&nbsp;Upgrading MySQL">Section&nbsp;2.11, “Upgrading MySQL”</a>
            </p><p style="color:blue;">升级参与复制设置的服务器时，升级过程取决于当前服务器版本和要升级到的版本。本节提供有关升级如何影响复制的信息。有关升级mysql的一般信息，请参见2.11节“升级mysql”</p><p>
            When you upgrade a master to 5.7 from an earlier
            MySQL release series, you should first ensure that all the slaves
            of this master are using the same 5.7.x release. If
            this is not the case, you should first upgrade the slaves. To
            upgrade each slave, shut it down, upgrade it to the appropriate
            5.7.x version, restart it, and restart replication.
            Relay logs created by the slave after the upgrade are in
            5.7 format.
        </p><p style="color:blue;">当您从早期的mysql发行版系列将master升级到5.7时，您应该首先确保该master的所有从机都使用相同的5.7.x版本。如果不是这样的话，你应该先升级奴隶。要升级每个从机，请关闭它，将其升级到适当的5.7.x版本，重新启动它，然后重新启动复制。升级后从机创建的中继日志采用5.7格式。</p><p>
            Changes affecting operations in strict SQL mode
            (<a class="link" href="server-administration.html#sqlmode_strict_trans_tables"><code class="literal">STRICT_TRANS_TABLES</code></a> or
            <a class="link" href="server-administration.html#sqlmode_strict_all_tables"><code class="literal">STRICT_ALL_TABLES</code></a>) may result in
            replication failure on an updated slave. For example, as of MySQL
            5.7.2, the server restricts insertion of a
            <code class="literal">DEFAULT</code> value of 0 for temporal data types in
            strict mode. If you use statement-based logging
            (<a class="link" href="replication.html#sysvar_binlog_format"><code class="literal">binlog_format=STATEMENT</code></a>), if a
            slave is upgraded before the master, the nonupgraded master will
            execute statements without error that may fail on the slave and
            replication will stop. To deal with this, stop all new statements
            on the master and wait until the slaves catch up. Then upgrade the
            slaves. Alternatively, if you cannot stop new statements,
            temporarily change to row-based logging on the master
            (<a class="link" href="replication.html#sysvar_binlog_format"><code class="literal">binlog_format=ROW</code></a>) and wait
            until all slaves have processed all binary logs produced up to the
            point of this change. Then upgrade the slaves.
        </p><p style="color:blue;">在strict sql模式下影响操作的更改（strict_trans_tables或strict_all_tables）可能会导致更新的从机上的复制失败。例如，从mysql 5.7.2开始，服务器在严格模式下限制插入时间数据类型的默认值0。如果使用基于语句的日志记录（binlog_format=statement），如果从机在主机之前升级，则未升级的主机将执行语句而不会出错，这可能会在从机上失败，复制将停止。要处理这个问题，请停止主节点上的所有新语句，并等待从节点赶上。然后升级奴隶。或者，如果无法停止新语句，则临时更改为基于行的主日志记录（binlog_format=row），并等待所有从服务器处理到该更改点为止生成的所有二进制日志。然后升级奴隶。</p><p>
            After the slaves have been upgraded, shut down the master, upgrade
            it to the same 5.7.x release as the slaves, and
            restart it. If you had temporarily changed the master to row-based
            logging, change it back to statement-based logging. The
            5.7 master is able to read the old binary logs
            written prior to the upgrade and to send them to the
            5.7 slaves. The slaves recognize the old format and
            handle it properly. Binary logs created by the master subsequent
            to the upgrade are in 5.7 format. These too are
            recognized by the 5.7 slaves.
        </p><p style="color:blue;">升级从机后，关闭主机，将其升级到与从机相同的5.7.x版本，然后重新启动。如果您临时将master更改为基于行的日志记录，请将其更改回基于语句的日志记录。5.7主机能够读取升级前写入的旧二进制日志，并将它们发送到5.7从机。从机可以识别旧格式并正确处理它。升级后由主机创建的二进制日志采用5.7格式。这些也被5.7个奴隶所认识。</p><p>
            In other words, when upgrading to MySQL 5.7, the
            slaves must be MySQL 5.7 before you can upgrade the
            master to 5.7. Note that downgrading from
            5.7 to older versions does not work so simply: You
            must ensure that any 5.7 binary log or relay log has
            been fully processed, so that you can remove it before proceeding
            with the downgrade.
        </p><p style="color:blue;">换言之，升级到mysql 5.7时，从机必须是mysql 5.7，才能将主机升级到5.7。请注意，从5.7降级到旧版本并不是那么简单：您必须确保已完全处理了任何5.7二进制日志或中继日志，以便可以在继续降级之前将其删除。</p><p>
            Some upgrades may require that you drop and re-create database
            objects when you move from one MySQL series to the next. For
            example, collation changes might require that table indexes be
            rebuilt. Such operations, if necessary, are detailed at
            <a class="xref" href="installing.html#upgrading-from-previous-series" title="2.11.3&nbsp;Changes in MySQL 5.7">Section&nbsp;2.11.3, “Changes in MySQL 5.7”</a>. It is safest to
            perform these operations separately on the slaves and the master,
            and to disable replication of these operations from the master to
            the slave. To achieve this, use the following procedure:
        </p><p style="color:blue;">某些升级可能需要在从一个mysql系列移动到下一个mysql系列时删除并重新创建数据库对象。例如，排序规则更改可能需要重建表索引。如有必要，可在第2.11.3节“mysql 5.7中的更改”中详细说明这些操作。最安全的做法是在从机和主机上分别执行这些操作，并禁用这些操作从主机到从机的复制。为此，请使用以下步骤：</p>
            <div class="orderedlist">
                <ol class="orderedlist" type="1"><li class="listitem"><p>
                    Stop all the slaves and upgrade them. Restart them with the
                    <a class="link" href="replication.html#option_mysqld_skip-slave-start"><code class="option">--skip-slave-start</code></a> option so
                    that they do not connect to the master. Perform any table
                    repair or rebuilding operations needed to re-create database
                    objects, such as use of <code class="literal">REPAIR TABLE</code> or
                    <code class="literal">ALTER TABLE</code>, or dumping and reloading
                    tables or triggers.
                </p><p style="color:blue;">停止所有奴隶并升级他们。使用--skip slave start选项重新启动它们，这样它们就不会连接到主节点。执行重新创建数据库对象所需的任何表修复或重建操作，例如使用修复表或更改表，或转储和重新加载表或触发器。</p></li><li class="listitem"><p>
                    Disable the binary log on the master. To do this without
                    restarting the master, execute a <code class="literal">SET sql_log_bin =
                    OFF</code> statement. Alternatively, stop the master and
                    restart it without the
                    <a class="link" href="replication.html#option_mysqld_log-bin"><code class="option">--log-bin</code></a> option. If you
                    restart the master, you might also want to disallow client
                    connections. For example, if all clients connect using TCP/IP,
                    use the <a class="link" href="server-administration.html#option_mysqld_skip-networking"><code class="option">--skip-networking</code></a>
                    option when you restart the master.
                </p><p style="color:blue;">禁用主机上的二进制日志。要在不重新启动主机的情况下执行此操作，请执行set sql_log_bin=off语句。或者，停止master并在没有--log bin选项的情况下重新启动它。如果重新启动主服务器，则可能还希望禁止客户端连接。例如，如果所有客户端都使用TCP/IP连接，则在重新启动主机时使用--skip networking选项。</p></li><li class="listitem"><p>
                    With the binary log disabled, perform any table repair or
                    rebuilding operations needed to re-create database objects.
                    The binary log must be disabled during this step to prevent
                    these operations from being logged and sent to the slaves
                    later.
                </p><p style="color:blue;">禁用二进制日志后，执行重新创建数据库对象所需的任何表修复或重建操作。在此步骤中，必须禁用二进制日志，以防止以后记录这些操作并将其发送到从属服务器。</p></li><li class="listitem"><p>
                    Re-enable the binary log on the master. If you set
                    <a class="link" href="replication.html#sysvar_sql_log_bin"><code class="literal">sql_log_bin</code></a> to
                    <code class="literal">OFF</code> earlier, execute a <code class="literal">SET
                    sql_log_bin = ON</code> statement. If you restarted the
                    master to disable the binary log, restart it with
                    <a class="link" href="replication.html#option_mysqld_log-bin"><code class="option">--log-bin</code></a>, and without
                    <a class="link" href="server-administration.html#option_mysqld_skip-networking"><code class="option">--skip-networking</code></a> so that
                    clients and slaves can connect.
                </p><p style="color:blue;">在主机上重新启用二进制日志。如果先前将sql_log_bin设置为off，请执行set sql_log_bin=on语句。如果重新启动主服务器以禁用二进制日志，请使用--log bin重新启动它，而不使用--skip networking，以便客户端和从服务器可以连接。</p></li><li class="listitem"><p>
                    Restart the slaves, this time without the
                    <a class="link" href="replication.html#option_mysqld_skip-slave-start"><code class="option">--skip-slave-start</code></a> option.
                </p><p style="color:blue;">重新启动从机，这次没有--skip slave start选项。</p></li></ol>
            </div>
            <p>
                If you are upgrading an existing replication setup from a version
                of MySQL that does not support global transaction identifiers to a
                version that does, you should not enable GTIDs on either the
                master or the slave before making sure that the setup meets all
                the requirements for GTID-based replication. For example
                <a class="link" href="replication.html#sysvar_server_uuid"><code class="literal">server_uuid</code></a>, which was added in
                MySQL 5.6, must exist for GTIDs to function correctly. See
                <a class="xref" href="replication.html#replication-gtids-howto" title="16.1.3.4&nbsp;Setting Up Replication Using GTIDs">Section&nbsp;16.1.3.4, “Setting Up Replication Using GTIDs”</a>, which contains
                information about converting existing replication setups to use
                GTID-based replication.
            </p><p style="color:blue;">如果正在从不支持全局事务标识符的MySQL版本升级现有的复制设置，那么在确保安装符合GTID复制的所有要求之前，不应在主或从上启用GTIDS。例如，在MySQL 5.6中添加的ServuiUuID必须存在于GTIDS才能正确运行。请参阅第16.1.3.4节，“使用GTIDS建立复制”，其中包含有关转换现有复制设置以使用基于GTID的复制的信息。</p><p>
            When the server is running with global transaction identifiers
            (GTIDs) enabled (<a class="link" href="replication.html#sysvar_gtid_mode"><code class="literal">gtid_mode=ON</code></a>),
            do not enable binary logging by <a class="link" href="programs.html#mysql-upgrade" title="4.4.7&nbsp;mysql_upgrade — Check and Upgrade MySQL Tables"><span class="command"><strong>mysql_upgrade</strong></span></a>.
        </p><p style="color:blue;">当服务器在启用全局事务标识符（gtid）的情况下运行（gtid_mode=on）时，不要通过mysql_upgrade启用二进制日志记录。</p><p>
            It is not recommended to load a dump file when GTIDs are enabled
            on the server (<a class="link" href="replication.html#sysvar_gtid_mode"><code class="literal">gtid_mode=ON</code></a>), if
            your dump file includes system tables.
            <a class="link" href="programs.html#mysqldump" title="4.5.4&nbsp;mysqldump — A Database Backup Program"><span class="command"><strong>mysqldump</strong></span></a> issues DML instructions for the
            system tables which use the non-transactional MyISAM storage
            engine, and this combination is not permitted when GTIDs are
            enabled. Also be aware that loading a dump file from a server with
            GTIDs enabled, into another server with GTIDs enabled, causes
            different transaction identifiers to be generated.
        </p><p style="color:blue;">如果转储文件包含系统表，建议不要在服务器上启用gtid（gtid_mode=on）时加载转储文件。mysqldump为使用非事务性myisam存储引擎的系统表发出dml指令，并且在启用gtid时不允许这种组合。还要注意，将转储文件从启用了gtids的服务器加载到启用了gtids的另一个服务器会导致生成不同的事务标识符。</p>
        </div>
        <div class="section">
            <div class="titlepage">
                <div>
                    <div>
                        <h3 class="title"><a name="replication-problems"></a>16.4.4&nbsp;Troubleshooting Replication</h3>

                    </div>

                </div>

            </div>
            <a class="indexterm" name="idm140286791203664"></a><p>
            If you have followed the instructions but your replication setup
            is not working, the first thing to do is <span class="emphasis"><em>check the error
      log for messages</em></span>. Many users have lost time by not
            doing this soon enough after encountering problems.
        </p><p style="color:blue;">如果已按照说明进行操作，但复制设置不起作用，则首先要检查错误日志中的消息。许多用户在遇到问题后没有很快做到这一点，从而浪费了时间。</p><p>
            If you cannot tell from the error log what the problem was, try
            the following techniques:
        </p><p style="color:blue;">如果无法从错误日志中判断出问题所在，请尝试以下技术：</p>
            <div class="itemizedlist">
                <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                    Verify that the master has binary logging enabled by issuing a
                    <a class="link" href="sql-syntax.html#show-master-status" title="13.7.5.23&nbsp;SHOW MASTER STATUS Syntax"><code class="literal">SHOW MASTER STATUS</code></a> statement.
                    If logging is enabled, <code class="literal">Position</code> is nonzero.
                    If binary logging is not enabled, verify that you are running
                    the master with the <a class="link" href="replication.html#option_mysqld_log-bin"><code class="option">--log-bin</code></a>
                    option.
                </p><p style="color:blue;">通过发出SHOW MASTER STATUS语句验证主机是否启用了二进制日志记录。如果启用日志记录，则位置为非零。如果未启用二进制日志记录，请验证是否正在使用--log bin选项运行主机。</p></li><li class="listitem"><p>
                    Verify that the master and slave both were started with the
                    <a class="link" href="replication.html#option_mysqld_server-id"><code class="option">--server-id</code></a> option and that the
                    ID value is unique on each server.
                </p><p style="color:blue;">验证主服务器和从服务器都是用--server id选项启动的，并且id值在每台服务器上都是唯一的。</p></li><li class="listitem"><p>
                    Verify that the slave is running. Use
                    <a class="link" href="sql-syntax.html#show-slave-status" title="13.7.5.34&nbsp;SHOW SLAVE STATUS Syntax"><code class="literal">SHOW SLAVE STATUS</code></a> to check
                    whether the <code class="literal">Slave_IO_Running</code> and
                    <code class="literal">Slave_SQL_Running</code> values are both
                    <code class="literal">Yes</code>. If not, verify the options that were
                    used when starting the slave server. For example,
                    <a class="link" href="replication.html#option_mysqld_skip-slave-start"><code class="option">--skip-slave-start</code></a> prevents the
                    slave threads from starting until you issue a
                    <a class="link" href="sql-syntax.html#start-slave" title="13.4.2.6&nbsp;START SLAVE Syntax"><code class="literal">START SLAVE</code></a> statement.
                </p><p style="color:blue;">确认从机正在运行。使用show slave status检查slave IO_running和slave SQL_running值是否都为yes。如果没有，请验证启动从属服务器时使用的选项。例如，-skip slave start防止从线程启动，直到发出start slave语句。</p></li><li class="listitem"><p>
                    If the slave is running, check whether it established a
                    connection to the master. Use <a class="link" href="sql-syntax.html#show-processlist" title="13.7.5.29&nbsp;SHOW PROCESSLIST Syntax"><code class="literal">SHOW
                    PROCESSLIST</code></a>, find the I/O and SQL threads and check
                    their <code class="literal">State</code> column to see what they
                    display. See
                    <a class="xref" href="replication.html#replication-implementation-details" title="16.2.2&nbsp;Replication Implementation Details">Section&nbsp;16.2.2, “Replication Implementation Details”</a>. If the
                    I/O thread state says <code class="literal">Connecting to master</code>,
                    check the following:
                </p><p style="color:blue;">如果从机正在运行，请检查它是否已建立到主机的连接。使用show processlist，找到i/o和sql线程并检查它们的state列以查看它们显示的内容。参见第16.2.2节“复制实现详细信息”。如果I/O线程状态显示正在连接到主线程，请检查以下内容：</p>
                    <div class="itemizedlist">
                        <ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
                            Verify the privileges for the user being used for
                            replication on the master.
                        </p><p style="color:blue;">验证用于在主服务器上进行复制的用户的权限。</p></li><li class="listitem"><p>
                            Check that the host name of the master is correct and that
                            you are using the correct port to connect to the master.
                            The port used for replication is the same as used for
                            client network communication (the default is
                            <code class="literal">3306</code>). For the host name, ensure that
                            the name resolves to the correct IP address.
                        </p><p style="color:blue;">检查主机的主机名是否正确，以及您是否使用正确的端口连接到主机。用于复制的端口与用于客户端网络通信的端口相同（默认为3306）。对于主机名，请确保该名称解析为正确的IP地址。</p></li><li class="listitem"><p>
                            Check that networking has not been disabled on the master
                            or slave. Look for the
                            <a class="link" href="server-administration.html#option_mysqld_skip-networking"><code class="option">skip-networking</code></a> option in
                            the configuration file. If present, comment it out or
                            remove it.
                        </p><p style="color:blue;">检查主设备或从设备上的网络是否被禁用。在配置文件中查找跳过网络选项。如果存在，请将其注释掉或删除。</p></li><li class="listitem"><p>
                            If the master has a firewall or IP filtering
                            configuration, ensure that the network port being used for
                            MySQL is not being filtered.
                        </p><p style="color:blue;">如果主服务器具有防火墙或IP筛选配置，请确保未筛选用于MySQL的网络端口。</p></li><li class="listitem"><p>
                            Check that you can reach the master by using
                            <code class="literal">ping</code> or
                            <code class="literal">traceroute</code>/<code class="literal">tracert</code>
                            to reach the host.
                        </p><p style="color:blue;">检查您是否可以使用ping或traceroute/tracert访问主机。</p></li></ul>
                    </div>
                </li><li class="listitem"><p>
                    If the slave was running previously but has stopped, the
                    reason usually is that some statement that succeeded on the
                    master failed on the slave. This should never happen if you
                    have taken a proper snapshot of the master, and never modified
                    the data on the slave outside of the slave thread. If the
                    slave stops unexpectedly, it is a bug or you have encountered
                    one of the known replication limitations described in
                    <a class="xref" href="replication.html#replication-features" title="16.4.1&nbsp;Replication Features and Issues">Section&nbsp;16.4.1, “Replication Features and Issues”</a>. If it is a bug, see
                    <a class="xref" href="replication.html#replication-bugs" title="16.4.5&nbsp;How to Report Replication Bugs or Problems">Section&nbsp;16.4.5, “How to Report Replication Bugs or Problems”</a>, for instructions on how to
                    report it.
                </p><p style="color:blue;">如果从机以前正在运行但已停止，原因通常是在主机上成功的某个语句在从机上失败。如果您对主线程进行了正确的快照，并且从未在从线程外部修改从线程上的数据，那么这种情况就永远不会发生。如果从机意外停止，则是一个错误，或者您遇到了第16.4.1节“复制功能和问题”中描述的已知复制限制之一。如果是一个bug，请参阅16.4.5节“如何报告复制bug或问题”，了解如何报告它的说明。</p></li><li class="listitem"><p>
                    If a statement that succeeded on the master refuses to run on
                    the slave, try the following procedure if it is not feasible
                    to do a full database resynchronization by deleting the
                    slave's databases and copying a new snapshot from the master:
                </p><p style="color:blue;">如果在主服务器上成功的语句拒绝在从服务器上运行，如果通过删除从服务器的数据库并从主服务器复制新快照来执行完全数据库重新同步不可行，请尝试以下过程：</p>
                    <div class="orderedlist">
                        <ol class="orderedlist" type="1"><li class="listitem"><p>
                            Determine whether the affected table on the slave is
                            different from the master table. Try to understand how
                            this happened. Then make the slave's table identical to
                            the master's and run <a class="link" href="sql-syntax.html#start-slave" title="13.4.2.6&nbsp;START SLAVE Syntax"><code class="literal">START
                            SLAVE</code></a>.
                        </p><p style="color:blue;">确定从机上受影响的表是否与主表不同。试着理解这是怎么发生的。然后使从机的表与主机的表相同，并运行start slave。</p></li><li class="listitem"><p>
                            If the preceding step does not work or does not apply, try
                            to understand whether it would be safe to make the update
                            manually (if needed) and then ignore the next statement
                            from the master.
                        </p><p style="color:blue;">如果前面的步骤不起作用或不适用，请尝试理解手动更新（如果需要）是否安全，然后忽略主控中的下一条语句。</p></li><li class="listitem"><p>
                            If you decide that the slave can skip the next statement
                            from the master, issue the following statements:
                        </p><p style="color:blue;">如果您决定从机可以跳过主机的下一条语句，请发出以下语句：</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>SET GLOBAL sql_slave_skip_counter = <em class="replaceable"><code>N</code></em>;</code></strong>
mysql&gt; <strong class="userinput"><code>START SLAVE;</code></strong>
</pre><p>
                            The value of <em class="replaceable"><code>N</code></em> should be 1 if
                            the next statement from the master does not use
                            <code class="literal">AUTO_INCREMENT</code> or
                            <a class="link" href="functions.html#function_last-insert-id"><code class="literal">LAST_INSERT_ID()</code></a>.
                            Otherwise, the value should be 2. The reason for using a
                            value of 2 for statements that use
                            <code class="literal">AUTO_INCREMENT</code> or
                            <a class="link" href="functions.html#function_last-insert-id"><code class="literal">LAST_INSERT_ID()</code></a> is that
                            they take two events in the binary log of the master.
                        </p><p style="color:blue;">如果master中的下一条语句不使用auto_increment或last_insert_id（），则n的值应为1。否则，该值应为2。对于使用auto_increment或last_insert_id（）的语句，使用值2的原因是它们在主节点的二进制日志中接受两个事件。</p><p>
                            See also
                            <a class="xref" href="sql-syntax.html#set-global-sql-slave-skip-counter" title="13.4.2.5&nbsp;SET GLOBAL sql_slave_skip_counter Syntax">Section&nbsp;13.4.2.5, “SET GLOBAL sql_slave_skip_counter Syntax”</a>.
                        </p><p style="color:blue;">另请参阅13.4.2.5节，“设置全局sql_slave_skip_counter语法”。</p></li><li class="listitem"><p>
                            If you are sure that the slave started out perfectly
                            synchronized with the master, and that no one has updated
                            the tables involved outside of the slave thread, then
                            presumably the discrepancy is the result of a bug. If you
                            are running the most recent version of MySQL, please
                            report the problem. If you are running an older version,
                            try upgrading to the latest production release to
                            determine whether the problem persists.
                        </p><p style="color:blue;">如果您确定从线程与主线程完全同步，并且没有人更新从线程之外涉及的表，那么这种差异可能是一个bug造成的。如果您运行的是最新版本的mysql，请报告问题。如果运行的是旧版本，请尝试升级到最新的生产版本以确定问题是否仍然存在。</p></li></ol>
                    </div>
                </li></ul>
            </div>

        </div>
        <div class="section">
            <div class="titlepage">
                <div>
                    <div>
                        <h3 class="title"><a name="replication-bugs"></a>16.4.5&nbsp;How to Report Replication Bugs or Problems</h3>

                    </div>

                </div>

            </div>
            <p>
                When you have determined that there is no user error involved, and
                replication still either does not work at all or is unstable, it
                is time to send us a bug report. We need to obtain as much
                information as possible from you to be able to track down the bug.
                Please spend some time and effort in preparing a good bug report.
            </p><p style="color:blue;">当您确定不涉及任何用户错误，并且复制仍然不起作用或不稳定时，是时候向我们发送错误报告了。我们需要从你那里获得尽可能多的信息才能追踪到这个错误。请花些时间和精力准备一份好的错误报告。</p><p>
            If you have a repeatable test case that demonstrates the bug,
            please enter it into our bugs database using the instructions
            given in <a class="xref" href="introduction.html#bug-reports" title="1.7&nbsp;How to Report Bugs or Problems">Section&nbsp;1.7, “How to Report Bugs or Problems”</a>. If you have a
            <span class="quote">“<span class="quote">phantom</span>”</span> problem (one that you cannot duplicate at
            will), use the following procedure:
        </p><p style="color:blue;">如果您有一个可重复的测试用例来演示bug，请使用第1.7节“如何报告bug或问题”中给出的说明将其输入到我们的bug数据库中。如果出现“幻影”问题（无法随意复制），请使用以下步骤：</p>
            <div class="orderedlist">
                <ol class="orderedlist" type="1"><li class="listitem"><p>
                    Verify that no user error is involved. For example, if you
                    update the slave outside of the slave thread, the data goes
                    out of synchrony, and you can have unique key violations on
                    updates. In this case, the slave thread stops and waits for
                    you to clean up the tables manually to bring them into
                    synchrony. <span class="emphasis"><em>This is not a replication problem. It is
          a problem of outside interference causing replication to
          fail.</em></span>
                </p><p style="color:blue;">确认不涉及用户错误。例如，如果在从线程外部更新从线程，数据将不同步，并且在更新时可能有唯一的密钥冲突。在这种情况下，从线程会停止并等待您手动清理表以使它们同步。这不是复制问题。这是一个外部干扰导致复制失败的问题。</p></li><li class="listitem"><p>
                    Run the slave with the
                    <a class="link" href="replication.html#sysvar_log_slave_updates"><code class="option">--log-slave-updates</code></a> and
                    <a class="link" href="replication.html#option_mysqld_log-bin"><code class="option">--log-bin</code></a> options. These
                    options cause the slave to log the updates that it receives
                    from the master into its own binary logs.
                </p><p style="color:blue;">使用--log slave updates和--log bin选项运行从机。这些选项使从机将从主机接收到的更新记录到自己的二进制日志中。</p></li><li class="listitem"><p>
                    Save all evidence before resetting the replication state. If
                    we have no information or only sketchy information, it becomes
                    difficult or impossible for us to track down the problem. The
                    evidence you should collect is:
                </p><p style="color:blue;">在重置复制状态之前保存所有证据。如果我们没有信息或只有粗略的信息，我们就很难或不可能找到问题。你应该收集的证据是：</p>
                    <div class="itemizedlist">
                        <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                            All binary log files from the master
                        </p><p style="color:blue;">来自主服务器的所有二进制日志文件</p></li><li class="listitem"><p>
                            All binary log files from the slave
                        </p><p style="color:blue;">从机上的所有二进制日志文件</p></li><li class="listitem"><p>
                            The output of <a class="link" href="sql-syntax.html#show-master-status" title="13.7.5.23&nbsp;SHOW MASTER STATUS Syntax"><code class="literal">SHOW MASTER
                            STATUS</code></a> from the master at the time you
                            discovered the problem
                        </p><p style="color:blue;">发现问题时主控形状显示主控形状的输出</p></li><li class="listitem"><p>
                            The output of <a class="link" href="sql-syntax.html#show-slave-status" title="13.7.5.34&nbsp;SHOW SLAVE STATUS Syntax"><code class="literal">SHOW SLAVE
                            STATUS</code></a> from the slave at the time you discovered
                            the problem
                        </p><p style="color:blue;">发现问题时从系统显示从系统状态的输出</p></li><li class="listitem"><p>
                            Error logs from the master and the slave
                        </p><p style="color:blue;">主设备和从设备的错误日志</p></li></ul>
                    </div>
                </li><li class="listitem"><p>
                    Use <a class="link" href="programs.html#mysqlbinlog" title="4.6.7&nbsp;mysqlbinlog — Utility for Processing Binary Log Files"><span class="command"><strong>mysqlbinlog</strong></span></a> to examine the binary logs.
                    The following should be helpful to find the problem statement.
                    <em class="replaceable"><code>log_file</code></em> and
                    <em class="replaceable"><code>log_pos</code></em> are the
                    <code class="literal">Master_Log_File</code> and
                    <code class="literal">Read_Master_Log_Pos</code> values from
                    <a class="link" href="sql-syntax.html#show-slave-status" title="13.7.5.34&nbsp;SHOW SLAVE STATUS Syntax"><code class="literal">SHOW SLAVE STATUS</code></a>.
                </p><p style="color:blue;">使用mysqlbinlog检查二进制日志。以下内容应该有助于找到问题陈述。logu file和logu pos是主日志文件，从show slave status读取主日志值。</p><pre data-lang="terminal" class="programlisting">shell&gt; <strong class="userinput"><code>mysqlbinlog --start-position=<em class="replaceable"><code>log_pos</code></em> <em class="replaceable"><code>log_file</code></em> | head</code></strong>
</pre></li></ol>
            </div>
            <p>
                After you have collected the evidence for the problem, try to
                isolate it as a separate test case first. Then enter the problem
                with as much information as possible into our bugs database using
                the instructions at <a class="xref" href="introduction.html#bug-reports" title="1.7&nbsp;How to Report Bugs or Problems">Section&nbsp;1.7, “How to Report Bugs or Problems”</a>.
            </p><p style="color:blue;">在收集了问题的证据之后，首先尝试将其分离为单独的测试用例。然后使用第1.7节“如何报告错误或问题”中的说明，将尽可能多的信息输入错误数据库。</p>
        </div>

    </div>

</div>
<div class="copyright-footer">

</div>
<div class="navfooter">
    <hr>
    <table width="100%" summary="Navigation footer">
        <tbody><tr>
            <td width="40%" align="left"><a accesskey="p" href="storage-engines.html">Prev</a></td>
            <td width="20%" align="center"><a accesskey="u" href="">Up</a></td>
            <td width="40%" align="right">&nbsp;<a accesskey="n" href="group-replication.html">Next</a></td>
        </tr>
        <tr>
            <td width="40%" align="left" valign="top">Chapter&nbsp;15 Alternative Storage Engines</td>
            <td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td>
            <td width="40%" align="right" valign="top">Chapter&nbsp;17 Group Replication</td>
        </tr>
        </tbody></table>
</div>


</body></html>