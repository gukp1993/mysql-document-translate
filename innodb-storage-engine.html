<html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
    <title>Chapter&nbsp;14 The InnoDB Storage Engine</title>
    <link rel="stylesheet" href="mvl.css" type="text/css">
    <meta name="generator" content="DocBook XSL Stylesheets + chunker.py v1.9.2">
    <link rel="start" href="index.html" title="{book-title}">
    <link rel="up" href="" title="">
    <link rel="prev" href="sql-syntax.html" title="Chapter&nbsp;13 SQL Statement Syntax">
    <link rel="next" href="storage-engines.html" title="Chapter&nbsp;15 Alternative Storage Engines">
    <script src="https://code.jquery.com/jquery-3.3.1.min.js"></script><script src="https://code.jquery.com/jquery-3.3.1.min.js"></script><script src="https://code.jquery.com/jquery-3.3.1.min.js"></script><script src="https://code.jquery.com/jquery-3.3.1.min.js"></script></head>
<body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF">
<div class="navheader">
    <table width="100%" summary="Navigation header">
        <tbody><tr>
            <th colspan="3" align="center">Chapter&nbsp;14 The InnoDB Storage Engine</th>
        </tr>
        <tr>
            <td width="20%" align="left"><a accesskey="p" href="sql-syntax.html">Prev</a>&nbsp;</td>
            <th width="60%" align="center"></th>
            <td width="20%" align="right">&nbsp;<a accesskey="n" href="storage-engines.html">Next</a></td>
        </tr>
        </tbody></table>
    <hr>
</div>
<div class="chapter">
    <div class="titlepage">
        <div>
            <div>
                <h1 class="title"><a name="innodb-storage-engine"></a>Chapter&nbsp;14&nbsp;The InnoDB Storage Engine</h1>

            </div>

        </div>

    </div>
    <div class="toc">
        <p><b>Table of Contents</b></p><p style="color:blue;">目录</p><dl class="toc"><dt><span class="section"><a href="innodb-storage-engine.html#innodb-introduction">14.1 Introduction to InnoDB</a></span></dt><dd><dl><dt><span class="section"><a href="innodb-storage-engine.html#innodb-benefits">14.1.1 Benefits of Using InnoDB Tables</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-best-practices">14.1.2 Best Practices for InnoDB Tables</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-check-availability">14.1.3 Verifying that InnoDB is the Default Storage Engine</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-benchmarking">14.1.4 Testing and Benchmarking with InnoDB</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-turning-off">14.1.5 Turning Off InnoDB</a></span></dt></dl></dd><dt><span class="section"><a href="innodb-storage-engine.html#mysql-acid">14.2 InnoDB and the ACID Model</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-multi-versioning">14.3 InnoDB Multi-Versioning</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-architecture">14.4 InnoDB Architecture</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-in-memory-structures">14.5 InnoDB In-Memory Structures</a></span></dt><dd><dl><dt><span class="section"><a href="innodb-storage-engine.html#innodb-buffer-pool">14.5.1 Buffer Pool</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-change-buffer">14.5.2 Change Buffer</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-adaptive-hash">14.5.3 Adaptive Hash Index</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-redo-log-buffer">14.5.4 Log Buffer</a></span></dt></dl></dd><dt><span class="section"><a href="innodb-storage-engine.html#innodb-on-disk-structures">14.6 InnoDB On-Disk Structures</a></span></dt><dd><dl><dt><span class="section"><a href="innodb-storage-engine.html#innodb-tables">14.6.1 Tables</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-indexes">14.6.2 Indexes</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-tablespace">14.6.3 Tablespaces</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-data-dictionary">14.6.4 InnoDB Data Dictionary</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-doublewrite-buffer">14.6.5 Doublewrite Buffer</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-redo-log">14.6.6 Redo Log</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-undo-logs">14.6.7 Undo Logs</a></span></dt></dl></dd><dt><span class="section"><a href="innodb-storage-engine.html#innodb-locking-transaction-model">14.7 InnoDB Locking and Transaction Model</a></span></dt><dd><dl><dt><span class="section"><a href="innodb-storage-engine.html#innodb-locking">14.7.1 InnoDB Locking</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-transaction-model">14.7.2 InnoDB Transaction Model</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-locks-set">14.7.3 Locks Set by Different SQL Statements in InnoDB</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-next-key-locking">14.7.4 Phantom Rows</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-deadlocks">14.7.5 Deadlocks in InnoDB</a></span></dt></dl></dd><dt><span class="section"><a href="innodb-storage-engine.html#innodb-configuration">14.8 InnoDB Configuration</a></span></dt><dd><dl><dt><span class="section"><a href="innodb-storage-engine.html#innodb-init-startup-configuration">14.8.1 InnoDB Startup Configuration</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-read-only-instance">14.8.2 Configuring InnoDB for Read-Only Operation</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-performance-buffer-pool">14.8.3 InnoDB Buffer Pool Configuration</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-performance-use_sys_malloc">14.8.4 Configuring the Memory Allocator for InnoDB</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-performance-thread_concurrency">14.8.5 Configuring Thread Concurrency for InnoDB</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-performance-multiple_io_threads">14.8.6 Configuring the Number of Background InnoDB I/O Threads</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-linux-native-aio">14.8.7 Using Asynchronous I/O on Linux</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-configuring-io-capacity">14.8.8 Configuring InnoDB I/O Capacity</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-performance-spin_lock_polling">14.8.9 Configuring Spin Lock Polling</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-purge-configuration">14.8.10 Purge Configuration</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-performance-optimizer-statistics">14.8.11 Configuring Optimizer Statistics for InnoDB</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#index-page-merge-threshold">14.8.12 Configuring the Merge Threshold for Index Pages</a></span></dt></dl></dd><dt><span class="section"><a href="innodb-storage-engine.html#innodb-compression">14.9 InnoDB Table and Page Compression</a></span></dt><dd><dl><dt><span class="section"><a href="innodb-storage-engine.html#innodb-table-compression">14.9.1 InnoDB Table Compression</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-page-compression">14.9.2 InnoDB Page Compression</a></span></dt></dl></dd><dt><span class="section"><a href="innodb-storage-engine.html#innodb-file-format">14.10 InnoDB File-Format Management</a></span></dt><dd><dl><dt><span class="section"><a href="innodb-storage-engine.html#innodb-file-format-enabling">14.10.1 Enabling File Formats</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-file-format-compatibility">14.10.2 Verifying File Format Compatibility</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-file-format-identifying">14.10.3 Identifying the File Format in Use</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-file-format-downgrading">14.10.4 Modifying the File Format</a></span></dt></dl></dd><dt><span class="section"><a href="innodb-storage-engine.html#innodb-row-format">14.11 InnoDB Row Formats</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-disk-management">14.12 InnoDB Disk I/O and File Space Management</a></span></dt><dd><dl><dt><span class="section"><a href="innodb-storage-engine.html#innodb-disk-io">14.12.1 InnoDB Disk I/O</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-file-space">14.12.2 File Space Management</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-checkpoints">14.12.3 InnoDB Checkpoints</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-file-defragmenting">14.12.4 Defragmenting a Table</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-truncate-table-reclaim-space">14.12.5 Reclaiming Disk Space with TRUNCATE TABLE</a></span></dt></dl></dd><dt><span class="section"><a href="innodb-storage-engine.html#innodb-online-ddl">14.13 InnoDB and Online DDL</a></span></dt><dd><dl><dt><span class="section"><a href="innodb-storage-engine.html#innodb-online-ddl-operations">14.13.1 Online DDL Operations</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-online-ddl-performance">14.13.2 Online DDL Performance and Concurrency</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-online-ddl-space-requirements">14.13.3 Online DDL Space Requirements</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-online-ddl-single-multi">14.13.4 Simplifying DDL Statements with Online DDL</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-online-ddl-failure-conditions">14.13.5 Online DDL Failure Conditions</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-online-ddl-limitations">14.13.6 Online DDL Limitations</a></span></dt></dl></dd><dt><span class="section"><a href="innodb-storage-engine.html#innodb-parameters">14.14 InnoDB Startup Options and System Variables</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-information-schema">14.15 InnoDB INFORMATION_SCHEMA Tables</a></span></dt><dd><dl><dt><span class="section"><a href="innodb-storage-engine.html#innodb-information-schema-compression-tables">14.15.1 InnoDB INFORMATION_SCHEMA Tables about Compression</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-information-schema-transactions">14.15.2 InnoDB INFORMATION_SCHEMA Transaction and Locking Information</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-information-schema-system-tables">14.15.3 InnoDB INFORMATION_SCHEMA System Tables</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-information-schema-fulltext_index-tables">14.15.4 InnoDB INFORMATION_SCHEMA FULLTEXT Index Tables</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-information-schema-buffer-pool-tables">14.15.5 InnoDB INFORMATION_SCHEMA Buffer Pool Tables</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-information-schema-metrics-table">14.15.6 InnoDB INFORMATION_SCHEMA Metrics Table</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-information-schema-temp-table-info">14.15.7 InnoDB INFORMATION_SCHEMA Temporary Table Info Table</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-information-schema-files-table">14.15.8 Retrieving InnoDB Tablespace Metadata from INFORMATION_SCHEMA.FILES</a></span></dt></dl></dd><dt><span class="section"><a href="innodb-storage-engine.html#innodb-performance-schema">14.16 InnoDB Integration with MySQL Performance Schema</a></span></dt><dd><dl><dt><span class="section"><a href="innodb-storage-engine.html#monitor-alter-table-performance-schema">14.16.1 Monitoring ALTER TABLE Progress for InnoDB Tables Using Performance
Schema</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#monitor-innodb-mutex-waits-performance-schema">14.16.2 Monitoring InnoDB Mutex Waits Using Performance Schema</a></span></dt></dl></dd><dt><span class="section"><a href="innodb-storage-engine.html#innodb-monitors">14.17 InnoDB Monitors</a></span></dt><dd><dl><dt><span class="section"><a href="innodb-storage-engine.html#innodb-monitor-types">14.17.1 InnoDB Monitor Types</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-enabling-monitors">14.17.2 Enabling InnoDB Monitors</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-standard-monitor">14.17.3 InnoDB Standard Monitor and Lock Monitor Output</a></span></dt></dl></dd><dt><span class="section"><a href="innodb-storage-engine.html#innodb-backup-recovery">14.18 InnoDB Backup and Recovery</a></span></dt><dd><dl><dt><span class="section"><a href="innodb-storage-engine.html#innodb-backup">14.18.1 InnoDB Backup</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-recovery">14.18.2 InnoDB Recovery</a></span></dt></dl></dd><dt><span class="section"><a href="innodb-storage-engine.html#innodb-and-mysql-replication">14.19 InnoDB and MySQL Replication</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-memcached">14.20 InnoDB memcached Plugin</a></span></dt><dd><dl><dt><span class="section"><a href="innodb-storage-engine.html#innodb-memcached-benefits">14.20.1 Benefits of the InnoDB memcached Plugin</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-memcached-intro">14.20.2 InnoDB memcached Architecture</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-memcached-setup">14.20.3 Setting Up the InnoDB memcached Plugin</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-memcached-security">14.20.4 Security Considerations for the InnoDB memcached Plugin</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-memcached-developing">14.20.5 Writing Applications for the InnoDB memcached Plugin</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-memcached-replication">14.20.6 The InnoDB memcached Plugin and Replication</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-memcached-internals">14.20.7 InnoDB memcached Plugin Internals</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-memcached-troubleshoot">14.20.8 Troubleshooting the InnoDB memcached Plugin</a></span></dt></dl></dd><dt><span class="section"><a href="innodb-storage-engine.html#innodb-troubleshooting">14.21 InnoDB Troubleshooting</a></span></dt><dd><dl><dt><span class="section"><a href="innodb-storage-engine.html#error-creating-innodb">14.21.1 Troubleshooting InnoDB I/O Problems</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#forcing-innodb-recovery">14.21.2 Forcing InnoDB Recovery</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-troubleshooting-datadict">14.21.3 Troubleshooting InnoDB Data Dictionary Operations</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-error-handling">14.21.4 InnoDB Error Handling</a></span></dt></dl></dd></dl>
    </div>
    <div class="section">
        <div class="titlepage">
            <div>
                <div>
                    <h2 class="title" style="clear: both"><a name="innodb-introduction"></a>14.1&nbsp;Introduction to InnoDB</h2>

                </div>

            </div>

        </div>
        <div class="toc">
            <dl class="toc"><dt><span class="section"><a href="innodb-storage-engine.html#innodb-benefits">14.1.1 Benefits of Using InnoDB Tables</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-best-practices">14.1.2 Best Practices for InnoDB Tables</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-check-availability">14.1.3 Verifying that InnoDB is the Default Storage Engine</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-benchmarking">14.1.4 Testing and Benchmarking with InnoDB</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-turning-off">14.1.5 Turning Off InnoDB</a></span></dt></dl>
        </div>
        <a class="indexterm" name="idm140286824912464"></a><a class="indexterm" name="idm140286824910976"></a><a class="indexterm" name="idm140286824909904"></a><a class="indexterm" name="idm140286824908416"></a><a class="indexterm" name="idm140286824907344"></a><a class="indexterm" name="idm140286824905856"></a><a class="indexterm" name="idm140286824904784"></a><a class="indexterm" name="idm140286824903712"></a><a class="indexterm" name="idm140286824902640"></a><p>
        <code class="literal">InnoDB</code> is a general-purpose storage engine that
        balances high reliability and high performance. In MySQL
        5.7, <code class="literal">InnoDB</code> is the default MySQL
        storage engine. Unless you have configured a different default
        storage engine, issuing a <a class="link" href="sql-syntax.html#create-table" title="13.1.18&nbsp;CREATE TABLE Syntax"><code class="literal">CREATE
        TABLE</code></a> statement without an <code class="literal">ENGINE=</code>
        clause creates an <code class="literal">InnoDB</code> table.
    </p><p style="color:blue;">InnoDB是一个通用存储引擎，它平衡了高可靠性和高性能。在mysql 5.7中，innodb是默认的mysql存储引擎。除非您配置了不同的默认存储引擎，否则在不使用engine=子句的情况下发出create table语句将创建innodb表。</p>
        <h3><a name="innodb-key-advantages"></a>Key Advantages of InnoDB</h3>
        <div class="itemizedlist">
            <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                Its <a class="link" href="glossary.html#glos_dml" title="DML">DML</a> operations follow the
                <a class="link" href="glossary.html#glos_acid" title="ACID">ACID</a> model, with
                <a class="link" href="glossary.html#glos_transaction" title="transaction">transactions</a> featuring
                <a class="link" href="glossary.html#glos_commit" title="commit">commit</a>,
                <a class="link" href="glossary.html#glos_rollback" title="rollback">rollback</a>, and
                <a class="link" href="glossary.html#glos_crash_recovery" title="crash recovery">crash-recovery</a>
                capabilities to protect user data. See
                <a class="xref" href="innodb-storage-engine.html#mysql-acid" title="14.2&nbsp;InnoDB and the ACID Model">Section&nbsp;14.2, “InnoDB and the ACID Model”</a> for more information.
            </p><p style="color:blue;">它的dml操作遵循acid模型，事务具有提交、回滚和崩溃恢复功能，以保护用户数据。更多信息见第14.2节“InnoDB和ACID模型”。</p></li><li class="listitem"><p>
                Row-level <a class="link" href="glossary.html#glos_locking" title="locking">locking</a> and
                Oracle-style <a class="link" href="glossary.html#glos_consistent_read" title="consistent read">consistent
                reads</a> increase multi-user concurrency and performance.
                See <a class="xref" href="innodb-storage-engine.html#innodb-locking-transaction-model" title="14.7&nbsp;InnoDB Locking and Transaction Model">Section&nbsp;14.7, “InnoDB Locking and Transaction Model”</a> for more
                information.
            </p><p style="color:blue;">行级锁定和oracle风格的一致读取提高了多用户并发性和性能。有关更多信息，请参阅第14.7节“InnoDB锁定和事务模型”。</p></li><li class="listitem"><p>
                <code class="literal">InnoDB</code> tables arrange your data on disk to
                optimize queries based on
                <a class="link" href="glossary.html#glos_primary_key" title="primary key">primary keys</a>. Each
                <code class="literal">InnoDB</code> table has a primary key index called
                the <a class="link" href="glossary.html#glos_clustered_index" title="clustered index">clustered index</a>
                that organizes the data to minimize I/O for primary key lookups.
                See <a class="xref" href="innodb-storage-engine.html#innodb-index-types" title="14.6.2.1&nbsp;Clustered and Secondary Indexes">Section&nbsp;14.6.2.1, “Clustered and Secondary Indexes”</a> for more information.
            </p><p style="color:blue;">innodb tables根据主键排列磁盘上的数据以优化查询。每个innodb表都有一个主键索引，称为聚集索引，它组织数据以最小化主键查找的i/o。有关详细信息，请参阅第14.6.2.1节“聚集索引和辅助索引”。</p></li><li class="listitem"><p>
                To maintain data
                <a class="link" href="glossary.html#glos_referential_integrity" title="referential integrity">integrity</a>,
                <code class="literal">InnoDB</code> supports
                <a class="link" href="glossary.html#glos_foreign_key" title="foreign key"><code class="literal">FOREIGN
                    KEY</code></a> constraints. With foreign keys, inserts,
                updates, and deletes are checked to ensure they do not result in
                inconsistencies across different tables. See
                <a class="xref" href="innodb-storage-engine.html#innodb-foreign-key-constraints" title="14.6.1.5&nbsp;InnoDB and FOREIGN KEY Constraints">Section&nbsp;14.6.1.5, “InnoDB and FOREIGN KEY Constraints”</a> for more
                information.
            </p><p style="color:blue;">为了保持数据的完整性，innodb支持外键约束。对于外键，将检查插入、更新和删除，以确保它们不会导致不同表之间的不一致。有关更多信息，请参阅第14.6.1.5节“innodb和外键约束”。</p></li></ul>
        </div>

        <div class="table">
            <a name="idm140286824875472"></a><p class="title"><b>Table&nbsp;14.1&nbsp;InnoDB Storage Engine Features</b></p><p style="color:blue;">表14.1 InnoDB存储引擎特性</p>
            <div class="table-contents">
                <table frame="box" rules="all" summary="Features supported by the InnoDB storage engine."><colgroup><col width="60%"><col width="40%"></colgroup><thead><tr><th scope="col">Feature</th>
                    <th scope="col">Support</th>
                </tr></thead><tbody><tr><td scope="row"><span class="bold"><strong>B-tree indexes</strong></span></td>
                    <td>Yes</td>
                </tr><tr><td scope="row"><span class="bold"><strong>Backup/point-in-time recovery</strong></span> (Implemented in the server, rather than in the storage engine.)</td>
                    <td>Yes</td>
                </tr><tr><td scope="row"><span class="bold"><strong>Cluster database support</strong></span></td>
                    <td>No</td>
                </tr><tr><td scope="row"><span class="bold"><strong>Clustered indexes</strong></span></td>
                    <td>Yes</td>
                </tr><tr><td scope="row"><span class="bold"><strong>Compressed data</strong></span></td>
                    <td>Yes</td>
                </tr><tr><td scope="row"><span class="bold"><strong>Data caches</strong></span></td>
                    <td>Yes</td>
                </tr><tr><td scope="row"><span class="bold"><strong>Encrypted data</strong></span></td>
                    <td>Yes (Implemented in the server via encryption functions; In MySQL 5.7 and later, data-at-rest tablespace encryption is supported.)</td>
                </tr><tr><td scope="row"><span class="bold"><strong>Foreign key support</strong></span></td>
                    <td>Yes</td>
                </tr><tr><td scope="row"><span class="bold"><strong>Full-text search indexes</strong></span></td>
                    <td>Yes (InnoDB support for FULLTEXT indexes is available in MySQL 5.6 and later.)</td>
                </tr><tr><td scope="row"><span class="bold"><strong>Geospatial data type support</strong></span></td>
                    <td>Yes</td>
                </tr><tr><td scope="row"><span class="bold"><strong>Geospatial indexing support</strong></span></td>
                    <td>Yes (InnoDB support for geospatial indexing is available in MySQL 5.7 and later.)</td>
                </tr><tr><td scope="row"><span class="bold"><strong>Hash indexes</strong></span></td>
                    <td>No (InnoDB utilizes hash indexes internally for its Adaptive Hash Index feature.)</td>
                </tr><tr><td scope="row"><span class="bold"><strong>Index caches</strong></span></td>
                    <td>Yes</td>
                </tr><tr><td scope="row"><span class="bold"><strong>Locking granularity</strong></span></td>
                    <td>Row</td>
                </tr><tr><td scope="row"><span class="bold"><strong>MVCC</strong></span></td>
                    <td>Yes</td>
                </tr><tr><td scope="row"><span class="bold"><strong>Replication support</strong></span> (Implemented in the server, rather than in the storage engine.)</td>
                    <td>Yes</td>
                </tr><tr><td scope="row"><span class="bold"><strong>Storage limits</strong></span></td>
                    <td>64TB</td>
                </tr><tr><td scope="row"><span class="bold"><strong>T-tree indexes</strong></span></td>
                    <td>No</td>
                </tr><tr><td scope="row"><span class="bold"><strong>Transactions</strong></span></td>
                    <td>Yes</td>
                </tr><tr><td scope="row"><span class="bold"><strong>Update statistics for data dictionary</strong></span></td>
                    <td>Yes</td>
                </tr></tbody></table>
            </div>

        </div>
        <br class="table-break"><p>
        To compare the features of <code class="literal">InnoDB</code> with other
        storage engines provided with MySQL, see the <span class="emphasis"><em>Storage
    Engine Features</em></span> table in
        <a class="xref" href="storage-engines.html" title="Chapter&nbsp;15&nbsp;Alternative Storage Engines">Chapter&nbsp;15, <i>Alternative Storage Engines</i></a>.
    </p><p style="color:blue;">要将InnoDB的特性与MySQL提供的其他存储引擎进行比较，请参阅第15章“替代存储引擎”中的存储引擎特性表。</p>
        <h3><a name="innodb-enhancements"></a>InnoDB Enhancements and New Features</h3>
        <p>
            For information about <code class="literal">InnoDB</code> enhancements and new
            features, refer to:
        </p><p style="color:blue;">有关InnoDB增强功能和新功能的信息，请参阅：</p>
        <div class="itemizedlist">
            <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                The <code class="literal">InnoDB</code> enhancements list in
                <a class="xref" href="introduction.html#mysql-nutshell" title="1.4&nbsp;What Is New in MySQL 5.7">Section&nbsp;1.4, “What Is New in MySQL 5.7”</a>.
            </p><p style="color:blue;">第1.4节“mysql 5.7的新特性”中的innodb增强列表。</p></li><li class="listitem"><p>
                The
                <a class="ulink" href="https://dev.mysql.com/doc/relnotes/mysql/5.7/en/" target="_top">Release
                    Notes</a>.
            </p><p style="color:blue;">发行说明。</p></li></ul>
        </div>
        <h3><a name="innodb-additional-resources"></a>Additional InnoDB Information and Resources</h3>
        <div class="itemizedlist">
            <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                For <code class="literal">InnoDB</code>-related terms and definitions, see
                the <a class="xref" href="glossary.html" title="MySQL Glossary">MySQL Glossary</a>.
            </p><p style="color:blue;">有关innodb相关术语和定义，请参阅mysql词汇表。</p></li><li class="listitem"><p>
                For a forum dedicated to the <code class="literal">InnoDB</code> storage
                engine, see
                <a class="ulink" href="http://forums.mysql.com/list.php?22" target="_top">MySQL
                    Forums::InnoDB</a>.
            </p><p style="color:blue;">有关innodb存储引擎专用论坛，请参见mysql forums：：innodb。</p></li><li class="listitem"><p>
                <code class="literal">InnoDB</code> is published under the same GNU GPL
                License Version 2 (of June 1991) as MySQL. For more information
                on MySQL licensing, see
                <a class="ulink" href="http://www.mysql.com/company/legal/licensing/" target="_top">http://www.mysql.com/company/legal/licensing/</a>.
            </p><p style="color:blue;">InnoDB是在与MySQL相同的GNU GPL许可版本2（1991年6月）下发布的。有关mysql许可的更多信息，请参见http://www.mysql.com/company/legal/licensing/。</p></li></ul>
        </div>
        <div class="section">
            <div class="titlepage">
                <div>
                    <div>
                        <h3 class="title"><a name="innodb-benefits"></a>14.1.1&nbsp;Benefits of Using InnoDB Tables</h3>

                    </div>

                </div>

            </div>
            <p>
                You may find <code class="literal">InnoDB</code> tables beneficial for the
                following reasons:
            </p><p style="color:blue;">您可能会发现innodb表有以下好处：</p>
            <div class="itemizedlist">
                <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                    If your server crashes because of a hardware or software
                    issue, regardless of what was happening in the database at the
                    time, you don't need to do anything special after restarting
                    the database. <code class="literal">InnoDB</code>
                    <a class="link" href="glossary.html#glos_crash_recovery" title="crash recovery">crash recovery</a>
                    automatically finalizes any changes that were committed before
                    the time of the crash, and undoes any changes that were in
                    process but not committed. Just restart and continue where you
                    left off.
                </p><p style="color:blue;">如果您的服务器由于硬件或软件问题而崩溃，无论当时数据库中发生了什么，重新启动数据库后不需要执行任何特殊操作。innodb crash recovery会自动完成崩溃前提交的任何更改，并撤消正在进行但未提交的任何更改。重新开始，继续你离开的地方。</p></li><li class="listitem"><p>
                    The <code class="literal">InnoDB</code> storage engine maintains its own
                    <a class="link" href="glossary.html#glos_buffer_pool" title="buffer pool">buffer pool</a> that
                    caches table and index data in main memory as data is
                    accessed. Frequently used data is processed directly from
                    memory. This cache applies to many types of information and
                    speeds up processing. On dedicated database servers, up to 80%
                    of physical memory is often assigned to the buffer pool.
                </p><p style="color:blue;">innodb存储引擎维护自己的缓冲池，当数据被访问时，缓冲池将表和索引数据缓存在主内存中。经常使用的数据直接从内存中处理。此缓存适用于多种类型的信息并加快处理速度。在专用数据库服务器上，多达80%的物理内存通常分配给缓冲池。</p></li><li class="listitem"><p>
                    If you split up related data into different tables, you can
                    set up <a class="link" href="glossary.html#glos_foreign_key" title="foreign key">foreign keys</a>
                    that enforce
                    <a class="link" href="glossary.html#glos_referential_integrity" title="referential integrity">referential
                        integrity</a>. Update or delete data, and the related data
                    in other tables is updated or deleted automatically. Try to
                    insert data into a secondary table without corresponding data
                    in the primary table, and the bad data gets kicked out
                    automatically.
                </p><p style="color:blue;">如果将相关数据拆分为不同的表，则可以设置强制引用完整性的外键。更新或删除数据，其他表中的相关数据将自动更新或删除。尝试在主表中没有相应数据的情况下将数据插入到辅助表中，错误数据将自动被踢出。</p></li><li class="listitem"><p>
                    If data becomes corrupted on disk or in memory, a
                    <a class="link" href="glossary.html#glos_checksum" title="checksum">checksum</a> mechanism alerts
                    you to the bogus data before you use it.
                </p><p style="color:blue;">如果数据在磁盘上或内存中损坏，校验和机制会在使用之前提醒您使用虚假数据。</p></li><li class="listitem"><p>
                    When you design your database with appropriate
                    <a class="link" href="glossary.html#glos_primary_key" title="primary key">primary key</a> columns
                    for each table, operations involving those columns are
                    automatically optimized. It is very fast to reference the
                    primary key columns in
                    <a class="link" href="sql-syntax.html#select" title="13.2.9&nbsp;SELECT Syntax"><code class="literal">WHERE</code></a>
                    clauses, <a class="link" href="sql-syntax.html#select" title="13.2.9&nbsp;SELECT Syntax"><code class="literal">ORDER
                    BY</code></a> clauses,
                    <a class="link" href="sql-syntax.html#select" title="13.2.9&nbsp;SELECT Syntax"><code class="literal">GROUP BY</code></a>
                    clauses, and <a class="link" href="glossary.html#glos_join" title="join">join</a> operations.
                </p><p style="color:blue;">当为每个表设计具有适当主键列的数据库时，涉及这些列的操作将自动优化。在where子句、order by子句、group by子句和join操作中引用主键列非常快。</p></li><li class="listitem"><p>
                    Inserts, updates, and deletes are optimized by an automatic
                    mechanism called <a class="link" href="glossary.html#glos_change_buffering" title="change buffering">change
                    buffering</a>. <code class="literal">InnoDB</code> not only allows
                    concurrent read and write access to the same table, it caches
                    changed data to streamline disk I/O.
                </p><p style="color:blue;">插入、更新和删除由一种称为更改缓冲的自动机制优化。innodb不仅允许对同一个表进行并发读写访问，还缓存更改后的数据以优化磁盘i/o。</p></li><li class="listitem"><p>
                    Performance benefits are not limited to giant tables with
                    long-running queries. When the same rows are accessed over and
                    over from a table, a feature called the
                    <a class="link" href="glossary.html#glos_adaptive_hash_index" title="adaptive hash index">Adaptive Hash
                        Index</a> takes over to make these lookups even faster, as
                    if they came out of a hash table.
                </p><p style="color:blue;">性能优势不仅限于具有长时间运行查询的大型表。当从一个表中一遍又一遍地访问相同的行时，一个称为自适应哈希索引的特性将接管这些查找，使其更快，就好像它们是从哈希表中出来的一样。</p></li><li class="listitem"><p>
                    You can compress tables and associated indexes.
                </p><p style="color:blue;">您可以压缩表和相关的索引。</p></li><li class="listitem"><p>
                    You can create and drop indexes with much less impact on
                    performance and availability.
                </p><p style="color:blue;">您可以创建和删除对性能和可用性影响小得多的索引。</p></li><li class="listitem"><p>
                    Truncating a
                    <a class="link" href="glossary.html#glos_file_per_table" title="file-per-table">file-per-table</a>
                    tablespace is very fast, and can free up disk space for the
                    operating system to reuse, rather than freeing up space within
                    the <a class="link" href="glossary.html#glos_system_tablespace" title="system tablespace">system
                    tablespace</a> that only <code class="literal">InnoDB</code> can
                    reuse.
                </p><p style="color:blue;">每表表空间截断一个文件非常快，可以释放磁盘空间供操作系统重用，而不是释放系统表空间中只有innodb可以重用的空间。</p></li><li class="listitem"><p>
                    The storage layout for table data is more efficient for
                    <a class="link" href="data-types.html#blob" title="11.4.3&nbsp;The BLOB and TEXT Types"><code class="literal">BLOB</code></a> and long text fields, with
                    the <a class="link" href="glossary.html#glos_dynamic_row_format" title="dynamic row format">DYNAMIC</a> row
                    format.
                </p><p style="color:blue;">对于blob和长文本字段，使用动态行格式，表数据的存储布局更有效。</p></li><li class="listitem"><p>
                    You can monitor the internal workings of the storage engine by
                    querying
                    <a class="link" href="glossary.html#glos_information_schema" title="INFORMATION_SCHEMA">INFORMATION_SCHEMA</a>
                    tables.
                </p><p style="color:blue;">您可以通过查询信息架构表来监视存储引擎的内部工作。</p></li><li class="listitem"><p>
                    You can monitor the performance details of the storage engine
                    by querying
                    <a class="link" href="glossary.html#glos_performance_schema" title="Performance Schema">Performance
                        Schema</a> tables.
                </p><p style="color:blue;">您可以通过查询性能架构表来监视存储引擎的性能详细信息。</p></li><li class="listitem"><p>
                    You can freely mix <code class="literal">InnoDB</code> tables with
                    tables from other MySQL storage engines, even within the same
                    statement. For example, you can use a
                    <a class="link" href="glossary.html#glos_join" title="join">join</a> operation to combine
                    data from <code class="literal">InnoDB</code> and
                    <a class="link" href="storage-engines.html#memory-storage-engine" title="15.3&nbsp;The MEMORY Storage Engine"><code class="literal">MEMORY</code></a> tables in a single query.
                </p><p style="color:blue;">即使在同一条语句中，也可以将innodb表与其他mysql存储引擎中的表自由混合。例如，可以使用join操作将innodb和内存表中的数据合并到一个查询中。</p></li><li class="listitem"><p>
                    <code class="literal">InnoDB</code> has been designed for CPU efficiency
                    and maximum performance when processing large data volumes.
                </p><p style="color:blue;">在处理大数据量时，InNDB已经被设计用于CPU效率和最大性能。</p></li><li class="listitem"><p>
                    <code class="literal">InnoDB</code> tables can handle large quantities
                    of data, even on operating systems where file size is limited
                    to 2GB.
                </p><p style="color:blue;">innodb表可以处理大量数据，即使在文件大小限制为2gb的操作系统上也是如此。</p></li></ul>
            </div>
            <p>
                For <code class="literal">InnoDB</code>-specific tuning techniques you can
                apply in your application code, see
                <a class="xref" href="optimization.html#optimizing-innodb" title="8.5&nbsp;Optimizing for InnoDB Tables">Section&nbsp;8.5, “Optimizing for InnoDB Tables”</a>.
            </p><p style="color:blue;">有关可以在应用程序代码中应用的innodb特定优化技术，请参阅8.5节“优化innodb表”。</p>
        </div>
        <div class="section">
            <div class="titlepage">
                <div>
                    <div>
                        <h3 class="title"><a name="innodb-best-practices"></a>14.1.2&nbsp;Best Practices for InnoDB Tables</h3>

                    </div>

                </div>

            </div>
            <p>
                This section describes best practices when using
                <code class="literal">InnoDB</code> tables.
            </p><p style="color:blue;">本节介绍使用innodb表时的最佳实践。</p>
            <div class="itemizedlist">
                <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                    Specifying a <a class="link" href="glossary.html#glos_primary_key" title="primary key">primary
                    key</a> for every table using the most frequently queried
                    column or columns, or an
                    <a class="link" href="glossary.html#glos_auto_increment" title="auto-increment">auto-increment</a>
                    value if there is no obvious primary key.
                </p><p style="color:blue;">使用最常查询的列为每个表指定主键，如果没有明显的主键，则为其指定自动增量值。</p></li><li class="listitem"><p>
                    Using <a class="link" href="glossary.html#glos_join" title="join">joins</a> wherever data is
                    pulled from multiple tables based on identical ID values from
                    those tables. For fast join performance, define
                    <a class="link" href="glossary.html#glos_foreign_key" title="foreign key">foreign keys</a> on the
                    join columns, and declare those columns with the same data
                    type in each table. Adding foreign keys ensures that
                    referenced columns are indexed, which can improve performance.
                    Foreign keys also propagate deletes or updates to all affected
                    tables, and prevent insertion of data in a child table if the
                    corresponding IDs are not present in the parent table.
                </p><p style="color:blue;">在根据来自多个表的相同id值从多个表中提取数据时使用联接。为了快速连接性能，在连接列上定义外键，并在每个表中声明具有相同数据类型的列。添加外键可确保对引用列进行索引，从而提高性能。外键还将删除或更新传播到所有受影响的表，并防止在父表中不存在相应的id时在子表中插入数据。</p></li><li class="listitem"><p>
                    Turning off <a class="link" href="glossary.html#glos_autocommit" title="autocommit">autocommit</a>.
                    Committing hundreds of times a second puts a cap on
                    performance (limited by the write speed of your storage
                    device).
                </p><p style="color:blue;">关闭自动提交。每秒提交数百次会限制性能（受存储设备的写入速度限制）。</p></li><li class="listitem"><p>
                    Grouping sets of related <a class="link" href="glossary.html#glos_dml" title="DML">DML</a>
                    operations into
                    <a class="link" href="glossary.html#glos_transaction" title="transaction">transactions</a>, by
                    bracketing them with <code class="literal">START TRANSACTION</code> and
                    <code class="literal">COMMIT</code> statements. While you don't want to
                    commit too often, you also don't want to issue huge batches of
                    <a class="link" href="sql-syntax.html#insert" title="13.2.5&nbsp;INSERT Syntax"><code class="literal">INSERT</code></a>,
                    <a class="link" href="sql-syntax.html#update" title="13.2.11&nbsp;UPDATE Syntax"><code class="literal">UPDATE</code></a>, or
                    <a class="link" href="sql-syntax.html#delete" title="13.2.2&nbsp;DELETE Syntax"><code class="literal">DELETE</code></a> statements that run for
                    hours without committing.
                </p><p style="color:blue;">通过用start transaction和commit语句将相关dml操作集分组到事务中。虽然您不想太频繁地提交，但也不想发出大量的insert、update或delete语句，这些语句在运行数小时后都没有提交。</p></li><li class="listitem"><p>
                    Not using <a class="link" href="sql-syntax.html#lock-tables" title="13.3.5&nbsp;LOCK TABLES and UNLOCK TABLES Syntax"><code class="literal">LOCK TABLES</code></a>
                    statements. <code class="literal">InnoDB</code> can handle multiple
                    sessions all reading and writing to the same table at once,
                    without sacrificing reliability or high performance. To get
                    exclusive write access to a set of rows, use the
                    <a class="link" href="innodb-storage-engine.html#innodb-locking-reads" title="14.7.2.4&nbsp;Locking Reads"><code class="literal">SELECT
                        ... FOR UPDATE</code></a> syntax to lock just the rows you
                    intend to update.
                </p><p style="color:blue;">不使用锁表语句。innodb可以同时处理多个会话，所有的读写都在同一个表上，而不会牺牲可靠性或高性能。要获得对一组行的独占写访问权，请使用选择…更新语法只锁定要更新的行。</p></li><li class="listitem"><p>
                    Enabling the
                    <a class="link" href="innodb-storage-engine.html#sysvar_innodb_file_per_table"><code class="literal">innodb_file_per_table</code></a> option
                    or using general tablespaces to put the data and indexes for
                    tables into separate files, instead of the
                    <a class="link" href="glossary.html#glos_system_tablespace" title="system tablespace">system
                        tablespace</a>.
                </p><p style="color:blue;">启用innodb_file_per_table选项或使用常规表空间将表的数据和索引放入单独的文件，而不是系统表空间。</p><p>
                    The <a class="link" href="innodb-storage-engine.html#sysvar_innodb_file_per_table"><code class="literal">innodb_file_per_table</code></a>
                    option is enabled by default.
                </p><p style="color:blue;">默认情况下，innodb_file_per_table选项处于启用状态。</p></li><li class="listitem"><p>
                    Evaluating whether your data and access patterns benefit from
                    the <code class="literal">InnoDB</code> table or page
                    <a class="link" href="glossary.html#glos_compression" title="compression">compression</a> features.
                    You can compress <code class="literal">InnoDB</code> tables without
                    sacrificing read/write capability.
                </p><p style="color:blue;">评估您的数据和访问模式是否受益于innodb表或页面压缩特性。您可以压缩innodb表而不牺牲读/写功能。</p></li><li class="listitem"><p>
                    Running your server with the option
                    <a class="link" href="server-administration.html#sysvar_sql_mode"><code class="literal">--sql_mode=NO_ENGINE_SUBSTITUTION</code></a>
                    to prevent tables being created with a different storage
                    engine if there is an issue with the engine specified in the
                    <code class="literal">ENGINE=</code> clause of
                    <a class="link" href="sql-syntax.html#create-table" title="13.1.18&nbsp;CREATE TABLE Syntax"><code class="literal">CREATE TABLE</code></a>.
                </p><p style="color:blue;">如果create table的engine=子句中指定的引擎有问题，请使用选项--sql_mode=no_engine_substitution运行服务器，以防止使用其他存储引擎创建表。</p></li></ul>
            </div>

        </div>
        <div class="section">
            <div class="titlepage">
                <div>
                    <div>
                        <h3 class="title"><a name="innodb-check-availability"></a>14.1.3&nbsp;Verifying that InnoDB is the Default Storage Engine</h3>

                    </div>

                </div>

            </div>
            <p>
                Issue the <a class="link" href="sql-syntax.html#show-engines" title="13.7.5.16&nbsp;SHOW ENGINES Syntax"><code class="literal">SHOW ENGINES</code></a> statement to
                view the available MySQL storage engines. Look for
                <code class="literal">DEFAULT</code> in the <code class="literal">InnoDB</code> line.
            </p><p style="color:blue;">发出show engines语句以查看可用的mysql存储引擎。在innodb行中查找默认值。</p><pre data-lang="sql" class="programlisting">mysql&gt; SHOW ENGINES;
</pre><p>
            Alternatively, query the
            <a class="link" href="information-schema.html#engines-table" title="24.7&nbsp;The INFORMATION_SCHEMA ENGINES Table"><code class="literal">INFORMATION_SCHEMA.ENGINES</code></a> table.
        </p><p style="color:blue;">或者，查询information_schema.engines表。</p><pre data-lang="sql" class="programlisting">mysql&gt; SELECT * FROM INFORMATION_SCHEMA.ENGINES;
</pre>
        </div>
        <div class="section">
            <div class="titlepage">
                <div>
                    <div>
                        <h3 class="title"><a name="innodb-benchmarking"></a>14.1.4&nbsp;Testing and Benchmarking with InnoDB</h3>

                    </div>

                </div>

            </div>
            <p>
                If <code class="literal">InnoDB</code> is not your default storage engine,
                you can determine if your database server or applications work
                correctly with <code class="literal">InnoDB</code> by restarting the server
                with
                <a class="link" href="server-administration.html#sysvar_default_storage_engine"><code class="literal">--default-storage-engine=InnoDB</code></a>
                defined on the command line or with
                <a class="link" href="server-administration.html#sysvar_default_storage_engine"><code class="literal">default-storage-engine=innodb</code></a>
                defined in the <code class="literal">[mysqld]</code> section of your MySQL
                server option file.
            </p><p style="color:blue;">如果innodb不是默认的存储引擎，您可以通过在命令行上定义--default storage engine=innodb或在mysql server选项文件的[mysqld]部分中定义的default storage engine=innodb来重新启动服务器，确定数据库服务器或应用程序是否与innodb一起正常工作。</p><p>
            Since changing the default storage engine only affects new tables
            as they are created, run all your application installation and
            setup steps to confirm that everything installs properly. Then
            exercise all the application features to make sure all the data
            loading, editing, and querying features work. If a table relies on
            a feature that is specific to another storage engine, you will
            receive an error; add the
            <code class="literal">ENGINE=<em class="replaceable"><code>other_engine_name</code></em></code>
            clause to the <a class="link" href="sql-syntax.html#create-table" title="13.1.18&nbsp;CREATE TABLE Syntax"><code class="literal">CREATE TABLE</code></a>
            statement to avoid the error.
        </p><p style="color:blue;">由于更改默认存储引擎只会在创建新表时影响它们，请运行所有应用程序安装和安装步骤以确认所有内容都安装正确。然后练习所有应用程序功能，以确保所有数据加载、编辑和查询功能正常工作。如果表依赖于特定于另一个存储引擎的功能，则会收到一个错误；请将engine=other_engine_name子句添加到create table语句中以避免该错误。</p><p>
            If you did not make a deliberate decision about the storage
            engine, and you want to preview how certain tables work when
            created using <code class="literal">InnoDB</code>, issue the command
            <a class="link" href="sql-syntax.html#alter-table" title="13.1.8&nbsp;ALTER TABLE Syntax"><code class="literal">ALTER TABLE
                table_name ENGINE=InnoDB;</code></a> for each table. Or, to run
            test queries and other statements without disturbing the original
            table, make a copy:
        </p><p style="color:blue;">如果您没有对存储引擎做出深思熟虑的决定，并且希望预览使用innodb创建某些表时如何工作，请为每个表发出命令alter table table_name engine=innodb；。或者，要在不干扰原始表的情况下运行测试查询和其他语句，请复制：</p><pre data-lang="sql" class="programlisting">CREATE TABLE InnoDB_Table (...) ENGINE=InnoDB AS SELECT * FROM <em class="replaceable"><code>other_engine_table</code></em>;
</pre><p>
            To assess performance with a full application under a realistic
            workload, install the latest MySQL server and run benchmarks.
        </p><p style="color:blue;">要在实际工作负载下评估完整应用程序的性能，请安装最新的mysql服务器并运行基准测试。</p><p>
            Test the full application lifecycle, from installation, through
            heavy usage, and server restart. Kill the server process while the
            database is busy to simulate a power failure, and verify that the
            data is recovered successfully when you restart the server.
        </p><p style="color:blue;">测试整个应用程序生命周期，从安装到大量使用，以及服务器重启。在数据库正忙时终止服务器进程以模拟电源故障，并在重新启动服务器时验证数据是否已成功恢复。</p><p>
            Test any replication configurations, especially if you use
            different MySQL versions and options on the master and slaves.
        </p><p style="color:blue;">测试任何复制配置，特别是在主服务器和从服务器上使用不同的mysql版本和选项时。</p>
        </div>
        <div class="section">
            <div class="titlepage">
                <div>
                    <div>
                        <h3 class="title"><a name="innodb-turning-off"></a>14.1.5&nbsp;Turning Off InnoDB</h3>

                    </div>

                </div>

            </div>
            <p>
                Oracle recommends <code class="literal">InnoDB</code> as the preferred
                storage engine for typical database applications, from single-user
                wikis and blogs running on a local system, to high-end
                applications pushing the limits of performance. In MySQL
                5.7, <code class="literal">InnoDB</code> is the default storage
                engine for new tables.
            </p><p style="color:blue;">Oracle建议将InnoDB作为典型数据库应用程序的首选存储引擎，从运行在本地系统上的单用户Wiki和博客，到性能受到限制的高端应用程序。在mysql 5.7中，innodb是新表的默认存储引擎。</p>
            <div class="important" style="margin-left: 0.5in; margin-right: 0.5in;">

                <div class="admon-title">
                    Important
                </div>
                <p>
                    <code class="literal">InnoDB</code> cannot be disabled. The
                    <a class="link" href="innodb-storage-engine.html#option_mysqld_innodb"><code class="option">--skip-innodb</code></a>
                    option is deprecated and has no effect, and its use results in a
                    warning. It will be removed in a future MySQL release. This also
                    applies to its synonyms (<code class="option">--innodb=OFF</code>,
                    <code class="option">--disable-innodb</code>, and so forth).
                </p><p style="color:blue;">无法禁用InnoDB。--skip innodb选项已弃用且没有任何效果，其使用将导致警告。它将在未来的mysql版本中被删除。这也适用于它的同义词（--innodb=off、--disable innodb等等）。</p>
            </div>

        </div>

    </div>
    <div class="section">
        <div class="titlepage">
            <div>
                <div>
                    <h2 class="title" style="clear: both"><a name="mysql-acid"></a>14.2&nbsp;InnoDB and the ACID Model</h2>

                </div>

            </div>

        </div>
        <a class="indexterm" name="idm140286824685600"></a><p>
        The <a class="link" href="glossary.html#glos_acid" title="ACID">ACID</a> model is a set of database
        design principles that emphasize aspects of reliability that are
        important for business data and mission-critical applications. MySQL
        includes components such as the <code class="literal">InnoDB</code> storage
        engine that adhere closely to the ACID model, so that data is not
        corrupted and results are not distorted by exceptional conditions
        such as software crashes and hardware malfunctions. When you rely on
        ACID-compliant features, you do not need to reinvent the wheel of
        consistency checking and crash recovery mechanisms. In cases where
        you have additional software safeguards, ultra-reliable hardware, or
        an application that can tolerate a small amount of data loss or
        inconsistency, you can adjust MySQL settings to trade some of the
        ACID reliability for greater performance or throughput.
    </p><p style="color:blue;">acid模型是一组数据库设计原则，强调对业务数据和任务关键型应用程序非常重要的可靠性方面。mysql包含了与acid模型紧密结合的innodb存储引擎等组件，这样数据就不会被破坏，结果也不会被软件崩溃和硬件故障等异常情况所扭曲。当您依赖于符合acid的特性时，不需要重新发明一致性检查和崩溃恢复机制。如果您有额外的软件保护措施、超可靠的硬件或能够容忍少量数据丢失或不一致的应用程序，则可以调整mysql设置，以牺牲一些acid可靠性，从而获得更高的性能或吞吐量。</p><p>
        The following sections discuss how MySQL features, in particular the
        <code class="literal">InnoDB</code> storage engine, interact with the
        categories of the ACID model:
    </p><p style="color:blue;">以下各节讨论mysql特性，特别是innodb存储引擎，如何与acid模型的类别交互：</p>
        <div class="itemizedlist">
            <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                <span class="bold"><strong>A</strong></span>: atomicity.
            </p><p style="color:blue;">A:原子性。</p></li><li class="listitem"><p>
                <span class="bold"><strong>C</strong></span>: consistency.
            </p><p style="color:blue;">C:一致性。</p></li><li class="listitem"><p>
                <span class="bold"><strong>I:</strong></span>: isolation.
            </p><p style="color:blue;">I:隔离。</p></li><li class="listitem"><p>
                <span class="bold"><strong>D</strong></span>: durability.
            </p><p style="color:blue;">D:耐久性。</p></li></ul>
        </div>
        <h3><a name="idm140286824674272"></a>Atomicity</h3>
        <p>
            The <span class="bold"><strong>atomicity</strong></span> aspect of the ACID
            model mainly involves <code class="literal">InnoDB</code>
            <a class="link" href="glossary.html#glos_transaction" title="transaction">transactions</a>. Related MySQL
            features include:
        </p><p style="color:blue;">acid模型的原子性方面主要涉及innodb事务。相关MySQL功能包括：</p>
        <div class="itemizedlist">
            <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                Autocommit setting.
            </p><p style="color:blue;">自动提交设置。</p></li><li class="listitem"><p>
                <a class="link" href="sql-syntax.html#commit" title="13.3.1&nbsp;START TRANSACTION, COMMIT, and ROLLBACK Syntax"><code class="literal">COMMIT</code></a> statement.
            </p><p style="color:blue;">提交语句。</p></li><li class="listitem"><p>
                <a class="link" href="sql-syntax.html#commit" title="13.3.1&nbsp;START TRANSACTION, COMMIT, and ROLLBACK Syntax"><code class="literal">ROLLBACK</code></a>
                statement.
            </p><p style="color:blue;">回滚语句。</p></li><li class="listitem"><p>
                Operational data from the <code class="literal">INFORMATION_SCHEMA</code>
                tables.
            </p><p style="color:blue;">信息架构表中的操作数据。</p></li></ul>
        </div>
        <h3><a name="idm140286824664112"></a>Consistency</h3>
        <p>
            The <span class="bold"><strong>consistency</strong></span> aspect of the ACID
            model mainly involves internal <code class="literal">InnoDB</code> processing
            to protect data from crashes. Related MySQL features include:
        </p><p style="color:blue;">acid模型的一致性方面主要涉及内部innodb处理，以防止数据崩溃。相关MySQL功能包括：</p>
        <div class="itemizedlist">
            <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                <code class="literal">InnoDB</code>
                <a class="link" href="glossary.html#glos_doublewrite_buffer" title="doublewrite buffer">doublewrite
                    buffer</a>.
            </p><p style="color:blue;">InnoDB双写缓冲区。</p></li><li class="listitem"><p>
                <code class="literal">InnoDB</code>
                <a class="link" href="glossary.html#glos_crash_recovery" title="crash recovery">crash recovery</a>.
            </p><p style="color:blue;">InnoDB崩溃恢复。</p></li></ul>
        </div>
        <h3><a name="idm140286824656496"></a>Isolation</h3>
        <p>
            The <span class="bold"><strong>isolation</strong></span> aspect of the ACID
            model mainly involves <code class="literal">InnoDB</code>
            <a class="link" href="glossary.html#glos_transaction" title="transaction">transactions</a>, in particular
            the <a class="link" href="glossary.html#glos_isolation_level" title="isolation level">isolation level</a> that
            applies to each transaction. Related MySQL features include:
        </p><p style="color:blue;">acid模型的隔离方面主要涉及innodb事务，特别是应用于每个事务的隔离级别。相关MySQL功能包括：</p>
        <div class="itemizedlist">
            <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                <a class="link" href="glossary.html#glos_autocommit" title="autocommit">Autocommit</a> setting.
            </p><p style="color:blue;">自动提交设置。</p></li><li class="listitem"><p>
                <code class="literal">SET ISOLATION LEVEL</code> statement.
            </p><p style="color:blue;">设置隔离级别语句。</p></li><li class="listitem"><p>
                The low-level details of <code class="literal">InnoDB</code>
                <a class="link" href="glossary.html#glos_locking" title="locking">locking</a>. During performance
                tuning, you see these details through
                <code class="literal">INFORMATION_SCHEMA</code> tables.
            </p><p style="color:blue;">innodb锁定的底层细节。在性能优化期间，可以通过信息架构表查看这些详细信息。</p></li></ul>
        </div>
        <h3><a name="idm140286824645616"></a>Durability</h3>
        <p>
            The <span class="bold"><strong>durability</strong></span> aspect of the ACID
            model involves MySQL software features interacting with your
            particular hardware configuration. Because of the many possibilities
            depending on the capabilities of your CPU, network, and storage
            devices, this aspect is the most complicated to provide concrete
            guidelines for. (And those guidelines might take the form of buy
            <span class="quote">“<span class="quote">new hardware</span>”</span>.) Related MySQL features include:
        </p><p style="color:blue;">acid模型的持久性方面涉及到mysql软件特性与特定硬件配置的交互。由于许多可能性取决于您的cpu、网络和存储设备的能力，因此这一方面最复杂，无法提供具体的指导原则。（这些指导原则可能采取购买“新硬件”的形式）相关的mysql特性包括：</p>
        <div class="itemizedlist">
            <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                <code class="literal">InnoDB</code>
                <a class="link" href="glossary.html#glos_doublewrite_buffer" title="doublewrite buffer">doublewrite
                    buffer</a>, turned on and off by the
                <a class="link" href="innodb-storage-engine.html#sysvar_innodb_doublewrite"><code class="literal">innodb_doublewrite</code></a>
                configuration option.
            </p><p style="color:blue;">innodb doublewrite buffer，由innodb_doublewrite配置选项打开和关闭。</p></li><li class="listitem"><p>
                Configuration option
                <a class="link" href="innodb-storage-engine.html#sysvar_innodb_flush_log_at_trx_commit"><code class="literal">innodb_flush_log_at_trx_commit</code></a>.
            </p><p style="color:blue;">配置选项innodb_flush_log_at_trx_commit。</p></li><li class="listitem"><p>
                Configuration option
                <a class="link" href="replication.html#sysvar_sync_binlog"><code class="literal">sync_binlog</code></a>.
            </p><p style="color:blue;">配置选项同步日志。</p></li><li class="listitem"><p>
                Configuration option
                <a class="link" href="innodb-storage-engine.html#sysvar_innodb_file_per_table"><code class="literal">innodb_file_per_table</code></a>.
            </p><p style="color:blue;">配置选项innodb_file_per_table。</p></li><li class="listitem"><p>
                Write buffer in a storage device, such as a disk drive, SSD, or
                RAID array.
            </p><p style="color:blue;">在存储设备（如磁盘驱动器、ssd或raid阵列）中写入缓冲区。</p></li><li class="listitem"><p>
                Battery-backed cache in a storage device.
            </p><p style="color:blue;">存储设备中的电池备份缓存。</p></li><li class="listitem"><p>
                The operating system used to run MySQL, in particular its
                support for the <code class="literal">fsync()</code> system call.
            </p><p style="color:blue;">用于运行MySQL的操作系统，特别是它对fsync（）系统调用的支持。</p></li><li class="listitem"><p>
                Uninterruptible power supply (UPS) protecting the electrical
                power to all computer servers and storage devices that run MySQL
                servers and store MySQL data.
            </p><p style="color:blue;">不间断电源（UPS）保护运行MySQL服务器和存储MySQL数据的所有计算机服务器和存储设备的电源。</p></li><li class="listitem"><p>
                Your backup strategy, such as frequency and types of backups,
                and backup retention periods.
            </p><p style="color:blue;">备份策略，如备份的频率和类型，以及备份保留期。</p></li><li class="listitem"><p>
                For distributed or hosted data applications, the particular
                characteristics of the data centers where the hardware for the
                MySQL servers is located, and network connections between the
                data centers.
            </p><p style="color:blue;">对于分布式或托管数据应用程序，MySQL服务器硬件所在的数据中心的特定特征，以及数据中心之间的网络连接。</p></li></ul>
        </div>

    </div>
    <div class="section">
        <div class="titlepage">
            <div>
                <div>
                    <h2 class="title" style="clear: both"><a name="innodb-multi-versioning"></a>14.3&nbsp;InnoDB Multi-Versioning</h2>

                </div>

            </div>

        </div>
        <a class="indexterm" name="idm140286824625264"></a><a class="indexterm" name="idm140286824623776"></a><p>
        <code class="literal">InnoDB</code> is a
        <a class="link" href="glossary.html#glos_mvcc" title="MVCC">multi-versioned storage engine</a>: it
        keeps information about old versions of changed rows, to support
        transactional features such as concurrency and
        <a class="link" href="glossary.html#glos_rollback" title="rollback">rollback</a>. This information is
        stored in the tablespace in a data structure called a
        <a class="link" href="glossary.html#glos_rollback_segment" title="rollback segment">rollback segment</a> (after
        an analogous data structure in Oracle). <code class="literal">InnoDB</code>
        uses the information in the rollback segment to perform the undo
        operations needed in a transaction rollback. It also uses the
        information to build earlier versions of a row for a
        <a class="link" href="glossary.html#glos_consistent_read" title="consistent read">consistent read</a>.
    </p><p style="color:blue;">innodb是一个多版本的存储引擎：它保存有关已更改行的旧版本的信息，以支持事务特性，如并发和回滚。这些信息存储在表空间中的一个称为回滚段的数据结构中（在oracle中类似的数据结构之后）。innodb使用回滚段中的信息来执行事务回滚所需的撤销操作。它还使用这些信息来构建行的早期版本，以便进行一致的读取。</p><p>
        Internally, <code class="literal">InnoDB</code> adds three fields to each row
        stored in the database. A 6-byte <code class="literal">DB_TRX_ID</code> field
        indicates the transaction identifier for the last transaction that
        inserted or updated the row. Also, a deletion is treated internally
        as an update where a special bit in the row is set to mark it as
        deleted. Each row also contains a 7-byte
        <code class="literal">DB_ROLL_PTR</code> field called the roll pointer. The
        roll pointer points to an undo log record written to the rollback
        segment. If the row was updated, the undo log record contains the
        information necessary to rebuild the content of the row before it
        was updated. A 6-byte <code class="literal">DB_ROW_ID</code> field contains a
        row ID that increases monotonically as new rows are inserted. If
        <code class="literal">InnoDB</code> generates a clustered index automatically,
        the index contains row ID values. Otherwise, the
        <code class="literal">DB_ROW_ID</code> column does not appear in any index.
    </p><p style="color:blue;">在内部，innodb向数据库中存储的每一行添加三个字段。6字节的db_trx_id字段表示插入或更新行的最后一个事务的事务标识符。此外，删除在内部被视为更新，其中行中的特殊位被设置为将其标记为已删除。每行还包含一个名为roll pointer的7字节db_roll_ptr字段。滚动指针指向写入回滚段的撤消日志记录。如果行已更新，则撤消日志记录包含更新前重建行内容所需的信息。一个6字节的db_row_id字段包含一个随着新行插入而单调增加的行id。如果innodb自动生成聚集索引，则该索引包含行id值。否则，db_row_id列不会出现在任何索引中。</p><p>
        Undo logs in the rollback segment are divided into insert and update
        undo logs. Insert undo logs are needed only in transaction rollback
        and can be discarded as soon as the transaction commits. Update undo
        logs are used also in consistent reads, but they can be discarded
        only after there is no transaction present for which
        <code class="literal">InnoDB</code> has assigned a snapshot that in a
        consistent read could need the information in the update undo log to
        build an earlier version of a database row.
    </p><p style="color:blue;">回滚段中的撤消日志分为插入和更新撤消日志。只有在事务回滚中才需要插入撤消日志，并且可以在事务提交后立即丢弃。更新撤销日志也用于一致性读取，但只有在不存在InnoDB为其分配了一致性读取中可能需要更新撤销日志中的信息以生成数据库行的早期版本的快照的事务之后，才能丢弃这些日志。</p><p>
        Commit your transactions regularly, including those transactions
        that issue only consistent reads. Otherwise,
        <code class="literal">InnoDB</code> cannot discard data from the update undo
        logs, and the rollback segment may grow too big, filling up your
        tablespace.
    </p><p style="color:blue;">定期提交事务，包括只发出一致读取的事务。否则，innodb无法丢弃update undo日志中的数据，并且回滚段可能会变得太大，从而填满表空间。</p><p>
        The physical size of an undo log record in the rollback segment is
        typically smaller than the corresponding inserted or updated row.
        You can use this information to calculate the space needed for your
        rollback segment.
    </p><p style="color:blue;">回滚段中撤消日志记录的物理大小通常小于相应的插入或更新行。可以使用此信息计算回滚段所需的空间。</p><p>
        In the <code class="literal">InnoDB</code> multi-versioning scheme, a row is
        not physically removed from the database immediately when you delete
        it with an SQL statement. <code class="literal">InnoDB</code> only physically
        removes the corresponding row and its index records when it discards
        the update undo log record written for the deletion. This removal
        operation is called a <a class="link" href="glossary.html#glos_purge" title="purge">purge</a>, and
        it is quite fast, usually taking the same order of time as the SQL
        statement that did the deletion.
    </p><p style="color:blue;">在innodb多版本方案中，使用sql语句删除行时，不会立即从数据库中物理删除行。InnoDB只有在丢弃为删除而写入的更新撤消日志记录时，才会物理地删除相应的行及其索引记录。这种删除操作称为清除，而且速度非常快，通常所用的时间顺序与执行删除操作的sql语句相同。</p><p>
        If you insert and delete rows in smallish batches at about the same
        rate in the table, the purge thread can start to lag behind and the
        table can grow bigger and bigger because of all the
        <span class="quote">“<span class="quote">dead</span>”</span> rows, making everything disk-bound and very
        slow. In such a case, throttle new row operations, and allocate more
        resources to the purge thread by tuning the
        <a class="link" href="innodb-storage-engine.html#sysvar_innodb_max_purge_lag"><code class="literal">innodb_max_purge_lag</code></a> system
        variable. See <a class="xref" href="innodb-storage-engine.html#innodb-parameters" title="14.14&nbsp;InnoDB Startup Options and System Variables">Section&nbsp;14.14, “InnoDB Startup Options and System Variables”</a> for more
        information.
    </p><p style="color:blue;">如果在表中以大约相同的速度以小批量插入和删除行，清除线程可能会开始落后，并且由于所有“死”行，表可能会越来越大，从而使所有内容都绑定到磁盘并且速度非常慢。在这种情况下，通过调整innodb_max_purge_lag系统变量来限制新行操作，并为清除线程分配更多资源。有关更多信息，请参阅14.14节，“InnoDB启动选项和系统变量”。</p>
        <div class="simplesect">

            <div class="titlepage">
                <div>

                    <div class="simple">
                        <h3 class="title"><a name="innodb-multi-versioning-secondary-indexes"></a>Multi-Versioning and Secondary Indexes</h3>
                    </div>
                </div>
            </div>
            <p>
                <code class="literal">InnoDB</code> multiversion concurrency control (MVCC)
                treats secondary indexes differently than clustered indexes.
                Records in a clustered index are updated in-place, and their
                hidden system columns point undo log entries from which earlier
                versions of records can be reconstructed. Unlike clustered index
                records, secondary index records do not contain hidden system
                columns nor are they updated in-place.
            </p><p style="color:blue;">innodb多版本并发控制（mvcc）处理二级索引的方式与处理聚集索引的方式不同。聚集索引中的记录将就地更新，其隐藏的系统列指向可以从中重建早期版本记录的撤消日志项。与聚集索引记录不同，辅助索引记录不包含隐藏的系统列，也不就地更新。</p><p>
            When a secondary index column is updated, old secondary index
            records are delete-marked, new records are inserted, and
            delete-marked records are eventually purged. When a secondary
            index record is delete-marked or the secondary index page is
            updated by a newer transaction, <code class="literal">InnoDB</code> looks up
            the database record in the clustered index. In the clustered
            index, the record's <code class="literal">DB_TRX_ID</code> is checked, and
            the correct version of the record is retrieved from the undo log
            if the record was modified after the reading transaction was
            initiated.
        </p><p style="color:blue;">更新辅助索引列时，旧的辅助索引记录将被删除标记，新记录将被插入，并最终清除删除标记的记录。当二级索引记录被删除标记或二级索引页被更新的事务更新时，innodb在聚集索引中查找数据库记录。在聚集索引中，检查记录的db_trx_id，如果在启动读取事务后修改了记录，则从撤消日志中检索记录的正确版本。</p><p>
            If a secondary index record is marked for deletion or the
            secondary index page is updated by a newer transaction, the
            <a class="link" href="glossary.html#glos_covering_index" title="covering index">covering index</a>
            technique is not used. Instead of returning values from the index
            structure, <code class="literal">InnoDB</code> looks up the record in the
            clustered index.
        </p><p style="color:blue;">如果二级索引记录被标记为删除，或者二级索引页被更新的事务更新，则不使用覆盖索引技术。innodb不从索引结构返回值，而是在聚集索引中查找记录。</p><p>
            However, if the
            <a class="link" href="optimization.html#index-condition-pushdown-optimization" title="8.2.1.5&nbsp;Index Condition Pushdown Optimization">index
                condition pushdown (ICP)</a> optimization is enabled, and parts
            of the <code class="literal">WHERE</code> condition can be evaluated using
            only fields from the index, the MySQL server still pushes this
            part of the <code class="literal">WHERE</code> condition down to the storage
            engine where it is evaluated using the index. If no matching
            records are found, the clustered index lookup is avoided. If
            matching records are found, even among delete-marked records,
            <code class="literal">InnoDB</code> looks up the record in the clustered
            index.
        </p><p style="color:blue;">但是，如果启用了索引条件下推（icp）优化，并且部分where条件只能使用索引中的字段进行求值，那么mysql服务器仍然会将这部分where条件下推到存储引擎中，在那里使用索引求值。如果没有找到匹配的记录，则避免了聚集索引查找。如果找到匹配的记录，即使在删除标记的记录中，innodb也会在聚集索引中查找该记录。</p>
        </div>

    </div>
    <div class="section">
        <div class="titlepage">
            <div>
                <div>
                    <h2 class="title" style="clear: both"><a name="innodb-architecture"></a>14.4&nbsp;InnoDB Architecture</h2>

                </div>

            </div>

        </div>
        <a class="indexterm" name="idm140286824588992"></a><p>
        The following diagram shows in-memory and on-disk structures that
        comprise the <code class="literal">InnoDB</code> storage engine
        architecture. For information about each structure, see
        <a class="xref" href="innodb-storage-engine.html#innodb-in-memory-structures" title="14.5&nbsp;InnoDB In-Memory Structures">Section&nbsp;14.5, “InnoDB In-Memory Structures”</a>, and
        <a class="xref" href="innodb-storage-engine.html#innodb-on-disk-structures" title="14.6&nbsp;InnoDB On-Disk Structures">Section&nbsp;14.6, “InnoDB On-Disk Structures”</a>.
    </p><p style="color:blue;">下图显示了构成InnoDB存储引擎体系结构的内存和磁盘结构。有关每个结构的信息，请参阅第14.5节“InnoDB内存结构”和第14.6节“InnoDB磁盘结构”。</p>
        <div class="figure">
            <a name="innodb-architecture-diagram"></a><p class="title"><b>Figure&nbsp;14.1&nbsp;InnoDB Architecture</b></p><p style="color:blue;">图14.1 InnoDB架构</p>
            <div class="figure-contents">

                <div class="mediaobject">
                    <img src="images/innodb-architecture.png" width="700" height="537" alt="InnoDB architecture diagram showing in-memory and on-disk structures.">
                </div>

            </div>

        </div>
        <br class="figure-break">
    </div>

    <div class="section">

        <div class="titlepage">
            <div>
                <div>
                    <h2 class="title" style="clear: both"><a name="innodb-in-memory-structures"></a>14.5&nbsp;InnoDB In-Memory Structures</h2>

                </div>

            </div>

        </div>

        <div class="toc">
            <dl class="toc"><dt><span class="section"><a href="innodb-storage-engine.html#innodb-buffer-pool">14.5.1 Buffer Pool</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-change-buffer">14.5.2 Change Buffer</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-adaptive-hash">14.5.3 Adaptive Hash Index</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-redo-log-buffer">14.5.4 Log Buffer</a></span></dt></dl>
        </div>
        <a class="indexterm" name="idm140286824576224"></a><p>
        This section describes <code class="literal">InnoDB</code> in-memory
        structures and related topics.
    </p><p style="color:blue;">本节介绍InnoDB内存结构和相关主题。</p>
        <div class="section">

            <div class="titlepage">
                <div>
                    <div>
                        <h3 class="title"><a name="innodb-buffer-pool"></a>14.5.1&nbsp;Buffer Pool</h3>
                    </div>
                </div>
            </div>
            <p>
                The buffer pool is an area in main memory where
                <code class="literal">InnoDB</code> caches table and index data as it is
                accessed. The buffer pool permits frequently used data to be
                processed directly from memory, which speeds up processing. On
                dedicated servers, up to 80% of physical memory is often assigned to
                the buffer pool.
            </p><p style="color:blue;">缓冲池是主内存中的一个区域，innodb在访问表和索引数据时将其缓存。缓冲池允许直接从内存中处理经常使用的数据，这加快了处理速度。在专用服务器上，多达80%的物理内存通常分配给缓冲池。</p><p>
            For efficiency of high-volume read operations, the buffer pool is
            divided into <a class="link" href="glossary.html#glos_page" title="page">pages</a> that can
            potentially hold multiple rows. For efficiency of cache management,
            the buffer pool is implemented as a linked list of pages; data that
            is rarely used is aged out of the cache using a variation of the
            <a class="link" href="glossary.html#glos_lru" title="LRU">LRU</a> algorithm.
        </p><p style="color:blue;">为了提高大容量读取操作的效率，缓冲池被划分为可能包含多行的页。为了提高缓存管理的效率，缓冲池被实现为页面的链接列表；很少使用的数据使用lru算法的变体从缓存中老化。</p><p>
            Knowing how to take advantage of the buffer pool to keep frequently
            accessed data in memory is an important aspect of MySQL tuning.
        </p><p style="color:blue;">了解如何利用缓冲池将频繁访问的数据保存在内存中是mysql优化的一个重要方面。</p>
            <div class="simplesect">

                <div class="titlepage">
                    <div>

                        <div class="simple">
                            <h4 class="title"><a name="innodb-buffer-pool-lru"></a>Buffer Pool LRU Algorithm</h4>
                        </div>
                    </div>
                </div>
                <p>
                    The buffer pool is managed as a list using a variation of the
                    least recently used (LRU) algorithm. When room is needed to add a
                    new page to the buffer pool, the least recently used page is
                    evicted and a new page is added to the middle of the list. This
                    midpoint insertion strategy treats the list as two sublists:
                </p><p style="color:blue;">缓冲池作为列表进行管理，使用最近使用最少（lru）算法的变体。当需要空间将新页添加到缓冲池时，将收回最近使用最少的页，并将新页添加到列表的中间。此中点插入策略将列表视为两个子列表：</p>
                <div class="itemizedlist">
                    <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                        At the head, a sublist of new (<span class="quote">“<span class="quote">young</span>”</span>) pages
                        that were accessed recently
                    </p><p style="color:blue;">在头部，最近访问的新（“年轻”）页的子列表</p></li><li class="listitem"><p>
                        At the tail, a sublist of old pages that were accessed less
                        recently
                    </p><p style="color:blue;">在尾部，是一个旧页的子列表，这些旧页最近访问的次数较少</p></li></ul>
                </div>

                <div class="figure">
                    <a name="innodb-buffer-pool-list"></a><p class="title"><b>Figure&nbsp;14.2&nbsp;Buffer Pool List</b></p><p style="color:blue;">图14.2缓冲池列表</p>
                    <div class="figure-contents">

                        <div class="mediaobject">
                            <img src="images/innodb-buffer-pool-list.png" width="600" height="616" alt="Content is described in the surrounding text.">
                        </div>

                    </div>

                </div>
                <br class="figure-break"><p>
                The algorithm keeps heavily pages in the new sublist. The old
                sublist contains less-used pages; these pages are candidates for
                <a class="link" href="glossary.html#glos_eviction" title="eviction">eviction</a>.
            </p><p style="color:blue;">该算法在新的子列表中保留了大量的页面。旧的子列表包含较少使用的页；这些页是要逐出的候选页。</p><p>
                By default, the algorithm operates as follows:
            </p><p style="color:blue;">默认情况下，算法的操作如下：</p>
                <div class="itemizedlist">
                    <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                        3/8 of the buffer pool is devoted to the old sublist.
                    </p><p style="color:blue;">缓冲池的3/8用于旧的子列表。</p></li><li class="listitem"><p>
                        The midpoint of the list is the boundary where the tail of the
                        new sublist meets the head of the old sublist.
                    </p><p style="color:blue;">列表的中点是新子列表的尾部与旧子列表的头部相交的边界。</p></li><li class="listitem"><p>
                        When <code class="literal">InnoDB</code> reads a page into the buffer
                        pool, it initially inserts it at the midpoint (the head of the
                        old sublist). A page can be read because it is required for a
                        user-initiated operation such as an SQL query, or as part of a
                        <a class="link" href="glossary.html#glos_read_ahead" title="read-ahead">read-ahead</a> operation
                        performed automatically by <code class="literal">InnoDB</code>.
                    </p><p style="color:blue;">当innodb将一个页面读入缓冲池时，它首先将其插入到中点（旧子列表的头部）。可以读取页面，因为它是用户发起的操作（如sql查询）所必需的，或者是innodb自动执行的预读操作的一部分。</p></li><li class="listitem"><p>
                        Accessing a page in the old sublist makes it
                        <span class="quote">“<span class="quote">young</span>”</span>, moving it to the head of the new
                        sublist. If the page was read because it was required by a
                        user-initiated operation, the first access occurs immediately
                        and the page is made young. If the page was read due to a
                        read-ahead operation, the first access does not occur
                        immediately, and might not occur at all before the page is
                        evicted.
                    </p><p style="color:blue;">访问旧子列表中的页面会使其“年轻”，并将其移动到新子列表的头部。如果由于用户启动的操作需要读取该页，则会立即进行第一次访问，并使该页变为年轻页。如果由于预读操作而读取了该页，则第一次访问不会立即发生，而且在收回该页之前可能根本不会发生。</p></li><li class="listitem"><p>
                        As the database operates, pages in the buffer pool that are
                        not accessed <span class="quote">“<span class="quote">age</span>”</span> by moving toward the tail of
                        the list. Pages in both the new and old sublists age as other
                        pages are made new. Pages in the old sublist also age as pages
                        are inserted at the midpoint. Eventually, a page that remains
                        unused reaches the tail of the old sublist and is evicted.
                    </p><p style="color:blue;">当数据库运行时，缓冲池中不被访问的页面会“老化”到列表的尾部。新的和旧的子列表中的页面随着其他页面的更新而老化。旧子列表中的页面也会随着页面插入到中点而老化。最终，一个未使用的页面到达旧子列表的尾部并被逐出。</p></li></ul>
                </div>
                <p>
                    By default, pages read by queries are immediately moved into the
                    new sublist, meaning they stay in the buffer pool longer. A table
                    scan, performed for a <a class="link" href="programs.html#mysqldump" title="4.5.4&nbsp;mysqldump — A Database Backup Program"><span class="command"><strong>mysqldump</strong></span></a> operation or a
                    <code class="literal">SELECT</code> statement with no
                    <code class="literal">WHERE</code> clause, for example, can bring a large
                    amount of data into the buffer pool and evict an equivalent amount
                    of older data, even if the new data is never used again.
                    Similarly, pages that are loaded by the read-ahead background
                    thread and accessed only once are moved to the head of the new
                    list. These situations can push frequently used pages to the old
                    sublist where they become subject to eviction. For information
                    about optimizing this behavior, see
                    <a class="xref" href="innodb-storage-engine.html#innodb-performance-midpoint_insertion" title="14.8.3.3&nbsp;Making the Buffer Pool Scan Resistant">Section&nbsp;14.8.3.3, “Making the Buffer Pool Scan Resistant”</a>, and
                    <a class="xref" href="innodb-storage-engine.html#innodb-performance-read_ahead" title="14.8.3.4&nbsp;Configuring InnoDB Buffer Pool Prefetching (Read-Ahead)">Section&nbsp;14.8.3.4, “Configuring InnoDB Buffer Pool Prefetching (Read-Ahead)”</a>.
                </p><p style="color:blue;">默认情况下，查询读取的页面会立即移动到新的子列表中，这意味着它们在缓冲池中停留的时间更长。例如，为mysqldump操作或不带where子句的select语句执行的表扫描可以将大量数据引入缓冲池，并收回等量的旧数据，即使新数据再也不会使用。类似地，由预读后台线程加载并且只访问一次的页面将移动到新列表的头部。这些情况会将经常使用的页面推送到旧的子列表中，在那里它们会被逐出。有关优化此行为的信息，请参阅14.8.3.3节“使缓冲池抗扫描”，以及14.8.3.4节“配置InnoDB缓冲池预取（预读）”。</p><p>
                <code class="literal">InnoDB</code> Standard Monitor output contains several
                fields in the <code class="literal">BUFFER POOL AND MEMORY</code> section
                regarding operation of the buffer pool LRU algorithm. For details,
                see <a class="xref" href="innodb-storage-engine.html#innodb-buffer-pool-monitoring" title="Monitoring the Buffer Pool Using the InnoDB Standard Monitor">Monitoring the Buffer Pool Using the InnoDB Standard Monitor</a>.
            </p><p style="color:blue;">innodb standard monitor输出包含缓冲池和内存部分的几个字段，这些字段与缓冲池lru算法的操作有关。有关详细信息，请参阅使用innodb标准监视器监视缓冲池。</p>
            </div>
            <div class="simplesect">
                <div class="titlepage">
                    <div>
                        <div class="simple">
                            <h4 class="title"><a name="innodb-buffer-pool-configuration"></a>Buffer Pool Configuration</h4>

                        </div>

                    </div>

                </div>
                <p>
                    You can configure the various aspects of the buffer pool to
                    improve performance.
                </p><p style="color:blue;">您可以配置缓冲池的各个方面以提高性能。</p>
                <div class="itemizedlist">
                    <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                        Ideally, you set the size of the buffer pool to as large a
                        value as practical, leaving enough memory for other processes
                        on the server to run without excessive paging. The larger the
                        buffer pool, the more <code class="literal">InnoDB</code> acts like an
                        in-memory database, reading data from disk once and then
                        accessing the data from memory during subsequent reads. See
                        <a class="xref" href="innodb-storage-engine.html#innodb-buffer-pool-resize" title="14.8.3.1&nbsp;Configuring InnoDB Buffer Pool Size">Section&nbsp;14.8.3.1, “Configuring InnoDB Buffer Pool Size”</a>.
                    </p><p style="color:blue;">理想情况下，您可以将缓冲池的大小设置为尽可能大的值，为服务器上的其他进程留下足够的内存，以便在不进行过度分页的情况下运行。缓冲池越大，innodb就越像内存中的数据库，从磁盘读取一次数据，然后在随后的读取过程中从内存访问数据。参见14.8.3.1节，“配置InnoDB缓冲池大小”。</p></li><li class="listitem"><p>
                        On 64-bit systems with sufficient memory, you can split the
                        buffer pool into multiple parts to minimize contention for
                        memory structures among concurrent operations. For details,
                        see <a class="xref" href="innodb-storage-engine.html#innodb-multiple-buffer-pools" title="14.8.3.2&nbsp;Configuring Multiple Buffer Pool Instances">Section&nbsp;14.8.3.2, “Configuring Multiple Buffer Pool Instances”</a>.
                    </p><p style="color:blue;">在具有足够内存的64位系统上，可以将缓冲池分成多个部分，以最小化并发操作之间的内存结构争用。有关详细信息，请参阅第14.8.3.2节“配置多个缓冲池实例”。</p></li><li class="listitem"><p>
                        You can keep frequently accessed data in memory regardless of
                        sudden spikes of activity from operations that would bring
                        large amounts of infrequently accessed data into the buffer
                        pool. For details, see
                        <a class="xref" href="innodb-storage-engine.html#innodb-performance-midpoint_insertion" title="14.8.3.3&nbsp;Making the Buffer Pool Scan Resistant">Section&nbsp;14.8.3.3, “Making the Buffer Pool Scan Resistant”</a>.
                    </p><p style="color:blue;">您可以将频繁访问的数据保存在内存中，而不必考虑将大量不常访问的数据带入缓冲池的操作所导致的活动突然激增。有关详细信息，请参阅14.8.3.3节“使缓冲池不受扫描”。</p></li><li class="listitem"><p>
                        You can control when and how to perform read-ahead requests to
                        prefetch pages into the buffer pool asynchronously in
                        anticipation that the pages will be needed soon. For details,
                        see <a class="xref" href="innodb-storage-engine.html#innodb-performance-read_ahead" title="14.8.3.4&nbsp;Configuring InnoDB Buffer Pool Prefetching (Read-Ahead)">Section&nbsp;14.8.3.4, “Configuring InnoDB Buffer Pool Prefetching (Read-Ahead)”</a>.
                    </p><p style="color:blue;">您可以控制何时以及如何执行预读请求，以异步将页预取到缓冲池中，以预期不久将需要这些页。有关详细信息，请参阅14.8.3.4节，“配置InnoDB缓冲池预取（预读）”。</p></li><li class="listitem"><p>
                        You can control when background flushing occurs and whether or
                        not the rate of flushing is dynamically adjusted based on
                        workload. For details, see
                        <a class="xref" href="innodb-storage-engine.html#innodb-buffer-pool-flushing" title="14.8.3.5&nbsp;Configuring Buffer Pool Flushing">Section&nbsp;14.8.3.5, “Configuring Buffer Pool Flushing”</a>.
                    </p><p style="color:blue;">您可以控制何时进行后台刷新，以及是否根据工作负载动态调整刷新速率。有关详细信息，请参阅第14.8.3.5节“配置缓冲池刷新”。</p></li><li class="listitem"><p>
                        You can configure how <code class="literal">InnoDB</code> preserves the
                        current buffer pool state to avoid a lengthy warmup period
                        after a server restart. For details, see
                        <a class="xref" href="innodb-storage-engine.html#innodb-preload-buffer-pool" title="14.8.3.6&nbsp;Saving and Restoring the Buffer Pool State">Section&nbsp;14.8.3.6, “Saving and Restoring the Buffer Pool State”</a>.
                    </p><p style="color:blue;">您可以配置innodb如何保留当前缓冲池状态，以避免服务器重启后长时间的预热。有关详细信息，请参阅第14.8.3.6节“保存和还原缓冲池状态”。</p></li></ul>
                </div>

            </div>
            <div class="simplesect">
                <div class="titlepage">
                    <div>
                        <div class="simple">
                            <h4 class="title"><a name="innodb-buffer-pool-monitoring"></a>Monitoring the Buffer Pool Using the InnoDB Standard Monitor</h4>

                        </div>

                    </div>

                </div>
                <a class="indexterm" name="idm140286824522912"></a><a class="indexterm" name="idm140286824521840"></a><a class="indexterm" name="idm140286824520352"></a><p>
                <code class="literal">InnoDB</code> Standard Monitor output, which can be
                accessed using
                <a class="link" href="innodb-storage-engine.html#innodb-standard-monitor" title="14.17.3&nbsp;InnoDB Standard Monitor and Lock Monitor Output"><code class="literal">SHOW
                    ENGINE INNODB STATUS</code></a>, provides metrics regarding
                operation of the buffer pool. Buffer pool metrics are located in
                the <code class="literal">BUFFER POOL AND MEMORY</code> section of
                <code class="literal">InnoDB</code> Standard Monitor output and appear
                similar to the following:
            </p><p style="color:blue;">innodb标准监视器输出（可以使用show engine innodb status访问）提供有关缓冲池操作的度量。缓冲池度量位于innodb standard monitor输出的缓冲池和内存部分，类似于以下内容：</p><pre data-lang="sql" class="programlisting">----------------------
BUFFER POOL AND MEMORY
----------------------
Total large memory allocated 2198863872
Dictionary memory allocated 776332
Buffer pool size   131072
Free buffers       124908
Database pages     5720
Old database pages 2071
Modified db pages  910
Pending reads 0
Pending writes: LRU 0, flush list 0, single page 0
Pages made young 4, not young 0
0.10 youngs/s, 0.00 non-youngs/s
Pages read 197, created 5523, written 5060
0.00 reads/s, 190.89 creates/s, 244.94 writes/s
Buffer pool hit rate 1000 / 1000, young-making rate 0 / 1000 not
0 / 1000
Pages read ahead 0.00/s, evicted without access 0.00/s, Random read
ahead 0.00/s
LRU len: 5720, unzip_LRU len: 0
I/O sum[0]:cur[0], unzip sum[0]:cur[0]
</pre><p>
                The following table describes buffer pool metrics reported by the
                <code class="literal">InnoDB</code> Standard Monitor.
            </p><p style="color:blue;">下表描述了innodb标准监视器报告的缓冲池度量。</p>
                <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">

                    <div class="admon-title">
                        Note
                    </div>
                    <p>
                        Per second averages provided in <code class="literal">InnoDB</code>
                        Standard Monitor output are based on the elapsed time since
                        <code class="literal">InnoDB</code> Standard Monitor output was last
                        printed.
                    </p><p style="color:blue;">innodb标准监视器输出中提供的每秒平均值是基于自上次打印innodb标准监视器输出以来经过的时间。</p>
                </div>

                <div class="table">
                    <a name="innodb-buffer-pool-metrics"></a><p class="title"><b>Table&nbsp;14.2&nbsp;InnoDB Buffer Pool Metrics</b></p><p style="color:blue;">表14.2 InnoDB缓冲池度量</p>
                    <div class="table-contents">
                        <table summary="InnoDB buffer pool metrics reported by the InnoDB Standard Monitor."><colgroup><col width="35%"><col width="65%"></colgroup><thead><tr>
                            <th scope="col">Name</th>
                            <th scope="col">Description</th>
                        </tr></thead><tbody><tr>
                            <td scope="row">Total memory allocated</td>
                            <td>The total memory allocated for the buffer pool in bytes.</td>
                        </tr><tr>
                            <td scope="row">Dictionary memory allocated</td>
                            <td>The total memory allocated for the <code class="literal">InnoDB</code> data
                                dictionary in bytes.</td>
                        </tr><tr>
                            <td scope="row">Buffer pool size</td>
                            <td>The total size in pages allocated to the buffer pool.</td>
                        </tr><tr>
                            <td scope="row">Free buffers</td>
                            <td>The total size in pages of the buffer pool free list.</td>
                        </tr><tr>
                            <td scope="row">Database pages</td>
                            <td>The total size in pages of the buffer pool LRU list.</td>
                        </tr><tr>
                            <td scope="row">Old database pages</td>
                            <td>The total size in pages of the buffer pool old LRU sublist.</td>
                        </tr><tr>
                            <td scope="row">Modified db pages</td>
                            <td>The current number of pages modified in the buffer pool.</td>
                        </tr><tr>
                            <td scope="row">Pending reads</td>
                            <td>The number of buffer pool pages waiting to be read into the buffer pool.</td>
                        </tr><tr>
                            <td scope="row">Pending writes LRU</td>
                            <td>The number of old dirty pages within the buffer pool to be written from
                                the bottom of the LRU list.</td>
                        </tr><tr>
                            <td scope="row">Pending writes flush list</td>
                            <td>The number of buffer pool pages to be flushed during checkpointing.</td>
                        </tr><tr>
                            <td scope="row">Pending writes single page</td>
                            <td>The number of pending independent page writes within the buffer pool.</td>
                        </tr><tr>
                            <td scope="row">Pages made young</td>
                            <td>The total number of pages made young in the buffer pool LRU list (moved
                                to the head of sublist of <span class="quote">“<span class="quote">new</span>”</span> pages).</td>
                        </tr><tr>
                            <td scope="row">Pages made not young</td>
                            <td>The total number of pages not made young in the buffer pool LRU list
                                (pages that have remained in the <span class="quote">“<span class="quote">old</span>”</span> sublist
                                without being made young).</td>
                        </tr><tr>
                            <td scope="row">youngs/s</td>
                            <td>The per second average of accesses to old pages in the buffer pool LRU
                                list that have resulted in making pages young. See the notes
                                that follow this table for more information.</td>
                        </tr><tr>
                            <td scope="row">non-youngs/s</td>
                            <td>The per second average of accesses to old pages in the buffer pool LRU
                                list that have resulted in not making pages young. See the
                                notes that follow this table for more information.</td>
                        </tr><tr>
                            <td scope="row">Pages read</td>
                            <td>The total number of pages read from the buffer pool.</td>
                        </tr><tr>
                            <td scope="row">Pages created</td>
                            <td>The total number of pages created within the buffer pool.</td>
                        </tr><tr>
                            <td scope="row">Pages written</td>
                            <td>The total number of pages written from the buffer pool.</td>
                        </tr><tr>
                            <td scope="row">reads/s</td>
                            <td>The per second average number of buffer pool page reads per second.</td>
                        </tr><tr>
                            <td scope="row">creates/s</td>
                            <td>The per second average number of buffer pool pages created per second.</td>
                        </tr><tr>
                            <td scope="row">writes/s</td>
                            <td>The per second average number of buffer pool page writes per second.</td>
                        </tr><tr>
                            <td scope="row">Buffer pool hit rate</td>
                            <td>The buffer pool page hit rate for pages read from the buffer pool memory
                                vs from disk storage.</td>
                        </tr><tr>
                            <td scope="row">young-making rate</td>
                            <td>The average hit rate at which page accesses have resulted in making
                                pages young. See the notes that follow this table for more
                                information.</td>
                        </tr><tr>
                            <td scope="row">not (young-making rate)</td>
                            <td>The average hit rate at which page accesses have not resulted in making
                                pages young. See the notes that follow this table for more
                                information.</td>
                        </tr><tr>
                            <td scope="row">Pages read ahead</td>
                            <td>The per second average of read ahead operations.</td>
                        </tr><tr>
                            <td scope="row">Pages evicted without access</td>
                            <td>The per second average of the pages evicted without being accessed from
                                the buffer pool.</td>
                        </tr><tr>
                            <td scope="row">Random read ahead</td>
                            <td>The per second average of random read ahead operations.</td>
                        </tr><tr>
                            <td scope="row">LRU len</td>
                            <td>The total size in pages of the buffer pool LRU list.</td>
                        </tr><tr>
                            <td scope="row">unzip_LRU len</td>
                            <td>The total size in pages of the buffer pool unzip_LRU list.</td>
                        </tr><tr>
                            <td scope="row">I/O sum</td>
                            <td>The total number of buffer pool LRU list pages accessed, for the last 50
                                seconds.</td>
                        </tr><tr>
                            <td scope="row">I/O cur</td>
                            <td>The total number of buffer pool LRU list pages accessed.</td>
                        </tr><tr>
                            <td scope="row">I/O unzip sum</td>
                            <td>The total number of buffer pool unzip_LRU list pages accessed.</td>
                        </tr><tr>
                            <td scope="row">I/O unzip cur</td>
                            <td>The total number of buffer pool unzip_LRU list pages accessed.</td>
                        </tr></tbody></table>
                    </div>

                </div>
                <br class="table-break"><p>
                <span class="bold"><strong>Notes</strong></span>:
            </p><p style="color:blue;">笔记：</p>
                <div class="itemizedlist">
                    <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                        The <code class="literal">youngs/s</code> metric is applicable only to
                        old pages. It is based on the number of accesses to pages and
                        not the number of pages. There can be multiple accesses to a
                        given page, all of which are counted. If you see very low
                        <code class="literal">youngs/s</code> values when there are no large
                        scans occurring, you might need to reduce the delay time or
                        increase the percentage of the buffer pool used for the old
                        sublist. Increasing the percentage makes the old sublist
                        larger, so pages in that sublist take longer to move to the
                        tail, which increases the likelihood that those pages will be
                        accessed again and made young.
                    </p><p style="color:blue;">youngs/s度量仅适用于旧页。它基于对页面的访问次数，而不是页面数量。对给定页面可以有多个访问，所有访问都被计算在内。如果在没有进行大型扫描时看到非常低的youngs/s值，则可能需要减少延迟时间或增加用于旧子列表的缓冲池百分比。增加百分比会使旧的子列表更大，因此该子列表中的页面移动到尾部所需的时间更长，这会增加再次访问这些页面并使其变年轻的可能性。</p></li><li class="listitem"><p>
                        The <code class="literal">non-youngs/s</code> metric is applicable only
                        to old pages. It is based on the number of accesses to pages
                        and not the number of pages. There can be multiple accesses to
                        a given page, all of which are counted. If you do not see a
                        higher <code class="literal">non-youngs/s</code> value when performing
                        large table scans (and a higher <code class="literal">youngs/s</code>
                        value), increase the delay value.
                    </p><p style="color:blue;">非扬斯/秒指标仅适用于旧页。它基于对页面的访问次数，而不是页面数量。对给定页面可以有多个访问，所有访问都被计算在内。如果在执行大型表扫描时未看到较高的非年轻/秒值（以及较高的年轻/秒值），请增加延迟值。</p></li><li class="listitem"><p>
                        The <code class="literal">young-making</code> rate accounts for accesses
                        to all buffer pool pages, not just accesses to pages in the
                        old sublist. The <code class="literal">young-making</code> rate and
                        <code class="literal">not</code> rate do not normally add up to the
                        overall buffer pool hit rate. Page hits in the old sublist
                        cause pages to move to the new sublist, but page hits in the
                        new sublist cause pages to move to the head of the list only
                        if they are a certain distance from the head.
                    </p><p style="color:blue;">年轻的生成速率说明了对所有缓冲池页的访问，而不仅仅是对旧子列表中页的访问。年轻的生成率和非生成率通常不等于总的缓冲池命中率。旧子列表中的页面点击会导致页面移动到新子列表，但新子列表中的页面点击只会导致页面移动到列表的标题，前提是它们与标题之间有一定的距离。</p></li><li class="listitem"><p>
                        <code class="literal">not (young-making rate)</code> is the average hit
                        rate at which page accesses have not resulted in making pages
                        young due to the delay defined by
                        <a class="link" href="innodb-storage-engine.html#sysvar_innodb_old_blocks_time"><code class="literal">innodb_old_blocks_time</code></a> not
                        being met, or due to page hits in the new sublist that did not
                        result in pages being moved to the head. This rate accounts
                        for accesses to all buffer pool pages, not just accesses to
                        pages in the old sublist.
                    </p><p style="color:blue;">not（young making rate）是由于InnoDB_old_blocks_time定义的延迟未满足，或者由于新子列表中的页面点击未导致页面移动到页眉而导致页面访问未导致页面年轻化的平均命中率。此速率说明了对所有缓冲池页的访问，而不仅仅是对旧子列表中页的访问。</p></li></ul>
                </div>
                <p>
                    Buffer pool <a class="link" href="server-administration.html#server-status-variables" title="5.1.9&nbsp;Server Status Variables">server status
                    variables</a> and the
                    <a class="link" href="information-schema.html#innodb-buffer-pool-stats-table" title="24.32.3&nbsp;The INFORMATION_SCHEMA INNODB_BUFFER_POOL_STATS Table"><code class="literal">INNODB_BUFFER_POOL_STATS</code></a> table
                    provide many of the same buffer pool metrics found in
                    <code class="literal">InnoDB</code> Standard Monitor output. For more
                    information, see
                    <a class="xref" href="innodb-storage-engine.html#innodb-information-schema-buffer-pool-stats-example" title="Example&nbsp;14.10&nbsp;Querying the INNODB_BUFFER_POOL_STATS Table">Example&nbsp;14.10, “Querying the INNODB_BUFFER_POOL_STATS Table”</a>.
                </p><p style="color:blue;">缓冲池服务器状态变量和innodb_buffer_pool_stats表提供了innodb标准监视器输出中的许多相同的缓冲池度量。有关更多信息，请参见示例14.10，“查询innodb_buffer_pool_stats表”。</p>
            </div>

        </div>
        <div class="section">
            <div class="titlepage">
                <div>
                    <div>
                        <h3 class="title"><a name="innodb-change-buffer"></a>14.5.2&nbsp;Change Buffer</h3>

                    </div>

                </div>

            </div>
            <a class="indexterm" name="idm140286824399904"></a><a class="indexterm" name="idm140286824398416"></a><p>
            The change buffer is a special data structure that caches changes to
            <a class="link" href="glossary.html#glos_secondary_index" title="secondary index">secondary index</a> pages
            when those pages are not in the
            <a class="link" href="glossary.html#glos_buffer_pool" title="buffer pool">buffer pool</a>. The buffered
            changes, which may result from
            <a class="link" href="sql-syntax.html#insert" title="13.2.5&nbsp;INSERT Syntax"><code class="literal">INSERT</code></a>,
            <a class="link" href="sql-syntax.html#update" title="13.2.11&nbsp;UPDATE Syntax"><code class="literal">UPDATE</code></a>, or
            <a class="link" href="sql-syntax.html#delete" title="13.2.2&nbsp;DELETE Syntax"><code class="literal">DELETE</code></a> operations (DML), are merged
            later when the pages are loaded into the buffer pool by other read
            operations.
        </p><p style="color:blue;">更改缓冲区是一种特殊的数据结构，当辅助索引页不在缓冲池中时，它会将更改缓存到辅助索引页。由插入、更新或删除操作（DML）引起的缓冲更改将在稍后由其他读取操作将页加载到缓冲池中时合并。</p>
            <div class="figure">
                <a name="innodb-change-buffer-diagram"></a><p class="title"><b>Figure&nbsp;14.3&nbsp;Change Buffer</b></p><p style="color:blue;">图14.3更换缓冲器</p>
                <div class="figure-contents">

                    <div class="mediaobject">
                        <img src="images/innodb-change-buffer.png" width="700" height="386" alt="Content is described in the surrounding text.">
                    </div>

                </div>

            </div>
            <br class="figure-break"><p>
            Unlike <a class="link" href="glossary.html#glos_clustered_index" title="clustered index">clustered
            indexes</a>, secondary indexes are usually nonunique, and inserts
            into secondary indexes happen in a relatively random order.
            Similarly, deletes and updates may affect secondary index pages that
            are not adjacently located in an index tree. Merging cached changes
            at a later time, when affected pages are read into the buffer pool
            by other operations, avoids substantial random access I/O that would
            be required to read secondary index pages into the buffer pool from
            disk.
        </p><p style="color:blue;">与聚集索引不同，二级索引通常是非均匀的，插入二级索引的顺序相对随机。类似地，删除和更新可能会影响索引树中不相邻的辅助索引页。稍后，当受影响的页被其他操作读取到缓冲池中时，合并缓存的更改可避免从磁盘将辅助索引页读取到缓冲池中所需的大量随机访问I/O。</p><p>
            Periodically, the purge operation that runs when the system is
            mostly idle, or during a slow shutdown, writes the updated index
            pages to disk. The purge operation can write disk blocks for a
            series of index values more efficiently than if each value were
            written to disk immediately.
        </p><p style="color:blue;">当系统大部分处于空闲状态或在缓慢关闭期间运行的清除操作会定期将更新的索引页写入磁盘。与将每个值立即写入磁盘相比，清除操作可以更有效地写入一系列索引值的磁盘块。</p><p>
            Change buffer merging may take several hours when there are many
            affected rows and numerous secondary indexes to update. During this
            time, disk I/O is increased, which can cause a significant slowdown
            for disk-bound queries. Change buffer merging may also continue to
            occur after a transaction is committed, and even after a server
            shutdown and restart (see <a class="xref" href="innodb-storage-engine.html#forcing-innodb-recovery" title="14.21.2&nbsp;Forcing InnoDB Recovery">Section&nbsp;14.21.2, “Forcing InnoDB Recovery”</a>
            for more information).
        </p><p style="color:blue;">当有许多受影响的行和许多要更新的辅助索引时，更改缓冲区合并可能需要几个小时。在此期间，磁盘I/O会增加，这可能会导致磁盘绑定查询的速度显著减慢。提交事务后，甚至在服务器关闭和重新启动后，更改缓冲区合并也可能继续发生（有关更多信息，请参阅第14.21.2节“强制InnoDB恢复”）。</p><p>
            In memory, the change buffer occupies part of the buffer pool. On
            disk, the change buffer is part of the system tablespace, where
            index changes are buffered when the database server is shut down.
        </p><p style="color:blue;">在内存中，更改缓冲区占据了缓冲池的一部分。在磁盘上，更改缓冲区是系统表空间的一部分，当数据库服务器关闭时，索引更改将被缓冲。</p><p>
            The type of data cached in the change buffer is governed by the
            <a class="link" href="innodb-storage-engine.html#sysvar_innodb_change_buffering"><code class="literal">innodb_change_buffering</code></a> variable.
            For more information, see
            <a class="xref" href="innodb-storage-engine.html#innodb-change-buffer-configuration" title="Configuring Change Buffering">Configuring Change Buffering</a>. You can also
            configure the maximum change buffer size. For more information, see
            <a class="xref" href="innodb-storage-engine.html#innodb-change-buffer-maximum-size" title="Configuring the Change Buffer Maximum Size">Configuring the Change Buffer Maximum Size</a>.
        </p><p style="color:blue;">缓存在更改缓冲区中的数据类型由innodb_change_buffering变量控制。有关更多信息，请参阅配置更改缓冲区。还可以配置最大更改缓冲区大小。有关更多信息，请参见配置更改缓冲区的最大大小。</p><p>
            Change buffering is not supported for a secondary index if the index
            contains a descending index column or if the primary key includes a
            descending index column.
        </p><p style="color:blue;">如果索引包含降序索引列或主键包含降序索引列，则不支持对辅助索引进行更改缓冲。</p><p>
            For answers to frequently asked questions about the change buffer,
            see <a class="xref" href="faqs.html#faqs-innodb-change-buffer" title="A.16&nbsp;MySQL 5.7 FAQ: InnoDB Change Buffer">Section&nbsp;A.16, “MySQL 5.7 FAQ: InnoDB Change Buffer”</a>.
        </p><p style="color:blue;">有关更改缓冲区的常见问题解答，请参阅a.16节，“mysql 5.7常见问题解答：innodb change buffer”。</p>
            <div class="simplesect">

                <div class="titlepage">
                    <div>

                        <div class="simple">
                            <h4 class="title"><a name="innodb-change-buffer-configuration"></a>Configuring Change Buffering</h4>
                        </div>
                    </div>
                </div>
                <a class="indexterm" name="idm140286824373504"></a><a class="indexterm" name="idm140286824372432"></a><a class="indexterm" name="idm140286824370944"></a><p>
                When <a class="link" href="sql-syntax.html#insert" title="13.2.5&nbsp;INSERT Syntax"><code class="literal">INSERT</code></a>,
                <a class="link" href="sql-syntax.html#update" title="13.2.11&nbsp;UPDATE Syntax"><code class="literal">UPDATE</code></a>, and
                <a class="link" href="sql-syntax.html#delete" title="13.2.2&nbsp;DELETE Syntax"><code class="literal">DELETE</code></a> operations are performed on
                a table, the values of indexed columns (particularly the values of
                secondary keys) are often in an unsorted order, requiring
                substantial I/O to bring secondary indexes up to date. The
                <a class="link" href="glossary.html#glos_change_buffer" title="change buffer">change buffer</a> caches
                changes to secondary index entries when the relevant
                <a class="link" href="glossary.html#glos_page" title="page">page</a> is not in the
                <a class="link" href="glossary.html#glos_buffer_pool" title="buffer pool">buffer pool</a>, thus avoiding
                expensive I/O operations by not immediately reading in the page
                from disk. The buffered changes are merged when the page is loaded
                into the buffer pool, and the updated page is later flushed to
                disk. The <code class="literal">InnoDB</code> main thread merges buffered
                changes when the server is nearly idle, and during a
                <a class="link" href="glossary.html#glos_slow_shutdown" title="slow shutdown">slow shutdown</a>.
            </p><p style="color:blue;">当在表上执行插入、更新和删除操作时，索引列的值（特别是辅助键的值）通常是按未排序的顺序排列的，需要大量的I/O来更新辅助索引。当相关页不在缓冲池中时，更改缓冲区缓存对辅助索引项的更改，从而避免了昂贵的I/O操作，因为不会立即从磁盘读取该页。当页面加载到缓冲池中时，缓冲的更改被合并，更新的页面稍后刷新到磁盘。InnoDB主线程在服务器接近空闲时以及在缓慢关闭期间合并缓冲的更改。</p><p>
                Because it can result in fewer disk reads and writes, the change
                buffer feature is most valuable for workloads that are I/O-bound,
                for example applications with a high volume of DML operations such
                as bulk inserts.
            </p><p style="color:blue;">由于更改缓冲区功能可以减少磁盘读写，因此对于I/O绑定的工作负载（例如具有大量DML操作（如大容量插入）的应用程序）来说，更改缓冲区功能最有价值。</p><p>
                However, the change buffer occupies a part of the buffer pool,
                reducing the memory available to cache data pages. If the working
                set almost fits in the buffer pool, or if your tables have
                relatively few secondary indexes, it may be useful to disable
                change buffering. If the working data set fits entirely within the
                buffer pool, change buffering does not impose extra overhead,
                because it only applies to pages that are not in the buffer pool.
            </p><p style="color:blue;">但是，更改缓冲区占用了缓冲池的一部分，从而减少了缓存数据页的可用内存。如果工作集几乎适合缓冲池，或者如果表的辅助索引相对较少，则禁用更改缓冲可能会很有用。如果工作数据集完全适合缓冲池，那么更改缓冲不会增加额外的开销，因为它只适用于不在缓冲池中的页。</p><p>
                You can control the extent to which <code class="literal">InnoDB</code>
                performs change buffering using the
                <a class="link" href="innodb-storage-engine.html#sysvar_innodb_change_buffering"><code class="literal">innodb_change_buffering</code></a>
                configuration parameter. You can enable or disable buffering for
                inserts, delete operations (when index records are initially
                marked for deletion) and purge operations (when index records are
                physically deleted). An update operation is a combination of an
                insert and a delete. The default
                <a class="link" href="innodb-storage-engine.html#sysvar_innodb_change_buffering"><code class="literal">innodb_change_buffering</code></a> value is
                <code class="literal">all</code>.
            </p><p style="color:blue;">您可以使用innodb_change_buffering配置参数控制innodb执行更改缓冲的范围。您可以启用或禁用插入缓冲、删除操作（当索引记录最初标记为删除时）和清除操作（当索引记录被物理删除时）。更新操作是插入和删除的组合。默认的innodb_change_缓冲值是all。</p><p>
                Permitted <a class="link" href="innodb-storage-engine.html#sysvar_innodb_change_buffering"><code class="literal">innodb_change_buffering</code></a>
                values include:
            </p><p style="color:blue;">允许的innodb_change_缓冲值包括：</p>
                <div class="itemizedlist">
                    <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                        <span class="bold"><strong><code class="literal">all</code></strong></span>
                    </p><p style="color:blue;">全部的</p><p>
                        The default value: buffer inserts, delete-marking operations,
                        and purges.
                    </p><p style="color:blue;">默认值：缓冲区插入、删除标记操作和清除。</p></li><li class="listitem"><p>
                        <span class="bold"><strong><code class="literal">none</code></strong></span>
                    </p><p style="color:blue;">没有人</p><p>
                        Do not buffer any operations.
                    </p><p style="color:blue;">不要缓冲任何操作。</p></li><li class="listitem"><p>
                        <span class="bold"><strong><code class="literal">inserts</code></strong></span>
                    </p><p style="color:blue;">插入件</p><p>
                        Buffer insert operations.
                    </p><p style="color:blue;">缓冲区插入操作。</p></li><li class="listitem"><p>
                        <span class="bold"><strong><code class="literal">deletes</code></strong></span>
                    </p><p style="color:blue;">删除</p><p>
                        Buffer delete-marking operations.
                    </p><p style="color:blue;">缓冲区删除标记操作。</p></li><li class="listitem"><p>
                        <span class="bold"><strong><code class="literal">changes</code></strong></span>
                    </p><p style="color:blue;">变化</p><p>
                        Buffer both inserts and delete-marking operations.
                    </p><p style="color:blue;">缓冲插入和删除标记操作。</p></li><li class="listitem"><p>
                        <span class="bold"><strong><code class="literal">purges</code></strong></span>
                    </p><p style="color:blue;">清洗</p><p>
                        Buffer physical deletion operations that happen in the
                        background.
                    </p><p style="color:blue;">缓冲区在后台发生的物理删除操作。</p></li></ul>
                </div>
                <p>
                    You can set the
                    <a class="link" href="innodb-storage-engine.html#sysvar_innodb_change_buffering"><code class="literal">innodb_change_buffering</code></a> parameter
                    in the MySQL option file (<code class="literal">my.cnf</code> or
                    <code class="literal">my.ini</code>) or change it dynamically with the
                    <a class="link" href="sql-syntax.html#set-variable" title="13.7.4.1&nbsp;SET Syntax for Variable Assignment"><code class="literal">SET GLOBAL</code></a>
                    statement, which requires privileges sufficient to set global
                    system variables. See
                    <a class="xref" href="server-administration.html#system-variable-privileges" title="5.1.8.1&nbsp;System Variable Privileges">Section&nbsp;5.1.8.1, “System Variable Privileges”</a>. Changing the setting
                    affects the buffering of new operations; the merging of existing
                    buffered entries is not affected.
                </p><p style="color:blue;">您可以在mysql选项文件（my.cnf或my.ini）中设置innodb_change_buffering参数，也可以使用set global语句动态更改它，这需要足够的权限来设置全局系统变量。见第5.1.8.1节“系统变量特权”。更改设置会影响新操作的缓冲；不影响现有缓冲项的合并。</p>
            </div>
            <div class="simplesect">
                <div class="titlepage">
                    <div>
                        <div class="simple">
                            <h4 class="title"><a name="innodb-change-buffer-maximum-size"></a>Configuring the Change Buffer Maximum Size</h4>

                        </div>

                    </div>

                </div>
                <p>
                    The <a class="link" href="innodb-storage-engine.html#sysvar_innodb_change_buffer_max_size"><code class="literal">innodb_change_buffer_max_size</code></a>
                    variable permits configuring the maximum size of the change buffer
                    as a percentage of the total size of the buffer pool. By default,
                    <a class="link" href="innodb-storage-engine.html#sysvar_innodb_change_buffer_max_size"><code class="literal">innodb_change_buffer_max_size</code></a> is
                    set to 25. The maximum setting is 50.
                </p><p style="color:blue;">NoNbjyLoxEnFuffReMax大小变量允许将更改缓冲区的最大大小配置为缓冲池总大小的百分比。默认情况下，innodb_change_buffer_max_size设置为25。最大设定值为50。</p><p>
                Consider increasing
                <a class="link" href="innodb-storage-engine.html#sysvar_innodb_change_buffer_max_size"><code class="literal">innodb_change_buffer_max_size</code></a> on
                a MySQL server with heavy insert, update, and delete activity,
                where change buffer merging does not keep pace with new change
                buffer entries, causing the change buffer to reach its maximum
                size limit.
            </p><p style="color:blue;">考虑在具有重插入、更新和删除活动的MySQL服务器上增加INNObjyCuxeFuffRexMax大小，其中更改缓冲区合并不跟上新的更改缓冲区条目，导致更改缓冲区达到其最大大小限制。</p><p>
                Consider decreasing
                <a class="link" href="innodb-storage-engine.html#sysvar_innodb_change_buffer_max_size"><code class="literal">innodb_change_buffer_max_size</code></a> on
                a MySQL server with static data used for reporting, or if the
                change buffer consumes too much of the memory space shared with
                the buffer pool, causing pages to age out of the buffer pool
                sooner than desired.
            </p><p style="color:blue;">考虑使用用于报告的静态数据减少mysql服务器上innodb_change_buffer_max_的大小，或者如果change buffer占用了与缓冲池共享的太多内存空间，从而导致页面比预期的更早地从缓冲池老化。</p><p>
                Test different settings with a representative workload to
                determine an optimal configuration. The
                <a class="link" href="innodb-storage-engine.html#sysvar_innodb_change_buffer_max_size"><code class="literal">innodb_change_buffer_max_size</code></a>
                setting is dynamic, which permits modifying the setting without
                restarting the server.
            </p><p style="color:blue;">使用具有代表性的工作负载测试不同的设置以确定最佳配置。innodb_change_buffer_max_size设置是动态的，允许在不重新启动服务器的情况下修改设置。</p>
            </div>
            <div class="simplesect">
                <div class="titlepage">
                    <div>
                        <div class="simple">
                            <h4 class="title"><a name="innodb-change-buffer-monitoring"></a>Monitoring the Change Buffer</h4>

                        </div>

                    </div>

                </div>
                <a class="indexterm" name="idm140286824321408"></a><a class="indexterm" name="idm140286824319920"></a><p>
                The following options are available for change buffer monitoring:
            </p><p style="color:blue;">以下选项可用于更改缓冲区监视：</p>
                <div class="itemizedlist">
                    <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                        <code class="literal">InnoDB</code> Standard Monitor output includes
                        change buffer status information. To view monitor data, issue
                        the <code class="literal">SHOW ENGINE INNODB STATUS</code> statement.
                    </p><p style="color:blue;">innodb标准监视器输出包括更改缓冲区状态信息。要查看监视器数据，请发出show engine innodb status语句。</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>SHOW ENGINE INNODB STATUS\G</code></strong>
</pre><p>
                        Change buffer status information is located under the
                        <code class="literal">INSERT BUFFER AND ADAPTIVE HASH INDEX</code>
                        heading and appears similar to the following:
                    </p><p style="color:blue;">更改缓冲区状态信息位于“插入缓冲区”和“自适应哈希索引”标题下，显示方式如下：</p><pre data-lang="sql" class="programlisting">-------------------------------------
INSERT BUFFER AND ADAPTIVE HASH INDEX
-------------------------------------
Ibuf: size 1, free list len 0, seg size 2, 0 merges
merged operations:
 insert 0, delete mark 0, delete 0
discarded operations:
 insert 0, delete mark 0, delete 0
Hash table size 4425293, used cells 32, node heap has 1 buffer(s)
13577.57 hash searches/s, 202.47 non-hash searches/s
</pre><p>
                        For more information, see
                        <a class="xref" href="innodb-storage-engine.html#innodb-standard-monitor" title="14.17.3&nbsp;InnoDB Standard Monitor and Lock Monitor Output">Section&nbsp;14.17.3, “InnoDB Standard Monitor and Lock Monitor Output”</a>.
                    </p><p style="color:blue;">有关更多信息，请参阅14.17.3节，“InnoDB标准监视器和锁定监视器输出”。</p></li><li class="listitem"><p>
                        The
                        <a class="link" href="information-schema.html#innodb-metrics-table" title="24.32.15&nbsp;The INFORMATION_SCHEMA INNODB_METRICS Table"><code class="literal">INFORMATION_SCHEMA.INNODB_METRICS</code></a>
                        table provides most of the data points found in
                        <code class="literal">InnoDB</code> Standard Monitor output, plus other
                        data points. To view change buffer metrics and a description
                        of each, issue the following query:
                    </p><p style="color:blue;">information_schema.innodb_metrics表提供了innodb标准监视器输出中的大多数数据点以及其他数据点。要查看更改缓冲区度量和每个度量的描述，请发出以下查询：</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT NAME, COMMENT FROM INFORMATION_SCHEMA.INNODB_METRICS WHERE NAME LIKE '%ibuf%'\G</code></strong>
</pre><p>
                        For <a class="link" href="information-schema.html#innodb-metrics-table" title="24.32.15&nbsp;The INFORMATION_SCHEMA INNODB_METRICS Table"><code class="literal">INNODB_METRICS</code></a> table usage
                        information, see
                        <a class="xref" href="innodb-storage-engine.html#innodb-information-schema-metrics-table" title="14.15.6&nbsp;InnoDB INFORMATION_SCHEMA Metrics Table">Section&nbsp;14.15.6, “InnoDB INFORMATION_SCHEMA Metrics Table”</a>.
                    </p><p style="color:blue;">有关innodb_metrics表的使用信息，请参阅第14.15.6节“innodb information_schema metrics表”。</p></li><li class="listitem"><p>
                        The
                        <a class="link" href="information-schema.html#innodb-buffer-page-table" title="24.32.1&nbsp;The INFORMATION_SCHEMA INNODB_BUFFER_PAGE Table"><code class="literal">INFORMATION_SCHEMA.INNODB_BUFFER_PAGE</code></a>
                        table provides metadata about each page in the buffer pool,
                        including change buffer index and change buffer bitmap pages.
                        Change buffer pages are identified by
                        <code class="literal">PAGE_TYPE</code>. <code class="literal">IBUF_INDEX</code> is
                        the page type for change buffer index pages, and
                        <code class="literal">IBUF_BITMAP</code> is the page type for change
                        buffer bitmap pages.
                    </p><p style="color:blue;">information_schema.innodb_buffer_page表提供关于缓冲池中每个页面的元数据，包括更改缓冲区索引和更改缓冲区位图页面。更改缓冲区页按页类型标识。ibuf懔index是更改缓冲区索引页的页类型，ibuf懔bitmap是更改缓冲区位图页的页类型。</p>
                        <div class="warning" style="margin-left: 0.5in; margin-right: 0.5in;">

                            <div class="admon-title">
                                Warning
                            </div>
                            <p>
                                Querying the <a class="link" href="information-schema.html#innodb-buffer-page-table" title="24.32.1&nbsp;The INFORMATION_SCHEMA INNODB_BUFFER_PAGE Table"><code class="literal">INNODB_BUFFER_PAGE</code></a>
                                table can introduce significant performance overhead. To
                                avoid impacting performance, reproduce the issue you want to
                                investigate on a test instance and run your queries on the
                                test instance.
                            </p><p style="color:blue;">查询innodb_buffer_page表会带来显著的性能开销。为了避免影响性能，请在测试实例上重现要调查的问题，并在测试实例上运行查询。</p>
                        </div>
                        <p>
                            For example, you can query the
                            <a class="link" href="information-schema.html#innodb-buffer-page-table" title="24.32.1&nbsp;The INFORMATION_SCHEMA INNODB_BUFFER_PAGE Table"><code class="literal">INNODB_BUFFER_PAGE</code></a> table to
                            determine the approximate number of
                            <code class="literal">IBUF_INDEX</code> and
                            <code class="literal">IBUF_BITMAP</code> pages as a percentage of total
                            buffer pool pages.
                        </p><p style="color:blue;">例如，您可以查询NoBudBuffelyPype页表，以确定缓冲区页面的百分比为iBFFI索引和iBFFI位图页面的大致数量。</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT (SELECT COUNT(*) FROM INFORMATION_SCHEMA.INNODB_BUFFER_PAGE</code></strong>
       <strong class="userinput"><code>WHERE PAGE_TYPE LIKE 'IBUF%') AS change_buffer_pages,</code></strong>
       <strong class="userinput"><code>(SELECT COUNT(*) FROM INFORMATION_SCHEMA.INNODB_BUFFER_PAGE) AS total_pages,</code></strong>
       <strong class="userinput"><code>(SELECT ((change_buffer_pages/total_pages)*100))</code></strong>
       <strong class="userinput"><code>AS change_buffer_page_percentage;</code></strong>
+---------------------+-------------+-------------------------------+
| change_buffer_pages | total_pages | change_buffer_page_percentage |
+---------------------+-------------+-------------------------------+
|                  25 |        8192 |                        0.3052 |
+---------------------+-------------+-------------------------------+
</pre><p>
                            For information about other data provided by the
                            <a class="link" href="information-schema.html#innodb-buffer-page-table" title="24.32.1&nbsp;The INFORMATION_SCHEMA INNODB_BUFFER_PAGE Table"><code class="literal">INNODB_BUFFER_PAGE</code></a> table, see
                            <a class="xref" href="information-schema.html#innodb-buffer-page-table" title="24.32.1&nbsp;The INFORMATION_SCHEMA INNODB_BUFFER_PAGE Table">Section&nbsp;24.32.1, “The INFORMATION_SCHEMA INNODB_BUFFER_PAGE Table”</a>. For related usage
                            information, see
                            <a class="xref" href="innodb-storage-engine.html#innodb-information-schema-buffer-pool-tables" title="14.15.5&nbsp;InnoDB INFORMATION_SCHEMA Buffer Pool Tables">Section&nbsp;14.15.5, “InnoDB INFORMATION_SCHEMA Buffer Pool Tables”</a>.
                        </p><p style="color:blue;">有关innodb_buffer_page表提供的其他数据的信息，请参阅第24.32.1节“信息模式innodb_buffer_page表”。有关使用信息，请参阅14.15.5节，“innodb information_schema buffer pool tables”。</p></li><li class="listitem"><p>
                        <a class="link" href="performance-schema.html" title="Chapter&nbsp;25&nbsp;MySQL Performance Schema">Performance Schema</a>
                        provides change buffer mutex wait instrumentation for advanced
                        performance monitoring. To view change buffer instrumentation,
                        issue the following query:
                    </p><p style="color:blue;">性能架构为高级性能监视提供更改缓冲区互斥等待检测。要查看更改缓冲区检测，请发出以下查询：</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT * FROM performance_schema.setup_instruments</code></strong>
       <strong class="userinput"><code>WHERE NAME LIKE '%wait/synch/mutex/innodb/ibuf%';</code></strong>
+-------------------------------------------------------+---------+-------+
| NAME                                                  | ENABLED | TIMED |
+-------------------------------------------------------+---------+-------+
| wait/synch/mutex/innodb/ibuf_bitmap_mutex             | YES     | YES   |
| wait/synch/mutex/innodb/ibuf_mutex                    | YES     | YES   |
| wait/synch/mutex/innodb/ibuf_pessimistic_insert_mutex | YES     | YES   |
+-------------------------------------------------------+---------+-------+
</pre><p>
                        For information about monitoring <code class="literal">InnoDB</code>
                        mutex waits, see
                        <a class="xref" href="innodb-storage-engine.html#monitor-innodb-mutex-waits-performance-schema" title="14.16.2&nbsp;Monitoring InnoDB Mutex Waits Using Performance Schema">Section&nbsp;14.16.2, “Monitoring InnoDB Mutex Waits Using Performance Schema”</a>.
                    </p><p style="color:blue;">有关监视innodb mutex等待的信息，请参阅14.16.2节“使用性能模式监视innodb mutex等待”。</p></li></ul>
                </div>

            </div>

        </div>
        <div class="section">
            <div class="titlepage">
                <div>
                    <div>
                        <h3 class="title"><a name="innodb-adaptive-hash"></a>14.5.3&nbsp;Adaptive Hash Index</h3>

                    </div>

                </div>

            </div>
            <a class="indexterm" name="idm140286824276320"></a><a class="indexterm" name="idm140286824274832"></a><p>
            The adaptive hash index feature enables <code class="literal">InnoDB</code>
            to perform more like an in-memory database on systems with
            appropriate combinations of workload and sufficient memory for the
            buffer pool without sacrificing transactional features or
            reliability. The adaptive hash index feature is enabled by the
            <a class="link" href="innodb-storage-engine.html#sysvar_innodb_adaptive_hash_index"><code class="literal">innodb_adaptive_hash_index</code></a>
            variable, or turned off at server startup by
            <code class="literal">--skip-innodb-adaptive-hash-index</code>.
        </p><p style="color:blue;">自适应散列索引特性使innodb能够在具有适当的工作负载和足够的缓冲池内存的系统上执行更像内存中的数据库，而不牺牲事务特性或可靠性。自适应哈希索引功能由innodb_adaptive_hash_index变量启用，或在服务器启动时由--skip innodb adaptive hash index关闭。</p><p>
            Based on the observed pattern of searches, a hash index is built
            using a prefix of the index key. The prefix can be any length, and
            it may be that only some values in the B-tree appear in the hash
            index. Hash indexes are built on demand for the pages of the index
            that are accessed often.
        </p><p style="color:blue;">根据观察到的搜索模式，使用索引键的前缀构建哈希索引。前缀可以是任意长度，并且可能只有b树中的某些值出现在哈希索引中。哈希索引是根据需要为经常访问的索引页构建的。</p><p>
            If a table fits almost entirely in main memory, a hash index can
            speed up queries by enabling direct lookup of any element, turning
            the index value into a sort of pointer. <code class="literal">InnoDB</code>
            has a mechanism that monitors index searches. If
            <code class="literal">InnoDB</code> notices that queries could benefit from
            building a hash index, it does so automatically.
        </p><p style="color:blue;">如果一个表几乎完全适合主内存，散列索引可以通过启用对任何元素的直接查找，将索引值转换为某种指针来加快查询速度。innodb有一个监视索引搜索的机制。如果innodb注意到构建散列索引可以使查询受益，那么它会自动这样做。</p><p>
            With some workloads, the speedup from hash index lookups greatly
            outweighs the extra work to monitor index lookups and maintain the
            hash index structure. Access to the adaptive hash index can
            sometimes become a source of contention under heavy workloads,
            such as multiple concurrent joins. Queries with
            <code class="literal">LIKE</code> operators and <code class="literal">%</code>
            wildcards also tend not to benefit. For workloads that do not
            benefit from the adaptive hash index feature, turning it off
            reduces unnecessary performance overhead. Because it is difficult
            to predict in advance whether the adaptive hash index feature is
            appropriate for a particular system and workload, consider running
            benchmarks with it enabled and disabled. Architectural changes in
            MySQL 5.6 make it more suitable to disable the adaptive hash index
            feature than in earlier releases.
        </p><p style="color:blue;">对于某些工作负载，哈希索引查找的速度大大超过了监视索引查找和维护哈希索引结构的额外工作。在繁重的工作负载（如多个并发连接）下，对自适应哈希索引的访问有时会成为争用源。使用like运算符和%通配符的查询也往往没有好处。对于不受益于自适应哈希索引功能的工作负载，关闭它可以减少不必要的性能开销。由于很难预先预测自适应哈希索引功能是否适合特定的系统和工作负载，请考虑在启用和禁用该功能的情况下运行基准测试。与早期版本相比，mysql 5.6中的体系结构更改使其更适合禁用自适应哈希索引功能。</p><p>
            In MySQL 5.7, the adaptive hash index feature is
            partitioned. Each index is bound to a specific partition, and each
            partition is protected by a separate latch. Partitioning is
            controlled by the
            <a class="link" href="innodb-storage-engine.html#sysvar_innodb_adaptive_hash_index_parts"><code class="literal">innodb_adaptive_hash_index_parts</code></a>
            variable. In earlier releases, the adaptive hash index feature was
            protected by a single latch which could become a point of
            contention under heavy workloads. The
            <a class="link" href="innodb-storage-engine.html#sysvar_innodb_adaptive_hash_index_parts"><code class="literal">innodb_adaptive_hash_index_parts</code></a>
            variable is set to 8 by default. The maximum setting is 512.
        </p><p style="color:blue;">在mysql 5.7中，自适应散列索引特性是分区的。每个索引都绑定到一个特定的分区，每个分区都由一个单独的锁存器保护。分区由innodb_adaptive_hash_index_parts变量控制。在早期版本中，自适应散列索引功能受单个锁存器的保护，在繁重的工作负载下，该锁存器可能成为争用点。innodb_adaptive_hash_index_parts变量默认设置为8。最大设定值为512。</p><p>
            You can monitor adaptive hash index use and contention in the
            <code class="literal">SEMAPHORES</code> section of
            <a class="link" href="sql-syntax.html#show-engine" title="13.7.5.15&nbsp;SHOW ENGINE Syntax"><code class="literal">SHOW ENGINE INNODB
                STATUS</code></a> output. If there are numerous threads waiting on
            RW-latches created in <code class="filename">btr0sea.c</code>, consider
            increasing the number of adaptive hash index partitions or
            disabling the adaptive hash index feature.
        </p><p style="color:blue;">您可以在show engine innodb status output的信号量部分监视自适应散列索引的使用和争用。如果有许多线程等待在btr0sea.c中创建的rw锁存，请考虑增加自适应哈希索引分区的数量或禁用自适应哈希索引功能。</p><p>
            For information about the performance characteristics of hash
            indexes, see <a class="xref" href="optimization.html#index-btree-hash" title="8.3.8&nbsp;Comparison of B-Tree and Hash Indexes">Section&nbsp;8.3.8, “Comparison of B-Tree and Hash Indexes”</a>.
        </p><p style="color:blue;">有关哈希索引的性能特征的信息，请参阅第8.3.8节“B-树和哈希索引的比较”。</p>
        </div>
        <div class="section">
            <div class="titlepage">
                <div>
                    <div>
                        <h3 class="title"><a name="innodb-redo-log-buffer"></a>14.5.4&nbsp;Log Buffer</h3>

                    </div>

                </div>

            </div>
            <p>
                The log buffer is the memory area that holds data to be written to
                the log files on disk. Log buffer size is defined by the
                <a class="link" href="innodb-storage-engine.html#sysvar_innodb_log_buffer_size"><code class="literal">innodb_log_buffer_size</code></a> variable.
                The default size is 16MB. The contents of the log buffer are
                periodically flushed to disk. A large log buffer enables large
                transactions to run without the need to write redo log data to
                disk before the transactions commit. Thus, if you have
                transactions that update, insert, or delete many rows, increasing
                the size of the log buffer saves disk I/O.
            </p><p style="color:blue;">日志缓冲区是存储要写入磁盘日志文件的数据的内存区域。日志缓冲区大小由innodb_log_buffer_size变量定义。默认大小为16MB。日志缓冲区的内容定期刷新到磁盘。大型日志缓冲区使大型事务能够运行，而无需在事务提交之前将重做日志数据写入磁盘。因此，如果您有更新、插入或删除许多行的事务，增加日志缓冲区的大小可以节省磁盘I/O。</p><p>
            The
            <a class="link" href="innodb-storage-engine.html#sysvar_innodb_flush_log_at_trx_commit"><code class="literal">innodb_flush_log_at_trx_commit</code></a>
            variable controls how the contents of the log buffer are written
            and flushed to disk. The
            <a class="link" href="innodb-storage-engine.html#sysvar_innodb_flush_log_at_timeout"><code class="literal">innodb_flush_log_at_timeout</code></a>
            variable controls log flushing frequency.
        </p><p style="color:blue;">innodb_flush_log_at_trx_commit变量控制如何将日志缓冲区的内容写入并刷新到磁盘。innodb_flush_log_at_timeout变量控制日志刷新频率。</p><p>
            For related information, see
            <a class="xref" href="innodb-storage-engine.html#innodb-startup-memory-configuration" title="Memory Configuration">Memory Configuration</a>, and
            <a class="xref" href="optimization.html#optimizing-innodb-logging" title="8.5.4&nbsp;Optimizing InnoDB Redo Logging">Section&nbsp;8.5.4, “Optimizing InnoDB Redo Logging”</a>.
        </p><p style="color:blue;">有关信息，请参阅内存配置和第8.5.4节“优化innodb重做日志”。</p>
        </div>

    </div>
    <div class="section">
        <div class="titlepage">
            <div>
                <div>
                    <h2 class="title" style="clear: both"><a name="innodb-on-disk-structures"></a>14.6&nbsp;InnoDB On-Disk Structures</h2>

                </div>

            </div>

        </div>
        <div class="toc">
            <dl class="toc"><dt><span class="section"><a href="innodb-storage-engine.html#innodb-tables">14.6.1 Tables</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-indexes">14.6.2 Indexes</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-tablespace">14.6.3 Tablespaces</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-data-dictionary">14.6.4 InnoDB Data Dictionary</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-doublewrite-buffer">14.6.5 Doublewrite Buffer</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-redo-log">14.6.6 Redo Log</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-undo-logs">14.6.7 Undo Logs</a></span></dt></dl>
        </div>
        <a class="indexterm" name="idm140286824246704"></a><p>
        This section describes <code class="literal">InnoDB</code> on-disk structures
        and related topics.
    </p><p style="color:blue;">本节介绍InnoDB的磁盘结构和相关主题。</p>
        <div class="section">

            <div class="titlepage">
                <div>
                    <div>
                        <h3 class="title"><a name="innodb-tables"></a>14.6.1&nbsp;Tables</h3>

                    </div>

                </div>

            </div>

            <div class="toc">
                <dl class="toc"><dt><span class="section"><a href="innodb-storage-engine.html#using-innodb-tables">14.6.1.1 Creating InnoDB Tables</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-migration">14.6.1.2 Moving or Copying InnoDB Tables</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#converting-tables-to-innodb">14.6.1.3 Converting Tables from MyISAM to InnoDB</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-auto-increment-handling">14.6.1.4 AUTO_INCREMENT Handling in InnoDB</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-foreign-key-constraints">14.6.1.5 InnoDB and FOREIGN KEY Constraints</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-restrictions">14.6.1.6 Limits on InnoDB Tables</a></span></dt></dl>
            </div>
            <a class="indexterm" name="idm140286824242944"></a><p>
            This section covers topics related to <code class="literal">InnoDB</code>
            tables.
        </p><p style="color:blue;">本节介绍与innodb表相关的主题。</p>
            <div class="section">

                <div class="titlepage">
                    <div>
                        <div>
                            <h4 class="title"><a name="using-innodb-tables"></a>14.6.1.1&nbsp;Creating InnoDB Tables</h4>
                        </div>
                    </div>
                </div>
                <a class="indexterm" name="idm140286824239136"></a><p>
                To create an <code class="literal">InnoDB</code> table, use the
                <a class="link" href="sql-syntax.html#create-table" title="13.1.18&nbsp;CREATE TABLE Syntax"><code class="literal">CREATE TABLE</code></a> statement.
            </p><p style="color:blue;">要创建innodb表，请使用create table语句。</p><pre data-lang="sql" class="programlisting">CREATE TABLE t1 (a INT, b CHAR (20), PRIMARY KEY (a)) ENGINE=InnoDB;
</pre><p>
                You do not need to specify the <code class="literal">ENGINE=InnoDB</code>
                clause if <code class="literal">InnoDB</code> is defined as the default
                storage engine, which it is by default. To check the default
                storage engine, issue the following statement:
            </p><p style="color:blue;">如果innodb被定义为默认的存储引擎，则不需要指定engine=innodb子句。要检查默认存储引擎，请发出以下语句：</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT @@default_storage_engine;</code></strong>
+--------------------------+
| @@default_storage_engine |
+--------------------------+
| InnoDB                   |
+--------------------------+
</pre><p>
                You might still use <code class="literal">ENGINE=InnoDB</code> clause if you
                plan to use <a class="link" href="programs.html#mysqldump" title="4.5.4&nbsp;mysqldump — A Database Backup Program"><span class="command"><strong>mysqldump</strong></span></a> or replication to replay
                the <a class="link" href="sql-syntax.html#create-table" title="13.1.18&nbsp;CREATE TABLE Syntax"><code class="literal">CREATE TABLE</code></a> statement on a
                server where the default storage engine is not
                <code class="literal">InnoDB</code>.
            </p><p style="color:blue;">如果您计划使用mysqldump或replication在默认存储引擎不是innodb的服务器上重播create table语句，那么仍然可以使用engine=innodb子句。</p><p>
                An <code class="literal">InnoDB</code> table and its indexes can be created
                in the <a class="link" href="glossary.html#glos_system_tablespace" title="system tablespace">system
                tablespace</a>, in a
                <a class="link" href="glossary.html#glos_file_per_table" title="file-per-table">file-per-table</a>
                tablespace, or in a
                <a class="link" href="glossary.html#glos_general_tablespace" title="general tablespace">general tablespace</a>.
                When <a class="link" href="innodb-storage-engine.html#sysvar_innodb_file_per_table"><code class="literal">innodb_file_per_table</code></a> is
                enabled, which is the default, an <code class="literal">InnoDB</code> table
                is implicitly created in an individual file-per-table tablespace.
                Conversely, when
                <a class="link" href="innodb-storage-engine.html#sysvar_innodb_file_per_table"><code class="literal">innodb_file_per_table</code></a> is
                disabled, an <code class="literal">InnoDB</code> table is implicitly created
                in the <code class="literal">InnoDB</code> system tablespace. To create a
                table in a general tablespace, use
                <a class="link" href="sql-syntax.html#create-table" title="13.1.18&nbsp;CREATE TABLE Syntax"><code class="literal">CREATE TABLE ...
                    TABLESPACE</code></a> syntax. For more information, see
                <a class="xref" href="innodb-storage-engine.html#general-tablespaces" title="14.6.3.3&nbsp;General Tablespaces">Section&nbsp;14.6.3.3, “General Tablespaces”</a>.
            </p><p style="color:blue;">innodb表及其索引可以在系统表空间、每表表空间一个文件或在一般表空间中创建。当innodb_file_per_table被启用（这是默认设置）时，innodb table被隐式地创建在单个file per table space中。相反，当innodb_file_per_table被禁用时，innodb table被隐式地创建在innodb系统表空间中。要在常规表空间中创建表，请使用CREATETABLE…表空间语法。有关更多信息，请参阅14.6.3.3节“常规表空间”。</p><p>
                When you create an <code class="literal">InnoDB</code> table, MySQL creates
                a <a class="link" href="glossary.html#glos_frm_file" title=".frm file">.frm file</a> in the database
                directory under the MySQL data directory. For more information
                about <code class="filename">.frm</code> files, see
                <a class="xref" href="innodb-storage-engine.html#innodb-frm-file" title="InnoDB Tables and .frm Files">InnoDB Tables and .frm Files</a>. For a table created in a
                file-per-table tablespace, MySQL also creates an
                <a class="link" href="glossary.html#glos_ibd_file" title=".ibd file">.ibd</a> tablespace file in the
                database directory, by default. A table created in the
                <code class="literal">InnoDB</code> system tablespace is created in an
                existing <a class="link" href="glossary.html#glos_ibd_file" title=".ibd file">ibdata file</a>, which
                resides in the MySQL data directory. A table created in a general
                tablespace is created in an existing general tablespace
                <a class="link" href="glossary.html#glos_ibd_file" title=".ibd file">.ibd file</a>. General tablespace
                files can be created inside or outside of the MySQL data
                directory. For more information, see
                <a class="xref" href="innodb-storage-engine.html#general-tablespaces" title="14.6.3.3&nbsp;General Tablespaces">Section&nbsp;14.6.3.3, “General Tablespaces”</a>.
            </p><p style="color:blue;">创建innodb表时，mysql会在mysql数据目录下的数据库目录中创建一个.frm文件。有关.frm文件的更多信息，请参阅innodb tables和.frm files。对于在每个表空间的文件中创建的表，默认情况下，mysql还会在数据库目录中创建一个.ibd表空间文件。在IDAB系统表空间中创建的表是在现有的iBdata文件中创建的，该文件位于MySQL数据目录中。在现有的通用表空间.IBD文件中创建一个通用表空间中创建的表。可以在mysql数据目录内部或外部创建常规表空间文件。有关更多信息，请参阅14.6.3.3节“常规表空间”。</p><p>
                Internally, <code class="literal">InnoDB</code> adds an entry for each table
                to the <code class="literal">InnoDB</code> data dictionary. The entry
                includes the database name. For example, if table
                <code class="literal">t1</code> is created in the <code class="literal">test</code>
                database, the data dictionary entry for the database name is
                <code class="literal">'test/t1'</code>. This means you can create a table of
                the same name (<code class="literal">t1</code>) in a different database, and
                the table names do not collide inside <code class="literal">InnoDB</code>.
            </p><p style="color:blue;">在内部，innodb为innodb数据字典中的每个表添加一个条目。条目包括数据库名称。例如，如果表T1是在测试数据库中创建的，则数据库名称的数据字典条目为“test/t1”。这意味着您可以在不同的数据库中创建一个同名（T1）的表，并且表名在InnoDB中不会发生冲突。</p>
                <div class="simplesect">

                    <div class="titlepage">
                        <div>

                            <div class="simple">
                                <h5 class="title"><a name="innodb-frm-file"></a>InnoDB Tables and .frm Files</h5>
                            </div>
                        </div>
                    </div>
                    <a class="indexterm" name="idm140286824200560"></a><p>
                    MySQL stores data dictionary information for tables in
                    <a class="link" href="glossary.html#glos_frm_file" title=".frm file">.frm files</a> in database
                    directories. Unlike other MySQL storage engines,
                    <code class="literal">InnoDB</code> also encodes information about the
                    table in its own internal data dictionary inside the system
                    tablespace. When MySQL drops a table or a database, it deletes
                    one or more <code class="filename">.frm</code> files as well as the
                    corresponding entries inside the <code class="literal">InnoDB</code> data
                    dictionary. You cannot move <code class="literal">InnoDB</code> tables
                    between databases simply by moving the <code class="filename">.frm</code>
                    files. For information about moving <code class="literal">InnoDB</code>
                    tables, see <a class="xref" href="innodb-storage-engine.html#innodb-migration" title="14.6.1.2&nbsp;Moving or Copying InnoDB Tables">Section&nbsp;14.6.1.2, “Moving or Copying InnoDB Tables”</a>.
                </p><p style="color:blue;">mysql在数据库目录的.frm文件中存储表的数据字典信息。与其他mysql存储引擎不同，innodb还将表的信息编码到系统表空间中自己的内部数据字典中。当mysql删除一个表或数据库时，它会删除一个或多个.frm文件以及innodb数据字典中相应的条目。不能简单地通过移动.frm文件在数据库之间移动innodb表。有关移动innodb表的信息，请参阅14.6.1.2节“移动或复制innodb表”。</p>
                </div>
                <div class="simplesect">
                    <div class="titlepage">
                        <div>
                            <div class="simple">
                                <h5 class="title"><a name="innodb-tables-row-format"></a>InnoDB Tables and Row Formats</h5>

                            </div>

                        </div>

                    </div>
                    <a class="indexterm" name="idm140286824191088"></a><p>
                    The default row format for <code class="literal">InnoDB</code> tables is
                    defined by the
                    <a class="link" href="innodb-storage-engine.html#sysvar_innodb_default_row_format"><code class="literal">innodb_default_row_format</code></a>
                    configuration option, which has a default value of
                    <code class="literal">DYNAMIC</code>.
                    <code class="literal"><a class="link" href="glossary.html#glos_dynamic_row_format" title="dynamic row format">Dynamic</a></code>
                    and
                    <code class="literal"><a class="link" href="glossary.html#glos_compressed_row_format" title="compressed row format">Compressed</a></code>
                    row format allow you to take advantage of
                    <code class="literal">InnoDB</code> features such as table compression and
                    efficient off-page storage of long column values. To use these
                    row formats,
                    <a class="link" href="innodb-storage-engine.html#sysvar_innodb_file_per_table"><code class="literal">innodb_file_per_table</code></a> must be
                    enabled (the default as of MySQL 5.6.6) and
                    <a class="link" href="innodb-storage-engine.html#sysvar_innodb_file_format"><code class="literal">innodb_file_format</code></a> must be set
                    to <a class="link" href="glossary.html#glos_barracuda" title="Barracuda">Barracuda</a>.
                </p><p style="color:blue;">innodb表的默认行格式由innodb_default_row_format配置选项定义，该选项的默认值为dynamic。动态和压缩行格式允许您利用innodb的特性，例如表压缩和长列值的高效页外存储。要使用这些行格式，必须启用innodb_file_per_table（mysql 5.6.6的默认值），并且innodb_file_format必须设置为barracuda。</p><pre data-lang="sql" class="programlisting">SET GLOBAL innodb_file_per_table=1;
SET GLOBAL innodb_file_format=barracuda;
CREATE TABLE t3 (a INT, b CHAR (20), PRIMARY KEY (a)) ROW_FORMAT=DYNAMIC;
CREATE TABLE t4 (a INT, b CHAR (20), PRIMARY KEY (a)) ROW_FORMAT=COMPRESSED;
</pre><p>
                    Alternatively, you can use
                    <a class="link" href="sql-syntax.html#create-table" title="13.1.18&nbsp;CREATE TABLE Syntax"><code class="literal">CREATE TABLE ...
                        TABLESPACE</code></a> syntax to create an
                    <code class="literal">InnoDB</code> table in a general tablespace. General
                    tablespaces support all row formats. For more information, see
                    <a class="xref" href="innodb-storage-engine.html#general-tablespaces" title="14.6.3.3&nbsp;General Tablespaces">Section&nbsp;14.6.3.3, “General Tablespaces”</a>.
                </p><p style="color:blue;">或者，您可以使用create table…在常规表空间中创建innodb表的表空间语法。常规表空间支持所有行格式。有关更多信息，请参阅14.6.3.3节“常规表空间”。</p><pre data-lang="sql" class="programlisting">CREATE TABLE t1 (c1 INT PRIMARY KEY) TABLESPACE ts1 ROW_FORMAT=DYNAMIC;
</pre><p>
                    <a class="link" href="sql-syntax.html#create-table" title="13.1.18&nbsp;CREATE TABLE Syntax"><code class="literal">CREATE TABLE ...
                        TABLESPACE</code></a> syntax can also be used to create
                    <code class="literal">InnoDB</code> tables with a
                    <code class="literal">Dynamic</code> row format in the system tablespace,
                    alongside tables with a <code class="literal">Compact</code> or
                    <code class="literal">Redundant</code> row format.
                </p><p style="color:blue;">创建表…表空间语法还可用于在系统表空间中创建具有动态行格式的innodb表，以及具有压缩或冗余行格式的表。</p><pre data-lang="sql" class="programlisting">CREATE TABLE t1 (c1 INT PRIMARY KEY) TABLESPACE = innodb_system ROW_FORMAT=DYNAMIC;
</pre><p>
                    For more information about <code class="literal">InnoDB</code> row
                    formats, see <a class="xref" href="innodb-storage-engine.html#innodb-row-format" title="14.11&nbsp;InnoDB Row Formats">Section&nbsp;14.11, “InnoDB Row Formats”</a>. For how to
                    determine the row format of an <code class="literal">InnoDB</code> table
                    and the physical characteristics of <code class="literal">InnoDB</code>
                    row formats, see <a class="xref" href="innodb-storage-engine.html#innodb-row-format" title="14.11&nbsp;InnoDB Row Formats">Section&nbsp;14.11, “InnoDB Row Formats”</a>.
                </p><p style="color:blue;">有关innodb行格式的更多信息，请参见第14.11节“innodb行格式”。有关如何确定innodb表的行格式和innodb行格式的物理特性，请参阅14.11节“innodb行格式”。</p>
                </div>
                <div class="simplesect">
                    <div class="titlepage">
                        <div>
                            <div class="simple">
                                <h5 class="title"><a name="innodb-tables-primary-key"></a>InnoDB Tables and Primary Keys</h5>

                            </div>

                        </div>

                    </div>
                    <a class="indexterm" name="idm140286824163168"></a><p>
                    Always define a <a class="link" href="glossary.html#glos_primary_key" title="primary key">primary
                    key</a> for an <code class="literal">InnoDB</code> table, specifying
                    the column or columns that:
                </p><p style="color:blue;">始终为innodb表定义主键，指定以下列：</p>
                    <div class="itemizedlist">
                        <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                            Are referenced by the most important queries.
                        </p><p style="color:blue;">被最重要的查询引用。</p></li><li class="listitem"><p>
                            Are never left blank.
                        </p><p style="color:blue;">永远不会空白。</p></li><li class="listitem"><p>
                            Never have duplicate values.
                        </p><p style="color:blue;">永远不要有重复的值。</p></li><li class="listitem"><p>
                            Rarely if ever change value once inserted.
                        </p><p style="color:blue;">一旦插入就很少更改值。</p></li></ul>
                    </div>
                    <p>
                        For example, in a table containing information about people, you
                        would not create a primary key on <code class="literal">(firstname,
                        lastname)</code> because more than one person can have the
                        same name, some people have blank last names, and sometimes
                        people change their names. With so many constraints, often there
                        is not an obvious set of columns to use as a primary key, so you
                        create a new column with a numeric ID to serve as all or part of
                        the primary key. You can declare an
                        <a class="link" href="glossary.html#glos_auto_increment" title="auto-increment">auto-increment</a> column
                        so that ascending values are filled in automatically as rows are
                        inserted:
                    </p><p style="color:blue;">例如，在包含人员信息的表中，您不会在（firstname，last name）上创建主键，因为不止一个人可以有相同的名称，有些人的姓氏为空，有时人们会更改他们的姓名。由于有这么多约束，通常没有一组明显的列用作主键，因此您可以创建一个具有数字id的新列作为主键的全部或部分。可以声明自动递增列，以便在插入行时自动填充升序值：</p><pre data-lang="sql" class="programlisting"># The value of ID can act like a pointer between related items in different tables.
CREATE TABLE t5 (id INT AUTO_INCREMENT, b CHAR (20), PRIMARY KEY (id));

# The primary key can consist of more than one column. Any autoinc column must come first.
CREATE TABLE t6 (id INT AUTO_INCREMENT, a INT, b CHAR (20), PRIMARY KEY (id,a));
</pre><p>
                    Although the table works correctly without defining a primary
                    key, the primary key is involved with many aspects of
                    performance and is a crucial design aspect for any large or
                    frequently used table. It is recommended that you always specify
                    a primary key in the <a class="link" href="sql-syntax.html#create-table" title="13.1.18&nbsp;CREATE TABLE Syntax"><code class="literal">CREATE TABLE</code></a>
                    statement. If you create the table, load data, and then run
                    <a class="link" href="sql-syntax.html#alter-table" title="13.1.8&nbsp;ALTER TABLE Syntax"><code class="literal">ALTER TABLE</code></a> to add a primary key
                    later, that operation is much slower than defining the primary
                    key when creating the table.
                </p><p style="color:blue;">尽管表在不定义主键的情况下工作正常，但主键涉及到性能的许多方面，对于任何大型或常用表来说，它都是一个关键的设计方面。建议始终在CREATE TABLE语句中指定主键。如果创建表、加载数据，然后运行alter table在以后添加主键，则该操作比创建表时定义主键慢得多。</p>
                </div>
                <div class="simplesect">
                    <div class="titlepage">
                        <div>
                            <div class="simple">
                                <h5 class="title"><a name="innodb-viewing-table-properties"></a>Viewing InnoDB Table Properties</h5>

                            </div>

                        </div>

                    </div>
                    <a class="indexterm" name="idm140286824147424"></a><p>
                    To view the properties of an <code class="literal">InnoDB</code> table,
                    issue a <a class="link" href="sql-syntax.html#show-table-status" title="13.7.5.36&nbsp;SHOW TABLE STATUS Syntax"><code class="literal">SHOW TABLE STATUS</code></a>
                    statement:
                </p><p style="color:blue;">要查看innodb表的属性，发出show table status语句：</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>SHOW TABLE STATUS FROM test LIKE 't%' \G;</code></strong>
*************************** 1. row ***************************
           Name: t1
         Engine: InnoDB
        Version: 10
     Row_format: Compact
           Rows: 0
 Avg_row_length: 0
    Data_length: 16384
Max_data_length: 0
   Index_length: 0
      Data_free: 0
 Auto_increment: NULL
    Create_time: 2015-03-16 15:13:31
    Update_time: NULL
     Check_time: NULL
      Collation: latin1_swedish_ci
       Checksum: NULL
 Create_options:
        Comment:
1 row in set (0.00 sec)
</pre><p>
                    For information about <a class="link" href="sql-syntax.html#show-table-status" title="13.7.5.36&nbsp;SHOW TABLE STATUS Syntax"><code class="literal">SHOW TABLE
                    STATUS</code></a> output, see
                    <a class="xref" href="sql-syntax.html#show-table-status" title="13.7.5.36&nbsp;SHOW TABLE STATUS Syntax">Section&nbsp;13.7.5.36, “SHOW TABLE STATUS Syntax”</a>.
                </p><p style="color:blue;">有关显示表状态输出的信息，请参阅第13.7.5.36节“显示表状态语法”。</p><p>
                    <code class="literal">InnoDB</code> table properties may also be queried
                    using the <code class="literal">InnoDB</code> Information Schema system
                    tables:
                </p><p style="color:blue;">也可以使用innodb information schema系统表查询innodb表属性：</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT * FROM INFORMATION_SCHEMA.INNODB_SYS_TABLES WHERE NAME='test/t1' \G</code></strong>
*************************** 1. row ***************************
     TABLE_ID: 45
         NAME: test/t1
         FLAG: 1
       N_COLS: 5
        SPACE: 35
  FILE_FORMAT: Antelope
   ROW_FORMAT: Compact
ZIP_PAGE_SIZE: 0
   SPACE_TYPE: Single
1 row in set (0.00 sec)
</pre><p>
                    For more information, see
                    <a class="xref" href="innodb-storage-engine.html#innodb-information-schema-system-tables" title="14.15.3&nbsp;InnoDB INFORMATION_SCHEMA System Tables">Section&nbsp;14.15.3, “InnoDB INFORMATION_SCHEMA System Tables”</a>.
                </p><p style="color:blue;">有关更多信息，请参阅14.15.3节，“innodb information_schema system tables”。</p>
                </div>

            </div>
            <div class="section">
                <div class="titlepage">
                    <div>
                        <div>
                            <h4 class="title"><a name="innodb-migration"></a>14.6.1.2&nbsp;Moving or Copying InnoDB Tables</h4>

                        </div>

                    </div>

                </div>
                <a class="indexterm" name="idm140286824132464"></a><p>
                This section describes techniques for moving or copying some or all
                <code class="literal">InnoDB</code> tables to a different server or instance.
                For example, you might move an entire MySQL instance to a larger,
                faster server; you might clone an entire MySQL instance to a new
                replication slave server; you might copy individual tables to
                another instance to develop and test an application, or to a data
                warehouse server to produce reports.
            </p><p style="color:blue;">本节描述将一些或所有innodb表移动或复制到不同服务器或实例的技术。例如，可以将整个mysql实例移动到更大、更快的服务器；可以将整个mysql实例克隆到新的复制从属服务器；可以将单个表复制到另一个实例以开发和测试应用程序，或者复制到数据仓库服务器以生成报告。</p><p>
                On Windows, <code class="literal">InnoDB</code> always stores database and
                table names internally in lowercase. To move databases in a binary
                format from Unix to Windows or from Windows to Unix, create all
                databases and tables using lowercase names. A convenient way to
                accomplish this is to add the following line to the
                <code class="literal">[mysqld]</code> section of your
                <code class="filename">my.cnf</code> or <code class="filename">my.ini</code> file
                before creating any databases or tables:
            </p><p style="color:blue;">在windows上，innodb总是在内部以小写形式存储数据库和表名。要将二进制格式的数据库从unix移动到windows或从windows移动到unix，请使用小写名称创建所有数据库和表。一种方便的方法是在创建任何数据库或表之前，将以下行添加到my.cnf或my.ini文件的[mysqld]部分：</p><pre data-lang="ini" class="programlisting">[mysqld]
lower_case_table_names=1
</pre><p>
                Techniques for moving or copying <code class="literal">InnoDB</code> tables
                include:
            </p><p style="color:blue;">移动或复制innodb表的技术包括：</p>
                <div class="itemizedlist">
                    <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><a class="xref" href="innodb-storage-engine.html#copy-tables-transportable-tablespaces" title="Transportable Tablespaces">Transportable Tablespaces</a></p><p style="color:blue;">迁移表空间</p></li><li class="listitem"><p><a class="xref" href="innodb-storage-engine.html#copy-tables-meb" title="MySQL Enterprise Backup">MySQL Enterprise Backup</a></p><p style="color:blue;">MySQL企业备份</p></li><li class="listitem"><p><a class="xref" href="innodb-storage-engine.html#copy-tables-cold-backup" title="Copying Data Files (Cold Backup Method)">Copying Data Files (Cold Backup Method)</a></p><p style="color:blue;">复制数据文件（冷备份方法）</p></li><li class="listitem"><p><a class="xref" href="innodb-storage-engine.html#copy-tables-export-import" title="Export and Import (mysqldump)">Export and Import (mysqldump)</a></p><p style="color:blue;">导出和导入（mysqldump）</p></li></ul>
                </div>
                <h5><a name="copy-tables-transportable-tablespaces"></a>Transportable Tablespaces</h5>
                <p>
                    The transportable tablespaces feature uses
                    <a class="link" href="sql-syntax.html#flush-tables-for-export-with-list"><code class="literal">FLUSH
                        TABLES ... FOR EXPORT</code></a> to ready <code class="literal">InnoDB</code>
                    tables for copying from one server instance to another. To use this
                    feature, <code class="literal">InnoDB</code> tables must be created with
                    <a class="link" href="innodb-storage-engine.html#sysvar_innodb_file_per_table"><code class="literal">innodb_file_per_table</code></a> set to
                    <code class="literal">ON</code> so that each <code class="literal">InnoDB</code> table
                    has its own tablespace. For usage information, see
                    <a class="xref" href="innodb-storage-engine.html#tablespace-copying" title="14.6.3.7&nbsp;Copying Tablespaces to Another Instance">Section&nbsp;14.6.3.7, “Copying Tablespaces to Another Instance”</a>.
                </p><p style="color:blue;">可移植表空间功能使用刷新表…用于导出到就绪的innodb表，以便从一个服务器实例复制到另一个服务器实例。要使用这个特性，innodb表必须在innodb_file_per_table设置为on的情况下创建，这样每个innodb表都有自己的表空间。有关用法信息，请参阅第14.6.3.7节“将表空间复制到另一个实例”。</p>
                <h5><a name="copy-tables-meb"></a>MySQL Enterprise Backup</h5>
                <p>
                    The MySQL Enterprise Backup product lets you back up a running MySQL
                    database with minimal disruption to operations while producing a
                    consistent snapshot of the database. When MySQL Enterprise Backup is
                    copying tables, reads and writes can continue. In addition, MySQL
                    Enterprise Backup can create compressed backup files, and back up
                    subsets of tables. In conjunction with the MySQL binary log, you can
                    perform point-in-time recovery. MySQL Enterprise Backup is included
                    as part of the MySQL Enterprise subscription.
                </p><p style="color:blue;">mysql企业备份产品允许您备份正在运行的mysql数据库，而对操作的中断最小，同时生成数据库的一致快照。当mysql企业备份复制表时，可以继续进行读写操作。此外，mysql企业备份可以创建压缩备份文件，并备份表的子集。结合mysql二进制日志，您可以执行时间点恢复。mysql企业备份是mysql企业订阅的一部分。</p><p>
                For more details about MySQL Enterprise Backup, see
                <a class="xref" href="mysql-enterprise.html#mysql-enterprise-backup" title="29.2&nbsp;MySQL Enterprise Backup Overview">Section&nbsp;29.2, “MySQL Enterprise Backup Overview”</a>.
            </p><p style="color:blue;">有关mysql企业备份的详细信息，请参阅29.2节“mysql企业备份概述”。</p>
                <h5><a name="copy-tables-cold-backup"></a>Copying Data Files (Cold Backup Method)</h5>
                <p>
                    You can move an <code class="literal">InnoDB</code> database simply by copying
                    all the relevant files listed under "Cold Backups" in
                    <a class="xref" href="innodb-storage-engine.html#innodb-backup" title="14.18.1&nbsp;InnoDB Backup">Section&nbsp;14.18.1, “InnoDB Backup”</a>.
                </p><p style="color:blue;">只需复制第14.18.1节“InnoDB备份”中“冷备份”下列出的所有相关文件，就可以移动InnoDB数据库。</p><p>
                <code class="literal">InnoDB</code> data and log files are binary-compatible
                on all platforms having the same floating-point number format. If
                the floating-point formats differ but you have not used
                <a class="link" href="data-types.html#floating-point-types" title="11.2.3&nbsp;Floating-Point Types (Approximate Value) - FLOAT, DOUBLE"><code class="literal">FLOAT</code></a> or
                <a class="link" href="data-types.html#floating-point-types" title="11.2.3&nbsp;Floating-Point Types (Approximate Value) - FLOAT, DOUBLE"><code class="literal">DOUBLE</code></a> data types in your tables,
                then the procedure is the same: simply copy the relevant files.
            </p><p style="color:blue;">InnoDB数据和日志文件在所有具有相同浮点数格式的平台上都是二进制兼容的。如果浮点格式不同，但表中没有使用float或double数据类型，则过程相同：只需复制相关文件。</p><p>
                When you move or copy file-per-table <code class="filename">.ibd</code>
                files, the database directory name must be the same on the source
                and destination systems. The table definition stored in the
                <code class="literal">InnoDB</code> shared tablespace includes the database
                name. The transaction IDs and log sequence numbers stored in the
                tablespace files also differ between databases.
            </p><p style="color:blue;">在按表.ibd文件移动或复制文件时，源系统和目标系统上的数据库目录名必须相同。存储在innodb共享表空间中的表定义包括数据库名。存储在表空间文件中的事务id和日志序列号在数据库之间也有所不同。</p><p>
                To move an <code class="filename">.ibd</code> file and the associated table
                from one database to another, use a <a class="link" href="sql-syntax.html#rename-table" title="13.1.33&nbsp;RENAME TABLE Syntax"><code class="literal">RENAME
                TABLE</code></a> statement:
            </p><p style="color:blue;">要将.ibd文件和关联的表从一个数据库移动到另一个数据库，请使用rename table语句：</p><pre data-lang="sql" class="programlisting">RENAME TABLE <em class="replaceable"><code>db1.tbl_name</code></em> TO <em class="replaceable"><code>db2.tbl_name</code></em>;
</pre><a class="indexterm" name="idm140286824095024"></a><a class="indexterm" name="idm140286824093952"></a><p>
                If you have a <span class="quote">“<span class="quote">clean</span>”</span> backup of an
                <code class="filename">.ibd</code> file, you can restore it to the MySQL
                installation from which it originated as follows:
            </p><p style="color:blue;">如果您有一个.ibd文件的“干净”备份，您可以将其还原到mysql安装，它的起源如下：</p>
                <div class="orderedlist">
                    <ol class="orderedlist" type="1"><li class="listitem"><p>
                        The table must not have been dropped or truncated since you
                        copied the <code class="filename">.ibd</code> file, because doing so
                        changes the table ID stored inside the tablespace.
                    </p><p style="color:blue;">复制.ibd文件后，不能删除或截断表，因为这样做会更改存储在表空间中的表id。</p></li><li class="listitem"><p>
                        Issue this <a class="link" href="sql-syntax.html#alter-table" title="13.1.8&nbsp;ALTER TABLE Syntax"><code class="literal">ALTER TABLE</code></a> statement
                        to delete the current <code class="filename">.ibd</code> file:
                    </p><p style="color:blue;">发出此alter table语句以删除当前的.ibd文件：</p><pre data-lang="sql" class="programlisting">ALTER TABLE <em class="replaceable"><code>tbl_name</code></em> DISCARD TABLESPACE;
</pre></li><li class="listitem"><p>
                        Copy the backup <code class="filename">.ibd</code> file to the proper
                        database directory.
                    </p><p style="color:blue;">将backup.ibd文件复制到正确的数据库目录。</p></li><li class="listitem"><p>
                        Issue this <a class="link" href="sql-syntax.html#alter-table" title="13.1.8&nbsp;ALTER TABLE Syntax"><code class="literal">ALTER TABLE</code></a> statement
                        to tell <code class="literal">InnoDB</code> to use the new
                        <code class="filename">.ibd</code> file for the table:
                    </p><p style="color:blue;">发出这个alter table语句，告诉innodb为表使用新的.ibd文件：</p><pre data-lang="sql" class="programlisting">ALTER TABLE <em class="replaceable"><code>tbl_name</code></em> IMPORT TABLESPACE;
</pre>
                        <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">

                            <div class="admon-title">
                                Note
                            </div>
                            <p>
                                The <a class="link" href="sql-syntax.html#alter-table" title="13.1.8&nbsp;ALTER TABLE Syntax"><code class="literal">ALTER TABLE
                                ... IMPORT TABLESPACE</code></a> feature does not enforce
                                foreign key constraints on imported data.
                            </p><p style="color:blue;">更改表…导入表空间功能不对导入的数据强制外键约束。</p>
                        </div>
                    </li></ol>
                </div>
                <p>
                    In this context, a <span class="quote">“<span class="quote">clean</span>”</span> <code class="filename">.ibd</code>
                    file backup is one for which the following requirements are
                    satisfied:
                </p><p style="color:blue;">在此上下文中，“clean”.ibd文件备份”满足以下要求：</p>
                <div class="itemizedlist">
                    <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                        There are no uncommitted modifications by transactions in the
                        <code class="filename">.ibd</code> file.
                    </p><p style="color:blue;">.ibd文件中没有事务未提交的修改。</p></li><li class="listitem"><p>
                        There are no unmerged insert buffer entries in the
                        <code class="filename">.ibd</code> file.
                    </p><p style="color:blue;">.ibd文件中没有未合并的插入缓冲区项。</p></li><li class="listitem"><p>
                        Purge has removed all delete-marked index records from the
                        <code class="filename">.ibd</code> file.
                    </p><p style="color:blue;">清除已从.ibd文件中删除所有删除标记的索引记录。</p></li><li class="listitem"><p>
                        <a class="link" href="programs.html#mysqld" title="4.3.1&nbsp;mysqld — The MySQL Server"><span class="command"><strong>mysqld</strong></span></a> has flushed all modified pages of the
                        <code class="filename">.ibd</code> file from the buffer pool to the file.
                    </p><p style="color:blue;">mysqld已将.ibd文件的所有修改页从缓冲池刷新到该文件。</p></li></ul>
                </div>
                <p>
                    You can make a clean backup <code class="filename">.ibd</code> file using the
                    following method:
                </p><p style="color:blue;">您可以使用以下方法创建一个干净的备份.ibd文件：</p>
                <div class="orderedlist">
                    <ol class="orderedlist" type="1"><li class="listitem"><p>
                        Stop all activity from the <a class="link" href="programs.html#mysqld" title="4.3.1&nbsp;mysqld — The MySQL Server"><span class="command"><strong>mysqld</strong></span></a> server and
                        commit all transactions.
                    </p><p style="color:blue;">停止mysqld服务器上的所有活动并提交所有事务。</p></li><li class="listitem"><p>
                        Wait until <a class="link" href="sql-syntax.html#show-engine" title="13.7.5.15&nbsp;SHOW ENGINE Syntax"><code class="literal">SHOW
                        ENGINE INNODB STATUS</code></a> shows that there are no active
                        transactions in the database, and the main thread status of
                        <code class="literal">InnoDB</code> is <code class="literal">Waiting for server
                        activity</code>. Then you can make a copy of the
                        <code class="filename">.ibd</code> file.
                    </p><p style="color:blue;">等到show engine innodb status显示数据库中没有活动事务，并且innodb的主线程状态正在等待服务器活动。然后可以复制.ibd文件。</p></li></ol>
                </div>
                <p>
                    Another method for making a clean copy of an
                    <code class="filename">.ibd</code> file is to use the MySQL Enterprise Backup
                    product:
                </p><p style="color:blue;">制作.ibd文件干净副本的另一种方法是使用mysql企业备份产品：</p>
                <div class="orderedlist">
                    <ol class="orderedlist" type="1"><li class="listitem"><p>
                        Use MySQL Enterprise Backup to back up the
                        <code class="literal">InnoDB</code> installation.
                    </p><p style="color:blue;">使用mysql enterprise back up备份innodb安装。</p></li><li class="listitem"><p>
                        Start a second <a class="link" href="programs.html#mysqld" title="4.3.1&nbsp;mysqld — The MySQL Server"><span class="command"><strong>mysqld</strong></span></a> server on the backup
                        and let it clean up the <code class="filename">.ibd</code> files in the
                        backup.
                    </p><p style="color:blue;">在备份上启动第二个mysqld服务器，让它清理备份中的.ibd文件。</p></li></ol>
                </div>
                <h5><a name="copy-tables-export-import"></a>Export and Import (mysqldump)</h5>
                <p>
                    You can use <a class="link" href="programs.html#mysqldump" title="4.5.4&nbsp;mysqldump — A Database Backup Program"><span class="command"><strong>mysqldump</strong></span></a> to dump your tables on one
                    machine and then import the dump files on the other machine. Using
                    this method, it does not matter whether the formats differ or if
                    your tables contain floating-point data.
                </p><p style="color:blue;">您可以使用mysqldump在一台机器上转储表，然后在另一台机器上导入转储文件。使用此方法，格式是否不同或表是否包含浮点数据并不重要。</p><p>
                One way to increase the performance of this method is to switch off
                <a class="link" href="glossary.html#glos_autocommit" title="autocommit">autocommit</a> mode when
                importing data, assuming that the tablespace has enough space for
                the big rollback segment that the import transactions generate. Do
                the commit only after importing a whole table or a segment of a
                table.
            </p><p style="color:blue;">提高此方法性能的一种方法是在导入数据时关闭自动提交模式，假设表空间有足够的空间用于导入事务生成的大回滚段。只有在导入整个表或表的一段之后才执行提交。</p>
            </div>
            <div class="section">
                <div class="titlepage">
                    <div>
                        <div>
                            <h4 class="title"><a name="converting-tables-to-innodb"></a>14.6.1.3&nbsp;Converting Tables from MyISAM to InnoDB</h4>

                        </div>

                    </div>

                </div>
                <a class="indexterm" name="idm140286824045408"></a><a class="indexterm" name="idm140286824043488"></a><p>
                If you have <a class="link" href="storage-engines.html#myisam-storage-engine" title="15.2&nbsp;The MyISAM Storage Engine"><code class="literal">MyISAM</code></a> tables that you want
                to convert to <a class="link" href="innodb-storage-engine.html" title="Chapter&nbsp;14&nbsp;The InnoDB Storage Engine"><code class="literal">InnoDB</code></a> for better
                reliability and scalability, review the following guidelines and
                tips before converting.
            </p><p style="color:blue;">如果有要转换为innodb以获得更好的可靠性和可伸缩性的myisam表，请在转换之前查看以下指南和提示。</p>
                <div class="itemizedlist">
                    <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><a class="xref" href="innodb-storage-engine.html#innodb-convert-memory-usage" title="Adjusting Memory Usage for MyISAM and InnoDB">Adjusting Memory Usage for MyISAM and InnoDB</a></p><p style="color:blue;">调整myisam和innodb的内存使用</p></li><li class="listitem"><p><a class="xref" href="innodb-storage-engine.html#innodb-convert-transactions" title="Handling Too-Long Or Too-Short Transactions">Handling Too-Long Or Too-Short Transactions</a></p><p style="color:blue;">处理太长或太短的事务</p></li><li class="listitem"><p><a class="xref" href="innodb-storage-engine.html#innodb-convert-deadlock" title="Handling Deadlocks">Handling Deadlocks</a></p><p style="color:blue;">处理死锁</p></li><li class="listitem"><p><a class="xref" href="innodb-storage-engine.html#innodb-convert-plan-storage" title="Planning the Storage Layout">Planning the Storage Layout</a></p><p style="color:blue;">规划存储布局</p></li><li class="listitem"><p><a class="xref" href="innodb-storage-engine.html#innodb-convert-convert" title="Converting an Existing Table">Converting an Existing Table</a></p><p style="color:blue;">转换现有表</p></li><li class="listitem"><p><a class="xref" href="innodb-storage-engine.html#innodb-convert-clone" title="Cloning the Structure of a Table">Cloning the Structure of a Table</a></p><p style="color:blue;">克隆表的结构</p></li><li class="listitem"><p><a class="xref" href="innodb-storage-engine.html#innodb-convert-transfer" title="Transferring Existing Data">Transferring Existing Data</a></p><p style="color:blue;">传输现有数据</p></li><li class="listitem"><p><a class="xref" href="innodb-storage-engine.html#innodb-convert-storage-requirements" title="Storage Requirements">Storage Requirements</a></p><p style="color:blue;">储存要求</p></li><li class="listitem"><p><a class="xref" href="innodb-storage-engine.html#innodb-convert-primary-key" title="Defining a PRIMARY KEY for Each Table">Defining a PRIMARY KEY for Each Table</a></p><p style="color:blue;">为每个表定义主键</p></li><li class="listitem"><p><a class="xref" href="innodb-storage-engine.html#innodb-convert-application-performance" title="Application Performance Considerations">Application Performance Considerations</a></p><p style="color:blue;">应用程序性能注意事项</p></li><li class="listitem"><p><a class="xref" href="innodb-storage-engine.html#innodb-convert-understand-files" title="Understanding Files Associated with InnoDB Tables">Understanding Files Associated with InnoDB Tables</a></p><p style="color:blue;">了解与innodb表关联的文件</p></li></ul>
                </div>

                <div class="simplesect">

                    <div class="titlepage">
                        <div>

                            <div class="simple">
                                <h5 class="title"><a name="innodb-convert-memory-usage"></a>Adjusting Memory Usage for MyISAM and InnoDB</h5>

                            </div>

                        </div>

                    </div>
                    <a class="indexterm" name="idm140286824025600"></a><p>
                    As you transition away from <code class="literal">MyISAM</code> tables,
                    lower the value of the
                    <a class="link" href="server-administration.html#sysvar_key_buffer_size"><code class="literal">key_buffer_size</code></a> configuration
                    option to free memory no longer needed for caching results.
                    Increase the value of the
                    <a class="link" href="innodb-storage-engine.html#sysvar_innodb_buffer_pool_size"><code class="literal">innodb_buffer_pool_size</code></a>
                    configuration option, which performs a similar role of allocating
                    cache memory for <code class="literal">InnoDB</code> tables. The
                    <code class="literal">InnoDB</code> <a class="link" href="glossary.html#glos_buffer_pool" title="buffer pool">buffer
                    pool</a> caches both table data and index data, speeding up
                    lookups for queries and keeping query results in memory for reuse.
                    For guidance regarding buffer pool size configuration, see
                    <a class="xref" href="optimization.html#memory-use" title="8.12.4.1&nbsp;How MySQL Uses Memory">Section&nbsp;8.12.4.1, “How MySQL Uses Memory”</a>.
                </p><p style="color:blue;">从myisam表转换时，降低key_buffer_size配置选项的值，以释放缓存结果不再需要的内存。增加innodb_buffer_pool_size配置选项的值，该选项执行类似的角色，为innodb表分配缓存。innodb缓冲池缓存表数据和索引数据，加速查询查找，并将查询结果保存在内存中以供重用。有关缓冲池大小配置的指导，请参阅8.12.4.1节“MySQL如何使用内存”。</p><p>
                    On a busy server, run benchmarks with the query cache turned off.
                    The <code class="literal">InnoDB</code> buffer pool provides similar
                    benefits, so the query cache might be tying up memory
                    unnecessarily. For information about the query cache, see
                    <a class="xref" href="optimization.html#query-cache" title="8.10.3&nbsp;The MySQL Query Cache">Section&nbsp;8.10.3, “The MySQL Query Cache”</a>.
                </p><p style="color:blue;">在繁忙的服务器上，在查询缓存关闭的情况下运行基准测试。innodb缓冲池提供了类似的好处，因此查询缓存可能会不必要地占用内存。有关查询缓存的信息，请参阅8.10.3节“mysql查询缓存”。</p>
                </div>
                <div class="simplesect">
                    <div class="titlepage">
                        <div>
                            <div class="simple">
                                <h5 class="title"><a name="innodb-convert-transactions"></a>Handling Too-Long Or Too-Short Transactions</h5>

                            </div>

                        </div>

                    </div>
                    <a class="indexterm" name="idm140286824013856"></a><p>
                    Because <code class="literal">MyISAM</code> tables do not support
                    <a class="link" href="glossary.html#glos_transaction" title="transaction">transactions</a>, you might
                    not have paid much attention to the
                    <a class="link" href="server-administration.html#sysvar_autocommit"><code class="literal">autocommit</code></a> configuration option
                    and the <a class="link" href="sql-syntax.html#commit" title="13.3.1&nbsp;START TRANSACTION, COMMIT, and ROLLBACK Syntax"><code class="literal">COMMIT</code></a> and
                    <a class="link" href="sql-syntax.html#commit" title="13.3.1&nbsp;START TRANSACTION, COMMIT, and ROLLBACK Syntax"><code class="literal">ROLLBACK</code></a>
                    statements. These keywords are important to allow multiple
                    sessions to read and write <code class="literal">InnoDB</code> tables
                    concurrently, providing substantial scalability benefits in
                    write-heavy workloads.
                </p><p style="color:blue;">因为myisam表不支持事务，所以您可能没有太多注意autocommit配置选项以及commit和rollback语句。这些关键字对于允许多个会话同时读写innodb表非常重要，在写繁重的工作负载中提供了巨大的可伸缩性优势。</p><p>
                    While a transaction is open, the system keeps a snapshot of the
                    data as seen at the beginning of the transaction, which can cause
                    substantial overhead if the system inserts, updates, and deletes
                    millions of rows while a stray transaction keeps running. Thus,
                    take care to avoid transactions that run for too long:
                </p><p style="color:blue;">当事务处于打开状态时，系统会保留在事务开始时看到的数据快照，如果系统在杂散事务继续运行时插入、更新和删除数百万行，则可能会导致大量开销。因此，请注意避免运行时间过长的事务：</p>
                    <div class="itemizedlist">
                        <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                            If you are using a <a class="link" href="programs.html#mysql" title="4.5.1&nbsp;mysql — The MySQL Command-Line Client"><span class="command"><strong>mysql</strong></span></a> session for
                            interactive experiments, always
                            <a class="link" href="sql-syntax.html#commit" title="13.3.1&nbsp;START TRANSACTION, COMMIT, and ROLLBACK Syntax"><code class="literal">COMMIT</code></a> (to finalize the
                            changes) or
                            <a class="link" href="sql-syntax.html#commit" title="13.3.1&nbsp;START TRANSACTION, COMMIT, and ROLLBACK Syntax"><code class="literal">ROLLBACK</code></a> (to
                            undo the changes) when finished. Close down interactive
                            sessions rather than leave them open for long periods, to
                            avoid keeping transactions open for long periods by accident.
                        </p><p style="color:blue;">如果使用mysql会话进行交互式实验，请在完成后始终提交（以完成更改）或回滚（以撤消更改）。关闭交互式会话而不是让它们长时间打开，以避免意外地使事务长时间打开。</p></li><li class="listitem"><p>
                            Make sure that any error handlers in your application also
                            <a class="link" href="sql-syntax.html#commit" title="13.3.1&nbsp;START TRANSACTION, COMMIT, and ROLLBACK Syntax"><code class="literal">ROLLBACK</code></a>
                            incomplete changes or <a class="link" href="sql-syntax.html#commit" title="13.3.1&nbsp;START TRANSACTION, COMMIT, and ROLLBACK Syntax"><code class="literal">COMMIT</code></a>
                            completed changes.
                        </p><p style="color:blue;">确保应用程序中的任何错误处理程序也回滚未完成的更改或提交已完成的更改。</p></li><li class="listitem"><p>
                            <a class="link" href="sql-syntax.html#commit" title="13.3.1&nbsp;START TRANSACTION, COMMIT, and ROLLBACK Syntax"><code class="literal">ROLLBACK</code></a> is
                            a relatively expensive operation, because
                            <a class="link" href="sql-syntax.html#insert" title="13.2.5&nbsp;INSERT Syntax"><code class="literal">INSERT</code></a>,
                            <a class="link" href="sql-syntax.html#update" title="13.2.11&nbsp;UPDATE Syntax"><code class="literal">UPDATE</code></a>, and
                            <a class="link" href="sql-syntax.html#delete" title="13.2.2&nbsp;DELETE Syntax"><code class="literal">DELETE</code></a> operations are written
                            to <code class="literal">InnoDB</code> tables prior to the
                            <a class="link" href="sql-syntax.html#commit" title="13.3.1&nbsp;START TRANSACTION, COMMIT, and ROLLBACK Syntax"><code class="literal">COMMIT</code></a>, with the expectation
                            that most changes are committed successfully and rollbacks are
                            rare. When experimenting with large volumes of data, avoid
                            making changes to large numbers of rows and then rolling back
                            those changes.
                        </p><p style="color:blue;">回滚是一个相对昂贵的操作，因为insert、update和delete操作是在提交之前写入到innodb表中的，期望大多数更改都能成功提交，回滚很少。在尝试使用大量数据时，请避免对大量行进行更改，然后回滚这些更改。</p></li><li class="listitem"><p>
                            When loading large volumes of data with a sequence of
                            <a class="link" href="sql-syntax.html#insert" title="13.2.5&nbsp;INSERT Syntax"><code class="literal">INSERT</code></a> statements, periodically
                            <a class="link" href="sql-syntax.html#commit" title="13.3.1&nbsp;START TRANSACTION, COMMIT, and ROLLBACK Syntax"><code class="literal">COMMIT</code></a> the results to avoid
                            having transactions that last for hours. In typical load
                            operations for data warehousing, if something goes wrong, you
                            truncate the table (using <a class="link" href="sql-syntax.html#truncate-table" title="13.1.34&nbsp;TRUNCATE TABLE Syntax"><code class="literal">TRUNCATE
                            TABLE</code></a>) and start over from the beginning rather than
                            doing a
                            <a class="link" href="sql-syntax.html#commit" title="13.3.1&nbsp;START TRANSACTION, COMMIT, and ROLLBACK Syntax"><code class="literal">ROLLBACK</code></a>.
                        </p><p style="color:blue;">当使用一系列insert语句加载大量数据时，请定期提交结果，以避免事务持续数小时。在数据仓库的典型加载操作中，如果发生错误，您将截断表（使用truncate table）并从头开始，而不是执行回滚。</p></li></ul>
                    </div>
                    <p>
                        The preceding tips save memory and disk space that can be wasted
                        during too-long transactions. When transactions are shorter than
                        they should be, the problem is excessive I/O. With each
                        <a class="link" href="sql-syntax.html#commit" title="13.3.1&nbsp;START TRANSACTION, COMMIT, and ROLLBACK Syntax"><code class="literal">COMMIT</code></a>, MySQL makes sure each
                        change is safely recorded to disk, which involves some I/O.
                    </p><p style="color:blue;">前面的提示节省了内存和磁盘空间，在太长的事务中可能会浪费这些空间。当事务比应该的时间短时，问题是I/O过多。每次提交时，MySQL都会确保每个更改都安全地记录到磁盘，这涉及到一些I/O。</p>
                    <div class="itemizedlist">
                        <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                            For most operations on <code class="literal">InnoDB</code> tables, you
                            should use the setting
                            <a class="link" href="server-administration.html#sysvar_autocommit"><code class="literal">autocommit=0</code></a>. From an
                            efficiency perspective, this avoids unnecessary I/O when you
                            issue large numbers of consecutive
                            <a class="link" href="sql-syntax.html#insert" title="13.2.5&nbsp;INSERT Syntax"><code class="literal">INSERT</code></a>,
                            <a class="link" href="sql-syntax.html#update" title="13.2.11&nbsp;UPDATE Syntax"><code class="literal">UPDATE</code></a>, or
                            <a class="link" href="sql-syntax.html#delete" title="13.2.2&nbsp;DELETE Syntax"><code class="literal">DELETE</code></a> statements. From a
                            safety perspective, this allows you to issue a
                            <a class="link" href="sql-syntax.html#commit" title="13.3.1&nbsp;START TRANSACTION, COMMIT, and ROLLBACK Syntax"><code class="literal">ROLLBACK</code></a>
                            statement to recover lost or garbled data if you make a
                            mistake on the <a class="link" href="programs.html#mysql" title="4.5.1&nbsp;mysql — The MySQL Command-Line Client"><span class="command"><strong>mysql</strong></span></a> command line, or in an
                            exception handler in your application.
                        </p><p style="color:blue;">对于innodb表上的大多数操作，应该使用设置autocommit=0。从效率的角度来看，这避免了在发出大量连续的insert、update或delete语句时不必要的i/o。从安全的角度来看，如果在mysql命令行或应用程序中的异常处理程序中出错，这允许您发出rollback语句来恢复丢失或混乱的数据。</p></li><li class="listitem"><p>
                            The time when <a class="link" href="server-administration.html#sysvar_autocommit"><code class="literal">autocommit=1</code></a> is
                            suitable for <code class="literal">InnoDB</code> tables is when running
                            a sequence of queries for generating reports or analyzing
                            statistics. In this situation, there is no I/O penalty related
                            to <a class="link" href="sql-syntax.html#commit" title="13.3.1&nbsp;START TRANSACTION, COMMIT, and ROLLBACK Syntax"><code class="literal">COMMIT</code></a> or
                            <a class="link" href="sql-syntax.html#commit" title="13.3.1&nbsp;START TRANSACTION, COMMIT, and ROLLBACK Syntax"><code class="literal">ROLLBACK</code></a>,
                            and <code class="literal">InnoDB</code> can
                            <a class="link" href="optimization.html#innodb-performance-ro-txn" title="8.5.3&nbsp;Optimizing InnoDB Read-Only Transactions">automatically
                                optimize the read-only workload</a>.
                        </p><p style="color:blue;">autocommit=1适用于innodb表的时间是运行一系列查询以生成报告或分析统计数据的时间。在这种情况下，没有与提交或回滚相关的I/O惩罚，InnoDB可以自动优化只读工作负载。</p></li><li class="listitem"><p>
                            If you make a series of related changes, finalize all the
                            changes at once with a single
                            <a class="link" href="sql-syntax.html#commit" title="13.3.1&nbsp;START TRANSACTION, COMMIT, and ROLLBACK Syntax"><code class="literal">COMMIT</code></a> at the end. For example,
                            if you insert related pieces of information into several
                            tables, do a single <a class="link" href="sql-syntax.html#commit" title="13.3.1&nbsp;START TRANSACTION, COMMIT, and ROLLBACK Syntax"><code class="literal">COMMIT</code></a>
                            after making all the changes. Or if you run many consecutive
                            <a class="link" href="sql-syntax.html#insert" title="13.2.5&nbsp;INSERT Syntax"><code class="literal">INSERT</code></a> statements, do a single
                            <a class="link" href="sql-syntax.html#commit" title="13.3.1&nbsp;START TRANSACTION, COMMIT, and ROLLBACK Syntax"><code class="literal">COMMIT</code></a> after all the data is
                            loaded; if you are doing millions of
                            <a class="link" href="sql-syntax.html#insert" title="13.2.5&nbsp;INSERT Syntax"><code class="literal">INSERT</code></a> statements, perhaps
                            split up the huge transaction by issuing a
                            <a class="link" href="sql-syntax.html#commit" title="13.3.1&nbsp;START TRANSACTION, COMMIT, and ROLLBACK Syntax"><code class="literal">COMMIT</code></a> every ten thousand or
                            hundred thousand records, so the transaction does not grow too
                            large.
                        </p><p style="color:blue;">如果您进行了一系列相关的更改，请在最后一次提交后立即完成所有更改。例如，如果将相关信息插入多个表中，则在进行所有更改后执行一次提交。或者，如果运行多个连续的insert语句，则在加载所有数据后执行一次commit；如果正在执行数百万条insert语句，则可能通过每隔一万或十万条记录发出commit来拆分庞大的事务，因此事务不会变得太大。</p></li><li class="listitem"><p>
                            Remember that even a <a class="link" href="sql-syntax.html#select" title="13.2.9&nbsp;SELECT Syntax"><code class="literal">SELECT</code></a>
                            statement opens a transaction, so after running some report or
                            debugging queries in an interactive <a class="link" href="programs.html#mysql" title="4.5.1&nbsp;mysql — The MySQL Command-Line Client"><span class="command"><strong>mysql</strong></span></a>
                            session, either issue a <a class="link" href="sql-syntax.html#commit" title="13.3.1&nbsp;START TRANSACTION, COMMIT, and ROLLBACK Syntax"><code class="literal">COMMIT</code></a>
                            or close the <a class="link" href="programs.html#mysql" title="4.5.1&nbsp;mysql — The MySQL Command-Line Client"><span class="command"><strong>mysql</strong></span></a> session.
                        </p><p style="color:blue;">请记住，即使select语句也会打开一个事务，因此在交互式mysql会话中运行一些报表或调试查询之后，要么发出commit，要么关闭mysql会话。</p></li></ul>
                    </div>

                </div>
                <div class="simplesect">
                    <div class="titlepage">
                        <div>
                            <div class="simple">
                                <h5 class="title"><a name="innodb-convert-deadlock"></a>Handling Deadlocks</h5>

                            </div>

                        </div>

                    </div>
                    <a class="indexterm" name="idm140286823947952"></a><p>
                    You might see warning messages referring to
                    <span class="quote">“<span class="quote">deadlocks</span>”</span> in the MySQL error log, or the output of
                    <a class="link" href="sql-syntax.html#show-engine" title="13.7.5.15&nbsp;SHOW ENGINE Syntax"><code class="literal">SHOW ENGINE INNODB
                        STATUS</code></a>. Despite the scary-sounding name, a
                    <a class="link" href="glossary.html#glos_deadlock" title="deadlock">deadlock</a> is not a serious
                    issue for <code class="literal">InnoDB</code> tables, and often does not
                    require any corrective action. When two transactions start
                    modifying multiple tables, accessing the tables in a different
                    order, they can reach a state where each transaction is waiting
                    for the other and neither can proceed. When
                    <a class="link" href="glossary.html#glos_deadlock_detection" title="deadlock detection">deadlock detection</a>
                    is enabled (the default), MySQL immediately detects this condition
                    and cancels (<a class="link" href="glossary.html#glos_rollback" title="rollback">rolls back</a>) the
                    <span class="quote">“<span class="quote">smaller</span>”</span> transaction, allowing the other to proceed.
                    If deadlock detection is disabled using the
                    <a class="link" href="innodb-storage-engine.html#sysvar_innodb_deadlock_detect"><code class="literal">innodb_deadlock_detect</code></a>
                    configuration option, <code class="literal">InnoDB</code> relies on the
                    <a class="link" href="innodb-storage-engine.html#sysvar_innodb_lock_wait_timeout"><code class="literal">innodb_lock_wait_timeout</code></a> setting
                    to roll back transactions in case of a deadlock.
                </p><p style="color:blue;">您可能会在mysql错误日志中看到有关“死锁”的警告消息，或者显示engine innodb status的输出。尽管名称听起来很吓人，但死锁对于innodb表来说并不是一个严重的问题，而且通常不需要任何纠正措施。当两个事务开始修改多个表，并以不同的顺序访问这些表时，它们可以达到每个事务都在等待另一个事务而两个事务都无法继续的状态。当启用死锁检测（默认设置）时，mysql会立即检测到这种情况，并取消（回滚）“较小”的事务，允许另一个事务继续进行。如果使用innodb_deadlock_detect配置选项禁用死锁检测，innodb将依赖innodb_lock_wait_timeout设置在死锁情况下回滚事务。</p><p>
                    Either way, your applications need error-handling logic to restart
                    a transaction that is forcibly cancelled due to a deadlock. When
                    you re-issue the same SQL statements as before, the original
                    timing issue no longer applies. Either the other transaction has
                    already finished and yours can proceed, or the other transaction
                    is still in progress and your transaction waits until it finishes.
                </p><p style="color:blue;">不管怎样，应用程序都需要错误处理逻辑来重新启动由于死锁而被强制取消的事务。当您重新发出与以前相同的sql语句时，原来的计时问题不再适用。另一个事务已经完成，您的事务可以继续，或者另一个事务仍在进行中，您的事务将一直等到它完成。</p><p>
                    If deadlock warnings occur constantly, you might review the
                    application code to reorder the SQL operations in a consistent
                    way, or to shorten the transactions. You can test with the
                    <a class="link" href="innodb-storage-engine.html#sysvar_innodb_print_all_deadlocks"><code class="literal">innodb_print_all_deadlocks</code></a> option
                    enabled to see all deadlock warnings in the MySQL error log,
                    rather than only the last warning in the
                    <a class="link" href="sql-syntax.html#show-engine" title="13.7.5.15&nbsp;SHOW ENGINE Syntax"><code class="literal">SHOW ENGINE INNODB
                        STATUS</code></a> output.
                </p><p style="color:blue;">如果死锁警告不断出现，您可以查看应用程序代码，以一致的方式重新排序SQL操作，或者缩短事务。您可以使用innodb_print_all_deadlocks选项进行测试，以查看mysql错误日志中的所有死锁警告，而不仅仅是显示引擎innodb status输出中的最后一个警告。</p><p>
                    For more information, see <a class="xref" href="innodb-storage-engine.html#innodb-deadlocks" title="14.7.5&nbsp;Deadlocks in InnoDB">Section&nbsp;14.7.5, “Deadlocks in InnoDB”</a>.
                </p><p style="color:blue;">有关更多信息，请参阅14.7.5节，“InnoDB中的死锁”。</p>
                </div>
                <div class="simplesect">
                    <div class="titlepage">
                        <div>
                            <div class="simple">
                                <h5 class="title"><a name="innodb-convert-plan-storage"></a>Planning the Storage Layout</h5>

                            </div>

                        </div>

                    </div>
                    <a class="indexterm" name="idm140286823930160"></a><p>
                    To get the best performance from <code class="literal">InnoDB</code> tables,
                    you can adjust a number of parameters related to storage layout.
                </p><p style="color:blue;">为了从innodb表中获得最佳性能，您可以调整与存储布局相关的一些参数。</p><p>
                    When you convert <code class="literal">MyISAM</code> tables that are large,
                    frequently accessed, and hold vital data, investigate and consider
                    the <a class="link" href="innodb-storage-engine.html#sysvar_innodb_file_per_table"><code class="literal">innodb_file_per_table</code></a>,
                    <a class="link" href="innodb-storage-engine.html#sysvar_innodb_file_format"><code class="literal">innodb_file_format</code></a>, and
                    <a class="link" href="innodb-storage-engine.html#sysvar_innodb_page_size"><code class="literal">innodb_page_size</code></a> configuration
                    options, and the
                    <a class="link" href="innodb-storage-engine.html#innodb-row-format" title="14.11&nbsp;InnoDB Row Formats"><code class="literal">ROW_FORMAT</code>
                        and <code class="literal">KEY_BLOCK_SIZE</code> clauses</a> of the
                    <a class="link" href="sql-syntax.html#create-table" title="13.1.18&nbsp;CREATE TABLE Syntax"><code class="literal">CREATE TABLE</code></a> statement.
                </p><p style="color:blue;">当您转换大型、频繁访问且保存重要数据的myisam表时，请研究并考虑innodb_file_per_表、innodb_file_格式和innodb_page_size配置选项，以及create table语句的row_format和key_block_size子句。</p><p>
                    During your initial experiments, the most important setting is
                    <a class="link" href="innodb-storage-engine.html#sysvar_innodb_file_per_table"><code class="literal">innodb_file_per_table</code></a>. When this
                    setting is enabled, which is the default as of MySQL 5.6.6, new
                    <code class="literal">InnoDB</code> tables are implicitly created in
                    <a class="link" href="glossary.html#glos_file_per_table" title="file-per-table">file-per-table</a>
                    tablespaces. In contrast with the <code class="literal">InnoDB</code> system
                    tablespace, file-per-table tablespaces allow disk space to be
                    reclaimed by the operating system when a table is truncated or
                    dropped. File-per-table tablespaces also support the
                    <a class="link" href="glossary.html#glos_barracuda" title="Barracuda">Barracuda</a> file format and
                    associated features such as table compression, efficient off-page
                    storage for long variable-length columns, and large index
                    prefixes. For more information, see
                    <a class="xref" href="innodb-storage-engine.html#innodb-multiple-tablespaces" title="14.6.3.2&nbsp;File-Per-Table Tablespaces">Section&nbsp;14.6.3.2, “File-Per-Table Tablespaces”</a>.
                </p><p style="color:blue;">在最初的实验中，最重要的设置是innodb_file_per_table。启用此设置（从mysql 5.6.6开始为默认设置）后，将在每个表空间的文件中隐式创建新的innodb表。与innodb系统表空间不同，当表被截断或删除时，每个表空间的文件允许操作系统回收磁盘空间。每表文件表空间还支持barracuda文件格式和相关功能，如表压缩、长可变长度列的高效页外存储和大索引前缀。有关更多信息，请参阅14.6.3.2节“每个表空间的文件”。</p><p>
                    You can also store <code class="literal">InnoDB</code> tables in a shared
                    general tablespace. General tablespaces support the Barracuda file
                    format and can contain multiple tables. For more information, see
                    <a class="xref" href="innodb-storage-engine.html#general-tablespaces" title="14.6.3.3&nbsp;General Tablespaces">Section&nbsp;14.6.3.3, “General Tablespaces”</a>.
                </p><p style="color:blue;">您还可以将innodb表存储在共享的通用表空间中。通用表空间支持Barracuda文件格式，可以包含多个表。有关更多信息，请参阅14.6.3.3节“常规表空间”。</p>
                </div>
                <div class="simplesect">
                    <div class="titlepage">
                        <div>
                            <div class="simple">
                                <h5 class="title"><a name="innodb-convert-convert"></a>Converting an Existing Table</h5>

                            </div>

                        </div>

                    </div>
                    <p>
                        To convert a non-<code class="literal">InnoDB</code> table to use
                        <code class="literal">InnoDB</code> use <a class="link" href="sql-syntax.html#alter-table" title="13.1.8&nbsp;ALTER TABLE Syntax"><code class="literal">ALTER
                        TABLE</code></a>:
                    </p><p style="color:blue;">要将非innodb表转换为使用innodb use alter table，请执行以下操作：</p><pre data-lang="sql" class="programlisting">ALTER TABLE <em class="replaceable"><code>table_name</code></em> ENGINE=InnoDB;
</pre>
                    <div class="important" style="margin-left: 0.5in; margin-right: 0.5in;">

                        <div class="admon-title">
                            Important
                        </div>
                        <p>
                            Do not convert MySQL system tables in the
                            <code class="literal">mysql</code> database from <code class="literal">MyISAM</code>
                            to the <code class="literal">InnoDB</code> type. This is an unsupported
                            operation. type.
                        </p><p style="color:blue;">不要将mysql数据库中的mysql系统表从myisam转换为innodb类型。这是不支持的操作。键入。</p>
                    </div>

                </div>
                <div class="simplesect">
                    <div class="titlepage">
                        <div>
                            <div class="simple">
                                <h5 class="title"><a name="innodb-convert-clone"></a>Cloning the Structure of a Table</h5>

                            </div>

                        </div>

                    </div>
                    <p>
                        You might make an <code class="literal">InnoDB</code> table that is a clone
                        of a MyISAM table, rather than using <a class="link" href="sql-syntax.html#alter-table" title="13.1.8&nbsp;ALTER TABLE Syntax"><code class="literal">ALTER
                        TABLE</code></a> to perform conversion, to test the old and new
                        table side-by-side before switching.
                    </p><p style="color:blue;">您可以创建一个innodb表，它是myisam表的克隆，而不是使用alter table来执行转换，在切换之前并排测试新旧表。</p><p>
                    Create an empty <code class="literal">InnoDB</code> table with identical
                    column and index definitions. Use <code class="literal">SHOW CREATE TABLE
                    <em class="replaceable"><code>table_name</code></em>\G</code> to see the full
                    <a class="link" href="sql-syntax.html#create-table" title="13.1.18&nbsp;CREATE TABLE Syntax"><code class="literal">CREATE TABLE</code></a> statement to use.
                    Change the <code class="literal">ENGINE</code> clause to
                    <code class="literal">ENGINE=INNODB</code>.
                </p><p style="color:blue;">创建一个具有相同列和索引定义的空innodb表。使用show create table table_name\g查看要使用的完整create table语句。将engine子句更改为engine=innodb。</p>
                </div>
                <div class="simplesect">
                    <div class="titlepage">
                        <div>
                            <div class="simple">
                                <h5 class="title"><a name="innodb-convert-transfer"></a>Transferring Existing Data</h5>

                            </div>

                        </div>

                    </div>
                    <a class="indexterm" name="idm140286823891968"></a><p>
                    To transfer a large volume of data into an empty
                    <code class="literal">InnoDB</code> table created as shown in the previous
                    section, insert the rows with <code class="literal">INSERT INTO
                    <em class="replaceable"><code>innodb_table</code></em> SELECT * FROM
                    <em class="replaceable"><code>myisam_table</code></em> ORDER BY
                    <em class="replaceable"><code>primary_key_columns</code></em></code>.
                </p><p style="color:blue;">要将大量数据传输到如前一节所示创建的空innodb表中，请使用insert in to innodb_table select*from myisam_table order by primary_key_columns插入行。</p><p>
                    You can also create the indexes for the <code class="literal">InnoDB</code>
                    table after inserting the data. Historically, creating new
                    secondary indexes was a slow operation for InnoDB, but now you can
                    create the indexes after the data is loaded with relatively little
                    overhead from the index creation step.
                </p><p style="color:blue;">也可以在插入数据之后为innodb表创建索引。历史上，对于innodb来说，创建新的二级索引是一个缓慢的操作，但是现在您可以在加载数据之后创建索引，而从索引创建步骤开始，开销相对较小。</p><p>
                    If you have <code class="literal">UNIQUE</code> constraints on secondary
                    keys, you can speed up a table import by turning off the
                    uniqueness checks temporarily during the import operation:
                </p><p style="color:blue;">如果对次关键字有唯一约束，则可以通过在导入操作期间暂时关闭唯一性检查来加快表导入：</p><pre data-lang="sql" class="programlisting">SET unique_checks=0;
<em class="replaceable"><code>... import operation ...</code></em>
SET unique_checks=1;
</pre><p>
                    For big tables, this saves disk I/O because
                    <code class="literal">InnoDB</code> can use its
                    <a class="link" href="glossary.html#glos_change_buffer" title="change buffer">change buffer</a> to write
                    secondary index records as a batch. Be certain that the data
                    contains no duplicate keys.
                    <a class="link" href="server-administration.html#sysvar_unique_checks"><code class="literal">unique_checks</code></a> permits but does
                    not require storage engines to ignore duplicate keys.
                </p><p style="color:blue;">对于大表，这可以节省磁盘I/O，因为InnoDB可以使用它的更改缓冲区将辅助索引记录作为批处理写入。确保数据不包含重复的键。unique_检查许可证，但不要求存储引擎忽略重复密钥。</p><p>
                    For better control over the insertion process, you can insert big
                    tables in pieces:
                </p><p style="color:blue;">为了更好地控制插入过程，可以将大表分片插入：</p><pre data-lang="sql" class="programlisting">INSERT INTO newtable SELECT * FROM oldtable
   WHERE yourkey &gt; <em class="replaceable"><code>something</code></em> AND yourkey &lt;= <em class="replaceable"><code>somethingelse</code></em>;
</pre><p>
                    After all records are inserted, you can rename the tables.
                </p><p style="color:blue;">插入所有记录后，可以重命名表。</p><p>
                    During the conversion of big tables, increase the size of the
                    <code class="literal">InnoDB</code> buffer pool to reduce disk I/O, to a
                    maximum of 80% of physical memory. You can also increase the size
                    of <code class="literal">InnoDB</code> log files.
                </p><p style="color:blue;">在大表的转换过程中，增加NIANDB缓冲池的大小，以减少磁盘I/O，最多达到物理内存的80%。您还可以增加innodb日志文件的大小。</p>
                </div>
                <div class="simplesect">
                    <div class="titlepage">
                        <div>
                            <div class="simple">
                                <h5 class="title"><a name="innodb-convert-storage-requirements"></a>Storage Requirements</h5>

                            </div>

                        </div>

                    </div>
                    <a class="indexterm" name="idm140286823873664"></a><p>
                    If you intend to make several temporary copies of your data in
                    <code class="literal">InnoDB</code> tables during the conversion process, it
                    is recommended that you create the tables in file-per-table
                    tablespaces so that you can reclaim the disk space when you drop
                    the tables. When the
                    <a class="link" href="innodb-storage-engine.html#sysvar_innodb_file_per_table"><code class="literal">innodb_file_per_table</code></a>
                    configuration option is enabled (the default), newly created
                    <code class="literal">InnoDB</code> tables are implicitly created in
                    file-per-table tablespaces.
                </p><p style="color:blue;">如果您打算在转换过程中对innodb表中的数据进行几个临时拷贝，建议您在file per table spaces中创建表，以便在删除表时回收磁盘空间。当innodb_file_per_table configuration选项被启用（默认设置）时，新创建的innodb tables将隐式地在file per table tables spaces中创建。</p><p>
                    Whether you convert the <code class="literal">MyISAM</code> table directly
                    or create a cloned <code class="literal">InnoDB</code> table, make sure that
                    you have sufficient disk space to hold both the old and new tables
                    during the process.
                    <span class="bold"><strong><code class="literal">InnoDB</code> tables require
      more disk space than <code class="literal">MyISAM</code> tables.</strong></span>
                    If an <a class="link" href="sql-syntax.html#alter-table" title="13.1.8&nbsp;ALTER TABLE Syntax"><code class="literal">ALTER TABLE</code></a> operation runs
                    out of space, it starts a rollback, and that can take hours if it
                    is disk-bound. For inserts, <code class="literal">InnoDB</code> uses the
                    insert buffer to merge secondary index records to indexes in
                    batches. That saves a lot of disk I/O. For rollback, no such
                    mechanism is used, and the rollback can take 30 times longer than
                    the insertion.
                </p><p style="color:blue;">无论是直接转换myisam表还是创建一个克隆的innodb表，都要确保有足够的磁盘空间来保存这个过程中的旧表和新表。innodb表需要比myisam表更多的磁盘空间。如果alter table操作空间不足，它将启动回滚，如果它是磁盘绑定的，则可能需要几个小时。对于插入，innodb使用插入缓冲区将二级索引记录批量合并到索引中。这样可以节省大量的磁盘I/O。对于回滚，不使用这种机制，并且回滚的时间可能比插入的时间长30倍。</p><p>
                    In the case of a runaway rollback, if you do not have valuable
                    data in your database, it may be advisable to kill the database
                    process rather than wait for millions of disk I/O operations to
                    complete. For the complete procedure, see
                    <a class="xref" href="innodb-storage-engine.html#forcing-innodb-recovery" title="14.21.2&nbsp;Forcing InnoDB Recovery">Section&nbsp;14.21.2, “Forcing InnoDB Recovery”</a>.
                </p><p style="color:blue;">在失控回滚的情况下，如果数据库中没有有价值的数据，建议终止数据库进程，而不是等待数百万个磁盘I/O操作完成。有关完整过程，请参阅第14.21.2节“强制InnoDB恢复”。</p>
                </div>
                <div class="simplesect">
                    <div class="titlepage">
                        <div>
                            <div class="simple">
                                <h5 class="title"><a name="innodb-convert-primary-key"></a>Defining a PRIMARY KEY for Each Table</h5>

                            </div>

                        </div>

                    </div>
                    <a class="indexterm" name="idm140286823859760"></a><p>
                    The <code class="literal">PRIMARY KEY</code> clause is a critical factor
                    affecting the performance of MySQL queries and the space usage for
                    tables and indexes. The primary key uniquely identifies a row in a
                    table. Every row in the table must have a primary key value, and
                    no two rows can have the same primary key value.
                </p><p style="color:blue;">主键子句是影响mysql查询性能和表和索引空间使用的关键因素。主键唯一标识表中的行。表中的每一行都必须有主键值，并且任何两行都不能有相同的主键值。</p><p>
                    These are guidelines for the primary key, followed by more
                    detailed explanations.
                </p><p style="color:blue;">以下是主键的指导原则，随后是更详细的解释。</p>
                    <div class="itemizedlist">
                        <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                            Declare a <code class="literal">PRIMARY KEY</code> for each table.
                            Typically, it is the most important column that you refer to
                            in <code class="literal">WHERE</code> clauses when looking up a single
                            row.
                        </p><p style="color:blue;">为每个表声明主键。通常，在查找单行时，它是where子句中引用的最重要的列。</p></li><li class="listitem"><p>
                            Declare the <code class="literal">PRIMARY KEY</code> clause in the
                            original <a class="link" href="sql-syntax.html#create-table" title="13.1.18&nbsp;CREATE TABLE Syntax"><code class="literal">CREATE TABLE</code></a>
                            statement, rather than adding it later through an
                            <a class="link" href="sql-syntax.html#alter-table" title="13.1.8&nbsp;ALTER TABLE Syntax"><code class="literal">ALTER TABLE</code></a> statement.
                        </p><p style="color:blue;">在原始CREATETABLE语句中声明PRIMARYKEY子句，而不是稍后通过ALTERTABLE语句添加它。</p></li><li class="listitem"><p>
                            Choose the column and its data type carefully. Prefer numeric
                            columns over character or string ones.
                        </p><p style="color:blue;">请仔细选择列及其数据类型。与字符或字符串列相比，更喜欢数字列。</p></li><li class="listitem"><p>
                            Consider using an auto-increment column if there is not
                            another stable, unique, non-null, numeric column to use.
                        </p><p style="color:blue;">如果没有其他要使用的稳定、唯一、非空的数值列，请考虑使用自动递增列。</p></li><li class="listitem"><p>
                            An auto-increment column is also a good choice if there is any
                            doubt whether the value of the primary key column could ever
                            change. Changing the value of a primary key column is an
                            expensive operation, possibly involving rearranging data
                            within the table and within each secondary index.
                        </p><p style="color:blue;">如果对主键列的值是否可以更改有任何疑问，那么自动递增列也是一个不错的选择。更改主键列的值是一项代价高昂的操作，可能涉及在表内和每个辅助索引内重新排列数据。</p></li></ul>
                    </div>
                    <p>
                        Consider adding a <a class="link" href="glossary.html#glos_primary_key" title="primary key">primary
                        key</a> to any table that does not already have one. Use the
                        smallest practical numeric type based on the maximum projected
                        size of the table. This can make each row slightly more compact,
                        which can yield substantial space savings for large tables. The
                        space savings are multiplied if the table has any
                        <a class="link" href="glossary.html#glos_secondary_index" title="secondary index">secondary indexes</a>,
                        because the primary key value is repeated in each secondary index
                        entry. In addition to reducing data size on disk, a small primary
                        key also lets more data fit into the
                        <a class="link" href="glossary.html#glos_buffer_pool" title="buffer pool">buffer pool</a>, speeding up
                        all kinds of operations and improving concurrency.
                    </p><p style="color:blue;">考虑将主键添加到任何还没有主键的表中。根据表的最大投影大小使用最小的实际数值类型。这可以使每一行稍微紧凑一点，从而为大型表节省大量空间。如果表有任何辅助索引，则节省的空间将成倍增加，因为主键值在每个辅助索引项中重复。除了减少磁盘上的数据大小之外，一个小主键还可以让更多的数据放入缓冲池，从而加快各种操作并提高并发性。</p><p>
                    If the table already has a primary key on some longer column, such
                    as a <code class="literal">VARCHAR</code>, consider adding a new unsigned
                    <code class="literal">AUTO_INCREMENT</code> column and switching the primary
                    key to that, even if that column is not referenced in queries.
                    This design change can produce substantial space savings in the
                    secondary indexes. You can designate the former primary key
                    columns as <code class="literal">UNIQUE NOT NULL</code> to enforce the same
                    constraints as the <code class="literal">PRIMARY KEY</code> clause, that is,
                    to prevent duplicate or null values across all those columns.
                </p><p style="color:blue;">如果表在某个较长的列（如varchar）上已经有主键，请考虑添加一个新的无符号自动递增列并将主键切换到该列，即使查询中未引用该列。这种设计更改可以在二级索引中节省大量空间。您可以将以前的主键列指定为unique not null，以强制执行与主键子句相同的约束，即防止所有这些列中出现重复或空值。</p><p>
                    If you spread related information across multiple tables,
                    typically each table uses the same column for its primary key. For
                    example, a personnel database might have several tables, each with
                    a primary key of employee number. A sales database might have some
                    tables with a primary key of customer number, and other tables
                    with a primary key of order number. Because lookups using the
                    primary key are very fast, you can construct efficient join
                    queries for such tables.
                </p><p style="color:blue;">如果将相关信息分散到多个表中，通常每个表的主键都使用同一列。例如，人员数据库可能有几个表，每个表的主键都是employee number。销售数据库可能包含一些主键为customer number的表，以及其他主键为order number的表。因为使用主键的查找非常快，所以可以为此类表构造有效的连接查询。</p><p>
                    If you leave the <code class="literal">PRIMARY KEY</code> clause out
                    entirely, MySQL creates an invisible one for you. It is a 6-byte
                    value that might be longer than you need, thus wasting space.
                    Because it is hidden, you cannot refer to it in queries.
                </p><p style="color:blue;">如果完全不使用主键子句，mysql会为您创建一个不可见的子句。它是一个6字节的值，可能比您需要的长，从而浪费空间。因为它是隐藏的，所以不能在查询中引用它。</p>
                </div>
                <div class="simplesect">
                    <div class="titlepage">
                        <div>
                            <div class="simple">
                                <h5 class="title"><a name="innodb-convert-application-performance"></a>Application Performance Considerations</h5>

                            </div>

                        </div>

                    </div>
                    <a class="indexterm" name="idm140286823835808"></a><p>
                    The reliability and scalability features of
                    <code class="literal">InnoDB</code> require more disk storage than
                    equivalent <code class="literal">MyISAM</code> tables. You might change the
                    column and index definitions slightly, for better space
                    utilization, reduced I/O and memory consumption when processing
                    result sets, and better query optimization plans making efficient
                    use of index lookups.
                </p><p style="color:blue;">innodb的可靠性和可伸缩性特性需要比等效myisam表更多的磁盘存储空间。您可以稍微更改列和索引定义，以获得更好的空间利用率，减少处理结果集时的I/O和内存消耗，以及更好的查询优化计划，从而有效地使用索引查找。</p><p>
                    If you do set up a numeric ID column for the primary key, use that
                    value to cross-reference with related values in any other tables,
                    particularly for <a class="link" href="glossary.html#glos_join" title="join">join</a> queries.
                    For example, rather than accepting a country name as input and
                    doing queries searching for the same name, do one lookup to
                    determine the country ID, then do other queries (or a single join
                    query) to look up relevant information across several tables.
                    Rather than storing a customer or catalog item number as a string
                    of digits, potentially using up several bytes, convert it to a
                    numeric ID for storing and querying. A 4-byte unsigned
                    <a class="link" href="data-types.html#integer-types" title="11.2.1&nbsp;Integer Types (Exact Value) - INTEGER, INT, SMALLINT, TINYINT, MEDIUMINT, BIGINT"><code class="literal">INT</code></a> column can index over 4 billion
                    items (with the US meaning of billion: 1000 million). For the
                    ranges of the different integer types, see
                    <a class="xref" href="data-types.html#integer-types" title="11.2.1&nbsp;Integer Types (Exact Value) - INTEGER, INT, SMALLINT, TINYINT, MEDIUMINT, BIGINT">Section&nbsp;11.2.1, “Integer Types (Exact Value) - INTEGER, INT, SMALLINT, TINYINT,
                        MEDIUMINT, BIGINT”</a>.
                </p><p style="color:blue;">如果确实为主键设置了数字id列，请使用该值与任何其他表中的相关值交叉引用，特别是对于联接查询。例如，与其接受一个国家名称作为输入并执行查询以搜索相同的名称，不如执行一次查找以确定国家ID，然后执行其他查询（或单个联接查询）以跨多个表查找相关信息。与其将客户号或目录项号存储为一串数字（可能会占用几个字节），不如将其转换为数字标识以进行存储和查询。一个4字节的无符号int列可以索引超过40亿个项（美国的意思是十亿：10亿）。有关不同整数类型的范围，请参见第11.2.1节“整数类型（精确值）-整数、整数、smallint、tinyint、mediumint、bigint”。</p>
                </div>
                <div class="simplesect">
                    <div class="titlepage">
                        <div>
                            <div class="simple">
                                <h5 class="title"><a name="innodb-convert-understand-files"></a>Understanding Files Associated with InnoDB Tables</h5>

                            </div>

                        </div>

                    </div>
                    <a class="indexterm" name="idm140286823826880"></a><p>
                    <code class="literal">InnoDB</code> files require more care and planning
                    than <code class="literal">MyISAM</code> files do.
                </p><p style="color:blue;">innodb文件比myisam文件需要更多的关注和计划。</p>
                    <div class="itemizedlist">
                        <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                            You must not delete the
                            <a class="link" href="glossary.html#glos_ibdata_file" title="ibdata file">ibdata files</a> that
                            represent the <code class="literal">InnoDB</code>
                            <a class="link" href="glossary.html#glos_system_tablespace" title="system tablespace">system
                                tablespace</a>.
                        </p><p style="color:blue;">不能删除表示innodb系统表空间的ibdata文件。</p></li><li class="listitem"><p>
                            Methods of moving or copying <code class="literal">InnoDB</code> tables
                            to a different server are described in
                            <a class="xref" href="innodb-storage-engine.html#innodb-migration" title="14.6.1.2&nbsp;Moving or Copying InnoDB Tables">Section&nbsp;14.6.1.2, “Moving or Copying InnoDB Tables”</a>.
                        </p><p style="color:blue;">第14.6.1.2节“移动或复制InnoDB表”描述了将InnoDB表移动或复制到不同服务器的方法。</p></li></ul>
                    </div>

                </div>

            </div>
            <div class="section">
                <div class="titlepage">
                    <div>
                        <div>
                            <h4 class="title"><a name="innodb-auto-increment-handling"></a>14.6.1.4&nbsp;AUTO_INCREMENT Handling in InnoDB</h4>

                        </div>

                    </div>

                </div>
                <a class="indexterm" name="idm140286823816304"></a><a class="indexterm" name="idm140286823815232"></a><p>
                <code class="literal">InnoDB</code> provides a configurable locking
                mechanism that can significantly improve scalability and
                performance of SQL statements that add rows to tables with
                <code class="literal">AUTO_INCREMENT</code> columns. To use the
                <code class="literal">AUTO_INCREMENT</code> mechanism with an
                <code class="literal">InnoDB</code> table, an
                <code class="literal">AUTO_INCREMENT</code> column must be defined as part
                of an index such that it is possible to perform the equivalent of
                an indexed <code class="literal">SELECT
                MAX(<em class="replaceable"><code>ai_col</code></em>)</code> lookup on the
                table to obtain the maximum column value. Typically, this is
                achieved by making the column the first column of some table
                index.
            </p><p style="color:blue;">innodb提供了一种可配置的锁定机制，可以显著提高sql语句的可伸缩性和性能，这些sql语句向具有自动递增列的表中添加行。若要使用UnIDB表的AutoYLoad增量机制，AutoYLoad列必须定义为索引的一部分，以便在表上执行索引选择MAX（AIAO-COL）查找的等价物，以获得最大列值。通常，这是通过使列成为某个表索引的第一列来实现的。</p><p>
                This section describes the behavior of
                <code class="literal">AUTO_INCREMENT</code> lock modes, usage implications
                for different <code class="literal">AUTO_INCREMENT</code> lock mode
                settings, and how <code class="literal">InnoDB</code> initializes the
                <code class="literal">AUTO_INCREMENT</code> counter.
            </p><p style="color:blue;">本节描述自动递增锁定模式的行为，不同自动递增锁定模式设置的使用含义，以及InnoDB如何初始化自动递增计数器。</p>
                <div class="itemizedlist">
                    <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                        <a class="link" href="innodb-storage-engine.html#innodb-auto-increment-lock-modes" title="InnoDB AUTO_INCREMENT Lock Modes">InnoDB
                            AUTO_INCREMENT Lock Modes</a>
                    </p><p style="color:blue;">InnoDB自动递增锁定模式</p></li><li class="listitem"><p>
                        <a class="link" href="innodb-storage-engine.html#innodb-auto-increment-lock-mode-usage-implications" title="InnoDB AUTO_INCREMENT Lock Mode Usage Implications">InnoDB
                            AUTO_INCREMENT Lock Mode Usage Implications</a>
                    </p><p style="color:blue;">innodb auto_increment lock mode用法含义</p></li><li class="listitem"><p>
                        <a class="link" href="innodb-storage-engine.html#innodb-auto-increment-initialization" title="InnoDB AUTO_INCREMENT Counter Initialization">InnoDB
                            AUTO_INCREMENT Counter Initialization</a>
                    </p><p style="color:blue;">InnoDB自动递增计数器初始化</p></li></ul>
                </div>
                <div class="simplesect">
                    <div class="titlepage">
                        <div>
                            <div class="simple">
                                <h5 class="title"><a name="innodb-auto-increment-lock-modes"></a>InnoDB AUTO_INCREMENT Lock Modes</h5>

                            </div>

                        </div>

                    </div>
                    <a class="indexterm" name="idm140286823797872"></a><p>
                    This section describes the behavior of
                    <code class="literal">AUTO_INCREMENT</code> lock modes used to generate
                    auto-increment values, and how each lock mode affects
                    replication. Auto-increment lock modes are configured at startup
                    using the
                    <a class="link" href="innodb-storage-engine.html#sysvar_innodb_autoinc_lock_mode"><code class="literal">innodb_autoinc_lock_mode</code></a>
                    configuration parameter.
                </p><p style="color:blue;">本节介绍用于生成自动增量值的自动增量锁定模式的行为，以及每个锁定模式如何影响复制。自动增量锁定模式在启动时使用innodb_autoinc_lock_mode配置参数进行配置。</p><p>
                    The following terms are used in describing
                    <a class="link" href="innodb-storage-engine.html#sysvar_innodb_autoinc_lock_mode"><code class="literal">innodb_autoinc_lock_mode</code></a>
                    settings:
                </p><p style="color:blue;">以下术语用于描述InnoDB_Autoinc_Lock_模式设置：</p>
                    <div class="itemizedlist">
                        <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                            <span class="quote">“<span class="quote"><a class="link" href="sql-syntax.html#insert" title="13.2.5&nbsp;INSERT Syntax"><code class="literal">INSERT</code></a>-like</span>”</span>
                            statements
                        </p><p style="color:blue;">“插入式”语句</p><p>
                            All statements that generate new rows in a table, including
                            <a class="link" href="sql-syntax.html#insert" title="13.2.5&nbsp;INSERT Syntax"><code class="literal">INSERT</code></a>,
                            <a class="link" href="sql-syntax.html#insert-select" title="13.2.5.1&nbsp;INSERT ... SELECT Syntax"><code class="literal">INSERT ...
                                SELECT</code></a>, <a class="link" href="sql-syntax.html#replace" title="13.2.8&nbsp;REPLACE Syntax"><code class="literal">REPLACE</code></a>,
                            <a class="link" href="sql-syntax.html#replace" title="13.2.8&nbsp;REPLACE Syntax"><code class="literal">REPLACE ...
                                SELECT</code></a>, and <a class="link" href="sql-syntax.html#load-data" title="13.2.6&nbsp;LOAD DATA Syntax"><code class="literal">LOAD
                            DATA</code></a>. Includes <span class="quote">“<span class="quote">simple-inserts</span>”</span>,
                            <span class="quote">“<span class="quote">bulk-inserts</span>”</span>, and <span class="quote">“<span class="quote">mixed-mode</span>”</span>
                            inserts.
                        </p><p style="color:blue;">在表中生成新行的所有语句，包括INSERT、INSERT…选择，替换，替换…选择并加载数据。包括“简单插入”、“大容量插入”和“混合模式”插入。</p></li><li class="listitem"><p>
                            <span class="quote">“<span class="quote">Simple inserts</span>”</span>
                        </p><p style="color:blue;">“简单插入”</p><p>
                            Statements for which the number of rows to be inserted can
                            be determined in advance (when the statement is initially
                            processed). This includes single-row and multiple-row
                            <a class="link" href="sql-syntax.html#insert" title="13.2.5&nbsp;INSERT Syntax"><code class="literal">INSERT</code></a> and
                            <a class="link" href="sql-syntax.html#replace" title="13.2.8&nbsp;REPLACE Syntax"><code class="literal">REPLACE</code></a> statements that do
                            not have a nested subquery, but not
                            <a class="link" href="sql-syntax.html#insert-on-duplicate" title="13.2.5.2&nbsp;INSERT ... ON DUPLICATE KEY UPDATE Syntax"><code class="literal">INSERT
                                ... ON DUPLICATE KEY UPDATE</code></a>.
                        </p><p style="color:blue;">可以预先确定要插入行数的语句（在最初处理该语句时）。这包括没有嵌套子查询但没有INSERT的单行和多行INSERT和REPLACE语句…在重复密钥更新时。</p></li><li class="listitem"><p>
                            <span class="quote">“<span class="quote">Bulk inserts</span>”</span>
                        </p><p style="color:blue;">“批量插入”</p><p>
                            Statements for which the number of rows to be inserted (and
                            the number of required auto-increment values) is not known
                            in advance. This includes
                            <a class="link" href="sql-syntax.html#insert-select" title="13.2.5.1&nbsp;INSERT ... SELECT Syntax"><code class="literal">INSERT ...
                                SELECT</code></a>,
                            <a class="link" href="sql-syntax.html#replace" title="13.2.8&nbsp;REPLACE Syntax"><code class="literal">REPLACE ...
                                SELECT</code></a>, and <a class="link" href="sql-syntax.html#load-data" title="13.2.6&nbsp;LOAD DATA Syntax"><code class="literal">LOAD
                            DATA</code></a> statements, but not plain
                            <code class="literal">INSERT</code>. <code class="literal">InnoDB</code> assigns
                            new values for the <code class="literal">AUTO_INCREMENT</code> column
                            one at a time as each row is processed.
                        </p><p style="color:blue;">要插入的行数（以及所需的自动增量值）事先未知的语句。这包括插入…选择，替换…选择并加载数据语句，但不是简单插入。innodb在处理每一行时，一次为auto_increment列分配一个新值。</p></li><li class="listitem"><p>
                            <span class="quote">“<span class="quote">Mixed-mode inserts</span>”</span>
                        </p><p style="color:blue;">“混合模式插入”</p><p>
                            These are <span class="quote">“<span class="quote">simple insert</span>”</span> statements that
                            specify the auto-increment value for some (but not all) of
                            the new rows. An example follows, where
                            <code class="literal">c1</code> is an
                            <code class="literal">AUTO_INCREMENT</code> column of table
                            <code class="literal">t1</code>:
                        </p><p style="color:blue;">这些是“简单插入”语句，为某些（但不是全部）新行指定自动增量值。下面是一个示例，其中c1是表t1的自动递增列：</p><pre data-lang="sql" class="programlisting">INSERT INTO t1 (c1,c2) VALUES (1,'a'), (NULL,'b'), (5,'c'), (NULL,'d');
</pre><p>
                            Another type of <span class="quote">“<span class="quote">mixed-mode insert</span>”</span> is
                            <a class="link" href="sql-syntax.html#insert-on-duplicate" title="13.2.5.2&nbsp;INSERT ... ON DUPLICATE KEY UPDATE Syntax"><code class="literal">INSERT
                                ... ON DUPLICATE KEY UPDATE</code></a>, which in the worst
                            case is in effect an <a class="link" href="sql-syntax.html#insert" title="13.2.5&nbsp;INSERT Syntax"><code class="literal">INSERT</code></a>
                            followed by a <a class="link" href="sql-syntax.html#update" title="13.2.11&nbsp;UPDATE Syntax"><code class="literal">UPDATE</code></a>, where
                            the allocated value for the
                            <code class="literal">AUTO_INCREMENT</code> column may or may not be
                            used during the update phase.
                        </p><p style="color:blue;">另一种“混合模式插入”是插入…在重复密钥更新时，在最坏的情况下是插入后更新，其中自动递增列的分配值可以在更新阶段使用，也可以不使用。</p></li></ul>
                    </div>
                    <p>
                        There are three possible settings for the
                        <a class="link" href="innodb-storage-engine.html#sysvar_innodb_autoinc_lock_mode"><code class="literal">innodb_autoinc_lock_mode</code></a>
                        configuration parameter. The settings are 0, 1, or 2, for
                        <span class="quote">“<span class="quote">traditional</span>”</span>, <span class="quote">“<span class="quote">consecutive</span>”</span>, or
                        <span class="quote">“<span class="quote">interleaved</span>”</span> lock mode, respectively.
                    </p><p style="color:blue;">innodb_autoinc_lock_mode配置参数有三种可能的设置。“传统”、“连续”或“交错”锁定模式的设置分别为0、1或2。</p>
                    <div class="itemizedlist">
                        <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><a name="innodb-auto-increment-lock-mode-traditional"></a>
                            <code class="literal">innodb_autoinc_lock_mode = 0</code>
                            (<span class="quote">“<span class="quote">traditional</span>”</span> lock mode)
                        </p><p style="color:blue;">innodb_autoinc_lock_mode=0（“传统”锁定模式）</p><p>
                            The traditional lock mode provides the same behavior that
                            existed before the
                            <a class="link" href="innodb-storage-engine.html#sysvar_innodb_autoinc_lock_mode"><code class="literal">innodb_autoinc_lock_mode</code></a>
                            configuration parameter was introduced in MySQL 5.1. The
                            traditional lock mode option is provided for backward
                            compatibility, performance testing, and working around
                            issues with “mixed-mode inserts”, due to possible
                            differences in semantics.
                        </p><p style="color:blue;">传统的锁模式提供了在MySQL 5.1中引入了NoNbjAutoClinux锁配置参数之前的相同行为。传统的锁模式选项是为了向后兼容、性能测试和解决“混合模式插入”问题而提供的，这是由于语义上可能存在的差异。</p><p>
                            In this lock mode, all <span class="quote">“<span class="quote">INSERT-like</span>”</span> statements
                            obtain a special table-level <code class="literal">AUTO-INC</code>
                            lock for inserts into tables with
                            <code class="literal">AUTO_INCREMENT</code> columns. This lock is
                            normally held to the end of the statement (not to the end of
                            the transaction) to ensure that auto-increment values are
                            assigned in a predictable and repeatable order for a given
                            sequence of <a class="link" href="sql-syntax.html#insert" title="13.2.5&nbsp;INSERT Syntax"><code class="literal">INSERT</code></a>
                            statements, and to ensure that auto-increment values
                            assigned by any given statement are consecutive.
                        </p><p style="color:blue;">在这种锁定模式下，所有“insert like”语句都获得一个特殊的表级auto-inc锁，用于插入具有自动递增列的表。此锁通常保持在语句的末尾（而不是事务的末尾），以确保按可预测和可重复的顺序为给定的insert语句序列分配自动增量值，并确保由任何给定语句分配的自动增量值是连续的。</p><p>
                            In the case of statement-based replication, this means that
                            when an SQL statement is replicated on a slave server, the
                            same values are used for the auto-increment column as on the
                            master server. The result of execution of multiple
                            <a class="link" href="sql-syntax.html#insert" title="13.2.5&nbsp;INSERT Syntax"><code class="literal">INSERT</code></a> statements is
                            deterministic, and the slave reproduces the same data as on
                            the master. If auto-increment values generated by multiple
                            <a class="link" href="sql-syntax.html#insert" title="13.2.5&nbsp;INSERT Syntax"><code class="literal">INSERT</code></a> statements were
                            interleaved, the result of two concurrent
                            <a class="link" href="sql-syntax.html#insert" title="13.2.5&nbsp;INSERT Syntax"><code class="literal">INSERT</code></a> statements would be
                            nondeterministic, and could not reliably be propagated to a
                            slave server using statement-based replication.
                        </p><p style="color:blue;">在基于语句的复制中，这意味着在从属服务器上复制SQL语句时，自动增量列的值与主服务器上的值相同。执行多个insert语句的结果是确定的，从机复制的数据与主机上的相同。如果对多个insert语句生成的自动增量值进行交织，则两个并发insert语句的结果将是不确定的，并且无法使用基于语句的复制可靠地传播到从属服务器。</p><p>
                            To make this clear, consider an example that uses this
                            table:
                        </p><p style="color:blue;">为了说明这一点，请考虑一个使用此表的示例：</p><pre data-lang="sql" class="programlisting">CREATE TABLE t1 (
  c1 INT(11) NOT NULL AUTO_INCREMENT,
  c2 VARCHAR(10) DEFAULT NULL,
  PRIMARY KEY (c1)
) ENGINE=InnoDB;
</pre><p>
                            Suppose that there are two transactions running, each
                            inserting rows into a table with an
                            <code class="literal">AUTO_INCREMENT</code> column. One transaction is
                            using an
                            <a class="link" href="sql-syntax.html#insert-select" title="13.2.5.1&nbsp;INSERT ... SELECT Syntax"><code class="literal">INSERT ...
                                SELECT</code></a> statement that inserts 1000 rows, and
                            another is using a simple
                            <a class="link" href="sql-syntax.html#insert" title="13.2.5&nbsp;INSERT Syntax"><code class="literal">INSERT</code></a> statement that inserts
                            one row:
                        </p><p style="color:blue;">假设有两个事务正在运行，每个事务将行插入到一个具有自动递增列的表中。一个事务正在使用插入…select语句插入1000行，另一个语句使用插入一行的简单insert语句：</p><pre data-lang="sql" class="programlisting">Tx1: INSERT INTO t1 (c2) SELECT 1000 rows from another table ...
Tx2: INSERT INTO t1 (c2) VALUES ('xxx');
</pre><p>
                            <code class="literal">InnoDB</code> cannot tell in advance how many
                            rows are retrieved from the
                            <a class="link" href="sql-syntax.html#select" title="13.2.9&nbsp;SELECT Syntax"><code class="literal">SELECT</code></a> in the
                            <a class="link" href="sql-syntax.html#insert" title="13.2.5&nbsp;INSERT Syntax"><code class="literal">INSERT</code></a> statement in Tx1, and
                            it assigns the auto-increment values one at a time as the
                            statement proceeds. With a table-level lock, held to the end
                            of the statement, only one
                            <a class="link" href="sql-syntax.html#insert" title="13.2.5&nbsp;INSERT Syntax"><code class="literal">INSERT</code></a> statement referring to
                            table <code class="literal">t1</code> can execute at a time, and the
                            generation of auto-increment numbers by different statements
                            is not interleaved. The auto-increment value generated by
                            the Tx1
                            <a class="link" href="sql-syntax.html#insert-select" title="13.2.5.1&nbsp;INSERT ... SELECT Syntax"><code class="literal">INSERT ...
                                SELECT</code></a> statement is consecutive, and the (single)
                            auto-increment value used by the
                            <a class="link" href="sql-syntax.html#insert" title="13.2.5&nbsp;INSERT Syntax"><code class="literal">INSERT</code></a> statement in Tx2 is
                            either be smaller or larger than all those used for Tx1,
                            depending on which statement executes first.
                        </p><p style="color:blue;">innodb无法预先判断在tx1的insert语句中从select中检索了多少行，并且它在语句进行时一次分配一个自动增量值。如果表级锁一直保持在语句的末尾，那么一次只能执行一个引用表T1的INSERT语句，并且不同语句生成的自动递增数不会交错。TX1插入生成的自动增量值…select语句是连续的，tx2中insert语句使用的（单个）自动增量值要么小于要么大于tx1中使用的所有值，这取决于哪个语句首先执行。</p><p>
                            As long as the SQL statements execute in the same order when
                            replayed from the binary log (when using statement-based
                            replication, or in recovery scenarios), the results are the
                            same as they were when Tx1 and Tx2 first ran. Thus,
                            table-level locks held until the end of a statement make
                            <a class="link" href="sql-syntax.html#insert" title="13.2.5&nbsp;INSERT Syntax"><code class="literal">INSERT</code></a> statements using
                            auto-increment safe for use with statement-based
                            replication. However, those table-level locks limit
                            concurrency and scalability when multiple transactions are
                            executing insert statements at the same time.
                        </p><p style="color:blue;">只要SQL语句在从二进制日志重放时以相同的顺序执行（当使用基于语句的复制时，或在恢复方案中），结果与首次运行TX1和TX2时相同。因此，在语句结束之前保持的表级锁使得使用自动增量的insert语句对于基于语句的复制是安全的。但是，当多个事务同时执行insert语句时，这些表级锁限制了并发性和可伸缩性。</p><p>
                            In the preceding example, if there were no table-level lock,
                            the value of the auto-increment column used for the
                            <a class="link" href="sql-syntax.html#insert" title="13.2.5&nbsp;INSERT Syntax"><code class="literal">INSERT</code></a> in Tx2 depends on
                            precisely when the statement executes. If the
                            <a class="link" href="sql-syntax.html#insert" title="13.2.5&nbsp;INSERT Syntax"><code class="literal">INSERT</code></a> of Tx2 executes while
                            the <a class="link" href="sql-syntax.html#insert" title="13.2.5&nbsp;INSERT Syntax"><code class="literal">INSERT</code></a> of Tx1 is running
                            (rather than before it starts or after it completes), the
                            specific auto-increment values assigned by the two
                            <a class="link" href="sql-syntax.html#insert" title="13.2.5&nbsp;INSERT Syntax"><code class="literal">INSERT</code></a> statements are
                            nondeterministic, and may vary from run to run.
                        </p><p style="color:blue;">在前面的示例中，如果没有表级锁，则用于tx2中的insert的自动增量列的值正好取决于语句执行的时间。如果在运行tx1的insert时执行tx2的insert（而不是在它开始之前或完成之后），两个insert语句指定的特定自动增量值是不确定的，并且可能因运行而异。</p><p>
                            Under the
                            <a class="link" href="innodb-storage-engine.html#innodb-auto-increment-lock-mode-consecutive">consecutive</a>
                            lock mode, <code class="literal">InnoDB</code> can avoid using
                            table-level <code class="literal">AUTO-INC</code> locks for
                            <span class="quote">“<span class="quote">simple insert</span>”</span> statements where the number of
                            rows is known in advance, and still preserve deterministic
                            execution and safety for statement-based replication.
                        </p><p style="color:blue;">在连续锁模式下，innodb可以避免对预先知道行数的“simple insert”语句使用表级auto-inc锁，并且仍然保留基于语句的复制的确定性执行和安全性。</p><p>
                            If you are not using the binary log to replay SQL statements
                            as part of recovery or replication, the
                            <a class="link" href="innodb-storage-engine.html#innodb-auto-increment-lock-mode-interleaved">interleaved</a>
                            lock mode can be used to eliminate all use of table-level
                            <code class="literal">AUTO-INC</code> locks for even greater
                            concurrency and performance, at the cost of permitting gaps
                            in auto-increment numbers assigned by a statement and
                            potentially having the numbers assigned by concurrently
                            executing statements interleaved.
                        </p><p style="color:blue;">如果不使用二进制日志作为恢复或复制的一部分来重放sql语句，则可以使用交错锁模式来消除表级auto-inc锁的所有使用，以获得更高的并发性和性能，代价是允许语句分配的自动递增数中存在间隙，并且可能将并发执行语句分配的数交错。</p></li><li class="listitem"><p><a name="innodb-auto-increment-lock-mode-consecutive"></a>
                            <code class="literal">innodb_autoinc_lock_mode = 1</code>
                            (<span class="quote">“<span class="quote">consecutive</span>”</span> lock mode)
                        </p><p style="color:blue;">innodb_autoinc_lock_mode=1（“连续”锁定模式）</p><p>
                            This is the default lock mode. In this mode, <span class="quote">“<span class="quote">bulk
            inserts</span>”</span> use the special <code class="literal">AUTO-INC</code>
                            table-level lock and hold it until the end of the statement.
                            This applies to all
                            <a class="link" href="sql-syntax.html#insert-select" title="13.2.5.1&nbsp;INSERT ... SELECT Syntax"><code class="literal">INSERT ...
                                SELECT</code></a>,
                            <a class="link" href="sql-syntax.html#replace" title="13.2.8&nbsp;REPLACE Syntax"><code class="literal">REPLACE ...
                                SELECT</code></a>, and <a class="link" href="sql-syntax.html#load-data" title="13.2.6&nbsp;LOAD DATA Syntax"><code class="literal">LOAD
                            DATA</code></a> statements. Only one statement holding the
                            <code class="literal">AUTO-INC</code> lock can execute at a time. If
                            the source table of the bulk insert operation is different
                            from the target table, the <code class="literal">AUTO-INC</code> lock
                            on the target table is taken after a shared lock is taken on
                            the first row selected from the source table. If the source
                            and target of the bulk insert operation are the same table,
                            the <code class="literal">AUTO-INC</code> lock is taken after shared
                            locks are taken on all selected rows.
                        </p><p style="color:blue;">这是默认的锁定模式。在这种模式下，“批量插入”使用特殊的auto-inc表级锁并将其保持到语句结束。这适用于所有插入…选择，替换…选择并加载数据语句。一次只能执行一个持有auto-inc锁的语句。如果大容量插入操作的源表与目标表不同，则在从源表中选择的第一行上获取共享锁后，将获取目标表上的auto-inc锁。如果大容量插入操作的源和目标是同一个表，则在对所有选定行执行共享锁之后，将执行auto-inc锁。</p><p>
                            <span class="quote">“<span class="quote">Simple inserts</span>”</span> (for which the number of rows
                            to be inserted is known in advance) avoid table-level
                            <code class="literal">AUTO-INC</code> locks by obtaining the required
                            number of auto-increment values under the control of a mutex
                            (a light-weight lock) that is only held for the duration of
                            the allocation process, <span class="emphasis"><em>not</em></span> until the
                            statement completes. No table-level
                            <code class="literal">AUTO-INC</code> lock is used unless an
                            <code class="literal">AUTO-INC</code> lock is held by another
                            transaction. If another transaction holds an
                            <code class="literal">AUTO-INC</code> lock, a <span class="quote">“<span class="quote">simple
            insert</span>”</span> waits for the <code class="literal">AUTO-INC</code>
                            lock, as if it were a <span class="quote">“<span class="quote">bulk insert</span>”</span>.
                        </p><p style="color:blue;">“简单插入”（要插入的行数预先知道）通过在互斥锁（一个轻量级锁）的控制下获得所需的自动增量值来避免表级的auto-inc锁，该互斥锁只在分配过程中保持，而不是在语句完成之前。除非auto-inc锁由另一个事务持有，否则不使用表级auto-inc锁。如果另一个事务持有auto-inc锁，“简单插入”会等待auto-inc锁，就好像它是“大容量插入”。</p><p>
                            This lock mode ensures that, in the presence of
                            <a class="link" href="sql-syntax.html#insert" title="13.2.5&nbsp;INSERT Syntax"><code class="literal">INSERT</code></a> statements where the
                            number of rows is not known in advance (and where
                            auto-increment numbers are assigned as the statement
                            progresses), all auto-increment values assigned by any
                            <span class="quote">“<span class="quote"><a class="link" href="sql-syntax.html#insert" title="13.2.5&nbsp;INSERT Syntax"><code class="literal">INSERT</code></a>-like</span>”</span>
                            statement are consecutive, and operations are safe for
                            statement-based replication.
                        </p><p style="color:blue;">这种锁定模式确保，在insert语句存在的情况下，如果事先不知道行数（并且在语句进行时分配了自动增量号），则任何“insert like”语句分配的所有自动增量值都是连续的，并且操作对于基于语句的复制是安全的。</p><p>
                            Simply put, this lock mode significantly improves
                            scalability while being safe for use with statement-based
                            replication. Further, as with <span class="quote">“<span class="quote">traditional</span>”</span>
                            lock mode, auto-increment numbers assigned by any given
                            statement are <span class="emphasis"><em>consecutive</em></span>. There is
                            <span class="emphasis"><em>no change</em></span> in semantics compared to
                            <span class="quote">“<span class="quote">traditional</span>”</span> mode for any statement that uses
                            auto-increment, with one important exception.
                        </p><p style="color:blue;">简单地说，这种锁定模式显著地提高了可伸缩性，同时可以安全地用于基于语句的复制。此外，与“传统”锁定模式一样，由任何给定语句指定的自动递增数都是连续的。与“传统”模式相比，任何使用自动增量的语句的语义都没有变化，但有一个重要的例外。</p><p>
                            The exception is for <span class="quote">“<span class="quote">mixed-mode inserts</span>”</span>,
                            where the user provides explicit values for an
                            <code class="literal">AUTO_INCREMENT</code> column for some, but not
                            all, rows in a multiple-row <span class="quote">“<span class="quote">simple insert</span>”</span>.
                            For such inserts, <code class="literal">InnoDB</code> allocates more
                            auto-increment values than the number of rows to be
                            inserted. However, all values automatically assigned are
                            consecutively generated (and thus higher than) the
                            auto-increment value generated by the most recently executed
                            previous statement. <span class="quote">“<span class="quote">Excess</span>”</span> numbers are lost.
                        </p><p style="color:blue;">“混合模式插入”除外，用户为多行“简单插入”中的某些行（而不是所有行）的自动增量列提供显式值。对于这种插入，innodb分配的自动增量值比要插入的行数还要多。但是，自动分配的所有值都是连续生成的（因此高于）由最近执行的前一条语句生成的自动增量值。“多余”的数字会丢失。</p></li><li class="listitem"><p><a name="innodb-auto-increment-lock-mode-interleaved"></a>
                            <code class="literal">innodb_autoinc_lock_mode = 2</code>
                            (<span class="quote">“<span class="quote">interleaved</span>”</span> lock mode)
                        </p><p style="color:blue;">innodb_autoinc_lock_mode=2（“交错”锁定模式）</p><p>
                            In this lock mode, no
                            <span class="quote">“<span class="quote"><a class="link" href="sql-syntax.html#insert" title="13.2.5&nbsp;INSERT Syntax"><code class="literal">INSERT</code></a>-like</span>”</span>
                            statements use the table-level <code class="literal">AUTO-INC</code>
                            lock, and multiple statements can execute at the same time.
                            This is the fastest and most scalable lock mode, but it is
                            <span class="emphasis"><em>not safe</em></span> when using statement-based
                            replication or recovery scenarios when SQL statements are
                            replayed from the binary log.
                        </p><p style="color:blue;">在这种锁模式下，没有“insert like”语句使用表级auto-inc锁，并且可以同时执行多个语句。这是最快、最可扩展的锁定模式，但当从二进制日志中重放SQL语句时，使用基于语句的复制或恢复方案时，这是不安全的。</p><p>
                            In this lock mode, auto-increment values are guaranteed to
                            be unique and monotonically increasing across all
                            concurrently executing
                            <span class="quote">“<span class="quote"><a class="link" href="sql-syntax.html#insert" title="13.2.5&nbsp;INSERT Syntax"><code class="literal">INSERT</code></a>-like</span>”</span>
                            statements. However, because multiple statements can be
                            generating numbers at the same time (that is, allocation of
                            numbers is <span class="emphasis"><em>interleaved</em></span> across
                            statements), the values generated for the rows inserted by
                            any given statement may not be consecutive.
                        </p><p style="color:blue;">在这种锁定模式下，自动增量值保证在所有并发执行的“类插入”语句中是唯一的和单调递增的。但是，由于多个语句可以同时生成数字（即，数字的分配是跨语句交叉的），因此为任何给定语句插入的行生成的值可能不是连续的。</p><p>
                            If the only statements executing are <span class="quote">“<span class="quote">simple
            inserts</span>”</span> where the number of rows to be inserted is
                            known ahead of time, there are no gaps in the numbers
                            generated for a single statement, except for
                            <span class="quote">“<span class="quote">mixed-mode inserts</span>”</span>. However, when <span class="quote">“<span class="quote">bulk
            inserts</span>”</span> are executed, there may be gaps in the
                            auto-increment values assigned by any given statement.
                        </p><p style="color:blue;">如果执行的唯一语句是“简单插入”，其中要插入的行数是提前知道的，则为单个语句生成的数字中没有间隙，除了“混合模式插入”。但是，当执行“大容量插入”时，任何给定语句指定的自动增量值中都可能有间隙。</p></li></ul>
                    </div>

                </div>
                <div class="simplesect">
                    <div class="titlepage">
                        <div>
                            <div class="simple">
                                <h5 class="title"><a name="innodb-auto-increment-lock-mode-usage-implications"></a>InnoDB AUTO_INCREMENT Lock Mode Usage Implications</h5>

                            </div>

                        </div>

                    </div>
                    <div class="itemizedlist">
                        <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                            Using auto-increment with replication
                        </p><p style="color:blue;">对复制使用自动增量</p><p>
                            If you are using statement-based replication, set
                            <a class="link" href="innodb-storage-engine.html#sysvar_innodb_autoinc_lock_mode"><code class="literal">innodb_autoinc_lock_mode</code></a> to
                            0 or 1 and use the same value on the master and its slaves.
                            Auto-increment values are not ensured to be the same on the
                            slaves as on the master if you use
                            <a class="link" href="innodb-storage-engine.html#sysvar_innodb_autoinc_lock_mode"><code class="literal">innodb_autoinc_lock_mode</code></a> =
                            2 (<span class="quote">“<span class="quote">interleaved</span>”</span>) or configurations where the
                            master and slaves do not use the same lock mode.
                        </p><p style="color:blue;">如果使用基于语句的复制，请将innodb_autoinc_lock_mode设置为0或1，并在主设备及其从设备上使用相同的值。如果使用innodb_autoinc_lock_mode=2（“交错”）或主/从不使用相同锁定模式的配置，则无法确保从机上的自动增量值与主机上的相同。</p><p>
                            If you are using row-based or mixed-format replication, all
                            of the auto-increment lock modes are safe, since row-based
                            replication is not sensitive to the order of execution of
                            the SQL statements (and the mixed format uses row-based
                            replication for any statements that are unsafe for
                            statement-based replication).
                        </p><p style="color:blue;">如果使用基于行的复制或混合格式复制，则所有自动增量锁定模式都是安全的，因为基于行的复制对SQL语句的执行顺序不敏感（并且混合格式对基于语句的复制不安全的任何语句使用基于行的复制）。</p></li><li class="listitem"><p>
                            <span class="quote">“<span class="quote">Lost</span>”</span> auto-increment values and sequence gaps
                        </p><p style="color:blue;">“丢失”自动增量值和序列间隙</p><p>
                            In all lock modes (0, 1, and 2), if a transaction that
                            generated auto-increment values rolls back, those
                            auto-increment values are <span class="quote">“<span class="quote">lost</span>”</span>. Once a value
                            is generated for an auto-increment column, it cannot be
                            rolled back, whether or not the
                            <span class="quote">“<span class="quote"><a class="link" href="sql-syntax.html#insert" title="13.2.5&nbsp;INSERT Syntax"><code class="literal">INSERT</code></a>-like</span>”</span>
                            statement is completed, and whether or not the containing
                            transaction is rolled back. Such lost values are not reused.
                            Thus, there may be gaps in the values stored in an
                            <code class="literal">AUTO_INCREMENT</code> column of a table.
                        </p><p style="color:blue;">在所有锁定模式（0、1和2）中，如果生成自动增量值的事务回滚，则这些自动增量值将“丢失”。为自动递增列生成值后，无论“类插入”语句是否完成，以及包含的事务是否回滚，都无法回滚该值。这样丢失的值不会被重用。因此，存储在表的自动递增列中的值可能有间隙。</p></li><li class="listitem"><p>
                            Specifying NULL or 0 for the
                            <code class="literal">AUTO_INCREMENT</code> column
                        </p><p style="color:blue;">为自动递增列指定NULL或0</p><p>
                            In all lock modes (0, 1, and 2), if a user specifies NULL or
                            0 for the <code class="literal">AUTO_INCREMENT</code> column in an
                            <a class="link" href="sql-syntax.html#insert" title="13.2.5&nbsp;INSERT Syntax"><code class="literal">INSERT</code></a>,
                            <code class="literal">InnoDB</code> treats the row as if the value was
                            not specified and generates a new value for it.
                        </p><p style="color:blue;">在所有锁模式（0、1和2）中，如果用户为insert中的auto_increment列指定null或0，innodb会将该行视为未指定值并为其生成新值。</p></li><li class="listitem"><p>
                            Assigning a negative value to the
                            <code class="literal">AUTO_INCREMENT</code> column
                        </p><p style="color:blue;">为自动递增列指定负值</p><p>
                            In all lock modes (0, 1, and 2), the behavior of the
                            auto-increment mechanism is not defined if you assign a
                            negative value to the <code class="literal">AUTO_INCREMENT</code>
                            column.
                        </p><p style="color:blue;">在所有锁定模式（0、1和2）中，如果为“自动增量”列指定负值，则不会定义自动增量机制的行为。</p></li><li class="listitem"><p>
                            If the <code class="literal">AUTO_INCREMENT</code> value becomes
                            larger than the maximum integer for the specified integer
                            type
                        </p><p style="color:blue;">如果AutoIoLoad值大于指定整数类型的最大整数</p><p>
                            In all lock modes (0, 1, and 2), the behavior of the
                            auto-increment mechanism is not defined if the value becomes
                            larger than the maximum integer that can be stored in the
                            specified integer type.
                        </p><p style="color:blue;">在所有锁定模式（0, 1和2）中，如果值大于可存储在指定整数类型中的最大整数，则不定义自动增量机制的行为。</p></li><li class="listitem"><p>
                            Gaps in auto-increment values for <span class="quote">“<span class="quote">bulk
            inserts</span>”</span>
                        </p><p style="color:blue;">“批量插入”的自动增量值中的间隙</p><p>
                            With
                            <a class="link" href="innodb-storage-engine.html#sysvar_innodb_autoinc_lock_mode"><code class="literal">innodb_autoinc_lock_mode</code></a>
                            set to 0 (<span class="quote">“<span class="quote">traditional</span>”</span>) or 1
                            (<span class="quote">“<span class="quote">consecutive</span>”</span>), the auto-increment values
                            generated by any given statement are consecutive, without
                            gaps, because the table-level <code class="literal">AUTO-INC</code>
                            lock is held until the end of the statement, and only one
                            such statement can execute at a time.
                        </p><p style="color:blue;">当innodb_auto inc_lock_mode设置为0（“传统”）或1（“连续”）时，任何给定语句生成的自动增量值都是连续的，没有间隙，因为表级auto-inc锁一直保持到语句结束，并且一次只能执行一个这样的语句。</p><p>
                            With
                            <a class="link" href="innodb-storage-engine.html#sysvar_innodb_autoinc_lock_mode"><code class="literal">innodb_autoinc_lock_mode</code></a>
                            set to 2 (<span class="quote">“<span class="quote">interleaved</span>”</span>), there may be gaps in
                            the auto-increment values generated by <span class="quote">“<span class="quote">bulk
            inserts,</span>”</span> but only if there are concurrently
                            executing
                            <span class="quote">“<span class="quote"><a class="link" href="sql-syntax.html#insert" title="13.2.5&nbsp;INSERT Syntax"><code class="literal">INSERT</code></a>-like</span>”</span>
                            statements.
                        </p><p style="color:blue;">当innodb_autoinc_lock_mode设置为2（“交错”）时，“批量插入”生成的自动增量值可能存在间隙，但只有在同时执行“类似插入”语句的情况下。</p><p>
                            For lock modes 1 or 2, gaps may occur between successive
                            statements because for bulk inserts the exact number of
                            auto-increment values required by each statement may not be
                            known and overestimation is possible.
                        </p><p style="color:blue;">对于锁模式1或2，连续语句之间可能会出现间隙，因为对于大容量插入，每个语句所需的自动增量值的确切数目可能未知，并且可能过高估计。</p></li><li class="listitem"><p>
                            Auto-increment values assigned by <span class="quote">“<span class="quote">mixed-mode
            inserts</span>”</span>
                        </p><p style="color:blue;">“混合模式插入”指定的自动增量值</p><p>
                            Consider a <span class="quote">“<span class="quote">mixed-mode insert,</span>”</span> where a
                            <span class="quote">“<span class="quote">simple insert</span>”</span> specifies the auto-increment
                            value for some (but not all) resulting rows. Such a
                            statement behaves differently in lock modes 0, 1, and 2. For
                            example, assume <code class="literal">c1</code> is an
                            <code class="literal">AUTO_INCREMENT</code> column of table
                            <code class="literal">t1</code>, and that the most recent
                            automatically generated sequence number is 100.
                        </p><p style="color:blue;">考虑一个“混合模式插入”，其中一个“简单插入”指定一些（但不是所有）结果行的自动增量值。这样的语句在锁定模式0、1和2中的行为不同。例如，假设c1是表t1的自动递增列，并且最近自动生成的序列号是100。</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>CREATE TABLE t1 (</code></strong>
    -&gt; <strong class="userinput"><code>c1 INT UNSIGNED NOT NULL AUTO_INCREMENT PRIMARY KEY, </code></strong>
    -&gt; <strong class="userinput"><code>c2 CHAR(1)</code></strong>
    -&gt; <strong class="userinput"><code>) ENGINE = INNODB;</code></strong>
</pre><p>
                            Now, consider the following <span class="quote">“<span class="quote">mixed-mode insert</span>”</span>
                            statement:
                        </p><p style="color:blue;">现在，考虑下面的“混合模式插入”语句：</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>INSERT INTO t1 (c1,c2) VALUES (1,'a'), (NULL,'b'), (5,'c'), (NULL,'d');</code></strong>
</pre><p>
                            With
                            <a class="link" href="innodb-storage-engine.html#sysvar_innodb_autoinc_lock_mode"><code class="literal">innodb_autoinc_lock_mode</code></a>
                            set to 0 (<span class="quote">“<span class="quote">traditional</span>”</span>), the four new rows
                            are:
                        </p><p style="color:blue;">当innodb_autoinc_lock_mode设置为0（“传统”）时，四个新行是：</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT c1, c2 FROM t1 ORDER BY c2;</code></strong>
+-----+------+
| c1  | c2   |
+-----+------+
|   1 | a    |
| 101 | b    |
|   5 | c    |
| 102 | d    |
+-----+------+
</pre><p>
                            The next available auto-increment value is 103 because the
                            auto-increment values are allocated one at a time, not all
                            at once at the beginning of statement execution. This result
                            is true whether or not there are concurrently executing
                            <span class="quote">“<span class="quote"><a class="link" href="sql-syntax.html#insert" title="13.2.5&nbsp;INSERT Syntax"><code class="literal">INSERT</code></a>-like</span>”</span>
                            statements (of any type).
                        </p><p style="color:blue;">下一个可用的自动增量值是103，因为自动增量值一次分配一个，而不是在语句执行开始时一次分配所有值。无论是否有（任何类型的）并发执行的“insert-like”语句，此结果都是正确的。</p><p>
                            With
                            <a class="link" href="innodb-storage-engine.html#sysvar_innodb_autoinc_lock_mode"><code class="literal">innodb_autoinc_lock_mode</code></a>
                            set to 1 (<span class="quote">“<span class="quote">consecutive</span>”</span>), the four new rows are
                            also:
                        </p><p style="color:blue;">当innodb_autoinc_lock_mode设置为1（“连续”）时，四个新行也为：</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT c1, c2 FROM t1 ORDER BY c2;</code></strong>
+-----+------+
| c1  | c2   |
+-----+------+
|   1 | a    |
| 101 | b    |
|   5 | c    |
| 102 | d    |
+-----+------+
</pre><p>
                            However, in this case, the next available auto-increment
                            value is 105, not 103 because four auto-increment values are
                            allocated at the time the statement is processed, but only
                            two are used. This result is true whether or not there are
                            concurrently executing
                            <span class="quote">“<span class="quote"><a class="link" href="sql-syntax.html#insert" title="13.2.5&nbsp;INSERT Syntax"><code class="literal">INSERT</code></a>-like</span>”</span>
                            statements (of any type).
                        </p><p style="color:blue;">但是，在这种情况下，下一个可用的自动增量值是105，而不是103，因为在处理语句时分配了四个自动增量值，但只使用了两个。无论是否有（任何类型的）并发执行的“insert-like”语句，此结果都是正确的。</p><p>
                            With
                            <a class="link" href="innodb-storage-engine.html#sysvar_innodb_autoinc_lock_mode"><code class="literal">innodb_autoinc_lock_mode</code></a>
                            set to mode 2 (<span class="quote">“<span class="quote">interleaved</span>”</span>), the four new
                            rows are:
                        </p><p style="color:blue;">当innodb_autoinc_lock_mode设置为mode 2（“交错”）时，四个新行是：</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT c1, c2 FROM t1 ORDER BY c2;</code></strong>
+-----+------+
| c1  | c2   |
+-----+------+
|   1 | a    |
|   <em class="replaceable"><code>x</code></em> | b    |
|   5 | c    |
|   <em class="replaceable"><code>y</code></em> | d    |
+-----+------+
</pre><p>
                            The values of <em class="replaceable"><code>x</code></em> and
                            <em class="replaceable"><code>y</code></em> are unique and larger than any
                            previously generated rows. However, the specific values of
                            <em class="replaceable"><code>x</code></em> and
                            <em class="replaceable"><code>y</code></em> depend on the number of
                            auto-increment values generated by concurrently executing
                            statements.
                        </p><p style="color:blue;">x和y的值是唯一的，比以前生成的任何行都大。但是，x和y的具体值取决于并发执行语句生成的自动增量值的数量。</p><p>
                            Finally, consider the following statement, issued when the
                            most-recently generated sequence number is 100:
                        </p><p style="color:blue;">最后，考虑以下语句，当最近生成的序列号为100时发出：</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>INSERT INTO t1 (c1,c2) VALUES (1,'a'), (NULL,'b'), (101,'c'), (NULL,'d');</code></strong>
</pre><p>
                            With any
                            <a class="link" href="innodb-storage-engine.html#sysvar_innodb_autoinc_lock_mode"><code class="literal">innodb_autoinc_lock_mode</code></a>
                            setting, this statement generates a duplicate-key error
                            23000 (<code class="literal">Can't write; duplicate key in
                            table</code>) because 101 is allocated for the row
                            <code class="literal">(NULL, 'b')</code> and insertion of the row
                            <code class="literal">(101, 'c')</code> fails.
                        </p><p style="color:blue;">对于任何innodb_autoinc_lock_mode设置，该语句都会生成一个重复的密钥错误23000（无法写入；表中有重复的密钥），因为101被分配给行（空，'b'），行（101，'c'）的插入失败。</p></li><li class="listitem"><p>
                            Modifying <code class="literal">AUTO_INCREMENT</code> column values in
                            the middle of a sequence of
                            <a class="link" href="sql-syntax.html#insert" title="13.2.5&nbsp;INSERT Syntax"><code class="literal">INSERT</code></a> statements
                        </p><p style="color:blue;">在INSERT语句序列中间修改自动递增列值</p><p>
                            In all lock modes (0, 1, and 2), modifying an
                            <code class="literal">AUTO_INCREMENT</code> column value in the middle
                            of a sequence of <a class="link" href="sql-syntax.html#insert" title="13.2.5&nbsp;INSERT Syntax"><code class="literal">INSERT</code></a>
                            statements could lead to <span class="quote">“<span class="quote">Duplicate entry</span>”</span>
                            errors. For example, if you perform an
                            <a class="link" href="sql-syntax.html#update" title="13.2.11&nbsp;UPDATE Syntax"><code class="literal">UPDATE</code></a> operation that changes
                            an <code class="literal">AUTO_INCREMENT</code> column value to a value
                            larger than the current maximum auto-increment value,
                            subsequent <a class="link" href="sql-syntax.html#insert" title="13.2.5&nbsp;INSERT Syntax"><code class="literal">INSERT</code></a> operations
                            that do not specify an unused auto-increment value could
                            encounter <span class="quote">“<span class="quote">Duplicate entry</span>”</span> errors. This
                            behavior is demonstrated in the following example.
                        </p><p style="color:blue;">在所有锁定模式（0、1和2）中，在一系列INSERT语句中间修改自动递增列值可能会导致“重复输入”错误。例如，如果执行更新操作，将AutoYLoad列值更改为大于当前最大自动增量值的值，则不指定未使用的自动增量值的后续插入操作可能会遇到“重复条目”错误。此行为在下面的示例中演示。</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>CREATE TABLE t1 (</code></strong>
    -&gt; <strong class="userinput"><code>c1 INT NOT NULL AUTO_INCREMENT,</code></strong>
    -&gt; <strong class="userinput"><code>PRIMARY KEY (c1)</code></strong>
    -&gt;  <strong class="userinput"><code>) ENGINE = InnoDB;</code></strong>

mysql&gt; <strong class="userinput"><code>INSERT INTO t1 VALUES(0), (0), (3);</code></strong>

mysql&gt; <strong class="userinput"><code>SELECT c1 FROM t1;</code></strong>
+----+
| c1 |
+----+
|  1 |
|  2 |
|  3 |
+----+

mysql&gt; <strong class="userinput"><code>UPDATE t1 SET c1 = 4 WHERE c1 = 1;</code></strong>

mysql&gt; <strong class="userinput"><code>SELECT c1 FROM t1;</code></strong>
+----+
| c1 |
+----+
|  2 |
|  3 |
|  4 |
+----+

mysql&gt; <strong class="userinput"><code>INSERT INTO t1 VALUES(0);</code></strong>
ERROR 1062 (23000): Duplicate entry '4' for key 'PRIMARY'
</pre></li></ul>
                    </div>

                </div>
                <div class="simplesect">
                    <div class="titlepage">
                        <div>
                            <div class="simple">
                                <h5 class="title"><a name="innodb-auto-increment-initialization"></a>InnoDB AUTO_INCREMENT Counter Initialization</h5>

                            </div>

                        </div>

                    </div>
                    <a class="indexterm" name="idm140286823586192"></a><p>
                    This section describes how <code class="literal">InnoDB</code> initializes
                    <code class="literal">AUTO_INCREMENT</code> counters.
                </p><p style="color:blue;">本节描述InnoDB如何初始化自动递增计数器。</p><p>
                    If you specify an <code class="literal">AUTO_INCREMENT</code> column for
                    an <code class="literal">InnoDB</code> table, the table handle in the
                    <code class="literal">InnoDB</code> data dictionary contains a special
                    counter called the auto-increment counter that is used in
                    assigning new values for the column. This counter is stored only
                    in main memory, not on disk.
                </p><p style="color:blue;">如果为innodb表指定了auto_increment列，那么innodb数据字典中的表句柄包含一个称为auto increment counter的特殊计数器，该计数器用于为列分配新值。此计数器仅存储在主内存中，而不是磁盘上。</p><p>
                    To initialize an auto-increment counter after a server restart,
                    <code class="literal">InnoDB</code> executes the equivalent of the
                    following statement on the first insert into a table containing
                    an <code class="literal">AUTO_INCREMENT</code> column.
                </p><p style="color:blue;">要在服务器重新启动后初始化自动递增计数器，innodb在第一次插入包含自动递增列的表时执行以下语句的等效语句。</p><pre data-lang="sql" class="programlisting">SELECT MAX(ai_col) FROM <em class="replaceable"><code>table_name</code></em> FOR UPDATE;
</pre><p>
                    <code class="literal">InnoDB</code> increments the value retrieved by the
                    statement and assigns it to the column and to the auto-increment
                    counter for the table. By default, the value is incremented by
                    1. This default can be overridden by the
                    <a class="link" href="replication.html#sysvar_auto_increment_increment"><code class="literal">auto_increment_increment</code></a>
                    configuration setting.
                </p><p style="color:blue;">innodb递增语句检索到的值，并将其分配给列和表的自动递增计数器。默认情况下，该值递增1。此默认值可以由自动增量配置设置覆盖。</p><p>
                    If the table is empty, <code class="literal">InnoDB</code> uses the value
                    <code class="literal">1</code>. This default can be overridden by the
                    <a class="link" href="replication.html#sysvar_auto_increment_offset"><code class="literal">auto_increment_offset</code></a>
                    configuration setting.
                </p><p style="color:blue;">如果表为空，innodb使用值1。此默认值可以由“自动增量偏移”配置设置覆盖。</p><p>
                    If a <a class="link" href="sql-syntax.html#show-table-status" title="13.7.5.36&nbsp;SHOW TABLE STATUS Syntax"><code class="literal">SHOW TABLE STATUS</code></a> statement
                    examines the table before the auto-increment counter is
                    initialized, <code class="literal">InnoDB</code> initializes but does not
                    increment the value. The value is stored for use by later
                    inserts. This initialization uses a normal exclusive-locking
                    read on the table and the lock lasts to the end of the
                    transaction. <code class="literal">InnoDB</code> follows the same
                    procedure for initializing the auto-increment counter for a
                    newly created table.
                </p><p style="color:blue;">如果show table status语句在初始化自动递增计数器之前检查表，innodb初始化但不递增该值。存储该值以供以后的插入使用。此初始化使用对表的正常独占锁读取，锁将持续到事务结束。innodb遵循相同的过程为新创建的表初始化自动递增计数器。</p><p>
                    After the auto-increment counter has been initialized, if you do
                    not explicitly specify a value for an
                    <code class="literal">AUTO_INCREMENT</code> column,
                    <code class="literal">InnoDB</code> increments the counter and assigns the
                    new value to the column. If you insert a row that explicitly
                    specifies the column value, and the value is greater than the
                    current counter value, the counter is set to the specified
                    column value.
                </p><p style="color:blue;">初始化自动递增计数器后，如果没有显式指定自动递增列的值，innodb将递增计数器并将新值分配给该列。如果插入显式指定列值的行，并且该值大于当前计数器值，则计数器将设置为指定的列值。</p><p>
                    <code class="literal">InnoDB</code> uses the in-memory auto-increment
                    counter as long as the server runs. When the server is stopped
                    and restarted, <code class="literal">InnoDB</code> reinitializes the
                    counter for each table for the first
                    <a class="link" href="sql-syntax.html#insert" title="13.2.5&nbsp;INSERT Syntax"><code class="literal">INSERT</code></a> to the table, as described
                    earlier.
                </p><p style="color:blue;">只要服务器运行，InnoDB就会使用内存中的自动递增计数器。当服务器停止并重新启动时，innodb会重新初始化每个表的计数器，以便第一次插入到表中，如前所述。</p><p>
                    A server restart also cancels the effect of the
                    <code class="literal">AUTO_INCREMENT = <em class="replaceable"><code>N</code></em></code>
                    table option in <a class="link" href="sql-syntax.html#create-table" title="13.1.18&nbsp;CREATE TABLE Syntax"><code class="literal">CREATE TABLE</code></a> and
                    <a class="link" href="sql-syntax.html#alter-table" title="13.1.8&nbsp;ALTER TABLE Syntax"><code class="literal">ALTER TABLE</code></a> statements, which you
                    can use with <code class="literal">InnoDB</code> tables to set the initial
                    counter value or alter the current counter value.
                </p><p style="color:blue;">服务器重启还会取消create table和alter table语句中auto_increment=n table选项的效果，您可以将其与innodb tables一起使用来设置初始计数器值或更改当前计数器值。</p>
                </div>

            </div>
            <div class="section">
                <div class="titlepage">
                    <div>
                        <div>
                            <h4 class="title"><a name="innodb-foreign-key-constraints"></a>14.6.1.5&nbsp;InnoDB and FOREIGN KEY Constraints</h4>

                        </div>

                    </div>

                </div>
                <a class="indexterm" name="idm140286823556112"></a><a class="indexterm" name="idm140286823554624"></a><a class="indexterm" name="idm140286823553136"></a><p>
                How the <code class="literal">InnoDB</code> storage engine handles foreign
                key constraints is described under the following topics in this
                section:
            </p><p style="color:blue;">InnoDB存储引擎如何处理外键约束在本节的以下主题中进行了描述：</p>
                <div class="itemizedlist">
                    <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><a class="xref" href="innodb-storage-engine.html#innodb-foreign-key-definitions" title="Foreign Key Definitions">Foreign Key Definitions</a></p><p style="color:blue;">外键定义</p></li><li class="listitem"><p><a class="xref" href="innodb-storage-engine.html#innodb-foreign-key-referential-actions" title="Referential Actions">Referential Actions</a></p><p style="color:blue;">参照动作</p></li><li class="listitem"><p><a class="xref" href="innodb-storage-engine.html#innodb-foreign-key-generated-columns" title="Foreign Key Restrictions for Generated Columns and Virtual Indexes">Foreign Key Restrictions for Generated Columns and Virtual Indexes</a></p><p style="color:blue;">生成的列和虚拟索引的外键限制</p></li></ul>
                </div>
                <p>
                    For foreign key usage information and examples, see
                    <a class="xref" href="sql-syntax.html#create-table-foreign-keys" title="13.1.18.6&nbsp;Using FOREIGN KEY Constraints">Section&nbsp;13.1.18.6, “Using FOREIGN KEY Constraints”</a>.
                </p><p style="color:blue;">有关外键使用信息和示例，请参阅第13.1.18.6节“使用外键约束”。</p>
                <div class="simplesect">

                    <div class="titlepage">
                        <div>

                            <div class="simple">
                                <h5 class="title"><a name="innodb-foreign-key-definitions"></a>Foreign Key Definitions</h5>
                            </div>
                        </div>
                    </div>
                    <p>
                        Foreign key definitions for <code class="literal">InnoDB</code> tables are
                        subject to the following conditions:
                    </p><p style="color:blue;">innodb表的外键定义受以下条件约束：</p>
                    <div class="itemizedlist">
                        <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                            <code class="literal">InnoDB</code> permits a foreign key to reference
                            any index column or group of columns. However, in the
                            referenced table, there must be an index where the
                            referenced columns are the <span class="emphasis"><em>first</em></span>
                            columns in the same order. Hidden columns that
                            <code class="literal">InnoDB</code> adds to an index are also
                            considered (see <a class="xref" href="innodb-storage-engine.html#innodb-index-types" title="14.6.2.1&nbsp;Clustered and Secondary Indexes">Section&nbsp;14.6.2.1, “Clustered and Secondary Indexes”</a>).
                        </p><p style="color:blue;">innodb允许外键引用任何索引列或列组。但是，在被引用表中，必须有一个索引，其中被引用列是同一顺序的第一列。还考虑了innodb添加到索引中的隐藏列（参见14.6.2.1节，“聚集索引和辅助索引”）。</p></li><li class="listitem"><p>
                            <a class="link" href="innodb-storage-engine.html" title="Chapter&nbsp;14&nbsp;The InnoDB Storage Engine"><code class="literal">InnoDB</code></a> does not currently
                            support foreign keys for tables with user-defined
                            partitioning. This means that no user-partitioned
                            <code class="literal">InnoDB</code> table may contain foreign key
                            references or columns referenced by foreign keys.
                        </p><p style="color:blue;">对于具有用户定义分区的表，innodb目前不支持外键。这意味着用户分区的innodb表不能包含外键引用或外键引用的列。</p></li><li class="listitem"><p>
                            <code class="literal">InnoDB</code> allows a foreign key constraint to
                            reference a nonunique key. <span class="emphasis"><em>This is an
            <code class="literal">InnoDB</code> extension to standard
            SQL.</em></span>
                        </p><p style="color:blue;">innodb允许外键约束引用非唯一键。这是标准sql的innodb扩展。</p></li></ul>
                    </div>

                </div>
                <div class="simplesect">
                    <div class="titlepage">
                        <div>
                            <div class="simple">
                                <h5 class="title"><a name="innodb-foreign-key-referential-actions"></a>Referential Actions</h5>

                            </div>

                        </div>

                    </div>
                    <p>
                        Referential actions for foreign keys of
                        <code class="literal">InnoDB</code> tables are subject to the following
                        conditions:
                    </p><p style="color:blue;">innodb表外键的引用操作受以下条件约束：</p>
                    <div class="itemizedlist">
                        <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                            While <code class="literal">SET DEFAULT</code> is allowed by the MySQL
                            Server, it is rejected as invalid by
                            <code class="literal">InnoDB</code>. <a class="link" href="sql-syntax.html#create-table" title="13.1.18&nbsp;CREATE TABLE Syntax"><code class="literal">CREATE
                            TABLE</code></a> and <a class="link" href="sql-syntax.html#alter-table" title="13.1.8&nbsp;ALTER TABLE Syntax"><code class="literal">ALTER
                            TABLE</code></a> statements using this clause are not allowed
                            for InnoDB tables.
                        </p><p style="color:blue;">虽然mysql服务器允许使用set default，但innodb拒绝使用set default。innodb tables不允许使用此子句创建table和alter table语句。</p></li><li class="listitem"><p>
                            If there are several rows in the parent table that have the
                            same referenced key value, <code class="literal">InnoDB</code> acts in
                            foreign key checks as if the other parent rows with the same
                            key value do not exist. For example, if you have defined a
                            <code class="literal">RESTRICT</code> type constraint, and there is a
                            child row with several parent rows,
                            <code class="literal">InnoDB</code> does not permit the deletion of
                            any of those parent rows.
                        </p><p style="color:blue;">如果父表中有多个行具有相同的引用键值，则在外键检查中，子进程充当相同键值的其他父行不存在。例如，如果您定义了一个限制类型约束，并且有一个子行有多个父行，那么innodb不允许删除这些父行中的任何一个。</p></li><li class="listitem"><p>
                            <code class="literal">InnoDB</code> performs cascading operations
                            through a depth-first algorithm, based on records in the
                            indexes corresponding to the foreign key constraints.
                        </p><p style="color:blue;">innodb基于对应外键约束的索引中的记录，通过深度优先算法执行级联操作。</p></li><li class="listitem"><p>
                            If <code class="literal">ON UPDATE CASCADE</code> or <code class="literal">ON
                            UPDATE SET NULL</code> recurses to update the
                            <span class="emphasis"><em>same table</em></span> it has previously updated
                            during the cascade, it acts like
                            <code class="literal">RESTRICT</code>. This means that you cannot use
                            self-referential <code class="literal">ON UPDATE CASCADE</code> or
                            <code class="literal">ON UPDATE SET NULL</code> operations. This is to
                            prevent infinite loops resulting from cascaded updates. A
                            self-referential <code class="literal">ON DELETE SET NULL</code>, on
                            the other hand, is possible, as is a self-referential
                            <code class="literal">ON DELETE CASCADE</code>. Cascading operations
                            may not be nested more than 15 levels deep.
                        </p><p style="color:blue;">如果on update cascade或on update set null递归更新以前在级联过程中更新过的同一个表，则它的作用类似于restrict。这意味着您不能在update cascade或update set null操作上使用自引用。这是为了防止层叠更新导致无限循环。另一方面，delete上的自引用集null是可能的，delete cascade上的自引用也是可能的。级联操作的嵌套深度不能超过15层。</p></li><li class="listitem"><p>
                            Like MySQL in general, in an SQL statement that inserts,
                            deletes, or updates many rows, <code class="literal">InnoDB</code>
                            checks <code class="literal">UNIQUE</code> and <code class="literal">FOREIGN
                            KEY</code> constraints row-by-row. When performing
                            foreign key checks, <code class="literal">InnoDB</code> sets shared
                            row-level locks on child or parent records it has to look
                            at. <code class="literal">InnoDB</code> checks foreign key constraints
                            immediately; the check is not deferred to transaction
                            commit. According to the SQL standard, the default behavior
                            should be deferred checking. That is, constraints are only
                            checked after the <span class="emphasis"><em>entire SQL statement</em></span>
                            has been processed. Until <code class="literal">InnoDB</code>
                            implements deferred constraint checking, some things are
                            impossible, such as deleting a record that refers to itself
                            using a foreign key.
                        </p><p style="color:blue;">和一般的mysql一样，在插入、删除或更新许多行的sql语句中，innodb会逐行检查唯一和外键约束。在执行外键检查时，innodb会对其必须查看的子记录或父记录设置共享行级锁。innodb立即检查外键约束；检查不会延迟到事务提交。根据sql标准，默认行为应该是延迟检查。也就是说，只有在处理完整个sql语句之后才检查约束。在innodb实现延迟约束检查之前，有些事情是不可能的，比如删除使用外键引用自身的记录。</p></li></ul>
                    </div>

                </div>

                <div class="simplesect">

                    <div class="titlepage">
                        <div>

                            <div class="simple">
                                <h5 class="title"><a name="innodb-foreign-key-generated-columns"></a>Foreign Key Restrictions for Generated Columns and Virtual Indexes</h5>

                            </div>

                        </div>

                    </div>
                    <a class="indexterm" name="idm140286823506752"></a><a class="indexterm" name="idm140286823505264"></a><a class="indexterm" name="idm140286823503776"></a><a class="indexterm" name="idm140286823502320"></a>
                    <div class="itemizedlist">
                        <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                            A foreign key constraint on a stored generated column cannot
                            use <code class="literal">CASCADE</code>, <code class="literal">SET NULL</code>,
                            or <code class="literal">SET DEFAULT</code> as <code class="literal">ON
                            UPDATE</code> referential actions, nor can it use
                            <code class="literal">SET NULL</code> or <code class="literal">SET
                            DEFAULT</code> as <code class="literal">ON DELETE</code>
                            referential actions.
                        </p><p style="color:blue;">存储生成列上的外键约束不能在更新引用操作时使用cascade、set null或set default，也不能在删除引用操作时使用set null或set default。</p></li><li class="listitem"><p>
                            A foreign key constraint on the base column of a stored
                            generated column cannot use <code class="literal">CASCADE</code>,
                            <code class="literal">SET NULL</code>, or <code class="literal">SET
                            DEFAULT</code> as <code class="literal">ON UPDATE</code> or
                            <code class="literal">ON DELETE</code> referential actions.
                        </p><p style="color:blue;">存储的生成列的基列上的外键约束不能使用cascade、set null或set default as on update或on delete引用操作。</p></li><li class="listitem"><p>
                            A foreign key constraint cannot reference a
                            <a class="link" href="glossary.html#glos_virtual_generated_column" title="virtual generated column">virtual
                                generated column</a>.
                        </p><p style="color:blue;">外键约束不能引用虚拟生成的列。</p></li><li class="listitem"><p>
                            Prior to 5.7.16, a foreign key constraint cannot reference a
                            secondary index defined on a virtual generated column.
                        </p><p style="color:blue;">在5.7.16之前，外键约束不能引用在虚拟生成列上定义的辅助索引。</p></li><li class="listitem"><p>
                            In MySQL 5.7.13 and earlier, <code class="literal">InnoDB</code> does
                            not permit defining a foreign key constraint with a
                            cascading referential action on the
                            <a class="link" href="glossary.html#glos_base_column" title="base column">base column</a> of an
                            indexed virtual generated column. This restriction is lifted
                            in MySQL 5.7.14.
                        </p><p style="color:blue;">在mysql 5.7.13和更早版本中，innodb不允许在索引的虚拟生成列的基列上使用级联引用操作定义外键约束。在mysql 5.7.14中取消了这个限制。</p></li><li class="listitem"><p>
                            In MySQL 5.7.13 and earlier, <code class="literal">InnoDB</code> does
                            not permit defining cascading referential actions on
                            non-virtual foreign key columns that are explicitly included
                            in a <a class="link" href="glossary.html#glos_virtual_index" title="virtual index">virtual
                            index</a>. This restriction is lifted in MySQL 5.7.14.
                        </p><p style="color:blue;">在mysql 5.7.13和更早版本中，innodb不允许在显式包含在虚拟索引中的非虚拟外键列上定义级联引用操作。在mysql 5.7.14中取消了这个限制。</p></li></ul>
                    </div>

                </div>

            </div>
            <div class="section">
                <div class="titlepage">
                    <div>
                        <div>
                            <h4 class="title"><a name="innodb-restrictions"></a>14.6.1.6&nbsp;Limits on InnoDB Tables</h4>

                        </div>

                    </div>

                </div>
                <a class="indexterm" name="idm140286823480416"></a><a class="indexterm" name="idm140286823478928"></a><a class="indexterm" name="idm140286823477440"></a><a class="indexterm" name="idm140286823475952"></a><a class="indexterm" name="idm140286823474448"></a><p>
                Limits on <code class="literal">InnoDB</code> tables are described under the
                following topics in this section:
            </p><p style="color:blue;">InnoDB表的限制在本节的以下主题中进行了描述：</p>
                <div class="itemizedlist">
                    <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><a class="xref" href="innodb-storage-engine.html#innodb-maximums-minimums" title="Maximums and Minimums">Maximums and Minimums</a></p><p style="color:blue;">Maximums与最小值</p></li><li class="listitem"><p><a class="xref" href="innodb-storage-engine.html#innodb-table-restrictions" title="Restrictions on InnoDB Tables">Restrictions on InnoDB Tables</a></p><p style="color:blue;">InnoDB表的限制</p></li><li class="listitem"><p><a class="xref" href="innodb-storage-engine.html#innodb-locking-transactions" title="Locking and Transactions">Locking and Transactions</a></p><p style="color:blue;">锁定和交易</p></li></ul>
                </div>

                <div class="warning" style="margin-left: 0.5in; margin-right: 0.5in;">

                    <div class="admon-title">
                        Warning
                    </div>
                    <p>
                        Do <span class="emphasis"><em>not</em></span> convert MySQL system tables in the
                        <code class="literal">mysql</code> database from <code class="literal">MyISAM</code>
                        to <code class="literal">InnoDB</code> tables. This is an unsupported
                        operation. If you do this, MySQL does not restart until you
                        restore the old system tables from a backup or regenerate them
                        by reinitializing the data directory (see
                        <a class="xref" href="installing.html#data-directory-initialization" title="2.10.1&nbsp;Initializing the Data Directory">Section&nbsp;2.10.1, “Initializing the Data Directory”</a>).
                    </p><p style="color:blue;">不要将mysql数据库中的mysql系统表从myisam转换为innodb表。这是不支持的操作。如果这样做，mysql不会重新启动，除非您从备份中还原旧的系统表，或者通过重新初始化数据目录来重新生成它们（请参阅2.10.1节，“初始化数据目录”）。</p>
                </div>
                <div class="warning" style="margin-left: 0.5in; margin-right: 0.5in;">
                    <div class="admon-title">
                        Warning
                    </div>
                    <p>
                        Before using NFS with <code class="literal">InnoDB</code>, review
                        potential issues outlined in <a class="xref" href="optimization.html#disk-issues-nfs" title="Using NFS with MySQL">Using NFS with MySQL</a>.
                    </p><p style="color:blue;">在将nfs与innodb一起使用之前，请查看在将nfs与mysql一起使用中概述的潜在问题。</p>
                </div>
                <div class="simplesect">
                    <div class="titlepage">
                        <div>
                            <div class="simple">
                                <h5 class="title"><a name="innodb-maximums-minimums"></a>Maximums and Minimums</h5>

                            </div>

                        </div>

                    </div>
                    <div class="itemizedlist">
                        <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                            A table can contain a maximum of 1017 columns (raised in
                            MySQL 5.6.9 from the earlier limit of 1000). Virtual
                            generated columns are included in this limit.
                        </p><p style="color:blue;">一个表最多可以包含1017列（在MySQL 5.69中从1000的早期限制中提升）。虚拟生成的列包含在此限制中。</p></li><li class="listitem"><p>
                            A table can contain a maximum of 64
                            <a class="link" href="glossary.html#glos_secondary_index" title="secondary index">secondary
                                indexes</a>.
                        </p><p style="color:blue;">表最多可以包含64个辅助索引。</p></li><li class="listitem"><p>
                            If <a class="link" href="innodb-storage-engine.html#sysvar_innodb_large_prefix"><code class="literal">innodb_large_prefix</code></a> is
                            enabled (the default), the index key prefix limit is 3072
                            bytes for <code class="literal">InnoDB</code> tables that use
                            <code class="literal"><a class="link" href="glossary.html#glos_dynamic_row_format" title="dynamic row format">DYNAMIC</a></code>
                            or
                            <code class="literal"><a class="link" href="glossary.html#glos_compressed_row_format" title="compressed row format">COMPRESSED</a></code>
                            row format. If
                            <a class="link" href="innodb-storage-engine.html#sysvar_innodb_large_prefix"><code class="literal">innodb_large_prefix</code></a> is
                            disabled, the index key prefix limit is 767 bytes for tables
                            of any row format.
                        </p><p style="color:blue;">如果启用innodb_large_prefix（默认值），则对于使用动态或压缩行格式的innodb表，索引键前缀限制为3072字节。如果禁用innodb_large_prefix，则任何行格式的表的索引键前缀限制为767字节。</p><p>
                            <a class="link" href="innodb-storage-engine.html#sysvar_innodb_large_prefix"><code class="literal">innodb_large_prefix</code></a> is
                            deprecated and will be removed in a future release.
                            <a class="link" href="innodb-storage-engine.html#sysvar_innodb_large_prefix"><code class="literal">innodb_large_prefix</code></a> was
                            introduced in MySQL 5.5 to disable large index key prefixes
                            for compatibility with earlier versions of
                            <code class="literal">InnoDB</code> that do not support large index
                            key prefixes.
                        </p><p style="color:blue;">InnoDB_large_前缀已弃用，将在以后的版本中删除。mysql 5.5中引入了innodb_large_前缀，以禁用大索引键前缀，以便与不支持大索引键前缀的早期版本的innodb兼容。</p><p>
                            The index key prefix length limit is 767 bytes for
                            <code class="literal">InnoDB</code> tables that use the
                            <code class="literal"><a class="link" href="glossary.html#glos_redundant_row_format" title="redundant row format">REDUNDANT</a></code>
                            or
                            <code class="literal"><a class="link" href="glossary.html#glos_compact_row_format" title="compact row format">COMPACT</a></code>
                            row format. For example, you might hit this limit with a
                            <a class="link" href="glossary.html#glos_column_prefix" title="column prefix">column prefix</a>
                            index of more than 255 characters on a
                            <code class="literal">TEXT</code> or <code class="literal">VARCHAR</code>
                            column, assuming a <code class="literal">utf8mb3</code> character set
                            and the maximum of 3 bytes for each character.
                        </p><p style="color:blue;">对于使用冗余或压缩行格式的innodb表，索引键前缀长度限制为767字节。例如，您可能在文本或VARCHAR列上以超过255个字符的列前缀索引命中此限制，假设UTF8Mb3字符集和每个字符的最大3字节。</p><p>
                            Attempting to use an index key prefix length that exceeds
                            the limit returns an error. To avoid such errors in
                            replication configurations, avoid enabling
                            <a class="link" href="innodb-storage-engine.html#sysvar_innodb_large_prefix"><code class="literal">innodb_large_prefix</code></a> on the
                            master if it cannot also be enabled on slaves.
                        </p><p style="color:blue;">尝试使用超过限制的索引键前缀长度将返回错误。为了避免复制配置中出现此类错误，如果在从机上也无法启用innodb_large_prefix，请避免在主机上启用该前缀。</p><p>
                            The limits that apply to index key prefixes also apply to
                            full-column index keys.
                        </p><p style="color:blue;">应用于索引键前缀的限制也适用于整列索引键。</p></li><li class="listitem"><p>
                            If you reduce the <code class="literal">InnoDB</code>
                            <a class="link" href="glossary.html#glos_page_size" title="page size">page size</a> to 8KB or
                            4KB by specifying the
                            <a class="link" href="innodb-storage-engine.html#sysvar_innodb_page_size"><code class="literal">innodb_page_size</code></a> option
                            when creating the MySQL instance, the maximum length of the
                            index key is lowered proportionally, based on the limit of
                            3072 bytes for a 16KB page size. That is, the maximum index
                            key length is 1536 bytes when the page size is 8KB, and 768
                            bytes when the page size is 4KB.
                        </p><p style="color:blue;">如果在创建MySQL实例时，通过指定InNudByPage大小选项来将InInDB页面大小减少到8KB或4KB，则索引键的最大长度按16KB页面大小的3072字节的限制成比例地降低。也就是说，当页面大小为8KB时，最大索引键长度为1536字节，当页面大小为4KB时，最大索引长度为768字节。</p></li><li class="listitem"><p>
                            A maximum of 16 columns is permitted for multicolumn
                            indexes. Exceeding the limit returns an error.
                        </p><p style="color:blue;">允许多列索引最多16列。超过限制将返回错误。</p><pre data-lang="sql" class="programlisting">ERROR 1070 (42000): Too many key parts specified; max 16 parts allowed
</pre></li><li class="listitem"><p>
                            The maximum row length, except for variable-length columns
                            (<a class="link" href="data-types.html#binary-varbinary" title="11.4.2&nbsp;The BINARY and VARBINARY Types"><code class="literal">VARBINARY</code></a>,
                            <a class="link" href="data-types.html#char" title="11.4.1&nbsp;The CHAR and VARCHAR Types"><code class="literal">VARCHAR</code></a>,
                            <a class="link" href="data-types.html#blob" title="11.4.3&nbsp;The BLOB and TEXT Types"><code class="literal">BLOB</code></a> and
                            <a class="link" href="data-types.html#blob" title="11.4.3&nbsp;The BLOB and TEXT Types"><code class="literal">TEXT</code></a>), is slightly less than
                            half of a page for 4KB, 8KB, 16KB, and 32KB page sizes. For
                            example, the maximum row length for the default
                            <a class="link" href="innodb-storage-engine.html#sysvar_innodb_page_size"><code class="literal">innodb_page_size</code></a> of 16KB is
                            about 8000 bytes. However, for an <code class="literal">InnoDB</code>
                            page size of 64KB, the maximum row length is approximately
                            16000 bytes. <a class="link" href="data-types.html#blob" title="11.4.3&nbsp;The BLOB and TEXT Types"><code class="literal">LONGBLOB</code></a> and
                            <a class="link" href="data-types.html#blob" title="11.4.3&nbsp;The BLOB and TEXT Types"><code class="literal">LONGTEXT</code></a>
                            columns must be less than 4GB, and the total row length,
                            including <a class="link" href="data-types.html#blob" title="11.4.3&nbsp;The BLOB and TEXT Types"><code class="literal">BLOB</code></a> and
                            <a class="link" href="data-types.html#blob" title="11.4.3&nbsp;The BLOB and TEXT Types"><code class="literal">TEXT</code></a> columns, must be less
                            than 4GB.
                        </p><p style="color:blue;">除了可变长度列（VARBION、VARCHAR、BLUB和文本）之外，最大行长度略小于4KB、8KB、16KB和3KB页大小的页的一半。例如，默认值为0的最大行长度约为8000字节。然而，对于64KB的NYNDB页面大小，最大行长度约为16000字节。longblob和longtext列必须小于4gb，并且包括blob和text列在内的总行长度必须小于4gb。</p><p>
                            If a row is less than half a page long, all of it is stored
                            locally within the page. If it exceeds half a page,
                            variable-length columns are chosen for external off-page
                            storage until the row fits within half a page, as described
                            in <a class="xref" href="innodb-storage-engine.html#innodb-file-space" title="14.12.2&nbsp;File Space Management">Section&nbsp;14.12.2, “File Space Management”</a>.
                        </p><p style="color:blue;">如果行的长度小于半页，则所有行都存储在页的本地。如第14.12.2节“文件空间管理”所述，如果超过半页，则选择可变长度列作为外部页外存储，直到行适合半页。</p></li><li class="listitem"><p>
                            Although <code class="literal">InnoDB</code> supports row sizes larger
                            than 65,535 bytes internally, MySQL itself imposes a
                            row-size limit of 65,535 for the combined size of all
                            columns:
                        </p><p style="color:blue;">尽管innodb在内部支持大于65535字节的行大小，但mysql本身对所有列的组合大小设置了65535的行大小限制：</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>CREATE TABLE t (a VARCHAR(8000), b VARCHAR(10000),</code></strong>
    -&gt; <strong class="userinput"><code>c VARCHAR(10000), d VARCHAR(10000), e VARCHAR(10000),</code></strong>
    -&gt; <strong class="userinput"><code>f VARCHAR(10000), g VARCHAR(10000)) ENGINE=InnoDB;</code></strong>
ERROR 1118 (42000): Row size too large. The maximum row size for the
used table type, not counting BLOBs, is 65535. You have to change some
columns to TEXT or BLOBs
</pre><p>
                            See <a class="xref" href="optimization.html#column-count-limit" title="8.4.7&nbsp;Limits on Table Column Count and Row Size">Section&nbsp;8.4.7, “Limits on Table Column Count and Row Size”</a>.
                        </p><p style="color:blue;">见第8.4.7节，“表格列数和行大小限制”。</p></li><li class="listitem"><p>
                            On some older operating systems, files must be less than
                            2GB. This is not a limitation of <code class="literal">InnoDB</code>
                            itself, but if you require a large tablespace, configure it
                            using several smaller data files rather than one large data
                            file.
                        </p><p style="color:blue;">在一些较旧的操作系统上，文件必须小于2GB。这不是innodb本身的限制，但是如果您需要一个大的表空间，可以使用几个小的数据文件而不是一个大的数据文件来配置它。</p></li><li class="listitem"><p>
                            The combined size of the <code class="literal">InnoDB</code> log files
                            can be up to 512GB.
                        </p><p style="color:blue;">InnoDB日志文件的总大小可达512GB。</p></li><li class="listitem"><p>
                            The minimum tablespace size is slightly larger than 10MB.
                            The maximum tablespace size depends on the
                            <code class="literal">InnoDB</code> page size.
                        </p><p style="color:blue;">最小表空间大小略大于10MB。最大表空间大小取决于NYNDB页面大小。</p>
                            <div class="table">
                                <a name="idm140286823405840"></a><p class="title"><b>Table&nbsp;14.3&nbsp;InnoDB Maximum Tablespace Size</b></p><p style="color:blue;">表14.3πInDB最大表空间大小</p>
                                <div class="table-contents">
                                    <table summary="The maximum tablespace size for each InnoDB page size."><colgroup><col width="40%"><col width="60%"></colgroup><thead><tr>
                                        <th scope="col">InnoDB Page Size</th>
                                        <th scope="col">Maximum Tablespace Size</th>
                                    </tr></thead><tbody><tr>
                                        <td scope="row">4KB</td>
                                        <td>16TB</td>
                                    </tr><tr>
                                        <td scope="row">8KB</td>
                                        <td>32TB</td>
                                    </tr><tr>
                                        <td scope="row">16KB</td>
                                        <td>64TB</td>
                                    </tr><tr>
                                        <td scope="row">32KB</td>
                                        <td>128TB</td>
                                    </tr><tr>
                                        <td scope="row">64KB</td>
                                        <td>256TB</td>
                                    </tr></tbody></table>
                                </div>

                            </div>
                            <br class="table-break"><p>
                                The maximum tablespace size is also the maximum size for a
                                table.
                            </p><p style="color:blue;">最大表空间大小也是表的最大大小。</p></li><li class="listitem"><p>
                            Tablespace files cannot exceed 4GB on Windows 32-bit systems
                            (Bug #80149).
                        </p><p style="color:blue;">在Windows 32位系统上，表空间文件不能超过4GB（错误80149）。</p></li><li class="listitem"><p>
                            The path of a tablespace file, including the file name,
                            cannot exceed the <code class="literal">MAX_PATH</code> limit on
                            Windows. Prior to Windows 10, the
                            <code class="literal">MAX_PATH</code> limit is 260 characters. As of
                            Windows 10, version 1607, <code class="literal">MAX_PATH</code>
                            limitations are removed from common Win32 file and directory
                            functions, but you must enable the new behavior.
                        </p><p style="color:blue;">表空间文件的路径（包括文件名）不能超过Windows上的最大路径限制。在Windows 10之前，最大路径限制为260个字符。从Windows10版本1607开始，从常见的win32文件和目录函数中删除了最大路径限制，但必须启用新行为。</p></li><li class="listitem"><p>
                            <a class="indexterm" name="idm140286823382416"></a>

                            <a class="indexterm" name="idm140286823380928"></a>

                            The default page size in <code class="literal">InnoDB</code> is 16KB.
                            You can increase or decrease the page size by configuring
                            the <a class="link" href="innodb-storage-engine.html#sysvar_innodb_page_size"><code class="literal">innodb_page_size</code></a> option
                            when creating the MySQL instance.
                        </p><p style="color:blue;">innodb的默认页面大小是16kb。在创建mysql实例时，可以通过配置innodb_page_size选项来增加或减少页面大小。</p><p>
                            <code class="literal">ROW_FORMAT=COMPRESSED</code> in the
                            <a class="link" href="glossary.html#glos_barracuda" title="Barracuda">Barracuda</a> file format
                            assumes that the page size is at most 16KB and uses 14-bit
                            pointers.
                        </p><p style="color:blue;">row_format=compressed in the barracuda file format假定页面大小最多为16KB，并使用14位指针。</p><p>
                            32KB and 64KB page sizes are supported, but
                            <code class="literal">ROW_FORMAT=COMPRESSED</code> is unsupported for
                            page sizes greater than 16KB. For both 32KB and 64KB page
                            sizes, the maximum record size is 16KB. For
                            <a class="link" href="innodb-storage-engine.html#sysvar_innodb_page_size"><code class="literal">innodb_page_size=32k</code></a>,
                            extent size is 2MB. For
                            <a class="link" href="innodb-storage-engine.html#sysvar_innodb_page_size"><code class="literal">innodb_page_size=64k</code></a>,
                            extent size is 4MB.
                        </p><p style="color:blue;">支持32KB和64KB的页面大小，但对于大于16KB的页面大小，不支持row_format=compressed。对于32 KB和64KB页面大小，最大记录大小为16KB。对于innodb_page_size=32k，数据块大小为2mb。对于innodb_page_size=64k，数据块大小为4MB。</p><p>
                            A MySQL instance using a particular
                            <code class="literal">InnoDB</code> page size cannot use data files or
                            log files from an instance that uses a different page size.
                        </p><p style="color:blue;">使用特定innodb页面大小的mysql实例不能使用来自使用不同页面大小的实例的数据文件或日志文件。</p></li></ul>
                    </div>

                </div>
                <div class="simplesect">
                    <div class="titlepage">
                        <div>
                            <div class="simple">
                                <h5 class="title"><a name="innodb-table-restrictions"></a>Restrictions on InnoDB Tables</h5>

                            </div>

                        </div>

                    </div>
                    <div class="itemizedlist">
                        <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                            <a class="link" href="sql-syntax.html#analyze-table" title="13.7.2.1&nbsp;ANALYZE TABLE Syntax"><code class="literal">ANALYZE TABLE</code></a> determines
                            index cardinality (as displayed in the
                            <code class="literal">Cardinality</code> column of
                            <a class="link" href="sql-syntax.html#show-index" title="13.7.5.22&nbsp;SHOW INDEX Syntax"><code class="literal">SHOW INDEX</code></a> output) by
                            performing <a class="link" href="glossary.html#glos_random_dive" title="random dive">random
                            dives</a> on each of the index trees and updating index
                            cardinality estimates accordingly. Because these are only
                            estimates, repeated runs of <a class="link" href="sql-syntax.html#analyze-table" title="13.7.2.1&nbsp;ANALYZE TABLE Syntax"><code class="literal">ANALYZE
                            TABLE</code></a> could produce different numbers. This makes
                            <a class="link" href="sql-syntax.html#analyze-table" title="13.7.2.1&nbsp;ANALYZE TABLE Syntax"><code class="literal">ANALYZE TABLE</code></a> fast on
                            <code class="literal">InnoDB</code> tables but not 100% accurate
                            because it does not take all rows into account.
                        </p><p style="color:blue;">analyze table通过对每个索引树执行随机潜水并相应地更新索引基数估计值来确定索引基数（如show index output的基数列所示）。因为这些只是估计值，所以重复运行分析表可能会产生不同的数字。这使得analyze table在innodb tables上运行得很快，但并不是100%准确，因为它没有考虑所有的行。</p><p>
                            You can make the
                            <a class="link" href="glossary.html#glos_statistics" title="statistics">statistics</a> collected
                            by <a class="link" href="sql-syntax.html#analyze-table" title="13.7.2.1&nbsp;ANALYZE TABLE Syntax"><code class="literal">ANALYZE TABLE</code></a> more precise
                            and more stable by turning on the
                            <a class="link" href="innodb-storage-engine.html#sysvar_innodb_stats_persistent"><code class="literal">innodb_stats_persistent</code></a>
                            configuration option, as explained in
                            <a class="xref" href="innodb-storage-engine.html#innodb-persistent-stats" title="14.8.11.1&nbsp;Configuring Persistent Optimizer Statistics Parameters">Section&nbsp;14.8.11.1, “Configuring Persistent Optimizer Statistics Parameters”</a>. When that setting
                            is enabled, it is important to run
                            <a class="link" href="sql-syntax.html#analyze-table" title="13.7.2.1&nbsp;ANALYZE TABLE Syntax"><code class="literal">ANALYZE TABLE</code></a> after major
                            changes to indexed column data, because the statistics are
                            not recalculated periodically (such as after a server
                            restart).
                        </p><p style="color:blue;">打开innodb_stats_persistent configuration选项，可以使analyze table收集的统计信息更精确、更稳定，如14.8.11.1节“配置持久优化器统计参数”所述。如果启用了该设置，则在索引列数据发生重大更改后运行analyze table非常重要，因为统计信息不会定期重新计算（例如在服务器重新启动后）。</p><p>
                            If the persistent statistics setting is enabled, you can
                            change the number of random dives by modifying the
                            <a class="link" href="innodb-storage-engine.html#sysvar_innodb_stats_persistent_sample_pages"><code class="literal">innodb_stats_persistent_sample_pages</code></a>
                            system variable. If the persistent statistics setting is
                            disabled, modify the
                            <a class="link" href="innodb-storage-engine.html#sysvar_innodb_stats_transient_sample_pages"><code class="literal">innodb_stats_transient_sample_pages</code></a>
                            system variable instead.
                        </p><p style="color:blue;">如果启用了persistent statistics设置，则可以通过修改innodb_stats_persistent_sample_pages系统变量来更改随机跳水的次数。如果永久统计设置被禁用，请改为修改innodb_stats_transient_sample_pages系统变量。</p><p>
                            MySQL uses index cardinality estimates in join optimization.
                            If a join is not optimized in the right way, try using
                            <a class="link" href="sql-syntax.html#analyze-table" title="13.7.2.1&nbsp;ANALYZE TABLE Syntax"><code class="literal">ANALYZE TABLE</code></a>. In the few
                            cases that <a class="link" href="sql-syntax.html#analyze-table" title="13.7.2.1&nbsp;ANALYZE TABLE Syntax"><code class="literal">ANALYZE TABLE</code></a> does
                            not produce values good enough for your particular tables,
                            you can use <code class="literal">FORCE INDEX</code> with your queries
                            to force the use of a particular index, or set the
                            <a class="link" href="server-administration.html#sysvar_max_seeks_for_key"><code class="literal">max_seeks_for_key</code></a> system
                            variable to ensure that MySQL prefers index lookups over
                            table scans. See <a class="xref" href="error-handling.html#optimizer-issues" title="B.4.5&nbsp;Optimizer-Related Issues">Section&nbsp;B.4.5, “Optimizer-Related Issues”</a>.
                        </p><p style="color:blue;">mysql在连接优化中使用索引基数估计。如果连接没有以正确的方式优化，请尝试使用analyze table。在少数情况下，analyze table不能为特定的表生成足够好的值，您可以在查询中使用force index来强制使用特定的索引，或者设置max_seeks_for_key系统变量，以确保mysql更喜欢索引查找而不是表扫描。见第B.4.5节“优化器相关问题”。</p></li><li class="listitem"><p>
                            <a class="link" href="sql-syntax.html#show-table-status" title="13.7.5.36&nbsp;SHOW TABLE STATUS Syntax"><code class="literal">SHOW TABLE STATUS</code></a> does not
                            give accurate statistics on <code class="literal">InnoDB</code> tables
                            except for the physical size reserved by the table. The row
                            count is only a rough estimate used in SQL optimization.
                        </p><p style="color:blue;">除了表保留的物理大小之外，show table status不会给出innodb表的准确统计信息。行数只是sql优化中使用的一个粗略估计。</p></li><li class="listitem"><p>
                            <code class="literal">InnoDB</code> does not keep an internal count of
                            rows in a table because concurrent transactions might
                            <span class="quote">“<span class="quote">see</span>”</span> different numbers of rows at the same
                            time. Consequently, <code class="literal">SELECT COUNT(*)</code>
                            statements only count rows visible to the current
                            transaction.
                        </p><p style="color:blue;">InnoDB不在表中保留行的内部计数，因为并发事务可能同时“看到”不同数量的行。因此，select count（*）语句只对当前事务可见的行进行计数。</p><p>
                            For information about how <code class="literal">InnoDB</code>
                            processes <code class="literal">SELECT COUNT(*)</code> statements,
                            refer to the <a class="link" href="functions.html#function_count"><code class="literal">COUNT()</code></a>
                            description in <a class="xref" href="functions.html#group-by-functions" title="12.20.1&nbsp;Aggregate (GROUP BY) Function Descriptions">Section&nbsp;12.20.1, “Aggregate (GROUP BY) Function Descriptions”</a>.
                        </p><p style="color:blue;">有关innodb进程如何选择count（*）语句的信息，请参阅12.20.1节“聚合（分组）函数描述”中的count（）描述。</p></li><li class="listitem"><p>
                            On Windows, <code class="literal">InnoDB</code> always stores database
                            and table names internally in lowercase. To move databases
                            in a binary format from Unix to Windows or from Windows to
                            Unix, create all databases and tables using lowercase names.
                        </p><p style="color:blue;">在windows上，innodb总是在内部以小写形式存储数据库和表名。要将二进制格式的数据库从unix移动到windows或从windows移动到unix，请使用小写名称创建所有数据库和表。</p></li><li class="listitem"><p>
                            An <code class="literal">AUTO_INCREMENT</code> column
                            <em class="replaceable"><code>ai_col</code></em> must be defined as part of
                            an index such that it is possible to perform the equivalent
                            of an indexed <code class="literal">SELECT
                            MAX(<em class="replaceable"><code>ai_col</code></em>)</code> lookup on
                            the table to obtain the maximum column value. Typically,
                            this is achieved by making the column the first column of
                            some table index.
                        </p><p style="color:blue;">AutoSype增量列AIO-COL必须定义为索引的一部分，以便在表上执行索引选择MAX（AIAO-COL）查找的等价物，以获得最大列值。通常，这是通过使列成为某个表索引的第一列来实现的。</p></li><li class="listitem"><p>
                            <code class="literal">InnoDB</code> sets an exclusive lock on the end
                            of the index associated with the
                            <code class="literal">AUTO_INCREMENT</code> column while initializing
                            a previously specified <code class="literal">AUTO_INCREMENT</code>
                            column on a table.
                        </p><p style="color:blue;">innodb在初始化表上先前指定的auto_increment列时，在与auto_increment列关联的索引末尾设置一个独占锁。</p><p>
                            With
                            <a class="link" href="innodb-storage-engine.html#sysvar_innodb_autoinc_lock_mode"><code class="literal">innodb_autoinc_lock_mode=0</code></a>,
                            <code class="literal">InnoDB</code> uses a special
                            <code class="literal">AUTO-INC</code> table lock mode where the lock
                            is obtained and held to the end of the current SQL statement
                            while accessing the auto-increment counter. Other clients
                            cannot insert into the table while the
                            <code class="literal">AUTO-INC</code> table lock is held. The same
                            behavior occurs for <span class="quote">“<span class="quote">bulk inserts</span>”</span> with
                            <a class="link" href="innodb-storage-engine.html#sysvar_innodb_autoinc_lock_mode"><code class="literal">innodb_autoinc_lock_mode=1</code></a>.
                            Table-level <code class="literal">AUTO-INC</code> locks are not used
                            with
                            <a class="link" href="innodb-storage-engine.html#sysvar_innodb_autoinc_lock_mode"><code class="literal">innodb_autoinc_lock_mode=2</code></a>.
                            For more information, See
                            <a class="xref" href="innodb-storage-engine.html#innodb-auto-increment-handling" title="14.6.1.4&nbsp;AUTO_INCREMENT Handling in InnoDB">Section&nbsp;14.6.1.4, “AUTO_INCREMENT Handling in InnoDB”</a>.
                        </p><p style="color:blue;">在innodb_auto inc_lock_mode=0的情况下，innodb使用一种特殊的auto-inc table lock模式，在这种模式下，在访问自动递增计数器时，锁被获取并保持到当前sql语句的末尾。持有auto-inc表锁时，其他客户端无法插入到表中。对于innodb_autoinc_lock_mode=1的“批量插入”，也会出现同样的行为。表级auto-inc锁不与innodb_autoinc_lock_mode=2一起使用。有关更多信息，请参阅第14.6.1.4节“InnoDB中的自动增量处理”。</p></li><li class="listitem"><p>
                            When you restart the MySQL server, <code class="literal">InnoDB</code>
                            may reuse an old value that was generated for an
                            <code class="literal">AUTO_INCREMENT</code> column but never stored
                            (that is, a value that was generated during an old
                            transaction that was rolled back).
                        </p><p style="color:blue;">重新启动mysql服务器时，innodb可能会重用为自动递增列生成但从未存储的旧值（即在回滚旧事务期间生成的值）。</p></li><li class="listitem"><p>
                            When an <code class="literal">AUTO_INCREMENT</code> integer column
                            runs out of values, a subsequent <code class="literal">INSERT</code>
                            operation returns a duplicate-key error. This is general
                            MySQL behavior.
                        </p><p style="color:blue;">当自动递增整数列的值用完时，后续的插入操作将返回重复的键错误。这是一般的mysql行为。</p></li><li class="listitem"><p>
                            <code class="literal">DELETE FROM
                                <em class="replaceable"><code>tbl_name</code></em></code> does not
                            regenerate the table but instead deletes all rows, one by
                            one.
                        </p><p style="color:blue;">delete from tbl_name不重新生成表，而是逐个删除所有行。</p></li><li class="listitem"><p>
                            Cascaded foreign key actions do not activate triggers.
                        </p><p style="color:blue;">级联外键操作不会激活触发器。</p></li><li class="listitem"><p>
                            You cannot create a table with a column name that matches
                            the name of an internal <code class="literal">InnoDB</code> column
                            (including <code class="literal">DB_ROW_ID</code>,
                            <code class="literal">DB_TRX_ID</code>,
                            <code class="literal">DB_ROLL_PTR</code>, and
                            <code class="literal">DB_MIX_ID</code>). This restriction applies to
                            use of the names in any letter case.
                        </p><p style="color:blue;">不能使用与内部innodb列名称匹配的列名创建表（包括db_row_id、db_trx_id、db_roll_ptr和db_mix_id）。此限制适用于在任何字母情况下使用名称。</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>CREATE TABLE t1 (c1 INT, db_row_id INT) ENGINE=INNODB;</code></strong>
ERROR 1166 (42000): Incorrect column name 'db_row_id'
</pre></li></ul>
                    </div>

                </div>
                <div class="simplesect">
                    <div class="titlepage">
                        <div>
                            <div class="simple">
                                <h5 class="title"><a name="innodb-locking-transactions"></a>Locking and Transactions</h5>

                            </div>

                        </div>

                    </div>
                    <div class="itemizedlist">
                        <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                            <a class="link" href="sql-syntax.html#lock-tables" title="13.3.5&nbsp;LOCK TABLES and UNLOCK TABLES Syntax"><code class="literal">LOCK TABLES</code></a> acquires two
                            locks on each table if
                            <code class="literal">innodb_table_locks=1</code> (the default). In
                            addition to a table lock on the MySQL layer, it also
                            acquires an <code class="literal">InnoDB</code> table lock. Versions
                            of MySQL before 4.1.2 did not acquire
                            <code class="literal">InnoDB</code> table locks; the old behavior can
                            be selected by setting
                            <code class="literal">innodb_table_locks=0</code>. If no
                            <code class="literal">InnoDB</code> table lock is acquired,
                            <a class="link" href="sql-syntax.html#lock-tables" title="13.3.5&nbsp;LOCK TABLES and UNLOCK TABLES Syntax"><code class="literal">LOCK TABLES</code></a> completes even if
                            some records of the tables are being locked by other
                            transactions.
                        </p><p style="color:blue;">如果innodb_table_locks=1（默认值），锁表在每个表上获取两个锁。除了mysql层上的表锁之外，它还获取innodb表锁。4.1.2之前的MySQL版本没有获取InnoDB表锁，可以通过设置InnoDB表锁=0来选择旧的行为。如果没有获取innodb table lock，那么即使表的某些记录被其他事务锁定，锁表也会完成。</p><p>
                            In MySQL 5.7,
                            <a class="link" href="innodb-storage-engine.html#sysvar_innodb_table_locks"><code class="literal">innodb_table_locks=0</code></a> has no
                            effect for tables locked explicitly with
                            <a class="link" href="sql-syntax.html#lock-tables" title="13.3.5&nbsp;LOCK TABLES and UNLOCK TABLES Syntax"><code class="literal">LOCK TABLES ...
                                WRITE</code></a>. It does have an effect for tables locked
                            for read or write by
                            <a class="link" href="sql-syntax.html#lock-tables" title="13.3.5&nbsp;LOCK TABLES and UNLOCK TABLES Syntax"><code class="literal">LOCK TABLES ...
                                WRITE</code></a> implicitly (for example, through triggers)
                            or by <a class="link" href="sql-syntax.html#lock-tables" title="13.3.5&nbsp;LOCK TABLES and UNLOCK TABLES Syntax"><code class="literal">LOCK
                            TABLES ... READ</code></a>.
                        </p><p style="color:blue;">在mysql 5.7中，innodb_table_locks=0对用锁表显式锁定的表没有影响…写。它确实对为读或写而锁定的表有影响…隐式写入（例如，通过触发器）或通过锁表写入…阅读。</p></li><li class="listitem"><p>
                            All <code class="literal">InnoDB</code> locks held by a transaction
                            are released when the transaction is committed or aborted.
                            Thus, it does not make much sense to invoke
                            <a class="link" href="sql-syntax.html#lock-tables" title="13.3.5&nbsp;LOCK TABLES and UNLOCK TABLES Syntax"><code class="literal">LOCK TABLES</code></a> on
                            <code class="literal">InnoDB</code> tables in
                            <a class="link" href="server-administration.html#sysvar_autocommit"><code class="literal">autocommit=1</code></a> mode because
                            the acquired <code class="literal">InnoDB</code> table locks would be
                            released immediately.
                        </p><p style="color:blue;">当事务被提交或中止时，事务持有的所有innodb锁都会被释放。因此，在autocommit=1模式下调用innodb表上的锁表没有多大意义，因为获取的innodb表锁将立即被释放。</p></li><li class="listitem"><p>
                            You cannot lock additional tables in the middle of a
                            transaction because <a class="link" href="sql-syntax.html#lock-tables" title="13.3.5&nbsp;LOCK TABLES and UNLOCK TABLES Syntax"><code class="literal">LOCK
                            TABLES</code></a> performs an implicit
                            <a class="link" href="sql-syntax.html#commit" title="13.3.1&nbsp;START TRANSACTION, COMMIT, and ROLLBACK Syntax"><code class="literal">COMMIT</code></a> and
                            <a class="link" href="sql-syntax.html#lock-tables" title="13.3.5&nbsp;LOCK TABLES and UNLOCK TABLES Syntax"><code class="literal">UNLOCK
                                TABLES</code></a>.
                        </p><p style="color:blue;">不能在事务中间锁定其他表，因为锁定表执行隐式提交和解锁表。</p></li><li class="listitem"><p>
                            For limits associated with concurrent read-write
                            transactions, see <a class="xref" href="innodb-storage-engine.html#innodb-undo-logs" title="14.6.7&nbsp;Undo Logs">Section&nbsp;14.6.7, “Undo Logs”</a>.
                        </p><p style="color:blue;">有关并发读写事务的限制，请参阅14.6.7节“撤消日志”。</p></li></ul>
                    </div>

                </div>

            </div>

        </div>
        <div class="section">
            <div class="titlepage">
                <div>
                    <div>
                        <h3 class="title"><a name="innodb-indexes"></a>14.6.2&nbsp;Indexes</h3>

                    </div>

                </div>

            </div>
            <div class="toc">
                <dl class="toc"><dt><span class="section"><a href="innodb-storage-engine.html#innodb-index-types">14.6.2.1 Clustered and Secondary Indexes</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-physical-structure">14.6.2.2 The Physical Structure of an InnoDB Index</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#sorted-index-builds">14.6.2.3 Sorted Index Builds</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-fulltext-index">14.6.2.4 InnoDB FULLTEXT Indexes</a></span></dt></dl>
            </div>
            <p>
                This section covers topics related to <code class="literal">InnoDB</code>
                indexes.
            </p><p style="color:blue;">本节介绍与innodb索引相关的主题。</p>
            <div class="section">

                <div class="titlepage">
                    <div>
                        <div>
                            <h4 class="title"><a name="innodb-index-types"></a>14.6.2.1&nbsp;Clustered and Secondary Indexes</h4>
                        </div>
                    </div>
                </div>
                <a class="indexterm" name="idm140286823273360"></a><a class="indexterm" name="idm140286823271904"></a><a class="indexterm" name="idm140286823270416"></a><a class="indexterm" name="idm140286823268928"></a><p>
                Every <code class="literal">InnoDB</code> table has a special index called
                the <a class="link" href="glossary.html#glos_clustered_index" title="clustered index">clustered index</a>
                where the data for the rows is stored. Typically, the clustered
                index is synonymous with the
                <a class="link" href="glossary.html#glos_primary_key" title="primary key">primary key</a>. To get the
                best performance from queries, inserts, and other database
                operations, you must understand how <code class="literal">InnoDB</code> uses
                the clustered index to optimize the most common lookup and DML
                operations for each table.
            </p><p style="color:blue;">每个innodb表都有一个称为聚集索引的特殊索引，其中存储了行的数据。通常，聚集索引是主键的同义词。为了从查询、插入和其他数据库操作中获得最佳性能，您必须了解innodb如何使用聚集索引来优化每个表最常见的查找和dml操作。</p>
                <div class="itemizedlist">
                    <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                        When you define a <code class="literal">PRIMARY KEY</code> on your
                        table, <code class="literal">InnoDB</code> uses it as the clustered
                        index. Define a primary key for each table that you create. If
                        there is no logical unique and non-null column or set of
                        columns, add a new
                        <a class="link" href="glossary.html#glos_auto_increment" title="auto-increment">auto-increment</a>
                        column, whose values are filled in automatically.
                    </p><p style="color:blue;">在表上定义主键时，innodb将其用作聚集索引。为创建的每个表定义主键。如果没有逻辑唯一且非空的列或列集，请添加一个新的自动递增列，其值将自动填充。</p></li><li class="listitem"><p>
                        If you do not define a <code class="literal">PRIMARY KEY</code> for your
                        table, MySQL locates the first <code class="literal">UNIQUE</code> index
                        where all the key columns are <code class="literal">NOT NULL</code> and
                        <code class="literal">InnoDB</code> uses it as the clustered index.
                    </p><p style="color:blue;">如果不为表定义主键，mysql会查找第一个唯一索引，其中所有键列都不为空，innodb会将其用作聚集索引。</p></li><li class="listitem"><p>
                        If the table has no <code class="literal">PRIMARY KEY</code> or suitable
                        <code class="literal">UNIQUE</code> index, <code class="literal">InnoDB</code>
                        internally generates a hidden clustered index named
                        <code class="literal">GEN_CLUST_INDEX</code> on a synthetic column
                        containing row ID values. The rows are ordered by the ID that
                        <code class="literal">InnoDB</code> assigns to the rows in such a table.
                        The row ID is a 6-byte field that increases monotonically as
                        new rows are inserted. Thus, the rows ordered by the row ID
                        are physically in insertion order.
                    </p><p style="color:blue;">如果表没有主键或合适的唯一索引，innodb会在包含行id值的合成列上内部生成一个名为gen_clust_index的隐藏聚集索引。这些行按innodb分配给此类表中的行的id排序。行id是一个6字节的字段，随着新行的插入而单调增加。因此，按行id排序的行实际上是按插入顺序排列的。</p></li></ul>
                </div>
                <div class="simplesect">
                    <div class="titlepage">
                        <div>
                            <div class="simple">
                                <h5 class="title"><a name="innodb-index-types-query-performance"></a>How the Clustered Index Speeds Up Queries</h5>

                            </div>

                        </div>

                    </div>
                    <p>
                        Accessing a row through the clustered index is fast because the
                        index search leads directly to the page with all the row data.
                        If a table is large, the clustered index architecture often
                        saves a disk I/O operation when compared to storage
                        organizations that store row data using a different page from
                        the index record.
                    </p><p style="color:blue;">通过聚集索引访问行很快，因为索引搜索直接指向包含所有行数据的页面。如果表很大，与使用索引记录的不同页存储行数据的存储组织相比，聚集索引体系结构通常会保存磁盘I/O操作。</p>
                </div>
                <div class="simplesect">
                    <div class="titlepage">
                        <div>
                            <div class="simple">
                                <h5 class="title"><a name="innodb-index-types-secondary-clustered"></a>How Secondary Indexes Relate to the Clustered Index</h5>

                            </div>

                        </div>

                    </div>
                    <p>
                        All indexes other than the clustered index are known as
                        <a class="link" href="glossary.html#glos_secondary_index" title="secondary index">secondary indexes</a>.
                        In <code class="literal">InnoDB</code>, each record in a secondary index
                        contains the primary key columns for the row, as well as the
                        columns specified for the secondary index.
                        <code class="literal">InnoDB</code> uses this primary key value to search
                        for the row in the clustered index.
                    </p><p style="color:blue;">除聚集索引以外的所有索引都称为辅助索引。在innodb中，二级索引中的每条记录都包含行的主键列，以及为二级索引指定的列。innodb使用这个主键值来搜索聚集索引中的行。</p><p>
                    If the primary key is long, the secondary indexes use more
                    space, so it is advantageous to have a short primary key.
                </p><p style="color:blue;">如果主键是长的，则次索引使用更多的空间，因此主键较短是有利的。</p><p>
                    For guidelines to take advantage of <code class="literal">InnoDB</code>
                    clustered and secondary indexes, see
                    <a class="xref" href="optimization.html#optimization-indexes" title="8.3&nbsp;Optimization and Indexes">Section&nbsp;8.3, “Optimization and Indexes”</a>.
                </p><p style="color:blue;">有关利用innodb集群索引和二级索引的指南，请参阅8.3节“优化和索引”。</p>
                </div>

            </div>
            <div class="section">
                <div class="titlepage">
                    <div>
                        <div>
                            <h4 class="title"><a name="innodb-physical-structure"></a>14.6.2.2&nbsp;The Physical Structure of an InnoDB Index</h4>

                        </div>

                    </div>

                </div>
                <a class="indexterm" name="idm140286823241088"></a><a class="indexterm" name="idm140286823239632"></a><a class="indexterm" name="idm140286823238144"></a><a class="indexterm" name="idm140286823236656"></a><a class="indexterm" name="idm140286823235584"></a><p>
                With the exception of spatial indexes, <code class="literal">InnoDB</code>
                indexes are <a class="link" href="glossary.html#glos_b_tree" title="B-tree">B-tree</a> data
                structures. Spatial indexes use
                <a class="link" href="glossary.html#glos_r_tree" title="R-tree">R-trees</a>, which are specialized
                data structures for indexing multi-dimensional data. Index records
                are stored in the leaf pages of their B-tree or R-tree data
                structure. The default size of an index page is 16KB.
            </p><p style="color:blue;">除了空间索引之外，innodb索引都是b树数据结构。空间索引使用R树，这些树是索引多维数据的专用数据结构。索引记录存储在其b树或r树数据结构的叶页中。索引页的默认大小为16KB。</p><p>
                When new records are inserted into an <code class="literal">InnoDB</code>
                <a class="link" href="glossary.html#glos_clustered_index" title="clustered index">clustered index</a>,
                <code class="literal">InnoDB</code> tries to leave 1/16 of the page free for
                future insertions and updates of the index records. If index
                records are inserted in a sequential order (ascending or
                descending), the resulting index pages are about 15/16 full. If
                records are inserted in a random order, the pages are from 1/2 to
                15/16 full.
            </p><p style="color:blue;">当新的记录被插入到innodb聚集索引中时，innodb试图保留页面的1/16空间，以便将来插入和更新索引记录。如果按顺序（升序或降序）插入索引记录，则生成的索引页大约为15/16。如果以随机顺序插入记录，则页面从1/2到15/16。</p><p>
                <code class="literal">InnoDB</code> performs a bulk load when creating or
                rebuilding B-tree indexes. This method of index creation is known
                as a sorted index build. The
                <a class="link" href="innodb-storage-engine.html#sysvar_innodb_fill_factor"><code class="literal">innodb_fill_factor</code></a> configuration
                option defines the percentage of space on each B-tree page that is
                filled during a sorted index build, with the remaining space
                reserved for future index growth. Sorted index builds are not
                supported for spatial indexes. For more information, see
                <a class="xref" href="innodb-storage-engine.html#sorted-index-builds" title="14.6.2.3&nbsp;Sorted Index Builds">Section&nbsp;14.6.2.3, “Sorted Index Builds”</a>. An
                <a class="link" href="innodb-storage-engine.html#sysvar_innodb_fill_factor"><code class="literal">innodb_fill_factor</code></a> setting of 100
                leaves 1/16 of the space in clustered index pages free for future
                index growth.
            </p><p style="color:blue;">innodb在创建或重建b树索引时执行大容量加载。这种索引创建方法称为排序索引构建。innodb_fill_factor configuration选项定义了在排序索引构建期间填充的每个b树页面上的空间百分比，剩余空间保留用于将来索引增长。空间索引不支持排序索引生成。有关更多信息，请参见第14.6.2.3节“排序索引生成”。如果innodb_fill_factor设置为100，则聚集索引页中的1/16空间可供将来索引增长使用。</p><p>
                If the fill factor of an <code class="literal">InnoDB</code> index page
                drops below the <code class="literal">MERGE_THRESHOLD</code>, which is 50%
                by default if not specified, <code class="literal">InnoDB</code> tries to
                contract the index tree to free the page. The
                <code class="literal">MERGE_THRESHOLD</code> setting applies to both B-tree
                and R-tree indexes. For more information, see
                <a class="xref" href="innodb-storage-engine.html#index-page-merge-threshold" title="14.8.12&nbsp;Configuring the Merge Threshold for Index Pages">Section&nbsp;14.8.12, “Configuring the Merge Threshold for Index Pages”</a>.
            </p><p style="color:blue;">如果innodb索引页的填充因子低于merge_阈值（如果未指定，默认为50%），innodb将尝试收缩索引树以释放该页。merge_threshold设置同时适用于b-tree和r-tree索引。有关更多信息，请参阅14.8.12节，“为索引页配置合并阈值”。</p><p>
                You can define the <a class="link" href="glossary.html#glos_page_size" title="page size">page size</a>
                for all <code class="literal">InnoDB</code> tablespaces in a MySQL instance
                by setting the <a class="link" href="innodb-storage-engine.html#sysvar_innodb_page_size"><code class="literal">innodb_page_size</code></a>
                configuration option prior to initializing the MySQL instance.
                Once the page size for an instance is defined, you cannot change
                it without reinitializing the instance. Supported sizes are 64KB,
                32KB, 16KB (default), 8KB, and 4KB.
            </p><p style="color:blue;">通过在初始化mysql实例之前设置innodb页面大小配置选项，可以为mysql实例中的所有innodb表空间定义页面大小。一旦定义了实例的页面大小，就不能在不重新初始化实例的情况下对其进行更改。支持的大小为64KB、32KB、16KB（默认）、8KB和4KB。</p><p>
                Support for 32KB and 64KB pages sizes was added in MySQL
                5.7. For more information, refer to the
                <a class="link" href="innodb-storage-engine.html#sysvar_innodb_page_size"><code class="literal">innodb_page_size</code></a> documentation.
            </p><p style="color:blue;">mysql 5.7增加了对32kb和64kb页面大小的支持。有关更多信息，请参阅innodb_page_size文档。</p><p>
                A MySQL instance using a particular <code class="literal">InnoDB</code> page
                size cannot use data files or log files from an instance that uses
                a different page size.
            </p><p style="color:blue;">使用特定innodb页面大小的mysql实例不能使用来自使用不同页面大小的实例的数据文件或日志文件。</p>
            </div>
            <div class="section">
                <div class="titlepage">
                    <div>
                        <div>
                            <h4 class="title"><a name="sorted-index-builds"></a>14.6.2.3&nbsp;Sorted Index Builds</h4>

                        </div>

                    </div>

                </div>
                <a class="indexterm" name="idm140286823211632"></a><a class="indexterm" name="idm140286823210144"></a><p>
                <code class="literal">InnoDB</code> performs a bulk load instead of
                inserting one index record at a time when creating or rebuilding
                indexes. This method of index creation is also known as a sorted
                index build. Sorted index builds are not supported for spatial
                indexes.
            </p><p style="color:blue;">innodb在创建或重建索引时执行大容量加载，而不是一次插入一条索引记录。这种索引创建方法也称为排序索引构建。空间索引不支持排序索引生成。</p><p>
                There are three phases to an index build. In the first phase, the
                <a class="link" href="glossary.html#glos_clustered_index" title="clustered index">clustered index</a> is
                scanned, and index entries are generated and added to the sort
                buffer. When the <a class="link" href="glossary.html#glos_sort_buffer" title="sort buffer">sort
                buffer</a> becomes full, entries are sorted and written out to
                a temporary intermediate file. This process is also known as a
                <span class="quote">“<span class="quote">run</span>”</span>. In the second phase, with one or more runs
                written to the temporary intermediate file, a merge sort is
                performed on all entries in the file. In the third and final
                phase, the sorted entries are inserted into the
                <a class="link" href="glossary.html#glos_b_tree" title="B-tree">B-tree</a>.
            </p><p style="color:blue;">索引构建有三个阶段。在第一阶段，将扫描聚集索引，生成索引项并将其添加到排序缓冲区。当排序缓冲区已满时，将对条目进行排序并将其写入临时中间文件。这个过程也被称为“运行”。在第二阶段，当一个或多个运行写入临时中间文件时，对文件中的所有条目执行合并排序。在第三个也是最后一个阶段，排序后的条目被插入到b树中。</p><p>
                Prior to the introduction of sorted index builds, index entries
                were inserted into the B-tree one record at a time using insert
                APIs. This method involved opening a B-tree
                <a class="link" href="glossary.html#glos_cursor" title="cursor">cursor</a> to find the insert
                position and then inserting entries into a B-tree page using an
                <a class="link" href="glossary.html#glos_optimistic" title="optimistic">optimistic</a> insert. If an
                insert failed due to a page being full, a
                <a class="link" href="glossary.html#glos_pessimistic" title="pessimistic">pessimistic</a> insert would
                be performed, which involves opening a B-tree cursor and splitting
                and merging B-tree nodes as necessary to find space for the entry.
                The drawbacks of this <span class="quote">“<span class="quote">top-down</span>”</span> method of building
                an index are the cost of searching for an insert position and the
                constant splitting and merging of B-tree nodes.
            </p><p style="color:blue;">在引入排序索引构建之前，使用insertapi一次将索引条目插入到b树一条记录中。此方法涉及打开一个b树光标以找到插入位置，然后使用乐观插入将条目插入到b树页中。如果由于页面已满而导致插入失败，则将执行悲观插入，这涉及打开b树光标，并根据需要拆分和合并b树节点以查找条目空间。这种自顶向下的索引方法的缺点是寻找插入位置的代价，以及b树节点的不断分裂和合并。</p><p>
                Sorted index builds use a <span class="quote">“<span class="quote">bottom-up</span>”</span> approach to
                building an index. With this approach, a reference to the
                right-most leaf page is held at all levels of the B-tree. The
                right-most leaf page at the necessary B-tree depth is allocated
                and entries are inserted according to their sorted order. Once a
                leaf page is full, a node pointer is appended to the parent page
                and a sibling leaf page is allocated for the next insert. This
                process continues until all entries are inserted, which may result
                in inserts up to the root level. When a sibling page is allocated,
                the reference to the previously pinned leaf page is released, and
                the newly allocated leaf page becomes the right-most leaf page and
                new default insert location.
            </p><p style="color:blue;">排序索引构建使用“自下而上”的方法来构建索引。使用这种方法，对最右边的叶页的引用将保存在b树的所有级别。在必要的b树深度处分配最右边的叶页，并根据其排序顺序插入条目。一旦叶页已满，节点指针将附加到父页，并为下一次插入分配同级叶页。此过程将继续，直到插入所有条目，这可能导致插入到根级别。分配同级页时，将释放对以前固定的叶页的引用，新分配的叶页将成为最右边的叶页和新的默认插入位置。</p>
                <h5><a name="idm140286823197232"></a>Reserving B-tree Page Space for Future Index Growth</h5>
                <p>
                    To set aside space for future index growth, you can use the
                    <a class="link" href="innodb-storage-engine.html#sysvar_innodb_fill_factor"><code class="literal">innodb_fill_factor</code></a> configuration
                    option to reserve a percentage of B-tree page space. For example,
                    setting <a class="link" href="innodb-storage-engine.html#sysvar_innodb_fill_factor"><code class="literal">innodb_fill_factor</code></a> to 80
                    reserves 20 percent of the space in B-tree pages during a sorted
                    index build. This setting applies to both B-tree leaf and non-leaf
                    pages. It does not apply to external pages used for
                    <a class="link" href="data-types.html#blob" title="11.4.3&nbsp;The BLOB and TEXT Types"><code class="literal">TEXT</code></a> or
                    <a class="link" href="data-types.html#blob" title="11.4.3&nbsp;The BLOB and TEXT Types"><code class="literal">BLOB</code></a> entries. The amount of space
                    that is reserved may not be exactly as configured, as the
                    <a class="link" href="innodb-storage-engine.html#sysvar_innodb_fill_factor"><code class="literal">innodb_fill_factor</code></a> value is
                    interpreted as a hint rather than a hard limit.
                </p><p style="color:blue;">要为将来的索引增长留出空间，可以使用innodb_fill_factor配置选项保留一定百分比的b树页面空间。例如，将innodb_fill_factor设置为80可以在排序索引构建期间保留b树页面中20%的空间。此设置同时适用于B树叶页和非叶页。它不适用于用于文本或blob项的外部页。保留的空间量可能与配置的空间量不同，因为innodb_fill_factor值被解释为提示而不是硬限制。</p>
                <h5><a name="idm140286823189296"></a>Sorted Index Builds and Full-Text Index Support</h5>
                <p>
                    Sorted index builds are supported for
                    <a class="link" href="glossary.html#glos_fulltext_index" title="FULLTEXT index">fulltext indexes</a>.
                    Previously, SQL was used to insert entries into a fulltext index.
                </p><p style="color:blue;">全文索引支持排序索引生成。以前，sql用于将条目插入到全文索引中。</p>
                <h5><a name="idm140286823187072"></a>Sorted Index Builds and Compressed Tables</h5>
                <p>
                    For <a class="link" href="glossary.html#glos_compression" title="compression">compressed tables</a>, the
                    previous index creation method appended entries to both compressed
                    and uncompressed pages. When the modification log (representing
                    free space on the compressed page) became full, the compressed
                    page would be recompressed. If compression failed due to a lack of
                    space, the page would be split. With sorted index builds, entries
                    are only appended to uncompressed pages. When an uncompressed page
                    becomes full, it is compressed. Adaptive padding is used to ensure
                    that compression succeeds in most cases, but if compression fails,
                    the page is split and compression is attempted again. This process
                    continues until compression is successful. For more information
                    about compression of B-Tree pages, see
                    <a class="xref" href="innodb-storage-engine.html#innodb-compression-internals" title="14.9.1.5&nbsp;How Compression Works for InnoDB Tables">Section&nbsp;14.9.1.5, “How Compression Works for InnoDB Tables”</a>.
                </p><p style="color:blue;">对于压缩表，以前的索引创建方法将条目追加到压缩页和未压缩页。当修改日志（表示压缩页上的可用空间）已满时，将重新压缩压缩页。如果压缩由于空间不足而失败，则将拆分页。对于排序索引生成，条目仅附加到未压缩的页。当未压缩的页变满时，它将被压缩。自适应填充用于确保在大多数情况下压缩成功，但如果压缩失败，则拆分页面并再次尝试压缩。此过程将继续，直到压缩成功。有关b-tree页面压缩的更多信息，请参阅14.9.1.5节，“如何对innodb表进行压缩”。</p>
                <h5><a name="idm140286823183552"></a>Sorted Index Builds and Redo Logging</h5>
                <p>
                    <a class="link" href="glossary.html#glos_redo_log" title="redo log">Redo logging</a> is disabled
                    during a sorted index build. Instead, there is a
                    <a class="link" href="glossary.html#glos_checkpoint" title="checkpoint">checkpoint</a> to ensure that
                    the index build can withstand a crash or failure. The checkpoint
                    forces a write of all dirty pages to disk. During a sorted index
                    build, the <a class="link" href="glossary.html#glos_page_cleaner" title="page cleaner">page cleaner</a>
                    thread is signaled periodically to flush
                    <a class="link" href="glossary.html#glos_dirty_page" title="dirty page">dirty pages</a> to ensure that
                    the checkpoint operation can be processed quickly. Normally, the
                    page cleaner thread flushes dirty pages when the number of clean
                    pages falls below a set threshold. For sorted index builds, dirty
                    pages are flushed promptly to reduce checkpoint overhead and to
                    parallelize I/O and CPU activity.
                </p><p style="color:blue;">在排序索引生成过程中禁用重做日志记录。相反，有一个检查点来确保索引构建能够经受崩溃或失败。检查点强制将所有脏页写入磁盘。在排序索引生成期间，会定期通知页清理器线程刷新脏页，以确保可以快速处理检查点操作。通常，当清除页的数目低于设置的阈值时，页清除线程会清除脏页。对于排序的索引构建，脏页会被迅速刷新，以减少检查点开销并并行化I/O和CPU活动。</p>
                <h5><a name="idm140286823178400"></a>Sorted Index Builds and Optimizer Statistics</h5>
                <p>
                    Sorted index builds may result in
                    <a class="link" href="glossary.html#glos_optimizer" title="optimizer">optimizer</a> statistics that
                    differ from those generated by the previous method of index
                    creation. The difference in statistics, which is not expected to
                    affect workload performance, is due to the different algorithm
                    used to populate the index.
                </p><p style="color:blue;">排序的索引生成可能会导致优化器统计信息不同于以前创建索引的方法生成的统计信息。统计数据的差异预计不会影响工作负载性能，这是由于用于填充索引的算法不同所致。</p>
            </div>
            <div class="section">
                <div class="titlepage">
                    <div>
                        <div>
                            <h4 class="title"><a name="innodb-fulltext-index"></a>14.6.2.4&nbsp;InnoDB FULLTEXT Indexes</h4>

                        </div>

                    </div>

                </div>
                <a class="indexterm" name="idm140286823174896"></a><a class="indexterm" name="idm140286823173408"></a><p>
                <code class="literal">FULLTEXT</code> indexes are created on text-based
                columns (<a class="link" href="data-types.html#char" title="11.4.1&nbsp;The CHAR and VARCHAR Types"><code class="literal">CHAR</code></a>,
                <a class="link" href="data-types.html#char" title="11.4.1&nbsp;The CHAR and VARCHAR Types"><code class="literal">VARCHAR</code></a>, or
                <a class="link" href="data-types.html#blob" title="11.4.3&nbsp;The BLOB and TEXT Types"><code class="literal">TEXT</code></a> columns) to help speed up
                queries and DML operations on data contained within those columns,
                omitting any words that are defined as stopwords.
            </p><p style="color:blue;">全文索引是在基于文本的列（char、varchar或text列）上创建的，有助于加快对这些列中包含的数据的查询和dml操作，省略任何定义为stopwords的单词。</p><p>
                A <code class="literal">FULLTEXT</code> index is defined as part of a
                <a class="link" href="sql-syntax.html#create-table" title="13.1.18&nbsp;CREATE TABLE Syntax"><code class="literal">CREATE TABLE</code></a> statement or added to
                an existing table using <a class="link" href="sql-syntax.html#alter-table" title="13.1.8&nbsp;ALTER TABLE Syntax"><code class="literal">ALTER TABLE</code></a>
                or <a class="link" href="sql-syntax.html#create-index" title="13.1.14&nbsp;CREATE INDEX Syntax"><code class="literal">CREATE INDEX</code></a>.
            </p><p style="color:blue;">FultLeXT索引定义为CREATETABLE语句的一部分，或者使用ALTER表或CREATED索引添加到现有表中。</p><p>
                Full-text search is performed using <a class="link" href="functions.html#function_match"><code class="literal">MATCH()
                ... AGAINST</code></a> syntax. For usage information, see
                <a class="xref" href="functions.html#fulltext-search" title="12.9&nbsp;Full-Text Search Functions">Section&nbsp;12.9, “Full-Text Search Functions”</a>.
            </p><p style="color:blue;">全文搜索是使用match（）执行的…反对语法。有关用法信息，请参见第12.9节“全文搜索功能”。</p><p>
                <code class="literal">InnoDB</code> <code class="literal">FULLTEXT</code> indexes are
                described under the following topics in this section:
            </p><p style="color:blue;">InnoDB全文索引在本节中的以下主题下介绍：</p>
                <div class="itemizedlist">
                    <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><a class="xref" href="innodb-storage-engine.html#innodb-fulltext-index-design" title="InnoDB Full-Text Index Design">InnoDB Full-Text Index Design</a></p><p style="color:blue;">innodb全文索引设计</p></li><li class="listitem"><p><a class="xref" href="innodb-storage-engine.html#innodb-fulltext-index-tables" title="InnoDB Full-Text Index Tables">InnoDB Full-Text Index Tables</a></p><p style="color:blue;">innodb全文索引表</p></li><li class="listitem"><p><a class="xref" href="innodb-storage-engine.html#innodb-fulltext-index-cache" title="InnoDB Full-Text Index Cache">InnoDB Full-Text Index Cache</a></p><p style="color:blue;">InnoDB全文索引缓存</p></li><li class="listitem"><p><a class="xref" href="innodb-storage-engine.html#innodb-fulltext-index-docid" title="InnoDB Full-Text Index Document ID and FTS_DOC_ID Column">InnoDB Full-Text Index Document ID and FTS_DOC_ID Column</a></p><p style="color:blue;">innodb全文索引文档id和fts_doc_id列</p></li><li class="listitem"><p><a class="xref" href="innodb-storage-engine.html#innodb-fulltext-index-deletion" title="InnoDB Full-Text Index Deletion Handling">InnoDB Full-Text Index Deletion Handling</a></p><p style="color:blue;">InnoDB全文索引删除处理</p></li><li class="listitem"><p><a class="xref" href="innodb-storage-engine.html#innodb-fulltext-index-transaction" title="InnoDB Full-Text Index Transaction Handling">InnoDB Full-Text Index Transaction Handling</a></p><p style="color:blue;">InnoDB全文索引事务处理</p></li><li class="listitem"><p><a class="xref" href="innodb-storage-engine.html#innodb-fulltext-index-monitoring" title="Monitoring InnoDB Full-Text Indexes">Monitoring InnoDB Full-Text Indexes</a></p><p style="color:blue;">监视innodb全文索引</p></li></ul>
                </div>

                <div class="simplesect">

                    <div class="titlepage">
                        <div>

                            <div class="simple">
                                <h5 class="title"><a name="innodb-fulltext-index-design"></a>InnoDB Full-Text Index Design</h5>

                            </div>

                        </div>

                    </div>
                    <p>
                        <code class="literal">InnoDB</code> <code class="literal">FULLTEXT</code> indexes
                        have an inverted index design. Inverted indexes store a list of
                        words, and for each word, a list of documents that the word
                        appears in. To support proximity search, position information
                        for each word is also stored, as a byte offset.
                    </p><p style="color:blue;">innodb全文索引采用反向索引设计。反向索引存储一个单词列表，对于每个单词，则存储该单词出现在其中的文档列表。为了支持邻近搜索，还存储每个单词的位置信息，作为字节偏移。</p>
                </div>
                <div class="simplesect">
                    <div class="titlepage">
                        <div>
                            <div class="simple">
                                <h5 class="title"><a name="innodb-fulltext-index-tables"></a>InnoDB Full-Text Index Tables</h5>

                            </div>

                        </div>

                    </div>
                    <p>
                        When creating an <code class="literal">InnoDB</code>
                        <code class="literal">FULLTEXT</code> index, a set of index tables is
                        created, as shown in the following example:
                    </p><p style="color:blue;">创建innodb全文索引时，会创建一组索引表，如下例所示：</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>CREATE TABLE opening_lines (</code></strong>
       <strong class="userinput"><code>id INT UNSIGNED AUTO_INCREMENT NOT NULL PRIMARY KEY,</code></strong>
       <strong class="userinput"><code>opening_line TEXT(500),</code></strong>
       <strong class="userinput"><code>author VARCHAR(200),</code></strong>
       <strong class="userinput"><code>title VARCHAR(200),</code></strong>
       <strong class="userinput"><code>FULLTEXT idx (opening_line)</code></strong>
       <strong class="userinput"><code>) ENGINE=InnoDB;</code></strong>

mysql&gt; <strong class="userinput"><code>SELECT table_id, name, space from INFORMATION_SCHEMA.INNODB_SYS_TABLES</code></strong>
       <strong class="userinput"><code>WHERE name LIKE 'test/%';</code></strong>
+----------+----------------------------------------------------+-------+
| table_id | name                                               | space |
+----------+----------------------------------------------------+-------+
|      333 | test/FTS_0000000000000147_00000000000001c9_INDEX_1 |   289 |
|      334 | test/FTS_0000000000000147_00000000000001c9_INDEX_2 |   290 |
|      335 | test/FTS_0000000000000147_00000000000001c9_INDEX_3 |   291 |
|      336 | test/FTS_0000000000000147_00000000000001c9_INDEX_4 |   292 |
|      337 | test/FTS_0000000000000147_00000000000001c9_INDEX_5 |   293 |
|      338 | test/FTS_0000000000000147_00000000000001c9_INDEX_6 |   294 |
|      330 | test/FTS_0000000000000147_BEING_DELETED            |   286 |
|      331 | test/FTS_0000000000000147_BEING_DELETED_CACHE      |   287 |
|      332 | test/FTS_0000000000000147_CONFIG                   |   288 |
|      328 | test/FTS_0000000000000147_DELETED                  |   284 |
|      329 | test/FTS_0000000000000147_DELETED_CACHE            |   285 |
|      327 | test/opening_lines                                 |   283 |
+----------+----------------------------------------------------+-------+
</pre><p>
                    The first six tables represent the inverted index and are
                    referred to as auxiliary index tables. When incoming documents
                    are tokenized, the individual words (also referred to as
                    <span class="quote">“<span class="quote">tokens</span>”</span>) are inserted into the index tables along
                    with position information and the associated Document ID
                    (<code class="literal">DOC_ID</code>). The words are fully sorted and
                    partitioned among the six index tables based on the character
                    set sort weight of the word's first character.
                </p><p style="color:blue;">前六个表表示倒排索引，称为辅助索引表。当传入文档被标记化时，单个单词（也称为“标记”）连同位置信息和相关文档id（doc_id）一起插入索引表中。根据单词第一个字符的字符集排序权重，在六个索引表中对单词进行完全排序和分区。</p><p>
                    The inverted index is partitioned into six auxiliary index
                    tables to support parallel index creation. By default, two
                    threads tokenize, sort, and insert words and associated data
                    into the index tables. The number of threads is configurable
                    using the
                    <a class="link" href="innodb-storage-engine.html#sysvar_innodb_ft_sort_pll_degree"><code class="literal">innodb_ft_sort_pll_degree</code></a>
                    option. Consider increasing the number of threads when creating
                    <code class="literal">FULLTEXT</code> indexes on large tables.
                </p><p style="color:blue;">将反向索引划分为六个辅助索引表以支持并行索引创建。默认情况下，两个线程将单词和相关数据标记、排序和插入索引表。可以使用innodb-ft-u-sort-pll-u-degree选项配置线程数。在大型表上创建全文索引时，请考虑增加线程数。</p><p>
                    Auxiliary index table names are prefixed with
                    <code class="literal">FTS_</code> and postfixed with
                    <code class="literal">INDEX_*</code>. Each index table is associated with
                    the indexed table by a hex value in the index table name that
                    matches the <code class="literal">table_id</code> of the indexed table.
                    For example, the <code class="literal">table_id</code> of the
                    <code class="literal">test/opening_lines</code> table is
                    <code class="literal">327</code>, for which the hex value is 0x147. As
                    shown in the preceding example, the <span class="quote">“<span class="quote">147</span>”</span> hex value
                    appears in the names of index tables that are associated with
                    the <code class="literal">test/opening_lines</code> table.
                </p><p style="color:blue;">辅助索引表名称用FTS1前缀，索引为后缀**。每个索引表通过索引表名称中与索引表的表id匹配的十六进制值与索引表相关联。例如，test/opening_lines表的table_id为327，十六进制值为0x147。如前例所示，“147”十六进制值出现在与test/opening_lines表关联的索引表的名称中。</p><p>
                    A hex value representing the <code class="literal">index_id</code> of the
                    <code class="literal">FULLTEXT</code> index also appears in auxiliary
                    index table names. For example, in the auxiliary table name
                    <code class="literal">test/FTS_0000000000000147_00000000000001c9_INDEX_1</code>,
                    the hex value <code class="literal">1c9</code> has a decimal value of 457.
                    The index defined on the <code class="literal">opening_lines</code> table
                    (<code class="literal">idx</code>) can be identified by querying the
                    <a class="link" href="information-schema.html#innodb-sys-indexes-table" title="24.32.21&nbsp;The INFORMATION_SCHEMA INNODB_SYS_INDEXES Table"><code class="literal">INFORMATION_SCHEMA.INNODB_SYS_INDEXES</code></a>
                    table for this value (457).
                </p><p style="color:blue;">表示全文索引的索引xxx的十六进制值也出现在辅助索引表名称中。例如，在辅助表名Test/FTSH 0000000000000 147My 0000000000000 1C9I索引X1中，十六进制值1C9具有457的十进制值。在opening_lines表（idx）上定义的索引可以通过查询information_schema.innodb_sys_indexes表来识别该值（457）。</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT index_id, name, table_id, space from INFORMATION_SCHEMA.INNODB_SYS_INDEXES</code></strong>
       <strong class="userinput"><code>WHERE index_id=457;</code></strong>
+----------+------+----------+-------+
| index_id | name | table_id | space |
+----------+------+----------+-------+
|      457 | idx  |      327 |   283 |
+----------+------+----------+-------+
</pre><p>
                    Index tables are stored in their own tablespace if the primary
                    table is created in a
                    <a class="link" href="glossary.html#glos_file_per_table" title="file-per-table">file-per-table</a>
                    tablespace.
                </p><p style="color:blue;">如果主表是在每个表空间的文件中创建的，则索引表存储在它们自己的表空间中。</p><p>
                    The other index tables shown in the preceding example are
                    referred to as common index tables and are used for deletion
                    handling and storing the internal state of
                    <code class="literal">FULLTEXT</code> indexes. Unlike the inverted index
                    tables, which are created for each full-text index, this set of
                    tables is common to all full-text indexes created on a
                    particular table.
                </p><p style="color:blue;">前面示例中显示的其他索引表称为公共索引表，用于删除处理和存储全文索引的内部状态。与为每个全文索引创建的反向索引表不同，这组表对于在特定表上创建的所有全文索引都是通用的。</p><p>
                    Common auxiliary tables are retained even if full-text indexes
                    are dropped. When a full-text index is dropped, the
                    <code class="literal">FTS_DOC_ID</code> column that was created for the
                    index is retained, as removing the <code class="literal">FTS_DOC_ID</code>
                    column would require rebuilding the table. Common axillary
                    tables are required to manage the <code class="literal">FTS_DOC_ID</code>
                    column.
                </p><p style="color:blue;">即使删除全文索引，也可以保留公共辅助表。删除全文索引时，将保留为该索引创建的fts_doc_id列，因为删除fts_doc_id列将需要重建表。需要通用的腋下表来管理FTSXDOXYID列。</p>
                    <div class="itemizedlist">
                        <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                            <code class="literal">FTS_*_DELETED</code> and
                            <code class="literal">FTS_*_DELETED_CACHE</code>
                        </p><p style="color:blue;">已删除fts和fts缓存</p><p>
                            Contain the document IDs (DOC_ID) for documents that are
                            deleted but whose data is not yet removed from the full-text
                            index. The <code class="literal">FTS_*_DELETED_CACHE</code> is the
                            in-memory version of the <code class="literal">FTS_*_DELETED</code>
                            table.
                        </p><p style="color:blue;">包含已删除但其数据尚未从全文索引中删除的文档的文档ID（文档ID）。fts\u deleted\u缓存是fts\u deleted表的内存版本。</p></li><li class="listitem"><p>
                            <code class="literal">FTS_*_BEING_DELETED</code> and
                            <code class="literal">FTS_*_BEING_DELETED_CACHE</code>
                        </p><p style="color:blue;">已删除fts，已删除fts缓存</p><p>
                            Contain the document IDs (DOC_ID) for documents that are
                            deleted and whose data is currently in the process of being
                            removed from the full-text index. The
                            <code class="literal">FTS_*_BEING_DELETED_CACHE</code> table is the
                            in-memory version of the
                            <code class="literal">FTS_*_BEING_DELETED</code> table.
                        </p><p style="color:blue;">包含已删除且其数据当前正在从全文索引中删除的文档的文档ID（文档ID）。被删除的FTS缓存表是被删除的FTS表的内存版本。</p></li><li class="listitem"><p>
                            <code class="literal">FTS_*_CONFIG</code>
                        </p><p style="color:blue;">FTS配置</p><p>
                            Stores information about the internal state of the
                            <code class="literal">FULLTEXT</code> index. Most importantly, it
                            stores the <code class="literal">FTS_SYNCED_DOC_ID</code>, which
                            identifies documents that have been parsed and flushed to
                            disk. In case of crash recovery,
                            <code class="literal">FTS_SYNCED_DOC_ID</code> values are used to
                            identify documents that have not been flushed to disk so
                            that the documents can be re-parsed and added back to the
                            <code class="literal">FULLTEXT</code> index cache. To view the data in
                            this table, query the
                            <a class="link" href="information-schema.html#innodb-ft-config-table" title="24.32.8&nbsp;The INFORMATION_SCHEMA INNODB_FT_CONFIG Table"><code class="literal">INFORMATION_SCHEMA.INNODB_FT_CONFIG</code></a>
                            table.
                        </p><p style="color:blue;">存储有关全文索引的内部状态的信息。最重要的是，它存储fts_synced_doc_id，该id标识已解析并刷新到磁盘的文档。在崩溃恢复的情况下，fts_synched_doc_id值用于标识尚未刷新到磁盘的文档，以便可以重新分析文档并将其添加回全文索引缓存。要查看此表中的数据，请查询information_schema.innodb_ft_config表。</p></li></ul>
                    </div>

                </div>
                <div class="simplesect">
                    <div class="titlepage">
                        <div>
                            <div class="simple">
                                <h5 class="title"><a name="innodb-fulltext-index-cache"></a>InnoDB Full-Text Index Cache</h5>

                            </div>

                        </div>

                    </div>
                    <p>
                        When a document is inserted, it is tokenized, and the individual
                        words and associated data are inserted into the
                        <code class="literal">FULLTEXT</code> index. This process, even for small
                        documents, could result in numerous small insertions into the
                        auxiliary index tables, making concurrent access to these tables
                        a point of contention. To avoid this problem,
                        <code class="literal">InnoDB</code> uses a <code class="literal">FULLTEXT</code>
                        index cache to temporarily cache index table insertions for
                        recently inserted rows. This in-memory cache structure holds
                        insertions until the cache is full and then batch flushes them
                        to disk (to the auxiliary index tables). You can query the
                        <a class="link" href="information-schema.html#innodb-ft-index-cache-table" title="24.32.11&nbsp;The INFORMATION_SCHEMA INNODB_FT_INDEX_CACHE Table"><code class="literal">INFORMATION_SCHEMA.INNODB_FT_INDEX_CACHE</code></a>
                        table to view tokenized data for recently inserted rows.
                    </p><p style="color:blue;">插入文档时，将对其进行标记化，并将单个单词和相关数据插入到全文索引中。这个过程，即使对于小文档，也可能导致大量的插入辅助索引表，使得并发访问这些表是一个争用点。为了避免这个问题，innodb使用全文索引缓存来临时缓存最近插入的行的索引表插入。这个内存缓存结构保存插入，直到缓存满，然后批量将它们刷新到磁盘（到辅助索引表）。您可以查询information_schema.innodb_ft_index_cache表，查看最近插入行的标记化数据。</p><p>
                    The caching and batch flushing behavior avoids frequent updates
                    to auxiliary index tables, which could result in concurrent
                    access issues during busy insert and update times. The batching
                    technique also avoids multiple insertions for the same word, and
                    minimizes duplicate entries. Instead of flushing each word
                    individually, insertions for the same word are merged and
                    flushed to disk as a single entry, improving insertion
                    efficiency while keeping auxiliary index tables as small as
                    possible.
                </p><p style="color:blue;">缓存和批处理行为避免了对辅助索引表的频繁更新，这会导致在繁忙的插入和更新期间并发访问问题。批处理技术还避免了对同一个单词的多个插入，并将重复项最小化。代替逐个刷新每个单词，将同一单词的插入合并并刷新为单个条目，提高插入效率，同时保持辅助索引表尽可能小。</p><p>
                    The <a class="link" href="innodb-storage-engine.html#sysvar_innodb_ft_cache_size"><code class="literal">innodb_ft_cache_size</code></a>
                    variable is used to configure the full-text index cache size (on
                    a per-table basis), which affects how often the full-text index
                    cache is flushed. You can also define a global full-text index
                    cache size limit for all tables in a given instance using the
                    <a class="link" href="innodb-storage-engine.html#sysvar_innodb_ft_total_cache_size"><code class="literal">innodb_ft_total_cache_size</code></a>
                    option.
                </p><p style="color:blue;">innodb_ft_cache_size变量用于配置全文索引缓存大小（基于每个表），这会影响刷新全文索引缓存的频率。还可以使用innodb-ft-u-total-cache-size选项为给定实例中的所有表定义全局全文索引缓存大小限制。</p><p>
                    The full-text index cache stores the same information as
                    auxiliary index tables. However, the full-text index cache only
                    caches tokenized data for recently inserted rows. The data that
                    is already flushed to disk (to the full-text auxiliary tables)
                    is not brought back into the full-text index cache when queried.
                    The data in auxiliary index tables is queried directly, and
                    results from the auxiliary index tables are merged with results
                    from the full-text index cache before being returned.
                </p><p style="color:blue;">全文索引Cache存储与辅助索引表相同的信息。但是，全文索引缓存仅缓存最近插入行的标记化数据。已被刷新到磁盘（到全文辅助表）的数据在查询时不会返回到全文索引缓存中。辅助索引表中的数据是直接查询的，辅助索引表的结果与全文索引缓存的结果在返回之前合并。</p>
                </div>
                <div class="simplesect">
                    <div class="titlepage">
                        <div>
                            <div class="simple">
                                <h5 class="title"><a name="innodb-fulltext-index-docid"></a>InnoDB Full-Text Index Document ID and FTS_DOC_ID Column</h5>

                            </div>

                        </div>

                    </div>
                    <p>
                        <code class="literal">InnoDB</code> uses a unique document identifier
                        referred to as a Document ID (<code class="literal">DOC_ID</code>) to map
                        words in the full-text index to document records where the word
                        appears. The mapping requires an <code class="literal">FTS_DOC_ID</code>
                        column on the indexed table. If an <code class="literal">FTS_DOC_ID</code>
                        column is not defined, <code class="literal">InnoDB</code> automatically
                        adds a hidden <code class="literal">FTS_DOC_ID</code> column when the
                        full-text index is created. The following example demonstrates
                        this behavior.
                    </p><p style="color:blue;">innodb使用称为文档id（doc_id）的唯一文档标识符将全文索引中的单词映射到出现单词的文档记录。映射需要索引表上的fts_doc_id列。如果没有定义fts_doc_id列，innodb会在创建全文索引时自动添加一个隐藏的fts_doc_id列。下面的示例演示此行为。</p><p>
                    The following table definition does not include an
                    <code class="literal">FTS_DOC_ID</code> column:
                </p><p style="color:blue;">下表定义不包括FTS U DOC U ID列：</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>CREATE TABLE opening_lines (</code></strong>
       <strong class="userinput"><code>id INT UNSIGNED AUTO_INCREMENT NOT NULL PRIMARY KEY,</code></strong>
       <strong class="userinput"><code>opening_line TEXT(500),</code></strong>
       <strong class="userinput"><code>author VARCHAR(200),</code></strong>
       <strong class="userinput"><code>title VARCHAR(200)</code></strong>
       <strong class="userinput"><code>) ENGINE=InnoDB;</code></strong>
</pre><p>
                    When you create a full-text index on the table using
                    <code class="literal">CREATE FULLTEXT INDEX</code> syntax, a warning is
                    returned which reports that <code class="literal">InnoDB</code> is
                    rebuilding the table to add the <code class="literal">FTS_DOC_ID</code>
                    column.
                </p><p style="color:blue;">使用create full text index语法在表上创建全文索引时，将返回一条警告，报告innodb正在重建表以添加fts_doc_id列。</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>CREATE FULLTEXT INDEX idx ON opening_lines(opening_line);</code></strong>
Query OK, 0 rows affected, 1 warning (0.19 sec)
Records: 0  Duplicates: 0  Warnings: 1

mysql&gt; <strong class="userinput"><code>SHOW WARNINGS;</code></strong>
+---------+------+--------------------------------------------------+
| Level   | Code | Message                                          |
+---------+------+--------------------------------------------------+
| Warning |  124 | InnoDB rebuilding table to add column FTS_DOC_ID |
+---------+------+--------------------------------------------------+
</pre><p>
                    The same warning is returned when using
                    <a class="link" href="sql-syntax.html#alter-table" title="13.1.8&nbsp;ALTER TABLE Syntax"><code class="literal">ALTER TABLE</code></a> to add a full-text
                    index to a table that does not have an
                    <code class="literal">FTS_DOC_ID</code> column. If you create a full-text
                    index at <a class="link" href="sql-syntax.html#create-table" title="13.1.18&nbsp;CREATE TABLE Syntax"><code class="literal">CREATE TABLE</code></a> time and do
                    not specify an <code class="literal">FTS_DOC_ID</code> column,
                    <code class="literal">InnoDB</code> adds a hidden
                    <code class="literal">FTS_DOC_ID</code> column, without warning.
                </p><p style="color:blue;">使用alter table将全文索引添加到没有fts_doc_id列的表时，将返回相同的警告。如果在创建表时创建全文索引，并且没有指定fts_doc_id列，innodb会在没有警告的情况下添加一个隐藏的fts_doc_id列。</p><p>
                    Defining an <code class="literal">FTS_DOC_ID</code> column at
                    <a class="link" href="sql-syntax.html#create-table" title="13.1.18&nbsp;CREATE TABLE Syntax"><code class="literal">CREATE TABLE</code></a> time is less
                    expensive than creating a full-text index on a table that is
                    already loaded with data. If an <code class="literal">FTS_DOC_ID</code>
                    column is defined on a table prior to loading data, the table
                    and its indexes do not have to be rebuilt to add the new column.
                    If you are not concerned with <code class="literal">CREATE FULLTEXT
                    INDEX</code> performance, leave out the
                    <code class="literal">FTS_DOC_ID</code> column to have
                    <code class="literal">InnoDB</code> create it for you.
                    <code class="literal">InnoDB</code> creates a hidden
                    <code class="literal">FTS_DOC_ID</code> column along with a unique index
                    (<code class="literal">FTS_DOC_ID_INDEX</code>) on the
                    <code class="literal">FTS_DOC_ID</code> column. If you want to create your
                    own <code class="literal">FTS_DOC_ID</code> column, the column must be
                    defined as <code class="literal">BIGINT UNSIGNED NOT NULL</code> and named
                    <code class="literal">FTS_DOC_ID</code> (all upper case), as in the
                    following example:
                </p><p style="color:blue;">在创建表时定义fts_doc_id列比在已加载数据的表上创建全文索引要便宜。如果在加载数据之前在表上定义了fts_doc_id列，则无需重新生成表及其索引即可添加新列。如果您不关心create fulltext index的性能，请省略fts_doc_id列，让innodb为您创建它。innodb在fts-doc-id列上创建一个隐藏的fts-doc-id列和一个唯一的索引（fts-doc-id-u索引）。如果要创建自己的fts_doc_id列，则必须将该列定义为bigint unsigned not null并命名为fts_doc_id（全大写），如下例所示：</p>
                    <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">

                        <div class="admon-title">
                            Note
                        </div>
                        <p>
                            The <code class="literal">FTS_DOC_ID</code> column does not need to be
                            defined as an <code class="literal">AUTO_INCREMENT</code> column, but
                            <code class="literal">AUTO_INCREMENT</code> could make loading data
                            easier.
                        </p><p style="color:blue;">fts_doc_id列不需要定义为auto_increment列，但是auto_increment可以简化数据加载。</p>
                    </div>
                    <pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>CREATE TABLE opening_lines (</code></strong>
       <strong class="userinput"><code>FTS_DOC_ID BIGINT UNSIGNED AUTO_INCREMENT NOT NULL PRIMARY KEY,</code></strong>
       <strong class="userinput"><code>opening_line TEXT(500),</code></strong>
       <strong class="userinput"><code>author VARCHAR(200),</code></strong>
       <strong class="userinput"><code>title VARCHAR(200)</code></strong>
       <strong class="userinput"><code>) ENGINE=InnoDB;</code></strong>
</pre><p>
                    If you choose to define the <code class="literal">FTS_DOC_ID</code> column
                    yourself, you are responsible for managing the column to avoid
                    empty or duplicate values. <code class="literal">FTS_DOC_ID</code> values
                    cannot be reused, which means <code class="literal">FTS_DOC_ID</code>
                    values must be ever increasing.
                </p><p style="color:blue;">如果您选择自己定义fts_doc_id列，您将负责管理该列，以避免出现空值或重复值。不能重用fts_doc_id值，这意味着fts_doc_id值必须不断增加。</p><p>
                    Optionally, you can create the required unique
                    <code class="literal">FTS_DOC_ID_INDEX</code> (all upper case) on the
                    <code class="literal">FTS_DOC_ID</code> column.
                </p><p style="color:blue;">或者，您可以在fts-doc-id列上创建所需的唯一fts-doc-id-u索引（全部大写）。</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>CREATE UNIQUE INDEX FTS_DOC_ID_INDEX on opening_lines(FTS_DOC_ID);</code></strong>
</pre><p>
                    If you do not create the <code class="literal">FTS_DOC_ID_INDEX</code>,
                    <code class="literal">InnoDB</code> creates it automatically.
                </p><p style="color:blue;">如果不创建fts_doc_id_索引，innodb会自动创建它。</p><p>
                    Before MySQL 5.7.13, the permitted gap between the largest used
                    <code class="literal">FTS_DOC_ID</code> value and new
                    <code class="literal">FTS_DOC_ID</code> value is 10000. In MySQL 5.7.13
                    and later, the permitted gap is 65535.
                </p><p style="color:blue;">在mysql 5.7.13之前，所使用的最大fts_doc_id值与新fts_doc_id值之间的允许间隙为10000。在mysql 5.7.13及更高版本中，允许的间隙为65535。</p><p>
                    To avoid rebuilding the table, the <code class="literal">FTS_DOC_ID</code>
                    column is retained when dropping a full-text index.
                </p><p style="color:blue;">为了避免重建表，删除全文索引时将保留fts_doc_id列。</p>
                </div>
                <div class="simplesect">
                    <div class="titlepage">
                        <div>
                            <div class="simple">
                                <h5 class="title"><a name="innodb-fulltext-index-deletion"></a>InnoDB Full-Text Index Deletion Handling</h5>

                            </div>

                        </div>

                    </div>
                    <p>
                        Deleting a record that has a full-text index column could result
                        in numerous small deletions in the auxiliary index tables,
                        making concurrent access to these tables a point of contention.
                        To avoid this problem, the Document ID
                        (<code class="literal">DOC_ID</code>) of a deleted document is logged in a
                        special <code class="literal">FTS_*_DELETED</code> table whenever a record
                        is deleted from an indexed table, and the indexed record remains
                        in the full-text index. Before returning query results,
                        information in the <code class="literal">FTS_*_DELETED</code> table is
                        used to filter out deleted Document IDs. The benefit of this
                        design is that deletions are fast and inexpensive. The drawback
                        is that the size of the index is not immediately reduced after
                        deleting records. To remove full-text index entries for deleted
                        records, run <code class="literal">OPTIMIZE TABLE</code> on the indexed
                        table with
                        <a class="link" href="innodb-storage-engine.html#sysvar_innodb_optimize_fulltext_only"><code class="literal">innodb_optimize_fulltext_only=ON</code></a>
                        to rebuild the full-text index. For more information, see
                        <a class="xref" href="functions.html#fulltext-optimize" title="Optimizing InnoDB Full-Text Indexes">Optimizing InnoDB Full-Text Indexes</a>.
                    </p><p style="color:blue;">删除具有全文索引列的记录可能会导致辅助索引表中出现许多小的删除，从而使这些表的并发访问成为争论的焦点。为避免此问题，每当从索引表中删除记录时，已删除文档的文档ID（doc_id）将记录在特殊的fts_*_deleted表中，并且索引记录将保留在全文索引中。在返回查询结果之前，将使用fts挈u deleted表中的信息筛选出已删除的文档ID。这种设计的好处是删除速度快、成本低。缺点是删除记录后索引的大小不会立即减小。要删除已删除记录的全文索引项，请在innodb_optimize_full text_only=on的索引表上运行optimize table以重新生成全文索引。有关更多信息，请参阅优化innodb全文索引。</p>
                </div>
                <div class="simplesect">
                    <div class="titlepage">
                        <div>
                            <div class="simple">
                                <h5 class="title"><a name="innodb-fulltext-index-transaction"></a>InnoDB Full-Text Index Transaction Handling</h5>

                            </div>

                        </div>

                    </div>
                    <p>
                        <code class="literal">InnoDB</code> <code class="literal">FULLTEXT</code> indexes
                        have special transaction handling characteristics due its
                        caching and batch processing behavior. Specifically, updates and
                        insertions on a <code class="literal">FULLTEXT</code> index are processed
                        at transaction commit time, which means that a
                        <code class="literal">FULLTEXT</code> search can only see committed data.
                        The following example demonstrates this behavior. The
                        <code class="literal">FULLTEXT</code> search only returns a result after
                        the inserted lines are committed.
                    </p><p style="color:blue;">innodb全文索引由于其缓存和批处理行为，具有特殊的事务处理特性。具体来说，全文索引上的更新和插入是在事务提交时处理的，这意味着全文搜索只能看到提交的数据。下面的示例演示此行为。全文搜索只在提交插入的行之后返回结果。</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>CREATE TABLE opening_lines (</code></strong>
       <strong class="userinput"><code>id INT UNSIGNED AUTO_INCREMENT NOT NULL PRIMARY KEY,</code></strong>
       <strong class="userinput"><code>opening_line TEXT(500),</code></strong>
       <strong class="userinput"><code>author VARCHAR(200),</code></strong>
       <strong class="userinput"><code>title VARCHAR(200),</code></strong>
       <strong class="userinput"><code>FULLTEXT idx (opening_line)</code></strong>
       <strong class="userinput"><code>) ENGINE=InnoDB;</code></strong>

mysql&gt; <strong class="userinput"><code>BEGIN;</code></strong>

mysql&gt; <strong class="userinput"><code>INSERT INTO opening_lines(opening_line,author,title) VALUES</code></strong>
       <strong class="userinput"><code>('Call me Ishmael.','Herman Melville','Moby-Dick'),</code></strong>
       <strong class="userinput"><code>('A screaming comes across the sky.','Thomas Pynchon','Gravity\'s Rainbow'),</code></strong>
       <strong class="userinput"><code>('I am an invisible man.','Ralph Ellison','Invisible Man'),</code></strong>
       <strong class="userinput"><code>('Where now? Who now? When now?','Samuel Beckett','The Unnamable'),</code></strong>
       <strong class="userinput"><code>('It was love at first sight.','Joseph Heller','Catch-22'),</code></strong>
       <strong class="userinput"><code>('All this happened, more or less.','Kurt Vonnegut','Slaughterhouse-Five'),</code></strong>
       <strong class="userinput"><code>('Mrs. Dalloway said she would buy the flowers herself.','Virginia Woolf','Mrs. Dalloway'),</code></strong>
       <strong class="userinput"><code>('It was a pleasure to burn.','Ray Bradbury','Fahrenheit 451');</code></strong>

mysql&gt; <strong class="userinput"><code>SELECT COUNT(*) FROM opening_lines WHERE MATCH(opening_line) AGAINST('Ishmael');</code></strong>
+----------+
| COUNT(*) |
+----------+
|        0 |
+----------+

mysql&gt; <strong class="userinput"><code>COMMIT;</code></strong>

mysql&gt; <strong class="userinput"><code>SELECT COUNT(*) FROM opening_lines WHERE MATCH(opening_line) AGAINST('Ishmael');</code></strong>
+----------+
| COUNT(*) |
+----------+
|        1 |
+----------+
</pre>
                </div>
                <div class="simplesect">
                    <div class="titlepage">
                        <div>
                            <div class="simple">
                                <h5 class="title"><a name="innodb-fulltext-index-monitoring"></a>Monitoring InnoDB Full-Text Indexes</h5>

                            </div>

                        </div>

                    </div>
                    <a class="indexterm" name="idm140286822996112"></a><a class="indexterm" name="idm140286822994624"></a><p>
                    You can monitor and examine the special text-processing aspects
                    of <code class="literal">InnoDB</code> <code class="literal">FULLTEXT</code> indexes
                    by querying the following <code class="literal">INFORMATION_SCHEMA</code>
                    tables:
                </p><p style="color:blue;">您可以通过查询以下信息架构表来监视和检查innodb全文索引的特殊文本处理方面：</p>
                    <div class="itemizedlist">
                        <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                            <a class="link" href="information-schema.html#innodb-ft-config-table" title="24.32.8&nbsp;The INFORMATION_SCHEMA INNODB_FT_CONFIG Table"><code class="literal">INNODB_FT_CONFIG</code></a>
                        </p><p style="color:blue;">innodb_ft_配置</p></li><li class="listitem"><p>
                            <a class="link" href="information-schema.html#innodb-ft-index-table-table" title="24.32.12&nbsp;The INFORMATION_SCHEMA INNODB_FT_INDEX_TABLE Table"><code class="literal">INNODB_FT_INDEX_TABLE</code></a>
                        </p><p style="color:blue;">innodb_ft_index_表</p></li><li class="listitem"><p>
                            <a class="link" href="information-schema.html#innodb-ft-index-cache-table" title="24.32.11&nbsp;The INFORMATION_SCHEMA INNODB_FT_INDEX_CACHE Table"><code class="literal">INNODB_FT_INDEX_CACHE</code></a>
                        </p><p style="color:blue;">InnoDB_ft_索引缓存</p></li><li class="listitem"><p>
                            <a class="link" href="information-schema.html#innodb-ft-default-stopword-table" title="24.32.9&nbsp;The INFORMATION_SCHEMA INNODB_FT_DEFAULT_STOPWORD Table"><code class="literal">INNODB_FT_DEFAULT_STOPWORD</code></a>
                        </p><p style="color:blue;">innodb_ft_default_停止字</p></li><li class="listitem"><p>
                            <a class="link" href="information-schema.html#innodb-ft-deleted-table" title="24.32.10&nbsp;The INFORMATION_SCHEMA INNODB_FT_DELETED Table"><code class="literal">INNODB_FT_DELETED</code></a>
                        </p><p style="color:blue;">Innodb_ft_已删除</p></li><li class="listitem"><p>
                            <a class="link" href="information-schema.html#innodb-ft-being-deleted-table" title="24.32.7&nbsp;The INFORMATION_SCHEMA INNODB_FT_BEING_DELETED Table"><code class="literal">INNODB_FT_BEING_DELETED</code></a>
                        </p><p style="color:blue;">Innodb_ft_被删除</p></li></ul>
                    </div>
                    <p>
                        You can also view basic information for
                        <code class="literal">FULLTEXT</code> indexes and tables by querying
                        <a class="link" href="information-schema.html#innodb-sys-indexes-table" title="24.32.21&nbsp;The INFORMATION_SCHEMA INNODB_SYS_INDEXES Table"><code class="literal">INNODB_SYS_INDEXES</code></a> and
                        <a class="link" href="information-schema.html#innodb-sys-tables-table" title="24.32.22&nbsp;The INFORMATION_SCHEMA INNODB_SYS_TABLES Table"><code class="literal">INNODB_SYS_TABLES</code></a>.
                    </p><p style="color:blue;">您还可以通过查询innodb_sys_index和innodb_sys_tables来查看全文索引和表的基本信息。</p><p>
                    For more information, see
                    <a class="xref" href="innodb-storage-engine.html#innodb-information-schema-fulltext_index-tables" title="14.15.4&nbsp;InnoDB INFORMATION_SCHEMA FULLTEXT Index Tables">Section&nbsp;14.15.4, “InnoDB INFORMATION_SCHEMA FULLTEXT Index Tables”</a>.
                </p><p style="color:blue;">有关更多信息，请参阅14.15.4节，“innodb information_schema全文索引表”。</p>
                </div>

            </div>

        </div>
        <div class="section">
            <div class="titlepage">
                <div>
                    <div>
                        <h3 class="title"><a name="innodb-tablespace"></a>14.6.3&nbsp;Tablespaces</h3>

                    </div>

                </div>

            </div>
            <div class="toc">
                <dl class="toc"><dt><span class="section"><a href="innodb-storage-engine.html#innodb-system-tablespace">14.6.3.1 The System Tablespace</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-multiple-tablespaces">14.6.3.2 File-Per-Table Tablespaces</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#general-tablespaces">14.6.3.3 General Tablespaces</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-undo-tablespaces">14.6.3.4 Undo Tablespaces</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-temporary-tablespace">14.6.3.5 The Temporary Tablespace</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#tablespace-placing">14.6.3.6 Creating a Tablespace Outside of the Data Directory</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#tablespace-copying">14.6.3.7 Copying Tablespaces to Another Instance</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-tablespace-encryption">14.6.3.8 InnoDB Data-at-Rest Encryption</a></span></dt></dl>
            </div>
            <p>
                This section covers topics related to <code class="literal">InnoDB</code>
                tablespaces.
            </p><p style="color:blue;">本节介绍与innodb表空间相关的主题。</p>
            <div class="section">

                <div class="titlepage">
                    <div>
                        <div>
                            <h4 class="title"><a name="innodb-system-tablespace"></a>14.6.3.1&nbsp;The System Tablespace</h4>
                        </div>
                    </div>
                </div>
                <p>
                    The system tablespace is the storage area for the
                    <code class="literal">InnoDB</code> data dictionary, the doublewrite buffer,
                    the change buffer, and undo logs. It may also contain table and
                    index data if tables are created in the system tablespace rather
                    than file-per-table or general tablespaces.
                </p><p style="color:blue;">系统表空间是innodb数据字典、doublewrite缓冲区、change缓冲区和undo日志的存储区域。如果表是在系统表空间中创建的，而不是在每个表或常规表空间中创建文件，则它还可能包含表和索引数据。</p><p>
                The system tablespace can have one or more data files. By default,
                a single system tablespace data file, named
                <code class="filename">ibdata1</code>, is created in the data directory.
                The size and number of system tablespace data files is defined by
                the <a class="link" href="innodb-storage-engine.html#sysvar_innodb_data_file_path"><code class="literal">innodb_data_file_path</code></a> startup
                option. For configuration information, see
                <a class="xref" href="innodb-storage-engine.html#innodb-startup-data-file-configuration" title="System Tablespace Data File Configuration">System Tablespace Data File Configuration</a>.
            </p><p style="color:blue;">系统表空间可以有一个或多个数据文件。默认情况下，在数据目录中创建一个名为ibdata1的系统表空间数据文件。系统表空间数据文件的大小和数量由innodb_data_file_path startup选项定义。有关配置信息，请参阅系统表空间数据文件配置。</p><p>
                Additional information about the system tablespace is provided
                under the following topics in the section:
            </p><p style="color:blue;">有关系统表空间的其他信息在本节的以下主题下提供：</p>
                <div class="simplesect">

                    <div class="titlepage">
                        <div>

                            <div class="simple">
                                <h5 class="title"><a name="innodb-resize-system-tablespace"></a>Resizing the System Tablespace</h5>
                            </div>
                        </div>
                    </div>
                    <a class="indexterm" name="idm140286822962688"></a><p>
                    This section describes how to increase or decrease the size of
                    the system tablespace.
                </p><p style="color:blue;">本节介绍如何增加或减小系统表空间的大小。</p><h6><a name="idm140286822960688"></a>Increasing the Size of the System Tablespace</h6><p>
                    The easiest way to increase the size of the system tablespace is
                    to configure it to be auto-extending. To do so, specify the
                    <code class="literal">autoextend</code> attribute for the last data file
                    in the <a class="link" href="innodb-storage-engine.html#sysvar_innodb_data_file_path"><code class="literal">innodb_data_file_path</code></a>
                    setting, and restart the server. For example:
                </p><p style="color:blue;">增加系统表空间大小的最简单方法是将其配置为自动扩展。为此，在innodb_data_file_path设置中为最后一个数据文件指定autoextend属性，然后重新启动服务器。例如：</p><pre data-lang="ini" class="programlisting">innodb_data_file_path=ibdata1:10MB:autoextend
</pre><p>
                    When the <code class="literal">autoextend</code> attribute is specified,
                    the data file automatically increases in size by 8MB increments
                    as space is required. The
                    <a class="link" href="innodb-storage-engine.html#sysvar_innodb_autoextend_increment"><code class="literal">innodb_autoextend_increment</code></a>
                    variable controls the increment size.
                </p><p style="color:blue;">当指定了autoextend属性时，数据文件的大小会随着空间的需要而自动增加8MB。innodb_autoextend_increment变量控制增量大小。</p><p>
                    You can also increase system tablespace size by adding another
                    data file. To do so:
                </p><p style="color:blue;">还可以通过添加另一个数据文件来增加系统表空间大小。为此：</p>
                    <div class="orderedlist">
                        <ol class="orderedlist" type="1"><li class="listitem"><p>
                            Stop the MySQL server.
                        </p><p style="color:blue;">停止mysql服务器。</p></li><li class="listitem"><p>
                            If the last data file in the
                            <a class="link" href="innodb-storage-engine.html#sysvar_innodb_data_file_path"><code class="literal">innodb_data_file_path</code></a>
                            setting is defined with the <code class="literal">autoextend</code>
                            attribute, remove it, and modify the size attribute to
                            reflect the current data file size. To determine the
                            appropriate data file size to specify, check your file
                            system for the file size, and round that value down to the
                            closest MB value, where a MB is equal to 1024 x 1024.
                        </p><p style="color:blue;">如果innodb_data_file_path设置中的最后一个数据文件是用autoextend属性定义的，那么删除它，并修改size属性以反映当前数据文件的大小。要确定要指定的适当数据文件大小，请检查文件系统中的文件大小，并将该值舍入到最接近的MB值，其中MB等于1024 x 1024。</p></li><li class="listitem"><p>
                            Append a new data file to the
                            <a class="link" href="innodb-storage-engine.html#sysvar_innodb_data_file_path"><code class="literal">innodb_data_file_path</code></a>
                            setting, optionally specifying the
                            <code class="literal">autoextend</code> attribute. The
                            <code class="literal">autoextend</code> attribute can be specified
                            only for the last data file in the
                            <a class="link" href="innodb-storage-engine.html#sysvar_innodb_data_file_path"><code class="literal">innodb_data_file_path</code></a>
                            setting.
                        </p><p style="color:blue;">将新的数据文件附加到innodb_data_file_path设置中，可以选择指定autoextend属性。只能为innodb_data_file_path设置中的最后一个数据文件指定autoextend属性。</p></li><li class="listitem"><p>
                            Start the MySQL server.
                        </p><p style="color:blue;">启动mysql服务器。</p></li></ol>
                    </div>
                    <p>
                        For example, this tablespace has one auto-extending data file:
                    </p><p style="color:blue;">例如，此表空间有一个自动扩展的数据文件：</p><pre data-lang="none" class="programlisting">innodb_data_home_dir =
innodb_data_file_path = /ibdata/ibdata1:10M:autoextend
</pre><p>
                    Suppose that the data file has grown to 988MB over time. This is
                    the <a class="link" href="innodb-storage-engine.html#sysvar_innodb_data_file_path"><code class="literal">innodb_data_file_path</code></a>
                    setting after modifying the size attribute to reflect the
                    current data file size, and after specifying a new 50MB
                    auto-extending data file:
                </p><p style="color:blue;">假设数据文件随着时间的推移已经增长到988MB。这是修改size属性以反映当前数据文件大小并指定新的50MB自动扩展数据文件后的innodb_data_file_path设置：</p><pre data-lang="none" class="programlisting">innodb_data_home_dir =
innodb_data_file_path = /ibdata/ibdata1:988M;/disk2/ibdata2:50M:autoextend
</pre><p>
                    When adding a new data file, do not specify an existing file
                    name. <code class="literal">InnoDB</code> creates and initializes the new
                    data file when you start the server.
                </p><p style="color:blue;">添加新的数据文件时，不要指定现有文件名。当您启动服务器时，innodb会创建并初始化新的数据文件。</p>
                    <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">

                        <div class="admon-title">
                            Note
                        </div>
                        <p>
                            You cannot increase the size of an existing system tablespace
                            data file by changing its size attribute. For example,
                            changing the
                            <a class="link" href="innodb-storage-engine.html#sysvar_innodb_data_file_path"><code class="literal">innodb_data_file_path</code></a> setting
                            from <code class="literal">ibdata1:10M:autoextend</code> to
                            <code class="literal">ibdata1:12M:autoextend</code> produces the
                            following error when starting the server:
                        </p><p style="color:blue;">不能通过改变其大小属性来增加现有系统表空间数据文件的大小。例如，将innodb_data_file_path设置从ibdata1:10m:autoextend更改为ibdata1:12m:autoextend会在启动服务器时产生以下错误：</p><pre data-lang="terminal" class="programlisting">[ERROR] [MY-012263] [InnoDB] The Auto-extending innodb_system
data file './ibdata1' is of a different size 640 pages (rounded down to MB) than
specified in the .cnf file: initial 768 pages, max 0 (relevant if non-zero) pages!
</pre><p>
                        The error indicates that the existing data file size
                        (expressed in <code class="literal">InnoDB</code> pages) is different
                        from the size specified in the configuration file. If you
                        encounter this error, restore the previous
                        <a class="link" href="innodb-storage-engine.html#sysvar_innodb_data_file_path"><code class="literal">innodb_data_file_path</code></a>
                        setting, and refer to the system tablespace resizing
                        instructions.
                    </p><p style="color:blue;">该错误指示现有的数据文件大小（在YNODB页中表示）与配置文件中指定的大小不同。如果遇到此错误，请恢复先前的innodb_data_file_path设置，并参考系统表空间调整说明。</p><p>
                        <code class="literal">InnoDB</code> page size is defined by the
                        <a class="link" href="innodb-storage-engine.html#sysvar_innodb_page_size"><code class="literal">innodb_page_size</code></a> variable.
                        The default is 16384 bytes.
                    </p><p style="color:blue;">innodb page size由innodb_page_size变量定义。默认值为16384字节。</p>
                    </div>
                    <h6><a name="idm140286822926816"></a>Decreasing the Size of the InnoDB System Tablespace</h6><p>
                    You cannot remove a data file from the system tablespace. To
                    decrease the system tablespace size, use this procedure:
                </p><p style="color:blue;">不能从系统表空间中删除数据文件。要减小系统表空间大小，请使用以下过程：</p>
                    <div class="orderedlist">
                        <ol class="orderedlist" type="1"><li class="listitem"><p>
                            Use <a class="link" href="programs.html#mysqldump" title="4.5.4&nbsp;mysqldump — A Database Backup Program"><span class="command"><strong>mysqldump</strong></span></a> to dump all your
                            <code class="literal">InnoDB</code> tables, including
                            <code class="literal">InnoDB</code> tables located in the MySQL
                            database. As of 5.6, there are five
                            <code class="literal">InnoDB</code> tables included in the MySQL
                            database:
                        </p><p style="color:blue;">使用mysql dump转储所有innodb表，包括mysql数据库中的innodb表。截至5.6，mysql数据库中包含五个innodb表：</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT TABLE_NAME from INFORMATION_SCHEMA.TABLES WHERE TABLE_SCHEMA='mysql' and ENGINE='InnoDB';</code></strong>
+---------------------------+
| TABLE_NAME                |
+---------------------------+
| engine_cost               |
| gtid_executed             |
| help_category             |
| help_keyword              |
| help_relation             |
| help_topic                |
| innodb_index_stats        |
| innodb_table_stats        |
| plugin                    |
| server_cost               |
| servers                   |
| slave_master_info         |
| slave_relay_log_info      |
| slave_worker_info         |
| time_zone                 |
| time_zone_leap_second     |
| time_zone_name            |
| time_zone_transition      |
| time_zone_transition_type |
+---------------------------+
</pre></li><li class="listitem"><p>
                            Stop the server.
                        </p><p style="color:blue;">停止服务器。</p></li><li class="listitem"><p>
                            Remove all the existing tablespace files
                            (<code class="filename">*.ibd</code>), including the
                            <code class="filename">ibdata</code> and <code class="filename">ib_log</code>
                            files. Do not forget to remove <code class="filename">*.ibd</code>
                            files for tables located in the MySQL database.
                        </p><p style="color:blue;">删除所有现有的表空间文件（包括IBD）和文件组。不要忘记删除MySQL数据库中表的*.ibd文件。</p></li><li class="listitem"><p>
                            Remove any <code class="filename">.frm</code> files for
                            <code class="literal">InnoDB</code> tables.
                        </p><p style="color:blue;">删除innodb表的任何.frm文件。</p></li><li class="listitem"><p>
                            Configure a new tablespace.
                        </p><p style="color:blue;">配置新表空间。</p></li><li class="listitem"><p>
                            Restart the server.
                        </p><p style="color:blue;">重新启动服务器。</p></li><li class="listitem"><p>
                            Import the dump files.
                        </p><p style="color:blue;">导入转储文件。</p></li></ol>
                    </div>
                    <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">
                        <div class="admon-title">
                            Note
                        </div>
                        <p>
                            If your databases only use the <code class="literal">InnoDB</code>
                            engine, it may be simpler to dump
                            <span class="bold"><strong>all</strong></span> databases, stop the
                            server, remove all databases and <code class="literal">InnoDB</code> log
                            files, restart the server, and import the dump files.
                        </p><p style="color:blue;">如果数据库只使用innodb引擎，那么转储所有数据库、停止服务器、删除所有数据库和innodb日志文件、重新启动服务器和导入转储文件可能会更简单。</p>
                    </div>

                </div>
                <div class="simplesect">
                    <div class="titlepage">
                        <div>
                            <div class="simple">
                                <h5 class="title"><a name="innodb-raw-devices"></a>Using Raw Disk Partitions for the System Tablespace</h5>

                            </div>

                        </div>

                    </div>
                    <a class="indexterm" name="idm140286822903984"></a><a class="indexterm" name="idm140286822902528"></a><p>
                    You can use raw disk partitions as data files in the
                    <code class="literal">InnoDB</code>
                    <a class="link" href="glossary.html#glos_system_tablespace" title="system tablespace">system tablespace</a>.
                    This technique enables nonbuffered I/O on Windows and on some
                    Linux and Unix systems without file system overhead. Perform
                    tests with and without raw partitions to verify whether this
                    change actually improves performance on your system.
                </p><p style="color:blue;">可以将原始磁盘分区用作innodb系统表空间中的数据文件。这种技术可以在windows和一些linux和unix系统上实现非缓冲i/o，而无需文件系统开销。在有或没有原始分区的情况下执行测试，以验证此更改是否实际提高了系统的性能。</p><p>
                    When you use a raw disk partition, ensure that the user ID that
                    runs the MySQL server has read and write privileges for that
                    partition. For example, if you run the server as the
                    <code class="literal">mysql</code> user, the partition must be readable
                    and writeable by <code class="literal">mysql</code>. If you run the server
                    with the <a class="link" href="server-administration.html#option_mysqld_memlock"><code class="option">--memlock</code></a> option, the
                    server must be run as <code class="literal">root</code>, so the partition
                    must be readable and writeable by <code class="literal">root</code>.
                </p><p style="color:blue;">使用原始磁盘分区时，请确保运行mysql服务器的用户id具有该分区的读写权限。例如，如果以mysql用户的身份运行服务器，那么mysql必须可读写分区。如果使用--memlock选项运行服务器，则服务器必须以根用户身份运行，因此分区必须由根用户可读写。</p><p>
                    The procedures described below involve option file modification.
                    For additional information, see <a class="xref" href="programs.html#option-files" title="4.2.2.2&nbsp;Using Option Files">Section&nbsp;4.2.2.2, “Using Option Files”</a>.
                </p><p style="color:blue;">下面描述的过程涉及选项文件修改。有关更多信息，请参见第4.2.2.2节“使用选项文件”。</p><h6><a name="idm140286822893424"></a>Allocating a Raw Disk Partition on Linux and Unix Systems</h6>
                    <div class="orderedlist">
                        <ol class="orderedlist" type="1"><li class="listitem"><p>
                            When you create a new data file, specify the keyword
                            <code class="literal">newraw</code> immediately after the data file
                            size for the
                            <a class="link" href="innodb-storage-engine.html#sysvar_innodb_data_file_path"><code class="literal">innodb_data_file_path</code></a>
                            option. The partition must be at least as large as the size
                            that you specify. Note that 1MB in <code class="literal">InnoDB</code>
                            is 1024 × 1024 bytes, whereas 1MB in disk
                            specifications usually means 1,000,000 bytes.
                        </p><p style="color:blue;">创建新数据文件时，请在innodb_data_file_path选项的数据文件大小之后立即指定关键字newraw。分区必须至少与指定的大小相同。注意，innodb中的1MB是1024×1024字节，而磁盘规范中的1MB通常意味着1000000字节。</p><pre data-lang="none" class="programlisting">[mysqld]
innodb_data_home_dir=
innodb_data_file_path=/dev/hdd1:3Gnewraw;/dev/hdd2:2Gnewraw
</pre></li><li class="listitem"><p>
                            Restart the server. <code class="literal">InnoDB</code> notices the
                            <code class="literal">newraw</code> keyword and initializes the new
                            partition. However, do not create or change any
                            <code class="literal">InnoDB</code> tables yet. Otherwise, when you
                            next restart the server, <code class="literal">InnoDB</code>
                            reinitializes the partition and your changes are lost. (As a
                            safety measure <code class="literal">InnoDB</code> prevents users from
                            modifying data when any partition with
                            <code class="literal">newraw</code> is specified.)
                        </p><p style="color:blue;">重新启动服务器。innodb注意到newraw关键字并初始化新分区。但是，不要创建或更改任何innodb表。否则，当您下次重新启动服务器时，innodb将重新初始化分区，您的更改将丢失。（作为一项安全措施，当指定了任何带有newraw的分区时，innodb会阻止用户修改数据。）</p></li><li class="listitem"><p>
                            After <code class="literal">InnoDB</code> has initialized the new
                            partition, stop the server, change <code class="literal">newraw</code>
                            in the data file specification to <code class="literal">raw</code>:
                        </p><p style="color:blue;">InnoDB初始化新分区后，停止服务器，将数据文件规范中的new raw更改为raw：</p><pre data-lang="none" class="programlisting">[mysqld]
innodb_data_home_dir=
innodb_data_file_path=/dev/hdd1:3Graw;/dev/hdd2:2Graw
</pre></li><li class="listitem"><p>
                            Restart the server. <code class="literal">InnoDB</code> now permits
                            changes to be made.
                        </p><p style="color:blue;">重新启动服务器。InnoDB现在允许进行更改。</p></li></ol>
                    </div>
                    <h6><a name="idm140286822875584"></a>Allocating a Raw Disk Partition on Windows</h6><p>
                    On Windows systems, the same steps and accompanying guidelines
                    described for Linux and Unix systems apply except that the
                    <a class="link" href="innodb-storage-engine.html#sysvar_innodb_data_file_path"><code class="literal">innodb_data_file_path</code></a> setting
                    differs slightly on Windows.
                </p><p style="color:blue;">在windows系统上，除了innodb_data_file_path设置在windows上略有不同外，适用于linux和unix系统的相同步骤和附带指南。</p>
                    <div class="orderedlist">
                        <ol class="orderedlist" type="1"><li class="listitem"><p>
                            When you create a new data file, specify the keyword
                            <code class="literal">newraw</code> immediately after the data file
                            size for the
                            <a class="link" href="innodb-storage-engine.html#sysvar_innodb_data_file_path"><code class="literal">innodb_data_file_path</code></a>
                            option:
                        </p><p style="color:blue;">创建新数据文件时，请在innodb_data_file_path选项的数据文件大小之后立即指定关键字newraw：</p><pre data-lang="none" class="programlisting">[mysqld]
innodb_data_home_dir=
innodb_data_file_path=//./D::10Gnewraw
</pre><p>
                            The <code class="filename">//./</code> corresponds to the Windows
                            syntax of <code class="filename">\\.\</code> for accessing physical
                            drives. In the example above, <code class="literal">D:</code> is the
                            drive letter of the partition.
                        </p><p style="color:blue;">//./对应于用于访问物理驱动器的Windows语法“\.”。在上面的例子中，d:是分区的驱动器号。</p></li><li class="listitem"><p>
                            Restart the server. <code class="literal">InnoDB</code> notices the
                            <code class="literal">newraw</code> keyword and initializes the new
                            partition.
                        </p><p style="color:blue;">重新启动服务器。innodb注意到newraw关键字并初始化新分区。</p></li><li class="listitem"><p>
                            After <code class="literal">InnoDB</code> has initialized the new
                            partition, stop the server, change <code class="literal">newraw</code>
                            in the data file specification to <code class="literal">raw</code>:
                        </p><p style="color:blue;">InnoDB初始化新分区后，停止服务器，将数据文件规范中的new raw更改为raw：</p><pre data-lang="none" class="programlisting">[mysqld]
innodb_data_home_dir=
innodb_data_file_path=//./D::10Graw
</pre></li><li class="listitem"><p>
                            Restart the server. <code class="literal">InnoDB</code> now permits
                            changes to be made.
                        </p><p style="color:blue;">重新启动服务器。InnoDB现在允许进行更改。</p></li></ol>
                    </div>

                </div>

            </div>
            <div class="section">
                <div class="titlepage">
                    <div>
                        <div>
                            <h4 class="title"><a name="innodb-multiple-tablespaces"></a>14.6.3.2&nbsp;File-Per-Table Tablespaces</h4>

                        </div>

                    </div>

                </div>
                <a class="indexterm" name="idm140286822856160"></a><a class="indexterm" name="idm140286822854672"></a><a class="indexterm" name="idm140286822853600"></a><p>
                Historically, <code class="literal">InnoDB</code> tables were stored in the
                <a class="link" href="glossary.html#glos_system_tablespace" title="system tablespace">system tablespace</a>.
                This monolithic approach was targeted at machines dedicated to
                database processing, with carefully planned data growth, where any
                disk storage allocated to MySQL would never be needed for other
                purposes. The <a class="link" href="glossary.html#glos_file_per_table" title="file-per-table">file-per-table
                tablespace</a> feature provides a more flexible alternative,
                where each <code class="literal">InnoDB</code> table is stored in its own
                tablespace data file (<code class="filename">.ibd</code> file). This
                feature is controlled by the
                <a class="link" href="innodb-storage-engine.html#sysvar_innodb_file_per_table"><code class="literal">innodb_file_per_table</code></a>
                configuration option, which is enabled by default.
            </p><p style="color:blue;">历史上，innodb表存储在系统表空间中。这种单一的方法针对的是专门用于数据库处理的机器，有着精心计划的数据增长，在那里分配给mysql的任何磁盘存储永远不需要用于其他目的。每表表空间特征的文件提供了一种更灵活的替代方案，其中每个IDYBB表都存储在它自己的表空间数据文件（.IBD文件）中。此功能由innodb_file_per_table configuration选项控制，该选项在默认情况下启用。</p>
                <h5><a name="idm140286822846544"></a>Advantages</h5>
                <div class="itemizedlist">
                    <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                        You can reclaim disk space when truncating or dropping a table
                        stored in a file-per-table tablespace. Truncating or dropping
                        tables stored in the shared
                        <a class="link" href="glossary.html#glos_system_tablespace" title="system tablespace">system
                            tablespace</a> creates free space internally in the system
                        tablespace data files (<a class="link" href="glossary.html#glos_ibdata_file" title="ibdata file">ibdata
                        files</a>) which can only be used for new
                        <code class="literal">InnoDB</code> data.
                    </p><p style="color:blue;">当截断或删除存储在每个表空间的文件中的表时，可以回收磁盘空间。截断或删除存储在共享系统表空间中的表会在系统表空间数据文件（ibdata文件）内部创建可用空间，这些文件只能用于新的innodb数据。</p><p>
                        Similarly, a table-copying <a class="link" href="sql-syntax.html#alter-table" title="13.1.8&nbsp;ALTER TABLE Syntax"><code class="literal">ALTER
                        TABLE</code></a> operation on table that resides in a shared
                        tablespace can increase the amount of space used by the
                        tablespace. Such operations may require as much additional
                        space as the data in the table plus indexes. The additional
                        space required for the table-copying
                        <a class="link" href="sql-syntax.html#alter-table" title="13.1.8&nbsp;ALTER TABLE Syntax"><code class="literal">ALTER TABLE</code></a> operation is not
                        released back to the operating system as it is for
                        file-per-table tablespaces.
                    </p><p style="color:blue;">类似地，对驻留在共享表空间中的表执行表复制alter table操作可以增加表空间使用的空间量。这样的操作可能需要与表中的数据加上索引一样多的额外空间。表复制alter table操作所需的额外空间不会释放回操作系统，因为它是针对每个表空间的文件的。</p></li><li class="listitem"><p>
                        The <a class="link" href="sql-syntax.html#truncate-table" title="13.1.34&nbsp;TRUNCATE TABLE Syntax"><code class="literal">TRUNCATE TABLE</code></a> operation is
                        faster when run on tables stored in file-per-table
                        tablespaces.
                    </p><p style="color:blue;">truncate table操作在存储在file-per-table表空间中的表上运行时速度更快。</p></li><li class="listitem"><p>
                        You can store specific tables on separate storage devices, for
                        I/O optimization, space management, or backup purposes. In
                        previous releases, you had to move entire database directories
                        to other drives and create symbolic links in the MySQL data
                        directory, as described in <a class="xref" href="optimization.html#symbolic-links" title="8.12.3&nbsp;Using Symbolic Links">Section&nbsp;8.12.3, “Using Symbolic Links”</a>.
                        In MySQL 5.6.6 and higher, you can specify the location of
                        each table using the syntax <code class="literal">CREATE TABLE ... DATA
                        DIRECTORY =
                        <em class="replaceable"><code>absolute_path_to_directory</code></em></code>,
                        as explained in <a class="xref" href="innodb-storage-engine.html#tablespace-placing" title="14.6.3.6&nbsp;Creating a Tablespace Outside of the Data Directory">Section&nbsp;14.6.3.6, “Creating a Tablespace Outside of the Data Directory”</a>.
                    </p><p style="color:blue;">您可以将特定的表存储在不同的存储设备上，以进行I/O优化、空间管理或备份。在以前的版本中，您必须将整个数据库目录移动到其他驱动器，并在mysql数据目录中创建符号链接，如8.12.3节“使用符号链接”中所述。在mysql 5.6.6及更高版本中，可以使用create table语法指定每个表的位置…data directory=absolute_path_to_directory，如第14.6.3.6节“在数据目录之外创建表空间”所述。</p></li><li class="listitem"><p>
                        You can run <a class="link" href="sql-syntax.html#optimize-table" title="13.7.2.4&nbsp;OPTIMIZE TABLE Syntax"><code class="literal">OPTIMIZE TABLE</code></a> to
                        compact or recreate a file-per-table tablespace. When you run
                        an <a class="link" href="sql-syntax.html#optimize-table" title="13.7.2.4&nbsp;OPTIMIZE TABLE Syntax"><code class="literal">OPTIMIZE TABLE</code></a>,
                        <code class="literal">InnoDB</code> creates a new
                        <code class="filename">.ibd</code> file with a temporary name, using
                        only the space required to store actual data. When the
                        optimization is complete, <code class="literal">InnoDB</code> removes
                        the old <code class="filename">.ibd</code> file and replaces it with
                        the new one. If the previous <code class="filename">.ibd</code> file
                        grew significantly but the actual data only accounted for a
                        portion of its size, running <a class="link" href="sql-syntax.html#optimize-table" title="13.7.2.4&nbsp;OPTIMIZE TABLE Syntax"><code class="literal">OPTIMIZE
                        TABLE</code></a> can reclaim the unused space.
                    </p><p style="color:blue;">您可以运行optimize table来压缩或重新创建每个表空间的文件。运行优化表时，innodb只使用存储实际数据所需的空间创建一个临时名为的新.ibd文件。优化完成后，innodb将删除旧的.ibd文件，并用新的文件替换它。如果以前的.ibd文件显著增长，但实际数据只占其大小的一部分，则运行optimize table可以回收未使用的空间。</p></li><li class="listitem"><p>
                        You can move individual <code class="literal">InnoDB</code> tables
                        rather than entire databases.
                    </p><p style="color:blue;">您可以移动单个innodb表，而不是整个数据库。</p></li><li class="listitem"><p>
                        You can copy individual <code class="literal">InnoDB</code> tables from
                        one MySQL instance to another (known as the
                        <a class="link" href="glossary.html#glos_transportable_tablespace" title="transportable tablespace">transportable
                            tablespace</a> feature).
                    </p><p style="color:blue;">您可以将单个innodb表从一个mysql实例复制到另一个实例（称为可移植表空间特性）。</p></li><li class="listitem"><p>
                        Tables created in file-per-table tablespaces use the
                        <a class="link" href="glossary.html#glos_barracuda" title="Barracuda">Barracuda</a> file format.
                        The Barracuda file format enables features such as
                        <a class="link" href="glossary.html#glos_compressed_row_format" title="compressed row format">compressed</a>
                        and <a class="link" href="glossary.html#glos_dynamic_row_format" title="dynamic row format">dynamic</a> row
                        formats.
                    </p><p style="color:blue;">在“文件/表”表空间中创建的表使用Barracuda文件格式。Barracuda文件格式支持压缩和动态行格式等功能。</p></li><li class="listitem"><p>
                        You can enable more efficient storage for tables with large
                        <code class="literal">BLOB</code> or <code class="literal">TEXT</code> columns
                        using the <a class="link" href="glossary.html#glos_dynamic_row_format" title="dynamic row format">dynamic row
                        format</a>.
                    </p><p style="color:blue;">可以使用动态行格式为具有大型blob或文本列的表启用更高效的存储。</p></li><li class="listitem"><p>
                        File-per-table tablespaces may improve chances for a
                        successful recovery and save time when a corruption occurs,
                        when a server cannot be restarted, or when backup and binary
                        logs are unavailable.
                    </p><p style="color:blue;">当发生损坏、服务器无法重新启动或备份和二进制日志不可用时，每个表的文件表空间可以提高成功恢复的机会并节省时间。</p></li><li class="listitem"><p>
                        You can back up or restore individual tables quickly using the
                        MySQL Enterprise Backup product, without interrupting the use
                        of other <code class="literal">InnoDB</code> tables. This is beneficial
                        if you have tables that require backup less frequently or on a
                        different backup schedule. See <a class="ulink" href="https://dev.mysql.com/doc/mysql-enterprise-backup/4.1/en/partial.html" target="_top">Making a Partial Backup</a> for
                        details.
                    </p><p style="color:blue;">您可以使用mysql企业备份产品快速备份或恢复单个表，而不中断其他innodb表的使用。如果您的表需要较少的备份或在不同的备份计划中进行备份，则这是有益的。有关详细信息，请参见进行部分备份。</p></li><li class="listitem"><p>
                        File-per-table tablespaces are convenient for per-table status
                        reporting when copying or backing up tables.
                    </p><p style="color:blue;">在复制或备份表时，每个表的文件表空间便于每个表的状态报告。</p></li><li class="listitem"><p>
                        You can monitor table size at a file system level without
                        accessing MySQL.
                    </p><p style="color:blue;">您可以在文件系统级别监视表大小，而无需访问mysql。</p></li><li class="listitem"><p>
                        Common Linux file systems do not permit concurrent writes to a
                        single file when
                        <a class="link" href="innodb-storage-engine.html#sysvar_innodb_flush_method"><code class="literal">innodb_flush_method</code></a> is set to
                        <code class="literal">O_DIRECT</code>. As a result, there are possible
                        performance improvements when using file-per-table tablespaces
                        in conjunction with
                        <a class="link" href="innodb-storage-engine.html#sysvar_innodb_flush_method"><code class="literal">innodb_flush_method</code></a>.
                    </p><p style="color:blue;">当innodb_flush_method设置为o_direct时，常见的linux文件系统不允许对单个文件进行并发写入。因此，在结合使用file per table表空间和innodb_flush_方法时，可能会有性能改进。</p></li><li class="listitem"><p>
                        The system tablespace stores the data dictionary and undo
                        logs, and is limited in size by <code class="literal">InnoDB</code>
                        tablespace size limits. See
                        <a class="xref" href="innodb-storage-engine.html#innodb-restrictions" title="14.6.1.6&nbsp;Limits on InnoDB Tables">Section&nbsp;14.6.1.6, “Limits on InnoDB Tables”</a>. With file-per-table
                        tablespaces, each table has its own tablespace, which provides
                        room for growth.
                    </p><p style="color:blue;">系统表空间存储数据字典和撤销日志，并且受innodb表空间大小限制。见第14.6.1.6节，“InnoDB表的限制”。对于每表表空间的文件，每个表都有自己的表空间，这为增长提供了空间。</p></li></ul>
                </div>
                <h5><a name="idm140286822801312"></a>Potential Disadvantages</h5>
                <div class="itemizedlist">
                    <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                        With file-per-table tablespaces, each table may have unused
                        space, which can only be utilized by rows of the same table.
                        This could lead to wasted space if not properly managed.
                    </p><p style="color:blue;">对于每个表的文件表空间，每个表都可能有未使用的空间，这些空间只能由同一表的行使用。如果管理不当，这可能会导致浪费空间。</p></li><li class="listitem"><p>
                        <code class="literal">fsync</code> operations must run on each open
                        table rather than on a single file. Because there is a
                        separate <code class="literal">fsync</code> operation for each file,
                        write operations on multiple tables cannot be combined into a
                        single I/O operation. This may require
                        <code class="literal">InnoDB</code> to perform a higher total number of
                        <code class="literal">fsync</code> operations.
                    </p><p style="color:blue;">fsync操作必须在每个打开的表上运行，而不是在单个文件上运行。因为每个文件都有一个单独的fsync操作，所以不能将多个表上的写操作组合到单个i/o操作中。这可能需要innodb执行更多的fsync操作。</p></li><li class="listitem"><p>
                        <a class="link" href="programs.html#mysqld" title="4.3.1&nbsp;mysqld — The MySQL Server"><span class="command"><strong>mysqld</strong></span></a> must keep one open file handle per
                        table, which may impact performance if you have numerous
                        tables in file-per-table tablespaces.
                    </p><p style="color:blue;">mysqld必须为每个表保留一个打开的文件句柄，如果每个表空间的文件中有许多表，这可能会影响性能。</p></li><li class="listitem"><p>
                        More file descriptors are used.
                    </p><p style="color:blue;">使用更多的文件描述符。</p></li><li class="listitem"><p>
                        <a class="link" href="innodb-storage-engine.html#sysvar_innodb_file_per_table"><code class="literal">innodb_file_per_table</code></a> is
                        enabled by default in MySQL 5.6 and higher. You may consider
                        disabling it if backward compatibility with earlier versions
                        of MySQL is a concern. Disabling
                        <a class="link" href="innodb-storage-engine.html#sysvar_innodb_file_per_table"><code class="literal">innodb_file_per_table</code></a>
                        prevents table-copying <a class="link" href="sql-syntax.html#alter-table" title="13.1.8&nbsp;ALTER TABLE Syntax"><code class="literal">ALTER
                        TABLE</code></a> operations from implicitly moving a table that
                        resides in the system tablespace to a file-per-table
                        tablespace.
                    </p><p style="color:blue;">InnoDB_file_per_table在MySQL 5.6及更高版本中默认启用。如果担心与早期版本的mysql向后兼容，可以考虑禁用它。禁用innodb_file_per_table可以防止表复制alter table操作隐式地将系统表空间中的表移动到file per table table space。</p><p>
                        For example, when restructuring the clustered index, the table
                        is re-created using the current setting for
                        <a class="link" href="innodb-storage-engine.html#sysvar_innodb_file_per_table"><code class="literal">innodb_file_per_table</code></a>. This
                        behavior does not apply to <a class="link" href="sql-syntax.html#alter-table" title="13.1.8&nbsp;ALTER TABLE Syntax"><code class="literal">ALTER
                        TABLE</code></a> operations that use the
                        <code class="literal">INPLACE</code> algorithm. This behavior also does
                        not apply to tables added to the system tablespace using
                        <a class="link" href="sql-syntax.html#create-table" title="13.1.18&nbsp;CREATE TABLE Syntax"><code class="literal">CREATE TABLE ...
                            TABLESPACE</code></a> or
                        <a class="link" href="sql-syntax.html#alter-table" title="13.1.8&nbsp;ALTER TABLE Syntax"><code class="literal">ALTER TABLE ...
                            TABLESPACE</code></a> syntax. These tables are not affected by
                        the <a class="link" href="innodb-storage-engine.html#sysvar_innodb_file_per_table"><code class="literal">innodb_file_per_table</code></a>
                        setting.
                    </p><p style="color:blue;">例如，重组聚集索引时，使用innodb_file_per_表的当前设置重新创建表。此行为不适用于使用inplace算法的alter table操作。此行为也不适用于使用CREATE TABLE添加到系统表空间的表…表空间或更改表…表空间语法。这些表不受innodb_file_per_table设置的影响。</p></li><li class="listitem"><p>
                        If many tables are growing there is potential for more
                        fragmentation which can impede <a class="link" href="sql-syntax.html#drop-table" title="13.1.29&nbsp;DROP TABLE Syntax"><code class="literal">DROP
                        TABLE</code></a> and table scan performance. However, when
                        fragmentation is managed, having files in their own tablespace
                        can improve performance.
                    </p><p style="color:blue;">如果许多表正在增长，则有可能出现更多的碎片，这可能会妨碍删除表和表扫描性能。但是，在管理碎片时，将文件放在自己的表空间中可以提高性能。</p></li><li class="listitem"><p>
                        The buffer pool is scanned when dropping a file-per-table
                        tablespace, which can take several seconds for buffer pools
                        that are tens of gigabytes in size. The scan is performed with
                        a broad internal lock, which may delay other operations.
                        Tables in the system tablespace are not affected.
                    </p><p style="color:blue;">删除每个表表空间的文件时会扫描缓冲池，对于大小为几十GB的缓冲池，这可能需要几秒钟的时间。扫描是用广泛的内部锁执行的，这可能会延迟其他操作。系统表空间中的表不受影响。</p></li><li class="listitem"><p>
                        The
                        <a class="link" href="innodb-storage-engine.html#sysvar_innodb_autoextend_increment"><code class="literal">innodb_autoextend_increment</code></a>
                        variable, which defines increment size (in MB) for extending
                        the size of an auto-extending shared tablespace file when it
                        becomes full, does not apply to file-per-table tablespace
                        files, which are auto-extending regardless of the
                        <a class="link" href="innodb-storage-engine.html#sysvar_innodb_autoextend_increment"><code class="literal">innodb_autoextend_increment</code></a>
                        setting. The initial extensions are by small amounts, after
                        which extensions occur in increments of 4MB.
                    </p><p style="color:blue;">innodb_autoextend_increment变量定义了增量大小（以MB为单位），用于在共享表空间文件满时扩展其大小，但它不适用于每表表表空间文件，无论innodb_autoextend_increment设置如何，这些文件都是自动扩展的。最初的扩展是少量的，之后扩展以4MB的增量出现。</p></li></ul>
                </div>
                <div class="simplesect">
                    <div class="titlepage">
                        <div>
                            <div class="simple">
                                <h5 class="title"><a name="tablespace-enabling"></a>Enabling File-Per-Table Tablespaces</h5>

                            </div>

                        </div>

                    </div>
                    <p>
                        The <a class="link" href="innodb-storage-engine.html#sysvar_innodb_file_per_table"><code class="literal">innodb_file_per_table</code></a>
                        option is enabled by default.
                    </p><p style="color:blue;">默认情况下，innodb_file_per_table选项处于启用状态。</p><p>
                    To set the
                    <a class="link" href="innodb-storage-engine.html#sysvar_innodb_file_per_table"><code class="literal">innodb_file_per_table</code></a> option at
                    startup, start the server with the
                    <a class="link" href="innodb-storage-engine.html#sysvar_innodb_file_per_table"><code class="option">--innodb-file-per-table</code></a>
                    command-line option, or add this line to the
                    <code class="literal">[mysqld]</code> section of
                    <code class="filename">my.cnf</code>:
                </p><p style="color:blue;">要在启动时设置innodb_file_per_table选项，请使用--innodb file per table命令行选项启动服务器，或者将此行添加到my.cnf的[mysqld]部分：</p><pre data-lang="none" class="programlisting">[mysqld]
innodb_file_per_table=1
</pre><p>
                    You can also set
                    <a class="link" href="innodb-storage-engine.html#sysvar_innodb_file_per_table"><code class="literal">innodb_file_per_table</code></a>
                    dynamically, while the server is running:
                </p><p style="color:blue;">您还可以在服务器运行时动态设置innodb_file_per_表：</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>SET GLOBAL innodb_file_per_table=1;</code></strong>
</pre><p>
                    With <a class="link" href="innodb-storage-engine.html#sysvar_innodb_file_per_table"><code class="literal">innodb_file_per_table</code></a>
                    enabled, you can store <code class="literal">InnoDB</code> tables in a
                    <code class="filename"><em class="replaceable"><code>tbl_name</code></em>.ibd</code>
                    file. Unlike the <code class="literal">MyISAM</code> storage engine, with
                    its separate
                    <code class="filename"><em class="replaceable"><code>tbl_name</code></em>.MYD</code> and
                    <code class="filename"><em class="replaceable"><code>tbl_name</code></em>.MYI</code>
                    files for indexes and data, <code class="literal">InnoDB</code> stores the
                    data and the indexes together in a single
                    <code class="filename">.ibd</code> file. The
                    <code class="filename"><em class="replaceable"><code>tbl_name</code></em>.frm</code>
                    file is still created as usual.
                </p><p style="color:blue;">启用innodb_file_per_table后，可以将innodb tables存储在tbl_name.ibd文件中。与myisam存储引擎不同，innodb将数据和索引一起存储在一个.ibd文件中，myisam存储引擎有单独的tbl_name.myd和tbl_name.myi文件用于索引和数据。tbl_name.frm文件仍像往常一样创建。</p><p>
                    If you disable
                    <a class="link" href="innodb-storage-engine.html#sysvar_innodb_file_per_table"><code class="literal">innodb_file_per_table</code></a> in your
                    startup options and restart the server, or disable it with the
                    <code class="literal">SET GLOBAL</code> command, <code class="literal">InnoDB</code>
                    creates new tables inside the system tablespace unless you have
                    explicitly placed the table in file-per-table tablespace or
                    general tablespace using the
                    <a class="link" href="sql-syntax.html#alter-table" title="13.1.8&nbsp;ALTER TABLE Syntax"><code class="literal">CREATE TABLE ...
                        TABLESPACE</code></a> option.
                </p><p style="color:blue;">如果在启动选项中禁用innodb_file_per_table并重新启动服务器，或者使用set global命令禁用它，innodb将在系统表空间中创建新表，除非使用create table将表显式地放置在file per table space或general table space中…表空间选项。</p><p>
                    You can always read and write any <code class="literal">InnoDB</code>
                    tables, regardless of the file-per-table setting.
                </p><p style="color:blue;">您总是可以读取和写入任何innodb表，而不必考虑每个表的文件设置。</p><p>
                    To move a table from the system tablespace to its own
                    tablespace, change the
                    <a class="link" href="innodb-storage-engine.html#sysvar_innodb_file_per_table"><code class="literal">innodb_file_per_table</code></a> setting
                    and rebuild the table:
                </p><p style="color:blue;">要将表从系统表空间移动到自己的表空间，请更改innodb_file_per_table设置并重新生成表：</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>SET GLOBAL innodb_file_per_table=1;</code></strong>
mysql&gt; <strong class="userinput"><code>ALTER TABLE <em class="replaceable"><code>table_name</code></em> ENGINE=InnoDB;</code></strong>
</pre><p>
                    Tables added to the system tablespace using
                    <a class="link" href="sql-syntax.html#create-table" title="13.1.18&nbsp;CREATE TABLE Syntax"><code class="literal">CREATE TABLE ...
                        TABLESPACE</code></a> or
                    <a class="link" href="sql-syntax.html#alter-table" title="13.1.8&nbsp;ALTER TABLE Syntax"><code class="literal">ALTER TABLE ...
                        TABLESPACE</code></a> syntax are not affected by the
                    <a class="link" href="innodb-storage-engine.html#sysvar_innodb_file_per_table"><code class="literal">innodb_file_per_table</code></a> setting.
                    To move these tables from the system tablespace to a
                    file-per-table tablespace, they must be moved explicitly using
                    <a class="link" href="sql-syntax.html#alter-table" title="13.1.8&nbsp;ALTER TABLE Syntax"><code class="literal">ALTER TABLE ...
                        TABLESPACE</code></a> syntax.
                </p><p style="color:blue;">使用CREATE TABLE添加到系统表空间的表…表空间或更改表…表空间语法不受innodb_file_per_表设置的影响。要将这些表从系统表空间移动到每表表空间一个文件，必须使用alter table显式移动它们…表空间语法。</p>
                    <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">

                        <div class="admon-title">
                            Note
                        </div>
                        <p>
                            <code class="literal">InnoDB</code> always needs the system tablespace
                            because it puts its internal
                            <a class="link" href="glossary.html#glos_data_dictionary" title="data dictionary">data dictionary</a>
                            and <a class="link" href="glossary.html#glos_undo_log" title="undo log">undo logs</a> there. The
                            <code class="filename">.ibd</code> files are not sufficient for
                            <code class="literal">InnoDB</code> to operate.
                        </p><p style="color:blue;">InnoDB总是需要系统表空间，因为它将其内部数据字典和撤销日志放在那里。.ibd文件不足以让innodb运行。</p><p>
                        When a table is moved out of the system tablespace into its
                        own <code class="filename">.ibd</code> file, the data files that make
                        up the system tablespace remain the same size. The space
                        formerly occupied by the table can be reused for new
                        <code class="literal">InnoDB</code> data, but is not reclaimed for use
                        by the operating system. When moving large
                        <code class="literal">InnoDB</code> tables out of the system tablespace,
                        where disk space is limited, you may prefer to enable
                        <a class="link" href="innodb-storage-engine.html#sysvar_innodb_file_per_table"><code class="literal">innodb_file_per_table</code></a> and
                        recreate the entire instance using the
                        <a class="link" href="programs.html#mysqldump" title="4.5.4&nbsp;mysqldump — A Database Backup Program"><span class="command"><strong>mysqldump</strong></span></a> command. As mentioned above,
                        tables added to the system tablespace using
                        <a class="link" href="sql-syntax.html#create-table" title="13.1.18&nbsp;CREATE TABLE Syntax"><code class="literal">CREATE TABLE ...
                            TABLESPACE</code></a> or
                        <a class="link" href="sql-syntax.html#alter-table" title="13.1.8&nbsp;ALTER TABLE Syntax"><code class="literal">ALTER TABLE ...
                            TABLESPACE</code></a> syntax are not affected by the
                        <a class="link" href="innodb-storage-engine.html#sysvar_innodb_file_per_table"><code class="literal">innodb_file_per_table</code></a>
                        setting. These tables must be moved individually.
                    </p><p style="color:blue;">当表从系统表空间移到自己的.ibd文件中时，组成系统表空间的数据文件将保持相同的大小。表以前占用的空间可以重新用于新的innodb数据，但不能回收供操作系统使用。在磁盘空间有限的情况下，将大型innodb表移出系统表空间时，您可能希望启用innodb_file_per_表，并使用mysqldump命令重新创建整个实例。如上所述，使用CREATETABLE添加到系统表空间的表…表空间或更改表…表空间语法不受innodb_file_per_表设置的影响。这些表必须单独移动。</p>
                    </div>

                </div>

            </div>
            <div class="section">
                <div class="titlepage">
                    <div>
                        <div>
                            <h4 class="title"><a name="general-tablespaces"></a>14.6.3.3&nbsp;General Tablespaces</h4>

                        </div>

                    </div>

                </div>
                <p>
                    A general tablespace is a shared <code class="literal">InnoDB</code>
                    tablespace that is created using <a class="link" href="sql-syntax.html#create-tablespace" title="13.1.19&nbsp;CREATE TABLESPACE Syntax"><code class="literal">CREATE
                    TABLESPACE</code></a> syntax. General tablespace capabilities and
                    features are described under the following topics in this section:
                </p><p style="color:blue;">通用表空间是使用create tablespace语法创建的一个共享innodb表空间。本节中的以下主题介绍了一般表空间功能和特性：</p>
                <div class="itemizedlist">
                    <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><a class="xref" href="innodb-storage-engine.html#general-tablespaces-capabilities" title="General Tablespace Capabilities">General Tablespace Capabilities</a></p><p style="color:blue;">一般表空间功能</p></li><li class="listitem"><p><a class="xref" href="innodb-storage-engine.html#general-tablespaces-creating" title="Creating a General Tablespace">Creating a General Tablespace</a></p><p style="color:blue;">创建常规表空间</p></li><li class="listitem"><p><a class="xref" href="innodb-storage-engine.html#general-tablespaces-adding-tables" title="Adding Tables to a General Tablespace">Adding Tables to a General Tablespace</a></p><p style="color:blue;">向常规表空间添加表</p></li><li class="listitem"><p><a class="xref" href="innodb-storage-engine.html#general-tablespaces-row-format-support" title="General Tablespace Row Format Support">General Tablespace Row Format Support</a></p><p style="color:blue;">常规表空间行格式支持</p></li><li class="listitem"><p><a class="xref" href="innodb-storage-engine.html#general-tablespaces-moving-non-partitioned-tables" title="Moving Tables Between Tablespaces Using ALTER TABLE">Moving Tables Between Tablespaces Using ALTER TABLE</a></p><p style="color:blue;">使用alter table在表空间之间移动表</p></li><li class="listitem"><p><a class="xref" href="innodb-storage-engine.html#general-tablespaces-dropping" title="Dropping a General Tablespace">Dropping a General Tablespace</a></p><p style="color:blue;">删除常规表空间</p></li><li class="listitem"><p><a class="xref" href="innodb-storage-engine.html#general-tablespaces-limitations" title="General Tablespace Limitations">General Tablespace Limitations</a></p><p style="color:blue;">一般表空间限制</p></li></ul>
                </div>

                <div class="simplesect">

                    <div class="titlepage">
                        <div>

                            <div class="simple">
                                <h5 class="title"><a name="general-tablespaces-capabilities"></a>General Tablespace Capabilities</h5>

                            </div>

                        </div>

                    </div>
                    <p>
                        The general tablespace feature provides the following
                        capabilities:
                    </p><p style="color:blue;">常规表空间功能提供以下功能：</p>
                    <div class="itemizedlist">
                        <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                            Similar to the system tablespace, general tablespaces are
                            shared tablespaces that can store data for multiple tables.
                        </p><p style="color:blue;">与系统表空间类似，通用表空间是可以存储多个表的数据的共享表空间。</p></li><li class="listitem"><p>
                            General tablespaces have a potential memory advantage over
                            <a class="link" href="innodb-storage-engine.html#innodb-multiple-tablespaces" title="14.6.3.2&nbsp;File-Per-Table Tablespaces">file-per-table
                                tablespaces</a>. The server keeps tablespace metadata in
                            memory for the lifetime of a tablespace. Multiple tables in
                            fewer general tablespaces consume less memory for tablespace
                            metadata than the same number of tables in separate
                            file-per-table tablespaces.
                        </p><p style="color:blue;">与按表文件表空间相比，常规表空间具有潜在的内存优势。服务器在表空间的生存期内将表空间元数据保存在内存中。与每个表空间单独文件中相同数量的表相比，在较少的常规表空间中的多个表消耗更少的表空间元数据内存。</p></li><li class="listitem"><p>
                            General tablespace data files may be placed in a directory
                            relative to or independent of the MySQL data directory,
                            which provides you with many of the data file and storage
                            management capabilities of
                            <a class="link" href="innodb-storage-engine.html#innodb-multiple-tablespaces" title="14.6.3.2&nbsp;File-Per-Table Tablespaces">file-per-table
                                tablespaces</a>. As with file-per-table tablespaces, the
                            ability to place data files outside of the MySQL data
                            directory allows you to manage performance of critical
                            tables separately, setup RAID or DRBD for specific tables,
                            or bind tables to particular disks, for example.
                        </p><p style="color:blue;">一般表空间数据文件可以放在相对于或独立于mysql数据目录的目录中，该目录为您提供了每个表空间文件的许多数据文件和存储管理功能。与按表文件表空间一样，将数据文件放在mysql数据目录之外的功能允许您分别管理关键表的性能，为特定表设置raid或drbd，或者将表绑定到特定磁盘。</p></li><li class="listitem"><p>
                            General tablespaces support both Antelope and Barracuda file
                            formats, and therefore support all table row formats and
                            associated features. With support for both file formats,
                            general tablespaces have no dependence on
                            <a class="link" href="innodb-storage-engine.html#sysvar_innodb_file_format"><code class="literal">innodb_file_format</code></a> or
                            <a class="link" href="innodb-storage-engine.html#sysvar_innodb_file_per_table"><code class="literal">innodb_file_per_table</code></a>
                            settings, nor do these variables have any effect on general
                            tablespaces.
                        </p><p style="color:blue;">通用表空间支持羚羊和梭鱼文件格式，因此支持所有表行格式和相关功能。在支持这两种文件格式的情况下，通用表空间不依赖于innodb_file_格式或innodb_file_per_表设置，这些变量也不影响通用表空间。</p></li><li class="listitem"><p>
                            The <code class="literal">TABLESPACE</code> option can be used with
                            <a class="link" href="sql-syntax.html#create-table" title="13.1.18&nbsp;CREATE TABLE Syntax"><code class="literal">CREATE TABLE</code></a> to create tables
                            in a general tablespaces, file-per-table tablespace, or in
                            the system tablespace.
                        </p><p style="color:blue;">tablespace选项可与create table一起用于在常规表空间、每个表空间的文件或系统表空间中创建表。</p></li><li class="listitem"><p>
                            The <code class="literal">TABLESPACE</code> option can be used with
                            <a class="link" href="sql-syntax.html#alter-table" title="13.1.8&nbsp;ALTER TABLE Syntax"><code class="literal">ALTER TABLE</code></a> to move tables
                            between general tablespaces, file-per-table tablespaces, and
                            the system tablespace. Previously, it was not possible to
                            move a table from a file-per-table tablespace to the system
                            tablespace. With the general tablespace feature, you can now
                            do so.
                        </p><p style="color:blue;">tablespace选项可与alter table一起用于在常规表空间、逐表文件表空间和系统表空间之间移动表。以前，不可能将表从文件/表空间移动到系统表空间。使用常规表空间功能，现在可以这样做了。</p></li></ul>
                    </div>

                </div>
                <div class="simplesect">
                    <div class="titlepage">
                        <div>
                            <div class="simple">
                                <h5 class="title"><a name="general-tablespaces-creating"></a>Creating a General Tablespace</h5>

                            </div>

                        </div>

                    </div>
                    <p>
                        General tablespaces are created using
                        <a class="link" href="sql-syntax.html#create-tablespace" title="13.1.19&nbsp;CREATE TABLESPACE Syntax"><code class="literal">CREATE TABLESPACE</code></a> syntax.
                    </p><p style="color:blue;">一般的表空间是使用create tablespace语法创建的。</p><pre data-lang="sql" class="programlisting">CREATE TABLESPACE <em class="replaceable"><code>tablespace_name</code></em>
    ADD DATAFILE '<em class="replaceable"><code>file_name</code></em>'
    [FILE_BLOCK_SIZE = <em class="replaceable"><code>value</code></em>]
        [ENGINE [=] <em class="replaceable"><code>engine_name</code></em>]</pre><p>
                    A general tablespace can be created in the data directory or
                    outside of it. To avoid conflicts with implicitly created
                    file-per-table tablespaces, creating a general tablespace in a
                    subdirectory under the data directory is not supported. When
                    creating a general tablespace outside of the data directory, the
                    directory must exist prior to creating the tablespace.
                </p><p style="color:blue;">一般表空间可以在数据目录中创建，也可以在其外部创建。为了避免与隐式创建的每表文件表空间冲突，不支持在数据目录下的子目录中创建常规表空间。当在数据目录之外创建一个通用表空间时，目录必须在创建表空间之前存在。</p><p>
                    An <a class="link" href="glossary.html#glos_isl_file" title=".isl file">.isl</a> file is created in
                    the MySQL data directory when a general tablespace is created
                    outside of the MySQL data directory.
                </p><p style="color:blue;">当在mysql数据目录之外创建常规表空间时，将在mysql数据目录中创建一个.isl文件。</p><p>
                    Examples:
                </p><p style="color:blue;">示例：</p><p>
                    Creating a general tablespace in the data directory:
                </p><p style="color:blue;">在数据目录中创建常规表空间：</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>CREATE TABLESPACE `ts1` ADD DATAFILE 'ts1.ibd' Engine=InnoDB;</code></strong>
</pre><p>
                    Creating a general tablespace in a directory outside of the data
                    directory:
                </p><p style="color:blue;">在数据目录之外的目录中创建常规表空间：</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>CREATE TABLESPACE `ts1` ADD DATAFILE '/my/tablespace/directory/ts1.ibd' Engine=InnoDB;</code></strong>
</pre><p>
                    You can specify a path that is relative to the data directory as
                    long as the tablespace directory is not under the data
                    directory. In this example, the
                    <code class="filename">my_tablespace</code> directory is at the same
                    level as the data directory:
                </p><p style="color:blue;">只要表空间目录不在数据目录下，就可以指定相对于数据目录的路径。在本例中，my_tablespace目录与data目录处于同一级别：</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>CREATE TABLESPACE `ts1` ADD DATAFILE '../my_tablespace/ts1.ibd' Engine=InnoDB;</code></strong>
</pre>
                    <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">

                        <div class="admon-title">
                            Note
                        </div>
                        <p>
                            The <code class="literal">ENGINE = InnoDB</code> clause must be defined
                            as part of the <a class="link" href="sql-syntax.html#create-tablespace" title="13.1.19&nbsp;CREATE TABLESPACE Syntax"><code class="literal">CREATE
                            TABLESPACE</code></a> statement, or <code class="literal">InnoDB</code>
                            must be defined as the default storage engine
                            (<a class="link" href="server-administration.html#sysvar_default_storage_engine"><code class="literal">default_storage_engine=InnoDB</code></a>).
                        </p><p style="color:blue;">engine=innodb子句必须定义为create tablespace语句的一部分，否则innodb必须定义为默认存储引擎（默认存储引擎=innodb）。</p>
                    </div>

                </div>
                <div class="simplesect">
                    <div class="titlepage">
                        <div>
                            <div class="simple">
                                <h5 class="title"><a name="general-tablespaces-adding-tables"></a>Adding Tables to a General Tablespace</h5>

                            </div>

                        </div>

                    </div>
                    <p>
                        After creating an <code class="literal">InnoDB</code> general tablespace,
                        you can use <a class="link" href="sql-syntax.html#create-table" title="13.1.18&nbsp;CREATE TABLE Syntax"><code class="literal">CREATE
                        TABLE <em class="replaceable"><code>tbl_name</code></em> ... TABLESPACE [=]
                        <em class="replaceable"><code>tablespace_name</code></em></code></a> or
                        <a class="link" href="sql-syntax.html#alter-table" title="13.1.8&nbsp;ALTER TABLE Syntax"><code class="literal">ALTER TABLE
                            <em class="replaceable"><code>tbl_name</code></em> TABLESPACE [=]
                            <em class="replaceable"><code>tablespace_name</code></em></code></a> to add
                        tables to the tablespace, as shown in the following examples:
                    </p><p style="color:blue;">创建innodb通用表空间后，可以使用create table tbl_name…tablespace[=]tablespace_name或alter table tbl_name tablespace[=]tablespace_name将表添加到表空间，如下例所示：</p><p>
                    <a class="link" href="sql-syntax.html#create-table" title="13.1.18&nbsp;CREATE TABLE Syntax"><code class="literal">CREATE TABLE</code></a>:
                </p><p style="color:blue;">创建表：</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>CREATE TABLE t1 (c1 INT PRIMARY KEY) TABLESPACE ts1;</code></strong>
</pre><p>
                    <a class="link" href="sql-syntax.html#alter-table" title="13.1.8&nbsp;ALTER TABLE Syntax"><code class="literal">ALTER TABLE</code></a>:
                </p><p style="color:blue;">更改表：</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>ALTER TABLE t2 TABLESPACE ts1;</code></strong>
</pre>
                    <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">

                        <div class="admon-title">
                            Note
                        </div>
                        <p>
                            Support for adding table partitions to shared tablespaces was
                            deprecated in MySQL 5.7.24 and will be removed in a future
                            MySQL version. Shared tablespaces include the
                            <code class="literal">InnoDB</code> system tablespace and general
                            tablespaces.
                        </p><p style="color:blue;">在mysql 5.7.24中，不支持将表分区添加到共享表空间中，并将在以后的mysql版本中删除。共享表空间包括innodb系统表空间和通用表空间。</p>
                    </div>
                    <p>
                        For detailed syntax information, see <a class="link" href="sql-syntax.html#create-table" title="13.1.18&nbsp;CREATE TABLE Syntax"><code class="literal">CREATE
                        TABLE</code></a> and <a class="link" href="sql-syntax.html#alter-table" title="13.1.8&nbsp;ALTER TABLE Syntax"><code class="literal">ALTER TABLE</code></a>.
                    </p><p style="color:blue;">有关详细的语法信息，请参见创建表和更改表。</p>
                </div>
                <div class="simplesect">
                    <div class="titlepage">
                        <div>
                            <div class="simple">
                                <h5 class="title"><a name="general-tablespaces-row-format-support"></a>General Tablespace Row Format Support</h5>

                            </div>

                        </div>

                    </div>
                    <p>
                        General tablespaces support all table row formats
                        (<code class="literal">REDUNDANT</code>, <code class="literal">COMPACT</code>,
                        <code class="literal">DYNAMIC</code>, <code class="literal">COMPRESSED</code>) with
                        the caveat that compressed and uncompressed tables cannot
                        coexist in the same general tablespace due to different physical
                        page sizes.
                    </p><p style="color:blue;">通用表空间支持所有表行格式（冗余、紧凑、动态、压缩），警告指出，由于不同的物理页大小，压缩的和未压缩的表不能在同一个通用表空间中共存。</p><p>
                    For a general tablespace to contain compressed tables
                    (<code class="literal">ROW_FORMAT=COMPRESSED</code>),
                    <code class="literal">FILE_BLOCK_SIZE</code> must be specified, and the
                    <code class="literal">FILE_BLOCK_SIZE</code> value must be a valid
                    compressed page size in relation to the
                    <a class="link" href="innodb-storage-engine.html#sysvar_innodb_page_size"><code class="literal">innodb_page_size</code></a> value. Also,
                    the physical page size of the compressed table
                    (<code class="literal">KEY_BLOCK_SIZE</code>) must be equal to
                    <code class="literal">FILE_BLOCK_SIZE/1024</code>. For example, if
                    <a class="link" href="innodb-storage-engine.html#sysvar_innodb_page_size"><code class="literal">innodb_page_size=16KB</code></a> and
                    <code class="literal">FILE_BLOCK_SIZE=8K</code>, the
                    <code class="literal">KEY_BLOCK_SIZE</code> of the table must be 8.
                </p><p style="color:blue;">要使常规表空间包含压缩表（row_format=compressed），必须指定file_block_size，并且file_block_size值必须是相对于innodb_page_size值的有效压缩页大小。此外，压缩表的物理页大小（key_block_size）必须等于file_block_size/1024。例如，如果innodb_page_size=16kb，file_block_size=8k，则表的key_block_size必须为8。</p><p>
                    The following table shows permitted
                    <a class="link" href="innodb-storage-engine.html#sysvar_innodb_page_size"><code class="literal">innodb_page_size</code></a>,
                    <code class="literal">FILE_BLOCK_SIZE</code>, and
                    <code class="literal">KEY_BLOCK_SIZE</code> combinations.
                    <code class="literal">FILE_BLOCK_SIZE</code> values may also be specified
                    in bytes. To determine a valid <code class="literal">KEY_BLOCK_SIZE</code>
                    value for a given <code class="literal">FILE_BLOCK_SIZE</code>, divide the
                    <code class="literal">FILE_BLOCK_SIZE</code> value by 1024. Table
                    compression is not support for 32K and 64K
                    <code class="literal">InnoDB</code> page sizes. For more information about
                    <code class="literal">KEY_BLOCK_SIZE</code>, see
                    <a class="link" href="sql-syntax.html#create-table" title="13.1.18&nbsp;CREATE TABLE Syntax"><code class="literal">CREATE TABLE</code></a>, and
                    <a class="xref" href="innodb-storage-engine.html#innodb-compression-usage" title="14.9.1.2&nbsp;Creating Compressed Tables">Section&nbsp;14.9.1.2, “Creating Compressed Tables”</a>.
                </p><p style="color:blue;">下表显示了允许的innodb_page_size、file_block_size和key_block_size组合。文件块大小值也可以指定为字节。要确定给定文件块大小的有效键块大小值，请将文件块大小值除以1024。32K和64K innodb页面大小不支持表压缩。有关键块大小的详细信息，请参见创建表和第14.9.1.2节“创建压缩表”。</p>
                    <div class="table">
                        <a name="idm140286822632816"></a><p class="title"><b>Table&nbsp;14.4&nbsp;Permitted Page Size, FILE_BLOCK_SIZE, and KEY_BLOCK_SIZE Combinations
                        for Compressed Tables</b></p><p style="color:blue;">表14.4压缩表的允许页大小、文件块大小和键块大小组合</p>
                        <div class="table-contents">
                            <table frame="all"><colgroup><col width="33%"><col width="33%"><col width="34%"></colgroup><thead><tr>
                                <th scope="col">InnoDB Page Size (innodb_page_size)</th>
                                <th scope="col">Permitted FILE_BLOCK_SIZE Value</th>
                                <th scope="col">Permitted KEY_BLOCK_SIZE Value</th>
                            </tr></thead><tbody><tr>
                                <td scope="row">64KB</td>
                                <td>64K (65536)</td>
                                <td>Compression is not supported</td>
                            </tr><tr>
                                <td scope="row">32KB</td>
                                <td>32K (32768)</td>
                                <td>Compression is not supported</td>
                            </tr><tr>
                                <td scope="row">16KB</td>
                                <td>16K (16384)</td>
                                <td>N/A: If <a class="link" href="innodb-storage-engine.html#sysvar_innodb_page_size"><code class="literal">innodb_page_size</code></a> is equal to
                                    <code class="literal">FILE_BLOCK_SIZE</code>, the tablespace cannot
                                    contain a compressed table.</td>
                            </tr><tr>
                                <td scope="row">16KB</td>
                                <td>8K (8192)</td>
                                <td>8</td>
                            </tr><tr>
                                <td scope="row">16KB</td>
                                <td>4K (4096)</td>
                                <td>4</td>
                            </tr><tr>
                                <td scope="row">16KB</td>
                                <td>2K (2048)</td>
                                <td>2</td>
                            </tr><tr>
                                <td scope="row">16KB</td>
                                <td>1K (1024)</td>
                                <td>1</td>
                            </tr><tr>
                                <td scope="row">8KB</td>
                                <td>8K (8192)</td>
                                <td>N/A: If <a class="link" href="innodb-storage-engine.html#sysvar_innodb_page_size"><code class="literal">innodb_page_size</code></a> is equal to
                                    <code class="literal">FILE_BLOCK_SIZE</code>, the tablespace cannot
                                    contain a compressed table.</td>
                            </tr><tr>
                                <td scope="row">8KB</td>
                                <td>4K (4096)</td>
                                <td>4</td>
                            </tr><tr>
                                <td scope="row">8KB</td>
                                <td>2K (2048)</td>
                                <td>2</td>
                            </tr><tr>
                                <td scope="row">8KB</td>
                                <td>1K (1024)</td>
                                <td>1</td>
                            </tr><tr>
                                <td scope="row">4KB</td>
                                <td>4K (4096)</td>
                                <td>N/A: If <a class="link" href="innodb-storage-engine.html#sysvar_innodb_page_size"><code class="literal">innodb_page_size</code></a> is equal to
                                    <code class="literal">FILE_BLOCK_SIZE</code>, the tablespace cannot
                                    contain a compressed table.</td>
                            </tr><tr>
                                <td scope="row">4K</td>
                                <td>2K (2048)</td>
                                <td>2</td>
                            </tr><tr>
                                <td scope="row">4KB</td>
                                <td>1K (1024)</td>
                                <td>1</td>
                            </tr></tbody></table>
                        </div>

                    </div>
                    <br class="table-break"><p>
                    This example demonstrates creating a general tablespace and
                    adding a compressed table. The example assumes a default
                    <a class="link" href="innodb-storage-engine.html#sysvar_innodb_page_size"><code class="literal">innodb_page_size</code></a> of 16KB. The
                    <code class="literal">FILE_BLOCK_SIZE</code> of 8192 requires that the
                    compressed table have a <code class="literal">KEY_BLOCK_SIZE</code> of 8.
                </p><p style="color:blue;">此示例演示如何创建常规表空间和添加压缩表。该示例假设innodb_page_的默认大小为16kb。文件块大小8192要求压缩表的键块大小为8。</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>CREATE TABLESPACE `ts2` ADD DATAFILE 'ts2.ibd' FILE_BLOCK_SIZE = 8192 Engine=InnoDB;</code></strong>

mysql&gt; <strong class="userinput"><code>CREATE TABLE t4 (c1 INT PRIMARY KEY) TABLESPACE ts2 ROW_FORMAT=COMPRESSED KEY_BLOCK_SIZE=8;</code></strong>
</pre><p>
                    If you do not specify <code class="literal">FILE_BLOCK_SIZE</code> when
                    creating a general tablespace,
                    <code class="literal">FILE_BLOCK_SIZE</code> defaults to
                    <a class="link" href="innodb-storage-engine.html#sysvar_innodb_page_size"><code class="literal">innodb_page_size</code></a>. When
                    <code class="literal">FILE_BLOCK_SIZE</code> is equal to
                    <a class="link" href="innodb-storage-engine.html#sysvar_innodb_page_size"><code class="literal">innodb_page_size</code></a>, the
                    tablespace may only contain tables with an uncompressed row
                    format (<code class="literal">COMPACT</code>,
                    <code class="literal">REDUNDANT</code>, and <code class="literal">DYNAMIC</code> row
                    formats).
                </p><p style="color:blue;">如果在创建常规表空间时未指定file_block_size，则file_block_size默认为innodb_page_size。当file_block_size等于innodb_page_size时，表空间只能包含未压缩行格式（压缩、冗余和动态行格式）的表。</p>
                </div>
                <div class="simplesect">
                    <div class="titlepage">
                        <div>
                            <div class="simple">
                                <h5 class="title"><a name="general-tablespaces-moving-non-partitioned-tables"></a>Moving Tables Between Tablespaces Using ALTER TABLE</h5>

                            </div>

                        </div>

                    </div>
                    <p>
                        You can use <a class="link" href="sql-syntax.html#alter-table" title="13.1.8&nbsp;ALTER TABLE Syntax"><code class="literal">ALTER TABLE</code></a> with the
                        <code class="literal">TABLESPACE</code> option to move a table to an
                        existing general tablespace, to a new file-per-table tablespace,
                        or to the system tablespace.
                    </p><p style="color:blue;">您可以使用TabelStand选项将ALTER表移动到现有的通用表空间，或者将每个表表空间中的新文件移动到系统表空间。</p>
                    <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">

                        <div class="admon-title">
                            Note
                        </div>
                        <p>
                            Support for placing table partitions in shared tablespaces was
                            deprecated in MySQL 5.7.24 and will be removed in a future
                            MySQL version. Shared tablespaces include the
                            <code class="literal">InnoDB</code> system tablespace and general
                            tablespaces.
                        </p><p style="color:blue;">mysql 5.7.24不支持将表分区放在共享表空间中，并将在以后的mysql版本中删除。共享表空间包括innodb系统表空间和通用表空间。</p>
                    </div>
                    <p>
                        To move a table from a file-per-table tablespace or from the
                        system tablespace to a general tablespace, specify the name of
                        the general tablespace. The general tablespace must exist. See
                        <a class="link" href="sql-syntax.html#create-tablespace" title="13.1.19&nbsp;CREATE TABLESPACE Syntax"><code class="literal">CREATE TABLESPACE</code></a> for more
                        information.
                    </p><p style="color:blue;">要将表从文件/表空间或系统表空间移动到常规表空间，请指定常规表空间的名称。一般表空间必须存在。有关详细信息，请参见创建表空间。</p><pre data-lang="sql" class="programlisting">ALTER TABLE tbl_name TABLESPACE [=] <em class="replaceable"><code>tablespace_name</code></em>;</pre><p>
                    To move a table from a general tablespace or file-per-table
                    tablespace to the system tablespace, specify
                    <code class="literal">innodb_system</code> as the tablespace name.
                </p><p style="color:blue;">要将表从一般表空间或每个表空间的文件移到系统表空间，请指定innodb_system作为表空间名称。</p><pre data-lang="sql" class="programlisting">ALTER TABLE tbl_name TABLESPACE [=] innodb_system;</pre><p>
                    To move a table from the system tablespace or a general
                    tablespace to a file-per-table tablespace, specify
                    <code class="literal">innodb_file_per_table</code> as the tablespace name.
                </p><p style="color:blue;">要将表从系统表空间或常规表空间移动到每个表空间的文件，请指定innodb_file_per_table作为表空间名称。</p><pre data-lang="sql" class="programlisting">ALTER TABLE tbl_name TABLESPACE [=] innodb_file_per_table;</pre><p>
                    <code class="literal">ALTER TABLE ... TABLESPACE</code> operations always
                    cause a full table rebuild, even if the
                    <code class="literal">TABLESPACE</code> attribute has not changed from its
                    previous value.
                </p><p style="color:blue;">更改表…表空间操作总是会导致完整的表重建，即使表空间属性与其前一个值没有更改。</p><p>
                    <code class="literal">ALTER TABLE ... TABLESPACE</code> syntax does not
                    support moving a table from a temporary tablespace to a
                    persistent tablespace.
                </p><p style="color:blue;">更改表…表空间语法不支持将表从临时表空间移动到持久表空间。</p><p>
                    The <code class="literal">DATA DIRECTORY</code> clause is permitted with
                    <code class="literal">CREATE TABLE ...
                        TABLESPACE=innodb_file_per_table</code> but is otherwise not
                    supported for use in combination with the
                    <code class="literal">TABLESPACE</code> option.
                </p><p style="color:blue;">允许在CREATE TABLE中使用数据目录子句…tablespace=innodb_file_per_table，但不支持与tablespace选项结合使用。</p><p>
                    Restrictions apply when moving tables from encrypted
                    tablespaces. See
                    <a class="xref" href="innodb-storage-engine.html#innodb-tablespace-encryption-limitations" title="Encryption Limitations">Encryption Limitations</a>.
                </p><p style="color:blue;">从加密表空间中移动表时应用限制。请参见加密限制。</p>
                </div>
                <div class="simplesect">
                    <div class="titlepage">
                        <div>
                            <div class="simple">
                                <h5 class="title"><a name="general-tablespaces-dropping"></a>Dropping a General Tablespace</h5>

                            </div>

                        </div>

                    </div>
                    <p>
                        The <a class="link" href="sql-syntax.html#drop-tablespace" title="13.1.30&nbsp;DROP TABLESPACE Syntax"><code class="literal">DROP TABLESPACE</code></a> statement is
                        used to drop an <code class="literal">InnoDB</code> general tablespace.
                    </p><p style="color:blue;">drop tablespace语句用于删除innodb通用表空间。</p><p>
                    All tables must be dropped from the tablespace prior to a
                    <a class="link" href="sql-syntax.html#drop-tablespace" title="13.1.30&nbsp;DROP TABLESPACE Syntax"><code class="literal">DROP TABLESPACE</code></a> operation. If the
                    tablespace is not empty, <a class="link" href="sql-syntax.html#drop-tablespace" title="13.1.30&nbsp;DROP TABLESPACE Syntax"><code class="literal">DROP
                    TABLESPACE</code></a> returns an error.
                </p><p style="color:blue;">在执行删除表空间操作之前，必须从表空间中删除所有表。如果表空间不是空的，DROP TABLESPACE将返回一个错误。</p><p>
                    Use a query similar to the following to identify tables in a
                    general tablespace.
                </p><p style="color:blue;">使用类似于以下的查询来标识常规表空间中的表。</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT a.NAME AS space_name, b.NAME AS table_name FROM INFORMATION_SCHEMA.INNODB_TABLESPACES a,</code></strong>
       <strong class="userinput"><code>INFORMATION_SCHEMA.INNODB_TABLES b WHERE a.SPACE=b.SPACE AND a.NAME LIKE 'ts1';</code></strong>
+------------+------------+
| space_name | table_name |
+------------+------------+
| ts1        | test/t1    |
| ts1        | test/t2    |
| ts1        | test/t3    |
+------------+------------+
</pre><p>
                    If a <a class="link" href="sql-syntax.html#drop-tablespace" title="13.1.30&nbsp;DROP TABLESPACE Syntax"><code class="literal">DROP TABLESPACE</code></a> operation on
                    an <span class="emphasis"><em>empty</em></span> general tablespace returns an
                    error, the tablespace may contain an orphan temporary or
                    intermediate table that was left by an
                    <a class="link" href="sql-syntax.html#alter-table" title="13.1.8&nbsp;ALTER TABLE Syntax"><code class="literal">ALTER TABLE</code></a> operation that was
                    interrupted by a server exit. For more information, see
                    <a class="xref" href="innodb-storage-engine.html#innodb-troubleshooting-datadict" title="14.21.3&nbsp;Troubleshooting InnoDB Data Dictionary Operations">Section&nbsp;14.21.3, “Troubleshooting InnoDB Data Dictionary Operations”</a>.
                </p><p style="color:blue;">如果空的通用表空间上的删除表空间操作返回错误，则表空间可以包含由服务器退出中断的ALTE表操作所遗留的孤儿临时表或中间表。有关更多信息，请参阅14.21.3节，“InnoDB数据字典操作故障排除”。</p><p>
                    A general <code class="literal">InnoDB</code> tablespace is not deleted
                    automatically when the last table in the tablespace is dropped.
                    The tablespace must be dropped explicitly using
                    <a class="link" href="sql-syntax.html#drop-tablespace" title="13.1.30&nbsp;DROP TABLESPACE Syntax"><code class="literal">DROP TABLESPACE
                        <em class="replaceable"><code>tablespace_name</code></em></code></a>.
                </p><p style="color:blue;">当删除表空间中的最后一个表时，一般的innodb表空间不会自动删除。必须使用drop tablespace tablespace\u name显式删除表空间。</p><p>
                    A general tablespace does not belong to any particular database.
                    A <a class="link" href="sql-syntax.html#drop-database" title="13.1.22&nbsp;DROP DATABASE Syntax"><code class="literal">DROP DATABASE</code></a> operation can
                    drop tables that belong to a general tablespace but it cannot
                    drop the tablespace, even if the <a class="link" href="sql-syntax.html#drop-database" title="13.1.22&nbsp;DROP DATABASE Syntax"><code class="literal">DROP
                    DATABASE</code></a> operation drops all tables that belong to the
                    tablespace. A general tablespace must be dropped explicitly
                    using <a class="link" href="sql-syntax.html#drop-tablespace" title="13.1.30&nbsp;DROP TABLESPACE Syntax"><code class="literal">DROP
                    TABLESPACE <em class="replaceable"><code>tablespace_name</code></em></code></a>.
                </p><p style="color:blue;">一般表空间不属于任何特定的数据库。drop database操作可以删除属于常规表空间的表，但不能删除表空间，即使drop database操作删除了属于该表空间的所有表。必须使用drop tablespace tablespace\u name显式删除常规表空间。</p><p>
                    Similar to the system tablespace, truncating or dropping tables
                    stored in a general tablespace creates free space internally in
                    the general tablespace <a class="link" href="glossary.html#glos_ibd_file" title=".ibd file">.ibd data
                    file</a> which can only be used for new
                    <code class="literal">InnoDB</code> data. Space is not released back to
                    the operating system as it is when a file-per-table tablespace
                    is deleted during a <a class="link" href="sql-syntax.html#drop-table" title="13.1.29&nbsp;DROP TABLE Syntax"><code class="literal">DROP TABLE</code></a>
                    operation.
                </p><p style="color:blue;">与系统表空间类似，截断或删除存储在通用表空间中的表会在通用表空间.ibd数据文件内部创建可用空间，该文件只能用于新的innodb数据。空间不会释放回操作系统，因为在DROP TABLE操作过程中删除了每个表空间的文件。</p><p>
                    This example demonstrates how to drop an
                    <code class="literal">InnoDB</code> general tablespace. The general
                    tablespace <code class="literal">ts1</code> is created with a single
                    table. The table must be dropped before dropping the tablespace.
                </p><p style="color:blue;">这个例子演示了如何删除innodb通用表空间。一般表空间ts1是用一个表创建的。在删除表空间之前，必须先删除表。</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>CREATE TABLESPACE `ts1` ADD DATAFILE 'ts1.ibd' Engine=InnoDB;</code></strong>

mysql&gt; <strong class="userinput"><code>CREATE TABLE t1 (c1 INT PRIMARY KEY) TABLESPACE ts10 Engine=InnoDB;</code></strong>

mysql&gt; <strong class="userinput"><code>DROP TABLE t1;</code></strong>

mysql&gt; <strong class="userinput"><code>DROP TABLESPACE ts1;</code></strong>
</pre>
                    <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">

                        <div class="admon-title">
                            Note
                        </div>
                        <p>
                            <code class="literal"><em class="replaceable"><code>tablespace_name</code></em></code>
                            is a case-sensitive identifier in MySQL.
                        </p><p style="color:blue;">表空间名称是MySQL中区分大小写的标识符。</p>
                    </div>

                </div>
                <div class="simplesect">
                    <div class="titlepage">
                        <div>
                            <div class="simple">
                                <h5 class="title"><a name="general-tablespaces-limitations"></a>General Tablespace Limitations</h5>

                            </div>

                        </div>

                    </div>
                    <div class="itemizedlist">
                        <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                            A generated or existing tablespace cannot be changed to a
                            general tablespace.
                        </p><p style="color:blue;">生成的或现有的表空间不能更改为通用表空间。</p></li><li class="listitem"><p>
                            Creation of temporary general tablespaces is not supported.
                        </p><p style="color:blue;">不支持创建临时通用表空间。</p></li><li class="listitem"><p>
                            General tablespaces do not support temporary tables.
                        </p><p style="color:blue;">常规表空间不支持临时表。</p></li><li class="listitem"><p>
                            Tables stored in a general tablespace may only be opened in
                            MySQL releases that support general tablespaces.
                        </p><p style="color:blue;">存储在通用表空间中的表只能在支持通用表空间的mysql版本中打开。</p></li><li class="listitem"><p>
                            Similar to the system tablespace, truncating or dropping
                            tables stored in a general tablespace creates free space
                            internally in the general tablespace
                            <a class="link" href="glossary.html#glos_ibd_file" title=".ibd file">.ibd data file</a> which
                            can only be used for new <code class="literal">InnoDB</code> data.
                            Space is not released back to the operating system as it is
                            for
                            <a class="link" href="glossary.html#glos_file_per_table" title="file-per-table">file-per-table</a>
                            tablespaces.
                        </p><p style="color:blue;">与系统表空间类似，截断或删除存储在通用表空间中的表会在通用表空间.ibd数据文件内部创建可用空间，该文件只能用于新的innodb数据。空间不会释放回操作系统，因为它是针对每个表的文件表空间。</p><p>
                            Additionally, a table-copying <a class="link" href="sql-syntax.html#alter-table" title="13.1.8&nbsp;ALTER TABLE Syntax"><code class="literal">ALTER
                            TABLE</code></a> operation on table that resides in a shared
                            tablespace (a general tablespace or the system tablespace)
                            can increase the amount of space used by the tablespace.
                            Such operations require as much additional space as the data
                            in the table plus indexes. The additional space required for
                            the table-copying <a class="link" href="sql-syntax.html#alter-table" title="13.1.8&nbsp;ALTER TABLE Syntax"><code class="literal">ALTER TABLE</code></a>
                            operation is not released back to the operating system as it
                            is for file-per-table tablespaces.
                        </p><p style="color:blue;">此外，对驻留在共享表空间（一般表空间或系统表空间）中的表执行表复制alter table操作可以增加表空间使用的空间量。这样的操作需要的额外空间与表中的数据加上索引一样多。表复制alter table操作所需的额外空间不会释放回操作系统，因为它是针对每个表空间的文件的。</p></li><li class="listitem"><p>
                            <a class="link" href="sql-syntax.html#alter-table" title="13.1.8&nbsp;ALTER TABLE Syntax"><code class="literal">ALTER TABLE ...
                                DISCARD TABLESPACE</code></a> and
                            <a class="link" href="sql-syntax.html#alter-table" title="13.1.8&nbsp;ALTER TABLE Syntax"><code class="literal">ALTER TABLE
                                ...IMPORT TABLESPACE</code></a> are not supported for tables
                            that belong to a general tablespace.
                        </p><p style="color:blue;">更改表…discard tablespace和alter table…import tablespace不支持属于常规表空间的表。</p></li><li class="listitem"><p>
                            Support for placing table partitions in general tablespaces
                            was deprecated in MySQL 5.7.24 and will be removed in a
                            future MySQL version.
                        </p><p style="color:blue;">在mysql 5.7.24中，不支持将表分区放在常规表空间中，并将在以后的mysql版本中删除。</p></li></ul>
                    </div>

                </div>

            </div>
            <div class="section">
                <div class="titlepage">
                    <div>
                        <div>
                            <h4 class="title"><a name="innodb-undo-tablespaces"></a>14.6.3.4&nbsp;Undo Tablespaces</h4>

                        </div>

                    </div>

                </div>
                <a class="indexterm" name="idm140286822488688"></a><a class="indexterm" name="idm140286822487616"></a><a class="indexterm" name="idm140286822486544"></a><p>
                Undo tablespaces contain undo logs, which are collections of undo
                log records that contain information about how to undo the latest
                change by a transaction to a clustered index record. Undo logs
                exist within undo log segments, which are contained within
                rollback segments. The
                <a class="link" href="innodb-storage-engine.html#sysvar_innodb_rollback_segments"><code class="literal">innodb_rollback_segments</code></a> variable
                defines the number of rollback segments allocated to each undo
                tablespace.
            </p><p style="color:blue;">撤消表空间包含撤消日志，撤消日志是撤消日志记录的集合，其中包含有关如何撤消事务对聚集索引记录的最新更改的信息。撤消日志存在于撤消日志段中，这些日志段包含在回滚段中。innodb_rollback_segments变量定义分配给每个撤消表空间的回滚段数。</p><p>
                <a class="link" href="glossary.html#glos_undo_log" title="undo log">Undo logs</a> can be stored in
                one or more <a class="link" href="glossary.html#glos_undo_tablespace" title="undo tablespace">undo
                tablespaces</a> instead of the
                <a class="link" href="glossary.html#glos_system_tablespace" title="system tablespace">system tablespace</a>.
                This layout differs from the default configuration in which undo
                logs reside in the <a class="link" href="glossary.html#glos_system_tablespace" title="system tablespace">system
                tablespace</a>. The I/O patterns for undo logs make undo
                tablespaces good candidates for
                <a class="link" href="glossary.html#glos_ssd" title="SSD">SSD</a> storage, while keeping the
                system tablespace on hard disk storage.
            </p><p style="color:blue;">撤消日志可以存储在一个或多个撤消表空间中，而不是存储在系统表空间中。此布局与系统表空间中存在撤消日志的默认配置不同。undo日志的i/o模式使undo表空间很适合ssd存储，同时将系统表空间保留在硬盘存储上。</p><p>
                The number of undo tablespaces used by <code class="literal">InnoDB</code>
                is controlled by the
                <a class="link" href="innodb-storage-engine.html#sysvar_innodb_undo_tablespaces"><code class="literal">innodb_undo_tablespaces</code></a>
                configuration option. This option can only be configured when
                initializing the MySQL instance. It cannot be changed afterward.
            </p><p style="color:blue;">innodb使用的undo表空间的数量由innodb_undo_tablespaces配置选项控制。此选项只能在初始化mysql实例时配置。以后不能更改。</p>
                <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">

                    <div class="admon-title">
                        Note
                    </div>
                    <p>
                        The <a class="link" href="innodb-storage-engine.html#sysvar_innodb_undo_tablespaces"><code class="literal">innodb_undo_tablespaces</code></a>
                        configuration option is deprecated and will be removed in a
                        future release.
                    </p><p style="color:blue;">innodb_undo_tablespaces配置选项已弃用，将在以后的版本中删除。</p>
                </div>
                <p>
                    Undo tablespaces and individual
                    <a class="link" href="glossary.html#glos_segment" title="segment">segments</a> inside those
                    tablespaces cannot be dropped. However, undo logs stored in undo
                    tablespaces can be truncated. For more information, see
                    <a class="xref" href="innodb-storage-engine.html#truncate-undo-tablespace" title="Truncating Undo Tablespaces">Truncating Undo Tablespaces</a>.
                </p><p style="color:blue;">撤消表空间和这些表空间中的各个段不能被删除。但是，存储在undo表空间中的undo日志可以被截断。有关详细信息，请参见截断撤消表空间。</p>
                <div class="simplesect">

                    <div class="titlepage">
                        <div>

                            <div class="simple">
                                <h5 class="title"><a name="innodb-undo-tablespace-configuration"></a>Configuring Undo Tablespaces</h5>
                            </div>
                        </div>
                    </div>
                    <p>
                        To configure undo tablespaces for a MySQL instance, perform the
                        following steps. It is assumed that you are performing the
                        procedure on a test instance prior to deploying the
                        configuration to a production system.
                    </p><p style="color:blue;">要为mysql实例配置撤消表空间，请执行以下步骤。假设在将配置部署到生产系统之前，您正在测试实例上执行该过程。</p>
                    <div class="important" style="margin-left: 0.5in; margin-right: 0.5in;">

                        <div class="admon-title">
                            Important
                        </div>
                        <p>
                            The number of undo tablespaces can only be configured when
                            initializing a MySQL instance and is fixed for the life of the
                            instance.
                        </p><p style="color:blue;">只有在初始化mysql实例时才能配置undo表空间的数量，并且在实例的生命周期内是固定的。</p>
                    </div>
                    <div class="orderedlist">
                        <ol class="orderedlist" type="1"><li class="listitem"><p>
                            Specify a directory location for undo tablespaces using the
                            <a class="link" href="innodb-storage-engine.html#sysvar_innodb_undo_directory"><code class="literal">innodb_undo_directory</code></a>
                            configuration option. If a directory location is not
                            specified, undo tablespaces are created in the data
                            directory.
                        </p><p style="color:blue;">使用innodb_undo_目录配置选项指定撤消表空间的目录位置。如果未指定目录位置，则在数据目录中创建撤消表空间。</p></li><li class="listitem"><p>
                            Define the number of rollback segments using the
                            <a class="link" href="innodb-storage-engine.html#sysvar_innodb_rollback_segments"><code class="literal">innodb_rollback_segments</code></a>
                            configuration option. Start with a relatively low value and
                            increase it incrementally over time to examine the effect on
                            performance. The default setting for
                            <a class="link" href="innodb-storage-engine.html#sysvar_innodb_rollback_segments"><code class="literal">innodb_rollback_segments</code></a> is
                            128, which is also the maximum value.
                        </p><p style="color:blue;">使用innodb_rollback_segments配置选项定义回滚段的数量。从一个相对较低的值开始，并随着时间的推移逐渐增加它，以检查对性能的影响。对于NudiBuffReleBead节的默认设置是128，这也是最大值。</p><p>
                            One rollback segment is always assigned to the system
                            tablespace, and 32 rollback segments are reserved for the
                            temporary tablespace (<code class="filename">ibtmp1</code>).
                            Therefore, to allocate rollback segments to undo
                            tablespaces, set
                            <a class="link" href="innodb-storage-engine.html#sysvar_innodb_rollback_segments"><code class="literal">innodb_rollback_segments</code></a> to
                            a value greater than 33. For example, if you have two undo
                            tablespaces, set
                            <a class="link" href="innodb-storage-engine.html#sysvar_innodb_rollback_segments"><code class="literal">innodb_rollback_segments</code></a> to
                            35 to assign one rollback segment to each of the two undo
                            tablespaces. Rollback segments are distributed among undo
                            tablespaces in a circular fashion.
                        </p><p style="color:blue;">一个回滚段始终分配给系统表空间，32个回滚段保留给临时表空间（ibtmp1）。因此，要分配回滚段来撤消表空间，请将innodb_rollback_segments设置为大于33的值。例如，如果有两个撤销表空间，那么将innodb_rollback_segments设置为35，以便为两个撤销表空间中的每一个分配一个回滚段。回滚段以循环方式分布在撤消表空间中。</p><p>
                            When you configure separate undo tablespaces, the rollback
                            segment in the system tablespace is rendered inactive.
                        </p><p style="color:blue;">配置单独的撤消表空间时，系统表空间中的回滚段将呈现为非活动状态。</p></li><li class="listitem"><p>
                            Define the number of undo tablespaces using the
                            <a class="link" href="innodb-storage-engine.html#sysvar_innodb_undo_tablespaces"><code class="literal">innodb_undo_tablespaces</code></a>
                            option. The specified number of undo tablespaces is fixed
                            for the life of the MySQL instance, so if you are uncertain
                            about an optimal value, estimate on the high side.
                        </p><p style="color:blue;">使用innodb_undo_tablespaces选项定义undo表空间的数量。在mysql实例的生命周期中，指定数量的撤消表空间是固定的，因此如果您不确定最佳值，请从较高的方面进行估计。</p></li><li class="listitem"><p>
                            Create a new MySQL test instance using the option values you
                            have chosen.
                        </p><p style="color:blue;">使用您选择的选项值创建一个新的mysql测试实例。</p></li><li class="listitem"><p>
                            Use a realistic workload on your test instance with data
                            volume similar to your production servers to test the
                            configuration.
                        </p><p style="color:blue;">在测试实例上使用与生产服务器类似的数据量的实际工作负载来测试配置。</p></li><li class="listitem"><p>
                            Benchmark the performance of I/O intensive workloads.
                        </p><p style="color:blue;">对I/O密集型工作负载的性能进行基准测试。</p></li><li class="listitem"><p>
                            Periodically increase the value of
                            <a class="link" href="innodb-storage-engine.html#sysvar_innodb_rollback_segments"><code class="literal">innodb_rollback_segments</code></a>
                            and rerun performance tests until there are no further
                            improvements in I/O performance.
                        </p><p style="color:blue;">定期增加innodb_rollback_段的值，并重新运行性能测试，直到i/o性能没有进一步提高为止。</p></li></ol>
                    </div>

                </div>
                <div class="simplesect">
                    <div class="titlepage">
                        <div>
                            <div class="simple">
                                <h5 class="title"><a name="truncate-undo-tablespace"></a>Truncating Undo Tablespaces</h5>

                            </div>

                        </div>

                    </div>
                    <a class="indexterm" name="idm140286822448656"></a><a class="indexterm" name="idm140286822447584"></a><a class="indexterm" name="idm140286822446512"></a><p>
                    Truncating undo tablespaces requires that the MySQL instance
                    have a minimum of two active undo tablespaces, which ensures
                    that one undo tablespace remains active while the other is taken
                    offline to be truncated. The number of undo tablespaces is
                    defined by the
                    <a class="link" href="innodb-storage-engine.html#sysvar_innodb_undo_tablespaces"><code class="literal">innodb_undo_tablespaces</code></a>
                    variable. The default value is 0. Use this statement to check
                    the value of
                    <a class="link" href="innodb-storage-engine.html#sysvar_innodb_undo_tablespaces"><code class="literal">innodb_undo_tablespaces</code></a>:
                </p><p style="color:blue;">截断undo表空间要求mysql实例至少有两个活动的undo表空间，这样可以确保一个undo表空间保持活动状态，而另一个将脱机以截断。undo tablespaces的数量由innodb_undo_tablespaces变量定义。默认值为0。使用此语句检查innodb_undo_表空间的值：</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT @@innodb_undo_tablespaces;</code></strong>
+---------------------------+
| @@innodb_undo_tablespaces |
+---------------------------+
|                         2 |
+---------------------------+
</pre><p>
                    To have undo tablespaces truncated, enable the
                    <a class="link" href="innodb-storage-engine.html#sysvar_innodb_undo_log_truncate"><code class="literal">innodb_undo_log_truncate</code></a>
                    variable. For example:
                </p><p style="color:blue;">要截断undo表空间，请启用innodb_undo_log_truncate变量。例如：</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>SET GLOBAL innodb_undo_log_truncate=ON;</code></strong>
</pre><p>
                    When the
                    <a class="link" href="innodb-storage-engine.html#sysvar_innodb_undo_log_truncate"><code class="literal">innodb_undo_log_truncate</code></a>
                    variable is enabled, undo tablespaces that exceed the size limit
                    defined by the
                    <a class="link" href="innodb-storage-engine.html#sysvar_innodb_max_undo_log_size"><code class="literal">innodb_max_undo_log_size</code></a>
                    variable are subject to truncation. The
                    <a class="link" href="innodb-storage-engine.html#sysvar_innodb_max_undo_log_size"><code class="literal">innodb_max_undo_log_size</code></a>
                    variable is dynamic and has a default value of 1073741824 bytes
                    (1024 MiB).
                </p><p style="color:blue;">启用innodb_undo_log_truncate变量时，超过innodb_max_undo_log_size变量定义的大小限制的undo表空间将被截断。innodb_max_undo_log_size变量是动态的，默认值为1073741824字节（1024 mib）。</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT @@innodb_max_undo_log_size;</code></strong>
+----------------------------+
| @@innodb_max_undo_log_size |
+----------------------------+
|                 1073741824 |
+----------------------------+
</pre><p>
                    When the
                    <a class="link" href="innodb-storage-engine.html#sysvar_innodb_undo_log_truncate"><code class="literal">innodb_undo_log_truncate</code></a>
                    variable is enabled:
                </p><p style="color:blue;">启用innodb_undo_log_truncate变量时：</p>
                    <div class="orderedlist">
                        <ol class="orderedlist" type="1"><li class="listitem"><p>
                            Undo tablespaces that exceed the
                            <a class="link" href="innodb-storage-engine.html#sysvar_innodb_max_undo_log_size"><code class="literal">innodb_max_undo_log_size</code></a>
                            setting are marked for truncation. Selection of an undo
                            tablespace for truncation is performed in a circular fashion
                            to avoid truncating the same undo tablespace each time.
                        </p><p style="color:blue;">超过innodb_max_undo_log_size设置的undo表空间被标记为截断。选择要截断的撤消表空间是以循环方式执行的，以避免每次截断相同的撤消表空间。</p></li><li class="listitem"><p>
                            Rollback segments residing in the selected undo tablespace
                            are made inactive so that they are not assigned to new
                            transactions. Existing transactions that are currently using
                            rollback segments are permitted to finish.
                        </p><p style="color:blue;">驻留在所选撤消表空间中的回滚段处于非活动状态，因此不会将它们分配给新事务。当前使用回滚段的现有事务被允许完成。</p></li><li class="listitem"><p>
                            The <a class="link" href="glossary.html#glos_purge" title="purge">purge</a> system frees
                            rollback segments that are no longer in use.
                        </p><p style="color:blue;">清除系统释放不再使用的回滚段。</p></li><li class="listitem"><p>
                            After all rollback segments in the undo tablespace are
                            freed, the truncate operation runs and truncates the undo
                            tablespace to its initial size. The initial size of an undo
                            tablespace depends on the
                            <a class="link" href="innodb-storage-engine.html#sysvar_innodb_page_size"><code class="literal">innodb_page_size</code></a> value. For
                            the default 16KB page size, the initial undo tablespace file
                            size is 10MiB. For 4KB, 8KB, 32KB, and 64KB page sizes, the
                            initial undo tablespace files sizes are 7MiB, 8MiB, 20MiB,
                            and 40MiB, respectively.
                        </p><p style="color:blue;">在撤消表空间中的所有回滚段被释放后，truncate操作将运行并将撤消表空间截断为其初始大小。撤消表空间的初始大小取决于innodb_page_size值。对于默认的16KB页面大小，初始的撤消表空间文件大小为10MIB。对于4KB、8KB、32KB和64KB的页面大小，初始的撤消表空间文件大小分别为7MIB、8MIB、20MIB和40MIB。</p><p>
                            The size of an undo tablespace after a truncate operation
                            may be larger than the initial size due to immediate use
                            following the completion of the operation.
                        </p><p style="color:blue;">由于在操作完成后立即使用，truncate操作后撤消表空间的大小可能大于初始大小。</p><p>
                            The <a class="link" href="innodb-storage-engine.html#sysvar_innodb_undo_directory"><code class="literal">innodb_undo_directory</code></a>
                            variable defines the location of undo tablespace files. If
                            the <a class="link" href="innodb-storage-engine.html#sysvar_innodb_undo_directory"><code class="literal">innodb_undo_directory</code></a>
                            variable is undefined, undo tablespaces reside in the data
                            directory.
                        </p><p style="color:blue;">innodb_undo_目录变量定义undo表空间文件的位置。如果innodb_undo_directory变量未定义，则undo表空间位于data目录中。</p></li><li class="listitem"><p>
                            Rollback segments are reactivated so that they can be
                            assigned to new transactions.
                        </p><p style="color:blue;">回滚段将重新激活，以便可以将它们分配给新事务。</p></li></ol>
                    </div>
                    <h6><a name="idm140286822415696"></a>Expediting Truncation of Undo Tablespaces</h6><p>
                    The purge thread is responsible for emptying and truncating undo
                    tablespaces. By default, the purge thread looks for undo
                    tablespaces to truncate once every 128 times that purge is
                    invoked. The frequency with which the purge thread looks for
                    undo tablespaces to truncate is controlled by the
                    <a class="link" href="innodb-storage-engine.html#sysvar_innodb_purge_rseg_truncate_frequency"><code class="literal">innodb_purge_rseg_truncate_frequency</code></a>
                    variable, which has a default setting of 128.
                </p><p style="color:blue;">清除线程负责清空和截断撤消表空间。默认情况下，清除线程会查找撤消表空间，以便在调用清除时每128次截断一次。清除线程查找要截断的撤消表空间的频率由innodb purge rseg truncate频率变量控制，该变量的默认设置为128。</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT @@innodb_purge_rseg_truncate_frequency;</code></strong>
+----------------------------------------+
| @@innodb_purge_rseg_truncate_frequency |
+----------------------------------------+
|                                    128 |
+----------------------------------------+
</pre><p>
                    To increase that frequency, decrease the
                    <a class="link" href="innodb-storage-engine.html#sysvar_innodb_purge_rseg_truncate_frequency"><code class="literal">innodb_purge_rseg_truncate_frequency</code></a>
                    setting. For example, to have the purge thread look for undo
                    tabespaces once every 32 timees that purge is invoked, set
                    <a class="link" href="innodb-storage-engine.html#sysvar_innodb_purge_rseg_truncate_frequency"><code class="literal">innodb_purge_rseg_truncate_frequency</code></a>
                    to 32.
                </p><p style="color:blue;">要增加该频率，请减小innodb_purge_rseg_truncate_frequency设置。例如，要让purge线程每调用一次purge就查找一次undo tabespace，请将innodb_purge_rseg_truncate_frequency设置为32。</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>SET GLOBAL innodb_purge_rseg_truncate_frequency=32;</code></strong>
</pre><p>
                    When the purge thread finds an undo tablespace that requires
                    truncation, the purge thread returns with increased frequency to
                    quickly empty and truncate the undo tablespace.
                </p><p style="color:blue;">当清除线程发现需要截断的撤消表空间时，清除线程以更高的频率返回，以快速清空并截断撤消表空间。</p><h6><a name="idm140286822405536"></a>Performance Impact of Truncating Undo Tablespace Files</h6><p>
                    When an undo tablespace is truncated, the rollback segments in
                    the undo tablespace are deactivated. The active rollback
                    segments in other undo tablespaces assume responsibility for the
                    entire system load, which may result in a slight performance
                    degradation. The amount of performance degradation depends on a
                    number of factors:
                </p><p style="color:blue;">当撤消表空间被截断时，撤消表空间中的回滚段将被停用。其他undo表空间中的活动回滚段承担整个系统负载的责任，这可能会导致性能略有下降。性能下降的程度取决于许多因素：</p>
                    <div class="itemizedlist">
                        <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                            Number of undo tablespaces
                        </p><p style="color:blue;">撤消表空间数</p></li><li class="listitem"><p>
                            Number of undo logs
                        </p><p style="color:blue;">撤消日志数</p></li><li class="listitem"><p>
                            Undo tablespace size
                        </p><p style="color:blue;">撤消表空间大小</p></li><li class="listitem"><p>
                            Speed of the I/O susbsystem
                        </p><p style="color:blue;">I/O SUBSystem的速度</p></li><li class="listitem"><p>
                            Existing long running transactions
                        </p><p style="color:blue;">现有的长时间运行事务</p></li><li class="listitem"><p>
                            System load
                        </p><p style="color:blue;">系统负载</p></li></ul>
                    </div>
                    <p>
                        The easiest way to avoid impacting performance when truncating
                        undo tablespaces is to increase the number of undo tablespaces.
                    </p><p style="color:blue;">在截断撤消表空间时，避免影响性能的最简单方法是增加撤消表空间的数量。</p>
                </div>

            </div>
            <div class="section">
                <div class="titlepage">
                    <div>
                        <div>
                            <h4 class="title"><a name="innodb-temporary-tablespace"></a>14.6.3.5&nbsp;The Temporary Tablespace</h4>

                        </div>

                    </div>

                </div>
                <p>
                    Non-compressed, user-created temporary tables and on-disk internal
                    temporary tables are created in a shared temporary tablespace. The
                    <a class="link" href="innodb-storage-engine.html#sysvar_innodb_temp_data_file_path"><code class="literal">innodb_temp_data_file_path</code></a>
                    configuration option defines the relative path, name, size, and
                    attributes for temporary tablespace data files. If no value is
                    specified for
                    <a class="link" href="innodb-storage-engine.html#sysvar_innodb_temp_data_file_path"><code class="literal">innodb_temp_data_file_path</code></a>, the
                    default behavior is to create an auto-extending data file named
                    <code class="filename">ibtmp1</code> in the
                    <a class="link" href="innodb-storage-engine.html#sysvar_innodb_data_home_dir"><code class="literal">innodb_data_home_dir</code></a> directory
                    that is slightly larger than 12MB.
                </p><p style="color:blue;">在共享临时表空间中创建非压缩的、用户创建的临时表和磁盘上的内部临时表。innodb_temp_data_file_path配置选项定义临时表空间数据文件的相对路径、名称、大小和属性。如果没有为innodb_temp_data_file_path指定值，默认行为是在innodb_data_home_dir目录中创建一个名为ibtmp1的自动扩展数据文件，该文件略大于12MB。</p>
                <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">

                    <div class="admon-title">
                        Note
                    </div>
                    <p>
                        In MySQL 5.6, non-compressed temporary tables are
                        created in individual file-per-table tablespaces in the
                        temporary file directory, or in the <code class="literal">InnoDB</code>
                        system tablespace in the data directory if
                        <a class="link" href="innodb-storage-engine.html#sysvar_innodb_file_per_table"><code class="literal">innodb_file_per_table</code></a> is
                        disabled. The introduction of a shared temporary tablespace in
                        MySQL 5.7 removes performance costs associated with
                        creating and removing a file-per-table tablespace for each
                        temporary table. A dedicated temporary tablespace also means
                        that it is no longer necessary to save temporary table metadata
                        to the <code class="literal">InnoDB</code> system tables.
                    </p><p style="color:blue;">在mysql 5.6中，非压缩的临时表是在临时文件目录中的每个表空间中创建的，如果禁用了innodb_file_per_table，则在数据目录中的innodb system表空间中创建。在mysql 5.7中引入共享临时表空间，可以降低为每个临时表创建和删除每个表表空间的文件所带来的性能成本。专用的临时表空间还意味着不再需要将临时表元数据保存到innodb系统表中。</p>
                </div>
                <p>
                    Compressed temporary tables, which are temporary tables created
                    using the <code class="literal">ROW_FORMAT=COMPRESSED</code> attribute, are
                    created in
                    <a class="link" href="glossary.html#glos_file_per_table" title="file-per-table">file-per-table</a>
                    tablespaces in the temporary file directory.
                </p><p style="color:blue;">压缩临时表是使用row_format=compressed属性创建的临时表，在临时文件目录中的每个表空间的文件中创建。</p><p>
                The temporary tablespace is removed on normal shutdown or on an
                aborted initialization, and is recreated each time the server is
                started. The temporary tablespace receives a dynamically generated
                space ID when it is created. Startup is refused if the temporary
                tablespace cannot be created. The temporary tablespace is not
                removed if the server halts unexpectedly. In this case, a database
                administrator can remove the temporary tablespace manually or
                restart the server, which removes and recreates the temporary
                tablespace automatically.
            </p><p style="color:blue;">临时表空间在正常关机或中止初始化时被删除，并在每次启动服务器时重新创建。临时表空间在创建时接收动态生成的空间id。如果无法创建临时表空间，则拒绝启动。如果服务器意外停止，则不会删除临时表空间。在这种情况下，数据库管理员可以手动删除临时表空间或重新启动服务器，服务器将自动删除并重新创建临时表空间。</p><p>
                The temporary tablespace cannot reside on a raw device.
            </p><p style="color:blue;">临时表空间不能位于原始设备上。</p><p>
                <a class="link" href="information-schema.html#files-table" title="24.9&nbsp;The INFORMATION_SCHEMA FILES Table"><code class="literal">INFORMATION_SCHEMA.FILES</code></a> provides
                metadata about the <code class="literal">InnoDB</code> temporary tablespace.
                Issue a query similar to this one to view temporary tablespace
                metadata:
            </p><p style="color:blue;">information_schema.files提供关于innodb临时表空间的元数据。发出与此类似的查询以查看临时表空间元数据：</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT * FROM INFORMATION_SCHEMA.FILES WHERE TABLESPACE_NAME='innodb_temporary'\G</code></strong>
</pre><p>
                <a class="link" href="information-schema.html#innodb-temp-table-info-table" title="24.32.25&nbsp;The INFORMATION_SCHEMA INNODB_TEMP_TABLE_INFO Table"><code class="literal">INFORMATION_SCHEMA.INNODB_TEMP_TABLE_INFO</code></a>
                provides metadata about user-created temporary tables that are
                currently active within an <code class="literal">InnoDB</code> instance. For
                more information, see
                <a class="xref" href="innodb-storage-engine.html#innodb-information-schema-temp-table-info" title="14.15.7&nbsp;InnoDB INFORMATION_SCHEMA Temporary Table Info Table">Section&nbsp;14.15.7, “InnoDB INFORMATION_SCHEMA Temporary Table Info Table”</a>.
            </p><p style="color:blue;">information_schema.innodb_temp_table_info提供有关用户创建的临时表的元数据，这些临时表当前在innodb实例中处于活动状态。有关更多信息，请参阅14.15.7节，“innodb information_schema temporary table info table”。</p>
                <div class="simplesect">

                    <div class="titlepage">
                        <div>

                            <div class="simple">
                                <h5 class="title"><a name="innodb-temporary-tablespace-data-file-size"></a>Managing Temporary Tablespace Data File Size</h5>
                            </div>
                        </div>
                    </div>
                    <p>
                        By default, the temporary tablespace data file is autoextending
                        and increases in size as necessary to accommodate on-disk
                        temporary tables. For example, if an operation creates a
                        temporary table that is 20MB in size, the temporary tablespace
                        data file, which is 12MB in size by default when created,
                        extends in size to accommodate it. When temporary tables are
                        dropped, freed space can be reused for new temporary tables, but
                        the data file remains at the extended size.
                    </p><p style="color:blue;">默认情况下，临时表空间数据文件是自动扩展的，并根据需要增加大小以容纳磁盘上的临时表。例如，如果一个操作创建一个20MB大小的临时表，则临时表空间数据文件（在创建时默认为12MB）的大小将扩展以容纳它。删除临时表时，释放的空间可以重新用于新的临时表，但数据文件仍保持扩展大小。</p><p>
                    An autoextending temporary tablespace data file can become large
                    in environments that use large temporary tables or that use
                    temporary tables extensively. A large data file can also result
                    from long running queries that use temporary tables.
                </p><p style="color:blue;">在使用大型临时表或广泛使用临时表的环境中，自动扩展临时表空间数据文件可能会变大。使用临时表的长时间运行查询也可能导致大型数据文件。</p><p>
                    To determine if a temporary tablespace data file is
                    autoextending, check the
                    <a class="link" href="innodb-storage-engine.html#sysvar_innodb_temp_data_file_path"><code class="literal">innodb_temp_data_file_path</code></a>
                    setting:
                </p><p style="color:blue;">要确定临时表空间数据文件是否自动扩展，请检查innodb_temp_data_file_path设置：</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT @@innodb_temp_data_file_path;</code></strong>
+------------------------------+
| @@innodb_temp_data_file_path |
+------------------------------+
| ibtmp1:12M:autoextend        |
+------------------------------+
</pre><p>
                    To check the size of temporary tablespace data files, query the
                    <a class="link" href="information-schema.html#files-table" title="24.9&nbsp;The INFORMATION_SCHEMA FILES Table"><code class="literal">INFORMATION_SCHEMA.FILES</code></a> table
                    using a query similar to this:
                </p><p style="color:blue;">要检查临时表空间数据文件的大小，请使用类似以下的查询查询information_schema.files表：</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT FILE_NAME, TABLESPACE_NAME, ENGINE, INITIAL_SIZE, TOTAL_EXTENTS*EXTENT_SIZE</code></strong>
       <strong class="userinput"><code>AS TotalSizeBytes, DATA_FREE, MAXIMUM_SIZE FROM INFORMATION_SCHEMA.FILES</code></strong>
       <strong class="userinput"><code>WHERE TABLESPACE_NAME = 'innodb_temporary'\G</code></strong>
*************************** 1. row ***************************
      FILE_NAME: ./ibtmp1
TABLESPACE_NAME: innodb_temporary
         ENGINE: InnoDB
   INITIAL_SIZE: 12582912
 TotalSizeBytes: 12582912
      DATA_FREE: 6291456
   MAXIMUM_SIZE: NULL
</pre><p>
                    The <code class="literal">TotalSizeBytes</code> value reports the current
                    size of the temporary tablespace data file. For information
                    about other field values, see <a class="xref" href="information-schema.html#files-table" title="24.9&nbsp;The INFORMATION_SCHEMA FILES Table">Section&nbsp;24.9, “The INFORMATION_SCHEMA FILES Table”</a>.
                </p><p style="color:blue;">totalSizeBytes值报告临时表空间数据文件的当前大小。有关其他字段值的信息，请参阅24.9节“信息架构文件表”。</p><p>
                    Alternatively, check the temporary tablespace data file size on
                    your operating system. By default, the temporary tablespace data
                    file is located in the directory defined by the
                    <a class="link" href="innodb-storage-engine.html#sysvar_innodb_temp_data_file_path"><code class="literal">innodb_temp_data_file_path</code></a>
                    configuration option. If a value was not specified for this
                    option explicitly, a temporary tablespace data file named
                    <code class="literal">ibtmp1</code> is created in
                    <a class="link" href="innodb-storage-engine.html#sysvar_innodb_data_home_dir"><code class="literal">innodb_data_home_dir</code></a>, which
                    defaults to the MySQL data directory if unspecified.
                </p><p style="color:blue;">或者，检查操作系统上的临时表空间数据文件大小。默认情况下，临时表空间数据文件位于innodb_temp_data_file_path配置选项定义的目录中。如果未显式为此选项指定值，则在innodb_data_home_dir中创建名为ibtmp1的临时表空间数据文件，如果未指定，则默认为mysql数据目录。</p><p>
                    To reclaim disk space occupied by a temporary tablespace data
                    file, restart the MySQL server. Restarting the server removes
                    and recreates the temporary tablespace data file according to
                    the attributes defined by
                    <a class="link" href="innodb-storage-engine.html#sysvar_innodb_temp_data_file_path"><code class="literal">innodb_temp_data_file_path</code></a>.
                </p><p style="color:blue;">要回收临时表空间数据文件占用的磁盘空间，请重新启动mysql服务器。重新启动服务器会根据innodb_temp_data_file_path定义的属性删除并重新创建临时表空间数据文件。</p><p>
                    To prevent the temporary data file from becoming too large, you
                    can configure the
                    <a class="link" href="innodb-storage-engine.html#sysvar_innodb_temp_data_file_path"><code class="literal">innodb_temp_data_file_path</code></a>
                    option to specify a maximum file size. For example:
                </p><p style="color:blue;">为了防止临时数据文件变得太大，可以配置NoYbBuxTimeDATAXFILYPATH PATH选项来指定最大文件大小。例如：</p><pre data-lang="ini" class="programlisting">[mysqld]
innodb_temp_data_file_path=ibtmp1:12M:autoextend:max:500M
</pre><p>
                    When the data file reaches the maximum size, queries fail with
                    an error indicating that the table is full. Configuring
                    <a class="link" href="innodb-storage-engine.html#sysvar_innodb_temp_data_file_path"><code class="literal">innodb_temp_data_file_path</code></a>
                    requires restarting the server.
                </p><p style="color:blue;">当数据文件达到最大大小时，查询失败，指示表已满的错误。配置innodb_temp_data_file_path需要重新启动服务器。</p><p>
                    Alternatively, configure the
                    <a class="link" href="server-administration.html#sysvar_default_tmp_storage_engine"><code class="literal">default_tmp_storage_engine</code></a> and
                    <a class="link" href="server-administration.html#sysvar_internal_tmp_disk_storage_engine"><code class="literal">internal_tmp_disk_storage_engine</code></a>
                    options, which define the storage engine to use for user-created
                    and on-disk internal temporary tables, respectively. Both
                    options are set to <code class="literal">InnoDB</code> by default. The
                    <code class="literal">MyISAM</code> storage engine uses an individual file
                    for each temporary table, which is removed when the temporary
                    table is dropped.
                </p><p style="color:blue;">或者，配置默认的_tmp_storage_engine和内部_tmp_disk_storage_engine选项，这些选项分别定义要用于用户创建的和磁盘上的内部临时表的存储引擎。默认情况下，这两个选项都设置为innodb。myisam存储引擎为每个临时表使用一个单独的文件，该文件在删除临时表时被删除。</p>
                </div>

            </div>
            <div class="section">
                <div class="titlepage">
                    <div>
                        <div>
                            <h4 class="title"><a name="tablespace-placing"></a>14.6.3.6&nbsp;Creating a Tablespace Outside of the Data Directory</h4>

                        </div>

                    </div>

                </div>
                <p>
                    The <a class="link" href="sql-syntax.html#create-table" title="13.1.18&nbsp;CREATE TABLE Syntax"><code class="literal">CREATE TABLE ...
                    DATA DIRECTORY</code></a> clause permits creating a
                    <a class="link" href="glossary.html#glos_file_per_table" title="file-per-table">file-per-table</a>
                    tablespace outside of the data directory. For example, you can use
                    the <code class="literal">DATA DIRECTORY</code> clause to create a
                    tablespace on a separate storage device with particular
                    performance or capacity characteristics, such as a fast
                    <a class="link" href="glossary.html#glos_ssd" title="SSD">SSD</a> or a high-capacity
                    <a class="link" href="glossary.html#glos_hdd" title="HDD">HDD</a>.
                </p><p style="color:blue;">创建表…data directory子句允许在数据目录之外为每个表表空间创建一个文件。例如，可以使用data directory子句在具有特定性能或容量特性的单独存储设备（如快速ssd或高容量hdd）上创建表空间。</p><p>
                Be sure of the location that you choose. The <code class="literal">DATA
                DIRECTORY</code> clause cannot be used with
                <a class="link" href="sql-syntax.html#alter-table" title="13.1.8&nbsp;ALTER TABLE Syntax"><code class="literal">ALTER TABLE</code></a> to change the location
                later.
            </p><p style="color:blue;">确定你选择的位置。data directory子句不能与alter table一起使用，以便以后更改位置。</p><p>
                The tablespace data file is created in the specified directory,
                within in a subdirectory named for the schema to which the table
                belongs. An <a class="link" href="glossary.html#glos_isl_file" title=".isl file">isl file</a> file
                that contains the tablespace path is created in the schema
                directory, beneath the data directory. The
                <code class="filename">isl</code> file is treated like a symbolic link.
                (<a class="link" href="optimization.html#symbolic-links" title="8.12.3&nbsp;Using Symbolic Links">Using actual symbolic links</a>
                is not supported for <code class="literal">InnoDB</code> tables.)
            </p><p style="color:blue;">表空间数据文件是在指定的目录中创建的，该目录位于为表所属架构命名的子目录中。包含表空间路径的ISL文件在数据目录下的schema目录中创建。ISL文件被视为符号链接。（InnoDB表不支持使用实际的符号链接。）</p><p>
                The following example demonstrates creating a file-per-table
                tablespace outside of the data directory. It is assumed that the
                <a class="link" href="innodb-storage-engine.html#sysvar_innodb_file_per_table"><code class="literal">innodb_file_per_table</code></a> variable is
                enabled.
            </p><p style="color:blue;">下面的示例演示如何在数据目录外为每个表表空间创建文件。假定innodb_file_per_table变量已启用。</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>USE test;</code></strong>
Database changed

mysql&gt; <strong class="userinput"><code>CREATE TABLE t1 (c1 INT PRIMARY KEY) DATA DIRECTORY = '<em class="replaceable"><code>/remote/directory</code></em>';</code></strong>

# MySQL creates the tablespace file in a subdirectory that is named
# for the schema to which the table belongs

shell&gt; <strong class="userinput"><code>cd /remote/directory/test</code></strong>
shell&gt; <strong class="userinput"><code>ls</code></strong>
t1.ibd

# In the schema directory, MySQL creates an isl file that defines
# the tablespace path

shell&gt; <strong class="userinput"><code>cd /<em class="replaceable"><code>path/to/mysql</code></em>/data/test</code></strong>
shell&gt; <strong class="userinput"><code>ls</code></strong>
db.opt  t1.frm  t1.isl
</pre><p>
                <a class="link" href="sql-syntax.html#create-table" title="13.1.18&nbsp;CREATE TABLE Syntax"><code class="literal">CREATE TABLE ...
                    TABLESPACE</code></a> syntax can also be used in combination with
                the <code class="literal">DATA DIRECTORY</code> clause to create a
                file-per-table tablespace outside of the data directory. To do so,
                specify <code class="literal">innodb_file_per_table</code> as the tablespace
                name.
            </p><p style="color:blue;">创建表…表空间语法还可以与data directory子句结合使用，在数据目录之外为每个表表空间创建一个文件。为此，指定innodb_file_per_table作为表空间名。</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>CREATE TABLE t2 (c1 INT PRIMARY KEY) TABLESPACE = innodb_file_per_table</code></strong>
       <strong class="userinput"><code>DATA DIRECTORY = '/remote/directory';</code></strong>
</pre><p>
                The <a class="link" href="innodb-storage-engine.html#sysvar_innodb_file_per_table"><code class="literal">innodb_file_per_table</code></a>
                variable does not need to be enabled when using this method.
            </p><p style="color:blue;">使用此方法时，不需要启用innodb_file_per_table变量。</p>
                <h5><a name="idm140286822317920"></a>Usage Notes:</h5>
                <div class="itemizedlist">
                    <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                        MySQL initially holds the tablespace data file open,
                        preventing you from dismounting the device, but might
                        eventually close the table if the server is busy. Be careful
                        not to accidentally dismount an external device while MySQL is
                        running, or start MySQL while the device is disconnected.
                        Attempting to access a table when the associated tablespace
                        data file is missing causes a serious error that requires a
                        server restart.
                    </p><p style="color:blue;">mysql最初会保持表空间数据文件处于打开状态，从而阻止您卸载设备，但如果服务器繁忙，最终可能会关闭表。注意不要在mysql运行时意外卸载外部设备，也不要在设备断开连接时启动mysql。在关联的表空间数据文件丢失时尝试访问表会导致严重错误，需要重新启动服务器。</p><p>
                        A server restart might fail if the tablespace data file is not
                        at the expected path. In this case, manually remove the
                        <code class="literal">isl</code> file from the schema directory, and
                        after restarting, drop the table to remove the
                        <code class="filename">.frm</code> file and the information about the
                        table from the <a class="link" href="glossary.html#glos_data_dictionary" title="data dictionary">data
                        dictionary</a>.
                    </p><p style="color:blue;">如果表空间数据文件不在预期路径上，服务器重新启动可能会失败。在这种情况下，请从架构目录中手动删除ISL文件，重新启动后，删除该表以从数据字典中删除.frm文件和有关该表的信息。</p></li><li class="listitem"><p>
                        Before placing a tablespace on an NFS-mounted volume, review
                        potential issues outlined in
                        <a class="xref" href="optimization.html#disk-issues-nfs" title="Using NFS with MySQL">Using NFS with MySQL</a>.
                    </p><p style="color:blue;">在将表空间放在安装了nfs的卷上之前，请查看将nfs与mysql结合使用中概述的潜在问题。</p></li><li class="listitem"><p>
                        If using an LVM snapshot, file copy, or other file-based
                        mechanism to back up the tablespace data file, always use the
                        <a class="link" href="sql-syntax.html#flush-tables-for-export-with-list"><code class="literal">FLUSH
                            TABLES ... FOR EXPORT</code></a> statement first to ensure that
                        all changes buffered in memory are
                        <a class="link" href="glossary.html#glos_flush" title="flush">flushed</a> to disk before the
                        backup occurs.
                    </p><p style="color:blue;">如果使用lvm快照、文件副本或其他基于文件的机制备份表空间数据文件，请始终使用刷新表…for export语句首先确保在备份发生之前将内存中缓冲的所有更改刷新到磁盘。</p></li><li class="listitem"><p>
                        Using the <code class="literal">DATA DIRECTORY</code> clause is an
                        alternative to <a class="link" href="optimization.html#symbolic-links" title="8.12.3&nbsp;Using Symbolic Links">using symbolic
                        links</a>, which is not supported.
                    </p><p style="color:blue;">使用data directory子句是使用符号链接的替代方法，这是不受支持的。</p></li></ul>
                </div>

            </div>
            <div class="section">
                <div class="titlepage">
                    <div>
                        <div>
                            <h4 class="title"><a name="tablespace-copying"></a>14.6.3.7&nbsp;Copying Tablespaces to Another Instance</h4>

                        </div>

                    </div>

                </div>
                <a class="indexterm" name="idm140286822304320"></a><a class="indexterm" name="idm140286822303280"></a><a class="indexterm" name="idm140286822301792"></a><p>
                This section describes how to copy a
                <a class="link" href="glossary.html#glos_file_per_table" title="file-per-table">file-per-table</a>
                tablespace from one MySQL instance to another, otherwise known as
                the <a class="link" href="glossary.html#glos_transportable_tablespace" title="transportable tablespace">Transportable
                Tablespaces</a> feature.
            </p><p style="color:blue;">本节介绍如何将每个表表空间的文件从一个mysql实例复制到另一个mysql实例，也称为可传输表空间功能。</p><p>
                For information about other <code class="literal">InnoDB</code> table
                copying methods, see <a class="xref" href="innodb-storage-engine.html#innodb-migration" title="14.6.1.2&nbsp;Moving or Copying InnoDB Tables">Section&nbsp;14.6.1.2, “Moving or Copying InnoDB Tables”</a>.
            </p><p style="color:blue;">有关其他innodb表复制方法的信息，请参阅14.6.1.2节“移动或复制innodb表”。</p><p>
                There are many reasons why you might copy an
                <code class="literal">InnoDB</code>
                <a class="link" href="glossary.html#glos_file_per_table" title="file-per-table">file-per-table</a>
                tablespace to a different instance:
            </p><p style="color:blue;">您可以将每个表空间的innodb文件复制到不同的实例，原因有很多：</p>
                <div class="itemizedlist">
                    <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                        To run reports without putting extra load on a production
                        server.
                    </p><p style="color:blue;">在不给生产服务器增加额外负载的情况下运行报表。</p></li><li class="listitem"><p>
                        To set up identical data for a table on a new
                        <a class="link" href="glossary.html#glos_slave_server" title="slave server">slave server</a>.
                    </p><p style="color:blue;">为新从属服务器上的表设置相同的数据。</p></li><li class="listitem"><p>
                        To restore a backed-up version of a table or partition after a
                        problem or mistake.
                    </p><p style="color:blue;">在出现问题或错误后还原表或分区的备份版本。</p></li><li class="listitem"><p>
                        As a faster way of moving data around than importing the
                        results of a <a class="link" href="programs.html#mysqldump" title="4.5.4&nbsp;mysqldump — A Database Backup Program"><span class="command"><strong>mysqldump</strong></span></a> command. The data is
                        available immediately, rather than having to be re-inserted
                        and the indexes rebuilt.
                    </p><p style="color:blue;">比导入mysqldump命令的结果更快地移动数据。数据立即可用，而不必重新插入和重建索引。</p></li><li class="listitem"><p>
                        To move a
                        <a class="link" href="glossary.html#glos_file_per_table" title="file-per-table">file-per-table</a>
                        tablespace to a server with storage medium that better suits
                        system requirements. For example, you may want to have busy
                        tables on an <a class="link" href="glossary.html#glos_ssd" title="SSD">SSD</a> device, or
                        large tables on a high-capacity
                        <a class="link" href="glossary.html#glos_hdd" title="HDD">HDD</a> device.
                    </p><p style="color:blue;">将每表表空间的文件移动到具有更适合系统要求的存储介质的服务器。例如，您可能希望在ssd设备上有繁忙的表，或者在大容量hdd设备上有较大的表。</p></li></ul>
                </div>
                <h5><a name="innodb-transportable-tablespace-limitations"></a>Limitations and Usage Notes</h5>
                <div class="itemizedlist">
                    <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                        The tablespace copy procedure is only possible when
                        <a class="link" href="innodb-storage-engine.html#sysvar_innodb_file_per_table"><code class="literal">innodb_file_per_table</code></a> is set
                        to <code class="literal">ON</code>, which is the default setting. Tables
                        residing in the shared system tablespace cannot be quiesced.
                    </p><p style="color:blue;">只有当innodb_file_per_table设置为on（这是默认设置）时，才可以执行表空间复制过程。无法停止共享系统表空间中的表。</p></li><li class="listitem"><p>
                        When a table is quiesced, only read-only transactions are
                        allowed on the affected table.
                    </p><p style="color:blue;">当表静止时，受影响的表上只允许只读事务。</p></li><li class="listitem"><p>
                        When importing a tablespace, the page size must match the page
                        size of the importing instance.
                    </p><p style="color:blue;">导入表空间时，页大小必须与导入实例的页大小匹配。</p></li><li class="listitem"><p>
                        <code class="literal">DISCARD TABLESPACE</code> is not supported for
                        tablespaces with a parent-child (primary key-foreign key)
                        relationship when
                        <a class="link" href="server-administration.html#sysvar_foreign_key_checks"><code class="literal">foreign_key_checks</code></a> is set to
                        <code class="literal">1</code>. Before discarding a tablespace for
                        parent-child tables, set
                        <code class="literal">foreign_key_checks=0</code>. Partitioned
                        <code class="literal">InnoDB</code> tables do not support foreign keys.
                    </p><p style="color:blue;">当外键检查设置为1时，具有父子（主键外键）关系的表空间不支持放弃表空间。在放弃父子表的表空间之前，请将foreign_key_checks设置为0。分区的innodb表不支持外键。</p></li><li class="listitem"><p>
                        <a class="link" href="sql-syntax.html#alter-table" title="13.1.8&nbsp;ALTER TABLE Syntax"><code class="literal">ALTER TABLE ...
                            IMPORT TABLESPACE</code></a> does not enforce foreign key
                        constraints on imported data. If there are foreign key
                        constraints between tables, all tables should be exported at
                        the same (logical) point in time. Partitioned
                        <code class="literal">InnoDB</code> tables do not support foreign keys.
                    </p><p style="color:blue;">更改表…导入表空间不对导入的数据强制外键约束。如果表之间存在外键约束，则应在同一时间点（逻辑）导出所有表。分区的innodb表不支持外键。</p></li><li class="listitem"><p>
                        <a class="link" href="sql-syntax.html#alter-table" title="13.1.8&nbsp;ALTER TABLE Syntax"><code class="literal">ALTER TABLE ...
                            IMPORT TABLESPACE</code></a> and
                        <a class="link" href="sql-syntax.html#alter-table" title="13.1.8&nbsp;ALTER TABLE Syntax"><code class="literal">ALTER TABLE ...
                            IMPORT PARTITION ... TABLESPACE</code></a> do not require a
                        <code class="filename">.cfg</code> metadata file to import a
                        tablespace. However, metadata checks are not performed when
                        importing without a <code class="filename">.cfg</code> file, and a
                        warning similar to the following is issued:
                    </p><p style="color:blue;">更改表…导入表空间并更改表…导入分区…表空间不需要.cfg元数据文件来导入表空间。但是，如果导入时没有.cfg文件，则不会执行元数据检查，并且会发出类似于以下内容的警告：</p><pre data-lang="none" class="programlisting">Message: InnoDB: IO Read error: (2, No such file or directory) Error opening '.\
test\t.cfg', will attempt to import without schema verification
1 row in set (0.00 sec)
</pre><p>
                        The ability to import without a <code class="filename">.cfg</code> file
                        may be more convenient when no schema mismatches are expected.
                        Additionally, the ability to import without a
                        <code class="filename">.cfg</code> file could be useful in crash
                        recovery scenarios in which metadata cannot be collected from
                        an <code class="filename">.ibd</code> file.
                    </p><p style="color:blue;">在不需要架构不匹配的情况下，不使用.cfg文件导入可能更方便。此外，在无法从.ibd文件收集元数据的崩溃恢复场景中，可以使用不带.cfg文件的导入功能。</p></li><li class="listitem"><p>
                        Due to a <code class="literal">.cfg</code> metadata file limitation,
                        schema mismatches are not reported for partition type or
                        partition definition differences when importing tablespace
                        files for partitioned tables. Column differences are reported.
                    </p><p style="color:blue;">由于.cfg元数据文件的限制，在为分区表导入表空间文件时，不会报告分区类型或分区定义差异的架构不匹配。报告列差异。</p></li><li class="listitem"><p>
                        When running
                        <a class="link" href="sql-syntax.html#alter-table" title="13.1.8&nbsp;ALTER TABLE Syntax"><code class="literal">ALTER TABLE ...
                            DISCARD PARTITION ... TABLESPACE</code></a> and
                        <a class="link" href="sql-syntax.html#alter-table" title="13.1.8&nbsp;ALTER TABLE Syntax"><code class="literal">ALTER TABLE ...
                            IMPORT PARTITION ... TABLESPACE</code></a> on subpartitioned
                        tables, both partition and subpartition table names are
                        allowed. When a partition name is specified, subpartitions of
                        that partition are included in the operation.
                    </p><p style="color:blue;">运行alter table时…丢弃分区…表空间和alter table…导入分区…子分区表上的表空间，允许同时使用分区表名和子分区表名。指定分区名称时，该分区的子分区将包含在操作中。</p></li><li class="listitem"><p>
                        Importing a tablespace file from another MySQL server instance
                        works if both instances have GA (General Availability) status
                        and their versions are within the same series. Otherwise, the
                        file must have been created on the same server instance into
                        which it is imported.
                    </p><p style="color:blue;">从另一个mysql服务器实例导入表空间文件，如果两个实例都具有ga（通用可用性）状态，并且它们的版本在同一系列中，则可以工作。否则，文件必须是在导入到的同一服务器实例上创建的。</p></li><li class="listitem"><p>
                        In replication scenarios,
                        <a class="link" href="innodb-storage-engine.html#sysvar_innodb_file_per_table"><code class="literal">innodb_file_per_table</code></a> must be
                        set to <code class="literal">ON</code> on both the master and slave.
                    </p><p style="color:blue;">在复制场景中，必须在主表和从表上将innodb_file_per_设置为on。</p></li><li class="listitem"><p>
                        On Windows, <code class="literal">InnoDB</code> stores database,
                        tablespace, and table names internally in lowercase. To avoid
                        import problems on case-sensitive operating systems such as
                        Linux and UNIX, create all databases, tablespaces, and tables
                        using lowercase names. A convenient way to accomplish this is
                        to add the following line to the <code class="literal">[mysqld]</code>
                        section of your <code class="filename">my.cnf</code> or
                        <code class="filename">my.ini</code> file before creating databases,
                        tablespaces, or tables:
                    </p><p style="color:blue;">在windows上，innodb在内部以小写形式存储数据库、表空间和表名。为了避免在区分大小写的操作系统（如linux和unix）上出现导入问题，请使用小写名称创建所有数据库、表空间和表。一种方便的方法是在创建数据库、表空间或表之前，将以下行添加到my.cnf或my.ini文件的[mysqld]部分：</p><pre data-lang="none" class="programlisting">[mysqld]
lower_case_table_names=1
</pre></li><li class="listitem"><p>
                        <a class="link" href="sql-syntax.html#alter-table" title="13.1.8&nbsp;ALTER TABLE Syntax"><code class="literal">ALTER TABLE ...
                            DISCARD TABLESPACE</code></a> and
                        <a class="link" href="sql-syntax.html#alter-table" title="13.1.8&nbsp;ALTER TABLE Syntax"><code class="literal">ALTER TABLE
                            ...IMPORT TABLESPACE</code></a> are not supported with tables
                        that belong to an <code class="literal">InnoDB</code> general
                        tablespace. For more information, see
                        <a class="link" href="sql-syntax.html#create-tablespace" title="13.1.19&nbsp;CREATE TABLESPACE Syntax"><code class="literal">CREATE TABLESPACE</code></a>.
                    </p><p style="color:blue;">更改表…discard tablespace和alter table…import tablespace不支持属于innodb general tablespace的表。有关详细信息，请参见创建表空间。</p></li><li class="listitem"><p>
                        The default row format for <code class="literal">InnoDB</code> tables is
                        configurable using the
                        <a class="link" href="innodb-storage-engine.html#sysvar_innodb_default_row_format"><code class="literal">innodb_default_row_format</code></a>
                        configuration option. Attempting to import a table that does
                        not explicitly define a row format
                        (<code class="literal">ROW_FORMAT</code>), or that uses
                        <code class="literal">ROW_FORMAT=DEFAULT</code>, could result in a
                        schema mismatch error if the
                        <a class="link" href="innodb-storage-engine.html#sysvar_innodb_default_row_format"><code class="literal">innodb_default_row_format</code></a>
                        setting on the source instance differs from the setting on the
                        destination instance. For related information, see
                        <a class="xref" href="innodb-storage-engine.html#innodb-row-format-defining" title="Defining the Row Format of a Table">Defining the Row Format of a Table</a>.
                    </p><p style="color:blue;">innodb表的默认行格式可以使用innodb_default_row_format配置选项进行配置。如果源实例上的innodb_default_row_format设置与目标实例上的设置不同，尝试导入未显式定义行格式（row_format）或使用row_format=default的表可能会导致架构不匹配错误。有关相关信息，请参见定义表格的行格式。</p></li><li class="listitem"><p>
                        When exporting an encrypted tablespace,
                        <code class="literal">InnoDB</code> generates a
                        <code class="filename">.cfp</code> file in addition to a
                        <code class="filename">.cfg</code> metadata file. The
                        <code class="filename">.cfp</code> file must be copied to the
                        destination instance together with the
                        <code class="filename">.cfg</code> file and tablespace file before
                        performing the
                        <a class="link" href="sql-syntax.html#alter-table" title="13.1.8&nbsp;ALTER TABLE Syntax"><code class="literal">ALTER TABLE ...
                            IMPORT TABLESPACE</code></a> operation on the destination
                        instance. The <code class="filename">.cfp</code> file contains a
                        transfer key and an encrypted tablespace key. On import,
                        <code class="literal">InnoDB</code> uses the transfer key to decrypt the
                        tablespace key. For related information, see
                        <a class="xref" href="innodb-storage-engine.html#innodb-tablespace-encryption" title="14.6.3.8&nbsp;InnoDB Data-at-Rest Encryption">Section&nbsp;14.6.3.8, “InnoDB Data-at-Rest Encryption”</a>.
                    </p><p style="color:blue;">导出加密表空间时，innodb除了生成.cfg元数据文件外，还会生成一个.cfp文件。在执行alter table之前，.cfp文件必须与.cfg文件和表空间文件一起复制到目标实例…在目标实例上导入表空间操作。.cfp文件包含一个传输密钥和一个加密的表空间密钥。在导入时，innodb使用传输密钥来解密表空间密钥。有关信息，请参阅14.6.3.8节，“InnoDB静态数据加密”。</p></li><li class="listitem"><p>
                        <a class="link" href="sql-syntax.html#flush-tables-for-export-with-list"><code class="literal">FLUSH
                            TABLES ... FOR EXPORT</code></a> is not supported on tables
                        that have a FULLTEXT index. Full-text search auxiliary tables
                        are not flushed. After importing a table with a
                        <code class="literal">FULLTEXT</code> index, run
                        <a class="link" href="sql-syntax.html#optimize-table" title="13.7.2.4&nbsp;OPTIMIZE TABLE Syntax"><code class="literal">OPTIMIZE TABLE</code></a> to rebuild the
                        <code class="literal">FULLTEXT</code> indexes. Alternatively, drop
                        <code class="literal">FULLTEXT</code> indexes before the export
                        operation and recreate them after importing the table on the
                        destination instance.
                    </p><p style="color:blue;">刷新表…具有全文索引的表不支持for export。全文搜索辅助表不刷新。导入带有全文索引的表后，运行optimize table重新生成全文索引。或者，在导出操作之前删除全文索引，并在目标实例上导入表后重新创建它们。</p></li><li class="listitem"><p>
                        If the source table was created outside of the data directory
                        by specifying the <code class="literal">DATA DIRECTORY</code> clause in
                        the <a class="link" href="sql-syntax.html#create-table" title="13.1.18&nbsp;CREATE TABLE Syntax"><code class="literal">CREATE TABLE</code></a> statement, the
                        table that you replace on the destination instance must be
                        defined with the same <code class="literal">DATA DIRECTORY</code>
                        clause. A schema mismatch error is reported if the clauses do
                        not match. To determine if the source table was defined with a
                        <code class="literal">DATA DIRECTORY</code> clause, use
                        <a class="link" href="sql-syntax.html#show-create-table" title="13.7.5.10&nbsp;SHOW CREATE TABLE Syntax"><code class="literal">SHOW CREATE TABLE</code></a> to view the
                        table definition. For information about using the
                        <code class="literal">DATA DIRECTORY</code> clause, see
                        <a class="xref" href="innodb-storage-engine.html#tablespace-placing" title="14.6.3.6&nbsp;Creating a Tablespace Outside of the Data Directory">Section&nbsp;14.6.3.6, “Creating a Tablespace Outside of the Data Directory”</a>.
                    </p><p style="color:blue;">如果源表是在数据目录之外通过在CREATE TABLE语句中指定DATA DIRECTORY子句创建的，则必须使用相同的DATA DIRECTORY子句定义在目标实例上替换的表。如果子句不匹配，则报告架构不匹配错误。要确定源表是否使用数据目录子句定义，请使用show create table查看表定义。有关使用data directory子句的信息，请参阅14.6.3.6节，“在数据目录之外创建表空间”。</p></li></ul>
                </div>
                <div class="section">
                    <div class="titlepage">
                        <div>
                            <div>
                                <h5 class="title"><a name="innodb-transportable-tablespace-examples"></a>14.6.3.7.1&nbsp;Transportable Tablespace Examples</h5>

                            </div>

                        </div>

                    </div>
                    <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">
                        <div class="admon-title">
                            Note
                        </div>
                        <p>
                            If you are transporting tables that are encrypted using the
                            <code class="literal">InnoDB</code> tablespace encryption, see
                            <a class="xref" href="innodb-storage-engine.html#innodb-transportable-tablespace-limitations" title="Limitations and Usage Notes">Limitations and Usage Notes</a>
                            before you begin for additional procedural information.
                        </p><p style="color:blue;">如果要传输使用innodb表空间加密加密的表，请在开始之前参阅限制和使用说明，以获取更多过程信息。</p>
                    </div>
                    <h6><a name="idm140286822209936"></a>Example 1: Copying an InnoDB Table to Another Instance</h6><p>
                    This procedure demonstrates how to copy a regular
                    <code class="literal">InnoDB</code> table from a running MySQL server
                    instance to another running instance. The same procedure with
                    minor adjustments can be used to perform a full table restore on
                    the same instance.
                </p><p style="color:blue;">此过程演示如何将常规innodb表从正在运行的mysql服务器实例复制到另一个正在运行的实例。相同的过程和小的调整可用于在同一实例上执行完整表还原。</p>
                    <div class="orderedlist">
                        <ol class="orderedlist" type="1"><li class="listitem"><p>
                            On the source instance, create a table if one does not
                            exist:
                        </p><p style="color:blue;">在源实例上，如果不存在表，则创建表：</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>USE test;</code></strong>
mysql&gt; <strong class="userinput"><code>CREATE TABLE t(c1 INT) ENGINE=InnoDB;</code></strong>
</pre></li><li class="listitem"><p>
                            On the destination instance, create a table if one does not
                            exist:
                        </p><p style="color:blue;">在目标实例上，如果不存在表，则创建表：</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>USE test;</code></strong>
mysql&gt; <strong class="userinput"><code>CREATE TABLE t(c1 INT) ENGINE=InnoDB;</code></strong>
</pre></li><li class="listitem"><p>
                            On the destination instance, discard the existing
                            tablespace. (Before a tablespace can be imported,
                            <code class="literal">InnoDB</code> must discard the tablespace that
                            is attached to the receiving table.)
                        </p><p style="color:blue;">在目标实例上，丢弃现有的表空间。（在导入表空间之前，innodb必须放弃附加到接收表的表空间。）</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>ALTER TABLE t DISCARD TABLESPACE;</code></strong>
</pre></li><li class="listitem"><p>
                            On the source instance, run
                            <a class="link" href="sql-syntax.html#flush-tables-for-export-with-list"><code class="literal">FLUSH
                                TABLES ... FOR EXPORT</code></a> to quiesce the table and
                            create the <code class="filename">.cfg</code> metadata file:
                        </p><p style="color:blue;">在源实例上，运行刷新表…要使导出停止表并创建.cfg元数据文件，请执行以下操作：</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>USE test;</code></strong>
mysql&gt; <strong class="userinput"><code>FLUSH TABLES t FOR EXPORT;</code></strong>
</pre><p>
                            The metadata (<code class="filename">.cfg</code>) is created in the
                            <code class="literal">InnoDB</code> data directory.
                        </p><p style="color:blue;">元数据（.cfg）在innodb data目录中创建。</p>
                            <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">

                                <div class="admon-title">
                                    Note
                                </div>
                                <p>
                                    The
                                    <a class="link" href="sql-syntax.html#flush-tables-for-export-with-list"><code class="literal">FLUSH
                                        TABLES ... FOR EXPORT</code></a> statement ensures that
                                    changes to the named table have been flushed to disk so
                                    that a binary table copy can be made while the instance is
                                    running. When
                                    <a class="link" href="sql-syntax.html#flush-tables-for-export-with-list"><code class="literal">FLUSH
                                        TABLES ... FOR EXPORT</code></a> is run,
                                    <code class="literal">InnoDB</code> produces a
                                    <code class="filename">.cfg</code> file in the same database
                                    directory as the table. The <code class="filename">.cfg</code> file
                                    contains metadata used for schema verification when
                                    importing the tablespace file.
                                </p><p style="color:blue;">冲水台…for export语句确保已将对命名表的更改刷新到磁盘，以便在实例运行时生成二进制表副本。刷新表时…对于export is run，innodb在与表相同的数据库目录中生成一个.cfg文件。cfg文件包含在导入表空间文件时用于架构验证的元数据。</p>
                            </div>
                        </li><li class="listitem"><p>
                            Copy the <code class="filename">.ibd</code> file and
                            <code class="filename">.cfg</code> metadata file from the source
                            instance to the destination instance. For example:
                        </p><p style="color:blue;">将.ibd文件和.cfg元数据文件从源实例复制到目标实例。例如：</p><pre data-lang="terminal" class="programlisting">shell&gt; <strong class="userinput"><code>scp <em class="replaceable"><code>/path/to/datadir</code></em>/test/t.{ibd,cfg} destination-server:<em class="replaceable"><code>/path/to/datadir</code></em>/test</code></strong>
</pre>
                            <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">

                                <div class="admon-title">
                                    Note
                                </div>
                                <p>
                                    The <code class="filename">.ibd</code> file and
                                    <code class="filename">.cfg</code> file must be copied before
                                    releasing the shared locks, as described in the next step.
                                </p><p style="color:blue;">必须在释放共享锁之前复制.ibd文件和.cfg文件，如下一步所述。</p>
                            </div>
                        </li><li class="listitem"><p>
                            On the source instance, use
                            <a class="link" href="sql-syntax.html#lock-tables" title="13.3.5&nbsp;LOCK TABLES and UNLOCK TABLES Syntax"><code class="literal">UNLOCK
                                TABLES</code></a> to release the locks acquired by
                            <a class="link" href="sql-syntax.html#flush-tables-for-export-with-list"><code class="literal">FLUSH
                                TABLES ... FOR EXPORT</code></a>:
                        </p><p style="color:blue;">在源实例上，使用unlock tables释放flush tables获取的锁…出口：</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>USE test;</code></strong>
mysql&gt; <strong class="userinput"><code>UNLOCK TABLES;</code></strong>
</pre></li><li class="listitem"><p>
                            On the destination instance, import the tablespace:
                        </p><p style="color:blue;">在目标实例上，导入表空间：</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>USE test;</code></strong>
mysql&gt; <strong class="userinput"><code>ALTER TABLE t IMPORT TABLESPACE;</code></strong>
</pre>
                            <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">

                                <div class="admon-title">
                                    Note
                                </div>
                                <p>
                                    The <a class="link" href="sql-syntax.html#alter-table" title="13.1.8&nbsp;ALTER TABLE Syntax"><code class="literal">ALTER
                                    TABLE ... IMPORT TABLESPACE</code></a> feature does not
                                    enforce foreign key constraints on imported data. If there
                                    are foreign key constraints between tables, all tables
                                    should be exported at the same (logical) point in time. In
                                    this case you would stop updating the tables, commit all
                                    transactions, acquire shared locks on the tables, and then
                                    perform the export operation.
                                </p><p style="color:blue;">更改表…导入表空间功能不对导入的数据强制外键约束。如果表之间存在外键约束，则应在同一时间点（逻辑）导出所有表。在这种情况下，您将停止更新表、提交所有事务、获取表上的共享锁，然后执行导出操作。</p>
                            </div>
                        </li></ol>
                    </div>
                    <h6><a name="idm140286822165376"></a>Example 2: Copying an InnoDB Partitioned Table to Another Instance</h6><p>
                    This procedure demonstrates how to copy a partitioned
                    <code class="literal">InnoDB</code> table from a running MySQL server
                    instance to another running instance. The same procedure with
                    minor adjustments can be used to perform a full restore of a
                    partitioned <code class="literal">InnoDB</code> table on the same
                    instance.
                </p><p style="color:blue;">此过程演示如何将分区的innodb表从正在运行的mysql服务器实例复制到另一个正在运行的实例。可以使用经过细微调整的相同过程在同一实例上执行分区innodb表的完全还原。</p>
                    <div class="orderedlist">
                        <ol class="orderedlist" type="1"><li class="listitem"><p>
                            On the source instance, create a partitioned table if one
                            does not exist. In the following example, a table with three
                            partitions (p0, p1, p2) is created:
                        </p><p style="color:blue;">在源实例上，如果不存在分区表，则创建分区表。在下面的示例中，创建了一个具有三个分区（p0、p1、p2）的表：</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>USE test;</code></strong>
mysql&gt; <strong class="userinput"><code>CREATE TABLE t1 (i int) ENGINE = InnoDB PARTITION BY KEY (i) PARTITIONS 3;</code></strong>
</pre><p>
                            In the
                            <code class="literal">/<em class="replaceable"><code>datadir</code></em>/test</code>
                            directory, there is a separate tablespace
                            (<code class="filename">.ibd</code>) file for each of the three
                            partitions.
                        </p><p style="color:blue;">在/datadir/test目录中，三个分区中的每个分区都有一个单独的表空间（.ibd）文件。</p><pre data-lang="terminal" class="programlisting">mysql&gt; <strong class="userinput"><code>\! ls <em class="replaceable"><code>/path/to/datadir</code></em>/test/</code></strong>
db.opt  t1.frm  t1#P#p0.ibd  t1#P#p1.ibd  t1#P#p2.ibd
</pre></li><li class="listitem"><p>
                            On the destination instance, create the same partitioned
                            table:
                        </p><p style="color:blue;">在目标实例上，创建相同的分区表：</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>USE test;</code></strong>
mysql&gt; <strong class="userinput"><code>CREATE TABLE t1 (i int) ENGINE = InnoDB PARTITION BY KEY (i) PARTITIONS 3;</code></strong>
</pre><p>
                            In the
                            <code class="literal">/<em class="replaceable"><code>datadir</code></em>/test</code>
                            directory, there is a separate tablespace
                            (<code class="filename">.ibd</code>) file for each of the three
                            partitions.
                        </p><p style="color:blue;">在/datadir/test目录中，三个分区中的每个分区都有一个单独的表空间（.ibd）文件。</p><pre data-lang="terminal" class="programlisting">mysql&gt; <strong class="userinput"><code>\! ls <em class="replaceable"><code>/path/to/datadir</code></em>/test/</code></strong>
db.opt  t1.frm  t1#P#p0.ibd  t1#P#p1.ibd  t1#P#p2.ibd
</pre></li><li class="listitem"><p>
                            On the destination instance, discard the tablespace for the
                            partitioned table. (Before the tablespace can be imported on
                            the destination instance, the tablespace that is attached to
                            the receiving table must be discarded.)
                        </p><p style="color:blue;">在目标实例上，放弃分区表的表空间。（在目标实例上导入表空间之前，必须放弃附加到接收表的表空间。）</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>ALTER TABLE t1 DISCARD TABLESPACE;</code></strong>
</pre><p>
                            The three <code class="filename">.ibd</code> files that make up the
                            tablespace for the partitioned table are discarded from the
                            <code class="literal">/<em class="replaceable"><code>datadir</code></em>/test</code>
                            directory, leaving the following files:
                        </p><p style="color:blue;">构成分区表表空间的三个.ibd文件将从/datadir/test目录中丢弃，留下以下文件：</p><pre data-lang="terminal" class="programlisting">mysql&gt; <strong class="userinput"><code>\! ls <em class="replaceable"><code>/path/to/datadir</code></em>/test/</code></strong>
db.opt  t1.frm
</pre></li><li class="listitem"><p>
                            On the source instance, run
                            <a class="link" href="sql-syntax.html#flush-tables-for-export-with-list"><code class="literal">FLUSH
                                TABLES ... FOR EXPORT</code></a> to quiesce the partitioned
                            table and create the <code class="filename">.cfg</code> metadata
                            files:
                        </p><p style="color:blue;">在源实例上，运行刷新表…要使导出停止分区表并创建.cfg元数据文件，请执行以下操作：</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>USE test;</code></strong>
mysql&gt; <strong class="userinput"><code>FLUSH TABLES t1 FOR EXPORT;</code></strong>
</pre><p>
                            Metadata (<code class="filename">.cfg</code>) files, one for each
                            tablespace (<code class="filename">.ibd</code>) file, are created in
                            the
                            <code class="literal">/<em class="replaceable"><code>datadir</code></em>/test</code>
                            directory on the source instance:
                        </p><p style="color:blue;">元数据（.cfg）文件（每个表空间（.ibd）文件一个）在源实例的/datadir/test目录中创建：</p><pre data-lang="terminal" class="programlisting">mysql&gt; <strong class="userinput"><code>\! ls <em class="replaceable"><code>/path/to/datadir</code></em>/test/</code></strong>
db.opt t1#P#p0.ibd  t1#P#p1.ibd  t1#P#p2.ibd
t1.frm  t1#P#p0.cfg  t1#P#p1.cfg  t1#P#p2.cfg
</pre>
                            <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">

                                <div class="admon-title">
                                    Note
                                </div>
                                <p>
                                    <a class="link" href="sql-syntax.html#flush-tables-for-export-with-list"><code class="literal">FLUSH
                                        TABLES ... FOR EXPORT</code></a> statement ensures that
                                    changes to the named table have been flushed to disk so
                                    that binary table copy can be made while the instance is
                                    running. When
                                    <a class="link" href="sql-syntax.html#flush-tables-for-export-with-list"><code class="literal">FLUSH
                                        TABLES ... FOR EXPORT</code></a> is run,
                                    <code class="literal">InnoDB</code> produces a
                                    <code class="filename">.cfg</code> metadata file for the table's
                                    tablespace files in the same database directory as the
                                    table. The <code class="filename">.cfg</code> files contain
                                    metadata used for schema verification when importing
                                    tablespace files.
                                    <a class="link" href="sql-syntax.html#flush-tables-for-export-with-list"><code class="literal">FLUSH
                                        TABLES ... FOR EXPORT</code></a> can only be run on the
                                    table, not on individual table partitions.
                                </p><p style="color:blue;">刷新表…for export语句确保已将对命名表的更改刷新到磁盘，以便在实例运行时进行二进制表复制。刷新表时…对于export is run，innodb在与表相同的数据库目录中为表的表空间文件生成一个.cfg元数据文件。.cfg文件包含在导入表空间文件时用于架构验证的元数据。刷新表…for export只能在表上运行，不能在单个表分区上运行。</p>
                            </div>
                        </li><li class="listitem"><p>
                            Copy the <code class="filename">.ibd</code> and
                            <code class="filename">.cfg</code> files from the source instance
                            database directory to the destination instance database
                            directory. For example:
                        </p><p style="color:blue;">将.ibd和.cfg文件从源实例数据库目录复制到目标实例数据库目录。例如：</p><pre data-lang="terminal" class="programlisting">shell&gt;scp <strong class="userinput"><code><em class="replaceable"><code>/path/to/datadir</code></em>/test/t1*.{ibd,cfg} destination-server:<em class="replaceable"><code>/path/to/datadir</code></em>/test</code></strong>
</pre>
                            <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">

                                <div class="admon-title">
                                    Note
                                </div>
                                <p>
                                    The <code class="filename">.ibd</code> and
                                    <code class="filename">.cfg</code> files must be copied before
                                    releasing the shared locks, as described in the next step.
                                </p><p style="color:blue;">必须在释放共享锁之前复制.ibd和.cfg文件，如下一步所述。</p>
                            </div>
                        </li><li class="listitem"><p>
                            On the source instance, use
                            <a class="link" href="sql-syntax.html#lock-tables" title="13.3.5&nbsp;LOCK TABLES and UNLOCK TABLES Syntax"><code class="literal">UNLOCK
                                TABLES</code></a> to release the locks acquired by
                            <a class="link" href="sql-syntax.html#flush-tables-for-export-with-list"><code class="literal">FLUSH
                                TABLES ... FOR EXPORT</code></a>:
                        </p><p style="color:blue;">在源实例上，使用unlock tables释放flush tables获取的锁…出口：</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>USE test;</code></strong>
mysql&gt; <strong class="userinput"><code>UNLOCK TABLES;</code></strong>
</pre></li><li class="listitem"><p>
                            On the destination instance, import the tablespace for the
                            partitioned table:
                        </p><p style="color:blue;">在目标实例上，导入分区表的表空间：</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>USE test;</code></strong>
mysql&gt; <strong class="userinput"><code>ALTER TABLE t1 IMPORT TABLESPACE;</code></strong>
</pre></li></ol>
                    </div>
                    <h6><a name="idm140286822104576"></a>Example 3: Copying InnoDB Table Partitions to Another Instance</h6><p>
                    This procedure demonstrates how to copy
                    <code class="literal">InnoDB</code> table partitions from a running MySQL
                    server instance to another running instance. The same procedure
                    with minor adjustments can be used to perform a restore of
                    <code class="literal">InnoDB</code> table partitions on the same instance.
                    In the following example, a partitioned table with four
                    partitions (p0, p1, p2, p3) is created on the source instance.
                    Two of the partitions (p2 and p3) are copied to the destination
                    instance.
                </p><p style="color:blue;">此过程演示如何将innodb表分区从正在运行的mysql服务器实例复制到另一个正在运行的实例。同一个过程可以用来在同一个实例上执行innodb表分区的恢复。在下面的示例中，将在源实例上创建一个具有四个分区（p0、p1、p2、p3）的分区表。两个分区（p2和p3）被复制到目标实例。</p>
                    <div class="orderedlist">
                        <ol class="orderedlist" type="1"><li class="listitem"><p>
                            On the source instance, create a partitioned table if one
                            does not exist. In the following example, a table with four
                            partitions (p0, p1, p2, p3) is created:
                        </p><p style="color:blue;">在源实例上，如果不存在分区表，则创建分区表。在下面的示例中，创建了一个具有四个分区（p0、p1、p2、p3）的表：</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>USE test;</code></strong>
mysql&gt; <strong class="userinput"><code>CREATE TABLE t1 (i int) ENGINE = InnoDB PARTITION BY KEY (i) PARTITIONS 4;</code></strong>
</pre><p>
                            In the
                            <code class="literal">/<em class="replaceable"><code>datadir</code></em>/test</code>
                            directory, there is a separate tablespace
                            (<code class="filename">.ibd</code>) file for each of the four
                            partitions.
                        </p><p style="color:blue;">在/datadir/test目录中，四个分区中的每个分区都有一个单独的表空间（.ibd）文件。</p><pre data-lang="terminal" class="programlisting">mysql&gt; <strong class="userinput"><code>\! ls <em class="replaceable"><code>/path/to/datadir</code></em>/test/</code></strong>
db.opt  t1.frm  t1#P#p0.ibd  t1#P#p1.ibd  t1#P#p2.ibd t1#P#p3.ibd
</pre></li><li class="listitem"><p>
                            On the destination instance, create the same partitioned
                            table:
                        </p><p style="color:blue;">在目标实例上，创建相同的分区表：</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>USE test;</code></strong>
mysql&gt; <strong class="userinput"><code>CREATE TABLE t1 (i int) ENGINE = InnoDB PARTITION BY KEY (i) PARTITIONS 4;</code></strong>
</pre><p>
                            In the
                            <code class="literal">/<em class="replaceable"><code>datadir</code></em>/test</code>
                            directory, there is a separate tablespace
                            (<code class="filename">.ibd</code>) file for each of the four
                            partitions.
                        </p><p style="color:blue;">在/datadir/test目录中，四个分区中的每个分区都有一个单独的表空间（.ibd）文件。</p><pre data-lang="terminal" class="programlisting">mysql&gt; <strong class="userinput"><code>\! ls <em class="replaceable"><code>/path/to/datadir</code></em>/test/</code></strong>
db.opt  t1.frm  t1#P#p0.ibd  t1#P#p1.ibd  t1#P#p2.ibd t1#P#p3.ibd
</pre></li><li class="listitem"><p>
                            On the destination instance, discard the tablespace
                            partitions that you plan to import from the source instance.
                            (Before tablespace partitions can be imported on the
                            destination instance, the corresponding partitions that are
                            attached to the receiving table must be discarded.)
                        </p><p style="color:blue;">在目标实例上，放弃计划从源实例导入的表空间分区。（在目标实例上导入表空间分区之前，必须丢弃附加到接收表的相应分区。）</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>ALTER TABLE t1 DISCARD PARTITION p2, p3 TABLESPACE;</code></strong>
</pre><p>
                            The <code class="literal">.ibd</code> files for the two discarded
                            partitions are removed from the
                            <code class="literal">/<em class="replaceable"><code>datadir</code></em>/test</code>
                            directory on the destination instance, leaving the following
                            files:
                        </p><p style="color:blue;">两个被丢弃分区的.ibd文件将从目标实例上的/datadir/test目录中删除，并保留以下文件：</p><pre data-lang="terminal" class="programlisting">mysql&gt; <strong class="userinput"><code>\! ls <em class="replaceable"><code>/path/to/datadir</code></em>/test/</code></strong>
db.opt  t1.frm  t1#P#p0.ibd  t1#P#p1.ibd
</pre>
                            <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">

                                <div class="admon-title">
                                    Note
                                </div>
                                <p>
                                    When <a class="link" href="sql-syntax.html#alter-table" title="13.1.8&nbsp;ALTER TABLE Syntax"><code class="literal">ALTER
                                    TABLE ... DISCARD PARTITION ... TABLESPACE</code></a> is
                                    run on subpartitioned tables, both partition and
                                    subpartition table names are allowed. When a partition
                                    name is specified, subpartitions of that partition are
                                    included in the operation.
                                </p><p style="color:blue;">当更改表时…丢弃分区…表空间在子分区表上运行，允许同时使用分区表名和子分区表名。指定分区名称时，该分区的子分区将包含在操作中。</p>
                            </div>
                        </li><li class="listitem"><p>
                            On the source instance, run
                            <a class="link" href="sql-syntax.html#flush-tables-for-export-with-list"><code class="literal">FLUSH
                                TABLES ... FOR EXPORT</code></a> to quiesce the partitioned
                            table and create the <code class="filename">.cfg</code> metadata
                            files.
                        </p><p style="color:blue;">在源实例上，运行刷新表…用于导出以停止分区表并创建.cfg元数据文件。</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>USE test;</code></strong>
mysql&gt; <strong class="userinput"><code>FLUSH TABLES t1 FOR EXPORT;</code></strong>
</pre><p>
                            The metadata files (<code class="filename">.cfg</code> files) are
                            created in the
                            <code class="literal">/<em class="replaceable"><code>datadir</code></em>/test</code>
                            directory on the source instance. There is a
                            <code class="filename">.cfg</code> file for each tablespace
                            (<code class="filename">.ibd</code>) file.
                        </p><p style="color:blue;">元数据文件（.cfg文件）是在源实例的/datadir/test目录中创建的。每个表空间（.ibd）文件都有一个.cfg文件。</p><pre data-lang="terminal" class="programlisting">mysql&gt; <strong class="userinput"><code>\! ls <em class="replaceable"><code>/path/to/datadir</code></em>/test/</code></strong>
db.opt  t1#P#p0.ibd  t1#P#p1.ibd  t1#P#p2.ibd t1#P#p3.ibd
t1.frm  t1#P#p0.cfg  t1#P#p1.cfg  t1#P#p2.cfg t1#P#p3.cfg
</pre>
                            <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">

                                <div class="admon-title">
                                    Note
                                </div>
                                <p>
                                    <a class="link" href="sql-syntax.html#flush-tables-for-export-with-list"><code class="literal">FLUSH
                                        TABLES ... FOR EXPORT</code></a> statement ensures that
                                    changes to the named table have been flushed to disk so
                                    that binary table copy can be made while the instance is
                                    running. When
                                    <a class="link" href="sql-syntax.html#flush-tables-for-export-with-list"><code class="literal">FLUSH
                                        TABLES ... FOR EXPORT</code></a> is run,
                                    <code class="literal">InnoDB</code> produces a
                                    <code class="filename">.cfg</code> metadata file for the table's
                                    tablespace files in the same database directory as the
                                    table. The <code class="filename">.cfg</code> files contain
                                    metadata used for schema verification when importing
                                    tablespace files.
                                    <a class="link" href="sql-syntax.html#flush-tables-for-export-with-list"><code class="literal">FLUSH
                                        TABLES ... FOR EXPORT</code></a> can only be run on the
                                    table, not on individual table partitions.
                                </p><p style="color:blue;">刷新表…for export语句确保已将对命名表的更改刷新到磁盘，以便在实例运行时进行二进制表复制。刷新表时…对于export is run，innodb在与表相同的数据库目录中为表的表空间文件生成一个.cfg元数据文件。.cfg文件包含在导入表空间文件时用于架构验证的元数据。刷新表…for export只能在表上运行，不能在单个表分区上运行。</p>
                            </div>
                        </li><li class="listitem"><p>
                            Copy the <code class="filename">.ibd</code> and
                            <code class="filename">.cfg</code> files from the source instance
                            database directory to the destination instance database
                            directory. In this example, only the
                            <code class="filename">.ibd</code> and <code class="filename">.cfg</code>
                            files for partition 2 (p2) and partition 3 (p3) are copied
                            to the <code class="filename">data</code> directory on the
                            destination instance. Partition 0 (p0) and partition 1 (p1)
                            remain on the source instance.
                        </p><p style="color:blue;">将.ibd和.cfg文件从源实例数据库目录复制到目标实例数据库目录。在本例中，只有分区2（p2）和分区3（p3）的.ibd和.cfg文件被复制到目标实例上的数据目录中。分区0（P0）和分区1（P1）保留在源实例上。</p><pre data-lang="terminal" class="programlisting">shell&gt; <strong class="userinput"><code>scp t1#P#p2.ibd  t1#P#p2.cfg t1#P#p3.ibd t1#P#p3.cfg destination-server:<em class="replaceable"><code>/path/to/datadir</code></em>/test</code></strong>
</pre>
                            <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">

                                <div class="admon-title">
                                    Note
                                </div>
                                <p>
                                    The <code class="filename">.ibd</code> files and
                                    <code class="filename">.cfg</code> files must be copied before
                                    releasing the shared locks, as described in the next step.
                                </p><p style="color:blue;">必须在释放共享锁之前复制.ibd文件和.cfg文件，如下一步所述。</p>
                            </div>
                        </li><li class="listitem"><p>
                            On the source instance, use
                            <a class="link" href="sql-syntax.html#lock-tables" title="13.3.5&nbsp;LOCK TABLES and UNLOCK TABLES Syntax"><code class="literal">UNLOCK
                                TABLES</code></a> to release the locks acquired by
                            <a class="link" href="sql-syntax.html#flush-tables-for-export-with-list"><code class="literal">FLUSH
                                TABLES ... FOR EXPORT</code></a>:
                        </p><p style="color:blue;">在源实例上，使用unlock tables释放flush tables获取的锁…出口：</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>USE test;</code></strong>
mysql&gt; <strong class="userinput"><code>UNLOCK TABLES;</code></strong>
</pre></li><li class="listitem"><p>
                            On the destination instance, import the tablespace
                            partitions (p2 and p3):
                        </p><p style="color:blue;">在目标实例上，导入表空间分区（p2和p3）：</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>USE test;</code></strong>
mysql&gt; <strong class="userinput"><code>ALTER TABLE t1 IMPORT PARTITION p2, p3 TABLESPACE;</code></strong>
</pre>
                            <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">

                                <div class="admon-title">
                                    Note
                                </div>
                                <p>
                                    When <a class="link" href="sql-syntax.html#alter-table" title="13.1.8&nbsp;ALTER TABLE Syntax"><code class="literal">ALTER
                                    TABLE ... IMPORT PARTITION ... TABLESPACE</code></a> is run
                                    on subpartitioned tables, both partition and subpartition
                                    table names are allowed. When a partition name is
                                    specified, subpartitions of that partition are included in
                                    the operation.
                                </p><p style="color:blue;">当更改表时…导入分区…表空间在子分区表上运行，允许同时使用分区表名和子分区表名。指定分区名称时，该分区的子分区将包含在操作中。</p>
                            </div>
                        </li></ol>
                    </div>

                </div>
                <div class="section">
                    <div class="titlepage">
                        <div>
                            <div>
                                <h5 class="title"><a name="innodb-transportable-tablespace-internals"></a>14.6.3.7.2&nbsp;Transportable Tablespace Internals</h5>

                            </div>

                        </div>

                    </div>
                    <p>
                        The following information describes internals and error log
                        messaging for the transportable tablespaces copy procedure for a
                        regular <code class="literal">InnoDB</code> table.
                    </p><p style="color:blue;">以下信息描述了普通innodb表的可传输表空间复制过程的内部和错误日志消息。</p><p>
                    When <a class="link" href="sql-syntax.html#alter-table" title="13.1.8&nbsp;ALTER TABLE Syntax"><code class="literal">ALTER TABLE
                    ... DISCARD TABLESPACE</code></a> is run on the destination
                    instance:
                </p><p style="color:blue;">当更改表时…放弃表空间在目标实例上运行：</p>
                    <div class="itemizedlist">
                        <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                            The table is locked in X mode.
                        </p><p style="color:blue;">该表在X模式下锁定。</p></li><li class="listitem"><p>
                            The tablespace is detached from the table.
                        </p><p style="color:blue;">表空间与表分离。</p></li></ul>
                    </div>
                    <p>
                        When
                        <a class="link" href="sql-syntax.html#flush-tables-for-export-with-list"><code class="literal">FLUSH
                            TABLES ... FOR EXPORT</code></a> is run on the source instance:
                    </p><p style="color:blue;">刷新表时…for export在源实例上运行：</p>
                    <div class="itemizedlist">
                        <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                            The table being flushed for export is locked in shared mode.
                        </p><p style="color:blue;">正在刷新以便导出的表被锁定在共享模式下。</p></li><li class="listitem"><p>
                            The purge coordinator thread is stopped.
                        </p><p style="color:blue;">清除协调器线程已停止。</p></li><li class="listitem"><p>
                            Dirty pages are synchronized to disk.
                        </p><p style="color:blue;">脏页与磁盘同步。</p></li><li class="listitem"><p>
                            Table metadata is written to the binary
                            <code class="filename">.cfg</code> file.
                        </p><p style="color:blue;">表元数据被写入binary.cfg文件。</p></li></ul>
                    </div>
                    <p>
                        Expected error log messages for this operation:
                    </p><p style="color:blue;">此操作需要的错误日志消息：</p><pre data-lang="none" class="programlisting">2013-09-24T13:10:19.903526Z 2 [Note] InnoDB: Sync to disk of '"test"."t"' started.
2013-09-24T13:10:19.903586Z 2 [Note] InnoDB: Stopping purge
2013-09-24T13:10:19.903725Z 2 [Note] InnoDB: Writing table metadata to './test/t.cfg'
2013-09-24T13:10:19.904014Z 2 [Note] InnoDB: Table '"test"."t"' flushed to disk
 </pre><p>
                    When <a class="link" href="sql-syntax.html#lock-tables" title="13.3.5&nbsp;LOCK TABLES and UNLOCK TABLES Syntax"><code class="literal">UNLOCK
                    TABLES</code></a> is run on the source instance:
                </p><p style="color:blue;">在源实例上运行解锁表时：</p>
                    <div class="itemizedlist">
                        <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                            The binary .cfg file is deleted.
                        </p><p style="color:blue;">二进制文件.cfg被删除。</p></li><li class="listitem"><p>
                            The shared lock on the table or tables being imported is
                            released and the purge coordinator thread is restarted.
                        </p><p style="color:blue;">将释放正在导入的一个或多个表上的共享锁，并重新启动清除协调器线程。</p></li></ul>
                    </div>
                    <p>
                        Expected error log messages for this operation:
                    </p><p style="color:blue;">此操作需要的错误日志消息：</p><pre data-lang="none" class="programlisting">2013-09-24T13:10:21.181104Z 2 [Note] InnoDB: Deleting the meta-data file './test/t.cfg'
2013-09-24T13:10:21.181180Z 2 [Note] InnoDB: Resuming purge
</pre><p>
                    When <a class="link" href="sql-syntax.html#alter-table" title="13.1.8&nbsp;ALTER TABLE Syntax"><code class="literal">ALTER TABLE
                    ... IMPORT TABLESPACE</code></a> is run on the destination
                    instance, the import algorithm performs the following operations
                    for each tablespace being imported:
                </p><p style="color:blue;">当更改表时…导入表空间在目标实例上运行，导入算法对导入的每个表空间执行以下操作：</p>
                    <div class="itemizedlist">
                        <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                            Each tablespace page is checked for corruption.
                        </p><p style="color:blue;">检查每个表空间页是否损坏。</p></li><li class="listitem"><p>
                            The space ID and log sequence numbers (LSNs) on each page
                            are updated
                        </p><p style="color:blue;">每页上的空间ID和日志序列号（LSN）都会更新</p></li><li class="listitem"><p>
                            Flags are validated and LSN updated for the header page.
                        </p><p style="color:blue;">对标题页验证标志并更新LSN。</p></li><li class="listitem"><p>
                            Btree pages are updated.
                        </p><p style="color:blue;">更新btree页面。</p></li><li class="listitem"><p>
                            The page state is set to dirty so that it is written to
                            disk.
                        </p><p style="color:blue;">页面状态设置为脏，以便将其写入磁盘。</p></li></ul>
                    </div>
                    <p>
                        Expected error log messages for this operation:
                    </p><p style="color:blue;">此操作需要的错误日志消息：</p><pre data-lang="none" class="programlisting">2013-07-18 15:15:01 34960 [Note] InnoDB: Importing tablespace for table 'test/t' that was exported from host 'ubuntu'
2013-07-18 15:15:01 34960 [Note] InnoDB: Phase I - Update all pages
2013-07-18 15:15:01 34960 [Note] InnoDB: Sync to disk
2013-07-18 15:15:01 34960 [Note] InnoDB: Sync to disk - done!
2013-07-18 15:15:01 34960 [Note] InnoDB: Phase III - Flush changes to disk
2013-07-18 15:15:01 34960 [Note] InnoDB: Phase IV - Flush complete</pre>
                    <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">

                        <div class="admon-title">
                            Note
                        </div>
                        <p>
                            You may also receive a warning that a tablespace is discarded
                            (if you discarded the tablespace for the destination table)
                            and a message stating that statistics could not be calculated
                            due to a missing <code class="filename">.ibd</code> file:
                        </p><p style="color:blue;">您还可能会收到一条警告，指出某个表空间已被丢弃（如果您已为目标表丢弃该表空间），以及一条消息，指出由于缺少.ibd文件而无法计算统计信息：</p><pre data-lang="none" class="programlisting">2013-07-18 15:14:38 34960 [Warning] InnoDB: Table "test"."t" tablespace is set as discarded.
2013-07-18 15:14:38 7f34d9a37700 InnoDB: cannot calculate statistics for table "test"."t" because the .ibd file is missing. For help, please refer to
http://dev.mysql.com/doc/refman/5.7/en/innodb-troubleshooting.html
</pre>
                    </div>

                </div>

            </div>
            <div class="section">
                <div class="titlepage">
                    <div>
                        <div>
                            <h4 class="title"><a name="innodb-tablespace-encryption"></a>14.6.3.8&nbsp;InnoDB Data-at-Rest Encryption</h4>

                        </div>

                    </div>

                </div>
                <a class="indexterm" name="idm140286822003360"></a><a class="indexterm" name="idm140286822002256"></a><a class="indexterm" name="idm140286822001184"></a><a class="indexterm" name="idm140286822000112"></a><a class="indexterm" name="idm140286821999024"></a><a class="indexterm" name="idm140286821997952"></a><a class="indexterm" name="idm140286821996880"></a><a class="indexterm" name="idm140286821995808"></a><p>
                <code class="literal">InnoDB</code> supports data-at-rest encryption for
                <a class="link" href="glossary.html#glos_file_per_table" title="file-per-table">file-per-table</a>
                tablespaces.
            </p><p style="color:blue;">innodb支持每表表空间文件的静态数据加密。</p>
                <div class="itemizedlist">
                    <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><a class="xref" href="innodb-storage-engine.html#innodb-tablespace-encryption-about" title="About Data-at-Rest Encryption">About Data-at-Rest Encryption</a></p><p style="color:blue;">关于静态数据加密</p></li><li class="listitem"><p><a class="xref" href="innodb-storage-engine.html#innodb-tablespace-encryption-encryption-prerequisites" title="Encryption Prerequisites">Encryption Prerequisites</a></p><p style="color:blue;">加密先决条件</p></li><li class="listitem"><p><a class="xref" href="innodb-storage-engine.html#innodb-tablespace-encryption-enabling-disabling" title="Enabling File-Per-Table Tablespace Encryption">Enabling File-Per-Table Tablespace Encryption</a></p><p style="color:blue;">启用每表文件表空间加密</p></li><li class="listitem"><p><a class="xref" href="innodb-storage-engine.html#innodb-tablespace-encryption-master-key-rotation" title="Master Key Rotation">Master Key Rotation</a></p><p style="color:blue;">主密钥旋转</p></li><li class="listitem"><p><a class="xref" href="innodb-storage-engine.html#innodb-tablespace-encryption-recovery" title="Encryption and Recovery">Encryption and Recovery</a></p><p style="color:blue;">加密和恢复</p></li><li class="listitem"><p><a class="xref" href="innodb-storage-engine.html#innodb-tablespace-encryption-exporting" title="Exporting Encrypted Tablespaces">Exporting Encrypted Tablespaces</a></p><p style="color:blue;">导出加密表空间</p></li><li class="listitem"><p><a class="xref" href="innodb-storage-engine.html#innodb-tablespace-encryption-replication" title="Encryption and Replication">Encryption and Replication</a></p><p style="color:blue;">加密和复制</p></li><li class="listitem"><p><a class="xref" href="innodb-storage-engine.html#innodb-tablespace-encryption-identifying" title="Identifying Encrypted Tablespaces">Identifying Encrypted Tablespaces</a></p><p style="color:blue;">识别加密表空间</p></li><li class="listitem"><p><a class="xref" href="innodb-storage-engine.html#innodb-tablespace-encryption-usage-notes" title="Encryption Usage Notes">Encryption Usage Notes</a></p><p style="color:blue;">加密使用说明</p></li><li class="listitem"><p><a class="xref" href="innodb-storage-engine.html#innodb-tablespace-encryption-limitations" title="Encryption Limitations">Encryption Limitations</a></p><p style="color:blue;">加密限制</p></li></ul>
                </div>

                <div class="simplesect">

                    <div class="titlepage">
                        <div>

                            <div class="simple">
                                <h5 class="title"><a name="innodb-tablespace-encryption-about"></a>About Data-at-Rest Encryption</h5>

                            </div>

                        </div>

                    </div>
                    <p>
                        <code class="literal">InnoDB</code> uses a two tier encryption key
                        architecture, consisting of a master encryption key and
                        tablespace keys. When a tablespace is encrypted, a tablespace
                        key is encrypted and stored in the tablespace header. When an
                        application or authenticated user wants to access encrypted
                        data, <code class="literal">InnoDB</code> uses a master encryption key to
                        decrypt the tablespace key. The decrypted version of a
                        tablespace key never changes, but the master encryption key can
                        be changed as required. This action is referred to as
                        <span class="emphasis"><em>master key rotation</em></span>.
                    </p><p style="color:blue;">InnoDB使用两层加密密钥体系结构，由主加密密钥和表空间密钥组成。当表空间被加密时，表空间密钥被加密并存储在表空间头中。当应用程序或经过身份验证的用户想要访问加密数据时，innodb使用主加密密钥来解密表空间密钥。表空间密钥的解密版本永远不会更改，但主加密密钥可以根据需要更改。此操作称为主密钥旋转。</p><p>
                    The data-at-rest encryption feature relies on a keyring plugin
                    for master encryption key management.
                </p><p style="color:blue;">静态数据加密功能依赖于密钥环插件进行主加密密钥管理。</p><p>
                    All MySQL editions provide a <code class="literal">keyring_file</code>
                    plugin, which stores keyring data in a file local to the server
                    host.
                </p><p style="color:blue;">所有mysql版本都提供keyring_文件插件，它将keyring数据存储在服务器主机本地的文件中。</p><p>
                    MySQL Enterprise Edition offers additional keyring plugins:
                </p><p style="color:blue;">mysql企业版提供了额外的keyring插件：</p>
                    <div class="itemizedlist">
                        <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                            The <code class="literal">keyring_encrypted_file</code> plugin, which
                            stores keyring data in an encrypted file local to the server
                            host.
                        </p><p style="color:blue;">keyring_encrypted_file插件，它将keyring数据存储在服务器主机本地的加密文件中。</p></li><li class="listitem"><p>
                            The <code class="literal">keyring_okv</code> plugin, which includes a
                            KMIP client (KMIP 1.1) that uses a KMIP-compatible product
                            as a back end for keyring storage. Supported KMIP-compatible
                            products include centralized key management solutions such
                            as Oracle Key Vault, Gemalto KeySecure, Thales Vormetric key
                            management server, and Fornetix Key Orchestration.
                        </p><p style="color:blue;">keyring_okv插件，其中包括一个kmip客户端（kmip 1.1），该客户端使用kmip兼容产品作为keyring存储的后端。支持的kmip兼容产品包括集中式密钥管理解决方案，如oracle密钥库、gemalto密钥安全、thales vormetric密钥管理服务器和fornetix密钥编排。</p></li><li class="listitem"><p>
                            The <code class="literal">keyring_aws</code> plugin, which
                            communicates with the Amazon Web Services Key Management
                            Service (AWS KMS) as a back end for key generation and uses
                            a local file for key storage.
                        </p><p style="color:blue;">keyring aws插件，它与amazon web服务密钥管理服务（aws-kms）通信，作为密钥生成的后端，并使用本地文件存储密钥。</p></li></ul>
                    </div>
                    <div class="warning" style="margin-left: 0.5in; margin-right: 0.5in;">
                        <div class="admon-title">
                            Warning
                        </div>
                        <p>
                            The <code class="literal">keyring_file</code> and
                            <code class="literal">keyring_encrypted file</code> plugins are not
                            intended as regulatory compliance solutions. Security
                            standards such as PCI, FIPS, and others require use of key
                            management systems to secure, manage, and protect encryption
                            keys in key vaults or hardware security modules (HSMs).
                        </p><p style="color:blue;">keyring_文件和keyring_加密文件插件不打算用作法规遵从性解决方案。PCI、FIPS等安全标准要求使用密钥管理系统来保护、管理和保护密钥库或硬件安全模块（HSM）中的加密密钥。</p>
                    </div>
                    <p>
                        A secure and robust encryption key management solution is
                        critical for security and for compliance with various security
                        standards. When the data-at-rest encryption feature uses a
                        centralized key management solution, the feature is referred to
                        as <span class="quote">“<span class="quote">MySQL Enterprise Transparent Data Encryption
        (TDE)</span>”</span>.
                    </p><p style="color:blue;">安全可靠的加密密钥管理解决方案对于安全性和遵守各种安全标准至关重要。当静态数据加密特性使用集中密钥管理解决方案时，该特性称为“mysql企业透明数据加密（mysql enterprise transparent data encryption，tde）”。</p><p>
                    The data-at-rest encryption feature supports the Advanced
                    Encryption Standard (AES) block-based encryption algorithm. It
                    uses Electronic Codebook (ECB) block encryption mode for
                    tablespace key encryption and Cipher Block Chaining (CBC) block
                    encryption mode for data encryption.
                </p><p style="color:blue;">静态数据加密功能支持高级加密标准（AES）基于块的加密算法。表空间密钥加密采用电子码本（ecb）块加密方式，数据加密采用密码块链（cbc）块加密方式。</p><p>
                    For frequently asked questions about the data-at-rest encryption
                    feature, see <a class="xref" href="faqs.html#faqs-tablespace-encryption" title="A.17&nbsp;MySQL 5.7 FAQ: InnoDB Data-at-Rest Encryption">Section&nbsp;A.17, “MySQL 5.7 FAQ: InnoDB Data-at-Rest Encryption”</a>.
                </p><p style="color:blue;">有关静态数据加密功能的常见问题，请参阅A.17节，“MySQL5.7常见问题解答：InnoDB Data at Rest Encryption”。</p>
                </div>
                <div class="simplesect">
                    <div class="titlepage">
                        <div>
                            <div class="simple">
                                <h5 class="title"><a name="innodb-tablespace-encryption-encryption-prerequisites"></a>Encryption Prerequisites</h5>

                            </div>

                        </div>

                    </div>
                    <div class="itemizedlist">
                        <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                            A keyring plugin must be installed and configured. Keyring
                            plugin installation is performed at startup using the
                            <a class="link" href="server-administration.html#option_mysqld_early-plugin-load"><code class="option">early-plugin-load</code></a> option.
                            Early loading ensures that the plugin is available prior to
                            initialization of the <code class="literal">InnoDB</code> storage
                            engine. For keyring plugin installation and configuration
                            instructions, see <a class="xref" href="security.html#keyring" title="6.4.4&nbsp;The MySQL Keyring">Section&nbsp;6.4.4, “The MySQL Keyring”</a>.
                        </p><p style="color:blue;">必须安装并配置keyring插件。keyring插件安装在启动时使用早期插件加载选项执行。早期加载确保插件在初始化innodb存储引擎之前可用。有关keyring插件的安装和配置说明，请参阅第6.4.4节“mysql keyring”。</p><p>
                            Only one keyring plugin can be enabled at a time. Enabling
                            multiple keyring plugins is not supported.
                        </p><p style="color:blue;">一次只能启用一个keyring插件。不支持启用多个keyring插件。</p>
                            <div class="important" style="margin-left: 0.5in; margin-right: 0.5in;">

                                <div class="admon-title">
                                    Important
                                </div>
                                <p>
                                    Once encrypted tablespaces are created in a MySQL
                                    instance, the keyring plugin that was loaded when creating
                                    the encrypted tablespace must continue to be loaded at
                                    startup using the
                                    <a class="link" href="server-administration.html#option_mysqld_early-plugin-load"><code class="option">early-plugin-load</code></a> option.
                                    Failing to do so results in errors when starting the
                                    server and during <code class="literal">InnoDB</code> recovery.
                                </p><p style="color:blue;">在mysql实例中创建加密表空间后，在创建加密表空间时加载的keyring插件必须在启动时使用早期插件加载选项继续加载。否则会导致在启动服务器和InnoDB恢复期间出现错误。</p>
                            </div>
                            <p>
                                To verify that a keyring plugin is active, use the
                                <a class="link" href="sql-syntax.html#show-plugins" title="13.7.5.25&nbsp;SHOW PLUGINS Syntax"><code class="literal">SHOW PLUGINS</code></a> statement or
                                query the
                                <a class="link" href="information-schema.html#plugins-table" title="24.17&nbsp;The INFORMATION_SCHEMA PLUGINS Table"><code class="literal">INFORMATION_SCHEMA.PLUGINS</code></a>
                                table. For example:
                            </p><p style="color:blue;">要验证keyring插件是否处于活动状态，请使用show plugins语句或查询information_schema.plugins表。例如：</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT PLUGIN_NAME, PLUGIN_STATUS</code></strong>
       <strong class="userinput"><code>FROM INFORMATION_SCHEMA.PLUGINS</code></strong>
       <strong class="userinput"><code>WHERE PLUGIN_NAME LIKE 'keyring%';</code></strong>
+--------------+---------------+
| PLUGIN_NAME  | PLUGIN_STATUS |
+--------------+---------------+
| keyring_file | ACTIVE        |
+--------------+---------------+
</pre></li><li class="listitem"><p>
                            When encrypting production data, ensure that you take steps
                            to prevent loss of the master encryption key. <span class="emphasis"><em>If
            the master encryption key is lost, data stored in encrypted
            tablespace files is unrecoverable.</em></span> If you use the
                            <code class="literal">keyring_file</code> or
                            <code class="literal">keyring_encrypted_file</code> plugin, create a
                            backup of the keyring data file immediately after creating
                            the first encrypted tablespace, before master key rotation,
                            and after master key rotation. The
                            <a class="link" href="security.html#sysvar_keyring_file_data"><code class="literal">keyring_file_data</code></a>
                            configuration option defines the keyring data file location
                            for the <code class="literal">keyring_file</code> plugin. The
                            <a class="link" href="security.html#sysvar_keyring_encrypted_file_data"><code class="literal">keyring_encrypted_file_data</code></a>
                            configuration option defines the keyring data file location
                            for the <code class="literal">keyring_encrypted_file</code> plugin. If
                            you use the <code class="literal">keyring_okv</code> or
                            <code class="literal">keyring_aws</code> plugin, ensure that you have
                            performed the necessary configuration. For instructions, see
                            <a class="xref" href="security.html#keyring" title="6.4.4&nbsp;The MySQL Keyring">Section&nbsp;6.4.4, “The MySQL Keyring”</a>.
                        </p><p style="color:blue;">加密生产数据时，请确保采取措施防止丢失主加密密钥。如果主加密密钥丢失，则存储在加密表空间文件中的数据是不可恢复的。如果使用keyring_文件或keyring_encrypted_文件插件，请在创建第一个加密表空间之后、主密钥旋转之前和主密钥旋转之后立即创建keyring数据文件的备份。keyring_file_data configuration选项定义keyring_file插件的keyring数据文件位置。keyring_encrypted_file_data configuration选项定义keyring_encrypted_file插件的keyring数据文件位置。如果使用keyring_okv或keyring_aws插件，请确保已执行必要的配置。有关说明，请参阅6.4.4节“mysql keyring”。</p></li></ul>
                    </div>

                </div>
                <div class="simplesect">
                    <div class="titlepage">
                        <div>
                            <div class="simple">
                                <h5 class="title"><a name="innodb-tablespace-encryption-enabling-disabling"></a>Enabling File-Per-Table Tablespace Encryption</h5>

                            </div>

                        </div>

                    </div>
                    <p>
                        To enable encryption for a new file-per-table tablespace,
                        specify the <code class="literal">ENCRYPTION</code> option in a
                        <a class="link" href="sql-syntax.html#create-table" title="13.1.18&nbsp;CREATE TABLE Syntax"><code class="literal">CREATE TABLE</code></a> statement. The
                        following example assumes that
                        <a class="link" href="innodb-storage-engine.html#sysvar_innodb_file_per_table"><code class="literal">innodb_file_per_table</code></a> is
                        enabled.
                    </p><p style="color:blue;">要为每个表空间的新文件启用加密，请在CREATETABLE语句中指定ENCRYPTION选项。下面的示例假设启用了innodb_file_per_表。</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>CREATE TABLE t1 (c1 INT) ENCRYPTION='Y';</code></strong>
</pre><p>
                    To enable encryption for an existing file-per-table tablespace,
                    specify the <code class="literal">ENCRYPTION</code> option in an
                    <a class="link" href="sql-syntax.html#alter-table" title="13.1.8&nbsp;ALTER TABLE Syntax"><code class="literal">ALTER TABLE</code></a> statement.
                </p><p style="color:blue;">若要为每一个表表空间启用现有文件的加密，请在ALTALTABLE语句中指定加密选项。</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>ALTER TABLE t1 ENCRYPTION='Y';</code></strong>
</pre><p>
                    To disable encryption for file-per-table tablespace, set
                    <code class="literal">ENCRYPTION='N'</code> using
                    <a class="link" href="sql-syntax.html#alter-table" title="13.1.8&nbsp;ALTER TABLE Syntax"><code class="literal">ALTER TABLE</code></a>.
                </p><p style="color:blue;">要禁用对每个表空间的文件的加密，请使用alter table设置encryption='n'。</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>ALTER TABLE t1 ENCRYPTION='N';</code></strong>
</pre>
                </div>
                <div class="simplesect">
                    <div class="titlepage">
                        <div>
                            <div class="simple">
                                <h5 class="title"><a name="innodb-tablespace-encryption-master-key-rotation"></a>Master Key Rotation</h5>

                            </div>

                        </div>

                    </div>
                    <p>
                        The master encryption key should be rotated periodically and
                        whenever you suspect that the key has been compromised.
                    </p><p style="color:blue;">主加密密钥应定期轮换，并在您怀疑密钥已被破坏时轮换。</p><p>
                    Master key rotation is an atomic, instance-level operation. Each
                    time the master encryption key is rotated, all tablespace keys
                    in the MySQL instance are re-encrypted and saved back to their
                    respective tablespace headers. As an atomic operation,
                    re-encryption must succeed for all tablespace keys once a
                    rotation operation is initiated. If master key rotation is
                    interrupted by a server failure, <code class="literal">InnoDB</code> rolls
                    the operation forward on server restart. For more information,
                    see <a class="xref" href="innodb-storage-engine.html#innodb-tablespace-encryption-recovery" title="Encryption and Recovery">Encryption and Recovery</a>.
                </p><p style="color:blue;">主密钥旋转是一个原子的实例级操作。每次旋转主加密密钥时，mysql实例中的所有表空间密钥都会重新加密并保存回各自的表空间头。作为一个原子操作，一旦启动了一个旋转操作，所有表空间密钥的重新加密必须成功。如果主密钥旋转被服务器故障中断，InnoDB会在服务器重启时向前滚动操作。有关详细信息，请参阅加密和恢复。</p><p>
                    Rotating the master encryption key only changes the master
                    encryption key and re-encrypts tablespace keys. It does not
                    decrypt or re-encrypt associated tablespace data.
                </p><p style="color:blue;">旋转主加密密钥只会更改主加密密钥并重新加密表空间密钥。它不会解密或重新加密关联的表空间数据。</p><p>
                    Rotating the master encryption key requires the
                    <a class="link" href="security.html#priv_super"><code class="literal">SUPER</code></a> privilege.
                </p><p style="color:blue;">旋转主加密密钥需要超级权限。</p><p>
                    To rotate the master encryption key, run:
                </p><p style="color:blue;">要旋转主加密密钥，请运行：</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>ALTER INSTANCE ROTATE INNODB MASTER KEY;</code></strong>
</pre><p>
                    <a class="link" href="sql-syntax.html#alter-instance" title="13.1.4&nbsp;ALTER INSTANCE Syntax"><code class="literal">ALTER INSTANCE
                        ROTATE INNODB MASTER KEY</code></a> supports concurrent DML.
                    However, it cannot be run concurrently with tablespace
                    encryption operations, and locks are taken to prevent conflicts
                    that could arise from concurrent execution. If an
                    <a class="link" href="sql-syntax.html#alter-instance" title="13.1.4&nbsp;ALTER INSTANCE Syntax"><code class="literal">ALTER INSTANCE
                        ROTATE INNODB MASTER KEY</code></a> operation is running, it must
                    finish before a tablespace encryption operation can proceed, and
                    vice versa.
                </p><p style="color:blue;">alter instance rotate innodb主键支持并发dml。但是，它不能与表空间加密操作同时运行，并且使用锁来防止并发执行可能引起的冲突。如果alter instance rotate innodb master key操作正在运行，则必须在表空间加密操作之前完成，反之亦然。</p>
                </div>
                <div class="simplesect">
                    <div class="titlepage">
                        <div>
                            <div class="simple">
                                <h5 class="title"><a name="innodb-tablespace-encryption-recovery"></a>Encryption and Recovery</h5>

                            </div>

                        </div>

                    </div>
                    <p>
                        If a server failure occurs during an encryption operation, the
                        operation is rolled forward when the server is restarted.
                    </p><p style="color:blue;">如果在加密操作期间发生服务器故障，则在重新启动服务器时会向前滚动该操作。</p><p>
                    If a server failure occurs during master key rotation,
                    <code class="literal">InnoDB</code> continues the operation on server
                    restart.
                </p><p style="color:blue;">如果在主密钥旋转期间发生服务器故障，InnoDB会在服务器重启时继续操作。</p><p>
                    The keyring plugin must be loaded prior to storage engine
                    initialization so that the information necessary to decrypt
                    tablespace data pages can be retrieved from tablespace headers
                    before <code class="literal">InnoDB</code> initialization and recovery
                    activities access tablespace data. (See
                    <a class="xref" href="innodb-storage-engine.html#innodb-tablespace-encryption-encryption-prerequisites" title="Encryption Prerequisites">Encryption Prerequisites</a>.)
                </p><p style="color:blue;">必须在存储引擎初始化之前加载keyring插件，以便在innodb初始化和恢复活动访问表空间数据之前，可以从表空间头中检索解密表空间数据页所需的信息。（请参见加密先决条件。）</p><p>
                    When <code class="literal">InnoDB</code> initialization and recovery
                    begin, the master key rotation operation resumes. Due to the
                    server failure, some tablespace keys may already be encrypted
                    using the new master encryption key. <code class="literal">InnoDB</code>
                    reads the encryption data from each tablespace header, and if
                    the data indicates that the tablespace key is encrypted using
                    the old master encryption key, <code class="literal">InnoDB</code>
                    retrieves the old key from the keyring and uses it to decrypt
                    the tablespace key. <code class="literal">InnoDB</code> then re-encrypts
                    the tablespace key using the new master encryption key and saves
                    the re-encrypted tablespace key back to the tablespace header.
                </p><p style="color:blue;">当innodb初始化和恢复开始时，主密钥旋转操作恢复。由于服务器故障，某些表空间密钥可能已使用新的主加密密钥加密。innodb从每个表空间头读取加密数据，如果数据表明表空间密钥是使用旧的主加密密钥加密的，innodb从keyring中检索旧密钥并使用它来解密表空间密钥。然后innodb使用新的主加密密钥重新加密表空间密钥，并将重新加密的表空间密钥保存回表空间头。</p>
                </div>
                <div class="simplesect">
                    <div class="titlepage">
                        <div>
                            <div class="simple">
                                <h5 class="title"><a name="innodb-tablespace-encryption-exporting"></a>Exporting Encrypted Tablespaces</h5>

                            </div>

                        </div>

                    </div>
                    <p>
                        When an encrypted tablespace is exported,
                        <code class="literal">InnoDB</code> generates a <span class="emphasis"><em>transfer
        key</em></span> that is used to encrypt the tablespace key. The
                        encrypted tablespace key and transfer key are stored in a
                        <code class="filename"><em class="replaceable"><code>tablespace_name</code></em>.cfp</code>
                        file. This file together with the encrypted tablespace file is
                        required to perform an import operation. On import,
                        <code class="literal">InnoDB</code> uses the transfer key to decrypt the
                        tablespace key in the
                        <code class="filename"><em class="replaceable"><code>tablespace_name</code></em>.cfp</code>
                        file. For related information, see
                        <a class="xref" href="innodb-storage-engine.html#tablespace-copying" title="14.6.3.7&nbsp;Copying Tablespaces to Another Instance">Section&nbsp;14.6.3.7, “Copying Tablespaces to Another Instance”</a>.
                    </p><p style="color:blue;">导出加密的表空间时，innodb生成一个传输密钥，用于加密表空间密钥。加密的表空间密钥和传输密钥存储在tablespace_name.cfp文件中。执行导入操作需要此文件和加密的表空间文件。导入时，innodb使用传输密钥解密tablespace_name.cfp文件中的表空间密钥。有关相关信息，请参阅第14.6.3.7节“将表空间复制到另一个实例”。</p>
                </div>
                <div class="simplesect">
                    <div class="titlepage">
                        <div>
                            <div class="simple">
                                <h5 class="title"><a name="innodb-tablespace-encryption-replication"></a>Encryption and Replication</h5>

                            </div>

                        </div>

                    </div>
                    <div class="itemizedlist">
                        <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                            The <a class="link" href="sql-syntax.html#alter-instance" title="13.1.4&nbsp;ALTER INSTANCE Syntax"><code class="literal">ALTER
                            INSTANCE ROTATE INNODB MASTER KEY</code></a> statement is
                            only supported in replication environments where the master
                            and slaves run a version of MySQL that supports at-rest data
                            encryption.
                        </p><p style="color:blue;">alter instance rotate innodb master key语句仅在主服务器和从服务器运行支持静态数据加密的mysql版本的复制环境中受支持。</p></li><li class="listitem"><p>
                            Successful
                            <a class="link" href="sql-syntax.html#alter-instance" title="13.1.4&nbsp;ALTER INSTANCE Syntax"><code class="literal">ALTER
                                INSTANCE ROTATE INNODB MASTER KEY</code></a> statements are
                            written to the binary log for replication on slaves.
                        </p><p style="color:blue;">成功的alter instance rotate innodb master key语句被写入二进制日志，以便在从机上进行复制。</p></li><li class="listitem"><p>
                            If an <a class="link" href="sql-syntax.html#alter-instance" title="13.1.4&nbsp;ALTER INSTANCE Syntax"><code class="literal">ALTER
                            INSTANCE ROTATE INNODB MASTER KEY</code></a> statement fails,
                            it is not logged to the binary log and is not replicated on
                            slaves.
                        </p><p style="color:blue;">如果alter instance rotate innodb master key语句失败，则不会将其记录到二进制日志中，也不会在从机上复制。</p></li><li class="listitem"><p>
                            Replication of an
                            <a class="link" href="sql-syntax.html#alter-instance" title="13.1.4&nbsp;ALTER INSTANCE Syntax"><code class="literal">ALTER
                                INSTANCE ROTATE INNODB MASTER KEY</code></a> operation fails
                            if the keyring plugin is installed on the master but not on
                            the slave.
                        </p><p style="color:blue;">如果keyring插件安装在主机上而不是从机上，alter instance rotate innodb master key操作的复制将失败。</p></li><li class="listitem"><p>
                            If the <code class="literal">keyring_file</code> or
                            <code class="literal">keyring_encrypted_file</code> plugin is
                            installed on both the master and a slave but the slave does
                            not have a keyring data file, the replicated
                            <a class="link" href="sql-syntax.html#alter-instance" title="13.1.4&nbsp;ALTER INSTANCE Syntax"><code class="literal">ALTER
                                INSTANCE ROTATE INNODB MASTER KEY</code></a> statement
                            creates the keyring data file on the slave, assuming the
                            keyring file data is not cached in memory.
                            <a class="link" href="sql-syntax.html#alter-instance" title="13.1.4&nbsp;ALTER INSTANCE Syntax"><code class="literal">ALTER
                                INSTANCE ROTATE INNODB MASTER KEY</code></a> uses keyring
                            file data that is cached in memory, if available.
                        </p><p style="color:blue;">如果keyring_文件或keyring_encrypted_文件插件安装在主设备和从设备上，但从设备没有keyring数据文件，则复制的alter instance rotate innodb master key语句将在从设备上创建keyring数据文件，假设keyring文件数据未缓存在内存中。alter instance rotate innodb master key使用缓存在内存中的keyring文件数据（如果可用）。</p></li></ul>
                    </div>

                </div>
                <div class="simplesect">
                    <div class="titlepage">
                        <div>
                            <div class="simple">
                                <h5 class="title"><a name="innodb-tablespace-encryption-identifying"></a>Identifying Encrypted Tablespaces</h5>

                            </div>

                        </div>

                    </div>
                    <p>
                        When the <code class="literal">ENCRYPTION</code> option is specified in a
                        <a class="link" href="sql-syntax.html#create-table" title="13.1.18&nbsp;CREATE TABLE Syntax"><code class="literal">CREATE TABLE</code></a> or
                        <a class="link" href="sql-syntax.html#alter-table" title="13.1.8&nbsp;ALTER TABLE Syntax"><code class="literal">ALTER TABLE</code></a> statement, it is
                        recorded in the <code class="literal">CREATE_OPTIONS</code> column of
                        <a class="link" href="information-schema.html#tables-table" title="24.25&nbsp;The INFORMATION_SCHEMA TABLES Table"><code class="literal">INFORMATION_SCHEMA.TABLES</code></a>. This
                        column can be queried to identify tables that reside in
                        encrypted file-per-table tablespaces.
                    </p><p style="color:blue;">当在CREATE TABLE或ALTER TABLE语句中指定ENCRYPTION选项时，它将记录在INFORMATION SCHEMA.TABLES的CREATE\U OPTIONS列中。可以查询此列以标识驻留在每个表空间的加密文件中的表。</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT TABLE_SCHEMA, TABLE_NAME, CREATE_OPTIONS FROM INFORMATION_SCHEMA.TABLES</code></strong>
       <strong class="userinput"><code>WHERE CREATE_OPTIONS LIKE '%ENCRYPTION%';</code></strong>
+--------------+------------+----------------+
| TABLE_SCHEMA | TABLE_NAME | CREATE_OPTIONS |
+--------------+------------+----------------+
| test         | t1         | ENCRYPTION="Y" |
+--------------+------------+----------------+
</pre><p>
                    Query
                    <a class="link" href="information-schema.html#innodb-sys-tablespaces-table" title="24.32.22.1&nbsp;The INFORMATION_SCHEMA INNODB_SYS_TABLESPACES Table"><code class="literal">INFORMATION_SCHEMA.INNODB_SYS_TABLESPACES</code></a>
                    to retrieve information about the tablespace associated with a
                    particular schema and table.
                </p><p style="color:blue;">查询information_schema.innodb_sys_表空间以检索与特定模式和表关联的表空间的信息。</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT SPACE, NAME, SPACE_TYPE FROM INFORMATION_SCHEMA.INNODB_SYS_TABLESPACES WHERE NAME='test/t1';</code></strong>
+-------+---------+------------+
| SPACE | NAME    | SPACE_TYPE |
+-------+---------+------------+
|     3 | test/t1 | Single     |
+-------+---------+------------+
</pre>
                </div>
                <div class="simplesect">
                    <div class="titlepage">
                        <div>
                            <div class="simple">
                                <h5 class="title"><a name="innodb-tablespace-encryption-usage-notes"></a>Encryption Usage Notes</h5>

                            </div>

                        </div>

                    </div>
                    <div class="itemizedlist">
                        <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                            Plan appropriately when altering an existing tablespace with
                            the <code class="literal">ENCRYPTION</code> option. The table is
                            rebuilt using the <code class="literal">COPY</code> algorithm. The
                            <code class="literal">INPLACE</code> algorithm is not supported.
                        </p><p style="color:blue;">当使用加密选项更改现有表空间时，计划适当。使用复制算法重建表。不支持就地算法。</p></li><li class="listitem"><p>
                            If the server exits or is stopped during normal operation,
                            it is recommended to restart the server using the same
                            encryption settings that were configured previously.
                        </p><p style="color:blue;">如果服务器在正常操作中退出或停止，建议使用以前配置的相同加密设置重新启动服务器。</p></li><li class="listitem"><p>
                            The first master encryption key is generated when the first
                            new or existing tablespace is encrypted.
                        </p><p style="color:blue;">当第一个新的或现有的表空间被加密时，生成第一主加密密钥。</p></li><li class="listitem"><p>
                            Master key rotation re-encrypts tablespaces keys but does
                            not change the tablespace key itself. To change a tablespace
                            key, you must disable and re-enable encryption, which is an
                            <code class="literal">ALGORITHM=COPY</code> operation that rebuilds
                            the table.
                        </p><p style="color:blue;">主密钥循环重新加密表空间密钥，但不会更改表空间密钥本身。要更改表空间密钥，必须禁用并重新启用加密，这是一个重建表的algorithm=copy操作。</p></li><li class="listitem"><p>
                            If a table is created with both the
                            <a class="link" href="sql-syntax.html#create-table" title="13.1.18&nbsp;CREATE TABLE Syntax"><code class="literal">COMPRESSION</code></a>
                            and
                            <a class="link" href="sql-syntax.html#create-table" title="13.1.18&nbsp;CREATE TABLE Syntax"><code class="literal">ENCRYPTION</code></a>
                            options, compression is performed before tablespace data is
                            encrypted.
                        </p><p style="color:blue;">如果使用压缩和加密选项创建表，则在对表空间数据进行加密之前执行压缩。</p></li><li class="listitem"><p>
                            If a keyring data file (the file named by
                            <a class="link" href="security.html#sysvar_keyring_file_data"><code class="literal">keyring_file_data</code></a> or
                            <a class="link" href="security.html#sysvar_keyring_encrypted_file_data"><code class="literal">keyring_encrypted_file_data</code></a>)
                            is empty or missing, the first execution of
                            <a class="link" href="sql-syntax.html#alter-instance" title="13.1.4&nbsp;ALTER INSTANCE Syntax"><code class="literal">ALTER
                                INSTANCE ROTATE INNODB MASTER KEY</code></a> creates a master
                            encryption key.
                        </p><p style="color:blue;">如果keyring数据文件（keyring_file_data或keyring_encrypted_file_data命名的文件）为空或丢失，则alter instance rotate innodb master key的第一次执行将创建主加密密钥。</p></li><li class="listitem"><p>
                            Uninstalling the <code class="literal">keyring_file</code> or
                            <code class="literal">keyring_encrypted_file</code> plugin does not
                            remove an existing keyring data file.
                        </p><p style="color:blue;">卸载KEYRIGIN文件或KEYRIGIN加密DEX文件插件不删除现有的密钥环数据文件。</p></li><li class="listitem"><p>
                            It is recommended that you not place a keyring data file
                            under the same directory as tablespace data files.
                        </p><p style="color:blue;">建议不要将keyring数据文件与表空间数据文件放在同一目录下。</p></li><li class="listitem"><p>
                            Modifying the
                            <a class="link" href="security.html#sysvar_keyring_file_data"><code class="literal">keyring_file_data</code></a> or
                            <a class="link" href="security.html#sysvar_keyring_encrypted_file_data"><code class="literal">keyring_encrypted_file_data</code></a>
                            setting at runtime or when restarting the server can cause
                            previously encrypted tablespaces to become inaccessible,
                            resulting in lost data.
                        </p><p style="color:blue;">在运行时或重新启动服务器时修改keyring_file_data或keyring_encrypted_file_data设置可能会导致以前加密的表空间变得不可访问，从而导致数据丢失。</p></li></ul>
                    </div>

                </div>
                <div class="simplesect">
                    <div class="titlepage">
                        <div>
                            <div class="simple">
                                <h5 class="title"><a name="innodb-tablespace-encryption-limitations"></a>Encryption Limitations</h5>

                            </div>

                        </div>

                    </div>
                    <div class="itemizedlist">
                        <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                            Advanced Encryption Standard (AES) is the only supported
                            encryption algorithm. <code class="literal">InnoDB</code> data-at-rest
                            encryption uses Electronic Codebook (ECB) block encryption
                            mode for tablespace key encryption and Cipher Block Chaining
                            (CBC) block encryption mode for data encryption.
                        </p><p style="color:blue;">高级加密标准（AES）是唯一受支持的加密算法。innodb data at rest encryption使用电子码本（ecb）块加密模式进行表空间密钥加密，使用密码块链（cbc）块加密模式进行数据加密。</p></li><li class="listitem"><p>
                            Altering the <code class="literal">ENCRYPTION</code> attribute of a
                            table is performed using the <code class="literal">COPY</code>
                            algorithm. The <code class="literal">INPLACE</code> algorithm is not
                            supported.
                        </p><p style="color:blue;">使用复制算法更改表的加密属性。不支持就地算法。</p></li><li class="listitem"><p>
                            Encryption is only supported for
                            <a class="link" href="glossary.html#glos_file_per_table" title="file-per-table">file-per-table</a>
                            tablespaces. Encryption is not supported for other
                            tablespace types including
                            <a class="link" href="glossary.html#glos_general_tablespace" title="general tablespace">general
                                tablespaces</a> and the
                            <a class="link" href="glossary.html#glos_system_tablespace" title="system tablespace">system
                                tablespace</a>.
                        </p><p style="color:blue;">只支持对每个表空间的文件进行加密。其他表空间类型（包括常规表空间和系统表空间）不支持加密。</p></li><li class="listitem"><p>
                            You cannot move or copy a table from an encrypted
                            <a class="link" href="glossary.html#glos_file_per_table" title="file-per-table">file-per-table</a>
                            tablespace to a tablespace type that does not support
                            encryption.
                        </p><p style="color:blue;">不能将表从每表表空间的加密文件移动或复制到不支持加密的表空间类型。</p></li><li class="listitem"><p>
                            Encryption only applies to data in the tablespace. Data is
                            not encrypted in the redo log, undo log, or binary log.
                        </p><p style="color:blue;">加密只适用于表空间中的数据。数据在重做日志、撤消日志或二进制日志中未加密。</p></li><li class="listitem"><p>
                            It is not permitted to change the storage engine of a table
                            that resides in, or previously resided in, an encrypted
                            tablespace.
                        </p><p style="color:blue;">不允许更改位于或以前位于加密表空间中的表的存储引擎。</p></li></ul>
                    </div>

                </div>

            </div>

        </div>
        <div class="section">
            <div class="titlepage">
                <div>
                    <div>
                        <h3 class="title"><a name="innodb-data-dictionary"></a>14.6.4&nbsp;InnoDB Data Dictionary</h3>

                    </div>

                </div>

            </div>
            <p>
                The <code class="literal">InnoDB</code> data dictionary is comprised of
                internal system tables that contain metadata used to keep track of
                objects such as tables, indexes, and table columns. The metadata
                is physically located in the <code class="literal">InnoDB</code> system
                tablespace. For historical reasons, data dictionary metadata
                overlaps to some degree with information stored in
                <code class="literal">InnoDB</code> table metadata files
                (<code class="filename">.frm</code> files).
            </p><p style="color:blue;">innodb数据字典由内部系统表组成，这些表包含用于跟踪表、索引和表列等对象的元数据。元数据物理上位于innodb系统表空间中。由于历史原因，数据字典元数据在一定程度上与innodb表元数据文件（.frm文件）中存储的信息重叠。</p>
        </div>
        <div class="section">
            <div class="titlepage">
                <div>
                    <div>
                        <h3 class="title"><a name="innodb-doublewrite-buffer"></a>14.6.5&nbsp;Doublewrite Buffer</h3>

                    </div>

                </div>

            </div>
            <p>
                The doublewrite buffer is a storage area located in the system
                tablespace where <code class="literal">InnoDB</code> writes pages that are
                flushed from the <code class="literal">InnoDB</code> buffer pool, before the
                pages are written to their proper positions in the data file. Only
                after flushing and writing pages to the doublewrite buffer, does
                <code class="literal">InnoDB</code> write pages to their proper positions.
                If there is an operating system, storage subsystem, or
                <a class="link" href="programs.html#mysqld" title="4.3.1&nbsp;mysqld — The MySQL Server"><span class="command"><strong>mysqld</strong></span></a> process crash in the middle of a page
                write, <code class="literal">InnoDB</code> can later find a good copy of the
                page from the doublewrite buffer during crash recovery.
            </p><p style="color:blue;">doublewrite缓冲区是位于系统表空间中的一个存储区域，innodb在将页面写入数据文件的适当位置之前，将从innodb缓冲池中刷新的页面写入其中。只有在刷新页面并将其写入doublewrite缓冲区之后，innodb才会将页面写入其正确的位置。如果在页面写入过程中出现操作系统、存储子系统或mysqld进程崩溃，innodb稍后可以在崩溃恢复期间从doublewrite缓冲区中找到页面的一个好副本。</p><p>
            Although data is always written twice, the doublewrite buffer does
            not require twice as much I/O overhead or twice as many I/O
            operations. Data is written to the doublewrite buffer itself as a
            large sequential chunk, with a single <code class="literal">fsync()</code>
            call to the operating system.
        </p><p style="color:blue;">尽管数据总是写两次，但doublewrite缓冲区不需要两倍的I/O开销或两倍的I/O操作。数据作为一个大的连续块写入doublewrite缓冲区本身，只需对操作系统进行一次fsync（）调用。</p><p>
            The doublewrite buffer is enabled by default in most cases. To
            disable the doublewrite buffer, set
            <a class="link" href="innodb-storage-engine.html#sysvar_innodb_doublewrite"><code class="literal">innodb_doublewrite</code></a> to 0.
        </p><p style="color:blue;">在大多数情况下，默认情况下启用双写缓冲区。要禁用doublewrite缓冲区，请将innodb_doublewrite设置为0。</p><p>
            If system tablespace files (<span class="quote">“<span class="quote">ibdata files</span>”</span>) are
            located on Fusion-io devices that support atomic writes,
            doublewrite buffering is automatically disabled and Fusion-io
            atomic writes are used for all data files. Because the doublewrite
            buffer setting is global, doublewrite buffering is also disabled
            for data files residing on non-Fusion-io hardware. This feature is
            only supported on Fusion-io hardware and is only enabled for
            Fusion-io NVMFS on Linux. To take full advantage of this feature,
            an <a class="link" href="innodb-storage-engine.html#sysvar_innodb_flush_method"><code class="literal">innodb_flush_method</code></a> setting of
            <code class="literal">O_DIRECT</code> is recommended.
        </p><p style="color:blue;">如果系统表空间文件（“ibdata文件”）位于支持原子写入的fusion io设备上，则会自动禁用doublewrite缓冲，并对所有数据文件使用fusion io原子写入。由于doublewrite缓冲区设置是全局的，因此也会对驻留在非Fusion IO硬件上的数据文件禁用doublewrite缓冲。此功能仅在Fusion IO硬件上受支持，并且仅在Linux上为Fusion IO NVMFS启用。为了充分利用这一特性，建议将innodb_flush_method设置为o_direct。</p>
        </div>
        <div class="section">
            <div class="titlepage">
                <div>
                    <div>
                        <h3 class="title"><a name="innodb-redo-log"></a>14.6.6&nbsp;Redo Log</h3>

                    </div>

                </div>

            </div>
            <a class="indexterm" name="idm140286821811472"></a><a class="indexterm" name="idm140286821809984"></a><p>
            The redo log is a disk-based data structure used during crash
            recovery to correct data written by incomplete transactions.
            During normal operations, the redo log encodes requests to change
            table data that result from SQL statements or low-level API calls.
            Modifications that did not finish updating the data files before
            an unexpected shutdown are replayed automatically during
            initialization, and before the connections are accepted. For
            information about the role of the redo log in crash recovery, see
            <a class="xref" href="innodb-storage-engine.html#innodb-recovery" title="14.18.2&nbsp;InnoDB Recovery">Section&nbsp;14.18.2, “InnoDB Recovery”</a>.
        </p><p style="color:blue;">重做日志是一种基于磁盘的数据结构，用于在崩溃恢复期间更正不完整事务写入的数据。在正常操作期间，重做日志对更改由sql语句或低级api调用产生的表数据的请求进行编码。未在意外关机之前完成数据文件更新的修改将在初始化期间和接受连接之前自动重播。有关重做日志在崩溃恢复中的作用的信息，请参阅14.18.2节“innodb recovery”。</p><p>
            By default, the redo log is physically represented on disk by two
            files named <code class="filename">ib_logfile0</code> and
            <code class="filename">ib_logfile1</code>. MySQL writes to the redo log
            files in a circular fashion. Data in the redo log is encoded in
            terms of records affected; this data is collectively referred to
            as redo. The passage of data through the redo log is represented
            by an ever-increasing <a class="link" href="glossary.html#glos_lsn" title="LSN">LSN</a> value.
        </p><p style="color:blue;">默认情况下，重做日志在磁盘上由两个名为ib_logfile0和ib_logfile1的文件物理表示。mysql以循环方式写入重做日志文件。重做日志中的数据根据受影响的记录进行编码；这些数据统称为重做。通过重做日志的数据通道由不断增加的lsn值表示。</p><p>
            For related information, see
            <a class="xref" href="innodb-storage-engine.html#innodb-startup-log-file-configuration" title="Redo Log File Configuration">Redo Log File Configuration</a>, and
            <a class="xref" href="optimization.html#optimizing-innodb-logging" title="8.5.4&nbsp;Optimizing InnoDB Redo Logging">Section&nbsp;8.5.4, “Optimizing InnoDB Redo Logging”</a>.
        </p><p style="color:blue;">有关信息，请参阅重做日志文件配置和第8.5.4节“优化innodb重做日志”。</p>
            <div class="simplesect">

                <div class="titlepage">
                    <div>

                        <div class="simple">
                            <h4 class="title"><a name="innodb-redo-log-file-reconfigure"></a>Changing the Number or Size of InnoDB Redo Log Files</h4>
                        </div>
                    </div>
                </div>
                <a class="indexterm" name="idm140286821800816"></a><a class="indexterm" name="idm140286821799328"></a><p>
                To change the number or the size of your
                <code class="literal">InnoDB</code> <a class="link" href="glossary.html#glos_redo_log" title="redo log">redo
                log</a> files, perform the following steps:
            </p><p style="color:blue;">要更改innodb重做日志文件的数量或大小，请执行以下步骤：</p>
                <div class="orderedlist">
                    <ol class="orderedlist" type="1"><li class="listitem"><p>
                        Stop the MySQL server and make sure that it shuts down
                        without errors.
                    </p><p style="color:blue;">停止mysql服务器并确保它在没有错误的情况下关闭。</p></li><li class="listitem"><p>
                        Edit <code class="filename">my.cnf</code> to change the log file
                        configuration. To change the log file size, configure
                        <a class="link" href="innodb-storage-engine.html#sysvar_innodb_log_file_size"><code class="literal">innodb_log_file_size</code></a>. To
                        increase the number of log files, configure
                        <a class="link" href="innodb-storage-engine.html#sysvar_innodb_log_files_in_group"><code class="literal">innodb_log_files_in_group</code></a>.
                    </p><p style="color:blue;">编辑my.cnf以更改日志文件配置。要更改日志文件大小，请配置innodb_log_file_size。要增加日志文件的数量，请配置innodb_log_files_in_group。</p></li><li class="listitem"><p>
                        Start the MySQL server again.
                    </p><p style="color:blue;">重新启动mysql服务器。</p></li></ol>
                </div>
                <p>
                    If <code class="literal">InnoDB</code> detects that the
                    <a class="link" href="innodb-storage-engine.html#sysvar_innodb_log_file_size"><code class="literal">innodb_log_file_size</code></a> differs
                    from the redo log file size, it writes a log checkpoint, closes
                    and removes the old log files, creates new log files at the
                    requested size, and opens the new log files.
                </p><p style="color:blue;">如果innodb检测到innodb_log_file_大小与重做日志文件大小不同，它将写入日志检查点，关闭并删除旧的日志文件，以请求的大小创建新的日志文件，并打开新的日志文件。</p>
            </div>
            <div class="simplesect">
                <div class="titlepage">
                    <div>
                        <div class="simple">
                            <h4 class="title"><a name="innodb-group-commit"></a>Group Commit for Redo Log Flushing</h4>

                        </div>

                    </div>

                </div>
                <a class="indexterm" name="idm140286821785488"></a><p>
                <code class="literal">InnoDB</code>, like any other
                <a class="link" href="glossary.html#glos_acid" title="ACID">ACID</a>-compliant database engine,
                flushes the <a class="link" href="glossary.html#glos_redo_log" title="redo log">redo log</a> of a
                transaction before it is committed. <code class="literal">InnoDB</code>
                uses <a class="link" href="glossary.html#glos_group_commit" title="group commit">group commit</a>
                functionality to group multiple such flush requests together to
                avoid one flush for each commit. With group commit,
                <code class="literal">InnoDB</code> issues a single write to the log file
                to perform the commit action for multiple user transactions that
                commit at about the same time, significantly improving
                throughput.
            </p><p style="color:blue;">与任何其他符合acid的数据库引擎一样，innodb在提交事务之前刷新该事务的重做日志。innodb使用组提交功能将多个这样的刷新请求分组在一起，以避免每次提交都有一个刷新。对于组提交，innodb向日志文件发出一次写操作，以对几乎同时提交的多个用户事务执行提交操作，从而显著提高吞吐量。</p><p>
                For more information about performance of
                <code class="literal">COMMIT</code> and other transactional operations,
                see <a class="xref" href="optimization.html#optimizing-innodb-transaction-management" title="8.5.2&nbsp;Optimizing InnoDB Transaction Management">Section&nbsp;8.5.2, “Optimizing InnoDB Transaction Management”</a>.
            </p><p style="color:blue;">有关提交和其他事务操作的性能的更多信息，请参阅8.5.2节，“优化innodb事务管理”。</p>
            </div>

        </div>
        <div class="section">
            <div class="titlepage">
                <div>
                    <div>
                        <h3 class="title"><a name="innodb-undo-logs"></a>14.6.7&nbsp;Undo Logs</h3>

                    </div>

                </div>

            </div>
            <p>
                An undo log is a collection of undo log records associated with a
                single read-write transaction. An undo log record contains
                information about how to undo the latest change by a transaction
                to a <a class="link" href="glossary.html#glos_clustered_index" title="clustered index">clustered index</a>
                record. If another transaction needs to see the original data as
                part of a consistent read operation, the unmodified data is
                retrieved from undo log records. Undo logs exist within
                <a class="link" href="glossary.html#glos_undo_log_segment" title="undo log segment">undo log segments</a>,
                which are contained within
                <a class="link" href="glossary.html#glos_rollback_segment" title="rollback segment">rollback segments</a>.
                Rollback segments reside in the
                <a class="link" href="glossary.html#glos_system_tablespace" title="system tablespace">system tablespace</a>,
                in <a class="link" href="glossary.html#glos_undo_tablespace" title="undo tablespace">undo tablespaces</a>,
                and in the <a class="link" href="glossary.html#glos_temporary_tablespace" title="temporary tablespace">temporary
                tablespace</a>.
            </p><p style="color:blue;">撤消日志是与单个读写事务关联的撤消日志记录的集合。撤消日志记录包含有关如何撤消事务对聚集索引记录的最新更改的信息。如果另一个事务需要将原始数据视为一致读取操作的一部分，则将从撤消日志记录中检索未修改的数据。撤消日志存在于撤消日志段中，这些日志段包含在回滚段中。回滚段位于系统表空间、撤消表空间和临时表空间中。</p><p>
            Undo logs that reside in the temporary tablespace are used for
            transactions that modify data in user-defined temporary tables.
            These undo logs are not redo-logged, as they are not required for
            crash recovery. They are used only for rollback while the server
            is running. This type of undo log benefits performance by avoiding
            redo logging I/O.
        </p><p style="color:blue;">驻留在临时表空间中的撤消日志用于修改用户定义的临时表中的数据的事务。这些撤消日志不记录重做，因为崩溃恢复不需要它们。它们仅用于服务器运行时的回滚。这种类型的撤消日志通过避免重做日志I/O而提高性能。</p><p>
            <code class="literal">InnoDB</code> supports a maximum of 128 rollback
            segments, 32 of which are allocated to the temporary tablespace.
            This leaves 96 rollback segments that can be assigned to
            transactions that modify data in regular tables. The
            <a class="link" href="innodb-storage-engine.html#sysvar_innodb_rollback_segments"><code class="literal">innodb_rollback_segments</code></a> variable
            defines the number of rollback segments used by
            <code class="literal">InnoDB</code>.
        </p><p style="color:blue;">NONDB支持最多128个回滚段，其中32个被分配给临时表空间。这将留下96个回滚段，可以分配给修改常规表中数据的事务。innodb_rollback_segments变量定义innodb使用的回滚段数。</p><p>
            The number of transactions that a rollback segment supports
            depends on the number of undo slots in the rollback segment and
            the number of undo logs required by each transaction.
        </p><p style="color:blue;">回滚段支持的事务数取决于回滚段中的撤消槽数和每个事务所需的撤消日志数。</p><p>
            The number of undo slots in a rollback segment differs according
            to <code class="literal">InnoDB</code> page size.
        </p><p style="color:blue;">回滚段中的撤消槽数根据innodb页面大小而不同。</p>
            <div class="informaltable">
                <table summary="Number of undo slots in a rollback segment for each InnoDB page size"><colgroup><col width="50%"><col width="50%"></colgroup><thead><tr>
                    <th scope="col">InnoDB Page Size</th>
                    <th scope="col">Number of Undo Slots in a Rollback Segment (InnoDB Page Size / 16)</th>
                </tr></thead><tbody><tr>
                    <td scope="row"><code class="literal">4096 (4KB)</code></td>
                    <td><code class="literal">256</code></td>
                </tr><tr>
                    <td scope="row"><code class="literal">8192 (8KB)</code></td>
                    <td><code class="literal">512</code></td>
                </tr><tr>
                    <td scope="row"><code class="literal">16384 (16KB)</code></td>
                    <td><code class="literal">1024</code></td>
                </tr><tr>
                    <td scope="row"><code class="literal">32768 (32KB)</code></td>
                    <td><code class="literal">2048</code></td>
                </tr><tr>
                    <td scope="row"><code class="literal">65536 (64KB)</code></td>
                    <td><code class="literal">4096</code></td>
                </tr></tbody></table>
            </div>
            <p>
                A transaction is assigned up to four undo logs, one for each of
                the following operation types:
            </p><p style="color:blue;">一个事务最多分配四个撤消日志，以下操作类型各一个：</p>
            <div class="orderedlist">
                <ol class="orderedlist" type="1"><li class="listitem"><p>
                    <a class="link" href="sql-syntax.html#insert" title="13.2.5&nbsp;INSERT Syntax"><code class="literal">INSERT</code></a> operations on
                    user-defined tables
                </p><p style="color:blue;">在用户定义的表上插入操作</p></li><li class="listitem"><p>
                    <a class="link" href="sql-syntax.html#update" title="13.2.11&nbsp;UPDATE Syntax"><code class="literal">UPDATE</code></a> and
                    <a class="link" href="sql-syntax.html#delete" title="13.2.2&nbsp;DELETE Syntax"><code class="literal">DELETE</code></a> operations on
                    user-defined tables
                </p><p style="color:blue;">对用户定义表的更新和删除操作</p></li><li class="listitem"><p>
                    <a class="link" href="sql-syntax.html#insert" title="13.2.5&nbsp;INSERT Syntax"><code class="literal">INSERT</code></a> operations on
                    user-defined temporary tables
                </p><p style="color:blue;">在用户定义的临时表上插入操作</p></li><li class="listitem"><p>
                    <a class="link" href="sql-syntax.html#update" title="13.2.11&nbsp;UPDATE Syntax"><code class="literal">UPDATE</code></a> and
                    <a class="link" href="sql-syntax.html#delete" title="13.2.2&nbsp;DELETE Syntax"><code class="literal">DELETE</code></a> operations on
                    user-defined temporary tables
                </p><p style="color:blue;">对用户定义的临时表的更新和删除操作</p></li></ol>
            </div>
            <p>
                Undo logs are assigned as needed. For example, a transaction that
                performs <a class="link" href="sql-syntax.html#insert" title="13.2.5&nbsp;INSERT Syntax"><code class="literal">INSERT</code></a>,
                <a class="link" href="sql-syntax.html#update" title="13.2.11&nbsp;UPDATE Syntax"><code class="literal">UPDATE</code></a>, and
                <a class="link" href="sql-syntax.html#delete" title="13.2.2&nbsp;DELETE Syntax"><code class="literal">DELETE</code></a> operations on regular and
                temporary tables requires a full assignment of four undo logs. A
                transaction that performs only
                <a class="link" href="sql-syntax.html#insert" title="13.2.5&nbsp;INSERT Syntax"><code class="literal">INSERT</code></a> operations on regular tables
                requires a single undo log.
            </p><p style="color:blue;">根据需要分配撤消日志。例如，对常规表和临时表执行插入、更新和删除操作的事务需要四个撤消日志的完整分配。仅对常规表执行插入操作的事务需要一个撤消日志。</p><p>
            A transaction that performs operations on regular tables is
            assigned undo logs from an assigned system tablespace or undo
            tablespace rollback segment. A transaction that performs
            operations on temporary tables is assigned undo logs from an
            assigned temporary tablespace rollback segment.
        </p><p style="color:blue;">对常规表执行操作的事务将从指定的系统表空间或撤消表空间回滚段分配撤消日志。对临时表执行操作的事务将从已分配的临时表空间回滚段中分配撤消日志。</p><p>
            An undo log assigned to a transaction remains tied to the
            transaction for its duration. For example, an undo log assigned to
            a transaction for an <a class="link" href="sql-syntax.html#insert" title="13.2.5&nbsp;INSERT Syntax"><code class="literal">INSERT</code></a>
            operation on a regular table is used for all
            <a class="link" href="sql-syntax.html#insert" title="13.2.5&nbsp;INSERT Syntax"><code class="literal">INSERT</code></a> operations on regular tables
            performed by that transaction.
        </p><p style="color:blue;">分配给事务的撤消日志在事务的持续时间内保持与事务的关联。例如，为常规表上的插入操作分配给事务的撤消日志将用于该事务对常规表执行的所有插入操作。</p><p>
            Given the factors described above, the following formulas can be
            used to estimate the number of concurrent read-write transactions
            that <code class="literal">InnoDB</code> is capable of supporting.
        </p><p style="color:blue;">考虑到上述因素，可以使用以下公式来估计innodb能够支持的并发读写事务的数量。</p>
            <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">

                <div class="admon-title">
                    Note
                </div>
                <p>
                    A transaction can encounter a concurrent transaction limit error
                    before reaching the number of concurrent read-write transactions
                    that <code class="literal">InnoDB</code> is capable of supporting. This
                    occurs when the rollback segment assigned to a transaction runs
                    out of undo slots. In such cases, try rerunning the transaction.
                </p><p style="color:blue;">在达到InnoDB能够支持的并发读写事务数之前，事务可能会遇到并发事务限制错误。当分配给事务的回滚段用完撤消槽时发生这种情况。在这种情况下，请尝试重新运行事务。</p><p>
                When transactions perform operations on temporary tables, the
                number of concurrent read-write transactions that
                <code class="literal">InnoDB</code> is capable of supporting is
                constrained by the number of rollback segments allocated to the
                temporary tablespace, which is 32.
            </p><p style="color:blue;">当事务对临时表执行操作时，innodb能够支持的并发读写事务的数量受分配给临时表空间的回滚段的数量（32）的限制。</p>
            </div>
            <div class="itemizedlist">
                <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                    If each transaction performs either an
                    <a class="link" href="sql-syntax.html#insert" title="13.2.5&nbsp;INSERT Syntax"><code class="literal">INSERT</code></a>
                    <span class="bold"><strong>or</strong></span> an
                    <a class="link" href="sql-syntax.html#update" title="13.2.11&nbsp;UPDATE Syntax"><code class="literal">UPDATE</code></a> or
                    <a class="link" href="sql-syntax.html#delete" title="13.2.2&nbsp;DELETE Syntax"><code class="literal">DELETE</code></a> operation, the number of
                    concurrent read-write transactions that
                    <code class="literal">InnoDB</code> is capable of supporting is:
                </p><p style="color:blue;">如果每个事务执行insert、update或delete操作，那么innodb能够支持的并发读写事务数是：</p><pre data-lang="none" class="programlisting">(<a class="link" href="innodb-storage-engine.html#sysvar_innodb_page_size"><code class="literal">innodb_page_size</code></a> / 16) * (<a class="link" href="innodb-storage-engine.html#sysvar_innodb_rollback_segments"><code class="literal">innodb_rollback_segments</code></a> - 32)
</pre></li><li class="listitem"><p>
                    If each transaction performs an
                    <a class="link" href="sql-syntax.html#insert" title="13.2.5&nbsp;INSERT Syntax"><code class="literal">INSERT</code></a>
                    <span class="bold"><strong>and</strong></span> an
                    <a class="link" href="sql-syntax.html#update" title="13.2.11&nbsp;UPDATE Syntax"><code class="literal">UPDATE</code></a> or
                    <a class="link" href="sql-syntax.html#delete" title="13.2.2&nbsp;DELETE Syntax"><code class="literal">DELETE</code></a> operation, the number of
                    concurrent read-write transactions that
                    <code class="literal">InnoDB</code> is capable of supporting is:
                </p><p style="color:blue;">如果每个事务执行insert和update或delete操作，那么innodb能够支持的并发读写事务数是：</p><pre data-lang="none" class="programlisting">(<a class="link" href="innodb-storage-engine.html#sysvar_innodb_page_size"><code class="literal">innodb_page_size</code></a> / 16 / 2) * (<a class="link" href="innodb-storage-engine.html#sysvar_innodb_rollback_segments"><code class="literal">innodb_rollback_segments</code></a> - 32)
</pre></li><li class="listitem"><p>
                    If each transaction performs an
                    <a class="link" href="sql-syntax.html#insert" title="13.2.5&nbsp;INSERT Syntax"><code class="literal">INSERT</code></a> operation on a temporary
                    table, the number of concurrent read-write transactions that
                    <code class="literal">InnoDB</code> is capable of supporting is:
                </p><p style="color:blue;">如果每个事务对一个临时表执行一个insert操作，那么innodb能够支持的并发读写事务数是：</p><pre data-lang="none" class="programlisting">(<a class="link" href="innodb-storage-engine.html#sysvar_innodb_page_size"><code class="literal">innodb_page_size</code></a> / 16) * 32
</pre></li><li class="listitem"><p>
                    If each transaction performs an
                    <a class="link" href="sql-syntax.html#insert" title="13.2.5&nbsp;INSERT Syntax"><code class="literal">INSERT</code></a>
                    <span class="bold"><strong>and</strong></span> an
                    <a class="link" href="sql-syntax.html#update" title="13.2.11&nbsp;UPDATE Syntax"><code class="literal">UPDATE</code></a> or
                    <a class="link" href="sql-syntax.html#delete" title="13.2.2&nbsp;DELETE Syntax"><code class="literal">DELETE</code></a> operation on a temporary
                    table, the number of concurrent read-write transactions that
                    <code class="literal">InnoDB</code> is capable of supporting is:
                </p><p style="color:blue;">如果每个事务对临时表执行insert和update或delete操作，那么innodb能够支持的并发读写事务数是：</p><pre data-lang="none" class="programlisting">(<a class="link" href="innodb-storage-engine.html#sysvar_innodb_page_size"><code class="literal">innodb_page_size</code></a> / 16 / 2) * 32
</pre></li></ul>
            </div>

        </div>

    </div>
    <div class="section">
        <div class="titlepage">
            <div>
                <div>
                    <h2 class="title" style="clear: both"><a name="innodb-locking-transaction-model"></a>14.7&nbsp;InnoDB Locking and Transaction Model</h2>

                </div>

            </div>

        </div>
        <div class="toc">
            <dl class="toc"><dt><span class="section"><a href="innodb-storage-engine.html#innodb-locking">14.7.1 InnoDB Locking</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-transaction-model">14.7.2 InnoDB Transaction Model</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-locks-set">14.7.3 Locks Set by Different SQL Statements in InnoDB</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-next-key-locking">14.7.4 Phantom Rows</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-deadlocks">14.7.5 Deadlocks in InnoDB</a></span></dt></dl>
        </div>
        <a class="indexterm" name="idm140286821681808"></a><a class="indexterm" name="idm140286821680320"></a><a class="indexterm" name="idm140286821678832"></a><a class="indexterm" name="idm140286821677760"></a><p>
        To implement a large-scale, busy, or highly reliable database
        application, to port substantial code from a different database
        system, or to tune MySQL performance, it is important to understand
        <code class="literal">InnoDB</code> locking and the <code class="literal">InnoDB</code>
        transaction model.
    </p><p style="color:blue;">要实现大规模、繁忙或高度可靠的数据库应用程序，从不同的数据库系统移植大量代码，或优化mysql性能，了解innodb锁定和innodb事务模型非常重要。</p><p>
        This section discusses several topics related to
        <code class="literal">InnoDB</code> locking and the <code class="literal">InnoDB</code>
        transaction model with which you should be familiar.
    </p><p style="color:blue;">本节讨论与innodb锁定和innodb事务模型相关的几个主题，您应该熟悉这些主题。</p>
        <div class="itemizedlist">
            <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                <a class="xref" href="innodb-storage-engine.html#innodb-locking" title="14.7.1&nbsp;InnoDB Locking">Section&nbsp;14.7.1, “InnoDB Locking”</a> describes lock types used by
                <code class="literal">InnoDB</code>.
            </p><p style="color:blue;">第14.7.1节，“InnoDB锁定”描述了InnoDB使用的锁类型。</p></li><li class="listitem"><p>
                <a class="xref" href="innodb-storage-engine.html#innodb-transaction-model" title="14.7.2&nbsp;InnoDB Transaction Model">Section&nbsp;14.7.2, “InnoDB Transaction Model”</a> describes transaction
                isolation levels and the locking strategies used by each. It
                also discusses the use of
                <a class="link" href="server-administration.html#sysvar_autocommit"><code class="literal">autocommit</code></a>, consistent
                non-locking reads, and locking reads.
            </p><p style="color:blue;">第14.7.2节“InnoDB事务模型”描述了事务隔离级别和每个级别使用的锁定策略。它还讨论了自动提交、一致非锁定读取和锁定读取的使用。</p></li><li class="listitem"><p>
                <a class="xref" href="innodb-storage-engine.html#innodb-locks-set" title="14.7.3&nbsp;Locks Set by Different SQL Statements in InnoDB">Section&nbsp;14.7.3, “Locks Set by Different SQL Statements in InnoDB”</a> discusses specific types of
                locks set in <code class="literal">InnoDB</code> for various statements.
            </p><p style="color:blue;">第14.7.3节“innodb中由不同sql语句设置的锁”讨论了innodb中为不同语句设置的特定类型的锁。</p></li><li class="listitem"><p>
                <a class="xref" href="innodb-storage-engine.html#innodb-next-key-locking" title="14.7.4&nbsp;Phantom Rows">Section&nbsp;14.7.4, “Phantom Rows”</a> describes how
                <code class="literal">InnoDB</code> uses next-key locking to avoid phantom
                rows.
            </p><p style="color:blue;">第14.7.4节“幻象行”描述了InnoDB如何使用下一个键锁定来避免幻象行。</p></li><li class="listitem"><p>
                <a class="xref" href="innodb-storage-engine.html#innodb-deadlocks" title="14.7.5&nbsp;Deadlocks in InnoDB">Section&nbsp;14.7.5, “Deadlocks in InnoDB”</a> provides a deadlock example,
                discusses deadlock detection and rollback, and provides tips for
                minimizing and handling deadlocks in <code class="literal">InnoDB</code>.
            </p><p style="color:blue;">第14.7.5节，“InnoDB中的死锁”提供了一个死锁示例，讨论了死锁检测和回滚，并提供了最小化和处理InnoDB中死锁的提示。</p></li></ul>
        </div>
        <div class="section">
            <div class="titlepage">
                <div>
                    <div>
                        <h3 class="title"><a name="innodb-locking"></a>14.7.1&nbsp;InnoDB Locking</h3>

                    </div>

                </div>

            </div>
            <a class="indexterm" name="idm140286821658864"></a><a class="indexterm" name="idm140286821657376"></a><a class="indexterm" name="idm140286821655888"></a><a class="indexterm" name="idm140286821654400"></a><a class="indexterm" name="idm140286821652912"></a><a class="indexterm" name="idm140286821651424"></a><a class="indexterm" name="idm140286821649936"></a><a class="indexterm" name="idm140286821648448"></a><a class="indexterm" name="idm140286821646960"></a><a class="indexterm" name="idm140286821645472"></a><a class="indexterm" name="idm140286821643984"></a><a class="indexterm" name="idm140286821642912"></a><a class="indexterm" name="idm140286821641840"></a><a class="indexterm" name="idm140286821640768"></a><a class="indexterm" name="idm140286821639696"></a><a class="indexterm" name="idm140286821638624"></a><a class="indexterm" name="idm140286821637552"></a><p>
            This section describes lock types used by
            <code class="literal">InnoDB</code>.
        </p><p style="color:blue;">本节介绍innodb使用的锁类型。</p>
            <div class="itemizedlist">
                <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><a class="xref" href="innodb-storage-engine.html#innodb-shared-exclusive-locks" title="Shared and Exclusive Locks">Shared and Exclusive Locks</a></p><p style="color:blue;">共享锁和独占锁</p></li><li class="listitem"><p><a class="xref" href="innodb-storage-engine.html#innodb-intention-locks" title="Intention Locks">Intention Locks</a></p><p style="color:blue;">意向锁</p></li><li class="listitem"><p><a class="xref" href="innodb-storage-engine.html#innodb-record-locks" title="Record Locks">Record Locks</a></p><p style="color:blue;">记录锁</p></li><li class="listitem"><p><a class="xref" href="innodb-storage-engine.html#innodb-gap-locks" title="Gap Locks">Gap Locks</a></p><p style="color:blue;">间隙锁</p></li><li class="listitem"><p><a class="xref" href="innodb-storage-engine.html#innodb-next-key-locks" title="Next-Key Locks">Next-Key Locks</a></p><p style="color:blue;">下一把钥匙锁</p></li><li class="listitem"><p><a class="xref" href="innodb-storage-engine.html#innodb-insert-intention-locks" title="Insert Intention Locks">Insert Intention Locks</a></p><p style="color:blue;">插入意向锁</p></li><li class="listitem"><p><a class="xref" href="innodb-storage-engine.html#innodb-auto-inc-locks" title="AUTO-INC Locks">AUTO-INC Locks</a></p><p style="color:blue;">汽车公司锁</p></li><li class="listitem"><p><a class="xref" href="innodb-storage-engine.html#innodb-predicate-locks" title="Predicate Locks for Spatial Indexes">Predicate Locks for Spatial Indexes</a></p><p style="color:blue;">空间索引的谓词锁</p></li></ul>
            </div>

            <div class="simplesect">

                <div class="titlepage">
                    <div>

                        <div class="simple">
                            <h4 class="title"><a name="innodb-shared-exclusive-locks"></a>Shared and Exclusive Locks</h4>

                        </div>

                    </div>

                </div>
                <p>
                    <code class="literal">InnoDB</code> implements standard row-level locking
                    where there are two types of locks,
                    <a class="link" href="glossary.html#glos_shared_lock" title="shared lock">shared (<code class="literal">S</code>)
                        locks</a> and <a class="link" href="glossary.html#glos_exclusive_lock" title="exclusive lock">exclusive
                    (<code class="literal">X</code>) locks</a>.
                </p><p style="color:blue;">innodb实现了标准的行级锁，其中有两种类型的锁：共享（s）锁和独占（x）锁。</p>
                <div class="itemizedlist">
                    <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                        A <a class="link" href="glossary.html#glos_shared_lock" title="shared lock">shared
                        (<code class="literal">S</code>) lock</a> permits the transaction
                        that holds the lock to read a row.
                    </p><p style="color:blue;">共享锁允许持有该锁的事务读取行。</p></li><li class="listitem"><p>
                        An <a class="link" href="glossary.html#glos_exclusive_lock" title="exclusive lock">exclusive
                        (<code class="literal">X</code>) lock</a> permits the transaction
                        that holds the lock to update or delete a row.
                    </p><p style="color:blue;">exclusive（x）锁允许持有该锁的事务更新或删除行。</p></li></ul>
                </div>
                <p>
                    If transaction <code class="literal">T1</code> holds a shared
                    (<code class="literal">S</code>) lock on row <code class="literal">r</code>, then
                    requests from some distinct transaction <code class="literal">T2</code>
                    for a lock on row <code class="literal">r</code> are handled as follows:
                </p><p style="color:blue;">如果事务T1持有行R上的共享锁，则来自某个不同事务T2的请求对行R上的锁的处理如下：</p>
                <div class="itemizedlist">
                    <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                        A request by <code class="literal">T2</code> for an
                        <code class="literal">S</code> lock can be granted immediately. As a
                        result, both <code class="literal">T1</code> and <code class="literal">T2</code>
                        hold an <code class="literal">S</code> lock on <code class="literal">r</code>.
                    </p><p style="color:blue;">t2对s锁的请求可以立即被批准。结果，T1和T2都在R上保持S锁。</p></li><li class="listitem"><p>
                        A request by <code class="literal">T2</code> for an
                        <code class="literal">X</code> lock cannot be granted immediately.
                    </p><p style="color:blue;">T2对X锁的请求不能立即被授予。</p></li></ul>
                </div>
                <p>
                    If a transaction <code class="literal">T1</code> holds an exclusive
                    (<code class="literal">X</code>) lock on row <code class="literal">r</code>, a
                    request from some distinct transaction <code class="literal">T2</code> for
                    a lock of either type on <code class="literal">r</code> cannot be granted
                    immediately. Instead, transaction <code class="literal">T2</code> has to
                    wait for transaction <code class="literal">T1</code> to release its lock
                    on row <code class="literal">r</code>.
                </p><p style="color:blue;">如果事务t1持有r行上的exclusive（x）锁，则不能立即授予来自某个不同事务t2的请求，请求r行上任何一种类型的锁。相反，事务t2必须等待事务t1释放对行r的锁。</p>
            </div>
            <div class="simplesect">
                <div class="titlepage">
                    <div>
                        <div class="simple">
                            <h4 class="title"><a name="innodb-intention-locks"></a>Intention Locks</h4>

                        </div>

                    </div>

                </div>
                <p>
                    <code class="literal">InnoDB</code> supports <span class="emphasis"><em>multiple
        granularity locking</em></span> which permits coexistence of row
                    locks and table locks. For example, a statement such as
                    <a class="link" href="sql-syntax.html#lock-tables" title="13.3.5&nbsp;LOCK TABLES and UNLOCK TABLES Syntax"><code class="literal">LOCK TABLES ...
                        WRITE</code></a> takes an exclusive lock (an <code class="literal">X</code>
                    lock) on the specified table. To make locking at multiple
                    granularity levels practical, <code class="literal">InnoDB</code> uses
                    <a class="link" href="glossary.html#glos_intention_lock" title="intention lock">intention locks</a>.
                    Intention locks are table-level locks that indicate which type
                    of lock (shared or exclusive) a transaction requires later for a
                    row in a table. There are two types of intention locks:
                </p><p style="color:blue;">NONDB支持多粒度锁定，允许行锁和表锁共存。例如，锁表之类的语句…write在指定的表上采用独占锁（x锁）。为了使多粒度级别的锁定切实可行，innodb使用意图锁。意图锁是表级锁，指示事务稍后需要对表中的行使用哪种类型的锁（共享或独占）。有两种类型的意向锁：</p>
                <div class="itemizedlist">
                    <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                        An <a class="link" href="glossary.html#glos_intention_shared_lock" title="intention shared lock">intention
                        shared lock</a> (<code class="literal">IS</code>) indicates that a
                        transaction intends to set a <span class="emphasis"><em>shared</em></span>
                        lock on individual rows in a table.
                    </p><p style="color:blue;">意向共享锁（IS）表示事务打算在表中的单个行上设置共享锁。</p></li><li class="listitem"><p>
                        An <a class="link" href="glossary.html#glos_intention_exclusive_lock" title="intention exclusive lock">intention
                        exclusive lock</a> (<code class="literal">IX</code>) indicates that
                        a transaction intends to set an exclusive lock on individual
                        rows in a table.
                    </p><p style="color:blue;">意向排他锁（ix）表示事务打算对表中的单个行设置排他锁。</p></li></ul>
                </div>
                <p>
                    For example, <a class="link" href="sql-syntax.html#select" title="13.2.9&nbsp;SELECT Syntax"><code class="literal">SELECT ...
                    LOCK IN SHARE MODE</code></a> sets an <code class="literal">IS</code> lock,
                    and <a class="link" href="sql-syntax.html#select" title="13.2.9&nbsp;SELECT Syntax"><code class="literal">SELECT ... FOR
                    UPDATE</code></a> sets an <code class="literal">IX</code> lock.
                </p><p style="color:blue;">例如，选择…在共享模式下锁定设置为锁定，然后选择…for update设置一个ix锁。</p><p>
                The intention locking protocol is as follows:
            </p><p style="color:blue;">意向锁定协议如下：</p>
                <div class="itemizedlist">
                    <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                        Before a transaction can acquire a shared lock on a row in a
                        table, it must first acquire an <code class="literal">IS</code> lock
                        or stronger on the table.
                    </p><p style="color:blue;">事务在获取表中某行上的共享锁之前，必须先获取表上的IS锁或更强的IS锁。</p></li><li class="listitem"><p>
                        Before a transaction can acquire an exclusive lock on a row
                        in a table, it must first acquire an <code class="literal">IX</code>
                        lock on the table.
                    </p><p style="color:blue;">事务在获取表中某行的独占锁之前，必须先获取该表的IX锁。</p></li></ul>
                </div>
                <p>
                    Table-level lock type compatibility is summarized in the
                    following matrix.
                </p><p style="color:blue;">下表汇总了表级锁类型兼容性。</p>
                <div class="informaltable">
                    <table summary="A matrix showing table-level lock type compatibility. Each cell in the matrix is marked as either &quot;Compatible&quot; or &quot;Conflict&quot;."><colgroup><col width="20%"><col width="20%"><col width="20%"><col width="20%"><col width="20%"></colgroup><thead><tr>
                        <th scope="col"></th>
                        <th scope="col"><code class="literal">X</code></th>
                        <th scope="col"><code class="literal">IX</code></th>
                        <th scope="col"><code class="literal">S</code></th>
                        <th scope="col"><code class="literal">IS</code></th>
                    </tr></thead><tbody><tr>
                        <td scope="row"><code class="literal">X</code></td>
                        <td>Conflict</td>
                        <td>Conflict</td>
                        <td>Conflict</td>
                        <td>Conflict</td>
                    </tr><tr>
                        <td scope="row"><code class="literal">IX</code></td>
                        <td>Conflict</td>
                        <td>Compatible</td>
                        <td>Conflict</td>
                        <td>Compatible</td>
                    </tr><tr>
                        <td scope="row"><code class="literal">S</code></td>
                        <td>Conflict</td>
                        <td>Conflict</td>
                        <td>Compatible</td>
                        <td>Compatible</td>
                    </tr><tr>
                        <td scope="row"><code class="literal">IS</code></td>
                        <td>Conflict</td>
                        <td>Compatible</td>
                        <td>Compatible</td>
                        <td>Compatible</td>
                    </tr></tbody></table>
                </div>
                <p>
                    A lock is granted to a requesting transaction if it is
                    compatible with existing locks, but not if it conflicts with
                    existing locks. A transaction waits until the conflicting
                    existing lock is released. If a lock request conflicts with an
                    existing lock and cannot be granted because it would cause
                    <a class="link" href="glossary.html#glos_deadlock" title="deadlock">deadlock</a>, an error occurs.
                </p><p style="color:blue;">如果与现有锁兼容，则授予请求事务的锁，但如果与现有锁冲突，则不授予锁。事务等待直到冲突的现有锁被释放。如果锁请求与现有锁冲突，且不能授予，因为它将导致死锁，则发生错误。</p><p>
                Intention locks do not block anything except full table requests
                (for example, <a class="link" href="sql-syntax.html#lock-tables" title="13.3.5&nbsp;LOCK TABLES and UNLOCK TABLES Syntax"><code class="literal">LOCK
                TABLES ... WRITE</code></a>). The main purpose of intention locks
                is to show that someone is locking a row, or going to lock a row
                in the table.
            </p><p style="color:blue;">意向锁不会阻止除完整表请求（例如，锁表…写）。意图锁的主要目的是显示某人正在锁定一行，或者将要锁定表中的一行。</p><p>
                Transaction data for an intention lock appears similar to the
                following in <a class="link" href="sql-syntax.html#show-engine" title="13.7.5.15&nbsp;SHOW ENGINE Syntax"><code class="literal">SHOW
                ENGINE INNODB STATUS</code></a> and
                <a class="link" href="innodb-storage-engine.html#innodb-standard-monitor" title="14.17.3&nbsp;InnoDB Standard Monitor and Lock Monitor Output">InnoDB monitor</a>
                output:
            </p><p style="color:blue;">意向锁的事务数据在show engine innodb status and innodb monitor output中类似如下：</p><pre data-lang="sql" class="programlisting">TABLE LOCK table `test`.`t` trx id 10080 lock mode IX
</pre>
            </div>
            <div class="simplesect">
                <div class="titlepage">
                    <div>
                        <div class="simple">
                            <h4 class="title"><a name="innodb-record-locks"></a>Record Locks</h4>

                        </div>

                    </div>

                </div>
                <p>
                    A record lock is a lock on an index record. For example,
                    <code class="literal">SELECT c1 FROM t WHERE c1 = 10 FOR UPDATE;</code>
                    prevents any other transaction from inserting, updating, or
                    deleting rows where the value of <code class="literal">t.c1</code> is
                    <code class="literal">10</code>.
                </p><p style="color:blue;">记录锁是对索引记录的锁。例如，从t中选择c1，其中c1=10用于更新；防止任何其他事务插入、更新或删除t.c1的值为10的行。</p><p>
                Record locks always lock index records, even if a table is
                defined with no indexes. For such cases,
                <code class="literal">InnoDB</code> creates a hidden clustered index and
                uses this index for record locking. See
                <a class="xref" href="innodb-storage-engine.html#innodb-index-types" title="14.6.2.1&nbsp;Clustered and Secondary Indexes">Section&nbsp;14.6.2.1, “Clustered and Secondary Indexes”</a>.
            </p><p style="color:blue;">记录锁总是锁定索引记录，即使表定义时没有索引。在这种情况下，innodb会创建一个隐藏的聚集索引，并使用这个索引来锁定记录。见第14.6.2.1节，“聚集索引和二级索引”。</p><p>
                Transaction data for a record lock appears similar to the
                following in <a class="link" href="sql-syntax.html#show-engine" title="13.7.5.15&nbsp;SHOW ENGINE Syntax"><code class="literal">SHOW
                ENGINE INNODB STATUS</code></a> and
                <a class="link" href="innodb-storage-engine.html#innodb-standard-monitor" title="14.17.3&nbsp;InnoDB Standard Monitor and Lock Monitor Output">InnoDB monitor</a>
                output:
            </p><p style="color:blue;">记录锁的事务数据在show engine innodb status and innodb monitor output中类似如下：</p><pre data-lang="sql" class="programlisting">RECORD LOCKS space id 58 page no 3 n bits 72 index `PRIMARY` of table `test`.`t`
trx id 10078 lock_mode X locks rec but not gap
Record lock, heap no 2 PHYSICAL RECORD: n_fields 3; compact format; info bits 0
 0: len 4; hex 8000000a; asc     ;;
 1: len 6; hex 00000000274f; asc     'O;;
 2: len 7; hex b60000019d0110; asc        ;;
</pre>
            </div>
            <div class="simplesect">
                <div class="titlepage">
                    <div>
                        <div class="simple">
                            <h4 class="title"><a name="innodb-gap-locks"></a>Gap Locks</h4>

                        </div>

                    </div>

                </div>
                <p>
                    A gap lock is a lock on a gap between index records, or a lock
                    on the gap before the first or after the last index record. For
                    example, <code class="literal">SELECT c1 FROM t WHERE c1 BETWEEN 10 and 20
                    FOR UPDATE;</code> prevents other transactions from inserting
                    a value of <code class="literal">15</code> into column
                    <code class="literal">t.c1</code>, whether or not there was already any
                    such value in the column, because the gaps between all existing
                    values in the range are locked.
                </p><p style="color:blue;">间隙锁是指索引记录之间的间隙上的锁，或在第一个或最后一个索引记录之前或之后的间隙上的锁。例如，从T中的C1选择C1，在10和20之间进行更新；防止其他事务插入列T.C1中的15值，无论该列中是否已经存在任何这样的值，因为在该范围内所有现有值之间的间隙被锁定。</p><p>
                A gap might span a single index value, multiple index values, or
                even be empty.
            </p><p style="color:blue;">间隙可能跨越单个索引值、多个索引值，甚至为空。</p><p>
                Gap locks are part of the tradeoff between performance and
                concurrency, and are used in some transaction isolation levels
                and not others.
            </p><p style="color:blue;">间隙锁是性能和并发性之间权衡的一部分，在某些事务隔离级别而不是其他事务隔离级别中使用。</p><p>
                Gap locking is not needed for statements that lock rows using a
                unique index to search for a unique row. (This does not include
                the case that the search condition includes only some columns of
                a multiple-column unique index; in that case, gap locking does
                occur.) For example, if the <code class="literal">id</code> column has a
                unique index, the following statement uses only an index-record
                lock for the row having <code class="literal">id</code> value 100 and it
                does not matter whether other sessions insert rows in the
                preceding gap:
            </p><p style="color:blue;">使用唯一索引来搜索唯一行的锁定行的语句不需要间隙锁定。（这不包括搜索条件仅包含多列唯一索引的某些列的情况；在这种情况下，会发生间隙锁定。）例如，如果id列具有唯一索引，则以下语句仅对id值为100的行使用索引记录锁，而其他会话是否插入并不重要前面间隙中的行：</p><pre data-lang="sql" class="programlisting">SELECT * FROM child WHERE id = 100;
</pre><p>
                If <code class="literal">id</code> is not indexed or has a nonunique
                index, the statement does lock the preceding gap.
            </p><p style="color:blue;">如果id没有索引或索引不一致，则语句会锁定前面的间隙。</p><p>
                It is also worth noting here that conflicting locks can be held
                on a gap by different transactions. For example, transaction A
                can hold a shared gap lock (gap S-lock) on a gap while
                transaction B holds an exclusive gap lock (gap X-lock) on the
                same gap. The reason conflicting gap locks are allowed is that
                if a record is purged from an index, the gap locks held on the
                record by different transactions must be merged.
            </p><p style="color:blue;">这里还值得注意的是，冲突锁可以由不同的事务保存在gap上。例如，事务A可以在一个gap上持有一个共享的gap锁（gap s-lock），而事务B在同一个gap上持有一个独占的gap锁（gap x-lock）。允许冲突的间隙锁的原因是，如果从索引中清除记录，则必须合并由不同事务保留在记录上的间隙锁。</p><p>
                Gap locks in <code class="literal">InnoDB</code> are <span class="quote">“<span class="quote">purely
        inhibitive</span>”</span>, which means that their only purpose is to
                prevent other transactions from inserting to the gap. Gap locks
                can co-exist. A gap lock taken by one transaction does not
                prevent another transaction from taking a gap lock on the same
                gap. There is no difference between shared and exclusive gap
                locks. They do not conflict with each other, and they perform
                the same function.
            </p><p style="color:blue;">innodb中的gap锁是“完全禁止的”，这意味着它们的唯一目的是防止其他事务插入到gap中。间隙锁可以共存。一个事务执行的间隙锁不会阻止另一个事务对同一个间隙执行间隙锁。共享锁和独占锁之间没有区别。它们不会相互冲突，它们执行相同的功能。</p><p>
                Gap locking can be disabled explicitly. This occurs if you
                change the transaction isolation level to
                <a class="link" href="innodb-storage-engine.html#isolevel_read-committed"><code class="literal">READ COMMITTED</code></a> or enable the
                <a class="link" href="innodb-storage-engine.html#sysvar_innodb_locks_unsafe_for_binlog"><code class="literal">innodb_locks_unsafe_for_binlog</code></a>
                system variable (which is now deprecated). Under these
                circumstances, gap locking is disabled for searches and index
                scans and is used only for foreign-key constraint checking and
                duplicate-key checking.
            </p><p style="color:blue;">可以显式禁用间隙锁定。如果将事务隔离级别更改为read committed或启用innodb_locks_unsafe_for_binlog系统变量（现已弃用），则会发生这种情况。在这些情况下，间隙锁定在搜索和索引扫描中被禁用，并且仅用于外键约束检查和重复键检查。</p><p>
                There are also other effects of using the
                <a class="link" href="innodb-storage-engine.html#isolevel_read-committed"><code class="literal">READ COMMITTED</code></a> isolation
                level or enabling
                <a class="link" href="innodb-storage-engine.html#sysvar_innodb_locks_unsafe_for_binlog"><code class="literal">innodb_locks_unsafe_for_binlog</code></a>.
                Record locks for nonmatching rows are released after MySQL has
                evaluated the <code class="literal">WHERE</code> condition. For
                <code class="literal">UPDATE</code> statements, <code class="literal">InnoDB</code>
                does a <span class="quote">“<span class="quote">semi-consistent</span>”</span> read, such that it returns
                the latest committed version to MySQL so that MySQL can
                determine whether the row matches the <code class="literal">WHERE</code>
                condition of the <a class="link" href="sql-syntax.html#update" title="13.2.11&nbsp;UPDATE Syntax"><code class="literal">UPDATE</code></a>.
            </p><p style="color:blue;">使用read committed隔离级别或启用innodb_locks_unsafe_for_binlog还有其他效果。在mysql评估where条件之后，将释放非匹配行的记录锁。对于update语句，innodb执行“半一致”读取，这样它会将最新提交的版本返回给mysql，以便mysql可以确定行是否与更新的where条件匹配。</p>
            </div>
            <div class="simplesect">
                <div class="titlepage">
                    <div>
                        <div class="simple">
                            <h4 class="title"><a name="innodb-next-key-locks"></a>Next-Key Locks</h4>

                        </div>

                    </div>

                </div>
                <p>
                    A next-key lock is a combination of a record lock on the index
                    record and a gap lock on the gap before the index record.
                </p><p style="color:blue;">下一个密钥锁是索引记录上的记录锁和索引记录之前的间隙上的间隙锁的组合。</p><p>
                <code class="literal">InnoDB</code> performs row-level locking in such a
                way that when it searches or scans a table index, it sets shared
                or exclusive locks on the index records it encounters. Thus, the
                row-level locks are actually index-record locks. A next-key lock
                on an index record also affects the <span class="quote">“<span class="quote">gap</span>”</span> before
                that index record. That is, a next-key lock is an index-record
                lock plus a gap lock on the gap preceding the index record. If
                one session has a shared or exclusive lock on record
                <code class="literal">R</code> in an index, another session cannot insert
                a new index record in the gap immediately before
                <code class="literal">R</code> in the index order.
            </p><p style="color:blue;">InnoDB执行行级锁定的方式是，当它搜索或扫描表索引时，它会在遇到的索引记录上设置共享锁或独占锁。因此，行级锁实际上是索引记录锁。索引记录上的下一个键锁也会影响该索引记录之前的“间隙”。也就是说，下一个密钥锁是索引记录锁加上索引记录前面的间隙上的间隙锁。如果一个会话对索引中的记录r具有共享或独占锁，则另一个会话不能按索引顺序在r前面的间隙中插入新的索引记录。</p><p>
                Suppose that an index contains the values 10, 11, 13, and 20.
                The possible next-key locks for this index cover the following
                intervals, where a round bracket denotes exclusion of the
                interval endpoint and a square bracket denotes inclusion of the
                endpoint:
            </p><p style="color:blue;">假设索引包含值10、11、13和20。此索引的下一个可能的密钥锁覆盖以下间隔，其中一个圆括号表示间隔端点的排除，一个方括号表示端点的包含：</p><pre data-lang="none" class="programlisting">(negative infinity, 10]
(10, 11]
(11, 13]
(13, 20]
(20, positive infinity)
</pre><p>
                For the last interval, the next-key lock locks the gap above the
                largest value in the index and the <span class="quote">“<span class="quote">supremum</span>”</span>
                pseudo-record having a value higher than any value actually in
                the index. The supremum is not a real index record, so, in
                effect, this next-key lock locks only the gap following the
                largest index value.
            </p><p style="color:blue;">对于最后一个间隔，下一个密钥锁将间隔锁定在索引中最大值之上，并且“supremum”伪记录的值高于索引中的任何实际值。上确界不是真正的索引记录，因此，实际上，下一个键锁只锁定最大索引值后面的间隙。</p><p>
                By default, <code class="literal">InnoDB</code> operates in
                <a class="link" href="innodb-storage-engine.html#isolevel_repeatable-read"><code class="literal">REPEATABLE READ</code></a> transaction
                isolation level. In this case, <code class="literal">InnoDB</code> uses
                next-key locks for searches and index scans, which prevents
                phantom rows (see <a class="xref" href="innodb-storage-engine.html#innodb-next-key-locking" title="14.7.4&nbsp;Phantom Rows">Section&nbsp;14.7.4, “Phantom Rows”</a>).
            </p><p style="color:blue;">默认情况下，innodb在可重复读取事务隔离级别运行。在这种情况下，innodb使用next key locks进行搜索和索引扫描，从而防止出现幻象行（参见14.7.4节，“幻象行”）。</p><p>
                Transaction data for a next-key lock appears similar to the
                following in <a class="link" href="sql-syntax.html#show-engine" title="13.7.5.15&nbsp;SHOW ENGINE Syntax"><code class="literal">SHOW
                ENGINE INNODB STATUS</code></a> and
                <a class="link" href="innodb-storage-engine.html#innodb-standard-monitor" title="14.17.3&nbsp;InnoDB Standard Monitor and Lock Monitor Output">InnoDB monitor</a>
                output:
            </p><p style="color:blue;">下一个密钥锁的事务数据显示类似于show engine innodb status and innodb monitor output中的以下内容：</p><pre data-lang="sql" class="programlisting">RECORD LOCKS space id 58 page no 3 n bits 72 index `PRIMARY` of table `test`.`t`
trx id 10080 lock_mode X
Record lock, heap no 1 PHYSICAL RECORD: n_fields 1; compact format; info bits 0
 0: len 8; hex 73757072656d756d; asc supremum;;

Record lock, heap no 2 PHYSICAL RECORD: n_fields 3; compact format; info bits 0
 0: len 4; hex 8000000a; asc     ;;
 1: len 6; hex 00000000274f; asc     'O;;
 2: len 7; hex b60000019d0110; asc        ;;
</pre>
            </div>
            <div class="simplesect">
                <div class="titlepage">
                    <div>
                        <div class="simple">
                            <h4 class="title"><a name="innodb-insert-intention-locks"></a>Insert Intention Locks</h4>

                        </div>

                    </div>

                </div>
                <p>
                    An insert intention lock is a type of gap lock set by
                    <a class="link" href="sql-syntax.html#insert" title="13.2.5&nbsp;INSERT Syntax"><code class="literal">INSERT</code></a> operations prior to row
                    insertion. This lock signals the intent to insert in such a way
                    that multiple transactions inserting into the same index gap
                    need not wait for each other if they are not inserting at the
                    same position within the gap. Suppose that there are index
                    records with values of 4 and 7. Separate transactions that
                    attempt to insert values of 5 and 6, respectively, each lock the
                    gap between 4 and 7 with insert intention locks prior to
                    obtaining the exclusive lock on the inserted row, but do not
                    block each other because the rows are nonconflicting.
                </p><p style="color:blue;">插入意图锁是在行插入之前由插入操作设置的一种间隙锁。此锁表示插入的意图，这样，如果插入到同一索引间隙中的多个事务没有在间隙中的同一位置插入，那么它们就不必彼此等待。假设存在值为4和7的索引记录。尝试分别插入值5和6的单独事务，在获取插入行的独占锁之前，每个事务都使用插入意图锁锁定4和7之间的间隙，但不要因为行是不冲突的而相互阻塞。</p><p>
                The following example demonstrates a transaction taking an
                insert intention lock prior to obtaining an exclusive lock on
                the inserted record. The example involves two clients, A and B.
            </p><p style="color:blue;">下面的示例演示在获取插入记录的独占锁之前获取插入意图锁的事务。这个例子涉及两个客户，A和B。</p><p>
                Client A creates a table containing two index records (90 and
                102) and then starts a transaction that places an exclusive lock
                on index records with an ID greater than 100. The exclusive lock
                includes a gap lock before record 102:
            </p><p style="color:blue;">客户机A创建一个包含两个索引记录（90和102）的表，然后启动一个事务，该事务对ID大于100的索引记录放置独占锁。专用锁包括记录102之前的间隙锁：</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>CREATE TABLE child (id int(11) NOT NULL, PRIMARY KEY(id)) ENGINE=InnoDB;</code></strong>
mysql&gt; <strong class="userinput"><code>INSERT INTO child (id) values (90),(102);</code></strong>

mysql&gt; <strong class="userinput"><code>START TRANSACTION;</code></strong>
mysql&gt; <strong class="userinput"><code>SELECT * FROM child WHERE id &gt; 100 FOR UPDATE;</code></strong>
+-----+
| id  |
+-----+
| 102 |
+-----+
</pre><p>
                Client B begins a transaction to insert a record into the gap.
                The transaction takes an insert intention lock while it waits to
                obtain an exclusive lock.
            </p><p style="color:blue;">客户机B开始一个事务，将一个记录插入到间隙中。事务在等待获取独占锁时获取插入意图锁。</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>START TRANSACTION;</code></strong>
mysql&gt; <strong class="userinput"><code>INSERT INTO child (id) VALUES (101);</code></strong>
</pre><p>
                Transaction data for an insert intention lock appears similar to
                the following in
                <a class="link" href="sql-syntax.html#show-engine" title="13.7.5.15&nbsp;SHOW ENGINE Syntax"><code class="literal">SHOW ENGINE INNODB
                    STATUS</code></a> and
                <a class="link" href="innodb-storage-engine.html#innodb-standard-monitor" title="14.17.3&nbsp;InnoDB Standard Monitor and Lock Monitor Output">InnoDB monitor</a>
                output:
            </p><p style="color:blue;">insert意向锁的事务数据与show engine innodb status和innodb monitor output中的类似：</p><pre data-lang="sql" class="programlisting">RECORD LOCKS space id 31 page no 3 n bits 72 index `PRIMARY` of table `test`.`child`
trx id 8731 lock_mode X locks gap before rec <span class="bold"><strong>insert intention</strong></span> waiting
Record lock, heap no 3 PHYSICAL RECORD: n_fields 3; compact format; info bits 0
 0: len 4; hex 80000066; asc    f;;
 1: len 6; hex 000000002215; asc     " ;;
 2: len 7; hex 9000000172011c; asc     r  ;;...
</pre>
            </div>
            <div class="simplesect">
                <div class="titlepage">
                    <div>
                        <div class="simple">
                            <h4 class="title"><a name="innodb-auto-inc-locks"></a>AUTO-INC Locks</h4>

                        </div>

                    </div>

                </div>
                <p>
                    An <code class="literal">AUTO-INC</code> lock is a special table-level
                    lock taken by transactions inserting into tables with
                    <code class="literal">AUTO_INCREMENT</code> columns. In the simplest case,
                    if one transaction is inserting values into the table, any other
                    transactions must wait to do their own inserts into that table,
                    so that rows inserted by the first transaction receive
                    consecutive primary key values.
                </p><p style="color:blue;">auto-inc锁是一种特殊的表级锁，由事务插入具有auto_increment列的表中获得。在最简单的情况下，如果一个事务正在向表中插入值，则任何其他事务都必须等待自己向该表中插入，以便第一个事务插入的行接收连续的主键值。</p><p>
                The <a class="link" href="innodb-storage-engine.html#sysvar_innodb_autoinc_lock_mode"><code class="literal">innodb_autoinc_lock_mode</code></a>
                configuration option controls the algorithm used for
                auto-increment locking. It allows you to choose how to trade off
                between predictable sequences of auto-increment values and
                maximum concurrency for insert operations.
            </p><p style="color:blue;">innodb_autoinc_lock_mode配置选项控制用于自动增量锁定的算法。它允许您选择如何在自动插入值的可预测序列和插入操作的最大并发之间进行折衷。</p><p>
                For more information, see
                <a class="xref" href="innodb-storage-engine.html#innodb-auto-increment-handling" title="14.6.1.4&nbsp;AUTO_INCREMENT Handling in InnoDB">Section&nbsp;14.6.1.4, “AUTO_INCREMENT Handling in InnoDB”</a>.
            </p><p style="color:blue;">有关更多信息，请参阅第14.6.1.4节“InnoDB中的自动增量处理”。</p>
            </div>
            <div class="simplesect">
                <div class="titlepage">
                    <div>
                        <div class="simple">
                            <h4 class="title"><a name="innodb-predicate-locks"></a>Predicate Locks for Spatial Indexes</h4>

                        </div>

                    </div>

                </div>
                <a class="indexterm" name="idm140286821461120"></a><a class="indexterm" name="idm140286821460080"></a><p>
                <code class="literal">InnoDB</code> supports <code class="literal">SPATIAL</code>
                indexing of columns containing spatial columns (see
                <a class="xref" href="data-types.html#optimizing-spatial-analysis" title="11.5.8&nbsp;Optimizing Spatial Analysis">Section&nbsp;11.5.8, “Optimizing Spatial Analysis”</a>).
            </p><p style="color:blue;">NONDB支持包含空间列的列的空间索引（参见第115.8节，“优化空间分析”）。</p><p>
                To handle locking for operations involving
                <code class="literal">SPATIAL</code> indexes, next-key locking does not
                work well to support <a class="link" href="innodb-storage-engine.html#isolevel_repeatable-read"><code class="literal">REPEATABLE
                READ</code></a> or
                <a class="link" href="innodb-storage-engine.html#isolevel_serializable"><code class="literal">SERIALIZABLE</code></a> transaction
                isolation levels. There is no absolute ordering concept in
                multidimensional data, so it is not clear which is the
                <span class="quote">“<span class="quote">next</span>”</span> key.
            </p><p style="color:blue;">为了处理涉及空间索引的操作的锁定，next key locking不能很好地支持可重复读取或可序列化的事务隔离级别。多维数据中没有绝对排序的概念，所以不清楚哪个是“下一个”键。</p><p>
                To enable support of isolation levels for tables with
                <code class="literal">SPATIAL</code> indexes, <code class="literal">InnoDB</code>
                uses predicate locks. A <code class="literal">SPATIAL</code> index
                contains minimum bounding rectangle (MBR) values, so
                <code class="literal">InnoDB</code> enforces consistent read on the index
                by setting a predicate lock on the MBR value used for a query.
                Other transactions cannot insert or modify a row that would
                match the query condition.
            </p><p style="color:blue;">为了支持具有空间索引的表的隔离级别，innodb使用谓词锁。空间索引包含最小绑定矩形（mbr）值，因此innodb通过对用于查询的mbr值设置谓词锁来强制对索引进行一致读取。其他事务处理无法插入或修改与查询条件匹配的行。</p>
            </div>

        </div>
        <div class="section">
            <div class="titlepage">
                <div>
                    <div>
                        <h3 class="title"><a name="innodb-transaction-model"></a>14.7.2&nbsp;InnoDB Transaction Model</h3>

                    </div>

                </div>

            </div>
            <div class="toc">
                <dl class="toc"><dt><span class="section"><a href="innodb-storage-engine.html#innodb-transaction-isolation-levels">14.7.2.1 Transaction Isolation Levels</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-autocommit-commit-rollback">14.7.2.2 autocommit, Commit, and Rollback</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-consistent-read">14.7.2.3 Consistent Nonlocking Reads</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-locking-reads">14.7.2.4 Locking Reads</a></span></dt></dl>
            </div>
            <a class="indexterm" name="idm140286821446544"></a><p>
            In the <code class="literal">InnoDB</code> transaction model, the goal is to
            combine the best properties of a
            <a class="link" href="glossary.html#glos_mvcc" title="MVCC">multi-versioning</a> database with
            traditional two-phase locking. <code class="literal">InnoDB</code> performs
            locking at the row level and runs queries as nonlocking
            <a class="link" href="glossary.html#glos_consistent_read" title="consistent read">consistent reads</a> by
            default, in the style of Oracle. The lock information in
            <code class="literal">InnoDB</code> is stored space-efficiently so that lock
            escalation is not needed. Typically, several users are permitted
            to lock every row in <code class="literal">InnoDB</code> tables, or any
            random subset of the rows, without causing
            <code class="literal">InnoDB</code> memory exhaustion.
        </p><p style="color:blue;">在innodb事务模型中，目标是将多版本数据库的最佳特性与传统的两阶段锁定相结合。innodb在行级别执行锁定，并在默认情况下以非锁定一致读取的方式运行查询，采用oracle的样式。InnoDB中的锁信息被有效地存储在空间中，因此不需要锁升级。通常，允许多个用户锁定innodb表中的每一行或任意行的子集，而不会导致innodb内存耗尽。</p>
            <div class="section">

                <div class="titlepage">
                    <div>
                        <div>
                            <h4 class="title"><a name="innodb-transaction-isolation-levels"></a>14.7.2.1&nbsp;Transaction Isolation Levels</h4>
                        </div>
                    </div>
                </div>
                <a class="indexterm" name="idm140286821437808"></a><a class="indexterm" name="idm140286821436320"></a><p>
                Transaction isolation is one of the foundations of database
                processing. Isolation is the I in the acronym
                <a class="link" href="glossary.html#glos_acid" title="ACID">ACID</a>; the isolation level is
                the setting that fine-tunes the balance between performance and
                reliability, consistency, and reproducibility of results when
                multiple transactions are making changes and performing queries
                at the same time.
            </p><p style="color:blue;">事务隔离是数据库处理的基础之一。隔离是缩写acid中的i；隔离级别是当多个事务同时进行更改和执行查询时，微调性能与可靠性、一致性和结果再现性之间的平衡的设置。</p><p>
                <code class="literal">InnoDB</code> offers all four transaction isolation
                levels described by the SQL:1992 standard:
                <a class="link" href="innodb-storage-engine.html#isolevel_read-uncommitted"><code class="literal">READ UNCOMMITTED</code></a>,
                <a class="link" href="innodb-storage-engine.html#isolevel_read-committed"><code class="literal">READ COMMITTED</code></a>,
                <a class="link" href="innodb-storage-engine.html#isolevel_repeatable-read"><code class="literal">REPEATABLE READ</code></a>, and
                <a class="link" href="innodb-storage-engine.html#isolevel_serializable"><code class="literal">SERIALIZABLE</code></a>. The default
                isolation level for <code class="literal">InnoDB</code> is
                <a class="link" href="innodb-storage-engine.html#isolevel_repeatable-read"><code class="literal">REPEATABLE READ</code></a>.
            </p><p style="color:blue;">innodb提供了sql:1992标准描述的所有四个事务隔离级别：read uncommitted、read committed、repeatable read和serializable。innodb的默认隔离级别是repeatable read。</p><p>
                A user can change the isolation level for a single session or
                for all subsequent connections with the <a class="link" href="sql-syntax.html#set-transaction" title="13.3.6&nbsp;SET TRANSACTION Syntax"><code class="literal">SET
                TRANSACTION</code></a> statement. To set the server's default
                isolation level for all connections, use the
                <a class="link" href="server-administration.html#option_mysqld_transaction-isolation"><code class="option">--transaction-isolation</code></a> option on
                the command line or in an option file. For detailed information
                about isolation levels and level-setting syntax, see
                <a class="xref" href="sql-syntax.html#set-transaction" title="13.3.6&nbsp;SET TRANSACTION Syntax">Section&nbsp;13.3.6, “SET TRANSACTION Syntax”</a>.
            </p><p style="color:blue;">用户可以使用set transaction语句更改单个会话或所有后续连接的隔离级别。要为所有连接设置服务器的默认隔离级别，请在命令行或选项文件中使用--transaction isolation选项。有关隔离级别和级别设置语法的详细信息，请参阅第13.3.6节“设置事务语法”。</p><p>
                <code class="literal">InnoDB</code> supports each of the transaction
                isolation levels described here using different
                <a class="link" href="glossary.html#glos_locking" title="locking">locking</a> strategies. You can
                enforce a high degree of consistency with the default
                <a class="link" href="innodb-storage-engine.html#isolevel_repeatable-read"><code class="literal">REPEATABLE READ</code></a> level, for
                operations on crucial data where
                <a class="link" href="glossary.html#glos_acid" title="ACID">ACID</a> compliance is important.
                Or you can relax the consistency rules with
                <a class="link" href="innodb-storage-engine.html#isolevel_read-committed"><code class="literal">READ COMMITTED</code></a> or even
                <a class="link" href="innodb-storage-engine.html#isolevel_read-uncommitted"><code class="literal">READ UNCOMMITTED</code></a>, in
                situations such as bulk reporting where precise consistency and
                repeatable results are less important than minimizing the amount
                of overhead for locking.
                <a class="link" href="innodb-storage-engine.html#isolevel_serializable"><code class="literal">SERIALIZABLE</code></a> enforces even
                stricter rules than <a class="link" href="innodb-storage-engine.html#isolevel_repeatable-read"><code class="literal">REPEATABLE
                READ</code></a>, and is used mainly in specialized situations,
                such as with <a class="link" href="glossary.html#glos_xa" title="XA">XA</a> transactions and
                for troubleshooting issues with concurrency and
                <a class="link" href="glossary.html#glos_deadlock" title="deadlock">deadlocks</a>.
            </p><p style="color:blue;">innodb使用不同的锁定策略支持这里描述的每个事务隔离级别。对于关键数据上的操作，在acid遵从性很重要的情况下，可以强制实现与默认可重复读取级别的高度一致性。或者，您可以使用read committed甚至read uncommitted来放松一致性规则，例如批量报告，在这种情况下，精确一致性和可重复的结果比最小化锁定开销更不重要。可序列化执行的规则比可重复读取更为严格，主要用于特殊情况，如xa事务，以及解决并发和死锁问题。</p><p>
                The following list describes how MySQL supports the different
                transaction levels. The list goes from the most commonly used
                level to the least used.
            </p><p style="color:blue;">下面的列表描述了mysql如何支持不同的事务级别。列表从最常用的级别到最不常用的级别。</p>
                <div class="itemizedlist">
                    <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><a name="isolevel_repeatable-read"></a>
                        <a class="indexterm" name="idm140286821408704"></a>

                        <a class="indexterm" name="idm140286821407248"></a>

                        <code class="literal">REPEATABLE READ</code>
                    </p><p style="color:blue;">可重复读取</p><p>
                        This is the default isolation level for
                        <code class="literal">InnoDB</code>.
                        <a class="link" href="glossary.html#glos_consistent_read" title="consistent read">Consistent reads</a>
                        within the same transaction read the
                        <a class="link" href="glossary.html#glos_snapshot" title="snapshot">snapshot</a> established by
                        the first read. This means that if you issue several plain
                        (nonlocking) <a class="link" href="sql-syntax.html#select" title="13.2.9&nbsp;SELECT Syntax"><code class="literal">SELECT</code></a>
                        statements within the same transaction, these
                        <a class="link" href="sql-syntax.html#select" title="13.2.9&nbsp;SELECT Syntax"><code class="literal">SELECT</code></a> statements are
                        consistent also with respect to each other. See
                        <a class="xref" href="innodb-storage-engine.html#innodb-consistent-read" title="14.7.2.3&nbsp;Consistent Nonlocking Reads">Section&nbsp;14.7.2.3, “Consistent Nonlocking Reads”</a>.
                    </p><p style="color:blue;">这是innodb的默认隔离级别。同一事务内的一致读取读取由第一次读取建立的快照。这意味着，如果在同一事务中发出多个普通（非锁定）select语句，则这些select语句彼此也保持一致。见第14.7.2.3节，“一致非锁定读数”。</p><p>
                        For <a class="link" href="glossary.html#glos_locking_read" title="locking read">locking reads</a>
                        (<a class="link" href="sql-syntax.html#select" title="13.2.9&nbsp;SELECT Syntax"><code class="literal">SELECT</code></a> with <code class="literal">FOR
                        UPDATE</code> or <code class="literal">LOCK IN SHARE MODE</code>),
                        <a class="link" href="sql-syntax.html#update" title="13.2.11&nbsp;UPDATE Syntax"><code class="literal">UPDATE</code></a>, and
                        <a class="link" href="sql-syntax.html#delete" title="13.2.2&nbsp;DELETE Syntax"><code class="literal">DELETE</code></a> statements, locking
                        depends on whether the statement uses a unique index with a
                        unique search condition, or a range-type search condition.
                    </p><p style="color:blue;">对于锁定读取（对于更新或锁定在共享模式）、更新和删除语句，锁定取决于该语句是使用具有唯一搜索条件的唯一索引，还是使用范围类型搜索条件。</p>
                        <div class="itemizedlist">
                            <ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
                                For a unique index with a unique search condition,
                                <code class="literal">InnoDB</code> locks only the index record
                                found, not the <a class="link" href="glossary.html#glos_gap" title="gap">gap</a>
                                before it.
                            </p><p style="color:blue;">对于具有唯一搜索条件的唯一索引，innodb只锁定找到的索引记录，而不锁定其前面的间隙。</p></li><li class="listitem"><p>
                                For other search conditions, <code class="literal">InnoDB</code>
                                locks the index range scanned, using
                                <a class="link" href="glossary.html#glos_gap_lock" title="gap lock">gap locks</a> or
                                <a class="link" href="glossary.html#glos_next_key_lock" title="next-key lock">next-key locks</a>
                                to block insertions by other sessions into the gaps
                                covered by the range. For information about gap locks
                                and next-key locks, see
                                <a class="xref" href="innodb-storage-engine.html#innodb-locking" title="14.7.1&nbsp;InnoDB Locking">Section&nbsp;14.7.1, “InnoDB Locking”</a>.
                            </p><p style="color:blue;">对于其他搜索条件，innodb会锁定扫描的索引范围，使用gap locks或next key locks来阻止其他会话插入到范围覆盖的间隙中。有关间隙锁和下一个钥匙锁的信息，请参阅第14.7.1节“InnoDB锁定”。</p></li></ul>
                        </div>
                    </li><li class="listitem"><p><a name="isolevel_read-committed"></a>
                        <a class="indexterm" name="idm140286821383360"></a>

                        <a class="indexterm" name="idm140286821381888"></a>

                        <code class="literal">READ COMMITTED</code>
                    </p><p style="color:blue;">读取已提交</p><p>
                        Each consistent read, even within the same transaction, sets
                        and reads its own fresh snapshot. For information about
                        consistent reads, see
                        <a class="xref" href="innodb-storage-engine.html#innodb-consistent-read" title="14.7.2.3&nbsp;Consistent Nonlocking Reads">Section&nbsp;14.7.2.3, “Consistent Nonlocking Reads”</a>.
                    </p><p style="color:blue;">即使在同一事务中，每个一致的读操作都设置并读取自己的新快照。有关一致读取的信息，请参阅第14.7.2.3节“一致非锁定读取”。</p><p>
                        For locking reads (<a class="link" href="sql-syntax.html#select" title="13.2.9&nbsp;SELECT Syntax"><code class="literal">SELECT</code></a>
                        with <code class="literal">FOR UPDATE</code> or <code class="literal">LOCK IN SHARE
                        MODE</code>), <a class="link" href="sql-syntax.html#update" title="13.2.11&nbsp;UPDATE Syntax"><code class="literal">UPDATE</code></a>
                        statements, and <a class="link" href="sql-syntax.html#delete" title="13.2.2&nbsp;DELETE Syntax"><code class="literal">DELETE</code></a>
                        statements, <code class="literal">InnoDB</code> locks only index
                        records, not the gaps before them, and thus permits the free
                        insertion of new records next to locked records. Gap locking
                        is only used for foreign-key constraint checking and
                        duplicate-key checking.
                    </p><p style="color:blue;">对于锁定读取（对于update或lock in share mode）、update语句和delete语句，innodb只锁定索引记录，而不锁定它们之前的间隙，因此允许在锁定记录旁边自由插入新记录。间隙锁定仅用于外键约束检查和重复键检查。</p><p>
                        Because gap locking is disabled, phantom problems may occur,
                        as other sessions can insert new rows into the gaps. For
                        information about phantoms, see
                        <a class="xref" href="innodb-storage-engine.html#innodb-next-key-locking" title="14.7.4&nbsp;Phantom Rows">Section&nbsp;14.7.4, “Phantom Rows”</a>.
                    </p><p style="color:blue;">由于间隙锁定被禁用，可能会出现幻象问题，因为其他会话可以在间隙中插入新行。有关幻影的信息，请参见第14.7.4节“幻影行”。</p><p>
                        Only row-based binary logging is supported with the
                        <code class="literal">READ COMMITTED</code> isolation level. If you
                        use <code class="literal">READ COMMITTED</code> with
                        <a class="link" href="replication.html#sysvar_binlog_format"><code class="literal">binlog_format=MIXED</code></a>, the
                        server automatically uses row-based logging.
                    </p><p style="color:blue;">只读提交隔离级别仅支持基于行的二进制日志记录。如果使用read committed with binlog_format=mixed，服务器将自动使用基于行的日志记录。</p><p>
                        Using <code class="literal">READ COMMITTED</code> has additional
                        effects:
                    </p><p style="color:blue;">使用read committed具有其他效果：</p>
                        <div class="itemizedlist">
                            <ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
                                For <a class="link" href="sql-syntax.html#update" title="13.2.11&nbsp;UPDATE Syntax"><code class="literal">UPDATE</code></a> or
                                <a class="link" href="sql-syntax.html#delete" title="13.2.2&nbsp;DELETE Syntax"><code class="literal">DELETE</code></a> statements,
                                <code class="literal">InnoDB</code> holds locks only for rows that
                                it updates or deletes. Record locks for nonmatching rows
                                are released after MySQL has evaluated the
                                <code class="literal">WHERE</code> condition. This greatly reduces
                                the probability of deadlocks, but they can still happen.
                            </p><p style="color:blue;">对于update或delete语句，innodb只对其更新或删除的行持有锁。在mysql评估where条件之后，将释放非匹配行的记录锁。这大大降低了死锁的可能性，但它们仍然可能发生。</p></li><li class="listitem"><p>
                                For <a class="link" href="sql-syntax.html#update" title="13.2.11&nbsp;UPDATE Syntax"><code class="literal">UPDATE</code></a> statements, if
                                a row is already locked, <code class="literal">InnoDB</code>
                                performs a <span class="quote">“<span class="quote">semi-consistent</span>”</span> read,
                                returning the latest committed version to MySQL so that
                                MySQL can determine whether the row matches the
                                <code class="literal">WHERE</code> condition of the
                                <a class="link" href="sql-syntax.html#update" title="13.2.11&nbsp;UPDATE Syntax"><code class="literal">UPDATE</code></a>. If the row
                                matches (must be updated), MySQL reads the row again and
                                this time <code class="literal">InnoDB</code> either locks it or
                                waits for a lock on it.
                            </p><p style="color:blue;">对于update语句，如果一行已经被锁定，innodb执行“半一致”读取，将最新提交的版本返回给mysql，这样mysql就可以确定该行是否与更新的where条件匹配。如果行匹配（必须更新），mysql会再次读取行，这次innodb要么锁定它，要么等待对它的锁定。</p></li></ul>
                        </div>
                        <p>
                            Consider the following example, beginning with this table:
                        </p><p style="color:blue;">请考虑以下示例，从下表开始：</p><pre data-lang="sql" class="programlisting">CREATE TABLE t (a INT NOT NULL, b INT) ENGINE = InnoDB;
INSERT INTO t VALUES (1,2),(2,3),(3,2),(4,3),(5,2);
COMMIT;
</pre><p>
                            In this case, the table has no indexes, so searches and
                            index scans use the hidden clustered index for record
                            locking (see <a class="xref" href="innodb-storage-engine.html#innodb-index-types" title="14.6.2.1&nbsp;Clustered and Secondary Indexes">Section&nbsp;14.6.2.1, “Clustered and Secondary Indexes”</a>) rather
                            than indexed columns.
                        </p><p style="color:blue;">在这种情况下，表没有索引，因此搜索和索引扫描使用隐藏的聚集索引进行记录锁定（请参见第14.6.2.1节“聚集索引和辅助索引”），而不是索引列。</p><p>
                            Suppose that one session performs an
                            <a class="link" href="sql-syntax.html#update" title="13.2.11&nbsp;UPDATE Syntax"><code class="literal">UPDATE</code></a> using these
                            statements:
                        </p><p style="color:blue;">假设一个会话使用以下语句执行更新：</p><pre data-lang="sql" class="programlisting"># Session A
START TRANSACTION;
UPDATE t SET b = 5 WHERE b = 3;
</pre><p>
                            Suppose also that a second session performs an
                            <a class="link" href="sql-syntax.html#update" title="13.2.11&nbsp;UPDATE Syntax"><code class="literal">UPDATE</code></a> by executing this
                            statement following those of the first session:
                        </p><p style="color:blue;">还假设第二个会话通过在第一个会话之后执行此语句来执行更新：</p><pre data-lang="sql" class="programlisting"># Session B
UPDATE t SET b = 4 WHERE b = 2;
</pre><p>
                            As <a class="link" href="innodb-storage-engine.html" title="Chapter&nbsp;14&nbsp;The InnoDB Storage Engine"><code class="literal">InnoDB</code></a> executes each
                            <a class="link" href="sql-syntax.html#update" title="13.2.11&nbsp;UPDATE Syntax"><code class="literal">UPDATE</code></a>, it first acquires an
                            exclusive lock for each row that it reads, and then
                            determines whether to modify it. If
                            <a class="link" href="innodb-storage-engine.html" title="Chapter&nbsp;14&nbsp;The InnoDB Storage Engine"><code class="literal">InnoDB</code></a> does not modify the row,
                            it releases the lock. Otherwise,
                            <a class="link" href="innodb-storage-engine.html" title="Chapter&nbsp;14&nbsp;The InnoDB Storage Engine"><code class="literal">InnoDB</code></a> retains the lock until
                            the end of the transaction. This affects transaction
                            processing as follows.
                        </p><p style="color:blue;">当innodb执行每个更新时，它首先为读取的每一行获取一个独占锁，然后决定是否修改它。如果innodb不修改行，它就会释放锁。否则，innodb将保留锁直到事务结束。这会影响以下事务处理。</p><p>
                            When using the default <code class="literal">REPEATABLE READ</code>
                            isolation level, the first
                            <a class="link" href="sql-syntax.html#update" title="13.2.11&nbsp;UPDATE Syntax"><code class="literal">UPDATE</code></a> acquires an x-lock on
                            each row that it reads and does not release any of them:
                        </p><p style="color:blue;">当使用默认的可重复读取隔离级别时，第一个更新在它读取的每一行上获取一个X锁，而不会释放其中的任何一个：</p><pre data-lang="none" class="programlisting">x-lock(1,2); retain x-lock
x-lock(2,3); update(2,3) to (2,5); retain x-lock
x-lock(3,2); retain x-lock
x-lock(4,3); update(4,3) to (4,5); retain x-lock
x-lock(5,2); retain x-lock
</pre><p>
                            The second <a class="link" href="sql-syntax.html#update" title="13.2.11&nbsp;UPDATE Syntax"><code class="literal">UPDATE</code></a> blocks as
                            soon as it tries to acquire any locks (because first update
                            has retained locks on all rows), and does not proceed until
                            the first <a class="link" href="sql-syntax.html#update" title="13.2.11&nbsp;UPDATE Syntax"><code class="literal">UPDATE</code></a> commits or
                            rolls back:
                        </p><p style="color:blue;">第二次更新在尝试获取任何锁时立即阻塞（因为第一次更新保留了所有行上的锁），并且在第一次更新提交或回滚之前不会继续：</p><pre data-lang="none" class="programlisting">x-lock(1,2); block and wait for first UPDATE to commit or roll back
</pre><p>
                            If <code class="literal">READ COMMITTED</code> is used instead, the
                            first <a class="link" href="sql-syntax.html#update" title="13.2.11&nbsp;UPDATE Syntax"><code class="literal">UPDATE</code></a> acquires an
                            x-lock on each row that it reads and releases those for rows
                            that it does not modify:
                        </p><p style="color:blue;">如果改为使用read committed，则第一次更新将在其读取的每一行上获取一个x锁，并为其未修改的行释放x锁：</p><pre data-lang="none" class="programlisting">x-lock(1,2); unlock(1,2)
x-lock(2,3); update(2,3) to (2,5); retain x-lock
x-lock(3,2); unlock(3,2)
x-lock(4,3); update(4,3) to (4,5); retain x-lock
x-lock(5,2); unlock(5,2)
</pre><p>
                            For the second <code class="literal">UPDATE</code>,
                            <code class="literal">InnoDB</code> does a
                            <span class="quote">“<span class="quote">semi-consistent</span>”</span> read, returning the latest
                            committed version of each row that it reads to MySQL so that
                            MySQL can determine whether the row matches the
                            <code class="literal">WHERE</code> condition of the
                            <a class="link" href="sql-syntax.html#update" title="13.2.11&nbsp;UPDATE Syntax"><code class="literal">UPDATE</code></a>:
                        </p><p style="color:blue;">对于第二次更新，innodb执行“半一致”读取，将读取的每一行的最新提交版本返回给mysql，以便mysql可以确定该行是否与更新的where条件匹配：</p><pre data-lang="none" class="programlisting">x-lock(1,2); update(1,2) to (1,4); retain x-lock
x-lock(2,3); unlock(2,3)
x-lock(3,2); update(3,2) to (3,4); retain x-lock
x-lock(4,3); unlock(4,3)
x-lock(5,2); update(5,2) to (5,4); retain x-lock
</pre><p>
                            However, if the <code class="literal">WHERE</code> condition includes
                            an indexed column, and <code class="literal">InnoDB</code> uses the
                            index, only the indexed column is considered when taking and
                            retaining record locks. In the following example, the first
                            <a class="link" href="sql-syntax.html#update" title="13.2.11&nbsp;UPDATE Syntax"><code class="literal">UPDATE</code></a> takes and retains an
                            x-lock on each row where b = 2. The second
                            <a class="link" href="sql-syntax.html#update" title="13.2.11&nbsp;UPDATE Syntax"><code class="literal">UPDATE</code></a> blocks when it tries
                            to acquire x-locks on the same records, as it also uses the
                            index defined on column b.
                        </p><p style="color:blue;">但是，如果where条件包含索引列，并且innodb使用索引，那么在获取和保留记录锁时只考虑索引列。在下面的示例中，第一次更新在b=2的每一行上获取并保留一个x锁。第二个更新在尝试获取相同记录上的x锁时阻塞，因为它还使用在列b上定义的索引。</p><pre data-lang="sql" class="programlisting">CREATE TABLE t (a INT NOT NULL, b INT, c INT, INDEX (b)) ENGINE = InnoDB;
INSERT INTO t VALUES (1,2,3),(2,2,4);
COMMIT;

# Session A
START TRANSACTION;
UPDATE t SET b = 3 WHERE b = 2 AND c = 3;

# Session B
UPDATE t SET b = 4 WHERE b = 2 AND c = 4;
</pre><p>
                            The effects of using the <code class="literal">READ COMMITTED</code>
                            isolation level are the same as enabling the deprecated
                            <a class="link" href="innodb-storage-engine.html#sysvar_innodb_locks_unsafe_for_binlog"><code class="literal">innodb_locks_unsafe_for_binlog</code></a>
                            configuration option, with these exceptions:
                        </p><p style="color:blue;">使用read committed隔离级别的效果与启用已弃用的innodb_locks_unsafe_for_binlog配置选项相同，但以下情况除外：</p>
                        <div class="itemizedlist">
                            <ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
                                Enabling
                                <a class="link" href="innodb-storage-engine.html#sysvar_innodb_locks_unsafe_for_binlog"><code class="literal">innodb_locks_unsafe_for_binlog</code></a>
                                is a global setting and affects all sessions, whereas
                                the isolation level can be set globally for all
                                sessions, or individually per session.
                            </p><p style="color:blue;">启用innodb_locks_unsafe_for_binlog是一个全局设置，会影响所有会话，而隔离级别可以为所有会话全局设置，也可以为每个会话单独设置。</p></li><li class="listitem"><p>
                                <a class="link" href="innodb-storage-engine.html#sysvar_innodb_locks_unsafe_for_binlog"><code class="literal">innodb_locks_unsafe_for_binlog</code></a>
                                can be set only at server startup, whereas the isolation
                                level can be set at startup or changed at runtime.
                            </p><p style="color:blue;">innodb_locks_unsafe_for_binlog只能在服务器启动时设置，而隔离级别可以在启动时设置或在运行时更改。</p></li></ul>
                        </div>
                        <p>
                            <code class="literal">READ COMMITTED</code> therefore offers finer and
                            more flexible control than
                            <a class="link" href="innodb-storage-engine.html#sysvar_innodb_locks_unsafe_for_binlog"><code class="literal">innodb_locks_unsafe_for_binlog</code></a>.
                        </p><p style="color:blue;">因此，Read Read提供了比NuffdBLosisSunSuffyFuxBiLoSQL更精细更灵活的控制。</p></li><li class="listitem"><p><a name="isolevel_read-uncommitted"></a>
                        <a class="indexterm" name="idm140286821306704"></a>

                        <a class="indexterm" name="idm140286821305248"></a>

                        <code class="literal">READ UNCOMMITTED</code>
                    </p><p style="color:blue;">未提交读取</p><p>
                        <a class="link" href="sql-syntax.html#select" title="13.2.9&nbsp;SELECT Syntax"><code class="literal">SELECT</code></a> statements are
                        performed in a nonlocking fashion, but a possible earlier
                        version of a row might be used. Thus, using this isolation
                        level, such reads are not consistent. This is also called a
                        <a class="link" href="glossary.html#glos_dirty_read" title="dirty read">dirty read</a>.
                        Otherwise, this isolation level works like
                        <a class="link" href="innodb-storage-engine.html#isolevel_read-committed"><code class="literal">READ COMMITTED</code></a>.
                    </p><p style="color:blue;">select语句是以非锁定方式执行的，但可能会使用行的早期版本。因此，使用这个隔离级别，这样的读取是不一致的。这也被称为脏读。否则，此隔离级别的工作方式与read committed类似。</p></li><li class="listitem"><p><a name="isolevel_serializable"></a>
                        <a class="indexterm" name="idm140286821297872"></a>

                        <a class="indexterm" name="idm140286821296400"></a>

                        <code class="literal">SERIALIZABLE</code>
                    </p><p style="color:blue;">可串行化</p><p>
                        This level is like <a class="link" href="innodb-storage-engine.html#isolevel_repeatable-read"><code class="literal">REPEATABLE
                        READ</code></a>, but <code class="literal">InnoDB</code> implicitly
                        converts all plain <a class="link" href="sql-syntax.html#select" title="13.2.9&nbsp;SELECT Syntax"><code class="literal">SELECT</code></a>
                        statements to <a class="link" href="sql-syntax.html#select" title="13.2.9&nbsp;SELECT Syntax"><code class="literal">SELECT
                        ... LOCK IN SHARE MODE</code></a> if
                        <a class="link" href="server-administration.html#sysvar_autocommit"><code class="literal">autocommit</code></a> is disabled. If
                        <a class="link" href="server-administration.html#sysvar_autocommit"><code class="literal">autocommit</code></a> is enabled, the
                        <a class="link" href="sql-syntax.html#select" title="13.2.9&nbsp;SELECT Syntax"><code class="literal">SELECT</code></a> is its own
                        transaction. It therefore is known to be read only and can
                        be serialized if performed as a consistent (nonlocking) read
                        and need not block for other transactions. (To force a plain
                        <a class="link" href="sql-syntax.html#select" title="13.2.9&nbsp;SELECT Syntax"><code class="literal">SELECT</code></a> to block if other
                        transactions have modified the selected rows, disable
                        <a class="link" href="server-administration.html#sysvar_autocommit"><code class="literal">autocommit</code></a>.)
                    </p><p style="color:blue;">这个级别类似于repeatable read，但innodb隐式地将所有纯select语句转换为select…如果禁用自动提交，则锁定在共享模式。如果启用自动提交，则选择是其自己的事务。因此，它是只读的，如果作为一致（非锁定）读取执行，则可以序列化，并且不需要为其他事务阻塞。（若要在其他事务已修改选定行时强制阻止纯选择，请禁用“自动提交”。）</p></li></ul>
                </div>

            </div>
            <div class="section">
                <div class="titlepage">
                    <div>
                        <div>
                            <h4 class="title"><a name="innodb-autocommit-commit-rollback"></a>14.7.2.2&nbsp;autocommit, Commit, and Rollback</h4>

                        </div>

                    </div>

                </div>
                <a class="indexterm" name="idm140286821281024"></a><a class="indexterm" name="idm140286821279536"></a><p>
                In <code class="literal">InnoDB</code>, all user activity occurs inside a
                transaction. If <a class="link" href="server-administration.html#sysvar_autocommit"><code class="literal">autocommit</code></a> mode
                is enabled, each SQL statement forms a single transaction on its
                own. By default, MySQL starts the session for each new
                connection with <a class="link" href="server-administration.html#sysvar_autocommit"><code class="literal">autocommit</code></a>
                enabled, so MySQL does a commit after each SQL statement if that
                statement did not return an error. If a statement returns an
                error, the commit or rollback behavior depends on the error. See
                <a class="xref" href="innodb-storage-engine.html#innodb-error-handling" title="14.21.4&nbsp;InnoDB Error Handling">Section&nbsp;14.21.4, “InnoDB Error Handling”</a>.
            </p><p style="color:blue;">在innodb中，所有用户活动都发生在事务中。如果启用了autocommit模式，则每个sql语句都单独形成一个事务。默认情况下，mysql在启用autocommit的情况下为每个新连接启动会话，因此如果该语句没有返回错误，mysql会在每个sql语句之后执行commit。如果语句返回错误，则提交或回滚行为取决于错误。参见14.21.4节，“InnoDB错误处理”。</p><p>
                A session that has <a class="link" href="server-administration.html#sysvar_autocommit"><code class="literal">autocommit</code></a>
                enabled can perform a multiple-statement transaction by starting
                it with an explicit
                <a class="link" href="sql-syntax.html#commit" title="13.3.1&nbsp;START TRANSACTION, COMMIT, and ROLLBACK Syntax"><code class="literal">START
                    TRANSACTION</code></a> or
                <a class="link" href="sql-syntax.html#commit" title="13.3.1&nbsp;START TRANSACTION, COMMIT, and ROLLBACK Syntax"><code class="literal">BEGIN</code></a>
                statement and ending it with a
                <a class="link" href="sql-syntax.html#commit" title="13.3.1&nbsp;START TRANSACTION, COMMIT, and ROLLBACK Syntax"><code class="literal">COMMIT</code></a> or
                <a class="link" href="sql-syntax.html#commit" title="13.3.1&nbsp;START TRANSACTION, COMMIT, and ROLLBACK Syntax"><code class="literal">ROLLBACK</code></a>
                statement. See <a class="xref" href="sql-syntax.html#commit" title="13.3.1&nbsp;START TRANSACTION, COMMIT, and ROLLBACK Syntax">Section&nbsp;13.3.1, “START TRANSACTION, COMMIT, and ROLLBACK Syntax”</a>.
            </p><p style="color:blue;">启用autocommit的会话可以通过使用显式start transaction或begin语句启动多语句事务，并使用commit或rollback语句结束它来执行多语句事务。参见第13.3.1节“启动事务、提交和回滚语法”。</p><p>
                If <a class="link" href="server-administration.html#sysvar_autocommit"><code class="literal">autocommit</code></a> mode is disabled
                within a session with <code class="literal">SET autocommit = 0</code>, the
                session always has a transaction open. A
                <a class="link" href="sql-syntax.html#commit" title="13.3.1&nbsp;START TRANSACTION, COMMIT, and ROLLBACK Syntax"><code class="literal">COMMIT</code></a> or
                <a class="link" href="sql-syntax.html#commit" title="13.3.1&nbsp;START TRANSACTION, COMMIT, and ROLLBACK Syntax"><code class="literal">ROLLBACK</code></a>
                statement ends the current transaction and a new one starts.
            </p><p style="color:blue;">如果在设置为autocommit=0的会话中禁用autocommit模式，则该会话始终有一个打开的事务。commit或rollback语句结束当前事务并启动新事务。</p><p>
                If a session that has
                <a class="link" href="server-administration.html#sysvar_autocommit"><code class="literal">autocommit</code></a> disabled ends
                without explicitly committing the final transaction, MySQL rolls
                back that transaction.
            </p><p style="color:blue;">如果禁用autocommit的会话在未显式提交最终事务的情况下结束，mysql将回滚该事务。</p><p>
                Some statements implicitly end a transaction, as if you had done
                a <a class="link" href="sql-syntax.html#commit" title="13.3.1&nbsp;START TRANSACTION, COMMIT, and ROLLBACK Syntax"><code class="literal">COMMIT</code></a> before executing the
                statement. For details, see <a class="xref" href="sql-syntax.html#implicit-commit" title="13.3.3&nbsp;Statements That Cause an Implicit Commit">Section&nbsp;13.3.3, “Statements That Cause an Implicit Commit”</a>.
            </p><p style="color:blue;">有些语句隐式地结束事务，就好像在执行语句之前执行了提交一样。有关详细信息，请参见第13.3.3节“导致隐式提交的语句”。</p><p>
                A <a class="link" href="sql-syntax.html#commit" title="13.3.1&nbsp;START TRANSACTION, COMMIT, and ROLLBACK Syntax"><code class="literal">COMMIT</code></a> means that the changes
                made in the current transaction are made permanent and become
                visible to other sessions. A
                <a class="link" href="sql-syntax.html#commit" title="13.3.1&nbsp;START TRANSACTION, COMMIT, and ROLLBACK Syntax"><code class="literal">ROLLBACK</code></a>
                statement, on the other hand, cancels all modifications made by
                the current transaction. Both
                <a class="link" href="sql-syntax.html#commit" title="13.3.1&nbsp;START TRANSACTION, COMMIT, and ROLLBACK Syntax"><code class="literal">COMMIT</code></a> and
                <a class="link" href="sql-syntax.html#commit" title="13.3.1&nbsp;START TRANSACTION, COMMIT, and ROLLBACK Syntax"><code class="literal">ROLLBACK</code></a>
                release all <code class="literal">InnoDB</code> locks that were set during
                the current transaction.
            </p><p style="color:blue;">提交意味着当前事务中所做的更改将成为永久性的，并对其他会话可见。另一方面，rollback语句取消当前事务所做的所有修改。commit和rollback都释放当前事务期间设置的所有innodb锁。</p>
                <div class="simplesect">

                    <div class="titlepage">
                        <div>

                            <div class="simple">
                                <h5 class="title"><a name="innodb-transactions-with-different-apis"></a>Grouping DML Operations with Transactions</h5>
                            </div>
                        </div>
                    </div>
                    <a class="indexterm" name="idm140286821249408"></a><p>
                    By default, connection to the MySQL server begins with
                    <a class="link" href="glossary.html#glos_autocommit" title="autocommit">autocommit</a> mode
                    enabled, which automatically commits every SQL statement as
                    you execute it. This mode of operation might be unfamiliar if
                    you have experience with other database systems, where it is
                    standard practice to issue a sequence of
                    <a class="link" href="glossary.html#glos_dml" title="DML">DML</a> statements and commit them
                    or roll them back all together.
                </p><p style="color:blue;">默认情况下，与mysql服务器的连接以启用自动提交模式开始，自动提交模式在您执行每一个sql语句时自动提交它。如果您有使用其他数据库系统的经验，则可能不熟悉这种操作模式，在其他数据库系统中，标准做法是发出一系列dml语句并提交它们或将它们一起回滚。</p><p>
                    To use multiple-statement
                    <a class="link" href="glossary.html#glos_transaction" title="transaction">transactions</a>, switch
                    autocommit off with the SQL statement <code class="literal">SET autocommit
                    = 0</code> and end each transaction with
                    <a class="link" href="sql-syntax.html#commit" title="13.3.1&nbsp;START TRANSACTION, COMMIT, and ROLLBACK Syntax"><code class="literal">COMMIT</code></a> or
                    <a class="link" href="sql-syntax.html#commit" title="13.3.1&nbsp;START TRANSACTION, COMMIT, and ROLLBACK Syntax"><code class="literal">ROLLBACK</code></a> as
                    appropriate. To leave autocommit on, begin each transaction
                    with <a class="link" href="sql-syntax.html#commit" title="13.3.1&nbsp;START TRANSACTION, COMMIT, and ROLLBACK Syntax"><code class="literal">START
                    TRANSACTION</code></a> and end it with
                    <a class="link" href="sql-syntax.html#commit" title="13.3.1&nbsp;START TRANSACTION, COMMIT, and ROLLBACK Syntax"><code class="literal">COMMIT</code></a> or
                    <a class="link" href="sql-syntax.html#commit" title="13.3.1&nbsp;START TRANSACTION, COMMIT, and ROLLBACK Syntax"><code class="literal">ROLLBACK</code></a>.
                    The following example shows two transactions. The first is
                    committed; the second is rolled back.
                </p><p style="color:blue;">若要使用多个语句事务，请关闭autocommit，并将sql语句设置为autocommit=0，然后根据需要使用commit或rollback结束每个事务。要使autocommit保持打开状态，请使用start transaction开始每个事务，并使用commit或rollback结束它。下面的示例显示了两个事务。第一个被提交；第二个被回滚。</p><pre data-lang="terminal" class="programlisting">shell&gt; <strong class="userinput"><code>mysql test</code></strong>
</pre><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>CREATE TABLE customer (a INT, b CHAR (20), INDEX (a));</code></strong>
Query OK, 0 rows affected (0.00 sec)
mysql&gt; <strong class="userinput"><code>-- Do a transaction with autocommit turned on.</code></strong>
mysql&gt; <strong class="userinput"><code>START TRANSACTION;</code></strong>
Query OK, 0 rows affected (0.00 sec)
mysql&gt; <strong class="userinput"><code>INSERT INTO customer VALUES (10, 'Heikki');</code></strong>
Query OK, 1 row affected (0.00 sec)
mysql&gt; <strong class="userinput"><code>COMMIT;</code></strong>
Query OK, 0 rows affected (0.00 sec)
mysql&gt; <strong class="userinput"><code>-- Do another transaction with autocommit turned off.</code></strong>
mysql&gt; <strong class="userinput"><code>SET autocommit=0;</code></strong>
Query OK, 0 rows affected (0.00 sec)
mysql&gt; <strong class="userinput"><code>INSERT INTO customer VALUES (15, 'John');</code></strong>
Query OK, 1 row affected (0.00 sec)
mysql&gt; <strong class="userinput"><code>INSERT INTO customer VALUES (20, 'Paul');</code></strong>
Query OK, 1 row affected (0.00 sec)
mysql&gt; <strong class="userinput"><code>DELETE FROM customer WHERE b = 'Heikki';</code></strong>
Query OK, 1 row affected (0.00 sec)
mysql&gt; <strong class="userinput"><code>-- Now we undo those last 2 inserts and the delete.</code></strong>
mysql&gt; <strong class="userinput"><code>ROLLBACK;</code></strong>
Query OK, 0 rows affected (0.00 sec)
mysql&gt; <strong class="userinput"><code>SELECT * FROM customer;</code></strong>
+------+--------+
| a    | b      |
+------+--------+
|   10 | Heikki |
+------+--------+
1 row in set (0.00 sec)
mysql&gt;
</pre><h6><a name="idm140286821223968"></a>Transactions in Client-Side Languages</h6><p>
                    In APIs such as PHP, Perl DBI, JDBC, ODBC, or the standard C
                    call interface of MySQL, you can send transaction control
                    statements such as <a class="link" href="sql-syntax.html#commit" title="13.3.1&nbsp;START TRANSACTION, COMMIT, and ROLLBACK Syntax"><code class="literal">COMMIT</code></a> to
                    the MySQL server as strings just like any other SQL statements
                    such as <a class="link" href="sql-syntax.html#select" title="13.2.9&nbsp;SELECT Syntax"><code class="literal">SELECT</code></a> or
                    <a class="link" href="sql-syntax.html#insert" title="13.2.5&nbsp;INSERT Syntax"><code class="literal">INSERT</code></a>. Some APIs also offer
                    separate special transaction commit and rollback functions or
                    methods.
                </p><p style="color:blue;">在php、perl-dbi、jdbc、odbc或mysql的标准c调用接口等api中，可以像select或insert等其他sql语句一样，将commit等事务控制语句作为字符串发送到mysql服务器。一些api还提供单独的特殊事务提交和回滚函数或方法。</p>
                </div>

            </div>
            <div class="section">
                <div class="titlepage">
                    <div>
                        <div>
                            <h4 class="title"><a name="innodb-consistent-read"></a>14.7.2.3&nbsp;Consistent Nonlocking Reads</h4>

                        </div>

                    </div>

                </div>
                <a class="indexterm" name="idm140286821217376"></a><a class="indexterm" name="idm140286821215920"></a><p>
                A <a class="link" href="glossary.html#glos_consistent_read" title="consistent read">consistent read</a>
                means that <code class="literal">InnoDB</code> uses multi-versioning to
                present to a query a snapshot of the database at a point in
                time. The query sees the changes made by transactions that
                committed before that point of time, and no changes made by
                later or uncommitted transactions. The exception to this rule is
                that the query sees the changes made by earlier statements
                within the same transaction. This exception causes the following
                anomaly: If you update some rows in a table, a
                <a class="link" href="sql-syntax.html#select" title="13.2.9&nbsp;SELECT Syntax"><code class="literal">SELECT</code></a> sees the latest version of
                the updated rows, but it might also see older versions of any
                rows. If other sessions simultaneously update the same table,
                the anomaly means that you might see the table in a state that
                never existed in the database.
            </p><p style="color:blue;">一致读取意味着innodb使用多版本控制在一个时间点向查询显示数据库的快照。查询将看到在该时间点之前提交的事务所做的更改，而不会看到稍后或未提交的事务所做的更改。此规则的例外情况是，查询可以看到同一事务中早期语句所做的更改。此异常导致以下异常：如果更新表中的某些行，select将看到更新行的最新版本，但也可能看到任何行的较旧版本。如果其他会话同时更新同一个表，则异常意味着您可能会在数据库中从未存在的状态下看到该表。</p><p>
                If the transaction
                <a class="link" href="glossary.html#glos_isolation_level" title="isolation level">isolation level</a> is
                <a class="link" href="innodb-storage-engine.html#isolevel_repeatable-read"><code class="literal">REPEATABLE READ</code></a> (the default
                level), all consistent reads within the same transaction read
                the snapshot established by the first such read in that
                transaction. You can get a fresher snapshot for your queries by
                committing the current transaction and after that issuing new
                queries.
            </p><p style="color:blue;">如果事务隔离级别是可重复读取（默认级别），则同一事务中的所有一致读取都将读取该事务中第一个此类读取所建立的快照。通过提交当前事务并在该事务之后发出新查询，可以为查询获取更新鲜的快照。</p><p>
                With <a class="link" href="innodb-storage-engine.html#isolevel_read-committed"><code class="literal">READ COMMITTED</code></a> isolation
                level, each consistent read within a transaction sets and reads
                its own fresh snapshot.
            </p><p style="color:blue;">使用read committed隔离级别，事务中的每个一致读取都会设置并读取自己的新快照。</p><p>
                Consistent read is the default mode in which
                <code class="literal">InnoDB</code> processes
                <a class="link" href="sql-syntax.html#select" title="13.2.9&nbsp;SELECT Syntax"><code class="literal">SELECT</code></a> statements in
                <a class="link" href="innodb-storage-engine.html#isolevel_read-committed"><code class="literal">READ COMMITTED</code></a> and
                <a class="link" href="innodb-storage-engine.html#isolevel_repeatable-read"><code class="literal">REPEATABLE READ</code></a> isolation
                levels. A consistent read does not set any locks on the tables
                it accesses, and therefore other sessions are free to modify
                those tables at the same time a consistent read is being
                performed on the table.
            </p><p style="color:blue;">一致读取是innodb进程在read committed和repeatable读取隔离级别中选择语句的默认模式。一致读取不会对其访问的表设置任何锁，因此其他会话可以在对表执行一致读取的同时自由修改这些表。</p><p>
                Suppose that you are running in the default
                <a class="link" href="innodb-storage-engine.html#isolevel_repeatable-read"><code class="literal">REPEATABLE READ</code></a> isolation
                level. When you issue a consistent read (that is, an ordinary
                <a class="link" href="sql-syntax.html#select" title="13.2.9&nbsp;SELECT Syntax"><code class="literal">SELECT</code></a> statement),
                <code class="literal">InnoDB</code> gives your transaction a timepoint
                according to which your query sees the database. If another
                transaction deletes a row and commits after your timepoint was
                assigned, you do not see the row as having been deleted. Inserts
                and updates are treated similarly.
            </p><p style="color:blue;">假设您正在默认的可重复读取隔离级别中运行。当发出一致读取（即普通的select语句）时，innodb会给事务一个时间点，根据这个时间点查询可以看到数据库。如果另一个事务在指定了您的时间点后删除一行并提交，则您不会看到该行已被删除。插入和更新的处理方式类似。</p>
                <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">

                    <div class="admon-title">
                        Note
                    </div>
                    <p>
                        The snapshot of the database state applies to
                        <a class="link" href="sql-syntax.html#select" title="13.2.9&nbsp;SELECT Syntax"><code class="literal">SELECT</code></a> statements within a
                        transaction, not necessarily to
                        <a class="link" href="glossary.html#glos_dml" title="DML">DML</a> statements. If you insert
                        or modify some rows and then commit that transaction, a
                        <a class="link" href="sql-syntax.html#delete" title="13.2.2&nbsp;DELETE Syntax"><code class="literal">DELETE</code></a> or
                        <a class="link" href="sql-syntax.html#update" title="13.2.11&nbsp;UPDATE Syntax"><code class="literal">UPDATE</code></a> statement issued from
                        another concurrent <code class="literal">REPEATABLE READ</code>
                        transaction could affect those just-committed rows, even
                        though the session could not query them. If a transaction does
                        update or delete rows committed by a different transaction,
                        those changes do become visible to the current transaction.
                        For example, you might encounter a situation like the
                        following:
                    </p><p style="color:blue;">数据库状态的快照应用于事务中的select语句，而不一定应用于dml语句。如果插入或修改某些行，然后提交该事务，则从另一个并发可重复读取事务发出的delete或update语句可能会影响那些刚刚提交的行，即使会话无法查询它们。如果事务确实更新或删除由其他事务提交的行，则这些更改对当前事务可见。例如，您可能会遇到以下情况：</p><pre data-lang="sql" class="programlisting">SELECT COUNT(c1) FROM t1 WHERE c1 = 'xyz';
-- Returns 0: no rows match.
DELETE FROM t1 WHERE c1 = 'xyz';
-- Deletes several rows recently committed by other transaction.

SELECT COUNT(c2) FROM t1 WHERE c2 = 'abc';
-- Returns 0: no rows match.
UPDATE t1 SET c2 = 'cba' WHERE c2 = 'abc';
-- Affects 10 rows: another txn just committed 10 rows with 'abc' values.
SELECT COUNT(c2) FROM t1 WHERE c2 = 'cba';
-- Returns 10: this txn can now see the rows it just updated.
</pre>
                </div>
                <p>
                    You can advance your timepoint by committing your transaction
                    and then doing another <a class="link" href="sql-syntax.html#select" title="13.2.9&nbsp;SELECT Syntax"><code class="literal">SELECT</code></a> or
                    <a class="link" href="sql-syntax.html#commit" title="13.3.1&nbsp;START TRANSACTION, COMMIT, and ROLLBACK Syntax"><code class="literal">START TRANSACTION WITH
                        CONSISTENT SNAPSHOT</code></a>.
                </p><p style="color:blue;">您可以通过提交事务，然后使用一致的快照执行另一个select或start事务来提前您的时间点。</p><p>
                This is called <span class="firstterm">multi-versioned
        concurrency control</span>.
            </p><p style="color:blue;">这称为多版本并发控制。</p><p>
                In the following example, session A sees the row inserted by B
                only when B has committed the insert and A has committed as
                well, so that the timepoint is advanced past the commit of B.
            </p><p style="color:blue;">在下面的示例中，会话A仅在B提交了插入操作并且A也提交了插入操作时才看到B插入的行，因此时间点提前到B提交操作之后。</p><pre data-lang="sql" class="programlisting">             Session A              Session B

           SET autocommit=0;      SET autocommit=0;
time
|          SELECT * FROM t;
|          empty set
|                                 INSERT INTO t VALUES (1, 2);
|
v          SELECT * FROM t;
           empty set
                                  COMMIT;

           SELECT * FROM t;
           empty set

           COMMIT;

           SELECT * FROM t;
           ---------------------
           |    1    |    2    |
           ---------------------
</pre><p>
                If you want to see the <span class="quote">“<span class="quote">freshest</span>”</span> state of the
                database, use either the <a class="link" href="innodb-storage-engine.html#isolevel_read-committed"><code class="literal">READ
                COMMITTED</code></a> isolation level or a
                <a class="link" href="glossary.html#glos_locking_read" title="locking read">locking read</a>:
            </p><p style="color:blue;">如果要查看数据库的“最新”状态，请使用读取提交隔离级别或锁定读取：</p><pre data-lang="sql" class="programlisting">SELECT * FROM t FOR SHARE;
</pre><p>
                With <a class="link" href="innodb-storage-engine.html#isolevel_read-committed"><code class="literal">READ COMMITTED</code></a> isolation
                level, each consistent read within a transaction sets and reads
                its own fresh snapshot. With <code class="literal">LOCK IN SHARE
                MODE</code>, a locking read occurs instead: A
                <code class="literal">SELECT</code> blocks until the transaction
                containing the freshest rows ends (see
                <a class="xref" href="innodb-storage-engine.html#innodb-locking-reads" title="14.7.2.4&nbsp;Locking Reads">Section&nbsp;14.7.2.4, “Locking Reads”</a>).
            </p><p style="color:blue;">使用read committed隔离级别，事务中的每个一致读取都会设置并读取自己的新快照。在共享模式下锁定时，将发生锁定读取：select阻塞直到包含最新行的事务结束（请参阅第14.7.2.4节“锁定读取”）。</p><p>
                Consistent read does not work over certain DDL statements:
            </p><p style="color:blue;">一致读取不适用于某些DDL语句：</p>
                <div class="itemizedlist">
                    <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                        Consistent read does not work over <a class="link" href="sql-syntax.html#drop-table" title="13.1.29&nbsp;DROP TABLE Syntax"><code class="literal">DROP
                        TABLE</code></a>, because MySQL cannot use a table that has
                        been dropped and <code class="literal">InnoDB</code> destroys the
                        table.
                    </p><p style="color:blue;">一致读取不适用于drop table，因为mysql不能使用已删除的表，innodb会破坏该表。</p></li><li class="listitem"><p>
                        Consistent read does not work over
                        <a class="link" href="sql-syntax.html#alter-table" title="13.1.8&nbsp;ALTER TABLE Syntax"><code class="literal">ALTER TABLE</code></a>, because that
                        statement makes a temporary copy of the original table and
                        deletes the original table when the temporary copy is built.
                        When you reissue a consistent read within a transaction,
                        rows in the new table are not visible because those rows did
                        not exist when the transaction's snapshot was taken. In this
                        case, the transaction returns an error:
                        <a class="link" href="error-handling.html#error_er_table_def_changed"><code class="literal">ER_TABLE_DEF_CHANGED</code></a>,
                        <span class="quote">“<span class="quote">Table definition has changed, please retry
            transaction</span>”</span>.
                    </p><p style="color:blue;">一致读取不适用于alter table，因为该语句生成原始表的临时副本，并在生成临时副本时删除原始表。当在事务中重新发布一致的读取时，新表中的行不可见，因为当事务快照被捕获时，这些行不存在。在这种情况下，事务返回一个错误：er_table_def_changed，“table definition has changed，please retry transaction”。</p></li></ul>
                </div>
                <p>
                    The type of read varies for selects in clauses like
                    <a class="link" href="sql-syntax.html#insert" title="13.2.5&nbsp;INSERT Syntax"><code class="literal">INSERT INTO ...
                        SELECT</code></a>, <a class="link" href="sql-syntax.html#update" title="13.2.11&nbsp;UPDATE Syntax"><code class="literal">UPDATE
                    ... (SELECT)</code></a>, and
                    <a class="link" href="sql-syntax.html#create-table" title="13.1.18&nbsp;CREATE TABLE Syntax"><code class="literal">CREATE TABLE ...
                        SELECT</code></a> that do not specify <code class="literal">FOR
                    UPDATE</code> or <code class="literal">LOCK IN SHARE MODE</code>:
                </p><p style="color:blue;">对于像INSERT INTO这样的SELECT IN子句，读取的类型有所不同…选择，更新…（选择），然后创建表…选择不指定用于更新或锁定共享模式的：</p>
                <div class="itemizedlist">
                    <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                        By default, <code class="literal">InnoDB</code> uses stronger locks
                        and the <a class="link" href="sql-syntax.html#select" title="13.2.9&nbsp;SELECT Syntax"><code class="literal">SELECT</code></a> part acts like
                        <a class="link" href="innodb-storage-engine.html#isolevel_read-committed"><code class="literal">READ COMMITTED</code></a>, where
                        each consistent read, even within the same transaction, sets
                        and reads its own fresh snapshot.
                    </p><p style="color:blue;">默认情况下，innodb使用更强的锁，select部分的行为类似于read committed，在这里，即使在同一个事务中，每个一致的读都设置并读取自己的新快照。</p></li><li class="listitem"><p>
                        To use a consistent read in such cases, enable the
                        <a class="link" href="innodb-storage-engine.html#sysvar_innodb_locks_unsafe_for_binlog"><code class="literal">innodb_locks_unsafe_for_binlog</code></a>
                        option and set the isolation level of the transaction to
                        <a class="link" href="innodb-storage-engine.html#isolevel_read-uncommitted"><code class="literal">READ UNCOMMITTED</code></a>,
                        <a class="link" href="innodb-storage-engine.html#isolevel_read-committed"><code class="literal">READ COMMITTED</code></a>, or
                        <a class="link" href="innodb-storage-engine.html#isolevel_repeatable-read"><code class="literal">REPEATABLE READ</code></a> (that is,
                        anything other than
                        <a class="link" href="innodb-storage-engine.html#isolevel_serializable"><code class="literal">SERIALIZABLE</code></a>). In this
                        case, no locks are set on rows read from the selected table.
                    </p><p style="color:blue;">要在这种情况下使用一致读取，请启用innodb_locks_unsafe_for_binlog选项，并将事务的隔离级别设置为读取未提交、已提交读取或可重复读取（即除可序列化之外的任何内容）。在这种情况下，不会对从选定表中读取的行设置锁。</p></li></ul>
                </div>

            </div>
            <div class="section">
                <div class="titlepage">
                    <div>
                        <div>
                            <h4 class="title"><a name="innodb-locking-reads"></a>14.7.2.4&nbsp;Locking Reads</h4>

                        </div>

                    </div>

                </div>
                <a class="indexterm" name="idm140286821148064"></a><p>
                If you query data and then insert or update related data within
                the same transaction, the regular <code class="literal">SELECT</code>
                statement does not give enough protection. Other transactions
                can update or delete the same rows you just queried.
                <code class="literal">InnoDB</code> supports two types of
                <a class="link" href="glossary.html#glos_locking_read" title="locking read">locking reads</a> that
                offer extra safety:
            </p><p style="color:blue;">如果查询数据，然后在同一事务中插入或更新相关数据，常规的select语句不会提供足够的保护。其他事务可以更新或删除刚才查询的同一行。InnoDB支持两种提供额外安全性的锁定读取：</p>
                <div class="itemizedlist">
                    <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                        <a class="link" href="sql-syntax.html#select" title="13.2.9&nbsp;SELECT Syntax"><code class="literal">SELECT ... LOCK IN
                            SHARE MODE</code></a>
                    </p><p style="color:blue;">选择…锁定共享模式</p><p>
                        Sets a shared mode lock on any rows that are read. Other
                        sessions can read the rows, but cannot modify them until
                        your transaction commits. If any of these rows were changed
                        by another transaction that has not yet committed, your
                        query waits until that transaction ends and then uses the
                        latest values.
                    </p><p style="color:blue;">对读取的任何行设置共享模式锁定。其他会话可以读取行，但在提交事务之前无法修改它们。如果这些行中的任何行被另一个尚未提交的事务更改，则查询将等待该事务结束，然后使用最新值。</p></li><li class="listitem"><p>
                        <a class="link" href="sql-syntax.html#select" title="13.2.9&nbsp;SELECT Syntax"><code class="literal">SELECT ... FOR
                            UPDATE</code></a>
                    </p><p style="color:blue;">选择…更新</p><p>
                        For index records the search encounters, locks the rows and
                        any associated index entries, the same as if you issued an
                        <code class="literal">UPDATE</code> statement for those rows. Other
                        transactions are blocked from updating those rows, from
                        doing <code class="literal">SELECT ... LOCK IN SHARE MODE</code>, or
                        from reading the data in certain transaction isolation
                        levels. Consistent reads ignore any locks set on the records
                        that exist in the read view. (Old versions of a record
                        cannot be locked; they are reconstructed by applying
                        <a class="link" href="glossary.html#glos_undo_log" title="undo log">undo logs</a> on an
                        in-memory copy of the record.)
                    </p><p style="color:blue;">对于搜索遇到的索引记录，锁定行和任何关联的索引项，就像对这些行发出update语句一样。其他事务无法更新这些行，无法执行选择…锁定在共享模式下，或从某些事务隔离级别读取数据。一致读取忽略在读取视图中存在的记录上设置的任何锁。（旧版本的记录无法锁定；它们是通过对记录的内存副本应用撤消日志来重建的。）</p></li></ul>
                </div>
                <p>
                    These clauses are primarily useful when dealing with
                    tree-structured or graph-structured data, either in a single
                    table or split across multiple tables. You traverse edges or
                    tree branches from one place to another, while reserving the
                    right to come back and change any of these
                    <span class="quote">“<span class="quote">pointer</span>”</span> values.
                </p><p style="color:blue;">这些子句主要用于处理树结构或图结构数据（在单个表中或在多个表中拆分）。您可以从一个地方到另一个地方遍历边或树枝，同时保留返回并更改这些“指针”值的权利。</p><p>
                All locks set by <code class="literal">LOCK IN SHARE MODE</code> and
                <code class="literal">FOR UPDATE</code> queries are released when the
                transaction is committed or rolled back.
            </p><p style="color:blue;">当事务被提交或回滚时，由共享模式下的锁和用于更新查询的锁设置的所有锁都将被释放。</p>
                <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">

                    <div class="admon-title">
                        Note
                    </div>
                    <p>
                        Locking reads are only possible when autocommit is disabled
                        (either by beginning transaction with
                        <a class="link" href="sql-syntax.html#commit" title="13.3.1&nbsp;START TRANSACTION, COMMIT, and ROLLBACK Syntax"><code class="literal">START
                            TRANSACTION</code></a> or by setting
                        <a class="link" href="server-administration.html#sysvar_autocommit"><code class="literal">autocommit</code></a> to 0.
                    </p><p style="color:blue;">只有当autocommit被禁用时（通过使用start transaction开始事务或通过将autocommit设置为0），才能进行锁定读取。</p>
                </div>
                <p>
                    A locking read clause in an outer statement does not lock the
                    rows of a table in a nested subquery unless a locking read
                    clause is also specified in the subquery. For example, the
                    following statement does not lock rows in table
                    <code class="literal">t2</code>.
                </p><p style="color:blue;">除非在子查询中也指定了locking read子句，否则外部语句中的locking read子句不会锁定嵌套子查询中表的行。例如，下面的语句不锁定表t2中的行。</p><pre data-lang="sql" class="programlisting">SELECT * FROM t1 WHERE c1 = (SELECT c1 FROM t2) FOR UPDATE;
</pre><p>
                To lock rows in table <code class="literal">t2</code>, add a locking read
                clause to the subquery:
            </p><p style="color:blue;">要锁定表t2中的行，请向子查询添加一个locking read子句：</p><pre data-lang="sql" class="programlisting">SELECT * FROM t1 WHERE c1 = (SELECT c1 FROM t2 FOR UPDATE) FOR UPDATE;
</pre>
                <div class="simplesect">

                    <div class="titlepage">
                        <div>

                            <div class="simple">
                                <h5 class="title"><a name="innodb-locking-reads-examples"></a>Locking Read Examples</h5>
                            </div>
                        </div>
                    </div>
                    <p>
                        Suppose that you want to insert a new row into a table
                        <code class="literal">child</code>, and make sure that the child row has
                        a parent row in table <code class="literal">parent</code>. Your
                        application code can ensure referential integrity throughout
                        this sequence of operations.
                    </p><p style="color:blue;">假设要将新行插入表子行，并确保子行在表父行中有父行。应用程序代码可以确保整个操作序列的引用完整性。</p><p>
                    First, use a consistent read to query the table
                    <code class="literal">PARENT</code> and verify that the parent row
                    exists. Can you safely insert the child row to table
                    <code class="literal">CHILD</code>? No, because some other session could
                    delete the parent row in the moment between your
                    <code class="literal">SELECT</code> and your <code class="literal">INSERT</code>,
                    without you being aware of it.
                </p><p style="color:blue;">首先，使用一致的读取来查询表父级并验证父行是否存在。您能安全地将子行插入到表child吗？不，因为在您的选择和插入之间的某个其他会话可能会删除父行，而您不会意识到这一点。</p><p>
                    To avoid this potential issue, perform the
                    <a class="link" href="sql-syntax.html#select" title="13.2.9&nbsp;SELECT Syntax"><code class="literal">SELECT</code></a> using <code class="literal">LOCK IN
                    SHARE MODE</code>:
                </p><p style="color:blue;">若要避免此潜在问题，请在共享模式下执行“使用锁定选择”：</p><pre data-lang="sql" class="programlisting">SELECT * FROM parent WHERE NAME = 'Jones' LOCK IN SHARE MODE;
</pre><p>
                    After the <code class="literal">LOCK IN SHARE MODE</code> query returns
                    the parent <code class="literal">'Jones'</code>, you can safely add the
                    child record to the <code class="literal">CHILD</code> table and commit
                    the transaction. Any transaction that tries to acquire an
                    exclusive lock in the applicable row in the
                    <code class="literal">PARENT</code> table waits until you are finished,
                    that is, until the data in all tables is in a consistent
                    state.
                </p><p style="color:blue;">在lock-in-share模式查询返回父“jones”之后，您可以安全地将子记录添加到子表并提交事务。任何试图在父表中的可应用行中获取排他锁的事务等待直到完成为止，也就是说，直到所有表中的数据处于一致状态。</p><p>
                    For another example, consider an integer counter field in a
                    table <code class="literal">CHILD_CODES</code>, used to assign a unique
                    identifier to each child added to table
                    <code class="literal">CHILD</code>. Do not use either consistent read or
                    a shared mode read to read the present value of the counter,
                    because two users of the database could see the same value for
                    the counter, and a duplicate-key error occurs if two
                    transactions attempt to add rows with the same identifier to
                    the <code class="literal">CHILD</code> table.
                </p><p style="color:blue;">例如，考虑表子代码中的整数计数器字段，用于为添加到表子代码中的每个子代码分配唯一标识符。不要使用一致读取或共享模式读取来读取计数器的当前值，因为数据库的两个用户可以看到计数器的相同值，如果两个事务尝试向子表添加具有相同标识符的行，则会发生重复键错误。</p><p>
                    Here, <code class="literal">LOCK IN SHARE MODE</code> is not a good
                    solution because if two users read the counter at the same
                    time, at least one of them ends up in deadlock when it
                    attempts to update the counter.
                </p><p style="color:blue;">在这里，锁定共享模式不是一个好的解决方案，因为如果两个用户同时读取计数器，那么至少其中一个用户在尝试更新计数器时会死锁。</p><p>
                    To implement reading and incrementing the counter, first
                    perform a locking read of the counter using <code class="literal">FOR
                    UPDATE</code>, and then increment the counter. For example:
                </p><p style="color:blue;">要实现计数器的读取和递增，首先使用for update对计数器执行锁定读取，然后递增计数器。例如：</p><pre data-lang="sql" class="programlisting">SELECT counter_field FROM child_codes FOR UPDATE;
UPDATE child_codes SET counter_field = counter_field + 1;
</pre><p>
                    A <a class="link" href="sql-syntax.html#select" title="13.2.9&nbsp;SELECT Syntax"><code class="literal">SELECT ... FOR
                    UPDATE</code></a> reads the latest available data, setting
                    exclusive locks on each row it reads. Thus, it sets the same
                    locks a searched SQL <a class="link" href="sql-syntax.html#update" title="13.2.11&nbsp;UPDATE Syntax"><code class="literal">UPDATE</code></a>
                    would set on the rows.
                </p><p style="color:blue;">选择…对于update，读取最新的可用数据，在读取的每一行上设置独占锁。因此，它设置的锁与搜索的sql更新在行上设置的锁相同。</p><p>
                    The preceding description is merely an example of how
                    <a class="link" href="sql-syntax.html#select" title="13.2.9&nbsp;SELECT Syntax"><code class="literal">SELECT ... FOR
                        UPDATE</code></a> works. In MySQL, the specific task of
                    generating a unique identifier actually can be accomplished
                    using only a single access to the table:
                </p><p style="color:blue;">前面的描述只是一个例子，说明如何选择…更新工作。在mysql中，生成唯一标识符的特定任务实际上可以只使用对表的一次访问来完成：</p><pre data-lang="sql" class="programlisting">UPDATE child_codes SET counter_field = LAST_INSERT_ID(counter_field + 1);
SELECT LAST_INSERT_ID();
</pre><p>
                    The <a class="link" href="sql-syntax.html#select" title="13.2.9&nbsp;SELECT Syntax"><code class="literal">SELECT</code></a> statement merely
                    retrieves the identifier information (specific to the current
                    connection). It does not access any table.
                </p><p style="color:blue;">select语句只检索标识符信息（特定于当前连接）。它不访问任何表。</p>
                </div>

            </div>

        </div>
        <div class="section">
            <div class="titlepage">
                <div>
                    <div>
                        <h3 class="title"><a name="innodb-locks-set"></a>14.7.3&nbsp;Locks Set by Different SQL Statements in InnoDB</h3>

                    </div>

                </div>

            </div>
            <a class="indexterm" name="idm140286821094496"></a><a class="indexterm" name="idm140286821093456"></a><p>
            A <a class="link" href="glossary.html#glos_locking_read" title="locking read">locking read</a>, an
            <a class="link" href="sql-syntax.html#update" title="13.2.11&nbsp;UPDATE Syntax"><code class="literal">UPDATE</code></a>, or a
            <a class="link" href="sql-syntax.html#delete" title="13.2.2&nbsp;DELETE Syntax"><code class="literal">DELETE</code></a> generally set record locks
            on every index record that is scanned in the processing of the SQL
            statement. It does not matter whether there are
            <code class="literal">WHERE</code> conditions in the statement that would
            exclude the row. <code class="literal">InnoDB</code> does not remember the
            exact <code class="literal">WHERE</code> condition, but only knows which
            index ranges were scanned. The locks are normally
            <a class="link" href="glossary.html#glos_next_key_lock" title="next-key lock">next-key locks</a> that also
            block inserts into the <span class="quote">“<span class="quote">gap</span>”</span> immediately before the
            record. However, <a class="link" href="glossary.html#glos_gap_lock" title="gap lock">gap locking</a>
            can be disabled explicitly, which causes next-key locking not to
            be used. For more information, see
            <a class="xref" href="innodb-storage-engine.html#innodb-locking" title="14.7.1&nbsp;InnoDB Locking">Section&nbsp;14.7.1, “InnoDB Locking”</a>. The transaction isolation level
            also can affect which locks are set; see
            <a class="xref" href="innodb-storage-engine.html#innodb-transaction-isolation-levels" title="14.7.2.1&nbsp;Transaction Isolation Levels">Section&nbsp;14.7.2.1, “Transaction Isolation Levels”</a>.
        </p><p style="color:blue;">锁定读取、更新或删除通常会在处理sql语句时扫描的每个索引记录上设置记录锁。语句中是否存在将排除该行的where条件并不重要。innodb不记得确切的位置条件，但只知道扫描了哪些索引范围。这些锁通常是下一个密钥锁，也会阻止在记录之前插入“gap”。但是，可以显式禁用间隙锁定，这将导致不使用下一个密钥锁定。有关更多信息，请参阅14.7.1节，“InnoDB锁定”。事务隔离级别还可以影响设置的锁；请参阅第14.7.2.1节“事务隔离级别”。</p><p>
            If a secondary index is used in a search and index record locks to
            be set are exclusive, <code class="literal">InnoDB</code> also retrieves the
            corresponding clustered index records and sets locks on them.
        </p><p style="color:blue;">如果在搜索中使用了二级索引，并且要设置的索引记录锁是互斥的，innodb还会检索相应的聚集索引记录并对其设置锁。</p><p>
            If you have no indexes suitable for your statement and MySQL must
            scan the entire table to process the statement, every row of the
            table becomes locked, which in turn blocks all inserts by other
            users to the table. It is important to create good indexes so that
            your queries do not unnecessarily scan many rows.
        </p><p style="color:blue;">如果没有适合于语句的索引，并且mysql必须扫描整个表才能处理该语句，则表的每一行都将被锁定，从而阻止其他用户对表的所有插入。创建好的索引很重要，这样查询就不会不必要地扫描许多行。</p><p>
            <code class="literal">InnoDB</code> sets specific types of locks as follows.
        </p><p style="color:blue;">innodb按如下方式设置特定类型的锁。</p>
            <div class="itemizedlist">
                <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                    <a class="link" href="sql-syntax.html#select" title="13.2.9&nbsp;SELECT Syntax"><code class="literal">SELECT ...
                        FROM</code></a> is a consistent read, reading a snapshot of the
                    database and setting no locks unless the transaction isolation
                    level is set to
                    <a class="link" href="innodb-storage-engine.html#isolevel_serializable"><code class="literal">SERIALIZABLE</code></a>. For
                    <a class="link" href="innodb-storage-engine.html#isolevel_serializable"><code class="literal">SERIALIZABLE</code></a> level, the
                    search sets shared next-key locks on the index records it
                    encounters. However, only an index record lock is required for
                    statements that lock rows using a unique index to search for a
                    unique row.
                </p><p style="color:blue;">选择…from是一致读取，读取数据库的快照并且不设置锁，除非事务隔离级别设置为可序列化。对于可序列化级别，搜索会在遇到的索引记录上设置共享的下一个密钥锁。但是，对于使用唯一索引锁定行以搜索唯一行的语句，只需要索引记录锁。</p></li><li class="listitem"><p>
                    For <a class="link" href="sql-syntax.html#select" title="13.2.9&nbsp;SELECT Syntax"><code class="literal">SELECT ... FOR
                    UPDATE</code></a> or
                    <a class="link" href="sql-syntax.html#select" title="13.2.9&nbsp;SELECT Syntax"><code class="literal">SELECT ... LOCK IN
                        SHARE MODE</code></a>, locks are acquired for scanned rows, and
                    expected to be released for rows that do not qualify for
                    inclusion in the result set (for example, if they do not meet
                    the criteria given in the <code class="literal">WHERE</code> clause).
                    However, in some cases, rows might not be unlocked immediately
                    because the relationship between a result row and its original
                    source is lost during query execution. For example, in a
                    <a class="link" href="sql-syntax.html#union" title="13.2.9.3&nbsp;UNION Syntax"><code class="literal">UNION</code></a>, scanned (and locked)
                    rows from a table might be inserted into a temporary table
                    before evaluation whether they qualify for the result set. In
                    this circumstance, the relationship of the rows in the
                    temporary table to the rows in the original table is lost and
                    the latter rows are not unlocked until the end of query
                    execution.
                </p><p style="color:blue;">选择…更新或选择…锁定在共享模式下，对扫描的行获取锁，对于不符合结果集中包含条件的行（例如，如果它们不符合where子句中给定的条件），则应释放锁。但是，在某些情况下，行可能不会立即解除锁定，因为结果行与其原始源之间的关系在查询执行期间丢失。例如，在联合中，在评估表中的扫描（和锁定）行是否符合结果集之前，可能会将它们插入到临时表中。在这种情况下，临时表中的行与原始表中的行之间的关系将丢失，并且直到查询执行结束后才会解除锁定后一行。</p></li><li class="listitem"><p>
                    <a class="link" href="sql-syntax.html#select" title="13.2.9&nbsp;SELECT Syntax"><code class="literal">SELECT ... LOCK IN
                        SHARE MODE</code></a> sets shared next-key locks on all index
                    records the search encounters. However, only an index record
                    lock is required for statements that lock rows using a unique
                    index to search for a unique row.
                </p><p style="color:blue;">选择…在共享模式下锁定将在搜索遇到的所有索引记录上设置共享的下一个密钥锁定。但是，对于使用唯一索引锁定行以搜索唯一行的语句，只需要索引记录锁。</p></li><li class="listitem"><p>
                    <a class="link" href="sql-syntax.html#select" title="13.2.9&nbsp;SELECT Syntax"><code class="literal">SELECT ... FOR
                        UPDATE</code></a> sets an exclusive next-key lock on every
                    record the search encounters. However, only an index record
                    lock is required for statements that lock rows using a unique
                    index to search for a unique row.
                </p><p style="color:blue;">选择…for update在搜索遇到的每个记录上设置一个独占的next键锁。但是，对于使用唯一索引锁定行以搜索唯一行的语句，只需要索引记录锁。</p><p>
                    For index records the search encounters,
                    <a class="link" href="sql-syntax.html#select" title="13.2.9&nbsp;SELECT Syntax"><code class="literal">SELECT ... FOR
                        UPDATE</code></a> blocks other sessions from doing
                    <a class="link" href="sql-syntax.html#select" title="13.2.9&nbsp;SELECT Syntax"><code class="literal">SELECT ... LOCK IN
                        SHARE MODE</code></a> or from reading in certain transaction
                    isolation levels. Consistent reads ignore any locks set on the
                    records that exist in the read view.
                </p><p style="color:blue;">对于搜索遇到的索引记录，请选择…对于更新阻止其他会话执行选择…在共享模式下锁定或在某些事务隔离级别下读取。一致读取忽略在读取视图中存在的记录上设置的任何锁。</p></li><li class="listitem"><p>
                    <a class="link" href="sql-syntax.html#update" title="13.2.11&nbsp;UPDATE Syntax"><code class="literal">UPDATE ... WHERE
                        ...</code></a> sets an exclusive next-key lock on every record
                    the search encounters. However, only an index record lock is
                    required for statements that lock rows using a unique index to
                    search for a unique row.
                </p><p style="color:blue;">更新。。。在哪里？在搜索遇到的每个记录上设置独占的下一个密钥锁。但是，对于使用唯一索引锁定行以搜索唯一行的语句，只需要索引记录锁。</p></li><li class="listitem"><p>
                    When <a class="link" href="sql-syntax.html#update" title="13.2.11&nbsp;UPDATE Syntax"><code class="literal">UPDATE</code></a> modifies a
                    clustered index record, implicit locks are taken on affected
                    secondary index records. The
                    <a class="link" href="sql-syntax.html#update" title="13.2.11&nbsp;UPDATE Syntax"><code class="literal">UPDATE</code></a> operation also takes
                    shared locks on affected secondary index records when
                    performing duplicate check scans prior to inserting new
                    secondary index records, and when inserting new secondary
                    index records.
                </p><p style="color:blue;">更新修改聚集索引记录时，会对受影响的辅助索引记录进行隐式锁定。在插入新的辅助索引记录之前执行重复检查扫描以及插入新的辅助索引记录时，更新操作还对受影响的辅助索引记录使用共享锁。</p></li><li class="listitem"><p>
                    <a class="link" href="sql-syntax.html#delete" title="13.2.2&nbsp;DELETE Syntax"><code class="literal">DELETE FROM ... WHERE
                        ...</code></a> sets an exclusive next-key lock on every record
                    the search encounters. However, only an index record lock is
                    required for statements that lock rows using a unique index to
                    search for a unique row.
                </p><p style="color:blue;">从中删除…在哪里？在搜索遇到的每个记录上设置独占的下一个密钥锁。但是，对于使用唯一索引锁定行以搜索唯一行的语句，只需要索引记录锁。</p></li><li class="listitem"><p>
                    <a class="link" href="sql-syntax.html#insert" title="13.2.5&nbsp;INSERT Syntax"><code class="literal">INSERT</code></a> sets an exclusive lock
                    on the inserted row. This lock is an index-record lock, not a
                    next-key lock (that is, there is no gap lock) and does not
                    prevent other sessions from inserting into the gap before the
                    inserted row.
                </p><p style="color:blue;">insert在插入的行上设置独占锁。此锁是索引记录锁，而不是下一个密钥锁（即没有间隙锁），并且不会阻止其他会话插入插入行之前的间隙中。</p><p>
                    Prior to inserting the row, a type of gap lock called an
                    insert intention gap lock is set. This lock signals the intent
                    to insert in such a way that multiple transactions inserting
                    into the same index gap need not wait for each other if they
                    are not inserting at the same position within the gap. Suppose
                    that there are index records with values of 4 and 7. Separate
                    transactions that attempt to insert values of 5 and 6 each
                    lock the gap between 4 and 7 with insert intention locks prior
                    to obtaining the exclusive lock on the inserted row, but do
                    not block each other because the rows are nonconflicting.
                </p><p style="color:blue;">在插入行之前，将设置一种称为插入意图间隙锁的间隙锁。此锁表示插入的意图，这样，如果插入到同一索引间隙中的多个事务没有在间隙中的同一位置插入，那么它们就不必彼此等待。假设存在值为4和7的索引记录。尝试在插入行上插入5和6的值的单独事务在获得独占锁之前使用插入意图锁锁定4和7之间的间隔，但不要因为行是非冲突的而相互阻塞。</p><p>
                    If a duplicate-key error occurs, a shared lock on the
                    duplicate index record is set. This use of a shared lock can
                    result in deadlock should there be multiple sessions trying to
                    insert the same row if another session already has an
                    exclusive lock. This can occur if another session deletes the
                    row. Suppose that an <code class="literal">InnoDB</code> table
                    <code class="literal">t1</code> has the following structure:
                </p><p style="color:blue;">如果发生重复键错误，则在重复索引记录上设置共享锁。如果有多个会话试图插入同一行（如果另一个会话已具有独占锁），则使用共享锁可能导致死锁。如果另一个会话删除行，则可能发生这种情况。假设innodb表t1具有以下结构：</p><pre data-lang="sql" class="programlisting">CREATE TABLE t1 (i INT, PRIMARY KEY (i)) ENGINE = InnoDB;
</pre><p>
                    Now suppose that three sessions perform the following
                    operations in order:
                </p><p style="color:blue;">现在假设三个会话按顺序执行以下操作：</p><p>
                    Session 1:
                </p><p style="color:blue;">会议1：</p><pre data-lang="sql" class="programlisting">START TRANSACTION;
INSERT INTO t1 VALUES(1);
</pre><p>
                    Session 2:
                </p><p style="color:blue;">会议2：</p><pre data-lang="sql" class="programlisting">START TRANSACTION;
INSERT INTO t1 VALUES(1);
</pre><p>
                    Session 3:
                </p><p style="color:blue;">第3课时：</p><pre data-lang="sql" class="programlisting">START TRANSACTION;
INSERT INTO t1 VALUES(1);
</pre><p>
                    Session 1:
                </p><p style="color:blue;">会议1：</p><pre data-lang="sql" class="programlisting">ROLLBACK;
</pre><p>
                    The first operation by session 1 acquires an exclusive lock
                    for the row. The operations by sessions 2 and 3 both result in
                    a duplicate-key error and they both request a shared lock for
                    the row. When session 1 rolls back, it releases its exclusive
                    lock on the row and the queued shared lock requests for
                    sessions 2 and 3 are granted. At this point, sessions 2 and 3
                    deadlock: Neither can acquire an exclusive lock for the row
                    because of the shared lock held by the other.
                </p><p style="color:blue;">会话1的第一个操作获取行的独占锁。会话2和3的操作都会导致重复的密钥错误，它们都会请求行的共享锁。当会话1回滚时，它将释放行上的独占锁，并授予会话2和3的排队共享锁请求。此时，会话2和3死锁：两个会话都无法获取行的独占锁，因为另一个会话持有共享锁。</p><p>
                    A similar situation occurs if the table already contains a row
                    with key value 1 and three sessions perform the following
                    operations in order:
                </p><p style="color:blue;">如果表已包含键值为1的行，并且三个会话按顺序执行以下操作，则会出现类似的情况：</p><p>
                    Session 1:
                </p><p style="color:blue;">会议1：</p><pre data-lang="sql" class="programlisting">START TRANSACTION;
DELETE FROM t1 WHERE i = 1;
</pre><p>
                    Session 2:
                </p><p style="color:blue;">会议2：</p><pre data-lang="sql" class="programlisting">START TRANSACTION;
INSERT INTO t1 VALUES(1);
</pre><p>
                    Session 3:
                </p><p style="color:blue;">第3课时：</p><pre data-lang="sql" class="programlisting">START TRANSACTION;
INSERT INTO t1 VALUES(1);
</pre><p>
                    Session 1:
                </p><p style="color:blue;">会议1：</p><pre data-lang="sql" class="programlisting">COMMIT;
</pre><p>
                    The first operation by session 1 acquires an exclusive lock
                    for the row. The operations by sessions 2 and 3 both result in
                    a duplicate-key error and they both request a shared lock for
                    the row. When session 1 commits, it releases its exclusive
                    lock on the row and the queued shared lock requests for
                    sessions 2 and 3 are granted. At this point, sessions 2 and 3
                    deadlock: Neither can acquire an exclusive lock for the row
                    because of the shared lock held by the other.
                </p><p style="color:blue;">会话1的第一个操作获取行的独占锁。会话2和3的操作都会导致重复的密钥错误，它们都会请求行的共享锁。当会话1提交时，它会释放行上的排他锁，并授予会话2和3的排队共享锁请求。此时，会话2和3死锁：两个会话都无法获取行的独占锁，因为另一个会话持有共享锁。</p></li><li class="listitem"><p>
                    <a class="link" href="sql-syntax.html#insert-on-duplicate" title="13.2.5.2&nbsp;INSERT ... ON DUPLICATE KEY UPDATE Syntax"><code class="literal">INSERT
                        ... ON DUPLICATE KEY UPDATE</code></a> differs from a simple
                    <a class="link" href="sql-syntax.html#insert" title="13.2.5&nbsp;INSERT Syntax"><code class="literal">INSERT</code></a> in that an exclusive
                    lock rather than a shared lock is placed on the row to be
                    updated when a duplicate-key error occurs. An exclusive
                    index-record lock is taken for a duplicate primary key value.
                    An exclusive next-key lock is taken for a duplicate unique key
                    value.
                </p><p style="color:blue;">插入…重复密钥更新与简单插入的不同之处在于，当发生重复密钥错误时，将在要更新的行上放置排他锁而不是共享锁。对重复的主键值使用独占索引记录锁。对重复的唯一密钥值使用独占的下一个密钥锁。</p></li><li class="listitem"><p>
                    <a class="link" href="sql-syntax.html#replace" title="13.2.8&nbsp;REPLACE Syntax"><code class="literal">REPLACE</code></a> is done like an
                    <a class="link" href="sql-syntax.html#insert" title="13.2.5&nbsp;INSERT Syntax"><code class="literal">INSERT</code></a> if there is no collision
                    on a unique key. Otherwise, an exclusive next-key lock is
                    placed on the row to be replaced.
                </p><p style="color:blue;">如果唯一键上没有冲突，则替换的操作与插入操作类似。否则，将在要替换的行上放置独占的下一个密钥锁。</p></li><li class="listitem"><p>
                    <code class="literal">INSERT INTO T SELECT ... FROM S WHERE ...</code>
                    sets an exclusive index record lock (without a gap lock) on
                    each row inserted into <code class="literal">T</code>. If the
                    transaction isolation level is <a class="link" href="innodb-storage-engine.html#isolevel_read-committed"><code class="literal">READ
                    COMMITTED</code></a>, or
                    <a class="link" href="innodb-storage-engine.html#sysvar_innodb_locks_unsafe_for_binlog"><code class="literal">innodb_locks_unsafe_for_binlog</code></a>
                    is enabled and the transaction isolation level is not
                    <a class="link" href="innodb-storage-engine.html#isolevel_serializable"><code class="literal">SERIALIZABLE</code></a>,
                    <code class="literal">InnoDB</code> does the search on
                    <code class="literal">S</code> as a consistent read (no locks).
                    Otherwise, <code class="literal">InnoDB</code> sets shared next-key
                    locks on rows from <code class="literal">S</code>.
                    <code class="literal">InnoDB</code> has to set locks in the latter case:
                    During roll-forward recovery using a statement-based binary
                    log, every SQL statement must be executed in exactly the same
                    way it was done originally.
                </p><p style="color:blue;">插入到T选择…从哪里…在插入t的每一行上设置一个排他索引记录锁（不带间隙锁）。如果事务隔离级别是read committed，或者innodb lock s unsafe for binlog是enabled，并且事务隔离级别不是serializable，innodb将在s上搜索作为一致读取（没有锁）。否则，innodb会在s的行上设置共享的next键锁。innodb必须在后一种情况下设置锁：在使用基于语句的二进制日志进行前滚恢复期间，每个sql语句必须以与最初完全相同的方式执行。</p><p>
                    <a class="link" href="sql-syntax.html#create-table" title="13.1.18&nbsp;CREATE TABLE Syntax"><code class="literal">CREATE TABLE ...
                        SELECT ...</code></a> performs the
                    <a class="link" href="sql-syntax.html#select" title="13.2.9&nbsp;SELECT Syntax"><code class="literal">SELECT</code></a> with shared next-key
                    locks or as a consistent read, as for
                    <a class="link" href="sql-syntax.html#insert-select" title="13.2.5.1&nbsp;INSERT ... SELECT Syntax"><code class="literal">INSERT ...
                        SELECT</code></a>.
                </p><p style="color:blue;">创建表…选择…使用共享的下一个密钥锁执行选择，或者作为一致读取执行选择，例如插入…选择。</p><p>
                    When a <code class="literal">SELECT</code> is used in the constructs
                    <code class="literal">REPLACE INTO t SELECT ... FROM s WHERE ...</code>
                    or <code class="literal">UPDATE t ... WHERE col IN (SELECT ... FROM s
                    ...)</code>, <code class="literal">InnoDB</code> sets shared next-key
                    locks on rows from table <code class="literal">s</code>.
                </p><p style="color:blue;">当在构造中使用select替换为t select时…从哪里…或者更新t…列在哪里（选择…从s…，innodb在表s的行上设置共享的next键锁。</p></li><li class="listitem"><p>
                    While initializing a previously specified
                    <code class="literal">AUTO_INCREMENT</code> column on a table,
                    <code class="literal">InnoDB</code> sets an exclusive lock on the end of
                    the index associated with the
                    <code class="literal">AUTO_INCREMENT</code> column. In accessing the
                    auto-increment counter, <code class="literal">InnoDB</code> uses a
                    specific <code class="literal">AUTO-INC</code> table lock mode where the
                    lock lasts only to the end of the current SQL statement, not
                    to the end of the entire transaction. Other sessions cannot
                    insert into the table while the <code class="literal">AUTO-INC</code>
                    table lock is held; see
                    <a class="xref" href="innodb-storage-engine.html#innodb-transaction-model" title="14.7.2&nbsp;InnoDB Transaction Model">Section&nbsp;14.7.2, “InnoDB Transaction Model”</a>.
                </p><p style="color:blue;">初始化表上先前指定的auto_increment列时，innodb在与auto_increment列关联的索引末尾设置一个独占锁。在访问自动递增计数器时，innodb使用一种特定的auto-inc表锁模式，其中锁只持续到当前sql语句的结尾，而不是整个事务的结尾。持有auto-inc表锁时，其他会话无法插入到表中；请参阅14.7.2节，“InnoDB事务模型”。</p><p>
                    <code class="literal">InnoDB</code> fetches the value of a previously
                    initialized <code class="literal">AUTO_INCREMENT</code> column without
                    setting any locks.
                </p><p style="color:blue;">innodb在不设置任何锁的情况下获取先前初始化的auto_increment列的值。</p></li><li class="listitem"><p>
                    If a <code class="literal">FOREIGN KEY</code> constraint is defined on a
                    table, any insert, update, or delete that requires the
                    constraint condition to be checked sets shared record-level
                    locks on the records that it looks at to check the constraint.
                    <code class="literal">InnoDB</code> also sets these locks in the case
                    where the constraint fails.
                </p><p style="color:blue;">如果在表上定义了外键约束，则任何需要检查约束条件的插入、更新或删除操作都会对检查该约束所查看的记录设置共享记录级锁。innodb还会在约束失败的情况下设置这些锁。</p></li><li class="listitem"><p>
                    <a class="link" href="sql-syntax.html#lock-tables" title="13.3.5&nbsp;LOCK TABLES and UNLOCK TABLES Syntax"><code class="literal">LOCK TABLES</code></a> sets table locks,
                    but it is the higher MySQL layer above the
                    <code class="literal">InnoDB</code> layer that sets these locks.
                    <code class="literal">InnoDB</code> is aware of table locks if
                    <code class="literal">innodb_table_locks = 1</code> (the default) and
                    <a class="link" href="server-administration.html#sysvar_autocommit"><code class="literal">autocommit = 0</code></a>, and the MySQL
                    layer above <code class="literal">InnoDB</code> knows about row-level
                    locks.
                </p><p style="color:blue;">lock tables设置表锁，但设置这些锁的是innodb层之上更高的mysql层。如果innodb_table_locks=1（默认值）和autocommit=0，innodb知道表锁，并且innodb上面的mysql层知道行级锁。</p><p>
                    Otherwise, <code class="literal">InnoDB</code>'s automatic deadlock
                    detection cannot detect deadlocks where such table locks are
                    involved. Also, because in this case the higher MySQL layer
                    does not know about row-level locks, it is possible to get a
                    table lock on a table where another session currently has
                    row-level locks. However, this does not endanger transaction
                    integrity, as discussed in
                    <a class="xref" href="innodb-storage-engine.html#innodb-deadlock-detection" title="14.7.5.2&nbsp;Deadlock Detection and Rollback">Section&nbsp;14.7.5.2, “Deadlock Detection and Rollback”</a>. See also
                    <a class="xref" href="innodb-storage-engine.html#innodb-restrictions" title="14.6.1.6&nbsp;Limits on InnoDB Tables">Section&nbsp;14.6.1.6, “Limits on InnoDB Tables”</a>.
                </p><p style="color:blue;">否则，innodb的自动死锁检测无法检测到涉及此类表锁的死锁。另外，因为在这种情况下，较高的mysql层不知道行级锁，所以可以在另一个会话当前具有行级锁的表上获取表锁。但是，这不会危及事务完整性，如第14.7.5.2节“死锁检测和回滚”所述。另见第14.6.1.6节“InnoDB表的限制”。</p></li></ul>
            </div>

        </div>
        <div class="section">
            <div class="titlepage">
                <div>
                    <div>
                        <h3 class="title"><a name="innodb-next-key-locking"></a>14.7.4&nbsp;Phantom Rows</h3>

                    </div>

                </div>

            </div>
            <a class="indexterm" name="idm140286820984336"></a><a class="indexterm" name="idm140286820983264"></a><a class="indexterm" name="idm140286820981776"></a><a class="indexterm" name="idm140286820980288"></a><a class="indexterm" name="idm140286820978800"></a><a class="indexterm" name="idm140286820977312"></a><a class="indexterm" name="idm140286820975824"></a><a class="indexterm" name="idm140286820974336"></a><a class="indexterm" name="idm140286820972848"></a><p>
            The so-called <span class="firstterm">phantom</span>
            problem occurs within a transaction when the same query produces
            different sets of rows at different times. For example, if a
            <a class="link" href="sql-syntax.html#select" title="13.2.9&nbsp;SELECT Syntax"><code class="literal">SELECT</code></a> is executed twice, but
            returns a row the second time that was not returned the first
            time, the row is a <span class="quote">“<span class="quote">phantom</span>”</span> row.
        </p><p style="color:blue;">当同一个查询在不同时间生成不同的行集时，事务中就会出现所谓的幻象问题。例如，如果select执行两次，但第二次返回的行不是第一次返回的行，则该行是“幻影”行。</p><p>
            Suppose that there is an index on the <code class="literal">id</code> column
            of the <code class="literal">child</code> table and that you want to read
            and lock all rows from the table having an identifier value larger
            than 100, with the intention of updating some column in the
            selected rows later:
        </p><p style="color:blue;">假设子表的id列上有一个索引，并且您希望读取并锁定表中标识符值大于100的所有行，以便稍后更新选定行中的某些列：</p><pre data-lang="sql" class="programlisting">SELECT * FROM child WHERE id &gt; 100 FOR UPDATE;
</pre><p>
            The query scans the index starting from the first record where
            <code class="literal">id</code> is bigger than 100. Let the table contain
            rows having <code class="literal">id</code> values of 90 and 102. If the
            locks set on the index records in the scanned range do not lock
            out inserts made in the gaps (in this case, the gap between 90 and
            102), another session can insert a new row into the table with an
            <code class="literal">id</code> of 101. If you were to execute the same
            <a class="link" href="sql-syntax.html#select" title="13.2.9&nbsp;SELECT Syntax"><code class="literal">SELECT</code></a> within the same transaction,
            you would see a new row with an <code class="literal">id</code> of 101 (a
            <span class="quote">“<span class="quote">phantom</span>”</span>) in the result set returned by the query.
            If we regard a set of rows as a data item, the new phantom child
            would violate the isolation principle of transactions that a
            transaction should be able to run so that the data it has read
            does not change during the transaction.
        </p><p style="color:blue;">查询从id大于100的第一条记录开始扫描索引。让表包含id值为90和102的行。如果在扫描范围内的索引记录上设置的锁没有锁定间隙中的插入（在本例中，间隙在90和102之间），则另一个会话可以将ID为101的新行插入表中。如果要在同一个事务中执行同一个select，您将在查询返回的结果集中看到一个id为101的新行（“幻影”）。如果我们将一组行视为一个数据项，那么新的幻像子项将违反事务的隔离原则，即事务应该能够运行，以便它读取的数据在事务期间不会更改。</p><p>
            To prevent phantoms, <code class="literal">InnoDB</code> uses an algorithm
            called <span class="firstterm">next-key locking</span> that
            combines index-row locking with gap locking.
            <code class="literal">InnoDB</code> performs row-level locking in such a way
            that when it searches or scans a table index, it sets shared or
            exclusive locks on the index records it encounters. Thus, the
            row-level locks are actually index-record locks. In addition, a
            next-key lock on an index record also affects the
            <span class="quote">“<span class="quote">gap</span>”</span> before that index record. That is, a next-key
            lock is an index-record lock plus a gap lock on the gap preceding
            the index record. If one session has a shared or exclusive lock on
            record <code class="literal">R</code> in an index, another session cannot
            insert a new index record in the gap immediately before
            <code class="literal">R</code> in the index order.
        </p><p style="color:blue;">为了防止出现幻象，innodb使用了一种称为next key locking的算法，该算法将索引行锁定和间隙锁定结合起来。InnoDB执行行级锁定的方式是，当它搜索或扫描表索引时，它会在遇到的索引记录上设置共享锁或独占锁。因此，行级锁实际上是索引记录锁。此外，索引记录上的下一个键锁也会影响该索引记录之前的“间隙”。也就是说，下一个密钥锁是索引记录锁加上索引记录前面的间隙上的间隙锁。如果一个会话对索引中的记录r具有共享或独占锁，则另一个会话不能按索引顺序在r前面的间隙中插入新的索引记录。</p><p>
            When <code class="literal">InnoDB</code> scans an index, it can also lock
            the gap after the last record in the index. Just that happens in
            the preceding example: To prevent any insert into the table where
            <code class="literal">id</code> would be bigger than 100, the locks set by
            <code class="literal">InnoDB</code> include a lock on the gap following
            <code class="literal">id</code> value 102.
        </p><p style="color:blue;">当innodb扫描索引时，它还可以锁定索引中最后一条记录之后的间隙。前面的例子就是这样：为了防止在id大于100的表中插入任何内容，innodb设置的锁在id值102后面的间隙上包含一个锁。</p><p>
            You can use next-key locking to implement a uniqueness check in
            your application: If you read your data in share mode and do not
            see a duplicate for a row you are going to insert, then you can
            safely insert your row and know that the next-key lock set on the
            successor of your row during the read prevents anyone meanwhile
            inserting a duplicate for your row. Thus, the next-key locking
            enables you to <span class="quote">“<span class="quote">lock</span>”</span> the nonexistence of something
            in your table.
        </p><p style="color:blue;">您可以使用next key locking在应用程序中实现唯一性检查：如果您在共享模式下读取数据，并且没有看到要插入的行的重复项，那么您可以安全地插入行，并知道在读取期间，在行的后续行上设置的next key lock防止任何人同时插入你的排。因此，下一个键锁定使您能够“锁定”表中不存在的东西。</p><p>
            Gap locking can be disabled as discussed in
            <a class="xref" href="innodb-storage-engine.html#innodb-locking" title="14.7.1&nbsp;InnoDB Locking">Section&nbsp;14.7.1, “InnoDB Locking”</a>. This may cause phantom problems
            because other sessions can insert new rows into the gaps when gap
            locking is disabled.
        </p><p style="color:blue;">如第14.7.1节“InnoDB锁定”所述，可以禁用间隙锁定。这可能会导致幻象问题，因为当禁用间隙锁定时，其他会话可以在间隙中插入新行。</p>
        </div>
        <div class="section">
            <div class="titlepage">
                <div>
                    <div>
                        <h3 class="title"><a name="innodb-deadlocks"></a>14.7.5&nbsp;Deadlocks in InnoDB</h3>

                    </div>

                </div>

            </div>
            <div class="toc">
                <dl class="toc"><dt><span class="section"><a href="innodb-storage-engine.html#innodb-deadlock-example">14.7.5.1 An InnoDB Deadlock Example</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-deadlock-detection">14.7.5.2 Deadlock Detection and Rollback</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-deadlocks-handling">14.7.5.3 How to Minimize and Handle Deadlocks</a></span></dt></dl>
            </div>
            <a class="indexterm" name="idm140286820947376"></a><a class="indexterm" name="idm140286820945888"></a><a class="indexterm" name="idm140286820943984"></a><a class="indexterm" name="idm140286820942496"></a><p>
            A deadlock is a situation where different transactions are unable
            to proceed because each holds a lock that the other needs. Because
            both transactions are waiting for a resource to become available,
            neither ever release the locks it holds.
        </p><p style="color:blue;">死锁是一种不同的事务无法进行的情况，因为每个事务都持有对方需要的锁。因为这两个事务都在等待资源变得可用，所以它们都不会释放它所持有的锁。</p><p>
            A deadlock can occur when transactions lock rows in multiple
            tables (through statements such as
            <a class="link" href="sql-syntax.html#update" title="13.2.11&nbsp;UPDATE Syntax"><code class="literal">UPDATE</code></a> or
            <a class="link" href="sql-syntax.html#select" title="13.2.9&nbsp;SELECT Syntax"><code class="literal">SELECT ... FOR
                UPDATE</code></a>), but in the opposite order. A deadlock can also
            occur when such statements lock ranges of index records and gaps,
            with each transaction acquiring some locks but not others due to a
            timing issue. For a deadlock example, see
            <a class="xref" href="innodb-storage-engine.html#innodb-deadlock-example" title="14.7.5.1&nbsp;An InnoDB Deadlock Example">Section&nbsp;14.7.5.1, “An InnoDB Deadlock Example”</a>.
        </p><p style="color:blue;">当事务锁定多个表中的行（通过update或select等语句）时，可能会发生死锁。但顺序相反。当这样的语句锁定索引记录和间隙的范围时，也会发生死锁，每个事务都会获取一些锁，而不是由于时间问题而获取其他锁。有关死锁示例，请参阅第14.7.5.1节“InnoDB死锁示例”。</p><p>
            To reduce the possibility of deadlocks, use transactions rather
            than <a class="link" href="sql-syntax.html#lock-tables" title="13.3.5&nbsp;LOCK TABLES and UNLOCK TABLES Syntax"><code class="literal">LOCK TABLES</code></a> statements; keep
            transactions that insert or update data small enough that they do
            not stay open for long periods of time; when different
            transactions update multiple tables or large ranges of rows, use
            the same order of operations (such as
            <a class="link" href="sql-syntax.html#select" title="13.2.9&nbsp;SELECT Syntax"><code class="literal">SELECT ... FOR
                UPDATE</code></a>) in each transaction; create indexes on the
            columns used in <a class="link" href="sql-syntax.html#select" title="13.2.9&nbsp;SELECT Syntax"><code class="literal">SELECT ...
            FOR UPDATE</code></a> and
            <a class="link" href="sql-syntax.html#update" title="13.2.11&nbsp;UPDATE Syntax"><code class="literal">UPDATE ... WHERE</code></a>
            statements. The possibility of deadlocks is not affected by the
            isolation level, because the isolation level changes the behavior
            of read operations, while deadlocks occur because of write
            operations. For more information about avoiding and recovering
            from deadlock conditions, see
            <a class="xref" href="innodb-storage-engine.html#innodb-deadlocks-handling" title="14.7.5.3&nbsp;How to Minimize and Handle Deadlocks">Section&nbsp;14.7.5.3, “How to Minimize and Handle Deadlocks”</a>.
        </p><p style="color:blue;">要减少死锁的可能性，请使用事务而不是锁表语句；使插入或更新数据的事务足够小，使其不会长时间保持打开状态；当不同的事务更新多个表或大范围的行时，请使用相同的操作顺序（如选择…在每个事务中；在select中使用的列上创建索引…更新和更新…where语句。死锁的可能性不受隔离级别的影响，因为隔离级别改变了读操作的行为，而死锁是由于写操作而产生的。有关避免死锁和从死锁状态中恢复的详细信息，请参阅第14.7.5.3节“如何最小化和处理死锁”。</p><p>
            When deadlock detection is enabled (the default) and a deadlock
            does occur, <code class="literal">InnoDB</code> detects the condition and
            rolls back one of the transactions (the victim). If deadlock
            detection is disabled using the
            <a class="link" href="innodb-storage-engine.html#sysvar_innodb_deadlock_detect"><code class="literal">innodb_deadlock_detect</code></a>
            configuration option, <code class="literal">InnoDB</code> relies on the
            <a class="link" href="innodb-storage-engine.html#sysvar_innodb_lock_wait_timeout"><code class="literal">innodb_lock_wait_timeout</code></a> setting
            to roll back transactions in case of a deadlock. Thus, even if
            your application logic is correct, you must still handle the case
            where a transaction must be retried. To see the last deadlock in
            an <code class="literal">InnoDB</code> user transaction, use the
            <a class="link" href="sql-syntax.html#show-engine" title="13.7.5.15&nbsp;SHOW ENGINE Syntax"><code class="literal">SHOW ENGINE INNODB
                STATUS</code></a> command. If frequent deadlocks highlight a
            problem with transaction structure or application error handling,
            run with the
            <a class="link" href="innodb-storage-engine.html#sysvar_innodb_print_all_deadlocks"><code class="literal">innodb_print_all_deadlocks</code></a>
            setting enabled to print information about all deadlocks to the
            <a class="link" href="programs.html#mysqld" title="4.3.1&nbsp;mysqld — The MySQL Server"><span class="command"><strong>mysqld</strong></span></a> error log. For more information about
            how deadlocks are automatically detected and handled, see
            <a class="xref" href="innodb-storage-engine.html#innodb-deadlock-detection" title="14.7.5.2&nbsp;Deadlock Detection and Rollback">Section&nbsp;14.7.5.2, “Deadlock Detection and Rollback”</a>.
        </p><p style="color:blue;">当死锁检测被启用（默认）并且死锁确实发生时，innodb会检测到该情况并回滚其中一个事务（受害者）。如果使用innodb_deadlock_detect配置选项禁用死锁检测，innodb将依赖innodb_lock_wait_timeout设置在死锁情况下回滚事务。因此，即使应用程序逻辑正确，也必须处理必须重试事务的情况。要查看innodb用户事务中的最后一个死锁，请使用show engine innodb status命令。如果频繁死锁突出显示事务结构或应用程序错误处理的问题，请在启用innodb_print_all_deadlocks设置的情况下运行，以便将所有死锁的信息打印到mysqld错误日志中。有关如何自动检测和处理死锁的详细信息，请参阅第14.7.5.2节“死锁检测和回滚”。</p>
            <div class="section">

                <div class="titlepage">
                    <div>
                        <div>
                            <h4 class="title"><a name="innodb-deadlock-example"></a>14.7.5.1&nbsp;An InnoDB Deadlock Example</h4>
                        </div>
                    </div>
                </div>
                <a class="indexterm" name="idm140286820918256"></a><a class="indexterm" name="idm140286820916800"></a><p>
                The following example illustrates how an error can occur when a
                lock request would cause a deadlock. The example involves two
                clients, A and B.
            </p><p style="color:blue;">下面的示例演示了当锁请求将导致死锁时如何发生错误。这个例子涉及两个客户，A和B。</p><p>
                First, client A creates a table containing one row, and then
                begins a transaction. Within the transaction, A obtains an
                <code class="literal">S</code> lock on the row by selecting it in share
                mode:
            </p><p style="color:blue;">首先，客户机A创建一个包含一行的表，然后开始一个事务。在事务中，A通过在共享模式下选择行来获取对该行的S锁：</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>CREATE TABLE t (i INT) ENGINE = InnoDB;</code></strong>
Query OK, 0 rows affected (1.07 sec)

mysql&gt; <strong class="userinput"><code>INSERT INTO t (i) VALUES(1);</code></strong>
Query OK, 1 row affected (0.09 sec)

mysql&gt; <strong class="userinput"><code>START TRANSACTION;</code></strong>
Query OK, 0 rows affected (0.00 sec)

mysql&gt; <strong class="userinput"><code>SELECT * FROM t WHERE i = 1 LOCK IN SHARE MODE;</code></strong>
+------+
| i    |
+------+
|    1 |
+------+
</pre><p>
                Next, client B begins a transaction and attempts to delete the
                row from the table:
            </p><p style="color:blue;">接下来，客户机B开始一个事务并尝试从表中删除该行：</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>START TRANSACTION;</code></strong>
Query OK, 0 rows affected (0.00 sec)

mysql&gt; <strong class="userinput"><code>DELETE FROM t WHERE i = 1;</code></strong>
</pre><p>
                The delete operation requires an <code class="literal">X</code> lock. The
                lock cannot be granted because it is incompatible with the
                <code class="literal">S</code> lock that client A holds, so the request
                goes on the queue of lock requests for the row and client B
                blocks.
            </p><p style="color:blue;">删除操作需要X锁。无法授予该锁，因为它与客户端A持有的S锁不兼容，因此请求将进入行和客户端B块的锁请求队列。</p><p>
                Finally, client A also attempts to delete the row from the
                table:
            </p><p style="color:blue;">最后，客户机A还尝试从表中删除行：</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>DELETE FROM t WHERE i = 1;</code></strong>
ERROR 1213 (40001): Deadlock found when trying to get lock;
try restarting transaction
</pre><p>
                Deadlock occurs here because client A needs an
                <code class="literal">X</code> lock to delete the row. However, that lock
                request cannot be granted because client B already has a request
                for an <code class="literal">X</code> lock and is waiting for client A to
                release its <code class="literal">S</code> lock. Nor can the
                <code class="literal">S</code> lock held by A be upgraded to an
                <code class="literal">X</code> lock because of the prior request by B for
                an <code class="literal">X</code> lock. As a result,
                <code class="literal">InnoDB</code> generates an error for one of the
                clients and releases its locks. The client returns this error:
            </p><p style="color:blue;">此处发生死锁，因为客户端A需要X锁来删除行。但是，无法授予该锁请求，因为客户端B已经有一个X锁请求，并且正在等待客户端A释放其S锁。也不能因为B先前请求X锁而将A持有的S锁升级为X锁。结果，innodb为其中一个客户机生成一个错误并释放其锁。客户端返回此错误：</p><pre data-lang="sql" class="programlisting">ERROR 1213 (40001): Deadlock found when trying to get lock;
try restarting transaction
</pre><p>
                At that point, the lock request for the other client can be
                granted and it deletes the row from the table.
            </p><p style="color:blue;">此时，可以授予另一个客户机的锁请求，并从表中删除行。</p>
            </div>
            <div class="section">
                <div class="titlepage">
                    <div>
                        <div>
                            <h4 class="title"><a name="innodb-deadlock-detection"></a>14.7.5.2&nbsp;Deadlock Detection and Rollback</h4>

                        </div>

                    </div>

                </div>
                <a class="indexterm" name="idm140286820894064"></a><a class="indexterm" name="idm140286820892576"></a><a class="indexterm" name="idm140286820891504"></a><a class="indexterm" name="idm140286820890016"></a><a class="indexterm" name="idm140286820888112"></a><a class="indexterm" name="idm140286820886624"></a><p>
                When <a class="link" href="glossary.html#glos_deadlock_detection" title="deadlock detection">deadlock
                detection</a> is enabled (the default),
                <code class="literal">InnoDB</code> automatically detects transaction
                <a class="link" href="glossary.html#glos_deadlock" title="deadlock">deadlocks</a> and rolls back a
                transaction or transactions to break the deadlock.
                <code class="literal">InnoDB</code> tries to pick small transactions to
                roll back, where the size of a transaction is determined by the
                number of rows inserted, updated, or deleted.
            </p><p style="color:blue;">当启用死锁检测（默认）时，innodb会自动检测事务死锁并回滚一个或多个事务以打破死锁。innodb尝试选择要回滚的小事务，其中事务的大小由插入、更新或删除的行数决定。</p><p>
                <code class="literal">InnoDB</code> is aware of table locks if
                <code class="literal">innodb_table_locks = 1</code> (the default) and
                <a class="link" href="server-administration.html#sysvar_autocommit"><code class="literal">autocommit = 0</code></a>, and the MySQL
                layer above it knows about row-level locks. Otherwise,
                <code class="literal">InnoDB</code> cannot detect deadlocks where a table
                lock set by a MySQL <a class="link" href="sql-syntax.html#lock-tables" title="13.3.5&nbsp;LOCK TABLES and UNLOCK TABLES Syntax"><code class="literal">LOCK TABLES</code></a>
                statement or a lock set by a storage engine other than
                <code class="literal">InnoDB</code> is involved. Resolve these situations
                by setting the value of the
                <a class="link" href="innodb-storage-engine.html#sysvar_innodb_lock_wait_timeout"><code class="literal">innodb_lock_wait_timeout</code></a> system
                variable.
            </p><p style="color:blue;">如果innodb_table_locks=1（默认值）和autocommit=0，innodb就会知道表锁，并且上面的mysql层知道行级锁。否则，如果涉及mysql lock tables语句设置的表锁或非innodb的存储引擎设置的锁，innodb将无法检测到死锁。通过设置innodb_lock_wait_timeout系统变量的值来解决这些情况。</p><p>
                When <code class="literal">InnoDB</code> performs a complete rollback of a
                transaction, all locks set by the transaction are released.
                However, if just a single SQL statement is rolled back as a
                result of an error, some of the locks set by the statement may
                be preserved. This happens because <code class="literal">InnoDB</code>
                stores row locks in a format such that it cannot know afterward
                which lock was set by which statement.
            </p><p style="color:blue;">当innodb执行事务的完全回滚时，该事务设置的所有锁都会被释放。但是，如果一个错误只回滚一个sql语句，那么该语句设置的一些锁可能会被保留。之所以会发生这种情况，是因为innodb以这样的格式存储行锁，这样它就无法在之后知道哪个锁是由哪个语句设置的。</p><p>
                If a <a class="link" href="sql-syntax.html#select" title="13.2.9&nbsp;SELECT Syntax"><code class="literal">SELECT</code></a> calls a stored
                function in a transaction, and a statement within the function
                fails, that statement rolls back. Furthermore, if
                <a class="link" href="sql-syntax.html#commit" title="13.3.1&nbsp;START TRANSACTION, COMMIT, and ROLLBACK Syntax"><code class="literal">ROLLBACK</code></a> is
                executed after that, the entire transaction rolls back.
            </p><p style="color:blue;">如果select调用事务中存储的函数，而函数中的语句失败，则该语句将回滚。此外，如果在此之后执行回滚，则整个事务将回滚。</p><p>
                If the <code class="literal">LATEST DETECTED DEADLOCK</code> section of
                <code class="literal">InnoDB</code> Monitor output includes a message
                stating, <span class="quote">“<span class="quote"><span class="errortext">TOO DEEP OR LONG SEARCH IN THE LOCK
        TABLE WAITS-FOR GRAPH, WE WILL ROLL BACK FOLLOWING
        TRANSACTION</span>,</span>”</span> this indicates that the number
                of transactions on the wait-for list has reached a limit of 200.
                A wait-for list that exceeds 200 transactions is treated as a
                deadlock and the transaction attempting to check the wait-for
                list is rolled back. The same error may also occur if the
                locking thread must look at more than 1,000,000 locks owned by
                transactions on the wait-for list.
            </p><p style="color:blue;">如果innodb monitor输出的最新检测到的死锁部分包含一条消息：“在锁表waits-for图中搜索太深或太长，我们将回滚后续事务”，这表示等待列表中的事务数已达到200的限制。超过200个事务的等待列表将被视为死锁，尝试检查等待列表的事务将回滚。如果锁定线程必须查看等待列表中事务拥有的超过1000000个锁，则也可能发生相同的错误。</p><p>
                For techniques to organize database operations to avoid
                deadlocks, see <a class="xref" href="innodb-storage-engine.html#innodb-deadlocks" title="14.7.5&nbsp;Deadlocks in InnoDB">Section&nbsp;14.7.5, “Deadlocks in InnoDB”</a>.
            </p><p style="color:blue;">有关组织数据库操作以避免死锁的技术，请参阅14.7.5节“InnoDB中的死锁”。</p>
                <div class="simplesect">

                    <div class="titlepage">
                        <div>

                            <div class="simple">
                                <h5 class="title"><a name="innodb-disable-deadlock-detection"></a>Disabling Deadlock Detection</h5>
                            </div>
                        </div>
                    </div>
                    <p>
                        On high concurrency systems, deadlock detection can cause a
                        slowdown when numerous threads wait for the same lock. At
                        times, it may be more efficient to disable deadlock detection
                        and rely on the
                        <a class="link" href="innodb-storage-engine.html#sysvar_innodb_lock_wait_timeout"><code class="literal">innodb_lock_wait_timeout</code></a>
                        setting for transaction rollback when a deadlock occurs.
                        Deadlock detection can be disabled using the
                        <a class="link" href="innodb-storage-engine.html#sysvar_innodb_deadlock_detect"><code class="literal">innodb_deadlock_detect</code></a>
                        configuration option.
                    </p><p style="color:blue;">在高并发性系统中，当多个线程等待同一个锁时，死锁检测可能会导致速度减慢。有时，禁用死锁检测和在发生死锁时依赖innodb_lock_wait_timeout设置进行事务回滚可能更有效。可以使用innodb_deadlock_detect配置选项禁用死锁检测。</p>
                </div>

            </div>
            <div class="section">
                <div class="titlepage">
                    <div>
                        <div>
                            <h4 class="title"><a name="innodb-deadlocks-handling"></a>14.7.5.3&nbsp;How to Minimize and Handle Deadlocks</h4>

                        </div>

                    </div>

                </div>
                <p>
                    This section builds on the conceptual information about
                    deadlocks in <a class="xref" href="innodb-storage-engine.html#innodb-deadlock-detection" title="14.7.5.2&nbsp;Deadlock Detection and Rollback">Section&nbsp;14.7.5.2, “Deadlock Detection and Rollback”</a>. It
                    explains how to organize database operations to minimize
                    deadlocks and the subsequent error handling required in
                    applications.
                </p><p style="color:blue;">本节以第14.7.5.2节“死锁检测和回滚”中有关死锁的概念信息为基础。它解释了如何组织数据库操作以最小化死锁和应用程序中所需的后续错误处理。</p><p>
                <a class="link" href="glossary.html#glos_deadlock" title="deadlock">Deadlocks</a> are a classic
                problem in transactional databases, but they are not dangerous
                unless they are so frequent that you cannot run certain
                transactions at all. Normally, you must write your applications
                so that they are always prepared to re-issue a transaction if it
                gets rolled back because of a deadlock.
            </p><p style="color:blue;">死锁是事务性数据库中的一个典型问题，但除非死锁频繁到您根本无法运行某些事务，否则它们并不危险。通常，您必须编写应用程序，以便在事务由于死锁而回滚时，它们始终准备重新发出该事务。</p><p>
                <code class="literal">InnoDB</code> uses automatic row-level locking. You
                can get deadlocks even in the case of transactions that just
                insert or delete a single row. That is because these operations
                are not really <span class="quote">“<span class="quote">atomic</span>”</span>; they automatically set
                locks on the (possibly several) index records of the row
                inserted or deleted.
            </p><p style="color:blue;">InnoDB使用自动行级锁定。即使是只插入或删除一行的事务，也会出现死锁。这是因为这些操作并不是真正的“原子”操作；它们会自动对插入或删除的行（可能是多个）索引记录设置锁。</p><p>
                You can cope with deadlocks and reduce the likelihood of their
                occurrence with the following techniques:
            </p><p style="color:blue;">您可以使用以下技术处理死锁并降低死锁发生的可能性：</p>
                <div class="itemizedlist">
                    <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                        At any time, issue the
                        <a class="link" href="sql-syntax.html#show-engine" title="13.7.5.15&nbsp;SHOW ENGINE Syntax"><code class="literal">SHOW ENGINE
                            INNODB STATUS</code></a> command to determine the cause of
                        the most recent deadlock. That can help you to tune your
                        application to avoid deadlocks.
                    </p><p style="color:blue;">随时发出show engine innodb status命令，以确定最近死锁的原因。这可以帮助您优化应用程序以避免死锁。</p></li><li class="listitem"><p>
                        If frequent deadlock warnings cause concern, collect more
                        extensive debugging information by enabling the
                        <a class="link" href="innodb-storage-engine.html#sysvar_innodb_print_all_deadlocks"><code class="literal">innodb_print_all_deadlocks</code></a>
                        configuration option. Information about each deadlock, not
                        just the latest one, is recorded in the MySQL
                        <a class="link" href="glossary.html#glos_error_log" title="error log">error log</a>. Disable
                        this option when you are finished debugging.
                    </p><p style="color:blue;">如果频繁的死锁警告引起关注，请通过启用innodb_print_all_deadlocks配置选项来收集更广泛的调试信息。mysql错误日志中记录了每个死锁的信息，而不仅仅是最新的死锁。完成调试后禁用此选项。</p></li><li class="listitem"><p>
                        Always be prepared to re-issue a transaction if it fails due
                        to deadlock. Deadlocks are not dangerous. Just try again.
                    </p><p style="color:blue;">如果事务由于死锁而失败，请随时准备重新发出该事务。死锁并不危险。再试一次。</p></li><li class="listitem"><p>
                        Keep transactions small and short in duration to make them
                        less prone to collision.
                    </p><p style="color:blue;">保持事务小而持续时间短，以使它们不易发生冲突。</p></li><li class="listitem"><p>
                        Commit transactions immediately after making a set of
                        related changes to make them less prone to collision. In
                        particular, do not leave an interactive
                        <a class="link" href="programs.html#mysql" title="4.5.1&nbsp;mysql — The MySQL Command-Line Client"><span class="command"><strong>mysql</strong></span></a> session open for a long time with
                        an uncommitted transaction.
                    </p><p style="color:blue;">在进行一组相关更改后立即提交事务，以减少它们发生冲突的可能性。特别是，不要让未提交事务的交互式mysql会话长时间处于打开状态。</p></li><li class="listitem"><p>
                        If you use <a class="link" href="glossary.html#glos_locking_read" title="locking read">locking
                        reads</a> (<a class="link" href="sql-syntax.html#select" title="13.2.9&nbsp;SELECT Syntax"><code class="literal">SELECT
                        ... FOR UPDATE</code></a> or
                        <code class="literal">SELECT ... LOCK IN SHARE
                            MODE</code>), try using a lower isolation level such as
                        <a class="link" href="innodb-storage-engine.html#isolevel_read-committed"><code class="literal">READ COMMITTED</code></a>.
                    </p><p style="color:blue;">如果使用锁定读取（选择…更新或选择…在共享模式下锁定），请尝试使用较低的隔离级别，如read committed。</p></li><li class="listitem"><p>
                        When modifying multiple tables within a transaction, or
                        different sets of rows in the same table, do those
                        operations in a consistent order each time. Then
                        transactions form well-defined queues and do not deadlock.
                        For example, organize database operations into functions
                        within your application, or call stored routines, rather
                        than coding multiple similar sequences of
                        <code class="literal">INSERT</code>, <code class="literal">UPDATE</code>, and
                        <code class="literal">DELETE</code> statements in different places.
                    </p><p style="color:blue;">当修改一个事务中的多个表或同一个表中的不同行集时，请每次以一致的顺序执行这些操作。然后事务形成定义良好的队列，而不是死锁。例如，将数据库操作组织到应用程序中的函数中，或调用存储的例程，而不是在不同的位置编写多个类似的insert、update和delete语句序列。</p></li><li class="listitem"><p>
                        Add well-chosen indexes to your tables. Then your queries
                        need to scan fewer index records and consequently set fewer
                        locks. Use <a class="link" href="sql-syntax.html#explain" title="13.8.2&nbsp;EXPLAIN Syntax"><code class="literal">EXPLAIN
                        SELECT</code></a> to determine which indexes the MySQL server
                        regards as the most appropriate for your queries.
                    </p><p style="color:blue;">将精心选择的索引添加到表中。然后查询需要扫描更少的索引记录，从而设置更少的锁。使用explain select确定mysql服务器认为哪些索引最适合您的查询。</p></li><li class="listitem"><p>
                        Use less locking. If you can afford to permit a
                        <a class="link" href="sql-syntax.html#select" title="13.2.9&nbsp;SELECT Syntax"><code class="literal">SELECT</code></a> to return data from an
                        old snapshot, do not add the clause <code class="literal">FOR
                        UPDATE</code> or <code class="literal">LOCK IN SHARE MODE</code> to
                        it. Using the <a class="link" href="innodb-storage-engine.html#isolevel_read-committed"><code class="literal">READ
                        COMMITTED</code></a> isolation level is good here, because
                        each consistent read within the same transaction reads from
                        its own fresh snapshot.
                    </p><p style="color:blue;">少用锁。如果您能够允许select从旧快照返回数据，请不要向其添加update或lock in share模式的子句。这里使用read committed隔离级别是很好的，因为同一事务中的每个一致读取都从自己的新快照中读取。</p></li><li class="listitem"><p>
                        If nothing else helps, serialize your transactions with
                        table-level locks. The correct way to use
                        <a class="link" href="sql-syntax.html#lock-tables" title="13.3.5&nbsp;LOCK TABLES and UNLOCK TABLES Syntax"><code class="literal">LOCK TABLES</code></a> with
                        transactional tables, such as <code class="literal">InnoDB</code>
                        tables, is to begin a transaction with <code class="literal">SET
                        autocommit = 0</code> (not
                        <a class="link" href="sql-syntax.html#commit" title="13.3.1&nbsp;START TRANSACTION, COMMIT, and ROLLBACK Syntax"><code class="literal">START
                            TRANSACTION</code></a>) followed by <a class="link" href="sql-syntax.html#lock-tables" title="13.3.5&nbsp;LOCK TABLES and UNLOCK TABLES Syntax"><code class="literal">LOCK
                        TABLES</code></a>, and to not call
                        <a class="link" href="sql-syntax.html#lock-tables" title="13.3.5&nbsp;LOCK TABLES and UNLOCK TABLES Syntax"><code class="literal">UNLOCK
                            TABLES</code></a> until you commit the transaction
                        explicitly. For example, if you need to write to table
                        <code class="literal">t1</code> and read from table
                        <code class="literal">t2</code>, you can do this:
                    </p><p style="color:blue;">如果没有其他帮助，请使用表级锁序列化事务。将锁表与事务表（如innodb tables）一起使用的正确方法是，以set autocommit=0（不是start transaction）后跟锁表开始事务，并且在显式提交事务之前不要调用unlock tables。例如，如果需要写入表T1并读取表T2，可以执行以下操作：</p><pre data-lang="sql" class="programlisting">SET autocommit=0;
LOCK TABLES t1 WRITE, t2 READ, ...;
<em class="replaceable"><code>... do something with tables t1 and t2 here ...</code></em>
COMMIT;
UNLOCK TABLES;
</pre><p>
                        Table-level locks prevent concurrent updates to the table,
                        avoiding deadlocks at the expense of less responsiveness for
                        a busy system.
                    </p><p style="color:blue;">表级锁防止对表的并发更新，以降低繁忙系统的响应速度为代价避免死锁。</p></li><li class="listitem"><p>
                        Another way to serialize transactions is to create an
                        auxiliary <span class="quote">“<span class="quote">semaphore</span>”</span> table that contains just
                        a single row. Have each transaction update that row before
                        accessing other tables. In that way, all transactions happen
                        in a serial fashion. Note that the <code class="literal">InnoDB</code>
                        instant deadlock detection algorithm also works in this
                        case, because the serializing lock is a row-level lock. With
                        MySQL table-level locks, the timeout method must be used to
                        resolve deadlocks.
                    </p><p style="color:blue;">另一种序列化事务的方法是创建一个辅助的“信号量”表，该表只包含一行。在访问其他表之前，让每个事务更新该行。这样，所有的交易都以一种连续的方式发生。注意，innodb即时死锁检测算法在这种情况下也可以工作，因为序列化锁是行级锁。对于mysql表级锁，必须使用timeout方法来解决死锁问题。</p></li></ul>
                </div>

            </div>

        </div>

    </div>
    <div class="section">
        <div class="titlepage">
            <div>
                <div>
                    <h2 class="title" style="clear: both"><a name="innodb-configuration"></a>14.8&nbsp;InnoDB Configuration</h2>

                </div>

            </div>

        </div>
        <div class="toc">
            <dl class="toc"><dt><span class="section"><a href="innodb-storage-engine.html#innodb-init-startup-configuration">14.8.1 InnoDB Startup Configuration</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-read-only-instance">14.8.2 Configuring InnoDB for Read-Only Operation</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-performance-buffer-pool">14.8.3 InnoDB Buffer Pool Configuration</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-performance-use_sys_malloc">14.8.4 Configuring the Memory Allocator for InnoDB</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-performance-thread_concurrency">14.8.5 Configuring Thread Concurrency for InnoDB</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-performance-multiple_io_threads">14.8.6 Configuring the Number of Background InnoDB I/O Threads</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-linux-native-aio">14.8.7 Using Asynchronous I/O on Linux</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-configuring-io-capacity">14.8.8 Configuring InnoDB I/O Capacity</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-performance-spin_lock_polling">14.8.9 Configuring Spin Lock Polling</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-purge-configuration">14.8.10 Purge Configuration</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-performance-optimizer-statistics">14.8.11 Configuring Optimizer Statistics for InnoDB</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#index-page-merge-threshold">14.8.12 Configuring the Merge Threshold for Index Pages</a></span></dt></dl>
        </div>
        <p>
            This section provides configuration information and procedures for
            <code class="literal">InnoDB</code> initialization, startup, and various
            components and features of the <code class="literal">InnoDB</code> storage
            engine. For information about optimizing database operations for
            <code class="literal">InnoDB</code> tables, see
            <a class="xref" href="optimization.html#optimizing-innodb" title="8.5&nbsp;Optimizing for InnoDB Tables">Section&nbsp;8.5, “Optimizing for InnoDB Tables”</a>.
        </p><p style="color:blue;">本节提供InnoDB初始化、启动的配置信息和过程，以及InnoDB存储引擎的各种组件和特性。有关为innodb表优化数据库操作的信息，请参阅8.5节“为innodb表优化”。</p>
        <div class="section">

            <div class="titlepage">
                <div>
                    <div>
                        <h3 class="title"><a name="innodb-init-startup-configuration"></a>14.8.1&nbsp;InnoDB Startup Configuration</h3>
                    </div>
                </div>
            </div>
            <p>
                The first decisions to make about <code class="literal">InnoDB</code>
                configuration involve the configuration of data files, log files,
                page size, and memory buffers. It is recommended that you define
                data file, log file, and page size configuration before creating
                the <code class="literal">InnoDB</code> instance. Modifying data file or log
                file configuration after the <code class="literal">InnoDB</code> instance is
                created may involve a non-trivial procedure, and page size can
                only be defined when the <code class="literal">InnoDB</code> instance is
                first initialized.
            </p><p style="color:blue;">关于innodb配置的第一个决定涉及到数据文件、日志文件、页面大小和内存缓冲区的配置。建议在创建innodb实例之前定义数据文件、日志文件和页面大小配置。在创建innodb实例后修改数据文件或日志文件配置可能涉及一个非常重要的过程，只有在innodb实例首次初始化时才能定义页面大小。</p><p>
            In addition to these topics, this section provides information
            about specifying <code class="literal">InnoDB</code> options in a
            configuration file, viewing <code class="literal">InnoDB</code>
            initialization information, and important storage considerations.
        </p><p style="color:blue;">除了这些主题之外，本节还提供了有关在配置文件中指定innodb选项、查看innodb初始化信息和重要存储注意事项的信息。</p>
            <div class="itemizedlist">
                <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><a class="xref" href="innodb-storage-engine.html#innodb-startup-mysql-configuration-file" title="Specifying Options in a MySQL Configuration File">Specifying Options in a MySQL Configuration File</a></p><p style="color:blue;">在mysql配置文件中指定选项</p></li><li class="listitem"><p><a class="xref" href="innodb-storage-engine.html#innodb-startup-initialization-information" title="Viewing InnoDB Initialization Information">Viewing InnoDB Initialization Information</a></p><p style="color:blue;">查看InnoDB初始化信息</p></li><li class="listitem"><p><a class="xref" href="innodb-storage-engine.html#innodb-startup-storage-considerations" title="Important Storage Considerations">Important Storage Considerations</a></p><p style="color:blue;">重要的存储注意事项</p></li><li class="listitem"><p><a class="xref" href="innodb-storage-engine.html#innodb-startup-data-file-configuration" title="System Tablespace Data File Configuration">System Tablespace Data File Configuration</a></p><p style="color:blue;">系统表空间数据文件配置</p></li><li class="listitem"><p><a class="xref" href="innodb-storage-engine.html#innodb-startup-log-file-configuration" title="Redo Log File Configuration">Redo Log File Configuration</a></p><p style="color:blue;">重做日志文件配置</p></li><li class="listitem"><p><a class="xref" href="innodb-storage-engine.html#innodb-startup-undo-tablespace" title="Undo Tablespace Configuration">Undo Tablespace Configuration</a></p><p style="color:blue;">撤消表空间配置</p></li><li class="listitem"><p><a class="xref" href="innodb-storage-engine.html#innodb-startup-temporary-tablespace" title="Temporary Tablespace Configuration">Temporary Tablespace Configuration</a></p><p style="color:blue;">临时表空间配置</p></li><li class="listitem"><p><a class="xref" href="innodb-storage-engine.html#innodb-startup-page-size" title="Page Size Configuration">Page Size Configuration</a></p><p style="color:blue;">页面大小配置</p></li><li class="listitem"><p><a class="xref" href="innodb-storage-engine.html#innodb-startup-memory-configuration" title="Memory Configuration">Memory Configuration</a></p><p style="color:blue;">内存配置</p></li></ul>
            </div>

            <div class="simplesect">

                <div class="titlepage">
                    <div>

                        <div class="simple">
                            <h4 class="title"><a name="innodb-startup-mysql-configuration-file"></a>Specifying Options in a MySQL Configuration File</h4>

                        </div>

                    </div>

                </div>
                <p>
                    Because MySQL uses data file, log file, and page size
                    configuration settings to initialize the
                    <code class="literal">InnoDB</code> instance, it is recommended that you
                    define these settings in a configuration file that MySQL reads
                    at startup, prior to initializing <code class="literal">InnoDB</code> for
                    the first time. <code class="literal">InnoDB</code> is initialized when
                    the MySQL server is started, and the first initialization of
                    <code class="literal">InnoDB</code> normally occurs the first time you
                    start the MySQL server.
                </p><p style="color:blue;">由于MySQL使用数据文件、日志文件和页面大小配置设置来初始化InnoDB实例，因此建议在首次初始化InnoDB之前，在MySQL启动时读取的配置文件中定义这些设置。InnoDB在MySQL服务器启动时初始化，InnoDB的第一次初始化通常在第一次启动MySQL服务器时进行。</p><p>
                You can place <code class="literal">InnoDB</code> options in the
                <code class="literal">[mysqld]</code> group of any option file that your
                server reads when it starts. The locations of MySQL option files
                are described in <a class="xref" href="programs.html#option-files" title="4.2.2.2&nbsp;Using Option Files">Section&nbsp;4.2.2.2, “Using Option Files”</a>.
            </p><p style="color:blue;">您可以将innodb options放在服务器启动时读取的任何选项文件的[mysqld]组中。mysql选项文件的位置在4.2.2.2节“使用选项文件”中描述。</p><p>
                To make sure that <a class="link" href="programs.html#mysqld" title="4.3.1&nbsp;mysqld — The MySQL Server"><span class="command"><strong>mysqld</strong></span></a> reads options only
                from a specific file, use the
                <a class="link" href="programs.html#option_general_defaults-file"><code class="option">--defaults-file</code></a> option as the
                first option on the command line when starting the server:
            </p><p style="color:blue;">要确保mysqld只从特定文件读取选项，请在启动服务器时将--defaults file选项用作命令行中的第一个选项：</p><pre data-lang="ini" class="programlisting">mysqld --defaults-file=<em class="replaceable"><code>path_to_configuration_file</code></em>
</pre>
            </div>
            <div class="simplesect">
                <div class="titlepage">
                    <div>
                        <div class="simple">
                            <h4 class="title"><a name="innodb-startup-initialization-information"></a>Viewing InnoDB Initialization Information</h4>

                        </div>

                    </div>

                </div>
                <p>
                    To view <code class="literal">InnoDB</code> initialization information
                    during startup, start <a class="link" href="programs.html#mysqld" title="4.3.1&nbsp;mysqld — The MySQL Server"><span class="command"><strong>mysqld</strong></span></a> from a command
                    prompt. When <a class="link" href="programs.html#mysqld" title="4.3.1&nbsp;mysqld — The MySQL Server"><span class="command"><strong>mysqld</strong></span></a> is started from a command
                    prompt, initialization information is printed to the console.
                </p><p style="color:blue;">要在启动期间查看innodb初始化信息，请从命令提示符启动mysqld。从命令提示符启动mysqld时，初始化信息将打印到控制台。</p><p>
                For example, on Windows, if <a class="link" href="programs.html#mysqld" title="4.3.1&nbsp;mysqld — The MySQL Server"><span class="command"><strong>mysqld</strong></span></a> is located
                in <code class="filename">C:\Program Files\MySQL\MySQL Server
                5.7\bin</code>, start the MySQL server like
                this:
            </p><p style="color:blue;">例如，在windows上，如果mysqld位于c:\ program files\mysql\mysql server 5.7\bin中，则按如下方式启动mysql服务器：</p><pre data-lang="terminal" class="programlisting">C:\&gt; <strong class="userinput"><code>"C:\Program Files\MySQL\MySQL Server 5.7\bin\mysqld" --console</code></strong>
</pre><p>
                On Unix-like systems, <a class="link" href="programs.html#mysqld" title="4.3.1&nbsp;mysqld — The MySQL Server"><span class="command"><strong>mysqld</strong></span></a> is located in
                the <code class="filename">bin</code> directory of your MySQL
                installation:
            </p><p style="color:blue;">在类unix系统上，mysqld位于mysql安装的bin目录中：</p><pre data-lang="terminal" class="programlisting">shell&gt; <strong class="userinput"><code>bin/mysqld --user=mysql &amp;</code></strong>
</pre><p>
                If you do not send server output to the console, check the error
                log after startup to see the initialization information
                <code class="literal">InnoDB</code> printed during the startup process.
            </p><p style="color:blue;">如果没有将服务器输出发送到控制台，请在启动后查看错误日志，查看在启动过程中打印的初始化信息innodb。</p><p>
                For information about starting MySQL using other methods, see
                <a class="xref" href="installing.html#automatic-start" title="2.10.5&nbsp;Starting and Stopping MySQL Automatically">Section&nbsp;2.10.5, “Starting and Stopping MySQL Automatically”</a>.
            </p><p style="color:blue;">有关使用其他方法启动mysql的信息，请参阅2.10.5节“自动启动和停止mysql”。</p>
                <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">

                    <div class="admon-title">
                        Note
                    </div>
                    <p>
                        <code class="literal">InnoDB</code> does not open all user tables and
                        associated data files at startup. However,
                        <code class="literal">InnoDB</code> does check for the existence of
                        tablespace files (<code class="filename">*.ibd</code> files) that are
                        referenced in the data dictionary. If a tablespace file is not
                        found, <code class="literal">InnoDB</code> logs an error and continues
                        the startup sequence. Tablespace files that are referenced in
                        the redo log may be opened during crash recovery for redo
                        application.
                    </p><p style="color:blue;">innodb不会在启动时打开所有用户表和相关的数据文件。但是，InNODB检查数据字典中引用的表空间文件（*.IBD文件）是否存在。如果找不到表空间文件，innodb会记录一个错误并继续启动序列。重做日志中引用的表空间文件可以在重做应用程序的崩溃恢复期间打开。</p>
                </div>

            </div>
            <div class="simplesect">
                <div class="titlepage">
                    <div>
                        <div class="simple">
                            <h4 class="title"><a name="innodb-startup-storage-considerations"></a>Important Storage Considerations</h4>

                        </div>

                    </div>

                </div>
                <a class="indexterm" name="idm140286820759248"></a><a class="indexterm" name="idm140286820757792"></a><p>
                Review the following storage-related considerations before
                proceeding with your startup configuration.
            </p><p style="color:blue;">在继续启动配置之前，请检查以下与存储相关的注意事项。</p>
                <div class="itemizedlist">
                    <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                        In some cases, database performance improves if the data is
                        not all placed on the same physical disk. Putting log files
                        on a different disk from data is very often beneficial for
                        performance. For example, you can place system tablespace
                        data files and log files on different disks. You can also
                        use raw disk partitions (raw devices) for
                        <code class="literal">InnoDB</code> data files, which may speed up
                        I/O. See <a class="xref" href="innodb-storage-engine.html#innodb-raw-devices" title="Using Raw Disk Partitions for the System Tablespace">Using Raw Disk Partitions for the System Tablespace</a>.
                    </p><p style="color:blue;">在某些情况下，如果数据不是全部放在同一个物理磁盘上，则数据库性能会提高。将日志文件与数据放在不同的磁盘上通常有助于提高性能。例如，您可以将系统表空间数据文件和日志文件放在不同的磁盘上。您也可以对innodb数据文件使用原始磁盘分区（原始设备），这可能会加快i/o速度。请参阅对系统表空间使用原始磁盘分区。</p></li><li class="listitem"><p>
                        <code class="literal">InnoDB</code> is a transaction-safe (ACID
                        compliant) storage engine for MySQL that has commit,
                        rollback, and crash-recovery capabilities to protect user
                        data. <span class="bold"><strong>However, it cannot do
            so</strong></span> if the underlying operating system or hardware
                        does not work as advertised. Many operating systems or disk
                        subsystems may delay or reorder write operations to improve
                        performance. On some operating systems, the very
                        <code class="literal">fsync()</code> system call that should wait
                        until all unwritten data for a file has been flushed might
                        actually return before the data has been flushed to stable
                        storage. Because of this, an operating system crash or a
                        power outage may destroy recently committed data, or in the
                        worst case, even corrupt the database because of write
                        operations having been reordered. If data integrity is
                        important to you, perform some <span class="quote">“<span class="quote">pull-the-plug</span>”</span>
                        tests before using anything in production. On OS X 10.3 and
                        higher, <code class="literal">InnoDB</code> uses a special
                        <code class="literal">fcntl()</code> file flush method. Under Linux,
                        it is advisable to <span class="bold"><strong>disable the
            write-back cache</strong></span>.
                    </p><p style="color:blue;">InnoDB是一个面向MySQL的事务安全（ACID兼容）存储引擎，它具有提交、回滚和崩溃恢复功能来保护用户数据。但是，如果底层操作系统或硬件不按广告的方式工作，则无法执行此操作。许多操作系统或磁盘子系统可能会延迟或重新排序写入操作以提高性能。在某些操作系统上，应该等到文件的所有未写入数据被刷新后才执行的fsync（）系统调用可能会在数据被刷新到稳定存储之前实际返回。因此，操作系统崩溃或断电可能会破坏最近提交的数据，或者在最坏的情况下，甚至会损坏数据库，因为写入操作已重新排序。如果数据完整性对您很重要，请在生产中使用任何东西之前执行一些“拔掉插头”测试。在OSX10.3及更高版本上，InnoDB使用特殊的fcntl（）文件刷新方法。在Linux下，建议禁用写回缓存。</p><p>
                        On ATA/SATA disk drives, a command such <code class="literal">hdparm -W0
                        /dev/hda</code> may work to disable the write-back cache.
                        <span class="bold"><strong>Beware that some drives or disk
            controllers may be unable to disable the write-back
            cache.</strong></span>
                    </p><p style="color:blue;">在ata/sata磁盘驱动器上，hdparm-w0/dev/hda这样的命令可以用来禁用写回缓存。请注意，某些驱动器或磁盘控制器可能无法禁用回写缓存。</p></li><li class="listitem"><p>
                        With regard to <code class="literal">InnoDB</code> recovery
                        capabilities that protect user data,
                        <code class="literal">InnoDB</code> uses a file flush technique
                        involving a structure called the
                        <a class="link" href="glossary.html#glos_doublewrite_buffer" title="doublewrite buffer">doublewrite
                            buffer</a>, which is enabled by default
                        (<a class="link" href="innodb-storage-engine.html#sysvar_innodb_doublewrite"><code class="literal">innodb_doublewrite=ON</code></a>).
                        The doublewrite buffer adds safety to recovery following a
                        crash or power outage, and improves performance on most
                        varieties of Unix by reducing the need for
                        <code class="literal">fsync()</code> operations. It is recommended
                        that the <a class="link" href="innodb-storage-engine.html#sysvar_innodb_doublewrite"><code class="literal">innodb_doublewrite</code></a>
                        option remains enabled if you are concerned with data
                        integrity or possible failures. For additional information
                        about the doublewrite buffer, see
                        <a class="xref" href="innodb-storage-engine.html#innodb-disk-io" title="14.12.1&nbsp;InnoDB Disk I/O">Section&nbsp;14.12.1, “InnoDB Disk I/O”</a>.
                    </p><p style="color:blue;">关于保护用户数据的innodb恢复功能，innodb使用一种文件刷新技术，该技术涉及一个名为doublewrite buffer的结构，该结构在默认情况下是启用的（innodb_doublewrite=on）。DoubleWrite缓冲区为崩溃或断电后的恢复增加了安全性，并通过减少对fsync（）操作的需要提高了大多数Unix上的性能。如果您担心数据完整性或可能出现的故障，建议继续启用innodb_doublewrite选项。有关doublewrite缓冲区的更多信息，请参阅14.12.1节，“innodb disk i/o”。</p></li><li class="listitem"><p>
                        Before using NFS with <code class="literal">InnoDB</code>, review
                        potential issues outlined in
                        <a class="xref" href="optimization.html#disk-issues-nfs" title="Using NFS with MySQL">Using NFS with MySQL</a>.
                    </p><p style="color:blue;">在将nfs与innodb一起使用之前，请查看在将nfs与mysql一起使用中概述的潜在问题。</p></li><li class="listitem"><p>
                        Running MySQL server on a 4K sector hard drive on Windows is
                        not supported with
                        <a class="link" href="innodb-storage-engine.html#sysvar_innodb_flush_method"><code class="literal">innodb_flush_method=async_unbuffered</code></a>,
                        which is the default setting. The workaround is to use
                        <a class="link" href="innodb-storage-engine.html#sysvar_innodb_flush_method"><code class="literal">innodb_flush_method=normal</code></a>.
                    </p><p style="color:blue;">默认设置innodb_flush_method=async_unbuffered不支持在windows上的4k扇区硬盘上运行mysql server。解决方法是使用innodb_flush_method=normal。</p></li></ul>
                </div>

            </div>
            <div class="simplesect">
                <div class="titlepage">
                    <div>
                        <div class="simple">
                            <h4 class="title"><a name="innodb-startup-data-file-configuration"></a>System Tablespace Data File Configuration</h4>

                        </div>

                    </div>

                </div>
                <p>
                    The <a class="link" href="innodb-storage-engine.html#sysvar_innodb_data_file_path"><code class="literal">innodb_data_file_path</code></a>
                    startup option defines the name, size, and attributes of
                    <code class="literal">InnoDB</code> system tablespace data files. If you
                    do not configure this option prior to initializing the MySQL
                    server, the default behavior is to create a single
                    auto-extending data file, slightly larger than 12MB, named
                    <code class="filename">ibdata1</code>:
                </p><p style="color:blue;">innodb_data_file_path startup选项定义innodb系统表空间数据文件的名称、大小和属性。如果在初始化mysql服务器之前未配置此选项，则默认行为是创建一个自动扩展的数据文件，其大小略大于12MB，名为ibdata1:</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>SHOW VARIABLES LIKE 'innodb_data_file_path';</code></strong>
+-----------------------+------------------------+
| Variable_name         | Value                  |
+-----------------------+------------------------+
| innodb_data_file_path | ibdata1:12M:autoextend |
+-----------------------+------------------------+
</pre><p>
                The full data file specification syntax includes the file name,
                file size, <code class="literal">autoextend</code> attribute, and
                <code class="literal">max</code> attribute:
            </p><p style="color:blue;">完整数据文件规范语法包括文件名、文件大小、自动扩展属性和max属性：</p><pre data-lang="ini" class="programlisting"><em class="replaceable"><code>file_name</code></em>:<em class="replaceable"><code>file_size</code></em>[:autoextend[:max:<em class="replaceable"><code>max_file_size</code></em>]]
</pre><p>
                File sizes are specified in kilobytes, megabytes, or gigabytes
                by appending <code class="literal">K</code>, <code class="literal">M</code> or
                <code class="literal">G</code> to the size value. If specifying the data
                file size in kilobytes, do so in multiples of 1024. Otherwise,
                kilobyte values are rounded to nearest megabyte (MB) boundary.
                The sum of file sizes must be, at a minimum, slightly larger
                than 12MB.
            </p><p style="color:blue;">文件大小是通过在大小值后面附加k、m或g以千字节、兆字节或千兆字节为单位指定的。如果以千字节为单位指定数据文件大小，请以1024的倍数指定。否则，千字节值将舍入到最接近的兆字节（MB）边界。文件大小之和必须至少略大于12MB。</p><p>
                You can specify more than one data file using a
                semicolon-separated list. For example:
            </p><p style="color:blue;">可以使用分号分隔的列表指定多个数据文件。例如：</p><pre data-lang="ini" class="programlisting">[mysqld]
innodb_data_file_path=ibdata1:50M;ibdata2:50M:autoextend
</pre><p>
                The <code class="literal">autoextend</code> and <code class="literal">max</code>
                attributes can be used only for the data file that is specified
                last.
            </p><p style="color:blue;">autoextend和max属性只能用于最后指定的数据文件。</p><p>
                When the <code class="literal">autoextend</code> attribute is specified,
                the data file automatically increases in size by 64MB increments
                as space is required. The
                <a class="link" href="innodb-storage-engine.html#sysvar_innodb_autoextend_increment"><code class="literal">innodb_autoextend_increment</code></a>
                variable controls the increment size.
            </p><p style="color:blue;">当指定了autoextend属性时，数据文件的大小会随着空间的需要而自动增加64MB。innodb_autoextend_increment变量控制增量大小。</p><p>
                To specify a maximum size for an auto-extending data file, use
                the <code class="literal">max</code> attribute following the
                <code class="literal">autoextend</code> attribute. Use the
                <code class="literal">max</code> attribute only in cases where
                constraining disk usage is of critical importance. The following
                configuration permits <code class="filename">ibdata1</code> to grow to a
                limit of 500MB:
            </p><p style="color:blue;">若要指定自动扩展数据文件的最大大小，请使用AutoExchange属性之后的Max属性。仅在约束磁盘使用非常重要的情况下才使用max属性。以下配置允许ibdata1扩展到500MB的限制：</p><pre data-lang="ini" class="programlisting">[mysqld]
innodb_data_file_path=ibdata1:12M:autoextend:max:500M
</pre><p>
                A minimum file size is enforced for the
                <span class="emphasis"><em>first</em></span> system tablespace data file to ensure
                that there is enough space for doublewrite buffer pages. The
                following table shows minimum file sizes for each
                <code class="literal">InnoDB</code> page size. The default
                <code class="literal">InnoDB</code> page size is 16384 (16KB).
            </p><p style="color:blue;">对第一个系统表空间数据文件强制使用最小文件大小，以确保有足够的空间用于doublewrite缓冲区页。下表显示了每个innodb页面大小的最小文件大小。默认innodb页面大小为16384（16kb）。</p>
                <div class="informaltable">
                    <table summary="The minimum system tablespace data file for each InnoDB page size."><colgroup><col width="30%"><col width="30%"></colgroup><thead><tr>
                        <th scope="col">Page Size (innodb_page_size)</th>
                        <th scope="col">Minimum File Size</th>
                    </tr></thead><tbody><tr>
                        <td scope="row">16384 (16KB) or less</td>
                        <td>3MB</td>
                    </tr><tr>
                        <td scope="row">32768 (32KB)</td>
                        <td>6MB</td>
                    </tr><tr>
                        <td scope="row">65536 (64KB)</td>
                        <td>12MB</td>
                    </tr></tbody></table>
                </div>
                <p>
                    If your disk becomes full, you can add a data file on another
                    disk. For instructions, see
                    <a class="xref" href="innodb-storage-engine.html#innodb-resize-system-tablespace" title="Resizing the System Tablespace">Resizing the System Tablespace</a>.
                </p><p style="color:blue;">如果磁盘已满，可以在另一个磁盘上添加数据文件。有关说明，请参阅调整系统表空间的大小。</p><p>
                The size limit for individual files is determined by your
                operating system. You can set the file size to more than 4GB on
                operating systems that support large files. You can also use raw
                disk partitions as data files. See
                <a class="xref" href="innodb-storage-engine.html#innodb-raw-devices" title="Using Raw Disk Partitions for the System Tablespace">Using Raw Disk Partitions for the System Tablespace</a>.
            </p><p style="color:blue;">单个文件的大小限制由您的操作系统决定。在支持大文件的操作系统上，可以将文件大小设置为大于4GB。也可以将原始磁盘分区用作数据文件。请参阅对系统表空间使用原始磁盘分区。</p><p>
                <code class="literal">InnoDB</code> is not aware of the file system
                maximum file size, so be cautious on file systems where the
                maximum file size is a small value such as 2GB.
            </p><p style="color:blue;">INODB不知道文件系统的最大文件大小，因此在文件系统最大的文件大小是一个小的值，例如2GB时要谨慎。</p><p>
                System tablespace files are created in the data directory by
                default (<a class="link" href="server-administration.html#sysvar_datadir"><code class="literal">datadir</code></a>). To specify
                an alternate location, use the
                <a class="link" href="innodb-storage-engine.html#sysvar_innodb_data_home_dir"><code class="literal">innodb_data_home_dir</code></a> option.
                For example, to create a system tablespace data file in a
                directory named <code class="filename">myibdata</code>, use this
                configuration:
            </p><p style="color:blue;">默认情况下，系统表空间文件是在数据目录（datadir）中创建的。要指定备用位置，请使用innodb_data_home_dir选项。例如，要在名为myibdata的目录中创建系统表空间数据文件，请使用以下配置：</p><pre data-lang="ini" class="programlisting">[mysqld]
innodb_data_home_dir = /myibdata/
innodb_data_file_path=ibdata1:50M:autoextend
</pre><p>
                A trailing slash is required when specifying a value for
                <a class="link" href="innodb-storage-engine.html#sysvar_innodb_data_home_dir"><code class="literal">innodb_data_home_dir</code></a>.
                <code class="literal">InnoDB</code> does not create directories, so ensure
                that the specified directory exists before you start the server.
                Also, ensure sure that the MySQL server has the proper access
                rights to create files in the directory.
            </p><p style="color:blue;">为innodb_data_home_dir指定值时，需要一个尾随斜杠。NONDB不创建目录，因此在启动服务器之前确保指定的目录存在。另外，确保mysql服务器具有在目录中创建文件的适当访问权限。</p><p>
                <code class="literal">InnoDB</code> forms the directory path for each data
                file by textually concatenating the value of
                <a class="link" href="innodb-storage-engine.html#sysvar_innodb_data_home_dir"><code class="literal">innodb_data_home_dir</code></a> to the
                data file name. If
                <a class="link" href="innodb-storage-engine.html#sysvar_innodb_data_home_dir"><code class="literal">innodb_data_home_dir</code></a> is not
                defined, the default value is <span class="quote">“<span class="quote">./</span>”</span>, which is the
                data directory. (The MySQL server changes its current working
                directory to the data directory when it begins executing.)
            </p><p style="color:blue;">innodb通过文本方式将innodb_data_home_dir的值连接到数据文件名，形成每个数据文件的目录路径。如果未定义innodb_data_home_dir，则默认值为“../”，这是数据目录。（MySQL服务器在开始执行时将其当前工作目录更改为数据目录。）</p><p>
                If you specify
                <a class="link" href="innodb-storage-engine.html#sysvar_innodb_data_home_dir"><code class="literal">innodb_data_home_dir</code></a> as an
                empty string, you can specify absolute paths for data files
                listed in the
                <a class="link" href="innodb-storage-engine.html#sysvar_innodb_data_file_path"><code class="literal">innodb_data_file_path</code></a> value.
                The following configuration is equivalent to the preceding one:
            </p><p style="color:blue;">如果将innodb_data_home_dir指定为空字符串，则可以为innodb_data_file_path值中列出的数据文件指定绝对路径。以下配置与前面的配置相同：</p><pre data-lang="ini" class="programlisting">[mysqld]
innodb_data_home_dir =
innodb_data_file_path=/myibdata/ibdata1:50M:autoextend
</pre>
            </div>
            <div class="simplesect">
                <div class="titlepage">
                    <div>
                        <div class="simple">
                            <h4 class="title"><a name="innodb-startup-log-file-configuration"></a>Redo Log File Configuration</h4>

                        </div>

                    </div>

                </div>
                <p>
                    By default, <code class="literal">InnoDB</code> creates two 5MB redo log
                    files in the data directory named
                    <code class="filename">ib_logfile0</code> and
                    <code class="filename">ib_logfile1</code>.
                </p><p style="color:blue;">默认情况下，innodb在名为ib_logfile0和ib_logfile1的数据目录中创建两个5MB重做日志文件。</p><p>
                The following options can be used to modify the default
                configuration:
            </p><p style="color:blue;">以下选项可用于修改默认配置：</p>
                <div class="itemizedlist">
                    <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                        <a class="link" href="innodb-storage-engine.html#sysvar_innodb_log_group_home_dir"><code class="literal">innodb_log_group_home_dir</code></a>
                        defines directory path to the <code class="literal">InnoDB</code> log
                        files (the redo logs). If this option is not configured,
                        <code class="literal">InnoDB</code> log files are created in the MySQL
                        data directory (<a class="link" href="server-administration.html#sysvar_datadir"><code class="literal">datadir</code></a>).
                    </p><p style="color:blue;">innodb_log_group_home_dir定义innodb日志文件（重做日志）的目录路径。如果未配置此选项，将在mysql数据目录（datadir）中创建innodb日志文件。</p><p>
                        You might use this option to place <code class="literal">InnoDB</code>
                        log files in a different physical storage location than
                        <code class="literal">InnoDB</code> data files to avoid potential I/O
                        resource conflicts. For example:
                    </p><p style="color:blue;">您可以使用此选项将innodb日志文件放置在与innodb数据文件不同的物理存储位置，以避免潜在的i/o资源冲突。例如：</p><pre data-lang="ini" class="programlisting">[mysqld]
innodb_log_group_home_dir = /dr3/iblogs
</pre>
                        <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">

                            <div class="admon-title">
                                Note
                            </div>
                            <p>
                                <code class="literal">InnoDB</code> does not create directories, so
                                make sure that the log directory exists before you start
                                the server. Use the Unix or DOS <code class="literal">mkdir</code>
                                command to create any necessary directories.
                            </p><p style="color:blue;">NONDB不创建目录，因此请确保在启动服务器之前存在日志目录。使用unix或dos mkdir命令创建任何必要的目录。</p><p>
                            Make sure that the MySQL server has the proper access
                            rights to create files in the log directory. More
                            generally, the server must have access rights in any
                            directory where it needs to create log files.
                        </p><p style="color:blue;">确保mysql服务器具有在日志目录中创建文件的适当访问权限。一般来说，服务器必须在需要创建日志文件的任何目录中具有访问权限。</p>
                        </div>
                    </li><li class="listitem"><p>
                        <a class="link" href="innodb-storage-engine.html#sysvar_innodb_log_files_in_group"><code class="literal">innodb_log_files_in_group</code></a>
                        defines the number of log files in the log group. The
                        default and recommended value is 2.
                    </p><p style="color:blue;">innodb_log_files_in_group定义日志组中的日志文件数。默认值和建议值为2。</p></li><li class="listitem"><p>
                        <a class="link" href="innodb-storage-engine.html#sysvar_innodb_log_file_size"><code class="literal">innodb_log_file_size</code></a>
                        defines the size in bytes of each log file in the log group.
                        The combined size of log files
                        (<a class="link" href="innodb-storage-engine.html#sysvar_innodb_log_file_size"><code class="literal">innodb_log_file_size</code></a> *
                        <a class="link" href="innodb-storage-engine.html#sysvar_innodb_log_files_in_group"><code class="literal">innodb_log_files_in_group</code></a>)
                        cannot exceed a maximum value that is slightly less than
                        512GB. A pair of 255 GB log files, for example, approaches
                        the limit but does not exceed it. The default log file size
                        is 48MB. Generally, the combined size of the log files
                        should be large enough that the server can smooth out peaks
                        and troughs in workload activity, which often means that
                        there is enough redo log space to handle more than an hour
                        of write activity. The larger the value, the less checkpoint
                        flush activity is needed in the buffer pool, saving disk
                        I/O. For additional information, see
                        <a class="xref" href="optimization.html#optimizing-innodb-logging" title="8.5.4&nbsp;Optimizing InnoDB Redo Logging">Section&nbsp;8.5.4, “Optimizing InnoDB Redo Logging”</a>.
                    </p><p style="color:blue;">innodb_log_file_size定义日志组中每个日志文件的字节大小。日志文件的组合大小不能超过一个小于0的最大值。例如，一对255gb日志文件接近限制，但不超过该限制。默认日志文件大小为48MB。通常，日志文件的组合大小应该足够大，以便服务器能够平滑工作负载活动中的高峰和低谷，这通常意味着有足够的重做日志空间来处理一个多小时的写入活动。值越大，缓冲池中所需的检查点刷新活动就越少，从而节省了磁盘I/O。有关更多信息，请参阅第8.5.4节“优化InnoDB重做日志记录”。</p></li></ul>
                </div>

            </div>
            <div class="simplesect">
                <div class="titlepage">
                    <div>
                        <div class="simple">
                            <h4 class="title"><a name="innodb-startup-undo-tablespace"></a>Undo Tablespace Configuration</h4>

                        </div>

                    </div>

                </div>
                <p>
                    By default, <code class="literal">InnoDB</code> undo logs are part of the
                    system tablespace. However, you can choose to store
                    <code class="literal">InnoDB</code> undo logs in one or more separate undo
                    tablespaces, typically on a different storage device.
                </p><p style="color:blue;">默认情况下，innodb undo日志是系统表空间的一部分。但是，您可以选择将innodb undo日志存储在一个或多个单独的undo表空间中，通常存储在不同的存储设备上。</p><p>
                The <a class="link" href="innodb-storage-engine.html#sysvar_innodb_undo_directory"><code class="literal">innodb_undo_directory</code></a>
                configuration option defines the path where
                <code class="literal">InnoDB</code> creates separate tablespaces for the
                undo logs. This option is typically used in conjunction with the
                <a class="link" href="innodb-storage-engine.html#sysvar_innodb_rollback_segments"><code class="literal">innodb_rollback_segments</code></a> and
                <a class="link" href="innodb-storage-engine.html#sysvar_innodb_undo_tablespaces"><code class="literal">innodb_undo_tablespaces</code></a>
                options, which determine the disk layout of the undo logs
                outside the system tablespace.
            </p><p style="color:blue;">innodb_undo_目录配置选项定义了innodb为撤销日志创建单独表空间的路径。此选项通常与innodb_rollback_segments和innodb_undo_tablespaces选项一起使用，后者决定了系统表空间之外的undo日志的磁盘布局。</p>
                <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">

                    <div class="admon-title">
                        Note
                    </div>
                    <p>
                        <a class="link" href="innodb-storage-engine.html#sysvar_innodb_undo_tablespaces"><code class="literal">innodb_undo_tablespaces</code></a> is
                        deprecated and will be removed in a future release.
                    </p><p style="color:blue;">innodb_undo_表空间已弃用，将在以后的版本中删除。</p>
                </div>
                <p>
                    For more information, see
                    <a class="xref" href="innodb-storage-engine.html#innodb-undo-tablespaces" title="14.6.3.4&nbsp;Undo Tablespaces">Section&nbsp;14.6.3.4, “Undo Tablespaces”</a>.
                </p><p style="color:blue;">有关更多信息，请参阅14.6.3.4节“撤消表空间”。</p>
            </div>
            <div class="simplesect">
                <div class="titlepage">
                    <div>
                        <div class="simple">
                            <h4 class="title"><a name="innodb-startup-temporary-tablespace"></a>Temporary Tablespace Configuration</h4>

                        </div>

                    </div>

                </div>
                <p>
                    By default, <code class="literal">InnoDB</code> creates a single
                    auto-extending temporary tablespace data file named
                    <code class="filename">ibtmp1</code> that is slightly larger than 12MB in
                    the <a class="link" href="innodb-storage-engine.html#sysvar_innodb_data_home_dir"><code class="literal">innodb_data_home_dir</code></a>
                    directory. The default temporary tablespace data file
                    configuration can be modified at startup using the
                    <a class="link" href="innodb-storage-engine.html#sysvar_innodb_temp_data_file_path"><code class="literal">innodb_temp_data_file_path</code></a>
                    configuration option.
                </p><p style="color:blue;">默认情况下，innodb会在innodb_data_home_dir目录中创建一个名为ibtmp1的自动扩展临时表空间数据文件，该文件的大小略大于12MB。默认的临时表空间数据文件配置可以在启动时使用innodb_temp_data_file_path配置选项进行修改。</p><p>
                The <a class="link" href="innodb-storage-engine.html#sysvar_innodb_temp_data_file_path"><code class="literal">innodb_temp_data_file_path</code></a>
                option specifies the path, file name, and file size for
                <code class="literal">InnoDB</code> temporary tablespace data files. The
                full directory path for a file is formed by concatenating
                <a class="link" href="innodb-storage-engine.html#sysvar_innodb_data_home_dir"><code class="literal">innodb_data_home_dir</code></a> to the
                path specified by
                <a class="link" href="innodb-storage-engine.html#sysvar_innodb_temp_data_file_path"><code class="literal">innodb_temp_data_file_path</code></a>.
                File size is specified in KB, MB, or GB (1024MB) by appending K,
                M, or G to the size value. The sum of the sizes of the files
                must be slightly larger than 12MB.
            </p><p style="color:blue;">innodb_temp_data_file_path选项指定innodb临时表空间数据文件的路径、文件名和文件大小。文件的完整目录路径是通过将innodb_data_home_dir连接到innodb_temp_data_file_path指定的路径形成的。文件大小是以KB、MB或GB（1024MB）为单位指定的，方法是在大小值后面附加K、M或G。文件大小之和必须略大于12MB。</p><p>
                The <a class="link" href="innodb-storage-engine.html#sysvar_innodb_data_home_dir"><code class="literal">innodb_data_home_dir</code></a>
                default value is the MySQL data directory
                (<a class="link" href="server-administration.html#sysvar_datadir"><code class="literal">datadir</code></a>).
            </p><p style="color:blue;">innodb_data_home_dir默认值是mysql数据目录（datadir）。</p><p>
                An autoextending temporary tablespace data file can become large
                in environments that use large temporary tables or that use
                temporary tables extensively. A large data file can also result
                from long running queries that use temporary tables. To prevent
                the temporary data file from becoming too large, configure the
                <a class="link" href="innodb-storage-engine.html#sysvar_innodb_temp_data_file_path"><code class="literal">innodb_temp_data_file_path</code></a>
                option to specify a maximum data file size. For more information
                see
                <a class="xref" href="innodb-storage-engine.html#innodb-temporary-tablespace-data-file-size" title="Managing Temporary Tablespace Data File Size">Managing Temporary Tablespace Data File Size</a>.
            </p><p style="color:blue;">在使用大型临时表或广泛使用临时表的环境中，自动扩展临时表空间数据文件可能会变大。使用临时表的长时间运行查询也可能导致大型数据文件。若要防止临时数据文件变得太大，请配置NoYbBuxTimeDATAXFILYPATH PATH选项，以指定最大数据文件大小。有关详细信息，请参见管理临时表空间数据文件大小。</p>
            </div>
            <div class="simplesect">
                <div class="titlepage">
                    <div>
                        <div class="simple">
                            <h4 class="title"><a name="innodb-startup-page-size"></a>Page Size Configuration</h4>

                        </div>

                    </div>

                </div>
                <p>
                    The <a class="link" href="innodb-storage-engine.html#sysvar_innodb_page_size"><code class="literal">innodb_page_size</code></a> option
                    specifies the page size for all <code class="literal">InnoDB</code>
                    tablespaces in a MySQL instance. This value is set when the
                    instance is created and remains constant afterward. Valid values
                    are 64KB, 32KB, 16KB (the default), 8KB, and 4KB. Alternatively,
                    you can specify page size in bytes (65536, 32768, 16384, 8192,
                    4096).
                </p><p style="color:blue;">innodb_page_size选项指定mysql实例中所有innodb表空间的页面大小。该值在创建实例时设置，之后保持不变。有效值为64KB、32KB、16KB（默认）、8KB和4KB。或者，可以指定页面大小（65536、32768、16384、8192、4096）。</p><p>
                The default page size of 16KB is appropriate for a wide range of
                workloads, particularly for queries involving table scans and
                DML operations involving bulk updates. Smaller page sizes might
                be more efficient for OLTP workloads involving many small
                writes, where contention can be an issue when a single page
                contains many rows. Smaller pages might also be efficient with
                SSD storage devices, which typically use small block sizes.
                Keeping the <code class="literal">InnoDB</code> page size close to the
                storage device block size minimizes the amount of unchanged data
                that is rewritten to disk.
            </p><p style="color:blue;">默认页面大小16kb适用于各种工作负载，特别是涉及表扫描和涉及批量更新的dml操作的查询。对于包含许多小写操作的oltp工作负载，较小的页面大小可能更有效，其中当单个页面包含许多行时，争用可能是一个问题。使用ssd存储设备（通常使用较小的块大小）时，较小的页面可能也很有效。将innodb页面大小保持在接近存储设备块大小的位置，可以最大限度地减少重写到磁盘的未更改数据量。</p>
            </div>
            <div class="simplesect">
                <div class="titlepage">
                    <div>
                        <div class="simple">
                            <h4 class="title"><a name="innodb-startup-memory-configuration"></a>Memory Configuration</h4>

                        </div>

                    </div>

                </div>
                <p>
                    MySQL allocates memory to various caches and buffers to improve
                    performance of database operations. When allocating memory for
                    <code class="literal">InnoDB</code>, always consider memory required by
                    the operating system, memory allocated to other applications,
                    and memory allocated for other MySQL buffers and caches. For
                    example, if you use <code class="literal">MyISAM</code> tables, consider
                    the amount of memory allocated for the key buffer
                    (<a class="link" href="server-administration.html#sysvar_key_buffer_size"><code class="literal">key_buffer_size</code></a>). For an
                    overview of MySQL buffers and caches, see
                    <a class="xref" href="optimization.html#memory-use" title="8.12.4.1&nbsp;How MySQL Uses Memory">Section&nbsp;8.12.4.1, “How MySQL Uses Memory”</a>.
                </p><p style="color:blue;">mysql将内存分配给不同的缓存和缓冲区，以提高数据库操作的性能。在为innodb分配内存时，始终考虑操作系统所需的内存、分配给其他应用程序的内存以及分配给其他mysql缓冲区和缓存的内存。例如，如果使用myisam表，请考虑为键缓冲区分配的内存量（键缓冲区大小）。有关mysql缓冲区和缓存的概述，请参阅8.12.4.1节“mysql如何使用内存”。</p><p>
                Buffers specific to <code class="literal">InnoDB</code> are configured
                using the following parameters:
            </p><p style="color:blue;">InnoDB特有的缓冲区使用以下参数配置：</p>
                <div class="itemizedlist">
                    <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                        <a class="link" href="innodb-storage-engine.html#sysvar_innodb_buffer_pool_size"><code class="literal">innodb_buffer_pool_size</code></a>
                        defines size of the buffer pool, which is the memory area
                        that holds cached data for <code class="literal">InnoDB</code> tables,
                        indexes, and other auxiliary buffers. The size of the buffer
                        pool is important for system performance, and it is
                        typically recommended that
                        <a class="link" href="innodb-storage-engine.html#sysvar_innodb_buffer_pool_size"><code class="literal">innodb_buffer_pool_size</code></a> is
                        configured to 50 to 75 percent of system memory. The default
                        buffer pool size is 128MB. For additional guidance, see
                        <a class="xref" href="optimization.html#memory-use" title="8.12.4.1&nbsp;How MySQL Uses Memory">Section&nbsp;8.12.4.1, “How MySQL Uses Memory”</a>. For information about how to
                        configure <code class="literal">InnoDB</code> buffer pool size, see
                        <a class="xref" href="innodb-storage-engine.html#innodb-buffer-pool-resize" title="14.8.3.1&nbsp;Configuring InnoDB Buffer Pool Size">Section&nbsp;14.8.3.1, “Configuring InnoDB Buffer Pool Size”</a>. Buffer pool
                        size can be configured at startup or dynamically.
                    </p><p style="color:blue;">NoNdBuffBuffryPoLoLyScript定义缓冲池的大小，它是为NIDB表、索引和其他辅助缓冲区保存缓存数据的内存区域。缓冲池的大小对系统性能很重要，通常建议将innodb_buffer_pool_size配置为系统内存的50%到75%。默认缓冲池大小为128MB。有关更多指导，请参阅8.12.4.1节“MySQL如何使用内存”。有关如何配置innodb缓冲池大小的信息，请参阅14.8.3.1节“配置innodb缓冲池大小”。缓冲池大小可以在启动时配置，也可以动态配置。</p><p>
                        On systems with a large amount of memory, you can improve
                        concurrency by dividing the buffer pool into multiple buffer
                        pool instances. The number of buffer pool instances is
                        controlled by the by
                        <a class="link" href="innodb-storage-engine.html#sysvar_innodb_buffer_pool_instances"><code class="literal">innodb_buffer_pool_instances</code></a>
                        option. By default, <code class="literal">InnoDB</code> creates one
                        buffer pool instance. The number of buffer pool instances
                        can be configured at startup. For more information, see
                        <a class="xref" href="innodb-storage-engine.html#innodb-multiple-buffer-pools" title="14.8.3.2&nbsp;Configuring Multiple Buffer Pool Instances">Section&nbsp;14.8.3.2, “Configuring Multiple Buffer Pool Instances”</a>.
                    </p><p style="color:blue;">在具有大量内存的系统上，可以通过将缓冲池划分为多个缓冲池实例来提高并发性。缓冲池实例的数量由innodb_buffer_pool_instances选项控制。默认情况下，innodb创建一个缓冲池实例。启动时可以配置缓冲池实例的数量。有关更多信息，请参阅第14.8.3.2节“配置多个缓冲池实例”。</p></li><li class="listitem"><p>
                        <a class="link" href="innodb-storage-engine.html#sysvar_innodb_log_buffer_size"><code class="literal">innodb_log_buffer_size</code></a>
                        defines the size in bytes of the buffer that
                        <code class="literal">InnoDB</code> uses to write to the log files on
                        disk. The default size is 16MB. A large log buffer enables
                        large transactions to run without a need to write the log to
                        disk before the transactions commit. If you have
                        transactions that update, insert, or delete many rows, you
                        might consider increasing the size of the log buffer to save
                        disk I/O.
                        <a class="link" href="innodb-storage-engine.html#sysvar_innodb_log_buffer_size"><code class="literal">innodb_log_buffer_size</code></a> can
                        be configured at startup. For related information, see
                        <a class="xref" href="optimization.html#optimizing-innodb-logging" title="8.5.4&nbsp;Optimizing InnoDB Redo Logging">Section&nbsp;8.5.4, “Optimizing InnoDB Redo Logging”</a>.
                    </p><p style="color:blue;">innodb_log_buffer_size以字节为单位定义innodb用来写入磁盘上的日志文件的缓冲区大小。默认大小为16MB。大型日志缓冲区使大型事务能够运行，而无需在事务提交之前将日志写入磁盘。如果有更新、插入或删除许多行的事务，可以考虑增大日志缓冲区的大小以保存磁盘I/O。可以在启动时配置innodb_log_buffer_size。有关信息，请参阅第8.5.4节“优化InnoDB重做日志”。</p></li></ul>
                </div>
                <div class="warning" style="margin-left: 0.5in; margin-right: 0.5in;">
                    <div class="admon-title">
                        Warning
                    </div>
                    <p>
                        On 32-bit GNU/Linux x86, be careful not to set memory usage
                        too high. <code class="literal">glibc</code> may permit the process heap
                        to grow over thread stacks, which crashes your server. It is a
                        risk if the memory allocated to the <a class="link" href="programs.html#mysqld" title="4.3.1&nbsp;mysqld — The MySQL Server"><span class="command"><strong>mysqld</strong></span></a>
                        process for global and per-thread buffers and caches is close
                        to or exceeds 2GB.
                    </p><p style="color:blue;">在32位gnu/linux x86上，注意不要设置太高的内存使用率。glibc可能允许进程堆在线程堆栈上增长，这会导致服务器崩溃。如果为全局和每线程缓冲区和缓存分配给mysqld进程的内存接近或超过2GB，则会有风险。</p><p>
                    A formula similar to the following that calculates global and
                    per-thread memory allocation for MySQL can be used to estimate
                    MySQL memory usage. You may need to modify the formula to
                    account for buffers and caches in your MySQL version and
                    configuration. For an overview of MySQL buffers and caches,
                    see <a class="xref" href="optimization.html#memory-use" title="8.12.4.1&nbsp;How MySQL Uses Memory">Section&nbsp;8.12.4.1, “How MySQL Uses Memory”</a>.
                </p><p style="color:blue;">类似于以下计算mysql全局和每线程内存分配的公式可用于估计mysql内存使用量。您可能需要修改公式，以便在mysql版本和配置中考虑缓冲区和缓存。有关mysql缓冲区和缓存的概述，请参阅8.12.4.1节“mysql如何使用内存”。</p><pre data-lang="none" class="programlisting">innodb_buffer_pool_size
+ key_buffer_size
+ max_connections*(sort_buffer_size+read_buffer_size+binlog_cache_size)
+ max_connections*2MB
</pre><p>
                    Each thread uses a stack (often 2MB, but only 256KB in MySQL
                    binaries provided by Oracle Corporation.) and in the worst
                    case also uses <code class="literal">sort_buffer_size +
                    read_buffer_size</code> additional memory.
                </p><p style="color:blue;">每个线程使用一个堆栈（通常为2MB，但Oracle公司提供的MySQL二进制文件中只有256KB），在最坏的情况下还使用sort_buffer_size+read_buffer_size附加内存。</p>
                </div>
                <p>
                    On Linux, if the kernel is enabled for large page support,
                    <code class="literal">InnoDB</code> can use large pages to allocate memory
                    for its buffer pool. See <a class="xref" href="optimization.html#large-page-support" title="8.12.4.2&nbsp;Enabling Large Page Support">Section&nbsp;8.12.4.2, “Enabling Large Page Support”</a>.
                </p><p style="color:blue;">在linux上，如果内核支持大页面，innodb可以使用大页面为其缓冲池分配内存。参见第8.12.4.2节“启用大页面支持”。</p>
            </div>

        </div>
        <div class="section">
            <div class="titlepage">
                <div>
                    <div>
                        <h3 class="title"><a name="innodb-read-only-instance"></a>14.8.2&nbsp;Configuring InnoDB for Read-Only Operation</h3>

                    </div>

                </div>

            </div>
            <p>
                You can query <code class="literal">InnoDB</code> tables where the MySQL
                data directory is on read-only media by enabling the
                <a class="link" href="innodb-storage-engine.html#sysvar_innodb_read_only"><code class="literal">--innodb-read-only</code></a> configuration
                option at server startup.
            </p><p style="color:blue;">通过在服务器启动时启用--innodb read-only配置选项，可以查询mysql数据目录位于只读媒体上的innodb表。</p>
            <h4><a name="idm140286820576160"></a>How to Enable</h4>
            <p>
                To prepare an instance for read-only operation, make sure all the
                necessary information is <a class="link" href="glossary.html#glos_flush" title="flush">flushed</a>
                to the data files before storing it on the read-only medium. Run
                the server with change buffering disabled
                (<a class="link" href="innodb-storage-engine.html#sysvar_innodb_change_buffering"><code class="literal">innodb_change_buffering=0</code></a>) and
                do a <a class="link" href="glossary.html#glos_slow_shutdown" title="slow shutdown">slow shutdown</a>.
            </p><p style="color:blue;">要为只读操作准备实例，请确保在将实例存储在只读介质上之前，将所有必需的信息刷新到数据文件中。在禁用更改缓冲的情况下运行服务器（innodb_change_buffering=0），然后缓慢关闭。</p><p>
            To enable read-only mode for an entire MySQL instance, specify the
            following configuration options at server startup:
        </p><p style="color:blue;">要为整个mysql实例启用只读模式，请在服务器启动时指定以下配置选项：</p>
            <div class="itemizedlist">
                <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                    <a class="link" href="innodb-storage-engine.html#sysvar_innodb_read_only"><code class="literal">--innodb-read-only=1</code></a>
                </p><p style="color:blue;">--InnoDB只读=1</p></li><li class="listitem"><p>
                    If the instance is on read-only media such as a DVD or CD, or
                    the <code class="filename">/var</code> directory is not writeable by
                    all:
                    <a class="link" href="server-administration.html#sysvar_pid_file"><code class="literal">--pid-file=<em class="replaceable"><code>path_on_writeable_media</code></em></code></a>
                    and
                    <a class="link" href="server-administration.html#sysvar_event_scheduler"><code class="literal">--event-scheduler=disabled</code></a>
                </p><p style="color:blue;">如果实例位于只读媒体（如DVD或CD）上，或者/var目录不可全部写入：--pid file=path\u on\u writeable\u媒体和--event scheduler=disabled</p></li><li class="listitem"><p>
                    <a class="link" href="innodb-storage-engine.html#sysvar_innodb_temp_data_file_path"><code class="literal">--innodb-temp-data-file-path</code></a>.
                    This option specifies the path, file name, and file size for
                    <code class="literal">InnoDB</code> temporary tablespace data files. The
                    default setting is <code class="literal">ibtmp1:12M:autoextend</code>,
                    which creates the <code class="filename">ibtmp1</code> temporary
                    tablespace data file in the data directory. To prepare an
                    instance for read-only operation, set
                    <a class="link" href="innodb-storage-engine.html#sysvar_innodb_temp_data_file_path"><code class="literal">innodb_temp_data_file_path</code></a> to
                    a location outside of the data directory. The path must be
                    relative to the data directory. For example:
                </p><p style="color:blue;">--InnoDB临时数据文件路径。此选项指定innodb临时表空间数据文件的路径、文件名和文件大小。默认设置是ibtmp1:12m:autoextend，它在数据目录中创建ibtmp1临时表空间数据文件。要准备只读操作的实例，请将innodb临时数据文件路径设置为数据目录之外的位置。路径必须相对于数据目录。例如：</p><pre data-lang="terminal" class="programlisting">--innodb-temp-data-file-path=../../../tmp/ibtmp1:12M:autoextend
</pre></li></ul>
            </div>
            <h4><a name="idm140286820557744"></a>Usage Scenarios</h4>
            <p>
                This mode of operation is appropriate in situations such as:
            </p><p style="color:blue;">这种操作模式适用于以下情况：</p>
            <div class="itemizedlist">
                <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                    Distributing a MySQL application, or a set of MySQL data, on a
                    read-only storage medium such as a DVD or CD.
                </p><p style="color:blue;">在只读存储介质（如DVD或CD）上分发MySQL应用程序或一组MySQL数据。</p></li><li class="listitem"><p>
                    Multiple MySQL instances querying the same data directory
                    simultaneously, typically in a data warehousing configuration.
                    You might use this technique to avoid
                    <a class="link" href="glossary.html#glos_bottleneck" title="bottleneck">bottlenecks</a> that can
                    occur with a heavily loaded MySQL instance, or you might use
                    different configuration options for the various instances to
                    tune each one for particular kinds of queries.
                </p><p style="color:blue;">多个mysql实例同时查询同一个数据目录，通常在数据仓库配置中。您可以使用此技术来避免重载mysql实例可能出现的瓶颈，也可以使用不同实例的不同配置选项来针对特定类型的查询优化每个实例。</p></li><li class="listitem"><p>
                    Querying data that has been put into a read-only state for
                    security or data integrity reasons, such as archived backup
                    data.
                </p><p style="color:blue;">查询出于安全或数据完整性原因而处于只读状态的数据，例如存档的备份数据。</p></li></ul>
            </div>
            <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">
                <div class="admon-title">
                    Note
                </div>
                <p>
                    This feature is mainly intended for flexibility in distribution
                    and deployment, rather than raw performance based on the
                    read-only aspect. See
                    <a class="xref" href="optimization.html#innodb-performance-ro-txn" title="8.5.3&nbsp;Optimizing InnoDB Read-Only Transactions">Section&nbsp;8.5.3, “Optimizing InnoDB Read-Only Transactions”</a> for ways to tune the
                    performance of read-only queries, which do not require making
                    the entire server read-only.
                </p><p style="color:blue;">此特性主要用于分发和部署的灵活性，而不是基于只读方面的原始性能。请参阅8.5.3节“优化innodb只读事务”以了解优化只读查询性能的方法，这些查询不需要将整个服务器设为只读。</p>
            </div>
            <h4><a name="idm140286820550464"></a>How It Works</h4>
            <p>
                When the server is run in read-only mode through the
                <a class="link" href="innodb-storage-engine.html#sysvar_innodb_read_only"><code class="literal">--innodb-read-only</code></a> option,
                certain <code class="literal">InnoDB</code> features and components are
                reduced or turned off entirely:
            </p><p style="color:blue;">当服务器通过--innodb read-only选项以只读模式运行时，某些innodb特性和组件会减少或完全关闭：</p>
            <div class="itemizedlist">
                <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                    No <a class="link" href="glossary.html#glos_change_buffering" title="change buffering">change
                    buffering</a> is done, in particular no merges from the
                    change buffer. To make sure the change buffer is empty when
                    you prepare the instance for read-only operation, disable
                    change buffering
                    (<a class="link" href="innodb-storage-engine.html#sysvar_innodb_change_buffering"><code class="literal">innodb_change_buffering=0</code></a>)
                    and do a <a class="link" href="glossary.html#glos_slow_shutdown" title="slow shutdown">slow
                    shutdown</a> first.
                </p><p style="color:blue;">不进行更改缓冲，特别是不从更改缓冲区进行合并。要确保在为只读操作准备实例时更改缓冲区是空的，请禁用更改缓冲区（innodb_change_buffering=0）并先缓慢关闭。</p></li><li class="listitem"><p>
                    There is no <a class="link" href="glossary.html#glos_crash_recovery" title="crash recovery">crash
                    recovery</a> phase at startup. The instance must have
                    performed a <a class="link" href="glossary.html#glos_slow_shutdown" title="slow shutdown">slow
                    shutdown</a> before being put into the read-only state.
                </p><p style="color:blue;">启动时没有崩溃恢复阶段。在将实例置于只读状态之前，该实例必须执行了慢速关闭。</p></li><li class="listitem"><p>
                    Because the <a class="link" href="glossary.html#glos_redo_log" title="redo log">redo log</a> is
                    not used in read-only operation, you can set
                    <a class="link" href="innodb-storage-engine.html#sysvar_innodb_log_file_size"><code class="literal">innodb_log_file_size</code></a> to the
                    smallest size possible (1 MB) before making the instance
                    read-only.
                </p><p style="color:blue;">由于重做日志不用于只读操作，因此在将实例设置为只读之前，可以将innodb_log_file_size设置为可能的最小大小（1 MB）。</p></li><li class="listitem"><p>
                    Most background threads are turned off. I/O read threads
                    remain, as well as I/O write threads and a page cleaner thread
                    for writes to temporary files, which are permitted in
                    read-only mode.
                </p><p style="color:blue;">大多数后台线程已关闭。I/O读线程、I/O写线程和用于写入临时文件的页面清理线程（在只读模式下是允许的）。</p></li><li class="listitem"><p>
                    Information about deadlocks, monitor output, and so on is not
                    written to temporary files. As a consequence,
                    <a class="link" href="sql-syntax.html#show-engine" title="13.7.5.15&nbsp;SHOW ENGINE Syntax"><code class="literal">SHOW ENGINE
                        INNODB STATUS</code></a> does not produce any output.
                </p><p style="color:blue;">有关死锁、监视器输出等的信息不会写入临时文件。因此，show engine innodb status不产生任何输出。</p></li><li class="listitem"><p>
                    If the MySQL server is started with
                    <a class="link" href="innodb-storage-engine.html#sysvar_innodb_read_only"><code class="literal">--innodb-read-only</code></a> but the
                    data directory is still on writeable media, the root user can
                    still perform <a class="link" href="glossary.html#glos_dcl" title="DCL">DCL</a> operations
                    such as <a class="link" href="sql-syntax.html#grant" title="13.7.1.4&nbsp;GRANT Syntax"><code class="literal">GRANT</code></a> and
                    <a class="link" href="sql-syntax.html#revoke" title="13.7.1.6&nbsp;REVOKE Syntax"><code class="literal">REVOKE</code></a>.
                </p><p style="color:blue;">如果mysql服务器是以--innodb read only启动的，但是数据目录仍然在可写媒体上，那么根用户仍然可以执行诸如grant和revoke之类的dcl操作。</p></li><li class="listitem"><p>
                    Changes to configuration option settings that would normally
                    change the behavior of write operations, have no effect when
                    the server is in read-only mode.
                </p><p style="color:blue;">对配置选项设置的更改通常会更改写入操作的行为，但在服务器处于只读模式时无效。</p></li><li class="listitem"><p>
                    The <a class="link" href="glossary.html#glos_mvcc" title="MVCC">MVCC</a> processing to
                    enforce <a class="link" href="glossary.html#glos_isolation_level" title="isolation level">isolation
                    levels</a> is turned off. All queries read the latest
                    version of a record, because update and deletes are not
                    possible.
                </p><p style="color:blue;">用于强制隔离级别的mvcc处理已关闭。所有查询都读取记录的最新版本，因为无法进行更新和删除。</p></li><li class="listitem"><p>
                    The <a class="link" href="glossary.html#glos_undo_log" title="undo log">undo log</a> is not used.
                    Disable any settings for the
                    <a class="link" href="innodb-storage-engine.html#sysvar_innodb_undo_tablespaces"><code class="literal">innodb_undo_tablespaces</code></a> and
                    <a class="link" href="innodb-storage-engine.html#sysvar_innodb_undo_directory"><code class="literal">innodb_undo_directory</code></a>
                    configuration options.
                </p><p style="color:blue;">未使用撤消日志。禁用innodb_undo_表空间和innodb_undo_目录配置选项的任何设置。</p></li></ul>
            </div>

        </div>
        <div class="section">
            <div class="titlepage">
                <div>
                    <div>
                        <h3 class="title"><a name="innodb-performance-buffer-pool"></a>14.8.3&nbsp;InnoDB Buffer Pool Configuration</h3>

                    </div>

                </div>

            </div>
            <div class="toc">
                <dl class="toc"><dt><span class="section"><a href="innodb-storage-engine.html#innodb-buffer-pool-resize">14.8.3.1 Configuring InnoDB Buffer Pool Size</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-multiple-buffer-pools">14.8.3.2 Configuring Multiple Buffer Pool Instances</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-performance-midpoint_insertion">14.8.3.3 Making the Buffer Pool Scan Resistant</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-performance-read_ahead">14.8.3.4 Configuring InnoDB Buffer Pool Prefetching (Read-Ahead)</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-buffer-pool-flushing">14.8.3.5 Configuring Buffer Pool Flushing</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-preload-buffer-pool">14.8.3.6 Saving and Restoring the Buffer Pool State</a></span></dt></dl>
            </div>
            <p>
                This section provides configuration and tuning information for the
                <code class="literal">InnoDB</code> buffer pool.
            </p><p style="color:blue;">本节提供了innodb缓冲池的配置和调优信息。</p>
            <div class="section">

                <div class="titlepage">
                    <div>
                        <div>
                            <h4 class="title"><a name="innodb-buffer-pool-resize"></a>14.8.3.1&nbsp;Configuring InnoDB Buffer Pool Size</h4>
                        </div>
                    </div>
                </div>
                <a class="indexterm" name="idm140286820517040"></a><a class="indexterm" name="idm140286820515968"></a><a class="indexterm" name="idm140286820514896"></a><p>
                You can configure <code class="literal">InnoDB</code> buffer pool size
                offline (at startup) or online, while the server is running.
                Behavior described in this section applies to both methods. For
                additional information about configuring buffer pool size
                online, see <a class="xref" href="innodb-storage-engine.html#innodb-buffer-pool-online-resize" title="Configuring InnoDB Buffer Pool Size Online">Configuring InnoDB Buffer Pool Size Online</a>.
            </p><p style="color:blue;">您可以在服务器运行时离线（启动时）或在线配置innodb缓冲池大小。本节中描述的行为适用于这两种方法。有关联机配置缓冲池大小的更多信息，请参阅联机配置innodb缓冲池大小。</p><p>
                When increasing or decreasing
                <a class="link" href="innodb-storage-engine.html#sysvar_innodb_buffer_pool_size"><code class="literal">innodb_buffer_pool_size</code></a>, the
                operation is performed in chunks. Chunk size is defined by the
                <a class="link" href="innodb-storage-engine.html#sysvar_innodb_buffer_pool_chunk_size"><code class="literal">innodb_buffer_pool_chunk_size</code></a>
                configuration option, which has a default of
                <code class="literal">128M</code>. For more information, see
                <a class="xref" href="innodb-storage-engine.html#innodb-buffer-pool-chunk-size" title="Configuring InnoDB Buffer Pool Chunk Size">Configuring InnoDB Buffer Pool Chunk Size</a>.
            </p><p style="color:blue;">当增大或减小innodb_buffer_pool_大小时，该操作将分块执行。块大小由innodb_buffer_pool_chunk_size配置选项定义，默认值为128m。有关更多信息，请参阅配置innodb buffer pool chunk size。</p><p>
                Buffer pool size must always be equal to or a multiple of
                <a class="link" href="innodb-storage-engine.html#sysvar_innodb_buffer_pool_chunk_size"><code class="literal">innodb_buffer_pool_chunk_size</code></a> *
                <a class="link" href="innodb-storage-engine.html#sysvar_innodb_buffer_pool_instances"><code class="literal">innodb_buffer_pool_instances</code></a>.
                If you configure
                <a class="link" href="innodb-storage-engine.html#sysvar_innodb_buffer_pool_size"><code class="literal">innodb_buffer_pool_size</code></a> to a
                value that is not equal to or a multiple of
                <a class="link" href="innodb-storage-engine.html#sysvar_innodb_buffer_pool_chunk_size"><code class="literal">innodb_buffer_pool_chunk_size</code></a> *
                <a class="link" href="innodb-storage-engine.html#sysvar_innodb_buffer_pool_instances"><code class="literal">innodb_buffer_pool_instances</code></a>,
                buffer pool size is automatically adjusted to a value that is
                equal to or a multiple of
                <a class="link" href="innodb-storage-engine.html#sysvar_innodb_buffer_pool_chunk_size"><code class="literal">innodb_buffer_pool_chunk_size</code></a> *
                <a class="link" href="innodb-storage-engine.html#sysvar_innodb_buffer_pool_instances"><code class="literal">innodb_buffer_pool_instances</code></a>.
            </p><p style="color:blue;">缓冲池大小必须始终等于或是innodb_buffer_pool_chunk_size*innodb_buffer_pool_instances的倍数。如果将innodb_buffer_pool_size配置为不等于或不等于innodb_buffer_pool_chunk_size*innodb_buffer pool_instances的值，缓冲池大小将自动调整为等于或等于innodb_buffer_pool_chunk_size*innodb_buffer pool_instances的值。</p><p>
                In the following example,
                <a class="link" href="innodb-storage-engine.html#sysvar_innodb_buffer_pool_size"><code class="literal">innodb_buffer_pool_size</code></a> is set
                to <code class="literal">8G</code>, and
                <a class="link" href="innodb-storage-engine.html#sysvar_innodb_buffer_pool_instances"><code class="literal">innodb_buffer_pool_instances</code></a> is
                set to <code class="literal">16</code>.
                <a class="link" href="innodb-storage-engine.html#sysvar_innodb_buffer_pool_chunk_size"><code class="literal">innodb_buffer_pool_chunk_size</code></a>
                is <code class="literal">128M</code>, which is the default value.
            </p><p style="color:blue;">在下面的例子中，innodb_buffer_pool_size设置为8g，innodb_buffer_pool_instances设置为16。innodb_buffer_pool_chunk_size为128m，为默认值。</p><p>
                <code class="literal">8G</code> is a valid
                <a class="link" href="innodb-storage-engine.html#sysvar_innodb_buffer_pool_size"><code class="literal">innodb_buffer_pool_size</code></a> value
                because <code class="literal">8G</code> is a multiple of
                <a class="link" href="innodb-storage-engine.html#sysvar_innodb_buffer_pool_instances"><code class="literal">innodb_buffer_pool_instances=16</code></a>
                *
                <a class="link" href="innodb-storage-engine.html#sysvar_innodb_buffer_pool_chunk_size"><code class="literal">innodb_buffer_pool_chunk_size=128M</code></a>,
                which is <code class="literal">2G</code>.
            </p><p style="color:blue;">8g是一个有效的innodb_buffer_pool_size值，因为8g是innodb_buffer_pool_instances=16*innodb_buffer_pool_chunk_size=128m的倍数，即2g。</p><pre data-lang="ini" class="programlisting">shell&gt; <strong class="userinput"><code>mysqld --innodb-buffer-pool-size=8G --innodb-buffer-pool-instances=16</code></strong>
</pre><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT @@innodb_buffer_pool_size/1024/1024/1024;</code></strong>
+------------------------------------------+
| @@innodb_buffer_pool_size/1024/1024/1024 |
+------------------------------------------+
|                           8.000000000000 |
+------------------------------------------+
</pre><p>
                In this example,
                <a class="link" href="innodb-storage-engine.html#sysvar_innodb_buffer_pool_size"><code class="literal">innodb_buffer_pool_size</code></a> is set
                to <code class="literal">9G</code>, and
                <a class="link" href="innodb-storage-engine.html#sysvar_innodb_buffer_pool_instances"><code class="literal">innodb_buffer_pool_instances</code></a> is
                set to <code class="literal">16</code>.
                <a class="link" href="innodb-storage-engine.html#sysvar_innodb_buffer_pool_chunk_size"><code class="literal">innodb_buffer_pool_chunk_size</code></a>
                is <code class="literal">128M</code>, which is the default value. In this
                case, <code class="literal">9G</code> is not a multiple of
                <a class="link" href="innodb-storage-engine.html#sysvar_innodb_buffer_pool_instances"><code class="literal">innodb_buffer_pool_instances=16</code></a>
                *
                <a class="link" href="innodb-storage-engine.html#sysvar_innodb_buffer_pool_chunk_size"><code class="literal">innodb_buffer_pool_chunk_size=128M</code></a>,
                so <a class="link" href="innodb-storage-engine.html#sysvar_innodb_buffer_pool_size"><code class="literal">innodb_buffer_pool_size</code></a> is
                adjusted to <code class="literal">10G</code>, which is a multiple of
                <a class="link" href="innodb-storage-engine.html#sysvar_innodb_buffer_pool_chunk_size"><code class="literal">innodb_buffer_pool_chunk_size</code></a> *
                <a class="link" href="innodb-storage-engine.html#sysvar_innodb_buffer_pool_instances"><code class="literal">innodb_buffer_pool_instances</code></a>.
            </p><p style="color:blue;">在本例中，innodb_buffer_pool_size设置为9g，innodb_buffer_pool_instances设置为16。innodb_buffer_pool_chunk_size为128m，为默认值。在这种情况下，9g不是innodb_buffer_instances=16*innodb_buffer_pool_chunk_size=128m的倍数，所以innodb_buffer_pool_size调整为10g，这是innodb_buffer_pool_chunk_size*innodb_buffer_pool_instances的倍数。</p><pre data-lang="terminal" class="programlisting">shell&gt; <strong class="userinput"><code>mysqld --innodb-buffer-pool-size=9G --innodb-buffer-pool-instances=16</code></strong>
</pre><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT @@innodb_buffer_pool_size/1024/1024/1024;</code></strong>
+------------------------------------------+
| @@innodb_buffer_pool_size/1024/1024/1024 |
+------------------------------------------+
|                          10.000000000000 |
+------------------------------------------+
</pre>
                <div class="simplesect">

                    <div class="titlepage">
                        <div>

                            <div class="simple">
                                <h5 class="title"><a name="innodb-buffer-pool-chunk-size"></a>Configuring InnoDB Buffer Pool Chunk Size</h5>
                            </div>
                        </div>
                    </div>
                    <p>
                        <a class="link" href="innodb-storage-engine.html#sysvar_innodb_buffer_pool_chunk_size"><code class="literal">innodb_buffer_pool_chunk_size</code></a>
                        can be increased or decreased in 1MB (1048576 byte) units but
                        can only be modified at startup, in a command line string or
                        in a MySQL configuration file.
                    </p><p style="color:blue;">innodb_buffer_pool_chunk_size可以以1MB（1048576 byte）为单位增加或减少，但只能在启动时、命令行字符串或MySQL配置文件中修改。</p><p>
                    Command line:
                </p><p style="color:blue;">命令行：</p><pre data-lang="terminal" class="programlisting">shell&gt; <strong class="userinput"><code>mysqld --innodb-buffer-pool-chunk-size=134217728</code></strong>
</pre><p>
                    Configuration file:
                </p><p style="color:blue;">配置文件：</p><pre data-lang="ini" class="programlisting">[mysqld]
innodb_buffer_pool_chunk_size=134217728
</pre><p>
                    The following conditions apply when altering
                    <a class="link" href="innodb-storage-engine.html#sysvar_innodb_buffer_pool_chunk_size"><code class="literal">innodb_buffer_pool_chunk_size</code></a>:
                </p><p style="color:blue;">更改innodb_buffer_pool_chunk_大小时适用以下条件：</p>
                    <div class="itemizedlist">
                        <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                            If the new <a class="link" href="innodb-storage-engine.html#sysvar_innodb_buffer_pool_chunk_size"><code class="literal">
                            innodb_buffer_pool_chunk_size</code></a> value *
                            <a class="link" href="innodb-storage-engine.html#sysvar_innodb_buffer_pool_instances"><code class="literal">innodb_buffer_pool_instances</code></a>
                            is larger than the current buffer pool size when the
                            buffer pool is initialized,
                            <a class="link" href="innodb-storage-engine.html#sysvar_innodb_buffer_pool_chunk_size"><code class="literal">innodb_buffer_pool_chunk_size</code></a>
                            is truncated to
                            <a class="link" href="innodb-storage-engine.html#sysvar_innodb_buffer_pool_size"><code class="literal">innodb_buffer_pool_size</code></a> /
                            <a class="link" href="innodb-storage-engine.html#sysvar_innodb_buffer_pool_instances"><code class="literal">innodb_buffer_pool_instances</code></a>.
                        </p><p style="color:blue;">如果新的innodb_buffer_pool_chunk_size值*innodb_buffer_pool_实例在初始化缓冲池时大于当前缓冲池大小，则innodb_buffer_pool_chunk_大小将被截断为innodb_buffer_pool/innodb_buffer_pool_实例。</p><p>
                            For example, if the buffer pool is initialized with a size
                            of <code class="literal">2GB</code> (2147483648 bytes),
                            <code class="literal">4</code> buffer pool instances, and a chunk
                            size of <code class="literal">1GB</code> (1073741824 bytes), chunk
                            size is truncated to a value equal to
                            <a class="link" href="innodb-storage-engine.html#sysvar_innodb_buffer_pool_size"><code class="literal">innodb_buffer_pool_size</code></a> /
                            <a class="link" href="innodb-storage-engine.html#sysvar_innodb_buffer_pool_instances"><code class="literal">innodb_buffer_pool_instances</code></a>,
                            as shown below:
                        </p><p style="color:blue;">例如，如果缓冲池初始化为2GB（2147483648字节）、4个缓冲池实例和1GB（1073741824字节）块大小，则块大小将被截断为等于innodb_buffer_pool_size/innodb_buffer_pool_instances的值，如下所示：</p><pre data-lang="terminal" class="programlisting">shell&gt; <strong class="userinput"><code>mysqld --innodb-buffer-pool-size=2147483648 --innodb-buffer-pool-instances=4</code></strong>
<strong class="userinput"><code>--innodb-buffer-pool-chunk-size=1073741824;</code></strong>
</pre><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT @@innodb_buffer_pool_size;</code></strong>
+---------------------------+
| @@innodb_buffer_pool_size |
+---------------------------+
|                2147483648 |
+---------------------------+

mysql&gt; <strong class="userinput"><code>SELECT @@innodb_buffer_pool_instances;</code></strong>
+--------------------------------+
| @@innodb_buffer_pool_instances |
+--------------------------------+
|                              4 |
+--------------------------------+

# Chunk size was set to 1GB (1073741824 bytes) on startup but was
# truncated to innodb_buffer_pool_size / innodb_buffer_pool_instances

mysql&gt; <strong class="userinput"><code>SELECT @@innodb_buffer_pool_chunk_size;</code></strong>
+---------------------------------+
| @@innodb_buffer_pool_chunk_size |
+---------------------------------+
|                       536870912 |
+---------------------------------+
</pre></li><li class="listitem"><p>
                            Buffer pool size must always be equal to or a multiple of
                            <a class="link" href="innodb-storage-engine.html#sysvar_innodb_buffer_pool_chunk_size"><code class="literal">innodb_buffer_pool_chunk_size</code></a>
                            *
                            <a class="link" href="innodb-storage-engine.html#sysvar_innodb_buffer_pool_instances"><code class="literal">innodb_buffer_pool_instances</code></a>.
                            If you alter
                            <a class="link" href="innodb-storage-engine.html#sysvar_innodb_buffer_pool_chunk_size"><code class="literal">innodb_buffer_pool_chunk_size</code></a>,
                            <a class="link" href="innodb-storage-engine.html#sysvar_innodb_buffer_pool_size"><code class="literal">innodb_buffer_pool_size</code></a>
                            is automatically adjusted to a value that is equal to or a
                            multiple of
                            <a class="link" href="innodb-storage-engine.html#sysvar_innodb_buffer_pool_chunk_size"><code class="literal">innodb_buffer_pool_chunk_size</code></a>
                            *
                            <a class="link" href="innodb-storage-engine.html#sysvar_innodb_buffer_pool_instances"><code class="literal">innodb_buffer_pool_instances</code></a>.
                            The adjustment occurs when the buffer pool is initialized.
                            This behavior is demonstrated in the following example:
                        </p><p style="color:blue;">缓冲池大小必须始终等于或是innodb_buffer_pool_chunk_size*innodb_buffer_pool_instances的倍数。如果更改innodb_buffer_pool_chunk_大小，innodb_buffer_pool_大小将自动调整为等于或是innodb_buffer_pool_chunk_大小*innodb_buffer_pool_实例的倍数的值。在初始化缓冲池时进行调整。此行为在以下示例中演示：</p><pre data-lang="sql" class="programlisting"># The buffer pool has a default size of 128MB (134217728 bytes)

mysql&gt; <strong class="userinput"><code>SELECT @@innodb_buffer_pool_size;</code></strong>
+---------------------------+
| @@innodb_buffer_pool_size |
+---------------------------+
|                 134217728 |
+---------------------------+

# The chunk size is also 128MB (134217728 bytes)

mysql&gt; <strong class="userinput"><code>SELECT @@innodb_buffer_pool_chunk_size;</code></strong>
+---------------------------------+
| @@innodb_buffer_pool_chunk_size |
+---------------------------------+
|                       134217728 |
+---------------------------------+

# There is a single buffer pool instance

mysql&gt; <strong class="userinput"><code>SELECT @@innodb_buffer_pool_instances;</code></strong>
+--------------------------------+
| @@innodb_buffer_pool_instances |
+--------------------------------+
|                              1 |
+--------------------------------+

# Chunk size is decreased by 1MB (1048576 bytes) at startup
# (134217728 - 1048576 = 133169152):

shell&gt; <strong class="userinput"><code>mysqld --innodb-buffer-pool-chunk-size=133169152</code></strong>

mysql&gt; <strong class="userinput"><code>SELECT @@innodb_buffer_pool_chunk_size;</code></strong>
+---------------------------------+
| @@innodb_buffer_pool_chunk_size |
+---------------------------------+
|                       133169152 |
+---------------------------------+

# Buffer pool size increases from 134217728 to 266338304
# Buffer pool size is automatically adjusted to a value that is equal to
# or a multiple of innodb_buffer_pool_chunk_size * innodb_buffer_pool_instances

mysql&gt; <strong class="userinput"><code>SELECT @@innodb_buffer_pool_size;</code></strong>
+---------------------------+
| @@innodb_buffer_pool_size |
+---------------------------+
|                 266338304 |
+---------------------------+</pre><p>
                            This example demonstrates the same behavior but with
                            multiple buffer pool instances:
                        </p><p style="color:blue;">此示例演示了相同的行为，但有多个缓冲池实例：</p><pre data-lang="sql" class="programlisting"># The buffer pool has a default size of 2GB (2147483648 bytes)

mysql&gt; <strong class="userinput"><code>SELECT @@innodb_buffer_pool_size;</code></strong>
+---------------------------+
| @@innodb_buffer_pool_size |
+---------------------------+
|                2147483648 |
+---------------------------+

# The chunk size is .5 GB (536870912 bytes)

mysql&gt; <strong class="userinput"><code>SELECT @@innodb_buffer_pool_chunk_size;</code></strong>
+---------------------------------+
| @@innodb_buffer_pool_chunk_size |
+---------------------------------+
|                       536870912 |
+---------------------------------+

# There are 4 buffer pool instances

mysql&gt; <strong class="userinput"><code>SELECT @@innodb_buffer_pool_instances;</code></strong>
+--------------------------------+
| @@innodb_buffer_pool_instances |
+--------------------------------+
|                              4 |
+--------------------------------+

# Chunk size is decreased by 1MB (1048576 bytes) at startup
# (536870912 - 1048576 = 535822336):

shell&gt; <strong class="userinput"><code>mysqld --innodb-buffer-pool-chunk-size=535822336</code></strong>

mysql&gt; <strong class="userinput"><code>SELECT @@innodb_buffer_pool_chunk_size;</code></strong>
+---------------------------------+
| @@innodb_buffer_pool_chunk_size |
+---------------------------------+
|                       535822336 |
+---------------------------------+

# Buffer pool size increases from 2147483648 to 4286578688
# Buffer pool size is automatically adjusted to a value that is equal to
# or a multiple of innodb_buffer_pool_chunk_size * innodb_buffer_pool_instances

mysql&gt; <strong class="userinput"><code>SELECT @@innodb_buffer_pool_size;</code></strong>
+---------------------------+
| @@innodb_buffer_pool_size |
+---------------------------+
|                4286578688 |
+---------------------------+
</pre><p>
                            Care should be taken when changing
                            <a class="link" href="innodb-storage-engine.html#sysvar_innodb_buffer_pool_chunk_size"><code class="literal">innodb_buffer_pool_chunk_size</code></a>,
                            as changing this value can increase the size of the buffer
                            pool, as shown in the examples above. Before you change
                            <a class="link" href="innodb-storage-engine.html#sysvar_innodb_buffer_pool_chunk_size"><code class="literal">innodb_buffer_pool_chunk_size</code></a>,
                            calculate the effect on
                            <a class="link" href="innodb-storage-engine.html#sysvar_innodb_buffer_pool_size"><code class="literal">innodb_buffer_pool_size</code></a>
                            to ensure that the resulting buffer pool size is
                            acceptable.
                        </p><p style="color:blue;">更改innodb_buffer_pool_chunk_size时应小心，因为更改此值会增加缓冲池的大小，如上面的示例所示。在更改innodb_buffer_pool_chunk_大小之前，请计算对innodb_buffer_pool_大小的影响，以确保生成的缓冲池大小是可接受的。</p></li></ul>
                    </div>
                    <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">
                        <div class="admon-title">
                            Note
                        </div>
                        <p>
                            To avoid potential performance issues, the number of chunks
                            (<a class="link" href="innodb-storage-engine.html#sysvar_innodb_buffer_pool_size"><code class="literal">innodb_buffer_pool_size</code></a> /
                            <a class="link" href="innodb-storage-engine.html#sysvar_innodb_buffer_pool_chunk_size"><code class="literal">innodb_buffer_pool_chunk_size</code></a>)
                            should not exceed 1000.
                        </p><p style="color:blue;">为了避免潜在的性能问题，块的数量（innodb_buffer_pool_size/innodb_buffer_pool_chunk_size）不应超过1000。</p>
                    </div>

                </div>
                <div class="simplesect">
                    <div class="titlepage">
                        <div>
                            <div class="simple">
                                <h5 class="title"><a name="innodb-buffer-pool-online-resize"></a>Configuring InnoDB Buffer Pool Size Online</h5>

                            </div>

                        </div>

                    </div>
                    <p>
                        The <a class="link" href="innodb-storage-engine.html#sysvar_innodb_buffer_pool_size"><code class="literal">innodb_buffer_pool_size</code></a>
                        configuration option can be set dynamically using a
                        <a class="link" href="data-types.html#set" title="11.4.5&nbsp;The SET Type"><code class="literal">SET</code></a> statement, allowing you to
                        resize the buffer pool without restarting the server. For
                        example:
                    </p><p style="color:blue;">innodb_buffer_pool_size配置选项可以使用set语句动态设置，允许您在不重新启动服务器的情况下调整缓冲池的大小。例如：</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>SET GLOBAL innodb_buffer_pool_size=402653184;</code></strong>
</pre><p>
                    Active transactions and operations performed through
                    <code class="literal">InnoDB</code> APIs should be completed before
                    resizing the buffer pool. When initiating a resizing
                    operation, the operation does not start until all active
                    transactions are completed. Once the resizing operation is in
                    progress, new transactions and operations that require access
                    to the buffer pool must wait until the resizing operation
                    finishes. The exception to the rule is that concurrent access
                    to the buffer pool is permitted while the buffer pool is
                    defragmented and pages are withdrawn when buffer pool size is
                    decreased. A drawback of allowing concurrent access is that it
                    could result in a temporary shortage of available pages while
                    pages are being withdrawn.
                </p><p style="color:blue;">在调整缓冲池大小之前，应该完成通过innodb api执行的活动事务和操作。启动调整大小操作时，在所有活动事务完成之前，操作不会启动。一旦正在进行调整大小操作，需要访问缓冲池的新事务和操作必须等到调整大小操作完成。该规则的例外情况是，在对缓冲池进行碎片整理并在缓冲池大小减小时撤回页面时，允许并发访问缓冲池。允许并发访问的一个缺点是，它可能导致在撤回页面时暂时缺少可用页面。</p>
                    <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">

                        <div class="admon-title">
                            Note
                        </div>
                        <p>
                            Nested transactions could fail if initiated after the buffer
                            pool resizing operation begins.
                        </p><p style="color:blue;">如果在缓冲池大小调整操作开始后启动，则嵌套事务可能会失败。</p>
                    </div>

                </div>
                <div class="simplesect">
                    <div class="titlepage">
                        <div>
                            <div class="simple">
                                <h5 class="title"><a name="innodb-buffer-pool-online-resize-monitoring"></a>Monitoring Online Buffer Pool Resizing Progress</h5>

                            </div>

                        </div>

                    </div>
                    <a class="indexterm" name="idm140286820392192"></a><a class="indexterm" name="idm140286820390704"></a><p>
                    The
                    <a class="link" href="server-administration.html#statvar_Innodb_buffer_pool_resize_status"><code class="literal">Innodb_buffer_pool_resize_status</code></a>
                    reports buffer pool resizing progress. For example:
                </p><p style="color:blue;">innodb_buffer_pool_resize_状态报告缓冲池大小调整进度。例如：</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>SHOW STATUS WHERE Variable_name='InnoDB_buffer_pool_resize_status';</code></strong>
+----------------------------------+----------------------------------+
| Variable_name                    | Value                            |
+----------------------------------+----------------------------------+
| Innodb_buffer_pool_resize_status | Resizing also other hash tables. |
+----------------------------------+----------------------------------+
</pre><p>
                    Buffer pool resizing progress is also logged in the server
                    error log. This example shows notes that are logged when
                    increasing the size of the buffer pool:
                </p><p style="color:blue;">缓冲池大小调整进度也记录在服务器错误日志中。此示例显示在增加缓冲池大小时记录的注释：</p><pre data-lang="terminal" class="programlisting">[Note] InnoDB: Resizing buffer pool from 134217728 to 4294967296. (unit=134217728)
[Note] InnoDB: disabled adaptive hash index.
[Note] InnoDB: buffer pool 0 : 31 chunks (253952 blocks) was added.
[Note] InnoDB: buffer pool 0 : hash tables were resized.
[Note] InnoDB: Resized hash tables at lock_sys, adaptive hash index, dictionary.
[Note] InnoDB: completed to resize buffer pool from 134217728 to 4294967296.
[Note] InnoDB: re-enabled adaptive hash index.
</pre><p>
                    This example shows notes that are logged when decreasing the
                    size of the buffer pool:
                </p><p style="color:blue;">此示例显示在减小缓冲池大小时记录的注释：</p><pre data-lang="terminal" class="programlisting">[Note] InnoDB: Resizing buffer pool from 4294967296 to 134217728. (unit=134217728)
[Note] InnoDB: disabled adaptive hash index.
[Note] InnoDB: buffer pool 0 : start to withdraw the last 253952 blocks.
[Note] InnoDB: buffer pool 0 : withdrew 253952 blocks from free list. tried to relocate 0 pages.
(253952/253952)
[Note] InnoDB: buffer pool 0 : withdrawn target 253952 blocks.
[Note] InnoDB: buffer pool 0 : 31 chunks (253952 blocks) was freed.
[Note] InnoDB: buffer pool 0 : hash tables were resized.
[Note] InnoDB: Resized hash tables at lock_sys, adaptive hash index, dictionary.
[Note] InnoDB: completed to resize buffer pool from 4294967296 to 134217728.
[Note] InnoDB: re-enabled adaptive hash index.
</pre>
                </div>
                <div class="simplesect">
                    <div class="titlepage">
                        <div>
                            <div class="simple">
                                <h5 class="title"><a name="innodb-buffer-pool-online-resize-internals"></a>Online Buffer Pool Resizing Internals</h5>

                            </div>

                        </div>

                    </div>
                    <p>
                        The resizing operation is performed by a background thread.
                        When increasing the size of the buffer pool, the resizing
                        operation:
                    </p><p style="color:blue;">调整大小操作由后台线程执行。增大缓冲池大小时，调整大小操作：</p>
                    <div class="itemizedlist">
                        <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                            Adds pages in <code class="literal">chunks</code> (chunk size is
                            defined by
                            <a class="link" href="innodb-storage-engine.html#sysvar_innodb_buffer_pool_chunk_size"><code class="literal">innodb_buffer_pool_chunk_size</code></a>)
                        </p><p style="color:blue;">以块的形式添加页面（块大小由innodb_buffer_pool_chunk_size定义）</p></li><li class="listitem"><p>
                            Coverts hash tables, lists, and pointers to use new
                            addresses in memory
                        </p><p style="color:blue;">转换哈希表、列表和指针以在内存中使用新地址</p></li><li class="listitem"><p>
                            Adds new pages to the free list
                        </p><p style="color:blue;">将新页面添加到免费列表</p></li></ul>
                    </div>
                    <p>
                        While these operations are in progress, other threads are
                        blocked from accessing the buffer pool.
                    </p><p style="color:blue;">当这些操作正在进行时，其他线程将被阻止访问缓冲池。</p><p>
                    When decreasing the size of the buffer pool, the resizing
                    operation:
                </p><p style="color:blue;">减小缓冲池大小时，调整大小操作：</p>
                    <div class="itemizedlist">
                        <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                            Defragments the buffer pool and withdraws (frees) pages
                        </p><p style="color:blue;">对缓冲池进行碎片整理并提取（释放）页</p></li><li class="listitem"><p>
                            Removes pages in <code class="literal">chunks</code> (chunk size is
                            defined by
                            <a class="link" href="innodb-storage-engine.html#sysvar_innodb_buffer_pool_chunk_size"><code class="literal">innodb_buffer_pool_chunk_size</code></a>)
                        </p><p style="color:blue;">删除块中的页面（块大小由innodb_buffer_pool_chunk_size定义）</p></li><li class="listitem"><p>
                            Converts hash tables, lists, and pointers to use new
                            addresses in memory
                        </p><p style="color:blue;">转换哈希表、列表和指针以使用内存中的新地址</p></li></ul>
                    </div>
                    <p>
                        Of these operations, only defragmenting the buffer pool and
                        withdrawing pages allow other threads to access to the buffer
                        pool concurrently.
                    </p><p style="color:blue;">在这些操作中，只有对缓冲池进行碎片整理和撤消页才能允许其他线程同时访问缓冲池。</p>
                </div>

            </div>
            <div class="section">
                <div class="titlepage">
                    <div>
                        <div>
                            <h4 class="title"><a name="innodb-multiple-buffer-pools"></a>14.8.3.2&nbsp;Configuring Multiple Buffer Pool Instances</h4>

                        </div>

                    </div>

                </div>
                <a class="indexterm" name="idm140286820366720"></a><a class="indexterm" name="idm140286820365648"></a><a class="indexterm" name="idm140286820364576"></a><p>
                For systems with buffer pools in the multi-gigabyte range,
                dividing the buffer pool into separate instances can improve
                concurrency, by reducing contention as different threads read
                and write to cached pages. This feature is typically intended
                for systems with a <a class="link" href="glossary.html#glos_buffer_pool" title="buffer pool">buffer
                pool</a> size in the multi-gigabyte range. Multiple buffer
                pool instances are configured using the
                <a class="link" href="innodb-storage-engine.html#sysvar_innodb_buffer_pool_instances"><code class="literal">innodb_buffer_pool_instances</code></a>
                configuration option, and you might also adjust the
                <a class="link" href="innodb-storage-engine.html#sysvar_innodb_buffer_pool_size"><code class="literal">innodb_buffer_pool_size</code></a> value.
            </p><p style="color:blue;">对于具有千兆字节范围的缓冲池的系统，将缓冲池划分为单独的实例可以通过减少不同线程对缓存页的读写争用来提高并发性。此功能通常用于缓冲池大小在千兆字节范围内的系统。使用innodb_buffer_pool_instances配置选项配置多个缓冲池实例，还可以调整innodb_buffer_pool_size值。</p><p>
                When the <code class="literal">InnoDB</code> buffer pool is large, many
                data requests can be satisfied by retrieving from memory. You
                might encounter bottlenecks from multiple threads trying to
                access the buffer pool at once. You can enable multiple buffer
                pools to minimize this contention. Each page that is stored in
                or read from the buffer pool is assigned to one of the buffer
                pools randomly, using a hashing function. Each buffer pool
                manages its own free lists, flush lists, LRUs, and all other
                data structures connected to a buffer pool, and is protected by
                its own buffer pool mutex.
            </p><p style="color:blue;">当innodb缓冲池很大时，可以通过从内存中检索来满足许多数据请求。您可能会遇到来自多个试图同时访问缓冲池的线程的瓶颈。您可以启用多个缓冲池来最小化此争用。存储在缓冲池中或从缓冲池读取的每个页面都使用哈希函数随机分配给其中一个缓冲池。每个缓冲池管理自己的空闲列表、刷新列表、lru和连接到缓冲池的所有其他数据结构，并受自己的缓冲池互斥保护。</p><p>
                To enable multiple buffer pool instances, set the
                <code class="literal">innodb_buffer_pool_instances</code> configuration
                option to a value greater than 1 (the default) up to 64 (the
                maximum). This option takes effect only when you set
                <code class="literal">innodb_buffer_pool_size</code> to a size of 1GB or
                more. The total size you specify is divided among all the buffer
                pools. For best efficiency, specify a combination of
                <a class="link" href="innodb-storage-engine.html#sysvar_innodb_buffer_pool_instances"><code class="literal">innodb_buffer_pool_instances</code></a>
                and <a class="link" href="innodb-storage-engine.html#sysvar_innodb_buffer_pool_size"><code class="literal">innodb_buffer_pool_size</code></a> so
                that each buffer pool instance is at least 1GB.
            </p><p style="color:blue;">若要启用多个缓冲池实例，请将NoNdByBuffelyPoLoLoCuffic配置选项设置为大于1（默认值）为64（最大值）的值。此选项仅在将innodb_buffer_pool_size设置为1GB或更大时生效。指定的总大小将在所有缓冲池中划分。为获得最佳效率，请指定innodb_buffer_pool_实例和innodb_buffer_pool_大小的组合，以便每个缓冲池实例至少为1GB。</p><p>
                For information about modifying <code class="literal">InnoDB</code> buffer
                pool size, see <a class="xref" href="innodb-storage-engine.html#innodb-buffer-pool-resize" title="14.8.3.1&nbsp;Configuring InnoDB Buffer Pool Size">Section&nbsp;14.8.3.1, “Configuring InnoDB Buffer Pool Size”</a>.
            </p><p style="color:blue;">有关修改innodb缓冲池大小的信息，请参阅第14.8.3.1节“配置innodb缓冲池大小”。</p>
            </div>
            <div class="section">
                <div class="titlepage">
                    <div>
                        <div>
                            <h4 class="title"><a name="innodb-performance-midpoint_insertion"></a>14.8.3.3&nbsp;Making the Buffer Pool Scan Resistant</h4>

                        </div>

                    </div>

                </div>
                <a class="indexterm" name="idm140286820349616"></a><a class="indexterm" name="idm140286820348544"></a><a class="indexterm" name="idm140286820347472"></a><a class="indexterm" name="idm140286820346400"></a><a class="indexterm" name="idm140286820345328"></a><a class="indexterm" name="idm140286820344256"></a><a class="indexterm" name="idm140286820343184"></a><p>
                Rather than using a strict <a class="link" href="glossary.html#glos_lru" title="LRU">LRU</a>
                algorithm, <code class="literal">InnoDB</code> uses a technique to
                minimize the amount of data that is brought into the
                <a class="link" href="glossary.html#glos_buffer_pool" title="buffer pool">buffer pool</a> and never
                accessed again. The goal is to make sure that frequently
                accessed (<span class="quote">“<span class="quote">hot</span>”</span>) pages remain in the buffer pool,
                even as <a class="link" href="glossary.html#glos_read_ahead" title="read-ahead">read-ahead</a> and
                <a class="link" href="glossary.html#glos_full_table_scan" title="full table scan">full table scans</a>
                bring in new blocks that might or might not be accessed
                afterward.
            </p><p style="color:blue;">innodb没有使用严格的lru算法，而是使用一种技术来最小化被带入缓冲池的数据量，而不再被访问。目标是确保频繁访问的（“热”）页仍保留在缓冲池中，即使预读和全表扫描会带来新的块，这些块可能在以后被访问，也可能不会被访问。</p><p>
                Newly read blocks are inserted into the middle of the LRU list.
                All newly read pages are inserted at a location that by default
                is <code class="literal">3/8</code> from the tail of the LRU list. The
                pages are moved to the front of the list (the most-recently used
                end) when they are accessed in the buffer pool for the first
                time. Thus, pages that are never accessed never make it to the
                front portion of the LRU list, and <span class="quote">“<span class="quote">age out</span>”</span> sooner
                than with a strict LRU approach. This arrangement divides the
                LRU list into two segments, where the pages downstream of the
                insertion point are considered <span class="quote">“<span class="quote">old</span>”</span> and are
                desirable victims for LRU eviction.
            </p><p style="color:blue;">新读取的块被插入lru列表的中间。所有新读取的页面都会插入到一个位置，默认情况下，该位置距离lru列表的尾部3/8。当第一次在缓冲池中访问页面时，它们将移动到列表的前面（最近使用的结尾）。因此，从未被访问过的页面永远不会出现在lru列表的前半部分，并且比使用严格的lru方法更快地“老化”。这种安排将lru列表分成两个部分，其中插入点下游的页面被认为是“旧的”，是lru驱逐的理想受害者。</p><p>
                For an explanation of the inner workings of the
                <code class="literal">InnoDB</code> buffer pool and specifics about the
                LRU algorithm, see <a class="xref" href="innodb-storage-engine.html#innodb-buffer-pool" title="14.5.1&nbsp;Buffer Pool">Section&nbsp;14.5.1, “Buffer Pool”</a>.
            </p><p style="color:blue;">有关innodb缓冲池内部工作原理的解释和lru算法的详细信息，请参阅14.5.1节“缓冲池”。</p><p>
                You can control the insertion point in the LRU list and choose
                whether <code class="literal">InnoDB</code> applies the same optimization
                to blocks brought into the buffer pool by table or index scans.
                The configuration parameter
                <a class="link" href="innodb-storage-engine.html#sysvar_innodb_old_blocks_pct"><code class="literal">innodb_old_blocks_pct</code></a> controls
                the percentage of <span class="quote">“<span class="quote">old</span>”</span> blocks in the LRU list. The
                default value of
                <a class="link" href="innodb-storage-engine.html#sysvar_innodb_old_blocks_pct"><code class="literal">innodb_old_blocks_pct</code></a> is
                <code class="literal">37</code>, corresponding to the original fixed ratio
                of 3/8. The value range is <code class="literal">5</code> (new pages in
                the buffer pool age out very quickly) to <code class="literal">95</code>
                (only 5% of the buffer pool is reserved for hot pages, making
                the algorithm close to the familiar LRU strategy).
            </p><p style="color:blue;">您可以控制lru列表中的插入点，并选择innodb是对通过表扫描还是索引扫描带入缓冲池的块应用相同的优化。配置参数innodb_old_blocks_pct控制lru列表中“old”块的百分比。innodb_old_blocks_pct的默认值是37，对应于原来的固定比率3/8。该值的范围是5（缓冲池中的新页面很快过时）到95（缓冲池中只有5%的页面是为热页面保留的，这使得算法接近于熟悉的lru策略）。</p><p>
                The optimization that keeps the buffer pool from being churned
                by read-ahead can avoid similar problems due to table or index
                scans. In these scans, a data page is typically accessed a few
                times in quick succession and is never touched again. The
                configuration parameter
                <a class="link" href="innodb-storage-engine.html#sysvar_innodb_old_blocks_time"><code class="literal">innodb_old_blocks_time</code></a>
                specifies the time window (in milliseconds) after the first
                access to a page during which it can be accessed without being
                moved to the front (most-recently used end) of the LRU list. The
                default value of
                <a class="link" href="innodb-storage-engine.html#sysvar_innodb_old_blocks_time"><code class="literal">innodb_old_blocks_time</code></a> is
                <code class="literal">1000</code>. Increasing this value makes more and
                more blocks likely to age out faster from the buffer pool.
            </p><p style="color:blue;">避免缓冲池被预读搅动的优化可以避免由于表或索引扫描而引起的类似问题。在这些扫描中，数据页通常会被快速地连续访问几次，并且再也不会被触摸。配置参数innodb_old_blocks_time指定第一次访问页面之后的时间窗口（以毫秒为单位），在此期间，可以访问页面，而无需移动到lru列表的前端（最近使用的端部）。innodb_old_blocks_time的默认值是1000。增加这个值会使越来越多的块从缓冲池中老化得更快。</p><p>
                Both <a class="link" href="innodb-storage-engine.html#sysvar_innodb_old_blocks_pct"><code class="literal">innodb_old_blocks_pct</code></a> and
                <a class="link" href="innodb-storage-engine.html#sysvar_innodb_old_blocks_time"><code class="literal">innodb_old_blocks_time</code></a> can be
                specified in the MySQL option file (<code class="literal">my.cnf</code> or
                <code class="literal">my.ini</code>) or changed at runtime with the
                <a class="link" href="sql-syntax.html#set-variable" title="13.7.4.1&nbsp;SET Syntax for Variable Assignment"><code class="literal">SET
                    GLOBAL</code></a> statement. Changing the value at runtime
                requires privileges sufficient to set global system variables.
                See <a class="xref" href="server-administration.html#system-variable-privileges" title="5.1.8.1&nbsp;System Variable Privileges">Section&nbsp;5.1.8.1, “System Variable Privileges”</a>.
            </p><p style="color:blue;">innodb_old_blocks_pct和innodb_old_blocks_time都可以在mysql选项文件（my.cnf或my.ini）中指定，或者在运行时使用set global语句更改。在运行时更改值需要足够的权限来设置全局系统变量。见第5.1.8.1节“系统变量特权”。</p><p>
                To help you gauge the effect of setting these parameters, the
                <code class="literal">SHOW ENGINE INNODB STATUS</code> command reports
                buffer pool statistics. For details, see
                <a class="xref" href="innodb-storage-engine.html#innodb-buffer-pool-monitoring" title="Monitoring the Buffer Pool Using the InnoDB Standard Monitor">Monitoring the Buffer Pool Using the InnoDB Standard Monitor</a>.
            </p><p style="color:blue;">为了帮助您判断设置这些参数的效果，show engine innodb status命令报告缓冲池统计信息。有关详细信息，请参阅使用innodb标准监视器监视缓冲池。</p><p>
                Because the effects of these parameters can vary widely based on
                your hardware configuration, your data, and the details of your
                workload, always benchmark to verify the effectiveness before
                changing these settings in any performance-critical or
                production environment.
            </p><p style="color:blue;">由于这些参数的影响可能因硬件配置、数据和工作负载的详细信息而有很大的不同，因此在任何性能关键型或生产环境中更改这些设置之前，请始终进行基准测试以验证其有效性。</p><p>
                In mixed workloads where most of the activity is OLTP type with
                periodic batch reporting queries which result in large scans,
                setting the value of
                <a class="link" href="innodb-storage-engine.html#sysvar_innodb_old_blocks_time"><code class="literal">innodb_old_blocks_time</code></a> during
                the batch runs can help keep the working set of the normal
                workload in the buffer pool.
            </p><p style="color:blue;">在大多数活动是oltp类型的混合工作负载中，通过定期的批处理报告查询（导致大扫描），在批处理运行期间设置innodb_old_blocks_time的值有助于将正常工作负载的工作集保留在缓冲池中。</p><p>
                When scanning large tables that cannot fit entirely in the
                buffer pool, setting
                <a class="link" href="innodb-storage-engine.html#sysvar_innodb_old_blocks_pct"><code class="literal">innodb_old_blocks_pct</code></a> to a
                small value keeps the data that is only read once from consuming
                a significant portion of the buffer pool. For example, setting
                <code class="literal">innodb_old_blocks_pct=5</code> restricts this data
                that is only read once to 5% of the buffer pool.
            </p><p style="color:blue;">当扫描不能完全放在缓冲池中的大表时，将innodb_old_blocks_pct设置为一个小值可以防止只读取一次的数据占用缓冲池的很大一部分。例如，设置innodb_old_blocks_pct=5将只读取一次的数据限制为缓冲池的5%。</p><p>
                When scanning small tables that do fit into memory, there is
                less overhead for moving pages around within the buffer pool, so
                you can leave
                <a class="link" href="innodb-storage-engine.html#sysvar_innodb_old_blocks_pct"><code class="literal">innodb_old_blocks_pct</code></a> at its
                default value, or even higher, such as
                <code class="literal">innodb_old_blocks_pct=50</code>.
            </p><p style="color:blue;">扫描内存中的小表时，在缓冲池内移动页面的开销较小，因此可以将innodb_old_blocks_pct保留为默认值，甚至更高，例如innodb_old_blocks_pct=50。</p><p>
                The effect of the
                <a class="link" href="innodb-storage-engine.html#sysvar_innodb_old_blocks_time"><code class="literal">innodb_old_blocks_time</code></a>
                parameter is harder to predict than the
                <a class="link" href="innodb-storage-engine.html#sysvar_innodb_old_blocks_pct"><code class="literal">innodb_old_blocks_pct</code></a>
                parameter, is relatively small, and varies more with the
                workload. To arrive at an optimal value, conduct your own
                benchmarks if the performance improvement from adjusting
                <a class="link" href="innodb-storage-engine.html#sysvar_innodb_old_blocks_pct"><code class="literal">innodb_old_blocks_pct</code></a> is not
                sufficient.
            </p><p style="color:blue;">innodb_old_blocks_time参数的效果比innodb_old_blocks_pct参数更难预测，相对较小，并且随工作负载变化较大。要获得最佳值，如果调整innodb_old_blocks_pct带来的性能改进还不够，请执行您自己的基准测试。</p>
            </div>
            <div class="section">
                <div class="titlepage">
                    <div>
                        <div>
                            <h4 class="title"><a name="innodb-performance-read_ahead"></a>14.8.3.4&nbsp;Configuring InnoDB Buffer Pool Prefetching (Read-Ahead)</h4>

                        </div>

                    </div>

                </div>
                <a class="indexterm" name="idm140286820299152"></a><a class="indexterm" name="idm140286820298080"></a><a class="indexterm" name="idm140286820297008"></a><a class="indexterm" name="idm140286820295968"></a><a class="indexterm" name="idm140286820294480"></a><p>
                A <a class="link" href="glossary.html#glos_read_ahead" title="read-ahead">read-ahead</a> request is
                an I/O request to prefetch multiple pages in the
                <a class="link" href="glossary.html#glos_buffer_pool" title="buffer pool">buffer pool</a>
                asynchronously, in anticipation that these pages will be needed
                soon. The requests bring in all the pages in one
                <a class="link" href="glossary.html#glos_extent" title="extent">extent</a>.
                <code class="literal">InnoDB</code> uses two read-ahead algorithms to
                improve I/O performance:
            </p><p style="color:blue;">预读请求是一个I/O请求，用于异步预取缓冲池中的多个页面，以预期很快将需要这些页面。这些请求在一个范围内包含了所有页面。InnoDB使用两种预读算法来提高I/O性能：</p><p>
                <span class="strong"><strong>Linear</strong></span> read-ahead is a
                technique that predicts what pages might be needed soon based on
                pages in the buffer pool being accessed sequentially. You
                control when <code class="literal">InnoDB </code>performs a read-ahead
                operation by adjusting the number of sequential page accesses
                required to trigger an asynchronous read request, using the
                configuration parameter
                <a class="link" href="innodb-storage-engine.html#sysvar_innodb_read_ahead_threshold"><code class="literal">innodb_read_ahead_threshold</code></a>.
                Before this parameter was added, <code class="literal">InnoDB</code> would
                only calculate whether to issue an asynchronous prefetch request
                for the entire next extent when it read the last page of the
                current extent.
            </p><p style="color:blue;">线性预读是一种根据缓冲池中按顺序访问的页预测可能很快需要哪些页的技术。您可以使用配置参数innodb-read-ahead-threshold调整触发异步读取请求所需的顺序页面访问数，从而控制innodb何时执行预读操作。在添加这个参数之前，innodb只会计算在读取当前数据块的最后一页时是否对整个下一个数据块发出异步预取请求。</p><p>
                The configuration parameter
                <a class="link" href="innodb-storage-engine.html#sysvar_innodb_read_ahead_threshold"><code class="literal">innodb_read_ahead_threshold</code></a>
                controls how sensitive <code class="literal">InnoDB</code> is in detecting
                patterns of sequential page access. If the number of pages read
                sequentially from an extent is greater than or equal to
                <a class="link" href="innodb-storage-engine.html#sysvar_innodb_read_ahead_threshold"><code class="literal">innodb_read_ahead_threshold</code></a>,
                <code class="literal">InnoDB</code> initiates an asynchronous read-ahead
                operation of the entire following extent.
                <a class="link" href="innodb-storage-engine.html#sysvar_innodb_read_ahead_threshold"><code class="literal">innodb_read_ahead_threshold</code></a> can
                be set to any value from 0-64. The default value is 56. The
                higher the value, the more strict the access pattern check. For
                example, if you set the value to 48, <code class="literal">InnoDB</code>
                triggers a linear read-ahead request only when 48 pages in the
                current extent have been accessed sequentially. If the value is
                8, <code class="literal">InnoDB</code> triggers an asynchronous read-ahead
                even if as few as 8 pages in the extent are accessed
                sequentially. You can set the value of this parameter in the
                MySQL <a class="link" href="glossary.html#glos_configuration_file" title="configuration file">configuration
                file</a>, or change it dynamically with the
                <a class="link" href="sql-syntax.html#set-variable" title="13.7.4.1&nbsp;SET Syntax for Variable Assignment"><code class="literal">SET
                    GLOBAL</code></a> statement, which requires privileges sufficient
                to set global system variables. See
                <a class="xref" href="server-administration.html#system-variable-privileges" title="5.1.8.1&nbsp;System Variable Privileges">Section&nbsp;5.1.8.1, “System Variable Privileges”</a>.
            </p><p style="color:blue;">配置参数innodb_read_ahead_threshold控制innodb检测顺序页面访问模式的敏感度。如果从一个区段按顺序读取的页数大于或等于innodb_read_ahead_threshold，innodb将启动以下整个区段的异步预读操作。innodb_read_ahead_threshold可以设置为0-64之间的任何值。默认值为56。值越高，访问模式检查就越严格。例如，如果您将该值设置为48，InnoDB只在当前区段中的48页被顺序访问时触发线性预读请求。如果该值为8，innodb会触发异步预读，即使按顺序访问扩展中只有8页。可以在mysql配置文件中设置此参数的值，也可以使用set global语句动态更改它，这需要足够的权限来设置全局系统变量。见第5.1.8.1节“系统变量特权”。</p><p>
                <span class="strong"><strong>Random</strong></span> read-ahead is a
                technique that predicts when pages might be needed soon based on
                pages already in the buffer pool, regardless of the order in
                which those pages were read. If 13 consecutive pages from the
                same extent are found in the buffer pool,
                <code class="literal">InnoDB</code> asynchronously issues a request to
                prefetch the remaining pages of the extent. To enable this
                feature, set the configuration variable
                <a class="link" href="innodb-storage-engine.html#sysvar_innodb_random_read_ahead"><code class="literal">innodb_random_read_ahead</code></a> to
                <code class="literal">ON</code>.
            </p><p style="color:blue;">随机预读是一种技术，它根据缓冲池中已经存在的页面预测何时可能很快需要页面，而不管这些页面的读取顺序如何。如果在缓冲池中发现来自同一区段的13个连续页面，innodb会异步发出预取区段剩余页面的请求。要启用此功能，请将配置变量innodb_random_read_ahead设置为on。</p><p>
                The <code class="literal">SHOW ENGINE INNODB STATUS</code> command
                displays statistics to help you evaluate the effectiveness of
                the read-ahead algorithm. Statistics include counter information
                for the following global status variables:
            </p><p style="color:blue;">show engine innodb status命令显示统计信息，帮助您评估预读算法的有效性。统计信息包括以下全局状态变量的计数器信息：</p>
                <div class="itemizedlist">
                    <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                        <a class="link" href="server-administration.html#statvar_Innodb_buffer_pool_read_ahead"><code class="literal">Innodb_buffer_pool_read_ahead</code></a>
                    </p><p style="color:blue;">innodb_buffer_pool_read_ahead_前面的缓冲池</p></li><li class="listitem"><p>
                        <a class="link" href="server-administration.html#statvar_Innodb_buffer_pool_read_ahead_evicted"><code class="literal">Innodb_buffer_pool_read_ahead_evicted</code></a>
                    </p><p style="color:blue;">innodb_buffer_pool_read_ahead_逐出</p></li><li class="listitem"><p>
                        <a class="link" href="server-administration.html#statvar_Innodb_buffer_pool_read_ahead_rnd"><code class="literal">Innodb_buffer_pool_read_ahead_rnd</code></a>
                    </p><p style="color:blue;">innodb_buffer_pool_read_ahead_rnd的缓冲池</p></li></ul>
                </div>
                <p>
                    This information can be useful when fine-tuning the
                    <a class="link" href="innodb-storage-engine.html#sysvar_innodb_random_read_ahead"><code class="literal">innodb_random_read_ahead</code></a>
                    setting.
                </p><p style="color:blue;">当微调innodb_random_read_ahead设置时，此信息非常有用。</p><p>
                For more information about I/O performance, see
                <a class="xref" href="optimization.html#optimizing-innodb-diskio" title="8.5.8&nbsp;Optimizing InnoDB Disk I/O">Section&nbsp;8.5.8, “Optimizing InnoDB Disk I/O”</a> and
                <a class="xref" href="optimization.html#disk-issues" title="8.12.2&nbsp;Optimizing Disk I/O">Section&nbsp;8.12.2, “Optimizing Disk I/O”</a>.
            </p><p style="color:blue;">有关I/O性能的更多信息，请参阅第8.5.8节“优化InnoDB磁盘I/O”和第8.12.2节“优化磁盘I/O”。</p>
            </div>
            <div class="section">
                <div class="titlepage">
                    <div>
                        <div>
                            <h4 class="title"><a name="innodb-buffer-pool-flushing"></a>14.8.3.5&nbsp;Configuring Buffer Pool Flushing</h4>

                        </div>

                    </div>

                </div>
                <a class="indexterm" name="idm140286820256896"></a><a class="indexterm" name="idm140286820255824"></a><p>
                <code class="literal">InnoDB</code> performs certain tasks in the
                background, including flushing of dirty pages from the buffer
                pool. Dirty pages are those that have been modified but are not
                yet written to the data files on disk.
            </p><p style="color:blue;">innodb在后台执行某些任务，包括从缓冲池刷新脏页。脏页是那些已修改但尚未写入磁盘上的数据文件的页。</p><p>
                In MySQL 5.7, buffer pool flushing is performed by
                page cleaner threads. The number of page cleaner threads is
                controlled by the
                <a class="link" href="innodb-storage-engine.html#sysvar_innodb_page_cleaners"><code class="literal">innodb_page_cleaners</code></a> variable,
                which has a default value of 4.
            </p><p style="color:blue;">在mysql 5.7中，缓冲池刷新由页面清理器线程执行。页面清理器线程的数量由innodb_page_cleaners变量控制，该变量的默认值为4。</p><p>
                Buffer pool flushing is initiated when the percentage of dirty
                pages reaches the low water mark value defined by the
                <a class="link" href="innodb-storage-engine.html#sysvar_innodb_max_dirty_pages_pct_lwm"><code class="literal">innodb_max_dirty_pages_pct_lwm</code></a>
                variable. The default low water mark is 0, which disables this
                early flushing behaviour.
            </p><p style="color:blue;">当脏页百分比达到innodb_max_dirty_pages_pct_lwm变量定义的低水位线值时，缓冲池刷新启动。默认的低水位线为0，这将禁用此早期冲洗行为。</p><p>
                The purpose of the
                <a class="link" href="innodb-storage-engine.html#sysvar_innodb_max_dirty_pages_pct_lwm"><code class="literal">innodb_max_dirty_pages_pct_lwm</code></a>
                threshold is to control the percentage dirty pages in the buffer
                pool, and to prevent the amount of dirty pages from reaching the
                threshold defined by the
                <a class="link" href="innodb-storage-engine.html#sysvar_innodb_max_dirty_pages_pct"><code class="literal">innodb_max_dirty_pages_pct</code></a>
                variable, which has a default value of 75.
                <code class="literal">InnoDB</code> aggressively flushes buffer pool pages
                if the percentage of dirty pages in the buffer pool reaches the
                <a class="link" href="innodb-storage-engine.html#sysvar_innodb_max_dirty_pages_pct"><code class="literal">innodb_max_dirty_pages_pct</code></a>
                threshold.
            </p><p style="color:blue;">innodb_max_dirty_pages_pct_lwm阈值的目的是控制缓冲池中的脏页百分比，并防止脏页数量达到innodb_max_dirty_pages_pct变量定义的阈值，该变量的默认值为75。如果缓冲池中脏页的百分比达到innodb_max_dirty_pages_pct阈值，innodb会主动刷新缓冲池页面。</p><p>
                Additional variables permit fine-tuning of buffer pool flushing
                behavior:
            </p><p style="color:blue;">其他变量允许微调缓冲池刷新行为：</p>
                <div class="itemizedlist">
                    <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                        The <a class="link" href="innodb-storage-engine.html#sysvar_innodb_flush_neighbors"><code class="literal">innodb_flush_neighbors</code></a>
                        variable defines whether flushing a page from the buffer
                        pool also flushes other dirty pages in the same extent.
                    </p><p style="color:blue;">innodb_flush_neighbors变量定义从缓冲池刷新页面是否也刷新同一区段中的其他脏页面。</p>
                        <div class="itemizedlist">
                            <ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
                                A setting of 0 disables
                                <a class="link" href="innodb-storage-engine.html#sysvar_innodb_flush_neighbors"><code class="literal">innodb_flush_neighbors</code></a>.
                                Dirty pages in the same extent are not flushed.
                            </p><p style="color:blue;">设置为0将禁用innodb_flush_neighbors。不刷新相同区域中的脏页。</p></li><li class="listitem"><p>
                                The default setting of 1 flushes contiguous dirty pages
                                in the same extent.
                            </p><p style="color:blue;">默认设置为1将刷新相同范围内的连续脏页。</p></li><li class="listitem"><p>
                                A setting of 2 flushes dirty pages in the same extent.
                            </p><p style="color:blue;">设置为2将刷新相同范围内的脏页。</p></li></ul>
                        </div>
                        <p>
                            When table data is stored on a traditional
                            <a class="link" href="glossary.html#glos_hdd" title="HDD">HDD</a> storage device, flushing
                            neighbor pages in one operation reduces I/O overhead
                            (primarily for disk seek operations) compared to flushing
                            individual pages at different times. For table data stored
                            on <a class="link" href="glossary.html#glos_ssd" title="SSD">SSD</a>, seek time is not a
                            significant factor and you can disable this setting to
                            spread out write operations.
                        </p><p style="color:blue;">当表数据存储在传统的hdd存储设备上时，与在不同时间刷新单个页相比，在一次操作中刷新相邻页减少了i/o开销（主要用于磁盘查找操作）。对于存储在ssd上的表数据，寻道时间不是一个重要因素，您可以禁用此设置来分散写操作。</p></li><li class="listitem"><p>
                        The <a class="link" href="innodb-storage-engine.html#sysvar_innodb_lru_scan_depth"><code class="literal">innodb_lru_scan_depth</code></a>
                        variable specifies, per buffer pool instance, how far down
                        the buffer pool LRU list the page cleaner thread scans
                        looking for dirty pages to flush. This is a background
                        operation performed by a page cleaner thread once per
                        second.
                    </p><p style="color:blue;">innodb_lru_scan_depth变量为每个缓冲池实例指定缓冲池lru列表中的页面清理器线程扫描脏页的深度。这是页清理程序线程每秒执行一次的后台操作。</p><p>
                        A setting smaller than the default is generally suitable for
                        most workloads. A value that is significantly higher than
                        necessary may impact performance. Only consider increasing
                        the value if you have spare I/O capacity under a typical
                        workload. Conversely, if a write-intensive workload
                        saturates your I/O capacity, decrease the value, especially
                        in the case of a large buffer pool.
                    </p><p style="color:blue;">小于默认值的设置通常适用于大多数工作负载。显著高于必要值可能会影响性能。只有在典型工作负载下有空闲的I/O容量时，才考虑增加该值。相反，如果写密集型工作负载使I/O容量饱和，请减小该值，特别是在大缓冲池的情况下。</p><p>
                        When tuning
                        <a class="link" href="innodb-storage-engine.html#sysvar_innodb_lru_scan_depth"><code class="literal">innodb_lru_scan_depth</code></a>,
                        start with a low value and configure the setting upward with
                        the goal of rarely seeing zero free pages. Also, consider
                        adjusting
                        <a class="link" href="innodb-storage-engine.html#sysvar_innodb_lru_scan_depth"><code class="literal">innodb_lru_scan_depth</code></a> when
                        changing the number of buffer pool instances, since
                        <a class="link" href="innodb-storage-engine.html#sysvar_innodb_lru_scan_depth"><code class="literal">innodb_lru_scan_depth</code></a> *
                        <a class="link" href="innodb-storage-engine.html#sysvar_innodb_buffer_pool_instances"><code class="literal">innodb_buffer_pool_instances</code></a>
                        defines the amount of work performed by the page cleaner
                        thread each second.
                    </p><p style="color:blue;">当调整innodb_lru_scan_depth时，从一个较低的值开始，向上配置设置，目标是很少看到零空闲页面。另外，在更改缓冲池实例数时，考虑调整innodb_lru_scan_depth，因为innodb_lru scan_depth*innodb_buffer_pool_instances定义了页面清理线程每秒执行的工作量。</p></li></ul>
                </div>
                <p>
                    The <a class="link" href="innodb-storage-engine.html#sysvar_innodb_flush_neighbors"><code class="literal">innodb_flush_neighbors</code></a> and
                    <a class="link" href="innodb-storage-engine.html#sysvar_innodb_lru_scan_depth"><code class="literal">innodb_lru_scan_depth</code></a> variables
                    are primarily intended for write-intensive workloads. With heavy
                    DML activity, flushing can fall behind if it is not aggressive
                    enough, or disk writes can saturate I/O capacity if flushing is
                    too aggressive. The ideal settings depend on your workload, data
                    access patterns, and storage configuration (for example, whether
                    data is stored on HDD or SSD devices).
                </p><p style="color:blue;">innodb_flush_neighbors和innodb_lru_scan_depth变量主要用于写密集型工作负载。对于大量的dml活动，如果刷新不够积极，刷新可能会落后，或者如果刷新过于积极，磁盘写入可能会使i/o容量饱和。理想的设置取决于您的工作负载、数据访问模式和存储配置（例如，数据是存储在hdd还是ssd设备上）。</p>
                <div class="simplesect">

                    <div class="titlepage">
                        <div>

                            <div class="simple">
                                <h5 class="title"><a name="innodb-adaptive-flushing"></a>Adaptive Flushing</h5>
                            </div>
                        </div>
                    </div>
                    <p>
                        <code class="literal">InnoDB</code> uses an adaptive flushing algorithm
                        to dynamically adjust the rate of flushing based on the speed
                        of redo log generation and the current rate of flushing. The
                        intent is to smooth overall performance by ensuring that
                        flushing activity keeps pace with the current workload.
                        Automatically adjusting the flushing rate helps avoid sudden
                        dips in throughput that can occur when bursts of I/O activity
                        due to buffer pool flushing affects the I/O capacity available
                        for ordinary read and write activity.
                    </p><p style="color:blue;">InnoDB使用一种自适应刷新算法，根据重做日志生成速度和当前的刷新速度动态调整刷新率。其目的是通过确保刷新活动与当前工作负载保持同步来平滑总体性能。自动调整刷新率有助于避免由于缓冲池刷新而导致的I/O活动突发影响可用于普通读写活动的I/O容量时可能发生的吞吐量突然下降。</p><p>
                    Sharp checkpoints, which are typically associated with
                    write-intensive workloads that generate a lot of redo entries,
                    can cause a sudden change in throughput, for example. A sharp
                    checkpoint occurs when <code class="literal">InnoDB</code> wants to
                    reuse a portion of a log file. Before doing so, all dirty
                    pages with redo entries in that portion of the log file must
                    be flushed. If log files become full, a sharp checkpoint
                    occurs, causing a temporary reduction in throughput. This
                    scenario can occur even if
                    <a class="link" href="innodb-storage-engine.html#sysvar_innodb_max_dirty_pages_pct"><code class="literal">innodb_max_dirty_pages_pct</code></a>
                    threshold is not reached.
                </p><p style="color:blue;">例如，尖锐的检查点通常与产生大量重做条目的写密集型工作负载相关联，会导致吞吐量的突然变化。当innodb想要重用日志文件的一部分时，会出现一个尖锐的检查点。执行此操作之前，必须刷新日志文件该部分中包含重做项的所有脏页。如果日志文件已满，则会出现一个尖锐的检查点，导致吞吐量暂时降低。即使未达到innodb_max_dirty_pages_pct阈值，也可能发生这种情况。</p><p>
                    The adaptive flushing algorithm helps avoid such scenarios by
                    tracking the number of dirty pages in the buffer pool and the
                    rate at which redo log records are being generated. Based on
                    this information, it decides how many dirty pages to flush
                    from the buffer pool each second, which permits it to manage
                    sudden changes in workload.
                </p><p style="color:blue;">自适应刷新算法通过跟踪缓冲池中脏页的数量和生成重做日志记录的速率，有助于避免这种情况。基于此信息，它决定每秒从缓冲池中刷新多少脏页，从而允许它管理工作负载的突然变化。</p><p>
                    The
                    <a class="link" href="innodb-storage-engine.html#sysvar_innodb_adaptive_flushing_lwm"><code class="literal">innodb_adaptive_flushing_lwm</code></a>
                    variable defines a low water mark for redo log capacity. When
                    that threshold is crossed, adaptive flushing is enabled, even
                    if the
                    <a class="link" href="innodb-storage-engine.html#sysvar_innodb_adaptive_flushing"><code class="literal">innodb_adaptive_flushing</code></a>
                    variable is disabled.
                </p><p style="color:blue;">innodb_adaptive_flushing_lwm变量定义了重做日志容量的低水位线。当超过该阈值时，即使禁用了innodb_adaptive_flush变量，也会启用自适应刷新。</p><p>
                    Internal benchmarking has shown that the algorithm not only
                    maintains throughput over time, but can also improve overall
                    throughput significantly. However, adaptive flushing can
                    affect the I/O pattern of a workload significantly and may not
                    be appropriate in all cases. It gives the most benefit when
                    the redo log is in danger of filling up. If adaptive flushing
                    is not appropriate to the characteristics of your workload,
                    you can disable it. Adaptive flushing controlled by the
                    <a class="link" href="innodb-storage-engine.html#sysvar_innodb_adaptive_flushing"><code class="literal">innodb_adaptive_flushing</code></a>
                    variable, which is enabled by default.
                </p><p style="color:blue;">内部基准测试表明，该算法不仅可以随着时间的推移保持吞吐量，而且还可以显著提高总体吞吐量。但是，自适应刷新会显著影响工作负载的I/O模式，并且可能并不适用于所有情况。当重做日志有填满的危险时，它提供了最大的好处。如果自适应刷新不适合工作负载的特性，则可以禁用它。由innodb_adaptive_flushing变量控制的自适应刷新，该变量默认启用。</p><p>
                    <a class="link" href="innodb-storage-engine.html#sysvar_innodb_flushing_avg_loops"><code class="literal">innodb_flushing_avg_loops</code></a>
                    defines the number of iterations that
                    <code class="literal">InnoDB</code> keeps the previously calculated
                    snapshot of the flushing state, controlling how quickly
                    adaptive flushing responds to foreground workload changes. A
                    high
                    <a class="link" href="innodb-storage-engine.html#sysvar_innodb_flushing_avg_loops"><code class="literal">innodb_flushing_avg_loops</code></a>
                    value means that <code class="literal">InnoDB</code> keeps the
                    previously calculated snapshot longer, so adaptive flushing
                    responds more slowly. When setting a high value it is
                    important to ensure that redo log utilization does not reach
                    75% (the hardcoded limit at which asynchronous flushing
                    starts), and that the
                    <a class="link" href="innodb-storage-engine.html#sysvar_innodb_max_dirty_pages_pct"><code class="literal">innodb_max_dirty_pages_pct</code></a>
                    threshold keeps the number of dirty pages to a level that is
                    appropriate for the workload.
                </p><p style="color:blue;">innodb_flushing_avg_循环定义innodb保留先前计算的刷新状态快照的迭代次数，控制自适应刷新对前台工作负载更改的响应速度。较高的innodb_flushing_avg_loops值意味着innodb会使先前计算的快照保持更长的时间，因此自适应刷新响应更慢。设置高值时，重要的是确保重做日志利用率不达到75%（异步刷新开始时的硬编码限制），并且innodb_max_dirty_pages_pct阈值将脏页数保持在适合工作负载的级别。</p><p>
                    Systems with consistent workloads, a large log file size
                    (<a class="link" href="innodb-storage-engine.html#sysvar_innodb_log_file_size"><code class="literal">innodb_log_file_size</code></a>), and
                    small spikes that do not reach 75% log space utilization
                    should use a high
                    <a class="link" href="innodb-storage-engine.html#sysvar_innodb_flushing_avg_loops"><code class="literal">innodb_flushing_avg_loops</code></a>
                    value to keep flushing as smooth as possible. For systems with
                    extreme load spikes or log files that do not provide a lot of
                    space, a smaller value allows flushing to closely track
                    workload changes, and helps to avoid reaching 75% log space
                    utilization.
                </p><p style="color:blue;">具有一致工作负载、较大日志文件大小（innodb_log_file_size）和未达到75%日志空间利用率的小峰值的系统应使用较高的innodb_flusing_avg_loops值，以保持刷新尽可能平滑。对于具有极端负载峰值的系统或不提供大量空间的日志文件，较小的值允许刷新以密切跟踪工作负载更改，并有助于避免达到75%的日志空间利用率。</p><p>
                    Be aware that if flushing falls behind, the rate of buffer
                    pool flushing can exceed the I/O capacity available to
                    <code class="literal">InnoDB</code>, as defined by
                    <a class="link" href="innodb-storage-engine.html#sysvar_innodb_io_capacity"><code class="literal">innodb_io_capacity</code></a> setting.
                    The <a class="link" href="innodb-storage-engine.html#sysvar_innodb_io_capacity_max"><code class="literal">innodb_io_capacity_max</code></a>
                    value defines an upper limit on I/O capacity in such
                    situations, so that a spike in I/O activity does not consume
                    the entire I/O capacity of the server.
                </p><p style="color:blue;">请注意，如果刷新落后，缓冲池刷新的速率可能会超过innodb可用的i/o容量，如innodb_io_capacity设置所定义的。innodb_i o_capacity_max值定义了这种情况下i/o容量的上限，因此i/o活动的峰值不会消耗服务器的整个i/o容量。</p><p>
                    The <a class="link" href="innodb-storage-engine.html#sysvar_innodb_io_capacity"><code class="literal">innodb_io_capacity</code></a>
                    setting is applicable to all buffer pool instances. When dirty
                    pages are flushed, I/O capacity is divided equally among
                    buffer pool instances.
                </p><p style="color:blue;">innodb_io_capacity设置适用于所有缓冲池实例。刷新脏页时，I/O容量在缓冲池实例之间平均分配。</p>
                </div>

            </div>
            <div class="section">
                <div class="titlepage">
                    <div>
                        <div>
                            <h4 class="title"><a name="innodb-preload-buffer-pool"></a>14.8.3.6&nbsp;Saving and Restoring the Buffer Pool State</h4>

                        </div>

                    </div>

                </div>
                <a class="indexterm" name="idm140286820192656"></a><a class="indexterm" name="idm140286820191584"></a><p>
                To reduce the <a class="link" href="glossary.html#glos_warm_up" title="warm up">warmup</a> period
                after restarting the server, <code class="literal">InnoDB</code> saves a
                percentage of the most recently used pages for each buffer pool
                at server shutdown and restores these pages at server startup.
                The percentage of recently used pages that is stored is defined
                by the
                <a class="link" href="innodb-storage-engine.html#sysvar_innodb_buffer_pool_dump_pct"><code class="literal">innodb_buffer_pool_dump_pct</code></a>
                configuration option.
            </p><p style="color:blue;">为了减少重启服务器后的预热时间，innodb在服务器关闭时为每个缓冲池保存最近使用的页面的百分比，并在服务器启动时恢复这些页面。存储的最近使用的页面百分比由innodb_buffer_pool_dump_pct配置选项定义。</p><p>
                After restarting a busy server, there is typically a warmup
                period with steadily increasing throughput, as disk pages that
                were in the buffer pool are brought back into memory (as the
                same data is queried, updated, and so on). The ability to
                restore the buffer pool at startup shortens the warmup period by
                reloading disk pages that were in the buffer pool before the
                restart rather than waiting for DML operations to access
                corresponding rows. Also, I/O requests can be performed in large
                batches, making the overall I/O faster. Page loading happens in
                the background, and does not delay database startup.
            </p><p style="color:blue;">重新启动繁忙的服务器后，通常会有一个热身期，吞吐量会稳步增加，因为缓冲池中的磁盘页会被带回内存中（查询、更新相同的数据，等等）。在启动时恢复缓冲池的能力通过重新加载重新启动前缓冲池中的磁盘页而不是等待dml操作访问相应的行来缩短预热时间。此外，可以成批执行I/O请求，从而加快整个I/O的速度。页面加载在后台进行，不会延迟数据库启动。</p><p>
                In addition to saving the buffer pool state at shutdown and
                restoring it at startup, you can save and restore the buffer
                pool state at any time, while the server is running. For
                example, you can save the state of the buffer pool after
                reaching a stable throughput under a steady workload. You could
                also restore the previous buffer pool state after running
                reports or maintenance jobs that bring data pages into the
                buffer pool that are only requited for those operations, or
                after running some other non-typical workload.
            </p><p style="color:blue;">除了在关机时保存缓冲池状态并在启动时还原外，您还可以在服务器运行时随时保存和还原缓冲池状态。例如，可以在稳定工作负载下达到稳定吞吐量后保存缓冲池的状态。您还可以在运行报告或维护作业（这些作业将数据页带到缓冲池中，这些操作只需要这些页）之后，或者在运行某些其他非典型工作负载之后，还原以前的缓冲池状态。</p><p>
                Even though a buffer pool can be many gigabytes in size, the
                buffer pool data that <code class="literal">InnoDB</code> saves to disk is
                tiny by comparison. Only tablespace IDs and page IDs necessary
                to locate the appropriate pages are saved to disk. This
                information is derived from the
                <a class="link" href="information-schema.html#innodb-buffer-page-lru-table" title="24.32.2&nbsp;The INFORMATION_SCHEMA INNODB_BUFFER_PAGE_LRU Table"><code class="literal">INNODB_BUFFER_PAGE_LRU</code></a>
                <code class="literal">INFORMATION_SCHEMA</code> table. By default,
                tablespace ID and page ID data is saved in a file named
                <code class="filename">ib_buffer_pool</code>, which is saved to the
                <code class="literal">InnoDB</code> data directory. The file name and
                location can be modified using the
                <a class="link" href="innodb-storage-engine.html#sysvar_innodb_buffer_pool_filename"><code class="literal">innodb_buffer_pool_filename</code></a>
                configuration parameter.
            </p><p style="color:blue;">尽管一个缓冲池的大小可以是千兆字节，但相比之下，innodb保存到磁盘的缓冲池数据很小。只有找到适当页面所需的表空间id和页面id才会保存到磁盘。此信息来自innodb_buffer_page_lru information_schema表。默认情况下，表空间id和页id数据保存在名为ib_buffer_pool的文件中，该文件保存在innodb data目录中。可以使用innodb_buffer_pool_file name配置参数修改文件名和位置。</p><p>
                Because data is cached in and aged out of the buffer pool as it
                is with regular database operations, there is no problem if the
                disk pages are recently updated, or if a DML operation involves
                data that has not yet been loaded. The loading mechanism skips
                requested pages that no longer exist.
            </p><p style="color:blue;">因为数据是在缓冲池中缓存的，而不是在常规数据库操作中老化的，所以如果磁盘页是最近更新的，或者DML操作涉及到尚未加载的数据，则没有问题。加载机制跳过不再存在的请求页。</p><p>
                The underlying mechanism involves a background thread that is
                dispatched to perform the dump and load operations.
            </p><p style="color:blue;">底层机制包含一个后台线程，该线程被调度来执行转储和加载操作。</p><p>
                Disk pages from compressed tables are loaded into the buffer
                pool in their compressed form. Pages are uncompressed as usual
                when page contents are accessed during DML operations. Because
                uncompressing pages is a CPU-intensive process, it is more
                efficient for concurrency to perform the operation in a
                connection thread rather than in the single thread that performs
                the buffer pool restore operation.
            </p><p style="color:blue;">压缩表中的磁盘页以压缩形式加载到缓冲池中。当在DML操作期间访问页面内容时，页面将像往常一样解压缩。由于解压缩页是一个CPU密集型进程，因此并发性在连接线程中执行该操作比在执行缓冲池还原操作的单个线程中执行该操作更有效。</p><p>
                Operations related to saving and restoring the buffer pool state
                are described in the following topics:
            </p><p style="color:blue;">与保存和还原缓冲池状态相关的操作将在以下主题中介绍：</p>
                <div class="itemizedlist">
                    <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><a class="xref" href="innodb-storage-engine.html#innodb-preload-buffer-pool-dump-pct" title="Configuring the Dump Percentage for Buffer Pool Pages">Configuring the Dump Percentage for Buffer Pool Pages</a></p><p style="color:blue;">为缓冲池页配置转储百分比</p></li><li class="listitem"><p><a class="xref" href="innodb-storage-engine.html#innodb-preload-buffer-pool-offline" title="Saving the Buffer Pool State at Shutdown and Restoring it at Startup">Saving the Buffer Pool State at Shutdown and Restoring it at Startup</a></p><p style="color:blue;">关闭时保存缓冲池状态并在启动时还原</p></li><li class="listitem"><p><a class="xref" href="innodb-storage-engine.html#innodb-preload-buffer-pool-online" title="Saving and Restoring the Buffer Pool State Online">Saving and Restoring the Buffer Pool State Online</a></p><p style="color:blue;">联机保存和还原缓冲池状态</p></li><li class="listitem"><p><a class="xref" href="innodb-storage-engine.html#innodb-preload-buffer-pool-dump-progress" title="Displaying Buffer Pool Dump Progress">Displaying Buffer Pool Dump Progress</a></p><p style="color:blue;">显示缓冲池转储进度</p></li><li class="listitem"><p><a class="xref" href="innodb-storage-engine.html#innodb-preload-buffer-pool-load-progress" title="Displaying Buffer Pool Load Progress">Displaying Buffer Pool Load Progress</a></p><p style="color:blue;">显示缓冲池加载进度</p></li><li class="listitem"><p><a class="xref" href="innodb-storage-engine.html#innodb-preload-buffer-pool-abort-load" title="Aborting a Buffer Pool Load Operation">Aborting a Buffer Pool Load Operation</a></p><p style="color:blue;">中止缓冲池加载操作</p></li><li class="listitem"><p><a class="xref" href="innodb-storage-engine.html#monitor-buffer-pool-load-performance-schema" title="Monitoring Buffer Pool Load Progress Using Performance Schema">Monitoring Buffer Pool Load Progress Using Performance Schema</a></p><p style="color:blue;">使用性能架构监视缓冲池加载进度</p></li></ul>
                </div>

                <div class="simplesect">

                    <div class="titlepage">
                        <div>

                            <div class="simple">
                                <h5 class="title"><a name="innodb-preload-buffer-pool-dump-pct"></a>Configuring the Dump Percentage for Buffer Pool Pages</h5>

                            </div>

                        </div>

                    </div>
                    <p>
                        Before dumping pages from the buffer pool, you can configure
                        the percentage of most-recently-used buffer pool pages that
                        you want to dump by setting the
                        <a class="link" href="innodb-storage-engine.html#sysvar_innodb_buffer_pool_dump_pct"><code class="literal">innodb_buffer_pool_dump_pct</code></a>
                        option. If you plan to dump buffer pool pages while the server
                        is running, you can configure the option dynamically:
                    </p><p style="color:blue;">在从缓冲池转储页面之前，可以通过设置innodb_buffer_pool_dump_pct选项来配置要转储的最近使用的缓冲池页面的百分比。如果计划在服务器运行时转储缓冲池页，则可以动态配置该选项：</p><pre data-lang="sql" class="programlisting">SET GLOBAL innodb_buffer_pool_dump_pct=40;
</pre><p>
                    If you plan to dump buffer pool pages at server shutdown, set
                    <a class="link" href="innodb-storage-engine.html#sysvar_innodb_buffer_pool_dump_pct"><code class="literal">innodb_buffer_pool_dump_pct</code></a>
                    in your configuration file.
                </p><p style="color:blue;">如果计划在服务器关闭时转储缓冲池页面，请在配置文件中设置innodb_buffer_pool_dump_pct。</p><pre data-lang="ini" class="programlisting">[mysqld]
innodb_buffer_pool_dump_pct=40
</pre><p>
                    The
                    <a class="link" href="innodb-storage-engine.html#sysvar_innodb_buffer_pool_dump_pct"><code class="literal">innodb_buffer_pool_dump_pct</code></a>
                    default value was changed from 100 (dump all pages) to 25
                    (dump 25% of most-recently-used pages) in MySQL
                    5.7 when
                    <a class="link" href="innodb-storage-engine.html#sysvar_innodb_buffer_pool_dump_at_shutdown"><code class="literal">innodb_buffer_pool_dump_at_shutdown</code></a>
                    and
                    <a class="link" href="innodb-storage-engine.html#sysvar_innodb_buffer_pool_load_at_startup"><code class="literal">innodb_buffer_pool_load_at_startup</code></a>
                    were enabled by default.
                </p><p style="color:blue;">InnoDB_Buffer_Pool_Dump_PCT默认值在MySQL 5.7中从100（转储所有页面）更改为25（转储最近使用的页面的25%），此时InnoDB_Buffer_Pool_Dump_at_Shutdown和InnoDB_Buffer_Pool_Load_at_Startup默认启用。</p>
                </div>
                <div class="simplesect">
                    <div class="titlepage">
                        <div>
                            <div class="simple">
                                <h5 class="title"><a name="innodb-preload-buffer-pool-offline"></a>Saving the Buffer Pool State at Shutdown and Restoring it at Startup</h5>

                            </div>

                        </div>

                    </div>
                    <p>
                        To save the state of the buffer pool at server shutdown, issue
                        the following statement prior to shutting down the server:
                    </p><p style="color:blue;">要在服务器关闭时保存缓冲池的状态，请在关闭服务器之前发出以下语句：</p><pre data-lang="sql" class="programlisting">SET GLOBAL innodb_buffer_pool_dump_at_shutdown=ON;
</pre><p>
                    <a class="link" href="innodb-storage-engine.html#sysvar_innodb_buffer_pool_dump_at_shutdown"><code class="literal">innodb_buffer_pool_dump_at_shutdown</code></a>
                    is enabled by default.
                </p><p style="color:blue;">innodb_buffer_pool_dump_at_shutdown默认启用。</p><p>
                    To restore the buffer pool state at server startup, specify
                    the <code class="literal">--innodb-buffer-pool-load-at-startup</code>
                    option when starting the server:
                </p><p style="color:blue;">要在服务器启动时还原缓冲池状态，请在启动服务器时指定--innodb buffer pool load at startup选项：</p><pre data-lang="terminal" class="programlisting">mysqld --innodb-buffer-pool-load-at-startup=ON;
</pre><p>
                    <a class="link" href="innodb-storage-engine.html#sysvar_innodb_buffer_pool_load_at_startup"><code class="literal">innodb_buffer_pool_load_at_startup</code></a>
                    is enabled by default.
                </p><p style="color:blue;">innodb_buffer_pool_load_at_startup默认启用。</p>
                </div>
                <div class="simplesect">
                    <div class="titlepage">
                        <div>
                            <div class="simple">
                                <h5 class="title"><a name="innodb-preload-buffer-pool-online"></a>Saving and Restoring the Buffer Pool State Online</h5>

                            </div>

                        </div>

                    </div>
                    <p>
                        To save the state of the buffer pool while MySQL server is
                        running, issue the following statement:
                    </p><p style="color:blue;">要在mysql server运行时保存缓冲池的状态，请发出以下语句：</p><pre data-lang="sql" class="programlisting">SET GLOBAL innodb_buffer_pool_dump_now=ON;
</pre><p>
                    To restore the buffer pool state while MySQL is running, issue
                    the following statement:
                </p><p style="color:blue;">要在mysql运行时还原缓冲池状态，请发出以下语句：</p><pre data-lang="sql" class="programlisting">SET GLOBAL innodb_buffer_pool_load_now=ON;
</pre>
                </div>
                <div class="simplesect">
                    <div class="titlepage">
                        <div>
                            <div class="simple">
                                <h5 class="title"><a name="innodb-preload-buffer-pool-dump-progress"></a>Displaying Buffer Pool Dump Progress</h5>

                            </div>

                        </div>

                    </div>
                    <p>
                        To display progress when saving the buffer pool state to disk,
                        issue the following statement:
                    </p><p style="color:blue;">要在将缓冲池状态保存到磁盘时显示进度，请发出以下语句：</p><pre data-lang="sql" class="programlisting">SHOW STATUS LIKE 'Innodb_buffer_pool_dump_status';
</pre><p>
                    If the operation has not yet started, <span class="quote">“<span class="quote">not
          started</span>”</span> is returned. If the operation is complete, the
                    completion time is printed (e.g. Finished at 110505 12:18:02).
                    If the operation is in progress, status information is
                    provided (e.g. Dumping buffer pool 5/7, page 237/2873).
                </p><p style="color:blue;">如果操作尚未启动，则返回“未启动”。如果操作完成，则打印完成时间（例如，在110505 12:18:02完成）。如果操作正在进行，则提供状态信息（例如转储缓冲池5/7，第237/2873页）。</p>
                </div>
                <div class="simplesect">
                    <div class="titlepage">
                        <div>
                            <div class="simple">
                                <h5 class="title"><a name="innodb-preload-buffer-pool-load-progress"></a>Displaying Buffer Pool Load Progress</h5>

                            </div>

                        </div>

                    </div>
                    <p>
                        To display progress when loading the buffer pool, issue the
                        following statement:
                    </p><p style="color:blue;">要在加载缓冲池时显示进度，请发出以下语句：</p><pre data-lang="sql" class="programlisting">SHOW STATUS LIKE 'Innodb_buffer_pool_load_status';
</pre><p>
                    If the operation has not yet started, <span class="quote">“<span class="quote">not
          started</span>”</span> is returned. If the operation is complete, the
                    completion time is printed (e.g. Finished at 110505 12:23:24).
                    If the operation is in progress, status information is
                    provided (e.g. Loaded 123/22301 pages).
                </p><p style="color:blue;">如果操作尚未启动，则返回“未启动”。如果操作完成，则打印完成时间（例如，在110505 12:23:24完成）。如果操作正在进行，则提供状态信息（例如，加载123/22301页）。</p>
                </div>
                <div class="simplesect">
                    <div class="titlepage">
                        <div>
                            <div class="simple">
                                <h5 class="title"><a name="innodb-preload-buffer-pool-abort-load"></a>Aborting a Buffer Pool Load Operation</h5>

                            </div>

                        </div>

                    </div>
                    <p>
                        To abort a buffer pool load operation, issue the following
                        statement:
                    </p><p style="color:blue;">要中止缓冲池加载操作，请发出以下语句：</p><pre data-lang="sql" class="programlisting">SET GLOBAL innodb_buffer_pool_load_abort=ON;
</pre>
                </div>
                <div class="simplesect">
                    <div class="titlepage">
                        <div>
                            <div class="simple">
                                <h5 class="title"><a name="monitor-buffer-pool-load-performance-schema"></a>Monitoring Buffer Pool Load Progress Using Performance Schema</h5>

                            </div>

                        </div>

                    </div>
                    <a class="indexterm" name="idm140286820131056"></a><a class="indexterm" name="idm140286820129568"></a><p>
                    You can monitor buffer pool load progress using
                    <a class="link" href="performance-schema.html" title="Chapter&nbsp;25&nbsp;MySQL Performance Schema">Performance Schema</a>.
                </p><p style="color:blue;">您可以使用性能架构监视缓冲池加载进度。</p><p>
                    The following example demonstrates how to enable the
                    <code class="literal">stage/innodb/buffer pool load</code> stage event
                    instrument and related consumer tables to monitor buffer pool
                    load progress.
                </p><p style="color:blue;">下面的示例演示如何启用stage/innodb/buffer pool load stage事件工具和相关的使用者表来监视缓冲池加载进度。</p><p>
                    For information about buffer pool dump and load procedures
                    used in this example, see
                    <a class="xref" href="innodb-storage-engine.html#innodb-preload-buffer-pool" title="14.8.3.6&nbsp;Saving and Restoring the Buffer Pool State">Section&nbsp;14.8.3.6, “Saving and Restoring the Buffer Pool State”</a>. For information
                    about Performance Schema stage event instruments and related
                    consumers, see
                    <a class="xref" href="performance-schema.html#performance-schema-stage-tables" title="25.12.5&nbsp;Performance Schema Stage Event Tables">Section&nbsp;25.12.5, “Performance Schema Stage Event Tables”</a>.
                </p><p style="color:blue;">有关本示例中使用的缓冲池转储和加载过程的信息，请参阅14.8.3.6节“保存和还原缓冲池状态”。有关Performance Schema Stage事件工具和相关使用者的信息，请参阅25.12.5节“Performance Schema Stage事件表”。</p>
                    <div class="orderedlist">
                        <ol class="orderedlist" type="1"><li class="listitem"><p>
                            Enable the <code class="literal">stage/innodb/buffer pool
                            load</code> instrument:
                        </p><p style="color:blue;">启用stage/innodb/buffer pool load instrument：</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>UPDATE performance_schema.setup_instruments SET ENABLED = 'YES' </code></strong>
       <strong class="userinput"><code>WHERE NAME LIKE 'stage/innodb/buffer%';</code></strong>
</pre></li><li class="listitem"><p>
                            Enable the stage event consumer tables, which include
                            <a class="link" href="performance-schema.html#events-stages-current-table" title="25.12.5.1&nbsp;The events_stages_current Table"><code class="literal">events_stages_current</code></a>,
                            <a class="link" href="performance-schema.html#events-stages-history-table" title="25.12.5.2&nbsp;The events_stages_history Table"><code class="literal">events_stages_history</code></a>, and
                            <a class="link" href="performance-schema.html#events-stages-history-long-table" title="25.12.5.3&nbsp;The events_stages_history_long Table"><code class="literal">events_stages_history_long</code></a>.
                        </p><p style="color:blue;">启用stage event consumer表，其中包括events_stages_current、events_stages_history和events_stages_history_long。</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>UPDATE performance_schema.setup_consumers SET ENABLED = 'YES' </code></strong>
       <strong class="userinput"><code>WHERE NAME LIKE '%stages%';</code></strong>
</pre></li><li class="listitem"><p>
                            Dump the current buffer pool state by enabling
                            <a class="link" href="innodb-storage-engine.html#sysvar_innodb_buffer_pool_dump_now"><code class="literal">innodb_buffer_pool_dump_now</code></a>.
                        </p><p style="color:blue;">立即启用innodb_buffer_pool_dump_，转储当前缓冲池状态。</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>SET GLOBAL innodb_buffer_pool_dump_now=ON;</code></strong>
</pre></li><li class="listitem"><p>
                            Check the buffer pool dump status to ensure that the
                            operation has completed.
                        </p><p style="color:blue;">检查缓冲池转储状态以确保操作已完成。</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>SHOW STATUS LIKE 'Innodb_buffer_pool_dump_status'\G</code></strong>
*************************** 1. row ***************************
Variable_name: Innodb_buffer_pool_dump_status
        Value: Buffer pool(s) dump completed at 150202 16:38:58
</pre></li><li class="listitem"><p>
                            Load the buffer pool by enabling
                            <a class="link" href="innodb-storage-engine.html#sysvar_innodb_buffer_pool_load_now"><code class="literal">innodb_buffer_pool_load_now</code></a>:
                        </p><p style="color:blue;">现在通过启用innodb_buffer_pool_load_来加载缓冲池：</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>SET GLOBAL innodb_buffer_pool_load_now=ON;</code></strong>
</pre></li><li class="listitem"><p>
                            Check the current status of the buffer pool load operation
                            by querying the Performance Schema
                            <a class="link" href="performance-schema.html#events-stages-current-table" title="25.12.5.1&nbsp;The events_stages_current Table"><code class="literal">events_stages_current</code></a> table.
                            The <code class="literal">WORK_COMPLETED</code> column shows the
                            number of buffer pool pages loaded. The
                            <code class="literal">WORK_ESTIMATED</code> column provides an
                            estimate of the remaining work, in pages.
                        </p><p style="color:blue;">通过查询performance schema events_stages_current表，检查缓冲池加载操作的当前状态。work_completed列显示加载的缓冲池页数。“工时估算”列以页为单位提供剩余工时的估算。</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT EVENT_NAME, WORK_COMPLETED, WORK_ESTIMATED</code></strong>
       <strong class="userinput"><code>FROM performance_schema.events_stages_current;</code></strong>
+-------------------------------+----------------+----------------+
| EVENT_NAME                    | WORK_COMPLETED | WORK_ESTIMATED |
+-------------------------------+----------------+----------------+
| stage/innodb/buffer pool load |           5353 |           7167 |
+-------------------------------+----------------+----------------+
</pre><p>
                            The <a class="link" href="performance-schema.html#events-stages-current-table" title="25.12.5.1&nbsp;The events_stages_current Table"><code class="literal">events_stages_current</code></a>
                            table returns an empty set if the buffer pool load
                            operation has completed. In this case, you can check the
                            <a class="link" href="performance-schema.html#events-stages-history-table" title="25.12.5.2&nbsp;The events_stages_history Table"><code class="literal">events_stages_history</code></a> table
                            to view data for the completed event. For example:
                        </p><p style="color:blue;">如果缓冲池加载操作已完成，则events_stages_current表返回空集。在这种情况下，可以检查events_stages_history表以查看已完成事件的数据。例如：</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT EVENT_NAME, WORK_COMPLETED, WORK_ESTIMATED </code></strong>
       <strong class="userinput"><code>FROM performance_schema.events_stages_history;</code></strong>
+-------------------------------+----------------+----------------+
| EVENT_NAME                    | WORK_COMPLETED | WORK_ESTIMATED |
+-------------------------------+----------------+----------------+
| stage/innodb/buffer pool load |           7167 |           7167 |
+-------------------------------+----------------+----------------+
</pre></li></ol>
                    </div>
                    <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">
                        <div class="admon-title">
                            Note
                        </div>
                        <p>
                            You can also monitor buffer pool load progress using
                            Performance Schema when loading the buffer pool at startup
                            using
                            <a class="link" href="innodb-storage-engine.html#sysvar_innodb_buffer_pool_load_at_startup"><code class="literal">innodb_buffer_pool_load_at_startup</code></a>.
                            In this case, the <code class="literal">stage/innodb/buffer pool
                            load</code> instrument and related consumers must be
                            enabled at startup. For more information, see
                            <a class="xref" href="performance-schema.html#performance-schema-startup-configuration" title="25.3&nbsp;Performance Schema Startup Configuration">Section&nbsp;25.3, “Performance Schema Startup Configuration”</a>.
                        </p><p style="color:blue;">在使用innodb_buffer_pool_load_at_startup在启动时加载缓冲池时，还可以使用性能模式监视缓冲池加载进度。在这种情况下，stage/innodb/buffer pool load instrument和相关的使用者必须在启动时启用。有关更多信息，请参阅25.3节“性能模式启动配置”。</p>
                    </div>

                </div>

            </div>

        </div>
        <div class="section">
            <div class="titlepage">
                <div>
                    <div>
                        <h3 class="title"><a name="innodb-performance-use_sys_malloc"></a>14.8.4&nbsp;Configuring the Memory Allocator for InnoDB</h3>

                    </div>

                </div>

            </div>
            <a class="indexterm" name="idm140286820083328"></a><a class="indexterm" name="idm140286820082288"></a><a class="indexterm" name="idm140286820080784"></a><a class="indexterm" name="idm140286820079296"></a><a class="indexterm" name="idm140286820077760"></a><p>
            When <code class="literal">InnoDB</code> was developed, the memory
            allocators supplied with operating systems and run-time libraries
            were often lacking in performance and scalability. At that time,
            there were no memory allocator libraries tuned for multi-core
            CPUs. Therefore, <code class="literal">InnoDB</code> implemented its own
            memory allocator in the <code class="literal">mem</code> subsystem. This
            allocator is guarded by a single mutex, which may become a
            <a class="link" href="glossary.html#glos_bottleneck" title="bottleneck">bottleneck</a>.
            <code class="literal">InnoDB</code> also implements a wrapper interface
            around the system allocator (<code class="literal">malloc</code> and
            <code class="literal">free</code>) that is likewise guarded by a single
            mutex.
        </p><p style="color:blue;">在开发innodb时，随操作系统和运行时库一起提供的内存分配器常常缺乏性能和可伸缩性。当时，没有为多核cpu调整内存分配程序库。因此，innodb在mem子系统中实现了自己的内存分配器。这个分配器由一个互斥锁保护，这可能成为一个瓶颈。innodb还在系统分配器（malloc和free）周围实现一个包装器接口，该接口同样由一个互斥锁保护。</p><p>
            Today, as multi-core systems have become more widely available,
            and as operating systems have matured, significant improvements
            have been made in the memory allocators provided with operating
            systems. These new memory allocators perform better and are more
            scalable than they were in the past. Most workloads, especially
            those where memory is frequently allocated and released (such as
            multi-table joins), benefit from using a more highly tuned memory
            allocator as opposed to the internal,
            <code class="literal">InnoDB</code>-specific memory allocator.
        </p><p style="color:blue;">如今，随着多核系统的广泛应用，以及操作系统的成熟，随操作系统一起提供的内存分配器有了显著的改进。与过去相比，这些新的内存分配器性能更好，可扩展性更强。大多数工作负载，特别是那些经常分配和释放内存的工作负载（例如多表连接），都受益于使用更高优化的内存分配器，而不是内部的、innodb特有的内存分配器。</p><p>
            You can control whether <code class="literal">InnoDB</code> uses its own
            memory allocator or an allocator of the operating system, by
            setting the value of the system configuration parameter
            <a class="link" href="innodb-storage-engine.html#sysvar_innodb_use_sys_malloc"><code class="literal">innodb_use_sys_malloc</code></a> in the
            MySQL option file (<code class="literal">my.cnf</code> or
            <code class="literal">my.ini</code>). If set to <code class="literal">ON</code> or
            <code class="literal">1</code> (the default), <code class="literal">InnoDB</code> uses
            the <code class="literal">malloc</code> and <code class="literal">free</code>
            functions of the underlying system rather than manage memory pools
            itself. This parameter is not dynamic, and takes effect only when
            the system is started. To continue to use the
            <code class="literal">InnoDB</code> memory allocator, set
            <a class="link" href="innodb-storage-engine.html#sysvar_innodb_use_sys_malloc"><code class="literal">innodb_use_sys_malloc</code></a> to
            <code class="literal">0</code>.
        </p><p style="color:blue;">通过设置mysql选项文件（my.cnf或my.ini）中的系统配置参数innodb_use_sys_malloc的值，可以控制innodb是使用自己的内存分配器还是操作系统的分配器。如果设置为on或1（默认），innodb将使用底层系统的malloc和free函数，而不是管理内存池本身。此参数不是动态的，仅在系统启动时生效。要继续使用innodb内存分配器，请将innodb_use_sys_malloc设置为0。</p><p>
            When the <code class="literal">InnoDB</code> memory allocator is disabled,
            <code class="literal">InnoDB</code> ignores the value of the parameter
            <a class="link" href="innodb-storage-engine.html#sysvar_innodb_additional_mem_pool_size"><code class="literal">innodb_additional_mem_pool_size</code></a>.
            The <code class="literal">InnoDB</code> memory allocator uses an additional
            memory pool for satisfying allocation requests without having to
            fall back to the system memory allocator. When the
            <code class="literal">InnoDB</code> memory allocator is disabled, all such
            allocation requests are fulfilled by the system memory allocator.
        </p><p style="color:blue;">当innodb内存分配器被禁用时，innodb忽略参数innodb_additional_mem_pool_size的值。innodb内存分配器使用一个额外的内存池来满足分配请求，而不必返回到系统内存分配器。当InnoDB内存分配器被禁用时，所有这些分配请求都由系统内存分配器完成。</p><p>
            On Unix-like systems that use dynamic linking, replacing the
            memory allocator may be as easy as making the environment variable
            <code class="literal">LD_PRELOAD</code> or
            <code class="literal">LD_LIBRARY_PATH</code> point to the dynamic library
            that implements the allocator. On other systems, some relinking
            may be necessary. Please refer to the documentation of the memory
            allocator library of your choice.
        </p><p style="color:blue;">在使用动态链接的类unix系统上，替换内存分配器可能与使环境变量ld_preload或ld_library_path指向实现分配器的动态库一样简单。在其他系统上，可能需要重新链接。请参考您选择的内存分配器库的文档。</p><p>
            Since <code class="literal">InnoDB</code> cannot track all memory use when
            the system memory allocator is used
            (<a class="link" href="innodb-storage-engine.html#sysvar_innodb_use_sys_malloc"><code class="literal">innodb_use_sys_malloc</code></a> is
            <code class="literal">ON</code>), the section <span class="quote">“<span class="quote">BUFFER POOL AND
      MEMORY</span>”</span> in the output of the <code class="literal">SHOW ENGINE INNODB
            STATUS</code> command only includes the buffer pool statistics
            in the <span class="quote">“<span class="quote">Total memory allocated</span>”</span>. Any memory allocated
            using the <code class="literal">mem</code> subsystem or using
            <code class="literal">ut_malloc</code> is excluded.
        </p><p style="color:blue;">由于InnoDB无法跟踪使用系统内存分配器时的所有内存使用情况（InnoDB_use_sys_malloc处于打开状态），因此show engine innoDB status命令输出中的“缓冲池和内存”部分仅包括“分配的总内存”中的缓冲池统计信息。不包括使用mem子系统或ut malloc分配的任何内存。</p>
            <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">

                <div class="admon-title">
                    Note
                </div>
                <p>
                    <a class="link" href="innodb-storage-engine.html#sysvar_innodb_use_sys_malloc"><code class="literal">innodb_use_sys_malloc</code></a> and
                    <a class="link" href="innodb-storage-engine.html#sysvar_innodb_additional_mem_pool_size"><code class="literal">innodb_additional_mem_pool_size</code></a>
                    were deprecated in MySQL 5.6 and removed in MySQL
                    5.7.
                </p><p style="color:blue;">innodb_use_sys_malloc和innodb_additional_mem_pool_size在mysql 5.6中被弃用，在mysql 5.7中被删除。</p>
            </div>
            <p>
                For more information about the performance implications of
                <code class="literal">InnoDB</code> memory usage, see
                <a class="xref" href="optimization.html#buffering-caching" title="8.10&nbsp;Buffering and Caching">Section&nbsp;8.10, “Buffering and Caching”</a>.
            </p><p style="color:blue;">有关innodb内存使用的性能影响的更多信息，请参阅8.10节“缓冲和缓存”。</p>
        </div>
        <div class="section">
            <div class="titlepage">
                <div>
                    <div>
                        <h3 class="title"><a name="innodb-performance-thread_concurrency"></a>14.8.5&nbsp;Configuring Thread Concurrency for InnoDB</h3>

                    </div>

                </div>

            </div>
            <a class="indexterm" name="idm140286820038192"></a><a class="indexterm" name="idm140286820037152"></a><a class="indexterm" name="idm140286820036064"></a><a class="indexterm" name="idm140286820034976"></a><a class="indexterm" name="idm140286820033472"></a><p>
            <code class="literal">InnoDB</code> uses operating system
            <a class="link" href="glossary.html#glos_thread" title="thread">threads</a> to process requests
            from user transactions. (Transactions may issue many requests to
            <code class="literal">InnoDB</code> before they commit or roll back.) On
            modern operating systems and servers with multi-core processors,
            where context switching is efficient, most workloads run well
            without any limit on the number of concurrent threads. Scalability
            improvements in MySQL 5.5 and up reduce the need to limit the
            number of concurrently executing threads inside
            <code class="literal">InnoDB</code>.
        </p><p style="color:blue;">innodb使用操作系统线程处理来自用户事务的请求。（事务在提交或回滚之前可能会向innodb发出许多请求。）在具有多核处理器的现代操作系统和服务器上，在上下文切换非常有效的情况下，大多数工作负载在不限制并发线程数量的情况下运行良好。mysql 5.5及以上版本的可伸缩性改进减少了限制innodb内并发执行线程数量的需要。</p><p>
            In situations where it is helpful to minimize context switching
            between threads, <code class="literal">InnoDB</code> can use a number of
            techniques to limit the number of concurrently executing operating
            system threads (and thus the number of requests that are processed
            at any one time). When <code class="literal">InnoDB</code> receives a new
            request from a user session, if the number of threads concurrently
            executing is at a pre-defined limit, the new request sleeps for a
            short time before it tries again. A request that cannot be
            rescheduled after the sleep is put in a first-in/first-out queue
            and eventually is processed. Threads waiting for locks are not
            counted in the number of concurrently executing threads.
        </p><p style="color:blue;">在有助于最小化线程之间的上下文切换的情况下，innodb可以使用许多技术来限制并发执行的操作系统线程的数量（从而限制一次处理的请求的数量）。当innodb从用户会话接收到一个新请求时，如果并发执行的线程数达到了预先定义的限制，那么新请求在再次尝试之前会休眠一小段时间。在睡眠被放入先进先出队列并最终被处理后，不能重新调度的请求。等待锁定的线程不计入并发执行的线程数。</p><p>
            You can limit the number of concurrent threads by setting the
            configuration parameter
            <a class="link" href="innodb-storage-engine.html#sysvar_innodb_thread_concurrency"><code class="literal">innodb_thread_concurrency</code></a>. Once
            the number of executing threads reaches this limit, additional
            threads sleep for a number of microseconds, set by the
            configuration parameter
            <a class="link" href="innodb-storage-engine.html#sysvar_innodb_thread_sleep_delay"><code class="literal">innodb_thread_sleep_delay</code></a>, before
            being placed into the queue.
        </p><p style="color:blue;">您可以通过设置配置参数innodb_thread_concurrency来限制并发线程的数量。一旦执行线程的数量达到此限制，额外的线程将在放入队列之前休眠若干微秒，由配置参数innodb_thread_sleep_delay设置。</p><p>
            Previously, it required experimentation to find the optimal value
            for <a class="link" href="innodb-storage-engine.html#sysvar_innodb_thread_sleep_delay"><code class="literal">innodb_thread_sleep_delay</code></a>,
            and the optimal value could change depending on the workload. In
            MySQL 5.6.3 and higher, you can set the configuration option
            <a class="link" href="innodb-storage-engine.html#sysvar_innodb_adaptive_max_sleep_delay"><code class="literal">innodb_adaptive_max_sleep_delay</code></a>
            to the highest value you would allow for
            <a class="link" href="innodb-storage-engine.html#sysvar_innodb_thread_sleep_delay"><code class="literal">innodb_thread_sleep_delay</code></a>, and
            <code class="literal">InnoDB</code> automatically adjusts
            <a class="link" href="innodb-storage-engine.html#sysvar_innodb_thread_sleep_delay"><code class="literal">innodb_thread_sleep_delay</code></a> up or
            down depending on the current thread-scheduling activity. This
            dynamic adjustment helps the thread scheduling mechanism to work
            smoothly during times when the system is lightly loaded and when
            it is operating near full capacity.
        </p><p style="color:blue;">以前，需要通过实验来找到innodb_线程睡眠_延迟的最佳值，而最佳值可能会随工作负载的变化而变化。在mysql 5.6.3及更高版本中，可以将配置选项innodb_adaptive_max_sleep_delay设置为innodb_thread_sleep_delay允许的最大值，innodb会根据当前的线程调度活动自动上下调整innodb_thread_sleep_delay。这种动态调整有助于线程调度机制在系统轻载和接近满负荷运行时顺利工作。</p><p>
            The default value for
            <a class="link" href="innodb-storage-engine.html#sysvar_innodb_thread_concurrency"><code class="literal">innodb_thread_concurrency</code></a> and the
            implied default limit on the number of concurrent threads has been
            changed in various releases of MySQL and
            <code class="literal">InnoDB</code>. The default value of
            <a class="link" href="innodb-storage-engine.html#sysvar_innodb_thread_concurrency"><code class="literal">innodb_thread_concurrency</code></a> is
            <code class="literal">0</code>, so that by default there is no limit on the
            number of concurrently executing threads.
        </p><p style="color:blue;">在mysql和innodb的不同版本中，innodb_thread_concurrency的默认值和隐含的并发线程数的默认限制都已更改。innodb_thread_concurrency的默认值是0，因此默认情况下，并发执行的线程数没有限制。</p><p>
            <code class="literal">InnoDB</code> causes threads to sleep only when the
            number of concurrent threads is limited. When there is no limit on
            the number of threads, all contend equally to be scheduled. That
            is, if <a class="link" href="innodb-storage-engine.html#sysvar_innodb_thread_concurrency"><code class="literal">innodb_thread_concurrency</code></a>
            is <code class="literal">0</code>, the value of
            <a class="link" href="innodb-storage-engine.html#sysvar_innodb_thread_sleep_delay"><code class="literal">innodb_thread_sleep_delay</code></a> is
            ignored.
        </p><p style="color:blue;">InnoDB只在并发线程数量有限的情况下才会导致线程休眠。当线程的数量没有限制时，所有线程都平等地进行调度。也就是说，如果innodb_thread_concurrency为0，则忽略innodb_thread_sleep_delay的值。</p><p>
            When there is a limit on the number of threads (when
            <a class="link" href="innodb-storage-engine.html#sysvar_innodb_thread_concurrency"><code class="literal">innodb_thread_concurrency</code></a> is &gt;
            0), <code class="literal">InnoDB</code> reduces context switching overhead
            by permitting multiple requests made during the execution of a
            <span class="emphasis"><em>single SQL statement</em></span> to enter
            <code class="literal">InnoDB</code> without observing the limit set by
            <a class="link" href="innodb-storage-engine.html#sysvar_innodb_thread_concurrency"><code class="literal">innodb_thread_concurrency</code></a>. Since
            an SQL statement (such as a join) may comprise multiple row
            operations within <code class="literal">InnoDB</code>,
            <code class="literal">InnoDB</code> assigns a specified number of
            <span class="quote">“<span class="quote">tickets</span>”</span> that allow a thread to be scheduled
            repeatedly with minimal overhead.
        </p><p style="color:blue;">当线程数有限制时（当innodb_thread_concurrency&gt;0时），innodb通过允许在执行单个sql语句期间发出的多个请求进入innodb而不遵守innodb_thread_concurrency设置的限制来减少上下文切换开销。由于一个sql语句（例如join）可能包含innodb中的多行操作，innodb分配指定数量的“票据”，允许以最小的开销重复调度线程。</p><p>
            When a new SQL statement starts, a thread has no tickets, and it
            must observe
            <a class="link" href="innodb-storage-engine.html#sysvar_innodb_thread_concurrency"><code class="literal">innodb_thread_concurrency</code></a>. Once
            the thread is entitled to enter <code class="literal">InnoDB</code>, it is
            assigned a number of tickets that it can use for subsequently
            entering <code class="literal">InnoDB</code> to perform row operations. If
            the tickets run out, the thread is evicted, and
            <a class="link" href="innodb-storage-engine.html#sysvar_innodb_thread_concurrency"><code class="literal">innodb_thread_concurrency</code></a> is
            observed again which may place the thread back into the
            first-in/first-out queue of waiting threads. When the thread is
            once again entitled to enter <code class="literal">InnoDB</code>, tickets
            are assigned again. The number of tickets assigned is specified by
            the global option
            <a class="link" href="innodb-storage-engine.html#sysvar_innodb_concurrency_tickets"><code class="literal">innodb_concurrency_tickets</code></a>, which
            is 5000 by default. A thread that is waiting for a lock is given
            one ticket once the lock becomes available.
        </p><p style="color:blue;">当一个新的sql语句启动时，一个线程没有票据，它必须遵守innodb_thread_concurrency。一旦线程有权进入innodb，它就被分配了一些票证，可以用来随后进入innodb执行行操作。如果票证用完，线程将被逐出，并且再次观察到innodb_thread_并发性，这可能会将线程放回等待线程的first-in/first-out队列中。当线程再次有权进入innodb时，将再次分配票证。分配的票证数量由全局选项innodb_concurrency_tickets指定，默认为5000。当锁可用时，等待锁的线程将获得一张票据。</p><p>
            The correct values of these variables depend on your environment
            and workload. Try a range of different values to determine what
            value works for your applications. Before limiting the number of
            concurrently executing threads, review configuration options that
            may improve the performance of <code class="literal">InnoDB</code> on
            multi-core and multi-processor computers, such as
            <a class="link" href="innodb-storage-engine.html#sysvar_innodb_adaptive_hash_index"><code class="literal">innodb_adaptive_hash_index</code></a>.
        </p><p style="color:blue;">这些变量的正确值取决于您的环境和工作负载。尝试一系列不同的值来确定哪些值适合您的应用程序。在限制并发执行线程的数量之前，请检查可以在多核和多处理器计算机上提高innodb性能的配置选项，例如innodb_adaptive_hash_index。</p><p>
            For general performance information about MySQL thread handling,
            see <a class="xref" href="optimization.html#client-connections" title="8.12.5.1&nbsp;How MySQL Handles Client Connections">Section&nbsp;8.12.5.1, “How MySQL Handles Client Connections”</a>.
        </p><p style="color:blue;">有关mysql线程处理的一般性能信息，请参阅8.12.5.1节“mysql如何处理客户端连接”。</p>
        </div>
        <div class="section">
            <div class="titlepage">
                <div>
                    <div>
                        <h3 class="title"><a name="innodb-performance-multiple_io_threads"></a>14.8.6&nbsp;Configuring the Number of Background InnoDB I/O Threads</h3>

                    </div>

                </div>

            </div>
            <a class="indexterm" name="idm140286819986816"></a><a class="indexterm" name="idm140286819985744"></a><a class="indexterm" name="idm140286819984672"></a><a class="indexterm" name="idm140286819983216"></a><p>
            <code class="literal">InnoDB</code> uses background
            <a class="link" href="glossary.html#glos_thread" title="thread">threads</a> to service various
            types of I/O requests. You can configure the number of background
            threads that service read and write I/O on data pages using the
            <a class="link" href="innodb-storage-engine.html#sysvar_innodb_read_io_threads"><code class="literal">innodb_read_io_threads</code></a> and
            <a class="link" href="innodb-storage-engine.html#sysvar_innodb_write_io_threads"><code class="literal">innodb_write_io_threads</code></a>
            configuration parameters. These parameters signify the number of
            background threads used for read and write requests, respectively.
            They are effective on all supported platforms. You can set values
            for these parameters in the MySQL option file
            (<code class="literal">my.cnf</code> or <code class="literal">my.ini</code>); you
            cannot change values dynamically. The default value for these
            parameters is <code class="literal">4</code> and permissible values range
            from <code class="literal">1-64</code>.
        </p><p style="color:blue;">innodb使用后台线程来服务各种类型的i/o请求。您可以使用innodb-read-i o-u线程和innodb-write-io-u线程配置参数配置为数据页上的读写i/o提供服务的后台线程数。这些参数分别表示用于读和写请求的后台线程数。它们在所有受支持的平台上都有效。可以在mysql选项文件（my.cnf或my.ini）中设置这些参数的值；不能动态更改值。这些参数的默认值为4，允许值范围为1-64。</p><p>
            The purpose of these configuration options to make
            <code class="literal">InnoDB</code> more scalable on high end systems. Each
            background thread can handle up to 256 pending I/O requests. A
            major source of background I/O is
            <a class="link" href="glossary.html#glos_read_ahead" title="read-ahead">read-ahead</a> requests.
            <code class="literal">InnoDB</code> tries to balance the load of incoming
            requests in such way that most background threads share work
            equally. <code class="literal">InnoDB</code> also attempts to allocate read
            requests from the same extent to the same thread, to increase the
            chances of coalescing the requests. If you have a high end I/O
            subsystem and you see more than 64 ×
            <a class="link" href="innodb-storage-engine.html#sysvar_innodb_read_io_threads"><code class="literal">innodb_read_io_threads</code></a> pending
            read requests in <code class="literal">SHOW ENGINE INNODB STATUS</code>
            output, you might improve performance by increasing the value of
            <a class="link" href="innodb-storage-engine.html#sysvar_innodb_read_io_threads"><code class="literal">innodb_read_io_threads</code></a>.
        </p><p style="color:blue;">这些配置选项的目的是使innodb在高端系统上更具可扩展性。每个后台线程最多可以处理256个挂起的I/O请求。后台I/O的一个主要来源是预读请求。innodb试图平衡传入请求的负载，这样大多数后台线程可以平等地共享工作。innodb还试图将来自同一区段的读请求分配给同一线程，以增加合并请求的机会。如果您有一个高端I/O子系统，并且在Show Engine InnoDB Status Output中看到超过64×InnoDB_Read_IO_线程挂起的读取请求，那么您可以通过增加InnoDB_Read_IO_线程的值来提高性能。</p><p>
            On Linux systems, <code class="literal">InnoDB</code> uses the asynchronous
            I/O subsystem by default to perform read-ahead and write requests
            for data file pages, which changes the way that
            <code class="literal">InnoDB</code> background threads service these types
            of I/O requests. For more information, see
            <a class="xref" href="innodb-storage-engine.html#innodb-linux-native-aio" title="14.8.7&nbsp;Using Asynchronous I/O on Linux">Section&nbsp;14.8.7, “Using Asynchronous I/O on Linux”</a>.
        </p><p style="color:blue;">在linux系统上，innodb默认使用异步i/o子系统来执行数据文件页的读写请求，这改变了innodb后台线程为这些类型的i/o请求提供服务的方式。有关更多信息，请参阅14.8.7节，“在Linux上使用异步I/O”。</p><p>
            For more information about <code class="literal">InnoDB</code> I/O
            performance, see <a class="xref" href="optimization.html#optimizing-innodb-diskio" title="8.5.8&nbsp;Optimizing InnoDB Disk I/O">Section&nbsp;8.5.8, “Optimizing InnoDB Disk I/O”</a>.
        </p><p style="color:blue;">有关InnoDB I/O性能的更多信息，请参阅8.5.8节“优化InnoDB磁盘I/O”。</p>
        </div>
        <div class="section">
            <div class="titlepage">
                <div>
                    <div>
                        <h3 class="title"><a name="innodb-linux-native-aio"></a>14.8.7&nbsp;Using Asynchronous I/O on Linux</h3>

                    </div>

                </div>

            </div>
            <a class="indexterm" name="idm140286819960480"></a><a class="indexterm" name="idm140286819959024"></a><a class="indexterm" name="idm140286819957536"></a><a class="indexterm" name="idm140286819956464"></a><p>
            <code class="literal">InnoDB</code> uses the asynchronous I/O subsystem
            (native AIO) on Linux to perform read-ahead and write requests for
            data file pages. This behavior is controlled by the
            <a class="link" href="innodb-storage-engine.html#sysvar_innodb_use_native_aio"><code class="literal">innodb_use_native_aio</code></a>
            configuration option, which applies to Linux systems only and is
            enabled by default. On other Unix-like systems,
            <code class="literal">InnoDB</code> uses synchronous I/O only. Historically,
            <code class="literal">InnoDB</code> only used asynchronous I/O on Windows
            systems. Using the asynchronous I/O subsystem on Linux requires
            the <code class="literal">libaio</code> library.
        </p><p style="color:blue;">innodb使用linux上的异步i/o子系统（本地aio）来执行数据文件页的读写请求。此行为由innodb_use_native_aio配置选项控制，该选项仅适用于Linux系统，默认情况下启用。在其他类unix系统上，innodb只使用同步i/o。过去，innodb只在windows系统上使用异步i/o。在Linux上使用异步I/O子系统需要libaio库。</p><p>
            With synchronous I/O, query threads queue I/O requests, and
            <code class="literal">InnoDB</code> background threads retrieve the queued
            requests one at a time, issuing a synchronous I/O call for each.
            When an I/O request is completed and the I/O call returns, the
            <code class="literal">InnoDB</code> background thread that is handling the
            request calls an I/O completion routine and returns to process the
            next request. The number of requests that can be processed in
            parallel is <em class="replaceable"><code>n</code></em>, where
            <em class="replaceable"><code>n</code></em> is the number of
            <code class="literal">InnoDB</code> background threads. The number of
            <code class="literal">InnoDB</code> background threads is controlled by
            <a class="link" href="innodb-storage-engine.html#sysvar_innodb_read_io_threads"><code class="literal">innodb_read_io_threads</code></a> and
            <a class="link" href="innodb-storage-engine.html#sysvar_innodb_write_io_threads"><code class="literal">innodb_write_io_threads</code></a>. See
            <a class="xref" href="innodb-storage-engine.html#innodb-performance-multiple_io_threads" title="14.8.6&nbsp;Configuring the Number of Background InnoDB I/O Threads">Section&nbsp;14.8.6, “Configuring the Number of Background InnoDB I/O Threads”</a>.
        </p><p style="color:blue;">对于同步I/O，查询线程将I/O请求排队，InnoDB后台线程一次检索一个排队的请求，为每个请求发出一个同步I/O调用。当一个I/O请求完成并且I/O调用返回时，处理该请求的InnoDB后台线程调用一个I/O完成例程并返回以处理下一个请求。可以并行处理的请求数为n，其中n为innodb后台线程数。innodb后台线程的数量由innodb_read_io_线程和innodb_write_io_线程控制。参见14.8.6节，“配置后台InnoDB I/O线程数”。</p><p>
            With native AIO, query threads dispatch I/O requests directly to
            the operating system, thereby removing the limit imposed by the
            number of background threads. <code class="literal">InnoDB</code> background
            threads wait for I/O events to signal completed requests. When a
            request is completed, a background thread calls an I/O completion
            routine and resumes waiting for I/O events.
        </p><p style="color:blue;">使用本机aio，查询线程将i/o请求直接分派到操作系统，从而消除了后台线程数量的限制。InnoDB后台线程等待I/O事件发出已完成请求的信号。当请求完成时，后台线程调用I/O完成例程并继续等待I/O事件。</p><p>
            The advantage of native AIO is scalability for heavily I/O-bound
            systems that typically show many pending reads/writes in
            <code class="literal">SHOW ENGINE INNODB STATUS\G</code> output. The
            increase in parallel processing when using native AIO means that
            the type of I/O scheduler or properties of the disk array
            controller have a greater influence on I/O performance.
        </p><p style="color:blue;">本机aio的优点是，对于通常在show engine innodb status\g输出中显示许多挂起的读/写的受i/o限制的系统，它具有可伸缩性。使用本机a i o时并行处理的增加意味着i/o调度程序的类型或磁盘阵列控制器的属性对i/o性能有更大的影响。</p><p>
            A potential disadvantage of native AIO for heavily I/O-bound
            systems is lack of control over the number of I/O write requests
            dispatched to the operating system at once. Too many I/O write
            requests dispatched to the operating system for parallel
            processing could, in some cases, result in I/O read starvation,
            depending on the amount of I/O activity and system capabilities.
        </p><p style="color:blue;">对于受i/o限制严重的系统，本机aio的一个潜在缺点是无法控制一次发送到操作系统的i/o写请求的数量。在某些情况下，调度到操作系统进行并行处理的I/O写请求过多可能导致I/O读不足，具体取决于I/O活动量和系统功能。</p><p>
            If a problem with the asynchronous I/O subsystem in the OS
            prevents <code class="literal">InnoDB</code> from starting, you can start
            the server with
            <a class="link" href="innodb-storage-engine.html#sysvar_innodb_use_native_aio"><code class="literal">innodb_use_native_aio=0</code></a>. This
            option may also be disabled automatically during startup if
            <code class="literal">InnoDB</code> detects a potential problem such as a
            combination of <code class="literal">tmpdir</code> location,
            <code class="literal">tmpfs</code> file system, and Linux kernel that does
            not support asynchronous I/O on <code class="literal">tmpfs</code>.
        </p><p style="color:blue;">如果操作系统中的异步I/O子系统出现问题，导致InnoDB无法启动，则可以使用InnoDB use_native_a i o=0启动服务器。如果innodb检测到潜在的问题，例如tmpdir位置、tmpfs文件系统和linux内核的组合不支持tmpfs上的异步i/o，则在启动期间也可以自动禁用此选项。</p>
        </div>
        <div class="section">
            <div class="titlepage">
                <div>
                    <div>
                        <h3 class="title"><a name="innodb-configuring-io-capacity"></a>14.8.8&nbsp;Configuring InnoDB I/O Capacity</h3>

                    </div>

                </div>

            </div>
            <a class="indexterm" name="idm140286819931984"></a><a class="indexterm" name="idm140286819930912"></a><p>
            The <code class="literal">InnoDB</code> master thread and other threads
            perform various tasks in the background, most of which are I/O
            related, such as flushing dirty pages from the buffer pool and
            writing changes from the change buffer to the appropriate
            secondary indexes. <code class="literal">InnoDB</code> attempts to perform
            these tasks in a way that does not adversely affect the normal
            working of the server. It tries to estimate the available I/O
            bandwidth and tune its activities to take advantage of available
            capacity.
        </p><p style="color:blue;">innodb主线程和其他线程在后台执行各种任务，其中大部分都与i/o相关，比如从缓冲池刷新脏页，将更改从更改缓冲区写入适当的辅助索引。InnoDB试图以不影响服务器正常工作的方式执行这些任务。它试图估计可用的I/O带宽，并调整其活动以利用可用容量。</p><p>
            The <a class="link" href="innodb-storage-engine.html#sysvar_innodb_io_capacity"><code class="literal">innodb_io_capacity</code></a> variable
            defines the overall I/O capacity available to
            <code class="literal">InnoDB</code>. It should be set to approximately the
            number of I/O operations that the system can perform per second
            (IOPS). When <a class="link" href="innodb-storage-engine.html#sysvar_innodb_io_capacity"><code class="literal">innodb_io_capacity</code></a>
            is set, <code class="literal">InnoDB</code> estimates the I/O bandwidth
            available for background tasks based on the set value.
        </p><p style="color:blue;">innodb_i o_capacity变量定义了innodb可用的总i/o容量。它应该被设置为系统能够每秒执行的I/O操作的数量。当设置了innodb_i o_capacity时，innodb根据设置值估计后台任务可用的i/o带宽。</p><p>
            You can set <a class="link" href="innodb-storage-engine.html#sysvar_innodb_io_capacity"><code class="literal">innodb_io_capacity</code></a> to
            a value of 100 or greater. The default value is
            <code class="literal">200</code>. Typically, values around 100 are
            appropriate for consumer-level storage devices, such as hard
            drives up to 7200 RPMs. Faster hard drives, RAID configurations,
            and solid state drives (SSDs) benefit from higher values.
        </p><p style="color:blue;">您可以将innodb_io_capacity设置为100或更大的值。默认值为200。通常，100左右的值适用于消费级存储设备，例如高达7200转/分的硬盘驱动器。更快的硬盘驱动器、RAID配置和固态驱动器（固态驱动器）受益于更高的值。</p><p>
            Ideally, keep the setting as low as practical, but not so low that
            background activities fall behind. If the value is too high, data
            is removed from the buffer pool and change buffer too quickly for
            caching to provide a significant benefit. For busy systems capable
            of higher I/O rates, you can set a higher value to help the server
            handle the background maintenance work associated with a high rate
            of row changes. Generally, you can increase the value as a
            function of the number of drives used for
            <code class="literal">InnoDB</code> I/O. For example, you can increase the
            value on systems that use multiple disks or SSDs.
        </p><p style="color:blue;">理想情况下，尽量降低设置的实际值，但不要太低以至于背景活动落后。如果该值太高，则会从缓冲池中删除数据，并快速更改缓冲区以进行缓存，从而提供显著的好处。对于能够提高I/O速率的繁忙系统，可以设置更高的值，以帮助服务器处理与高行更改速率相关联的后台维护工作。通常，可以根据innodb i/o所用驱动器的数量来增加该值。例如，可以在使用多个磁盘或ssd的系统上增加该值。</p><p>
            The default setting of 200 is generally sufficient for a lower-end
            SSD. For a higher-end, bus-attached SSD, consider a higher setting
            such as 1000, for example. For systems with individual 5400 RPM or
            7200 RPM drives, you might lower the value to 100, which
            represents an estimated proportion of the I/O operations per
            second (IOPS) available to older-generation disk drives that can
            perform about 100 IOPS.
        </p><p style="color:blue;">对于低端ssd，默认设置200通常就足够了。对于更高端、总线连接的ssd，请考虑更高的设置，例如1000。对于具有单独5400 RPM或7200 RPM驱动器的系统，可以将该值降低到100，这表示可以执行大约100 IOPS的旧一代磁盘驱动器每秒可用I/O操作（IOPS）的估计比例。</p><p>
            Although you can specify a high value such as a million, in
            practice such large values have little benefit. Generally, a value
            higher than 20000 is not recommended unless you are certain that
            lower values are insufficient for your workload.
        </p><p style="color:blue;">尽管您可以指定一个高值，例如一百万，但实际上，如此大的值几乎没有什么好处。一般来说，除非您确定较低的值不足以满足您的工作负载，否则不建议使用高于20000的值。</p><p>
            Consider write workload when tuning
            <a class="link" href="innodb-storage-engine.html#sysvar_innodb_io_capacity"><code class="literal">innodb_io_capacity</code></a>. Systems with
            large write workloads are likely to benefit from a higher setting.
            A lower setting may be sufficient for systems with a small write
            workload.
        </p><p style="color:blue;">在调整innodb_io_容量时考虑写工作负载。具有大量写工作负载的系统可能会受益于更高的设置。较低的设置对于写工作负载较小的系统来说可能就足够了。</p><p>
            The <a class="link" href="innodb-storage-engine.html#sysvar_innodb_io_capacity"><code class="literal">innodb_io_capacity</code></a> setting is
            not a per buffer pool instance setting. Available I/O capacity is
            distributed equally among buffer pool instances for flushing
            activities.
        </p><p style="color:blue;">innodb_io_capacity设置不是每个缓冲池实例的设置。可用的I/O容量在用于刷新活动的缓冲池实例之间平均分配。</p><p>
            You can set the
            <a class="link" href="innodb-storage-engine.html#sysvar_innodb_io_capacity"><code class="literal">innodb_io_capacity</code></a> value in the
            MySQL option file (<code class="literal">my.cnf</code> or
            <code class="literal">my.ini</code>) or modify it at runtime using a
            <a class="link" href="sql-syntax.html#set-variable" title="13.7.4.1&nbsp;SET Syntax for Variable Assignment"><code class="literal">SET GLOBAL</code></a>
            statement, which requires privileges sufficient to set global
            system variables. See
            <a class="xref" href="server-administration.html#system-variable-privileges" title="5.1.8.1&nbsp;System Variable Privileges">Section&nbsp;5.1.8.1, “System Variable Privileges”</a>.
        </p><p style="color:blue;">您可以在mysql选项文件（my.cnf或my.ini）中设置innodb_io_capacity值，或者在运行时使用set global语句修改它，这需要足够的权限来设置全局系统变量。见第5.1.8.1节“系统变量特权”。</p>
            <div class="simplesect">

                <div class="titlepage">
                    <div>

                        <div class="simple">
                            <h4 class="title"><a name="innodb-ignore-io-capacity"></a>Ignoring I/O Capacity at Checkpoints</h4>
                        </div>
                    </div>
                </div>
                <p>
                    The <a class="link" href="innodb-storage-engine.html#sysvar_innodb_flush_sync"><code class="literal">innodb_flush_sync</code></a> variable,
                    which is enabled by default, causes the
                    <a class="link" href="innodb-storage-engine.html#sysvar_innodb_io_capacity"><code class="literal">innodb_io_capacity</code></a> setting to
                    be ignored during bursts of I/O activity that occur at
                    <a class="link" href="glossary.html#glos_checkpoint" title="checkpoint">checkpoints</a>. To adhere to
                    the I/O rate defined by the
                    <a class="link" href="innodb-storage-engine.html#sysvar_innodb_io_capacity"><code class="literal">innodb_io_capacity</code></a> setting,
                    disable <a class="link" href="innodb-storage-engine.html#sysvar_innodb_flush_sync"><code class="literal">innodb_flush_sync</code></a>.
                </p><p style="color:blue;">默认启用的innodb_flush_sync变量会导致在检查点发生的I/O活动突发期间忽略innodb_i o_容量设置。要遵循innodb_i o_容量设置定义的I/O速率，请禁用innodb_flush_sync。</p><p>
                You can set the
                <a class="link" href="innodb-storage-engine.html#sysvar_innodb_flush_sync"><code class="literal">innodb_flush_sync</code></a> value in the
                MySQL option file (<code class="literal">my.cnf</code> or
                <code class="literal">my.ini</code>) or modify it at runtime using a
                <a class="link" href="sql-syntax.html#set-variable" title="13.7.4.1&nbsp;SET Syntax for Variable Assignment"><code class="literal">SET
                    GLOBAL</code></a> statement, which requires privileges sufficient
                to set global system variables. See
                <a class="xref" href="server-administration.html#system-variable-privileges" title="5.1.8.1&nbsp;System Variable Privileges">Section&nbsp;5.1.8.1, “System Variable Privileges”</a>.
            </p><p style="color:blue;">您可以在mysql选项文件（my.cnf或my.ini）中设置innodb_flush_sync值，或者在运行时使用set global语句修改它，这需要足够的权限来设置全局系统变量。见第5.1.8.1节“系统变量特权”。</p>
            </div>
            <div class="simplesect">
                <div class="titlepage">
                    <div>
                        <div class="simple">
                            <h4 class="title"><a name="innodb-io-capacity-maximum"></a>Configuring an I/O Capacity Maximum</h4>

                        </div>

                    </div>

                </div>
                <p>
                    If flushing activity falls behind, <code class="literal">InnoDB</code> can
                    flush more aggressively, at a higher rate of I/O operations per
                    second (IOPS) than defined by the
                    <a class="link" href="innodb-storage-engine.html#sysvar_innodb_io_capacity"><code class="literal">innodb_io_capacity</code></a> variable.
                    The <a class="link" href="innodb-storage-engine.html#sysvar_innodb_io_capacity_max"><code class="literal">innodb_io_capacity_max</code></a>
                    variable defines a maximum number of IOPS performed by
                    <code class="literal">InnoDB</code> background tasks in such situations.
                </p><p style="color:blue;">如果刷新活动落后，innodb可以以比innodb_i o_capacity变量定义的更高的每秒I/O操作速率（IOPS）更积极地刷新。NoNdByIOxLoabyTyxMax变量定义了在这种情况下由INODB后台任务执行的最大IOP数。</p><p>
                If you specify an
                <a class="link" href="innodb-storage-engine.html#sysvar_innodb_io_capacity"><code class="literal">innodb_io_capacity</code></a> setting at
                startup but do not specify a value for
                <a class="link" href="innodb-storage-engine.html#sysvar_innodb_io_capacity_max"><code class="literal">innodb_io_capacity_max</code></a>,
                <a class="link" href="innodb-storage-engine.html#sysvar_innodb_io_capacity_max"><code class="literal">innodb_io_capacity_max</code></a> defaults
                to twice the value of
                <a class="link" href="innodb-storage-engine.html#sysvar_innodb_io_capacity"><code class="literal">innodb_io_capacity</code></a>, with a
                minimum value of 2000.
            </p><p style="color:blue;">如果在启动时指定innodb_io_capacity设置，但未指定innodb_io_capacity_max的值，则innodb_io_capacity_max默认为innodb_io_capacity的两倍，最小值为2000。</p><p>
                When configuring
                <a class="link" href="innodb-storage-engine.html#sysvar_innodb_io_capacity_max"><code class="literal">innodb_io_capacity_max</code></a>, twice
                the <a class="link" href="innodb-storage-engine.html#sysvar_innodb_io_capacity"><code class="literal">innodb_io_capacity</code></a> is often
                a good starting point. The default value of 2000 is intended for
                workloads that use an SSD or more than one regular disk drive. A
                setting of 2000 is likely too high for workloads that do not use
                SSDs or multiple disk drives, and could allow too much flushing.
                For a single regular disk drive, a setting between 200 and 400
                is recommended. For a high-end, bus-attached SSD, consider a
                higher setting such as 2500. As with the
                <a class="link" href="innodb-storage-engine.html#sysvar_innodb_io_capacity"><code class="literal">innodb_io_capacity</code></a> setting,
                keep the setting as low as practical, but not so low that
                <code class="literal">InnoDB</code> cannot sufficiently extend rate of
                IOPS beyond the
                <a class="link" href="innodb-storage-engine.html#sysvar_innodb_io_capacity"><code class="literal">innodb_io_capacity</code></a> setting.
            </p><p style="color:blue;">在配置innodb_io_capacity_max时，两倍的innodb_io_capacity通常是一个很好的起点。默认值2000适用于使用ssd或多个常规磁盘驱动器的工作负载。对于不使用ssd或多个磁盘驱动器的工作负载，2000的设置可能太高，并且可能允许过多的刷新。对于单个常规磁盘驱动器，建议设置在200到400之间。对于高端、总线连接的ssd，请考虑更高的设置，如2500。与innodb_io_容量设置一样，保持设置尽可能低，但不要太低，以免innodb无法将iops速率充分扩展到innodb_io_容量设置之外。</p><p>
                Consider write workload when tuning
                <a class="link" href="innodb-storage-engine.html#sysvar_innodb_io_capacity_max"><code class="literal">innodb_io_capacity_max</code></a>. Systems
                with large write workloads may benefit from a higher setting. A
                lower setting may be sufficient for systems with a small write
                workload.
            </p><p style="color:blue;">在调整innodb_io_capacity_max时，请考虑写工作负载。具有较大写工作负载的系统可能会受益于较高的设置。较低的设置对于写工作负载较小的系统来说可能就足够了。</p><p>
                <a class="link" href="innodb-storage-engine.html#sysvar_innodb_io_capacity_max"><code class="literal">innodb_io_capacity_max</code></a> cannot
                be set to a value lower than the
                <a class="link" href="innodb-storage-engine.html#sysvar_innodb_io_capacity"><code class="literal">innodb_io_capacity</code></a> value.
            </p><p style="color:blue;">innodb_io_capacity_max不能设置为低于innodb_io_capacity值的值。</p><p>
                Setting <a class="link" href="innodb-storage-engine.html#sysvar_innodb_io_capacity_max"><code class="literal">innodb_io_capacity_max</code></a>
                to <code class="literal">DEFAULT</code> using a
                <a class="link" href="sql-syntax.html#set-variable" title="13.7.4.1&nbsp;SET Syntax for Variable Assignment"><code class="literal">SET</code></a>
                statement (<code class="literal">SET GLOBAL
                innodb_io_capacity_max=DEFAULT</code>) sets
                <a class="link" href="innodb-storage-engine.html#sysvar_innodb_io_capacity_max"><code class="literal">innodb_io_capacity_max</code></a> to the
                maximum value.
            </p><p style="color:blue;">使用SET语句（设置全局Global BudBiIOxLoad SythMax＝缺省值）将NoNdByIoIoLyPultIyMax设置为默认值。</p><p>
                The <a class="link" href="innodb-storage-engine.html#sysvar_innodb_io_capacity_max"><code class="literal">innodb_io_capacity_max</code></a>
                limit applies to all buffer pool instances. It is not a per
                buffer pool instance setting.
            </p><p style="color:blue;">innodb_io_capacity_max限制适用于所有缓冲池实例。它不是每个缓冲池实例设置。</p>
            </div>

        </div>
        <div class="section">
            <div class="titlepage">
                <div>
                    <div>
                        <h3 class="title"><a name="innodb-performance-spin_lock_polling"></a>14.8.9&nbsp;Configuring Spin Lock Polling</h3>

                    </div>

                </div>

            </div>
            <a class="indexterm" name="idm140286819863216"></a><p>
            <code class="literal">InnoDB</code>
            <a class="link" href="glossary.html#glos_mutex" title="mutex">mutexes</a> and
            <a class="link" href="glossary.html#glos_rw_lock" title="rw-lock">rw-locks</a> are typically
            reserved for short intervals. On a multi-core system, it can be
            more efficient for a thread to continuously check if it can
            acquire a mutex or rw-lock for a period of time before it sleeps.
            If the mutex or rw-lock becomes available during this period, the
            thread can continue immediately, in the same time slice. However,
            too-frequent polling of a shared object such as a mutex or rw-lock
            by multiple threads can cause <span class="quote">“<span class="quote">cache ping pong</span>”</span>,
            which results in processors invalidating portions of each
            other's cache. <code class="literal">InnoDB</code> minimizes this issue
            by forcing a random delay between polls to desychronize polling
            activity. The random delay is implemented as a spin-wait loop.
        </p><p style="color:blue;">innodb互斥锁和rw锁通常为短时间间隔保留。在多核系统中，线程在睡眠前连续检查一段时间内是否可以获取互斥锁或rw锁会更有效率。如果互斥锁或rw锁在此期间变为可用，则线程可以立即在同一时间片中继续。然而，多个线程过于频繁地轮询共享对象（如互斥锁或rw锁）可能会导致“缓存乒乓”，从而导致处理器使彼此缓存的某些部分失效。InnoDB通过强制轮询之间的随机延迟来取消轮询活动的同步，从而将此问题最小化。随机延迟被实现为一个自旋等待循环。</p><p>
            The duration of a spin-wait loop is determined by the number of
            PAUSE instructions that occur in the loop. That number is
            generated by randomly selecting an integer ranging from 0 up to
            but not including the
            <a class="link" href="innodb-storage-engine.html#sysvar_innodb_spin_wait_delay"><code class="literal">innodb_spin_wait_delay</code></a> value, and
            multiplying that value by 50. For example, an integer is randomly
            selected from the following range for an
            <a class="link" href="innodb-storage-engine.html#sysvar_innodb_spin_wait_delay"><code class="literal">innodb_spin_wait_delay</code></a> setting of
            6:
        </p><p style="color:blue;">自旋等待循环的持续时间由循环中出现的暂停指令数决定。这个数字是通过随机选择一个0到但不包括innodb_spin_wait_delay值的整数，并将该值乘以50来生成的。例如，对于innodb_spin_wait_延迟设置6，从以下范围中随机选择一个整数：</p><pre data-lang="none" class="programlisting">{0,1,2,3,4,5}</pre><p>
            The selected integer is multiplied by 50, resulting in one of six
            possible PAUSE instruction values:
        </p><p style="color:blue;">所选整数乘以50，得到六个可能的暂停指令值之一：</p><pre data-lang="none" class="programlisting">{0,50,100,150,200,250}</pre><p>
            For that set of values, 250 is the maximum number of PAUSE
            instructions that can occur in a spin-wait loop. An
            <a class="link" href="innodb-storage-engine.html#sysvar_innodb_spin_wait_delay"><code class="literal">innodb_spin_wait_delay</code></a> setting of
            5 results in a set of five possible values
            <code class="literal">{0,50,100,150,200}</code>, where 200 is the maximum
            number of PAUSE instructions, and so on. In this way, the
            <a class="link" href="innodb-storage-engine.html#sysvar_innodb_spin_wait_delay"><code class="literal">innodb_spin_wait_delay</code></a> setting
            controls the maximum delay between spin lock polls.
        </p><p style="color:blue;">对于这组值，250是可在自旋等待循环中发生的暂停指令的最大数目。5的NynBudSPixWaiTi延迟设置导致五个可能值集合{0，50100150 200 }，其中200是暂停指令的最大数目，等等。以这种方式，NoNdBySpRixWaiTi延迟设置控制自旋锁定轮询之间的最大延迟。</p><p>
            The duration of the delay loop depends on the C compiler and the
            target processor. In the 100MHz Pentium era, an
            <a class="link" href="innodb-storage-engine.html#sysvar_innodb_spin_wait_delay"><code class="literal">innodb_spin_wait_delay</code></a> unit was
            calibrated to be equivalent to one microsecond. That time
            equivalence did not hold, but PAUSE instruction duration has
            remained fairly constant in terms of processor cycles relative to
            other CPU instructions on most processor architectures.
        </p><p style="color:blue;">延迟循环的持续时间取决于C编译器和目标处理器。在100MHz奔腾时代，InnoDB_Spin_Wait_延迟单元被校准为相当于一微秒。这种时间等价性不成立，但暂停指令的持续时间相对于大多数处理器体系结构上的其他CPU指令，在处理器周期方面保持相当恒定。</p><p>
            On a system where all processor cores share a fast cache memory,
            you might reduce the maximum delay or disable the busy loop
            altogether by setting
            <a class="link" href="innodb-storage-engine.html#sysvar_innodb_spin_wait_delay"><code class="literal">innodb_spin_wait_delay=0</code></a>. On a
            system with multiple processor chips, the effect of cache
            invalidation can be more significant and you might increase the
            maximum delay.
        </p><p style="color:blue;">在一个系统中，所有处理器内核共享一个快速缓存内存，您可以通过设置NynBudSPixWaITHORD延迟＝0来减少最大延迟或完全禁用繁忙循环。在具有多个处理器芯片的系统中，缓存失效的影响可能更为显著，并且可能会增加最大延迟。</p><p>
            The <a class="link" href="innodb-storage-engine.html#sysvar_innodb_spin_wait_delay"><code class="literal">innodb_spin_wait_delay</code></a>
            variable is dynamic. It can be specified in a MySQL option file or
            modified at runtime using a
            <a class="link" href="sql-syntax.html#set-variable" title="13.7.4.1&nbsp;SET Syntax for Variable Assignment"><code class="literal">SET GLOBAL</code></a>
            statement. Runtime modification requires privileges sufficient to
            set global system variables. See
            <a class="xref" href="server-administration.html#system-variable-privileges" title="5.1.8.1&nbsp;System Variable Privileges">Section&nbsp;5.1.8.1, “System Variable Privileges”</a>.
        </p><p style="color:blue;">innodb_spin_wait_延迟变量是动态的。它可以在mysql选项文件中指定，也可以在运行时使用set global语句进行修改。运行时修改需要足够的权限来设置全局系统变量。见第5.1.8.1节“系统变量特权”。</p>
        </div>
        <div class="section">
            <div class="titlepage">
                <div>
                    <div>
                        <h3 class="title"><a name="innodb-purge-configuration"></a>14.8.10&nbsp;Purge Configuration</h3>

                    </div>

                </div>

            </div>
            <a class="indexterm" name="idm140286819838688"></a><a class="indexterm" name="idm140286819837616"></a><a class="indexterm" name="idm140286819836544"></a><p>
            <code class="literal">InnoDB</code> does not physically remove a row from
            the database immediately when you delete it with an SQL statement.
            A row and its index records are only physically removed when
            <code class="literal">InnoDB</code> discards the undo log record written for
            the deletion. This removal operation, which only occurs after the
            row is no longer required for multi-version concurrency control
            (MVCC) or rollback, is called a purge.
        </p><p style="color:blue;">使用sql语句删除行时，innodb不会立即从数据库中物理删除行。只有当innodb放弃为删除而写入的撤消日志记录时，才会物理删除行及其索引记录。此删除操作仅在多版本并发控制（MVCC）或回滚不再需要该行之后发生，称为清除。</p><p>
            Purge runs on a periodic schedule. It parses and processes undo
            log pages from the history list, which is a list of undo log pages
            for committed transactions that is maintained by the
            <code class="literal">InnoDB</code> transaction system. Purge frees the undo
            log pages from the history list after processing them.
        </p><p style="color:blue;">清除按定期计划运行。它解析并处理历史列表中的撤销日志页，历史列表是innodb事务系统维护的已提交事务的撤销日志页列表。清除在处理完撤消日志页后，将其从历史记录列表中释放出来。</p>
            <h4><a name="idm140286819831824"></a>Configuring Purge Threads</h4>
            <p>
                Purge operations are performed in the background by one or more
                purge threads. The number of purge threads is controlled by the
                <a class="link" href="innodb-storage-engine.html#sysvar_innodb_purge_threads"><code class="literal">innodb_purge_threads</code></a> variable.
                The default value is 4. If DML action is concentrated on a single
                table or a few tables, keep the setting low so that the threads do
                not contend with each other for access to the busy tables. If DML
                operations are spread across many tables, increase the setting.
                The maximum number of purge threads is 32.
            </p><p style="color:blue;">清除操作由一个或多个清除线程在后台执行。清除线程的数量由innodb_purge_threads变量控制。默认值为4。如果DML操作集中在一个表或几个表上，请保持低设置，以使线程不会为了访问忙表而相互竞争。如果DML操作分布在多个表中，请增加设置。清洗螺纹的最大数量是32。</p><p>
            The <a class="link" href="innodb-storage-engine.html#sysvar_innodb_purge_threads"><code class="literal">innodb_purge_threads</code></a> setting
            is the maximum number of purge threads permitted. The purge system
            automatically adjusts the number of purge threads as necessary.
        </p><p style="color:blue;">NoNdBuxPurgEnthType设置是允许的清洗线程的最大数量。清洗系统会根据需要自动调整清洗螺纹的数量。</p>
            <h4><a name="idm140286819827136"></a>Configuring Purge Batch Size</h4>
            <p>
                The <a class="link" href="innodb-storage-engine.html#sysvar_innodb_purge_batch_size"><code class="literal">innodb_purge_batch_size</code></a>
                variable defines the number of undo log pages that purge parses
                and processes in one batch from the history list. The default
                value is 300. In a multithreaded purge configuration, the
                coordinator purge thread divides
                <a class="link" href="innodb-storage-engine.html#sysvar_innodb_purge_batch_size"><code class="literal">innodb_purge_batch_size</code></a> by
                <a class="link" href="innodb-storage-engine.html#sysvar_innodb_purge_threads"><code class="literal">innodb_purge_threads</code></a> and assigns
                that number of pages to each purge thread.
            </p><p style="color:blue;">innodb_purge_batch_size变量定义从历史记录列表中清除一个批中的解析和处理的撤消日志页数。默认值为300。在多线程清除配置中，协调器清除线程将innodb_purge_batch_size除以innodb_purge_threads，并将该页数分配给每个清除线程。</p><p>
            The purge system also frees the undo log pages that are no longer
            required. It does so every 128 iterations through the undo logs.
            In addition to defining the number of undo log pages parsed and
            processed in a batch, the
            <a class="link" href="innodb-storage-engine.html#sysvar_innodb_purge_batch_size"><code class="literal">innodb_purge_batch_size</code></a> variable
            defines the number of undo log pages that purge frees every 128
            iterations through the undo logs.
        </p><p style="color:blue;">清除系统还释放不再需要的撤消日志页。它通过撤销日志每128次迭代执行一次。除了定义在批处理中解析和处理的撤消日志页数之外，innodb_purge_batch_size变量还定义了通过撤消日志每128次迭代清除释放的撤消日志页数。</p><p>
            The <a class="link" href="innodb-storage-engine.html#sysvar_innodb_purge_batch_size"><code class="literal">innodb_purge_batch_size</code></a>
            variable is intended for advanced performance tuning and
            experimentation. Most users need not change
            <a class="link" href="innodb-storage-engine.html#sysvar_innodb_purge_batch_size"><code class="literal">innodb_purge_batch_size</code></a> from its
            default value.
        </p><p style="color:blue;">innodb_purge_batch_size变量用于高级性能调整和实验。大多数用户不需要更改innodb_purge_batch_的默认值。</p>
            <h4><a name="idm140286819816864"></a>Configuring the Maximum Purge Lag</h4>
            <p>
                The <a class="link" href="innodb-storage-engine.html#sysvar_innodb_max_purge_lag"><code class="literal">innodb_max_purge_lag</code></a> variable
                defines the desired maximum purge lag. When the purge lag exceeds
                the <a class="link" href="innodb-storage-engine.html#sysvar_innodb_max_purge_lag"><code class="literal">innodb_max_purge_lag</code></a>
                threshold, a delay is imposed on
                <a class="link" href="sql-syntax.html#insert" title="13.2.5&nbsp;INSERT Syntax"><code class="literal">INSERT</code></a>,
                <a class="link" href="sql-syntax.html#update" title="13.2.11&nbsp;UPDATE Syntax"><code class="literal">UPDATE</code></a>, and
                <a class="link" href="sql-syntax.html#delete" title="13.2.2&nbsp;DELETE Syntax"><code class="literal">DELETE</code></a> operations to allow time for
                purge operations to catch up. The default value is 0, which means
                there is no maximum purge lag and no delay.
            </p><p style="color:blue;">NoNdBuxMax PurgEng滞后变量定义了期望的最大清除滞后。当清除延迟超过innodb_max_purge_lag阈值时，会对插入、更新和删除操作施加延迟，以便清除操作有时间赶上。默认值为0，这意味着没有最大清除滞后和没有延迟。</p><p>
            The <code class="literal">InnoDB</code> transaction system maintains a list
            of transactions that have index records delete-marked by
            <a class="link" href="sql-syntax.html#update" title="13.2.11&nbsp;UPDATE Syntax"><code class="literal">UPDATE</code></a> or
            <a class="link" href="sql-syntax.html#delete" title="13.2.2&nbsp;DELETE Syntax"><code class="literal">DELETE</code></a> operations. The length of
            the list is the purge lag. The purge lag delay is calculated by
            the following formula, which results in a minimum delay of 5000
            microseconds:
        </p><p style="color:blue;">innodb事务系统维护一个事务列表，其中的索引记录被update或delete操作标记为delete。列表的长度是清除延迟。吹扫滞后延迟由以下公式计算，其最小延迟为5000微秒：</p><pre data-lang="none" class="programlisting">(purge lag/innodb_max_purge_lag - 0.5) * 10000</pre><p>
            The delay is calculated at the beginning of a purge batch
        </p><p style="color:blue;">延迟是在清洗批次开始时计算的</p><p>
            A typical <a class="link" href="innodb-storage-engine.html#sysvar_innodb_max_purge_lag"><code class="literal">innodb_max_purge_lag</code></a>
            setting for a problematic workload might be 1000000 (1 million),
            assuming that transactions are small, only 100 bytes in size, and
            it is permissible to have 100MB of unpurged table rows.
        </p><p style="color:blue;">对于有问题的工作负载，典型的innodb_max_purge_lag设置可能是1000000（一百万），假设事务很小，只有100字节大小，并且允许有100MB的未敦促表行。</p><p>
            The purge lag is presented as the <code class="literal">History list
            length</code> value in the <code class="literal">TRANSACTIONS</code>
            section of <a class="link" href="sql-syntax.html#show-engine" title="13.7.5.15&nbsp;SHOW ENGINE Syntax"><code class="literal">SHOW
            ENGINE INNODB STATUS</code></a> output.
        </p><p style="color:blue;">清除延迟作为历史列表长度值显示在show engine innodb status output的transactions部分。</p><pre data-lang="terminal" class="programlisting">mysql&gt; SHOW ENGINE INNODB STATUS;
...
------------
TRANSACTIONS
------------
Trx id counter 0 290328385
Purge done for trx's n:o &lt; 0 290315608 undo n:o &lt; 0 17
History list length 20
</pre><p>
            The <code class="literal">History list length</code> is typically a low
            value, usually less than a few thousand, but a write-heavy
            workload or long running transactions can cause it to increase,
            even for transactions that are read only. The reason that a long
            running transaction can cause the <code class="literal">History list
            length</code> to increase is that under a consistent read
            transaction isolation level such as
            <code class="literal">REPEATABLE READ</code>, a transaction
            must return the same result as when the read view for that
            transaction was created. Consequently, the
            <code class="literal">InnoDB</code> multi-version concurrency control (MVCC)
            system must keep a copy of the data in the undo log until all
            transactions that depend on that data have completed. The
            following are examples of long running transactions that could
            cause the <code class="literal">History list length</code> to increase:
        </p><p style="color:blue;">历史记录列表的长度通常是一个很低的值，通常小于几千，但是写的繁重工作负载或长时间运行的事务会导致它增加，即使对于只读事务也是如此。长时间运行的事务可能导致历史记录列表长度增加的原因是，在一致的读取事务隔离级别（如可重复读取）下，事务必须返回与创建该事务的读取视图时相同的结果。因此，innodb多版本并发控制（mvcc）系统必须在撤销日志中保留数据的副本，直到依赖于该数据的所有事务都完成。以下是可能导致历史记录列表长度增加的长时间运行事务的示例：</p>
            <div class="itemizedlist">
                <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                    A <a class="link" href="programs.html#mysqldump" title="4.5.4&nbsp;mysqldump — A Database Backup Program"><span class="command"><strong>mysqldump</strong></span></a> operation that uses the
                    <a class="link" href="programs.html#option_mysqldump_single-transaction"><code class="option">--single-transaction</code></a> option
                    while there is a significant amount of concurrent DML.
                </p><p style="color:blue;">一种mysqldump操作，在存在大量并发dml时使用--single事务选项。</p></li><li class="listitem"><p>
                    Running a <a class="link" href="sql-syntax.html#select" title="13.2.9&nbsp;SELECT Syntax"><code class="literal">SELECT</code></a> query after
                    disabling <a class="link" href="server-administration.html#sysvar_autocommit"><code class="literal">autocommit</code></a>, and
                    forgetting to issue an explicit <code class="literal">COMMIT</code> or
                    <code class="literal">ROLLBACK</code>.
                </p><p style="color:blue;">在禁用autocommit并忘记发出显式提交或回滚后运行select查询。</p></li></ul>
            </div>
            <p>
                To prevent excessive delays in extreme situations where the purge
                lag becomes huge, you can limit the delay by setting the
                <a class="link" href="innodb-storage-engine.html#sysvar_innodb_max_purge_lag_delay"><code class="literal">innodb_max_purge_lag_delay</code></a>
                variable. The
                <a class="link" href="innodb-storage-engine.html#sysvar_innodb_max_purge_lag_delay"><code class="literal">innodb_max_purge_lag_delay</code></a>
                variable specifies the maximum delay in microseconds for the delay
                imposed when the
                <a class="link" href="innodb-storage-engine.html#sysvar_innodb_max_purge_lag"><code class="literal">innodb_max_purge_lag</code></a> threshold is
                exceeded. The specified
                <a class="link" href="innodb-storage-engine.html#sysvar_innodb_max_purge_lag_delay"><code class="literal">innodb_max_purge_lag_delay</code></a> value
                is an upper limit on the delay period calculated by the
                <a class="link" href="innodb-storage-engine.html#sysvar_innodb_max_purge_lag"><code class="literal">innodb_max_purge_lag</code></a> formula.
            </p><p style="color:blue;">为了防止在清除延迟变大的极端情况下出现过度延迟，可以通过设置innodb_max_purge_lag_delay变量来限制延迟。UnnByMax Max Purgier-LaGyDelphi变量指定在NuiBudMax Max PurgEngor滞后阈值超过时施加的延迟的微秒最大延迟。指定的innodb_max_purge_lag_延迟值是由innodb_max_purge_lag公式计算的延迟周期的上限。</p>
            <h4><a name="idm140286819777280"></a>Purge and Undo Tablespace Truncation</h4>
            <p>
                The purge system is also responsible for truncating undo
                tablespaces. You can configure the
                <a class="link" href="innodb-storage-engine.html#sysvar_innodb_purge_rseg_truncate_frequency"><code class="literal">innodb_purge_rseg_truncate_frequency</code></a>
                variable to control the frequency with which the purge system
                looks for undo tablespaces to truncate. For more information, see
                <a class="xref" href="innodb-storage-engine.html#truncate-undo-tablespace" title="Truncating Undo Tablespaces">Truncating Undo Tablespaces</a>.
            </p><p style="color:blue;">清除系统还负责截断撤消表空间。您可以配置innodb_purge_rseg_truncate_频率变量来控制清除系统查找要截断的撤消表空间的频率。有关详细信息，请参见截断撤消表空间。</p>
        </div>
        <div class="section">
            <div class="titlepage">
                <div>
                    <div>
                        <h3 class="title"><a name="innodb-performance-optimizer-statistics"></a>14.8.11&nbsp;Configuring Optimizer Statistics for InnoDB</h3>

                    </div>

                </div>

            </div>
            <div class="toc">
                <dl class="toc"><dt><span class="section"><a href="innodb-storage-engine.html#innodb-persistent-stats">14.8.11.1 Configuring Persistent Optimizer Statistics Parameters</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-statistics-estimation">14.8.11.2 Configuring Non-Persistent Optimizer Statistics Parameters</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-analyze-table-complexity">14.8.11.3 Estimating ANALYZE TABLE Complexity for InnoDB Tables</a></span></dt></dl>
            </div>
            <p>
                This section describes how to configure persistent and
                non-persistent optimizer statistics for <code class="literal">InnoDB</code>
                tables.
            </p><p style="color:blue;">本节描述如何为innodb表配置持久化和非持久化优化器统计信息。</p><p>
            Persistent optimizer statistics are persisted across server
            restarts, allowing for greater
            <a class="link" href="glossary.html#glos_plan_stability" title="plan stability">plan stability</a> and more
            consistent query performance. Persistent optimizer statistics also
            provide control and flexibility with these additional benefits:
        </p><p style="color:blue;">持久优化器统计信息在服务器重新启动时被持久化，从而允许更高的计划稳定性和更一致的查询性能。持久性优化器统计还提供了控制和灵活性，这些额外的好处：</p>
            <div class="itemizedlist">
                <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                    You can use the
                    <a class="link" href="innodb-storage-engine.html#sysvar_innodb_stats_auto_recalc"><code class="literal">innodb_stats_auto_recalc</code></a>
                    configuration option to control whether statistics are updated
                    automatically after substantial changes to a table.
                </p><p style="color:blue;">您可以使用innodb_stats_auto_recalc configuration选项来控制在对表进行重大更改后是否自动更新统计信息。</p></li><li class="listitem"><p>
                    You can use the <code class="literal">STATS_PERSISTENT</code>,
                    <code class="literal">STATS_AUTO_RECALC</code>, and
                    <code class="literal">STATS_SAMPLE_PAGES</code> clauses with
                    <a class="link" href="sql-syntax.html#create-table" title="13.1.18&nbsp;CREATE TABLE Syntax"><code class="literal">CREATE TABLE</code></a> and
                    <a class="link" href="sql-syntax.html#alter-table" title="13.1.8&nbsp;ALTER TABLE Syntax"><code class="literal">ALTER TABLE</code></a> statements to
                    configure optimizer statistics for individual tables.
                </p><p style="color:blue;">您可以将stats_persistent、stats_auto_recalc和stats_sample_pages子句与create table和alter table语句一起使用，为单个表配置优化器统计信息。</p></li><li class="listitem"><p>
                    You can query optimizer statistics data in the
                    <code class="literal">mysql.innodb_table_stats</code> and
                    <code class="literal">mysql.innodb_index_stats</code> tables.
                </p><p style="color:blue;">您可以在mysql.innodb_table_stats和mysql.innodb_index_stats表中查询优化器统计数据。</p></li><li class="listitem"><p>
                    You can view the <code class="literal">last_update</code> column of the
                    <code class="literal">mysql.innodb_table_stats</code> and
                    <code class="literal">mysql.innodb_index_stats</code> tables to see when
                    statistics were last updated.
                </p><p style="color:blue;">您可以查看mysql.innodb_table_stats和mysql.innodb_index_stats表的last_update列，查看上次更新统计信息的时间。</p></li><li class="listitem"><p>
                    You can manually modify the
                    <code class="literal">mysql.innodb_table_stats</code> and
                    <code class="literal">mysql.innodb_index_stats</code> tables to force a
                    specific query optimization plan or to test alternative plans
                    without modifying the database.
                </p><p style="color:blue;">您可以手动修改mysql.innodb_table_stats和mysql.innodb_index_stats表，以强制执行特定的查询优化计划或在不修改数据库的情况下测试替代计划。</p></li></ul>
            </div>
            <p>
                The persistent optimizer statistics feature is enabled by default
                (<a class="link" href="innodb-storage-engine.html#sysvar_innodb_stats_persistent"><code class="literal">innodb_stats_persistent=ON</code></a>).
            </p><p style="color:blue;">默认情况下会启用持久优化器统计特性（innodb_stats_persistent=on）。</p><p>
            Non-persistent optimizer statistics are cleared on each server
            restart and after some other operations, and recomputed on the
            next table access. As a result, different estimates could be
            produced when recomputing statistics, leading to different choices
            in execution plans and variations in query performance.
        </p><p style="color:blue;">非持久优化器统计信息在每次服务器重新启动和其他一些操作之后被清除，并在下一次表访问时重新计算。因此，在重新计算统计信息时可能会产生不同的估计值，从而导致执行计划的不同选择和查询性能的变化。</p><p>
            This section also provides information about estimating
            <a class="link" href="sql-syntax.html#analyze-table" title="13.7.2.1&nbsp;ANALYZE TABLE Syntax"><code class="literal">ANALYZE TABLE</code></a> complexity, which may
            be useful when attempting to achieve a balance between accurate
            statistics and <a class="link" href="sql-syntax.html#analyze-table" title="13.7.2.1&nbsp;ANALYZE TABLE Syntax"><code class="literal">ANALYZE TABLE</code></a>
            execution time.
        </p><p style="color:blue;">本节还提供了有关估计分析表复杂性的信息，当试图在准确的统计和分析表执行时间之间实现平衡时，这可能是有用的。</p>
            <div class="section">

                <div class="titlepage">
                    <div>
                        <div>
                            <h4 class="title"><a name="innodb-persistent-stats"></a>14.8.11.1&nbsp;Configuring Persistent Optimizer Statistics Parameters</h4>
                        </div>
                    </div>
                </div>
                <a class="indexterm" name="idm140286819747040"></a><a class="indexterm" name="idm140286819745568"></a><a class="indexterm" name="idm140286819744064"></a><a class="indexterm" name="idm140286819742560"></a><a class="indexterm" name="idm140286819741056"></a><p>
                The persistent optimizer statistics feature improves
                <a class="link" href="glossary.html#glos_plan_stability" title="plan stability">plan stability</a> by
                storing statistics to disk and making them persistent across
                server restarts so that the
                <a class="link" href="glossary.html#glos_optimizer" title="optimizer">optimizer</a> is more likely
                to make consistent choices each time for a given query.
            </p><p style="color:blue;">持久化优化器统计特性通过将统计信息存储到磁盘并使它们在服务器重新启动时持久化，从而使优化器更有可能每次为给定查询做出一致的选择，从而提高了计划的稳定性。</p><p>
                Optimizer statistics are persisted to disk when
                <a class="link" href="innodb-storage-engine.html#sysvar_innodb_stats_persistent"><code class="literal">innodb_stats_persistent=ON</code></a> or
                when individual tables are defined with
                <a class="link" href="sql-syntax.html#create-table" title="13.1.18&nbsp;CREATE TABLE Syntax"><code class="literal">STATS_PERSISTENT=1</code></a>.
                <a class="link" href="innodb-storage-engine.html#sysvar_innodb_stats_persistent"><code class="literal">innodb_stats_persistent</code></a> is
                enabled by default.
            </p><p style="color:blue;">当innodb_stats_persistent=on或使用stats_persistent=1定义单个表时，优化器统计信息将持久化到磁盘。默认情况下，innodb_stats_persistent处于启用状态。</p><p>
                Formerly, optimizer statistics were cleared when restarting the
                server and after some other types of operations, and recomputed
                on the next table access. Consequently, different estimates
                could be produced when recalculating statistics leading to
                different choices in query execution plans and variation in
                query performance.
            </p><p style="color:blue;">以前，在重新启动服务器和执行某些其他类型的操作后，优化器统计信息会被清除，并在下一个表访问时重新计算。因此，当重新计算统计信息时，可能会产生不同的估计值，从而导致查询执行计划中的不同选择和查询性能的变化。</p><p>
                Persistent statistics are stored in the
                <code class="literal">mysql.innodb_table_stats</code> and
                <code class="literal">mysql.innodb_index_stats</code> tables. See
                <a class="xref" href="innodb-storage-engine.html#innodb-persistent-stats-tables" title="14.8.11.1.5&nbsp;InnoDB Persistent Statistics Tables">Section&nbsp;14.8.11.1.5, “InnoDB Persistent Statistics Tables”</a>.
            </p><p style="color:blue;">持久统计信息存储在mysql.innodb_table_stats和mysql.innodb_index_stats表中。参见14.8.11.1.5节，“InnoDB持久统计表”。</p><p>
                If you prefer not to persist optimizer statistics to disk, see
                <a class="xref" href="innodb-storage-engine.html#innodb-statistics-estimation" title="14.8.11.2&nbsp;Configuring Non-Persistent Optimizer Statistics Parameters">Section&nbsp;14.8.11.2, “Configuring Non-Persistent Optimizer Statistics Parameters”</a>
            </p><p style="color:blue;">如果您不希望将优化器统计信息持久化到磁盘，请参阅14.8.11.2节，“配置非持久优化器统计信息参数”</p>
                <div class="section">

                    <div class="titlepage">
                        <div>
                            <div>
                                <h5 class="title"><a name="innodb-persistent-stats-auto-recalc"></a>14.8.11.1.1&nbsp;Configuring Automatic Statistics Calculation for Persistent Optimizer
                                    Statistics</h5>
                            </div>
                        </div>
                    </div>
                    <p>
                        The <a class="link" href="innodb-storage-engine.html#sysvar_innodb_stats_auto_recalc"><code class="literal">innodb_stats_auto_recalc</code></a>
                        variable, which is enabled by default, controls whether
                        statistics are calculated automatically when a table undergoes
                        changes to more than 10% of its rows. You can also configure
                        automatic statistics recalculation for individual tables by
                        specifying the <code class="literal">STATS_AUTO_RECALC</code> clause
                        when creating or altering a table.
                    </p><p style="color:blue;">innodb_stats_auto_recalc变量在默认情况下是启用的，它控制当一个表发生超过其行的10%的更改时是否自动计算统计信息。还可以通过在创建或更改表时指定stats_auto_recalc子句，为各个表配置自动统计重新计算。</p><p>
                    Because of the asynchronous nature of automatic statistics
                    recalculation, which occurs in the background, statistics may
                    not be recalculated instantly after running a DML operation
                    that affects more than 10% of a table, even when
                    <a class="link" href="innodb-storage-engine.html#sysvar_innodb_stats_auto_recalc"><code class="literal">innodb_stats_auto_recalc</code></a> is
                    enabled. Statistics recalculation can be delayed by few
                    seconds in some cases. If up-to-date statistics are required
                    immediately, run <a class="link" href="sql-syntax.html#analyze-table" title="13.7.2.1&nbsp;ANALYZE TABLE Syntax"><code class="literal">ANALYZE TABLE</code></a>
                    to initiate a synchronous (foreground) recalculation of
                    statistics.
                </p><p style="color:blue;">由于自动统计重新计算的异步性质（在后台发生），因此即使启用了innodb_stats_auto_recalc，在运行影响表的10%以上的dml操作后，也可能无法立即重新计算统计信息。在某些情况下，统计数据重新计算可能会延迟几秒钟。如果需要立即更新统计信息，请运行analyze table以启动统计信息的同步（前台）重新计算。</p><p>
                    If <a class="link" href="innodb-storage-engine.html#sysvar_innodb_stats_auto_recalc"><code class="literal">innodb_stats_auto_recalc</code></a>
                    is disabled, you can ensure the accuracy of optimizer
                    statistics by executing the <a class="link" href="sql-syntax.html#analyze-table" title="13.7.2.1&nbsp;ANALYZE TABLE Syntax"><code class="literal">ANALYZE
                    TABLE</code></a> statement after making substantial changes to
                    indexed columns. You might also consider adding
                    <a class="link" href="sql-syntax.html#analyze-table" title="13.7.2.1&nbsp;ANALYZE TABLE Syntax"><code class="literal">ANALYZE TABLE</code></a> to setup scripts
                    that you run after loading data, and running
                    <a class="link" href="sql-syntax.html#analyze-table" title="13.7.2.1&nbsp;ANALYZE TABLE Syntax"><code class="literal">ANALYZE TABLE</code></a> on a schedule at
                    times of low activity.
                </p><p style="color:blue;">如果innodb_stats_auto_recalc被禁用，那么在对索引列进行实质性更改之后，可以通过执行analyze table语句来确保优化器统计的准确性。您还可以考虑将analyze table添加到在加载数据后运行的安装脚本中，并在低活动时间按计划运行analyze table。</p><p>
                    When an index is added to an existing table, or when a column
                    is added or dropped, index statistics are calculated and added
                    to the <code class="literal">innodb_index_stats</code> table regardless
                    of the value of
                    <a class="link" href="innodb-storage-engine.html#sysvar_innodb_stats_auto_recalc"><code class="literal">innodb_stats_auto_recalc</code></a>.
                </p><p style="color:blue;">当将索引添加到现有表中时，或在添加或删除列时，计算索引统计信息，并将其添加到NoYbByRexXixSTATS表中，而不管NoNdByStassAutoRealc的值。</p>
                </div>
                <div class="section">
                    <div class="titlepage">
                        <div>
                            <div>
                                <h5 class="title"><a name="innodb-persistent-stats-table-configuration"></a>14.8.11.1.2&nbsp;Configuring Optimizer Statistics Parameters for Individual Tables</h5>

                            </div>

                        </div>

                    </div>
                    <p>
                        <a class="link" href="innodb-storage-engine.html#sysvar_innodb_stats_persistent"><code class="literal">innodb_stats_persistent</code></a>,
                        <a class="link" href="innodb-storage-engine.html#sysvar_innodb_stats_auto_recalc"><code class="literal">innodb_stats_auto_recalc</code></a>, and
                        <a class="link" href="innodb-storage-engine.html#sysvar_innodb_stats_persistent_sample_pages"><code class="literal">innodb_stats_persistent_sample_pages</code></a>
                        are global variables. To override these system-wide settings
                        and configure optimizer statistics parameters for individual
                        tables, you can define <code class="literal">STATS_PERSISTENT</code>,
                        <code class="literal">STATS_AUTO_RECALC</code>, and
                        <code class="literal">STATS_SAMPLE_PAGES</code> clauses in
                        <a class="link" href="sql-syntax.html#create-table" title="13.1.18&nbsp;CREATE TABLE Syntax"><code class="literal">CREATE TABLE</code></a> or
                        <a class="link" href="sql-syntax.html#alter-table" title="13.1.8&nbsp;ALTER TABLE Syntax"><code class="literal">ALTER TABLE</code></a> statements.
                    </p><p style="color:blue;">innodb_stats_persistent、innodb_stats_auto_recalc和innodb_stats_persistent_sample_页面是全局变量。要覆盖这些系统范围的设置并为单个表配置优化器统计参数，可以在CREATE TABLE或ALTER TABLE语句中定义STATS U PERSISTENT、STATS U AUTO U RECALC和STATS U sample U pages子句。</p>
                    <div class="itemizedlist">
                        <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                            <code class="literal">STATS_PERSISTENT</code> specifies whether to
                            enable
                            <a class="link" href="glossary.html#glos_persistent_statistics" title="persistent statistics">persistent
                                statistics</a> for an <code class="literal">InnoDB</code> table.
                            The value <code class="literal">DEFAULT</code> causes the persistent
                            statistics setting for the table to be determined by the
                            <a class="link" href="innodb-storage-engine.html#sysvar_innodb_stats_persistent"><code class="literal">innodb_stats_persistent</code></a>
                            setting. A value of <code class="literal">1</code> enables
                            persistent statistics for the table, while a value of
                            <code class="literal">0</code> disables the feature. After enabling
                            persistent statistics for an individual table, use
                            <a class="link" href="sql-syntax.html#analyze-table" title="13.7.2.1&nbsp;ANALYZE TABLE Syntax"><code class="literal">ANALYZE TABLE</code></a> to calculate
                            statistics after table data is loaded.
                        </p><p style="color:blue;">stats_persistent指定是否为innodb表启用持久统计。默认值使表的持久统计设置由innodb_stats_persistent设置确定。值1启用表的持久统计信息，值0禁用该功能。为单个表启用持久统计之后，使用analyze table在加载表数据之后计算统计信息。</p></li><li class="listitem"><p>
                            <code class="literal">STATS_AUTO_RECALC</code> specifies whether to
                            automatically recalculate
                            <a class="link" href="glossary.html#glos_persistent_statistics" title="persistent statistics">persistent
                                statistics</a>. The value <code class="literal">DEFAULT</code>
                            causes the persistent statistics setting for the table to
                            be determined by the
                            <a class="link" href="innodb-storage-engine.html#sysvar_innodb_stats_auto_recalc"><code class="literal">innodb_stats_auto_recalc</code></a>
                            setting. A value of <code class="literal">1</code> causes statistics
                            to be recalculated when 10% of table data has changed. A
                            value <code class="literal">0</code> prevents automatic
                            recalculation for the table. When using a value of 0, use
                            <a class="link" href="sql-syntax.html#analyze-table" title="13.7.2.1&nbsp;ANALYZE TABLE Syntax"><code class="literal">ANALYZE TABLE</code></a> to
                            recalculate statistics after making substantial changes to
                            the table.
                        </p><p style="color:blue;">stats_auto_recalc指定是否自动重新计算持久性统计信息。默认值导致表的持久统计设置由innodb_stats_auto_recalc设置确定。值为1时，当表数据的10%发生更改时，将重新计算统计信息。值0阻止自动重新计算表。当使用值0时，请在对表进行实质性更改后使用analyze table重新计算统计信息。</p></li><li class="listitem"><p>
                            <code class="literal">STATS_SAMPLE_PAGES</code> specifies the number
                            of index pages to sample when cardinality and other
                            statistics are calculated for an indexed column, by an
                            <a class="link" href="sql-syntax.html#analyze-table" title="13.7.2.1&nbsp;ANALYZE TABLE Syntax"><code class="literal">ANALYZE TABLE</code></a> operation,
                            for example.
                        </p><p style="color:blue;">stats_sample_pages指定通过分析表操作（例如）计算索引列的基数和其他统计信息时要采样的索引页数。</p></li></ul>
                    </div>
                    <p>
                        All three clauses are specified in the following
                        <a class="link" href="sql-syntax.html#create-table" title="13.1.18&nbsp;CREATE TABLE Syntax"><code class="literal">CREATE TABLE</code></a> example:
                    </p><p style="color:blue;">以下创建表示例中指定了所有这三个子句：</p><pre data-lang="sql" class="programlisting">CREATE TABLE `t1` (
`id` int(8) NOT NULL auto_increment,
`data` varchar(255),
`date` datetime,
PRIMARY KEY  (`id`),
INDEX `DATE_IX` (`date`)
) ENGINE=InnoDB,
  STATS_PERSISTENT=1,
  STATS_AUTO_RECALC=1,
  STATS_SAMPLE_PAGES=25;
</pre>
                </div>
                <div class="section">
                    <div class="titlepage">
                        <div>
                            <div>
                                <h5 class="title"><a name="innodb-persistent-stats-pages-sampled"></a>14.8.11.1.3&nbsp;Configuring the Number of Sampled Pages for InnoDB Optimizer Statistics</h5>

                            </div>

                        </div>

                    </div>
                    <p>
                        The optimizer uses estimated
                        <a class="link" href="glossary.html#glos_statistics" title="statistics">statistics</a> about key
                        distributions to choose the indexes for an execution plan,
                        based on the relative
                        <a class="link" href="glossary.html#glos_selectivity" title="selectivity">selectivity</a> of the
                        index. Operations such as <a class="link" href="sql-syntax.html#analyze-table" title="13.7.2.1&nbsp;ANALYZE TABLE Syntax"><code class="literal">ANALYZE
                        TABLE</code></a> cause <code class="literal">InnoDB</code> to sample
                        random pages from each index on a table to estimate the
                        <a class="link" href="glossary.html#glos_cardinality" title="cardinality">cardinality</a> of the
                        index. This sampling technique is known as a
                        <a class="link" href="glossary.html#glos_random_dive" title="random dive">random dive</a>.
                    </p><p style="color:blue;">优化器根据索引的相对选择性，使用有关键分布的估计统计信息来选择执行计划的索引。analyze table之类的操作会导致innodb从表上的每个索引中抽取随机页来估计索引的基数。这种抽样技术称为随机潜水。</p><p>
                    The
                    <a class="link" href="innodb-storage-engine.html#sysvar_innodb_stats_persistent_sample_pages"><code class="literal">innodb_stats_persistent_sample_pages</code></a>
                    controls the number of sampled pages. You can adjust the
                    setting at runtime to manage the quality of statistics
                    estimates used by the optimizer. The default value is 20.
                    Consider modifying the setting when encountering the following
                    issues:
                </p><p style="color:blue;">innodb_stats_persistent_sample_页面控制采样页面的数量。您可以在运行时调整设置，以管理优化器使用的统计估计的质量。默认值为20。遇到以下问题时，请考虑修改设置：</p>
                    <div class="orderedlist">
                        <ol class="orderedlist" type="1"><li class="listitem"><p>
              <span class="emphasis"><em>Statistics are not accurate enough and the
              optimizer chooses suboptimal plans</em></span>, as shown in
                            <a class="link" href="sql-syntax.html#explain" title="13.8.2&nbsp;EXPLAIN Syntax"><code class="literal">EXPLAIN</code></a> output. You can
                            check the accuracy of statistics by comparing the actual
                            cardinality of an index (determined by running
                            <a class="link" href="sql-syntax.html#select" title="13.2.9&nbsp;SELECT Syntax"><code class="literal">SELECT
                                DISTINCT</code></a> on the index columns) with the
                            estimates in the
                            <code class="literal">mysql.innodb_index_stats</code> table.
                        </p><p style="color:blue;">统计数据不够精确，优化器选择次优计划，如explain output所示。通过比较索引的实际基数（通过在索引列上运行select distinct来确定）与mysql.innodb_index_stats表中的估计值，可以检查统计信息的准确性。</p><p>
                            If it is determined that statistics are not accurate
                            enough, the value of
                            <a class="link" href="innodb-storage-engine.html#sysvar_innodb_stats_persistent_sample_pages"><code class="literal">innodb_stats_persistent_sample_pages</code></a>
                            should be increased until the statistics estimates are
                            sufficiently accurate. Increasing
                            <a class="link" href="innodb-storage-engine.html#sysvar_innodb_stats_persistent_sample_pages"><code class="literal">innodb_stats_persistent_sample_pages</code></a>
                            too much, however, could cause
                            <a class="link" href="sql-syntax.html#analyze-table" title="13.7.2.1&nbsp;ANALYZE TABLE Syntax"><code class="literal">ANALYZE TABLE</code></a> to run
                            slowly.
                        </p><p style="color:blue;">如果确定统计数据不够准确，那么应该增加innodb_stats_persistent_sample_页面的值，直到统计数据估计足够准确为止。但是，增加innodb_stats_persistent_sample_页面太多可能会导致analyze表运行缓慢。</p></li><li class="listitem"><p>
              <span class="emphasis"><em><a class="link" href="sql-syntax.html#analyze-table" title="13.7.2.1&nbsp;ANALYZE TABLE Syntax"><code class="literal">ANALYZE TABLE</code></a> is
              too slow</em></span>. In this case
                            <a class="link" href="innodb-storage-engine.html#sysvar_innodb_stats_persistent_sample_pages"><code class="literal">innodb_stats_persistent_sample_pages</code></a>
                            should be decreased until <a class="link" href="sql-syntax.html#analyze-table" title="13.7.2.1&nbsp;ANALYZE TABLE Syntax"><code class="literal">ANALYZE
                            TABLE</code></a> execution time is acceptable. Decreasing
                            the value too much, however, could lead to the first
                            problem of inaccurate statistics and suboptimal query
                            execution plans.
                        </p><p style="color:blue;">分析表太慢。在这种情况下，应该减少innodb_stats_persistent_sample_页面，直到分析表执行时间可以接受为止。但是，过多地减少该值可能会导致第一个问题，即统计数据不准确和查询执行计划不理想。</p><p>
                            If a balance cannot be achieved between accurate
                            statistics and <a class="link" href="sql-syntax.html#analyze-table" title="13.7.2.1&nbsp;ANALYZE TABLE Syntax"><code class="literal">ANALYZE
                            TABLE</code></a> execution time, consider decreasing the
                            number of indexed columns in the table or limiting the
                            number of partitions to reduce
                            <a class="link" href="sql-syntax.html#analyze-table" title="13.7.2.1&nbsp;ANALYZE TABLE Syntax"><code class="literal">ANALYZE TABLE</code></a> complexity.
                            The number of columns in the table's primary key is also
                            important to consider, as primary key columns are appended
                            to each nonunique index.
                        </p><p style="color:blue;">如果在精确统计和分析表执行时间之间不能达到平衡，请考虑减少表中索引列的数量或限制分区的数量，以减少分析表的复杂性。表主键中的列数也需要考虑，因为主键列附加到每个非唯一索引。</p><p>
                            For related information, see
                            <a class="xref" href="innodb-storage-engine.html#innodb-analyze-table-complexity" title="14.8.11.3&nbsp;Estimating ANALYZE TABLE Complexity for InnoDB Tables">Section&nbsp;14.8.11.3, “Estimating ANALYZE TABLE Complexity for InnoDB Tables”</a>.
                        </p><p style="color:blue;">有关相关信息，请参阅第14章第11节第3节，“估计NYNDB表的分析表复杂性”。</p></li></ol>
                    </div>

                </div>
                <div class="section">
                    <div class="titlepage">
                        <div>
                            <div>
                                <h5 class="title"><a name="innodb-persistent-stats-delete-marked"></a>14.8.11.1.4&nbsp;Including Delete-marked Records in Persistent Statistics Calculations</h5>

                            </div>

                        </div>

                    </div>
                    <a class="indexterm" name="idm140286819649792"></a><a class="indexterm" name="idm140286819648688"></a><p>
                    By default, <code class="literal">InnoDB</code> reads uncommitted data
                    when calculating statistics. In the case of an uncommitted
                    transaction that deletes rows from a table, delete-marked
                    records are excluded when calculating row estimates and index
                    statistics, which can lead to non-optimal execution plans for
                    other transactions that are operating on the table
                    concurrently using a transaction isolation level other than
                    <a class="link" href="innodb-storage-engine.html#isolevel_read-uncommitted"><code class="literal">READ UNCOMMITTED</code></a>. To avoid
                    this scenario,
                    <a class="link" href="innodb-storage-engine.html#sysvar_innodb_stats_include_delete_marked"><code class="literal">innodb_stats_include_delete_marked</code></a>
                    can be enabled to ensure that delete-marked records are
                    included when calculating persistent optimizer statistics.
                </p><p style="color:blue;">默认情况下，innodb在计算统计数据时读取未提交的数据。对于从表中删除行的未提交事务，在计算行估计值和索引统计信息时，将排除已删除标记的记录，这可能会导致使用事务隔离级别（而不是读取未提交）同时在表上操作的其他事务的非最佳执行计划。为了避免这种情况，可以启用innodb_stats_include_delete_marked以确保在计算持久优化器统计信息时包含delete marked记录。</p><p>
                    When
                    <a class="link" href="innodb-storage-engine.html#sysvar_innodb_stats_include_delete_marked"><code class="literal">innodb_stats_include_delete_marked</code></a>
                    is enabled, <a class="link" href="sql-syntax.html#analyze-table" title="13.7.2.1&nbsp;ANALYZE TABLE Syntax"><code class="literal">ANALYZE TABLE</code></a>
                    considers delete-marked records when recalculating statistics.
                </p><p style="color:blue;">当启用innodb_stats_include_delete_marked时，analyze table在重新计算统计信息时会考虑删除标记的记录。</p><p>
                    <a class="link" href="innodb-storage-engine.html#sysvar_innodb_stats_include_delete_marked"><code class="literal">innodb_stats_include_delete_marked</code></a>
                    is a global setting that affects all <code class="literal">InnoDB</code>
                    tables, and it is only applicable to persistent optimizer
                    statistics.
                </p><p style="color:blue;">innodb_stats_include_delete_marked是一个影响所有innodb表的全局设置，它只适用于持久优化器统计。</p><p>
                    <a class="link" href="innodb-storage-engine.html#sysvar_innodb_stats_include_delete_marked"><code class="literal">innodb_stats_include_delete_marked</code></a>
                    was introduced in MySQL 5.7.16.
                </p><p style="color:blue;">innodb_stats_include_delete_marked是在mysql 5.7.16中引入的。</p>
                </div>
                <div class="section">
                    <div class="titlepage">
                        <div>
                            <div>
                                <h5 class="title"><a name="innodb-persistent-stats-tables"></a>14.8.11.1.5&nbsp;InnoDB Persistent Statistics Tables</h5>

                            </div>

                        </div>

                    </div>
                    <p>
                        The persistent statistics feature relies on the internally
                        managed tables in the <code class="literal">mysql</code> database, named
                        <code class="literal">innodb_table_stats</code> and
                        <code class="literal">innodb_index_stats</code>. These tables are set up
                        automatically in all install, upgrade, and build-from-source
                        procedures.
                    </p><p style="color:blue;">持久统计特性依赖于mysql数据库中的内部管理表，名为innodb_table_stats和innodb_index_stats。这些表在所有安装、升级和从源代码生成过程中自动设置。</p>
                    <div class="table">
                        <a name="innodb-table-stats-table"></a><p class="title"><b>Table&nbsp;14.5&nbsp;Columns of innodb_table_stats</b></p><p style="color:blue;">表14.5 InnoDB表列统计</p>
                        <div class="table-contents">
                            <table summary="Columns of the mysql.innodb_table_stats table."><colgroup><col width="30%"><col width="70%"></colgroup><thead><tr>
                                <th scope="col">Column name</th>
                                <th scope="col">Description</th>
                            </tr></thead><tbody><tr>
                                <td scope="row"><code class="literal">database_name</code></td>
                                <td>Database name</td>
                            </tr><tr>
                                <td scope="row"><code class="literal">table_name</code></td>
                                <td>Table name, partition name, or subpartition name</td>
                            </tr><tr>
                                <td scope="row"><code class="literal">last_update</code></td>
                                <td>A timestamp indicating the last time the row was updated</td>
                            </tr><tr>
                                <td scope="row"><code class="literal">n_rows</code></td>
                                <td>The number of rows in the table</td>
                            </tr><tr>
                                <td scope="row"><code class="literal">clustered_index_size</code></td>
                                <td>The size of the primary index, in pages</td>
                            </tr><tr>
                                <td scope="row"><code class="literal">sum_of_other_index_sizes</code></td>
                                <td>The total size of other (non-primary) indexes, in pages</td>
                            </tr></tbody></table>
                        </div>

                    </div>
                    <br class="table-break">
                    <div class="table">
                        <a name="innodb-index-stats-table"></a><p class="title"><b>Table&nbsp;14.6&nbsp;Columns of innodb_index_stats</b></p><p style="color:blue;">表14.6 innodb_index_stats列</p>
                        <div class="table-contents">
                            <table summary="Columns of the mysql.innodb_index_stats table."><colgroup><col width="30%"><col width="70%"></colgroup><thead><tr>
                                <th scope="col">Column name</th>
                                <th scope="col">Description</th>
                            </tr></thead><tbody><tr>
                                <td scope="row"><code class="literal">database_name</code></td>
                                <td>Database name</td>
                            </tr><tr>
                                <td scope="row"><code class="literal">table_name</code></td>
                                <td>Table name, partition name, or subpartition name</td>
                            </tr><tr>
                                <td scope="row"><code class="literal">index_name</code></td>
                                <td>Index name</td>
                            </tr><tr>
                                <td scope="row"><code class="literal">last_update</code></td>
                                <td>A timestamp indicating the last time that <code class="literal">InnoDB</code>
                                    updated this row</td>
                            </tr><tr>
                                <td scope="row"><code class="literal">stat_name</code></td>
                                <td>The name of the statistic, whose value is reported in the
                                    <code class="literal">stat_value</code> column</td>
                            </tr><tr>
                                <td scope="row"><code class="literal">stat_value</code></td>
                                <td>The value of the statistic that is named in <code class="literal">stat_name</code>
                                    column</td>
                            </tr><tr>
                                <td scope="row"><code class="literal">sample_size</code></td>
                                <td>The number of pages sampled for the estimate provided in the
                                    <code class="literal">stat_value</code> column</td>
                            </tr><tr>
                                <td scope="row"><code class="literal">stat_description</code></td>
                                <td>Description of the statistic that is named in the
                                    <code class="literal">stat_name</code> column</td>
                            </tr></tbody></table>
                        </div>

                    </div>
                    <br class="table-break"><p>
                    The <code class="literal">innodb_table_stats</code> and
                    <code class="literal">innodb_index_stats</code> tables include a
                    <code class="literal">last_update</code> column that shows when index
                    statistics were last updated:
                </p><p style="color:blue;">innodb_table_stats和innodb_index_stats表包含一个last_update列，显示上次更新索引统计信息的时间：</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT * FROM innodb_table_stats \G</code></strong>
*************************** 1. row ***************************
           database_name: sakila
              table_name: actor
             last_update: 2014-05-28 16:16:44
                  n_rows: 200
    clustered_index_size: 1
sum_of_other_index_sizes: 1
...</pre><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT * FROM innodb_index_stats \G</code></strong>
*************************** 1. row ***************************
   database_name: sakila
      table_name: actor
      index_name: PRIMARY
     last_update: 2014-05-28 16:16:44
       stat_name: n_diff_pfx01
      stat_value: 200
     sample_size: 1
     ...</pre><p>
                    The <code class="literal">innodb_table_stats</code> and
                    <code class="literal">innodb_index_stats</code> tables can be updated
                    manually, which makes it possible to force a specific query
                    optimization plan or test alternative plans without modifying
                    the database. If you manually update statistics, use the
                    <code class="literal">FLUSH TABLE
                        <em class="replaceable"><code>tbl_name</code></em></code> statement to
                    load the updated statistics.
                </p><p style="color:blue;">可以手动更新innodb_table_stats和innodb_index_stats表，这样就可以在不修改数据库的情况下强制执行特定的查询优化计划或测试替代计划。如果手动更新统计信息，请使用flush table tbl_name语句加载更新的统计信息。</p><p>
                    Persistent statistics are considered local information,
                    because they relate to the server instance. The
                    <code class="literal">innodb_table_stats</code> and
                    <code class="literal">innodb_index_stats</code> tables are therefore not
                    replicated when automatic statistics recalculation takes
                    place. If you run <a class="link" href="sql-syntax.html#analyze-table" title="13.7.2.1&nbsp;ANALYZE TABLE Syntax"><code class="literal">ANALYZE TABLE</code></a>
                    to initiate a synchronous recalculation of statistics, this
                    statement is replicated (unless you suppressed logging for
                    it), and recalculation takes place on the replication slaves.
                </p><p style="color:blue;">持久性统计信息被视为本地信息，因为它们与服务器实例相关。因此，当自动重新计算统计数据时，不会复制innodb_table_stats和innodb_index_stats表。如果运行analyze table以启动统计信息的同步重新计算，则会复制此语句（除非您取消了对它的日志记录），并在复制从机上进行重新计算。</p>
                </div>
                <div class="section">
                    <div class="titlepage">
                        <div>
                            <div>
                                <h5 class="title"><a name="innodb-persistent-stats-tables-example"></a>14.8.11.1.6&nbsp;InnoDB Persistent Statistics Tables Example</h5>

                            </div>

                        </div>

                    </div>
                    <p>
                        The <code class="literal">innodb_table_stats</code> table contains one
                        row for each table. The following example demonstrates the
                        type of data collected.
                    </p><p style="color:blue;">innodb_table_stats表为每个表包含一行。下面的示例演示收集的数据类型。</p><p>
                    Table <code class="literal">t1</code> contains a primary index (columns
                    <code class="literal">a</code>, <code class="literal">b</code>) secondary index
                    (columns <code class="literal">c</code>, <code class="literal">d</code>), and
                    unique index (columns <code class="literal">e</code>,<code class="literal">
                    f</code>):
                </p><p style="color:blue;">表T1包含一个主索引（A、B列）、二级索引（C、D列）和唯一索引（E、F列）：</p><pre data-lang="sql" class="programlisting">CREATE TABLE t1 (
a INT, b INT, c INT, d INT, e INT, f INT,
PRIMARY KEY (a, b), KEY i1 (c, d), UNIQUE KEY i2uniq (e, f)
) ENGINE=INNODB;
</pre><p>
                    After inserting five rows of sample data, table
                    <code class="literal">t1</code> appears as follows:
                </p><p style="color:blue;">插入五行样本数据后，表T1显示如下：</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT * FROM t1;</code></strong>
+---+---+------+------+------+------+
| a | b | c    | d    | e    | f    |
+---+---+------+------+------+------+
| 1 | 1 |   10 |   11 |  100 |  101 |
| 1 | 2 |   10 |   11 |  200 |  102 |
| 1 | 3 |   10 |   11 |  100 |  103 |
| 1 | 4 |   10 |   12 |  200 |  104 |
| 1 | 5 |   10 |   12 |  100 |  105 |
+---+---+------+------+------+------+
</pre><p>
                    To immediately update statistics, run
                    <a class="link" href="sql-syntax.html#analyze-table" title="13.7.2.1&nbsp;ANALYZE TABLE Syntax"><code class="literal">ANALYZE TABLE</code></a> (if
                    <a class="link" href="innodb-storage-engine.html#sysvar_innodb_stats_auto_recalc"><code class="literal">innodb_stats_auto_recalc</code></a> is
                    enabled, statistics are updated automatically within a few
                    seconds assuming that the 10% threshold for changed table rows
                    is reached):
                </p><p style="color:blue;">要立即更新统计信息，请运行analyze table（如果启用了innodb_stats_auto_recalc，则在几秒钟内自动更新统计信息，前提是已达到更改表行的10%阈值）：</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>ANALYZE TABLE t1;</code></strong>
+---------+---------+----------+----------+
| Table   | Op      | Msg_type | Msg_text |
+---------+---------+----------+----------+
| test.t1 | analyze | status   | OK       |
+---------+---------+----------+----------+
</pre><p>
                    Table statistics for table <code class="literal">t1</code> show the last
                    time <code class="literal">InnoDB</code> updated the table statistics
                    (<code class="literal">2014-03-14 14:36:34</code>), the number of rows
                    in the table (<code class="literal">5</code>), the clustered index size
                    (<code class="literal">1</code> page), and the combined size of the
                    other indexes (<code class="literal">2</code> pages).
                </p><p style="color:blue;">表T1的表统计信息显示了InnoDB上次更新表统计信息的时间（2014-03-14 14 14:36:34）、表中的行数（5）、聚集索引大小（1页）和其他索引的组合大小（2页）。</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT * FROM mysql.innodb_table_stats WHERE table_name like 't1'\G</code></strong>
*************************** 1. row ***************************
           database_name: test
              table_name: t1
             last_update: 2014-03-14 14:36:34
                  n_rows: 5
    clustered_index_size: 1
sum_of_other_index_sizes: 2
</pre><p>
                    The <code class="literal">innodb_index_stats</code> table contains
                    multiple rows for each index. Each row in the
                    <code class="literal">innodb_index_stats</code> table provides data
                    related to a particular index statistic which is named in the
                    <code class="literal">stat_name</code> column and described in the
                    <code class="literal">stat_description</code> column. For example:
                </p><p style="color:blue;">innodb_index_stats表包含每个索引的多行。innodb_index_stats表中的每一行提供与特定索引统计相关的数据，该统计在stat_name列中命名，在stat_description列中描述。例如：</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT index_name, stat_name, stat_value, stat_description</code></strong>
       <strong class="userinput"><code>FROM mysql.innodb_index_stats WHERE table_name like 't1';</code></strong>
+------------+--------------+------------+-----------------------------------+
| index_name | stat_name    | stat_value | stat_description                  |
+------------+--------------+------------+-----------------------------------+
| PRIMARY    | n_diff_pfx01 |          1 | a                                 |
| PRIMARY    | n_diff_pfx02 |          5 | a,b                               |
| PRIMARY    | n_leaf_pages |          1 | Number of leaf pages in the index |
| PRIMARY    | size         |          1 | Number of pages in the index      |
| i1         | n_diff_pfx01 |          1 | c                                 |
| i1         | n_diff_pfx02 |          2 | c,d                               |
| i1         | n_diff_pfx03 |          2 | c,d,a                             |
| i1         | n_diff_pfx04 |          5 | c,d,a,b                           |
| i1         | n_leaf_pages |          1 | Number of leaf pages in the index |
| i1         | size         |          1 | Number of pages in the index      |
| i2uniq     | n_diff_pfx01 |          2 | e                                 |
| i2uniq     | n_diff_pfx02 |          5 | e,f                               |
| i2uniq     | n_leaf_pages |          1 | Number of leaf pages in the index |
| i2uniq     | size         |          1 | Number of pages in the index      |
+------------+--------------+------------+-----------------------------------+
</pre><p>
                    The <code class="literal">stat_name</code> column shows the following
                    types of statistics:
                </p><p style="color:blue;">stat_name列显示以下统计类型：</p>
                    <div class="itemizedlist">
                        <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                            <code class="literal">size</code>: Where
                            <code class="literal">stat_name</code>=<code class="literal">size</code>, the
                            <code class="literal">stat_value</code> column displays the total
                            number of pages in the index.
                        </p><p style="color:blue;">size：stat_name=size时，stat_value列显示索引中的总页数。</p></li><li class="listitem"><p>
                            <code class="literal">n_leaf_pages</code>: Where
                            <code class="literal">stat_name</code>=<code class="literal">n_leaf_pages</code>,
                            the <code class="literal">stat_value</code> column displays the
                            number of leaf pages in the index.
                        </p><p style="color:blue;">n_leaf_pages：其中stat_name=n_leaf_pages，stat_value列显示索引中的叶页数。</p></li><li class="listitem"><p>
                            <code class="literal">n_diff_pfx<em class="replaceable"><code>NN</code></em></code>:
                            Where
                            <code class="literal">stat_name</code>=<code class="literal">n_diff_pfx01</code>,
                            the <code class="literal">stat_value</code> column displays the
                            number of distinct values in the first column of the
                            index. Where
                            <code class="literal">stat_name</code>=<code class="literal">n_diff_pfx02</code>,
                            the <code class="literal">stat_value</code> column displays the
                            number of distinct values in the first two columns of the
                            index, and so on. Where
                            <code class="literal">stat_name</code>=<code class="literal">n_diff_pfx<em class="replaceable"><code>NN</code></em></code>,
                            the <code class="literal">stat_description</code> column shows a
                            comma separated list of the index columns that are
                            counted.
                        </p><p style="color:blue;">n_diff_pfxnn：当stat_name=n_diff_pfx01时，stat_value列显示索引第一列中不同值的数目。其中stat_name=n_diff_pfx02，stat_value列显示索引前两列中不同值的数目，依此类推。其中stat_name=n_diff_pfxnn，stat_description列显示已计数的索引列的逗号分隔列表。</p></li></ul>
                    </div>
                    <p>
                        To further illustrate the
                        <code class="literal">n_diff_pfx<em class="replaceable"><code>NN</code></em></code>
                        statistic, which provides cardinality data, consider once
                        again the <code class="literal">t1</code> table example that was
                        introduced previously. As shown below, the
                        <code class="literal">t1</code> table is created with a primary index
                        (columns <code class="literal">a</code>, <code class="literal">b</code>), a
                        secondary index (columns <code class="literal">c</code>,
                        <code class="literal">d</code>), and a unique index (columns
                        <code class="literal">e</code>, <code class="literal">f</code>):
                    </p><p style="color:blue;">为了进一步说明提供基数数据的n_diff_pfxnn统计，请再次考虑前面介绍的T1表示例。如下图所示，T1表由一个主索引（A、B列）、一个辅助索引（C、D列）和一个唯一索引（E、F列）创建：</p><pre data-lang="sql" class="programlisting">CREATE TABLE t1 (
  a INT, b INT, c INT, d INT, e INT, f INT,
  PRIMARY KEY (a, b), KEY i1 (c, d), UNIQUE KEY i2uniq (e, f)
) ENGINE=INNODB;
</pre><p>
                    After inserting five rows of sample data, table
                    <code class="literal">t1</code> appears as follows:
                </p><p style="color:blue;">插入五行样本数据后，表T1显示如下：</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT * FROM t1;</code></strong>
+---+---+------+------+------+------+
| a | b | c    | d    | e    | f    |
+---+---+------+------+------+------+
| 1 | 1 |   10 |   11 |  100 |  101 |
| 1 | 2 |   10 |   11 |  200 |  102 |
| 1 | 3 |   10 |   11 |  100 |  103 |
| 1 | 4 |   10 |   12 |  200 |  104 |
| 1 | 5 |   10 |   12 |  100 |  105 |
+---+---+------+------+------+------+
</pre><p>
                    When you query the <code class="literal">index_name</code>,
                    <code class="literal">stat_name</code>, <code class="literal">stat_value</code>,
                    and <code class="literal">stat_description</code>, where
                    <code class="literal">stat_name LIKE 'n_diff%'</code>, the following
                    result set is returned:
                </p><p style="color:blue;">查询索引名、stat_name、stat_value和stat_description时，其中stat_name类似于'n_diff%'，将返回以下结果集：</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT index_name, stat_name, stat_value, stat_description</code></strong>
       <strong class="userinput"><code>FROM mysql.innodb_index_stats</code></strong>
       <strong class="userinput"><code>WHERE table_name like 't1' AND stat_name LIKE 'n_diff%';</code></strong>
+------------+--------------+------------+------------------+
| index_name | stat_name    | stat_value | stat_description |
+------------+--------------+------------+------------------+
| PRIMARY    | n_diff_pfx01 |          1 | a                |
| PRIMARY    | n_diff_pfx02 |          5 | a,b              |
| i1         | n_diff_pfx01 |          1 | c                |
| i1         | n_diff_pfx02 |          2 | c,d              |
| i1         | n_diff_pfx03 |          2 | c,d,a            |
| i1         | n_diff_pfx04 |          5 | c,d,a,b          |
| i2uniq     | n_diff_pfx01 |          2 | e                |
| i2uniq     | n_diff_pfx02 |          5 | e,f              |
+------------+--------------+------------+------------------+
</pre><p>
                    For the <code class="literal">PRIMARY</code> index, there are two
                    <code class="literal">n_diff%</code> rows. The number of rows is equal
                    to the number of columns in the index.
                </p><p style="color:blue;">对于主索引，有两个n_diff%行。行数等于索引中的列数。</p>
                    <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">

                        <div class="admon-title">
                            Note
                        </div>
                        <p>
                            For nonunique indexes, <code class="literal">InnoDB</code> appends the
                            columns of the primary key.
                        </p><p style="color:blue;">对于非均匀索引，innodb追加主键的列。</p>
                    </div>
                    <div class="itemizedlist">
                        <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                            Where
                            <code class="literal">index_name</code>=<code class="literal">PRIMARY</code>
                            and
                            <code class="literal">stat_name</code>=<code class="literal">n_diff_pfx01</code>,
                            the <code class="literal">stat_value</code> is <code class="literal">1</code>,
                            which indicates that there is a single distinct value in
                            the first column of the index (column
                            <code class="literal">a</code>). The number of distinct values in
                            column <code class="literal">a</code> is confirmed by viewing the
                            data in column <code class="literal">a</code> in table
                            <code class="literal">t1</code>, in which there is a single distinct
                            value (<code class="literal">1</code>). The counted column
                            (<code class="literal">a</code>) is shown in the
                            <code class="literal">stat_description</code> column of the result
                            set.
                        </p><p style="color:blue;">其中index_name=primary，stat_name=n_diff_pfx01，stat_值为1，表示索引的第一列（A列）中有一个单独的值。通过查看表T1中A列中的数据来确认A列中不同值的数量，其中有一个单独的不同值（1）。计数列（a）显示在结果集的stat_description列中。</p></li><li class="listitem"><p>
                            Where
                            <code class="literal">index_name</code>=<code class="literal">PRIMARY</code>
                            and
                            <code class="literal">stat_name</code>=<code class="literal">n_diff_pfx02</code>,
                            the <code class="literal">stat_value</code> is <code class="literal">5</code>,
                            which indicates that there are five distinct values in the
                            two columns of the index (<code class="literal">a,b</code>). The
                            number of distinct values in columns <code class="literal">a</code>
                            and <code class="literal">b</code> is confirmed by viewing the data
                            in columns <code class="literal">a</code> and <code class="literal">b</code>
                            in table <code class="literal">t1</code>, in which there are five
                            distinct values: (<code class="literal">1,1</code>),
                            (<code class="literal">1,2</code>), (<code class="literal">1,3</code>),
                            (<code class="literal">1,4</code>) and (<code class="literal">1,5</code>). The
                            counted columns (<code class="literal">a,b</code>) are shown in the
                            <code class="literal">stat_description</code> column of the result
                            set.
                        </p><p style="color:blue;">其中index_name=primary，stat_name=n_diff_pfx02，stat_value为5，表示索引的两列（a，b）中有五个不同的值。通过查看表T1中A列和B列中的数据，可以确定A列和B列中不同值的数量，其中有五个不同值：（1,1），（1,2），（1,3），（1,4）和（1,5）。计数列（a，b）显示在结果集的stat_description列中。</p></li></ul>
                    </div>
                    <p>
                        For the secondary index (<code class="literal">i1</code>), there are
                        four <code class="literal">n_diff%</code> rows. Only two columns are
                        defined for the secondary index (<code class="literal">c,d</code>) but
                        there are four <code class="literal">n_diff%</code> rows for the
                        secondary index because <code class="literal">InnoDB</code> suffixes all
                        nonunique indexes with the primary key. As a result, there are
                        four <code class="literal">n_diff%</code> rows instead of two to account
                        for the both the secondary index columns
                        (<code class="literal">c,d</code>) and the primary key columns
                        (<code class="literal">a,b</code>).
                    </p><p style="color:blue;">对于二级索引（i1），有四个n_diff%行。只为辅助索引（c，d）定义了两列，但是辅助索引有四个n_diff%行，因为innodb用主键对所有非唯一索引进行后缀。因此，有四个n_diff%行，而不是两个，用于同时考虑辅助索引列（c，d）和主键列（a，b）。</p>
                    <div class="itemizedlist">
                        <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                            Where <code class="literal">index_name</code>=<code class="literal">i1</code>
                            and
                            <code class="literal">stat_name</code>=<code class="literal">n_diff_pfx01</code>,
                            the <code class="literal">stat_value</code> is <code class="literal">1</code>,
                            which indicates that there is a single distinct value in
                            the first column of the index (column
                            <code class="literal">c</code>). The number of distinct values in
                            column <code class="literal">c</code> is confirmed by viewing the
                            data in column <code class="literal">c</code> in table
                            <code class="literal">t1</code>, in which there is a single distinct
                            value: (<code class="literal">10</code>). The counted column
                            (<code class="literal">c</code>) is shown in the
                            <code class="literal">stat_description</code> column of the result
                            set.
                        </p><p style="color:blue;">其中index_name=i1和stat_name=n_diff_pfx01，stat_值为1，表示索引的第一列（c列）中有一个单独的值。通过查看表T1中C列中的数据确认C列中的不同值的数量，其中有一个单独的不同值：（10）。计数列（c）显示在结果集的stat_description列中。</p></li><li class="listitem"><p>
                            Where <code class="literal">index_name</code>=<code class="literal">i1</code>
                            and
                            <code class="literal">stat_name</code>=<code class="literal">n_diff_pfx02</code>,
                            the <code class="literal">stat_value</code> is <code class="literal">2</code>,
                            which indicates that there are two distinct values in the
                            first two columns of the index (<code class="literal">c,d</code>).
                            The number of distinct values in columns
                            <code class="literal">c</code> an <code class="literal">d</code> is confirmed
                            by viewing the data in columns <code class="literal">c</code> and
                            <code class="literal">d</code> in table <code class="literal">t1</code>, in
                            which there are two distinct values:
                            (<code class="literal">10,11</code>) and (<code class="literal">10,12</code>).
                            The counted columns (<code class="literal">c,d</code>) are shown in
                            the <code class="literal">stat_description</code> column of the
                            result set.
                        </p><p style="color:blue;">其中index_name=i1和stat_name=n_diff_pfx02，stat_值为2，这表示索引的前两列（c，d）中有两个不同的值。通过查看表T1中C列和D列中的数据，可以确定C列和D列中不同值的数量，其中有两个不同值：（10,11）和（10,12）。计数列（c，d）显示在结果集的stat_description列中。</p></li><li class="listitem"><p>
                            Where <code class="literal">index_name</code>=<code class="literal">i1</code>
                            and
                            <code class="literal">stat_name</code>=<code class="literal">n_diff_pfx03</code>,
                            the <code class="literal">stat_value</code> is <code class="literal">2</code>,
                            which indicates that there are two distinct values in the
                            first three columns of the index
                            (<code class="literal">c,d,a</code>). The number of distinct values
                            in columns <code class="literal">c</code>, <code class="literal">d</code>, and
                            <code class="literal">a</code> is confirmed by viewing the data in
                            column <code class="literal">c</code>, <code class="literal">d</code>, and
                            <code class="literal">a</code> in table <code class="literal">t1</code>, in
                            which there are two distinct values:
                            (<code class="literal">10,11,1</code>) and
                            (<code class="literal">10,12,1</code>). The counted columns
                            (<code class="literal">c,d,a</code>) are shown in the
                            <code class="literal">stat_description</code> column of the result
                            set.
                        </p><p style="color:blue;">其中index_name=i1和stat_name=n_diff_pfx03，stat_值为2，这表示索引的前三列（c、d、a）中有两个不同的值。通过查看表T1中C、D和A列中的数据，确认C、D和A列中不同值的数量，其中有两个不同值：（10,11,1）和（10,12,1）。计数列（c、d、a）显示在结果集的stat_description列中。</p></li><li class="listitem"><p>
                            Where <code class="literal">index_name</code>=<code class="literal">i1</code>
                            and
                            <code class="literal">stat_name</code>=<code class="literal">n_diff_pfx04</code>,
                            the <code class="literal">stat_value</code> is <code class="literal">5</code>,
                            which indicates that there are five distinct values in the
                            four columns of the index (<code class="literal">c,d,a,b</code>).
                            The number of distinct values in columns
                            <code class="literal">c</code>, <code class="literal">d</code>,
                            <code class="literal">a</code> and <code class="literal">b</code> is confirmed
                            by viewing the data in columns <code class="literal">c</code>,
                            <code class="literal">d</code>, <code class="literal">a</code>, and
                            <code class="literal">b</code> in table <code class="literal">t1</code>, in
                            which there are five distinct values:
                            (<code class="literal">10,11,1,1</code>),
                            (<code class="literal">10,11,1,2</code>),
                            (<code class="literal">10,11,1,3</code>),
                            (<code class="literal">10,12,1,4</code>), and
                            (<code class="literal">10,12,1,5</code>). The counted columns
                            (<code class="literal">c,d,a,b</code>) are shown in the
                            <code class="literal">stat_description</code> column of the result
                            set.
                        </p><p style="color:blue;">其中index_name=i1和stat_name=n_diff_pfx04，stat_值为5，这表示索引的四列中有五个不同的值（c、d、a、b）。通过查看表T1中C、D、A和B列的数据，可以确定C、D、A和B列中不同值的数量，其中有五个不同值：（10、11、1、1），（10、11、1、2），（10、11、1、3），（10、12、1、4）和（10、12、1、5）。计数列（c、d、a、b）显示在结果集的stat_description列中。</p></li></ul>
                    </div>
                    <p>
                        For the unique index (<code class="literal">i2uniq</code>), there are
                        two <code class="literal">n_diff%</code> rows.
                    </p><p style="color:blue;">对于唯一索引（i2uniq），有两个n_diff%行。</p>
                    <div class="itemizedlist">
                        <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                            Where
                            <code class="literal">index_name</code>=<code class="literal">i2uniq</code>
                            and
                            <code class="literal">stat_name</code>=<code class="literal">n_diff_pfx01</code>,
                            the <code class="literal">stat_value</code> is <code class="literal">2</code>,
                            which indicates that there are two distinct values in the
                            first column of the index (column <code class="literal">e</code>).
                            The number of distinct values in column
                            <code class="literal">e</code> is confirmed by viewing the data in
                            column <code class="literal">e</code> in table
                            <code class="literal">t1</code>, in which there are two distinct
                            values: (<code class="literal">100</code>) and
                            (<code class="literal">200</code>). The counted column
                            (<code class="literal">e</code>) is shown in the
                            <code class="literal">stat_description</code> column of the result
                            set.
                        </p><p style="color:blue;">其中index_name=i2uniq和stat_name=n_diff_pfx01，stat_值为2，表示索引的第一列（e列）中有两个不同的值。通过查看表T1中E列中的数据来确认E列中不同值的数量，其中有两个不同值：（100）和（200）。计数列（e）显示在结果集的stat_description列中。</p></li><li class="listitem"><p>
                            Where
                            <code class="literal">index_name</code>=<code class="literal">i2uniq</code>
                            and
                            <code class="literal">stat_name</code>=<code class="literal">n_diff_pfx02</code>,
                            the <code class="literal">stat_value</code> is <code class="literal">5</code>,
                            which indicates that there are five distinct values in the
                            two columns of the index (<code class="literal">e,f</code>). The
                            number of distinct values in columns <code class="literal">e</code>
                            and <code class="literal">f</code> is confirmed by viewing the data
                            in columns <code class="literal">e</code> and <code class="literal">f</code>
                            in table <code class="literal">t1</code>, in which there are five
                            distinct values: (<code class="literal">100,101</code>),
                            (<code class="literal">200,102</code>),
                            (<code class="literal">100,103</code>),
                            (<code class="literal">200,104</code>), and
                            (<code class="literal">100,105</code>). The counted columns
                            (<code class="literal">e,f</code>) are shown in the
                            <code class="literal">stat_description</code> column of the result
                            set.
                        </p><p style="color:blue;">其中index_name=i2uniq和stat_name=n_diff_pfx02，stat_值为5，表示索引的两列中有五个不同的值（e，f）。通过查看表T1中的列E和F中的数据来确认列E和F中的不同值的数目，其中有五个不同值：（100101），（200102），（100103），（200104）和（100105）。计数列（e，f）显示在结果集的stat_description列中。</p></li></ul>
                    </div>

                </div>
                <div class="section">
                    <div class="titlepage">
                        <div>
                            <div>
                                <h5 class="title"><a name="innodb-persistent-stats-tables-index-size"></a>14.8.11.1.7&nbsp;Retrieving Index Size Using the innodb_index_stats Table</h5>

                            </div>

                        </div>

                    </div>
                    <p>
                        You can retrieve the index size for tables, partitions, or
                        subpartitions can using the
                        <code class="literal">innodb_index_stats</code> table. In the following
                        example, index sizes are retrieved for table
                        <code class="literal">t1</code>. For a definition of table
                        <code class="literal">t1</code> and corresponding index statistics, see
                        <a class="xref" href="innodb-storage-engine.html#innodb-persistent-stats-tables-example" title="14.8.11.1.6&nbsp;InnoDB Persistent Statistics Tables Example">Section&nbsp;14.8.11.1.6, “InnoDB Persistent Statistics Tables Example”</a>.
                    </p><p style="color:blue;">可以使用innodb_index_stats表检索表、分区或子分区的索引大小。在下面的示例中，检索表T1的索引大小。有关表T1和相应索引统计信息的定义，请参阅14.8.11.1.6节，“innodb persistent statistics tables example”。</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT SUM(stat_value) pages, index_name,</code></strong>
       <strong class="userinput"><code>SUM(stat_value)*@@innodb_page_size size</code></strong>
       <strong class="userinput"><code>FROM mysql.innodb_index_stats WHERE table_name='t1'</code></strong>
       <strong class="userinput"><code>AND stat_name = 'size' GROUP BY index_name;</code></strong>
+-------+------------+-------+
| pages | index_name | size  |
+-------+------------+-------+
|     1 | PRIMARY    | 16384 |
|     1 | i1         | 16384 |
|     1 | i2uniq     | 16384 |
+-------+------------+-------+
</pre><p>
                    For partitions or subpartitions, you can use the same query
                    with a modified <code class="literal">WHERE</code> clause to retrieve
                    index sizes. For example, the following query retrieves index
                    sizes for partitions of table <code class="literal">t1</code>:
                </p><p style="color:blue;">对于分区或子分区，可以对modified where子句使用相同的查询来检索索引大小。例如，以下查询检索表T1的分区的索引大小：</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT SUM(stat_value) pages, index_name,</code></strong>
       <strong class="userinput"><code>SUM(stat_value)*@@innodb_page_size size</code></strong>
       <strong class="userinput"><code>FROM mysql.innodb_index_stats WHERE table_name like 't1#P%'</code></strong>
       <strong class="userinput"><code>AND stat_name = 'size' GROUP BY index_name;</code></strong>
</pre>
                </div>

            </div>
            <div class="section">
                <div class="titlepage">
                    <div>
                        <div>
                            <h4 class="title"><a name="innodb-statistics-estimation"></a>14.8.11.2&nbsp;Configuring Non-Persistent Optimizer Statistics Parameters</h4>

                        </div>

                    </div>

                </div>
                <a class="indexterm" name="idm140286819360928"></a><a class="indexterm" name="idm140286819359856"></a><a class="indexterm" name="idm140286819358816"></a><p>
                This section describes how to configure non-persistent optimizer
                statistics. Optimizer statistics are not persisted to disk when
                <a class="link" href="innodb-storage-engine.html#sysvar_innodb_stats_persistent"><code class="literal">innodb_stats_persistent=OFF</code></a> or
                when individual tables are created or altered with
                <a class="link" href="sql-syntax.html#create-table" title="13.1.18&nbsp;CREATE TABLE Syntax"><code class="literal">STATS_PERSISTENT=0</code></a>.
                Instead, statistics are stored in memory, and are lost when the
                server is shut down. Statistics are also updated periodically by
                certain operations and under certain conditions.
            </p><p style="color:blue;">本节介绍如何配置非持久优化器统计信息。当innodb_stats_persistent=off或者当使用stats_persistent=0创建或更改单个表时，优化器统计信息不会持久化到磁盘。相反，统计数据存储在内存中，在服务器关闭时丢失。在某些情况下，某些操作也会定期更新统计数据。</p><p>
                As of MySQL 5.6.6, optimizer statistics are persisted to disk by
                default, enabled by the
                <a class="link" href="innodb-storage-engine.html#sysvar_innodb_stats_persistent"><code class="literal">innodb_stats_persistent</code></a>
                configuration option. For information about persistent optimizer
                statistics, see <a class="xref" href="innodb-storage-engine.html#innodb-persistent-stats" title="14.8.11.1&nbsp;Configuring Persistent Optimizer Statistics Parameters">Section&nbsp;14.8.11.1, “Configuring Persistent Optimizer Statistics Parameters”</a>.
            </p><p style="color:blue;">从mysql 5.6.6开始，优化器统计信息在默认情况下被持久化到磁盘，这是由innodb_stats_persistent配置选项启用的。有关持久优化器统计信息，请参阅第14.8.11.1节“配置持久优化器统计参数”。</p>
                <h5><a name="innodb-statistics-estimation-update"></a>Optimizer Statistics Updates</h5>
                <p>
                    Non-persistent optimizer statistics are updated when:
                </p><p style="color:blue;">非持久优化器统计信息在以下情况下更新：</p>
                <div class="itemizedlist">
                    <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                        Running <a class="link" href="sql-syntax.html#analyze-table" title="13.7.2.1&nbsp;ANALYZE TABLE Syntax"><code class="literal">ANALYZE TABLE</code></a>.
                    </p><p style="color:blue;">正在运行分析表。</p></li><li class="listitem"><p>
                        Running <a class="link" href="sql-syntax.html#show-table-status" title="13.7.5.36&nbsp;SHOW TABLE STATUS Syntax"><code class="literal">SHOW TABLE STATUS</code></a>,
                        <a class="link" href="sql-syntax.html#show-index" title="13.7.5.22&nbsp;SHOW INDEX Syntax"><code class="literal">SHOW INDEX</code></a>, or querying the
                        <a class="link" href="information-schema.html#tables-table" title="24.25&nbsp;The INFORMATION_SCHEMA TABLES Table"><code class="literal">INFORMATION_SCHEMA.TABLES</code></a> or
                        <a class="link" href="information-schema.html#statistics-table" title="24.24&nbsp;The INFORMATION_SCHEMA STATISTICS Table"><code class="literal">INFORMATION_SCHEMA.STATISTICS</code></a>
                        tables with the
                        <a class="link" href="innodb-storage-engine.html#sysvar_innodb_stats_on_metadata"><code class="literal">innodb_stats_on_metadata</code></a>
                        option enabled.
                    </p><p style="color:blue;">运行show table status、show index或查询information_schema.tables或information_schema.statistics表，同时启用innodb_stats_on_metadata选项。</p><p>
                        The default setting for
                        <a class="link" href="innodb-storage-engine.html#sysvar_innodb_stats_on_metadata"><code class="literal">innodb_stats_on_metadata</code></a>
                        was changed to <code class="literal">OFF</code> when persistent
                        optimizer statistics were enabled by default in MySQL 5.6.6.
                        Enabling
                        <a class="link" href="innodb-storage-engine.html#sysvar_innodb_stats_on_metadata"><code class="literal">innodb_stats_on_metadata</code></a>
                        may reduce access speed for schemas that have a large number
                        of tables or indexes, and reduce stability of execution
                        plans for queries that involve <code class="literal">InnoDB</code>
                        tables.
                        <a class="link" href="innodb-storage-engine.html#sysvar_innodb_stats_on_metadata"><code class="literal">innodb_stats_on_metadata</code></a> is
                        configured globally using a
                        <a class="link" href="data-types.html#set" title="11.4.5&nbsp;The SET Type"><code class="literal">SET</code></a> statement.
                    </p><p style="color:blue;">在mysql 5.6.6中默认启用持久优化器统计时，innodb_stats_on_元数据的默认设置更改为off。启用innodb_stats_on_元数据可能会降低具有大量表或索引的模式的访问速度，并降低涉及innodb表的查询的执行计划的稳定性。innodb_stats_on_元数据是使用set语句全局配置的。</p><pre data-lang="sql" class="programlisting">SET GLOBAL innodb_stats_on_metadata=ON
</pre>
                        <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">

                            <div class="admon-title">
                                Note
                            </div>
                            <p>
                                <a class="link" href="innodb-storage-engine.html#sysvar_innodb_stats_on_metadata"><code class="literal">innodb_stats_on_metadata</code></a>
                                only applies when optimizer
                                <a class="link" href="glossary.html#glos_statistics" title="statistics">statistics</a> are
                                configured to be non-persistent (when
                                <a class="link" href="innodb-storage-engine.html#sysvar_innodb_stats_persistent"><code class="literal">innodb_stats_persistent</code></a>
                                is disabled).
                            </p><p style="color:blue;">innodb_stats_on_元数据仅在优化器统计信息配置为非持久性时（当innodb_stats_persistent被禁用时）才适用。</p>
                        </div>
                    </li><li class="listitem"><p>
                        Starting a <a class="link" href="programs.html#mysql" title="4.5.1&nbsp;mysql — The MySQL Command-Line Client"><span class="command"><strong>mysql</strong></span></a> client with the
                        <a class="link" href="programs.html#option_mysql_auto-rehash"><code class="option">--auto-rehash</code></a> option enabled,
                        which is the default. The
                        <a class="link" href="programs.html#option_mysql_auto-rehash"><code class="option">auto-rehash</code></a> option causes all
                        <code class="literal">InnoDB</code> tables to be opened, and the open
                        table operations cause statistics to be recalculated.
                    </p><p style="color:blue;">在启用--auto rehash选项（这是默认设置）的情况下启动MySQL客户端。auto rehash选项将打开所有innodb表，open table操作将重新计算统计信息。</p><p>
                        To improve the start up time of the <a class="link" href="programs.html#mysql" title="4.5.1&nbsp;mysql — The MySQL Command-Line Client"><span class="command"><strong>mysql</strong></span></a>
                        client and to updating statistics, you can turn off
                        <a class="link" href="programs.html#option_mysql_auto-rehash"><code class="option">auto-rehash</code></a> using the
                        <a class="link" href="programs.html#option_mysql_auto-rehash"><code class="option">--disable-auto-rehash</code></a>
                        option. The <a class="link" href="programs.html#option_mysql_auto-rehash"><code class="option">auto-rehash</code></a>
                        feature enables automatic name completion of database,
                        table, and column names for interactive users.
                    </p><p style="color:blue;">为了提高mysql客户机的启动时间和更新统计信息，可以使用--disable auto rehash选项关闭auto rehash。auto rehash特性允许交互式用户自动完成数据库、表和列名的名称。</p></li><li class="listitem"><p>
                        A table is first opened.
                    </p><p style="color:blue;">首先打开一张桌子。</p></li><li class="listitem"><p>
                        <code class="literal">InnoDB</code> detects that 1 / 16 of table has
                        been modified since the last time statistics were updated.
                    </p><p style="color:blue;">InnoDB检测到自上次更新统计数据以来，表的1/16已被修改。</p></li></ul>
                </div>
                <h5><a name="idm140286819315952"></a>Configuring the Number of Sampled Pages</h5>
                <p>
                    The MySQL query optimizer uses estimated
                    <a class="link" href="glossary.html#glos_statistics" title="statistics">statistics</a> about key
                    distributions to choose the indexes for an execution plan, based
                    on the relative
                    <a class="link" href="glossary.html#glos_selectivity" title="selectivity">selectivity</a> of the
                    index. When <code class="literal">InnoDB</code> updates optimizer
                    statistics, it samples random pages from each index on a table
                    to estimate the
                    <a class="link" href="glossary.html#glos_cardinality" title="cardinality">cardinality</a> of the
                    index. (This technique is known as
                    <a class="link" href="glossary.html#glos_random_dive" title="random dive">random dives</a>.)
                </p><p style="color:blue;">mysql查询优化器根据索引的相对选择性，使用有关键分布的估计统计信息来选择执行计划的索引。当innodb更新优化器统计信息时，它会从表上的每个索引中随机抽取页面来估计索引的基数。（这种技术称为随机跳水。）</p><p>
                To give you control over the quality of the statistics estimate
                (and thus better information for the query optimizer), you can
                change the number of sampled pages using the parameter
                <a class="link" href="innodb-storage-engine.html#sysvar_innodb_stats_transient_sample_pages"><code class="literal">innodb_stats_transient_sample_pages</code></a>.
                The default number of sampled pages is 8, which could be
                insufficient to produce an accurate estimate, leading to poor
                index choices by the query optimizer. This technique is
                especially important for large tables and tables used in
                <a class="link" href="glossary.html#glos_join" title="join">joins</a>. Unnecessary
                <a class="link" href="glossary.html#glos_full_table_scan" title="full table scan">full table scans</a> for
                such tables can be a substantial performance issue. See
                <a class="xref" href="optimization.html#table-scan-avoidance" title="8.2.1.20&nbsp;Avoiding Full Table Scans">Section&nbsp;8.2.1.20, “Avoiding Full Table Scans”</a> for tips on tuning such
                queries.
                <a class="link" href="innodb-storage-engine.html#sysvar_innodb_stats_transient_sample_pages"><code class="literal">innodb_stats_transient_sample_pages</code></a>
                is a global parameter that can be set at runtime.
            </p><p style="color:blue;">为了控制统计估计的质量（从而为查询优化器提供更好的信息），可以使用参数innodb_stats_transient_sample_pages更改采样页面的数量。默认的抽样页面数是8，这可能不足以产生准确的估计，从而导致查询优化器的索引选择不当。这种技术对于连接中使用的大型表和表尤其重要。对此类表不必要的全表扫描可能是一个很大的性能问题。有关优化此类查询的提示，请参阅第8.2.1.20节“避免全表扫描”。innodb_stats_transient_sample_pages是一个全局参数，可以在运行时设置。</p><p>
                The value of
                <a class="link" href="innodb-storage-engine.html#sysvar_innodb_stats_transient_sample_pages"><code class="literal">innodb_stats_transient_sample_pages</code></a>
                affects the index sampling for all <code class="literal">InnoDB</code>
                tables and indexes when
                <a class="link" href="innodb-storage-engine.html#sysvar_innodb_stats_persistent"><code class="literal">innodb_stats_persistent=0</code></a>. Be
                aware of the following potentially significant impacts when you
                change the index sample size:

            </p><p style="color:blue;">innodb_stats_transient_sample_pages的值在innodb_stats_persistent=0时影响所有innodb表和索引的索引采样。更改索引样本大小时，请注意以下潜在的重大影响：</p>
                <div class="itemizedlist">
                    <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                        Small values like 1 or 2 can result in inaccurate
                        estimates of cardinality.
                    </p><p style="color:blue;">较小的值（如1或2）可能导致对基数的不准确估计。</p></li><li class="listitem"><p>
                        Increasing the
                        <a class="link" href="innodb-storage-engine.html#sysvar_innodb_stats_transient_sample_pages"><code class="literal">innodb_stats_transient_sample_pages</code></a>
                        value might require more disk reads. Values much larger
                        than 8 (say, 100), can cause a significant slowdown in the
                        time it takes to open a table or execute <code class="literal">SHOW
                        TABLE STATUS</code>.
                    </p><p style="color:blue;">增加innodb_stats_transient_sample_pages值可能需要更多的磁盘读取。值远远大于8（例如100）可能会导致打开表或执行show table status所需的时间显著减慢。</p></li><li class="listitem"><p>
                        The optimizer might choose very different query plans
                        based on different estimates of index selectivity.
                    </p><p style="color:blue;">优化器可能根据索引选择性的不同估计选择非常不同的查询计划。</p></li></ul>
                </div>
                <p>
                </p><p>
                Whatever value of
                <a class="link" href="innodb-storage-engine.html#sysvar_innodb_stats_transient_sample_pages"><code class="literal">innodb_stats_transient_sample_pages</code></a>
                works best for a system, set the option and leave it at that
                value. Choose a value that results in reasonably accurate
                estimates for all tables in your database without requiring
                excessive I/O. Because the statistics are automatically
                recalculated at various times other than on execution of
                <a class="link" href="sql-syntax.html#analyze-table" title="13.7.2.1&nbsp;ANALYZE TABLE Syntax"><code class="literal">ANALYZE TABLE</code></a>, it does not make
                sense to increase the index sample size, run
                <a class="link" href="sql-syntax.html#analyze-table" title="13.7.2.1&nbsp;ANALYZE TABLE Syntax"><code class="literal">ANALYZE TABLE</code></a>, then decrease
                sample size again.
            </p><p style="color:blue;">无论innodb_stats_transient_sample_页面的值是什么，都最适合系统，设置该选项并保留该值。选择一个值，该值可在不需要过多I/O的情况下对数据库中的所有表进行合理准确的估计。由于统计信息在执行分析表时以外的不同时间自动重新计算，因此增加索引样本大小、运行分析表，然后再次减小样本大小是没有意义的。</p><p>
                Smaller tables generally require fewer index samples than larger
                tables. If your database has many large tables, consider using a
                higher value for
                <a class="link" href="innodb-storage-engine.html#sysvar_innodb_stats_transient_sample_pages"><code class="literal">innodb_stats_transient_sample_pages</code></a>
                than if you have mostly smaller tables.
            </p><p style="color:blue;">较小的表通常比较大的表需要更少的索引样本。如果您的数据库有很多大表，那么考虑对innodb_stats_transient_sample_页面使用一个更高的值，而不是对大多数较小的表使用这个值。</p>
            </div>
            <div class="section">
                <div class="titlepage">
                    <div>
                        <div>
                            <h4 class="title"><a name="innodb-analyze-table-complexity"></a>14.8.11.3&nbsp;Estimating ANALYZE TABLE Complexity for InnoDB Tables</h4>

                        </div>

                    </div>

                </div>
                <p>
                    <a class="link" href="sql-syntax.html#analyze-table" title="13.7.2.1&nbsp;ANALYZE TABLE Syntax"><code class="literal">ANALYZE TABLE</code></a> complexity for
                    <code class="literal">InnoDB</code> tables is dependent on:
                </p><p style="color:blue;">分析UnIDB表的表复杂度取决于：</p>
                <div class="itemizedlist">
                    <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                        The number of pages sampled, as defined by
                        <a class="link" href="innodb-storage-engine.html#sysvar_innodb_stats_persistent_sample_pages"><code class="literal">innodb_stats_persistent_sample_pages</code></a>.
                    </p><p style="color:blue;">innodb_stats_persistent_sample_页面定义的采样页面数。</p></li><li class="listitem"><p>
                        The number of indexed columns in a table
                    </p><p style="color:blue;">表中索引列的数目</p></li><li class="listitem"><p>
                        The number of partitions. If a table has no partitions, the
                        number of partitions is considered to be 1.
                    </p><p style="color:blue;">分区的数目。如果一个表没有分区，那么分区的数目被认为是1。</p></li></ul>
                </div>
                <p>
                    Using these parameters, an approximate formula for estimating
                    <a class="link" href="sql-syntax.html#analyze-table" title="13.7.2.1&nbsp;ANALYZE TABLE Syntax"><code class="literal">ANALYZE TABLE</code></a> complexity would
                    be:
                </p><p style="color:blue;">使用这些参数，估计分析表复杂度的近似公式将是：</p><p>
                The value of
                <a class="link" href="innodb-storage-engine.html#sysvar_innodb_stats_persistent_sample_pages"><code class="literal">innodb_stats_persistent_sample_pages</code></a>
                * number of indexed columns in a table * the number of
                partitions
            </p><p style="color:blue;">innodb_stats_persistent_sample_pages的值*表中的索引列数*分区数</p><p>
                Typically, the greater the resulting value, the greater the
                execution time for <a class="link" href="sql-syntax.html#analyze-table" title="13.7.2.1&nbsp;ANALYZE TABLE Syntax"><code class="literal">ANALYZE TABLE</code></a>.
            </p><p style="color:blue;">通常，结果值越大，analyze表的执行时间就越长。</p>
                <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">

                    <div class="admon-title">
                        Note
                    </div>
                    <p>
                        <a class="link" href="innodb-storage-engine.html#sysvar_innodb_stats_persistent_sample_pages"><code class="literal">innodb_stats_persistent_sample_pages</code></a>
                        defines the number of pages sampled at a global level. To set
                        the number of pages sampled for an individual table, use the
                        <code class="literal">STATS_SAMPLE_PAGES</code> option with
                        <a class="link" href="sql-syntax.html#create-table" title="13.1.18&nbsp;CREATE TABLE Syntax"><code class="literal">CREATE TABLE</code></a> or
                        <a class="link" href="sql-syntax.html#alter-table" title="13.1.8&nbsp;ALTER TABLE Syntax"><code class="literal">ALTER TABLE</code></a>. For more
                        information, see <a class="xref" href="innodb-storage-engine.html#innodb-persistent-stats" title="14.8.11.1&nbsp;Configuring Persistent Optimizer Statistics Parameters">Section&nbsp;14.8.11.1, “Configuring Persistent Optimizer Statistics Parameters”</a>.
                    </p><p style="color:blue;">innodb_stats_persistent_sample_pages定义在全局级别上采样的页数。要设置为单个表采样的页数，请将stats_sample_pages选项与create table或alter table一起使用。有关更多信息，请参阅第14.8.11.1节“配置持久优化器统计参数”。</p><p>
                    If
                    <a class="link" href="innodb-storage-engine.html#sysvar_innodb_stats_persistent"><code class="literal">innodb_stats_persistent=OFF</code></a>,
                    the number of pages sampled is defined by
                    <a class="link" href="innodb-storage-engine.html#sysvar_innodb_stats_transient_sample_pages"><code class="literal">innodb_stats_transient_sample_pages</code></a>.
                    See <a class="xref" href="innodb-storage-engine.html#innodb-statistics-estimation" title="14.8.11.2&nbsp;Configuring Non-Persistent Optimizer Statistics Parameters">Section&nbsp;14.8.11.2, “Configuring Non-Persistent Optimizer Statistics Parameters”</a> for
                    additional information.
                </p><p style="color:blue;">如果innodb_stats_persistent=off，采样的页数由innodb_stats_transient_sample_pages定义。有关更多信息，请参阅第14.8.11.2节“配置非持久优化器统计参数”。</p>
                </div>
                <p>
                    For a more in-depth approach to estimating <code class="literal">ANALYZE
                    TABLE</code> complexity, consider the following example.
                </p><p style="color:blue;">为了更深入地分析分析表复杂度，请考虑下面的示例。</p><p>
                In <a class="ulink" href="http://en.wikipedia.org/wiki/Big_O_notation" target="_top">Big
                O notation</a>, <a class="link" href="sql-syntax.html#analyze-table" title="13.7.2.1&nbsp;ANALYZE TABLE Syntax"><code class="literal">ANALYZE TABLE</code></a>
                complexity is described as:
            </p><p style="color:blue;">在大O表示法中，分析表复杂性描述为：</p><pre data-lang="none" class="programlisting">
O(n_sample
  * (n_cols_in_uniq_i
     + n_cols_in_non_uniq_i
     + n_cols_in_pk * (1 + n_non_uniq_i))
  * n_part)
</pre><p>
                where:
            </p><p style="color:blue;">在哪里？</p>
                <div class="itemizedlist">
                    <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                        <code class="literal">n_sample</code> is the number of pages sampled
                        (defined by
                        <a class="link" href="innodb-storage-engine.html#sysvar_innodb_stats_persistent_sample_pages"><code class="literal">innodb_stats_persistent_sample_pages</code></a>)
                    </p><p style="color:blue;">n_sample是采样的页数（由innodb_stats_persistent_sample_pages定义）</p></li><li class="listitem"><p>
                        <code class="literal">n_cols_in_uniq_i</code> is total number of all
                        columns in all unique indexes (not counting the primary key
                        columns)
                    </p><p style="color:blue;">n_cols_in_uniq_i是所有唯一索引中所有列的总数（不包括主键列）</p></li><li class="listitem"><p>
                        <code class="literal">n_cols_in_non_uniq_i</code> is the total number
                        of all columns in all nonunique indexes
                    </p><p style="color:blue;">n_cols_in_non_uniq_i是所有非唯一索引中所有列的总数</p></li><li class="listitem"><p>
                        <code class="literal">n_cols_in_pk</code> is the number of columns in
                        the primary key (if a primary key is not defined,
                        <code class="literal">InnoDB</code> creates a single column primary
                        key internally)
                    </p><p style="color:blue;">n_cols_in_pk是主键中的列数（如果没有定义主键，innodb会在内部创建一个单列主键）</p></li><li class="listitem"><p>
                        <code class="literal">n_non_uniq_i</code> is the number of nonunique
                        indexes in the table
                    </p><p style="color:blue;">n_non_uniq_i是表中非唯一索引的数目</p></li><li class="listitem"><p>
                        <code class="literal">n_part</code> is the number of partitions. If no
                        partitions are defined, the table is considered to be a
                        single partition.
                    </p><p style="color:blue;">n_part是分区数。如果没有定义分区，则将表视为单个分区。</p></li></ul>
                </div>
                <p>
                    Now, consider the following table (table <code class="literal">t</code>),
                    which has a primary key (2 columns), a unique index (2 columns),
                    and two nonunique indexes (two columns each):
                </p><p style="color:blue;">现在，考虑下表（表T），它有一个主键（两列）、一个唯一索引（两列）和两个非唯一索引（每列两列）：</p><pre data-lang="sql" class="programlisting">CREATE TABLE t (
  a INT,
  b INT,
  c INT,
  d INT,
  e INT,
  f INT,
  g INT,
  h INT,
  PRIMARY KEY (a, b),
  UNIQUE KEY i1uniq (c, d),
  KEY i2nonuniq (e, f),
  KEY i3nonuniq (g, h)
);
</pre><p>
                For the column and index data required by the algorithm
                described above, query the
                <code class="literal">mysql.innodb_index_stats</code> persistent index
                statistics table for table <code class="literal">t</code>. The
                <code class="literal">n_diff_pfx%</code> statistics show the columns that
                are counted for each index. For example, columns
                <code class="literal">a</code> and <code class="literal">b</code> are counted for
                the primary key index. For the nonunique indexes, the primary
                key columns (a,b) are counted in addition to the user defined
                columns.
            </p><p style="color:blue;">对于上述算法所需的列和索引数据，请查询表t的mysql.innodb_index_stats persistent index statistics表。n_diff_pfx%统计信息显示为每个索引计数的列。例如，列A和列B被计算为主键索引。对于非唯一索引，除了用户定义的列之外，主键列（a，b）也会被计算在内。</p>
                <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">

                    <div class="admon-title">
                        Note
                    </div>
                    <p>
                        For additional information about the <code class="literal">InnoDB</code>
                        persistent statistics tables, see
                        <a class="xref" href="innodb-storage-engine.html#innodb-persistent-stats" title="14.8.11.1&nbsp;Configuring Persistent Optimizer Statistics Parameters">Section&nbsp;14.8.11.1, “Configuring Persistent Optimizer Statistics Parameters”</a>
                    </p><p style="color:blue;">有关innodb persistent statistics表的更多信息，请参阅14.8.11.1节，“配置persistent optimizer统计参数”</p>
                </div>
                <pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT index_name, stat_name, stat_description</code></strong>
       <strong class="userinput"><code>FROM mysql.innodb_index_stats WHERE</code></strong>
       <strong class="userinput"><code>database_name='test' AND</code></strong>
       <strong class="userinput"><code>table_name='t' AND</code></strong>
       <strong class="userinput"><code>stat_name like 'n_diff_pfx%';</code></strong>
  +------------+--------------+------------------+
  | index_name | stat_name    | stat_description |
  +------------+--------------+------------------+
  | PRIMARY    | n_diff_pfx01 | a                |
  | PRIMARY    | n_diff_pfx02 | a,b              |
  | i1uniq     | n_diff_pfx01 | c                |
  | i1uniq     | n_diff_pfx02 | c,d              |
  | i2nonuniq  | n_diff_pfx01 | e                |
  | i2nonuniq  | n_diff_pfx02 | e,f              |
  | i2nonuniq  | n_diff_pfx03 | e,f,a            |
  | i2nonuniq  | n_diff_pfx04 | e,f,a,b          |
  | i3nonuniq  | n_diff_pfx01 | g                |
  | i3nonuniq  | n_diff_pfx02 | g,h              |
  | i3nonuniq  | n_diff_pfx03 | g,h,a            |
  | i3nonuniq  | n_diff_pfx04 | g,h,a,b          |
  +------------+--------------+------------------+
</pre><p>
                Based on the index statistics data shown above and the table
                definition, the following values can be determined:
            </p><p style="color:blue;">根据上面显示的索引统计数据和表定义，可以确定以下值：</p>
                <div class="itemizedlist">
                    <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                        <code class="literal">n_cols_in_uniq_i</code>, the total number of all
                        columns in all unique indexes not counting the primary key
                        columns, is 2 (<code class="literal">c</code> and
                        <code class="literal">d</code>)
                    </p><p style="color:blue;">n_cols_in_uniq_i，所有唯一索引中不包括主键列的所有列的总数为2（c和d）</p></li><li class="listitem"><p>
                        <code class="literal">n_cols_in_non_uniq_i</code>, the total number of
                        all columns in all nonunique indexes, is 4
                        (<code class="literal">e</code>, <code class="literal">f</code>,
                        <code class="literal">g</code> and <code class="literal">h</code>)
                    </p><p style="color:blue;">n_cols_in_non_uniq_i，所有非唯一索引中所有列的总数为4（e、f、g和h）</p></li><li class="listitem"><p>
                        <code class="literal">n_cols_in_pk</code>, the number of columns in
                        the primary key, is 2 (<code class="literal">a</code> and
                        <code class="literal">b</code>)
                    </p><p style="color:blue;">n_cols_in_pk，主键中的列数是2（a和b）</p></li><li class="listitem"><p>
                        <code class="literal">n_non_uniq_i</code>, the number of nonunique
                        indexes in the table, is 2 (<code class="literal">i2nonuniq</code> and
                        <code class="literal">i3nonuniq</code>))
                    </p><p style="color:blue;">n_non_uniq_i，表中非唯一索引的数目为2（i2nonuniq和i3nonuniq）</p></li><li class="listitem"><p>
                        <code class="literal">n_part</code>, the number of partitions, is 1.
                    </p><p style="color:blue;">n_部分，分区的数目，是1。</p></li></ul>
                </div>
                <p>
                    You can now calculate
                    <code class="literal">innodb_stats_persistent_sample_pages</code> * (2 + 4
                    + 2 * (1 + 2)) * 1 to determine the number of leaf pages that
                    are scanned. With
                    <code class="literal">innodb_stats_persistent_sample_pages</code> set to
                    the default value of <code class="literal">20</code>, and with a default
                    page size of 16 <code class="literal">KiB</code>
                    (<a class="link" href="innodb-storage-engine.html#sysvar_innodb_page_size"><code class="literal">innodb_page_size</code></a>=16384), you
                    can then estimate that 20 * 12 * 16384 <code class="literal">bytes</code>
                    are read for table <code class="literal">t</code>, or about 4
                    <code class="literal">MiB</code>.
                </p><p style="color:blue;">现在可以计算innodb_stats_persistent_sample_pages*（2+4+2*（1+2））*1来确定扫描的叶页数。如果innodb_stats_persistent_sample_pages设置为默认值20，并且默认页面大小为16 kib（innodb_pages_size=16384），那么可以估计表t的读取字节数为20*12*16384，或者大约为4 mib。</p>
                <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">

                    <div class="admon-title">
                        Note
                    </div>
                    <p>
                        All 4 <code class="literal">MiB</code> may not be read from disk, as
                        some leaf pages may already be cached in the buffer pool.
                    </p><p style="color:blue;">可能无法从磁盘读取所有4 MIB，因为某些叶页可能已缓存在缓冲池中。</p>
                </div>

            </div>

        </div>
        <div class="section">
            <div class="titlepage">
                <div>
                    <div>
                        <h3 class="title"><a name="index-page-merge-threshold"></a>14.8.12&nbsp;Configuring the Merge Threshold for Index Pages</h3>

                    </div>

                </div>

            </div>
            <p>
                You can configure the <code class="literal">MERGE_THRESHOLD</code> value for
                index pages. If the <span class="quote">“<span class="quote">page-full</span>”</span> percentage for an
                index page falls below the <code class="literal">MERGE_THRESHOLD</code>
                value when a row is deleted or when a row is shortened by an
                <a class="link" href="sql-syntax.html#update" title="13.2.11&nbsp;UPDATE Syntax"><code class="literal">UPDATE</code></a> operation,
                <code class="literal">InnoDB</code> attempts to merge the index page with a
                neighboring index page. The default
                <code class="literal">MERGE_THRESHOLD</code> value is 50, which is the
                previously hardcoded value. The minimum
                <code class="literal">MERGE_THRESHOLD</code> value is 1 and the maximum
                value is 50.
            </p><p style="color:blue;">您可以为索引页配置合并阈值。如果删除行或更新操作缩短行时，索引页的“页满”百分比低于合并阈值，InnoDB将尝试将索引页与相邻索引页合并。默认的合并阈值是50，这是以前硬编码的值。最小值阈值为1，最大值为50。</p><p>
            When the <span class="quote">“<span class="quote">page-full</span>”</span> percentage for an index page
            falls below 50%, which is the default
            <code class="literal">MERGE_THRESHOLD</code> setting,
            <code class="literal">InnoDB</code> attempts to merge the index page with a
            neighboring page. If both pages are close to 50% full, a page
            split can occur soon after the pages are merged. If this
            merge-split behavior occurs frequently, it can have an adverse
            affect on performance. To avoid frequent merge-splits, you can
            lower the <code class="literal">MERGE_THRESHOLD</code> value so that
            <code class="literal">InnoDB</code> attempts page merges at a lower
            <span class="quote">“<span class="quote">page-full</span>”</span> percentage. Merging pages at a lower
            page-full percentage leaves more room in index pages and helps
            reduce merge-split behavior.
        </p><p style="color:blue;">当索引页的“页满”百分比低于50%（这是默认的合并阈值设置）时，InnoDB会尝试将索引页与相邻页合并。如果两个页面都接近50%已满，则合并页面后很快就会发生页面拆分。如果此合并拆分行为频繁发生，则可能会对性能产生不利影响。为了避免频繁的合并拆分，您可以降低合并阈值，以便innodb以较低的“页面满”百分比尝试页面合并。以较低的页面完整百分比合并页面会在索引页面中留下更多空间，并有助于减少合并拆分行为。</p><p>
            The <code class="literal">MERGE_THRESHOLD</code> for index pages can be
            defined for a table or for individual indexes. A
            <code class="literal">MERGE_THRESHOLD</code> value defined for an individual
            index takes priority over a <code class="literal">MERGE_THRESHOLD</code>
            value defined for the table. If undefined, the
            <code class="literal">MERGE_THRESHOLD</code> value defaults to 50.
        </p><p style="color:blue;">可以为表或单个索引定义索引页的合并阈值。为单个索引定义的合并阈值优先于为表定义的合并阈值。如果未定义，则合并阈值默认为50。</p>
            <h4><a name="idm140286819194896"></a>Setting MERGE_THRESHOLD for a Table</h4>
            <p>
                You can set the <code class="literal">MERGE_THRESHOLD</code> value for a
                table using the <em class="replaceable"><code>table_option</code></em>
                <code class="literal">COMMENT</code> clause of the
                <a class="link" href="sql-syntax.html#create-table" title="13.1.18&nbsp;CREATE TABLE Syntax"><code class="literal">CREATE TABLE</code></a> statement. For
                example:
            </p><p style="color:blue;">您可以使用CREATETABLE语句的TABLE U OPTION comment子句设置表的MERGE U阈值。例如：</p><pre data-lang="sql" class="programlisting">CREATE TABLE t1 (
   id INT,
  KEY id_index (id)
) COMMENT='MERGE_THRESHOLD=45';
</pre><p>
            You can also set the <code class="literal">MERGE_THRESHOLD</code> value for
            an existing table using the
            <em class="replaceable"><code>table_option</code></em> <code class="literal">COMMENT</code>
            clause with <a class="link" href="sql-syntax.html#alter-table" title="13.1.8&nbsp;ALTER TABLE Syntax"><code class="literal">ALTER TABLE</code></a>:
        </p><p style="color:blue;">还可以使用TabelYOffice注释子句使用ALTE表设置现有表的MelGeHead阈值：</p><pre data-lang="sql" class="programlisting">CREATE TABLE t1 (
   id INT,
  KEY id_index (id)
);

ALTER TABLE t1 COMMENT='MERGE_THRESHOLD=40';
</pre>
            <h4><a name="idm140286819185088"></a>Setting MERGE_THRESHOLD for Individual Indexes</h4>
            <p>
                To set the <code class="literal">MERGE_THRESHOLD</code> value for an
                individual index, you can use the
                <em class="replaceable"><code>index_option</code></em> <code class="literal">COMMENT</code>
                clause with <a class="link" href="sql-syntax.html#create-table" title="13.1.18&nbsp;CREATE TABLE Syntax"><code class="literal">CREATE TABLE</code></a>,
                <a class="link" href="sql-syntax.html#alter-table" title="13.1.8&nbsp;ALTER TABLE Syntax"><code class="literal">ALTER TABLE</code></a>, or
                <a class="link" href="sql-syntax.html#create-index" title="13.1.14&nbsp;CREATE INDEX Syntax"><code class="literal">CREATE INDEX</code></a>, as shown in the
                following examples:
            </p><p style="color:blue;">要设置单个索引的合并阈值，可以将index_option comment子句与create table、alter table或create index一起使用，如下例所示：</p>
            <div class="itemizedlist">
                <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                    Setting <code class="literal">MERGE_THRESHOLD</code> for an individual
                    index using <a class="link" href="sql-syntax.html#create-table" title="13.1.18&nbsp;CREATE TABLE Syntax"><code class="literal">CREATE TABLE</code></a>:
                </p><p style="color:blue;">使用创建表为单个索引设置合并阈值：</p><pre data-lang="sql" class="programlisting">CREATE TABLE t1 (
   id INT,
  KEY id_index (id) COMMENT 'MERGE_THRESHOLD=40'
);
</pre></li><li class="listitem"><p>
                    Setting <code class="literal">MERGE_THRESHOLD</code> for an individual
                    index using <a class="link" href="sql-syntax.html#alter-table" title="13.1.8&nbsp;ALTER TABLE Syntax"><code class="literal">ALTER TABLE</code></a>:
                </p><p style="color:blue;">使用alter table为单个索引设置合并阈值：</p><pre data-lang="sql" class="programlisting">CREATE TABLE t1 (
   id INT,
  KEY id_index (id)
);

ALTER TABLE t1 DROP KEY id_index;
ALTER TABLE t1 ADD KEY id_index (id) COMMENT 'MERGE_THRESHOLD=40';
</pre></li><li class="listitem"><p>
                    Setting <code class="literal">MERGE_THRESHOLD</code> for an individual
                    index using <a class="link" href="sql-syntax.html#create-index" title="13.1.14&nbsp;CREATE INDEX Syntax"><code class="literal">CREATE INDEX</code></a>:
                </p><p style="color:blue;">使用创建索引为单个索引设置合并阈值：</p><pre data-lang="sql" class="programlisting">CREATE TABLE t1 (id INT);
CREATE INDEX id_index ON t1 (id) COMMENT 'MERGE_THRESHOLD=40';
</pre></li></ul>
            </div>
            <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">
                <div class="admon-title">
                    Note
                </div>
                <p>
                    You cannot modify the <code class="literal">MERGE_THRESHOLD</code> value
                    at the index level for <code class="literal">GEN_CLUST_INDEX</code>, which
                    is the clustered index created by <code class="literal">InnoDB</code> when
                    an <code class="literal">InnoDB</code> table is created without a primary
                    key or unique key index. You can only modify the
                    <code class="literal">MERGE_THRESHOLD</code> value for
                    <code class="literal">GEN_CLUST_INDEX</code> by setting
                    <code class="literal">MERGE_THRESHOLD</code> for the table.
                </p><p style="color:blue;">不能在gen_clust_index的索引级别修改merge_阈值，gen_clust_index是在没有主键或唯一键索引的情况下创建innodb表时由innodb创建的聚集索引。只能通过设置表的merge_threshold来修改gen_clust_索引的merge_threshold值。</p>
            </div>
            <h4><a name="idm140286819160496"></a>Querying the MERGE_THRESHOLD Value for an Index</h4>
            <p>
                The current <code class="literal">MERGE_THRESHOLD</code> value for an index
                can be obtained by querying the
                <a class="link" href="information-schema.html#innodb-sys-indexes-table" title="24.32.21&nbsp;The INFORMATION_SCHEMA INNODB_SYS_INDEXES Table"><code class="literal">INNODB_SYS_INDEXES</code></a> table. For
                example:
            </p><p style="color:blue;">可以通过查询innodb_sys_indexes表获得索引的当前合并阈值。例如：</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT * FROM INFORMATION_SCHEMA.INNODB_SYS_INDEXES WHERE NAME='id_index' \G</code></strong>
*************************** 1. row ***************************
       INDEX_ID: 91
           NAME: id_index
       TABLE_ID: 68
           TYPE: 0
       N_FIELDS: 1
        PAGE_NO: 4
          SPACE: 57
MERGE_THRESHOLD: 40
</pre><p>
            You can use <a class="link" href="sql-syntax.html#show-create-table" title="13.7.5.10&nbsp;SHOW CREATE TABLE Syntax"><code class="literal">SHOW CREATE TABLE</code></a> to
            view the <code class="literal">MERGE_THRESHOLD</code> value for a table, if
            explicitly defined using the
            <em class="replaceable"><code>table_option</code></em> <code class="literal">COMMENT</code>
            clause:
        </p><p style="color:blue;">如果使用table_option comment子句显式定义，则可以使用show create table查看表的合并阈值：</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>SHOW CREATE TABLE t2 \G</code></strong>
*************************** 1. row ***************************
       Table: t2
Create Table: CREATE TABLE `t2` (
  `id` int(11) DEFAULT NULL,
  KEY `id_index` (`id`) COMMENT 'MERGE_THRESHOLD=40'
) ENGINE=InnoDB DEFAULT CHARSET=latin1
</pre>
            <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">

                <div class="admon-title">
                    Note
                </div>
                <p>
                    A <code class="literal">MERGE_THRESHOLD</code> value defined at the index
                    level takes priority over a <code class="literal">MERGE_THRESHOLD</code>
                    value defined for the table. If undefined,
                    <code class="literal">MERGE_THRESHOLD</code> defaults to 50%
                    (<code class="literal">MERGE_THRESHOLD=50</code>, which is the previously
                    hardcoded value.
                </p><p style="color:blue;">在索引级别定义的合并阈值优先于为表定义的合并阈值。如果未定义，则merge_threshold默认为50%（merge_threshold=50，这是以前硬编码的值）。</p>
            </div>
            <p>
                Likewise, you can use <a class="link" href="sql-syntax.html#show-index" title="13.7.5.22&nbsp;SHOW INDEX Syntax"><code class="literal">SHOW INDEX</code></a> to
                view the <code class="literal">MERGE_THRESHOLD</code> value for an index, if
                explicitly defined using the
                <em class="replaceable"><code>index_option</code></em> <code class="literal">COMMENT</code>
                clause:
            </p><p style="color:blue;">同样，如果使用index_option comment子句显式定义，则可以使用show index查看索引的合并阈值：</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>SHOW INDEX FROM t2 \G</code></strong>
*************************** 1. row ***************************
        Table: t2
   Non_unique: 1
     Key_name: id_index
 Seq_in_index: 1
  Column_name: id
    Collation: A
  Cardinality: 0
     Sub_part: NULL
       Packed: NULL
         Null: YES
   Index_type: BTREE
      Comment:
Index_comment: MERGE_THRESHOLD=40
</pre>
            <h4><a name="idm140286819140576"></a>Measuring the Effect of MERGE_THRESHOLD Settings</h4>
            <p>
                The <a class="link" href="information-schema.html#innodb-metrics-table" title="24.32.15&nbsp;The INFORMATION_SCHEMA INNODB_METRICS Table"><code class="literal">INNODB_METRICS</code></a> table provides two
                counters that can be used to measure the effect of a
                <code class="literal">MERGE_THRESHOLD</code> setting on index page merges.
            </p><p style="color:blue;">innodb_metrics表提供了两个计数器，可用于测量merge_threshold设置对索引页合并的影响。</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT NAME, COMMENT FROM INFORMATION_SCHEMA.INNODB_METRICS</code></strong>
       <strong class="userinput"><code>WHERE NAME like '%index_page_merge%';</code></strong>
+-----------------------------+----------------------------------------+
| NAME                        | COMMENT                                |
+-----------------------------+----------------------------------------+
| index_page_merge_attempts   | Number of index page merge attempts    |
| index_page_merge_successful | Number of successful index page merges |
+-----------------------------+----------------------------------------+
</pre><p>
            When lowering the <code class="literal">MERGE_THRESHOLD</code> value, the
            objectives are:
        </p><p style="color:blue;">降低合并阈值时，目标是：</p>
            <div class="itemizedlist">
                <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                    A smaller number of page merge attempts and successful page
                    merges
                </p><p style="color:blue;">较少的页面合并尝试次数和成功的页面合并次数</p></li><li class="listitem"><p>
                    A similar number of page merge attempts and successful page
                    merges
                </p><p style="color:blue;">相同数量的页面合并尝试和成功的页面合并</p></li></ul>
            </div>
            <p>
                A <code class="literal">MERGE_THRESHOLD</code> setting that is too small
                could result in large data files due to an excessive amount of
                empty page space.
            </p><p style="color:blue;">太小的合并阈值设置可能会由于页面空间过大而导致数据文件过大。</p><p>
            For information about using
            <a class="link" href="information-schema.html#innodb-metrics-table" title="24.32.15&nbsp;The INFORMATION_SCHEMA INNODB_METRICS Table"><code class="literal">INNODB_METRICS</code></a> counters, see
            <a class="xref" href="innodb-storage-engine.html#innodb-information-schema-metrics-table" title="14.15.6&nbsp;InnoDB INFORMATION_SCHEMA Metrics Table">Section&nbsp;14.15.6, “InnoDB INFORMATION_SCHEMA Metrics Table”</a>.
        </p><p style="color:blue;">有关使用innodb_metrics计数器的信息，请参阅第14.15.6节“innodb information_schema metrics table”。</p>
        </div>

    </div>
    <div class="section">
        <div class="titlepage">
            <div>
                <div>
                    <h2 class="title" style="clear: both"><a name="innodb-compression"></a>14.9&nbsp;InnoDB Table and Page Compression</h2>

                </div>

            </div>

        </div>
        <div class="toc">
            <dl class="toc"><dt><span class="section"><a href="innodb-storage-engine.html#innodb-table-compression">14.9.1 InnoDB Table Compression</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-page-compression">14.9.2 InnoDB Page Compression</a></span></dt></dl>
        </div>
        <a class="indexterm" name="idm140286819126208"></a><a class="indexterm" name="idm140286819125168"></a><p>
        This section provides information about the
        <code class="literal">InnoDB</code> table compression and
        <code class="literal">InnoDB</code> page compression features. The page
        compression feature is referred to as
        <a class="link" href="glossary.html#glos_transparent_page_compression" title="transparent page compression">transparent page
            compression</a>.
    </p><p style="color:blue;">本节提供有关innodb表压缩和innodb页压缩特性的信息。页面压缩功能称为透明页面压缩。</p><p>
        Using the compression features of <code class="literal">InnoDB</code>, you can
        create tables where the data is stored in compressed form.
        Compression can help to improve both raw performance and
        scalability. The compression means less data is transferred between
        disk and memory, and takes up less space on disk and in memory. The
        benefits are amplified for tables with
        <a class="link" href="glossary.html#glos_secondary_index" title="secondary index">secondary indexes</a>,
        because index data is compressed also. Compression can be especially
        important for <a class="link" href="glossary.html#glos_ssd" title="SSD">SSD</a> storage devices,
        because they tend to have lower capacity than
        <a class="link" href="glossary.html#glos_hdd" title="HDD">HDD</a> devices.
    </p><p style="color:blue;">使用innodb的压缩特性，可以创建以压缩形式存储数据的表。压缩可以帮助提高原始性能和可伸缩性。压缩意味着更少的数据在磁盘和内存之间传输，占用更少的磁盘和内存空间。因为索引数据也被压缩，所以对于具有二级索引的表，好处就更大了。压缩对于ssd存储设备尤其重要，因为它们的容量往往低于hdd设备。</p>
        <div class="section">

            <div class="titlepage">
                <div>
                    <div>
                        <h3 class="title"><a name="innodb-table-compression"></a>14.9.1&nbsp;InnoDB Table Compression</h3>

                    </div>

                </div>

            </div>

            <div class="toc">
                <dl class="toc"><dt><span class="section"><a href="innodb-storage-engine.html#innodb-compression-background">14.9.1.1 Overview of Table Compression</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-compression-usage">14.9.1.2 Creating Compressed Tables</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-compression-tuning">14.9.1.3 Tuning Compression for InnoDB Tables</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-compression-tuning-monitoring">14.9.1.4 Monitoring InnoDB Table Compression at Runtime</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-compression-internals">14.9.1.5 How Compression Works for InnoDB Tables</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-performance-compression-oltp">14.9.1.6 Compression for OLTP Workloads</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-compression-syntax-warnings">14.9.1.7 SQL Compression Syntax Warnings and Errors</a></span></dt></dl>
            </div>
            <p>
                This section describes <code class="literal">InnoDB</code> table
                compression, which is supported with <code class="literal">InnoDB</code>
                tables that reside in
                <a class="link" href="glossary.html#glos_file_per_table" title="file-per-table">file_per_table</a>
                tablespaces or <a class="link" href="glossary.html#glos_general_tablespace" title="general tablespace">general
                tablespaces</a>. Table compression is enabled using the
                <code class="literal">ROW_FORMAT=COMPRESSED</code> attribute with
                <a class="link" href="sql-syntax.html#create-table" title="13.1.18&nbsp;CREATE TABLE Syntax"><code class="literal">CREATE TABLE</code></a> or
                <a class="link" href="sql-syntax.html#alter-table" title="13.1.8&nbsp;ALTER TABLE Syntax"><code class="literal">ALTER TABLE</code></a>.
            </p><p style="color:blue;">本节介绍InnoDB表压缩，它受位于文件/表空间或常规表空间中的InnoDB表支持。使用带有create table或alter table的row_format=compressed属性启用表压缩。</p>
            <div class="section">

                <div class="titlepage">
                    <div>
                        <div>
                            <h4 class="title"><a name="innodb-compression-background"></a>14.9.1.1&nbsp;Overview of Table Compression</h4>
                        </div>
                    </div>
                </div>
                <a class="indexterm" name="idm140286819107904"></a><p>
                Because processors and cache memories have increased in speed
                more than disk storage devices, many workloads are
                <a class="link" href="glossary.html#glos_disk_bound" title="disk-bound">disk-bound</a>. Data
                <a class="link" href="glossary.html#glos_compression" title="compression">compression</a> enables
                smaller database size, reduced I/O, and improved throughput, at
                the small cost of increased CPU utilization. Compression is
                especially valuable for read-intensive applications, on systems
                with enough RAM to keep frequently used data in memory.
            </p><p style="color:blue;">由于处理器和缓存的速度比磁盘存储设备快，许多工作负载都是磁盘绑定的。数据压缩以提高CPU利用率为代价，实现更小的数据库大小、减少I/O和提高吞吐量。压缩对于读密集型应用程序尤其有价值，在具有足够RAM以将常用数据保存在内存中的系统上。</p><p>
                An <code class="literal">InnoDB</code> table created with
                <code class="literal">ROW_FORMAT=COMPRESSED</code> can use a smaller
                <a class="link" href="glossary.html#glos_page_size" title="page size">page size</a> on disk than the
                configured <a class="link" href="innodb-storage-engine.html#sysvar_innodb_page_size"><code class="literal">innodb_page_size</code></a>
                value. Smaller pages require less I/O to read from and write to
                disk, which is especially valuable for
                <a class="link" href="glossary.html#glos_ssd" title="SSD">SSD</a> devices.
            </p><p style="color:blue;">使用row_format=compressed创建的innodb表可以在磁盘上使用比配置的innodb_page_size值更小的页面大小。较小的页面需要较少的I/O来读取和写入磁盘，这对于固态硬盘设备尤其有价值。</p><p>
                The compressed page size is specified through the
                <a class="link" href="sql-syntax.html#create-table" title="13.1.18&nbsp;CREATE TABLE Syntax"><code class="literal">CREATE TABLE</code></a> or
                <a class="link" href="sql-syntax.html#alter-table" title="13.1.8&nbsp;ALTER TABLE Syntax"><code class="literal">ALTER TABLE</code></a>
                <code class="literal">KEY_BLOCK_SIZE</code> parameter. The different page
                size requires that the table be placed in a
                <a class="link" href="glossary.html#glos_file_per_table" title="file-per-table">file-per-table</a>
                tablespace or <a class="link" href="glossary.html#glos_general_tablespace" title="general tablespace">general
                tablespace</a> rather than in the
                <a class="link" href="glossary.html#glos_system_tablespace" title="system tablespace">system tablespace</a>,
                as the system tablespace cannot store compressed tables. For
                more information, see
                <a class="xref" href="innodb-storage-engine.html#innodb-multiple-tablespaces" title="14.6.3.2&nbsp;File-Per-Table Tablespaces">Section&nbsp;14.6.3.2, “File-Per-Table Tablespaces”</a>, and
                <a class="xref" href="innodb-storage-engine.html#general-tablespaces" title="14.6.3.3&nbsp;General Tablespaces">Section&nbsp;14.6.3.3, “General Tablespaces”</a>.
            </p><p style="color:blue;">压缩页大小是通过create table或alter table key_block_size参数指定的。由于系统表空间无法存储压缩表，因此不同的页面大小要求将表放置在每个表空间或常规表空间的文件中，而不是系统表空间中。有关更多信息，请参阅14.6.3.2节“每表表空间文件”和14.6.3.3节“常规表空间”。</p><p>
                The level of compression is the same regardless of the
                <code class="literal">KEY_BLOCK_SIZE</code> value. As you specify smaller
                values for <code class="literal">KEY_BLOCK_SIZE</code>, you get the I/O
                benefits of increasingly smaller pages. But if you specify a
                value that is too small, there is additional overhead to
                reorganize the pages when data values cannot be compressed
                enough to fit multiple rows in each page. There is a hard limit
                on how small <code class="literal">KEY_BLOCK_SIZE</code> can be for a
                table, based on the lengths of the key columns for each of its
                indexes. Specify a value that is too small, and the
                <a class="link" href="sql-syntax.html#create-table" title="13.1.18&nbsp;CREATE TABLE Syntax"><code class="literal">CREATE TABLE</code></a> or
                <a class="link" href="sql-syntax.html#alter-table" title="13.1.8&nbsp;ALTER TABLE Syntax"><code class="literal">ALTER TABLE</code></a> statement fails.
            </p><p style="color:blue;">无论密钥块大小值如何，压缩级别都是相同的。当为键块大小指定较小的值时，可以获得越来越小的页的I/O好处。但是，如果指定的值太小，当数据值无法压缩到足以容纳每个页面中的多行时，会有额外的开销来重新组织页面。根据表中每个索引的键列长度，表的键块大小有一个硬限制。指定的值太小，CREATE TABLE或ALTER TABLE语句将失败。</p><p>
                In the buffer pool, the compressed data is held in small pages,
                with a page size based on the <code class="literal">KEY_BLOCK_SIZE</code>
                value. For extracting or updating the column values, MySQL also
                creates an uncompressed page in the buffer pool with the
                uncompressed data. Within the buffer pool, any updates to the
                uncompressed page are also re-written back to the equivalent
                compressed page. You might need to size your buffer pool to
                accommodate the additional data of both compressed and
                uncompressed pages, although the uncompressed pages are
                <a class="link" href="glossary.html#glos_eviction" title="eviction">evicted</a> from the buffer
                pool when space is needed, and then uncompressed again on the
                next access.
            </p><p style="color:blue;">在缓冲池中，压缩数据保存在小页面中，页面大小基于key_block_size值。为了提取或更新列值，mysql还使用未压缩的数据在缓冲池中创建未压缩的页。在缓冲池中，对未压缩页的任何更新也会重新写入到等效的压缩页中。您可能需要调整缓冲池的大小，以容纳压缩页和未压缩页的其他数据，尽管在需要空间时会将未压缩页从缓冲池中逐出，然后在下次访问时再次解压缩。</p>
            </div>
            <div class="section">
                <div class="titlepage">
                    <div>
                        <div>
                            <h4 class="title"><a name="innodb-compression-usage"></a>14.9.1.2&nbsp;Creating Compressed Tables</h4>

                        </div>

                    </div>

                </div>
                <a class="indexterm" name="idm140286819081680"></a><a class="indexterm" name="idm140286819080192"></a><a class="indexterm" name="idm140286819079120"></a><a class="indexterm" name="idm140286819077632"></a><a class="indexterm" name="idm140286819076144"></a><a class="indexterm" name="idm140286819074656"></a><a class="indexterm" name="idm140286819073584"></a><a class="indexterm" name="idm140286819072512"></a><p>
                Compressed tables can be created in
                <a class="link" href="glossary.html#glos_file_per_table" title="file-per-table">file-per-table</a>
                tablespaces or in
                <a class="link" href="glossary.html#glos_general_tablespace" title="general tablespace">general
                    tablespaces</a>. Table compression is not available for the
                InnoDB <a class="link" href="glossary.html#glos_system_tablespace" title="system tablespace">system
                tablespace</a>. The system tablespace (space 0, the
                <a class="link" href="glossary.html#glos_ibd_file" title=".ibd file">.ibdata files</a>) can contain
                user-created tables, but it also contains internal system data,
                which is never compressed. Thus, compression applies only to
                tables (and indexes) stored in file-per-table or general
                tablespaces.
            </p><p style="color:blue;">压缩表可以在每个表空间的文件中创建，也可以在一般表空间中创建。对于innodb系统表空间，表压缩不可用。系统表空间（空间0，.ibdata文件）可以包含用户创建的表，但也包含从不压缩的内部系统数据。因此，压缩仅适用于按表或常规表空间存储在文件中的表（和索引）。</p>
                <h5><a name="idm140286819066880"></a>Creating a Compressed Table in File-Per-Table Tablespace</h5>
                <p>
                    To create a compressed table in a file-per-table tablespace,
                    <a class="link" href="innodb-storage-engine.html#sysvar_innodb_file_per_table"><code class="literal">innodb_file_per_table</code></a> must be
                    enabled (the default in MySQL 5.6.6) and
                    <a class="link" href="innodb-storage-engine.html#sysvar_innodb_file_format"><code class="literal">innodb_file_format</code></a> must be set
                    to <code class="literal">Barracuda</code>. You can set these parameters in
                    the MySQL configuration file (<code class="filename">my.cnf</code> or
                    <code class="filename">my.ini</code>) or dynamically, using a
                    <a class="link" href="sql-syntax.html#set-variable" title="13.7.4.1&nbsp;SET Syntax for Variable Assignment"><code class="literal">SET</code></a>
                    statement.
                </p><p style="color:blue;">要在每个表空间的文件中创建压缩表，必须启用innodb_file_per_table（mysql 5.6.6中的默认值），并且innodb_file_format必须设置为barracuda。可以在mysql配置文件（my.cnf或my.ini）中设置这些参数，也可以使用set语句动态设置这些参数。</p><p>
                After the <a class="link" href="innodb-storage-engine.html#sysvar_innodb_file_per_table"><code class="literal">innodb_file_per_table</code></a>
                and <a class="link" href="innodb-storage-engine.html#sysvar_innodb_file_format"><code class="literal">innodb_file_format</code></a> options
                are configured, specify the
                <code class="literal">ROW_FORMAT=COMPRESSED</code> clause or
                <code class="literal">KEY_BLOCK_SIZE</code> clause, or both, in a
                <a class="link" href="sql-syntax.html#create-table" title="13.1.18&nbsp;CREATE TABLE Syntax"><code class="literal">CREATE TABLE</code></a> or
                <a class="link" href="sql-syntax.html#alter-table" title="13.1.8&nbsp;ALTER TABLE Syntax"><code class="literal">ALTER TABLE</code></a> statement to create a
                compressed table in a file-per-table tablespace.
            </p><p style="color:blue;">配置innodb_file_per_table和innodb_file_format选项后，在create table或alter table语句中指定row_format=compressed子句或key_block_size子句，或同时指定这两个子句，以在file per table表空间中创建压缩表。</p><p>
                For example, you might use the following statements:
            </p><p style="color:blue;">例如，可以使用以下语句：</p><pre data-lang="sql" class="programlisting">SET GLOBAL innodb_file_per_table=1;
SET GLOBAL innodb_file_format=Barracuda;
CREATE TABLE t1
 (c1 INT PRIMARY KEY)
 ROW_FORMAT=COMPRESSED
 KEY_BLOCK_SIZE=8;
</pre>
                <h5><a name="idm140286819051072"></a>Creating a Compressed Table in a General Tablespace</h5>
                <p>
                    To create a compressed table in a general tablespace,
                    <code class="literal">FILE_BLOCK_SIZE</code> must be defined for the
                    general tablespace, which is specified when the tablespace is
                    created. The <code class="literal">FILE_BLOCK_SIZE</code> value must be a
                    valid compressed page size in relation to the
                    <a class="link" href="innodb-storage-engine.html#sysvar_innodb_page_size"><code class="literal">innodb_page_size</code></a> value, and the
                    page size of the compressed table, defined by the
                    <a class="link" href="sql-syntax.html#create-table" title="13.1.18&nbsp;CREATE TABLE Syntax"><code class="literal">CREATE TABLE</code></a> or
                    <a class="link" href="sql-syntax.html#alter-table" title="13.1.8&nbsp;ALTER TABLE Syntax"><code class="literal">ALTER TABLE</code></a>
                    <code class="literal">KEY_BLOCK_SIZE</code> clause, must be equal to
                    <code class="literal">FILE_BLOCK_SIZE/1024</code>. For example, if
                    <a class="link" href="innodb-storage-engine.html#sysvar_innodb_page_size"><code class="literal">innodb_page_size=16384</code></a> and
                    <code class="literal">FILE_BLOCK_SIZE=8192</code>, the
                    <code class="literal">KEY_BLOCK_SIZE</code> of the table must be 8. For
                    more information, see <a class="xref" href="innodb-storage-engine.html#general-tablespaces" title="14.6.3.3&nbsp;General Tablespaces">Section&nbsp;14.6.3.3, “General Tablespaces”</a>.
                </p><p style="color:blue;">要在常规表空间中创建压缩表，必须为常规表空间定义文件块大小，该表空间在创建表空间时指定。file_block_size值必须是相对于innodb_page_size值的有效压缩页大小，并且由create table或alter table key_block_size子句定义的压缩表的页大小必须等于file_block_size/1024。例如，如果innodb_page_size=16384，file_block_size=8192，则表的key_block_size必须为8。有关更多信息，请参阅14.6.3.3节“常规表空间”。</p><p>
                The following example demonstrates creating a general tablespace
                and adding a compressed table. The example assumes a default
                <a class="link" href="innodb-storage-engine.html#sysvar_innodb_page_size"><code class="literal">innodb_page_size</code></a> of 16K. The
                <code class="literal">FILE_BLOCK_SIZE</code> of 8192 requires that the
                compressed table have a <code class="literal">KEY_BLOCK_SIZE</code> of 8.
            </p><p style="color:blue;">下面的示例演示如何创建常规表空间和添加压缩表。该示例假设innodb_page_的默认大小为16k。8192的file_block_大小要求压缩表的key_block_大小为8。</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>CREATE TABLESPACE `ts2` ADD DATAFILE 'ts2.ibd' FILE_BLOCK_SIZE = 8192 Engine=InnoDB;</code></strong>

mysql&gt; <strong class="userinput"><code>CREATE TABLE t4 (c1 INT PRIMARY KEY) TABLESPACE ts2 ROW_FORMAT=COMPRESSED KEY_BLOCK_SIZE=8;</code></strong>
</pre>
                <h5><a name="idm140286819033920"></a>Notes</h5>
                <div class="itemizedlist">
                    <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                        If you specify <code class="literal">ROW_FORMAT=COMPRESSED</code>, you
                        can omit <code class="literal">KEY_BLOCK_SIZE</code>; the
                        <code class="literal">KEY_BLOCK_SIZE</code> setting defaults to half
                        the <a class="link" href="innodb-storage-engine.html#sysvar_innodb_page_size"><code class="literal">innodb_page_size</code></a> value.
                    </p><p style="color:blue;">如果指定row_format=compressed，可以省略key_block_size；key_block_size设置默认为innodb_page_size值的一半。</p></li><li class="listitem"><p>
                        If you specify a valid <code class="literal">KEY_BLOCK_SIZE</code>
                        value, you can omit
                        <code class="literal">ROW_FORMAT=COMPRESSED</code>; compression is
                        enabled automatically.
                    </p><p style="color:blue;">如果指定了有效的key_block_size值，则可以忽略row_format=compressed；压缩将自动启用。</p></li><li class="listitem"><p>
                        To determine the best value for
                        <code class="literal">KEY_BLOCK_SIZE,</code> typically you create
                        several copies of the same table with different values for
                        this clause, then measure the size of the resulting
                        <code class="filename">.ibd</code> files and see how well each
                        performs with a realistic
                        <a class="link" href="glossary.html#glos_workload" title="workload">workload</a>. For general
                        tablespaces, keep in mind that dropping a table does not
                        reduce the size of the general tablespace
                        <code class="filename">.ibd</code> file, nor does it return disk
                        space to the operating system. For more information, see
                        <a class="xref" href="innodb-storage-engine.html#general-tablespaces" title="14.6.3.3&nbsp;General Tablespaces">Section&nbsp;14.6.3.3, “General Tablespaces”</a>.
                    </p><p style="color:blue;">要确定key_block_size的最佳值，通常要为此子句创建具有不同值的同一表的多个副本，然后测量生成的.ibd文件的大小，并查看每个副本在实际工作负载下的性能如何。对于常规表空间，请记住删除表不会减小常规表空间.ibd文件的大小，也不会将磁盘空间返回给操作系统。有关更多信息，请参阅14.6.3.3节“常规表空间”。</p></li><li class="listitem"><p>
                        The <code class="literal">KEY_BLOCK_SIZE</code> value is treated as a
                        hint; a different size could be used by
                        <code class="literal">InnoDB</code> if necessary. For file-per-table
                        tablespaces, the <code class="literal">KEY_BLOCK_SIZE</code> can only
                        be less than or equal to the
                        <a class="link" href="innodb-storage-engine.html#sysvar_innodb_page_size"><code class="literal">innodb_page_size</code></a> value. If
                        you specify a value greater than the
                        <a class="link" href="innodb-storage-engine.html#sysvar_innodb_page_size"><code class="literal">innodb_page_size</code></a> value, the
                        specified value is ignored, a warning is issued, and
                        <code class="literal">KEY_BLOCK_SIZE</code> is set to half of the
                        <a class="link" href="innodb-storage-engine.html#sysvar_innodb_page_size"><code class="literal">innodb_page_size</code></a> value. If
                        <code class="literal">innodb_strict_mode=ON</code>, specifying an
                        invalid <code class="literal">KEY_BLOCK_SIZE</code> value returns an
                        error. For general tablespaces, valid
                        <code class="literal">KEY_BLOCK_SIZE</code> values depend on the
                        <code class="literal">FILE_BLOCK_SIZE</code> setting of the
                        tablespace. For more information, see
                        <a class="xref" href="innodb-storage-engine.html#general-tablespaces" title="14.6.3.3&nbsp;General Tablespaces">Section&nbsp;14.6.3.3, “General Tablespaces”</a>.
                    </p><p style="color:blue;">key_block_size值被视为提示；如果需要，innodb可以使用不同的大小。对于每个表表空间的文件，key_block_size只能小于或等于innodb_page_size值。如果指定的值大于innodb_page_size值，则忽略指定的值，发出警告，并将key_block_size设置为innodb_page_size值的一半。如果innodb_strict_mode=on，指定无效的key_block_size值将返回错误。对于常规表空间，有效的键块大小值取决于表空间的文件块大小设置。有关更多信息，请参阅14.6.3.3节“常规表空间”。</p></li><li class="listitem"><p>
                        32KB and 64KB page sizes do not support compression. For
                        more information, refer to the
                        <a class="link" href="innodb-storage-engine.html#sysvar_innodb_page_size"><code class="literal">innodb_page_size</code></a>
                        documentation.
                    </p><p style="color:blue;">32KB和64KB页大小不支持压缩。有关更多信息，请参阅innodb_page_size文档。</p></li><li class="listitem"><p>
                        The default uncompressed size of <code class="literal">InnoDB</code>
                        data <a class="link" href="glossary.html#glos_page" title="page">pages</a> is 16KB.
                        Depending on the combination of option values, MySQL uses a
                        page size of 1KB, 2KB, 4KB, 8KB, or 16KB for the tablespace
                        data file (<code class="filename">.ibd</code> file). The actual
                        compression algorithm is not affected by the
                        <code class="literal">KEY_BLOCK_SIZE</code> value; the value
                        determines how large each compressed chunk is, which in turn
                        affects how many rows can be packed into each compressed
                        page.
                    </p><p style="color:blue;">InnoDB数据页的默认未压缩大小为16KB。根据选项值的组合，mysql对表空间数据文件（.ibd文件）使用1kb、2kb、4kb、8kb或16kb的页面大小。实际的压缩算法不受key_block_size值的影响；该值决定每个压缩块有多大，进而影响每个压缩页可以压缩多少行。</p></li><li class="listitem"><p>
                        When creating a compressed table in a file-per-table
                        tablespace, setting <code class="literal">KEY_BLOCK_SIZE</code> equal
                        to the <code class="literal">InnoDB</code>
                        <a class="link" href="glossary.html#glos_page_size" title="page size">page size</a> does not
                        typically result in much compression. For example, setting
                        <code class="literal">KEY_BLOCK_SIZE=16</code> typically would not
                        result in much compression, since the normal
                        <code class="literal">InnoDB</code> page size is 16KB. This setting
                        may still be useful for tables with many long
                        <a class="link" href="data-types.html#blob" title="11.4.3&nbsp;The BLOB and TEXT Types"><code class="literal">BLOB</code></a>,
                        <a class="link" href="data-types.html#char" title="11.4.1&nbsp;The CHAR and VARCHAR Types"><code class="literal">VARCHAR</code></a> or
                        <a class="link" href="data-types.html#blob" title="11.4.3&nbsp;The BLOB and TEXT Types"><code class="literal">TEXT</code></a> columns, because such
                        values often do compress well, and might therefore require
                        fewer <a class="link" href="glossary.html#glos_overflow_page" title="overflow page">overflow
                        pages</a> as described in
                        <a class="xref" href="innodb-storage-engine.html#innodb-compression-internals" title="14.9.1.5&nbsp;How Compression Works for InnoDB Tables">Section&nbsp;14.9.1.5, “How Compression Works for InnoDB Tables”</a>. For general
                        tablespaces, a <code class="literal">KEY_BLOCK_SIZE</code> value equal
                        to the <code class="literal">InnoDB</code> page size is not permitted.
                        For more information, see
                        <a class="xref" href="innodb-storage-engine.html#general-tablespaces" title="14.6.3.3&nbsp;General Tablespaces">Section&nbsp;14.6.3.3, “General Tablespaces”</a>.
                    </p><p style="color:blue;">在每个表空间的文件中创建压缩表时，将key_block_size设置为innodb page size通常不会导致太大的压缩。例如，设置key_block_size=16通常不会导致太多压缩，因为正常的innodb页面大小是16kb。此设置对于具有许多长blob、varchar或文本列的表仍然有用，因为这些值通常压缩得很好，因此可能需要更少的溢出页，如14.9.1.5节“压缩对innodb表的工作方式”中所述。对于一般表空间，不允许使用等于innodb页面大小的key-block-size值。有关更多信息，请参阅14.6.3.3节“常规表空间”。</p></li><li class="listitem"><p>
                        All indexes of a table (including the
                        <a class="link" href="glossary.html#glos_clustered_index" title="clustered index">clustered index</a>)
                        are compressed using the same page size, as specified in the
                        <code class="literal">CREATE TABLE</code> or <code class="literal">ALTER
                        TABLE</code> statement. Table attributes such as
                        <code class="literal">ROW_FORMAT</code> and
                        <code class="literal">KEY_BLOCK_SIZE</code> are not part of the
                        <code class="literal">CREATE INDEX</code> syntax for
                        <code class="literal">InnoDB</code> tables, and are ignored if they
                        are specified (although, if specified, they will appear in
                        the output of the <a class="link" href="sql-syntax.html#show-create-table" title="13.7.5.10&nbsp;SHOW CREATE TABLE Syntax"><code class="literal">SHOW CREATE
                        TABLE</code></a> statement).
                    </p><p style="color:blue;">表的所有索引（包括聚集索引）都使用create table或alter table语句中指定的相同页面大小进行压缩。row_format和key_block_size等表属性不是innodb表的create index语法的一部分，如果指定了它们，它们将被忽略（尽管如果指定了，它们将出现在show create table语句的输出中）。</p></li><li class="listitem"><p>
                        For performance-related configuration options, see
                        <a class="xref" href="innodb-storage-engine.html#innodb-compression-tuning" title="14.9.1.3&nbsp;Tuning Compression for InnoDB Tables">Section&nbsp;14.9.1.3, “Tuning Compression for InnoDB Tables”</a>.
                    </p><p style="color:blue;">有关性能相关的配置选项，请参阅14.9.1.3节，“调整innodb表的压缩”。</p></li></ul>
                </div>
                <h5><a name="idm140286818981504"></a>Restrictions on Compressed Tables</h5>
                <div class="itemizedlist">
                    <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                        MySQL versions prior to 5.1 cannot process compressed
                        tables.
                    </p><p style="color:blue;">5.1之前的MySQL版本无法处理压缩表。</p></li><li class="listitem"><p>
                        Compressed tables cannot be stored in the
                        <code class="literal">InnoDB</code> system tablespace.
                    </p><p style="color:blue;">压缩表不能存储在innodb系统表空间中。</p></li><li class="listitem"><p>
                        General tablespaces can contain multiple tables, but
                        compressed and uncompressed tables cannot coexist within the
                        same general tablespace.
                    </p><p style="color:blue;">一般表空间可以包含多个表，但压缩的和未压缩的表不能在同一个通用表空间中共存。</p></li><li class="listitem"><p>
                        Compression applies to an entire table and all its
                        associated indexes, not to individual rows, despite the
                        clause name <code class="literal">ROW_FORMAT</code>.
                    </p><p style="color:blue;">压缩应用于整个表及其所有关联索引，而不是单个行，尽管子句名为row_format。</p></li></ul>
                </div>

            </div>
            <div class="section">
                <div class="titlepage">
                    <div>
                        <div>
                            <h4 class="title"><a name="innodb-compression-tuning"></a>14.9.1.3&nbsp;Tuning Compression for InnoDB Tables</h4>

                        </div>

                    </div>

                </div>
                <a class="indexterm" name="idm140286818974064"></a><a class="indexterm" name="idm140286818972576"></a><p>
                Most often, the internal optimizations described in
                <a class="xref" href="innodb-storage-engine.html#innodb-compression-internals-storage" title="InnoDB Data Storage and Compression">InnoDB Data Storage and Compression</a> ensure
                that the system runs well with compressed data. However, because
                the efficiency of compression depends on the nature of your
                data, you can make decisions that affect the performance of
                compressed tables:
            </p><p style="color:blue;">通常，innodb数据存储和压缩中描述的内部优化可以确保系统在压缩数据下运行良好。但是，由于压缩效率取决于数据的性质，因此您可以做出影响压缩表性能的决策：</p>
                <div class="itemizedlist">
                    <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                        Which tables to compress.
                    </p><p style="color:blue;">要压缩哪些表。</p></li><li class="listitem"><p>
                        What compressed page size to use.
                    </p><p style="color:blue;">要使用的压缩页面大小。</p></li><li class="listitem"><p>
                        Whether to adjust the size of the buffer pool based on
                        run-time performance characteristics, such as the amount of
                        time the system spends compressing and uncompressing data.
                        Whether the workload is more like a
                        <a class="link" href="glossary.html#glos_data_warehouse" title="data warehouse">data warehouse</a>
                        (primarily queries) or an
                        <a class="link" href="glossary.html#glos_oltp" title="OLTP">OLTP</a> system (mix of queries
                        and <a class="link" href="glossary.html#glos_dml" title="DML">DML</a>).
                    </p><p style="color:blue;">是否根据运行时性能特征（如系统压缩和解压缩数据所花费的时间）调整缓冲池的大小。工作负载更像是数据仓库（主要是查询）还是oltp系统（查询和dml的混合）。</p></li><li class="listitem"><p>
                        If the system performs DML operations on compressed tables,
                        and the way the data is distributed leads to expensive
                        <a class="link" href="glossary.html#glos_compression_failure" title="compression failure">compression
                            failures</a> at runtime, you might adjust additional
                        advanced configuration options.
                    </p><p style="color:blue;">如果系统对压缩表执行dml操作，并且数据的分发方式导致运行时出现昂贵的压缩失败，则可以调整其他高级配置选项。</p></li></ul>
                </div>
                <p>
                    Use the guidelines in this section to help make those
                    architectural and configuration choices. When you are ready to
                    conduct long-term testing and put compressed tables into
                    production, see
                    <a class="xref" href="innodb-storage-engine.html#innodb-compression-tuning-monitoring" title="14.9.1.4&nbsp;Monitoring InnoDB Table Compression at Runtime">Section&nbsp;14.9.1.4, “Monitoring InnoDB Table Compression at Runtime”</a> for ways
                    to verify the effectiveness of those choices under real-world
                    conditions.
                </p><p style="color:blue;">使用本节中的指导原则帮助您做出架构和配置选择。当您准备好进行长期测试并将压缩表投入生产时，请参阅14.9.1.4节“在运行时监视innodb表压缩”，了解在实际情况下验证这些选择的有效性的方法。</p>
                <h5><a name="innodb-compression-tuning-when"></a>When to Use Compression</h5>
                <p>
                    In general, compression works best on tables that include a
                    reasonable number of character string columns and where the data
                    is read far more often than it is written. Because there are no
                    guaranteed ways to predict whether or not compression benefits a
                    particular situation, always test with a specific
                    <a class="link" href="glossary.html#glos_workload" title="workload">workload</a> and data set
                    running on a representative configuration. Consider the
                    following factors when deciding which tables to compress.
                </p><p style="color:blue;">一般来说，压缩最适用于包含合理数量的字符串列的表，并且在这些表中，数据的读取频率远远高于数据的写入频率。因为没有可靠的方法可以预测压缩是否有利于特定的情况，所以总是使用在代表性配置上运行的特定工作负载和数据集进行测试。在决定压缩哪些表时，请考虑以下因素。</p>
                <h5><a name="innodb-compression-tuning-when-data"></a>Data Characteristics and Compression</h5>
                <a class="indexterm" name="idm140286818955664"></a><p>
                A key determinant of the efficiency of compression in reducing
                the size of data files is the nature of the data itself. Recall
                that compression works by identifying repeated strings of bytes
                in a block of data. Completely randomized data is the worst
                case. Typical data often has repeated values, and so compresses
                effectively. Character strings often compress well, whether
                defined in <code class="literal">CHAR</code>, <code class="literal">VARCHAR</code>,
                <code class="literal">TEXT</code> or <code class="literal">BLOB</code> columns. On
                the other hand, tables containing mostly binary data (integers
                or floating point numbers) or data that is previously compressed
                (for example <acronym class="acronym">JPEG</acronym> or <acronym class="acronym">PNG</acronym>
                images) may not generally compress well, significantly or at
                all.
            </p><p style="color:blue;">压缩效率在减小数据文件大小方面的一个关键决定因素是数据本身的性质。回想一下，压缩是通过标识数据块中重复的字节字符串来工作的。完全随机的数据是最坏的情况。典型的数据通常具有重复的值，因此可以有效地压缩。不管是在char、varchar、text还是blob列中定义的，字符串通常压缩得很好。另一方面，大多数包含二进制数据（整数或浮点数）或以前压缩过的数据（例如jpeg或png图像）的表通常压缩得不好、不明显或根本压缩不好。</p><p>
                You choose whether to turn on compression for each InnoDB table.
                A table and all of its indexes use the same (compressed)
                <a class="link" href="glossary.html#glos_page_size" title="page size">page size</a>. It might be
                that the <a class="link" href="glossary.html#glos_primary_key" title="primary key">primary key</a>
                (clustered) index, which contains the data for all columns of a
                table, compresses more effectively than the secondary indexes.
                For those cases where there are long rows, the use of
                compression might result in long column values being stored
                <span class="quote">“<span class="quote">off-page</span>”</span>, as discussed in
                <a class="xref" href="innodb-storage-engine.html#innodb-row-format-dynamic" title="DYNAMIC Row Format">DYNAMIC Row Format</a>. Those overflow
                pages may compress well. Given these considerations, for many
                applications, some tables compress more effectively than others,
                and you might find that your workload performs best only with a
                subset of tables compressed.
            </p><p style="color:blue;">您可以选择是否为每个innodb表打开压缩。表及其所有索引使用相同的（压缩的）页面大小。可能是主键（聚集）索引（包含表中所有列的数据）比辅助索引压缩得更有效。对于那些有长行的情况，使用压缩可能会导致长列值存储在“页外”，如动态行格式中所述。这些溢出页可以很好地压缩。考虑到这些因素，对于许多应用程序，某些表的压缩比其他表更有效，您可能会发现，只有压缩了一个子集的表，您的工作负载才能发挥最佳性能。</p><p>
                To determine whether or not to compress a particular table,
                conduct experiments. You can get a rough estimate of how
                efficiently your data can be compressed by using a utility that
                implements LZ77 compression (such as <code class="literal">gzip</code> or
                WinZip) on a copy of the <a class="link" href="glossary.html#glos_ibd_file" title=".ibd file">.ibd
                file</a> for an uncompressed table. You can expect less
                compression from a MySQL compressed table than from file-based
                compression tools, because MySQL compresses data in chunks based
                on the <a class="link" href="glossary.html#glos_page_size" title="page size">page size</a>, 16KB by
                default. In addition to user data, the page format includes some
                internal system data that is not compressed. File-based
                compression utilities can examine much larger chunks of data,
                and so might find more repeated strings in a huge file than
                MySQL can find in an individual page.
            </p><p style="color:blue;">要确定是否压缩特定表，请执行实验。通过使用一个在未压缩表的.ibd文件副本上实现lz77压缩（如gzip或winzip）的实用程序，可以粗略估计数据的压缩效率。与基于文件的压缩工具相比，mysql压缩表的压缩要少一些，因为mysql会根据页面大小（默认为16kb）将数据压缩成块。除了用户数据之外，页面格式还包括一些未压缩的内部系统数据。基于文件的压缩实用程序可以检查更大的数据块，因此可能会在一个大文件中找到比mysql在单个页面中找到的更多重复字符串。</p><p>
                Another way to test compression on a specific table is to copy
                some data from your uncompressed table to a similar, compressed
                table (having all the same indexes) in a
                <a class="link" href="glossary.html#glos_file_per_table" title="file-per-table">file-per-table</a>
                tablespace and look at the size of the resulting
                <code class="literal">.ibd</code> file. For example:
            </p><p style="color:blue;">在特定表上测试压缩的另一种方法是将未压缩表中的某些数据复制到每个表空间的文件中的类似压缩表（具有所有相同的索引）中，并查看生成的.ibd文件的大小。例如：</p><pre data-lang="sql" class="programlisting">USE test;
SET GLOBAL innodb_file_per_table=1;
SET GLOBAL innodb_file_format=Barracuda;
SET GLOBAL autocommit=0;

-- Create an uncompressed table with a million or two rows.
CREATE TABLE big_table AS SELECT * FROM information_schema.columns;
INSERT INTO big_table SELECT * FROM big_table;
INSERT INTO big_table SELECT * FROM big_table;
INSERT INTO big_table SELECT * FROM big_table;
INSERT INTO big_table SELECT * FROM big_table;
INSERT INTO big_table SELECT * FROM big_table;
INSERT INTO big_table SELECT * FROM big_table;
INSERT INTO big_table SELECT * FROM big_table;
INSERT INTO big_table SELECT * FROM big_table;
INSERT INTO big_table SELECT * FROM big_table;
INSERT INTO big_table SELECT * FROM big_table;
COMMIT;
ALTER TABLE big_table ADD id int unsigned NOT NULL PRIMARY KEY auto_increment;

SHOW CREATE TABLE big_table\G

select count(id) from big_table;

-- Check how much space is needed for the uncompressed table.
\! ls -l data/test/big_table.ibd

CREATE TABLE key_block_size_4 LIKE big_table;
ALTER TABLE key_block_size_4 key_block_size=4 row_format=compressed;

INSERT INTO key_block_size_4 SELECT * FROM big_table;
commit;

-- Check how much space is needed for a compressed table
-- with particular compression settings.
\! ls -l data/test/key_block_size_4.ibd
</pre><p>
                This experiment produced the following numbers, which of course
                could vary considerably depending on your table structure and
                data:
            </p><p style="color:blue;">这个实验产生了以下数字，当然，这些数字可能因表结构和数据的不同而有很大差异：</p><pre data-lang="terminal" class="programlisting">-rw-rw----  1 cirrus  staff  310378496 Jan  9 13:44 data/test/big_table.ibd
-rw-rw----  1 cirrus  staff  83886080 Jan  9 15:10 data/test/key_block_size_4.ibd
</pre><p>
                To see whether compression is efficient for your particular
                <a class="link" href="glossary.html#glos_workload" title="workload">workload</a>:
            </p><p style="color:blue;">要查看压缩是否对特定工作负载有效，请执行以下操作：</p>
                <div class="itemizedlist">
                    <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                        For simple tests, use a MySQL instance with no other
                        compressed tables and run queries against the
                        <a class="link" href="information-schema.html#innodb-cmp-table" title="24.32.4&nbsp;The INFORMATION_SCHEMA INNODB_CMP and INNODB_CMP_RESET Tables"><code class="literal">INFORMATION_SCHEMA.INNODB_CMP</code></a>
                        table.
                    </p><p style="color:blue;">对于简单的测试，使用没有其他压缩表的mysql实例，并对information schema.innodb_cmp表运行查询。</p></li><li class="listitem"><p>
                        For more elaborate tests involving workloads with multiple
                        compressed tables, run queries against the
                        <a class="link" href="information-schema.html#innodb-cmp-per-index-table" title="24.32.6&nbsp;The INFORMATION_SCHEMA INNODB_CMP_PER_INDEX and INNODB_CMP_PER_INDEX_RESET Tables"><code class="literal">INFORMATION_SCHEMA.INNODB_CMP_PER_INDEX</code></a>
                        table. Because the statistics in the
                        <code class="literal">INNODB_CMP_PER_INDEX</code> table are expensive
                        to collect, you must enable the configuration option
                        <a class="link" href="innodb-storage-engine.html#sysvar_innodb_cmp_per_index_enabled"><code class="literal">innodb_cmp_per_index_enabled</code></a>
                        before querying that table, and you might restrict such
                        testing to a development server or a non-critical
                        <a class="link" href="glossary.html#glos_slave_server" title="slave server">slave server</a>.
                    </p><p style="color:blue;">有关涉及多个压缩表的工作负载的更详细的测试，请对information_schema.innodb_cmp_per_索引表运行查询。由于innodb_cmp_per_index表中的统计信息的收集成本很高，因此在查询该表之前，必须启用配置选项innodb_cmp_per_index_enabled，并且您可能将此类测试限制为开发服务器或非关键从属服务器。</p></li><li class="listitem"><p>
                        Run some typical SQL statements against the compressed table
                        you are testing.
                    </p><p style="color:blue;">对正在测试的压缩表运行一些典型的sql语句。</p></li><li class="listitem"><p>
                        Examine the ratio of successful compression operations to
                        overall compression operations by querying the
                        <a class="link" href="information-schema.html#innodb-cmp-table" title="24.32.4&nbsp;The INFORMATION_SCHEMA INNODB_CMP and INNODB_CMP_RESET Tables"><code class="literal">INFORMATION_SCHEMA.INNODB_CMP</code></a>
                        or
                        <a class="link" href="information-schema.html#innodb-cmp-per-index-table" title="24.32.6&nbsp;The INFORMATION_SCHEMA INNODB_CMP_PER_INDEX and INNODB_CMP_PER_INDEX_RESET Tables"><code class="literal">INFORMATION_SCHEMA.INNODB_CMP_PER_INDEX</code></a>
                        table, and comparing <code class="literal">COMPRESS_OPS</code> to
                        <code class="literal">COMPRESS_OPS_OK</code>.
                    </p><p style="color:blue;">通过查询information_schema.innodb_cmp或information_schema.innodb_cmp_per_索引表，并将compress_ops与compress_ops_ok进行比较，检查成功压缩操作与总压缩操作的比率。</p></li><li class="listitem"><p>
                        If a high percentage of compression operations complete
                        successfully, the table might be a good candidate for
                        compression.
                    </p><p style="color:blue;">如果压缩操作成功完成的百分比很高，则该表可能是压缩的最佳候选表。</p></li><li class="listitem"><p>
                        If you get a high proportion of
                        <a class="link" href="glossary.html#glos_compression_failure" title="compression failure">compression
                            failures</a>, you can adjust
                        <a class="link" href="innodb-storage-engine.html#sysvar_innodb_compression_level"><code class="literal">innodb_compression_level</code></a>,
                        <a class="link" href="innodb-storage-engine.html#sysvar_innodb_compression_failure_threshold_pct"><code class="literal">innodb_compression_failure_threshold_pct</code></a>,
                        and
                        <a class="link" href="innodb-storage-engine.html#sysvar_innodb_compression_pad_pct_max"><code class="literal">innodb_compression_pad_pct_max</code></a>
                        options as described in
                        <a class="xref" href="innodb-storage-engine.html#innodb-performance-compression-oltp" title="14.9.1.6&nbsp;Compression for OLTP Workloads">Section&nbsp;14.9.1.6, “Compression for OLTP Workloads”</a>, and
                        try further tests.
                    </p><p style="color:blue;">如果压缩失败的比例很高，可以调整innodb_compression_level、innodb_compression_failure_threshold_pct和innodb_compression_pad_pct_max选项，如第14.9.1.6节“oltp工作负载的压缩”所述，并尝试进一步测试。</p></li></ul>
                </div>
                <h5><a name="innodb-compression-application"></a>Database Compression versus Application Compression</h5>
                <a class="indexterm" name="idm140286818909872"></a><p>
                Decide whether to compress data in your application or in the
                table; do not use both types of compression for the same data.
                When you compress the data in the application and store the
                results in a compressed table, extra space savings are extremely
                unlikely, and the double compression just wastes CPU cycles.
            </p><p style="color:blue;">决定是压缩应用程序中的数据还是压缩表中的数据；不要对同一数据同时使用这两种类型的压缩。当您压缩应用程序中的数据并将结果存储在压缩表中时，不太可能节省额外的空间，而双重压缩只会浪费CPU周期。</p>
                <h5><a name="innodb-compression-in-database"></a>Compressing in the Database</h5>
                <p>
                    When enabled, MySQL table compression is automatic and applies
                    to all columns and index values. The columns can still be tested
                    with operators such as <code class="literal">LIKE</code>, and sort
                    operations can still use indexes even when the index values are
                    compressed. Because indexes are often a significant fraction of
                    the total size of a database, compression could result in
                    significant savings in storage, I/O or processor time. The
                    compression and decompression operations happen on the database
                    server, which likely is a powerful system that is sized to
                    handle the expected load.
                </p><p style="color:blue;">启用时，mysql表压缩是自动的，适用于所有列和索引值。列仍然可以使用类似的运算符进行测试，排序操作仍然可以使用索引，即使在压缩索引值时也是如此。由于索引通常占数据库总大小的很大一部分，因此压缩可以显著节省存储、I/O或处理器时间。压缩和解压缩操作发生在数据库服务器上，这可能是一个功能强大的系统，其大小足以处理预期的负载。</p>
                <h5><a name="innodb-compression-in-application"></a>Compressing in the Application</h5>
                <p>
                    If you compress data such as text in your application, before it
                    is inserted into the database, You might save overhead for data
                    that does not compress well by compressing some columns and not
                    others. This approach uses CPU cycles for compression and
                    uncompression on the client machine rather than the database
                    server, which might be appropriate for a distributed application
                    with many clients, or where the client machine has spare CPU
                    cycles.
                </p><p style="color:blue;">如果压缩应用程序中的文本等数据，在将其插入数据库之前，可以通过压缩某些列而不是其他列来节省压缩不好的数据的开销。这种方法使用cpu周期在客户机上而不是数据库服务器上进行压缩和解压缩，这可能适用于具有许多客户机的分布式应用程序，或者客户机有空闲cpu周期的情况。</p>
                <h5><a name="innodb-compression-hybrid"></a>Hybrid Approach</h5>
                <p>
                    Of course, it is possible to combine these approaches. For some
                    applications, it may be appropriate to use some compressed
                    tables and some uncompressed tables. It may be best to
                    externally compress some data (and store it in uncompressed
                    tables) and allow MySQL to compress (some of) the other tables
                    in the application. As always, up-front design and real-life
                    testing are valuable in reaching the right decision.
                </p><p style="color:blue;">当然，可以将这些方法结合起来。对于某些应用程序，可以使用一些压缩表和一些未压缩表。最好在外部压缩一些数据（并将其存储在未压缩的表中），并允许mysql压缩应用程序中的其他表。与以往一样，前期设计和实际测试对于做出正确的决策很有价值。</p>
                <h5><a name="innodb-compression-tuning-when-workload"></a>Workload Characteristics and Compression</h5>
                <a class="indexterm" name="idm140286818899216"></a><p>
                In addition to choosing which tables to compress (and the page
                size), the workload is another key determinant of performance.
                If the application is dominated by reads, rather than updates,
                fewer pages need to be reorganized and recompressed after the
                index page runs out of room for the per-page <span class="quote">“<span class="quote">modification
        log</span>”</span> that MySQL maintains for compressed data. If the
                updates predominantly change non-indexed columns or those
                containing <code class="literal">BLOB</code>s or large strings that happen
                to be stored <span class="quote">“<span class="quote">off-page</span>”</span>, the overhead of
                compression may be acceptable. If the only changes to a table
                are <code class="literal">INSERT</code>s that use a monotonically
                increasing primary key, and there are few secondary indexes,
                there is little need to reorganize and recompress index pages.
                Since MySQL can <span class="quote">“<span class="quote">delete-mark</span>”</span> and delete rows on
                compressed pages <span class="quote">“<span class="quote">in place</span>”</span> by modifying
                uncompressed data, <code class="literal">DELETE</code> operations on a
                table are relatively efficient.
            </p><p style="color:blue;">除了选择要压缩的表（和页面大小）之外，工作负载也是性能的另一个关键决定因素。如果应用程序主要是读取而不是更新，那么在索引页没有空间容纳mysql为压缩数据维护的每页“修改日志”之后，需要重新组织和重新压缩的页面就更少了。如果更新主要更改了非索引列或包含blob或碰巧存储在“页外”的大字符串的列，则压缩开销可能是可以接受的。如果对表的唯一更改是使用单调递增主键的插入，并且很少有辅助索引，则无需重新组织和重新压缩索引页。由于mysql可以通过修改未压缩的数据“就地”删除压缩页面上的标记和行，因此表上的删除操作相对高效。</p><p>
                For some environments, the time it takes to load data can be as
                important as run-time retrieval. Especially in data warehouse
                environments, many tables may be read-only or read-mostly. In
                those cases, it might or might not be acceptable to pay the
                price of compression in terms of increased load time, unless the
                resulting savings in fewer disk reads or in storage cost is
                significant.
            </p><p style="color:blue;">对于某些环境，加载数据所需的时间与运行时检索一样重要。特别是在数据仓库环境中，许多表可能是只读的，也可能是只读的。在这些情况下，以增加的加载时间来支付压缩的代价可能是可以接受的，也可能是不可以接受的，除非在减少磁盘读取或存储成本方面所带来的节约是显著的。</p><p>
                Fundamentally, compression works best when the CPU time is
                available for compressing and uncompressing data. Thus, if your
                workload is I/O bound, rather than CPU-bound, you might find
                that compression can improve overall performance. When you test
                your application performance with different compression
                configurations, test on a platform similar to the planned
                configuration of the production system.
            </p><p style="color:blue;">从根本上说，当CPU时间可用于压缩和解压缩数据时，压缩效果最佳。因此，如果您的工作负载是I/O绑定的，而不是CPU绑定的，您可能会发现压缩可以提高总体性能。使用不同的压缩配置测试应用程序性能时，请在与生产系统的计划配置类似的平台上进行测试。</p>
                <h5><a name="innodb-compression-tuning-when-config"></a>Configuration Characteristics and Compression</h5>
                <a class="indexterm" name="idm140286818889520"></a><p>
                Reading and writing database
                <a class="link" href="glossary.html#glos_page" title="page">pages</a> from and to disk is the
                slowest aspect of system performance. Compression attempts to
                reduce I/O by using CPU time to compress and uncompress data,
                and is most effective when I/O is a relatively scarce resource
                compared to processor cycles.
            </p><p style="color:blue;">从磁盘读取和写入数据库页是系统性能最慢的方面。压缩试图通过使用cpu时间压缩和解压缩数据来减少i/o，并且当i/o与处理器周期相比是相对稀缺的资源时，压缩最有效。</p><p>
                This is often especially the case when running in a multi-user
                environment with fast, multi-core CPUs. When a page of a
                compressed table is in memory, MySQL often uses additional
                memory, typically 16KB, in the
                <a class="link" href="glossary.html#glos_buffer_pool" title="buffer pool">buffer pool</a> for an
                uncompressed copy of the page. The adaptive LRU algorithm
                attempts to balance the use of memory between compressed and
                uncompressed pages to take into account whether the workload is
                running in an I/O-bound or CPU-bound manner. Still, a
                configuration with more memory dedicated to the buffer pool
                tends to run better when using compressed tables than a
                configuration where memory is highly constrained.
            </p><p style="color:blue;">尤其是在多用户环境中运行快速多核cpu时。当压缩表的一页在内存中时，mysql经常在缓冲池中使用额外的内存（通常为16kb）来存储该页的未压缩副本。自适应lru算法尝试在压缩页面和未压缩页面之间平衡内存的使用，以考虑工作负载是以i/o绑定方式运行还是以cpu绑定方式运行。不过，在使用压缩表时，专用于缓冲池的内存更多的配置往往比内存高度受限的配置运行得更好。</p>
                <h5><a name="innodb-compression-tuning-when-size"></a>Choosing the Compressed Page Size</h5>
                <a class="indexterm" name="idm140286818883328"></a><a class="indexterm" name="idm140286818881840"></a><a class="indexterm" name="idm140286818880352"></a><a class="indexterm" name="idm140286818878864"></a><p>
                The optimal setting of the compressed page size depends on the
                type and distribution of data that the table and its indexes
                contain. The compressed page size should always be bigger than
                the maximum record size, or operations may fail as noted in
                <a class="xref" href="innodb-storage-engine.html#innodb-compression-internals-storage-btree" title="Compression of B-Tree Pages">Compression of B-Tree Pages</a>.
            </p><p style="color:blue;">压缩页面大小的最佳设置取决于表及其索引包含的数据的类型和分布。压缩页大小应该总是大于最大记录大小，或者操作可能失败，如B-Trage页面的压缩所示。</p><p>
                Setting the compressed page size too large wastes some space,
                but the pages do not have to be compressed as often. If the
                compressed page size is set too small, inserts or updates may
                require time-consuming recompression, and the
                <a class="link" href="glossary.html#glos_b_tree" title="B-tree">B-tree</a> nodes may have to be
                split more frequently, leading to bigger data files and less
                efficient indexing.
            </p><p style="color:blue;">将压缩页面大小设置得太大会浪费一些空间，但不必经常压缩页面。如果压缩的页面大小设置得太小，插入或更新可能需要耗时的再压缩，并且B-树节点可能必须更频繁地分裂，从而导致更大的数据文件和较低效率的索引。</p><p>
                Typically, you set the compressed page size to 8K or 4K bytes.
                Given that the maximum row size for an InnoDB table is around
                8K, <code class="literal">KEY_BLOCK_SIZE=8</code> is usually a safe
                choice.
            </p><p style="color:blue;">通常，将压缩页面大小设置为8k或4k字节。假定UnIdB表的最大行大小在8K左右，KyiBuxBysiSmith= 8通常是一个安全的选择。</p>
            </div>
            <div class="section">
                <div class="titlepage">
                    <div>
                        <div>
                            <h4 class="title"><a name="innodb-compression-tuning-monitoring"></a>14.9.1.4&nbsp;Monitoring InnoDB Table Compression at Runtime</h4>

                        </div>

                    </div>

                </div>
                <a class="indexterm" name="idm140286818871920"></a><a class="indexterm" name="idm140286818870432"></a><p>
                Overall application performance, CPU and I/O utilization and the
                size of disk files are good indicators of how effective
                compression is for your application. This section builds on the
                performance tuning advice from
                <a class="xref" href="innodb-storage-engine.html#innodb-compression-tuning" title="14.9.1.3&nbsp;Tuning Compression for InnoDB Tables">Section&nbsp;14.9.1.3, “Tuning Compression for InnoDB Tables”</a>, and shows how to
                find problems that might not turn up during initial testing.
            </p><p style="color:blue;">总体应用程序性能、CPU和I/O利用率以及磁盘文件的大小都很好地指示了压缩对应用程序的有效性。本节以第14.9.1.3节“调整innodb表的压缩”中的性能调整建议为基础，并说明如何查找在初始测试期间可能不会出现的问题。</p><p>
                To dig deeper into performance considerations for compressed
                tables, you can monitor compression performance at runtime using
                the <a class="link" href="glossary.html#glos_information_schema" title="INFORMATION_SCHEMA">Information
                Schema</a> tables described in
                <a class="xref" href="innodb-storage-engine.html#innodb-information-schema-examples-compression" title="Example&nbsp;14.1&nbsp;Using the Compression Information Schema Tables">Example&nbsp;14.1, “Using the Compression Information Schema Tables”</a>.
                These tables reflect the internal use of memory and the rates of
                compression used overall.
            </p><p style="color:blue;">为了深入研究压缩表的性能考虑，可以使用示例14.1“使用压缩信息模式表”中描述的信息模式表在运行时监视压缩性能。这些表反映了内存的内部使用情况和总体使用的压缩率。</p><p>
                The <a class="link" href="information-schema.html#innodb-cmp-table" title="24.32.4&nbsp;The INFORMATION_SCHEMA INNODB_CMP and INNODB_CMP_RESET Tables"><code class="literal">INNODB_CMP</code></a> table reports
                information about compression activity for each compressed page
                size (<code class="literal">KEY_BLOCK_SIZE</code>) in use. The information
                in these tables is system-wide: it summarizes the compression
                statistics across all compressed tables in your database. You
                can use this data to help decide whether or not to compress a
                table by examining these tables when no other compressed tables
                are being accessed. It involves relatively low overhead on the
                server, so you might query it periodically on a production
                server to check the overall efficiency of the compression
                feature.
            </p><p style="color:blue;">innodb_cmp表报告关于正在使用的每个压缩页面大小（key_block_size）的压缩活动的信息。这些表中的信息是系统范围的：它汇总了数据库中所有压缩表的压缩统计信息。当没有其他压缩表被访问时，您可以通过检查这些表来帮助决定是否压缩表。它在服务器上的开销相对较低，因此您可以在生产服务器上定期查询它，以检查压缩功能的总体效率。</p><p>
                The <a class="link" href="information-schema.html#innodb-cmp-per-index-table" title="24.32.6&nbsp;The INFORMATION_SCHEMA INNODB_CMP_PER_INDEX and INNODB_CMP_PER_INDEX_RESET Tables"><code class="literal">INNODB_CMP_PER_INDEX</code></a> table
                reports information about compression activity for individual
                tables and indexes. This information is more targeted and more
                useful for evaluating compression efficiency and diagnosing
                performance issues one table or index at a time. (Because that
                each <code class="literal">InnoDB</code> table is represented as a
                clustered index, MySQL does not make a big distinction between
                tables and indexes in this context.) The
                <a class="link" href="information-schema.html#innodb-cmp-per-index-table" title="24.32.6&nbsp;The INFORMATION_SCHEMA INNODB_CMP_PER_INDEX and INNODB_CMP_PER_INDEX_RESET Tables"><code class="literal">INNODB_CMP_PER_INDEX</code></a> table does
                involve substantial overhead, so it is more suitable for
                development servers, where you can compare the effects of
                different <a class="link" href="glossary.html#glos_workload" title="workload">workloads</a>, data,
                and compression settings in isolation. To guard against imposing
                this monitoring overhead by accident, you must enable the
                <a class="link" href="innodb-storage-engine.html#sysvar_innodb_cmp_per_index_enabled"><code class="literal">innodb_cmp_per_index_enabled</code></a>
                configuration option before you can query the
                <a class="link" href="information-schema.html#innodb-cmp-per-index-table" title="24.32.6&nbsp;The INFORMATION_SCHEMA INNODB_CMP_PER_INDEX and INNODB_CMP_PER_INDEX_RESET Tables"><code class="literal">INNODB_CMP_PER_INDEX</code></a> table.
            </p><p style="color:blue;">innodb_cmp_per_index表报告有关单个表和索引的压缩活动的信息。此信息更有针对性，对于评估压缩效率和一次诊断一个表或索引的性能问题更有用。（因为每个innodb表都表示为一个聚集索引，所以mysql在这个上下文中并没有对表和索引进行很大的区分。）innodb_cmp_per_index表确实涉及大量开销，所以它更适合于开发服务器，在那里可以比较不同工作负载、数据的效果，以及单独的压缩设置。为了防止意外地增加监视开销，您必须先启用innodb_cmp_per_index_enabled配置选项，然后才能查询innodb_cmp_per_index表。</p><p>
                The key statistics to consider are the number of, and amount of
                time spent performing, compression and uncompression operations.
                Since MySQL splits <a class="link" href="glossary.html#glos_b_tree" title="B-tree">B-tree</a>
                nodes when they are too full to contain the compressed data
                following a modification, compare the number of
                <span class="quote">“<span class="quote">successful</span>”</span> compression operations with the number
                of such operations overall. Based on the information in the
                <a class="link" href="information-schema.html#innodb-cmp-table" title="24.32.4&nbsp;The INFORMATION_SCHEMA INNODB_CMP and INNODB_CMP_RESET Tables"><code class="literal">INNODB_CMP</code></a> and
                <a class="link" href="information-schema.html#innodb-cmp-per-index-table" title="24.32.6&nbsp;The INFORMATION_SCHEMA INNODB_CMP_PER_INDEX and INNODB_CMP_PER_INDEX_RESET Tables"><code class="literal">INNODB_CMP_PER_INDEX</code></a> tables and
                overall application performance and hardware resource
                utilization, you might make changes in your hardware
                configuration, adjust the size of the buffer pool, choose a
                different page size, or select a different set of tables to
                compress.
            </p><p style="color:blue;">要考虑的关键统计数据是执行压缩和解压缩操作的次数和时间。由于mysql在b-tree节点太满而无法包含修改后的压缩数据时将其拆分，因此请将“成功”压缩操作的数量与此类操作的总数进行比较。根据innodb_cmp和innodb_cmp_per_索引表中的信息以及应用程序的总体性能和硬件资源利用率，可以更改硬件配置、调整缓冲池的大小、选择不同的页面大小或选择要压缩的不同表集。</p><p>
                If the amount of CPU time required for compressing and
                uncompressing is high, changing to faster or multi-core CPUs can
                help improve performance with the same data, application
                workload and set of compressed tables. Increasing the size of
                the buffer pool might also help performance, so that more
                uncompressed pages can stay in memory, reducing the need to
                uncompress pages that exist in memory only in compressed form.
            </p><p style="color:blue;">如果压缩和解压所需的cpu时间很长，那么在相同的数据、应用程序工作负载和压缩表集的情况下，更改为更快或多核cpu有助于提高性能。增加缓冲池的大小也可能有助于性能，这样更多的未压缩页可以留在内存中，从而减少了仅以压缩形式解压缩内存中存在的页面的需求。</p><p>
                A large number of compression operations overall (compared to
                the number of <code class="literal">INSERT</code>,
                <code class="literal">UPDATE</code> and <code class="literal">DELETE</code>
                operations in your application and the size of the database)
                could indicate that some of your compressed tables are being
                updated too heavily for effective compression. If so, choose a
                larger page size, or be more selective about which tables you
                compress.
            </p><p style="color:blue;">总的来说，大量的压缩操作（与应用程序中插入、更新和删除操作的数量以及数据库的大小相比）可能表明某些压缩表更新过多，无法进行有效的压缩。如果是，请选择较大的页面大小，或者对压缩哪些表更具选择性。</p><p>
                If the number of <span class="quote">“<span class="quote">successful</span>”</span> compression
                operations (<code class="literal">COMPRESS_OPS_OK</code>) is a high
                percentage of the total number of compression operations
                (<code class="literal">COMPRESS_OPS</code>), then the system is likely
                performing well. If the ratio is low, then MySQL is
                reorganizing, recompressing, and splitting B-tree nodes more
                often than is desirable. In this case, avoid compressing some
                tables, or increase <code class="literal">KEY_BLOCK_SIZE</code> for some
                of the compressed tables. You might turn off compression for
                tables that cause the number of <span class="quote">“<span class="quote">compression
        failures</span>”</span> in your application to be more than 1% or 2% of
                the total. (Such a failure ratio might be acceptable during a
                temporary operation such as a data load).
            </p><p style="color:blue;">如果“成功”压缩操作（compress_ops_ok）的数量占压缩操作（compress_ops）总数的高百分比，则系统可能性能良好。如果比率很低，那么mysql重组、重新压缩和拆分b-tree节点的频率就比预期的要高。在这种情况下，请避免压缩某些表，或增加某些压缩表的关键字块大小。您可能会关闭表的压缩，这会导致应用程序中“压缩失败”的数量超过总数的1%或2%。（在数据加载等临时操作期间，这种故障率可能是可以接受的）。</p>
            </div>
            <div class="section">
                <div class="titlepage">
                    <div>
                        <div>
                            <h4 class="title"><a name="innodb-compression-internals"></a>14.9.1.5&nbsp;How Compression Works for InnoDB Tables</h4>

                        </div>

                    </div>

                </div>
                <a class="indexterm" name="idm140286818840752"></a><p>
                This section describes some internal implementation details
                about <a class="link" href="glossary.html#glos_compression" title="compression">compression</a> for
                InnoDB tables. The information presented here may be helpful in
                tuning for performance, but is not necessary to know for basic
                use of compression.
            </p><p style="color:blue;">本节描述了一些关于innodb表压缩的内部实现细节。这里提供的信息可能有助于优化性能，但对于压缩的基本用途，不必知道。</p>
                <h5><a name="innodb-compression-internals-algorithms"></a>Compression Algorithms</h5>
                <a class="indexterm" name="idm140286818836544"></a><p>
                Some operating systems implement compression at the file system
                level. Files are typically divided into fixed-size blocks that
                are compressed into variable-size blocks, which easily leads
                into fragmentation. Every time something inside a block is
                modified, the whole block is recompressed before it is written
                to disk. These properties make this compression technique
                unsuitable for use in an update-intensive database system.
            </p><p style="color:blue;">一些操作系统在文件系统级别实现压缩。文件通常分为固定大小的块，压缩成可变大小的块，这很容易导致碎片。每次修改块中的某个内容时，都会在将整个块写入磁盘之前重新压缩它。这些特性使得这种压缩技术不适合用于更新密集型数据库系统。</p><p>
                MySQL implements compression with the help of the well-known
                <a class="ulink" href="http://www.zlib.net/" target="_top">zlib library</a>, which
                implements the LZ77 compression algorithm. This compression
                algorithm is mature, robust, and efficient in both CPU
                utilization and in reduction of data size. The algorithm is
                <span class="quote">“<span class="quote">lossless</span>”</span>, so that the original uncompressed data
                can always be reconstructed from the compressed form. LZ77
                compression works by finding sequences of data that are repeated
                within the data to be compressed. The patterns of values in your
                data determine how well it compresses, but typical user data
                often compresses by 50% or more.
            </p><p style="color:blue;">mysql借助于著名的zlib库实现压缩，zlib库实现了lz77压缩算法。这种压缩算法成熟、健壮，在cpu利用率和数据量缩减方面都很有效。该算法是“无损”的，因此原始的未压缩数据总是可以从压缩格式中重建出来。LZ77压缩通过查找要压缩的数据中重复的数据序列来工作。数据中的值模式决定了它压缩的程度，但典型的用户数据通常压缩50%或更多。</p>
                <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">

                    <div class="admon-title">
                        Note
                    </div>
                    <p>
                        Prior to MySQL 5.7.24, <code class="literal">InnoDB</code> supports the
                        <code class="literal">zlib</code> library up to version 1.2.3. In MySQL
                        5.7.24 and later, <code class="literal">InnoDB</code> supports the
                        <code class="literal">zlib</code> library up to version 1.2.11.
                    </p><p style="color:blue;">在mysql 5.7.24之前，innodb支持1.2.3版之前的zlib库。在mysql 5.7.24及更高版本中，innodb支持1.2.11版之前的zlib库。</p>
                </div>
                <p>
                    Unlike compression performed by an application, or compression
                    features of some other database management systems, InnoDB
                    compression applies both to user data and to indexes. In many
                    cases, indexes can constitute 40-50% or more of the total
                    database size, so this difference is significant. When
                    compression is working well for a data set, the size of the
                    InnoDB data files (the
                    <a class="link" href="glossary.html#glos_file_per_table" title="file-per-table">file-per-table</a>
                    tablespace or <a class="link" href="glossary.html#glos_general_tablespace" title="general tablespace">general
                    tablespace</a> <code class="literal">.ibd</code> files) is 25% to 50%
                    of the uncompressed size or possibly smaller. Depending on the
                    <a class="link" href="glossary.html#glos_workload" title="workload">workload</a>, this smaller
                    database can in turn lead to a reduction in I/O, and an increase
                    in throughput, at a modest cost in terms of increased CPU
                    utilization. You can adjust the balance between compression
                    level and CPU overhead by modifying the
                    <a class="link" href="innodb-storage-engine.html#sysvar_innodb_compression_level"><code class="literal">innodb_compression_level</code></a>
                    configuration option.
                </p><p style="color:blue;">与应用程序执行的压缩或其他一些数据库管理系统的压缩特性不同，innodb压缩同时适用于用户数据和索引。在许多情况下，索引可以占数据库总大小的40-50%或更多，因此这种差异是显著的。当一个数据集的压缩工作良好时，innodb数据文件（每个表空间的文件或general tablespace.ibd文件）的大小是未压缩大小的25%到50%，或者可能更小。根据工作负载的不同，这个较小的数据库可以反过来导致I/O的减少和吞吐量的增加，而CPU利用率的提高只需要一个适中的成本。您可以通过修改innodb_compression_level配置选项来调整压缩级别和cpu开销之间的平衡。</p>
                <h5><a name="innodb-compression-internals-storage"></a>InnoDB Data Storage and Compression</h5>
                <a class="indexterm" name="idm140286818821360"></a><p>
                All user data in InnoDB tables is stored in pages comprising a
                <a class="link" href="glossary.html#glos_b_tree" title="B-tree">B-tree</a> index (the
                <a class="link" href="glossary.html#glos_clustered_index" title="clustered index">clustered index</a>). In
                some other database systems, this type of index is called an
                <span class="quote">“<span class="quote">index-organized table</span>”</span>. Each row in the index node
                contains the values of the (user-specified or system-generated)
                <a class="link" href="glossary.html#glos_primary_key" title="primary key">primary key</a> and all the
                other columns of the table.
            </p><p style="color:blue;">innodb表中的所有用户数据都存储在包含b树索引（聚集索引）的页面中。在其他一些数据库系统中，这种类型的索引称为“索引组织表”。索引节点中的每一行都包含（用户指定的或系统生成的）主键的值和表的所有其他列。</p><p>
                <a class="link" href="glossary.html#glos_secondary_index" title="secondary index">Secondary indexes</a> in
                InnoDB tables are also B-trees, containing pairs of values: the
                index key and a pointer to a row in the clustered index. The
                pointer is in fact the value of the primary key of the table,
                which is used to access the clustered index if columns other
                than the index key and primary key are required. Secondary index
                records must always fit on a single B-tree page.
            </p><p style="color:blue;">innodb表中的二级索引也是b树，包含成对的值：索引键和指向聚集索引中一行的指针。指针实际上是表主键的值，如果需要索引键和主键以外的列，则该值用于访问聚集索引。辅助索引记录必须始终适合单个B树页。</p><p>
                The compression of B-tree nodes (of both clustered and secondary
                indexes) is handled differently from compression of
                <a class="link" href="glossary.html#glos_overflow_page" title="overflow page">overflow pages</a> used to
                store long <code class="literal">VARCHAR</code>, <code class="literal">BLOB</code>,
                or <code class="literal">TEXT</code> columns, as explained in the
                following sections.
            </p><p style="color:blue;">B树节点（包括聚集索引和辅助索引）的压缩与用于存储长VARCHAR、BLOB或文本列的溢出页的压缩不同，如下节所述。</p>
                <h5><a name="innodb-compression-internals-storage-btree"></a>Compression of B-Tree Pages</h5>
                <a class="indexterm" name="idm140286818809360"></a><p>
                Because they are frequently updated, B-tree pages require
                special treatment. It is important to minimize the number of
                times B-tree nodes are split, as well as to minimize the need to
                uncompress and recompress their content.
            </p><p style="color:blue;">因为它们经常更新，所以b树页面需要特殊处理。最小化b树节点被拆分的次数，以及最小化解压缩和重新压缩其内容的需要是非常重要的。</p><p>
                One technique MySQL uses is to maintain some system information
                in the B-tree node in uncompressed form, thus facilitating
                certain in-place updates. For example, this allows rows to be
                delete-marked and deleted without any compression operation.
            </p><p style="color:blue;">mysql使用的一种技术是以未压缩的形式在b树节点中维护一些系统信息，从而方便某些就地更新。例如，这允许在不进行任何压缩操作的情况下删除标记和删除行。</p><p>
                In addition, MySQL attempts to avoid unnecessary uncompression
                and recompression of index pages when they are changed. Within
                each B-tree page, the system keeps an uncompressed
                <span class="quote">“<span class="quote">modification log</span>”</span> to record changes made to the
                page. Updates and inserts of small records may be written to
                this modification log without requiring the entire page to be
                completely reconstructed.
            </p><p style="color:blue;">此外，mysql还试图避免索引页更改时不必要的解压缩和重新压缩。在每个b树页面中，系统保存一个未压缩的“修改日志”，以记录对页面所做的更改。小记录的更新和插入可以写入此修改日志，而无需完全重建整个页面。</p><p>
                When the space for the modification log runs out, InnoDB
                uncompresses the page, applies the changes and recompresses the
                page. If recompression fails (a situation known as a
                <a class="link" href="glossary.html#glos_compression_failure" title="compression failure">compression
                    failure</a>), the B-tree nodes are split and the process is
                repeated until the update or insert succeeds.
            </p><p style="color:blue;">当修改日志的空间用完时，innodb解压缩页面，应用更改并重新压缩页面。如果重新压缩失败（这种情况称为压缩失败），将拆分B树节点并重复该过程，直到更新或插入成功。</p><p>
                To avoid frequent compression failures in write-intensive
                workloads, such as for <a class="link" href="glossary.html#glos_oltp" title="OLTP">OLTP</a>
                applications, MySQL sometimes reserves some empty space
                (padding) in the page, so that the modification log fills up
                sooner and the page is recompressed while there is still enough
                room to avoid splitting it. The amount of padding space left in
                each page varies as the system keeps track of the frequency of
                page splits. On a busy server doing frequent writes to
                compressed tables, you can adjust the
                <a class="link" href="innodb-storage-engine.html#sysvar_innodb_compression_failure_threshold_pct"><code class="literal">innodb_compression_failure_threshold_pct</code></a>,
                and
                <a class="link" href="innodb-storage-engine.html#sysvar_innodb_compression_pad_pct_max"><code class="literal">innodb_compression_pad_pct_max</code></a>
                configuration options to fine-tune this mechanism.
            </p><p style="color:blue;">为了避免在写密集型工作负载（如对于oltp应用程序）中频繁出现压缩失败，mysql有时会在页面中保留一些空白（填充），以便在仍有足够空间避免拆分页面的情况下，更快地填充修改日志并重新压缩页面。随着系统跟踪页面拆分的频率，每页中剩余的填充空间量会有所不同。在一个频繁写入压缩表的繁忙服务器上，您可以调整innodb_compression_failure_threshold_pct和innodb_compression_pad_pct_max配置选项来微调此机制。</p><p>
                Generally, MySQL requires that each B-tree page in an InnoDB
                table can accommodate at least two records. For compressed
                tables, this requirement has been relaxed. Leaf pages of B-tree
                nodes (whether of the primary key or secondary indexes) only
                need to accommodate one record, but that record must fit, in
                uncompressed form, in the per-page modification log. If
                <a class="link" href="innodb-storage-engine.html#sysvar_innodb_strict_mode"><code class="literal">innodb_strict_mode</code></a> is
                <code class="literal">ON</code>, MySQL checks the maximum row size during
                <a class="link" href="sql-syntax.html#create-table" title="13.1.18&nbsp;CREATE TABLE Syntax"><code class="literal">CREATE TABLE</code></a> or
                <a class="link" href="sql-syntax.html#create-index" title="13.1.14&nbsp;CREATE INDEX Syntax"><code class="literal">CREATE INDEX</code></a>. If the row does not
                fit, the following error message is issued: <code class="literal">ERROR
                HY000: Too big row</code>.
            </p><p style="color:blue;">通常，mysql要求innodb表中的每个b树页面至少可以容纳两条记录。对于压缩表，这一要求已经放宽。b树节点的叶页（无论是主键索引还是辅助索引）只需要容纳一条记录，但该记录必须以未压缩的形式适合每页修改日志。如果NoNdByStrutTyMoad处于ON状态，MySQL检查CREATE TABLE或CREATED索引中的最大行大小。如果行不适合，将发出以下错误消息：error hy000:too big row。</p><p>
                If you create a table when
                <a class="link" href="innodb-storage-engine.html#sysvar_innodb_strict_mode"><code class="literal">innodb_strict_mode</code></a> is OFF, and
                a subsequent <code class="literal">INSERT</code> or
                <code class="literal">UPDATE</code> statement attempts to create an index
                entry that does not fit in the size of the compressed page, the
                operation fails with <code class="literal">ERROR 42000: Row size too
                large</code>. (This error message does not name the index for
                which the record is too large, or mention the length of the
                index record or the maximum record size on that particular index
                page.) To solve this problem, rebuild the table with
                <a class="link" href="sql-syntax.html#alter-table" title="13.1.8&nbsp;ALTER TABLE Syntax"><code class="literal">ALTER TABLE</code></a> and select a larger
                compressed page size (<code class="literal">KEY_BLOCK_SIZE</code>),
                shorten any column prefix indexes, or disable compression
                entirely with <code class="literal">ROW_FORMAT=DYNAMIC</code> or
                <code class="literal">ROW_FORMAT=COMPACT</code>.
            </p><p style="color:blue;">如果在innodb_strict_mode关闭时创建一个表，并且随后的insert或update语句试图创建一个不适合压缩页面大小的索引项，则操作将失败，并出现错误42000：row size too large。（此错误消息不命名记录太大的索引，或提及索引记录的长度或该特定索引页上的最大记录大小）。要解决此问题，请使用ALTE表重建表，并选择较大的压缩页大小（KEY-BROCKSIZE SLEVER），缩短任何列前缀索引，或者使用row_format=dynamic或row_format=compact完全禁用压缩。</p><p>
                <a class="link" href="innodb-storage-engine.html#sysvar_innodb_strict_mode"><code class="literal">innodb_strict_mode</code></a> is not
                applicable to general tablespaces, which also support compressed
                tables. Tablespace management rules for general tablespaces are
                strictly enforced independently of
                <a class="link" href="innodb-storage-engine.html#sysvar_innodb_strict_mode"><code class="literal">innodb_strict_mode</code></a>. For more
                information, see <a class="xref" href="sql-syntax.html#create-tablespace" title="13.1.19&nbsp;CREATE TABLESPACE Syntax">Section&nbsp;13.1.19, “CREATE TABLESPACE Syntax”</a>.
            </p><p style="color:blue;">innodb_strict_mode不适用于通用表空间，它也支持压缩表。一般表空间的表空间管理规则严格执行，独立于innodb_strict_模式。有关更多信息，请参阅第13.1.19节“创建表空间语法”。</p>
                <h5><a name="innodb-compression-internals-storage-blobs"></a>Compressing BLOB, VARCHAR, and TEXT Columns</h5>
                <a class="indexterm" name="idm140286818780384"></a><a class="indexterm" name="idm140286818778896"></a><a class="indexterm" name="idm140286818777408"></a><a class="indexterm" name="idm140286818775920"></a><p>
                In an InnoDB table, <a class="link" href="data-types.html#blob" title="11.4.3&nbsp;The BLOB and TEXT Types"><code class="literal">BLOB</code></a>,
                <a class="link" href="data-types.html#char" title="11.4.1&nbsp;The CHAR and VARCHAR Types"><code class="literal">VARCHAR</code></a>, and
                <a class="link" href="data-types.html#blob" title="11.4.3&nbsp;The BLOB and TEXT Types"><code class="literal">TEXT</code></a> columns that are not part of
                the primary key may be stored on separately allocated
                <a class="link" href="glossary.html#glos_overflow_page" title="overflow page">overflow pages</a>. We
                refer to these columns as
                <a class="link" href="glossary.html#glos_off_page_column" title="off-page column">off-page columns</a>.
                Their values are stored on singly-linked lists of overflow
                pages.
            </p><p style="color:blue;">在innodb表中，不属于主键的blob、varchar和文本列可以存储在单独分配的溢出页上。我们将这些列称为页外列。它们的值存储在溢出页的单个链接列表中。</p><p>
                For tables created in <code class="literal">ROW_FORMAT=DYNAMIC</code> or
                <code class="literal">ROW_FORMAT=COMPRESSED</code>, the values of
                <a class="link" href="data-types.html#blob" title="11.4.3&nbsp;The BLOB and TEXT Types"><code class="literal">BLOB</code></a>,
                <a class="link" href="data-types.html#blob" title="11.4.3&nbsp;The BLOB and TEXT Types"><code class="literal">TEXT</code></a>, or
                <a class="link" href="data-types.html#char" title="11.4.1&nbsp;The CHAR and VARCHAR Types"><code class="literal">VARCHAR</code></a> columns may be stored
                fully off-page, depending on their length and the length of the
                entire row. For columns that are stored off-page, the clustered
                index record only contains 20-byte pointers to the overflow
                pages, one per column. Whether any columns are stored off-page
                depends on the page size and the total size of the row. When the
                row is too long to fit entirely within the page of the clustered
                index, MySQL chooses the longest columns for off-page storage
                until the row fits on the clustered index page. As noted above,
                if a row does not fit by itself on a compressed page, an error
                occurs.
            </p><p style="color:blue;">对于以row_format=dynamic或row_format=compressed创建的表，blob、text或varchar列的值可以完全存储在页外，具体取决于它们的长度和整行的长度。对于存储在页外的列，聚集索引记录仅包含指向溢出页的20字节指针，每列一个。是否有任何列存储在页外取决于页大小和行的总大小。当行太长而无法完全容纳在聚集索引页中时，mysql将选择最长的列作为页外存储，直到行适合聚集索引页为止。如上所述，如果行本身不适合压缩页，则会发生错误。</p>
                <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">

                    <div class="admon-title">
                        Note
                    </div>
                    <p>
                        For tables created in <code class="literal">ROW_FORMAT=DYNAMIC</code> or
                        <code class="literal">ROW_FORMAT=COMPRESSED</code>,
                        <a class="link" href="data-types.html#blob" title="11.4.3&nbsp;The BLOB and TEXT Types"><code class="literal">TEXT</code></a> and
                        <a class="link" href="data-types.html#blob" title="11.4.3&nbsp;The BLOB and TEXT Types"><code class="literal">BLOB</code></a> columns that are less than
                        or equal to 40 bytes are always stored in-line.
                    </p><p style="color:blue;">对于以row_format=dynamic或row_format=compressed创建的表，小于或等于40字节的文本列和blob列始终以行方式存储。</p>
                </div>
                <p>
                    Tables created in older versions of MySQL use the
                    <a class="link" href="glossary.html#glos_antelope" title="Antelope">Antelope</a> file format, which
                    supports only <code class="literal">ROW_FORMAT=REDUNDANT</code> and
                    <code class="literal">ROW_FORMAT=COMPACT</code>. In these formats, MySQL
                    stores the first 768 bytes of
                    <a class="link" href="data-types.html#blob" title="11.4.3&nbsp;The BLOB and TEXT Types"><code class="literal">BLOB</code></a>,
                    <a class="link" href="data-types.html#char" title="11.4.1&nbsp;The CHAR and VARCHAR Types"><code class="literal">VARCHAR</code></a>, and
                    <a class="link" href="data-types.html#blob" title="11.4.3&nbsp;The BLOB and TEXT Types"><code class="literal">TEXT</code></a> columns in the clustered
                    index record along with the primary key. The 768-byte prefix is
                    followed by a 20-byte pointer to the overflow pages that contain
                    the rest of the column value.
                </p><p style="color:blue;">在旧版本的mysql中创建的表使用antelope文件格式，它只支持row_format=redundant和row_format=compact。在这些格式中，mysql将blob、varchar和文本列的前768字节与主键一起存储在聚集索引记录中。768字节的前缀后面跟着一个20字节的指针，指向包含列值其余部分的溢出页。</p><p>
                When a table is in <code class="literal">COMPRESSED</code> format, all
                data written to overflow pages is compressed <span class="quote">“<span class="quote">as
        is</span>”</span>; that is, MySQL applies the zlib compression
                algorithm to the entire data item. Other than the data,
                compressed overflow pages contain an uncompressed header and
                trailer comprising a page checksum and a link to the next
                overflow page, among other things. Therefore, very significant
                storage savings can be obtained for longer
                <code class="literal">BLOB</code>, <code class="literal">TEXT</code>, or
                <code class="literal">VARCHAR</code> columns if the data is highly
                compressible, as is often the case with text data. Image data,
                such as <code class="literal">JPEG</code>, is typically already compressed
                and so does not benefit much from being stored in a compressed
                table; the double compression can waste CPU cycles for little or
                no space savings.
            </p><p style="color:blue;">当一个表是压缩格式时，所有写入溢出页的数据都是“按原样”压缩的；也就是说，mysql对整个数据项应用zlib压缩算法。除数据外，压缩溢出页还包含未压缩的头和尾，其中包括页校验和以及指向下一个溢出页的链接。因此，如果数据是高度可压缩的，则可以为较长的blob、text或varchar列节省非常可观的存储空间，这在文本数据中通常是如此。像jpeg这样的图像数据通常已经被压缩，因此存储在压缩表中并没有太大好处；双重压缩可能会浪费cpu周期，只节省很少或根本没有空间。</p><p>
                The overflow pages are of the same size as other pages. A row
                containing ten columns stored off-page occupies ten overflow
                pages, even if the total length of the columns is only 8K bytes.
                In an uncompressed table, ten uncompressed overflow pages occupy
                160K bytes. In a compressed table with an 8K page size, they
                occupy only 80K bytes. Thus, it is often more efficient to use
                compressed table format for tables with long column values.
            </p><p style="color:blue;">溢出页的大小与其他页相同。即使列的总长度只有8k字节，一行包含存储在页外的十列，也会占用十个溢出页。在未压缩的表中，十个未压缩的溢出页占用160k字节。在8K页大小的压缩表中，它们只占用80K字节。因此，对于具有长列值的表，使用压缩表格式通常更有效。</p><p>
                For <a class="link" href="glossary.html#glos_file_per_table" title="file-per-table">file-per-table</a>
                tablespaces, using a 16K compressed page size can reduce storage
                and I/O costs for <a class="link" href="data-types.html#blob" title="11.4.3&nbsp;The BLOB and TEXT Types"><code class="literal">BLOB</code></a>,
                <a class="link" href="data-types.html#char" title="11.4.1&nbsp;The CHAR and VARCHAR Types"><code class="literal">VARCHAR</code></a>, or
                <a class="link" href="data-types.html#blob" title="11.4.3&nbsp;The BLOB and TEXT Types"><code class="literal">TEXT</code></a> columns, because such data
                often compress well, and might therefore require fewer overflow
                pages, even though the B-tree nodes themselves take as many
                pages as in the uncompressed form. General tablespaces do not
                support a 16K compressed page size
                (<code class="literal">KEY_BLOCK_SIZE</code>). For more information, see
                <a class="xref" href="innodb-storage-engine.html#general-tablespaces" title="14.6.3.3&nbsp;General Tablespaces">Section&nbsp;14.6.3.3, “General Tablespaces”</a>.
            </p><p style="color:blue;">对于每个表的文件表空间，使用16K压缩页大小可以减少blob、varchar或文本列的存储和I/O成本，因为这些数据通常压缩得很好，因此可能需要更少的溢出页，即使B树节点本身所占用的页数与未压缩表单中的相同。常规表空间不支持16K压缩页大小（键块大小）。有关更多信息，请参阅14.6.3.3节“常规表空间”。</p>
                <h5><a name="innodb-compression-internals-pool"></a>Compression and the InnoDB Buffer Pool</h5>
                <a class="indexterm" name="idm140286818735664"></a><a class="indexterm" name="idm140286818734160"></a><p>
                In a compressed <code class="literal">InnoDB</code> table, every
                compressed page (whether 1K, 2K, 4K or 8K) corresponds to an
                uncompressed page of 16K bytes (or a smaller size if
                <a class="link" href="innodb-storage-engine.html#sysvar_innodb_page_size"><code class="literal">innodb_page_size</code></a> is set). To
                access the data in a page, MySQL reads the compressed page from
                disk if it is not already in the
                <a class="link" href="glossary.html#glos_buffer_pool" title="buffer pool">buffer pool</a>, then
                uncompresses the page to its original form. This section
                describes how <code class="literal">InnoDB</code> manages the buffer pool
                with respect to pages of compressed tables.
            </p><p style="color:blue;">在一个压缩的innodb表中，每一个压缩页（不管是1k、2k、4k还是8k）对应一个16k字节的未压缩页（如果设置了innodb_page_size，则为较小的大小）。要访问页面中的数据，mysql会从磁盘读取压缩的页面（如果该页面不在缓冲池中），然后将该页面解压缩为原始形式。本节描述innodb如何管理与压缩表页面相关的缓冲池。</p><p>
                To minimize I/O and to reduce the need to uncompress a page, at
                times the buffer pool contains both the compressed and
                uncompressed form of a database page. To make room for other
                required database pages, MySQL can
                <a class="link" href="glossary.html#glos_eviction" title="eviction">evict</a> from the buffer pool
                an uncompressed page, while leaving the compressed page in
                memory. Or, if a page has not been accessed in a while, the
                compressed form of the page might be written to disk, to free
                space for other data. Thus, at any given time, the buffer pool
                might contain both the compressed and uncompressed forms of the
                page, or only the compressed form of the page, or neither.
            </p><p style="color:blue;">为了最小化I/O并减少解压页的需要，有时缓冲池包含数据库页的压缩和未压缩形式。为了给其他需要的数据库页面腾出空间，mysql可以从缓冲池中取出一个未压缩的页面，同时将压缩的页面保留在内存中。或者，如果一个页面已经有一段时间没有被访问了，那么该页面的压缩格式可能会被写入磁盘，以释放其他数据的空间。因此，在任何给定的时间，缓冲池可能同时包含页面的压缩和未压缩形式，或者只包含页面的压缩形式，或者两者都不包含。</p><p>
                MySQL keeps track of which pages to keep in memory and which to
                evict using a least-recently-used
                (<a class="link" href="glossary.html#glos_lru" title="LRU">LRU</a>) list, so that
                <a class="link" href="glossary.html#glos_hot" title="hot">hot</a> (frequently accessed) data
                tends to stay in memory. When compressed tables are accessed,
                MySQL uses an adaptive LRU algorithm to achieve an appropriate
                balance of compressed and uncompressed pages in memory. This
                adaptive algorithm is sensitive to whether the system is running
                in an <a class="link" href="glossary.html#glos_io_bound" title="I/O-bound">I/O-bound</a> or
                <a class="link" href="glossary.html#glos_cpu_bound" title="CPU-bound">CPU-bound</a> manner. The goal
                is to avoid spending too much processing time uncompressing
                pages when the CPU is busy, and to avoid doing excess I/O when
                the CPU has spare cycles that can be used for uncompressing
                compressed pages (that may already be in memory). When the
                system is I/O-bound, the algorithm prefers to evict the
                uncompressed copy of a page rather than both copies, to make
                more room for other disk pages to become memory resident. When
                the system is CPU-bound, MySQL prefers to evict both the
                compressed and uncompressed page, so that more memory can be
                used for <span class="quote">“<span class="quote">hot</span>”</span> pages and reducing the need to
                uncompress data in memory only in compressed form.
            </p><p style="color:blue;">mysql使用最近最少使用的（lru）列表来跟踪哪些页面要保存在内存中，哪些页面要退出，这样热（频繁访问的）数据往往会保留在内存中。当访问压缩表时，mysql使用一种自适应lru算法来实现内存中压缩和未压缩页面的适当平衡。此自适应算法对系统是以I/O绑定方式运行还是以CPU绑定方式运行敏感。目标是避免在cpu繁忙时花费过多的处理时间来解压缩页面，并避免在cpu有空闲周期可用于解压缩压缩页面（可能已经在内存中）时执行过多的i/o。当系统是I/O绑定的时，该算法倾向于逐出一个页面的未压缩副本，而不是同时逐出两个副本，以便为其他磁盘页面留有更多空间，使其成为内存驻留页。当系统受CPU限制时，MySQL倾向于同时收回压缩和未压缩的页面，以便更多的内存可用于“热”页面，并减少仅以压缩形式在内存中解压缩数据的需要。</p>
                <h5><a name="innodb-compression-internals-log"></a>Compression and the InnoDB Redo Log Files</h5>
                <a class="indexterm" name="idm140286818719344"></a><p>
                Before a compressed page is written to a
                <a class="link" href="glossary.html#glos_data_files" title="data files">data file</a>, MySQL writes a
                copy of the page to the redo log (if it has been recompressed
                since the last time it was written to the database). This is
                done to ensure that redo logs are usable for
                <a class="link" href="glossary.html#glos_crash_recovery" title="crash recovery">crash recovery</a>, even
                in the unlikely case that the <code class="literal">zlib</code> library is
                upgraded and that change introduces a compatibility problem with
                the compressed data. Therefore, some increase in the size of
                <a class="link" href="glossary.html#glos_log_file" title="log file">log files</a>, or a need for
                more frequent
                <a class="link" href="glossary.html#glos_checkpoint" title="checkpoint">checkpoints</a>, can be
                expected when using compression. The amount of increase in the
                log file size or checkpoint frequency depends on the number of
                times compressed pages are modified in a way that requires
                reorganization and recompression.
            </p><p style="color:blue;">在将压缩页写入数据文件之前，mysql会将该页的副本写入重做日志（如果自上次写入数据库后已重新压缩）。这样做是为了确保重做日志可用于崩溃恢复，即使在不太可能升级zlib库并且更改会导致与压缩数据的兼容性问题的情况下也是如此。因此，在使用压缩时，日志文件的大小可能会有所增加，或者需要更频繁的检查点。日志文件大小或检查点频率的增加量取决于以需要重新组织和重新压缩的方式修改压缩页的次数。</p><p>
                Compressed tables require the
                <a class="link" href="glossary.html#glos_barracuda" title="Barracuda">Barracuda</a> file format. To
                create a compressed table in a file-per-table tablespace,
                <a class="link" href="innodb-storage-engine.html#sysvar_innodb_file_per_table"><code class="literal">innodb_file_per_table</code></a> must be
                enabled and <a class="link" href="innodb-storage-engine.html#sysvar_innodb_file_format"><code class="literal">innodb_file_format</code></a>
                must be set to <a class="link" href="glossary.html#glos_barracuda" title="Barracuda">Barracuda</a>.
                There is no dependence on the
                <a class="link" href="innodb-storage-engine.html#sysvar_innodb_file_format"><code class="literal">innodb_file_format</code></a> setting when
                creating a compressed table in a general tablespace. For more
                information, see <a class="xref" href="innodb-storage-engine.html#general-tablespaces" title="14.6.3.3&nbsp;General Tablespaces">Section&nbsp;14.6.3.3, “General Tablespaces”</a>. The
                <a class="link" href="glossary.html#glos_mysql_enterprise_backup" title="MySQL Enterprise Backup">MySQL Enterprise
                    Backup</a> product supports the
                <a class="link" href="glossary.html#glos_barracuda" title="Barracuda">Barracuda</a> file format.
            </p><p style="color:blue;">压缩表需要梭鱼文件格式。要在每个表空间的文件中创建压缩表，必须启用innodb_file_per_table，并且innodb_file_format必须设置为barracuda。在常规表空间中创建压缩表时，不依赖于innodb_file_格式设置。有关更多信息，请参阅14.6.3.3节“常规表空间”。mysql企业备份产品支持barracuda文件格式。</p>
            </div>
            <div class="section">
                <div class="titlepage">
                    <div>
                        <div>
                            <h4 class="title"><a name="innodb-performance-compression-oltp"></a>14.9.1.6&nbsp;Compression for OLTP Workloads</h4>

                        </div>

                    </div>

                </div>
                <p>
                    Traditionally, the <code class="literal">InnoDB</code>
                    <a class="link" href="glossary.html#glos_compression" title="compression">compression</a> feature was
                    recommended primarily for read-only or read-mostly
                    <a class="link" href="glossary.html#glos_workload" title="workload">workloads</a>, such as in a
                    <a class="link" href="glossary.html#glos_data_warehouse" title="data warehouse">data warehouse</a>
                    configuration. The rise of <a class="link" href="glossary.html#glos_ssd" title="SSD">SSD</a>
                    storage devices, which are fast but relatively small and
                    expensive, makes compression attractive also for
                    <code class="literal">OLTP</code> workloads: high-traffic, interactive
                    websites can reduce their storage requirements and their I/O
                    operations per second (<a class="link" href="glossary.html#glos_iops" title="IOPS">IOPS</a>) by
                    using compressed tables with applications that do frequent
                    <a class="link" href="sql-syntax.html#insert" title="13.2.5&nbsp;INSERT Syntax"><code class="literal">INSERT</code></a>,
                    <a class="link" href="sql-syntax.html#update" title="13.2.11&nbsp;UPDATE Syntax"><code class="literal">UPDATE</code></a>, and
                    <a class="link" href="sql-syntax.html#delete" title="13.2.2&nbsp;DELETE Syntax"><code class="literal">DELETE</code></a> operations.
                </p><p style="color:blue;">传统上，innodb压缩特性主要推荐用于只读或以读为主的工作负载，例如在数据仓库配置中。ssd存储设备的兴起，虽然速度快，但体积小，价格昂贵，使得压缩对oltp工作负载也很有吸引力：高流量、交互式网站可以通过使用压缩表和频繁插入、更新的应用程序来降低其存储需求和每秒i/o操作（iops）。以及删除操作。</p><p>
                Configuration options introduced in MySQL 5.6 let you adjust the
                way compression works for a particular MySQL instance, with an
                emphasis on performance and scalability for write-intensive
                operations:
            </p><p style="color:blue;">mysql 5.6中引入的配置选项允许您调整针对特定mysql实例的压缩方式，重点是针对写密集型操作的性能和可伸缩性：</p>
                <div class="itemizedlist">
                    <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                        <a class="link" href="innodb-storage-engine.html#sysvar_innodb_compression_level"><code class="literal">innodb_compression_level</code></a>
                        lets you turn the degree of compression up or down. A higher
                        value lets you fit more data onto a storage device, at the
                        expense of more CPU overhead during compression. A lower
                        value lets you reduce CPU overhead when storage space is not
                        critical, or you expect the data is not especially
                        compressible.
                    </p><p style="color:blue;">innodb_compression_level允许您提高或降低压缩程度。更高的值允许您将更多的数据放在存储设备上，而在压缩期间会消耗更多的CPU开销。较低的值可以在存储空间不重要或数据不可压缩时减少CPU开销。</p></li><li class="listitem"><p>
                        <a class="link" href="innodb-storage-engine.html#sysvar_innodb_compression_failure_threshold_pct"><code class="literal">innodb_compression_failure_threshold_pct</code></a>
                        specifies a cutoff point for
                        <a class="link" href="glossary.html#glos_compression_failure" title="compression failure">compression
                            failures</a> during updates to a compressed table. When
                        this threshold is passed, MySQL begins to leave additional
                        free space within each new compressed page, dynamically
                        adjusting the amount of free space up to the percentage of
                        page size specified by
                        <a class="link" href="innodb-storage-engine.html#sysvar_innodb_compression_pad_pct_max"><code class="literal">innodb_compression_pad_pct_max</code></a>
                    </p><p style="color:blue;">innodb_compression_failure_threshold_pct指定压缩表更新期间压缩失败的截止点。当这个阈值通过时，mysql开始在每个新的压缩页面中保留额外的可用空间，动态调整可用空间的大小，直到innodb_compression_pad_pct_max指定的页面大小百分比</p></li><li class="listitem"><p>
                        <a class="link" href="innodb-storage-engine.html#sysvar_innodb_compression_pad_pct_max"><code class="literal">innodb_compression_pad_pct_max</code></a>
                        lets you adjust the maximum amount of space reserved within
                        each <a class="link" href="glossary.html#glos_page" title="page">page</a> to record changes
                        to compressed rows, without needing to compress the entire
                        page again. The higher the value, the more changes can be
                        recorded without recompressing the page. MySQL uses a
                        variable amount of free space for the pages within each
                        compressed table, only when a designated percentage of
                        compression operations
                        <span class="quote">“<span class="quote"><a class="link" href="glossary.html#glos_compression_failure" title="compression failure">fail</a></span>”</span>
                        at runtime, requiring an expensive operation to split the
                        compressed page.
                    </p><p style="color:blue;">NoNdByByPursixPADYPCTXMAX允许您调整每个页面中保留的最大空间量，以记录对压缩行的更改，而不需要再次压缩整个页面。值越高，可以记录的更改越多，而无需重新按页面。mysql为每个压缩表中的页面使用可变的可用空间，只有当指定百分比的压缩操作在运行时“失败”时，才需要昂贵的操作来拆分压缩页面。</p></li><li class="listitem"><p>
                        <a class="link" href="innodb-storage-engine.html#sysvar_innodb_log_compressed_pages"><code class="literal">innodb_log_compressed_pages</code></a>
                        lets you disable writing of images of
                        <a class="link" href="glossary.html#glos_compression" title="compression">re-compressed</a>
                        <a class="link" href="glossary.html#glos_page" title="page">pages</a> to the
                        <a class="link" href="glossary.html#glos_redo_log" title="redo log">redo log</a>.
                        Re-compression may occur when changes are made to compressed
                        data. This option is enabled by default to prevent
                        corruption that could occur if a different version of the
                        <code class="literal">zlib</code> compression algorithm is used during
                        recovery. If you are certain that the
                        <code class="literal">zlib</code> version will not change, disable
                        <a class="link" href="innodb-storage-engine.html#sysvar_innodb_log_compressed_pages"><code class="literal">innodb_log_compressed_pages</code></a>
                        to reduce redo log generation for workloads that modify
                        compressed data.
                    </p><p style="color:blue;">InnoDB_Log_Compressed_Pages允许您禁用将重新压缩页面的图像写入重做日志。更改压缩数据时，可能会发生重新压缩。默认情况下，启用此选项可防止在恢复期间使用不同版本的zlib压缩算法时发生损坏。如果确定zlib版本不会更改，请禁用innodb_log_compressed_pages以减少修改压缩数据的工作负载的重做日志生成。</p></li></ul>
                </div>
                <p>
                    Because working with compressed data sometimes involves keeping
                    both compressed and uncompressed versions of a page in memory at
                    the same time, when using compression with an OLTP-style
                    workload, be prepared to increase the value of the
                    <a class="link" href="innodb-storage-engine.html#sysvar_innodb_buffer_pool_size"><code class="literal">innodb_buffer_pool_size</code></a>
                    configuration option.
                </p><p style="color:blue;">因为处理压缩数据有时需要同时将页面的压缩版本和未压缩版本保留在内存中，所以在对oltp样式的工作负载使用压缩时，请准备好增加innodb_buffer_pool_size配置选项的值。</p>
            </div>
            <div class="section">
                <div class="titlepage">
                    <div>
                        <div>
                            <h4 class="title"><a name="innodb-compression-syntax-warnings"></a>14.9.1.7&nbsp;SQL Compression Syntax Warnings and Errors</h4>

                        </div>

                    </div>

                </div>
                <p>
                    This section describes syntax warnings and errors that you may
                    encounter when using the table compression feature with
                    <a class="link" href="glossary.html#glos_file_per_table" title="file-per-table">file-per-table</a>
                    tablespaces and <a class="link" href="glossary.html#glos_general_tablespace" title="general tablespace">general
                    tablespaces</a>.
                </p><p style="color:blue;">本节介绍在将表压缩功能与文件/表空间和常规表空间一起使用时可能遇到的语法警告和错误。</p>
                <h5><a name="idm140286818666832"></a>SQL Compression Syntax Warnings and Errors for File-Per-Table
                    Tablespaces</h5>
                <p>
                    When <a class="link" href="innodb-storage-engine.html#sysvar_innodb_strict_mode"><code class="literal">innodb_strict_mode</code></a> is
                    enabled (the default), specifying
                    <code class="literal">ROW_FORMAT=COMPRESSED</code> or
                    <code class="literal">KEY_BLOCK_SIZE</code> in <a class="link" href="sql-syntax.html#create-table" title="13.1.18&nbsp;CREATE TABLE Syntax"><code class="literal">CREATE
                    TABLE</code></a> or <a class="link" href="sql-syntax.html#alter-table" title="13.1.8&nbsp;ALTER TABLE Syntax"><code class="literal">ALTER TABLE</code></a>
                    statements produces the following error if
                    <a class="link" href="innodb-storage-engine.html#sysvar_innodb_file_per_table"><code class="literal">innodb_file_per_table</code></a> is
                    disabled or if
                    <a class="link" href="innodb-storage-engine.html#sysvar_innodb_file_format"><code class="literal">innodb_file_format</code></a> is set to
                    <code class="literal">Antelope</code> rather than
                    <code class="literal">Barracuda</code>.
                </p><p style="color:blue;">如果启用了innodb_strict_mode（默认值），在create table或alter table语句中指定row_format=compressed或key_block_size会在禁用innodb_file_per_table或innodb_file_format设置为antelope而不是barracuda时产生以下错误。</p><pre data-lang="terminal" class="programlisting">ERROR 1031 (HY000): Table storage engine for 't1' doesn't have this option
</pre>
                <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">

                    <div class="admon-title">
                        Note
                    </div>
                    <p>
                        The table is not created if the current configuration does not
                        permit using compressed tables.
                    </p><p style="color:blue;">如果当前配置不允许使用压缩表，则不会创建表。</p>
                </div>
                <p>
                    When <a class="link" href="innodb-storage-engine.html#sysvar_innodb_strict_mode"><code class="literal">innodb_strict_mode</code></a> is
                    disabled, specifying <code class="literal">ROW_FORMAT=COMPRESSED</code> or
                    <code class="literal">KEY_BLOCK_SIZE</code> in <a class="link" href="sql-syntax.html#create-table" title="13.1.18&nbsp;CREATE TABLE Syntax"><code class="literal">CREATE
                    TABLE</code></a> or <a class="link" href="sql-syntax.html#alter-table" title="13.1.8&nbsp;ALTER TABLE Syntax"><code class="literal">ALTER TABLE</code></a>
                    statements produces the following warnings if
                    <a class="link" href="innodb-storage-engine.html#sysvar_innodb_file_per_table"><code class="literal">innodb_file_per_table</code></a> is
                    disabled.
                </p><p style="color:blue;">禁用innodb_strict_mode时，如果禁用innodb_file_per_table，则在create table或alter table语句中指定row_format=compressed或key_block_size会产生以下警告。</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>SHOW WARNINGS;</code></strong>
+---------+------+---------------------------------------------------------------+
| Level   | Code | Message                                                       |
+---------+------+---------------------------------------------------------------+
| Warning | 1478 | InnoDB: KEY_BLOCK_SIZE requires innodb_file_per_table.        |
| Warning | 1478 | InnoDB: ignoring KEY_BLOCK_SIZE=4.                            |
| Warning | 1478 | InnoDB: ROW_FORMAT=COMPRESSED requires innodb_file_per_table. |
| Warning | 1478 | InnoDB: assuming ROW_FORMAT=DYNAMIC.                          |
+---------+------+---------------------------------------------------------------+
</pre><p>
                Similar warnings are issued if
                <a class="link" href="innodb-storage-engine.html#sysvar_innodb_file_format"><code class="literal">innodb_file_format</code></a> is set to
                <code class="literal">Antelope</code> rather than
                <code class="literal">Barracuda</code>.
            </p><p style="color:blue;">如果innodb_file_format设置为antelope而不是barracuda，则会发出类似的警告。</p>
                <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">

                    <div class="admon-title">
                        Note
                    </div>
                    <p>
                        These messages are only warnings, not errors, and the table is
                        created without compression, as if the options were not
                        specified.
                    </p><p style="color:blue;">这些消息只是警告，而不是错误，创建表时不进行压缩，就好像没有指定选项一样。</p>
                </div>
                <p>
                    The <span class="quote">“<span class="quote">non-strict</span>”</span> behavior lets you import a
                    <code class="literal">mysqldump</code> file into a database that does not
                    support compressed tables, even if the source database contained
                    compressed tables. In that case, MySQL creates the table in
                    <code class="literal">ROW_FORMAT=COMPACT</code> instead of preventing the
                    operation.
                </p><p style="color:blue;">“非严格”行为允许您将mysqldump文件导入不支持压缩表的数据库，即使源数据库包含压缩表。在这种情况下，mysql以row_format=compact创建表，而不是阻止操作。</p><p>
                To import the dump file into a new database, and have the tables
                re-created as they exist in the original database, ensure the
                server has the proper settings for the configuration parameters
                <a class="link" href="innodb-storage-engine.html#sysvar_innodb_file_format"><code class="literal">innodb_file_format</code></a> and
                <a class="link" href="innodb-storage-engine.html#sysvar_innodb_file_per_table"><code class="literal">innodb_file_per_table</code></a>.
            </p><p style="color:blue;">若要将转储文件导入新数据库，并将表重新创建为原始数据库中存在的表，则确保服务器具有配置参数NydBuffFielyFrand和NoNdByFielePixTabl的适当设置。</p><p>
                The attribute <code class="literal">KEY_BLOCK_SIZE</code> is permitted
                only when <code class="literal">ROW_FORMAT</code> is specified as
                <code class="literal">COMPRESSED</code> or is omitted. Specifying a
                <code class="literal">KEY_BLOCK_SIZE</code> with any other
                <code class="literal">ROW_FORMAT</code> generates a warning that you can
                view with <code class="literal">SHOW WARNINGS</code>. However, the table
                is non-compressed; the specified
                <code class="literal">KEY_BLOCK_SIZE</code> is ignored).
            </p><p style="color:blue;">仅当行格式指定为压缩或省略时，才允许使用属性键块大小。使用任何其他行格式指定键块大小会生成一个警告，您可以使用“显示警告”查看该警告。但是，表是非压缩的；指定的键块大小被忽略）。</p>
                <div class="informaltable">
                    <table summary="Warning level, error code, and message text for messages that could be generated when using conflicting clauses for InnoDB table compression."><colgroup><col width="20%"><col width="20%"><col width="60%"></colgroup><thead><tr>
                        <th scope="col">Level</th>
                        <th scope="col">Code</th>
                        <th scope="col">Message</th>
                    </tr></thead><tbody><tr>
                        <td scope="row">Warning</td>
                        <td>1478</td>
                        <td><code class="literal"> InnoDB: ignoring KEY_BLOCK_SIZE=<em class="replaceable"><code>n</code></em>
                            unless ROW_FORMAT=COMPRESSED. </code></td>
                    </tr></tbody></table>
                </div>
                <p>
                    If you are running with
                    <a class="link" href="innodb-storage-engine.html#sysvar_innodb_strict_mode"><code class="literal">innodb_strict_mode</code></a> enabled, the
                    combination of a <code class="literal">KEY_BLOCK_SIZE</code> with any
                    <code class="literal">ROW_FORMAT</code> other than
                    <code class="literal">COMPRESSED</code> generates an error, not a warning,
                    and the table is not created.
                </p><p style="color:blue;">如果您在启用innodb_strict_模式的情况下运行，那么将key_block_size与除compressed以外的任何row_格式组合起来会生成一个错误，而不是一个警告，并且不会创建表。</p><p>
                <a class="xref" href="innodb-storage-engine.html#innodb-compression-create-and-alter-options-table" title="Table&nbsp;14.7&nbsp;ROW_FORMAT and KEY_BLOCK_SIZE Options">Table&nbsp;14.7, “ROW_FORMAT and KEY_BLOCK_SIZE Options”</a>
                provides an overview the <code class="literal">ROW_FORMAT</code> and
                <code class="literal">KEY_BLOCK_SIZE</code> options that are used with
                <a class="link" href="sql-syntax.html#create-table" title="13.1.18&nbsp;CREATE TABLE Syntax"><code class="literal">CREATE TABLE</code></a> or
                <a class="link" href="sql-syntax.html#alter-table" title="13.1.8&nbsp;ALTER TABLE Syntax"><code class="literal">ALTER TABLE</code></a>.
            </p><p style="color:blue;">表14.7“行格式和键块大小选项”概述了用于创建表或更改表的行格式和键块大小选项。</p>
                <div class="table">
                    <a name="innodb-compression-create-and-alter-options-table"></a><p class="title"><b>Table&nbsp;14.7&nbsp;ROW_FORMAT and KEY_BLOCK_SIZE Options</b></p><p style="color:blue;">表14.7行格式和键块大小选项</p>
                    <div class="table-contents">
                        <table summary="ROW_FORMAT and KEY_BLOCK_SIZE option usage notes and descriptions."><colgroup><col width="20%"><col width="40%"><col width="40%"></colgroup><thead><tr>
                            <th scope="col">Option</th>
                            <th scope="col">Usage Notes</th>
                            <th scope="col">Description</th>
                        </tr></thead><tbody><tr>
                            <td scope="row"><code class="literal">ROW_FORMAT=​REDUNDANT</code></td>
                            <td>Storage format used prior to MySQL 5.0.3</td>
                            <td>Less efficient than <code class="literal">ROW_FORMAT=COMPACT</code>; for backward
                                compatibility</td>
                        </tr><tr>
                            <td scope="row"><code class="literal">ROW_FORMAT=​COMPACT</code></td>
                            <td>Default storage format since MySQL 5.0.3</td>
                            <td>Stores a prefix of 768 bytes of long column values in the clustered
                                index page, with the remaining bytes stored in an overflow
                                page</td>
                        </tr><tr>
                            <td scope="row"><code class="literal">ROW_FORMAT=​DYNAMIC</code></td>
                            <td>File-per-table tablespaces require
                                <code class="literal">innodb_file​_format=Barracuda</code></td>
                            <td>Store values within the clustered index page if they fit; if not, stores
                                only a 20-byte pointer to an overflow page (no prefix)</td>
                        </tr><tr>
                            <td scope="row"><code class="literal">ROW_FORMAT=​COMPRESSED</code></td>
                            <td>File-per-table tablespaces require
                                <code class="literal">innodb_file​_format=Barracuda</code></td>
                            <td>Compresses the table and indexes using zlib</td>
                        </tr><tr>
                            <td scope="row"><code class="literal">KEY_BLOCK_​SIZE=<em class="replaceable"><code>n</code></em></code></td>
                            <td>File-per-table tablespaces require
                                <code class="literal">innodb_file​_format=Barracuda</code></td>
                            <td>Specifies compressed page size of 1, 2, 4, 8 or 16 kilobytes; implies
                                <code class="literal">ROW_FORMAT=COMPRESSED</code>. For general
                                tablespaces, a <code class="literal">KEY_BLOCK_SIZE</code> value
                                equal to the <code class="literal">InnoDB</code> page size is not
                                permitted.</td>
                        </tr></tbody></table>
                    </div>

                </div>
                <br class="table-break"><p>
                <a class="xref" href="innodb-storage-engine.html#innodb-compression-create-and-alter-errors-table" title="Table&nbsp;14.8&nbsp;CREATE/ALTER TABLE Warnings and Errors when InnoDB Strict Mode is OFF">Table&nbsp;14.8, “CREATE/ALTER TABLE Warnings and Errors when InnoDB Strict Mode is OFF”</a>
                summarizes error conditions that occur with certain combinations
                of configuration parameters and options on the
                <a class="link" href="sql-syntax.html#create-table" title="13.1.18&nbsp;CREATE TABLE Syntax"><code class="literal">CREATE TABLE</code></a> or
                <a class="link" href="sql-syntax.html#alter-table" title="13.1.8&nbsp;ALTER TABLE Syntax"><code class="literal">ALTER TABLE</code></a> statements, and how
                the options appear in the output of <code class="literal">SHOW TABLE
                STATUS</code>.
            </p><p style="color:blue;">表14.8，“InnoDB Strict Mode关闭时创建/更改表警告和错误”总结了配置参数和CREATE TABLE或ALTER TABLE语句选项的某些组合出现的错误情况，以及这些选项在显示表状态输出中的显示方式。</p><p>
                When <a class="link" href="innodb-storage-engine.html#sysvar_innodb_strict_mode"><code class="literal">innodb_strict_mode</code></a> is
                <code class="literal">OFF</code>, MySQL creates or alters the table, but
                ignores certain settings as shown below. You can see the warning
                messages in the MySQL error log. When
                <a class="link" href="innodb-storage-engine.html#sysvar_innodb_strict_mode"><code class="literal">innodb_strict_mode</code></a> is
                <code class="literal">ON</code>, these specified combinations of options
                generate errors, and the table is not created or altered. To see
                the full description of the error condition, issue the
                <code class="literal">SHOW ERRORS</code> statement: example:

            </p><p style="color:blue;">当innodb_strict_mode关闭时，mysql创建或更改表，但忽略如下所示的某些设置。您可以在mysql错误日志中看到警告消息。当innodb_strict_mode打开时，这些指定的选项组合会生成错误，并且不会创建或更改表。要查看错误条件的完整描述，请发出show errors语句：示例：</p><pre class="screen">mysql&gt; <strong class="userinput"><code>CREATE TABLE x (id INT PRIMARY KEY, c INT)
</code></strong>
-&gt; <strong class="userinput"><code>ENGINE=INNODB KEY_BLOCK_SIZE=33333;
</code></strong>
ERROR 1005 (HY000): Can't create table 'test.x' (errno: 1478)

mysql&gt; <strong class="userinput"><code>SHOW ERRORS;</code></strong>
+-------+------+-------------------------------------------+
| Level | Code | Message                                   |
+-------+------+-------------------------------------------+
| Error | 1478 | InnoDB: invalid KEY_BLOCK_SIZE=33333.     |
| Error | 1005 | Can't create table 'test.x' (errno: 1478) |
+-------+------+-------------------------------------------+
</pre><p>
            </p>
                <div class="table">
                    <a name="innodb-compression-create-and-alter-errors-table"></a><p class="title"><b>Table&nbsp;14.8&nbsp;CREATE/ALTER TABLE Warnings and Errors when InnoDB Strict Mode is OFF</b></p><p style="color:blue;">table 14.8关闭InnoDB Strict模式时创建/更改表警告和错误</p>
                    <div class="table-contents">
                        <table summary="CREATE and ALTER TABLE warnings and errors when InnoDB strict mode is OFF."><colgroup><col width="33%"><col width="33%"><col width="33%"></colgroup><thead><tr>
                            <th scope="col">Syntax</th>
                            <th scope="col">Warning or Error Condition</th>
                            <th scope="col">Resulting <code class="literal">ROW_FORMAT</code>, as shown in <code class="literal">SHOW TABLE
                                STATUS</code></th>
                        </tr></thead><tbody><tr>
                            <td scope="row"><code class="literal">ROW_FORMAT=REDUNDANT</code></td>
                            <td>None</td>
                            <td><code class="literal">REDUNDANT</code></td>
                        </tr><tr>
                            <td scope="row"><code class="literal">ROW_FORMAT=COMPACT</code></td>
                            <td>None</td>
                            <td><code class="literal">COMPACT</code></td>
                        </tr><tr>
                            <td scope="row"><code class="literal">ROW_FORMAT=COMPRESSED</code> or
                                <code class="literal">ROW_FORMAT=DYNAMIC</code> or
                                <code class="literal">KEY_BLOCK_SIZE</code> is specified</td>
                            <td>Ignored for file-per-table tablespaces unless both
                                <a class="link" href="innodb-storage-engine.html#sysvar_innodb_file_format"><code class="literal">innodb_file_format</code></a><code class="literal">=Barracuda</code>
                                and <a class="link" href="innodb-storage-engine.html#sysvar_innodb_file_per_table"><code class="literal">innodb_file_per_table</code></a>
                                are enabled. General tablespaces support all row formats
                                (with some restrictions) regardless of
                                <a class="link" href="innodb-storage-engine.html#sysvar_innodb_file_format"><code class="literal">innodb_file_format</code></a> and
                                <a class="link" href="innodb-storage-engine.html#sysvar_innodb_file_per_table"><code class="literal">innodb_file_per_table</code></a>
                                settings. See <a class="xref" href="innodb-storage-engine.html#general-tablespaces" title="14.6.3.3&nbsp;General Tablespaces">Section&nbsp;14.6.3.3, “General Tablespaces”</a>.</td>
                            <td><code class="literal">the default row format for file-per-table tablespaces; the
                                specified row format for general tablespaces</code></td>
                        </tr><tr>
                            <td scope="row">Invalid <code class="literal">KEY_BLOCK_SIZE</code> is specified (not 1, 2, 4, 8
                                or 16)</td>
                            <td><code class="literal">KEY_BLOCK_SIZE</code> is ignored</td>
                            <td>the specified row format, or the default row format</td>
                        </tr><tr>
                            <td scope="row"><code class="literal">ROW_FORMAT=COMPRESSED</code> and valid
                                <code class="literal">KEY_BLOCK_SIZE</code> are specified</td>
                            <td>None; <code class="literal">KEY_BLOCK_SIZE</code> specified is used</td>
                            <td><code class="literal">COMPRESSED</code></td>
                        </tr><tr>
                            <td scope="row"><code class="literal">KEY_BLOCK_SIZE</code> is specified with
                                <code class="literal">REDUNDANT</code>, <code class="literal">COMPACT</code>
                                or <code class="literal">DYNAMIC</code> row format</td>
                            <td><code class="literal">KEY_BLOCK_SIZE</code> is ignored</td>
                            <td><code class="literal">REDUNDANT</code>, <code class="literal">COMPACT</code> or
                                <code class="literal">DYNAMIC</code></td>
                        </tr><tr>
                            <td scope="row"><code class="literal">ROW_FORMAT</code> is not one of
                                <code class="literal">REDUNDANT</code>, <code class="literal">COMPACT</code>,
                                <code class="literal">DYNAMIC</code> or
                                <code class="literal">COMPRESSED</code></td>
                            <td>Ignored if recognized by the MySQL parser. Otherwise, an error is
                                issued.</td>
                            <td>the default row format or N/A</td>
                        </tr></tbody></table>
                    </div>

                </div>
                <br class="table-break"><p>
                When <code class="literal">innodb_strict_mode</code> is
                <code class="literal">ON</code>, MySQL rejects invalid
                <code class="literal">ROW_FORMAT</code> or
                <code class="literal">KEY_BLOCK_SIZE</code> parameters and issues errors.
                When <code class="literal">innodb_strict_mode</code> is
                <code class="literal">OFF</code>, MySQL issues warnings instead of errors
                for ignored invalid parameters.
                <code class="literal">innodb_strict_mode</code> is <code class="literal">ON</code>
                by default.
            </p><p style="color:blue;">当innodb_strict_mode打开时，mysql拒绝无效的row_format或key_block_size参数并发出错误。当innodb_strict_mode关闭时，mysql会对忽略的无效参数发出警告而不是错误。默认情况下，innodb_strict_mode处于打开状态。</p><p>
                When <code class="literal">innodb_strict_mode</code> is
                <code class="literal">ON</code>, MySQL rejects invalid
                <code class="literal">ROW_FORMAT</code> or
                <code class="literal">KEY_BLOCK_SIZE</code> parameters. For compatibility
                with earlier versions of MySQL, strict mode is not enabled by
                default; instead, MySQL issues warnings (not errors) for ignored
                invalid parameters.
            </p><p style="color:blue;">当innodb_strict_mode打开时，mysql拒绝无效的row_format或key_block_size参数。为了与早期版本的mysql兼容，默认情况下不启用strict模式；相反，mysql会对忽略的无效参数发出警告（而不是错误）。</p><p>
                It is not possible to see the chosen
                <code class="literal">KEY_BLOCK_SIZE</code> using <code class="literal">SHOW TABLE
                STATUS</code>. The statement <code class="literal">SHOW CREATE
                TABLE</code> displays the <code class="literal">KEY_BLOCK_SIZE</code>
                (even if it was ignored when creating the table). The real
                compressed page size of the table cannot be displayed by MySQL.
            </p><p style="color:blue;">无法使用“显示表状态”查看所选的键块大小。语句show create table显示键块大小（即使在创建表时忽略了它）。mysql无法显示表的实际压缩页大小。</p>
                <h5><a name="idm140286818493968"></a>SQL Compression Syntax Warnings and Errors for General Tablespaces</h5>
                <div class="itemizedlist">
                    <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                        If <code class="literal">FILE_BLOCK_SIZE</code> was not defined for
                        the general tablespace when the tablespace was created, the
                        tablespace cannot contain compressed tables. If you attempt
                        to add a compressed table, an error is returned, as shown in
                        the following example:
                    </p><p style="color:blue;">如果在创建表空间时没有为常规表空间定义文件块大小，则表空间不能包含压缩表。如果尝试添加压缩表，将返回错误，如下例所示：</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>CREATE TABLESPACE `ts1` ADD DATAFILE 'ts1.ibd' Engine=InnoDB;</code></strong>

mysql&gt; <strong class="userinput"><code>CREATE TABLE t1 (c1 INT PRIMARY KEY) TABLESPACE ts1 ROW_FORMAT=COMPRESSED</code></strong>
       <strong class="userinput"><code>KEY_BLOCK_SIZE=8;</code></strong>
ERROR 1478 (HY000): InnoDB: Tablespace `ts1` cannot contain a COMPRESSED table
</pre></li><li class="listitem"><p>
                        Attempting to add a table with an invalid
                        <code class="literal">KEY_BLOCK_SIZE</code> to a general tablespace
                        returns an error, as shown in the following example:
                    </p><p style="color:blue;">试图将具有无效键块大小的表添加到常规表空间将返回一个错误，如下例所示：</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>CREATE TABLESPACE `ts2` ADD DATAFILE 'ts2.ibd' FILE_BLOCK_SIZE = 8192 Engine=InnoDB;</code></strong>

mysql&gt; <strong class="userinput"><code>CREATE TABLE t2 (c1 INT PRIMARY KEY) TABLESPACE ts2 ROW_FORMAT=COMPRESSED</code></strong>
       <strong class="userinput"><code>KEY_BLOCK_SIZE=4;</code></strong>
ERROR 1478 (HY000): InnoDB: Tablespace `ts2` uses block size 8192 and cannot
contain a table with physical page size 4096</pre><p>
                        For general tablespaces, the
                        <code class="literal">KEY_BLOCK_SIZE</code> of the table must be equal
                        to the <code class="literal">FILE_BLOCK_SIZE</code> of the tablespace
                        divided by 1024. For example, if the
                        <code class="literal">FILE_BLOCK_SIZE</code> of the tablespace is
                        8192, the <code class="literal">KEY_BLOCK_SIZE</code> of the table
                        must be 8.
                    </p><p style="color:blue;">对于一般表空间，表的键块大小必须等于表空间的文件块大小除以1024。例如，如果表空间的文件块大小是8192，则表的键块大小必须是8。</p></li><li class="listitem"><p>
                        Attempting to add a table with an uncompressed row format to
                        a general tablespace configured to store compressed tables
                        returns an error, as shown in the following example:
                    </p><p style="color:blue;">尝试将未压缩行格式的表添加到配置为存储压缩表的常规表空间时，将返回错误，如下例所示：</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>CREATE TABLESPACE `ts3` ADD DATAFILE 'ts3.ibd' FILE_BLOCK_SIZE = 8192 Engine=InnoDB;</code></strong>

mysql&gt; <strong class="userinput"><code>CREATE TABLE t3 (c1 INT PRIMARY KEY) TABLESPACE ts3 ROW_FORMAT=COMPACT;</code></strong>
ERROR 1478 (HY000): InnoDB: Tablespace `ts3` uses block size 8192 and cannot
contain a table with physical page size 16384</pre></li></ul>
                </div>
                <p>
                    <a class="link" href="innodb-storage-engine.html#sysvar_innodb_strict_mode"><code class="literal">innodb_strict_mode</code></a> is not
                    applicable to general tablespaces. Tablespace management rules
                    for general tablespaces are strictly enforced independently of
                    <a class="link" href="innodb-storage-engine.html#sysvar_innodb_strict_mode"><code class="literal">innodb_strict_mode</code></a>. For more
                    information, see <a class="xref" href="sql-syntax.html#create-tablespace" title="13.1.19&nbsp;CREATE TABLESPACE Syntax">Section&nbsp;13.1.19, “CREATE TABLESPACE Syntax”</a>.
                </p><p style="color:blue;">innodb_strict_mode不适用于一般表空间。一般表空间的表空间管理规则严格执行，独立于innodb_strict_模式。有关更多信息，请参阅第13.1.19节“创建表空间语法”。</p><p>
                For more information about using compressed tables with general
                tablespaces, see <a class="xref" href="innodb-storage-engine.html#general-tablespaces" title="14.6.3.3&nbsp;General Tablespaces">Section&nbsp;14.6.3.3, “General Tablespaces”</a>.
            </p><p style="color:blue;">有关将压缩表与常规表空间一起使用的更多信息，请参阅14.6.3.3节“常规表空间”。</p>
            </div>

        </div>
        <div class="section">
            <div class="titlepage">
                <div>
                    <div>
                        <h3 class="title"><a name="innodb-page-compression"></a>14.9.2&nbsp;InnoDB Page Compression</h3>

                    </div>

                </div>

            </div>
            <a class="indexterm" name="idm140286818469472"></a><a class="indexterm" name="idm140286818468400"></a><p>
            <code class="literal">InnoDB</code> supports page-level compression for
            tables that reside in
            <a class="link" href="glossary.html#glos_file_per_table" title="file-per-table">file-per-table</a>
            tablespaces. This feature is referred to as <span class="emphasis"><em>Transparent
      Page Compression</em></span>. Page compression is enabled by
            specifying the <code class="literal">COMPRESSION</code> attribute with
            <a class="link" href="sql-syntax.html#create-table" title="13.1.18&nbsp;CREATE TABLE Syntax"><code class="literal">CREATE TABLE</code></a> or
            <a class="link" href="sql-syntax.html#alter-table" title="13.1.8&nbsp;ALTER TABLE Syntax"><code class="literal">ALTER TABLE</code></a>. Supported compression
            algorithms include <code class="literal">Zlib</code> and
            <code class="literal">LZ4</code>.
        </p><p style="color:blue;">innodb支持对每个表空间文件中的表进行页级压缩。此功能称为透明页压缩。通过使用create table或alter table指定compression属性，可以启用页面压缩。支持的压缩算法包括zlib和lz4。</p>
            <h4><a name="idm140286818460192"></a>Supported Platforms</h4>
            <p>
                Page compression requires sparse file and hole punching support.
                Page compression is supported on Windows with NTFS, and on the
                following subset of MySQL-supported Linux platforms where the
                kernel level provides hole punching support:
            </p><p style="color:blue;">页面压缩需要稀疏文件和打孔支持。具有ntfs的windows和以下mysql支持的linux平台支持页面压缩，其中内核级提供了穿孔支持：</p>
            <div class="itemizedlist">
                <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                    RHEL 7 and derived distributions that use kernel version
                    3.10.0-123 or higher
                </p><p style="color:blue;">RHEL7和使用内核版本3.10.0-123或更高版本的派生发行版</p></li><li class="listitem"><p>
                    OEL 5.10 (UEK2) kernel version 2.6.39 or higher
                </p><p style="color:blue;">OEL 5.10（UEK2）内核版本2.6.39或更高版本</p></li><li class="listitem"><p>
                    OEL 6.5 (UEK3) kernel version 3.8.13 or higher
                </p><p style="color:blue;">oel 6.5（uek3）内核版本3.8.13或更高版本</p></li><li class="listitem"><p>
                    OEL 7.0 kernel version 3.8.13 or higher
                </p><p style="color:blue;">OEL 7.0内核版本3.8.13或更高版本</p></li><li class="listitem"><p>
                    SLE11 kernel version 3.0-x
                </p><p style="color:blue;">SLE11内核版本3.0-x</p></li><li class="listitem"><p>
                    SLE12 kernel version 3.12-x
                </p><p style="color:blue;">SLE12内核版本3.12-x</p></li><li class="listitem"><p>
                    OES11 kernel version 3.0-x
                </p><p style="color:blue;">oes11内核版本3.0-x</p></li><li class="listitem"><p>
                    Ubuntu 14.0.4 LTS kernel version 3.13 or higher
                </p><p style="color:blue;">Ubuntu14.0.4LTS内核3.13或更高版本</p></li><li class="listitem"><p>
                    Ubuntu 12.0.4 LTS kernel version 3.2 or higher
                </p><p style="color:blue;">Ubuntu12.0.4LTS内核3.2或更高版本</p></li><li class="listitem"><p>
                    Debian 7 kernel version 3.2 or higher
                </p><p style="color:blue;">Debian 7内核3.2或更高版本</p></li></ul>
            </div>
            <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">
                <div class="admon-title">
                    Note
                </div>
                <p>
                    All of the available file systems for a given Linux distribution
                    may not support hole punching.
                </p><p style="color:blue;">给定Linux发行版的所有可用文件系统可能都不支持打孔。</p>
            </div>
            <h4><a name="idm140286818449072"></a>How Page Compression Works</h4>
            <p>
                When a page is written, it is compressed using the specified
                compression algorithm. The compressed data is written to disk,
                where the hole punching mechanism releases empty blocks from the
                end of the page. If compression fails, data is written out as-is.
            </p><p style="color:blue;">写入页时，将使用指定的压缩算法对其进行压缩。压缩后的数据被写入磁盘，在磁盘上打孔机构从页面末尾释放空块。如果压缩失败，则按原样写出数据。</p>
            <h4><a name="idm140286818447664"></a>Hole Punch Size on Linux</h4>
            <p>
                On Linux systems, the file system block size is the unit size used
                for hole punching. Therefore, page compression only works if page
                data can be compressed to a size that is less than or equal to the
                <code class="literal">InnoDB</code> page size minus the file system block
                size. For example, if
                <a class="link" href="innodb-storage-engine.html#sysvar_innodb_page_size"><code class="literal">innodb_page_size=16K</code></a> and the file
                system block size is 4K, page data must compress to less than or
                equal to 12K to make hole punching possible.
            </p><p style="color:blue;">在Linux系统上，文件系统块大小是用于打孔的单位大小。因此，只有当页面数据可以压缩到小于或等于innodb页面大小减去文件系统块大小的大小时，页面压缩才起作用。例如，如果innodb_page_size=16k，文件系统块大小为4k，则页面数据必须压缩到小于或等于12k，以使打孔成为可能。</p>
            <h4><a name="idm140286818444176"></a>Hole Punch Size on Windows</h4>
            <p>
                On Windows systems, the underlying infrastructure for sparse files
                is based on NTFS compression. Hole punching size is the NTFS
                compression unit, which is 16 times the NTFS cluster size. Cluster
                sizes and their compression units are shown in the following
                table:
            </p><p style="color:blue;">在windows系统上，稀疏文件的底层基础结构基于ntfs压缩。穿孔大小是ntfs压缩单元，是ntfs集群大小的16倍。集群大小及其压缩单位如下表所示：</p>
            <div class="table">
                <a name="idm140286818442752"></a><p class="title"><b>Table&nbsp;14.9&nbsp;Windows NTFS Cluster Size and Compression Units</b></p><p style="color:blue;">表14.9 Windows NTFS群集大小和压缩单位</p>
                <div class="table-contents">
                    <table frame="all" summary="Windows NTFS cluster size and compression units."><colgroup><col width="50%"><col width="50%"></colgroup><thead><tr>
                        <th scope="col">Cluster Size</th>
                        <th scope="col">Compression Unit</th>
                    </tr></thead><tbody><tr>
                        <td scope="row">512 Bytes</td>
                        <td>8 KB</td>
                    </tr><tr>
                        <td scope="row">1 KB</td>
                        <td>16 KB</td>
                    </tr><tr>
                        <td scope="row">2 KB</td>
                        <td>32 KB</td>
                    </tr><tr>
                        <td scope="row">4 KB</td>
                        <td>64 KB</td>
                    </tr></tbody></table>
                </div>

            </div>
            <br class="table-break"><p>
            Page compression on Windows systems only works if page data can be
            compressed to a size that is less than or equal to the
            <code class="literal">InnoDB</code> page size minus the compression unit
            size.
        </p><p style="color:blue;">只有当页面数据可以压缩到小于或等于innodb页面大小减去压缩单元大小的大小时，windows系统上的页面压缩才有效。</p><p>
            The default NTFS cluster size is 4KB, for which the compression
            unit size is 64KB. This means that page compression has no benefit
            for an out-of-the box Windows NTFS configuration, as the maximum
            <a class="link" href="innodb-storage-engine.html#sysvar_innodb_page_size"><code class="literal">innodb_page_size</code></a> is also 64KB.
        </p><p style="color:blue;">默认的ntfs集群大小为4kb，压缩单元大小为64kb。这意味着页面压缩对框外窗口NTFS配置没有好处，因为最大的INNObjpPage大小也为64KB。</p><p>
            For page compression to work on Windows, the file system must be
            created with a cluster size smaller than 4K, and the
            <a class="link" href="innodb-storage-engine.html#sysvar_innodb_page_size"><code class="literal">innodb_page_size</code></a> must be at least
            twice the size of the compression unit. For example, for page
            compression to work on Windows, you could build the file system
            with a cluster size of 512 Bytes (which has a compression unit of
            8KB) and initialize <code class="literal">InnoDB</code> with an
            <a class="link" href="innodb-storage-engine.html#sysvar_innodb_page_size"><code class="literal">innodb_page_size</code></a> value of 16K or
            greater.
        </p><p style="color:blue;">要使页面压缩在windows上工作，必须创建集群大小小于4k的文件系统，并且innodb_page_的大小必须至少是压缩单元大小的两倍。例如，要使页面压缩在windows上工作，可以构建集群大小为512字节（压缩单位为8kb）的文件系统，并使用innodb页面大小值16k或更大的值初始化innodb。</p>
            <h4><a name="idm140286818419680"></a>Enabling Page Compression</h4>
            <p>
                To enable page compression, specify the
                <code class="literal">COMPRESSION</code> attribute in the
                <a class="link" href="sql-syntax.html#create-table" title="13.1.18&nbsp;CREATE TABLE Syntax"><code class="literal">CREATE TABLE</code></a> statement. For
                example:
            </p><p style="color:blue;">要启用页压缩，请在create table语句中指定compression属性。例如：</p><pre data-lang="sql" class="programlisting">CREATE TABLE t1 (c1 INT) COMPRESSION="zlib";
</pre><p>
            You can also enable page compression in an
            <a class="link" href="sql-syntax.html#alter-table" title="13.1.8&nbsp;ALTER TABLE Syntax"><code class="literal">ALTER TABLE</code></a> statement. However,
            <a class="link" href="sql-syntax.html#alter-table" title="13.1.8&nbsp;ALTER TABLE Syntax"><code class="literal">ALTER TABLE ...
                COMPRESSION</code></a> only updates the tablespace compression
            attribute. Writes to the tablespace that occur after setting the
            new compression algorithm use the new setting, but to apply the
            new compression algorithm to existing pages, you must rebuild the
            table using <a class="link" href="sql-syntax.html#optimize-table" title="13.7.2.4&nbsp;OPTIMIZE TABLE Syntax"><code class="literal">OPTIMIZE TABLE</code></a>.
        </p><p style="color:blue;">还可以在alter table语句中启用页压缩。但是，更改表…压缩只更新表空间压缩属性。将新压缩算法设置为使用新设置后出现的表空间，但要将新的压缩算法应用到现有的页，必须使用优化表重建表。</p><pre data-lang="sql" class="programlisting">ALTER TABLE t1 COMPRESSION="zlib";
OPTIMIZE TABLE t1;
</pre>
            <h4><a name="idm140286818410160"></a>Disabling Page Compression</h4>
            <p>
                To disable page compression, set
                <code class="literal">COMPRESSION=None</code> using
                <a class="link" href="sql-syntax.html#alter-table" title="13.1.8&nbsp;ALTER TABLE Syntax"><code class="literal">ALTER TABLE</code></a>. Writes to the
                tablespace that occur after setting
                <code class="literal">COMPRESSION=None</code> no longer use page
                compression. To uncompress existing pages, you must rebuild the
                table using <a class="link" href="sql-syntax.html#optimize-table" title="13.7.2.4&nbsp;OPTIMIZE TABLE Syntax"><code class="literal">OPTIMIZE TABLE</code></a> after
                setting <code class="literal">COMPRESSION=None</code>.
            </p><p style="color:blue;">要禁用页压缩，请使用alter table设置compression=none。设置compression=none后发生的表空间写入不再使用页压缩。若要解压缩现有页，必须在设置压缩=“否”之后使用优化表重建表。</p><pre data-lang="sql" class="programlisting">ALTER TABLE t1 COMPRESSION="None";
OPTIMIZE TABLE t1;
</pre>
            <h4><a name="idm140286818403264"></a>Page Compression Metadata</h4>
            <p>
                Page compression metadata is found in the
                <a class="link" href="information-schema.html#innodb-sys-tablespaces-table" title="24.32.22.1&nbsp;The INFORMATION_SCHEMA INNODB_SYS_TABLESPACES Table"><code class="literal">INFORMATION_SCHEMA.INNODB_SYS_TABLESPACES</code></a>
                table, in the following columns:
            </p><p style="color:blue;">页面压缩元数据位于information_schema.innodb_sys_tablespaces表中的以下列中：</p>
            <div class="itemizedlist">
                <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                    <code class="literal">FS_BLOCK_SIZE</code>: The file system block size,
                    which is the unit size used for hole punching.
                </p><p style="color:blue;">fs_block_size：文件系统块大小，是用于打孔的单位大小。</p></li><li class="listitem"><p>
                    <code class="literal">FILE_SIZE</code>: The apparent size of the file,
                    which represents the maximum size of the file, uncompressed.
                </p><p style="color:blue;">文件大小：文件的显式大小，表示文件的最大大小，未压缩。</p></li><li class="listitem"><p>
                    <code class="literal">ALLOCATED_SIZE</code>: The actual size of the
                    file, which is the amount of space allocated on disk.
                </p><p style="color:blue;">已分配大小：文件的实际大小，即磁盘上已分配的空间量。</p></li></ul>
            </div>
            <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">
                <div class="admon-title">
                    Note
                </div>
                <p>
                    On Unix-like systems, <code class="literal">ls -l
                    <em class="replaceable"><code>tablespace_name.ibd</code></em></code> shows
                    the apparent file size (equivalent to
                    <code class="literal">FILE_SIZE</code>) in bytes. To view the actual
                    amount of space allocated on disk (equivalent to
                    <code class="literal">ALLOCATED_SIZE</code>), use <code class="literal">du
                    --block-size=1
                    <em class="replaceable"><code>tablespace_name.ibd</code></em></code>. The
                    <code class="literal">--block-size=1</code> option prints the allocated
                    space in bytes instead of blocks, so that it can be compared to
                    <code class="literal">ls -l</code> output.
                </p><p style="color:blue;">在类Unix系统上，ls-l tablespace_name.ibd以字节为单位显示明显的文件大小（相当于文件大小）。要查看磁盘上分配的实际空间量（相当于分配的磁盘大小），请使用du--block size=1 tablespace_name.ibd。--block size=1选项以字节而不是块打印分配的空间，以便可以将其与ls-l输出进行比较。</p><p>
                Use <a class="link" href="sql-syntax.html#show-create-table" title="13.7.5.10&nbsp;SHOW CREATE TABLE Syntax"><code class="literal">SHOW CREATE TABLE</code></a> to view the
                current page compression setting (<code class="literal">Zlib</code>,
                <code class="literal">Lz4</code>, or <code class="literal">None</code>). A table may
                contain a mix of pages with different compression settings.
            </p><p style="color:blue;">使用show create table查看当前页面压缩设置（zlib、lz4或none）。表可以包含具有不同压缩设置的页面组合。</p>
            </div>
            <p>
                In the following example, page compression metadata for the
                employees table is retrieved from the
                <a class="link" href="information-schema.html#innodb-sys-tablespaces-table" title="24.32.22.1&nbsp;The INFORMATION_SCHEMA INNODB_SYS_TABLESPACES Table"><code class="literal">INFORMATION_SCHEMA.INNODB_SYS_TABLESPACES</code></a>
                table.
            </p><p style="color:blue;">在下面的示例中，employees表的页面压缩元数据是从information_schema.innodb_sys_tablespaces表中检索的。</p><pre data-lang="sql" class="programlisting"># Create the employees table with Zlib page compression

CREATE TABLE employees (
    emp_no      INT             NOT NULL,
    birth_date  DATE            NOT NULL,
    first_name  VARCHAR(14)     NOT NULL,
    last_name   VARCHAR(16)     NOT NULL,
    gender      ENUM ('M','F')  NOT NULL,
    hire_date   DATE            NOT NULL,
    PRIMARY KEY (emp_no)
) COMPRESSION="zlib";

# Insert data (not shown)

# Query page compression metadata in INFORMATION_SCHEMA.INNODB_SYS_TABLESPACES

mysql&gt; <strong class="userinput"><code>SELECT SPACE, NAME, FS_BLOCK_SIZE, FILE_SIZE, ALLOCATED_SIZE FROM</code></strong>
       <strong class="userinput"><code>INFORMATION_SCHEMA.INNODB_SYS_TABLESPACES WHERE NAME='employees/employees'\G</code></strong>
*************************** 1. row ***************************
SPACE: 45
NAME: employees/employees
FS_BLOCK_SIZE: 4096
FILE_SIZE: 23068672
ALLOCATED_SIZE: 19415040
</pre><p>
            Page compression metadata for the employees table shows that the
            apparent file size is 23068672 bytes while the actual file size
            (with page compression) is 19415040 bytes. The file system block
            size is 4096 bytes, which is the block size used for hole
            punching.
        </p><p style="color:blue;">employees表的页面压缩元数据显示，表观文件大小为23068672字节，而实际文件大小（使用页面压缩）为19415040字节。文件系统块大小为4096字节，这是用于打孔的块大小。</p>
            <h4><a name="idm140286818379632"></a>Identifying Tables Using Page Compression</h4>
            <p>
                To identify tables for which page compression is enabled, you can
                query the <a class="link" href="information-schema.html#tables-table" title="24.25&nbsp;The INFORMATION_SCHEMA TABLES Table"><code class="literal">INFORMATION_SCHEMA.TABLES</code></a>
                <code class="literal">CREATE_OPTIONS</code> column for tables defined with
                the <code class="literal">COMPRESSION</code> attribute:
            </p><p style="color:blue;">要标识启用页压缩的表，可以查询信息架构。表为使用压缩属性定义的表创建选项列：</p><pre data-lang="stmt" class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT TABLE_NAME, TABLE_SCHEMA, CREATE_OPTIONS FROM INFORMATION_SCHEMA.TABLES </code></strong>
       <strong class="userinput"><code>WHERE CREATE_OPTIONS LIKE '%COMPRESSION=%';</code></strong>
+------------+--------------+--------------------+
| TABLE_NAME | TABLE_SCHEMA | CREATE_OPTIONS     |
+------------+--------------+--------------------+
| employees  | test         | COMPRESSION="zlib" |
+------------+--------------+--------------------+
</pre><p>
            <a class="link" href="sql-syntax.html#show-create-table" title="13.7.5.10&nbsp;SHOW CREATE TABLE Syntax"><code class="literal">SHOW CREATE TABLE</code></a> also shows the
            <code class="literal">COMPRESSION</code> attribute, if used.
        </p><p style="color:blue;">show create table还显示压缩属性（如果使用）。</p>
            <h4><a name="idm140286818370688"></a>Page Compression Limitations and Usage Notes</h4>
            <div class="itemizedlist">
                <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                    Page compression is disabled if the file system block size (or
                    compression unit size on Windows) * 2 &gt;
                    <a class="link" href="innodb-storage-engine.html#sysvar_innodb_page_size"><code class="literal">innodb_page_size</code></a>.
                </p><p style="color:blue;">如果文件系统块大小（或Windows上的压缩单元大小）*2&gt;InnoDB_page_size，则禁用页压缩。</p></li><li class="listitem"><p>
                    Page compression is not supported for tables that reside in
                    shared tablespaces, which include the system tablespace, the
                    temporary tablespace, and general tablespaces.
                </p><p style="color:blue;">共享表空间（包括系统表空间、临时表空间和常规表空间）中的表不支持页压缩。</p></li><li class="listitem"><p>
                    Page compression is not supported for undo log tablespaces.
                </p><p style="color:blue;">撤消日志表空间不支持页压缩。</p></li><li class="listitem"><p>
                    Page compression is not supported for redo log pages.
                </p><p style="color:blue;">重做日志页不支持页压缩。</p></li><li class="listitem"><p>
                    R-tree pages, which are used for spatial indexes, are not
                    compressed.
                </p><p style="color:blue;">用于空间索引的r树页不会被压缩。</p></li><li class="listitem"><p>
                    Pages that belong to compressed tables
                    (<code class="literal">ROW_FORMAT=COMPRESSED</code>) are left as-is.
                </p><p style="color:blue;">属于压缩表（row_format=compressed）的页按原样保留。</p></li><li class="listitem"><p>
                    During recovery, updated pages are written out in an
                    uncompressed form.
                </p><p style="color:blue;">在恢复过程中，更新的页面将以未压缩的形式写出。</p></li><li class="listitem"><p>
                    Loading a page-compressed tablespace on a server that does not
                    support the compression algorithm that was used causes an I/O
                    error.
                </p><p style="color:blue;">在不支持所用压缩算法的服务器上加载页压缩表空间会导致I/O错误。</p></li><li class="listitem"><p>
                    Before downgrading to an earlier version of MySQL that does
                    not support page compression, uncompress the tables that use
                    the page compression feature. To uncompress a table, run
                    <a class="link" href="sql-syntax.html#alter-table" title="13.1.8&nbsp;ALTER TABLE Syntax"><code class="literal">ALTER TABLE ...
                        COMPRESSION=None</code></a> and <a class="link" href="sql-syntax.html#optimize-table" title="13.7.2.4&nbsp;OPTIMIZE TABLE Syntax"><code class="literal">OPTIMIZE
                    TABLE</code></a>.
                </p><p style="color:blue;">在降级到不支持页面压缩的MySQL早期版本之前，请解压缩使用页面压缩功能的表。要解压缩表，请运行alter table…压缩=无并优化表。</p></li><li class="listitem"><p>
                    Page-compressed tablespaces can be copied between Linux and
                    Windows servers if the compression algorithm that was used is
                    available on both servers.
                </p><p style="color:blue;">如果所使用的压缩算法在两台服务器上都可用，则可以在Linux和Windows服务器之间复制页压缩表空间。</p></li><li class="listitem"><p>
                    Preserving page compression when moving a page-compressed
                    tablespace file from one host to another requires a utility
                    that preserves sparse files.
                </p><p style="color:blue;">在将页压缩表空间文件从一个主机移动到另一个主机时保留页压缩需要一个保留稀疏文件的实用程序。</p></li><li class="listitem"><p>
                    Better page compression may be achieved on Fusion-io hardware
                    with NVMFS than on other platforms, as NVMFS is designed to
                    take advantage of punch hole functionality.
                </p><p style="color:blue;">与其他平台相比，在具有nvmfs的fusion io硬件上可以实现更好的页面压缩，因为nvmfs被设计为利用打孔功能。</p></li><li class="listitem"><p>
                    Using the page compression feature with a large
                    <code class="literal">InnoDB</code> page size and relatively small file
                    system block size could result in write amplification. For
                    example, a maximum <code class="literal">InnoDB</code> page size of 64KB
                    with a 4KB file system block size may improve compression but
                    may also increase demand on the buffer pool, leading to
                    increased I/O and potential write amplification.
                </p><p style="color:blue;">使用具有较大innodb页面大小和相对较小文件系统块大小的页面压缩功能可能会导致写放大。例如，具有4KB文件系统块大小的最大的YNDB页大小64KB可以提高压缩，但也可能增加对缓冲池的需求，导致增加的I/O和潜在的写入放大。</p></li></ul>
            </div>

        </div>

    </div>
    <div class="section">
        <div class="titlepage">
            <div>
                <div>
                    <h2 class="title" style="clear: both"><a name="innodb-file-format"></a>14.10&nbsp;InnoDB File-Format Management</h2>

                </div>

            </div>

        </div>
        <div class="toc">
            <dl class="toc"><dt><span class="section"><a href="innodb-storage-engine.html#innodb-file-format-enabling">14.10.1 Enabling File Formats</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-file-format-compatibility">14.10.2 Verifying File Format Compatibility</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-file-format-identifying">14.10.3 Identifying the File Format in Use</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-file-format-downgrading">14.10.4 Modifying the File Format</a></span></dt></dl>
        </div>
        <a class="indexterm" name="idm140286818349744"></a><a class="indexterm" name="idm140286818348704"></a><a class="indexterm" name="idm140286818347632"></a><a class="indexterm" name="idm140286818346560"></a><p>
        As <code class="literal">InnoDB</code> evolves, data file formats that are not
        compatible with prior versions of <code class="literal">InnoDB</code> are
        sometimes required to support new features. To help manage
        compatibility in upgrade and downgrade situations, and systems that
        run different versions of MySQL, <code class="literal">InnoDB</code> uses
        named file formats. <code class="literal">InnoDB</code> currently supports two
        named file formats, <a class="link" href="glossary.html#glos_antelope" title="Antelope">Antelope</a>
        and <a class="link" href="glossary.html#glos_barracuda" title="Barracuda">Barracuda</a>.
    </p><p style="color:blue;">随着InnoDB的发展，有时需要与以前版本的InnoDB不兼容的数据文件格式来支持新功能。为了帮助管理升级和降级情况下的兼容性，以及运行不同版本mysql的系统，innodb使用命名文件格式。InnoDB目前支持两种命名文件格式，羚羊和梭鱼。</p>
        <div class="itemizedlist">
            <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                <a class="link" href="glossary.html#glos_antelope" title="Antelope">Antelope</a> is the original
                <code class="literal">InnoDB</code> file format, which previously did not
                have a name. It supports the
                <a class="link" href="glossary.html#glos_compact_row_format" title="compact row format">COMPACT</a> and
                <a class="link" href="glossary.html#glos_redundant_row_format" title="redundant row format">REDUNDANT</a> row
                formats for <code class="literal">InnoDB</code> tables.
            </p><p style="color:blue;">羚羊是最初的innodb文件格式，以前没有名字。它支持innodb表的压缩和冗余行格式。</p></li><li class="listitem"><p>
                <a class="link" href="glossary.html#glos_barracuda" title="Barracuda">Barracuda</a> is the newest
                file format. It supports all <code class="literal">InnoDB</code> row
                formats including the newer
                <a class="link" href="glossary.html#glos_compressed_row_format" title="compressed row format">COMPRESSED</a> and
                <a class="link" href="glossary.html#glos_dynamic_row_format" title="dynamic row format">DYNAMIC</a> row
                formats. The features associated with
                <a class="link" href="glossary.html#glos_compressed_row_format" title="compressed row format">COMPRESSED</a> and
                <a class="link" href="glossary.html#glos_dynamic_row_format" title="dynamic row format">DYNAMIC</a> row
                formats include compressed tables, efficient storage of off-page
                columns, and index key prefixes up to 3072 bytes
                (<a class="link" href="innodb-storage-engine.html#sysvar_innodb_large_prefix"><code class="literal">innodb_large_prefix</code></a>). See
                <a class="xref" href="innodb-storage-engine.html#innodb-row-format" title="14.11&nbsp;InnoDB Row Formats">Section&nbsp;14.11, “InnoDB Row Formats”</a>.
            </p><p style="color:blue;">梭鱼是最新的文件格式。它支持所有innodb行格式，包括新的压缩和动态行格式。与压缩和动态行格式相关联的特性包括压缩表、页外列的有效存储和索引键前缀（最多3072字节）（innodb_large_prefix）。见第14.11节，“InnoDB行格式”。</p></li></ul>
        </div>
        <p>
            This section discusses enabling <code class="literal">InnoDB</code> file
            formats for new <code class="literal">InnoDB</code> tables, verifying
            compatibility of different file formats between MySQL releases, and
            identifying the file format in use.
        </p><p style="color:blue;">本节讨论为新的innodb表启用innodb文件格式，验证mysql版本之间不同文件格式的兼容性，以及识别正在使用的文件格式。</p><p>
        InnoDB file format settings do not apply to tables stored in
        <a class="link" href="innodb-storage-engine.html#general-tablespaces" title="14.6.3.3&nbsp;General Tablespaces">general tablespaces</a>.
        General tablespaces provide support for all row formats and
        associated features. For more information, see
        <a class="xref" href="innodb-storage-engine.html#general-tablespaces" title="14.6.3.3&nbsp;General Tablespaces">Section&nbsp;14.6.3.3, “General Tablespaces”</a>.
    </p><p style="color:blue;">innodb文件格式设置不适用于存储在常规表空间中的表。通用表空间支持所有行格式和相关功能。有关更多信息，请参阅14.6.3.3节“常规表空间”。</p>
        <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">

            <div class="admon-title">
                Note
            </div>
            <p>
                The following file format configuration parameters have new
                default values:
            </p><p style="color:blue;">以下文件格式配置参数具有新的默认值：</p>
            <div class="itemizedlist">
                <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                    The <a class="link" href="innodb-storage-engine.html#sysvar_innodb_file_format"><code class="literal">innodb_file_format</code></a>
                    default value was changed to <code class="literal">Barracuda</code>. The
                    previous default value was <code class="literal">Antelope</code>.
                </p><p style="color:blue;">innodb_file_format默认值已更改为barracuda。以前的默认值是羚羊。</p></li><li class="listitem"><p>
                    The <a class="link" href="innodb-storage-engine.html#sysvar_innodb_large_prefix"><code class="literal">innodb_large_prefix</code></a>
                    default value was changed to <code class="literal">ON</code>. The
                    previous default was <code class="literal">OFF</code>.
                </p><p style="color:blue;">innodb_large_prefix默认值更改为on。以前的默认设置为关闭。</p></li></ul>
            </div>
            <p>
                The following file format configuration parameters are deprecated
                in and may be removed in a future release:
            </p><p style="color:blue;">以下文件格式配置参数在中已弃用，在以后的版本中可能会被删除：</p>
            <div class="itemizedlist">
                <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                    <a class="link" href="innodb-storage-engine.html#sysvar_innodb_file_format"><code class="literal">innodb_file_format</code></a>
                </p><p style="color:blue;">innodb_文件格式</p></li><li class="listitem"><p>
                    <a class="link" href="innodb-storage-engine.html#sysvar_innodb_file_format_check"><code class="literal">innodb_file_format_check</code></a>
                </p><p style="color:blue;">innodb_文件格式检查</p></li><li class="listitem"><p>
                    <a class="link" href="innodb-storage-engine.html#sysvar_innodb_file_format_max"><code class="literal">innodb_file_format_max</code></a>
                </p><p style="color:blue;">innodb_file_format_最大值</p></li><li class="listitem"><p>
                    <a class="link" href="innodb-storage-engine.html#sysvar_innodb_large_prefix"><code class="literal">innodb_large_prefix</code></a>
                </p><p style="color:blue;">innodb_large_前缀</p></li></ul>
            </div>
            <p>
                The file format configuration parameters were provided for
                creating tables compatible with earlier versions of
                <code class="literal">InnoDB</code> in MySQL 5.1. Now that MySQL 5.1 has
                reached the end of its product lifecycle, the parameters are no
                longer required.
            </p><p style="color:blue;">提供了文件格式配置参数，用于在mysql 5.1中创建与早期版本的innodb兼容的表。现在mysql 5.1已经到了产品生命周期的末尾，不再需要这些参数。</p>
        </div>
        <div class="section">
            <div class="titlepage">
                <div>
                    <div>
                        <h3 class="title"><a name="innodb-file-format-enabling"></a>14.10.1&nbsp;Enabling File Formats</h3>

                    </div>

                </div>

            </div>
            <p>
                The <a class="link" href="innodb-storage-engine.html#sysvar_innodb_file_format"><code class="literal">innodb_file_format</code></a>
                configuration option enables an <code class="literal">InnoDB</code> file
                format for
                <a class="link" href="glossary.html#glos_file_per_table" title="file-per-table">file-per-table</a>
                tablespaces.
            </p><p style="color:blue;">innodb_file_format配置选项为每个表空间的文件启用innodb文件格式。</p><p>
            <code class="literal">Barracuda</code> is the default
            <a class="link" href="innodb-storage-engine.html#sysvar_innodb_file_format"><code class="literal">innodb_file_format</code></a> setting. In
            earlier releases, the default file format was
            <code class="literal">Antelope</code>.
        </p><p style="color:blue;">Barracuda是默认的innodb_file_格式设置。在早期版本中，默认的文件格式是antelope。</p>
            <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">

                <div class="admon-title">
                    Note
                </div>
                <p>
                    The <a class="link" href="innodb-storage-engine.html#sysvar_innodb_file_format"><code class="literal">innodb_file_format</code></a>
                    configuration option is deprecated and may be removed in a
                    future release. For more information, see
                    <a class="xref" href="innodb-storage-engine.html#innodb-file-format" title="14.10&nbsp;InnoDB File-Format Management">Section&nbsp;14.10, “InnoDB File-Format Management”</a>.
                </p><p style="color:blue;">InnoDB_file_format configuration选项已被弃用，可能会在以后的版本中删除。有关更多信息，请参阅14.10节，“InnoDB文件格式管理”。</p>
            </div>
            <p>
                You can set the value of
                <a class="link" href="innodb-storage-engine.html#sysvar_innodb_file_format"><code class="literal">innodb_file_format</code></a> on the command
                line when you start <a class="link" href="programs.html#mysqld" title="4.3.1&nbsp;mysqld — The MySQL Server"><span class="command"><strong>mysqld</strong></span></a>, or in the option
                file (<code class="filename">my.cnf</code> on Unix,
                <code class="filename">my.ini</code> on Windows). You can also change it
                dynamically with a <code class="literal">SET GLOBAL</code> statement.
            </p><p style="color:blue;">启动mysqld时，可以在命令行或选项文件（UNIX上的my.cnf，Windows上的my.ini）中设置innodb_file_格式的值。您还可以使用set global语句动态更改它。</p><pre data-lang="sql" class="programlisting">SET GLOBAL innodb_file_format=Barracuda;
</pre>
            <h4><a name="idm140286818287744"></a>Usage notes</h4>
            <div class="itemizedlist">
                <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                    <code class="literal">InnoDB</code> file format settings do not apply to
                    tables stored in <a class="link" href="innodb-storage-engine.html#general-tablespaces" title="14.6.3.3&nbsp;General Tablespaces">general
                    tablespaces</a>. General tablespaces provide support for
                    all row formats and associated features. For more information,
                    see <a class="xref" href="innodb-storage-engine.html#general-tablespaces" title="14.6.3.3&nbsp;General Tablespaces">Section&nbsp;14.6.3.3, “General Tablespaces”</a>.
                </p><p style="color:blue;">innodb文件格式设置不适用于存储在常规表空间中的表。通用表空间支持所有行格式和相关功能。有关更多信息，请参阅14.6.3.3节“常规表空间”。</p></li><li class="listitem"><p>
                    The <a class="link" href="innodb-storage-engine.html#sysvar_innodb_file_format"><code class="literal">innodb_file_format</code></a>
                    setting is not applicable when using the <code class="literal">TABLESPACE
                    [=] innodb_system</code> table option with
                    <a class="link" href="sql-syntax.html#create-table" title="13.1.18&nbsp;CREATE TABLE Syntax"><code class="literal">CREATE TABLE</code></a> or
                    <a class="link" href="sql-syntax.html#alter-table" title="13.1.8&nbsp;ALTER TABLE Syntax"><code class="literal">ALTER TABLE</code></a> to store a
                    <code class="literal">DYNAMIC</code> table in the system tablespace.
                </p><p style="color:blue;">当使用tablespace[=]innodb_system table选项和create table或alter table在系统表空间中存储动态表时，innodb_file_格式设置不适用。</p></li><li class="listitem"><p>
                    The <a class="link" href="innodb-storage-engine.html#sysvar_innodb_file_format"><code class="literal">innodb_file_format</code></a>
                    setting is ignored when creating tables that use the
                    <code class="literal">DYNAMIC</code> row format. For more information,
                    see <a class="xref" href="innodb-storage-engine.html#innodb-row-format-dynamic" title="DYNAMIC Row Format">DYNAMIC Row Format</a>.
                </p><p style="color:blue;">创建使用动态行格式的表时，忽略innodb_file_format设置。有关详细信息，请参见动态行格式。</p></li></ul>
            </div>

        </div>
        <div class="section">
            <div class="titlepage">
                <div>
                    <div>
                        <h3 class="title"><a name="innodb-file-format-compatibility"></a>14.10.2&nbsp;Verifying File Format Compatibility</h3>

                    </div>

                </div>

            </div>
            <div class="toc">
                <dl class="toc"><dt><span class="section"><a href="innodb-storage-engine.html#innodb-file-format-compatibility-checking">14.10.2.1 Compatibility Check When InnoDB Is Started</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-file-format-compatibility-checking-table-access">14.10.2.2 Compatibility Check When a Table Is Opened</a></span></dt></dl>
            </div>
            <a class="indexterm" name="idm140286818272528"></a><p>
            InnoDB incorporates several checks to guard against the possible
            crashes and data corruptions that might occur if you run an old
            release of the MySQL server on InnoDB data files that use a newer
            file format. These checks take place when the server is started,
            and when you first access a table. This section describes these
            checks, how you can control them, and error and warning conditions
            that might arise.
        </p><p style="color:blue;">innodb合并了几个检查，以防止在使用较新文件格式的innodb数据文件上运行旧版本的mysql服务器时可能发生的崩溃和数据损坏。这些检查在服务器启动和首次访问表时进行。本节介绍这些检查、如何控制它们以及可能出现的错误和警告条件。</p>
            <h4><a name="idm140286818270592"></a>Backward Compatibility</h4>
            <p>
                You only need to consider backward file format compatibility when
                using a recent version of InnoDB (MySQL 5.5 and higher with
                InnoDB) alongside an older version (MySQL 5.1 or earlier, with the
                built-in InnoDB rather than the InnoDB Plugin). To minimize the
                chance of compatibility issues, you can standardize on the InnoDB
                Plugin for all your MySQL 5.1 and earlier database servers.
            </p><p style="color:blue;">在使用最新版本的innodb（mysql 5.5和更高版本的innodb）和旧版本（mysql 5.1或更早版本的innodb，内置innodb而不是innodb插件）时，只需考虑向后文件格式兼容性。为了将兼容性问题的可能性降到最低，您可以为所有mysql 5.1和更早版本的数据库服务器标准化innodb插件。</p><p>
            In general, a newer version of InnoDB may create a table or index
            that cannot safely be read or written with an older version of
            InnoDB without risk of crashes, hangs, wrong results or
            corruptions. InnoDB includes a mechanism to guard against these
            conditions, and to help preserve compatibility among database
            files and versions of InnoDB. This mechanism lets you take
            advantage of some new features of an InnoDB release (such as
            performance improvements and bug fixes), and still preserve the
            option of using your database with an old version of InnoDB, by
            preventing accidental use of new features that create
            downward-incompatible disk files.
        </p><p style="color:blue;">一般来说，新版本的innodb可能会创建一个不能用旧版本的innodb安全读写的表或索引，而不会有崩溃、挂起、错误结果或损坏的风险。innodb包含一种机制来防范这些情况，并帮助保持数据库文件和innodb版本之间的兼容性。此机制允许您利用InnoDB版本的一些新特性（例如性能改进和错误修复），并且仍然保留将数据库与旧版本InnoDB一起使用的选项，防止意外使用创建向下不兼容磁盘文件的新特性。</p><p>
            If a version of InnoDB supports a particular file format (whether
            or not that format is the default), you can query and update any
            table that requires that format or an earlier format. Only the
            creation of new tables using new features is limited based on the
            particular file format enabled. Conversely, if a tablespace
            contains a table or index that uses a file format that is not
            supported, it cannot be accessed at all, even for read access.
        </p><p style="color:blue;">如果innodb版本支持特定的文件格式（无论该格式是否为默认格式），您可以查询和更新任何需要该格式或更早格式的表。根据启用的特定文件格式，仅使用新功能创建新表受到限制。相反，如果表空间包含使用不受支持的文件格式的表或索引，则根本无法访问该表或索引，甚至无法进行读取访问。</p><p>
            The only way to <span class="quote">“<span class="quote">downgrade</span>”</span> an InnoDB tablespace to
            the earlier Antelope file format is to copy the data to a new
            table, in a tablespace that uses the earlier format.
        </p><p style="color:blue;">将innodb表空间“降级”为早期羚羊文件格式的唯一方法是将数据复制到使用早期格式的表空间中的新表中。</p><p>
            The easiest way to determine the file format of an existing InnoDB
            tablespace is to examine the properties of the table it contains,
            using the <code class="literal">SHOW TABLE STATUS</code> command or querying
            the table <code class="literal">INFORMATION_SCHEMA.TABLES</code>. If the
            <code class="literal">Row_format</code> of the table is reported as
            <code class="literal">'Compressed'</code> or <code class="literal">'Dynamic'</code>,
            the tablespace containing the table supports the Barracuda format.
        </p><p style="color:blue;">确定现有的NIDDB表空间的文件格式最简单的方法是使用显示表状态命令或查询表IdvIsStudio表检查其包含的表的属性。如果表的row_格式报告为“compressed”或“dynamic”，则包含该表的表空间支持barracuda格式。</p>
            <h4><a name="idm140286818261776"></a>Internal Details</h4>
            <p>
                Every InnoDB file-per-table tablespace (represented by a
                <code class="literal">*.ibd</code> file) file is labeled with a file format
                identifier. The system tablespace (represented by the
                <code class="literal">ibdata</code> files) is tagged with the
                <span class="quote">“<span class="quote">highest</span>”</span> file format in use in a group of InnoDB
                database files, and this tag is checked when the files are opened.
            </p><p style="color:blue;">每个innodb文件每个表空间（由一个*.ibd文件表示）文件都有一个文件格式标识符。系统表空间（由ibdata文件表示）被标记为一组innodb数据库文件中使用的“最高”文件格式，并且在文件打开时检查此标记。</p><p>
            Creating a compressed table, or a table with
            <code class="literal">ROW_FORMAT=DYNAMIC</code>, updates the file header of
            the corresponding file-per-table <code class="literal">.ibd</code> file and
            the table type in the InnoDB data dictionary with the identifier
            for the Barracuda file format. From that point forward, the table
            cannot be used with a version of InnoDB that does not support the
            Barracuda file format. To protect against anomalous behavior,
            InnoDB performs a compatibility check when the table is opened.
            (In many cases, the <a class="link" href="sql-syntax.html#alter-table" title="13.1.8&nbsp;ALTER TABLE Syntax"><code class="literal">ALTER TABLE</code></a>
            statement recreates a table and thus changes its properties. The
            special case of adding or dropping indexes without rebuilding the
            table is described in
            <a class="xref" href="innodb-storage-engine.html#innodb-online-ddl-operations" title="14.13.1&nbsp;Online DDL Operations">Section&nbsp;14.13.1, “Online DDL Operations”</a>.)
        </p><p style="color:blue;">创建一个压缩表，或者一个row_format=dynamic的表，用barracuda文件格式的标识符更新每个table.ibd文件对应文件的文件头和innodb数据字典中的表类型。从那时起，该表不能与不支持Barracuda文件格式的InnoDB版本一起使用。为了防止异常行为，innodb在打开表时执行兼容性检查。（在许多情况下，alter table语句重新创建一个表，从而更改其属性。在14.13.1节“联机DDL操作”中描述了在不重建表的情况下添加或删除索引的特殊情况。</p><p>
            General tablespaces, which are also represented by a
            <code class="literal">*.ibd</code> file, support both Antelope and Barracuda
            file formats. For more information about general tablespaces, see
            <a class="xref" href="innodb-storage-engine.html#general-tablespaces" title="14.6.3.3&nbsp;General Tablespaces">Section&nbsp;14.6.3.3, “General Tablespaces”</a>.
        </p><p style="color:blue;">通用表空间也由*.ibd文件表示，支持羚羊和梭鱼文件格式。有关通用表空间的更多信息，请参阅14.6.3.3节“通用表空间”。</p>
            <h4><a name="idm140286818252144"></a>Definition of ib-file set</h4>
            <p>
                To avoid confusion, for the purposes of this discussion we define
                the term <span class="quote">“<span class="quote">ib-file set</span>”</span> to mean the set of operating
                system files that InnoDB manages as a unit. The ib-file set
                includes the following files:
            </p><p style="color:blue;">为了避免混淆，在本讨论中，我们将术语“ib文件集”定义为innodb作为一个单元管理的操作系统文件集。IB文件集包括以下文件：</p>
            <div class="itemizedlist">
                <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                    The system tablespace (one or more <code class="literal">ibdata</code>
                    files) that contain internal system information (including
                    internal catalogs and undo information) and may include user
                    data and indexes.
                </p><p style="color:blue;">系统表空间（一个或多个ibdata文件），其中包含内部系统信息（包括内部编目和撤消信息），并且可以包括用户数据和索引。</p></li><li class="listitem"><p>
                    Zero or more single-table tablespaces (also called <span class="quote">“<span class="quote">file
          per table</span>”</span> files, named <code class="literal">*.ibd</code>
                    files).
                </p><p style="color:blue;">零个或多个单表表空间（也称为“每表文件”，名为*.ibd文件）。</p></li><li class="listitem"><p>
                    InnoDB log files; usually two, <code class="literal">ib_logfile0</code>
                    and <code class="literal">ib_logfile1</code>. Used for crash recovery
                    and in backups.
                </p><p style="color:blue;">InnoDB日志文件；通常是两个，ib_logfile0和ib_logfile1。用于崩溃恢复和备份。</p></li></ul>
            </div>
            <p>
                An <span class="quote">“<span class="quote">ib-file set</span>”</span> does not include the corresponding
                <code class="filename">.frm</code> files that contain metadata about InnoDB
                tables. The <code class="filename">.frm</code> files are created and
                managed by MySQL, and can sometimes get out of sync with the
                internal metadata in InnoDB.
            </p><p style="color:blue;">“IB文件集”不包含包含InnoDB表元数据的相应.frm文件。.frm文件由mysql创建和管理，有时可能与innodb中的内部元数据不同步。</p><p>
            Multiple tables, even from more than one database, can be stored
            in a single <span class="quote">“<span class="quote">ib-file set</span>”</span>. (In MySQL, a
            <span class="quote">“<span class="quote">database</span>”</span> is a logical collection of tables, what
            other systems refer to as a <span class="quote">“<span class="quote">schema</span>”</span> or
            <span class="quote">“<span class="quote">catalog</span>”</span>.)
        </p><p style="color:blue;">多个表（甚至来自多个数据库）可以存储在单个“ib文件集中”。（在mysql中，“数据库”是表的逻辑集合，其他系统称之为“模式”或“目录”。）</p>
            <div class="section">

                <div class="titlepage">
                    <div>
                        <div>
                            <h4 class="title"><a name="innodb-file-format-compatibility-checking"></a>14.10.2.1&nbsp;Compatibility Check When InnoDB Is Started</h4>
                        </div>
                    </div>
                </div>
                <a class="indexterm" name="idm140286818237792"></a><a class="indexterm" name="idm140286818236704"></a><p>
                To prevent possible crashes or data corruptions when InnoDB
                opens an ib-file set, it checks that it can fully support the
                file formats in use within the ib-file set. If the system is
                restarted following a crash, or a <span class="quote">“<span class="quote">fast shutdown</span>”</span>
                (i.e., <a class="link" href="innodb-storage-engine.html#sysvar_innodb_fast_shutdown"><code class="literal">innodb_fast_shutdown</code></a> is
                greater than zero), there may be on-disk data structures (such
                as redo or undo entries, or doublewrite pages) that are in a
                <span class="quote">“<span class="quote">too-new</span>”</span> format for the current software. During
                the recovery process, serious damage can be done to your data
                files if these data structures are accessed. The startup check
                of the file format occurs before any recovery process begins,
                thereby preventing consistency issues with the new tables or
                startup problems for the MySQL server.
            </p><p style="color:blue;">为了防止innodb打开ib文件集时可能发生的崩溃或数据损坏，它会检查是否能够完全支持ib文件集中使用的文件格式。如果系统在崩溃或“快速关机”（即innodb_fast_shutdown大于零）后重新启动，则可能存在磁盘上的数据结构（如重做或撤消条目或双写页），其格式对于当前软件来说“太新”。在恢复过程中，如果访问这些数据结构，可能会严重损坏数据文件。文件格式的启动检查在任何恢复过程开始之前进行，从而防止与新表的一致性问题或mysql服务器的启动问题。</p><p>
                Beginning with version InnoDB 1.0.1, the system tablespace
                records an identifier or tag for the <span class="quote">“<span class="quote">highest</span>”</span> file
                format used by any table in any of the tablespaces that is part
                of the ib-file set. Checks against this file format tag are
                controlled by the configuration parameter
                <a class="link" href="innodb-storage-engine.html#sysvar_innodb_file_format_check"><code class="literal">innodb_file_format_check</code></a>, which
                is <code class="literal">ON</code> by default.
            </p><p style="color:blue;">从innodb 1.0.1版开始，系统表空间记录ib文件集中任何表空间中任何表使用的“最高”文件格式的标识符或标记。对该文件格式标记的检查由配置参数innodb_file_format_check控制，该参数在默认情况下处于启用状态。</p><p>
                If the file format tag in the system tablespace is newer or
                higher than the highest version supported by the particular
                currently executing software and if
                <a class="link" href="innodb-storage-engine.html#sysvar_innodb_file_format_check"><code class="literal">innodb_file_format_check</code></a> is
                <code class="literal">ON</code>, the following error is issued when the
                server is started:
            </p><p style="color:blue;">如果系统表空间中的文件格式标记比当前执行的特定软件支持的最高版本更新或更高，并且如果innodb_file_format_check处于打开状态，则在启动服务器时会发出以下错误：</p><pre data-lang="terminal" class="programlisting">InnoDB: Error: the system tablespace is in a
file format that this version doesn't support
</pre><p>
                You can also set
                <a class="link" href="innodb-storage-engine.html#sysvar_innodb_file_format"><code class="literal">innodb_file_format</code></a> to a file
                format name. Doing so prevents InnoDB from starting if the
                current software does not support the file format specified. It
                also sets the <span class="quote">“<span class="quote">high water mark</span>”</span> to the value you
                specify. The ability to set
                <a class="link" href="innodb-storage-engine.html#sysvar_innodb_file_format_check"><code class="literal">innodb_file_format_check</code></a> is
                useful (with future releases) if you manually
                <span class="quote">“<span class="quote">downgrade</span>”</span> all of the tables in an ib-file set.
                You can then rely on the file format check at startup if you
                subsequently use an older version of InnoDB to access the
                ib-file set.
            </p><p style="color:blue;">您还可以将innodb_file_format设置为文件格式名。如果当前软件不支持指定的文件格式，那么这样做会阻止innodb启动。它还将“高水位线”设置为您指定的值。如果您手动“降级”ib文件集中的所有表，那么设置innodb_file_format_check的功能非常有用（在将来的版本中）。如果随后使用较旧版本的innodb访问ib文件集，那么可以在启动时依赖文件格式检查。</p><p>
                In some limited circumstances, you might want to start the
                server and use an ib-file set that is in a new file format that
                is not supported by the software you are using. If you set the
                configuration parameter
                <a class="link" href="innodb-storage-engine.html#sysvar_innodb_file_format_check"><code class="literal">innodb_file_format_check</code></a> to
                <code class="literal">OFF</code>, InnoDB opens the database, but issues
                this warning message in the error log:
            </p><p style="color:blue;">在某些有限的情况下，您可能希望启动服务器并使用所用软件不支持的新文件格式的IB文件集。如果将配置参数innodb_file_format_check设置为off，innodb将打开数据库，但在错误日志中发出此警告消息：</p><pre data-lang="terminal" class="programlisting">InnoDB: Warning: the system tablespace is in a
file format that this version doesn't support
</pre>
                <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">

                    <div class="admon-title">
                        Note
                    </div>
                    <p>
                        This is a dangerous setting, as it permits the recovery
                        process to run, possibly corrupting your database if the
                        previous shutdown was a crash or <span class="quote">“<span class="quote">fast shutdown</span>”</span>.
                        You should only set
                        <a class="link" href="innodb-storage-engine.html#sysvar_innodb_file_format_check"><code class="literal">innodb_file_format_check</code></a> to
                        <code class="literal">OFF</code> if you are sure that the previous
                        shutdown was done with
                        <code class="literal">innodb_fast_shutdown=0</code>, so that essentially
                        no recovery process occurs.
                    </p><p style="color:blue;">这是一个危险的设置，因为它允许恢复进程运行，如果上次关机是崩溃或“快速关机”，则可能会损坏数据库。如果您确定上一次关机是在innodb_fast_shutdown=0的情况下完成的，那么您应该将innodb_file_format_check设置为off，这样基本上就不会发生恢复过程。</p>
                </div>
                <p>
                    The parameter
                    <a class="link" href="innodb-storage-engine.html#sysvar_innodb_file_format_check"><code class="literal">innodb_file_format_check</code></a>
                    affects only what happens when a database is opened, not
                    subsequently. Conversely, the parameter
                    <a class="link" href="innodb-storage-engine.html#sysvar_innodb_file_format"><code class="literal">innodb_file_format</code></a> (which
                    enables a specific format) only determines whether or not a new
                    table can be created in the enabled format and has no effect on
                    whether or not a database can be opened.
                </p><p style="color:blue;">参数innodb_file_format_check只影响打开数据库时发生的情况，而不是随后发生的情况。相反，参数innodb_file_format（启用特定格式）只决定是否可以使用启用的格式创建新表，而不影响是否可以打开数据库。</p><p>
                The file format tag is a <span class="quote">“<span class="quote">high water mark</span>”</span>, and as
                such it is increased after the server is started, if a table in
                a <span class="quote">“<span class="quote">higher</span>”</span> format is created or an existing table
                is accessed for read or write (assuming its format is
                supported). If you access an existing table in a format higher
                than the format the running software supports, the system
                tablespace tag is not updated, but table-level compatibility
                checking applies (and an error is issued), as described in
                <a class="xref" href="innodb-storage-engine.html#innodb-file-format-compatibility-checking-table-access" title="14.10.2.2&nbsp;Compatibility Check When a Table Is Opened">Section&nbsp;14.10.2.2, “Compatibility Check When a Table Is Opened”</a>.
                Any time the high water mark is updated, the value of
                <a class="link" href="innodb-storage-engine.html#sysvar_innodb_file_format_check"><code class="literal">innodb_file_format_check</code></a> is
                updated as well, so the command <code class="literal">SELECT
                @@innodb_file_format_check;</code> displays the name of the
                latest file format known to be used by tables in the currently
                open ib-file set and supported by the currently executing
                software.
            </p><p style="color:blue;">文件格式标签是一个“高水位标志”，因此，在服务器启动后，如果创建一个“更高”格式的表或访问一个现有的表进行读取或写入（假设其格式被支持），则会增加该标签。如果您以高于运行软件支持的格式访问现有表，则不更新系统表空间标记，而是应用表级兼容性检查（并发出错误），如第14节中所描述的“打开表时的兼容性检查”。每当高水位线被更新时，innodb_file_format_check的值也会被更新，因此命令select@@innodb_file_format_check；显示当前打开的ib文件集中的表使用的、当前执行软件支持的最新文件格式的名称。</p>
            </div>
            <div class="section">
                <div class="titlepage">
                    <div>
                        <div>
                            <h4 class="title"><a name="innodb-file-format-compatibility-checking-table-access"></a>14.10.2.2&nbsp;Compatibility Check When a Table Is Opened</h4>

                        </div>

                    </div>

                </div>
                <p>
                    When a table is first accessed, InnoDB (including some releases
                    prior to InnoDB 1.0) checks that the file format of the
                    tablespace in which the table is stored is fully supported. This
                    check prevents crashes or corruptions that would otherwise occur
                    when tables using a <span class="quote">“<span class="quote">too new</span>”</span> data structure are
                    encountered.
                </p><p style="color:blue;">第一次访问表时，innodb（包括innodb 1.0之前的一些版本）检查存储表的表空间的文件格式是否完全受支持。此检查可防止在遇到使用“太新”数据结构的表时发生崩溃或损坏。</p><p>
                All tables using any file format supported by a release can be
                read or written (assuming the user has sufficient privileges).
                The setting of the system configuration parameter
                <a class="link" href="innodb-storage-engine.html#sysvar_innodb_file_format"><code class="literal">innodb_file_format</code></a> can prevent
                creating a new table that uses a specific file format, even if
                the file format is supported by a given release. Such a setting
                might be used to preserve backward compatibility, but it does
                not prevent accessing any table that uses a supported format.
            </p><p style="color:blue;">使用发行版支持的任何文件格式的所有表都可以读取或写入（假设用户有足够的权限）。系统配置参数innodb_file_format的设置可以防止创建使用特定文件格式的新表，即使给定版本支持该文件格式。这样的设置可以用来保持向后兼容性，但它不会阻止访问使用受支持格式的任何表。</p><p>
                Versions of MySQL older than 5.0.21 cannot reliably use database
                files created by newer versions if a new file format was used
                when a table was created. To prevent various error conditions or
                corruptions, InnoDB checks file format compatibility when it
                opens a file (for example, upon first access to a table). If the
                currently running version of InnoDB does not support the file
                format identified by the table type in the InnoDB data
                dictionary, MySQL reports the following error:
            </p><p style="color:blue;">如果在创建表时使用了新的文件格式，则5.0.21之前的mysql版本无法可靠地使用较新版本创建的数据库文件。为了防止各种错误情况或损坏，innodb在打开文件时（例如，第一次访问表时）检查文件格式兼容性。如果当前运行的innodb版本不支持innodb数据字典中的表类型所标识的文件格式，mysql将报告以下错误：</p><pre data-lang="terminal" class="programlisting">ERROR 1146 (42S02): Table '<em class="replaceable"><code>test</code></em>.<em class="replaceable"><code>t1</code></em>' doesn't exist
</pre><p>
                InnoDB also writes a message to the error log:
            </p><p style="color:blue;">InnoDB还将一条消息写入错误日志：</p><pre data-lang="terminal" class="programlisting">InnoDB: table <em class="replaceable"><code>test</code></em>/<em class="replaceable"><code>t1</code></em>: unknown table type <em class="replaceable"><code>33</code></em>
</pre><p>
                The table type should be equal to the tablespace flags, which
                contains the file format version as discussed in
                <a class="xref" href="innodb-storage-engine.html#innodb-file-format-identifying" title="14.10.3&nbsp;Identifying the File Format in Use">Section&nbsp;14.10.3, “Identifying the File Format in Use”</a>.
            </p><p style="color:blue;">表类型应等于表空间标志，其中包含第14.10.3节“识别使用中的文件格式”中讨论的文件格式版本。</p><p>
                Versions of InnoDB prior to MySQL 4.1 did not include table
                format identifiers in the database files, and versions prior to
                MySQL 5.0.21 did not include a table format compatibility check.
                Therefore, there is no way to ensure proper operations if a
                table in a newer file format is used with versions of InnoDB
                prior to 5.0.21.
            </p><p style="color:blue;">MySQL4.1之前的InnoDB版本没有在数据库文件中包含表格式标识符，MySQL5.0.21之前的版本没有包含表格式兼容性检查。因此，如果5.0.21之前的innodb版本使用了更新文件格式的表，则无法确保正确的操作。</p><p>
                The file format management capability in InnoDB 1.0 and higher
                (tablespace tagging and run-time checks) allows InnoDB to verify
                as soon as possible that the running version of software can
                properly process the tables existing in the database.
            </p><p style="color:blue;">InDB 1和更高的文件格式管理能力（表空间标记和运行时检查）允许UnIDB尽快验证运行的软件版本能够正确地处理数据库中存在的表。</p><p>
                If you permit InnoDB to open a database containing files in a
                format it does not support (by setting the parameter
                <a class="link" href="innodb-storage-engine.html#sysvar_innodb_file_format_check"><code class="literal">innodb_file_format_check</code></a> to
                <code class="literal">OFF</code>), the table-level checking described in
                this section still applies.
            </p><p style="color:blue;">如果您允许innodb以它不支持的格式打开包含文件的数据库（通过将参数innodb_file_format_check设置为off），本节中描述的表级检查仍然适用。</p><p>
                Users are <span class="emphasis"><em>strongly</em></span> urged not to use
                database files that contain Barracuda file format tables with
                releases of InnoDB older than the MySQL 5.1 with the InnoDB
                Plugin. It may be possible to rebuild such tables to use the
                Antelope format.
            </p><p style="color:blue;">强烈建议用户不要使用包含Barracuda文件格式表的数据库文件，这些文件的InnoDB版本比带有InnoDB插件的MySQL5.1版本早。也许可以重建这样的表以使用羚羊格式。</p>
            </div>

        </div>
        <div class="section">
            <div class="titlepage">
                <div>
                    <div>
                        <h3 class="title"><a name="innodb-file-format-identifying"></a>14.10.3&nbsp;Identifying the File Format in Use</h3>

                    </div>

                </div>

            </div>
            <a class="indexterm" name="idm140286818186416"></a><a class="indexterm" name="idm140286818184928"></a><p>
            If you enable a different <a class="link" href="glossary.html#glos_file_format" title="file format">file
            format</a> using the
            <a class="link" href="innodb-storage-engine.html#sysvar_innodb_file_format"><code class="literal">innodb_file_format</code></a> configuration
            option, the change only applies to newly created tables. Also,
            when you create a new table, the tablespace containing the table
            is tagged with the <span class="quote">“<span class="quote">earliest</span>”</span> or
            <span class="quote">“<span class="quote">simplest</span>”</span> file format that is required to support
            the table's features. For example, if you enable the
            <code class="literal">Barracuda</code> file format, and create a new table
            that does not use the Dynamic or Compressed row format, the new
            tablespace that contains the table is tagged as using the
            <code class="literal">Antelope</code> file format .
        </p><p style="color:blue;">如果使用innodb_file_format配置选项启用不同的文件格式，则更改仅适用于新创建的表。此外，当您创建新表时，包含该表的表空间将被标记为支持该表功能所需的“最早”或“最简单”文件格式。例如，如果启用梭鱼文件格式，并创建不使用动态或压缩行格式的新表，则包含该表的新表空间将标记为使用羚羊文件格式。</p><p>
            It is easy to identify the file format used by a given table. The
            table uses the <code class="literal">Antelope</code> file format if the row
            format reported by <code class="literal">SHOW TABLE STATUS</code> is either
            <code class="literal">Compact</code> or <code class="literal">Redundant</code>. The
            table uses the <code class="literal">Barracuda</code> file format if the row
            format reported by <code class="literal">SHOW TABLE STATUS</code> is either
            <code class="literal">Compressed</code> or <code class="literal">Dynamic</code>.
        </p><p style="color:blue;">很容易识别给定表使用的文件格式。如果show table status报告的行格式为compact或redundant，则该表使用羚羊文件格式。如果show table status报告的行格式为compressed或dynamic，则该表使用梭鱼文件格式。</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>SHOW TABLE STATUS\G</code></strong>
*************************** 1. row ***************************
           Name: t1
         Engine: InnoDB
        Version: 10
     Row_format: Compact
           Rows: 0
 Avg_row_length: 0
    Data_length: 16384
Max_data_length: 0
   Index_length: 16384
      Data_free: 0
 Auto_increment: 1
    Create_time: 2014-11-03 13:32:10
    Update_time: NULL
     Check_time: NULL
      Collation: latin1_swedish_ci
       Checksum: NULL
 Create_options:
        Comment:</pre><p>
            You can also identify the file format used by a given table or
            tablespace using <code class="literal">InnoDB</code>
            <code class="literal">INFORMATION_SCHEMA</code> tables. For example:
        </p><p style="color:blue;">您还可以使用innodb information_schema tables标识给定表或表空间使用的文件格式。例如：</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT * FROM INFORMATION_SCHEMA.INNODB_SYS_TABLES WHERE NAME='test/t1'\G</code></strong>
*************************** 1. row ***************************
     TABLE_ID: 44
         NAME: test/t1
         FLAG: 1
       N_COLS: 6
        SPACE: 30
  FILE_FORMAT: Antelope
   ROW_FORMAT: Compact
ZIP_PAGE_SIZE: 0

mysql&gt; <strong class="userinput"><code>SELECT * FROM INFORMATION_SCHEMA.INNODB_SYS_TABLESPACES WHERE NAME='test/t1'\G</code></strong>
*************************** 1. row ***************************
        SPACE: 30
         NAME: test/t1
         FLAG: 0
  FILE_FORMAT: Antelope
   ROW_FORMAT: Compact or Redundant
    PAGE_SIZE: 16384
ZIP_PAGE_SIZE: 0
</pre>
        </div>
        <div class="section">
            <div class="titlepage">
                <div>
                    <div>
                        <h3 class="title"><a name="innodb-file-format-downgrading"></a>14.10.4&nbsp;Modifying the File Format</h3>

                    </div>

                </div>

            </div>
            <a class="indexterm" name="idm140286818163152"></a><p>
            Each InnoDB tablespace file (with a name matching
            <code class="literal">*.ibd</code>) is tagged with the file format used to
            create its table and indexes. The way to modify the file format is
            to re-create the table and its indexes. The easiest way to
            recreate a table and its indexes is to use the following command
            on each table that you want to modify:
        </p><p style="color:blue;">每个innodb表空间文件（其名称与*.ibd匹配）都被标记为用于创建其表和索引的文件格式。修改文件格式的方法是重新创建表及其索引。重新创建表及其索引的最简单方法是对要修改的每个表使用以下命令：</p><pre data-lang="sql" class="programlisting">ALTER TABLE <em class="replaceable"><code>t</code></em> ROW_FORMAT=<em class="replaceable"><code>format_name</code></em>;
</pre><p>
            If you are modifying the file format to downgrade to an older
            MySQL version, there may be incompatibilities in table storage
            formats that require additional steps. For information about
            downgrading to a previous MySQL version, see
            <a class="xref" href="installing.html#downgrading" title="2.12&nbsp;Downgrading MySQL">Section&nbsp;2.12, “Downgrading MySQL”</a>.
        </p><p style="color:blue;">如果修改文件格式以降级到较旧的mysql版本，则表存储格式中可能存在不兼容，需要执行其他步骤。有关降级到早期mysql版本的信息，请参阅2.12节“降级mysql”。</p>
        </div>

    </div>
    <div class="section">
        <div class="titlepage">
            <div>
                <div>
                    <h2 class="title" style="clear: both"><a name="innodb-row-format"></a>14.11&nbsp;InnoDB Row Formats</h2>

                </div>

            </div>

        </div>
        <p>
            The row format of a table determines how its rows are physically
            stored, which in turn can affect the performance of queries and DML
            operations. As more rows fit into a single disk page, queries and
            index lookups can work faster, less cache memory is required in the
            buffer pool, and less I/O is required to write out updated values.
        </p><p style="color:blue;">表的行格式决定了它的行是如何物理存储的，这反过来又会影响查询和DML操作的性能。随着在单个磁盘页中容纳更多行，查询和索引查找可以更快地工作，缓冲池中所需的缓存内存更少，写入更新值所需的I/O更少。</p><p>
        The data in each table is divided into pages. The pages that make up
        each table are arranged in a tree data structure called a B-tree
        index. Table data and secondary indexes both use this type of
        structure. The B-tree index that represents an entire table is known
        as the clustered index, which is organized according to the primary
        key columns. The nodes of a clustered index data structure contain
        the values of all columns in the row. The nodes of a secondary index
        structure contain the values of index columns and primary key
        columns.
    </p><p style="color:blue;">每个表中的数据被分成几页。组成每个表的页都排列在一个称为b树索引的树数据结构中。表数据和辅助索引都使用这种类型的结构。表示整个表的B树索引称为聚集索引，它根据主键列进行组织。聚集索引数据结构的节点包含行中所有列的值。辅助索引结构的节点包含索引列和主键列的值。</p><p>
        Variable-length columns are an exception to the rule that column
        values are stored in B-tree index nodes. Variable-length columns
        that are too long to fit on a B-tree page are stored on separately
        allocated disk pages called overflow pages. Such columns are
        referred to as off-page columns. The values of off-page columns are
        stored in singly-linked lists of overflow pages, with each such
        column having its own list of one or more overflow pages. Depending
        on column length, all or a prefix of variable-length column values
        are stored in the B-tree to avoid wasting storage and having to read
        a separate page.
    </p><p style="color:blue;">对于列值存储在B树索引节点中的规则，可变长度列是一个例外。长度可变的列太长，无法放在B树页上，这些列存储在单独分配的称为溢出页的磁盘页上。此类列称为页外列。页外列的值存储在溢出页的单个链接列表中，每个此类列都有自己的一个或多个溢出页列表。根据列的长度，可变长度列值的全部或前缀都存储在b树中，以避免浪费存储空间和读取单独的页。</p><p>
        The <code class="literal">InnoDB</code> storage engine supports four row
        formats: <code class="literal">REDUNDANT</code>, <code class="literal">COMPACT</code>,
        <code class="literal">DYNAMIC</code>, and <code class="literal">COMPRESSED</code>.
    </p><p style="color:blue;">InnoDB存储引擎支持四种行格式：冗余、压缩、动态和压缩。</p>
        <div class="table">
            <a name="innodb-row-format-overview"></a><p class="title"><b>Table&nbsp;14.10&nbsp;InnoDB Row Format Overview</b></p><p style="color:blue;">表14.10 InnoDB行格式概述</p>
            <div class="table-contents">
                <table summary="Overview of InnoDB row formats incuding a description, supported features, and supported tablespace types."><colgroup><col width="10%"><col width="15%"><col width="15%"><col width="15%"><col width="15%"><col width="15%"><col width="15%"></colgroup><thead><tr>
                    <th scope="col">Row Format</th>
                    <th scope="col">Compact Storage Characteristics</th>
                    <th scope="col">Enhanced Variable-Length Column Storage</th>
                    <th scope="col">Large Index Key Prefix Support</th>
                    <th scope="col">Compression Support</th>
                    <th scope="col">Supported Tablespace Types</th>
                    <th scope="col">Required File Format</th>
                </tr></thead><tbody><tr>
                    <td scope="row"><code class="literal">REDUNDANT</code></td>
                    <td>No</td>
                    <td>No</td>
                    <td>No</td>
                    <td>No</td>
                    <td>system, file-per-table, general</td>
                    <td>Antelope or Barracuda</td>
                </tr><tr>
                    <td scope="row"><code class="literal">COMPACT</code></td>
                    <td>Yes</td>
                    <td>No</td>
                    <td>No</td>
                    <td>No</td>
                    <td>system, file-per-table, general</td>
                    <td>Antelope or Barracuda</td>
                </tr><tr>
                    <td scope="row"><code class="literal">DYNAMIC</code></td>
                    <td>Yes</td>
                    <td>Yes</td>
                    <td>Yes</td>
                    <td>No</td>
                    <td>system, file-per-table, general</td>
                    <td>Barracuda</td>
                </tr><tr>
                    <td scope="row"><code class="literal">COMPRESSED</code></td>
                    <td>Yes</td>
                    <td>Yes</td>
                    <td>Yes</td>
                    <td>Yes</td>
                    <td>file-per-table, general</td>
                    <td>Barracuda</td>
                </tr></tbody></table>
            </div>

        </div>
        <br class="table-break"><p>
        The topics that follow describe row format storage characteristics
        and how to define and determine the row format of a table.
    </p><p style="color:blue;">以下主题描述行格式存储特性以及如何定义和确定表的行格式。</p>
        <div class="itemizedlist">
            <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><a class="xref" href="innodb-storage-engine.html#innodb-row-format-redundant" title="REDUNDANT Row Format">REDUNDANT Row Format</a></p><p style="color:blue;">冗余行格式</p></li><li class="listitem"><p><a class="xref" href="innodb-storage-engine.html#innodb-row-format-compact" title="COMPACT Row Format">COMPACT Row Format</a></p><p style="color:blue;">压缩行格式</p></li><li class="listitem"><p><a class="xref" href="innodb-storage-engine.html#innodb-row-format-dynamic" title="DYNAMIC Row Format">DYNAMIC Row Format</a></p><p style="color:blue;">动态行格式</p></li><li class="listitem"><p><a class="xref" href="innodb-storage-engine.html#innodb-row-format-compressed" title="COMPRESSED Row Format">COMPRESSED Row Format</a></p><p style="color:blue;">压缩行格式</p></li><li class="listitem"><p><a class="xref" href="innodb-storage-engine.html#innodb-row-format-defining" title="Defining the Row Format of a Table">Defining the Row Format of a Table</a></p><p style="color:blue;">定义表的行格式</p></li><li class="listitem"><p><a class="xref" href="innodb-storage-engine.html#innodb-row-format-detrmining" title="Determining the Row Format of a Table">Determining the Row Format of a Table</a></p><p style="color:blue;">确定表的行格式</p></li></ul>
        </div>

        <div class="simplesect">

            <div class="titlepage">
                <div>

                    <div class="simple">
                        <h3 class="title"><a name="innodb-row-format-redundant"></a>REDUNDANT Row Format</h3>

                    </div>

                </div>

            </div>
            <a class="indexterm" name="idm140286818095520"></a><a class="indexterm" name="idm140286818094032"></a><p>
            The <code class="literal">REDUNDANT</code> format provides compatibility
            with older versions of MySQL.
        </p><p style="color:blue;">冗余格式提供了与旧版本mysql的兼容性。</p><p>
            The <code class="literal">REDUNDANT</code> row format is supported by both
            <code class="literal">InnoDB</code> file formats
            (<code class="literal">Antelope</code> and <code class="literal">Barracuda</code>).
            For more information, see <a class="xref" href="innodb-storage-engine.html#innodb-file-format" title="14.10&nbsp;InnoDB File-Format Management">Section&nbsp;14.10, “InnoDB File-Format Management”</a>.
        </p><p style="color:blue;">innodb文件格式（antelope和barracuda）都支持冗余行格式。有关更多信息，请参阅14.10节，“InnoDB文件格式管理”。</p><p>
            Tables that use the <code class="literal">REDUNDANT</code> row format store
            the first 768 bytes of variable-length column values
            (<a class="link" href="data-types.html#char" title="11.4.1&nbsp;The CHAR and VARCHAR Types"><code class="literal">VARCHAR</code></a>,
            <a class="link" href="data-types.html#binary-varbinary" title="11.4.2&nbsp;The BINARY and VARBINARY Types"><code class="literal">VARBINARY</code></a>, and
            <a class="link" href="data-types.html#blob" title="11.4.3&nbsp;The BLOB and TEXT Types"><code class="literal">BLOB</code></a> and
            <a class="link" href="data-types.html#blob" title="11.4.3&nbsp;The BLOB and TEXT Types"><code class="literal">TEXT</code></a> types) in the index record
            within the B-tree node, with the remainder stored on overflow
            pages. Fixed-length columns greater than or equal to 768 bytes are
            encoded as variable-length columns, which can be stored off-page.
            For example, a <code class="literal">CHAR(255)</code> column can exceed 768
            bytes if the maximum byte length of the character set is greater
            than 3, as it is with <code class="literal">utf8mb4</code>.
        </p><p style="color:blue;">使用冗余行格式的表将变长列值（varchar、varbinary、blob和文本类型）的前768字节存储在b树节点的索引记录中，其余的存储在溢出页上。大于或等于768字节的固定长度列被编码为可变长度列，可在页外存储。例如，如果字符集的最大字节长度大于3，则字符（255）列可以超过768字节，因为它与UTF8Mb4是相同的。</p><p>
            If the value of a column is 768 bytes or less, an overflow page is
            not used, and some savings in I/O may result, since the value is
            stored entirely in the B-tree node. This works well for relatively
            short <code class="literal">BLOB</code> column values, but may cause B-tree
            nodes to fill with data rather than key values, reducing their
            efficiency. Tables with many <code class="literal">BLOB</code> columns could
            cause B-tree nodes to become too full, and contain too few rows,
            making the entire index less efficient than if rows were shorter
            or column values were stored off-page.
        </p><p style="color:blue;">如果列的值小于或等于768字节，则不使用溢出页，并且由于该值完全存储在b树节点中，因此可能会节省一些i/o。这对于相对较短的blob列值很有效，但可能会导致b-tree节点填充数据而不是键值，从而降低它们的效率。具有许多blob列的表可能会导致b树节点变得太满，并且包含的行太少，从而使整个索引的效率低于行较短或列值存储在页外的情况。</p>
            <h4><a name="innodb-redundant-row-format-characteristics"></a>REDUNDANT Row Format Storage Characteristics</h4>
            <a class="indexterm" name="idm140286818076192"></a><p>
            The <code class="literal">REDUNDANT</code> row format has the following
            storage characteristics:
        </p><p style="color:blue;">冗余行格式具有以下存储特性：</p>
            <div class="itemizedlist">
                <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                    Each index record contains a 6-byte header. The header is used
                    to link together consecutive records, and for row-level
                    locking.
                </p><p style="color:blue;">每个索引记录都包含一个6字节的头。头用于将连续记录链接在一起，并用于行级锁定。</p></li><li class="listitem"><p>
                    Records in the clustered index contain fields for all
                    user-defined columns. In addition, there is a 6-byte
                    transaction ID field and a 7-byte roll pointer field.
                </p><p style="color:blue;">聚集索引中的记录包含所有用户定义列的字段。此外，还有一个6字节的事务id字段和一个7字节的滚动指针字段。</p></li><li class="listitem"><p>
                    If no primary key is defined for a table, each clustered index
                    record also contains a 6-byte row ID field.
                </p><p style="color:blue;">如果没有为表定义主键，则每个聚集索引记录还包含一个6字节的行id字段。</p></li><li class="listitem"><p>
                    Each secondary index record contains all the primary key
                    columns defined for the clustered index key that are not in
                    the secondary index.
                </p><p style="color:blue;">每个辅助索引记录都包含为聚集索引键定义的所有主键列，这些主键列不在辅助索引中。</p></li><li class="listitem"><p>
                    A record contains a pointer to each field of the record. If
                    the total length of the fields in a record is less than 128
                    bytes, the pointer is one byte; otherwise, two bytes. The
                    array of pointers is called the record directory. The area
                    where the pointers point is the data part of the record.
                </p><p style="color:blue;">记录包含指向该记录的每个字段的指针。如果记录中字段的总长度小于128字节，则指针为一个字节；否则为两个字节。指针数组称为记录目录。指针指向的区域是记录的数据部分。</p></li><li class="listitem"><p>
                    Internally, fixed-length character columns such as
                    <a class="link" href="data-types.html#char" title="11.4.1&nbsp;The CHAR and VARCHAR Types"><code class="literal">CHAR(10)</code></a> are stored in
                    fixed-length format. Trailing spaces are not truncated from
                    <a class="link" href="data-types.html#char" title="11.4.1&nbsp;The CHAR and VARCHAR Types"><code class="literal">VARCHAR</code></a> columns.
                </p><p style="color:blue;">在内部，固定长度字符列（如char（10））以固定长度格式存储。不从varchar列中截断尾随空格。</p></li><li class="listitem"><p>
                    Fixed-length columns greater than or equal to 768 bytes are
                    encoded as variable-length columns, which can be stored
                    off-page. For example, a <code class="literal">CHAR(255)</code> column
                    can exceed 768 bytes if the maximum byte length of the
                    character set is greater than 3, as it is with
                    <code class="literal">utf8mb4</code>.
                </p><p style="color:blue;">大于或等于768字节的固定长度列被编码为可变长度列，可在页外存储。例如，如果字符集的最大字节长度大于3，则字符（255）列可以超过768字节，因为它与UTF8Mb4是相同的。</p></li><li class="listitem"><p>
                    An SQL <code class="literal">NULL</code> value reserves one or two bytes
                    in the record directory. An SQL <code class="literal">NULL</code> value
                    reserves zero bytes in the data part of the record if stored
                    in a variable-length column. For a fixed-length column, the
                    fixed length of the column is reserved in the data part of the
                    record. Reserving fixed space for <code class="literal">NULL</code>
                    values permits columns to be updated in place from
                    <code class="literal">NULL</code> to non-<code class="literal">NULL</code> values
                    without causing index page fragmentation.
                </p><p style="color:blue;">sql空值在记录目录中保留一个或两个字节。如果存储在可变长度列中，则sql空值将在记录的数据部分保留零字节。对于固定长度的列，该列的固定长度保留在记录的数据部分。为空值保留固定空间允许将列从空值更新为非空值，而不会导致索引页碎片。</p></li></ul>
            </div>

        </div>
        <div class="simplesect">
            <div class="titlepage">
                <div>
                    <div class="simple">
                        <h3 class="title"><a name="innodb-row-format-compact"></a>COMPACT Row Format</h3>

                    </div>

                </div>

            </div>
            <a class="indexterm" name="idm140286818056096"></a><a class="indexterm" name="idm140286818054608"></a><p>
            The <code class="literal">COMPACT</code> row format reduces row storage
            space by about 20% compared to the <code class="literal">REDUNDANT</code>
            row format, at the cost of increasing CPU use for some operations.
            If your workload is a typical one that is limited by cache hit
            rates and disk speed, <code class="literal">COMPACT</code> format is likely
            to be faster. If the workload is limited by CPU speed, compact
            format might be slower.
        </p><p style="color:blue;">与冗余行格式相比，紧凑行格式减少了约20%的行存储空间，但代价是增加了某些操作的CPU使用量。如果您的工作负载是受缓存命中率和磁盘速度限制的典型工作负载，那么压缩格式可能更快。如果工作负载受到cpu速度的限制，那么压缩格式可能会慢一些。</p><p>
            The <code class="literal">COMPACT</code> row format is supported by both
            <code class="literal">InnoDB</code> file formats
            (<code class="literal">Antelope</code> and <code class="literal">Barracuda</code>).
            For more information, see <a class="xref" href="innodb-storage-engine.html#innodb-file-format" title="14.10&nbsp;InnoDB File-Format Management">Section&nbsp;14.10, “InnoDB File-Format Management”</a>.
        </p><p style="color:blue;">innodb文件格式（antelope和barracuda）都支持压缩行格式。有关更多信息，请参阅14.10节，“InnoDB文件格式管理”。</p><p>
            Tables that use the <code class="literal">COMPACT</code> row format store
            the first 768 bytes of variable-length column values
            (<a class="link" href="data-types.html#char" title="11.4.1&nbsp;The CHAR and VARCHAR Types"><code class="literal">VARCHAR</code></a>,
            <a class="link" href="data-types.html#binary-varbinary" title="11.4.2&nbsp;The BINARY and VARBINARY Types"><code class="literal">VARBINARY</code></a>, and
            <a class="link" href="data-types.html#blob" title="11.4.3&nbsp;The BLOB and TEXT Types"><code class="literal">BLOB</code></a> and
            <a class="link" href="data-types.html#blob" title="11.4.3&nbsp;The BLOB and TEXT Types"><code class="literal">TEXT</code></a> types) in the index record
            within the <a class="link" href="glossary.html#glos_b_tree" title="B-tree">B-tree</a> node, with
            the remainder stored on overflow pages. Fixed-length columns
            greater than or equal to 768 bytes are encoded as variable-length
            columns, which can be stored off-page. For example, a
            <code class="literal">CHAR(255)</code> column can exceed 768 bytes if the
            maximum byte length of the character set is greater than 3, as it
            is with <code class="literal">utf8mb4</code>.
        </p><p style="color:blue;">使用压缩行格式的表将变长列值（varchar、varbinary、blob和文本类型）的前768字节存储在b树节点的索引记录中，其余的存储在溢出页上。大于或等于768字节的固定长度列被编码为可变长度列，可在页外存储。例如，如果字符集的最大字节长度大于3，则字符（255）列可以超过768字节，因为它与UTF8Mb4是相同的。</p><p>
            If the value of a column is 768 bytes or less, an overflow page is
            not used, and some savings in I/O may result, since the value is
            stored entirely in the B-tree node. This works well for relatively
            short <code class="literal">BLOB</code> column values, but may cause B-tree
            nodes to fill with data rather than key values, reducing their
            efficiency. Tables with many <code class="literal">BLOB</code> columns could
            cause B-tree nodes to become too full, and contain too few rows,
            making the entire index less efficient than if rows were shorter
            or column values were stored off-page.
        </p><p style="color:blue;">如果列的值小于或等于768字节，则不使用溢出页，并且由于该值完全存储在b树节点中，因此可能会节省一些i/o。这对于相对较短的blob列值很有效，但可能会导致b-tree节点填充数据而不是键值，从而降低它们的效率。具有许多blob列的表可能会导致b树节点变得太满，并且包含的行太少，从而使整个索引的效率低于行较短或列值存储在页外的情况。</p>
            <h4><a name="innodb-compact-row-format-characteristics"></a>COMPACT Row Format Storage Characteristics</h4>
            <a class="indexterm" name="idm140286818034272"></a><p>
            The <code class="literal">COMPACT</code> row format has the following
            storage characteristics:
        </p><p style="color:blue;">压缩行格式具有以下存储特性：</p>
            <div class="itemizedlist">
                <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                    Each index record contains a 5-byte header that may be
                    preceded by a variable-length header. The header is used to
                    link together consecutive records, and for row-level locking.
                </p><p style="color:blue;">每个索引记录都包含一个5字节的头，其前面可能有一个可变长度的头。头用于将连续记录链接在一起，并用于行级锁定。</p></li><li class="listitem"><p>
                    The variable-length part of the record header contains a bit
                    vector for indicating <code class="literal">NULL</code> columns. If the
                    number of columns in the index that can be
                    <code class="literal">NULL</code> is <em class="replaceable"><code>N</code></em>, the
                    bit vector occupies
                    <code class="literal">CEILING(<em class="replaceable"><code>N</code></em>/8)</code>
                    bytes. (For example, if there are anywhere from 9 to 16
                    columns that can be <code class="literal">NULL</code>, the bit vector
                    uses two bytes.) Columns that are <code class="literal">NULL</code> do
                    not occupy space other than the bit in this vector. The
                    variable-length part of the header also contains the lengths
                    of variable-length columns. Each length takes one or two
                    bytes, depending on the maximum length of the column. If all
                    columns in the index are <code class="literal">NOT NULL</code> and have
                    a fixed length, the record header has no variable-length part.
                </p><p style="color:blue;">记录头的可变长度部分包含用于指示空列的位向量。如果索引中可以为空的列数为n，则位向量占用上限（n/8）字节。（例如，如果有9到16列可以为空，则位向量使用两个字节。）为空的列不会占用此向量中位以外的空间。标题的可变长度部分还包含可变长度列的长度。每个长度都需要一个或两个字节，这取决于列的最大长度。如果索引中的所有列都不为空并且具有固定长度，则记录头没有可变长度部分。</p></li><li class="listitem"><p>
                    For each non-<code class="literal">NULL</code> variable-length field,
                    the record header contains the length of the column in one or
                    two bytes. Two bytes are only needed if part of the column is
                    stored externally in overflow pages or the maximum length
                    exceeds 255 bytes and the actual length exceeds 127 bytes. For
                    an externally stored column, the 2-byte length indicates the
                    length of the internally stored part plus the 20-byte pointer
                    to the externally stored part. The internal part is 768 bytes,
                    so the length is 768+20. The 20-byte pointer stores the true
                    length of the column.
                </p><p style="color:blue;">对于每个非空的可变长度字段，记录头包含一个或两个字节的列长度。仅当列的一部分存储在溢出页或最大长度超过255字节且实际长度超过127字节时，才需要两个字节。对于外部存储的列，2字节长度表示内部存储部分的长度加上指向外部存储部分的20字节指针。内部部分是768字节，所以长度是768+20。20字节指针存储列的实际长度。</p></li><li class="listitem"><p>
                    The record header is followed by the data contents of
                    non-<code class="literal">NULL</code> columns.
                </p><p style="color:blue;">记录头后面跟着非空列的数据内容。</p></li><li class="listitem"><p>
                    Records in the clustered index contain fields for all
                    user-defined columns. In addition, there is a 6-byte
                    transaction ID field and a 7-byte roll pointer field.
                </p><p style="color:blue;">聚集索引中的记录包含所有用户定义列的字段。此外，还有一个6字节的事务id字段和一个7字节的滚动指针字段。</p></li><li class="listitem"><p>
                    If no primary key is defined for a table, each clustered index
                    record also contains a 6-byte row ID field.
                </p><p style="color:blue;">如果没有为表定义主键，则每个聚集索引记录还包含一个6字节的行id字段。</p></li><li class="listitem"><p>
                    Each secondary index record contains all the primary key
                    columns defined for the clustered index key that are not in
                    the secondary index. If any of the primary key columns are
                    variable length, the record header for each secondary index
                    has a variable-length part to record their lengths, even if
                    the secondary index is defined on fixed-length columns.
                </p><p style="color:blue;">每个辅助索引记录都包含为聚集索引键定义的所有主键列，这些主键列不在辅助索引中。如果任何主键列都是可变长度的，则每个辅助索引的记录头都有一个可变长度部分来记录它们的长度，即使辅助索引是在固定长度的列上定义的。</p></li><li class="listitem"><p>
                    Internally, for nonvariable-length character sets,
                    fixed-length character columns such as
                    <a class="link" href="data-types.html#char" title="11.4.1&nbsp;The CHAR and VARCHAR Types"><code class="literal">CHAR(10)</code></a> are stored in a
                    fixed-length format.
                </p><p style="color:blue;">在内部，对于非可变长度字符集，固定长度字符列（例如char（10））以固定长度格式存储。</p><p>
                    Trailing spaces are not truncated from
                    <a class="link" href="data-types.html#char" title="11.4.1&nbsp;The CHAR and VARCHAR Types"><code class="literal">VARCHAR</code></a> columns.
                </p><p style="color:blue;">不从varchar列中截断尾随空格。</p></li><li class="listitem"><p>
                    Internally, for variable-length character sets such as
                    <code class="literal">utf8mb3</code> and <code class="literal">utf8mb4</code>,
                    <code class="literal">InnoDB</code> attempts to store
                    <a class="link" href="data-types.html#char" title="11.4.1&nbsp;The CHAR and VARCHAR Types"><code class="literal">CHAR(<em class="replaceable"><code>N</code></em>)</code></a>
                    in <em class="replaceable"><code>N</code></em> bytes by trimming trailing
                    spaces. If the byte length of a
                    <a class="link" href="data-types.html#char" title="11.4.1&nbsp;The CHAR and VARCHAR Types"><code class="literal">CHAR(<em class="replaceable"><code>N</code></em>)</code></a>
                    column value exceeds <em class="replaceable"><code>N</code></em> bytes,
                    trailing spaces are trimmed to a minimum of the column value
                    byte length. The maximum length of a
                    <a class="link" href="data-types.html#char" title="11.4.1&nbsp;The CHAR and VARCHAR Types"><code class="literal">CHAR(<em class="replaceable"><code>N</code></em>)</code></a>
                    column is the maximum character byte length ×
                    <em class="replaceable"><code>N</code></em>.
                </p><p style="color:blue;">在内部，对于可变长度字符集，如utf8mb3和utf8mb4，innodb尝试通过修剪尾随空格以n字节存储char（n）。如果char（n）列值的字节长度超过n个字节，则尾随空格将被修剪为列值字节长度的最小值。char（n）列的最大长度是最大字符字节长度×n。</p><p>
                    A minimum of <em class="replaceable"><code>N</code></em> bytes is reserved
                    for
                    <a class="link" href="data-types.html#char" title="11.4.1&nbsp;The CHAR and VARCHAR Types"><code class="literal">CHAR(<em class="replaceable"><code>N</code></em>)</code></a>.
                    Reserving the minimum space <em class="replaceable"><code>N</code></em> in
                    many cases enables column updates to be done in place without
                    causing index page fragmentation. By comparison,
                    <a class="link" href="data-types.html#char" title="11.4.1&nbsp;The CHAR and VARCHAR Types"><code class="literal">CHAR(<em class="replaceable"><code>N</code></em>)</code></a>
                    columns occupy the maximum character byte length ×
                    <em class="replaceable"><code>N</code></em> when using the
                    <code class="literal">REDUNDANT</code> row format.
                </p><p style="color:blue;">至少为char（n）保留n个字节。在许多情况下，保留最小空间n可以在不导致索引页碎片的情况下就地完成列更新。相比之下，当使用冗余行格式时，字符（n）列占据最大字符字节长度×n。</p><p>
                    Fixed-length columns greater than or equal to 768 bytes are
                    encoded as variable-length fields, which can be stored
                    off-page. For example, a <code class="literal">CHAR(255)</code> column
                    can exceed 768 bytes if the maximum byte length of the
                    character set is greater than 3, as it is with
                    <code class="literal">utf8mb4</code>.
                </p><p style="color:blue;">大于或等于768字节的固定长度列被编码为可变长度字段，可在页外存储。例如，如果字符集的最大字节长度大于3，则字符（255）列可以超过768字节，因为它与UTF8Mb4是相同的。</p></li></ul>
            </div>

        </div>
        <div class="simplesect">
            <div class="titlepage">
                <div>
                    <div class="simple">
                        <h3 class="title"><a name="innodb-row-format-dynamic"></a>DYNAMIC Row Format</h3>

                    </div>

                </div>

            </div>
            <a class="indexterm" name="idm140286817993248"></a><a class="indexterm" name="idm140286817991760"></a><p>
            The <code class="literal">DYNAMIC</code> row format offers the same storage
            characteristics as the <code class="literal">COMPACT</code> row format but
            adds enhanced storage capabilities for long variable-length
            columns and supports large index key prefixes.
        </p><p style="color:blue;">动态行格式提供了与压缩行格式相同的存储特性，但为长可变长列添加了增强的存储功能，并支持大索引键前缀。</p><p>
            The Barracuda file format supports the <code class="literal">DYNAMIC</code>
            row format. See <a class="xref" href="innodb-storage-engine.html#innodb-file-format" title="14.10&nbsp;InnoDB File-Format Management">Section&nbsp;14.10, “InnoDB File-Format Management”</a>.
        </p><p style="color:blue;">梭鱼文件格式支持动态行格式。见14.10节，“InnoDB文件格式管理”。</p><p>
            When a table is created with
            <code class="literal">ROW_FORMAT=DYNAMIC</code>, <code class="literal">InnoDB</code>
            can store long variable-length column values (for
            <a class="link" href="data-types.html#char" title="11.4.1&nbsp;The CHAR and VARCHAR Types"><code class="literal">VARCHAR</code></a>,
            <a class="link" href="data-types.html#binary-varbinary" title="11.4.2&nbsp;The BINARY and VARBINARY Types"><code class="literal">VARBINARY</code></a>, and
            <a class="link" href="data-types.html#blob" title="11.4.3&nbsp;The BLOB and TEXT Types"><code class="literal">BLOB</code></a> and
            <a class="link" href="data-types.html#blob" title="11.4.3&nbsp;The BLOB and TEXT Types"><code class="literal">TEXT</code></a> types) fully off-page, with
            the clustered index record containing only a 20-byte pointer to
            the overflow page. Fixed-length fields greater than or equal to
            768 bytes are encoded as variable-length fields. For example, a
            <code class="literal">CHAR(255)</code> column can exceed 768 bytes if the
            maximum byte length of the character set is greater than 3, as it
            is with <code class="literal">utf8mb4</code>.
        </p><p style="color:blue;">当使用row_format=dynamic创建表时，innodb可以将长可变长度的列值（对于varchar、varbinary、blob和文本类型）完全存储在页外，而聚集索引记录只包含指向溢出页的20字节指针。大于或等于768字节的固定长度字段编码为可变长度字段。例如，如果字符集的最大字节长度大于3，则字符（255）列可以超过768字节，因为它与UTF8Mb4是相同的。</p><p>
            Whether columns are stored off-page depends on the page size and
            the total size of the row. When a row is too long, the longest
            columns are chosen for off-page storage until the clustered index
            record fits on the <a class="link" href="glossary.html#glos_b_tree" title="B-tree">B-tree</a> page.
            <a class="link" href="data-types.html#blob" title="11.4.3&nbsp;The BLOB and TEXT Types"><code class="literal">TEXT</code></a> and
            <a class="link" href="data-types.html#blob" title="11.4.3&nbsp;The BLOB and TEXT Types"><code class="literal">BLOB</code></a> columns that are less than or
            equal to 40 bytes are stored in line.
        </p><p style="color:blue;">列是否存储在页外取决于页大小和行的总大小。当行太长时，将选择最长的列作为页外存储，直到聚集索引记录适合B树页。小于或等于40字节的文本列和blob列存储在行中。</p><p>
            The <code class="literal">DYNAMIC</code> row format maintains the efficiency
            of storing the entire row in the index node if it fits (as do the
            <code class="literal">COMPACT</code> and <code class="literal">REDUNDANT</code>
            formats), but the <code class="literal">DYNAMIC</code> row format avoids the
            problem of filling B-tree nodes with a large number of data bytes
            of long columns. The <code class="literal">DYNAMIC</code> row format is
            based on the idea that if a portion of a long data value is stored
            off-page, it is usually most efficient to store the entire value
            off-page. With <code class="literal">DYNAMIC</code> format, shorter columns
            are likely to remain in the B-tree node, minimizing the number of
            overflow pages required for a given row.
        </p><p style="color:blue;">动态行格式保持了在索引节点中存储整行的效率（与压缩和冗余格式一样），但动态行格式避免了用长列的大量数据字节填充b树节点的问题。动态行格式基于这样一种思想：如果长数据值的一部分存储在页外，则通常最有效的方法是将整个值存储在页外。使用动态格式时，较短的列可能会保留在B树节点中，从而最小化给定行所需的溢出页数。</p><p>
            The <code class="literal">DYNAMIC</code> row format supports index key
            prefixes up to 3072 bytes. This feature is controlled by the
            <a class="link" href="innodb-storage-engine.html#sysvar_innodb_large_prefix"><code class="literal">innodb_large_prefix</code></a> variable,
            which is enabled by default. See the
            <a class="link" href="innodb-storage-engine.html#sysvar_innodb_large_prefix"><code class="literal">innodb_large_prefix</code></a> variable
            description for more information.
        </p><p style="color:blue;">动态行格式支持最多3072字节的索引键前缀。此功能由innodb_large_prefix变量控制，该变量默认启用。有关更多信息，请参阅innodb_large_prefix变量描述。</p><p>
            Tables that use the <code class="literal">DYNAMIC</code> row format can be
            stored in the system tablespace, file-per-table tablespaces, and
            general tablespaces. To store <code class="literal">DYNAMIC</code> tables in
            the system tablespace, either disable
            <a class="link" href="innodb-storage-engine.html#sysvar_innodb_file_per_table"><code class="literal">innodb_file_per_table</code></a> and use a
            regular <code class="literal">CREATE TABLE</code> or <code class="literal">ALTER
            TABLE</code> statement, or use the <code class="literal">TABLESPACE [=]
            innodb_system</code> table option with <code class="literal">CREATE
            TABLE</code> or <code class="literal">ALTER TABLE</code>. The
            <a class="link" href="innodb-storage-engine.html#sysvar_innodb_file_per_table"><code class="literal">innodb_file_per_table</code></a> and
            <a class="link" href="innodb-storage-engine.html#sysvar_innodb_file_format"><code class="literal">innodb_file_format</code></a> variables are
            not applicable to general tablespaces, nor are they applicable
            when using the <code class="literal">TABLESPACE [=] innodb_system</code>
            table option to store <code class="literal">DYNAMIC</code> tables in the
            system tablespace.
        </p><p style="color:blue;">使用动态行格式的表可以存储在系统表空间、逐表文件表空间和常规表空间中。要在系统表空间中存储动态表，请禁用innodb_file_per_table并使用常规的create table或alter table语句，或者将tablespace[=]innodb_system table选项与create table或alter table一起使用。innodb_file_per_table和innodb_file_format变量不适用于常规表空间，也不适用于使用tablespace[=]innodb_system table选项在系统表空间中存储动态表。</p>
            <h4><a name="innodb-dynamic-row-format-characteristics"></a>DYNAMIC Row Format Storage Characteristics</h4>
            <a class="indexterm" name="idm140286817952800"></a><p>
            The <code class="literal">DYNAMIC</code> row format is a variation of the
            <code class="literal">COMPACT</code> row format. For storage
            characteristics, see
            <a class="xref" href="innodb-storage-engine.html#innodb-compact-row-format-characteristics" title="COMPACT Row Format Storage Characteristics">COMPACT Row Format Storage Characteristics</a>.
        </p><p style="color:blue;">动态行格式是压缩行格式的变体。有关存储特性，请参阅压缩行格式存储特性。</p>
        </div>
        <div class="simplesect">
            <div class="titlepage">
                <div>
                    <div class="simple">
                        <h3 class="title"><a name="innodb-row-format-compressed"></a>COMPRESSED Row Format</h3>

                    </div>

                </div>

            </div>
            <a class="indexterm" name="idm140286817947328"></a><a class="indexterm" name="idm140286817945840"></a><p>
            The <code class="literal">COMPRESSED</code> row format offers the same
            storage characteristics and capabilities as the
            <code class="literal">DYNAMIC</code> row format but adds support for table
            and index data compression.
        </p><p style="color:blue;">压缩行格式提供与动态行格式相同的存储特性和功能，但增加了对表和索引数据压缩的支持。</p><p>
            The Barracuda file format supports the
            <code class="literal">COMPRESSED</code> row format. See
            <a class="xref" href="innodb-storage-engine.html#innodb-file-format" title="14.10&nbsp;InnoDB File-Format Management">Section&nbsp;14.10, “InnoDB File-Format Management”</a>.
        </p><p style="color:blue;">梭鱼文件格式支持压缩行格式。见14.10节，“InnoDB文件格式管理”。</p><p>
            The <code class="literal">COMPRESSED</code> row format uses similar internal
            details for off-page storage as the <code class="literal">DYNAMIC</code> row
            format, with additional storage and performance considerations
            from the table and index data being compressed and using smaller
            page sizes. With the <code class="literal">COMPRESSED</code> row format, the
            <code class="literal">KEY_BLOCK_SIZE</code> option controls how much column
            data is stored in the clustered index, and how much is placed on
            overflow pages. For more information about the
            <code class="literal">COMPRESSED</code> row format, see
            <a class="xref" href="innodb-storage-engine.html#innodb-compression" title="14.9&nbsp;InnoDB Table and Page Compression">Section&nbsp;14.9, “InnoDB Table and Page Compression”</a>.
        </p><p style="color:blue;">压缩行格式使用与动态行格式类似的页外存储内部详细信息，同时压缩表和索引数据并使用较小的页大小，以考虑额外的存储和性能。对于压缩行格式，key_block_size选项控制聚集索引中存储的列数据量，以及溢出页上放置的列数据量。有关压缩行格式的更多信息，请参阅14.9节，“innodb table and page compression”。</p><p>
            The <code class="literal">COMPRESSED</code> row format supports index key
            prefixes up to 3072 bytes. This feature is controlled by the
            <a class="link" href="innodb-storage-engine.html#sysvar_innodb_large_prefix"><code class="literal">innodb_large_prefix</code></a> variable,
            which is enabled by default. See the
            <a class="link" href="innodb-storage-engine.html#sysvar_innodb_large_prefix"><code class="literal">innodb_large_prefix</code></a> variable
            description for more information.
        </p><p style="color:blue;">压缩行格式支持最多3072字节的索引键前缀。此功能由innodb_large_prefix变量控制，该变量默认启用。有关更多信息，请参阅innodb_large_prefix变量描述。</p><p>
            Tables that use the <code class="literal">COMPRESSED</code> row format can
            be created in file-per-table tablespaces or general tablespaces.
            The system tablespace does not support the
            <code class="literal">COMPRESSED</code> row format. To store a
            <code class="literal">COMPRESSED</code> table in a file-per-table
            tablespace, the
            <a class="link" href="innodb-storage-engine.html#sysvar_innodb_file_per_table"><code class="literal">innodb_file_per_table</code></a> variable
            must be enabled and
            <a class="link" href="innodb-storage-engine.html#sysvar_innodb_file_format"><code class="literal">innodb_file_format</code></a> must be set to
            <code class="literal">Barracuda</code>. The
            <a class="link" href="innodb-storage-engine.html#sysvar_innodb_file_per_table"><code class="literal">innodb_file_per_table</code></a> and
            <a class="link" href="innodb-storage-engine.html#sysvar_innodb_file_format"><code class="literal">innodb_file_format</code></a> variables are
            not applicable to general tablespaces. General tablespaces support
            all row formats with the caveat that compressed and uncompressed
            tables cannot coexist in the same general tablespace due to
            different physical page sizes. For more information about, see
            <a class="xref" href="innodb-storage-engine.html#general-tablespaces" title="14.6.3.3&nbsp;General Tablespaces">Section&nbsp;14.6.3.3, “General Tablespaces”</a>.
        </p><p style="color:blue;">使用压缩行格式的表可以在每个表空间或常规表空间的文件中创建。系统表空间不支持压缩行格式。要将压缩表存储在每个表空间的文件中，必须启用innodb_file_per_table变量，并且innodb_file_format必须设置为barracuda。innodb_file_per_表和innodb_file_格式变量不适用于常规表空间。通用表空间支持所有行格式，警告指出，由于不同的物理页大小，压缩和未压缩表不能共存于同一个通用表空间中。有关的更多信息，请参阅14.6.3.3节“常规表空间”。</p>
            <h4><a name="innodb-compressed-row-format-characteristics"></a>Compressed Row Format Storage Characteristics</h4>
            <a class="indexterm" name="idm140286817921248"></a><p>
            The <code class="literal">COMPRESSED</code> row format is a variation of the
            <code class="literal">COMPACT</code> row format. For storage
            characteristics, see
            <a class="xref" href="innodb-storage-engine.html#innodb-compact-row-format-characteristics" title="COMPACT Row Format Storage Characteristics">COMPACT Row Format Storage Characteristics</a>.
        </p><p style="color:blue;">压缩行格式是压缩行格式的变体。有关存储特性，请参阅压缩行格式存储特性。</p>
        </div>
        <div class="simplesect">
            <div class="titlepage">
                <div>
                    <div class="simple">
                        <h3 class="title"><a name="innodb-row-format-defining"></a>Defining the Row Format of a Table</h3>

                    </div>

                </div>

            </div>
            <a class="indexterm" name="idm140286817915808"></a><a class="indexterm" name="idm140286817914320"></a><a class="indexterm" name="idm140286817912832"></a><p>
            The default row format for <code class="literal">InnoDB</code> tables is
            defined by
            <a class="link" href="innodb-storage-engine.html#sysvar_innodb_default_row_format"><code class="literal">innodb_default_row_format</code></a>
            variable, which has a default value of <code class="literal">DYNAMIC</code>.
            The default row format is used when the
            <code class="literal">ROW_FORMAT</code> table option is not defined
            explicitly or when <code class="literal">ROW_FORMAT=DEFAULT</code> is
            specified.
        </p><p style="color:blue;">innodb表的默认行格式由innodb_default_row_format变量定义，该变量的默认值为dynamic。当未显式定义row_format table选项或指定row_format=default时，使用默认行格式。</p><p>
            The row format of a table can be defined explicitly using the
            <code class="literal">ROW_FORMAT</code> table option in a
            <a class="link" href="sql-syntax.html#create-table" title="13.1.18&nbsp;CREATE TABLE Syntax"><code class="literal">CREATE TABLE</code></a> or
            <a class="link" href="sql-syntax.html#alter-table" title="13.1.8&nbsp;ALTER TABLE Syntax"><code class="literal">ALTER TABLE</code></a> statement. For example:
        </p><p style="color:blue;">可以在CREATE TABLE或ALTER TABLE语句中使用ROW U FORMAT TABLE选项显式定义表的行格式。例如：</p><pre data-lang="sql" class="programlisting">CREATE TABLE t1 (c1 INT) ROW_FORMAT=DYNAMIC;
</pre><p>
            An explicitly defined <code class="literal">ROW_FORMAT</code> setting
            overrides the default row format. Specifying
            <code class="literal">ROW_FORMAT=DEFAULT</code> is equivalent to using the
            implicit default.
        </p><p style="color:blue;">显式定义的行格式设置将覆盖默认行格式。指定row_format=default等同于使用隐式默认值。</p><p>
            The <a class="link" href="innodb-storage-engine.html#sysvar_innodb_default_row_format"><code class="literal">innodb_default_row_format</code></a>
            variable can be set dynamically:
        </p><p style="color:blue;">innodb_default_row_format变量可以动态设置：</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>SET GLOBAL innodb_default_row_format=DYNAMIC;</code></strong>
</pre><p>
            Valid <a class="link" href="innodb-storage-engine.html#sysvar_innodb_default_row_format"><code class="literal">innodb_default_row_format</code></a>
            options include <code class="literal">DYNAMIC</code>,
            <code class="literal">COMPACT</code>, and <code class="literal">REDUNDANT</code>. The
            <code class="literal">COMPRESSED</code> row format, which is not supported
            for use in the system tablespace, cannot be defined as the
            default. It can only be specified explicitly in a
            <a class="link" href="sql-syntax.html#create-table" title="13.1.18&nbsp;CREATE TABLE Syntax"><code class="literal">CREATE TABLE</code></a> or
            <a class="link" href="sql-syntax.html#alter-table" title="13.1.8&nbsp;ALTER TABLE Syntax"><code class="literal">ALTER TABLE</code></a> statement. Attempting
            to set the
            <a class="link" href="innodb-storage-engine.html#sysvar_innodb_default_row_format"><code class="literal">innodb_default_row_format</code></a>
            variable to <code class="literal">COMPRESSED</code> returns an error:
        </p><p style="color:blue;">有效的innodb_默认_行格式选项包括动态、压缩和冗余。压缩行格式不支持在系统表空间中使用，不能定义为默认格式。它只能在CREATETABLE或ALTERTABLE语句中显式指定。试图将innodb_default_row_format变量设置为compressed返回错误：</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>SET GLOBAL innodb_default_row_format=COMPRESSED;</code></strong>
ERROR 1231 (42000): Variable 'innodb_default_row_format'
can't be set to the value of 'COMPRESSED'
</pre><p>
            Newly created tables use the row format defined by the
            <a class="link" href="innodb-storage-engine.html#sysvar_innodb_default_row_format"><code class="literal">innodb_default_row_format</code></a>
            variable when a <code class="literal">ROW_FORMAT</code> option is not
            specified explicitly, or when
            <code class="literal">ROW_FORMAT=DEFAULT</code> is used. For example, the
            following <a class="link" href="sql-syntax.html#create-table" title="13.1.18&nbsp;CREATE TABLE Syntax"><code class="literal">CREATE TABLE</code></a> statements
            use the row format defined by the
            <a class="link" href="innodb-storage-engine.html#sysvar_innodb_default_row_format"><code class="literal">innodb_default_row_format</code></a>
            variable.
        </p><p style="color:blue;">当未显式指定row_format选项或使用row_format=default时，新创建的表使用innodb_default_row_format变量定义的行格式。例如，下面的create table语句使用innodb_default_row_format变量定义的行格式。</p><pre data-lang="sql" class="programlisting">CREATE TABLE t1 (c1 INT);
</pre><pre data-lang="sql" class="programlisting">CREATE TABLE t2 (c1 INT) ROW_FORMAT=DEFAULT;
</pre><p>
            When a <code class="literal">ROW_FORMAT</code> option is not specified
            explicitly, or when <code class="literal">ROW_FORMAT=DEFAULT</code> is used,
            an operation that rebuilds a table silently changes the row format
            of the table to the format defined by the
            <a class="link" href="innodb-storage-engine.html#sysvar_innodb_default_row_format"><code class="literal">innodb_default_row_format</code></a>
            variable.
        </p><p style="color:blue;">如果未显式指定row_format选项，或者使用row_format=default，则无提示地重建表的操作会将表的行格式更改为innodb_default_row_format变量定义的格式。</p><p>
            Table-rebuilding operations include <a class="link" href="sql-syntax.html#alter-table" title="13.1.8&nbsp;ALTER TABLE Syntax"><code class="literal">ALTER
            TABLE</code></a> operations that use
            <code class="literal">ALGORITHM=COPY</code> or
            <code class="literal">ALGORITHM=INPLACE</code> where table rebuilding is
            required. See <a class="xref" href="innodb-storage-engine.html#innodb-online-ddl-operations" title="14.13.1&nbsp;Online DDL Operations">Section&nbsp;14.13.1, “Online DDL Operations”</a> for
            more information. <a class="link" href="sql-syntax.html#optimize-table" title="13.7.2.4&nbsp;OPTIMIZE TABLE Syntax"><code class="literal">OPTIMIZE TABLE</code></a> is
            also a table-rebuilding operation.
        </p><p style="color:blue;">表重建操作包括在需要表重建的地方使用algorithm=copy或algorithm=inplace的alter table操作。更多信息请参见第14.13.1节“在线DDL操作”。优化表也是一种表重建操作。</p><p>
            The following example demonstrates a table-rebuilding operation
            that silently changes the row format of a table created without an
            explicitly defined row format.
        </p><p style="color:blue;">下面的示例演示了一个表重建操作，该操作无提示地更改在没有显式定义的行格式的情况下创建的表的行格式。</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT @@innodb_default_row_format;</code></strong>
+-----------------------------+
| @@innodb_default_row_format |
+-----------------------------+
| dynamic                     |
+-----------------------------+

mysql&gt; <strong class="userinput"><code>CREATE TABLE t1 (c1 INT);</code></strong>

mysql&gt; <strong class="userinput"><code>SELECT * FROM INFORMATION_SCHEMA.INNODB_SYS_TABLES WHERE NAME LIKE 'test/t1' \G</code></strong>
*************************** 1. row ***************************
     TABLE_ID: 54
         NAME: test/t1
         FLAG: 33
       N_COLS: 4
        SPACE: 35
  FILE_FORMAT: Barracuda
   ROW_FORMAT: Dynamic
ZIP_PAGE_SIZE: 0
   SPACE_TYPE: Single

mysql&gt; <strong class="userinput"><code>SET GLOBAL innodb_default_row_format=COMPACT;</code></strong>

mysql&gt; <strong class="userinput"><code>ALTER TABLE t1 ADD COLUMN (c2 INT);</code></strong>

mysql&gt; <strong class="userinput"><code>SELECT * FROM INFORMATION_SCHEMA.INNODB_SYS_TABLES WHERE NAME LIKE 'test/t1' \G</code></strong>
*************************** 1. row ***************************
     TABLE_ID: 55
         NAME: test/t1
         FLAG: 1
       N_COLS: 5
        SPACE: 36
  FILE_FORMAT: Antelope
   ROW_FORMAT: Compact
ZIP_PAGE_SIZE: 0
   SPACE_TYPE: Single
</pre><p>
            Consider the following potential issues before changing the row
            format of existing tables from <code class="literal">REDUNDANT</code> or
            <code class="literal">COMPACT</code> to <code class="literal">DYNAMIC</code>.
        </p><p style="color:blue;">在将现有表的行格式从冗余或紧凑更改为动态之前，考虑以下潜在问题。</p>
            <div class="itemizedlist">
                <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                    The <code class="literal">REDUNDANT</code> and
                    <code class="literal">COMPACT</code> row formats support a maximum index
                    key prefix length of 767 bytes whereas
                    <code class="literal">DYNAMIC</code> and <code class="literal">COMPRESSED</code>
                    row formats support an index key prefix length of 3072 bytes.
                    In a replication environment, if the
                    <a class="link" href="innodb-storage-engine.html#sysvar_innodb_default_row_format"><code class="literal">innodb_default_row_format</code></a>
                    variable is set to <code class="literal">DYNAMIC</code> on the master,
                    and set to <code class="literal">COMPACT</code> on the slave, the
                    following DDL statement, which does not explicitly define a
                    row format, succeeds on the master but fails on the slave:
                </p><p style="color:blue;">冗余和紧凑的行格式支持最大索引键前缀长度为767字节，而动态和压缩行格式支持索引键前缀长度为3072字节。在复制环境中，如果innodb_default_row_format变量在master上设置为dynamic，在slave上设置为compact，那么下面的ddl语句（它没有显式定义行格式）在master上成功，但在slave上失败：</p><pre data-lang="sql" class="programlisting">CREATE TABLE t1 (c1 INT PRIMARY KEY, c2 VARCHAR(5000), KEY i1(c2(3070)));
</pre><p>
                    For related information, see
                    <a class="xref" href="innodb-storage-engine.html#innodb-restrictions" title="14.6.1.6&nbsp;Limits on InnoDB Tables">Section&nbsp;14.6.1.6, “Limits on InnoDB Tables”</a>.
                </p><p style="color:blue;">有关信息，请参阅第14.6.1.6节“InnoDB表的限制”。</p></li><li class="listitem"><p>
                    Importing a table that does not explicitly define a row format
                    results in a schema mismatch error if the
                    <a class="link" href="innodb-storage-engine.html#sysvar_innodb_default_row_format"><code class="literal">innodb_default_row_format</code></a>
                    setting on the source server differs from the setting on the
                    destination server. For more information, refer to the
                    limitations outlined in <a class="xref" href="innodb-storage-engine.html#tablespace-copying" title="14.6.3.7&nbsp;Copying Tablespaces to Another Instance">Section&nbsp;14.6.3.7, “Copying Tablespaces to Another Instance”</a>.
                </p><p style="color:blue;">如果源服务器上的innodb_default_row_format设置与目标服务器上的设置不同，则导入未显式定义行格式的表将导致架构不匹配错误。有关更多信息，请参阅14.6.3.7节“将表空间复制到另一个实例”中概述的限制。</p></li></ul>
            </div>

        </div>
        <div class="simplesect">
            <div class="titlepage">
                <div>
                    <div class="simple">
                        <h3 class="title"><a name="innodb-row-format-detrmining"></a>Determining the Row Format of a Table</h3>

                    </div>

                </div>

            </div>
            <a class="indexterm" name="idm140286817846528"></a><p>
            To determine the row format of a table, use
            <a class="link" href="sql-syntax.html#show-table-status" title="13.7.5.36&nbsp;SHOW TABLE STATUS Syntax"><code class="literal">SHOW TABLE STATUS</code></a>:
        </p><p style="color:blue;">要确定表格的行格式，请使用“显示表格状态”：</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>SHOW TABLE STATUS IN test1\G</code></strong>
*************************** 1. row ***************************
           Name: t1
         Engine: InnoDB
        Version: 10
     Row_format: Dynamic
           Rows: 0
 Avg_row_length: 0
    Data_length: 16384
Max_data_length: 0
   Index_length: 16384
      Data_free: 0
 Auto_increment: 1
    Create_time: 2016-09-14 16:29:38
    Update_time: NULL
     Check_time: NULL
      Collation: latin1_swedish_ci
       Checksum: NULL
 Create_options:
        Comment:
</pre><p>
            Alternatively, query the
            <a class="ulink" href="https://dev.mysql.com/doc/refman/8.0/en/innodb-tables-table.html" target="_top"><code class="literal">INFORMATION_SCHEMA.INNODB_TABLES</code></a>
            table:
        </p><p style="color:blue;">或者，查询information_schema.innodb_tables表：</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT NAME, ROW_FORMAT FROM INFORMATION_SCHEMA.INNODB_SYS_TABLES WHERE NAME='test1/t1';</code></strong>
+----------+------------+
| NAME     | ROW_FORMAT |
+----------+------------+
| test1/t1 | Dynamic    |
+----------+------------+
</pre>
        </div>

    </div>
    <div class="section">
        <div class="titlepage">
            <div>
                <div>
                    <h2 class="title" style="clear: both"><a name="innodb-disk-management"></a>14.12&nbsp;InnoDB Disk I/O and File Space Management</h2>

                </div>

            </div>

        </div>
        <div class="toc">
            <dl class="toc"><dt><span class="section"><a href="innodb-storage-engine.html#innodb-disk-io">14.12.1 InnoDB Disk I/O</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-file-space">14.12.2 File Space Management</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-checkpoints">14.12.3 InnoDB Checkpoints</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-file-defragmenting">14.12.4 Defragmenting a Table</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-truncate-table-reclaim-space">14.12.5 Reclaiming Disk Space with TRUNCATE TABLE</a></span></dt></dl>
        </div>
        <p>
            As a DBA, you must manage disk I/O to keep the I/O subsystem from
            becoming saturated, and manage disk space to avoid filling up
            storage devices. The <a class="link" href="glossary.html#glos_acid" title="ACID">ACID</a> design
            model requires a certain amount of I/O that might seem redundant,
            but helps to ensure data reliability. Within these constraints,
            <code class="literal">InnoDB</code> tries to optimize the database work and
            the organization of disk files to minimize the amount of disk I/O.
            Sometimes, I/O is postponed until the database is not busy, or until
            everything needs to be brought to a consistent state, such as during
            a database restart after a <a class="link" href="glossary.html#glos_fast_shutdown" title="fast shutdown">fast
            shutdown</a>.
        </p><p style="color:blue;">作为dba，您必须管理磁盘i/o以防止i/o子系统变得饱和，并管理磁盘空间以避免填满存储设备。acid设计模型需要一定数量的i/o，这些i/o看似多余，但有助于确保数据的可靠性。在这些限制条件下，InnoDB试图优化数据库工作和磁盘文件的组织，以最小化磁盘I/O的数量。有时，I/O被推迟到数据库不忙，或者直到所有东西都需要保持一致的状态，例如在数据库快速关闭后重新启动时。</p><p>
        This section discusses the main considerations for I/O and disk
        space with the default kind of MySQL tables (also known as
        <code class="literal">InnoDB</code> tables):
    </p><p style="color:blue;">本节讨论默认类型mysql表（也称为innodb表）的i/o和磁盘空间的主要注意事项：</p>
        <div class="itemizedlist">
            <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                Controlling the amount of background I/O used to improve query
                performance.
            </p><p style="color:blue;">控制用于提高查询性能的后台I/O数量。</p></li><li class="listitem"><p>
                Enabling or disabling features that provide extra durability at
                the expense of additional I/O.
            </p><p style="color:blue;">启用或禁用以牺牲额外I/O为代价提供额外耐久性的功能。</p></li><li class="listitem"><p>
                Organizing tables into many small files, a few larger files, or
                a combination of both.
            </p><p style="color:blue;">将表组织成许多小文件、几个大文件或两者的组合。</p></li><li class="listitem"><p>
                Balancing the size of redo log files against the I/O activity
                that occurs when the log files become full.
            </p><p style="color:blue;">平衡重做日志文件的大小与日志文件满时发生的I/O活动。</p></li><li class="listitem"><p>
                How to reorganize a table for optimal query performance.
            </p><p style="color:blue;">如何重新组织表以获得最佳查询性能。</p></li></ul>
        </div>
        <div class="section">
            <div class="titlepage">
                <div>
                    <div>
                        <h3 class="title"><a name="innodb-disk-io"></a>14.12.1&nbsp;InnoDB Disk I/O</h3>

                    </div>

                </div>

            </div>
            <a class="indexterm" name="idm140286817825680"></a><p>
            <code class="literal">InnoDB</code> uses asynchronous disk I/O where
            possible, by creating a number of threads to handle I/O
            operations, while permitting other database operations to proceed
            while the I/O is still in progress. On Linux and Windows
            platforms, <code class="literal">InnoDB</code> uses the available OS and
            library functions to perform <span class="quote">“<span class="quote">native</span>”</span> asynchronous
            I/O. On other platforms, <code class="literal">InnoDB</code> still uses I/O
            threads, but the threads may actually wait for I/O requests to
            complete; this technique is known as <span class="quote">“<span class="quote">simulated</span>”</span>
            asynchronous I/O.
        </p><p style="color:blue;">InnoDB尽可能使用异步磁盘I/O，方法是创建多个线程来处理I/O操作，同时允许其他数据库操作在I/O仍在进行时继续进行。在Linux和Windows平台上，InnoDB使用可用的操作系统和库函数来执行“本机”异步I/O。在其他平台上，InnoDB仍然使用I/O线程，但线程实际上可能等待I/O请求完成；这种技术称为“模拟”异步I/O。</p>
            <div class="simplesect">

                <div class="titlepage">
                    <div>

                        <div class="simple">
                            <h4 class="title"><a name="innodb-disk-io-read-ahead"></a>Read-Ahead</h4>
                        </div>
                    </div>
                </div>
                <p>
                    If <code class="literal">InnoDB</code> can determine there is a high
                    probability that data might be needed soon, it performs
                    read-ahead operations to bring that data into the buffer pool so
                    that it is available in memory. Making a few large read requests
                    for contiguous data can be more efficient than making several
                    small, spread-out requests. There are two read-ahead heuristics
                    in <code class="literal">InnoDB</code>:
                </p><p style="color:blue;">如果innodb能够确定很快需要数据的可能性很高，它将执行预读操作，将数据带到缓冲池中，以便在内存中可用。对连续数据发出几个大的读取请求比发出几个小的分散请求更有效。InnoDB中有两种预读启发式：</p>
                <div class="itemizedlist">
                    <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                        In sequential read-ahead, if <code class="literal">InnoDB</code>
                        notices that the access pattern to a segment in the
                        tablespace is sequential, it posts in advance a batch of
                        reads of database pages to the I/O system.
                    </p><p style="color:blue;">在顺序预读中，如果innodb注意到表空间中某个段的访问模式是顺序的，那么它会提前向i/o系统发送一批数据库页的读取。</p></li><li class="listitem"><p>
                        In random read-ahead, if <code class="literal">InnoDB</code> notices
                        that some area in a tablespace seems to be in the process of
                        being fully read into the buffer pool, it posts the
                        remaining reads to the I/O system.
                    </p><p style="color:blue;">在随机预读中，如果innodb注意到表空间中的某个区域似乎正在完全读入缓冲池，那么它会将剩余的读操作发送到i/o系统。</p></li></ul>
                </div>
                <p>
                    For information about configuring read-ahead heuristics, see
                    <a class="xref" href="innodb-storage-engine.html#innodb-performance-read_ahead" title="14.8.3.4&nbsp;Configuring InnoDB Buffer Pool Prefetching (Read-Ahead)">Section&nbsp;14.8.3.4, “Configuring InnoDB Buffer Pool Prefetching (Read-Ahead)”</a>.
                </p><p style="color:blue;">有关配置预读启发式的信息，请参阅14.8.3.4节，“配置InnoDB缓冲池预取（预读）”。</p>
            </div>
            <div class="simplesect">
                <div class="titlepage">
                    <div>
                        <div class="simple">
                            <h4 class="title"><a name="innodb-disk-io-doublewrite"></a>Doublewrite Buffer</h4>

                        </div>

                    </div>

                </div>
                <a class="indexterm" name="idm140286817810496"></a><a class="indexterm" name="idm140286817809424"></a><p>
                <code class="literal">InnoDB</code> uses a novel file flush technique
                involving a structure called the
                <a class="link" href="glossary.html#glos_doublewrite_buffer" title="doublewrite buffer">doublewrite
                    buffer</a>, which is enabled by default in most cases
                (<a class="link" href="innodb-storage-engine.html#sysvar_innodb_doublewrite"><code class="literal">innodb_doublewrite=ON</code></a>). It
                adds safety to recovery following a crash or power outage, and
                improves performance on most varieties of Unix by reducing the
                need for <code class="literal">fsync()</code> operations.
            </p><p style="color:blue;">InnoDB使用了一种新的文件刷新技术，其中包含一个名为doublewrite buffer的结构，在大多数情况下（innodb_doublewrite=on）默认启用该结构。它为崩溃或断电后的恢复增加了安全性，并通过减少对fsync（）操作的需要，提高了大多数Unix上的性能。</p><p>
                Before writing pages to a data file, <code class="literal">InnoDB</code>
                first writes them to a contiguous tablespace area called the
                doublewrite buffer. Only after the write and the flush to the
                doublewrite buffer has completed does <code class="literal">InnoDB</code>
                write the pages to their proper positions in the data file. If
                there is an operating system, storage subsystem, or
                <a class="link" href="programs.html#mysqld" title="4.3.1&nbsp;mysqld — The MySQL Server"><span class="command"><strong>mysqld</strong></span></a> process crash in the middle of a page
                write (causing a <a class="link" href="glossary.html#glos_torn_page" title="torn page">torn page</a>
                condition), <code class="literal">InnoDB</code> can later find a good copy
                of the page from the doublewrite buffer during recovery.
            </p><p style="color:blue;">在将页面写入数据文件之前，innodb首先将它们写入一个称为doublewrite缓冲区的连续表空间区域。只有在对doublewrite缓冲区的写入和刷新完成之后，innodb才会将页面写入数据文件中的正确位置。如果在页面写入过程中出现操作系统、存储子系统或mysqld进程崩溃（导致页面损坏），innodb稍后可以在恢复期间从doublewrite缓冲区中找到页面的一个好副本。</p><p>
                If system tablespace files (<span class="quote">“<span class="quote">ibdata files</span>”</span>) are
                located on Fusion-io devices that support atomic writes,
                doublewrite buffering is automatically disabled and Fusion-io
                atomic writes are used for all data files. Because the
                doublewrite buffer setting is global, doublewrite buffering is
                also disabled for data files residing on non-Fusion-io hardware.
                This feature is only supported on Fusion-io hardware and is only
                enabled for Fusion-io NVMFS on Linux. To take full advantage of
                this feature, an
                <a class="link" href="innodb-storage-engine.html#sysvar_innodb_flush_method"><code class="literal">innodb_flush_method</code></a> setting of
                <code class="literal">O_DIRECT</code> is recommended.
            </p><p style="color:blue;">如果系统表空间文件（“ibdata文件”）位于支持原子写入的fusion io设备上，则会自动禁用doublewrite缓冲，并对所有数据文件使用fusion io原子写入。由于doublewrite缓冲区设置是全局的，因此也会对驻留在非Fusion IO硬件上的数据文件禁用doublewrite缓冲。此功能仅在Fusion IO硬件上受支持，并且仅在Linux上为Fusion IO NVMFS启用。为了充分利用这一特性，建议将innodb_flush_method设置为o_direct。</p>
            </div>

        </div>
        <div class="section">
            <div class="titlepage">
                <div>
                    <div>
                        <h3 class="title"><a name="innodb-file-space"></a>14.12.2&nbsp;File Space Management</h3>

                    </div>

                </div>

            </div>
            <a class="indexterm" name="idm140286817794224"></a><p>
            The data files that you define in the configuration file using the
            <a class="link" href="innodb-storage-engine.html#sysvar_innodb_data_file_path"><code class="literal">innodb_data_file_path</code></a>
            configuration option form the <code class="literal">InnoDB</code>
            <a class="link" href="glossary.html#glos_system_tablespace" title="system tablespace">system tablespace</a>.
            The files are logically concatenated to form the system
            tablespace. There is no striping in use. You cannot define where
            within the system tablespace your tables are allocated. In a newly
            created system tablespace, <code class="literal">InnoDB</code> allocates
            space starting from the first data file.
        </p><p style="color:blue;">使用innodb_data_file_path配置选项在配置文件中定义的数据文件构成innodb系统表空间。这些文件被逻辑连接起来形成系统表空间。没有使用条纹。不能定义表在系统表空间中的分配位置。在新创建的系统表空间中，innodb从第一个数据文件开始分配空间。</p><p>
            To avoid the issues that come with storing all tables and indexes
            inside the system tablespace, you can enable the
            <a class="link" href="innodb-storage-engine.html#sysvar_innodb_file_per_table"><code class="literal">innodb_file_per_table</code></a>
            configuration option (the default), which stores each newly
            created table in a separate tablespace file (with extension
            <code class="literal">.ibd</code>). For tables stored this way, there is
            less fragmentation within the disk file, and when the table is
            truncated, the space is returned to the operating system rather
            than still being reserved by InnoDB within the system tablespace.
            For more information, see
            <a class="xref" href="innodb-storage-engine.html#innodb-multiple-tablespaces" title="14.6.3.2&nbsp;File-Per-Table Tablespaces">Section&nbsp;14.6.3.2, “File-Per-Table Tablespaces”</a>.
        </p><p style="color:blue;">为了避免在系统表空间中存储所有表和索引时出现的问题，可以启用innodb_file_per_table configuration选项（默认值），该选项将每个新创建的表存储在一个单独的表空间文件中（扩展名为.ibd）。对于以这种方式存储的表，磁盘文件中的碎片较少，当表被截断时，空间将返回给操作系统，而不是仍然由innodb保留在系统表空间中。有关更多信息，请参阅14.6.3.2节“每个表空间的文件”。</p><p>
            You can also store tables in
            <a class="link" href="glossary.html#glos_general_tablespace" title="general tablespace">general
                tablespaces</a>. General tablespaces are shared tablespaces
            created using <a class="link" href="sql-syntax.html#create-tablespace" title="13.1.19&nbsp;CREATE TABLESPACE Syntax"><code class="literal">CREATE TABLESPACE</code></a>
            syntax. They can be created outside of the MySQL data directory,
            are capable of holding multiple tables, and support tables of all
            row formats. For more information, see
            <a class="xref" href="innodb-storage-engine.html#general-tablespaces" title="14.6.3.3&nbsp;General Tablespaces">Section&nbsp;14.6.3.3, “General Tablespaces”</a>.
        </p><p style="color:blue;">还可以将表存储在常规表空间中。通用表空间是使用CREATE TABLESPACE语法创建的共享表空间。它们可以在mysql数据目录之外创建，能够保存多个表，并且支持所有行格式的表。有关更多信息，请参阅14.6.3.3节“常规表空间”。</p>
            <h4><a name="idm140286817781184"></a>Pages, Extents, Segments, and Tablespaces</h4>
            <p>
                Each tablespace consists of database
                <a class="link" href="glossary.html#glos_page" title="page">pages</a>. Every tablespace in a
                MySQL instance has the same <a class="link" href="glossary.html#glos_page_size" title="page size">page
                size</a>. By default, all tablespaces have a page size of 16KB;
                you can reduce the page size to 8KB or 4KB by specifying the
                <a class="link" href="innodb-storage-engine.html#sysvar_innodb_page_size"><code class="literal">innodb_page_size</code></a> option when you
                create the MySQL instance. You can also increase the page size to
                32KB or 64KB. For more information, refer to the
                <a class="link" href="innodb-storage-engine.html#sysvar_innodb_page_size"><code class="literal">innodb_page_size</code></a> documentation.
            </p><p style="color:blue;">每个表空间由数据库页组成。mysql实例中的每个表空间都有相同的页面大小。默认情况下，所有表空间的页面大小都是16kb；您可以在创建mysql实例时通过指定innodb_page_size选项将页面大小减少到8kb或4kb。您还可以将页面大小增加到32KB或64KB。有关更多信息，请参阅innodb_page_size文档。</p><p>
            The pages are grouped into
            <a class="link" href="glossary.html#glos_extent" title="extent">extents</a> of size 1MB for pages
            up to 16KB in size (64 consecutive 16KB pages, or 128 8KB pages,
            or 256 4KB pages). For a page size of 32KB, extent size is 2MB.
            For page size of 64KB, extent size is 4MB. The
            <span class="quote">“<span class="quote">files</span>”</span> inside a tablespace are called
            <a class="link" href="glossary.html#glos_segment" title="segment">segments</a> in
            <code class="literal">InnoDB</code>. (These segments are different from the
            <a class="link" href="glossary.html#glos_rollback_segment" title="rollback segment">rollback segment</a>,
            which actually contains many tablespace segments.)
        </p><p style="color:blue;">对于大小不超过16KB的页面（64个连续16KB的页面，或128个8KB的页面，或256个4KB的页面），这些页面被分组为大小为1MB的区段。对于32kb的页面大小，区段大小为2mb。对于64KB的页面大小，扩展数据块大小为4MB。表空间中的“文件”在innodb中称为段。（这些段与回滚段不同，回滚段实际上包含许多表空间段。）</p><p>
            When a segment grows inside the tablespace,
            <code class="literal">InnoDB</code> allocates the first 32 pages to it one
            at a time. After that, <code class="literal">InnoDB</code> starts to
            allocate whole extents to the segment. <code class="literal">InnoDB</code>
            can add up to 4 extents at a time to a large segment to ensure
            good sequentiality of data.
        </p><p style="color:blue;">当一个段在表空间内增长时，innodb一次为它分配前32页。之后，innodb开始向段分配整个区段。InnoDB一次最多可以向一个大段添加4个区段，以确保数据的良好顺序性。</p><p>
            Two segments are allocated for each index in
            <code class="literal">InnoDB</code>. One is for nonleaf nodes of the
            <a class="link" href="glossary.html#glos_b_tree" title="B-tree">B-tree</a>, the other is for the
            leaf nodes. Keeping the leaf nodes contiguous on disk enables
            better sequential I/O operations, because these leaf nodes contain
            the actual table data.
        </p><p style="color:blue;">为innodb中的每个索引分配两个段。一个用于b-树的非叶节点，另一个用于叶节点。保持叶节点在磁盘上的连续性可以实现更好的顺序I/O操作，因为这些叶节点包含实际的表数据。</p><p>
            Some pages in the tablespace contain bitmaps of other pages, and
            therefore a few extents in an <code class="literal">InnoDB</code> tablespace
            cannot be allocated to segments as a whole, but only as individual
            pages.
        </p><p style="color:blue;">表空间中的某些页包含其他页的位图，因此innodb表空间中的一些区段不能作为一个整体分配给段，而只能作为单个页分配。</p><p>
            When you ask for available free space in the tablespace by issuing
            a <a class="link" href="sql-syntax.html#show-table-status" title="13.7.5.36&nbsp;SHOW TABLE STATUS Syntax"><code class="literal">SHOW TABLE STATUS</code></a> statement,
            <code class="literal">InnoDB</code> reports the extents that are definitely
            free in the tablespace. <code class="literal">InnoDB</code> always reserves
            some extents for cleanup and other internal purposes; these
            reserved extents are not included in the free space.
        </p><p style="color:blue;">当您通过发出show table status语句来请求表空间中的可用空间时，innodb报告表空间中绝对可用的扩展数据块。innodb总是为清理和其他内部用途保留一些区段；这些保留的区段不包括在可用空间中。</p><p>
            When you delete data from a table, <code class="literal">InnoDB</code>
            contracts the corresponding B-tree indexes. Whether the freed
            space becomes available for other users depends on whether the
            pattern of deletes frees individual pages or extents to the
            tablespace. Dropping a table or deleting all rows from it is
            guaranteed to release the space to other users, but remember that
            deleted rows are physically removed only by the
            <a class="link" href="glossary.html#glos_purge" title="purge">purge</a> operation, which happens
            automatically some time after they are no longer needed for
            transaction rollbacks or consistent reads. (See
            <a class="xref" href="innodb-storage-engine.html#innodb-multi-versioning" title="14.3&nbsp;InnoDB Multi-Versioning">Section&nbsp;14.3, “InnoDB Multi-Versioning”</a>.)
        </p><p style="color:blue;">从表中删除数据时，innodb会收缩相应的b树索引。释放的空间是否对其他用户可用取决于delete模式是否将单个页面或区段释放到表空间。删除表或删除表中的所有行可以保证将空间释放给其他用户，但请记住，删除的行只有通过清除操作才能物理删除，而清除操作在事务回滚或一致性读取不再需要这些行之后的一段时间内自动执行。（见第14.3节，“InnoDB多版本控制”。）</p>
            <h4><a name="idm140286817757872"></a>How Pages Relate to Table Rows</h4>
            <p>
                The maximum row length is slightly less than half a database page
                for 4KB, 8KB, 16KB, and 32KB
                <a class="link" href="innodb-storage-engine.html#sysvar_innodb_page_size"><code class="literal">innodb_page_size</code></a> settings. For
                example, the maximum row length is slightly less than 8KB for the
                default 16KB <code class="literal">InnoDB</code> page size. For 64KB pages,
                the maximum row length is slightly less than 16KB.
            </p><p style="color:blue;">最大行长度略小于数据库页的4KB、8KB、16KB和32 KNYNDB的Page大小设置。例如，对于默认16kb的YNDB页面大小，最大行长度略小于8KB。对于64KB页，最大行长度略小于16KB。</p><p>
            If a row does not exceed the maximum row length, all of it is
            stored locally within the page. If a row exceeds the maximum row
            length, <a class="link" href="glossary.html#glos_variable_length_type" title="variable-length type">variable-length
            columns</a> are chosen for external off-page storage until the
            row fits within the maximum row length limit. External off-page
            storage for variable-length columns differs by row format:
        </p><p style="color:blue;">如果行不超过最大行长度，则所有行都在本地存储在页中。如果行超过最大行长度，则选择可变长度列以用于外部的外页存储，直到行符合最大行长度限制。可变长度列的外部页外存储因行格式而异：</p>
            <div class="itemizedlist">
                <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                    <span class="emphasis"><em>COMPACT and REDUNDANT Row Formats</em></span>
                </p><p style="color:blue;">压缩和冗余行格式</p><p>
                    When a variable-length column is chosen for external off-page
                    storage, <code class="literal">InnoDB</code> stores the first 768 bytes
                    locally in the row, and the rest externally into overflow
                    pages. Each such column has its own list of overflow pages.
                    The 768-byte prefix is accompanied by a 20-byte value that
                    stores the true length of the column and points into the
                    overflow list where the rest of the value is stored. See
                    <a class="xref" href="innodb-storage-engine.html#innodb-row-format" title="14.11&nbsp;InnoDB Row Formats">Section&nbsp;14.11, “InnoDB Row Formats”</a>.
                </p><p style="color:blue;">当选择可变长度列作为外部页外存储时，innodb将第一个768字节本地存储在行中，其余的外部存储在溢出页中。每个这样的列都有自己的溢出页列表。768字节的前缀附带一个20字节的值，该值存储列的真实长度，并指向溢出列表中存储剩余值的位置。见第14.11节，“InnoDB行格式”。</p></li><li class="listitem"><p>
                    <span class="emphasis"><em>DYNAMIC and COMPRESSED Row Formats</em></span>
                </p><p style="color:blue;">动态和压缩行格式</p><p>
                    When a variable-length column is chosen for external off-page
                    storage, <code class="literal">InnoDB</code> stores a 20-byte pointer
                    locally in the row, and the rest externally into overflow
                    pages. See <a class="xref" href="innodb-storage-engine.html#innodb-row-format" title="14.11&nbsp;InnoDB Row Formats">Section&nbsp;14.11, “InnoDB Row Formats”</a>.
                </p><p style="color:blue;">当选择可变长度列作为外部页外存储时，innodb会在行中本地存储一个20字节的指针，其余的则在外部存储到溢出页中。见第14.11节，“InnoDB行格式”。</p></li></ul>
            </div>
            <p>
                <a class="link" href="data-types.html#blob" title="11.4.3&nbsp;The BLOB and TEXT Types"><code class="literal">LONGBLOB</code></a> and
                <a class="link" href="data-types.html#blob" title="11.4.3&nbsp;The BLOB and TEXT Types"><code class="literal">LONGTEXT</code></a> columns
                must be less than 4GB, and the total row length, including
                <a class="link" href="data-types.html#blob" title="11.4.3&nbsp;The BLOB and TEXT Types"><code class="literal">BLOB</code></a> and
                <a class="link" href="data-types.html#blob" title="11.4.3&nbsp;The BLOB and TEXT Types"><code class="literal">TEXT</code></a> columns, must be less than
                4GB.
            </p><p style="color:blue;">longblob和longtext列必须小于4gb，并且包括blob和text列在内的总行长度必须小于4gb。</p>
        </div>
        <div class="section">
            <div class="titlepage">
                <div>
                    <div>
                        <h3 class="title"><a name="innodb-checkpoints"></a>14.12.3&nbsp;InnoDB Checkpoints</h3>

                    </div>

                </div>

            </div>
            <a class="indexterm" name="idm140286817739184"></a><p>
            Making your <a class="link" href="glossary.html#glos_log_file" title="log file">log files</a> very
            large may reduce disk I/O during
            <a class="link" href="glossary.html#glos_checkpoint" title="checkpoint">checkpointing</a>. It often
            makes sense to set the total size of the log files as large as the
            buffer pool or even larger. Although in the past large log files
            could make crash recovery take excessive time, starting with MySQL
            5.5, performance enhancements to crash recovery make it possible
            to use large log files with fast startup after a crash. (Strictly
            speaking, this performance improvement is available for MySQL 5.1
            with the InnoDB Plugin 1.0.7 and higher. It is with MySQL 5.5 that
            this improvement is available in the default InnoDB storage
            engine.)
        </p><p style="color:blue;">使日志文件非常大可能会减少检查点期间的磁盘I/O。将日志文件的总大小设置为与缓冲池一样大甚至更大通常是有意义的。尽管在过去，从mysql 5.5开始，大型日志文件可能会使崩溃恢复花费过多的时间，但对崩溃恢复的性能增强使在崩溃后快速启动时使用大型日志文件成为可能。（严格地说，这种性能改进适用于带有innodb插件1.0.7和更高版本的mysql 5.1。在mysql 5.5中，默认的innodb存储引擎中提供了这种改进。）</p>
            <h4><a name="idm140286817734992"></a>How Checkpoint Processing Works</h4>
            <p>
                <code class="literal">InnoDB</code> implements a
                <a class="link" href="glossary.html#glos_checkpoint" title="checkpoint">checkpoint</a> mechanism known
                as <a class="link" href="glossary.html#glos_fuzzy_checkpointing" title="fuzzy checkpointing">fuzzy
                checkpointing</a>. <code class="literal">InnoDB</code> flushes modified
                database pages from the buffer pool in small batches. There is no
                need to flush the buffer pool in one single batch, which would
                disrupt processing of user SQL statements during the checkpointing
                process.
            </p><p style="color:blue;">innodb实现了一种称为模糊检查点的检查点机制。innodb从缓冲池中以小批量刷新修改过的数据库页面。不需要在一个批处理中刷新缓冲池，这将在检查点过程中中断用户sql语句的处理。</p><p>
            During <a class="link" href="glossary.html#glos_crash_recovery" title="crash recovery">crash recovery</a>,
            <code class="literal">InnoDB</code> looks for a checkpoint label written to
            the log files. It knows that all modifications to the database
            before the label are present in the disk image of the database.
            Then <code class="literal">InnoDB</code> scans the log files forward from
            the checkpoint, applying the logged modifications to the database.
        </p><p style="color:blue;">在崩溃恢复期间，innodb查找写入日志文件的检查点标签。它知道在标签出现在数据库的磁盘映像中之前对数据库的所有修改。然后innodb从检查点向前扫描日志文件，对数据库应用记录的修改。</p>
        </div>
        <div class="section">
            <div class="titlepage">
                <div>
                    <div>
                        <h3 class="title"><a name="innodb-file-defragmenting"></a>14.12.4&nbsp;Defragmenting a Table</h3>

                    </div>

                </div>

            </div>
            <a class="indexterm" name="idm140286817726064"></a><a class="indexterm" name="idm140286817724160"></a><p>
            Random insertions into or deletions from a secondary index can
            cause the index to become fragmented. Fragmentation means that the
            physical ordering of the index pages on the disk is not close to
            the index ordering of the records on the pages, or that there are
            many unused pages in the 64-page blocks that were allocated to the
            index.
        </p><p style="color:blue;">对二级索引的随机插入或删除可能导致索引碎片化。分段意味着磁盘上索引页的物理顺序与页上记录的索引顺序不接近，或者在分配给索引的64页块中有许多未使用的页。</p><p>
            One symptom of fragmentation is that a table takes more space than
            it <span class="quote">“<span class="quote">should</span>”</span> take. How much that is exactly, is
            difficult to determine. All <code class="literal">InnoDB</code> data and
            indexes are stored in <a class="link" href="glossary.html#glos_b_tree" title="B-tree">B-trees</a>,
            and their <a class="link" href="glossary.html#glos_fill_factor" title="fill factor">fill factor</a> may
            vary from 50% to 100%. Another symptom of fragmentation is that a
            table scan such as this takes more time than it
            <span class="quote">“<span class="quote">should</span>”</span> take:
        </p><p style="color:blue;">碎片化的一个症状是表占用的空间比“应该”占用的空间多。具体是多少，很难确定。所有innodb数据和索引都存储在b树中，它们的填充因子可以在50%到100%之间变化。碎片化的另一个症状是，这样的表扫描所需的时间比“应该”要长：</p><pre data-lang="sql" class="programlisting">SELECT COUNT(*) FROM t WHERE <em class="replaceable"><code>non_indexed_column</code></em> &lt;&gt; 12345;
</pre><p>
            The preceding query requires MySQL to perform a full table scan,
            the slowest type of query for a large table.
        </p><p style="color:blue;">前面的查询要求mysql执行全表扫描，这是大型表的最慢查询类型。</p><p>
            To speed up index scans, you can periodically perform a
            <span class="quote">“<span class="quote">null</span>”</span> <a class="link" href="sql-syntax.html#alter-table" title="13.1.8&nbsp;ALTER TABLE Syntax"><code class="literal">ALTER TABLE</code></a>
            operation, which causes MySQL to rebuild the table:
        </p><p style="color:blue;">为了加快索引扫描速度，可以定期执行“null”alter table操作，这将导致mysql重新生成表：</p><pre data-lang="sql" class="programlisting">ALTER TABLE <em class="replaceable"><code>tbl_name</code></em> ENGINE=INNODB
</pre><p>
            You can also use
            <a class="link" href="sql-syntax.html#alter-table" title="13.1.8&nbsp;ALTER TABLE Syntax"><code class="literal">ALTER TABLE
                <em class="replaceable"><code>tbl_name</code></em> FORCE</code></a> to perform a
            <span class="quote">“<span class="quote">null</span>”</span> alter operation that rebuilds the table.
        </p><p style="color:blue;">您还可以使用alter table tbl_name force执行“null”alter操作来重建表。</p><p>
            Both <a class="link" href="sql-syntax.html#alter-table" title="13.1.8&nbsp;ALTER TABLE Syntax"><code class="literal">ALTER TABLE
            <em class="replaceable"><code>tbl_name</code></em> ENGINE=INNODB</code></a> and
            <a class="link" href="sql-syntax.html#alter-table" title="13.1.8&nbsp;ALTER TABLE Syntax"><code class="literal">ALTER TABLE
                <em class="replaceable"><code>tbl_name</code></em> FORCE</code></a> use
            <a class="link" href="innodb-storage-engine.html#innodb-online-ddl" title="14.13&nbsp;InnoDB and Online DDL">online DDL</a>. For more
            information, see <a class="xref" href="innodb-storage-engine.html#innodb-online-ddl" title="14.13&nbsp;InnoDB and Online DDL">Section&nbsp;14.13, “InnoDB and Online DDL”</a>.
        </p><p style="color:blue;">alter table tbl_name engine=innodb和alter table tbl_name force都使用联机ddl。有关更多信息，请参见第14.13节“InnoDB和联机DDL”。</p><p>
            Another way to perform a defragmentation operation is to use
            <a class="link" href="programs.html#mysqldump" title="4.5.4&nbsp;mysqldump — A Database Backup Program"><span class="command"><strong>mysqldump</strong></span></a> to dump the table to a text file,
            drop the table, and reload it from the dump file.
        </p><p style="color:blue;">执行碎片整理操作的另一种方法是使用mysqldump将表转储到文本文件，删除表，然后从转储文件重新加载它。</p><p>
            If the insertions into an index are always ascending and records
            are deleted only from the end, the <code class="literal">InnoDB</code>
            filespace management algorithm guarantees that fragmentation in
            the index does not occur.
        </p><p style="color:blue;">如果索引中的插入总是递增的，并且只从末尾删除记录，那么innodb文件空间管理算法保证索引中不会出现碎片。</p>
        </div>
        <div class="section">
            <div class="titlepage">
                <div>
                    <div>
                        <h3 class="title"><a name="innodb-truncate-table-reclaim-space"></a>14.12.5&nbsp;Reclaiming Disk Space with TRUNCATE TABLE</h3>

                    </div>

                </div>

            </div>
            <p>
                To reclaim operating system disk space when
                <a class="link" href="glossary.html#glos_truncate" title="truncate">truncating</a> an
                <code class="literal">InnoDB</code> table, the table must be stored in its
                own <a class="link" href="glossary.html#glos_ibd_file" title=".ibd file">.ibd</a> file. For a table to
                be stored in its own <a class="link" href="glossary.html#glos_ibd_file" title=".ibd file">.ibd</a>
                file, <a class="link" href="innodb-storage-engine.html#sysvar_innodb_file_per_table"><code class="literal">innodb_file_per_table</code></a> must
                enabled when the table is created. Additionally, there cannot be a
                <a class="link" href="glossary.html#glos_foreign_key" title="foreign key">foreign key</a> constraint
                between the table being truncated and other tables, otherwise the
                <code class="literal">TRUNCATE TABLE</code> operation fails. A foreign key
                constraint between two columns in the same table, however, is
                permitted.
            </p><p style="color:blue;">要在截断innodb表时回收操作系统磁盘空间，该表必须存储在自己的.ibd文件中。对于要存储在自己的.ibd文件中的表，创建该表时必须启用innodb_file_per_table。另外，被截断的表和其他表之间不能有外键约束，否则截断表操作将失败。但是，允许在同一表中的两列之间使用外键约束。</p><p>
            When a table is truncated, it is dropped and re-created in a new
            <code class="filename">.ibd</code> file, and the freed space is returned to
            the operating system. This is in contrast to truncating
            <code class="literal">InnoDB</code> tables that are stored within the
            <code class="literal">InnoDB</code>
            <a class="link" href="glossary.html#glos_system_tablespace" title="system tablespace">system tablespace</a>
            (tables created when <code class="literal">innodb_file_per_table=OFF</code>)
            and tables stored in shared
            <a class="link" href="glossary.html#glos_general_tablespace" title="general tablespace">general
                tablespaces</a>, where only <code class="literal">InnoDB</code> can use
            the freed space after the table is truncated.
        </p><p style="color:blue;">当表被截断时，它将被删除并在新的.ibd文件中重新创建，释放的空间将返回给操作系统。这与截断存储在innodb系统表空间中的innodb表（当innodb_file_per_table=off时创建的表）和存储在共享通用表空间中的表相反，在共享通用表空间中，只有innodb可以在表被截断后使用释放的空间。</p><p>
            The ability to truncate tables and return disk space to the
            operating system also means that
            <a class="link" href="glossary.html#glos_physical_backup" title="physical backup">physical backups</a> can
            be smaller. Truncating tables that are stored in the system
            tablespace (tables created when
            <code class="literal">innodb_file_per_table=OFF</code>) or in a general
            tablespace leaves blocks of unused space in the tablespace.
        </p><p style="color:blue;">截断表并将磁盘空间返回到操作系统的能力还意味着物理备份可以更小。截断存储在系统表空间（当innodb_file_per_table=off时创建的表）或一般表空间中的表会在表空间中留下未使用的空间块。</p>
        </div>

    </div>
    <div class="section">
        <div class="titlepage">
            <div>
                <div>
                    <h2 class="title" style="clear: both"><a name="innodb-online-ddl"></a>14.13&nbsp;InnoDB and Online DDL</h2>

                </div>

            </div>

        </div>
        <div class="toc">
            <dl class="toc"><dt><span class="section"><a href="innodb-storage-engine.html#innodb-online-ddl-operations">14.13.1 Online DDL Operations</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-online-ddl-performance">14.13.2 Online DDL Performance and Concurrency</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-online-ddl-space-requirements">14.13.3 Online DDL Space Requirements</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-online-ddl-single-multi">14.13.4 Simplifying DDL Statements with Online DDL</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-online-ddl-failure-conditions">14.13.5 Online DDL Failure Conditions</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-online-ddl-limitations">14.13.6 Online DDL Limitations</a></span></dt></dl>
        </div>
        <a class="indexterm" name="idm140286817683456"></a><a class="indexterm" name="idm140286817682384"></a><p>
        The online DDL feature provides support for in-place table
        alterations and concurrent DML. Benefits of this feature include:
    </p><p style="color:blue;">联机ddl特性支持就地表转换和并发dml。此功能的优点包括：</p>
        <div class="itemizedlist">
            <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                Improved responsiveness and availability in busy production
                environments, where making a table unavailable for minutes or
                hours is not practical.
            </p><p style="color:blue;">在繁忙的生产环境中提高了响应能力和可用性，在这种环境中，使表在几分钟或几小时内不可用是不实际的。</p></li><li class="listitem"><p>
                The ability to adjust the balance between performance and
                concurrency during DDL operations using the
                <code class="literal">LOCK</code> clause. See
                <a class="xref" href="innodb-storage-engine.html#innodb-online-ddl-locking-options" title="The LOCK clause">The LOCK clause</a>.
            </p><p style="color:blue;">使用lock子句在ddl操作期间调整性能和并发性之间的平衡的能力。参见锁定条款。</p></li><li class="listitem"><p>
                Less disk space usage and I/O overhead than the table-copy
                method.
            </p><p style="color:blue;">比表复制方法更少的磁盘空间使用和I/O开销。</p></li></ul>
        </div>
        <p>
            Typically, you do not need to do anything special to enable online
            DDL. By default, MySQL performs the operation in place, as
            permitted, with as little locking as possible.
        </p><p style="color:blue;">通常，您不需要做任何特殊的事情来启用联机ddl。默认情况下，mysql在允许的情况下就地执行操作，并且尽可能少地锁定。</p><p>
        You can control aspects of a DDL operation using the
        <code class="literal">ALGORITHM</code> and <code class="literal">LOCK</code> clauses of
        the <a class="link" href="sql-syntax.html#alter-table" title="13.1.8&nbsp;ALTER TABLE Syntax"><code class="literal">ALTER TABLE</code></a> statement. These
        clauses are placed at the end of the statement, separated from the
        table and column specifications by commas. For example:
    </p><p style="color:blue;">可以使用alter table语句的算法和lock子句控制ddl操作的各个方面。这些子句放在语句的末尾，用逗号与表和列规范分开。例如：</p><pre data-lang="sql" class="programlisting">ALTER TABLE <em class="replaceable"><code>tbl_name</code></em> ADD PRIMARY KEY (<em class="replaceable"><code>column</code></em>), ALGORITHM=INPLACE, LOCK=NONE;
</pre><p>
        The <code class="literal">LOCK</code> clause is useful for fine-tuning the
        degree of concurrent access to the table. The
        <code class="literal">ALGORITHM</code> clause is primarily intended for
        performance comparisons and as a fallback to the older table-copying
        behavior in case you encounter any issues. For example:
    </p><p style="color:blue;">lock子句对于微调表的并发访问程度非常有用。algorithm子句主要用于性能比较，并在遇到任何问题时作为对旧表复制行为的回退。例如：</p>
        <div class="itemizedlist">
            <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                To avoid accidentally making the table unavailable for reads,
                writes, or both, specify a clause on the
                <a class="link" href="sql-syntax.html#alter-table" title="13.1.8&nbsp;ALTER TABLE Syntax"><code class="literal">ALTER TABLE</code></a> statement such as
                <code class="literal">LOCK=NONE</code> (permit reads and writes) or
                <code class="literal">LOCK=SHARED</code> (permit reads). The operation
                halts immediately if the requested level of concurrency is not
                available.
            </p><p style="color:blue;">为了避免意外地使表无法进行读、写或同时进行读、写操作，请在alter table语句中指定一个子句，例如lock=none（permit reads and writes）或lock=shared（permit reads）。如果请求的并发级别不可用，则操作立即停止。</p></li><li class="listitem"><p>
                To compare performance between algorithms, run a statement with
                <code class="literal">ALGORITHM=INPLACE</code> and
                <code class="literal">ALGORITHM=COPY</code>. Alternatively, run a
                statement with the
                <a class="link" href="server-administration.html#sysvar_old_alter_table"><code class="literal">old_alter_table</code></a> configuration
                option disabled and enabled.
            </p><p style="color:blue;">要比较算法之间的性能，请使用algorithm=inplace和algorithm=copy运行一个语句。或者，运行一个语句，禁用并启用old_alter_table configuration选项。</p></li><li class="listitem"><p>
                To avoid tying up the server with an <a class="link" href="sql-syntax.html#alter-table" title="13.1.8&nbsp;ALTER TABLE Syntax"><code class="literal">ALTER
                TABLE</code></a> operation that copies the table, include
                <code class="literal">ALGORITHM=INPLACE</code>. The statement halts
                immediately if it cannot use the in-place mechanism.
            </p><p style="color:blue;">为了避免将服务器与复制表的alter table操作捆绑在一起，include algorithm=inplace。如果无法使用就地机制，则语句立即停止。</p></li></ul>
        </div>
        <div class="section">
            <div class="titlepage">
                <div>
                    <div>
                        <h3 class="title"><a name="innodb-online-ddl-operations"></a>14.13.1&nbsp;Online DDL Operations</h3>

                    </div>

                </div>

            </div>
            <a class="indexterm" name="idm140286817656000"></a><p>
            Online support details, syntax examples, and usage notes for DDL
            operations are provided under the following topics in this
            section.
        </p><p style="color:blue;">本节的以下主题提供了DDL操作的联机支持详细信息、语法示例和用法说明。</p>
            <div class="itemizedlist">
                <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><a class="xref" href="innodb-storage-engine.html#online-ddl-index-operations" title="Index Operations">Index Operations</a></p><p style="color:blue;">索引操作</p></li><li class="listitem"><p><a class="xref" href="innodb-storage-engine.html#online-ddl-primary-key-operations" title="Primary Key Operations">Primary Key Operations</a></p><p style="color:blue;">主键操作</p></li><li class="listitem"><p><a class="xref" href="innodb-storage-engine.html#online-ddl-column-operations" title="Column Operations">Column Operations</a></p><p style="color:blue;">列操作</p></li><li class="listitem"><p><a class="xref" href="innodb-storage-engine.html#online-ddl-generated-column-operations" title="Generated Column Operations">Generated Column Operations</a></p><p style="color:blue;">生成的列操作</p></li><li class="listitem"><p><a class="xref" href="innodb-storage-engine.html#online-ddl-foreign-key-operations" title="Foreign Key Operations">Foreign Key Operations</a></p><p style="color:blue;">外键操作</p></li><li class="listitem"><p><a class="xref" href="innodb-storage-engine.html#online-ddl-table-operations" title="Table Operations">Table Operations</a></p><p style="color:blue;">表操作</p></li><li class="listitem"><p><a class="xref" href="innodb-storage-engine.html#online-ddl-tablespace-operations" title="Tablespace Operations">Tablespace Operations</a></p><p style="color:blue;">表空间操作</p></li><li class="listitem"><p><a class="xref" href="innodb-storage-engine.html#online-ddl-partitioning" title="Partitioning Operations">Partitioning Operations</a></p><p style="color:blue;">分区操作</p></li></ul>
            </div>

            <div class="simplesect">

                <div class="titlepage">
                    <div>

                        <div class="simple">
                            <h4 class="title"><a name="online-ddl-index-operations"></a>Index Operations</h4>

                        </div>

                    </div>

                </div>
                <p>
                    The following table provides an overview of online DDL support
                    for index operations. An asterisk indicates additional
                    information, an exception, or a dependency. For details, see
                    <a class="xref" href="innodb-storage-engine.html#online-ddl-index-syntax-notes" title="Syntax and Usage Notes">Syntax and Usage Notes</a>.
                </p><p style="color:blue;">下表概述了对索引操作的联机ddl支持。星号表示附加信息、异常或依赖项。有关详细信息，请参见语法和用法说明。</p>
                <div class="table">
                    <a name="online-ddl-index-operations-table"></a><p class="title"><b>Table&nbsp;14.11&nbsp;Online DDL Support for Index Operations</b></p><p style="color:blue;">表14.11索引操作的在线ddl支持</p>
                    <div class="table-contents">
                        <table summary="Online DDL support for index operations indicating whether the operation is performed in place, rebuilds the table, permits concurrent DML, or only modifies metadata."><colgroup><col width="20%" align="left"><col width="20%" align="center"><col width="20%" align="center"><col width="20%" align="center"><col width="20%" align="center"></colgroup><thead><tr>
                            <th scope="col">Operation</th>
                            <th scope="col">In Place</th>
                            <th scope="col">Rebuilds Table</th>
                            <th scope="col">Permits Concurrent DML</th>
                            <th scope="col">Only Modifies Metadata</th>
                        </tr></thead><tbody><tr>
                            <td scope="row">Creating or adding a secondary index</td>
                            <td>Yes</td>
                            <td>No</td>
                            <td>Yes</td>
                            <td>No</td>
                        </tr><tr>
                            <td scope="row">Dropping an index</td>
                            <td>Yes</td>
                            <td>No</td>
                            <td>Yes</td>
                            <td>Yes</td>
                        </tr><tr>
                            <td scope="row">Renaming an index</td>
                            <td>Yes</td>
                            <td>No</td>
                            <td>Yes</td>
                            <td>Yes</td>
                        </tr><tr>
                            <td scope="row">Adding a <code class="literal">FULLTEXT</code> index</td>
                            <td>Yes*</td>
                            <td>No*</td>
                            <td>No</td>
                            <td>No</td>
                        </tr><tr>
                            <td scope="row">Adding a <code class="literal">SPATIAL</code> index</td>
                            <td>Yes</td>
                            <td>No</td>
                            <td>No</td>
                            <td>No</td>
                        </tr><tr>
                            <td scope="row">Changing the index type</td>
                            <td>Yes</td>
                            <td>No</td>
                            <td>Yes</td>
                            <td>Yes</td>
                        </tr></tbody></table>
                    </div>

                </div>
                <br class="table-break">
                <h5><a name="online-ddl-index-syntax-notes"></a>Syntax and Usage Notes</h5>
                <div class="itemizedlist">
                    <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                        Creating or adding a secondary index
                    </p><p style="color:blue;">创建或添加辅助索引</p><pre data-lang="sql" class="programlisting">CREATE INDEX <em class="replaceable"><code>name</code></em> ON <em class="replaceable"><code>table</code></em> (<em class="replaceable"><code>col_list</code></em>);
</pre><pre data-lang="sql" class="programlisting">ALTER TABLE <em class="replaceable"><code>tbl_name</code></em> ADD INDEX <em class="replaceable"><code>name</code></em> (<em class="replaceable"><code>col_list</code></em>);
</pre><p>
                        The table remains available for read and write operations
                        while the index is being created. The
                        <a class="link" href="sql-syntax.html#create-index" title="13.1.14&nbsp;CREATE INDEX Syntax"><code class="literal">CREATE INDEX</code></a> statement only
                        finishes after all transactions that are accessing the table
                        are completed, so that the initial state of the index
                        reflects the most recent contents of the table.
                    </p><p style="color:blue;">在创建索引时，表仍可用于读写操作。CREATEINDEX语句只在访问表的所有事务完成后才结束，以便索引的初始状态反映表的最新内容。</p><p>
                        Online DDL support for adding secondary indexes means that
                        you can generally speed the overall process of creating and
                        loading a table and associated indexes by creating the table
                        without secondary indexes, then adding secondary indexes
                        after the data is loaded.
                    </p><p style="color:blue;">在线ddl支持添加二级索引，这意味着您通常可以通过创建不带二级索引的表，然后在加载数据后添加二级索引，来加快创建和加载表及其关联索引的整个过程。</p><p>
                        A newly created secondary index contains only the committed
                        data in the table at the time the
                        <a class="link" href="sql-syntax.html#create-index" title="13.1.14&nbsp;CREATE INDEX Syntax"><code class="literal">CREATE INDEX</code></a> or
                        <a class="link" href="sql-syntax.html#alter-table" title="13.1.8&nbsp;ALTER TABLE Syntax"><code class="literal">ALTER TABLE</code></a> statement
                        finishes executing. It does not contain any uncommitted
                        values, old versions of values, or values marked for
                        deletion but not yet removed from the old index.
                    </p><p style="color:blue;">新创建的辅助索引只包含执行完CREATEINDEX或ALTERTABLE语句时表中提交的数据。它不包含任何未提交的值、旧版本的值或标记为删除但尚未从旧索引中删除的值。</p><p>
                        If the server exits while creating a secondary index, upon
                        recovery, MySQL drops any partially created indexes. You
                        must re-run the <a class="link" href="sql-syntax.html#alter-table" title="13.1.8&nbsp;ALTER TABLE Syntax"><code class="literal">ALTER TABLE</code></a>
                        or <a class="link" href="sql-syntax.html#create-index" title="13.1.14&nbsp;CREATE INDEX Syntax"><code class="literal">CREATE INDEX</code></a> statement.
                    </p><p style="color:blue;">如果服务器在创建辅助索引时退出，则在恢复后，MySQL会删除任何部分创建的索引。必须重新运行alter table或create index语句。</p><p>
                        Some factors affect the performance, space usage, and
                        semantics of this operation. For details, see
                        <a class="xref" href="innodb-storage-engine.html#innodb-online-ddl-limitations" title="14.13.6&nbsp;Online DDL Limitations">Section&nbsp;14.13.6, “Online DDL Limitations”</a>.
                    </p><p style="color:blue;">一些因素会影响此操作的性能、空间使用和语义。有关详细信息，请参见第14.13.6节“联机DDL限制”。</p></li><li class="listitem"><p>
                        Dropping an index
                    </p><p style="color:blue;">删除索引</p><pre data-lang="sql" class="programlisting">DROP INDEX <em class="replaceable"><code>name</code></em> ON <em class="replaceable"><code>table</code></em>;
</pre><pre data-lang="sql" class="programlisting">ALTER TABLE <em class="replaceable"><code>tbl_name</code></em> DROP INDEX <em class="replaceable"><code>name</code></em>;
</pre><p>
                        The table remains available for read and write operations
                        while the index is being dropped. The
                        <a class="link" href="sql-syntax.html#drop-index" title="13.1.25&nbsp;DROP INDEX Syntax"><code class="literal">DROP INDEX</code></a> statement only
                        finishes after all transactions that are accessing the table
                        are completed, so that the initial state of the index
                        reflects the most recent contents of the table.
                    </p><p style="color:blue;">在删除索引时，表仍可用于读写操作。DROP INDEX语句只在访问表的所有事务完成后才结束，以便索引的初始状态反映表的最新内容。</p></li><li class="listitem"><p>
                        Renaming an index
                    </p><p style="color:blue;">重命名索引</p><pre data-lang="sql" class="programlisting">ALTER TABLE <em class="replaceable"><code>tbl_name</code></em> RENAME INDEX <em class="replaceable"><code>old_index_name</code></em> TO <em class="replaceable"><code>new_index_name</code></em>, ALGORITHM=INPLACE, LOCK=NONE;
</pre></li><li class="listitem"><p>
                        Adding a <code class="literal">FULLTEXT</code> index
                    </p><p style="color:blue;">添加全文索引</p><pre data-lang="sql" class="programlisting">CREATE FULLTEXT INDEX <em class="replaceable"><code>name</code></em> ON table(<em class="replaceable"><code>column</code></em>);
</pre><p>
                        Adding the first <code class="literal">FULLTEXT</code> index rebuilds
                        the table if there is no user-defined
                        <code class="literal">FTS_DOC_ID</code> column. Additional
                        <code class="literal">FULLTEXT</code> indexes may be added without
                        rebuilding the table.
                    </p><p style="color:blue;">如果没有用户定义的fts_doc_id列，添加第一个全文索引将重建表。可以在不重建表的情况下添加其他全文索引。</p></li><li class="listitem"><p>
                        Adding a <code class="literal">SPATIAL</code> index
                    </p><p style="color:blue;">添加空间索引</p><pre data-lang="sql" class="programlisting">CREATE TABLE geom (g GEOMETRY NOT NULL);
ALTER TABLE geom ADD SPATIAL INDEX(g), ALGORITHM=INPLACE, LOCK=SHARED;
</pre><p>
                        Adding the first <code class="literal">FULLTEXT</code> index rebuilds
                        the table if there is no user-defined
                        <code class="literal">FTS_DOC_ID</code> column. Additional
                        <code class="literal">FULLTEXT</code> indexes may be added without
                        rebuilding the table.
                    </p><p style="color:blue;">如果没有用户定义的fts_doc_id列，添加第一个全文索引将重建表。可以在不重建表的情况下添加其他全文索引。</p></li><li class="listitem"><p>
                        Changing the index type (<code class="literal">USING {BTREE |
                        HASH}</code>)
                    </p><p style="color:blue;">更改索引类型（使用{btree hash}）</p><pre data-lang="sql" class="programlisting">ALTER TABLE <em class="replaceable"><code>tbl_name</code></em> DROP INDEX i1, ADD INDEX i1(<em class="replaceable"><code>key_part,...</code></em>) USING BTREE, ALGORITHM=INPLACE;
</pre></li></ul>
                </div>

            </div>
            <div class="simplesect">
                <div class="titlepage">
                    <div>
                        <div class="simple">
                            <h4 class="title"><a name="online-ddl-primary-key-operations"></a>Primary Key Operations</h4>

                        </div>

                    </div>

                </div>
                <p>
                    The following table provides an overview of online DDL support
                    for primary key operations. An asterisk indicates additional
                    information, an exception, or a dependency. See
                    <a class="xref" href="innodb-storage-engine.html#online-ddl-primary-key-syntax-notes" title="Syntax and Usage Notes">Syntax and Usage Notes</a>.
                </p><p style="color:blue;">下表概述了对主键操作的联机ddl支持。星号表示附加信息、异常或依赖项。参见语法和用法说明。</p>
                <div class="table">
                    <a name="online-ddl-primary-key-operations-table"></a><p class="title"><b>Table&nbsp;14.12&nbsp;Online DDL Support for Primary Key Operations</b></p><p style="color:blue;">表14.12主键操作在线DDL支持</p>
                    <div class="table-contents">
                        <table summary="Online DDL support for primary key operations indicating whether the operation is performed in place, rebuilds the table, permits concurrent DML, or only modifies metadata."><colgroup><col width="20%" align="left"><col width="20%" align="center"><col width="20%" align="center"><col width="20%" align="center"><col width="20%" align="center"></colgroup><thead><tr>
                            <th scope="col">Operation</th>
                            <th scope="col">In Place</th>
                            <th scope="col">Rebuilds Table</th>
                            <th scope="col">Permits Concurrent DML</th>
                            <th scope="col">Only Modifies Metadata</th>
                        </tr></thead><tbody><tr>
                            <td scope="row">Adding a primary key</td>
                            <td>Yes*</td>
                            <td>Yes*</td>
                            <td>Yes</td>
                            <td>No</td>
                        </tr><tr>
                            <td scope="row">Dropping a primary key</td>
                            <td>No</td>
                            <td>Yes</td>
                            <td>No</td>
                            <td>No</td>
                        </tr><tr>
                            <td scope="row">Dropping a primary key and adding another</td>
                            <td>Yes</td>
                            <td>Yes</td>
                            <td>Yes</td>
                            <td>No</td>
                        </tr></tbody></table>
                    </div>

                </div>
                <br class="table-break">
                <h5><a name="online-ddl-primary-key-syntax-notes"></a>Syntax and Usage Notes</h5>
                <div class="itemizedlist">
                    <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                        Adding a primary key
                    </p><p style="color:blue;">添加主键</p><pre data-lang="sql" class="programlisting">ALTER TABLE <em class="replaceable"><code>tbl_name</code></em> ADD PRIMARY KEY (<em class="replaceable"><code>column</code></em>), ALGORITHM=INPLACE, LOCK=NONE;
</pre><p>
                        Rebuilds the table in place. Data is reorganized
                        substantially, making it an expensive operation.
                        <code class="literal">ALGORITHM=INPLACE</code> is not permitted under
                        certain conditions if columns have to be converted to
                        <code class="literal">NOT NULL</code>.
                    </p><p style="color:blue;">在适当的地方重建桌子。数据经过了实质性的重组，使之成为一种昂贵的操作。在某些情况下，如果必须将列转换为非空，则不允许algorithm=inplace。</p><p>
                        Restructuring the
                        <a class="link" href="glossary.html#glos_clustered_index" title="clustered index">clustered index</a>
                        always requires copying of table data. Thus, it is best to
                        define the <a class="link" href="glossary.html#glos_primary_key" title="primary key">primary
                        key</a> when you create a table, rather than issuing
                        <code class="literal">ALTER TABLE ... ADD PRIMARY KEY</code> later.
                    </p><p style="color:blue;">重新构造聚集索引总是需要复制表数据。因此，最好在创建表时定义主键，而不是发出alter table…稍后添加主键。</p><p>
                        When you create a <code class="literal">UNIQUE</code> or
                        <code class="literal">PRIMARY KEY</code> index, MySQL must do some
                        extra work. For <code class="literal">UNIQUE</code> indexes, MySQL
                        checks that the table contains no duplicate values for the
                        key. For a <code class="literal">PRIMARY KEY</code> index, MySQL also
                        checks that none of the <code class="literal">PRIMARY KEY</code>
                        columns contains a <code class="literal">NULL</code>.
                    </p><p style="color:blue;">创建唯一或主键索引时，mysql必须做一些额外的工作。对于唯一索引，mysql检查表是否包含键的重复值。对于主键索引，mysql还检查所有主键列都不包含空值。</p><p>


                        When you add a primary key using the
                        <code class="literal">ALGORITHM=COPY</code> clause, MySQL converts
                        <code class="literal">NULL</code> values in the associated columns to
                        default values: 0 for numbers, an empty string for
                        character-based columns and BLOBs, and 0000-00-00 00:00:00
                        for <code class="literal">DATETIME</code>. This is a non-standard
                        behavior that Oracle recommends you not rely on. Adding a
                        primary key using <code class="literal">ALGORITHM=INPLACE</code> is
                        only permitted when the
                        <a class="link" href="server-administration.html#sysvar_sql_mode"><code class="literal">SQL_MODE</code></a> setting includes
                        the <code class="literal">strict_trans_tables</code> or
                        <code class="literal">strict_all_tables</code> flags; when the
                        <code class="literal">SQL_MODE</code> setting is strict,
                        <code class="literal">ALGORITHM=INPLACE</code> is permitted, but the
                        statement can still fail if the requested primary key
                        columns contain <code class="literal">NULL</code> values. The
                        <code class="literal">ALGORITHM=INPLACE</code> behavior is more
                        standard-compliant.
                    </p><p style="color:blue;">使用algorithm=copy子句添加主键时，mysql会将关联列中的空值转换为默认值：0表示数字，空字符串表示基于字符的列和blob，0000-00-00 00:00:00表示datetime。这是Oracle建议您不要依赖的非标准行为。仅当sql_mode设置包含strict_trans_tables或strict_all_tables标志时，才允许使用algorithm=inplace添加主键；当sql_mode设置为strict时，允许algorithm=inplace，但如果请求的主键列包含空值，则语句仍可能失败。算法=就地行为更符合标准。</p><p>
                        If you create a table without a primary key,
                        <code class="literal">InnoDB</code> chooses one for you, which can be
                        the first <code class="literal">UNIQUE</code> key defined on
                        <code class="literal">NOT NULL</code> columns, or a system-generated
                        key. To avoid uncertainty and the potential space
                        requirement for an extra hidden column, specify the
                        <code class="literal">PRIMARY KEY</code> clause as part of the
                        <a class="link" href="sql-syntax.html#create-table" title="13.1.18&nbsp;CREATE TABLE Syntax"><code class="literal">CREATE TABLE</code></a> statement.
                    </p><p style="color:blue;">如果创建一个没有主键的表，innodb会为您选择一个主键，它可以是在非空列上定义的第一个唯一键，也可以是系统生成的键。为了避免不确定性和额外隐藏列的潜在空间需求，请将主键子句指定为CREATETABLE语句的一部分。</p><p>
                        MySQL creates a new clustered index by copying the existing
                        data from the original table to a temporary table that has
                        the desired index structure. Once the data is completely
                        copied to the temporary table, the original table is renamed
                        with a different temporary table name. The temporary table
                        comprising the new clustered index is renamed with the name
                        of the original table, and the original table is dropped
                        from the database.
                    </p><p style="color:blue;">MySQL通过将现有数据从原始表复制到具有所需索引结构的临时表来创建新的聚集索引。将数据完全复制到临时表后，将使用其他临时表名称重命名原始表。将使用原始表的名称重命名包含新聚集索引的临时表，并从数据库中删除原始表。</p><p>
                        The online performance enhancements that apply to operations
                        on secondary indexes do not apply to the primary key index.
                        The rows of an InnoDB table are stored in a
                        <a class="link" href="glossary.html#glos_clustered_index" title="clustered index">clustered index</a>
                        organized based on the
                        <a class="link" href="glossary.html#glos_primary_key" title="primary key">primary key</a>, forming
                        what some database systems call an <span class="quote">“<span class="quote">index-organized
            table</span>”</span>. Because the table structure is closely tied
                        to the primary key, redefining the primary key still
                        requires copying the data.
                    </p><p style="color:blue;">应用于辅助索引上的操作的联机性能增强不适用于主键索引。innodb表的行存储在基于主键组织的聚集索引中，形成一些数据库系统所称的“索引组织表”。由于表结构与主键紧密相关，重新定义主键仍然需要复制数据。</p><p>
                        When an operation on the primary key uses
                        <code class="literal">ALGORITHM=INPLACE</code>, even though the data
                        is still copied, it is more efficient than using
                        <code class="literal">ALGORITHM=COPY</code> because:
                    </p><p style="color:blue;">当主键上的操作使用algorithm=inplace时，即使数据仍被复制，它比使用algorithm=copy更有效，因为：</p>
                        <div class="itemizedlist">
                            <ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
                                No undo logging or associated redo logging is required
                                for <code class="literal">ALGORITHM=INPLACE</code>. These
                                operations add overhead to DDL statements that use
                                <code class="literal">ALGORITHM=COPY</code>.
                            </p><p style="color:blue;">对于algorithm=inplace，不需要撤消日志记录或关联的重做日志记录。这些操作给使用algorithm=copy的ddl语句增加了开销。</p></li><li class="listitem"><p>
                                The secondary index entries are pre-sorted, and so can
                                be loaded in order.
                            </p><p style="color:blue;">辅助索引项是预先排序的，因此可以按顺序加载。</p></li><li class="listitem"><p>
                                The change buffer is not used, because there are no
                                random-access inserts into the secondary indexes.
                            </p><p style="color:blue;">不使用更改缓冲区，因为辅助索引中没有随机访问插入。</p></li></ul>
                        </div>
                        <p>
                            If the server exits while creating a new clustered index, no
                            data is lost, but you must complete the recovery process
                            using the temporary tables that exist during the process.
                            Since it is rare to re-create a clustered index or re-define
                            primary keys on large tables, or to encounter a system crash
                            during this operation, this manual does not provide
                            information on recovering from this scenario.
                        </p><p style="color:blue;">如果服务器在创建新的聚集索引时退出，则不会丢失数据，但必须使用过程中存在的临时表完成恢复过程。由于很少在大型表上重新创建聚集索引或重新定义主键，或者在此操作期间遇到系统崩溃，因此本手册不提供有关从此场景恢复的信息。</p></li><li class="listitem"><p>
                        Dropping a primary key
                    </p><p style="color:blue;">删除主键</p><pre data-lang="sql" class="programlisting">ALTER TABLE <em class="replaceable"><code>tbl_name</code></em> DROP PRIMARY KEY, ALGORITHM=COPY;
</pre><p>
                        Only <code class="literal">ALGORITHM=COPY</code> supports dropping a
                        primary key without adding a new one in the same
                        <code class="literal">ALTER TABLE</code> statement.
                    </p><p style="color:blue;">仅algorithm=copy支持删除主键，而不在同一alter table语句中添加新的主键。</p></li><li class="listitem"><p>
                        Dropping a primary key and adding another
                    </p><p style="color:blue;">删除主键并添加另一个主键</p><pre data-lang="sql" class="programlisting">ALTER TABLE <em class="replaceable"><code>tbl_name</code></em> DROP PRIMARY KEY, ADD PRIMARY KEY (<em class="replaceable"><code>column</code></em>), ALGORITHM=INPLACE, LOCK=NONE;
</pre><p>
                        Data is reorganized substantially, making it an expensive
                        operation.
                    </p><p style="color:blue;">数据经过了实质性的重组，使之成为一种昂贵的操作。</p></li></ul>
                </div>

            </div>
            <div class="simplesect">
                <div class="titlepage">
                    <div>
                        <div class="simple">
                            <h4 class="title"><a name="online-ddl-column-operations"></a>Column Operations</h4>

                        </div>

                    </div>

                </div>
                <p>
                    The following table provides an overview of online DDL support
                    for column operations. An asterisk indicates additional
                    information, an exception, or a dependency. For details, see
                    <a class="xref" href="innodb-storage-engine.html#online-ddl-column-syntax-notes" title="Syntax and Usage Notes">Syntax and Usage Notes</a>.
                </p><p style="color:blue;">下表概述了对列操作的联机ddl支持。星号表示附加信息、异常或依赖项。有关详细信息，请参见语法和用法说明。</p>
                <div class="table">
                    <a name="online-ddl-column-operations-table"></a><p class="title"><b>Table&nbsp;14.13&nbsp;Online DDL Support for Column Operations</b></p><p style="color:blue;">表14.13列操作的在线ddl支持</p>
                    <div class="table-contents">
                        <table summary="Online DDL support for column operations indicating whether the operation is performed in place, rebuilds the table, permits concurrent DML, or only modifies metadata."><colgroup><col width="20%" align="left"><col width="20%" align="center"><col width="20%" align="center"><col width="20%" align="center"><col width="20%" align="center"></colgroup><thead><tr>
                            <th scope="col">Operation</th>
                            <th scope="col">In Place</th>
                            <th scope="col">Rebuilds Table</th>
                            <th scope="col">Permits Concurrent DML</th>
                            <th scope="col">Only Modifies Metadata</th>
                        </tr></thead><tbody><tr>
                            <td scope="row">Adding a column</td>
                            <td>Yes</td>
                            <td>Yes</td>
                            <td>Yes*</td>
                            <td>No</td>
                        </tr><tr>
                            <td scope="row">Dropping a column</td>
                            <td>Yes</td>
                            <td>Yes</td>
                            <td>Yes</td>
                            <td>No</td>
                        </tr><tr>
                            <td scope="row">Renaming a column</td>
                            <td>Yes</td>
                            <td>No</td>
                            <td>Yes*</td>
                            <td>Yes</td>
                        </tr><tr>
                            <td scope="row">Reordering columns</td>
                            <td>Yes</td>
                            <td>Yes</td>
                            <td>Yes</td>
                            <td>No</td>
                        </tr><tr>
                            <td scope="row">Setting a column default value</td>
                            <td>Yes</td>
                            <td>No</td>
                            <td>Yes</td>
                            <td>Yes</td>
                        </tr><tr>
                            <td scope="row">Changing the column data type</td>
                            <td>No</td>
                            <td>Yes</td>
                            <td>No</td>
                            <td>No</td>
                        </tr><tr>
                            <td scope="row">Extending <code class="literal">VARCHAR</code> column size</td>
                            <td>Yes</td>
                            <td>No</td>
                            <td>Yes</td>
                            <td>Yes</td>
                        </tr><tr>
                            <td scope="row">Dropping the column default value</td>
                            <td>Yes</td>
                            <td>No</td>
                            <td>Yes</td>
                            <td>Yes</td>
                        </tr><tr>
                            <td scope="row">Changing the auto-increment value</td>
                            <td>Yes</td>
                            <td>No</td>
                            <td>Yes</td>
                            <td>No*</td>
                        </tr><tr>
                            <td scope="row">Making a column <code class="literal">NULL</code></td>
                            <td>Yes</td>
                            <td>Yes*</td>
                            <td>Yes</td>
                            <td>No</td>
                        </tr><tr>
                            <td scope="row">Making a column <code class="literal">NOT NULL</code></td>
                            <td>Yes*</td>
                            <td>Yes*</td>
                            <td>Yes</td>
                            <td>No</td>
                        </tr><tr>
                            <td scope="row">Modifying the definition of an <code class="literal">ENUM</code> or
                                <code class="literal">SET</code> column</td>
                            <td>Yes</td>
                            <td>No</td>
                            <td>Yes</td>
                            <td>Yes</td>
                        </tr></tbody></table>
                    </div>

                </div>
                <br class="table-break">
                <h5><a name="online-ddl-column-syntax-notes"></a>Syntax and Usage Notes</h5>
                <div class="itemizedlist">
                    <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                        Adding a column
                    </p><p style="color:blue;">添加列</p><pre data-lang="sql" class="programlisting">ALTER TABLE <em class="replaceable"><code>tbl_name</code></em> ADD COLUMN <em class="replaceable"><code>column_name</code></em> <em class="replaceable"><code>column_definition</code></em>, ALGORITHM=INPLACE, LOCK=NONE;
</pre><p>
                        Concurrent DML is not permitted when adding an
                        <a class="link" href="glossary.html#glos_auto_increment" title="auto-increment">auto-increment</a>
                        column. Data is reorganized substantially, making it an
                        expensive operation. At a minimum,
                        <code class="literal">ALGORITHM=INPLACE, LOCK=SHARED</code> is
                        required.
                    </p><p style="color:blue;">添加自动递增列时不允许并发DML。数据经过了实质性的重组，使之成为一种昂贵的操作。至少需要algorithm=inplace，lock=shared。</p></li><li class="listitem"><p>
                        Dropping a column
                    </p><p style="color:blue;">删除列</p><pre data-lang="sql" class="programlisting">ALTER TABLE <em class="replaceable"><code>tbl_name</code></em> DROP COLUMN <em class="replaceable"><code>column_name</code></em>, ALGORITHM=INPLACE, LOCK=NONE;
</pre><p>
                        Data is reorganized substantially, making it an expensive
                        operation.
                    </p><p style="color:blue;">数据经过了实质性的重组，使之成为一种昂贵的操作。</p></li><li class="listitem"><p>
                        Renaming a column
                    </p><p style="color:blue;">重命名列</p><pre data-lang="sql" class="programlisting">ALTER TABLE <em class="replaceable"><code>tbl</code></em> CHANGE <em class="replaceable"><code>old_col_name</code></em> <em class="replaceable"><code>new_col_name</code></em> <em class="replaceable"><code>data_type</code></em>, ALGORITHM=INPLACE, LOCK=NONE;
</pre><p>
                        To permit concurrent DML, keep the same data type and only
                        change the column name.
                    </p><p style="color:blue;">要允许并发dml，请保持相同的数据类型，并且只更改列名。</p><p>
                        When you keep the same data type and <code class="literal">[NOT]
                        NULL</code> attribute, only changing the column name, the
                        operation can always be performed online.
                    </p><p style="color:blue;">如果保持相同的数据类型和[not]空属性，并且只更改列名，则该操作始终可以联机执行。</p><p>
                        You can also rename a column that is part of a foreign key
                        constraint. The foreign key definition is automatically
                        updated to use the new column name. Renaming a column
                        participating in a foreign key only works with
                        <code class="literal">ALGORITHM=INPLACE</code>. If you use the
                        <code class="literal">ALGORITHM=COPY</code> clause, or some other
                        condition causes the command to use
                        <code class="literal">ALGORITHM=COPY</code> behind the scenes, the
                        <code class="literal">ALTER TABLE</code> statement fails.
                    </p><p style="color:blue;">也可以重命名作为外键约束一部分的列。外键定义将自动更新为使用新列名。重命名参与外键的列只适用于algorithm=inplace。如果使用algorithm=copy子句，或者其他条件导致命令在后台使用algorithm=copy，那么alter table语句将失败。</p><p>
                        <code class="literal">ALGORITHM=INPLACE</code> is not supported for
                        renaming a <a class="link" href="glossary.html#glos_generated_column" title="generated column">generated
                        column</a>.
                    </p><p style="color:blue;">不支持将生成的列重命名为algorithm=inplace。</p></li><li class="listitem"><p>
                        Reordering columns
                    </p><p style="color:blue;">重新排序列</p><p>
                        To reorder columns, use <code class="literal">FIRST</code> or
                        <code class="literal">AFTER</code> in <code class="literal">CHANGE</code> or
                        <code class="literal">MODIFY</code> operations.
                    </p><p style="color:blue;">若要对列重新排序，请在“更改”或“修改”操作中使用“第一个”或“之后”。</p><pre data-lang="sql" class="programlisting">ALTER TABLE <em class="replaceable"><code>tbl_name</code></em> MODIFY COLUMN <em class="replaceable"><code>col_name</code></em> <em class="replaceable"><code>column_definition</code></em> FIRST, ALGORITHM=INPLACE, LOCK=NONE;
</pre><p>
                        Data is reorganized substantially, making it an expensive
                        operation.
                    </p><p style="color:blue;">数据经过了实质性的重组，使之成为一种昂贵的操作。</p></li><li class="listitem"><p>
                        Changing the column data type
                    </p><p style="color:blue;">更改列数据类型</p><pre data-lang="sql" class="programlisting">ALTER TABLE <em class="replaceable"><code>tbl_name</code></em> CHANGE c1 c1 BIGINT, ALGORITHM=COPY;
</pre><p>
                        Changing the column data type is only supported with
                        <code class="literal">ALGORITHM=COPY</code>.
                    </p><p style="color:blue;">只有algorithm=copy才支持更改列数据类型。</p></li><li class="listitem"><p>
                        Extending <code class="literal">VARCHAR</code> column size
                    </p><p style="color:blue;">扩展varchar列大小</p><pre data-lang="sql" class="programlisting">ALTER TABLE <em class="replaceable"><code>tbl_name</code></em> CHANGE COLUMN c1 c1 VARCHAR(255), ALGORITHM=INPLACE, LOCK=NONE;
</pre><p>
                        The number of length bytes required by a
                        <a class="link" href="data-types.html#char" title="11.4.1&nbsp;The CHAR and VARCHAR Types"><code class="literal">VARCHAR</code></a> column must remain
                        the same. For <a class="link" href="data-types.html#char" title="11.4.1&nbsp;The CHAR and VARCHAR Types"><code class="literal">VARCHAR</code></a> columns
                        of 0 to 255 bytes in size, one length byte is required to
                        encode the value. For <a class="link" href="data-types.html#char" title="11.4.1&nbsp;The CHAR and VARCHAR Types"><code class="literal">VARCHAR</code></a>
                        columns of 256 bytes in size or more, two length bytes are
                        required. As a result, in-place <a class="link" href="sql-syntax.html#alter-table" title="13.1.8&nbsp;ALTER TABLE Syntax"><code class="literal">ALTER
                        TABLE</code></a> only supports increasing
                        <a class="link" href="data-types.html#char" title="11.4.1&nbsp;The CHAR and VARCHAR Types"><code class="literal">VARCHAR</code></a> column size from 0 to
                        255 bytes, or from 256 bytes to a greater size. In-place
                        <a class="link" href="sql-syntax.html#alter-table" title="13.1.8&nbsp;ALTER TABLE Syntax"><code class="literal">ALTER TABLE</code></a> does not support
                        increasing the size of a
                        <a class="link" href="data-types.html#char" title="11.4.1&nbsp;The CHAR and VARCHAR Types"><code class="literal">VARCHAR</code></a> column from less than
                        256 bytes to a size equal to or greater than 256 bytes. In
                        this case, the number of required length bytes changes from
                        1 to 2, which is only supported by a table copy
                        (<code class="literal">ALGORITHM=COPY</code>). For example, attempting
                        to change <a class="link" href="data-types.html#char" title="11.4.1&nbsp;The CHAR and VARCHAR Types"><code class="literal">VARCHAR</code></a> column size
                        for a single byte character set from VARCHAR(255) to
                        VARCHAR(256) using in-place <a class="link" href="sql-syntax.html#alter-table" title="13.1.8&nbsp;ALTER TABLE Syntax"><code class="literal">ALTER
                        TABLE</code></a> returns this error:
                    </p><p style="color:blue;">varchar列所需的长度字节数必须保持不变。对于0到255字节的varchar列，需要一个长度字节来编码该值。对于256字节或更大的varchar列，需要两个长度字节。因此，就地alter table只支持将varchar列大小从0增加到255字节，或从256字节增加到更大的大小。就地alter table不支持将varchar列的大小从小于256字节增加到等于或大于256字节。在这种情况下，所需的长度字节数从1变为2，这仅由表副本（algorithm=copy）支持。例如，尝试使用就地alter table将单字节字符集的varchar列大小从varchar（255）更改为varchar（256），将返回以下错误：</p><pre data-lang="sql" class="programlisting">ALTER TABLE <em class="replaceable"><code>tbl_name</code></em> ALGORITHM=INPLACE, CHANGE COLUMN c1 c1 VARCHAR(256);
ERROR 0A000: ALGORITHM=INPLACE is not supported. Reason: Cannot change
column type INPLACE. Try ALGORITHM=COPY.
</pre>
                        <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">

                            <div class="admon-title">
                                Note
                            </div>
                            <p>
                                The byte length of a <code class="literal">VARCHAR</code> column is
                                dependant on the byte length of the character set.
                            </p><p style="color:blue;">varchar列的字节长度取决于字符集的字节长度。</p>
                        </div>
                        <p>
                            Decreasing <a class="link" href="data-types.html#char" title="11.4.1&nbsp;The CHAR and VARCHAR Types"><code class="literal">VARCHAR</code></a> size using
                            in-place <a class="link" href="sql-syntax.html#alter-table" title="13.1.8&nbsp;ALTER TABLE Syntax"><code class="literal">ALTER TABLE</code></a> is not
                            supported. Decreasing <a class="link" href="data-types.html#char" title="11.4.1&nbsp;The CHAR and VARCHAR Types"><code class="literal">VARCHAR</code></a>
                            size requires a table copy
                            (<code class="literal">ALGORITHM=COPY</code>).
                        </p><p style="color:blue;">不支持使用就地alter table减小varchar大小。减小varchar大小需要一个表副本（algorithm=copy）。</p></li><li class="listitem"><p>
                        Setting a column default value
                    </p><p style="color:blue;">设置列默认值</p><pre data-lang="sql" class="programlisting">ALTER TABLE <em class="replaceable"><code>tbl_name</code></em> ALTER COLUMN <em class="replaceable"><code>col</code></em> SET DEFAULT <em class="replaceable"><code>literal</code></em>, ALGORITHM=INPLACE, LOCK=NONE;
</pre><p>
                        Only modifies table metadata. Default column values are
                        stored in the <a class="link" href="glossary.html#glos_frm_file" title=".frm file">.frm file</a>
                        for the table, not the <code class="literal">InnoDB</code>
                        <a class="link" href="glossary.html#glos_data_dictionary" title="data dictionary">data dictionary</a>.
                    </p><p style="color:blue;">只修改表元数据。默认列值存储在表的.frm文件中，而不是innodb数据字典中。</p></li><li class="listitem"><p>
                        Dropping a column default value
                    </p><p style="color:blue;">删除列默认值</p><pre data-lang="sql" class="programlisting">ALTER TABLE <em class="replaceable"><code>tbl</code></em> ALTER COLUMN <em class="replaceable"><code>col</code></em> DROP DEFAULT, ALGORITHM=INPLACE, LOCK=NONE;
</pre></li><li class="listitem"><p>
                        Changing the auto-increment value
                    </p><p style="color:blue;">更改自动增量值</p><pre data-lang="sql" class="programlisting">ALTER TABLE <em class="replaceable"><code>table</code></em> AUTO_INCREMENT=<em class="replaceable"><code>next_value</code></em>, ALGORITHM=INPLACE, LOCK=NONE;
</pre><p>
                        Modifies a value stored in memory, not the data file.
                    </p><p style="color:blue;">修改存储在内存中的值，而不是数据文件。</p><p>
                        In a distributed system using replication or sharding, you
                        sometimes reset the auto-increment counter for a table to a
                        specific value. The next row inserted into the table uses
                        the specified value for its auto-increment column. You might
                        also use this technique in a data warehousing environment
                        where you periodically empty all the tables and reload them,
                        and restart the auto-increment sequence from 1.
                    </p><p style="color:blue;">在使用复制或分片的分布式系统中，有时会将表的自动递增计数器重置为特定值。插入表中的下一行使用指定的值作为其自动递增列。您还可以在数据仓库环境中使用此技术，定期清空所有表并重新加载它们，然后从1重新启动自动增量序列。</p></li><li class="listitem"><p>
                        Making a column <code class="literal">NULL</code>
                    </p><p style="color:blue;">使列为空</p><pre data-lang="sql" class="programlisting">ALTER TABLE tbl_name MODIFY COLUMN <em class="replaceable"><code>column_name</code></em> <em class="replaceable"><code>data_type</code></em> NULL, ALGORITHM=INPLACE, LOCK=NONE;
</pre><p>
                        Rebuilds the table in place. Data is reorganized
                        substantially, making it an expensive operation.
                    </p><p style="color:blue;">在适当的地方重建桌子。数据经过了实质性的重组，使之成为一种昂贵的操作。</p></li><li class="listitem"><p>
                        Making a column <code class="literal">NOT NULL</code>
                    </p><p style="color:blue;">使列不为空</p><pre data-lang="sql" class="programlisting">ALTER TABLE <em class="replaceable"><code>tbl_name</code></em> MODIFY COLUMN <em class="replaceable"><code>column_name</code></em> <em class="replaceable"><code>data_type</code></em> NOT NULL, ALGORITHM=INPLACE, LOCK=NONE;
</pre><p>
                        Rebuilds the table in place.
                        <code class="literal">STRICT_ALL_TABLES</code> or
                        <code class="literal">STRICT_TRANS_TABLES</code>
                        <a class="link" href="server-administration.html#sysvar_sql_mode"><code class="literal">SQL_MODE</code></a> is required for
                        the operation to succeed. The operation fails if the column
                        contains NULL values. The server prohibits changes to
                        foreign key columns that have the potential to cause loss of
                        referential integrity. See <a class="xref" href="sql-syntax.html#alter-table" title="13.1.8&nbsp;ALTER TABLE Syntax">Section&nbsp;13.1.8, “ALTER TABLE Syntax”</a>.
                        Data is reorganized substantially, making it an expensive
                        operation.
                    </p><p style="color:blue;">在适当的地方重建桌子。要使操作成功，需要使用strict_all_tables或strict_trans_tables sql_mode。如果列包含空值，则操作失败。服务器禁止更改可能导致引用完整性丢失的外键列。见第13.1.8节“更改表语法”。数据经过了实质性的重组，使之成为一种昂贵的操作。</p></li><li class="listitem"><p>
                        Modifying the definition of an <code class="literal">ENUM</code> or
                        <code class="literal">SET</code> column
                    </p><p style="color:blue;">修改枚举或集合列的定义</p><pre data-lang="sql" class="programlisting">CREATE TABLE t1 (c1 ENUM('a', 'b', 'c'));
ALTER TABLE t1 MODIFY COLUMN c1 ENUM('a', 'b', 'c', 'd'), ALGORITHM=INPLACE, LOCK=NONE;
</pre><p>
                        Modifying the definition of an
                        <a class="link" href="data-types.html#enum" title="11.4.4&nbsp;The ENUM Type"><code class="literal">ENUM</code></a> or
                        <a class="link" href="data-types.html#set" title="11.4.5&nbsp;The SET Type"><code class="literal">SET</code></a> column by adding new
                        enumeration or set members to the <span class="emphasis"><em>end</em></span>
                        of the list of valid member values may be performed in
                        place, as long as the storage size of the data type does not
                        change. For example, adding a member to a
                        <a class="link" href="data-types.html#set" title="11.4.5&nbsp;The SET Type"><code class="literal">SET</code></a> column that has 8 members
                        changes the required storage per value from 1 byte to 2
                        bytes; this requires a table copy. Adding members in the
                        middle of the list causes renumbering of existing members,
                        which requires a table copy.
                    </p><p style="color:blue;">只要数据类型的存储大小不变，就可以通过在有效成员值列表的末尾添加新的枚举或集合成员来修改枚举或集合列的定义。例如，将一个成员添加到具有8个成员的集合列会将每个值所需的存储从1字节更改为2字节；这需要一个表副本。在列表中间添加成员会导致现有成员重新编号，这需要表复制。</p></li></ul>
                </div>

            </div>
            <div class="simplesect">
                <div class="titlepage">
                    <div>
                        <div class="simple">
                            <h4 class="title"><a name="online-ddl-generated-column-operations"></a>Generated Column Operations</h4>

                        </div>

                    </div>

                </div>
                <p>
                    The following table provides an overview of online DDL support
                    for generated column operations. For details, see
                    <a class="xref" href="innodb-storage-engine.html#online-ddl-generated-column-syntax-notes" title="Syntax and Usage Notes">Syntax and Usage Notes</a>.
                </p><p style="color:blue;">下表概述了对生成的列操作的联机DDL支持。有关详细信息，请参见语法和用法说明。</p>
                <div class="table">
                    <a name="online-ddl-generated-column-operations-table"></a><p class="title"><b>Table&nbsp;14.14&nbsp;Online DDL Support for Generated Column Operations</b></p><p style="color:blue;">表14.14生成列操作的在线ddl支持</p>
                    <div class="table-contents">
                        <table summary="Online DDL support for generated column operations indicating whether the operation is performed in place, rebuilds the table, permits concurrent DML, or only modifies metadata."><colgroup><col width="20%" align="left"><col width="20%" align="center"><col width="20%" align="center"><col width="20%" align="center"><col width="20%" align="center"></colgroup><thead><tr>
                            <th scope="col">Operation</th>
                            <th scope="col">In Place</th>
                            <th scope="col">Rebuilds Table</th>
                            <th scope="col">Permits Concurrent DML</th>
                            <th scope="col">Only Modifies Metadata</th>
                        </tr></thead><tbody><tr>
                            <td scope="row">Adding a <code class="literal">STORED</code> column</td>
                            <td>No</td>
                            <td>Yes</td>
                            <td>No</td>
                            <td>No</td>
                        </tr><tr>
                            <td scope="row">Modifying <code class="literal">STORED</code> column order</td>
                            <td>No</td>
                            <td>Yes</td>
                            <td>No</td>
                            <td>No</td>
                        </tr><tr>
                            <td scope="row">Dropping a <code class="literal">STORED</code> column</td>
                            <td>Yes</td>
                            <td>Yes</td>
                            <td>Yes</td>
                            <td>No</td>
                        </tr><tr>
                            <td scope="row">Adding a <code class="literal">VIRTUAL</code> column</td>
                            <td>Yes</td>
                            <td>No</td>
                            <td>Yes</td>
                            <td>Yes</td>
                        </tr><tr>
                            <td scope="row">Modifying <code class="literal">VIRTUAL</code> column order</td>
                            <td>No</td>
                            <td>Yes</td>
                            <td>No</td>
                            <td>No</td>
                        </tr><tr>
                            <td scope="row">Dropping a <code class="literal">VIRTUAL</code> column</td>
                            <td>Yes</td>
                            <td>No</td>
                            <td>Yes</td>
                            <td>Yes</td>
                        </tr></tbody></table>
                    </div>

                </div>
                <br class="table-break">
                <h5><a name="online-ddl-generated-column-syntax-notes"></a>Syntax and Usage Notes</h5>
                <div class="itemizedlist">
                    <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                        Adding a <code class="literal">STORED</code> column
                    </p><p style="color:blue;">添加存储列</p><pre data-lang="sql" class="programlisting">ALTER TABLE t1 ADD COLUMN (c2 INT GENERATED ALWAYS AS (c1 + 1) STORED), ALGORITHM=COPY;
</pre><p>
                        <code class="literal">ADD COLUMN</code> is not an in-place operation
                        for stored columns (done without using a temporary table)
                        because the expression must be evaluated by the server.
                    </p><p style="color:blue;">添加列不是存储列的就地操作（在不使用临时表的情况下完成），因为服务器必须计算表达式。</p></li><li class="listitem"><p>
                        Modifying <code class="literal">STORED</code> column order
                    </p><p style="color:blue;">修改存储列顺序</p><pre data-lang="sql" class="programlisting">ALTER TABLE t1 MODIFY COLUMN c2 INT GENERATED ALWAYS AS (c1 + 1) STORED FIRST, ALGORITHM=COPY;
</pre><p>
                        Rebuilds the table in place.
                    </p><p style="color:blue;">在适当的地方重建桌子。</p></li><li class="listitem"><p>
                        Dropping a <code class="literal">STORED</code> column
                    </p><p style="color:blue;">删除存储列</p><pre data-lang="sql" class="programlisting">ALTER TABLE t1 DROP COLUMN c2, ALGORITHM=INPLACE, LOCK=NONE;
</pre><p>
                        Rebuilds the table in place.
                    </p><p style="color:blue;">在适当的地方重建桌子。</p></li><li class="listitem"><p>
                        Adding a <code class="literal">VIRTUAL</code> column
                    </p><p style="color:blue;">添加虚拟列</p><pre data-lang="sql" class="programlisting">ALTER TABLE t1 ADD COLUMN (c2 INT GENERATED ALWAYS AS (c1 + 1) VIRTUAL), ALGORITHM=INPLACE, LOCK=NONE;
</pre><p>
                        Adding a virtual column is an in-place operation for
                        non-partitioned tables. However, adding a virtual column
                        cannot be combined with other <a class="link" href="sql-syntax.html#alter-table" title="13.1.8&nbsp;ALTER TABLE Syntax"><code class="literal">ALTER
                        TABLE</code></a> actions.
                    </p><p style="color:blue;">添加虚拟列是非分区表的就地操作。但是，添加虚拟列不能与其他alter table操作组合。</p><p>
                        Adding a <code class="literal">VIRTUAL</code> is not an in-place
                        operation for partitioned tables.
                    </p><p style="color:blue;">添加虚拟表不是分区表的就地操作。</p></li><li class="listitem"><p>
                        Modifying <code class="literal">VIRTUAL</code> column order
                    </p><p style="color:blue;">修改虚拟列顺序</p><pre data-lang="sql" class="programlisting">ALTER TABLE t1 MODIFY COLUMN c2 INT GENERATED ALWAYS AS (c1 + 1) VIRTUAL FIRST, ALGORITHM=COPY;
</pre></li><li class="listitem"><p>
                        Dropping a <code class="literal">VIRTUAL</code> column
                    </p><p style="color:blue;">删除虚拟列</p><pre data-lang="sql" class="programlisting">ALTER TABLE t1 DROP COLUMN c2, ALGORITHM=INPLACE, LOCK=NONE;
</pre><p>
                        Dropping a <code class="literal">VIRTUAL</code> column is an in-place
                        operation for non-partitioned tables. However, dropping a
                        virtual column cannot be combined with other
                        <a class="link" href="sql-syntax.html#alter-table" title="13.1.8&nbsp;ALTER TABLE Syntax"><code class="literal">ALTER TABLE</code></a> actions.
                    </p><p style="color:blue;">删除虚拟列是非分区表的就地操作。但是，删除虚拟列不能与其他alter table操作组合。</p><p>
                        Dropping a <code class="literal">VIRTUAL</code> is not an in-place
                        operation for partitioned tables.
                    </p><p style="color:blue;">删除虚拟表不是分区表的就地操作。</p></li></ul>
                </div>

            </div>
            <div class="simplesect">
                <div class="titlepage">
                    <div>
                        <div class="simple">
                            <h4 class="title"><a name="online-ddl-foreign-key-operations"></a>Foreign Key Operations</h4>

                        </div>

                    </div>

                </div>
                <p>
                    The following table provides an overview of online DDL support
                    for foreign key operations. An asterisk indicates additional
                    information, an exception, or a dependency. For details, see
                    <a class="xref" href="innodb-storage-engine.html#online-ddl-foreign-key-syntax-notes" title="Syntax and Usage Notes">Syntax and Usage Notes</a>.
                </p><p style="color:blue;">下表概述了外键操作的联机DDL支持。星号表示附加信息、异常或依赖项。有关详细信息，请参见语法和用法说明。</p>
                <div class="table">
                    <a name="online-ddl-foreign-key-operations-table"></a><p class="title"><b>Table&nbsp;14.15&nbsp;Online DDL Support for Foreign Key Operations</b></p><p style="color:blue;">表14.15外键操作在线ddl支持</p>
                    <div class="table-contents">
                        <table summary="Online DDL support for foreign key operations indicating whether the operation is performed in place, rebuilds the table, permits concurrent DML, or only modifies metadata."><colgroup><col width="20%" align="left"><col width="20%" align="center"><col width="20%" align="center"><col width="20%" align="center"><col width="20%" align="center"></colgroup><thead><tr>
                            <th scope="col">Operation</th>
                            <th scope="col">In Place</th>
                            <th scope="col">Rebuilds Table</th>
                            <th scope="col">Permits Concurrent DML</th>
                            <th scope="col">Only Modifies Metadata</th>
                        </tr></thead><tbody><tr>
                            <td scope="row">Adding a foreign key constraint</td>
                            <td>Yes*</td>
                            <td>No</td>
                            <td>Yes</td>
                            <td>Yes</td>
                        </tr><tr>
                            <td scope="row">Dropping a foreign key constraint</td>
                            <td>Yes</td>
                            <td>No</td>
                            <td>Yes</td>
                            <td>Yes</td>
                        </tr></tbody></table>
                    </div>

                </div>
                <br class="table-break">
                <h5><a name="online-ddl-foreign-key-syntax-notes"></a>Syntax and Usage Notes</h5>
                <div class="itemizedlist">
                    <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                        Adding a foreign key constraint
                    </p><p style="color:blue;">添加外键约束</p><p>
                        The <code class="literal">INPLACE</code> algorithm is supported when
                        <a class="link" href="server-administration.html#sysvar_foreign_key_checks"><code class="literal">foreign_key_checks</code></a> is
                        disabled. Otherwise, only the <code class="literal">COPY</code>
                        algorithm is supported.
                    </p><p style="color:blue;">当禁用外部密钥检查时，支持就地算法。否则，只支持复制算法。</p><pre data-lang="sql" class="programlisting">ALTER TABLE <em class="replaceable"><code>tbl1</code></em> ADD CONSTRAINT <em class="replaceable"><code>fk_name</code></em> FOREIGN KEY <em class="replaceable"><code>index</code></em> (<em class="replaceable"><code>col1</code></em>)
  REFERENCES <em class="replaceable"><code>tbl2</code></em>(<em class="replaceable"><code>col2</code></em>) <em class="replaceable"><code>referential_actions</code></em>;
</pre></li><li class="listitem"><p>
                        Dropping a foreign key constraint
                    </p><p style="color:blue;">删除外键约束</p><pre data-lang="sql" class="programlisting">ALTER TABLE <em class="replaceable"><code>tbl</code></em> DROP FOREIGN KEY <em class="replaceable"><code>fk_name</code></em>;
</pre><p>
                        Dropping a foreign key can be performed online with the
                        <a class="link" href="server-administration.html#sysvar_foreign_key_checks"><code class="literal">foreign_key_checks</code></a> option
                        enabled or disabled.
                    </p><p style="color:blue;">删除外键可以在启用或禁用外键检查选项的情况下联机执行。</p><p>
                        If you do not know the names of the foreign key constraints
                        on a particular table, issue the following statement and
                        find the constraint name in the
                        <code class="literal">CONSTRAINT</code> clause for each foreign key:
                    </p><p style="color:blue;">如果不知道特定表上外键约束的名称，请发出以下语句并在constraint子句中为每个外键查找约束名称：</p><pre data-lang="sql" class="programlisting">SHOW CREATE TABLE <em class="replaceable"><code>table</code></em>\G
</pre><p>
                        Or, query the
                        <a class="link" href="information-schema.html#table-constraints-table" title="24.27&nbsp;The INFORMATION_SCHEMA TABLE_CONSTRAINTS Table"><code class="literal">INFORMATION_SCHEMA.TABLE_CONSTRAINTS</code></a>
                        table and use the <code class="literal">CONSTRAINT_NAME</code> and
                        <code class="literal">CONSTRAINT_TYPE</code> columns to identify the
                        foreign key names.
                    </p><p style="color:blue;">或者，查询information_schema.table_constraints表，并使用constraint_name和constraint_type列标识外键名称。</p><p>
                        You can also drop a foreign key and its associated index in
                        a single statement:
                    </p><p style="color:blue;">也可以在单个语句中删除外键及其关联索引：</p><pre data-lang="sql" class="programlisting">ALTER TABLE <em class="replaceable"><code>table</code></em> DROP FOREIGN KEY <em class="replaceable"><code>constraint</code></em>, DROP INDEX <em class="replaceable"><code>index</code></em>;
</pre></li></ul>
                </div>
                <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">
                    <div class="admon-title">
                        Note
                    </div>
                    <p>
                        If <a class="link" href="glossary.html#glos_foreign_key" title="foreign key">foreign keys</a> are
                        already present in the table being altered (that is, it is a
                        <a class="link" href="glossary.html#glos_child_table" title="child table">child table</a> containing
                        a <code class="literal">FOREIGN KEY ... REFERENCE</code> clause),
                        additional restrictions apply to online DDL operations, even
                        those not directly involving the foreign key columns:
                    </p><p style="color:blue;">如果正在更改的表中已经存在外键（即，它是包含外键的子表…reference子句），其他限制适用于联机ddl操作，甚至那些不直接涉及外键列的操作：</p>
                    <div class="itemizedlist">
                        <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                            An <a class="link" href="sql-syntax.html#alter-table" title="13.1.8&nbsp;ALTER TABLE Syntax"><code class="literal">ALTER TABLE</code></a> on the child
                            table could wait for another transaction to commit, if a
                            change to the parent table causes associated changes in
                            the child table through an <code class="literal">ON UPDATE</code> or
                            <code class="literal">ON DELETE</code> clause using the
                            <code class="literal">CASCADE</code> or <code class="literal">SET NULL</code>
                            parameters.
                        </p><p style="color:blue;">如果对父表的更改通过使用cascade或set null参数的on update或on delete子句导致子表中的相关更改，则子表上的alter表可以等待另一个事务提交。</p></li><li class="listitem"><p>
                            In the same way, if a table is the
                            <a class="link" href="glossary.html#glos_parent_table" title="parent table">parent table</a> in a
                            foreign key relationship, even though it does not contain
                            any <code class="literal">FOREIGN KEY</code> clauses, it could wait
                            for the <a class="link" href="sql-syntax.html#alter-table" title="13.1.8&nbsp;ALTER TABLE Syntax"><code class="literal">ALTER TABLE</code></a> to
                            complete if an <a class="link" href="sql-syntax.html#insert" title="13.2.5&nbsp;INSERT Syntax"><code class="literal">INSERT</code></a>,
                            <a class="link" href="sql-syntax.html#update" title="13.2.11&nbsp;UPDATE Syntax"><code class="literal">UPDATE</code></a>, or
                            <a class="link" href="sql-syntax.html#delete" title="13.2.2&nbsp;DELETE Syntax"><code class="literal">DELETE</code></a> statement causes an
                            <code class="literal">ON UPDATE</code> or <code class="literal">ON
                            DELETE</code> action in the child table.
                        </p><p style="color:blue;">同样，如果表是外键关系中的父表，即使它不包含任何外键子句，如果insert、update或delete语句在子表中导致on update或on delete操作，它也可以等待alter表完成。</p></li></ul>
                    </div>

                </div>

            </div>
            <div class="simplesect">
                <div class="titlepage">
                    <div>
                        <div class="simple">
                            <h4 class="title"><a name="online-ddl-table-operations"></a>Table Operations</h4>

                        </div>

                    </div>

                </div>
                <p>
                    The following table provides an overview of online DDL support
                    for table operations. An asterisk indicates additional
                    information, an exception, or a dependency. For details, see
                    <a class="xref" href="innodb-storage-engine.html#online-ddl-table-syntax-notes" title="Syntax and Usage Notes">Syntax and Usage Notes</a>.
                </p><p style="color:blue;">下表概述了对表操作的联机ddl支持。星号表示附加信息、异常或依赖项。有关详细信息，请参见语法和用法说明。</p>
                <div class="table">
                    <a name="online-ddl-table-operations-table"></a><p class="title"><b>Table&nbsp;14.16&nbsp;Online DDL Support for Table Operations</b></p><p style="color:blue;">表14.16表操作的在线ddl支持</p>
                    <div class="table-contents">
                        <table summary="Online DDL support for table operations indicating whether the operation is performed in place, rebuilds the table, permits concurrent DML, or only modifies metadata."><colgroup><col width="20%" align="left"><col width="20%" align="center"><col width="20%" align="center"><col width="20%" align="center"><col width="20%" align="center"></colgroup><thead><tr>
                            <th scope="col">Operation</th>
                            <th scope="col">In Place</th>
                            <th scope="col">Rebuilds Table</th>
                            <th scope="col">Permits Concurrent DML</th>
                            <th scope="col">Only Modifies Metadata</th>
                        </tr></thead><tbody><tr>
                            <td scope="row">Changing the <code class="literal">ROW_FORMAT</code></td>
                            <td>Yes</td>
                            <td>Yes</td>
                            <td>Yes</td>
                            <td>No</td>
                        </tr><tr>
                            <td scope="row">Changing the <code class="literal">KEY_BLOCK_SIZE</code></td>
                            <td>Yes</td>
                            <td>Yes</td>
                            <td>Yes</td>
                            <td>No</td>
                        </tr><tr>
                            <td scope="row">Setting persistent table statistics</td>
                            <td>Yes</td>
                            <td>No</td>
                            <td>Yes</td>
                            <td>Yes</td>
                        </tr><tr>
                            <td scope="row">Specifying a character set</td>
                            <td>Yes</td>
                            <td>Yes*</td>
                            <td>No</td>
                            <td>No</td>
                        </tr><tr>
                            <td scope="row">Converting a character set</td>
                            <td>No</td>
                            <td>Yes*</td>
                            <td>No</td>
                            <td>No</td>
                        </tr><tr>
                            <td scope="row">Optimizing a table</td>
                            <td>Yes*</td>
                            <td>Yes</td>
                            <td>Yes</td>
                            <td>No</td>
                        </tr><tr>
                            <td scope="row">Rebuilding with the <code class="literal">FORCE</code> option</td>
                            <td>Yes*</td>
                            <td>Yes</td>
                            <td>Yes</td>
                            <td>No</td>
                        </tr><tr>
                            <td scope="row">Performing a null rebuild</td>
                            <td>Yes*</td>
                            <td>Yes</td>
                            <td>Yes</td>
                            <td>No</td>
                        </tr><tr>
                            <td scope="row">Renaming a table</td>
                            <td>Yes</td>
                            <td>No</td>
                            <td>Yes</td>
                            <td>Yes</td>
                        </tr></tbody></table>
                    </div>

                </div>
                <br class="table-break">
                <h5><a name="online-ddl-table-syntax-notes"></a>Syntax and Usage Notes</h5>
                <div class="itemizedlist">
                    <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                        Changing the <code class="literal">ROW_FORMAT</code>
                    </p><p style="color:blue;">更改行格式</p><pre data-lang="sql" class="programlisting">ALTER TABLE <em class="replaceable"><code>tbl_name</code></em> ROW_FORMAT = <em class="replaceable"><code>row_format</code></em>, ALGORITHM=INPLACE, LOCK=NONE;
</pre><p>
                        Data is reorganized substantially, making it an expensive
                        operation.
                    </p><p style="color:blue;">数据经过了实质性的重组，使之成为一种昂贵的操作。</p><p>
                        For additional information about the
                        <code class="literal">ROW_FORMAT</code> option, see
                        <a class="xref" href="sql-syntax.html#create-table-options" title="Table Options">Table Options</a>.
                    </p><p style="color:blue;">有关“行格式”选项的其他信息，请参见表选项。</p></li><li class="listitem"><p>
                        Changing the <code class="literal">KEY_BLOCK_SIZE</code>
                    </p><p style="color:blue;">更改密钥块大小</p><pre data-lang="sql" class="programlisting">ALTER TABLE <em class="replaceable"><code>tbl_name</code></em> KEY_BLOCK_SIZE = <em class="replaceable"><code>value</code></em>, ALGORITHM=INPLACE, LOCK=NONE;
</pre><p>
                        Data is reorganized substantially, making it an expensive
                        operation.
                    </p><p style="color:blue;">数据经过了实质性的重组，使之成为一种昂贵的操作。</p><p>
                        For additional information about the
                        <code class="literal">KEY_BLOCK_SIZE</code> option, see
                        <a class="xref" href="sql-syntax.html#create-table-options" title="Table Options">Table Options</a>.
                    </p><p style="color:blue;">有关“块大小”选项的其他信息，请参见表选项。</p></li><li class="listitem"><p>
                        Setting persistent table statistics options
                    </p><p style="color:blue;">设置持久表统计选项</p><pre data-lang="sql" class="programlisting">ALTER TABLE <em class="replaceable"><code>tbl_name</code></em> STATS_PERSISTENT=0, STATS_SAMPLE_PAGES=20, STATS_AUTO_RECALC=1, ALGORITHM=INPLACE, LOCK=NONE;
</pre><p>
                        Only modifies table metadata.
                    </p><p style="color:blue;">只修改表元数据。</p><p>
                        Persistent statistics include
                        <code class="literal">STATS_PERSISTENT</code>,
                        <code class="literal">STATS_AUTO_RECALC</code>, and
                        <code class="literal">STATS_SAMPLE_PAGES</code>. For more information,
                        see <a class="xref" href="innodb-storage-engine.html#innodb-persistent-stats" title="14.8.11.1&nbsp;Configuring Persistent Optimizer Statistics Parameters">Section&nbsp;14.8.11.1, “Configuring Persistent Optimizer Statistics Parameters”</a>.
                    </p><p style="color:blue;">持久性统计包括stats_persistent、stats_auto_recalc和stats_sample_页面。有关更多信息，请参阅第14.8.11.1节“配置持久优化器统计参数”。</p></li><li class="listitem"><p>
                        Specifying a character set
                    </p><p style="color:blue;">指定字符集</p><pre data-lang="sql" class="programlisting">ALTER TABLE <em class="replaceable"><code>tbl_name</code></em> CHARACTER SET = <em class="replaceable"><code>charset_name</code></em>, ALGORITHM=INPLACE, LOCK=NONE;
</pre><p>
                        Rebuilds the table if the new character encoding is
                        different.
                    </p><p style="color:blue;">如果新字符编码不同，则重建表。</p></li><li class="listitem"><p>
                        Converting a character set
                    </p><p style="color:blue;">转换字符集</p><pre data-lang="sql" class="programlisting">ALTER TABLE <em class="replaceable"><code>tbl_name</code></em> CONVERT TO CHARACTER SET <em class="replaceable"><code>charset_name</code></em>, ALGORITHM=COPY;
</pre><p>
                        Rebuilds the table if the new character encoding is
                        different.
                    </p><p style="color:blue;">如果新字符编码不同，则重建表。</p></li><li class="listitem"><p>
                        Optimizing a table
                    </p><p style="color:blue;">优化表</p><pre data-lang="sql" class="programlisting">OPTIMIZE TABLE <em class="replaceable"><code>tbl_name</code></em>;
</pre><p>
                        In-place operation is not supported for tables with
                        <code class="literal">FULLTEXT</code> indexes. The operation uses the
                        <code class="literal">INPLACE</code> algorithm, but
                        <code class="literal">ALGORITHM</code> and <code class="literal">LOCK</code>
                        syntax is not permitted.
                    </p><p style="color:blue;">具有全文索引的表不支持就地操作。该操作使用inplace算法，但不允许使用算法和锁语法。</p></li><li class="listitem"><p>
                        Rebuilding a table with the <code class="literal">FORCE</code> option
                    </p><p style="color:blue;">使用force选项重建表</p><pre data-lang="sql" class="programlisting">ALTER TABLE <em class="replaceable"><code>tbl_name</code></em> FORCE, ALGORITHM=INPLACE, LOCK=NONE;
</pre><p>
                        Uses <code class="literal">ALGORITHM=INPLACE</code> as of MySQL
                        5.6.17<code class="literal"></code>. <code class="literal">ALGORITHM=INPLACE</code> is
                        not supported for tables with <code class="literal">FULLTEXT</code>
                        indexes.
                    </p><p style="color:blue;">从mysql 5.6.17开始使用algorithm=inplace。具有全文索引的表不支持algorithm=inplace。</p></li><li class="listitem"><p>
                        Performing a "null" rebuild
                    </p><p style="color:blue;">执行“空”重建</p><pre data-lang="sql" class="programlisting">ALTER TABLE <em class="replaceable"><code>tbl_name</code></em> ENGINE=InnoDB, ALGORITHM=INPLACE, LOCK=NONE;
</pre><p>
                        Uses <code class="literal">ALGORITHM=INPLACE</code> as of MySQL
                        5.6.17. <code class="literal">ALGORITHM=INPLACE</code> is not
                        supported for tables with <code class="literal">FULLTEXT</code>
                        indexes.
                    </p><p style="color:blue;">从mysql 5.6.17开始使用algorithm=inplace。具有全文索引的表不支持algorithm=inplace。</p></li><li class="listitem"><p>
                        Renaming a table
                    </p><p style="color:blue;">重命名表</p><pre data-lang="sql" class="programlisting">ALTER TABLE <em class="replaceable"><code>old_tbl_name</code></em> RENAME TO <em class="replaceable"><code>new_tbl_name</code></em>, ALGORITHM=INPLACE, LOCK=NONE;
</pre><p>
                        MySQL renames files that correspond to the table
                        <em class="replaceable"><code>tbl_name</code></em> without making a copy.
                        (You can also use the <a class="link" href="sql-syntax.html#rename-table" title="13.1.33&nbsp;RENAME TABLE Syntax"><code class="literal">RENAME
                        TABLE</code></a> statement to rename tables. See
                        <a class="xref" href="sql-syntax.html#rename-table" title="13.1.33&nbsp;RENAME TABLE Syntax">Section&nbsp;13.1.33, “RENAME TABLE Syntax”</a>.) Privileges granted
                        specifically for the renamed table are not migrated to the
                        new name. They must be changed manually.
                    </p><p style="color:blue;">mysql重命名与表tbl_name相对应的文件，而不进行复制。（也可以使用rename table语句重命名表。请参阅13.1.33节，“重命名表语法”。）专门为重命名的表授予的权限不会迁移到新名称。必须手动更改它们。</p></li></ul>
                </div>

            </div>
            <div class="simplesect">
                <div class="titlepage">
                    <div>
                        <div class="simple">
                            <h4 class="title"><a name="online-ddl-tablespace-operations"></a>Tablespace Operations</h4>

                        </div>

                    </div>

                </div>
                <p>
                    The following table provides an overview of online DDL support
                    for tablespace operations. For details, see
                    <a class="xref" href="innodb-storage-engine.html#online-ddl-tablespace-syntax-notes" title="Syntax and Usage Notes">Syntax and Usage Notes</a>.
                </p><p style="color:blue;">下表概述了对表空间操作的联机ddl支持。有关详细信息，请参见语法和用法说明。</p>
                <div class="table">
                    <a name="online-ddl-tablespace-operations-table"></a><p class="title"><b>Table&nbsp;14.17&nbsp;Online DDL Support for Tablespace Operations</b></p><p style="color:blue;">表14.17表空间操作的在线ddl支持</p>
                    <div class="table-contents">
                        <table summary="Online DDL support for tablespace operations indicating whether the operation is performed in place, rebuilds tables within the tablespace, permits concurrent DML, or only modifies metadata."><colgroup><col width="20%" align="left"><col width="20%" align="center"><col width="20%" align="center"><col width="20%" align="center"><col width="20%" align="center"></colgroup><thead><tr>
                            <th scope="col">Operation</th>
                            <th scope="col">In Place</th>
                            <th scope="col">Rebuilds Table</th>
                            <th scope="col">Permits Concurrent DML</th>
                            <th scope="col">Only Modifies Metadata</th>
                        </tr></thead><tbody><tr>
                            <td scope="row">Enabling or disabling file-per-table tablespace encryption</td>
                            <td>No</td>
                            <td>Yes</td>
                            <td>No</td>
                            <td>No</td>
                        </tr></tbody></table>
                    </div>

                </div>
                <br class="table-break">
                <h5><a name="online-ddl-tablespace-syntax-notes"></a>Syntax and Usage Notes</h5>
                <p>
                    Enabling or disabling file-per-table tablespace encryption
                </p><p style="color:blue;">启用或禁用逐表文件表空间加密</p><pre data-lang="sql" class="programlisting">ALTER TABLE <em class="replaceable"><code>tbl_name</code></em> ENCRYPTION='Y', ALGORITHM=COPY;
</pre><p>
                Encryption is only supported for file-per-table tablespaces. For
                related information, see
                <a class="xref" href="innodb-storage-engine.html#innodb-tablespace-encryption" title="14.6.3.8&nbsp;InnoDB Data-at-Rest Encryption">Section&nbsp;14.6.3.8, “InnoDB Data-at-Rest Encryption”</a>.
            </p><p style="color:blue;">只支持对每个表空间的文件进行加密。有关信息，请参阅14.6.3.8节，“InnoDB静态数据加密”。</p>
            </div>
            <div class="simplesect">
                <div class="titlepage">
                    <div>
                        <div class="simple">
                            <h4 class="title"><a name="online-ddl-partitioning"></a>Partitioning Operations</h4>

                        </div>

                    </div>

                </div>
                <p>
                    With the exception of most <a class="link" href="sql-syntax.html#alter-table" title="13.1.8&nbsp;ALTER TABLE Syntax"><code class="literal">ALTER
                    TABLE</code></a> partitioning clauses, online DDL operations for
                    partitioned <code class="literal">InnoDB</code> tables follow the same
                    rules that apply to regular <code class="literal">InnoDB</code> tables.
                </p><p style="color:blue;">除了大多数alter table partitioning子句之外，对已分区的innodb表的联机ddl操作遵循适用于常规innodb表的相同规则。</p><p>
                Most <a class="link" href="sql-syntax.html#alter-table" title="13.1.8&nbsp;ALTER TABLE Syntax"><code class="literal">ALTER TABLE</code></a> partitioning
                clauses do not go through the same internal online DDL API as
                regular non-partitioned <code class="literal">InnoDB</code> tables. As a
                result, online support for <a class="link" href="sql-syntax.html#alter-table" title="13.1.8&nbsp;ALTER TABLE Syntax"><code class="literal">ALTER
                TABLE</code></a> partitioning clauses varies.
            </p><p style="color:blue;">大多数alter table partitioning子句不会像普通的无分区innodb表那样通过相同的内部联机ddl api。因此，对alter table partitioning子句的在线支持各不相同。</p><p>
                The following table shows the online status for each
                <code class="literal">ALTER TABLE</code> partitioning statement.
                Regardless of the online DDL API that is used, MySQL attempts to
                minimize data copying and locking where possible.
            </p><p style="color:blue;">下表显示了每个alter table partitioning语句的联机状态。不管使用的是在线ddl api，mysql都会尽量减少数据复制和锁定。</p><p>
                <a class="link" href="sql-syntax.html#alter-table" title="13.1.8&nbsp;ALTER TABLE Syntax"><code class="literal">ALTER TABLE</code></a> partitioning options
                that use <code class="literal">ALGORITHM=COPY</code> or that only permit
                <span class="quote">“<span class="quote"><code class="literal">ALGORITHM=DEFAULT,
        LOCK=DEFAULT</code></span>”</span>, repartition the table using the
                <code class="literal">COPY</code> algorithm. In other words, a new
                partitioned table is created with the new partitioning scheme.
                The newly created table includes any changes applied by the
                <a class="link" href="sql-syntax.html#alter-table" title="13.1.8&nbsp;ALTER TABLE Syntax"><code class="literal">ALTER TABLE</code></a> statement, and table
                data is copied into the new table structure.
            </p><p style="color:blue;">更改使用algorithm=copy或只允许“algorithm=default，lock=default”的表分区选项，使用copy算法重新分区表。换句话说，用新的分区方案创建一个新的分区表。新创建的表包含alter table语句应用的任何更改，表数据将复制到新的表结构中。</p>
                <div class="table">
                    <a name="innodb-online-ddl-partitioning-clauses"></a><p class="title"><b>Table&nbsp;14.18&nbsp;Online DDL Support for Partitioning Operations</b></p><p style="color:blue;">表14.18分区操作的在线ddl支持</p>
                    <div class="table-contents">
                        <table summary="Online DDL support for partitioning operatings indicating whether the operation is performed in place and permits concurrent DML."><colgroup><col width="24%" align="left"><col width="8%" align="center"><col width="12%" align="center"><col width="32%" align="left"></colgroup><thead><tr>
                            <th scope="col">Partitioning Clause</th>
                            <th scope="col">In Place</th>
                            <th scope="col">Permits DML</th>
                            <th scope="col">Notes</th>
                        </tr></thead><tbody><tr>
                            <td scope="row"><a class="link" href="sql-syntax.html#alter-table" title="13.1.8&nbsp;ALTER TABLE Syntax"><code class="literal">PARTITION BY</code></a></td>
                            <td>No</td>
                            <td>No</td>
                            <td>Permits <code class="literal">ALGORITHM=COPY</code>,
                                <code class="literal">LOCK={DEFAULT|SHARED|EXCLUSIVE}</code></td>
                        </tr><tr>
                            <td scope="row"><a class="link" href="sql-syntax.html#alter-table" title="13.1.8&nbsp;ALTER TABLE Syntax"><code class="literal">ADD PARTITION</code></a></td>
                            <td>No</td>
                            <td>No</td>
                            <td>Only permits <code class="literal">ALGORITHM=DEFAULT</code>,
                                <code class="literal">LOCK=DEFAULT</code>. Does not copy existing
                                data for tables partitioned by <code class="literal">RANGE</code> or
                                <code class="literal">LIST</code>. Concurrent queries are permitted
                                for tables partitioned by <code class="literal">HASH</code> or
                                <code class="literal">LIST</code>. MySQL copies the data while
                                holding a shared lock.</td>
                        </tr><tr>
                            <td scope="row"><a class="link" href="sql-syntax.html#alter-table" title="13.1.8&nbsp;ALTER TABLE Syntax"><code class="literal">DROP PARTITION</code></a></td>
                            <td>No</td>
                            <td>No</td>
                            <td>Only permits <code class="literal">ALGORITHM=DEFAULT</code>,
                                <code class="literal">LOCK=DEFAULT</code>. Does not copy existing
                                data for tables partitioned by <code class="literal">RANGE</code> or
                                <code class="literal">LIST</code>.</td>
                        </tr><tr>
                            <td scope="row"><a class="link" href="sql-syntax.html#alter-table" title="13.1.8&nbsp;ALTER TABLE Syntax"><code class="literal">DISCARD PARTITION</code></a></td>
                            <td>No</td>
                            <td>No</td>
                            <td>Only permits <code class="literal">ALGORITHM=DEFAULT</code>,
                                <code class="literal">LOCK=DEFAULT</code></td>
                        </tr><tr>
                            <td scope="row"><a class="link" href="sql-syntax.html#alter-table" title="13.1.8&nbsp;ALTER TABLE Syntax"><code class="literal">IMPORT PARTITION</code></a></td>
                            <td>No</td>
                            <td>No</td>
                            <td>Only permits <code class="literal">ALGORITHM=DEFAULT</code>,
                                <code class="literal">LOCK=DEFAULT</code></td>
                        </tr><tr>
                            <td scope="row"><a class="link" href="sql-syntax.html#alter-table" title="13.1.8&nbsp;ALTER TABLE Syntax"><code class="literal">TRUNCATE
                                PARTITION</code></a></td>
                            <td>Yes</td>
                            <td>Yes</td>
                            <td>Does not copy existing data. It merely deletes rows; it does not alter
                                the definition of the table itself, or of any of its
                                partitions.</td>
                        </tr><tr>
                            <td scope="row"><a class="link" href="sql-syntax.html#alter-table" title="13.1.8&nbsp;ALTER TABLE Syntax"><code class="literal">COALESCE
                                PARTITION</code></a></td>
                            <td>No</td>
                            <td>No</td>
                            <td>Only permits <code class="literal">ALGORITHM=DEFAULT</code>,
                                <code class="literal">LOCK=DEFAULT</code>. Concurrent queries are
                                permitted for tables partitioned by
                                <code class="literal">HASH</code> or <code class="literal">LIST</code>, as
                                MySQL copies the data while holding a shared lock.</td>
                        </tr><tr>
                            <td scope="row"><a class="link" href="sql-syntax.html#alter-table" title="13.1.8&nbsp;ALTER TABLE Syntax"><code class="literal">REORGANIZE
                                PARTITION</code></a></td>
                            <td>No</td>
                            <td>No</td>
                            <td>Only permits <code class="literal">ALGORITHM=DEFAULT</code>,
                                <code class="literal">LOCK=DEFAULT</code>. Concurrent queries are
                                permitted for tables partitioned by <code class="literal">LINEAR
                                    HASH</code> or <code class="literal">LIST</code>. MySQL copies
                                data from affected partitions while holding a shared
                                metadata lock.</td>
                        </tr><tr>
                            <td scope="row"><a class="link" href="sql-syntax.html#alter-table" title="13.1.8&nbsp;ALTER TABLE Syntax"><code class="literal">EXCHANGE
                                PARTITION</code></a></td>
                            <td>Yes</td>
                            <td>Yes</td>
                            <td></td>
                        </tr><tr>
                            <td scope="row"><a class="link" href="sql-syntax.html#alter-table" title="13.1.8&nbsp;ALTER TABLE Syntax"><code class="literal">ANALYZE PARTITION</code></a></td>
                            <td>Yes</td>
                            <td>Yes</td>
                            <td></td>
                        </tr><tr>
                            <td scope="row"><a class="link" href="sql-syntax.html#alter-table" title="13.1.8&nbsp;ALTER TABLE Syntax"><code class="literal">CHECK PARTITION</code></a></td>
                            <td>Yes</td>
                            <td>Yes</td>
                            <td></td>
                        </tr><tr>
                            <td scope="row"><a class="link" href="sql-syntax.html#alter-table" title="13.1.8&nbsp;ALTER TABLE Syntax"><code class="literal">OPTIMIZE
                                PARTITION</code></a></td>
                            <td>No</td>
                            <td>No</td>
                            <td><code class="literal">ALGORITHM</code> and <code class="literal">LOCK</code> clauses are
                                ignored. Rebuilds the entire table. See
                                <a class="xref" href="partitioning.html#partitioning-maintenance" title="22.3.4&nbsp;Maintenance of Partitions">Section&nbsp;22.3.4, “Maintenance of Partitions”</a>.</td>
                        </tr><tr>
                            <td scope="row"><a class="link" href="sql-syntax.html#alter-table" title="13.1.8&nbsp;ALTER TABLE Syntax"><code class="literal">REBUILD PARTITION</code></a></td>
                            <td>No</td>
                            <td>No</td>
                            <td>Only permits <code class="literal">ALGORITHM=DEFAULT</code>,
                                <code class="literal">LOCK=DEFAULT</code>. Concurrent queries are
                                permitted for tables partitioned by <code class="literal">LINEAR
                                    HASH</code> or <code class="literal">LIST</code>. MySQL copies
                                data from affected partitions while holding a shared
                                metadata lock.</td>
                        </tr><tr>
                            <td scope="row"><a class="link" href="sql-syntax.html#alter-table" title="13.1.8&nbsp;ALTER TABLE Syntax"><code class="literal">REPAIR PARTITION</code></a></td>
                            <td>Yes</td>
                            <td>Yes</td>
                            <td></td>
                        </tr><tr>
                            <td scope="row"><a class="link" href="sql-syntax.html#alter-table" title="13.1.8&nbsp;ALTER TABLE Syntax"><code class="literal">REMOVE
                                PARTITIONING</code></a></td>
                            <td>No</td>
                            <td>No</td>
                            <td>Permits <code class="literal">ALGORITHM=COPY</code>,
                                <code class="literal">LOCK={DEFAULT|SHARED|EXCLUSIVE}</code></td>
                        </tr></tbody></table>
                    </div>

                </div>
                <br class="table-break"><p>
                Non-partitioning online <a class="link" href="sql-syntax.html#alter-table" title="13.1.8&nbsp;ALTER TABLE Syntax"><code class="literal">ALTER
                TABLE</code></a> operations on partitioned tables follow the same
                rules that apply to regular tables. However,
                <a class="link" href="sql-syntax.html#alter-table" title="13.1.8&nbsp;ALTER TABLE Syntax"><code class="literal">ALTER TABLE</code></a> performs online
                operations on each table partition, which causes increased
                demand on system resources due to operations being performed on
                multiple partitions.
            </p><p style="color:blue;">分区表上的非分区联机alter table操作遵循适用于常规表的相同规则。但是，alter table在每个表分区上执行联机操作，这会由于在多个分区上执行操作而增加对系统资源的需求。</p><p>
                For additional information about <a class="link" href="sql-syntax.html#alter-table" title="13.1.8&nbsp;ALTER TABLE Syntax"><code class="literal">ALTER
                TABLE</code></a> partitioning clauses, see
                <a class="xref" href="sql-syntax.html#alter-table-partition-options" title="Partitioning Options">Partitioning Options</a>, and
                <a class="xref" href="sql-syntax.html#alter-table-partition-operations" title="13.1.8.1&nbsp;ALTER TABLE Partition Operations">Section&nbsp;13.1.8.1, “ALTER TABLE Partition Operations”</a>. For
                information about partitioning in general, see
                <a class="xref" href="partitioning.html" title="Chapter&nbsp;22&nbsp;Partitioning">Chapter&nbsp;22, <i>Partitioning</i></a>.
            </p><p style="color:blue;">有关alter table partitioning子句的更多信息，请参阅partitioning options和第13.1.8.1节“alter table partition operations”。有关一般分区的信息，请参阅第22章，分区。</p>
            </div>

        </div>
        <div class="section">
            <div class="titlepage">
                <div>
                    <div>
                        <h3 class="title"><a name="innodb-online-ddl-performance"></a>14.13.2&nbsp;Online DDL Performance and Concurrency</h3>

                    </div>

                </div>

            </div>
            <a class="indexterm" name="idm140286816895664"></a><p>
            Online DDL improves several aspects of MySQL operation:
        </p><p style="color:blue;">联机ddl改进了mysql操作的几个方面：</p>
            <div class="itemizedlist">
                <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                    Applications that access the table are more responsive because
                    queries and DML operations on the table can proceed while the
                    DDL operation is in progress. Reduced locking and waiting for
                    MySQL server resources leads to greater scalability, even for
                    operations that are not involved in the DDL operation.
                </p><p style="color:blue;">访问该表的应用程序响应性更强，因为在执行ddl操作时，可以继续对该表进行查询和dml操作。减少了对mysql服务器资源的锁定和等待，从而提高了可伸缩性，即使对于不涉及ddl操作的操作也是如此。</p></li><li class="listitem"><p>
                    In-place operations avoid the disk I/O and CPU cycles
                    associated with the table-copy method, which minimizes overall
                    load on the database. Minimizing load helps maintain good
                    performance and high throughput during the DDL operation.
                </p><p style="color:blue;">就地操作避免了与表复制方法相关联的磁盘I/O和CPU周期，从而最小化了数据库的总体负载。最小化负载有助于在ddl操作期间保持良好的性能和高吞吐量。</p></li><li class="listitem"><p>
                    In-place operations read less data into the buffer pool than
                    the table-copy operations, which reduces purging of frequently
                    accessed data from memory. Purging of frequently accessed data
                    can cause a temporary performance dip after a DDL operation.
                </p><p style="color:blue;">与表复制操作相比，就地操作在缓冲池中读取的数据更少，这减少了从内存中清除频繁访问的数据。清除频繁访问的数据可能导致DDL操作后的临时性能下降。</p></li></ul>
            </div>
            <div class="simplesect">
                <div class="titlepage">
                    <div>
                        <div class="simple">
                            <h4 class="title"><a name="innodb-online-ddl-locking-options"></a>The LOCK clause</h4>

                        </div>

                    </div>

                </div>
                <p>
                    By default, MySQL uses as little locking as possible during a
                    DDL operation. The <code class="literal">LOCK</code> clause can be
                    specified to enforce more restrictive locking, if required. If
                    the <code class="literal">LOCK</code> clause specifies a less restrictive
                    level of locking than is permitted for a particular DDL
                    operation, the statement fails with an error.
                    <code class="literal">LOCK</code> clauses are described below, in order of
                    least to most restrictive:
                </p><p style="color:blue;">默认情况下，mysql在ddl操作期间使用尽可能少的锁。如果需要，可以指定lock子句来强制执行更严格的锁定。如果lock子句指定的锁定级别低于特定ddl操作所允许的限制级别，则语句将失败，并出现错误。锁条款如下所述，按从少到多的限制顺序排列：</p>
                <div class="itemizedlist">
                    <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                        <code class="literal">LOCK=NONE</code>:
                    </p><p style="color:blue;">锁定=无：</p><p>
                        Permits concurrent queries and DML.
                    </p><p style="color:blue;">允许并发查询和DML。</p><p>
                        For example, use this clause for tables involving customer
                        signups or purchases, to avoid making the tables unavailable
                        during lengthy DDL operations.
                    </p><p style="color:blue;">例如，对涉及客户注册或购买的表使用此子句，以避免在长时间的ddl操作期间使表不可用。</p></li><li class="listitem"><p>
                        <code class="literal">LOCK=SHARED</code>:
                    </p><p style="color:blue;">锁定=共享：</p><p>
                        Permits concurrent queries but blocks DML.
                    </p><p style="color:blue;">允许并发查询，但阻止DML。</p><p>
                        For example, use this clause on data warehouse tables, where
                        you can delay data load operations until the DDL operation
                        is finished, but queries cannot be delayed for long periods.
                    </p><p style="color:blue;">例如，在数据仓库表上使用此子句，可以将数据加载操作延迟到DDL操作完成，但查询不能长时间延迟。</p></li><li class="listitem"><p>
                        <code class="literal">LOCK=DEFAULT</code>:
                    </p><p style="color:blue;">锁定=默认值：</p><p>
                        Permits as much concurrency as possible (concurrent queries,
                        DML, or both). Omitting the <code class="literal">LOCK</code> clause
                        is the same as specifying <code class="literal">LOCK=DEFAULT</code>.
                    </p><p style="color:blue;">允许尽可能多的并发（并发查询、DML或两者）。省略lock子句与指定lock=default相同。</p><p>
                        Use this clause when you know that the default locking level
                        of the DDL statement will not cause availability problems
                        for the table.
                    </p><p style="color:blue;">如果知道ddl语句的默认锁定级别不会导致表的可用性问题，请使用此子句。</p></li><li class="listitem"><p>
                        <code class="literal">LOCK=EXCLUSIVE</code>:
                    </p><p style="color:blue;">锁定=独占：</p><p>
                        Blocks concurrent queries and DML.
                    </p><p style="color:blue;">阻止并发查询和DML。</p><p>
                        Use this clause if the primary concern is finishing the DDL
                        operation in the shortest amount of time possible, and
                        concurrent query and DML access is not necessary. You might
                        also use this clause if the server is supposed to be idle,
                        to avoid unexpected table accesses.
                    </p><p style="color:blue;">如果主要关注点是在尽可能短的时间内完成DDL操作，并且不需要并发查询和DML访问，请使用此子句。如果服务器应该空闲，也可以使用此子句，以避免意外的表访问。</p></li></ul>
                </div>

            </div>
            <div class="simplesect">
                <div class="titlepage">
                    <div>
                        <div class="simple">
                            <h4 class="title"><a name="innodb-online-ddl-metadata-locks"></a>Online DDL and Metadata Locks</h4>

                        </div>

                    </div>

                </div>
                <p>
                    Online DDL operations can be viewed as having three phases:
                </p><p style="color:blue;">在线ddl操作可以看作有三个阶段：</p>
                <div class="itemizedlist">
                    <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                        <span class="emphasis"><em>Phase 1: Initialization</em></span>
                    </p><p style="color:blue;">阶段1：初始化</p><p>
                        In the initialization phase, the server determines how much
                        concurrency is permitted during the operation, taking into
                        account storage engine capabilities, operations specified in
                        the statement, and user-specified
                        <code class="literal">ALGORITHM</code> and <code class="literal">LOCK</code>
                        options. During this phase, a shared upgradeable metadata
                        lock is taken to protect the current table definition.
                    </p><p style="color:blue;">在初始化阶段，服务器将考虑存储引擎功能、语句中指定的操作以及用户指定的算法和锁选项，确定操作期间允许的并发性。在此阶段，将使用共享的可升级元数据锁来保护当前表定义。</p></li><li class="listitem"><p>
                        <span class="emphasis"><em>Phase 2: Execution</em></span>
                    </p><p style="color:blue;">第2阶段：执行</p><p>
                        In this phase, the statement is prepared and executed.
                        Whether the metadata lock is upgraded to exclusive depends
                        on the factors assessed in the initialization phase. If an
                        exclusive metadata lock is required, it is only taken
                        briefly during statement preparation.
                    </p><p style="color:blue;">在此阶段，将准备并执行语句。元数据锁是否升级为exclusive取决于在初始化阶段评估的因素。如果需要排他元数据锁，则只在语句准备期间短暂执行。</p></li><li class="listitem"><p>
                        <span class="emphasis"><em>Phase 3: Commit Table Definition</em></span>
                    </p><p style="color:blue;">阶段3：提交表定义</p><p>
                        In the commit table definition phase, the metadata lock is
                        upgraded to exclusive to evict the old table definition and
                        commit the new one. Once granted, the duration of the
                        exclusive metadata lock is brief.
                    </p><p style="color:blue;">在提交表定义阶段，元数据锁升级为exclusive，以收回旧表定义并提交新表定义。一旦授予，独占元数据锁的持续时间很短。</p></li></ul>
                </div>
                <p>
                    Due to the exclusive metadata lock requirements outlined above,
                    an online DDL operation may have to wait for concurrent
                    transactions that hold metadata locks on the table to commit or
                    rollback. Transactions started before or during the DDL
                    operation can hold metadata locks on the table being altered. In
                    the case of a long running or inactive transaction, an online
                    DDL operation can time out waiting for an exclusive metadata
                    lock. Additionally, a pending exclusive metadata lock requested
                    by an online DDL operation blocks subsequent transactions on the
                    table.
                </p><p style="color:blue;">由于上面概述的独占元数据锁要求，联机ddl操作可能需要等待持有表上元数据锁的并发事务提交或回滚。在ddl操作之前或期间启动的事务可以保存正在更改的表上的元数据锁。在长时间运行或非活动事务的情况下，联机ddl操作可能会在等待独占元数据锁时超时。此外，联机ddl操作请求的挂起的独占元数据锁会阻塞表上的后续事务。</p><p>
                The following example demonstrates an online DDL operation
                waiting for an exclusive metadata lock, and how a pending
                metadata lock blocks subsequent transactions on the table.
            </p><p style="color:blue;">下面的示例演示等待独占元数据锁的联机DDL操作，以及挂起的元数据锁如何阻止表上的后续事务。</p><p>
                Session 1:
            </p><p style="color:blue;">会议1：</p><pre data-lang="sql" class="programlisting">mysql&gt; CREATE TABLE t1 (c1 INT) ENGINE=InnoDB;
mysql&gt; START TRANSACTION;
mysql&gt; SELECT * FROM t1;
</pre><p>
                The session 1 <a class="link" href="sql-syntax.html#select" title="13.2.9&nbsp;SELECT Syntax"><code class="literal">SELECT</code></a> statement
                takes a shared metadata lock on table t1.
            </p><p style="color:blue;">session 1 select语句对表t1使用共享元数据锁。</p><p>
                Session 2:
            </p><p style="color:blue;">会议2：</p><pre data-lang="sql" class="programlisting">mysql&gt; ALTER TABLE t1 ADD COLUMN x INT, ALGORITHM=INPLACE, LOCK=NONE;
</pre><p>
                The online DDL operation in session 2, which requires an
                exclusive metadata lock on table t1 to commit table definition
                changes, must wait for the session 1 transaction to commit or
                roll back.
            </p><p style="color:blue;">会话2中的联机DDL操作需要表T1上的独占元数据锁来提交表定义更改，必须等待会话1事务提交或回滚。</p><p>
                Session 3:
            </p><p style="color:blue;">第3课时：</p><pre data-lang="sql" class="programlisting">mysql&gt; SELECT * FROM t1;
</pre><p>
                The <a class="link" href="sql-syntax.html#select" title="13.2.9&nbsp;SELECT Syntax"><code class="literal">SELECT</code></a> statement issued in
                session 3 is blocked waiting for the exclusive metadata lock
                requested by the <a class="link" href="sql-syntax.html#alter-table" title="13.1.8&nbsp;ALTER TABLE Syntax"><code class="literal">ALTER TABLE</code></a>
                operation in session 2 to be granted.
            </p><p style="color:blue;">会话3中发出的select语句在等待会话2中的alter table操作请求的独占元数据锁被授予时被阻止。</p><p>
                You can use
                <a class="link" href="sql-syntax.html#show-processlist" title="13.7.5.29&nbsp;SHOW PROCESSLIST Syntax"><code class="literal">SHOW FULL
                    PROCESSLIST</code></a> to determine if transactions are waiting
                for a metadata lock.
            </p><p style="color:blue;">您可以使用show full processlist来确定事务是否正在等待元数据锁。</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>SHOW FULL PROCESSLIST\G</code></strong>
...
*************************** 2. row ***************************
     Id: 5
   User: root
   Host: localhost
     db: test
Command: Query
   Time: 44
  State: Waiting for table metadata lock
   Info: ALTER TABLE t1 ADD COLUMN x INT, ALGORITHM=INPLACE, LOCK=NONE
...
*************************** 4. row ***************************
     Id: 7
   User: root
   Host: localhost
     db: test
Command: Query
   Time: 5
  State: Waiting for table metadata lock
   Info: SELECT * FROM t1
4 rows in set (0.00 sec)
</pre><p>
                Metadata lock information is also exposed through the
                Performance Schema <a class="link" href="performance-schema.html#metadata-locks-table" title="25.12.12.1&nbsp;The metadata_locks Table"><code class="literal">metadata_locks</code></a>
                table, which provides information about metadata lock
                dependencies between sessions, the metadata lock a session is
                waiting for, and the session that currently holds the metadata
                lock. For more information, see
                <a class="xref" href="performance-schema.html#metadata-locks-table" title="25.12.12.1&nbsp;The metadata_locks Table">Section&nbsp;25.12.12.1, “The metadata_locks Table”</a>.
            </p><p style="color:blue;">元数据锁信息还通过性能架构元数据锁表公开，该表提供有关会话之间的元数据锁依赖关系、会话正在等待的元数据锁以及当前持有元数据锁的会话的信息。有关详细信息，请参见第25.12.12.1节“元数据锁定表”。</p>
            </div>
            <div class="simplesect">
                <div class="titlepage">
                    <div>
                        <div class="simple">
                            <h4 class="title"><a name="innodb-online-ddl-performance-comparison"></a>Online DDL Performance</h4>

                        </div>

                    </div>

                </div>
                <p>
                    The performance of a DDL operation is largely determined by
                    whether the operation is performed in place and whether it
                    rebuilds the table.
                </p><p style="color:blue;">ddl操作的性能在很大程度上取决于该操作是否执行到位，以及它是否重建了表。</p><p>
                To assess the relative performance of a DDL operation, you can
                compare results using <code class="literal">ALGORITHM=INPLACE</code> with
                results using <code class="literal">ALGORITHM=COPY</code>. Alternatively,
                you can compare results with
                <a class="link" href="server-administration.html#sysvar_old_alter_table"><code class="literal">old_alter_table</code></a> disabled and
                enabled.
            </p><p style="color:blue;">要评估DDL操作的相对性能，可以使用algorithm=inplace与algorithm=copy比较结果。或者，您可以将结果与禁用和启用的旧更改表进行比较。</p><p>
                For DDL operations that modify table data, you can determine
                whether a DDL operation performs changes in place or performs a
                table copy by looking at the <span class="quote">“<span class="quote">rows affected</span>”</span> value
                displayed after the command finishes. For example:
            </p><p style="color:blue;">对于修改表数据的ddl操作，可以通过查看命令完成后显示的“受影响的行”值来确定ddl操作是就地执行更改还是执行表复制。例如：</p>
                <div class="itemizedlist">
                    <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                        Changing the default value of a column (fast, does not
                        affect the table data):
                    </p><p style="color:blue;">更改列的默认值（fast，不影响表数据）：</p><pre data-lang="sql" class="programlisting">Query OK, 0 rows affected (0.07 sec)
</pre></li><li class="listitem"><p>
                        Adding an index (takes time, but <code class="literal">0 rows
                        affected</code> shows that the table is not copied):
                    </p><p style="color:blue;">添加索引（需要时间，但受影响的0行表示未复制表）：</p><pre data-lang="sql" class="programlisting">Query OK, 0 rows affected (21.42 sec)
</pre></li><li class="listitem"><p>
                        Changing the data type of a column (takes substantial time
                        and requires rebuilding all the rows of the table):
                    </p><p style="color:blue;">更改列的数据类型（需要大量时间并需要重新生成表中的所有行）：</p><pre data-lang="sql" class="programlisting">Query OK, 1671168 rows affected (1 min 35.54 sec)
</pre></li></ul>
                </div>
                <p>
                    Before running a DDL operation on a large table, check whether
                    the operation is fast or slow as follows:
                </p><p style="color:blue;">在对大型表运行DDL操作之前，请按以下步骤检查该操作是快还是慢：</p>
                <div class="orderedlist">
                    <ol class="orderedlist" type="1"><li class="listitem"><p>
                        Clone the table structure.
                    </p><p style="color:blue;">克隆表结构。</p></li><li class="listitem"><p>
                        Populate the cloned table with a small amount of data.
                    </p><p style="color:blue;">用少量数据填充克隆的表。</p></li><li class="listitem"><p>
                        Run the DDL operation on the cloned table.
                    </p><p style="color:blue;">在克隆的表上运行ddl操作。</p></li><li class="listitem"><p>
                        Check whether the <span class="quote">“<span class="quote">rows affected</span>”</span> value is zero
                        or not. A nonzero value means the operation copies table
                        data, which might require special planning. For example, you
                        might do the DDL operation during a period of scheduled
                        downtime, or on each replication slave server one at a time.
                    </p><p style="color:blue;">检查“受影响的行”值是否为零。非零值表示操作复制表数据，这可能需要特殊的计划。例如，可以在计划停机期间执行DDL操作，也可以在每个复制从属服务器上一次执行一个DDL操作。</p></li></ol>
                </div>
                <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">
                    <div class="admon-title">
                        Note
                    </div>
                    <p>
                        For a greater understanding of the MySQL processing associated
                        with a DDL operation, examine Performance Schema and
                        <code class="literal">INFORMATION_SCHEMA</code> tables related to
                        <code class="literal">InnoDB</code> before and after DDL operations to
                        see the number of physical reads, writes, memory allocations,
                        and so on.
                    </p><p style="color:blue;">为了更好地理解与ddl操作相关联的mysql处理，请在ddl操作前后检查性能模式和与innodb相关的信息模式表，以查看物理读取、写入、内存分配等的数量。</p><p>
                    Performance Schema stage events can be used to monitor
                    <a class="link" href="sql-syntax.html#alter-table" title="13.1.8&nbsp;ALTER TABLE Syntax"><code class="literal">ALTER TABLE</code></a> progress. See
                    <a class="xref" href="innodb-storage-engine.html#monitor-alter-table-performance-schema" title="14.16.1&nbsp;Monitoring ALTER TABLE Progress for InnoDB Tables Using Performance Schema">Section&nbsp;14.16.1, “Monitoring ALTER TABLE Progress for InnoDB Tables Using Performance
                        Schema”</a>.
                </p><p style="color:blue;">性能架构阶段事件可用于监视alter table进度。参见14.16.1节，“使用性能模式监视innodb表的alter table进度”。</p>
                </div>
                <p>
                    Because there is some processing work involved with recording
                    the changes made by concurrent DML operations, then applying
                    those changes at the end, an online DDL operation could take
                    longer overall than the table-copy mechanism that blocks table
                    access from other sessions. The reduction in raw performance is
                    balanced against better responsiveness for applications that use
                    the table. When evaluating the techniques for changing table
                    structure, consider end-user perception of performance, based on
                    factors such as load times for web pages.
                </p><p style="color:blue;">由于在记录并发dml操作所做的更改，然后在最后应用这些更改时需要进行一些处理工作，因此联机ddl操作总体上可能比阻止其他会话访问表的表复制机制花费更长的时间。原始性能的降低与使用该表的应用程序的更好响应性是平衡的。在评估更改表结构的技术时，请考虑最终用户对性能的感知，这取决于web页面的加载时间等因素。</p>
            </div>

        </div>
        <div class="section">
            <div class="titlepage">
                <div>
                    <div>
                        <h3 class="title"><a name="innodb-online-ddl-space-requirements"></a>14.13.3&nbsp;Online DDL Space Requirements</h3>

                    </div>

                </div>

            </div>
            <p>
                Online DDL operations have the following space requirements:
            </p><p style="color:blue;">联机DDL操作具有以下空间要求：</p>
            <div class="itemizedlist">
                <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                    Space for temporary log files
                </p><p style="color:blue;">临时日志文件的空间</p><p>
                    A temporary log file records concurrent DML when an online DDL
                    operation creates an index or alters a table. The temporary
                    log file is extended as required by the value of
                    <a class="link" href="innodb-storage-engine.html#sysvar_innodb_sort_buffer_size"><code class="literal">innodb_sort_buffer_size</code></a> up to
                    a maximum specified by
                    <a class="link" href="innodb-storage-engine.html#sysvar_innodb_online_alter_log_max_size"><code class="literal">innodb_online_alter_log_max_size</code></a>.
                    If a temporary log file exceeds the size limit, the online DDL
                    operation fails, and uncommitted concurrent DML operations are
                    rolled back. A large
                    <a class="link" href="innodb-storage-engine.html#sysvar_innodb_online_alter_log_max_size"><code class="literal">innodb_online_alter_log_max_size</code></a>
                    setting permits more DML during an online DDL operation, but
                    it also extends the period of time at the end of the DDL
                    operation when the table is locked to apply logged DML.
                </p><p style="color:blue;">当联机DDL操作创建索引或更改表时，临时日志文件记录并发DML。临时日志文件按UnbjySoTrpFuffelSoad的值扩展到由NudidByOnLy.AutoLogLog-Max大小所指定的最大值。如果临时日志文件超过大小限制，则联机DDL操作失败，并且回滚未提交的并发DML操作。一个大型的innodb_online_alter_log_max_size设置允许在联机ddl操作期间使用更多的dml，但它也延长了ddl操作结束时锁定表以应用记录的dml的时间段。</p><p>
                    If the operation takes a long time and concurrent DML modifies
                    the table so much that the size of the temporary log file
                    exceeds the value of
                    <a class="link" href="innodb-storage-engine.html#sysvar_innodb_online_alter_log_max_size"><code class="literal">innodb_online_alter_log_max_size</code></a>,
                    the online DDL operation fails with a
                    <code class="literal">DB_ONLINE_LOG_TOO_BIG</code> error.
                </p><p style="color:blue;">如果操作花费很长时间，并发DML修改表的次数太多，临时日志文件的大小超过innodb_online_alter_log_max_size的值，则联机DDL操作失败，并出现db_online_log_too_大错误。</p></li><li class="listitem"><p>
                    Space for temporary sort files
                </p><p style="color:blue;">临时排序文件的空间</p><p>
                    Online DDL operations that rebuild the table write temporary
                    sort files to the MySQL temporary directory
                    (<code class="literal">$TMPDIR</code> on Unix, <code class="literal">%TEMP%</code>
                    on Windows, or the directory specified by
                    <a class="link" href="server-administration.html#sysvar_tmpdir"><code class="literal">--tmpdir</code></a>) during index
                    creation. Temporary sort files are not created in the
                    directory that contains the original table. Each temporary
                    sort file is large enough to hold all secondary index columns
                    plus the primary key columns of the clustered index. Temporary
                    sort files are removed as soon as their contents are merged
                    into the final table or index. Temporary sort files may
                    require space equal to the amount of data in the table plus
                    indexes. An online DDL operation that rebuilds the table
                    reports an error if it uses all of the available disk space on
                    the file system where the data directory resides.
                </p><p style="color:blue;">重建表的联机DDL操作在索引创建期间将临时排序文件写入MySQL临时目录（UNIX上为tmpdir，Windows上为temp%，或由--tmpdir指定的目录）。临时排序文件不是在包含原始表的目录中创建的。每个临时排序文件都足够大，可以容纳所有辅助索引列和聚集索引的主键列。一旦临时排序文件的内容合并到最终表或索引中，它们就会被删除。临时排序文件可能需要的空间等于表中的数据量加上索引。如果重建表的联机ddl操作使用数据目录所在的文件系统上的所有可用磁盘空间，则会报告错误。</p><p>
                    If the MySQL temporary directory is not large enough to hold
                    the sort files, set <a class="link" href="server-administration.html#sysvar_tmpdir"><code class="literal">tmpdir</code></a> to
                    a different directory. Alternatively, define a separate
                    temporary directory for online DDL operations using
                    <a class="link" href="innodb-storage-engine.html#sysvar_innodb_tmpdir"><code class="literal">innodb_tmpdir</code></a>. This option
                    was introduced in MySQL 5.7.11 to help avoid temporary
                    directory overflows that could occur as a result of large
                    temporary sort files.
                </p><p style="color:blue;">如果mysql临时目录不够大，无法保存排序文件，请将tmpdir设置为其他目录。或者，使用innodb_tmpdir为联机ddl操作定义一个单独的临时目录。mysql 5.7.11中引入了此选项，以帮助避免由于大型临时排序文件而导致的临时目录溢出。</p></li><li class="listitem"><p>
                    Space for an intermediate table file
                </p><p style="color:blue;">中间表文件的空间</p><p>
                    Some online DDL operations that rebuild the table create a
                    temporary intermediate table file in the same directory as the
                    original table. An intermediate table file may require space
                    equal to the size of the original table. Intermediate table
                    file names begin with <code class="filename">#sql-ib</code> prefix and
                    only appear briefly during the online DDL operation.
                </p><p style="color:blue;">一些重建表的联机ddl操作在与原始表相同的目录中创建临时中间表文件。中间表文件可能需要与原始表大小相等的空间。中间表文件名以SQL IB前缀开头，仅在联机DDL操作期间短暂出现。</p><p>
                    The <a class="link" href="innodb-storage-engine.html#sysvar_innodb_tmpdir"><code class="literal">innodb_tmpdir</code></a> option is
                    not applicable to intermediate table files.
                </p><p style="color:blue;">innodb_tmpdir选项不适用于中间表文件。</p></li></ul>
            </div>

        </div>
        <div class="section">
            <div class="titlepage">
                <div>
                    <div>
                        <h3 class="title"><a name="innodb-online-ddl-single-multi"></a>14.13.4&nbsp;Simplifying DDL Statements with Online DDL</h3>

                    </div>

                </div>

            </div>
            <p>
                Before the introduction of <a class="link" href="glossary.html#glos_online_ddl" title="online DDL">online
                DDL</a>, it was common practice to combine many DDL operations
                into a single <a class="link" href="sql-syntax.html#alter-table" title="13.1.8&nbsp;ALTER TABLE Syntax"><code class="literal">ALTER TABLE</code></a>
                statement. Because each <a class="link" href="sql-syntax.html#alter-table" title="13.1.8&nbsp;ALTER TABLE Syntax"><code class="literal">ALTER TABLE</code></a>
                statement involved copying and rebuilding the table, it was more
                efficient to make several changes to the same table at once, since
                those changes could all be done with a single rebuild operation
                for the table. The downside was that SQL code involving DDL
                operations was harder to maintain and to reuse in different
                scripts. If the specific changes were different each time, you
                might have to construct a new complex <a class="link" href="sql-syntax.html#alter-table" title="13.1.8&nbsp;ALTER TABLE Syntax"><code class="literal">ALTER
                TABLE</code></a> for each slightly different scenario.
            </p><p style="color:blue;">在引入联机ddl之前，将多个ddl操作组合到一个alter table语句中是一种常见的做法。因为每个alter table语句都涉及复制和重新生成表，所以一次对同一个表进行多个更改更为有效，因为这些更改都可以通过表的单个重新生成操作来完成。缺点是，涉及ddl操作的sql代码很难在不同的脚本中维护和重用。如果每次特定的更改都不同，则可能需要为每个稍有不同的场景构建一个新的复杂alter表。</p><p>
            For DDL operations that can be done in place, you can separate
            them into individual <a class="link" href="sql-syntax.html#alter-table" title="13.1.8&nbsp;ALTER TABLE Syntax"><code class="literal">ALTER TABLE</code></a>
            statements for easier scripting and maintenance, without
            sacrificing efficiency. For example, you might take a complicated
            statement such as:
        </p><p style="color:blue;">对于可以就地执行的ddl操作，您可以将它们分离为单独的alter table语句，以便于编写脚本和维护，而不牺牲效率。例如，您可以使用一个复杂的语句，例如：</p><pre data-lang="sql" class="programlisting">ALTER TABLE t1 ADD INDEX i1(c1), ADD UNIQUE INDEX i2(c2),
  CHANGE c4_old_name c4_new_name INTEGER UNSIGNED;
</pre><p>
            and break it down into simpler parts that can be tested and
            performed independently, such as:
        </p><p style="color:blue;">并将其分解为可以独立测试和执行的更简单的部分，例如：</p><pre data-lang="sql" class="programlisting">ALTER TABLE t1 ADD INDEX i1(c1);
ALTER TABLE t1 ADD UNIQUE INDEX i2(c2);
ALTER TABLE t1 CHANGE c4_old_name c4_new_name INTEGER UNSIGNED NOT NULL;
</pre><p>
            You might still use multi-part <a class="link" href="sql-syntax.html#alter-table" title="13.1.8&nbsp;ALTER TABLE Syntax"><code class="literal">ALTER
            TABLE</code></a> statements for:
        </p><p style="color:blue;">您仍然可以使用多部分alter table语句来：</p>
            <div class="itemizedlist">
                <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                    Operations that must be performed in a specific sequence, such
                    as creating an index followed by a foreign key constraint that
                    uses that index.
                </p><p style="color:blue;">必须按特定顺序执行的操作，例如创建索引，后跟使用该索引的外键约束。</p></li><li class="listitem"><p>
                    Operations all using the same specific <code class="literal">LOCK</code>
                    clause, that you want to either succeed or fail as a group.
                </p><p style="color:blue;">所有操作都使用同一个特定的lock子句，您希望它们作为一个组成功或失败。</p></li><li class="listitem"><p>
                    Operations that cannot be performed in place, that is, that
                    still use the table-copy method.
                </p><p style="color:blue;">不能就地执行的操作，即仍然使用表复制方法的操作。</p></li><li class="listitem"><p>
                    Operations for which you specify
                    <code class="literal">ALGORITHM=COPY</code> or
                    <a class="link" href="server-administration.html#sysvar_old_alter_table"><code class="literal">old_alter_table=1</code></a>, to force
                    the table-copying behavior if needed for precise
                    backward-compatibility in specialized scenarios.
                </p><p style="color:blue;">为其指定algorithm=copy或old_alter_table=1的操作，以便在需要时强制表复制行为，以便在特定场景中实现精确的向后兼容性。</p></li></ul>
            </div>

        </div>
        <div class="section">
            <div class="titlepage">
                <div>
                    <div>
                        <h3 class="title"><a name="innodb-online-ddl-failure-conditions"></a>14.13.5&nbsp;Online DDL Failure Conditions</h3>

                    </div>

                </div>

            </div>
            <p>
                The failure of an online DDL operation is typically due to one of
                the following conditions:
            </p><p style="color:blue;">联机DDL操作失败通常是由于以下情况之一造成的：</p>
            <div class="itemizedlist">
                <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                    An <code class="literal">ALGORITHM</code> clause specifies an algorithm
                    that is not compatible with the particular type of DDL
                    operation or storage engine.
                </p><p style="color:blue;">algorithm子句指定的算法与特定类型的ddl操作或存储引擎不兼容。</p></li><li class="listitem"><p>
                    A <code class="literal">LOCK</code> clause specifies a low degree of
                    locking (<code class="literal">SHARED</code> or <code class="literal">NONE</code>)
                    that is not compatible with the particular type of DDL
                    operation.
                </p><p style="color:blue;">lock子句指定与特定类型的ddl操作不兼容的低级别锁定（shared或none）。</p></li><li class="listitem"><p>
                    A timeout occurs while waiting for an
                    <a class="link" href="glossary.html#glos_exclusive_lock" title="exclusive lock">exclusive lock</a> on
                    the table, which may be needed briefly during the initial and
                    final phases of the DDL operation.
                </p><p style="color:blue;">在等待表上的独占锁时发生超时，在DDL操作的初始和最终阶段可能会短暂需要该锁。</p></li><li class="listitem"><p>
                    The <a class="link" href="server-administration.html#sysvar_tmpdir"><code class="literal">tmpdir</code></a> or
                    <a class="link" href="innodb-storage-engine.html#sysvar_innodb_tmpdir"><code class="literal">innodb_tmpdir</code></a> file system
                    runs out of disk space, while MySQL writes temporary sort
                    files on disk during index creation. For more information, see
                    <a class="xref" href="innodb-storage-engine.html#innodb-online-ddl-space-requirements" title="14.13.3&nbsp;Online DDL Space Requirements">Section&nbsp;14.13.3, “Online DDL Space Requirements”</a>.
                </p><p style="color:blue;">tmpdir或innodb_tmpdir文件系统的磁盘空间不足，而mysql在创建索引时在磁盘上写入临时排序文件。有关更多信息，请参见第14.13.3节“联机DDL空间要求”。</p></li><li class="listitem"><p>
                    The operation takes a long time and concurrent DML modifies
                    the table so much that the size of the temporary online log
                    exceeds the value of the
                    <a class="link" href="innodb-storage-engine.html#sysvar_innodb_online_alter_log_max_size"><code class="literal">innodb_online_alter_log_max_size</code></a>
                    configuration option. This condition causes a
                    <code class="literal">DB_ONLINE_LOG_TOO_BIG</code> error.
                </p><p style="color:blue;">该操作需要很长时间，并发dml修改表的次数太多，以至于临时联机日志的大小超过了innodb_online_alter_log_max_size配置选项的值。这种情况会导致数据库联机日志出现大错误。</p></li><li class="listitem"><p>
                    Concurrent DML makes changes to the table that are allowed
                    with the original table definition, but not with the new one.
                    The operation only fails at the very end, when MySQL tries to
                    apply all the changes from concurrent DML statements. For
                    example, you might insert duplicate values into a column while
                    a unique index is being created, or you might insert
                    <code class="literal">NULL</code> values into a column while creating a
                    <a class="link" href="glossary.html#glos_primary_key" title="primary key">primary key</a> index on
                    that column. The changes made by the concurrent DML take
                    precedence, and the <a class="link" href="sql-syntax.html#alter-table" title="13.1.8&nbsp;ALTER TABLE Syntax"><code class="literal">ALTER TABLE</code></a>
                    operation is effectively <a class="link" href="glossary.html#glos_rollback" title="rollback">rolled
                    back</a>.
                </p><p style="color:blue;">并发dml对原始表定义允许的表进行更改，但对新表定义不允许。当mysql试图应用来自并发dml语句的所有更改时，该操作只在最后失败。例如，可以在创建唯一索引时向列中插入重复值，也可以在该列上创建主键索引时向列中插入空值。并发dml所做的更改优先，alter table操作被有效回滚。</p></li></ul>
            </div>

        </div>
        <div class="section">
            <div class="titlepage">
                <div>
                    <div>
                        <h3 class="title"><a name="innodb-online-ddl-limitations"></a>14.13.6&nbsp;Online DDL Limitations</h3>

                    </div>

                </div>

            </div>
            <a class="indexterm" name="idm140286816756640"></a><a class="indexterm" name="idm140286816755152"></a><a class="indexterm" name="idm140286816753664"></a><p>
            The following limitations apply to online DDL operations:
        </p><p style="color:blue;">以下限制适用于联机DDL操作：</p>
            <div class="itemizedlist">
                <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                    The table is copied when creating an index on a
                    <code class="literal">TEMPORARY TABLE</code>.
                </p><p style="color:blue;">在临时表上创建索引时复制该表。</p></li><li class="listitem"><p>
                    The <a class="link" href="sql-syntax.html#alter-table" title="13.1.8&nbsp;ALTER TABLE Syntax"><code class="literal">ALTER TABLE</code></a> clause
                    <code class="literal">LOCK=NONE</code> is not permitted if there are
                    <code class="literal">ON...CASCADE</code> or <code class="literal">ON...SET
                    NULL</code> constraints on the table.
                </p><p style="color:blue;">如果表上有on…cascade或on…set null约束，则不允许使用alter table子句lock=none。</p></li><li class="listitem"><p>
                    Before an online DDL operation can finish, it must wait for
                    transactions that hold metadata locks on the table to commit
                    or roll back. An online DDL operation may briefly require an
                    exclusive metadata lock on the table during its execution
                    phase, and always requires one in the final phase of the
                    operation when updating the table definition. Consequently,
                    transactions holding metadata locks on the table can cause an
                    online DDL operation to block. The transactions that hold
                    metadata locks on the table may have been started before or
                    during the online DDL operation. A long running or inactive
                    transaction that holds a metadata lock on the table can cause
                    an online DDL operation to timeout.
                </p><p style="color:blue;">在完成联机ddl操作之前，它必须等待持有表上元数据锁的事务提交或回滚。在线ddl操作在执行阶段可能会短暂地需要表上的独占元数据锁，并且在更新表定义时，在操作的最后阶段总是需要一个。因此，在表上保留元数据锁的事务可能会导致联机DDL操作被阻塞。在表上保留元数据锁的事务可能是在联机DDL操作之前或期间启动的。长时间运行或不活动的事务（在表上保留元数据锁）可能导致联机DDL操作超时。</p></li><li class="listitem"><p>
                    An online DDL operation on a table in a foreign key
                    relationship does not wait for a transaction executing on the
                    other table in the foreign key relationship to commit or
                    rollback. The transaction holds an exclusive metadata lock on
                    the table it is updating and shared metadata lock on the
                    foreign-key-related table (required for foreign key checking).
                    The shared metadata lock permits the online DDL operation to
                    proceed but blocks the operation in its final phase, when an
                    exclusive metadata lock is required to update the table
                    definition. This scenario can result in deadlocks as other
                    transactions wait for the online DDL operation to finish.
                </p><p style="color:blue;">外键关系表上的联机DDL操作不会等待外键关系中另一个表上执行的事务提交或回滚。事务在其正在更新的表上保留独占元数据锁，在与外键相关的表上保留共享元数据锁（外键检查需要）。共享元数据锁允许联机ddl操作继续进行，但在更新表定义时需要独占元数据锁的最后阶段阻止该操作。当其他事务等待联机ddl操作完成时，此场景可能会导致死锁。</p></li><li class="listitem"><p>
                    When running an online DDL operation, the thread that runs the
                    <a class="link" href="sql-syntax.html#alter-table" title="13.1.8&nbsp;ALTER TABLE Syntax"><code class="literal">ALTER TABLE</code></a> statement applies
                    an online log of DML operations that were run concurrently on
                    the same table from other connection threads. When the DML
                    operations are applied, it is possible to encounter a
                    duplicate key entry error (<span class="errortext">ERROR 1062 (23000):
          Duplicate entry</span>), even if the duplicate entry is
                    only temporary and would be reverted by a later entry in the
                    online log. This is similar to the idea of a foreign key
                    constraint check in <code class="literal">InnoDB</code> in which
                    constraints must hold during a transaction.
                </p><p style="color:blue;">当运行联机DDL操作时，运行alter table语句的线程将应用一个DML操作的联机日志，这些DML操作是从其他连接线程同时在同一个表上运行的。当应用dml操作时，可能会遇到重复的密钥条目错误（错误1062（23000）：重复条目），即使重复条目只是临时的，并且将由联机日志中的稍后条目还原。这类似于innodb中的外键约束检查，其中的约束必须在事务期间保持。</p></li><li class="listitem"><p>
                    <a class="link" href="sql-syntax.html#optimize-table" title="13.7.2.4&nbsp;OPTIMIZE TABLE Syntax"><code class="literal">OPTIMIZE TABLE</code></a> for an
                    <code class="literal">InnoDB</code> table is mapped to an
                    <a class="link" href="sql-syntax.html#alter-table" title="13.1.8&nbsp;ALTER TABLE Syntax"><code class="literal">ALTER TABLE</code></a> operation to
                    rebuild the table and update index statistics and free unused
                    space in the clustered index. Secondary indexes are not
                    created as efficiently because keys are inserted in the order
                    they appeared in the primary key.
                    <a class="link" href="sql-syntax.html#optimize-table" title="13.7.2.4&nbsp;OPTIMIZE TABLE Syntax"><code class="literal">OPTIMIZE TABLE</code></a> is supported
                    with the addition of online DDL support for rebuilding regular
                    and partitioned <code class="literal">InnoDB</code> tables.
                </p><p style="color:blue;">innodb表的optimize table映射到alter table操作，以重建表并更新索引统计信息，并释放聚集索引中未使用的空间。辅助索引的创建效率不高，因为键是按它们在主键中出现的顺序插入的。通过添加在线ddl支持来重建常规和分区的innodb表，从而支持优化表。</p></li><li class="listitem"><p>
                    Tables created before MySQL 5.6 that include temporal columns
                    (<a class="link" href="data-types.html#datetime" title="11.3.1&nbsp;The DATE, DATETIME, and TIMESTAMP Types"><code class="literal">DATE</code></a>,
                    <a class="link" href="data-types.html#datetime" title="11.3.1&nbsp;The DATE, DATETIME, and TIMESTAMP Types"><code class="literal">DATETIME</code></a> or
                    <a class="link" href="data-types.html#datetime" title="11.3.1&nbsp;The DATE, DATETIME, and TIMESTAMP Types"><code class="literal">TIMESTAMP</code></a>) and have not been
                    rebuilt using <code class="literal"> ALGORITHM=COPY</code> do not
                    support <code class="literal">ALGORITHM=INPLACE</code>. In this case, an
                    <a class="link" href="sql-syntax.html#alter-table" title="13.1.8&nbsp;ALTER TABLE Syntax"><code class="literal">ALTER TABLE ...
                        ALGORITHM=INPLACE</code></a> operation returns the following
                    error:
                </p><p style="color:blue;">在mysql 5.6之前创建的包含时态列（日期、日期时间或时间戳）且未使用algorithm=copy重建的表不支持algorithm=inplace。在这种情况下，一个alter表…algorithm=inplace操作返回以下错误：</p><pre data-lang="sql" class="programlisting">ERROR 1846 (0A000): ALGORITHM=INPLACE is not supported.
Reason: Cannot change column type INPLACE. Try ALGORITHM=COPY.
</pre></li><li class="listitem"><p>
                    The following limitations are generally applicable to online
                    DDL operations on large tables that involve rebuilding the
                    table:
                </p><p style="color:blue;">以下限制通常适用于涉及重建表的大型表上的联机DDL操作：</p>
                    <div class="itemizedlist">
                        <ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
                            There is no mechanism to pause an online DDL operation or
                            to throttle I/O or CPU usage for an online DDL operation.
                        </p><p style="color:blue;">没有暂停联机ddl操作或限制联机ddl操作的i/o或cpu使用的机制。</p></li><li class="listitem"><p>
                            Rollback of an online DDL operation can be expensive
                            should the operation fail.
                        </p><p style="color:blue;">如果操作失败，联机DDL操作的回滚可能会很昂贵。</p></li><li class="listitem"><p>
                            Long running online DDL operations can cause replication
                            lag. An online DDL operation must finish running on the
                            master before it is run on the slave. Also, DML that was
                            processed concurrently on the master is only processed on
                            the slave after the DDL operation on the slave is
                            completed.
                        </p><p style="color:blue;">长时间运行的联机DDL操作可能导致复制延迟。联机DDL操作必须在主机上完成运行，然后才能在从机上运行。此外，只有在从机上的ddl操作完成后，才会在从机上同时处理的dml。</p></li></ul>
                    </div>
                    <p>
                        For additional information related to running online DDL
                        operations on large tables, see
                        <a class="xref" href="innodb-storage-engine.html#innodb-online-ddl-performance" title="14.13.2&nbsp;Online DDL Performance and Concurrency">Section&nbsp;14.13.2, “Online DDL Performance and Concurrency”</a>.
                    </p><p style="color:blue;">有关在大型表上运行联机ddl操作的其他信息，请参阅14.13.2节“联机ddl性能和并发性”。</p></li></ul>
            </div>

        </div>

    </div>

    <div class="section">

        <div class="titlepage">
            <div>
                <div>
                    <h2 class="title" style="clear: both"><a name="innodb-parameters"></a>14.14&nbsp;InnoDB Startup Options and System Variables</h2>

                </div>

            </div>

        </div>
        <a class="indexterm" name="idm140286816713376"></a><a class="indexterm" name="idm140286816711952"></a>
        <div class="itemizedlist">
            <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                System variables that are true or false can be enabled at
                server startup by naming them, or disabled by using a
                <code class="literal">--skip-</code> prefix. For example, to enable or
                disable the <code class="literal">InnoDB</code> adaptive hash index, you
                can use
                <a class="link" href="innodb-storage-engine.html#sysvar_innodb_adaptive_hash_index"><code class="option">--innodb-adaptive-hash-index</code></a> or
                <a class="link" href="innodb-storage-engine.html#sysvar_innodb_adaptive_hash_index"><code class="option">--skip-innodb-adaptive-hash-index</code></a>
                on the command line, or
                <a class="link" href="innodb-storage-engine.html#sysvar_innodb_adaptive_hash_index"><code class="literal">innodb_adaptive_hash_index</code></a> or
                <code class="literal">skip_innodb_adaptive_hash_index</code> in an
                option file.
            </p><p style="color:blue;">可以通过命名在服务器启动时启用true或false的系统变量，也可以使用--skip-prefix禁用它们。例如，要启用或禁用innodb自适应哈希索引，可以在命令行中使用--innodb adaptive hash index或--skip innodb adaptive hash index，或者在选项文件中使用innodb自适应哈希索引或skip innodb自适应哈希索引。</p></li><li class="listitem"><p>
                System variables that take a numeric value can be specified as
                <code class="option">--<em class="replaceable"><code>var_name</code></em>=<em class="replaceable"><code>value</code></em></code>
                on the command line or as
                <code class="literal"><em class="replaceable"><code>var_name</code></em>=<em class="replaceable"><code>value</code></em></code>
                in option files.
            </p><p style="color:blue;">接受数值的系统变量可以在命令行上指定为--var_name=value，也可以在选项文件中指定为var_name=value。</p></li><li class="listitem"><p>
                Many system variables can be changed at runtime (see
                <a class="xref" href="server-administration.html#dynamic-system-variables" title="5.1.8.2&nbsp;Dynamic System Variables">Section&nbsp;5.1.8.2, “Dynamic System Variables”</a>).
            </p><p style="color:blue;">许多系统变量可以在运行时更改（见第5.1.8.2节“动态系统变量”）。</p></li><li class="listitem"><p>
                For information about <code class="literal">GLOBAL</code> and
                <code class="literal">SESSION</code> variable scope modifiers, refer to
                the
                <a class="link" href="sql-syntax.html#set-variable" title="13.7.4.1&nbsp;SET Syntax for Variable Assignment"><code class="literal">SET</code></a>
                statement documentation.
            </p><p style="color:blue;">有关全局和会话变量范围修饰符的信息，请参阅set语句文档。</p></li><li class="listitem"><p>
                Certain options control the locations and layout of the
                <code class="literal">InnoDB</code> data files.
                <a class="xref" href="innodb-storage-engine.html#innodb-init-startup-configuration" title="14.8.1&nbsp;InnoDB Startup Configuration">Section&nbsp;14.8.1, “InnoDB Startup Configuration”</a> explains
                how to use these options.
            </p><p style="color:blue;">某些选项控制innodb数据文件的位置和布局。第14.8.1节“InnoDB启动配置”解释了如何使用这些选项。</p></li><li class="listitem"><p>
                Some options, which you might not use initially, help tune
                <code class="literal">InnoDB</code> performance characteristics based on
                machine capacity and your database
                <a class="link" href="glossary.html#glos_workload" title="workload">workload</a>.
            </p><p style="color:blue;">一些选项（最初可能不使用）有助于根据机器容量和数据库工作负载调整innodb性能特性。</p></li><li class="listitem"><p>
                For more information on specifying options and system
                variables, see <a class="xref" href="programs.html#program-options" title="4.2.2&nbsp;Specifying Program Options">Section&nbsp;4.2.2, “Specifying Program Options”</a>.
            </p><p style="color:blue;">有关指定选项和系统变量的详细信息，请参阅第4.2.2节“指定程序选项”。</p></li></ul>
        </div>

        <div class="table">
            <a name="idm140286816688784"></a><p class="title"><b>Table&nbsp;14.19&nbsp;InnoDB Option and Variable Reference</b></p><p style="color:blue;">表14.19 InnoDB选项和变量参考</p>
            <div class="table-contents">
                <table frame="box" rules="all" summary="Reference for InnoDB command-line options and system variables."><colgroup><col width="20%"><col width="15%"><col width="15%"><col width="15%"><col width="15%"><col width="15%"><col width="15%"></colgroup><thead><tr><th scope="col">Name</th>
                    <th scope="col">Cmd-Line</th>
                    <th scope="col">Option File</th>
                    <th scope="col">System Var</th>
                    <th scope="col">Status Var</th>
                    <th scope="col">Var Scope</th>
                    <th scope="col">Dynamic</th>
                </tr></thead><tbody><tr><td scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_daemon_memcached_enable_binlog">daemon_memcached_enable_binlog</a></td>
                    <td>Yes</td>
                    <td>Yes</td>
                    <td>Yes</td>
                    <td></td>
                    <td>Global</td>
                    <td>No</td>
                </tr><tr><td scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_daemon_memcached_engine_lib_name">daemon_memcached_engine_lib_name</a></td>
                    <td>Yes</td>
                    <td>Yes</td>
                    <td>Yes</td>
                    <td></td>
                    <td>Global</td>
                    <td>No</td>
                </tr><tr><td scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_daemon_memcached_engine_lib_path">daemon_memcached_engine_lib_path</a></td>
                    <td>Yes</td>
                    <td>Yes</td>
                    <td>Yes</td>
                    <td></td>
                    <td>Global</td>
                    <td>No</td>
                </tr><tr><td scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_daemon_memcached_option">daemon_memcached_option</a></td>
                    <td>Yes</td>
                    <td>Yes</td>
                    <td>Yes</td>
                    <td></td>
                    <td>Global</td>
                    <td>No</td>
                </tr><tr><td scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_daemon_memcached_r_batch_size">daemon_memcached_r_batch_size</a></td>
                    <td>Yes</td>
                    <td>Yes</td>
                    <td>Yes</td>
                    <td></td>
                    <td>Global</td>
                    <td>No</td>
                </tr><tr><td scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_daemon_memcached_w_batch_size">daemon_memcached_w_batch_size</a></td>
                    <td>Yes</td>
                    <td>Yes</td>
                    <td>Yes</td>
                    <td></td>
                    <td>Global</td>
                    <td>No</td>
                </tr><tr><td scope="row"><a class="link" href="server-administration.html#sysvar_foreign_key_checks">foreign_key_checks</a></td>
                    <td></td>
                    <td></td>
                    <td>Yes</td>
                    <td></td>
                    <td>Both</td>
                    <td>Yes</td>
                </tr><tr><td scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_ignore_builtin_innodb">ignore_builtin_innodb</a></td>
                    <td>Yes</td>
                    <td>Yes</td>
                    <td>Yes</td>
                    <td></td>
                    <td>Global</td>
                    <td>No</td>
                </tr><tr><td scope="row"><a class="link" href="innodb-storage-engine.html#option_mysqld_innodb">innodb</a></td>
                    <td>Yes</td>
                    <td>Yes</td>
                    <td></td>
                    <td></td>
                    <td></td>
                    <td></td>
                </tr><tr><td scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_adaptive_flushing">innodb_adaptive_flushing</a></td>
                    <td>Yes</td>
                    <td>Yes</td>
                    <td>Yes</td>
                    <td></td>
                    <td>Global</td>
                    <td>Yes</td>
                </tr><tr><td scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_adaptive_flushing_lwm">innodb_adaptive_flushing_lwm</a></td>
                    <td>Yes</td>
                    <td>Yes</td>
                    <td>Yes</td>
                    <td></td>
                    <td>Global</td>
                    <td>Yes</td>
                </tr><tr><td scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_adaptive_hash_index">innodb_adaptive_hash_index</a></td>
                    <td>Yes</td>
                    <td>Yes</td>
                    <td>Yes</td>
                    <td></td>
                    <td>Global</td>
                    <td>Yes</td>
                </tr><tr><td scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_adaptive_hash_index_parts">innodb_adaptive_hash_index_parts</a></td>
                    <td>Yes</td>
                    <td>Yes</td>
                    <td>Yes</td>
                    <td></td>
                    <td>Global</td>
                    <td>No</td>
                </tr><tr><td scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_adaptive_max_sleep_delay">innodb_adaptive_max_sleep_delay</a></td>
                    <td>Yes</td>
                    <td>Yes</td>
                    <td>Yes</td>
                    <td></td>
                    <td>Global</td>
                    <td>Yes</td>
                </tr><tr><td scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_additional_mem_pool_size">innodb_additional_mem_pool_size</a></td>
                    <td>Yes</td>
                    <td>Yes</td>
                    <td>Yes</td>
                    <td></td>
                    <td>Global</td>
                    <td>No</td>
                </tr><tr><td scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_api_bk_commit_interval">innodb_api_bk_commit_interval</a></td>
                    <td>Yes</td>
                    <td>Yes</td>
                    <td>Yes</td>
                    <td></td>
                    <td>Global</td>
                    <td>Yes</td>
                </tr><tr><td scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_api_disable_rowlock">innodb_api_disable_rowlock</a></td>
                    <td>Yes</td>
                    <td>Yes</td>
                    <td>Yes</td>
                    <td></td>
                    <td>Global</td>
                    <td>No</td>
                </tr><tr><td scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_api_enable_binlog">innodb_api_enable_binlog</a></td>
                    <td>Yes</td>
                    <td>Yes</td>
                    <td>Yes</td>
                    <td></td>
                    <td>Global</td>
                    <td>No</td>
                </tr><tr><td scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_api_enable_mdl">innodb_api_enable_mdl</a></td>
                    <td>Yes</td>
                    <td>Yes</td>
                    <td>Yes</td>
                    <td></td>
                    <td>Global</td>
                    <td>No</td>
                </tr><tr><td scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_api_trx_level">innodb_api_trx_level</a></td>
                    <td>Yes</td>
                    <td>Yes</td>
                    <td>Yes</td>
                    <td></td>
                    <td>Global</td>
                    <td>Yes</td>
                </tr><tr><td scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_autoextend_increment">innodb_autoextend_increment</a></td>
                    <td>Yes</td>
                    <td>Yes</td>
                    <td>Yes</td>
                    <td></td>
                    <td>Global</td>
                    <td>Yes</td>
                </tr><tr><td scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_autoinc_lock_mode">innodb_autoinc_lock_mode</a></td>
                    <td>Yes</td>
                    <td>Yes</td>
                    <td>Yes</td>
                    <td></td>
                    <td>Global</td>
                    <td>No</td>
                </tr><tr><td scope="row"><a class="link" href="server-administration.html#statvar_Innodb_available_undo_logs">Innodb_available_undo_logs</a></td>
                    <td></td>
                    <td></td>
                    <td></td>
                    <td>Yes</td>
                    <td>Global</td>
                    <td>No</td>
                </tr><tr><td scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_background_drop_list_empty">innodb_background_drop_list_empty</a></td>
                    <td>Yes</td>
                    <td>Yes</td>
                    <td>Yes</td>
                    <td></td>
                    <td>Global</td>
                    <td>Yes</td>
                </tr><tr><td scope="row"><a class="link" href="server-administration.html#statvar_Innodb_buffer_pool_bytes_data">Innodb_buffer_pool_bytes_data</a></td>
                    <td></td>
                    <td></td>
                    <td></td>
                    <td>Yes</td>
                    <td>Global</td>
                    <td>No</td>
                </tr><tr><td scope="row"><a class="link" href="server-administration.html#statvar_Innodb_buffer_pool_bytes_dirty">Innodb_buffer_pool_bytes_dirty</a></td>
                    <td></td>
                    <td></td>
                    <td></td>
                    <td>Yes</td>
                    <td>Global</td>
                    <td>No</td>
                </tr><tr><td scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_buffer_pool_chunk_size">innodb_buffer_pool_chunk_size</a></td>
                    <td>Yes</td>
                    <td>Yes</td>
                    <td>Yes</td>
                    <td></td>
                    <td>Global</td>
                    <td>No</td>
                </tr><tr><td scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_buffer_pool_dump_at_shutdown">innodb_buffer_pool_dump_at_shutdown</a></td>
                    <td>Yes</td>
                    <td>Yes</td>
                    <td>Yes</td>
                    <td></td>
                    <td>Global</td>
                    <td>Yes</td>
                </tr><tr><td scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_buffer_pool_dump_now">innodb_buffer_pool_dump_now</a></td>
                    <td>Yes</td>
                    <td>Yes</td>
                    <td>Yes</td>
                    <td></td>
                    <td>Global</td>
                    <td>Yes</td>
                </tr><tr><td scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_buffer_pool_dump_pct">innodb_buffer_pool_dump_pct</a></td>
                    <td>Yes</td>
                    <td>Yes</td>
                    <td>Yes</td>
                    <td></td>
                    <td>Global</td>
                    <td>Yes</td>
                </tr><tr><td scope="row"><a class="link" href="server-administration.html#statvar_Innodb_buffer_pool_dump_status">Innodb_buffer_pool_dump_status</a></td>
                    <td></td>
                    <td></td>
                    <td></td>
                    <td>Yes</td>
                    <td>Global</td>
                    <td>No</td>
                </tr><tr><td scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_buffer_pool_filename">innodb_buffer_pool_filename</a></td>
                    <td>Yes</td>
                    <td>Yes</td>
                    <td>Yes</td>
                    <td></td>
                    <td>Global</td>
                    <td>Yes</td>
                </tr><tr><td scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_buffer_pool_instances">innodb_buffer_pool_instances</a></td>
                    <td>Yes</td>
                    <td>Yes</td>
                    <td>Yes</td>
                    <td></td>
                    <td>Global</td>
                    <td>No</td>
                </tr><tr><td scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_buffer_pool_load_abort">innodb_buffer_pool_load_abort</a></td>
                    <td>Yes</td>
                    <td>Yes</td>
                    <td>Yes</td>
                    <td></td>
                    <td>Global</td>
                    <td>Yes</td>
                </tr><tr><td scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_buffer_pool_load_at_startup">innodb_buffer_pool_load_at_startup</a></td>
                    <td>Yes</td>
                    <td>Yes</td>
                    <td>Yes</td>
                    <td></td>
                    <td>Global</td>
                    <td>No</td>
                </tr><tr><td scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_buffer_pool_load_now">innodb_buffer_pool_load_now</a></td>
                    <td>Yes</td>
                    <td>Yes</td>
                    <td>Yes</td>
                    <td></td>
                    <td>Global</td>
                    <td>Yes</td>
                </tr><tr><td scope="row"><a class="link" href="server-administration.html#statvar_Innodb_buffer_pool_load_status">Innodb_buffer_pool_load_status</a></td>
                    <td></td>
                    <td></td>
                    <td></td>
                    <td>Yes</td>
                    <td>Global</td>
                    <td>No</td>
                </tr><tr><td scope="row"><a class="link" href="server-administration.html#statvar_Innodb_buffer_pool_pages_data">Innodb_buffer_pool_pages_data</a></td>
                    <td></td>
                    <td></td>
                    <td></td>
                    <td>Yes</td>
                    <td>Global</td>
                    <td>No</td>
                </tr><tr><td scope="row"><a class="link" href="server-administration.html#statvar_Innodb_buffer_pool_pages_dirty">Innodb_buffer_pool_pages_dirty</a></td>
                    <td></td>
                    <td></td>
                    <td></td>
                    <td>Yes</td>
                    <td>Global</td>
                    <td>No</td>
                </tr><tr><td scope="row"><a class="link" href="server-administration.html#statvar_Innodb_buffer_pool_pages_flushed">Innodb_buffer_pool_pages_flushed</a></td>
                    <td></td>
                    <td></td>
                    <td></td>
                    <td>Yes</td>
                    <td>Global</td>
                    <td>No</td>
                </tr><tr><td scope="row"><a class="link" href="server-administration.html#statvar_Innodb_buffer_pool_pages_free">Innodb_buffer_pool_pages_free</a></td>
                    <td></td>
                    <td></td>
                    <td></td>
                    <td>Yes</td>
                    <td>Global</td>
                    <td>No</td>
                </tr><tr><td scope="row"><a class="link" href="server-administration.html#statvar_Innodb_buffer_pool_pages_latched">Innodb_buffer_pool_pages_latched</a></td>
                    <td></td>
                    <td></td>
                    <td></td>
                    <td>Yes</td>
                    <td>Global</td>
                    <td>No</td>
                </tr><tr><td scope="row"><a class="link" href="server-administration.html#statvar_Innodb_buffer_pool_pages_misc">Innodb_buffer_pool_pages_misc</a></td>
                    <td></td>
                    <td></td>
                    <td></td>
                    <td>Yes</td>
                    <td>Global</td>
                    <td>No</td>
                </tr><tr><td scope="row"><a class="link" href="server-administration.html#statvar_Innodb_buffer_pool_pages_total">Innodb_buffer_pool_pages_total</a></td>
                    <td></td>
                    <td></td>
                    <td></td>
                    <td>Yes</td>
                    <td>Global</td>
                    <td>No</td>
                </tr><tr><td scope="row"><a class="link" href="server-administration.html#statvar_Innodb_buffer_pool_read_ahead">Innodb_buffer_pool_read_ahead</a></td>
                    <td></td>
                    <td></td>
                    <td></td>
                    <td>Yes</td>
                    <td>Global</td>
                    <td>No</td>
                </tr><tr><td scope="row"><a class="link" href="server-administration.html#statvar_Innodb_buffer_pool_read_ahead_evicted">Innodb_buffer_pool_read_ahead_evicted</a></td>
                    <td></td>
                    <td></td>
                    <td></td>
                    <td>Yes</td>
                    <td>Global</td>
                    <td>No</td>
                </tr><tr><td scope="row"><a class="link" href="server-administration.html#statvar_Innodb_buffer_pool_read_ahead_rnd">Innodb_buffer_pool_read_ahead_rnd</a></td>
                    <td></td>
                    <td></td>
                    <td></td>
                    <td>Yes</td>
                    <td>Global</td>
                    <td>No</td>
                </tr><tr><td scope="row"><a class="link" href="server-administration.html#statvar_Innodb_buffer_pool_read_requests">Innodb_buffer_pool_read_requests</a></td>
                    <td></td>
                    <td></td>
                    <td></td>
                    <td>Yes</td>
                    <td>Global</td>
                    <td>No</td>
                </tr><tr><td scope="row"><a class="link" href="server-administration.html#statvar_Innodb_buffer_pool_reads">Innodb_buffer_pool_reads</a></td>
                    <td></td>
                    <td></td>
                    <td></td>
                    <td>Yes</td>
                    <td>Global</td>
                    <td>No</td>
                </tr><tr><td scope="row"><a class="link" href="server-administration.html#statvar_Innodb_buffer_pool_resize_status">Innodb_buffer_pool_resize_status</a></td>
                    <td></td>
                    <td></td>
                    <td></td>
                    <td>Yes</td>
                    <td>Global</td>
                    <td>No</td>
                </tr><tr><td scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_buffer_pool_size">innodb_buffer_pool_size</a></td>
                    <td>Yes</td>
                    <td>Yes</td>
                    <td>Yes</td>
                    <td></td>
                    <td>Global</td>
                    <td>Varies</td>
                </tr><tr><td scope="row"><a class="link" href="server-administration.html#statvar_Innodb_buffer_pool_wait_free">Innodb_buffer_pool_wait_free</a></td>
                    <td></td>
                    <td></td>
                    <td></td>
                    <td>Yes</td>
                    <td>Global</td>
                    <td>No</td>
                </tr><tr><td scope="row"><a class="link" href="server-administration.html#statvar_Innodb_buffer_pool_write_requests">Innodb_buffer_pool_write_requests</a></td>
                    <td></td>
                    <td></td>
                    <td></td>
                    <td>Yes</td>
                    <td>Global</td>
                    <td>No</td>
                </tr><tr><td scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_change_buffer_max_size">innodb_change_buffer_max_size</a></td>
                    <td>Yes</td>
                    <td>Yes</td>
                    <td>Yes</td>
                    <td></td>
                    <td>Global</td>
                    <td>Yes</td>
                </tr><tr><td scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_change_buffering">innodb_change_buffering</a></td>
                    <td>Yes</td>
                    <td>Yes</td>
                    <td>Yes</td>
                    <td></td>
                    <td>Global</td>
                    <td>Yes</td>
                </tr><tr><td scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_change_buffering_debug">innodb_change_buffering_debug</a></td>
                    <td>Yes</td>
                    <td>Yes</td>
                    <td>Yes</td>
                    <td></td>
                    <td>Global</td>
                    <td>Yes</td>
                </tr><tr><td scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_checksum_algorithm">innodb_checksum_algorithm</a></td>
                    <td>Yes</td>
                    <td>Yes</td>
                    <td>Yes</td>
                    <td></td>
                    <td>Global</td>
                    <td>Yes</td>
                </tr><tr><td scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_checksums">innodb_checksums</a></td>
                    <td>Yes</td>
                    <td>Yes</td>
                    <td>Yes</td>
                    <td></td>
                    <td>Global</td>
                    <td>No</td>
                </tr><tr><td scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_cmp_per_index_enabled">innodb_cmp_per_index_enabled</a></td>
                    <td>Yes</td>
                    <td>Yes</td>
                    <td>Yes</td>
                    <td></td>
                    <td>Global</td>
                    <td>Yes</td>
                </tr><tr><td scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_commit_concurrency">innodb_commit_concurrency</a></td>
                    <td>Yes</td>
                    <td>Yes</td>
                    <td>Yes</td>
                    <td></td>
                    <td>Global</td>
                    <td>Yes</td>
                </tr><tr><td scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_compress_debug">innodb_compress_debug</a></td>
                    <td>Yes</td>
                    <td>Yes</td>
                    <td>Yes</td>
                    <td></td>
                    <td>Global</td>
                    <td>Yes</td>
                </tr><tr><td scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_compression_failure_threshold_pct">innodb_compression_failure_threshold_pct</a></td>
                    <td>Yes</td>
                    <td>Yes</td>
                    <td>Yes</td>
                    <td></td>
                    <td>Global</td>
                    <td>Yes</td>
                </tr><tr><td scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_compression_level">innodb_compression_level</a></td>
                    <td>Yes</td>
                    <td>Yes</td>
                    <td>Yes</td>
                    <td></td>
                    <td>Global</td>
                    <td>Yes</td>
                </tr><tr><td scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_compression_pad_pct_max">innodb_compression_pad_pct_max</a></td>
                    <td>Yes</td>
                    <td>Yes</td>
                    <td>Yes</td>
                    <td></td>
                    <td>Global</td>
                    <td>Yes</td>
                </tr><tr><td scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_concurrency_tickets">innodb_concurrency_tickets</a></td>
                    <td>Yes</td>
                    <td>Yes</td>
                    <td>Yes</td>
                    <td></td>
                    <td>Global</td>
                    <td>Yes</td>
                </tr><tr><td scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_data_file_path">innodb_data_file_path</a></td>
                    <td>Yes</td>
                    <td>Yes</td>
                    <td>Yes</td>
                    <td></td>
                    <td>Global</td>
                    <td>No</td>
                </tr><tr><td scope="row"><a class="link" href="server-administration.html#statvar_Innodb_data_fsyncs">Innodb_data_fsyncs</a></td>
                    <td></td>
                    <td></td>
                    <td></td>
                    <td>Yes</td>
                    <td>Global</td>
                    <td>No</td>
                </tr><tr><td scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_data_home_dir">innodb_data_home_dir</a></td>
                    <td>Yes</td>
                    <td>Yes</td>
                    <td>Yes</td>
                    <td></td>
                    <td>Global</td>
                    <td>No</td>
                </tr><tr><td scope="row"><a class="link" href="server-administration.html#statvar_Innodb_data_pending_fsyncs">Innodb_data_pending_fsyncs</a></td>
                    <td></td>
                    <td></td>
                    <td></td>
                    <td>Yes</td>
                    <td>Global</td>
                    <td>No</td>
                </tr><tr><td scope="row"><a class="link" href="server-administration.html#statvar_Innodb_data_pending_reads">Innodb_data_pending_reads</a></td>
                    <td></td>
                    <td></td>
                    <td></td>
                    <td>Yes</td>
                    <td>Global</td>
                    <td>No</td>
                </tr><tr><td scope="row"><a class="link" href="server-administration.html#statvar_Innodb_data_pending_writes">Innodb_data_pending_writes</a></td>
                    <td></td>
                    <td></td>
                    <td></td>
                    <td>Yes</td>
                    <td>Global</td>
                    <td>No</td>
                </tr><tr><td scope="row"><a class="link" href="server-administration.html#statvar_Innodb_data_read">Innodb_data_read</a></td>
                    <td></td>
                    <td></td>
                    <td></td>
                    <td>Yes</td>
                    <td>Global</td>
                    <td>No</td>
                </tr><tr><td scope="row"><a class="link" href="server-administration.html#statvar_Innodb_data_reads">Innodb_data_reads</a></td>
                    <td></td>
                    <td></td>
                    <td></td>
                    <td>Yes</td>
                    <td>Global</td>
                    <td>No</td>
                </tr><tr><td scope="row"><a class="link" href="server-administration.html#statvar_Innodb_data_writes">Innodb_data_writes</a></td>
                    <td></td>
                    <td></td>
                    <td></td>
                    <td>Yes</td>
                    <td>Global</td>
                    <td>No</td>
                </tr><tr><td scope="row"><a class="link" href="server-administration.html#statvar_Innodb_data_written">Innodb_data_written</a></td>
                    <td></td>
                    <td></td>
                    <td></td>
                    <td>Yes</td>
                    <td>Global</td>
                    <td>No</td>
                </tr><tr><td scope="row"><a class="link" href="server-administration.html#statvar_Innodb_dblwr_pages_written">Innodb_dblwr_pages_written</a></td>
                    <td></td>
                    <td></td>
                    <td></td>
                    <td>Yes</td>
                    <td>Global</td>
                    <td>No</td>
                </tr><tr><td scope="row"><a class="link" href="server-administration.html#statvar_Innodb_dblwr_writes">Innodb_dblwr_writes</a></td>
                    <td></td>
                    <td></td>
                    <td></td>
                    <td>Yes</td>
                    <td>Global</td>
                    <td>No</td>
                </tr><tr><td scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_deadlock_detect">innodb_deadlock_detect</a></td>
                    <td>Yes</td>
                    <td>Yes</td>
                    <td>Yes</td>
                    <td></td>
                    <td>Global</td>
                    <td>Yes</td>
                </tr><tr><td scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_default_row_format">innodb_default_row_format</a></td>
                    <td>Yes</td>
                    <td>Yes</td>
                    <td>Yes</td>
                    <td></td>
                    <td>Global</td>
                    <td>Yes</td>
                </tr><tr><td scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_disable_resize_buffer_pool_debug">innodb_disable_resize_buffer_pool_debug</a></td>
                    <td>Yes</td>
                    <td>Yes</td>
                    <td>Yes</td>
                    <td></td>
                    <td>Global</td>
                    <td>Yes</td>
                </tr><tr><td scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_disable_sort_file_cache">innodb_disable_sort_file_cache</a></td>
                    <td>Yes</td>
                    <td>Yes</td>
                    <td>Yes</td>
                    <td></td>
                    <td>Global</td>
                    <td>Yes</td>
                </tr><tr><td scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_doublewrite">innodb_doublewrite</a></td>
                    <td>Yes</td>
                    <td>Yes</td>
                    <td>Yes</td>
                    <td></td>
                    <td>Global</td>
                    <td>No</td>
                </tr><tr><td scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_fast_shutdown">innodb_fast_shutdown</a></td>
                    <td>Yes</td>
                    <td>Yes</td>
                    <td>Yes</td>
                    <td></td>
                    <td>Global</td>
                    <td>Yes</td>
                </tr><tr><td scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_fil_make_page_dirty_debug">innodb_fil_make_page_dirty_debug</a></td>
                    <td>Yes</td>
                    <td>Yes</td>
                    <td>Yes</td>
                    <td></td>
                    <td>Global</td>
                    <td>Yes</td>
                </tr><tr><td scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_file_format">innodb_file_format</a></td>
                    <td>Yes</td>
                    <td>Yes</td>
                    <td>Yes</td>
                    <td></td>
                    <td>Global</td>
                    <td>Yes</td>
                </tr><tr><td scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_file_format_check">innodb_file_format_check</a></td>
                    <td>Yes</td>
                    <td>Yes</td>
                    <td>Yes</td>
                    <td></td>
                    <td>Global</td>
                    <td>No</td>
                </tr><tr><td scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_file_format_max">innodb_file_format_max</a></td>
                    <td>Yes</td>
                    <td>Yes</td>
                    <td>Yes</td>
                    <td></td>
                    <td>Global</td>
                    <td>Yes</td>
                </tr><tr><td scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_file_per_table">innodb_file_per_table</a></td>
                    <td>Yes</td>
                    <td>Yes</td>
                    <td>Yes</td>
                    <td></td>
                    <td>Global</td>
                    <td>Yes</td>
                </tr><tr><td scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_fill_factor">innodb_fill_factor</a></td>
                    <td>Yes</td>
                    <td>Yes</td>
                    <td>Yes</td>
                    <td></td>
                    <td>Global</td>
                    <td>Yes</td>
                </tr><tr><td scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_flush_log_at_timeout">innodb_flush_log_at_timeout</a></td>
                    <td>Yes</td>
                    <td>Yes</td>
                    <td>Yes</td>
                    <td></td>
                    <td>Global</td>
                    <td>Yes</td>
                </tr><tr><td scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_flush_log_at_trx_commit">innodb_flush_log_at_trx_commit</a></td>
                    <td>Yes</td>
                    <td>Yes</td>
                    <td>Yes</td>
                    <td></td>
                    <td>Global</td>
                    <td>Yes</td>
                </tr><tr><td scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_flush_method">innodb_flush_method</a></td>
                    <td>Yes</td>
                    <td>Yes</td>
                    <td>Yes</td>
                    <td></td>
                    <td>Global</td>
                    <td>No</td>
                </tr><tr><td scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_flush_neighbors">innodb_flush_neighbors</a></td>
                    <td>Yes</td>
                    <td>Yes</td>
                    <td>Yes</td>
                    <td></td>
                    <td>Global</td>
                    <td>Yes</td>
                </tr><tr><td scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_flush_sync">innodb_flush_sync</a></td>
                    <td>Yes</td>
                    <td>Yes</td>
                    <td>Yes</td>
                    <td></td>
                    <td>Global</td>
                    <td>Yes</td>
                </tr><tr><td scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_flushing_avg_loops">innodb_flushing_avg_loops</a></td>
                    <td>Yes</td>
                    <td>Yes</td>
                    <td>Yes</td>
                    <td></td>
                    <td>Global</td>
                    <td>Yes</td>
                </tr><tr><td scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_force_load_corrupted">innodb_force_load_corrupted</a></td>
                    <td>Yes</td>
                    <td>Yes</td>
                    <td>Yes</td>
                    <td></td>
                    <td>Global</td>
                    <td>No</td>
                </tr><tr><td scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_force_recovery">innodb_force_recovery</a></td>
                    <td>Yes</td>
                    <td>Yes</td>
                    <td>Yes</td>
                    <td></td>
                    <td>Global</td>
                    <td>No</td>
                </tr><tr><td scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_ft_aux_table">innodb_ft_aux_table</a></td>
                    <td></td>
                    <td></td>
                    <td>Yes</td>
                    <td></td>
                    <td>Global</td>
                    <td>Yes</td>
                </tr><tr><td scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_ft_cache_size">innodb_ft_cache_size</a></td>
                    <td>Yes</td>
                    <td>Yes</td>
                    <td>Yes</td>
                    <td></td>
                    <td>Global</td>
                    <td>No</td>
                </tr><tr><td scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_ft_enable_diag_print">innodb_ft_enable_diag_print</a></td>
                    <td>Yes</td>
                    <td>Yes</td>
                    <td>Yes</td>
                    <td></td>
                    <td>Global</td>
                    <td>Yes</td>
                </tr><tr><td scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_ft_enable_stopword">innodb_ft_enable_stopword</a></td>
                    <td>Yes</td>
                    <td>Yes</td>
                    <td>Yes</td>
                    <td></td>
                    <td>Both</td>
                    <td>Yes</td>
                </tr><tr><td scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_ft_max_token_size">innodb_ft_max_token_size</a></td>
                    <td>Yes</td>
                    <td>Yes</td>
                    <td>Yes</td>
                    <td></td>
                    <td>Global</td>
                    <td>No</td>
                </tr><tr><td scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_ft_min_token_size">innodb_ft_min_token_size</a></td>
                    <td>Yes</td>
                    <td>Yes</td>
                    <td>Yes</td>
                    <td></td>
                    <td>Global</td>
                    <td>No</td>
                </tr><tr><td scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_ft_num_word_optimize">innodb_ft_num_word_optimize</a></td>
                    <td>Yes</td>
                    <td>Yes</td>
                    <td>Yes</td>
                    <td></td>
                    <td>Global</td>
                    <td>Yes</td>
                </tr><tr><td scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_ft_result_cache_limit">innodb_ft_result_cache_limit</a></td>
                    <td>Yes</td>
                    <td>Yes</td>
                    <td>Yes</td>
                    <td></td>
                    <td>Global</td>
                    <td>Yes</td>
                </tr><tr><td scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_ft_server_stopword_table">innodb_ft_server_stopword_table</a></td>
                    <td>Yes</td>
                    <td>Yes</td>
                    <td>Yes</td>
                    <td></td>
                    <td>Global</td>
                    <td>Yes</td>
                </tr><tr><td scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_ft_sort_pll_degree">innodb_ft_sort_pll_degree</a></td>
                    <td>Yes</td>
                    <td>Yes</td>
                    <td>Yes</td>
                    <td></td>
                    <td>Global</td>
                    <td>No</td>
                </tr><tr><td scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_ft_total_cache_size">innodb_ft_total_cache_size</a></td>
                    <td>Yes</td>
                    <td>Yes</td>
                    <td>Yes</td>
                    <td></td>
                    <td>Global</td>
                    <td>No</td>
                </tr><tr><td scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_ft_user_stopword_table">innodb_ft_user_stopword_table</a></td>
                    <td>Yes</td>
                    <td>Yes</td>
                    <td>Yes</td>
                    <td></td>
                    <td>Both</td>
                    <td>Yes</td>
                </tr><tr><td scope="row"><a class="link" href="server-administration.html#statvar_Innodb_have_atomic_builtins">Innodb_have_atomic_builtins</a></td>
                    <td></td>
                    <td></td>
                    <td></td>
                    <td>Yes</td>
                    <td>Global</td>
                    <td>No</td>
                </tr><tr><td scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_io_capacity">innodb_io_capacity</a></td>
                    <td>Yes</td>
                    <td>Yes</td>
                    <td>Yes</td>
                    <td></td>
                    <td>Global</td>
                    <td>Yes</td>
                </tr><tr><td scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_io_capacity_max">innodb_io_capacity_max</a></td>
                    <td>Yes</td>
                    <td>Yes</td>
                    <td>Yes</td>
                    <td></td>
                    <td>Global</td>
                    <td>Yes</td>
                </tr><tr><td scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_large_prefix">innodb_large_prefix</a></td>
                    <td>Yes</td>
                    <td>Yes</td>
                    <td>Yes</td>
                    <td></td>
                    <td>Global</td>
                    <td>Yes</td>
                </tr><tr><td scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_limit_optimistic_insert_debug">innodb_limit_optimistic_insert_debug</a></td>
                    <td>Yes</td>
                    <td>Yes</td>
                    <td>Yes</td>
                    <td></td>
                    <td>Global</td>
                    <td>Yes</td>
                </tr><tr><td scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_lock_wait_timeout">innodb_lock_wait_timeout</a></td>
                    <td>Yes</td>
                    <td>Yes</td>
                    <td>Yes</td>
                    <td></td>
                    <td>Both</td>
                    <td>Yes</td>
                </tr><tr><td scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_locks_unsafe_for_binlog">innodb_locks_unsafe_for_binlog</a></td>
                    <td>Yes</td>
                    <td>Yes</td>
                    <td>Yes</td>
                    <td></td>
                    <td>Global</td>
                    <td>No</td>
                </tr><tr><td scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_log_buffer_size">innodb_log_buffer_size</a></td>
                    <td>Yes</td>
                    <td>Yes</td>
                    <td>Yes</td>
                    <td></td>
                    <td>Global</td>
                    <td>No</td>
                </tr><tr><td scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_log_checkpoint_now">innodb_log_checkpoint_now</a></td>
                    <td>Yes</td>
                    <td>Yes</td>
                    <td>Yes</td>
                    <td></td>
                    <td>Global</td>
                    <td>Yes</td>
                </tr><tr><td scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_log_checksum_algorithm">innodb_log_checksum_algorithm</a></td>
                    <td>Yes</td>
                    <td>Yes</td>
                    <td>Yes</td>
                    <td></td>
                    <td>Global</td>
                    <td>Yes</td>
                </tr><tr><td scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_log_checksums">innodb_log_checksums</a></td>
                    <td>Yes</td>
                    <td>Yes</td>
                    <td>Yes</td>
                    <td></td>
                    <td>Global</td>
                    <td>Yes</td>
                </tr><tr><td scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_log_compressed_pages">innodb_log_compressed_pages</a></td>
                    <td>Yes</td>
                    <td>Yes</td>
                    <td>Yes</td>
                    <td></td>
                    <td>Global</td>
                    <td>Yes</td>
                </tr><tr><td scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_log_file_size">innodb_log_file_size</a></td>
                    <td>Yes</td>
                    <td>Yes</td>
                    <td>Yes</td>
                    <td></td>
                    <td>Global</td>
                    <td>No</td>
                </tr><tr><td scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_log_files_in_group">innodb_log_files_in_group</a></td>
                    <td>Yes</td>
                    <td>Yes</td>
                    <td>Yes</td>
                    <td></td>
                    <td>Global</td>
                    <td>No</td>
                </tr><tr><td scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_log_group_home_dir">innodb_log_group_home_dir</a></td>
                    <td>Yes</td>
                    <td>Yes</td>
                    <td>Yes</td>
                    <td></td>
                    <td>Global</td>
                    <td>No</td>
                </tr><tr><td scope="row"><a class="link" href="server-administration.html#statvar_Innodb_log_waits">Innodb_log_waits</a></td>
                    <td></td>
                    <td></td>
                    <td></td>
                    <td>Yes</td>
                    <td>Global</td>
                    <td>No</td>
                </tr><tr><td scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_log_write_ahead_size">innodb_log_write_ahead_size</a></td>
                    <td>Yes</td>
                    <td>Yes</td>
                    <td>Yes</td>
                    <td></td>
                    <td>Global</td>
                    <td>Yes</td>
                </tr><tr><td scope="row"><a class="link" href="server-administration.html#statvar_Innodb_log_write_requests">Innodb_log_write_requests</a></td>
                    <td></td>
                    <td></td>
                    <td></td>
                    <td>Yes</td>
                    <td>Global</td>
                    <td>No</td>
                </tr><tr><td scope="row"><a class="link" href="server-administration.html#statvar_Innodb_log_writes">Innodb_log_writes</a></td>
                    <td></td>
                    <td></td>
                    <td></td>
                    <td>Yes</td>
                    <td>Global</td>
                    <td>No</td>
                </tr><tr><td scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_lru_scan_depth">innodb_lru_scan_depth</a></td>
                    <td>Yes</td>
                    <td>Yes</td>
                    <td>Yes</td>
                    <td></td>
                    <td>Global</td>
                    <td>Yes</td>
                </tr><tr><td scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_max_dirty_pages_pct">innodb_max_dirty_pages_pct</a></td>
                    <td>Yes</td>
                    <td>Yes</td>
                    <td>Yes</td>
                    <td></td>
                    <td>Global</td>
                    <td>Yes</td>
                </tr><tr><td scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_max_dirty_pages_pct_lwm">innodb_max_dirty_pages_pct_lwm</a></td>
                    <td>Yes</td>
                    <td>Yes</td>
                    <td>Yes</td>
                    <td></td>
                    <td>Global</td>
                    <td>Yes</td>
                </tr><tr><td scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_max_purge_lag">innodb_max_purge_lag</a></td>
                    <td>Yes</td>
                    <td>Yes</td>
                    <td>Yes</td>
                    <td></td>
                    <td>Global</td>
                    <td>Yes</td>
                </tr><tr><td scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_max_purge_lag_delay">innodb_max_purge_lag_delay</a></td>
                    <td>Yes</td>
                    <td>Yes</td>
                    <td>Yes</td>
                    <td></td>
                    <td>Global</td>
                    <td>Yes</td>
                </tr><tr><td scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_max_undo_log_size">innodb_max_undo_log_size</a></td>
                    <td>Yes</td>
                    <td>Yes</td>
                    <td>Yes</td>
                    <td></td>
                    <td>Global</td>
                    <td>Yes</td>
                </tr><tr><td scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_merge_threshold_set_all_debug">innodb_merge_threshold_set_all_debug</a></td>
                    <td>Yes</td>
                    <td>Yes</td>
                    <td>Yes</td>
                    <td></td>
                    <td>Global</td>
                    <td>Yes</td>
                </tr><tr><td scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_monitor_disable">innodb_monitor_disable</a></td>
                    <td>Yes</td>
                    <td>Yes</td>
                    <td>Yes</td>
                    <td></td>
                    <td>Global</td>
                    <td>Yes</td>
                </tr><tr><td scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_monitor_enable">innodb_monitor_enable</a></td>
                    <td>Yes</td>
                    <td>Yes</td>
                    <td>Yes</td>
                    <td></td>
                    <td>Global</td>
                    <td>Yes</td>
                </tr><tr><td scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_monitor_reset">innodb_monitor_reset</a></td>
                    <td>Yes</td>
                    <td>Yes</td>
                    <td>Yes</td>
                    <td></td>
                    <td>Global</td>
                    <td>Yes</td>
                </tr><tr><td scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_monitor_reset_all">innodb_monitor_reset_all</a></td>
                    <td>Yes</td>
                    <td>Yes</td>
                    <td>Yes</td>
                    <td></td>
                    <td>Global</td>
                    <td>Yes</td>
                </tr><tr><td scope="row"><a class="link" href="server-administration.html#statvar_Innodb_num_open_files">Innodb_num_open_files</a></td>
                    <td></td>
                    <td></td>
                    <td></td>
                    <td>Yes</td>
                    <td>Global</td>
                    <td>No</td>
                </tr><tr><td scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_numa_interleave">innodb_numa_interleave</a></td>
                    <td>Yes</td>
                    <td>Yes</td>
                    <td>Yes</td>
                    <td></td>
                    <td>Global</td>
                    <td>No</td>
                </tr><tr><td scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_old_blocks_pct">innodb_old_blocks_pct</a></td>
                    <td>Yes</td>
                    <td>Yes</td>
                    <td>Yes</td>
                    <td></td>
                    <td>Global</td>
                    <td>Yes</td>
                </tr><tr><td scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_old_blocks_time">innodb_old_blocks_time</a></td>
                    <td>Yes</td>
                    <td>Yes</td>
                    <td>Yes</td>
                    <td></td>
                    <td>Global</td>
                    <td>Yes</td>
                </tr><tr><td scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_online_alter_log_max_size">innodb_online_alter_log_max_size</a></td>
                    <td>Yes</td>
                    <td>Yes</td>
                    <td>Yes</td>
                    <td></td>
                    <td>Global</td>
                    <td>Yes</td>
                </tr><tr><td scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_open_files">innodb_open_files</a></td>
                    <td>Yes</td>
                    <td>Yes</td>
                    <td>Yes</td>
                    <td></td>
                    <td>Global</td>
                    <td>No</td>
                </tr><tr><td scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_optimize_fulltext_only">innodb_optimize_fulltext_only</a></td>
                    <td>Yes</td>
                    <td>Yes</td>
                    <td>Yes</td>
                    <td></td>
                    <td>Global</td>
                    <td>Yes</td>
                </tr><tr><td scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_optimize_point_storage">innodb_optimize_point_storage</a></td>
                    <td>Yes</td>
                    <td>Yes</td>
                    <td>Yes</td>
                    <td></td>
                    <td>Session</td>
                    <td>Yes</td>
                </tr><tr><td scope="row"><a class="link" href="server-administration.html#statvar_Innodb_os_log_fsyncs">Innodb_os_log_fsyncs</a></td>
                    <td></td>
                    <td></td>
                    <td></td>
                    <td>Yes</td>
                    <td>Global</td>
                    <td>No</td>
                </tr><tr><td scope="row"><a class="link" href="server-administration.html#statvar_Innodb_os_log_pending_fsyncs">Innodb_os_log_pending_fsyncs</a></td>
                    <td></td>
                    <td></td>
                    <td></td>
                    <td>Yes</td>
                    <td>Global</td>
                    <td>No</td>
                </tr><tr><td scope="row"><a class="link" href="server-administration.html#statvar_Innodb_os_log_pending_writes">Innodb_os_log_pending_writes</a></td>
                    <td></td>
                    <td></td>
                    <td></td>
                    <td>Yes</td>
                    <td>Global</td>
                    <td>No</td>
                </tr><tr><td scope="row"><a class="link" href="server-administration.html#statvar_Innodb_os_log_written">Innodb_os_log_written</a></td>
                    <td></td>
                    <td></td>
                    <td></td>
                    <td>Yes</td>
                    <td>Global</td>
                    <td>No</td>
                </tr><tr><td scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_page_cleaners">innodb_page_cleaners</a></td>
                    <td>Yes</td>
                    <td>Yes</td>
                    <td>Yes</td>
                    <td></td>
                    <td>Global</td>
                    <td>No</td>
                </tr><tr><td scope="row"><a class="link" href="server-administration.html#statvar_Innodb_page_size">Innodb_page_size</a></td>
                    <td></td>
                    <td></td>
                    <td></td>
                    <td>Yes</td>
                    <td>Global</td>
                    <td>No</td>
                </tr><tr><td scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_page_size">innodb_page_size</a></td>
                    <td>Yes</td>
                    <td>Yes</td>
                    <td>Yes</td>
                    <td></td>
                    <td>Global</td>
                    <td>No</td>
                </tr><tr><td scope="row"><a class="link" href="server-administration.html#statvar_Innodb_pages_created">Innodb_pages_created</a></td>
                    <td></td>
                    <td></td>
                    <td></td>
                    <td>Yes</td>
                    <td>Global</td>
                    <td>No</td>
                </tr><tr><td scope="row"><a class="link" href="server-administration.html#statvar_Innodb_pages_read">Innodb_pages_read</a></td>
                    <td></td>
                    <td></td>
                    <td></td>
                    <td>Yes</td>
                    <td>Global</td>
                    <td>No</td>
                </tr><tr><td scope="row"><a class="link" href="server-administration.html#statvar_Innodb_pages_written">Innodb_pages_written</a></td>
                    <td></td>
                    <td></td>
                    <td></td>
                    <td>Yes</td>
                    <td>Global</td>
                    <td>No</td>
                </tr><tr><td scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_print_all_deadlocks">innodb_print_all_deadlocks</a></td>
                    <td>Yes</td>
                    <td>Yes</td>
                    <td>Yes</td>
                    <td></td>
                    <td>Global</td>
                    <td>Yes</td>
                </tr><tr><td scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_purge_batch_size">innodb_purge_batch_size</a></td>
                    <td>Yes</td>
                    <td>Yes</td>
                    <td>Yes</td>
                    <td></td>
                    <td>Global</td>
                    <td>Yes</td>
                </tr><tr><td scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_purge_rseg_truncate_frequency">innodb_purge_rseg_truncate_frequency</a></td>
                    <td>Yes</td>
                    <td>Yes</td>
                    <td>Yes</td>
                    <td></td>
                    <td>Global</td>
                    <td>Yes</td>
                </tr><tr><td scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_purge_threads">innodb_purge_threads</a></td>
                    <td>Yes</td>
                    <td>Yes</td>
                    <td>Yes</td>
                    <td></td>
                    <td>Global</td>
                    <td>No</td>
                </tr><tr><td scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_random_read_ahead">innodb_random_read_ahead</a></td>
                    <td>Yes</td>
                    <td>Yes</td>
                    <td>Yes</td>
                    <td></td>
                    <td>Global</td>
                    <td>Yes</td>
                </tr><tr><td scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_read_ahead_threshold">innodb_read_ahead_threshold</a></td>
                    <td>Yes</td>
                    <td>Yes</td>
                    <td>Yes</td>
                    <td></td>
                    <td>Global</td>
                    <td>Yes</td>
                </tr><tr><td scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_read_io_threads">innodb_read_io_threads</a></td>
                    <td>Yes</td>
                    <td>Yes</td>
                    <td>Yes</td>
                    <td></td>
                    <td>Global</td>
                    <td>No</td>
                </tr><tr><td scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_read_only">innodb_read_only</a></td>
                    <td>Yes</td>
                    <td>Yes</td>
                    <td>Yes</td>
                    <td></td>
                    <td>Global</td>
                    <td>No</td>
                </tr><tr><td scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_replication_delay">innodb_replication_delay</a></td>
                    <td>Yes</td>
                    <td>Yes</td>
                    <td>Yes</td>
                    <td></td>
                    <td>Global</td>
                    <td>Yes</td>
                </tr><tr><td scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_rollback_on_timeout">innodb_rollback_on_timeout</a></td>
                    <td>Yes</td>
                    <td>Yes</td>
                    <td>Yes</td>
                    <td></td>
                    <td>Global</td>
                    <td>No</td>
                </tr><tr><td scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_rollback_segments">innodb_rollback_segments</a></td>
                    <td>Yes</td>
                    <td>Yes</td>
                    <td>Yes</td>
                    <td></td>
                    <td>Global</td>
                    <td>Yes</td>
                </tr><tr><td scope="row"><a class="link" href="server-administration.html#statvar_Innodb_row_lock_current_waits">Innodb_row_lock_current_waits</a></td>
                    <td></td>
                    <td></td>
                    <td></td>
                    <td>Yes</td>
                    <td>Global</td>
                    <td>No</td>
                </tr><tr><td scope="row"><a class="link" href="server-administration.html#statvar_Innodb_row_lock_time">Innodb_row_lock_time</a></td>
                    <td></td>
                    <td></td>
                    <td></td>
                    <td>Yes</td>
                    <td>Global</td>
                    <td>No</td>
                </tr><tr><td scope="row"><a class="link" href="server-administration.html#statvar_Innodb_row_lock_time_avg">Innodb_row_lock_time_avg</a></td>
                    <td></td>
                    <td></td>
                    <td></td>
                    <td>Yes</td>
                    <td>Global</td>
                    <td>No</td>
                </tr><tr><td scope="row"><a class="link" href="server-administration.html#statvar_Innodb_row_lock_time_max">Innodb_row_lock_time_max</a></td>
                    <td></td>
                    <td></td>
                    <td></td>
                    <td>Yes</td>
                    <td>Global</td>
                    <td>No</td>
                </tr><tr><td scope="row"><a class="link" href="server-administration.html#statvar_Innodb_row_lock_waits">Innodb_row_lock_waits</a></td>
                    <td></td>
                    <td></td>
                    <td></td>
                    <td>Yes</td>
                    <td>Global</td>
                    <td>No</td>
                </tr><tr><td scope="row"><a class="link" href="server-administration.html#statvar_Innodb_rows_deleted">Innodb_rows_deleted</a></td>
                    <td></td>
                    <td></td>
                    <td></td>
                    <td>Yes</td>
                    <td>Global</td>
                    <td>No</td>
                </tr><tr><td scope="row"><a class="link" href="server-administration.html#statvar_Innodb_rows_inserted">Innodb_rows_inserted</a></td>
                    <td></td>
                    <td></td>
                    <td></td>
                    <td>Yes</td>
                    <td>Global</td>
                    <td>No</td>
                </tr><tr><td scope="row"><a class="link" href="server-administration.html#statvar_Innodb_rows_read">Innodb_rows_read</a></td>
                    <td></td>
                    <td></td>
                    <td></td>
                    <td>Yes</td>
                    <td>Global</td>
                    <td>No</td>
                </tr><tr><td scope="row"><a class="link" href="server-administration.html#statvar_Innodb_rows_updated">Innodb_rows_updated</a></td>
                    <td></td>
                    <td></td>
                    <td></td>
                    <td>Yes</td>
                    <td>Global</td>
                    <td>No</td>
                </tr><tr><td scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_saved_page_number_debug">innodb_saved_page_number_debug</a></td>
                    <td>Yes</td>
                    <td>Yes</td>
                    <td>Yes</td>
                    <td></td>
                    <td>Global</td>
                    <td>Yes</td>
                </tr><tr><td scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_sort_buffer_size">innodb_sort_buffer_size</a></td>
                    <td>Yes</td>
                    <td>Yes</td>
                    <td>Yes</td>
                    <td></td>
                    <td>Global</td>
                    <td>No</td>
                </tr><tr><td scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_spin_wait_delay">innodb_spin_wait_delay</a></td>
                    <td>Yes</td>
                    <td>Yes</td>
                    <td>Yes</td>
                    <td></td>
                    <td>Global</td>
                    <td>Yes</td>
                </tr><tr><td scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_stats_auto_recalc">innodb_stats_auto_recalc</a></td>
                    <td>Yes</td>
                    <td>Yes</td>
                    <td>Yes</td>
                    <td></td>
                    <td>Global</td>
                    <td>Yes</td>
                </tr><tr><td scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_stats_include_delete_marked">innodb_stats_include_delete_marked</a></td>
                    <td>Yes</td>
                    <td>Yes</td>
                    <td>Yes</td>
                    <td></td>
                    <td>Global</td>
                    <td>Yes</td>
                </tr><tr><td scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_stats_method">innodb_stats_method</a></td>
                    <td>Yes</td>
                    <td>Yes</td>
                    <td>Yes</td>
                    <td></td>
                    <td>Global</td>
                    <td>Yes</td>
                </tr><tr><td scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_stats_on_metadata">innodb_stats_on_metadata</a></td>
                    <td>Yes</td>
                    <td>Yes</td>
                    <td>Yes</td>
                    <td></td>
                    <td>Global</td>
                    <td>Yes</td>
                </tr><tr><td scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_stats_persistent">innodb_stats_persistent</a></td>
                    <td>Yes</td>
                    <td>Yes</td>
                    <td>Yes</td>
                    <td></td>
                    <td>Global</td>
                    <td>Yes</td>
                </tr><tr><td scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_stats_persistent_sample_pages">innodb_stats_persistent_sample_pages</a></td>
                    <td>Yes</td>
                    <td>Yes</td>
                    <td>Yes</td>
                    <td></td>
                    <td>Global</td>
                    <td>Yes</td>
                </tr><tr><td scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_stats_sample_pages">innodb_stats_sample_pages</a></td>
                    <td>Yes</td>
                    <td>Yes</td>
                    <td>Yes</td>
                    <td></td>
                    <td>Global</td>
                    <td>Yes</td>
                </tr><tr><td scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_stats_transient_sample_pages">innodb_stats_transient_sample_pages</a></td>
                    <td>Yes</td>
                    <td>Yes</td>
                    <td>Yes</td>
                    <td></td>
                    <td>Global</td>
                    <td>Yes</td>
                </tr><tr><td scope="row"><a class="link" href="innodb-storage-engine.html#option_mysqld_innodb-status-file">innodb-status-file</a></td>
                    <td>Yes</td>
                    <td>Yes</td>
                    <td></td>
                    <td></td>
                    <td></td>
                    <td></td>
                </tr><tr><td scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_status_output">innodb_status_output</a></td>
                    <td>Yes</td>
                    <td>Yes</td>
                    <td>Yes</td>
                    <td></td>
                    <td>Global</td>
                    <td>Yes</td>
                </tr><tr><td scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_status_output_locks">innodb_status_output_locks</a></td>
                    <td>Yes</td>
                    <td>Yes</td>
                    <td>Yes</td>
                    <td></td>
                    <td>Global</td>
                    <td>Yes</td>
                </tr><tr><td scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_strict_mode">innodb_strict_mode</a></td>
                    <td>Yes</td>
                    <td>Yes</td>
                    <td>Yes</td>
                    <td></td>
                    <td>Both</td>
                    <td>Yes</td>
                </tr><tr><td scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_support_xa">innodb_support_xa</a></td>
                    <td>Yes</td>
                    <td>Yes</td>
                    <td>Yes</td>
                    <td></td>
                    <td>Both</td>
                    <td>Yes</td>
                </tr><tr><td scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_sync_array_size">innodb_sync_array_size</a></td>
                    <td>Yes</td>
                    <td>Yes</td>
                    <td>Yes</td>
                    <td></td>
                    <td>Global</td>
                    <td>No</td>
                </tr><tr><td scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_sync_debug">innodb_sync_debug</a></td>
                    <td>Yes</td>
                    <td>Yes</td>
                    <td>Yes</td>
                    <td></td>
                    <td>Global</td>
                    <td>No</td>
                </tr><tr><td scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_sync_spin_loops">innodb_sync_spin_loops</a></td>
                    <td>Yes</td>
                    <td>Yes</td>
                    <td>Yes</td>
                    <td></td>
                    <td>Global</td>
                    <td>Yes</td>
                </tr><tr><td scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_table_locks">innodb_table_locks</a></td>
                    <td>Yes</td>
                    <td>Yes</td>
                    <td>Yes</td>
                    <td></td>
                    <td>Both</td>
                    <td>Yes</td>
                </tr><tr><td scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_temp_data_file_path">innodb_temp_data_file_path</a></td>
                    <td>Yes</td>
                    <td>Yes</td>
                    <td>Yes</td>
                    <td></td>
                    <td>Global</td>
                    <td>No</td>
                </tr><tr><td scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_thread_concurrency">innodb_thread_concurrency</a></td>
                    <td>Yes</td>
                    <td>Yes</td>
                    <td>Yes</td>
                    <td></td>
                    <td>Global</td>
                    <td>Yes</td>
                </tr><tr><td scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_thread_sleep_delay">innodb_thread_sleep_delay</a></td>
                    <td>Yes</td>
                    <td>Yes</td>
                    <td>Yes</td>
                    <td></td>
                    <td>Global</td>
                    <td>Yes</td>
                </tr><tr><td scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_tmpdir">innodb_tmpdir</a></td>
                    <td>Yes</td>
                    <td>Yes</td>
                    <td>Yes</td>
                    <td></td>
                    <td>Both</td>
                    <td>Yes</td>
                </tr><tr><td scope="row"><a class="link" href="server-administration.html#statvar_Innodb_truncated_status_writes">Innodb_truncated_status_writes</a></td>
                    <td></td>
                    <td></td>
                    <td></td>
                    <td>Yes</td>
                    <td>Global</td>
                    <td>No</td>
                </tr><tr><td scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_trx_purge_view_update_only_debug">innodb_trx_purge_view_update_only_debug</a></td>
                    <td>Yes</td>
                    <td>Yes</td>
                    <td>Yes</td>
                    <td></td>
                    <td>Global</td>
                    <td>Yes</td>
                </tr><tr><td scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_trx_rseg_n_slots_debug">innodb_trx_rseg_n_slots_debug</a></td>
                    <td>Yes</td>
                    <td>Yes</td>
                    <td>Yes</td>
                    <td></td>
                    <td>Global</td>
                    <td>Yes</td>
                </tr><tr><td scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_undo_directory">innodb_undo_directory</a></td>
                    <td>Yes</td>
                    <td>Yes</td>
                    <td>Yes</td>
                    <td></td>
                    <td>Global</td>
                    <td>No</td>
                </tr><tr><td scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_undo_log_truncate">innodb_undo_log_truncate</a></td>
                    <td>Yes</td>
                    <td>Yes</td>
                    <td>Yes</td>
                    <td></td>
                    <td>Global</td>
                    <td>Yes</td>
                </tr><tr><td scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_undo_logs">innodb_undo_logs</a></td>
                    <td>Yes</td>
                    <td>Yes</td>
                    <td>Yes</td>
                    <td></td>
                    <td>Global</td>
                    <td>Yes</td>
                </tr><tr><td scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_undo_tablespaces">innodb_undo_tablespaces</a></td>
                    <td>Yes</td>
                    <td>Yes</td>
                    <td>Yes</td>
                    <td></td>
                    <td>Global</td>
                    <td>No</td>
                </tr><tr><td scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_use_native_aio">innodb_use_native_aio</a></td>
                    <td>Yes</td>
                    <td>Yes</td>
                    <td>Yes</td>
                    <td></td>
                    <td>Global</td>
                    <td>No</td>
                </tr><tr><td scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_use_sys_malloc">innodb_use_sys_malloc</a></td>
                    <td>Yes</td>
                    <td>Yes</td>
                    <td>Yes</td>
                    <td></td>
                    <td>Global</td>
                    <td>No</td>
                </tr><tr><td scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_version">innodb_version</a></td>
                    <td></td>
                    <td></td>
                    <td>Yes</td>
                    <td></td>
                    <td>Global</td>
                    <td>No</td>
                </tr><tr><td scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_write_io_threads">innodb_write_io_threads</a></td>
                    <td>Yes</td>
                    <td>Yes</td>
                    <td>Yes</td>
                    <td></td>
                    <td>Global</td>
                    <td>No</td>
                </tr><tr><td scope="row"><a class="link" href="server-administration.html#sysvar_timed_mutexes">timed_mutexes</a></td>
                    <td>Yes</td>
                    <td>Yes</td>
                    <td>Yes</td>
                    <td></td>
                    <td>Global</td>
                    <td>Yes</td>
                </tr><tr><td scope="row"><a class="link" href="server-administration.html#sysvar_unique_checks">unique_checks</a></td>
                    <td></td>
                    <td></td>
                    <td>Yes</td>
                    <td></td>
                    <td>Both</td>
                    <td>Yes</td>
                </tr></tbody></table>
            </div>

        </div>
        <br class="table-break">
        <h3><a name="idm140286815182864"></a>InnoDB Command Options</h3>
        <div class="itemizedlist">
            <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><a name="option_mysqld_innodb"></a>
                <a class="indexterm" name="idm140286815180944"></a>

                <a class="indexterm" name="idm140286815179488"></a>

                <code class="option">--innodb[=<em class="replaceable"><code>value</code></em>]</code>
            </p><p style="color:blue;">--InnoDB[=值]</p>
                <div class="informaltable">
                    <table frame="box" rules="all" summary="Properties for innodb"><colgroup><col width="30%"><col width="70%"></colgroup><thead><tr><th scope="col">Property</th>
                        <th scope="col">Value</th>
                    </tr></thead><tbody><tr><td scope="row"><span class="bold"><strong>Command-Line Format</strong></span></td>
                        <td><code class="literal">--innodb[=value]</code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Deprecated</strong></span></td>
                        <td>5.7.5</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Type</strong></span></td>
                        <td>Enumeration</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Default Value</strong></span></td>
                        <td><code class="literal">ON</code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Valid Values</strong></span></td>
                        <td><p class="valid-value"><code class="literal">OFF</code></p><p style="color:blue;">关闭</p><p class="valid-value"><code class="literal">ON</code></p><p style="color:blue;">打开</p><p class="valid-value"><code class="literal">FORCE</code></p><p style="color:blue;">力</p></td>
                    </tr></tbody></table>
                </div>
                <p>
                    Controls loading of the <code class="literal">InnoDB</code> storage
                    engine, if the server was compiled with
                    <code class="literal">InnoDB</code> support. This option has a tristate
                    format, with possible values of <code class="literal">OFF</code>,
                    <code class="literal">ON</code>, or <code class="literal">FORCE</code>. See
                    <a class="xref" href="server-administration.html#plugin-loading" title="5.5.1&nbsp;Installing and Uninstalling Plugins">Section&nbsp;5.5.1, “Installing and Uninstalling Plugins”</a>.
                </p><p style="color:blue;">如果服务器是使用InnoDB支持编译的，则控制InnoDB存储引擎的加载。此选项具有三态格式，可能的值为“关”、“开”或“力”。参见第5.5.1节“安装和卸载插件”。</p><p>
                    To disable <code class="literal">InnoDB</code>, use
                    <a class="link" href="innodb-storage-engine.html#option_mysqld_innodb"><code class="option">--innodb=OFF</code></a>
                    or
                    <a class="link" href="innodb-storage-engine.html#option_mysqld_innodb"><code class="option">--skip-innodb</code></a>.
                    In this case, because the default storage engine is
                    <a class="link" href="innodb-storage-engine.html" title="Chapter&nbsp;14&nbsp;The InnoDB Storage Engine"><code class="literal">InnoDB</code></a>, the server does not start
                    unless you also use
                    <a class="link" href="server-administration.html#sysvar_default_storage_engine"><code class="option">--default-storage-engine</code></a> and
                    <a class="link" href="server-administration.html#sysvar_default_tmp_storage_engine"><code class="option">--default-tmp-storage-engine</code></a> to
                    set the default to some other engine for both permanent and
                    <code class="literal">TEMPORARY</code> tables.
                </p><p style="color:blue;">要禁用innodb，请使用--innodb=off或--skip innodb。在这种情况下，因为默认存储引擎是innodb，所以服务器不会启动，除非您还使用--default storage engine和--default tmp storage engine为永久表和临时表将默认值设置为其他引擎。</p><p>
                    The <code class="literal">InnoDB</code> storage engine can no longer be
                    disabled, and the
                    <a class="link" href="innodb-storage-engine.html#option_mysqld_innodb"><code class="option">--innodb=OFF</code></a>
                    and
                    <a class="link" href="innodb-storage-engine.html#option_mysqld_innodb"><code class="option">--skip-innodb</code></a>
                    options are deprecated and have no effect. Their use results
                    in a warning. These options will be removed in a future MySQL
                    release.
                </p><p style="color:blue;">InnoDB存储引擎不能再被禁用，--innodb=off和--skip innodb选项被弃用，并且没有任何效果。它们的使用会导致警告。这些选项将在未来的mysql版本中删除。</p></li><li class="listitem"><p><a name="option_mysqld_innodb-status-file"></a>
                <a class="indexterm" name="idm140286815137936"></a>

                <a class="indexterm" name="idm140286815136480"></a>

                <code class="option">--innodb-status-file</code>
            </p><p style="color:blue;">--InnoDB状态文件</p>
                <div class="informaltable">
                    <table frame="box" rules="all" summary="Properties for innodb-status-file"><colgroup><col width="30%"><col width="70%"></colgroup><thead><tr><th scope="col">Property</th>
                        <th scope="col">Value</th>
                    </tr></thead><tbody><tr><td scope="row"><span class="bold"><strong>Command-Line Format</strong></span></td>
                        <td><code class="literal">--innodb-status-file[={OFF|ON}]</code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Type</strong></span></td>
                        <td>Boolean</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Default Value</strong></span></td>
                        <td><code class="literal">OFF</code></td>
                    </tr></tbody></table>
                </div>
                <p>
                    The <code class="option">--innodb-status-file</code> startup option
                    controls whether <code class="literal">InnoDB</code> creates a file
                    named
                    <code class="filename">innodb_status.<em class="replaceable"><code>pid</code></em></code>
                    in the data directory and writes
                    <a class="link" href="sql-syntax.html#show-engine" title="13.7.5.15&nbsp;SHOW ENGINE Syntax"><code class="literal">SHOW ENGINE
                        INNODB STATUS</code></a> output to it every 15 seconds,
                    approximately.
                </p><p style="color:blue;">状态文件启动选项控制是否在数据目录中创建一个名为“文件名”的文件，并每隔15秒写入一次引擎输出状态。</p><p>
                    The
                    <code class="filename">innodb_status.<em class="replaceable"><code>pid</code></em></code>
                    file is not created by default. To create it, start
                    <a class="link" href="programs.html#mysqld" title="4.3.1&nbsp;mysqld — The MySQL Server"><span class="command"><strong>mysqld</strong></span></a> with the
                    <code class="option">--innodb-status-file</code> option.
                    <code class="literal">InnoDB</code> removes the file when the server is
                    shut down normally. If an abnormal shutdown occurs, the status
                    file may have to be removed manually.
                </p><p style="color:blue;">默认情况下不会创建innodb_status.pid文件。要创建它，请使用--innodb status file选项启动mysqld。当服务器正常关闭时，innodb会删除文件。如果发生异常关机，可能必须手动删除状态文件。</p><p>
                    The <code class="option">--innodb-status-file</code> option is intended
                    for temporary use, as
                    <a class="link" href="sql-syntax.html#show-engine" title="13.7.5.15&nbsp;SHOW ENGINE Syntax"><code class="literal">SHOW ENGINE
                        INNODB STATUS</code></a> output generation can affect
                    performance, and the
                    <code class="filename">innodb_status.<em class="replaceable"><code>pid</code></em></code>
                    file can become quite large over time.
                </p><p style="color:blue;">--innodb status file选项是临时使用的，因为show engine innodb status output generation会影响性能，并且innodb_status.pid文件会随着时间的推移变得非常大。</p><p>
                    For related information, see
                    <a class="xref" href="innodb-storage-engine.html#innodb-enabling-monitors" title="14.17.2&nbsp;Enabling InnoDB Monitors">Section&nbsp;14.17.2, “Enabling InnoDB Monitors”</a>.
                </p><p style="color:blue;">有关信息，请参阅14.17.2节，“启用InnoDB监视器”。</p></li><li class="listitem"><p>
                <a class="indexterm" name="idm140286815105712"></a>

                <a class="indexterm" name="idm140286815104224"></a>

                <a class="link" href="innodb-storage-engine.html#option_mysqld_innodb"><code class="option">--skip-innodb</code></a>
            </p><p style="color:blue;">--跳过innodb</p><p>
                Disable the <code class="literal">InnoDB</code> storage engine. See the
                description of <a class="link" href="innodb-storage-engine.html#option_mysqld_innodb"><code class="option">--innodb</code></a>.
            </p><p style="color:blue;">禁用InnoDB存储引擎。请参阅--innodb的描述。</p></li></ul>
        </div>
        <h3><a name="idm140286815099344"></a>InnoDB System Variables</h3>
        <div class="itemizedlist">
            <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><a name="sysvar_daemon_memcached_enable_binlog"></a>
                <a class="indexterm" name="idm140286815097376"></a>

                <code class="literal">daemon_memcached_enable_binlog</code>
            </p><p style="color:blue;">daemon_memcached_enable_binlog</p>
                <div class="informaltable">
                    <table frame="box" rules="all" summary="Properties for daemon_memcached_enable_binlog"><colgroup><col width="30%"><col width="70%"></colgroup><thead><tr><th scope="col">Property</th>
                        <th scope="col">Value</th>
                    </tr></thead><tbody><tr><td scope="row"><span class="bold"><strong>Command-Line Format</strong></span></td>
                        <td><code class="literal">--daemon-memcached-enable-binlog[={OFF|ON}]</code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>System Variable</strong></span></td>
                        <td><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_daemon_memcached_enable_binlog">daemon_memcached_enable_binlog</a></code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Scope</strong></span></td>
                        <td>Global</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Dynamic</strong></span></td>
                        <td>No</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Type</strong></span></td>
                        <td>Boolean</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Default Value</strong></span></td>
                        <td><code class="literal">OFF</code></td>
                    </tr></tbody></table>
                </div>
                <p>
                    Enable this option on the
                    <a class="link" href="glossary.html#glos_master_server" title="master server">master server</a> to use
                    the <code class="literal">InnoDB</code> <span class="command"><strong>memcached</strong></span>
                    plugin (<code class="literal">daemon_memcached</code>) with the MySQL
                    <a class="link" href="glossary.html#glos_binary_log" title="binary log">binary log</a>. This option
                    can only be set at server startup. You must also enable the
                    MySQL binary log on the master server using the
                    <a class="link" href="replication.html#sysvar_log_bin"><code class="literal">--log-bin</code></a> option.
                </p><p style="color:blue;">在主服务器上启用此选项，以便在mysql二进制日志中使用innodb memcached插件（daemon_memcached）。此选项只能在服务器启动时设置。还必须使用--log bin选项在主服务器上启用mysql二进制日志。</p><p>
                    For more information, see
                    <a class="xref" href="innodb-storage-engine.html#innodb-memcached-replication" title="14.20.6&nbsp;The InnoDB memcached Plugin and Replication">Section&nbsp;14.20.6, “The InnoDB memcached Plugin and Replication”</a>.
                </p><p style="color:blue;">有关更多信息，请参阅14.20.6节，“innodb memcached plugin and replication”。</p></li><li class="listitem"><p><a name="sysvar_daemon_memcached_engine_lib_name"></a>
                <a class="indexterm" name="idm140286815063408"></a>

                <code class="literal">daemon_memcached_engine_lib_name</code>
            </p><p style="color:blue;">daemon_memcached_engine_lib_名称</p>
                <div class="informaltable">
                    <table frame="box" rules="all" summary="Properties for daemon_memcached_engine_lib_name"><colgroup><col width="30%"><col width="70%"></colgroup><thead><tr><th scope="col">Property</th>
                        <th scope="col">Value</th>
                    </tr></thead><tbody><tr><td scope="row"><span class="bold"><strong>Command-Line Format</strong></span></td>
                        <td><code class="literal">--daemon-memcached-engine-lib-name=file_name</code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>System Variable</strong></span></td>
                        <td><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_daemon_memcached_engine_lib_name">daemon_memcached_engine_lib_name</a></code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Scope</strong></span></td>
                        <td>Global</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Dynamic</strong></span></td>
                        <td>No</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Type</strong></span></td>
                        <td>File name</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Default Value</strong></span></td>
                        <td><code class="literal">innodb_engine.so</code></td>
                    </tr></tbody></table>
                </div>
                <p>
                    Specifies the shared library that implements the
                    <code class="literal">InnoDB</code> <span class="command"><strong>memcached</strong></span> plugin.
                </p><p style="color:blue;">指定实现innodb memcached插件的共享库。</p><p>
                    For more information, see
                    <a class="xref" href="innodb-storage-engine.html#innodb-memcached-setup" title="14.20.3&nbsp;Setting Up the InnoDB memcached Plugin">Section&nbsp;14.20.3, “Setting Up the InnoDB memcached Plugin”</a>.
                </p><p style="color:blue;">有关更多信息，请参阅14.20.3节，“设置innodb memcached插件”。</p></li><li class="listitem"><p><a name="sysvar_daemon_memcached_engine_lib_path"></a>
                <a class="indexterm" name="idm140286815033376"></a>

                <code class="literal">daemon_memcached_engine_lib_path</code>
            </p><p style="color:blue;">daemon_memcached_engine_lib_路径</p>
                <div class="informaltable">
                    <table frame="box" rules="all" summary="Properties for daemon_memcached_engine_lib_path"><colgroup><col width="30%"><col width="70%"></colgroup><thead><tr><th scope="col">Property</th>
                        <th scope="col">Value</th>
                    </tr></thead><tbody><tr><td scope="row"><span class="bold"><strong>Command-Line Format</strong></span></td>
                        <td><code class="literal">--daemon-memcached-engine-lib-path=dir_name</code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>System Variable</strong></span></td>
                        <td><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_daemon_memcached_engine_lib_path">daemon_memcached_engine_lib_path</a></code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Scope</strong></span></td>
                        <td>Global</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Dynamic</strong></span></td>
                        <td>No</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Type</strong></span></td>
                        <td>Directory name</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Default Value</strong></span></td>
                        <td><code class="literal">NULL</code></td>
                    </tr></tbody></table>
                </div>
                <p>
                    The path of the directory containing the shared library that
                    implements the <code class="literal">InnoDB</code>
                    <span class="command"><strong>memcached</strong></span> plugin. The default value is
                    NULL, representing the MySQL plugin directory. You should not
                    need to modify this parameter unless specifying a
                    <code class="literal">memcached</code> plugin for a different storage
                    engine that is located outside of the MySQL plugin directory.
                </p><p style="color:blue;">包含实现innodb memcached插件的共享库的目录的路径。默认值为空，表示mysql插件目录。除非为位于mysql插件目录之外的其他存储引擎指定memcached插件，否则不需要修改此参数。</p><p>
                    For more information, see
                    <a class="xref" href="innodb-storage-engine.html#innodb-memcached-setup" title="14.20.3&nbsp;Setting Up the InnoDB memcached Plugin">Section&nbsp;14.20.3, “Setting Up the InnoDB memcached Plugin”</a>.
                </p><p style="color:blue;">有关更多信息，请参阅14.20.3节，“设置innodb memcached插件”。</p></li><li class="listitem"><p><a name="sysvar_daemon_memcached_option"></a>
                <a class="indexterm" name="idm140286815002576"></a>

                <code class="literal">daemon_memcached_option</code>
            </p><p style="color:blue;">daemon_memcached_选项</p>
                <div class="informaltable">
                    <table frame="box" rules="all" summary="Properties for daemon_memcached_option"><colgroup><col width="30%"><col width="70%"></colgroup><thead><tr><th scope="col">Property</th>
                        <th scope="col">Value</th>
                    </tr></thead><tbody><tr><td scope="row"><span class="bold"><strong>Command-Line Format</strong></span></td>
                        <td><code class="literal">--daemon-memcached-option=options</code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>System Variable</strong></span></td>
                        <td><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_daemon_memcached_option">daemon_memcached_option</a></code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Scope</strong></span></td>
                        <td>Global</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Dynamic</strong></span></td>
                        <td>No</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Type</strong></span></td>
                        <td>String</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Default Value</strong></span></td>
                        <td><code class="literal"></code></td>
                    </tr></tbody></table>
                </div>
                <p>
                    Used to pass space-separated memcached options to the
                    underlying <span class="command"><strong>memcached</strong></span> memory object caching
                    daemon on startup. For example, you might change the port that
                    <span class="command"><strong>memcached</strong></span> listens on, reduce the maximum
                    number of simultaneous connections, change the maximum memory
                    size for a key-value pair, or enable debugging messages for
                    the error log.
                </p><p style="color:blue;">用于在启动时将空间分隔的memcached选项传递给底层memcached内存对象缓存守护进程。例如，您可以更改MimcCask侦听的端口，减少同时连接的最大数量，更改密钥值对的最大内存大小，或者启用错误日志的调试消息。</p><p>
                    See <a class="xref" href="innodb-storage-engine.html#innodb-memcached-setup" title="14.20.3&nbsp;Setting Up the InnoDB memcached Plugin">Section&nbsp;14.20.3, “Setting Up the InnoDB memcached Plugin”</a> for usage
                    details. For information about <span class="command"><strong>memcached</strong></span>
                    options, refer to the <span class="command"><strong>memcached</strong></span> man page.
                </p><p style="color:blue;">请参阅14.20.3节“设置innodb memcached插件”了解用法详细信息。有关memcached选项的信息，请参阅memcached手册页。</p></li><li class="listitem"><p><a name="sysvar_daemon_memcached_r_batch_size"></a>
                <a class="indexterm" name="idm140286814971152"></a>

                <code class="literal">daemon_memcached_r_batch_size</code>
            </p><p style="color:blue;">daemon_memcached_r_批处理大小</p>
                <div class="informaltable">
                    <table frame="box" rules="all" summary="Properties for daemon_memcached_r_batch_size"><colgroup><col width="30%"><col width="70%"></colgroup><thead><tr><th scope="col">Property</th>
                        <th scope="col">Value</th>
                    </tr></thead><tbody><tr><td scope="row"><span class="bold"><strong>Command-Line Format</strong></span></td>
                        <td><code class="literal">--daemon-memcached-r-batch-size=#</code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>System Variable</strong></span></td>
                        <td><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_daemon_memcached_r_batch_size">daemon_memcached_r_batch_size</a></code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Scope</strong></span></td>
                        <td>Global</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Dynamic</strong></span></td>
                        <td>No</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Type</strong></span></td>
                        <td>Integer</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Default Value</strong></span></td>
                        <td><code class="literal">1</code></td>
                    </tr></tbody></table>
                </div>
                <p>
                    Specifies how many <span class="command"><strong>memcached</strong></span> read
                    operations (<code class="literal">get</code> operations) to perform
                    before doing a <a class="link" href="sql-syntax.html#commit" title="13.3.1&nbsp;START TRANSACTION, COMMIT, and ROLLBACK Syntax"><code class="literal">COMMIT</code></a> to start
                    a new transaction. Counterpart of
                    <a class="link" href="innodb-storage-engine.html#sysvar_daemon_memcached_w_batch_size"><code class="literal">daemon_memcached_w_batch_size</code></a>.
                </p><p style="color:blue;">指定在执行提交以启动新事务之前要执行多少memcached读取操作（get操作）。daemon_memcached_w_batch_size的对应项。</p><p>
                    This value is set to 1 by default, so that any changes made to
                    the table through SQL statements are immediately visible to
                    <span class="command"><strong>memcached</strong></span> operations. You might increase it
                    to reduce the overhead from frequent commits on a system where
                    the underlying table is only being accessed through the
                    <span class="command"><strong>memcached</strong></span> interface. If you set the value
                    too large, the amount of undo or redo data could impose some
                    storage overhead, as with any long-running transaction.
                </p><p style="color:blue;">默认情况下，此值设置为1，这样通过sql语句对表所做的任何更改都将立即对memcached操作可见。在只通过memcached接口访问底层表的系统上，您可以增加它以减少频繁提交的开销。如果设置的值太大，那么撤消或重做数据量可能会带来一些存储开销，就像任何长时间运行的事务一样。</p><p>
                    For more information, see
                    <a class="xref" href="innodb-storage-engine.html#innodb-memcached-setup" title="14.20.3&nbsp;Setting Up the InnoDB memcached Plugin">Section&nbsp;14.20.3, “Setting Up the InnoDB memcached Plugin”</a>.
                </p><p style="color:blue;">有关更多信息，请参阅14.20.3节，“设置innodb memcached插件”。</p></li><li class="listitem"><p><a name="sysvar_daemon_memcached_w_batch_size"></a>
                <a class="indexterm" name="idm140286814936384"></a>

                <code class="literal">daemon_memcached_w_batch_size</code>
            </p><p style="color:blue;">daemon_memcached_w_batch_大小</p>
                <div class="informaltable">
                    <table frame="box" rules="all" summary="Properties for daemon_memcached_w_batch_size"><colgroup><col width="30%"><col width="70%"></colgroup><thead><tr><th scope="col">Property</th>
                        <th scope="col">Value</th>
                    </tr></thead><tbody><tr><td scope="row"><span class="bold"><strong>Command-Line Format</strong></span></td>
                        <td><code class="literal">--daemon-memcached-w-batch-size=#</code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>System Variable</strong></span></td>
                        <td><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_daemon_memcached_w_batch_size">daemon_memcached_w_batch_size</a></code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Scope</strong></span></td>
                        <td>Global</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Dynamic</strong></span></td>
                        <td>No</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Type</strong></span></td>
                        <td>Integer</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Default Value</strong></span></td>
                        <td><code class="literal">1</code></td>
                    </tr></tbody></table>
                </div>
                <p>
                    Specifies how many <span class="command"><strong>memcached</strong></span> write
                    operations, such as <code class="literal">add</code>,
                    <code class="literal">set</code>, and <code class="literal">incr</code>, to
                    perform before doing a <a class="link" href="sql-syntax.html#commit" title="13.3.1&nbsp;START TRANSACTION, COMMIT, and ROLLBACK Syntax"><code class="literal">COMMIT</code></a>
                    to start a new transaction. Counterpart of
                    <a class="link" href="innodb-storage-engine.html#sysvar_daemon_memcached_r_batch_size"><code class="literal">daemon_memcached_r_batch_size</code></a>.
                </p><p style="color:blue;">指定在执行提交以启动新事务之前要执行多少memcached写操作，如add、set和incr。daemon_memcached_r_batch_size的对应项。</p><p>
                    This value is set to 1 by default, on the assumption that data
                    being stored is important to preserve in case of an outage and
                    should immediately be committed. When storing non-critical
                    data, you might increase this value to reduce the overhead
                    from frequent commits; but then the last
                    <em class="replaceable"><code>N</code></em>-1 uncommitted write operations
                    could be lost if a crash occurs.
                </p><p style="color:blue;">默认情况下，此值设置为1，前提是存储的数据对于在中断情况下保留非常重要，并且应立即提交。在存储非关键数据时，可以增加此值以减少频繁提交的开销；但如果发生崩溃，则可能会丢失最后N-1个未提交的写操作。</p><p>
                    For more information, see
                    <a class="xref" href="innodb-storage-engine.html#innodb-memcached-setup" title="14.20.3&nbsp;Setting Up the InnoDB memcached Plugin">Section&nbsp;14.20.3, “Setting Up the InnoDB memcached Plugin”</a>.
                </p><p style="color:blue;">有关更多信息，请参阅14.20.3节，“设置innodb memcached插件”。</p></li><li class="listitem"><p><a name="sysvar_ignore_builtin_innodb"></a>
                <a class="indexterm" name="idm140286814901392"></a>

                <a class="indexterm" name="idm140286814900352"></a>

                <code class="literal">ignore_builtin_innodb</code>
            </p><p style="color:blue;">忽略内置innodb</p>
                <div class="informaltable">
                    <table frame="box" rules="all" summary="Properties for ignore_builtin_innodb"><colgroup><col width="30%"><col width="70%"></colgroup><thead><tr><th scope="col">Property</th>
                        <th scope="col">Value</th>
                    </tr></thead><tbody><tr><td scope="row"><span class="bold"><strong>Command-Line Format</strong></span></td>
                        <td><code class="literal">--ignore-builtin-innodb[={OFF|ON}]</code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Deprecated</strong></span></td>
                        <td>Yes</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>System Variable</strong></span></td>
                        <td><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_ignore_builtin_innodb">ignore_builtin_innodb</a></code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Scope</strong></span></td>
                        <td>Global</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Dynamic</strong></span></td>
                        <td>No</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Type</strong></span></td>
                        <td>Boolean</td>
                    </tr></tbody></table>
                </div>
                <p>
                    In earlier versions of MySQL, enabling this variable caused
                    the server to behave as if the built-in
                    <code class="literal">InnoDB</code> were not present, which enabled the
                    <code class="literal">InnoDB Plugin</code> to be used instead. In MySQL
                    5.7, <code class="literal">InnoDB</code> is the default
                    storage engine and <code class="literal">InnoDB Plugin</code> is not
                    used, so this variable is ignored.
                </p><p style="color:blue;">在早期版本的mysql中，启用这个变量会导致服务器的行为就像内置的innodb不存在一样，这使得innodb插件可以被使用。在mysql 5.7中，innodb是默认的存储引擎，不使用innodb plugin，所以忽略这个变量。</p></li><li class="listitem"><p><a name="sysvar_innodb_adaptive_flushing"></a>
                <a class="indexterm" name="idm140286814870000"></a>

                <a class="indexterm" name="idm140286814868896"></a>

                <code class="literal">innodb_adaptive_flushing</code>
            </p><p style="color:blue;">InnoDB_自适应_刷新</p>
                <div class="informaltable">
                    <table frame="box" rules="all" summary="Properties for innodb_adaptive_flushing"><colgroup><col width="30%"><col width="70%"></colgroup><thead><tr><th scope="col">Property</th>
                        <th scope="col">Value</th>
                    </tr></thead><tbody><tr><td scope="row"><span class="bold"><strong>Command-Line Format</strong></span></td>
                        <td><code class="literal">--innodb-adaptive-flushing[={OFF|ON}]</code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>System Variable</strong></span></td>
                        <td><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_adaptive_flushing">innodb_adaptive_flushing</a></code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Scope</strong></span></td>
                        <td>Global</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Dynamic</strong></span></td>
                        <td>Yes</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Type</strong></span></td>
                        <td>Boolean</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Default Value</strong></span></td>
                        <td><code class="literal">ON</code></td>
                    </tr></tbody></table>
                </div>
                <a class="indexterm" name="idm140286814842848"></a><p>
                    Specifies whether to dynamically adjust the rate of flushing
                    <a class="link" href="glossary.html#glos_dirty_page" title="dirty page">dirty pages</a> in the
                    <code class="literal">InnoDB</code>
                    <a class="link" href="glossary.html#glos_buffer_pool" title="buffer pool">buffer pool</a> based on
                    the workload. Adjusting the flush rate dynamically is intended
                    to avoid bursts of I/O activity. This setting is enabled by
                    default. See <a class="xref" href="innodb-storage-engine.html#innodb-buffer-pool-flushing" title="14.8.3.5&nbsp;Configuring Buffer Pool Flushing">Section&nbsp;14.8.3.5, “Configuring Buffer Pool Flushing”</a> for
                    more information. For general I/O tuning advice, see
                    <a class="xref" href="optimization.html#optimizing-innodb-diskio" title="8.5.8&nbsp;Optimizing InnoDB Disk I/O">Section&nbsp;8.5.8, “Optimizing InnoDB Disk I/O”</a>.
                </p><p style="color:blue;">指定是否根据工作负载动态调整innodb缓冲池中脏页的刷新速率。动态调整刷新率是为了避免I/O活动的突发。默认情况下启用此设置。有关更多信息，请参阅第14.8.3.5节“配置缓冲池刷新”。有关一般I/O调整建议，请参阅第8.5.8节“优化InnoDB磁盘I/O”。</p></li><li class="listitem"><p><a name="sysvar_innodb_adaptive_flushing_lwm"></a>
                <a class="indexterm" name="idm140286814836160"></a>

                <code class="literal">innodb_adaptive_flushing_lwm</code>
            </p><p style="color:blue;">innodb_adaptive_flushing_lwm公司</p>
                <div class="informaltable">
                    <table frame="box" rules="all" summary="Properties for innodb_adaptive_flushing_lwm"><colgroup><col width="30%"><col width="70%"></colgroup><thead><tr><th scope="col">Property</th>
                        <th scope="col">Value</th>
                    </tr></thead><tbody><tr><td scope="row"><span class="bold"><strong>Command-Line Format</strong></span></td>
                        <td><code class="literal">--innodb-adaptive-flushing-lwm=#</code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>System Variable</strong></span></td>
                        <td><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_adaptive_flushing_lwm">innodb_adaptive_flushing_lwm</a></code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Scope</strong></span></td>
                        <td>Global</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Dynamic</strong></span></td>
                        <td>Yes</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Type</strong></span></td>
                        <td>Integer</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Default Value</strong></span></td>
                        <td><code class="literal">10</code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Minimum Value</strong></span></td>
                        <td><code class="literal">0</code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Maximum Value</strong></span></td>
                        <td><code class="literal">70</code></td>
                    </tr></tbody></table>
                </div>
                <p>
                    Defines the low water mark representing percentage of
                    <a class="link" href="glossary.html#glos_redo_log" title="redo log">redo log</a> capacity at
                    which <a class="link" href="glossary.html#glos_adaptive_flushing" title="adaptive flushing">adaptive
                    flushing</a> is enabled. For more information, see
                    <a class="xref" href="innodb-storage-engine.html#innodb-buffer-pool-flushing" title="14.8.3.5&nbsp;Configuring Buffer Pool Flushing">Section&nbsp;14.8.3.5, “Configuring Buffer Pool Flushing”</a>.
                </p><p style="color:blue;">定义表示启用自适应刷新时重做日志容量百分比的低水位线。有关更多信息，请参阅第14.8.3.5节“配置缓冲池刷新”。</p></li><li class="listitem"><p><a name="sysvar_innodb_adaptive_hash_index"></a>
                <a class="indexterm" name="idm140286814800144"></a>

                <a class="indexterm" name="idm140286814799040"></a>

                <code class="literal">innodb_adaptive_hash_index</code>
            </p><p style="color:blue;">innodb_adaptive_hash_索引</p>
                <div class="informaltable">
                    <table frame="box" rules="all" summary="Properties for innodb_adaptive_hash_index"><colgroup><col width="30%"><col width="70%"></colgroup><thead><tr><th scope="col">Property</th>
                        <th scope="col">Value</th>
                    </tr></thead><tbody><tr><td scope="row"><span class="bold"><strong>Command-Line Format</strong></span></td>
                        <td><code class="literal">--innodb-adaptive-hash-index[={OFF|ON}]</code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>System Variable</strong></span></td>
                        <td><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_adaptive_hash_index">innodb_adaptive_hash_index</a></code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Scope</strong></span></td>
                        <td>Global</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Dynamic</strong></span></td>
                        <td>Yes</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Type</strong></span></td>
                        <td>Boolean</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Default Value</strong></span></td>
                        <td><code class="literal">ON</code></td>
                    </tr></tbody></table>
                </div>
                <p>
                    Whether the <code class="literal">InnoDB</code>
                    <a class="link" href="glossary.html#glos_adaptive_hash_index" title="adaptive hash index">adaptive hash
                        index</a> is enabled or disabled. It may be desirable,
                    depending on your workload, to dynamically enable or disable
                    <a class="link" href="glossary.html#glos_adaptive_hash_index" title="adaptive hash index">adaptive hash
                        indexing</a> to improve query performance. Because the
                    adaptive hash index may not be useful for all workloads,
                    conduct benchmarks with it both enabled and disabled, using
                    realistic workloads. See
                    <a class="xref" href="innodb-storage-engine.html#innodb-adaptive-hash" title="14.5.3&nbsp;Adaptive Hash Index">Section&nbsp;14.5.3, “Adaptive Hash Index”</a> for details.
                </p><p style="color:blue;">InnoDB自适应哈希索引是启用还是禁用。根据您的工作量，动态地启用或禁用自适应哈希索引以提高查询性能可能是可取的。由于自适应散列索引可能对所有工作负载都没有用处，因此使用实际工作负载，在启用和禁用该索引的情况下执行基准测试。详见第14.5.3节“自适应散列索引”。</p><p>
                    This variable is enabled by default. You can modify this
                    parameter using the <code class="literal">SET GLOBAL</code> statement,
                    without restarting the server. Changing the setting at runtime
                    requires privileges sufficient to set global system variables.
                    See <a class="xref" href="server-administration.html#system-variable-privileges" title="5.1.8.1&nbsp;System Variable Privileges">Section&nbsp;5.1.8.1, “System Variable Privileges”</a>. You can also
                    use <code class="option">--skip-innodb-adaptive-hash-index</code> at
                    server startup to disable it.
                </p><p style="color:blue;">默认情况下启用此变量。您可以使用set global语句修改此参数，而无需重新启动服务器。在运行时更改设置需要足够的权限来设置全局系统变量。见第5.1.8.1节“系统变量特权”。您还可以使用--skip innodb adaptive hash index at server startup禁用它。</p><p>
                    Disabling the adaptive hash index empties the hash table
                    immediately. Normal operations can continue while the hash
                    table is emptied, and executing queries that were using the
                    hash table access the index B-trees directly instead. When the
                    adaptive hash index is re-enabled, the hash table is populated
                    again during normal operation.
                </p><p style="color:blue;">禁用自适应哈希索引会立即清空哈希表。当哈希表被清空时，正常的操作可以继续，而执行使用哈希表的查询可以直接访问索引b树。当重新启用自适应哈希索引时，将在正常操作期间再次填充哈希表。</p></li><li class="listitem"><p><a name="sysvar_innodb_adaptive_hash_index_parts"></a>
                <a class="indexterm" name="idm140286814764576"></a>

                <a class="indexterm" name="idm140286814763472"></a>

                <code class="literal">innodb_adaptive_hash_index_parts</code>
            </p><p style="color:blue;">innodb_adaptive_hash_index_部件</p>
                <div class="informaltable">
                    <table frame="box" rules="all" summary="Properties for innodb_adaptive_hash_index_parts"><colgroup><col width="30%"><col width="70%"></colgroup><thead><tr><th scope="col">Property</th>
                        <th scope="col">Value</th>
                    </tr></thead><tbody><tr><td scope="row"><span class="bold"><strong>Command-Line Format</strong></span></td>
                        <td><code class="literal">--innodb-adaptive-hash-index-parts=#</code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Introduced</strong></span></td>
                        <td>5.7.8</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>System Variable</strong></span></td>
                        <td><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_adaptive_hash_index_parts">innodb_adaptive_hash_index_parts</a></code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Scope</strong></span></td>
                        <td>Global</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Dynamic</strong></span></td>
                        <td>No</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Type</strong></span></td>
                        <td>Numeric</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Default Value</strong></span></td>
                        <td><code class="literal">8</code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Minimum Value</strong></span></td>
                        <td><code class="literal">1</code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Maximum Value</strong></span></td>
                        <td><code class="literal">512</code></td>
                    </tr></tbody></table>
                </div>
                <p>
                    Partitions the adaptive hash index search system. Each index
                    is bound to a specific partition, with each partition
                    protected by a separate latch.
                </p><p style="color:blue;">对自适应哈希索引搜索系统进行分区。每个索引都绑定到一个特定的分区，每个分区由一个单独的闩锁保护。</p><p>
                    In earlier releases, the adaptive hash index search system was
                    protected by a single latch
                    (<code class="literal">btr_search_latch</code>) which could become a
                    point of contention. With the introduction of the
                    <code class="literal">innodb_adaptive_hash_index_parts</code> option,
                    the search system is partitioned into 8 parts by default. The
                    maximum setting is 512.
                </p><p style="color:blue;">在早期版本中，自适应散列索引搜索系统由单个锁存器（btr_search_latch）保护，该锁存器可能成为争用点。随着innodb_adaptive_hash_index_parts选项的引入，搜索系统默认分为8个部分。最大设定值为512。</p><p>
                    For related information, see
                    <a class="xref" href="innodb-storage-engine.html#innodb-adaptive-hash" title="14.5.3&nbsp;Adaptive Hash Index">Section&nbsp;14.5.3, “Adaptive Hash Index”</a>.
                </p><p style="color:blue;">有关信息，请参阅第14.5.3节“自适应哈希索引”。</p></li><li class="listitem"><p><a name="sysvar_innodb_adaptive_max_sleep_delay"></a>
                <a class="indexterm" name="idm140286814723568"></a>

                <a class="link" href="innodb-storage-engine.html#sysvar_innodb_adaptive_max_sleep_delay"><code class="literal">innodb_adaptive_max_sleep_delay</code></a>
            </p><p style="color:blue;">innodb_adaptive_max_sleep_延迟</p>
                <div class="informaltable">
                    <table frame="box" rules="all" summary="Properties for innodb_adaptive_max_sleep_delay"><colgroup><col width="30%"><col width="70%"></colgroup><thead><tr><th scope="col">Property</th>
                        <th scope="col">Value</th>
                    </tr></thead><tbody><tr><td scope="row"><span class="bold"><strong>Command-Line Format</strong></span></td>
                        <td><code class="literal">--innodb-adaptive-max-sleep-delay=#</code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>System Variable</strong></span></td>
                        <td><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_adaptive_max_sleep_delay">innodb_adaptive_max_sleep_delay</a></code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Scope</strong></span></td>
                        <td>Global</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Dynamic</strong></span></td>
                        <td>Yes</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Type</strong></span></td>
                        <td>Integer</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Default Value</strong></span></td>
                        <td><code class="literal">150000</code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Minimum Value</strong></span></td>
                        <td><code class="literal">0</code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Maximum Value</strong></span></td>
                        <td><code class="literal">1000000</code></td>
                    </tr></tbody></table>
                </div>
                <p>
                    Permits <code class="literal">InnoDB</code> to automatically adjust the
                    value of
                    <a class="link" href="innodb-storage-engine.html#sysvar_innodb_thread_sleep_delay"><code class="literal">innodb_thread_sleep_delay</code></a> up
                    or down according to the current workload. Any nonzero value
                    enables automated, dynamic adjustment of the
                    <code class="literal">innodb_thread_sleep_delay</code> value, up to the
                    maximum value specified in the
                    <code class="literal">innodb_adaptive_max_sleep_delay</code> option. The
                    value represents the number of microseconds. This option can
                    be useful in busy systems, with greater than 16
                    <code class="literal">InnoDB</code> threads. (In practice, it is most
                    valuable for MySQL systems with hundreds or thousands of
                    simultaneous connections.)
                </p><p style="color:blue;">允许innodb根据当前工作负载自动上下调整innodb_thread_sleep_delay的值。任何非零值都能自动、动态地调整NoNdButhTraceLeLePyLoad延迟值，直到UndByAdviTyVixMax SypEpLead延迟选项中指定的最大值。该值表示微秒数。这个选项在繁忙的系统中非常有用，有超过16个innodb线程。（实际上，对于同时有数百或数千个连接的mysql系统来说，它是最有价值的。）</p><p>
                    For more information, see
                    <a class="xref" href="innodb-storage-engine.html#innodb-performance-thread_concurrency" title="14.8.5&nbsp;Configuring Thread Concurrency for InnoDB">Section&nbsp;14.8.5, “Configuring Thread Concurrency for InnoDB”</a>.
                </p><p style="color:blue;">有关更多信息，请参阅14.8.5节，“为innodb配置线程并发”。</p></li><li class="listitem"><p><a name="sysvar_innodb_additional_mem_pool_size"></a>
                <a class="indexterm" name="idm140286814683776"></a>

                <a class="indexterm" name="idm140286814682672"></a>

                <code class="literal">innodb_additional_mem_pool_size</code>
            </p><p style="color:blue;">InnoDB_附加内存池大小</p>
                <div class="informaltable">
                    <table frame="box" rules="all" summary="Properties for innodb_additional_mem_pool_size"><colgroup><col width="30%"><col width="70%"></colgroup><thead><tr><th scope="col">Property</th>
                        <th scope="col">Value</th>
                    </tr></thead><tbody><tr><td scope="row"><span class="bold"><strong>Command-Line Format</strong></span></td>
                        <td><code class="literal">--innodb-additional-mem-pool-size=#</code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Deprecated</strong></span></td>
                        <td>Yes (removed in 5.7.4)</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>System Variable</strong></span></td>
                        <td><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_additional_mem_pool_size">innodb_additional_mem_pool_size</a></code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Scope</strong></span></td>
                        <td>Global</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Dynamic</strong></span></td>
                        <td>No</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Type</strong></span></td>
                        <td>Integer</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Default Value</strong></span></td>
                        <td><code class="literal">8388608</code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Minimum Value</strong></span></td>
                        <td><code class="literal">2097152</code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Maximum Value</strong></span></td>
                        <td><code class="literal">4294967295</code></td>
                    </tr></tbody></table>
                </div>
                <p>
                    The size in bytes of a memory pool <code class="literal">InnoDB</code>
                    uses to store <a class="link" href="glossary.html#glos_data_dictionary" title="data dictionary">data
                    dictionary</a> information and other internal data
                    structures. The more tables you have in your application, the
                    more memory you allocate here. If <code class="literal">InnoDB</code>
                    runs out of memory in this pool, it starts to allocate memory
                    from the operating system and writes warning messages to the
                    MySQL error log. The default value is 8MB.
                </p><p style="color:blue;">innodb用来存储数据字典信息和其他内部数据结构的内存池的字节大小。应用程序中的表越多，在这里分配的内存就越多。如果innodb耗尽了这个池中的内存，它将开始从操作系统分配内存，并将警告消息写入mysql错误日志。默认值为8MB。</p><p>
                    This variable relates to the <code class="literal">InnoDB</code>
                    internal memory allocator, which is unused if
                    <a class="link" href="innodb-storage-engine.html#sysvar_innodb_use_sys_malloc"><code class="literal">innodb_use_sys_malloc</code></a> is
                    enabled. For more information, see
                    <a class="xref" href="innodb-storage-engine.html#innodb-performance-use_sys_malloc" title="14.8.4&nbsp;Configuring the Memory Allocator for InnoDB">Section&nbsp;14.8.4, “Configuring the Memory Allocator for InnoDB”</a>.
                </p><p style="color:blue;">此变量与innodb内部内存分配器相关，如果启用innodb_use_sys_malloc，则该分配器将不使用。有关更多信息，请参阅14.8.4节，“为InnoDB配置内存分配器”。</p></li><li class="listitem"><p><a name="sysvar_innodb_api_bk_commit_interval"></a>
                <a class="indexterm" name="idm140286814640240"></a>

                <code class="literal">innodb_api_bk_commit_interval</code>
            </p><p style="color:blue;">innodb_api_bk_commit_间隔</p>
                <div class="informaltable">
                    <table frame="box" rules="all" summary="Properties for innodb_api_bk_commit_interval"><colgroup><col width="30%"><col width="70%"></colgroup><thead><tr><th scope="col">Property</th>
                        <th scope="col">Value</th>
                    </tr></thead><tbody><tr><td scope="row"><span class="bold"><strong>Command-Line Format</strong></span></td>
                        <td><code class="literal">--innodb-api-bk-commit-interval=#</code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>System Variable</strong></span></td>
                        <td><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_api_bk_commit_interval">innodb_api_bk_commit_interval</a></code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Scope</strong></span></td>
                        <td>Global</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Dynamic</strong></span></td>
                        <td>Yes</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Type</strong></span></td>
                        <td>Integer</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Default Value</strong></span></td>
                        <td><code class="literal">5</code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Minimum Value</strong></span></td>
                        <td><code class="literal">1</code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Maximum Value</strong></span></td>
                        <td><code class="literal">1073741824</code></td>
                    </tr></tbody></table>
                </div>
                <p>
                    How often to auto-commit idle connections that use the
                    <code class="literal">InnoDB</code> <span class="command"><strong>memcached</strong></span>
                    interface, in seconds. For more information, see
                    <a class="xref" href="innodb-storage-engine.html#innodb-memcached-txn" title="14.20.5.4&nbsp;Controlling Transactional Behavior of the InnoDB memcached Plugin">Section&nbsp;14.20.5.4, “Controlling Transactional Behavior of the InnoDB memcached Plugin”</a>.
                </p><p style="color:blue;">自动提交使用innodb memcached接口的空闲连接的频率（秒）。有关更多信息，请参阅14.20.5.4节，“控制innodb memcached插件的事务行为”。</p></li><li class="listitem"><p><a name="sysvar_innodb_api_disable_rowlock"></a>
                <a class="indexterm" name="idm140286814604560"></a>

                <code class="literal">innodb_api_disable_rowlock</code>
            </p><p style="color:blue;">innodb_api_disable_rowlock</p>
                <div class="informaltable">
                    <table frame="box" rules="all" summary="Properties for innodb_api_disable_rowlock"><colgroup><col width="30%"><col width="70%"></colgroup><thead><tr><th scope="col">Property</th>
                        <th scope="col">Value</th>
                    </tr></thead><tbody><tr><td scope="row"><span class="bold"><strong>Command-Line Format</strong></span></td>
                        <td><code class="literal">--innodb-api-disable-rowlock[={OFF|ON}]</code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>System Variable</strong></span></td>
                        <td><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_api_disable_rowlock">innodb_api_disable_rowlock</a></code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Scope</strong></span></td>
                        <td>Global</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Dynamic</strong></span></td>
                        <td>No</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Type</strong></span></td>
                        <td>Boolean</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Default Value</strong></span></td>
                        <td><code class="literal">OFF</code></td>
                    </tr></tbody></table>
                </div>
                <p>
                    Use this option to disable row locks when
                    <code class="literal">InnoDB</code> <span class="command"><strong>memcached</strong></span>
                    performs DML operations. By default,
                    <code class="literal">innodb_api_disable_rowlock</code> is disabled,
                    which means that <span class="command"><strong>memcached</strong></span> requests row
                    locks for <code class="literal">get</code> and <code class="literal">set</code>
                    operations. When <code class="literal">innodb_api_disable_rowlock</code>
                    is enabled, <span class="command"><strong>memcached</strong></span> requests a table lock
                    instead of row locks.
                </p><p style="color:blue;">当innodb memcached执行dml操作时，使用此选项禁用行锁。默认情况下，innodb_api_disable_rowlock被禁用，这意味着memcached为get和set操作请求行锁。当启用innodb_api_disable_row lock时，memcached请求表锁而不是行锁。</p><p>
                    <code class="literal">innodb_api_disable_rowlock</code> is not dynamic.
                    It must be specified on the <a class="link" href="programs.html#mysqld" title="4.3.1&nbsp;mysqld — The MySQL Server"><span class="command"><strong>mysqld</strong></span></a> command
                    line or entered in the MySQL configuration file. Configuration
                    takes effect when the plugin is installed, which occurs when
                    the MySQL server is started.
                </p><p style="color:blue;">innodb_api_disable_rowlock不是动态的。必须在mysqld命令行中指定或在mysql配置文件中输入。配置在安装插件时生效，这在mysql服务器启动时发生。</p><p>
                    For more information, see
                    <a class="xref" href="innodb-storage-engine.html#innodb-memcached-txn" title="14.20.5.4&nbsp;Controlling Transactional Behavior of the InnoDB memcached Plugin">Section&nbsp;14.20.5.4, “Controlling Transactional Behavior of the InnoDB memcached Plugin”</a>.
                </p><p style="color:blue;">有关更多信息，请参阅14.20.5.4节，“控制innodb memcached插件的事务行为”。</p></li><li class="listitem"><p><a name="sysvar_innodb_api_enable_binlog"></a>
                <a class="indexterm" name="idm140286814567728"></a>

                <code class="literal">innodb_api_enable_binlog</code>
            </p><p style="color:blue;">innodb_api_enable_binlog</p>
                <div class="informaltable">
                    <table frame="box" rules="all" summary="Properties for innodb_api_enable_binlog"><colgroup><col width="30%"><col width="70%"></colgroup><thead><tr><th scope="col">Property</th>
                        <th scope="col">Value</th>
                    </tr></thead><tbody><tr><td scope="row"><span class="bold"><strong>Command-Line Format</strong></span></td>
                        <td><code class="literal">--innodb-api-enable-binlog[={OFF|ON}]</code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>System Variable</strong></span></td>
                        <td><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_api_enable_binlog">innodb_api_enable_binlog</a></code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Scope</strong></span></td>
                        <td>Global</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Dynamic</strong></span></td>
                        <td>No</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Type</strong></span></td>
                        <td>Boolean</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Default Value</strong></span></td>
                        <td><code class="literal">OFF</code></td>
                    </tr></tbody></table>
                </div>
                <p>
                    Lets you use the <code class="literal">InnoDB</code>
                    <span class="command"><strong>memcached</strong></span> plugin with the MySQL
                    <a class="link" href="glossary.html#glos_binary_log" title="binary log">binary log</a>. For more
                    information, see
                    <a class="xref" href="innodb-storage-engine.html#innodb-memcached-replication-enable-binlog" title="Enabling the InnoDB memcached Binary Log">Enabling the InnoDB memcached Binary Log</a>.
                </p><p style="color:blue;">允许您在mysql二进制日志中使用innodb memcached插件。有关更多信息，请参阅启用innodb memcached二进制日志。</p></li><li class="listitem"><p><a name="sysvar_innodb_api_enable_mdl"></a>
                <a class="indexterm" name="idm140286814537344"></a>

                <code class="literal">innodb_api_enable_mdl</code>
            </p><p style="color:blue;">InnoDB_API_启用</p>
                <div class="informaltable">
                    <table frame="box" rules="all" summary="Properties for innodb_api_enable_mdl"><colgroup><col width="30%"><col width="70%"></colgroup><thead><tr><th scope="col">Property</th>
                        <th scope="col">Value</th>
                    </tr></thead><tbody><tr><td scope="row"><span class="bold"><strong>Command-Line Format</strong></span></td>
                        <td><code class="literal">--innodb-api-enable-mdl[={OFF|ON}]</code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>System Variable</strong></span></td>
                        <td><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_api_enable_mdl">innodb_api_enable_mdl</a></code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Scope</strong></span></td>
                        <td>Global</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Dynamic</strong></span></td>
                        <td>No</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Type</strong></span></td>
                        <td>Boolean</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Default Value</strong></span></td>
                        <td><code class="literal">OFF</code></td>
                    </tr></tbody></table>
                </div>
                <p>
                    Locks the table used by the <code class="literal">InnoDB</code>
                    <span class="command"><strong>memcached</strong></span> plugin, so that it cannot be
                    dropped or altered by <a class="link" href="glossary.html#glos_ddl" title="DDL">DDL</a>
                    through the SQL interface. For more information, see
                    <a class="xref" href="innodb-storage-engine.html#innodb-memcached-txn" title="14.20.5.4&nbsp;Controlling Transactional Behavior of the InnoDB memcached Plugin">Section&nbsp;14.20.5.4, “Controlling Transactional Behavior of the InnoDB memcached Plugin”</a>.
                </p><p style="color:blue;">锁定innodb memcached插件使用的表，这样ddl就不能通过sql接口删除或更改它。有关更多信息，请参阅14.20.5.4节，“控制innodb memcached插件的事务行为”。</p></li><li class="listitem"><p><a name="sysvar_innodb_api_trx_level"></a>
                <a class="indexterm" name="idm140286814506992"></a>

                <code class="literal">innodb_api_trx_level</code>
            </p><p style="color:blue;">innodb_api_trx_级</p>
                <div class="informaltable">
                    <table frame="box" rules="all" summary="Properties for innodb_api_trx_level"><colgroup><col width="30%"><col width="70%"></colgroup><thead><tr><th scope="col">Property</th>
                        <th scope="col">Value</th>
                    </tr></thead><tbody><tr><td scope="row"><span class="bold"><strong>Command-Line Format</strong></span></td>
                        <td><code class="literal">--innodb-api-trx-level=#</code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>System Variable</strong></span></td>
                        <td><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_api_trx_level">innodb_api_trx_level</a></code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Scope</strong></span></td>
                        <td>Global</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Dynamic</strong></span></td>
                        <td>Yes</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Type</strong></span></td>
                        <td>Integer</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Default Value</strong></span></td>
                        <td><code class="literal">0</code></td>
                    </tr></tbody></table>
                </div>
                <p>
                    Controls the transaction
                    <a class="link" href="glossary.html#glos_isolation_level" title="isolation level">isolation level</a> on
                    queries processed by the <span class="command"><strong>memcached</strong></span>
                    interface. The constants corresponding to the familiar names
                    are:
                </p><p style="color:blue;">控制由memcached接口处理的查询的事务隔离级别。与熟悉的名称对应的常量是：</p>
                <div class="itemizedlist">
                    <ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
                        0 = <a class="link" href="innodb-storage-engine.html#isolevel_read-uncommitted"><code class="literal">READ UNCOMMITTED</code></a>
                    </p><p style="color:blue;">0=读取未提交</p></li><li class="listitem"><p>
                        1 = <a class="link" href="innodb-storage-engine.html#isolevel_read-committed"><code class="literal">READ COMMITTED</code></a>
                    </p><p style="color:blue;">1=读取已提交</p></li><li class="listitem"><p>
                        2 = <a class="link" href="innodb-storage-engine.html#isolevel_repeatable-read"><code class="literal">REPEATABLE READ</code></a>
                    </p><p style="color:blue;">2=可重复读取</p></li><li class="listitem"><p>
                        3 = <a class="link" href="innodb-storage-engine.html#isolevel_serializable"><code class="literal">SERIALIZABLE</code></a>
                    </p><p style="color:blue;">3=可序列化</p></li></ul>
                </div>
                <p>
                    For more information, see
                    <a class="xref" href="innodb-storage-engine.html#innodb-memcached-txn" title="14.20.5.4&nbsp;Controlling Transactional Behavior of the InnoDB memcached Plugin">Section&nbsp;14.20.5.4, “Controlling Transactional Behavior of the InnoDB memcached Plugin”</a>.
                </p><p style="color:blue;">有关更多信息，请参阅14.20.5.4节，“控制innodb memcached插件的事务行为”。</p></li><li class="listitem"><p><a name="sysvar_innodb_autoextend_increment"></a>
                <a class="indexterm" name="idm140286814468576"></a>

                <a class="indexterm" name="idm140286814467472"></a>

                <code class="literal">innodb_autoextend_increment</code>
            </p><p style="color:blue;">innodb_autoextend_增量</p>
                <div class="informaltable">
                    <table frame="box" rules="all" summary="Properties for innodb_autoextend_increment"><colgroup><col width="30%"><col width="70%"></colgroup><thead><tr><th scope="col">Property</th>
                        <th scope="col">Value</th>
                    </tr></thead><tbody><tr><td scope="row"><span class="bold"><strong>Command-Line Format</strong></span></td>
                        <td><code class="literal">--innodb-autoextend-increment=#</code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>System Variable</strong></span></td>
                        <td><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_autoextend_increment">innodb_autoextend_increment</a></code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Scope</strong></span></td>
                        <td>Global</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Dynamic</strong></span></td>
                        <td>Yes</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Type</strong></span></td>
                        <td>Integer</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Default Value</strong></span></td>
                        <td><code class="literal">64</code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Minimum Value</strong></span></td>
                        <td><code class="literal">1</code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Maximum Value</strong></span></td>
                        <td><code class="literal">1000</code></td>
                    </tr></tbody></table>
                </div>
                <p>
                    The increment size (in megabytes) for extending the size of an
                    auto-extending <code class="literal">InnoDB</code>
                    <a class="link" href="glossary.html#glos_system_tablespace" title="system tablespace">system
                        tablespace</a> file when it becomes full. The default value
                    is 64. For related information, see
                    <a class="xref" href="innodb-storage-engine.html#innodb-startup-data-file-configuration" title="System Tablespace Data File Configuration">System Tablespace Data File Configuration</a>, and
                    <a class="xref" href="innodb-storage-engine.html#innodb-resize-system-tablespace" title="Resizing the System Tablespace">Resizing the System Tablespace</a>.
                </p><p style="color:blue;">当一个自动扩展的innodb系统表空间文件变满时，用来扩展它的大小的增量（以兆字节为单位）。默认值为64。有关相关信息，请参阅系统表空间数据文件配置和调整系统表空间大小。</p><p>
                    The
                    <a class="link" href="innodb-storage-engine.html#sysvar_innodb_autoextend_increment"><code class="literal">innodb_autoextend_increment</code></a>
                    setting does not affect
                    <a class="link" href="glossary.html#glos_file_per_table" title="file-per-table">file-per-table</a>
                    tablespace files or
                    <a class="link" href="glossary.html#glos_general_tablespace" title="general tablespace">general
                        tablespace</a> files. These files are auto-extending
                    regardless of the
                    <a class="link" href="innodb-storage-engine.html#sysvar_innodb_autoextend_increment"><code class="literal">innodb_autoextend_increment</code></a>
                    setting. The initial extensions are by small amounts, after
                    which extensions occur in increments of 4MB.
                </p><p style="color:blue;">innodb_autoextend_increment设置不影响每个表的文件表空间文件或常规表空间文件。无论innodb_autoextend_增量设置如何，这些文件都是自动扩展的。最初的扩展是少量的，之后扩展以4MB的增量出现。</p></li><li class="listitem"><p><a name="sysvar_innodb_autoinc_lock_mode"></a>
                <a class="indexterm" name="idm140286814425680"></a>

                <a class="indexterm" name="idm140286814424576"></a>

                <code class="literal">innodb_autoinc_lock_mode</code>
            </p><p style="color:blue;">InnoDB_Autoinc_Lock_模式</p>
                <div class="informaltable">
                    <table frame="box" rules="all" summary="Properties for innodb_autoinc_lock_mode"><colgroup><col width="30%"><col width="70%"></colgroup><thead><tr><th scope="col">Property</th>
                        <th scope="col">Value</th>
                    </tr></thead><tbody><tr><td scope="row"><span class="bold"><strong>Command-Line Format</strong></span></td>
                        <td><code class="literal">--innodb-autoinc-lock-mode=#</code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>System Variable</strong></span></td>
                        <td><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_autoinc_lock_mode">innodb_autoinc_lock_mode</a></code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Scope</strong></span></td>
                        <td>Global</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Dynamic</strong></span></td>
                        <td>No</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Type</strong></span></td>
                        <td>Integer</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Default Value</strong></span></td>
                        <td><code class="literal">1</code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Valid Values</strong></span></td>
                        <td><p class="valid-value"><code class="literal">0</code></p><p style="color:blue;">0个</p><p class="valid-value"><code class="literal">1</code></p><p style="color:blue;">1个</p><p class="valid-value"><code class="literal">2</code></p><p style="color:blue;">二</p></td>
                    </tr></tbody></table>
                </div>
                <p>
                    The <a class="link" href="glossary.html#glos_lock_mode" title="lock mode">lock mode</a> to use for
                    generating
                    <a class="link" href="glossary.html#glos_auto_increment" title="auto-increment">auto-increment</a>
                    values. Permissible values are 0, 1, or 2, for traditional,
                    consecutive, or interleaved, respectively. The default setting
                    is 1 (consecutive). For the characteristics of each lock mode,
                    see <a class="xref" href="innodb-storage-engine.html#innodb-auto-increment-lock-modes" title="InnoDB AUTO_INCREMENT Lock Modes">InnoDB AUTO_INCREMENT Lock Modes</a>.
                </p><p style="color:blue;">用于生成自动增量值的锁定模式。对于传统、连续或交错，允许值分别为0、1或2。默认设置为1（连续）。关于每个锁定模式的特性，请参见innodb auto_increment lock modes。</p></li><li class="listitem"><p><a name="sysvar_innodb_background_drop_list_empty"></a>
                <a class="indexterm" name="idm140286814388768"></a>

                <a class="indexterm" name="idm140286814387728"></a>

                <code class="literal">innodb_background_drop_list_empty</code>
            </p><p style="color:blue;">innodb_background_drop_list_空</p>
                <div class="informaltable">
                    <table frame="box" rules="all" summary="Properties for innodb_background_drop_list_empty"><colgroup><col width="30%"><col width="70%"></colgroup><thead><tr><th scope="col">Property</th>
                        <th scope="col">Value</th>
                    </tr></thead><tbody><tr><td scope="row"><span class="bold"><strong>Command-Line Format</strong></span></td>
                        <td><code class="literal">--innodb-background-drop-list-empty[={OFF|ON}]</code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Introduced</strong></span></td>
                        <td>5.7.10</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>System Variable</strong></span></td>
                        <td><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_background_drop_list_empty">innodb_background_drop_list_empty</a></code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Scope</strong></span></td>
                        <td>Global</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Dynamic</strong></span></td>
                        <td>Yes</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Type</strong></span></td>
                        <td>Boolean</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Default Value</strong></span></td>
                        <td><code class="literal">OFF</code></td>
                    </tr></tbody></table>
                </div>
                <p>
                    Enabling the
                    <code class="literal">innodb_background_drop_list_empty</code> debug
                    option helps avoid test case failures by delaying table
                    creation until the background drop list is empty. For example,
                    if test case A places table <code class="literal">t1</code> on the
                    background drop list, test case B waits until the background
                    drop list is empty before creating table
                    <code class="literal">t1</code>.
                </p><p style="color:blue;">启用innodb_background_drop_list_empty debug选项可以延迟表的创建，直到background drop list为空，从而避免测试用例失败。例如，如果测试用例A将表T1放在后台下拉列表中，则测试用例B将在创建表T1之前等待后台下拉列表为空。</p></li><li class="listitem"><p><a name="sysvar_innodb_buffer_pool_chunk_size"></a>
                <a class="indexterm" name="idm140286814354928"></a>

                <a class="indexterm" name="idm140286814353824"></a>

                <code class="literal">innodb_buffer_pool_chunk_size</code>
            </p><p style="color:blue;">innodb_buffer_pool_chunk_大小</p>
                <div class="informaltable">
                    <table frame="box" rules="all" summary="Properties for innodb_buffer_pool_chunk_size"><colgroup><col width="30%"><col width="70%"></colgroup><thead><tr><th scope="col">Property</th>
                        <th scope="col">Value</th>
                    </tr></thead><tbody><tr><td scope="row"><span class="bold"><strong>Command-Line Format</strong></span></td>
                        <td><code class="literal">--innodb-buffer-pool-chunk-size=#</code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Introduced</strong></span></td>
                        <td>5.7.5</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>System Variable</strong></span></td>
                        <td><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_buffer_pool_chunk_size">innodb_buffer_pool_chunk_size</a></code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Scope</strong></span></td>
                        <td>Global</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Dynamic</strong></span></td>
                        <td>No</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Type</strong></span></td>
                        <td>Integer</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Default Value</strong></span></td>
                        <td><code class="literal">134217728</code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Minimum Value</strong></span></td>
                        <td><code class="literal">1048576</code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Maximum Value</strong></span></td>
                        <td><code class="literal">innodb_buffer_pool_size / innodb_buffer_pool_instances</code></td>
                    </tr></tbody></table>
                </div>
                <p>
                    <code class="literal">innodb_buffer_pool_chunk_size</code> defines the
                    chunk size for <code class="literal">InnoDB</code> buffer pool resizing
                    operations. The
                    <a class="link" href="innodb-storage-engine.html#sysvar_innodb_buffer_pool_size"><code class="literal">innodb_buffer_pool_size</code></a>
                    parameter is dynamic, which allows you to resize the buffer
                    pool without restarting the server.
                </p><p style="color:blue;">innodb_buffer_pool_chunk_size定义innodb缓冲池大小调整操作的块大小。innodb_buffer_pool_size参数是动态的，它允许您在不重新启动服务器的情况下调整缓冲池的大小。</p><p>
                    To avoid copying all buffer pool pages during resizing
                    operations, the operation is performed in
                    <span class="quote">“<span class="quote">chunks</span>”</span>. By default,
                    <code class="literal">innodb_buffer_pool_chunk_size</code> is 128MB
                    (134217728 bytes). The number of pages contained in a chunk
                    depends on the value of
                    <a class="link" href="innodb-storage-engine.html#sysvar_innodb_page_size"><code class="literal">innodb_page_size</code></a>.
                    <code class="literal">innodb_buffer_pool_chunk_size</code> can be
                    increased or decreased in units of 1MB (1048576 bytes).
                </p><p style="color:blue;">为了避免在调整大小操作期间复制所有缓冲池页，该操作将在“块”中执行。默认情况下，innodb_buffer_pool_chunk_size为128MB（134217728 bytes）。块中包含的页数取决于innodb_page_size的值。innodb_buffer_pool_chunk_size可以以1MB（1048576字节）为单位增加或减少。</p><p>
                    The following conditions apply when altering the
                    <a class="link" href="innodb-storage-engine.html#sysvar_innodb_buffer_pool_chunk_size"><code class="literal">innodb_buffer_pool_chunk_size</code></a>
                    value:
                </p><p style="color:blue;">更改innodb_buffer_pool_chunk_size值时适用以下条件：</p>
                <div class="itemizedlist">
                    <ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
                        If <a class="link" href="innodb-storage-engine.html#sysvar_innodb_buffer_pool_chunk_size"><code class="literal">
                        innodb_buffer_pool_chunk_size</code></a> *
                        <a class="link" href="innodb-storage-engine.html#sysvar_innodb_buffer_pool_instances"><code class="literal">innodb_buffer_pool_instances</code></a>
                        is larger than the current buffer pool size when the
                        buffer pool is initialized,
                        <a class="link" href="innodb-storage-engine.html#sysvar_innodb_buffer_pool_chunk_size"><code class="literal">innodb_buffer_pool_chunk_size</code></a>
                        is truncated to
                        <a class="link" href="innodb-storage-engine.html#sysvar_innodb_buffer_pool_size"><code class="literal">innodb_buffer_pool_size</code></a> /
                        <a class="link" href="innodb-storage-engine.html#sysvar_innodb_buffer_pool_instances"><code class="literal">innodb_buffer_pool_instances</code></a>.
                    </p><p style="color:blue;">如果初始化缓冲池时innodb_buffer_pool_chunk_size*innodb_buffer_pool_instances大于当前缓冲池大小，则innodb_buffer_pool_chunk_size将被截断为innodb_buffer_pool_size/innodb_buffer_pool_instances。</p></li><li class="listitem"><p>
                        Buffer pool size must always be equal to or a multiple of
                        <a class="link" href="innodb-storage-engine.html#sysvar_innodb_buffer_pool_chunk_size"><code class="literal">innodb_buffer_pool_chunk_size</code></a>
                        *
                        <a class="link" href="innodb-storage-engine.html#sysvar_innodb_buffer_pool_instances"><code class="literal">innodb_buffer_pool_instances</code></a>.
                        If you alter
                        <a class="link" href="innodb-storage-engine.html#sysvar_innodb_buffer_pool_chunk_size"><code class="literal">innodb_buffer_pool_chunk_size</code></a>,
                        <a class="link" href="innodb-storage-engine.html#sysvar_innodb_buffer_pool_size"><code class="literal">innodb_buffer_pool_size</code></a>
                        is automatically rounded to a value that is equal to or a
                        multiple of
                        <a class="link" href="innodb-storage-engine.html#sysvar_innodb_buffer_pool_chunk_size"><code class="literal">innodb_buffer_pool_chunk_size</code></a>
                        *
                        <a class="link" href="innodb-storage-engine.html#sysvar_innodb_buffer_pool_instances"><code class="literal">innodb_buffer_pool_instances</code></a>.
                        The adjustment occurs when the buffer pool is initialized.
                    </p><p style="color:blue;">缓冲池大小必须始终等于或是innodb_buffer_pool_chunk_size*innodb_buffer_pool_instances的倍数。如果更改innodb_buffer_pool_chunk_大小，innodb_buffer_pool_大小将自动舍入为等于或是innodb_buffer_pool_chunk_大小*innodb_buffer_pool_实例的倍数的值。在初始化缓冲池时进行调整。</p></li></ul>
                </div>
                <div class="important" style="margin-left: 0.5in; margin-right: 0.5in;">
                    <div class="admon-title">
                        Important
                    </div>
                    <p>
                        Care should be taken when changing
                        <a class="link" href="innodb-storage-engine.html#sysvar_innodb_buffer_pool_chunk_size"><code class="literal">innodb_buffer_pool_chunk_size</code></a>,
                        as changing this value can automatically increase the size
                        of the buffer pool. Before changing
                        <a class="link" href="innodb-storage-engine.html#sysvar_innodb_buffer_pool_chunk_size"><code class="literal">innodb_buffer_pool_chunk_size</code></a>,
                        calculate the effect it will have on
                        <a class="link" href="innodb-storage-engine.html#sysvar_innodb_buffer_pool_size"><code class="literal">innodb_buffer_pool_size</code></a> to
                        ensure that the resulting buffer pool size is acceptable.
                    </p><p style="color:blue;">更改innodb_buffer_pool_chunk_size时应小心，因为更改此值会自动增加缓冲池的大小。在更改innodb_buffer_pool_chunk_大小之前，请计算它对innodb_buffer_pool_大小的影响，以确保生成的缓冲池大小是可接受的。</p>
                </div>
                <p>
                    To avoid potential performance issues, the number of chunks
                    (<a class="link" href="innodb-storage-engine.html#sysvar_innodb_buffer_pool_size"><code class="literal">innodb_buffer_pool_size</code></a> /
                    <a class="link" href="innodb-storage-engine.html#sysvar_innodb_buffer_pool_chunk_size"><code class="literal">innodb_buffer_pool_chunk_size</code></a>)
                    should not exceed 1000.
                </p><p style="color:blue;">为了避免潜在的性能问题，块的数量（innodb_buffer_pool_size/innodb_buffer_pool_chunk_size）不应超过1000。</p><p>
                    See <a class="xref" href="innodb-storage-engine.html#innodb-buffer-pool-resize" title="14.8.3.1&nbsp;Configuring InnoDB Buffer Pool Size">Section&nbsp;14.8.3.1, “Configuring InnoDB Buffer Pool Size”</a> for more
                    information.
                </p><p style="color:blue;">有关更多信息，请参阅第14.8.3.1节“配置InnoDB缓冲池大小”。</p></li><li class="listitem"><p><a name="sysvar_innodb_buffer_pool_dump_at_shutdown"></a>
                <a class="indexterm" name="idm140286814283088"></a>

                <code class="literal">innodb_buffer_pool_dump_at_shutdown</code>
            </p><p style="color:blue;">innodb_buffer_pool_dump_at_关机</p>
                <div class="informaltable">
                    <table frame="box" rules="all" summary="Properties for innodb_buffer_pool_dump_at_shutdown"><colgroup><col width="30%"><col width="70%"></colgroup><thead><tr><th scope="col">Property</th>
                        <th scope="col">Value</th>
                    </tr></thead><tbody><tr><td scope="row"><span class="bold"><strong>Command-Line Format</strong></span></td>
                        <td><code class="literal">--innodb-buffer-pool-dump-at-shutdown[={OFF|ON}]</code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>System Variable</strong></span></td>
                        <td><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_buffer_pool_dump_at_shutdown">innodb_buffer_pool_dump_at_shutdown</a></code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Scope</strong></span></td>
                        <td>Global</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Dynamic</strong></span></td>
                        <td>Yes</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Type</strong></span></td>
                        <td>Boolean</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Default Value</strong></span> (&gt;= 5.7.7)</td>
                        <td><code class="literal">ON</code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Default Value</strong></span> (&lt;= 5.7.6)</td>
                        <td><code class="literal">OFF</code></td>
                    </tr></tbody></table>
                </div>
                <p>
                    Specifies whether to record the pages cached in the
                    <code class="literal">InnoDB</code>
                    <a class="link" href="glossary.html#glos_buffer_pool" title="buffer pool">buffer pool</a> when the
                    MySQL server is shut down, to shorten the
                    <a class="link" href="glossary.html#glos_warm_up" title="warm up">warmup</a> process at the next
                    restart. Typically used in combination with
                    <a class="link" href="innodb-storage-engine.html#sysvar_innodb_buffer_pool_load_at_startup"><code class="literal">innodb_buffer_pool_load_at_startup</code></a>.
                    The
                    <a class="link" href="innodb-storage-engine.html#sysvar_innodb_buffer_pool_dump_pct"><code class="literal">innodb_buffer_pool_dump_pct</code></a>
                    option defines the percentage of most recently used buffer
                    pool pages to dump.
                </p><p style="color:blue;">指定在mysql服务器关闭时是否记录缓存在innodb缓冲池中的页面，以便在下次重新启动时缩短预热过程。通常与innodb_buffer_pool_load_at_startup结合使用。innodb_buffer_pool_dump_pct选项定义要转储的最近使用的缓冲池页面的百分比。</p><p>
                    Both
                    <a class="link" href="innodb-storage-engine.html#sysvar_innodb_buffer_pool_dump_at_shutdown"><code class="literal">innodb_buffer_pool_dump_at_shutdown</code></a>
                    and <code class="literal">innodb_buffer_pool_load_at_startup</code> are
                    enabled by default.
                </p><p style="color:blue;">默认情况下，innodb_buffer_pool_dump_at_shutdown和innodb_buffer_pool_load_at_startup都启用。</p><p>
                    For more information, see
                    <a class="xref" href="innodb-storage-engine.html#innodb-preload-buffer-pool" title="14.8.3.6&nbsp;Saving and Restoring the Buffer Pool State">Section&nbsp;14.8.3.6, “Saving and Restoring the Buffer Pool State”</a>.
                </p><p style="color:blue;">有关更多信息，请参阅第14.8.3.6节“保存和还原缓冲池状态”。</p></li><li class="listitem"><p><a name="sysvar_innodb_buffer_pool_dump_now"></a>
                <a class="indexterm" name="idm140286814243552"></a>

                <code class="literal">innodb_buffer_pool_dump_now</code>
            </p><p style="color:blue;">innodb_buffer_pool_dump_现在</p>
                <div class="informaltable">
                    <table frame="box" rules="all" summary="Properties for innodb_buffer_pool_dump_now"><colgroup><col width="30%"><col width="70%"></colgroup><thead><tr><th scope="col">Property</th>
                        <th scope="col">Value</th>
                    </tr></thead><tbody><tr><td scope="row"><span class="bold"><strong>Command-Line Format</strong></span></td>
                        <td><code class="literal">--innodb-buffer-pool-dump-now[={OFF|ON}]</code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>System Variable</strong></span></td>
                        <td><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_buffer_pool_dump_now">innodb_buffer_pool_dump_now</a></code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Scope</strong></span></td>
                        <td>Global</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Dynamic</strong></span></td>
                        <td>Yes</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Type</strong></span></td>
                        <td>Boolean</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Default Value</strong></span></td>
                        <td><code class="literal">OFF</code></td>
                    </tr></tbody></table>
                </div>
                <p>
                    Immediately records the pages cached in the
                    <code class="literal">InnoDB</code>
                    <a class="link" href="glossary.html#glos_buffer_pool" title="buffer pool">buffer pool</a>. Typically
                    used in combination with
                    <a class="link" href="innodb-storage-engine.html#sysvar_innodb_buffer_pool_load_now"><code class="literal">innodb_buffer_pool_load_now</code></a>.
                </p><p style="color:blue;">立即记录缓存在innodb缓冲池中的页面。现在通常与innodb_buffer_pool_load_结合使用。</p><p>
                    For more information, see
                    <a class="xref" href="innodb-storage-engine.html#innodb-preload-buffer-pool" title="14.8.3.6&nbsp;Saving and Restoring the Buffer Pool State">Section&nbsp;14.8.3.6, “Saving and Restoring the Buffer Pool State”</a>.
                </p><p style="color:blue;">有关更多信息，请参阅第14.8.3.6节“保存和还原缓冲池状态”。</p></li><li class="listitem"><p><a name="sysvar_innodb_buffer_pool_dump_pct"></a>
                <a class="indexterm" name="idm140286814212256"></a>

                <code class="literal">innodb_buffer_pool_dump_pct</code>
            </p><p style="color:blue;">InnoDB_缓冲池转储PCT</p>
                <div class="informaltable">
                    <table frame="box" rules="all" summary="Properties for innodb_buffer_pool_dump_pct"><colgroup><col width="30%"><col width="70%"></colgroup><thead><tr><th scope="col">Property</th>
                        <th scope="col">Value</th>
                    </tr></thead><tbody><tr><td scope="row"><span class="bold"><strong>Command-Line Format</strong></span></td>
                        <td><code class="literal">--innodb-buffer-pool-dump-pct=#</code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Introduced</strong></span></td>
                        <td>5.7.2</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>System Variable</strong></span></td>
                        <td><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_buffer_pool_dump_pct">innodb_buffer_pool_dump_pct</a></code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Scope</strong></span></td>
                        <td>Global</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Dynamic</strong></span></td>
                        <td>Yes</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Type</strong></span></td>
                        <td>Integer</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Default Value</strong></span> (&gt;= 5.7.7)</td>
                        <td><code class="literal">25</code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Default Value</strong></span> (&lt;= 5.7.6)</td>
                        <td><code class="literal">100</code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Minimum Value</strong></span></td>
                        <td><code class="literal">1</code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Maximum Value</strong></span></td>
                        <td><code class="literal">100</code></td>
                    </tr></tbody></table>
                </div>
                <p>
                    Specifies the percentage of the most recently used pages for
                    each buffer pool to read out and dump. The range is 1 to 100.
                    The default value is 25. For example, if there are 4 buffer
                    pools with 100 pages each, and
                    <a class="link" href="innodb-storage-engine.html#sysvar_innodb_buffer_pool_dump_pct"><code class="literal">innodb_buffer_pool_dump_pct</code></a>
                    is set to 25, the 25 most recently used pages from each buffer
                    pool are dumped.
                </p><p style="color:blue;">指定每个缓冲池要读取和转储的最近使用的页的百分比。范围是1到100。默认值为25。例如，如果有4个缓冲池，每个缓冲池有100个页面，并且innodb_buffer_pool_dump_pct设置为25，那么每个缓冲池中最近使用的25个页面将被转储。</p><p>
                    The change to the
                    <a class="link" href="innodb-storage-engine.html#sysvar_innodb_buffer_pool_dump_pct"><code class="literal">innodb_buffer_pool_dump_pct</code></a>
                    default value coincides with default value changes for
                    <a class="link" href="innodb-storage-engine.html#sysvar_innodb_buffer_pool_dump_at_shutdown"><code class="literal">innodb_buffer_pool_dump_at_shutdown</code></a>
                    and
                    <a class="link" href="innodb-storage-engine.html#sysvar_innodb_buffer_pool_load_at_startup"><code class="literal">innodb_buffer_pool_load_at_startup</code></a>,
                    which are both enabled by default in MySQL 5.7.
                </p><p style="color:blue;">对innodb_buffer_pool_dump_pct默认值的更改与innodb_buffer_pool_dump_at_shutdown和innodb_buffer_pool_load_at_startup的默认值更改一致，这两个默认值都在mysql 5.7中启用。</p></li><li class="listitem"><p><a name="sysvar_innodb_buffer_pool_filename"></a>
                <a class="indexterm" name="idm140286814166704"></a>

                <code class="literal">innodb_buffer_pool_filename</code>
            </p><p style="color:blue;">innodb_buffer_pool_文件名</p>
                <div class="informaltable">
                    <table frame="box" rules="all" summary="Properties for innodb_buffer_pool_filename"><colgroup><col width="30%"><col width="70%"></colgroup><thead><tr><th scope="col">Property</th>
                        <th scope="col">Value</th>
                    </tr></thead><tbody><tr><td scope="row"><span class="bold"><strong>Command-Line Format</strong></span></td>
                        <td><code class="literal">--innodb-buffer-pool-filename=file_name</code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>System Variable</strong></span></td>
                        <td><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_buffer_pool_filename">innodb_buffer_pool_filename</a></code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Scope</strong></span></td>
                        <td>Global</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Dynamic</strong></span></td>
                        <td>Yes</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Type</strong></span></td>
                        <td>File name</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Default Value</strong></span></td>
                        <td><code class="literal">ib_buffer_pool</code></td>
                    </tr></tbody></table>
                </div>
                <p>
                    Specifies the name of the file that holds the list of
                    tablespace IDs and page IDs produced by
                    <a class="link" href="innodb-storage-engine.html#sysvar_innodb_buffer_pool_dump_at_shutdown"><code class="literal">innodb_buffer_pool_dump_at_shutdown</code></a>
                    or
                    <a class="link" href="innodb-storage-engine.html#sysvar_innodb_buffer_pool_dump_now"><code class="literal">innodb_buffer_pool_dump_now</code></a>.
                    Tablespace IDs and page IDs are saved in the following format:
                    <code class="literal">space, page_id</code>. By default, the file is
                    named <code class="filename">ib_buffer_pool</code> and is located in
                    the <code class="literal">InnoDB</code> data directory. A non-default
                    location must be specified relative to the data directory.
                </p><p style="color:blue;">指定文件的名称，该文件保存innodb_buffer_pool_dump_shutdown或innodb_buffer_pool_dump_now生成的表空间id和页id列表。表空间id和页id以以下格式保存：space，page_id。默认情况下，文件名为ib_buffer_pool，位于innodb data目录中。必须指定相对于数据目录的非默认位置。</p><p>
                    A file name can be specified at runtime, using a
                    <a class="link" href="sql-syntax.html#set-variable" title="13.7.4.1&nbsp;SET Syntax for Variable Assignment"><code class="literal">SET</code></a>
                    statement:
                </p><p style="color:blue;">可以在运行时使用set语句指定文件名：</p><pre data-lang="sql" class="programlisting">SET GLOBAL innodb_buffer_pool_filename=<em class="replaceable"><code>'file_name'</code></em>;
</pre><p>
                    You can also specify a file name at startup, in a startup
                    string or MySQL configuration file. When specifying a file
                    name at startup, the file must exist or
                    <code class="literal">InnoDB</code> will return a startup error
                    indicating that there is no such file or directory.
                </p><p style="color:blue;">也可以在启动时在启动字符串或mysql配置文件中指定文件名。在启动时指定文件名时，文件必须存在，否则UnIDB将返回启动错误，指示没有此类文件或目录。</p><p>
                    For more information, see
                    <a class="xref" href="innodb-storage-engine.html#innodb-preload-buffer-pool" title="14.8.3.6&nbsp;Saving and Restoring the Buffer Pool State">Section&nbsp;14.8.3.6, “Saving and Restoring the Buffer Pool State”</a>.
                </p><p style="color:blue;">有关更多信息，请参阅第14.8.3.6节“保存和还原缓冲池状态”。</p></li><li class="listitem"><p><a name="sysvar_innodb_buffer_pool_instances"></a>
                <a class="indexterm" name="idm140286814128752"></a>

                <a class="indexterm" name="idm140286814127648"></a>

                <code class="literal">innodb_buffer_pool_instances</code>
            </p><p style="color:blue;">innodb_buffer_pool_实例</p>
                <div class="informaltable">
                    <table frame="box" rules="all" summary="Properties for innodb_buffer_pool_instances"><colgroup><col width="30%"><col width="70%"></colgroup><thead><tr><th scope="col">Property</th>
                        <th scope="col">Value</th>
                    </tr></thead><tbody><tr><td scope="row"><span class="bold"><strong>Command-Line Format</strong></span></td>
                        <td><code class="literal">--innodb-buffer-pool-instances=#</code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>System Variable</strong></span></td>
                        <td><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_buffer_pool_instances">innodb_buffer_pool_instances</a></code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Scope</strong></span></td>
                        <td>Global</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Dynamic</strong></span></td>
                        <td>No</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Type</strong></span></td>
                        <td>Integer</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Default Value</strong></span> (Other)</td>
                        <td><code class="literal">8 (or 1 if innodb_buffer_pool_size &lt; 1GB</code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Default Value</strong></span> (Windows, 32-bit platforms)</td>
                        <td><code class="literal">(autosized)</code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Minimum Value</strong></span></td>
                        <td><code class="literal">1</code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Maximum Value</strong></span></td>
                        <td><code class="literal">64</code></td>
                    </tr></tbody></table>
                </div>
                <p>
                    The number of regions that the <code class="literal">InnoDB</code>
                    <a class="link" href="glossary.html#glos_buffer_pool" title="buffer pool">buffer pool</a> is divided
                    into. For systems with buffer pools in the multi-gigabyte
                    range, dividing the buffer pool into separate instances can
                    improve concurrency, by reducing contention as different
                    threads read and write to cached pages. Each page that is
                    stored in or read from the buffer pool is assigned to one of
                    the buffer pool instances randomly, using a hashing function.
                    Each buffer pool manages its own free lists,
                    <a class="link" href="glossary.html#glos_flush_list" title="flush list">flush lists</a>,
                    <a class="link" href="glossary.html#glos_lru" title="LRU">LRUs</a>, and all other data
                    structures connected to a buffer pool, and is protected by its
                    own buffer pool <a class="link" href="glossary.html#glos_mutex" title="mutex">mutex</a>.
                </p><p style="color:blue;">InnoDB缓冲池划分的区域数。对于具有千兆字节范围的缓冲池的系统，将缓冲池划分为单独的实例可以通过减少不同线程对缓存页的读写争用来提高并发性。存储在缓冲池中或从缓冲池读取的每个页面都使用哈希函数随机分配给其中一个缓冲池实例。每个缓冲池管理自己的空闲列表、刷新列表、lru和连接到缓冲池的所有其他数据结构，并受自己的缓冲池互斥保护。</p><p>
                    This option only takes effect when setting
                    <a class="link" href="innodb-storage-engine.html#sysvar_innodb_buffer_pool_size"><code class="literal">innodb_buffer_pool_size</code></a> to
                    1GB or more. The total buffer pool size is divided among all
                    the buffer pools. For best efficiency, specify a combination
                    of
                    <a class="link" href="innodb-storage-engine.html#sysvar_innodb_buffer_pool_instances"><code class="literal">innodb_buffer_pool_instances</code></a>
                    and <a class="link" href="innodb-storage-engine.html#sysvar_innodb_buffer_pool_size"><code class="literal">innodb_buffer_pool_size</code></a>
                    so that each buffer pool instance is at least 1GB.
                </p><p style="color:blue;">此选项仅在将innodb_buffer_pool_size设置为1GB或更大时生效。总缓冲池大小在所有缓冲池中划分。为获得最佳效率，请指定innodb_buffer_pool_实例和innodb_buffer_pool_大小的组合，以便每个缓冲池实例至少为1GB。</p><p>
                    The default value on 32-bit Windows systems depends on the
                    value of
                    <a class="link" href="innodb-storage-engine.html#sysvar_innodb_buffer_pool_size"><code class="literal">innodb_buffer_pool_size</code></a>, as
                    described below:
                </p><p style="color:blue;">32位Windows系统的默认值取决于innodb_buffer_pool_size的值，如下所述：</p>
                <div class="itemizedlist">
                    <ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
                        If
                        <a class="link" href="innodb-storage-engine.html#sysvar_innodb_buffer_pool_size"><code class="literal">innodb_buffer_pool_size</code></a>
                        is greater than 1.3GB, the default for
                        <a class="link" href="innodb-storage-engine.html#sysvar_innodb_buffer_pool_instances"><code class="literal">innodb_buffer_pool_instances</code></a>
                        is
                        <a class="link" href="innodb-storage-engine.html#sysvar_innodb_buffer_pool_size"><code class="literal">innodb_buffer_pool_size</code></a>/128MB,
                        with individual memory allocation requests for each chunk.
                        1.3GB was chosen as the boundary at which there is
                        significant risk for 32-bit Windows to be unable to
                        allocate the contiguous address space needed for a single
                        buffer pool.
                    </p><p style="color:blue;">如果innodb_buffer_pool_size大于1.3gb，innodb_buffer_pool_instances的默认值是innodb_buffer_pool_size/128mb，每个块都有单独的内存分配请求。选择1.3GB作为边界，在该边界处，32位窗口可能无法分配单个缓冲池所需的连续地址空间。</p></li><li class="listitem"><p>
                        Otherwise, the default is 1.
                    </p><p style="color:blue;">否则，默认值为1。</p></li></ul>
                </div>
                <p>
                    On all other platforms, the default value is 8 when
                    <a class="link" href="innodb-storage-engine.html#sysvar_innodb_buffer_pool_size"><code class="literal">innodb_buffer_pool_size</code></a> is
                    greater than or equal to 1GB. Otherwise, the default is 1.
                </p><p style="color:blue;">在所有其他平台上，当innodb_buffer_pool_size大于或等于1gb时，默认值为8。否则，默认值为1。</p><p>
                    For related information, see
                    <a class="xref" href="innodb-storage-engine.html#innodb-buffer-pool-resize" title="14.8.3.1&nbsp;Configuring InnoDB Buffer Pool Size">Section&nbsp;14.8.3.1, “Configuring InnoDB Buffer Pool Size”</a>.
                </p><p style="color:blue;">有关信息，请参阅第14.8.3.1节“配置innodb缓冲池大小”。</p></li><li class="listitem"><p><a name="sysvar_innodb_buffer_pool_load_abort"></a>
                <a class="indexterm" name="idm140286814070176"></a>

                <code class="literal">innodb_buffer_pool_load_abort</code>
            </p><p style="color:blue;">innodb_buffer_pool_load_中止</p>
                <div class="informaltable">
                    <table frame="box" rules="all" summary="Properties for innodb_buffer_pool_load_abort"><colgroup><col width="30%"><col width="70%"></colgroup><thead><tr><th scope="col">Property</th>
                        <th scope="col">Value</th>
                    </tr></thead><tbody><tr><td scope="row"><span class="bold"><strong>Command-Line Format</strong></span></td>
                        <td><code class="literal">--innodb-buffer-pool-load-abort[={OFF|ON}]</code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>System Variable</strong></span></td>
                        <td><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_buffer_pool_load_abort">innodb_buffer_pool_load_abort</a></code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Scope</strong></span></td>
                        <td>Global</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Dynamic</strong></span></td>
                        <td>Yes</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Type</strong></span></td>
                        <td>Boolean</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Default Value</strong></span></td>
                        <td><code class="literal">OFF</code></td>
                    </tr></tbody></table>
                </div>
                <p>
                    Interrupts the process of restoring <code class="literal">InnoDB</code>
                    <a class="link" href="glossary.html#glos_buffer_pool" title="buffer pool">buffer pool</a> contents
                    triggered by
                    <a class="link" href="innodb-storage-engine.html#sysvar_innodb_buffer_pool_load_at_startup"><code class="literal">innodb_buffer_pool_load_at_startup</code></a>
                    or
                    <a class="link" href="innodb-storage-engine.html#sysvar_innodb_buffer_pool_load_now"><code class="literal">innodb_buffer_pool_load_now</code></a>.
                </p><p style="color:blue;">中断恢复innodb缓冲池内容的过程，该过程由innodb缓冲池加载在启动或innodb缓冲池加载时触发。</p><p>
                    For more information, see
                    <a class="xref" href="innodb-storage-engine.html#innodb-preload-buffer-pool" title="14.8.3.6&nbsp;Saving and Restoring the Buffer Pool State">Section&nbsp;14.8.3.6, “Saving and Restoring the Buffer Pool State”</a>.
                </p><p style="color:blue;">有关更多信息，请参阅第14.8.3.6节“保存和还原缓冲池状态”。</p></li><li class="listitem"><p><a name="sysvar_innodb_buffer_pool_load_at_startup"></a>
                <a class="indexterm" name="idm140286814037488"></a>

                <code class="literal">innodb_buffer_pool_load_at_startup</code>
            </p><p style="color:blue;">innodb_buffer_pool_load_at_启动</p>
                <div class="informaltable">
                    <table frame="box" rules="all" summary="Properties for innodb_buffer_pool_load_at_startup"><colgroup><col width="30%"><col width="70%"></colgroup><thead><tr><th scope="col">Property</th>
                        <th scope="col">Value</th>
                    </tr></thead><tbody><tr><td scope="row"><span class="bold"><strong>Command-Line Format</strong></span></td>
                        <td><code class="literal">--innodb-buffer-pool-load-at-startup[={OFF|ON}]</code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>System Variable</strong></span></td>
                        <td><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_buffer_pool_load_at_startup">innodb_buffer_pool_load_at_startup</a></code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Scope</strong></span></td>
                        <td>Global</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Dynamic</strong></span></td>
                        <td>No</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Type</strong></span></td>
                        <td>Boolean</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Default Value</strong></span> (&gt;= 5.7.7)</td>
                        <td><code class="literal">ON</code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Default Value</strong></span> (&lt;= 5.7.6)</td>
                        <td><code class="literal">OFF</code></td>
                    </tr></tbody></table>
                </div>
                <p>
                    Specifies that, on MySQL server startup, the
                    <code class="literal">InnoDB</code>
                    <a class="link" href="glossary.html#glos_buffer_pool" title="buffer pool">buffer pool</a> is
                    automatically <a class="link" href="glossary.html#glos_warm_up" title="warm up">warmed up</a> by
                    loading the same pages it held at an earlier time. Typically
                    used in combination with
                    <a class="link" href="innodb-storage-engine.html#sysvar_innodb_buffer_pool_dump_at_shutdown"><code class="literal">innodb_buffer_pool_dump_at_shutdown</code></a>.
                </p><p style="color:blue;">指定在mysql服务器启动时，innodb缓冲池通过加载之前保存的相同页面自动预热。通常与innodb_buffer_pool_dump_一起使用。</p><p>
                    Both
                    <a class="link" href="innodb-storage-engine.html#sysvar_innodb_buffer_pool_dump_at_shutdown"><code class="literal">innodb_buffer_pool_dump_at_shutdown</code></a>
                    and <code class="literal">innodb_buffer_pool_load_at_startup</code> are
                    enabled by default.
                </p><p style="color:blue;">默认情况下，innodb_buffer_pool_dump_at_shutdown和innodb_buffer_pool_load_at_startup都启用。</p><p>
                    For more information, see
                    <a class="xref" href="innodb-storage-engine.html#innodb-preload-buffer-pool" title="14.8.3.6&nbsp;Saving and Restoring the Buffer Pool State">Section&nbsp;14.8.3.6, “Saving and Restoring the Buffer Pool State”</a>.
                </p><p style="color:blue;">有关更多信息，请参阅第14.8.3.6节“保存和还原缓冲池状态”。</p></li><li class="listitem"><p><a name="sysvar_innodb_buffer_pool_load_now"></a>
                <a class="indexterm" name="idm140286813999344"></a>

                <code class="literal">innodb_buffer_pool_load_now</code>
            </p><p style="color:blue;">innodb_buffer_pool_load_现在</p>
                <div class="informaltable">
                    <table frame="box" rules="all" summary="Properties for innodb_buffer_pool_load_now"><colgroup><col width="30%"><col width="70%"></colgroup><thead><tr><th scope="col">Property</th>
                        <th scope="col">Value</th>
                    </tr></thead><tbody><tr><td scope="row"><span class="bold"><strong>Command-Line Format</strong></span></td>
                        <td><code class="literal">--innodb-buffer-pool-load-now[={OFF|ON}]</code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>System Variable</strong></span></td>
                        <td><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_buffer_pool_load_now">innodb_buffer_pool_load_now</a></code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Scope</strong></span></td>
                        <td>Global</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Dynamic</strong></span></td>
                        <td>Yes</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Type</strong></span></td>
                        <td>Boolean</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Default Value</strong></span></td>
                        <td><code class="literal">OFF</code></td>
                    </tr></tbody></table>
                </div>
                <p>
                    Immediately <a class="link" href="glossary.html#glos_warm_up" title="warm up">warms up</a> the
                    <code class="literal">InnoDB</code>
                    <a class="link" href="glossary.html#glos_buffer_pool" title="buffer pool">buffer pool</a> by loading
                    a set of data pages, without waiting for a server restart. Can
                    be useful to bring cache memory back to a known state during
                    benchmarking, or to ready the MySQL server to resume its
                    normal workload after running queries for reports or
                    maintenance.
                </p><p style="color:blue;">通过加载一组数据页立即预热innodb缓冲池，而无需等待服务器重启。在基准测试期间将缓存内存恢复到已知状态，或者在运行报表查询或维护后准备好mysql服务器恢复其正常工作负载，都是很有用的。</p><p>
                    For more information, see
                    <a class="xref" href="innodb-storage-engine.html#innodb-preload-buffer-pool" title="14.8.3.6&nbsp;Saving and Restoring the Buffer Pool State">Section&nbsp;14.8.3.6, “Saving and Restoring the Buffer Pool State”</a>.
                </p><p style="color:blue;">有关更多信息，请参阅第14.8.3.6节“保存和还原缓冲池状态”。</p></li><li class="listitem"><p><a name="sysvar_innodb_buffer_pool_size"></a>
                <a class="indexterm" name="idm140286813968352"></a>

                <a class="indexterm" name="idm140286813967312"></a>

                <code class="literal">innodb_buffer_pool_size</code>
            </p><p style="color:blue;">InnoDB_缓冲池大小</p>
                <div class="informaltable">
                    <table frame="box" rules="all" summary="Properties for innodb_buffer_pool_size"><colgroup><col width="30%"><col width="70%"></colgroup><thead><tr><th scope="col">Property</th>
                        <th scope="col">Value</th>
                    </tr></thead><tbody><tr><td scope="row"><span class="bold"><strong>Command-Line Format</strong></span></td>
                        <td><code class="literal">--innodb-buffer-pool-size=#</code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>System Variable</strong></span></td>
                        <td><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_buffer_pool_size">innodb_buffer_pool_size</a></code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Scope</strong></span></td>
                        <td>Global</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Dynamic</strong></span> (&gt;= 5.7.5)</td>
                        <td>Yes</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Dynamic</strong></span> (&lt;= 5.7.4)</td>
                        <td>No</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Type</strong></span></td>
                        <td>Integer</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Default Value</strong></span></td>
                        <td><code class="literal">134217728</code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Minimum Value</strong></span></td>
                        <td><code class="literal">5242880</code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Maximum Value</strong></span> (64-bit platforms)</td>
                        <td><code class="literal">2**64-1</code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Maximum Value</strong></span> (32-bit platforms)</td>
                        <td><code class="literal">2**32-1</code></td>
                    </tr></tbody></table>
                </div>
                <p>
                    The size in bytes of the
                    <a class="link" href="glossary.html#glos_buffer_pool" title="buffer pool">buffer pool</a>, the
                    memory area where <code class="literal">InnoDB</code> caches table and
                    index data. The default value is 134217728 bytes (128MB). The
                    maximum value depends on the CPU architecture; the maximum is
                    4294967295 (2<sup>32</sup>-1) on 32-bit
                    systems and 18446744073709551615
                    (2<sup>64</sup>-1) on 64-bit systems. On
                    32-bit systems, the CPU architecture and operating system may
                    impose a lower practical maximum size than the stated maximum.
                    When the size of the buffer pool is greater than 1GB, setting
                    <a class="link" href="innodb-storage-engine.html#sysvar_innodb_buffer_pool_instances"><code class="literal">innodb_buffer_pool_instances</code></a>
                    to a value greater than 1 can improve the scalability on a
                    busy server.
                </p><p style="color:blue;">缓冲池的字节大小，InnoDB缓存表和索引数据的内存区域。默认值为134217728字节（128MB）。最大值取决于CPU架构；32位系统上最大值为4294967295（23 2-1），在64位系统上最大值为1844 66407370955 1615（264-1）。在32位系统上，CPU体系结构和操作系统可以施加比所述最大值更低的实际最大尺寸。当缓冲池大小大于1gb时，将innodb_buffer_pool_instances设置为大于1的值可以提高繁忙服务器上的可伸缩性。</p><p>
                    A larger buffer pool requires less disk I/O to access the same
                    table data more than once. On a dedicated database server, you
                    might set the buffer pool size to 80% of the machine's
                    physical memory size. Be aware of the following potential
                    issues when configuring buffer pool size, and be prepared to
                    scale back the size of the buffer pool if necessary.
                </p><p style="color:blue;">较大的缓冲池需要较少的磁盘I/O才能多次访问同一表数据。在专用数据库服务器上，可以将缓冲池大小设置为计算机物理内存大小的80%。配置缓冲池大小时请注意以下潜在问题，并准备在必要时缩小缓冲池的大小。</p>
                <div class="itemizedlist">
                    <ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
                        Competition for physical memory can cause paging in the
                        operating system.
                    </p><p style="color:blue;">竞争物理内存可能导致操作系统中的分页。</p></li><li class="listitem"><p>
                        <code class="literal">InnoDB</code> reserves additional memory for
                        buffers and control structures, so that the total
                        allocated space is approximately 10% greater than the
                        specified buffer pool size.
                    </p><p style="color:blue;">INODB为缓冲区和控制结构保留了额外的内存，使得总分配的空间比指定的缓冲池大小大约10%。</p></li><li class="listitem"><p>
                        Address space for the buffer pool must be contiguous,
                        which can be an issue on Windows systems with DLLs that
                        load at specific addresses.
                    </p><p style="color:blue;">缓冲池的地址空间必须是连续的，这在具有在特定地址加载的dll的windows系统上可能是一个问题。</p></li><li class="listitem"><p>
                        The time to initialize the buffer pool is roughly
                        proportional to its size. On instances with large buffer
                        pools, initialization time might be significant. To reduce
                        the initialization period, you can save the buffer pool
                        state at server shutdown and restore it at server startup.
                        See <a class="xref" href="innodb-storage-engine.html#innodb-preload-buffer-pool" title="14.8.3.6&nbsp;Saving and Restoring the Buffer Pool State">Section&nbsp;14.8.3.6, “Saving and Restoring the Buffer Pool State”</a>.
                    </p><p style="color:blue;">初始化缓冲池的时间大致与其大小成正比。在具有大型缓冲池的实例上，初始化时间可能很长。要缩短初始化周期，可以在服务器关闭时保存缓冲池状态，并在服务器启动时还原它。参见第14.8.3.6节“保存和恢复缓冲池状态”。</p></li></ul>
                </div>
                <p>
                    When you increase or decrease buffer pool size, the operation
                    is performed in chunks. Chunk size is defined by the
                    <a class="link" href="innodb-storage-engine.html#sysvar_innodb_buffer_pool_chunk_size"><code class="literal">innodb_buffer_pool_chunk_size</code></a>
                    variable, which has a default of 128 MB.
                </p><p style="color:blue;">当您增加或减少缓冲池大小时，该操作将分块执行。块大小由innodb_buffer_pool_chunk_size变量定义，默认值为128 MB。</p><p>
                    Buffer pool size must always be equal to or a multiple of
                    <a class="link" href="innodb-storage-engine.html#sysvar_innodb_buffer_pool_chunk_size"><code class="literal">innodb_buffer_pool_chunk_size</code></a>
                    *
                    <a class="link" href="innodb-storage-engine.html#sysvar_innodb_buffer_pool_instances"><code class="literal">innodb_buffer_pool_instances</code></a>.
                    If you alter the buffer pool size to a value that is not equal
                    to or a multiple of
                    <a class="link" href="innodb-storage-engine.html#sysvar_innodb_buffer_pool_chunk_size"><code class="literal">innodb_buffer_pool_chunk_size</code></a>
                    *
                    <a class="link" href="innodb-storage-engine.html#sysvar_innodb_buffer_pool_instances"><code class="literal">innodb_buffer_pool_instances</code></a>,
                    buffer pool size is automatically adjusted to a value that is
                    equal to or a multiple of
                    <a class="link" href="innodb-storage-engine.html#sysvar_innodb_buffer_pool_chunk_size"><code class="literal">innodb_buffer_pool_chunk_size</code></a>
                    *
                    <a class="link" href="innodb-storage-engine.html#sysvar_innodb_buffer_pool_instances"><code class="literal">innodb_buffer_pool_instances</code></a>.
                </p><p style="color:blue;">缓冲池大小必须始终等于或是innodb_buffer_pool_chunk_size*innodb_buffer_pool_instances的倍数。如果将缓冲池大小更改为不等于或不等于innodb_buffer_pool_chunk_size*innodb_buffer_pool_instances的值，则缓冲池大小将自动调整为等于或等于innodb_buffer_pool_chunk_size*innodb_buffer_pool_instances的值。</p><p>
                    <code class="literal">innodb_buffer_pool_size</code> can be set
                    dynamically, which allows you to resize the buffer pool
                    without restarting the server. The
                    <a class="link" href="server-administration.html#statvar_Innodb_buffer_pool_resize_status"><code class="literal">Innodb_buffer_pool_resize_status</code></a>
                    status variable reports the status of online buffer pool
                    resizing operations. See
                    <a class="xref" href="innodb-storage-engine.html#innodb-buffer-pool-resize" title="14.8.3.1&nbsp;Configuring InnoDB Buffer Pool Size">Section&nbsp;14.8.3.1, “Configuring InnoDB Buffer Pool Size”</a> for more
                    information.
                </p><p style="color:blue;">innodb_buffer_pool_size可以动态设置，这允许您在不重新启动服务器的情况下调整缓冲池的大小。innodb_buffer_pool_resize_status变量报告联机缓冲池大小调整操作的状态。有关更多信息，请参阅第14.8.3.1节“配置InnoDB缓冲池大小”。</p></li><li class="listitem"><p><a name="sysvar_innodb_change_buffer_max_size"></a>
                <a class="indexterm" name="idm140286813902592"></a>

                <code class="literal">innodb_change_buffer_max_size</code>
            </p><p style="color:blue;">innodb_change_buffer_max_大小</p>
                <div class="informaltable">
                    <table frame="box" rules="all" summary="Properties for innodb_change_buffer_max_size"><colgroup><col width="30%"><col width="70%"></colgroup><thead><tr><th scope="col">Property</th>
                        <th scope="col">Value</th>
                    </tr></thead><tbody><tr><td scope="row"><span class="bold"><strong>Command-Line Format</strong></span></td>
                        <td><code class="literal">--innodb-change-buffer-max-size=#</code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>System Variable</strong></span></td>
                        <td><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_change_buffer_max_size">innodb_change_buffer_max_size</a></code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Scope</strong></span></td>
                        <td>Global</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Dynamic</strong></span></td>
                        <td>Yes</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Type</strong></span></td>
                        <td>Integer</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Default Value</strong></span></td>
                        <td><code class="literal">25</code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Minimum Value</strong></span></td>
                        <td><code class="literal">0</code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Maximum Value</strong></span></td>
                        <td><code class="literal">50</code></td>
                    </tr></tbody></table>
                </div>
                <p>
                    Maximum size for the <code class="literal">InnoDB</code>
                    <a class="link" href="glossary.html#glos_change_buffer" title="change buffer">change buffer</a>, as a
                    percentage of the total size of the
                    <a class="link" href="glossary.html#glos_buffer_pool" title="buffer pool">buffer pool</a>. You might
                    increase this value for a MySQL server with heavy insert,
                    update, and delete activity, or decrease it for a MySQL server
                    with unchanging data used for reporting. For more information,
                    see <a class="xref" href="innodb-storage-engine.html#innodb-change-buffer" title="14.5.2&nbsp;Change Buffer">Section&nbsp;14.5.2, “Change Buffer”</a>. For general I/O
                    tuning advice, see <a class="xref" href="optimization.html#optimizing-innodb-diskio" title="8.5.8&nbsp;Optimizing InnoDB Disk I/O">Section&nbsp;8.5.8, “Optimizing InnoDB Disk I/O”</a>.
                </p><p style="color:blue;">UnIDB更改缓冲区的最大大小，作为缓冲池总大小的百分比。对于具有大量插入、更新和删除活动的mysql服务器，可以增加该值，对于具有用于报告的不变数据的mysql服务器，可以减少该值。有关更多信息，请参见第14.5.2节“更改缓冲区”。有关一般I/O调整建议，请参阅第8.5.8节“优化InnoDB磁盘I/O”。</p></li><li class="listitem"><p><a name="sysvar_innodb_change_buffering"></a>
                <a class="indexterm" name="idm140286813865072"></a>

                <a class="indexterm" name="idm140286813864032"></a>

                <code class="literal">innodb_change_buffering</code>
            </p><p style="color:blue;">innodb_change_缓冲</p>
                <div class="informaltable">
                    <table frame="box" rules="all" summary="Properties for innodb_change_buffering"><colgroup><col width="30%"><col width="70%"></colgroup><thead><tr><th scope="col">Property</th>
                        <th scope="col">Value</th>
                    </tr></thead><tbody><tr><td scope="row"><span class="bold"><strong>Command-Line Format</strong></span></td>
                        <td><code class="literal">--innodb-change-buffering=value</code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>System Variable</strong></span></td>
                        <td><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_change_buffering">innodb_change_buffering</a></code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Scope</strong></span></td>
                        <td>Global</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Dynamic</strong></span></td>
                        <td>Yes</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Type</strong></span></td>
                        <td>Enumeration</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Default Value</strong></span></td>
                        <td><code class="literal">all</code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Valid Values</strong></span></td>
                        <td><p class="valid-value"><code class="literal">none</code></p><p style="color:blue;">没有人</p><p class="valid-value"><code class="literal">inserts</code></p><p style="color:blue;">插入件</p><p class="valid-value"><code class="literal">deletes</code></p><p style="color:blue;">删除</p><p class="valid-value"><code class="literal">changes</code></p><p style="color:blue;">变化</p><p class="valid-value"><code class="literal">purges</code></p><p style="color:blue;">清洗</p><p class="valid-value"><code class="literal">all</code></p><p style="color:blue;">全部的</p></td>
                    </tr></tbody></table>
                </div>
                <p>
                    Whether <code class="literal">InnoDB</code> performs
                    <a class="link" href="glossary.html#glos_change_buffering" title="change buffering">change buffering</a>,
                    an optimization that delays write operations to secondary
                    indexes so that the I/O operations can be performed
                    sequentially. Permitted values are described in the following
                    table.
                </p><p style="color:blue;">InnoDB是否执行更改缓冲，这是一种优化，延迟对辅助索引的写入操作，以便可以按顺序执行I/O操作。允许值如下表所示。</p>
                <div class="table">
                    <a name="innodb-change-buffer-permitted-values"></a><p class="title"><b>Table&nbsp;14.20&nbsp;Permitted Values for innodb_change_buffering</b></p><p style="color:blue;">表14.20 InnoDB_Change_缓冲允许值</p>
                    <div class="table-contents">
                        <table summary="Permitted values for the innodb_chansge_buffering variable. The first column defines the value. The second column describes the option effect."><colgroup><col width="20%"><col width="60%"></colgroup><thead><tr>
                            <th scope="col">Value</th>
                            <th scope="col">Description</th>
                        </tr></thead><tbody><tr>
                            <td scope="row"><code class="literal">none</code></td>
                            <td>Do not buffer any operations.</td>
                        </tr><tr>
                            <td scope="row"><code class="literal">inserts</code></td>
                            <td>Buffer insert operations.</td>
                        </tr><tr>
                            <td scope="row"><code class="literal">deletes</code></td>
                            <td>Buffer delete marking operations; strictly speaking, the writes that
                                mark index records for later deletion during a purge
                                operation.</td>
                        </tr><tr>
                            <td scope="row"><code class="literal">changes</code></td>
                            <td>Buffer inserts and delete-marking operations.</td>
                        </tr><tr>
                            <td scope="row"><code class="literal">purges</code></td>
                            <td>Buffer the physical deletion operations that happen in the background.</td>
                        </tr><tr>
                            <td scope="row"><code class="literal">all</code></td>
                            <td>The default. Buffer inserts, delete-marking operations, and purges.</td>
                        </tr></tbody></table>
                    </div>

                </div>
                <br class="table-break"><p>
                    For more information, see
                    <a class="xref" href="innodb-storage-engine.html#innodb-change-buffer" title="14.5.2&nbsp;Change Buffer">Section&nbsp;14.5.2, “Change Buffer”</a>. For general I/O tuning
                    advice, see <a class="xref" href="optimization.html#optimizing-innodb-diskio" title="8.5.8&nbsp;Optimizing InnoDB Disk I/O">Section&nbsp;8.5.8, “Optimizing InnoDB Disk I/O”</a>.
                </p><p style="color:blue;">有关更多信息，请参见第14.5.2节“更改缓冲区”。有关一般I/O调整建议，请参阅第8.5.8节“优化InnoDB磁盘I/O”。</p></li><li class="listitem"><p><a name="sysvar_innodb_change_buffering_debug"></a>
                <a class="indexterm" name="idm140286813800736"></a>

                <a class="indexterm" name="idm140286813799696"></a>

                <code class="literal">innodb_change_buffering_debug</code>
            </p><p style="color:blue;">innodb_change_buffering_调试</p>
                <div class="informaltable">
                    <table frame="box" rules="all" summary="Properties for innodb_change_buffering_debug"><colgroup><col width="30%"><col width="70%"></colgroup><thead><tr><th scope="col">Property</th>
                        <th scope="col">Value</th>
                    </tr></thead><tbody><tr><td scope="row"><span class="bold"><strong>Command-Line Format</strong></span></td>
                        <td><code class="literal">--innodb-change-buffering-debug=#</code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>System Variable</strong></span></td>
                        <td><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_change_buffering_debug">innodb_change_buffering_debug</a></code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Scope</strong></span></td>
                        <td>Global</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Dynamic</strong></span></td>
                        <td>Yes</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Type</strong></span></td>
                        <td>Integer</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Default Value</strong></span></td>
                        <td><code class="literal">0</code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Maximum Value</strong></span></td>
                        <td><code class="literal">2</code></td>
                    </tr></tbody></table>
                </div>
                <p>
                    Sets a debug flag for <code class="literal">InnoDB</code> change
                    buffering. A value of 1 forces all changes to the change
                    buffer. A value of 2 causes a crash at merge. A default value
                    of 0 indicates that the change buffering debug flag is not
                    set. This option is only available when debugging support is
                    compiled in using the <a class="link" href="installing.html#option_cmake_with_debug"><code class="option">WITH_DEBUG</code></a>
                    <span class="command"><strong>CMake</strong></span> option.
                </p><p style="color:blue;">为innodb change buffering设置调试标志。值为1将强制对更改缓冲区进行所有更改。值为2会导致合并时崩溃。默认值为0表示未设置更改缓冲调试标志。只有在使用with_debug cmake选项编译调试支持时，此选项才可用。</p></li><li class="listitem"><p><a name="sysvar_innodb_checksum_algorithm"></a>
                <a class="indexterm" name="idm140286813766272"></a>

                <a class="link" href="innodb-storage-engine.html#sysvar_innodb_checksum_algorithm"><code class="literal">innodb_checksum_algorithm</code></a>
            </p><p style="color:blue;">InnoDB_校验和算法</p>
                <div class="informaltable">
                    <table frame="box" rules="all" summary="Properties for innodb_checksum_algorithm"><colgroup><col width="30%"><col width="70%"></colgroup><thead><tr><th scope="col">Property</th>
                        <th scope="col">Value</th>
                    </tr></thead><tbody><tr><td scope="row"><span class="bold"><strong>Command-Line Format</strong></span></td>
                        <td><code class="literal">--innodb-checksum-algorithm=value</code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>System Variable</strong></span></td>
                        <td><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_checksum_algorithm">innodb_checksum_algorithm</a></code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Scope</strong></span></td>
                        <td>Global</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Dynamic</strong></span></td>
                        <td>Yes</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Type</strong></span></td>
                        <td>Enumeration</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Default Value</strong></span> (&gt;= 5.7.7)</td>
                        <td><code class="literal">crc32</code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Default Value</strong></span> (&lt;= 5.7.6)</td>
                        <td><code class="literal">innodb</code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Valid Values</strong></span></td>
                        <td><p class="valid-value"><code class="literal">innodb</code></p><p style="color:blue;">InnoDB公司</p><p class="valid-value"><code class="literal">crc32</code></p><p style="color:blue;">CRC32型</p><p class="valid-value"><code class="literal">none</code></p><p style="color:blue;">没有人</p><p class="valid-value"><code class="literal">strict_innodb</code></p><p style="color:blue;">严格的</p><p class="valid-value"><code class="literal">strict_crc32</code></p><p style="color:blue;">严格的</p><p class="valid-value"><code class="literal">strict_none</code></p><p style="color:blue;">严格的</p></td>
                    </tr></tbody></table>
                </div>
                <p>
                    Specifies how to generate and verify the
                    <a class="link" href="glossary.html#glos_checksum" title="checksum">checksum</a> stored in the
                    disk blocks of <code class="literal">InnoDB</code>
                    <a class="link" href="glossary.html#glos_tablespace" title="tablespace">tablespaces</a>.
                    <code class="literal">crc32</code> is the default value as of MySQL
                    5.7.7.
                </p><p style="color:blue;">指定如何生成和验证存储在innodb表空间的磁盘块中的校验和。crc32是mysql 5.7.7的默认值。</p><p>
                    <code class="literal">innodb_checksum_algorithm</code> replaces the
                    <a class="link" href="innodb-storage-engine.html#sysvar_innodb_checksums"><code class="literal">innodb_checksums</code></a> option. The
                    following values were provided for compatibility, up to and
                    including MySQL 5.7.6:
                </p><p style="color:blue;">innodb_checksum_算法取代了innodb_checksums选项。为兼容提供了以下值，包括mysql 5.7.6：</p>
                <div class="itemizedlist">
                    <ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
                        <code class="literal">innodb_checksums=ON</code> is the same as
                        <code class="literal">innodb_checksum_algorithm=innodb</code>.
                    </p><p style="color:blue;">innodb_checksums=on与innodb_checksum_algorithm=innodb相同。</p></li><li class="listitem"><p>
                        <code class="literal">innodb_checksums=OFF</code> is the same as
                        <code class="literal">innodb_checksum_algorithm=none</code>.
                    </p><p style="color:blue;">innodb_checksums=off与innodb_checksum_algorithm=none相同。</p></li></ul>
                </div>
                <p>
                    As of MySQL 5.7.7, with a default
                    <code class="literal">innodb_checksum_algorithm</code> value of crc32,
                    <code class="literal">innodb_checksums=ON</code> is now the same as
                    <code class="literal">innodb_checksum_algorithm=crc32</code>.
                    <code class="literal">innodb_checksums=OFF</code> is still the same as
                    <code class="literal">innodb_checksum_algorithm=none</code>.
                </p><p style="color:blue;">从mysql 5.7.7开始，默认innodb_checksum_algorithm值为crc32，innodb_checksums=on现在与innodb_checksum_algorithm=crc32相同。innodb_checksums=off仍然与innodb_checksum_algorithm=none相同。</p><p>
                    To avoid conflicts, remove references to
                    <a class="link" href="innodb-storage-engine.html#sysvar_innodb_checksums"><code class="literal">innodb_checksums</code></a> from MySQL
                    configuration files and startup scripts.
                </p><p style="color:blue;">为了避免冲突，请从mysql配置文件和启动脚本中删除对innodb_校验和的引用。</p><p>
                    The value <code class="literal">innodb</code> is backward-compatible
                    with earlier versions of MySQL. The value
                    <code class="literal">crc32</code> uses an algorithm that is faster to
                    compute the checksum for every modified block, and to check
                    the checksums for each disk read. It scans blocks 32 bits at a
                    time, which is faster than the <code class="literal">innodb</code>
                    checksum algorithm, which scans blocks 8 bits at a time. The
                    value <code class="literal">none</code> writes a constant value in the
                    checksum field rather than computing a value based on the
                    block data. The blocks in a tablespace can use a mix of old,
                    new, and no checksum values, being updated gradually as the
                    data is modified; once blocks in a tablespace are modified to
                    use the <code class="literal">crc32</code> algorithm, the associated
                    tables cannot be read by earlier versions of MySQL.
                </p><p style="color:blue;">innodb的值与mysql的早期版本向后兼容。值crc32使用一种算法，该算法可以更快地计算每个修改块的校验和，并检查每个磁盘读取的校验和。它一次扫描32位块，比innodb校验和算法一次扫描8位块要快。值none在校验和字段中写入常量值，而不是基于块数据计算值。表空间中的块可以混合使用旧的、新的和无校验和值，随着数据的修改而逐渐更新；一旦表空间中的块被修改为使用CRC32算法，则早期版本的MySQL将无法读取关联的表。</p><p>
                    The strict form of a checksum algorithm reports an error if it
                    encounters a valid but non-matching checksum value in a
                    tablespace. It is recommended that you only use strict
                    settings in a new instance, to set up tablespaces for the
                    first time. Strict settings are somewhat faster, because they
                    do not need to compute all checksum values during disk reads.
                </p><p style="color:blue;">校验和算法的严格形式在表空间中遇到有效但不匹配的校验和值时报告错误。建议您只在新实例中使用严格设置，以便第一次设置表空间。严格设置要快一些，因为它们不需要在磁盘读取期间计算所有校验和值。</p>
                <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">

                    <div class="admon-title">
                        Note
                    </div>
                    <p>
                        Prior to MySQL 5.7.8, a strict mode setting for
                        <code class="literal">innodb_checksum_algorithm</code> caused
                        <code class="literal">InnoDB</code> to halt when encountering a
                        <span class="emphasis"><em>valid</em></span> but non-matching checksum. In
                        MySQL 5.7.8 and later, only an error message is printed, and
                        the page is accepted as valid if it has a valid
                        <code class="literal">innodb</code>, <code class="literal">crc32</code> or
                        <code class="literal">none</code> checksum.
                    </p><p style="color:blue;">在mysql 5.7.8之前，innodb_checksum_算法的严格模式设置导致innodb在遇到有效但不匹配的校验和时停止。在mysql 5.7.8及更高版本中，只打印一条错误消息，如果页面具有有效的innodb、crc32或无校验和，则该页面被视为有效。</p>
                </div>
                <p>
                    The following table shows the difference between the
                    <code class="literal">none</code>, <code class="literal">innodb</code>, and
                    <code class="literal">crc32</code> option values, and their strict
                    counterparts. <code class="literal">none</code>,
                    <code class="literal">innodb</code>, and <code class="literal">crc32</code> write
                    the specified type of checksum value into each data block, but
                    for compatibility accept other checksum values when verifying
                    a block during a read operation. Strict settings also accept
                    valid checksum values but print an error message when a valid
                    non-matching checksum value is encountered. Using the strict
                    form can make verification faster if all
                    <code class="literal">InnoDB</code> data files in an instance are
                    created under an identical
                    <code class="literal">innodb_checksum_algorithm</code> value.
                </p><p style="color:blue;">下表显示了none、innodb和crc32选项值及其严格对应值之间的差异。none、innodb和crc32将指定类型的校验和值写入每个数据块，但为了兼容性，在读取操作期间验证块时接受其他校验和值。严格设置也接受有效的校验和值，但在遇到有效的不匹配校验和值时打印错误消息。如果实例中的所有innodb数据文件都是在相同的innodb_checksum_算法值下创建的，那么使用strict表单可以加快验证速度。</p>
                <div class="table">
                    <a name="innodb-checksum-algorithm-values"></a><p class="title"><b>Table&nbsp;14.21&nbsp;Permitted innodb_checksum_algorithm Values</b></p><p style="color:blue;">表14.21允许的InnoDB校验和算法值</p>
                    <div class="table-contents">
                        <table summary="Permitted values for the innodb_checksum_algorithm variable. The first column defines the checksum value. The second column describes the generated checksum. The third column describes compatible checksums."><colgroup><col width="20%"><col width="40%"><col width="40%"></colgroup><thead><tr>
                            <th scope="col">Value</th>
                            <th scope="col">Generated checksum (when writing)</th>
                            <th scope="col">Permitted checksums (when reading)</th>
                        </tr></thead><tbody><tr>
                            <td scope="row">none</td>
                            <td>A constant number.</td>
                            <td>Any of the checksums generated by <code class="literal">none</code>,
                                <code class="literal">innodb</code>, or <code class="literal">crc32</code>.</td>
                        </tr><tr>
                            <td scope="row">innodb</td>
                            <td>A checksum calculated in software, using the original algorithm from
                                <code class="literal">InnoDB</code>.</td>
                            <td>Any of the checksums generated by <code class="literal">none</code>,
                                <code class="literal">innodb</code>, or <code class="literal">crc32</code>.</td>
                        </tr><tr>
                            <td scope="row">crc32</td>
                            <td>A checksum calculated using the <code class="literal">crc32</code> algorithm,
                                possibly done with a hardware assist.</td>
                            <td>Any of the checksums generated by <code class="literal">none</code>,
                                <code class="literal">innodb</code>, or <code class="literal">crc32</code>.</td>
                        </tr><tr>
                            <td scope="row">strict_none</td>
                            <td>A constant number</td>
                            <td>Any of the checksums generated by <code class="literal">none</code>,
                                <code class="literal">innodb</code>, or <code class="literal">crc32</code>.
                                <code class="literal">InnoDB</code> prints an error message if a
                                valid but non-matching checksum is encountered.</td>
                        </tr><tr>
                            <td scope="row">strict_innodb</td>
                            <td>A checksum calculated in software, using the original algorithm from
                                <code class="literal">InnoDB</code>.</td>
                            <td>Any of the checksums generated by <code class="literal">none</code>,
                                <code class="literal">innodb</code>, or <code class="literal">crc32</code>.
                                <code class="literal">InnoDB</code> prints an error message if a
                                valid but non-matching checksum is encountered.</td>
                        </tr><tr>
                            <td scope="row">strict_crc32</td>
                            <td>A checksum calculated using the <code class="literal">crc32</code> algorithm,
                                possibly done with a hardware assist.</td>
                            <td>Any of the checksums generated by <code class="literal">none</code>,
                                <code class="literal">innodb</code>, or <code class="literal">crc32</code>.
                                <code class="literal">InnoDB</code> prints an error message if a
                                valid but non-matching checksum is encountered.</td>
                        </tr></tbody></table>
                    </div>

                </div>
                <br class="table-break"><p>
                    Versions of <a class="link" href="mysql-enterprise.html#mysql-enterprise-backup" title="29.2&nbsp;MySQL Enterprise Backup Overview">MySQL
                    Enterprise Backup</a> up to 3.8.0 do not support backing up
                    tablespaces that use CRC32 checksums.
                    <a class="link" href="mysql-enterprise.html#mysql-enterprise-backup" title="29.2&nbsp;MySQL Enterprise Backup Overview">MySQL Enterprise
                        Backup</a> adds CRC32 checksum support in 3.8.1, with some
                    limitations. Refer to the
                    <a class="link" href="mysql-enterprise.html#mysql-enterprise-backup" title="29.2&nbsp;MySQL Enterprise Backup Overview">MySQL Enterprise
                        Backup</a> 3.8.1 Change History for more information.
                </p><p style="color:blue;">3.8.0之前的mysql企业备份版本不支持备份使用crc32校验和的表空间。mysql企业备份在3.8.1中添加了crc32校验和支持，但有一些限制。有关详细信息，请参阅mysql enterprise backup 3.8.1更改历史记录。</p></li><li class="listitem"><p><a name="sysvar_innodb_checksums"></a>
                <a class="indexterm" name="idm140286813642832"></a>

                <a class="indexterm" name="idm140286813641776"></a>

                <code class="literal">innodb_checksums</code>
            </p><p style="color:blue;">innodb_校验和</p>
                <div class="informaltable">
                    <table frame="box" rules="all" summary="Properties for innodb_checksums"><colgroup><col width="30%"><col width="70%"></colgroup><thead><tr><th scope="col">Property</th>
                        <th scope="col">Value</th>
                    </tr></thead><tbody><tr><td scope="row"><span class="bold"><strong>Command-Line Format</strong></span></td>
                        <td><code class="literal">--innodb-checksums[={OFF|ON}]</code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Deprecated</strong></span></td>
                        <td>Yes</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>System Variable</strong></span></td>
                        <td><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_checksums">innodb_checksums</a></code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Scope</strong></span></td>
                        <td>Global</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Dynamic</strong></span></td>
                        <td>No</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Type</strong></span></td>
                        <td>Boolean</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Default Value</strong></span></td>
                        <td><code class="literal">ON</code></td>
                    </tr></tbody></table>
                </div>
                <p>
                    <code class="literal">InnoDB</code> can use
                    <a class="link" href="glossary.html#glos_checksum" title="checksum">checksum</a> validation on
                    all tablespace pages read from disk to ensure extra fault
                    tolerance against hardware faults or corrupted data files.
                    This validation is enabled by default. Under specialized
                    circumstances (such as when running benchmarks) this safety
                    feature can be disabled with
                    <code class="option">--skip-innodb-checksums</code>. You can specify the
                    method of calculating the checksum using the
                    <a class="link" href="innodb-storage-engine.html#sysvar_innodb_checksum_algorithm"><code class="literal">innodb_checksum_algorithm</code></a>
                    option.
                </p><p style="color:blue;">InnoDB可以对从磁盘读取的所有表空间页使用校验和验证，以确保对硬件故障或损坏的数据文件有额外的容错能力。默认情况下启用此验证。在特殊情况下（例如运行基准测试时），可以使用--skip innodb checksums禁用此安全功能。您可以使用innodb_checksum_algorithm选项指定计算校验和的方法。</p><p>
                    <code class="literal">innodb_checksums</code> is deprecated, replaced by
                    <a class="link" href="innodb-storage-engine.html#sysvar_innodb_checksum_algorithm"><code class="literal">innodb_checksum_algorithm</code></a>.
                </p><p style="color:blue;">InnoDB_校验和已弃用，取而代之的是InnoDB_校验和算法。</p><p>
                    Prior to MySQL 5.7.7, <code class="literal">innodb_checksums=ON</code>
                    is the same as
                    <a class="link" href="innodb-storage-engine.html#sysvar_innodb_checksum_algorithm"><code class="literal">innodb_checksum_algorithm=innodb</code></a>.
                    As of MySQL 5.7.7, the
                    <a class="link" href="innodb-storage-engine.html#sysvar_innodb_checksum_algorithm"><code class="literal">innodb_checksum_algorithm</code></a>
                    default value is <code class="literal">crc32</code>, and
                    <code class="literal">innodb_checksums=ON</code> is the same as
                    <a class="link" href="innodb-storage-engine.html#sysvar_innodb_checksum_algorithm"><code class="literal">innodb_checksum_algorithm=crc32</code></a>.
                    <code class="literal">innodb_checksums=OFF</code> is the same as
                    <a class="link" href="innodb-storage-engine.html#sysvar_innodb_checksum_algorithm"><code class="literal">innodb_checksum_algorithm=none</code></a>.
                </p><p style="color:blue;">在mysql 5.7.7之前，innodb_checksums=on与innodb_checksum_algorithm=innodb相同。从mysql 5.7.7开始，innodb_checksum_algorithm默认值为crc32，innodb_checksums=on与innodb_checksum_algorithm=crc32相同。innodb_checksums=off与innodb_checksum_algorithm=none相同。</p><p>
                    Remove any <code class="literal">innodb_checksums</code> options from
                    your configuration files and startup scripts to avoid
                    conflicts with <code class="literal">innodb_checksum_algorithm</code>.
                    <code class="literal">innodb_checksums=OFF</code> automatically sets
                    <code class="literal">innodb_checksum_algorithm=none</code>.
                    <code class="literal">innodb_checksums=ON</code> is ignored and
                    overridden by any other setting for
                    <code class="literal">innodb_checksum_algorithm</code>.
                </p><p style="color:blue;">从配置文件和启动脚本中删除任何innodb_checksum选项，以避免与innodb_checksum_算法冲突。innodb_checksums=off自动设置innodb_checksum_algorithm=none。innodb_checksum=on被忽略，并被innodb_checksum_算法的任何其他设置覆盖。</p></li><li class="listitem"><p><a name="sysvar_innodb_cmp_per_index_enabled"></a>
                <a class="indexterm" name="idm140286813592016"></a>

                <code class="literal">innodb_cmp_per_index_enabled</code>
            </p><p style="color:blue;">innodb_cmp_per_index_启用</p>
                <div class="informaltable">
                    <table frame="box" rules="all" summary="Properties for innodb_cmp_per_index_enabled"><colgroup><col width="30%"><col width="70%"></colgroup><thead><tr><th scope="col">Property</th>
                        <th scope="col">Value</th>
                    </tr></thead><tbody><tr><td scope="row"><span class="bold"><strong>Command-Line Format</strong></span></td>
                        <td><code class="literal">--innodb-cmp-per-index-enabled[={OFF|ON}]</code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>System Variable</strong></span></td>
                        <td><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_cmp_per_index_enabled">innodb_cmp_per_index_enabled</a></code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Scope</strong></span></td>
                        <td>Global</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Dynamic</strong></span></td>
                        <td>Yes</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Type</strong></span></td>
                        <td>Boolean</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Default Value</strong></span></td>
                        <td><code class="literal">OFF</code></td>
                    </tr></tbody></table>
                </div>
                <p>
                    Enables per-index compression-related statistics in the
                    <a class="link" href="information-schema.html#innodb-cmp-per-index-table" title="24.32.6&nbsp;The INFORMATION_SCHEMA INNODB_CMP_PER_INDEX and INNODB_CMP_PER_INDEX_RESET Tables"><code class="literal">INFORMATION_SCHEMA.INNODB_CMP_PER_INDEX</code></a>
                    table. Because these statistics can be expensive to gather,
                    only enable this option on development, test, or slave
                    instances during performance tuning related to
                    <code class="literal">InnoDB</code>
                    <a class="link" href="glossary.html#glos_compression" title="compression">compressed</a> tables.
                </p><p style="color:blue;">在information schema.innodb_cmp_per_index表中启用与每个索引压缩相关的统计信息。因为收集这些统计数据可能很昂贵，所以在与innodb压缩表相关的性能优化期间，只在开发、测试或从机实例上启用此选项。</p><p>
                    For more information, see
                    <a class="xref" href="information-schema.html#innodb-cmp-per-index-table" title="24.32.6&nbsp;The INFORMATION_SCHEMA INNODB_CMP_PER_INDEX and INNODB_CMP_PER_INDEX_RESET Tables">Section&nbsp;24.32.6, “The INFORMATION_SCHEMA INNODB_CMP_PER_INDEX and
                        INNODB_CMP_PER_INDEX_RESET Tables”</a>, and
                    <a class="xref" href="innodb-storage-engine.html#innodb-compression-tuning-monitoring" title="14.9.1.4&nbsp;Monitoring InnoDB Table Compression at Runtime">Section&nbsp;14.9.1.4, “Monitoring InnoDB Table Compression at Runtime”</a>.
                </p><p style="color:blue;">有关更多信息，请参阅第24.32.6节“信息模式innodb_cmp_per_index和innodb_cmp_per_index_reset tables”，以及第14.9.1.4节“运行时监视innodb表压缩”。</p></li><li class="listitem"><p><a name="sysvar_innodb_commit_concurrency"></a>
                <a class="indexterm" name="idm140286813559856"></a>

                <a class="indexterm" name="idm140286813558752"></a>

                <a class="indexterm" name="idm140286813557296"></a>

                <code class="literal">innodb_commit_concurrency</code>
            </p><p style="color:blue;">innodb_commit_并发</p>
                <div class="informaltable">
                    <table frame="box" rules="all" summary="Properties for innodb_commit_concurrency"><colgroup><col width="30%"><col width="70%"></colgroup><thead><tr><th scope="col">Property</th>
                        <th scope="col">Value</th>
                    </tr></thead><tbody><tr><td scope="row"><span class="bold"><strong>Command-Line Format</strong></span></td>
                        <td><code class="literal">--innodb-commit-concurrency=#</code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>System Variable</strong></span></td>
                        <td><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_commit_concurrency">innodb_commit_concurrency</a></code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Scope</strong></span></td>
                        <td>Global</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Dynamic</strong></span></td>
                        <td>Yes</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Type</strong></span></td>
                        <td>Integer</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Default Value</strong></span></td>
                        <td><code class="literal">0</code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Minimum Value</strong></span></td>
                        <td><code class="literal">0</code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Maximum Value</strong></span></td>
                        <td><code class="literal">1000</code></td>
                    </tr></tbody></table>
                </div>
                <p>
                    The number of <a class="link" href="glossary.html#glos_thread" title="thread">threads</a> that
                    can <a class="link" href="glossary.html#glos_commit" title="commit">commit</a> at the same
                    time. A value of 0 (the default) permits any number of
                    <a class="link" href="glossary.html#glos_transaction" title="transaction">transactions</a> to commit
                    simultaneously.
                </p><p style="color:blue;">可以同时提交的线程数。值0（默认值）允许同时提交任意数量的事务。</p><p>
                    The value of <code class="literal">innodb_commit_concurrency</code>
                    cannot be changed at runtime from zero to nonzero or vice
                    versa. The value can be changed from one nonzero value to
                    another.
                </p><p style="color:blue;">innodb_commit_concurrency的值在运行时不能从零更改为非零，反之亦然。该值可以从一个非零值更改为另一个。</p></li><li class="listitem"><p><a name="sysvar_innodb_compress_debug"></a>
                <a class="indexterm" name="idm140286813519552"></a>

                <a class="indexterm" name="idm140286813518480"></a>

                <code class="literal">innodb_compress_debug</code>
            </p><p style="color:blue;">innodb_compress_调试</p>
                <div class="informaltable">
                    <table frame="box" rules="all" summary="Properties for innodb_compress_debug"><colgroup><col width="30%"><col width="70%"></colgroup><thead><tr><th scope="col">Property</th>
                        <th scope="col">Value</th>
                    </tr></thead><tbody><tr><td scope="row"><span class="bold"><strong>Command-Line Format</strong></span></td>
                        <td><code class="literal">--innodb-compress-debug=value</code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Introduced</strong></span></td>
                        <td>5.7.8</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>System Variable</strong></span></td>
                        <td><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_compress_debug">innodb_compress_debug</a></code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Scope</strong></span></td>
                        <td>Global</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Dynamic</strong></span></td>
                        <td>Yes</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Type</strong></span></td>
                        <td>Enumeration</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Default Value</strong></span></td>
                        <td><code class="literal">none</code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Valid Values</strong></span></td>
                        <td><p class="valid-value"><code class="literal">none</code></p><p style="color:blue;">没有人</p><p class="valid-value"><code class="literal">zlib</code></p><p style="color:blue;">zlib</p><p class="valid-value"><code class="literal">lz4</code></p><p style="color:blue;">LZ4型</p><p class="valid-value"><code class="literal">lz4hc</code></p><p style="color:blue;">LZ4HC型</p></td>
                    </tr></tbody></table>
                </div>
                <p>
                    Compresses all tables using a specified compression algorithm
                    without having to define a <code class="literal">COMPRESSION</code>
                    attribute for each table. This option is only available if
                    debugging support is compiled in using the
                    <a class="link" href="installing.html#option_cmake_with_debug"><code class="option">WITH_DEBUG</code></a>
                    <span class="command"><strong>CMake</strong></span> option.
                </p><p style="color:blue;">使用指定的压缩算法压缩所有表，而不必为每个表定义压缩属性。只有在使用with_debug cmake选项编译调试支持时，此选项才可用。</p><p>
                    For related information, see
                    <a class="xref" href="innodb-storage-engine.html#innodb-page-compression" title="14.9.2&nbsp;InnoDB Page Compression">Section&nbsp;14.9.2, “InnoDB Page Compression”</a>.
                </p><p style="color:blue;">有关信息，请参阅14.9.2节，“InnoDB页面压缩”。</p></li><li class="listitem"><p><a name="sysvar_innodb_compression_failure_threshold_pct"></a>
                <a class="indexterm" name="idm140286813478096"></a>

                <code class="literal">innodb_compression_failure_threshold_pct</code>
            </p><p style="color:blue;">innodb_compression_failure_threshold_pct公司</p>
                <div class="informaltable">
                    <table frame="box" rules="all" summary="Properties for innodb_compression_failure_threshold_pct"><colgroup><col width="30%"><col width="70%"></colgroup><thead><tr><th scope="col">Property</th>
                        <th scope="col">Value</th>
                    </tr></thead><tbody><tr><td scope="row"><span class="bold"><strong>Command-Line Format</strong></span></td>
                        <td><code class="literal">--innodb-compression-failure-threshold-pct=#</code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>System Variable</strong></span></td>
                        <td><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_compression_failure_threshold_pct">innodb_compression_failure_threshold_pct</a></code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Scope</strong></span></td>
                        <td>Global</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Dynamic</strong></span></td>
                        <td>Yes</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Type</strong></span></td>
                        <td>Integer</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Default Value</strong></span></td>
                        <td><code class="literal">5</code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Minimum Value</strong></span></td>
                        <td><code class="literal">0</code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Maximum Value</strong></span></td>
                        <td><code class="literal">100</code></td>
                    </tr></tbody></table>
                </div>
                <p>
                    Defines the compression failure rate threshold for a table, as
                    a percentage, at which point MySQL begins adding padding
                    within <a class="link" href="glossary.html#glos_compression" title="compression">compressed</a>
                    pages to avoid expensive
                    <a class="link" href="glossary.html#glos_compression_failure" title="compression failure">compression
                        failures</a>. When this threshold is passed, MySQL begins
                    to leave additional free space within each new compressed
                    page, dynamically adjusting the amount of free space up to the
                    percentage of page size specified by
                    <a class="link" href="innodb-storage-engine.html#sysvar_innodb_compression_pad_pct_max"><code class="literal">innodb_compression_pad_pct_max</code></a>.
                    A value of zero disables the mechanism that monitors
                    compression efficiency and dynamically adjusts the padding
                    amount.
                </p><p style="color:blue;">定义表的压缩失败率阈值（以百分比表示），此时mysql开始在压缩页面中添加填充以避免昂贵的压缩失败。当这个阈值通过时，mysql开始在每个新的压缩页面中留下额外的可用空间，动态调整可用空间量，使其达到innodb_compression_pad_pct_max指定的页面大小百分比。值为零将禁用监视压缩效率和动态调整填充量的机制。</p><p>
                    For more information, see
                    <a class="xref" href="innodb-storage-engine.html#innodb-performance-compression-oltp" title="14.9.1.6&nbsp;Compression for OLTP Workloads">Section&nbsp;14.9.1.6, “Compression for OLTP Workloads”</a>.
                </p><p style="color:blue;">有关更多信息，请参阅第14.9.1.6节“OLTP工作负载的压缩”。</p></li><li class="listitem"><p><a name="sysvar_innodb_compression_level"></a>
                <a class="indexterm" name="idm140286813439984"></a>

                <code class="literal">innodb_compression_level</code>
            </p><p style="color:blue;">innodb_压缩级别</p>
                <div class="informaltable">
                    <table frame="box" rules="all" summary="Properties for innodb_compression_level"><colgroup><col width="30%"><col width="70%"></colgroup><thead><tr><th scope="col">Property</th>
                        <th scope="col">Value</th>
                    </tr></thead><tbody><tr><td scope="row"><span class="bold"><strong>Command-Line Format</strong></span></td>
                        <td><code class="literal">--innodb-compression-level=#</code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>System Variable</strong></span></td>
                        <td><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_compression_level">innodb_compression_level</a></code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Scope</strong></span></td>
                        <td>Global</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Dynamic</strong></span></td>
                        <td>Yes</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Type</strong></span></td>
                        <td>Integer</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Default Value</strong></span></td>
                        <td><code class="literal">6</code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Minimum Value</strong></span></td>
                        <td><code class="literal">0</code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Maximum Value</strong></span></td>
                        <td><code class="literal">9</code></td>
                    </tr></tbody></table>
                </div>
                <p>
                    Specifies the level of zlib compression to use for
                    <code class="literal">InnoDB</code>
                    <a class="link" href="glossary.html#glos_compression" title="compression">compressed</a> tables and
                    indexes. A higher value lets you fit more data onto a storage
                    device, at the expense of more CPU overhead during
                    compression. A lower value lets you reduce CPU overhead when
                    storage space is not critical, or you expect the data is not
                    especially compressible.
                </p><p style="color:blue;">指定用于innodb压缩表和索引的zlib压缩级别。更高的值允许您将更多的数据放在存储设备上，而在压缩期间会消耗更多的CPU开销。较低的值可以在存储空间不重要或数据不可压缩时减少CPU开销。</p><p>
                    For more information, see
                    <a class="xref" href="innodb-storage-engine.html#innodb-performance-compression-oltp" title="14.9.1.6&nbsp;Compression for OLTP Workloads">Section&nbsp;14.9.1.6, “Compression for OLTP Workloads”</a>.
                </p><p style="color:blue;">有关更多信息，请参阅第14.9.1.6节“OLTP工作负载的压缩”。</p></li><li class="listitem"><p><a name="sysvar_innodb_compression_pad_pct_max"></a>
                <a class="indexterm" name="idm140286813403600"></a>

                <code class="literal">innodb_compression_pad_pct_max</code>
            </p><p style="color:blue;">innodb_compression_pad_pct_max公司</p>
                <div class="informaltable">
                    <table frame="box" rules="all" summary="Properties for innodb_compression_pad_pct_max"><colgroup><col width="30%"><col width="70%"></colgroup><thead><tr><th scope="col">Property</th>
                        <th scope="col">Value</th>
                    </tr></thead><tbody><tr><td scope="row"><span class="bold"><strong>Command-Line Format</strong></span></td>
                        <td><code class="literal">--innodb-compression-pad-pct-max=#</code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>System Variable</strong></span></td>
                        <td><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_compression_pad_pct_max">innodb_compression_pad_pct_max</a></code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Scope</strong></span></td>
                        <td>Global</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Dynamic</strong></span></td>
                        <td>Yes</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Type</strong></span></td>
                        <td>Integer</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Default Value</strong></span></td>
                        <td><code class="literal">50</code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Minimum Value</strong></span></td>
                        <td><code class="literal">0</code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Maximum Value</strong></span></td>
                        <td><code class="literal">75</code></td>
                    </tr></tbody></table>
                </div>
                <p>
                    Specifies the maximum percentage that can be reserved as free
                    space within each compressed
                    <a class="link" href="glossary.html#glos_page" title="page">page</a>, allowing room to
                    reorganize the data and modification log within the page when
                    a <a class="link" href="glossary.html#glos_compression" title="compression">compressed</a> table or
                    index is updated and the data might be recompressed. Only
                    applies when
                    <a class="link" href="innodb-storage-engine.html#sysvar_innodb_compression_failure_threshold_pct"><code class="literal">innodb_compression_failure_threshold_pct</code></a>
                    is set to a nonzero value, and the rate of
                    <a class="link" href="glossary.html#glos_compression_failure" title="compression failure">compression
                        failures</a> passes the cutoff point.
                </p><p style="color:blue;">指定可在每个压缩页内保留为自由空间的最大百分比，允许在压缩表或索引被更新并重新压缩数据时重新整理页内的数据和修改日志。仅当innodb_compression_failure_threshold_pct设置为非零值且压缩失败率超过截止点时适用。</p><p>
                    For more information, see
                    <a class="xref" href="innodb-storage-engine.html#innodb-performance-compression-oltp" title="14.9.1.6&nbsp;Compression for OLTP Workloads">Section&nbsp;14.9.1.6, “Compression for OLTP Workloads”</a>.
                </p><p style="color:blue;">有关更多信息，请参阅第14.9.1.6节“OLTP工作负载的压缩”。</p></li><li class="listitem"><p><a name="sysvar_innodb_concurrency_tickets"></a>
                <a class="indexterm" name="idm140286813364880"></a>

                <a class="indexterm" name="idm140286813363776"></a>

                <a class="indexterm" name="idm140286813362320"></a>

                <code class="literal">innodb_concurrency_tickets</code>
            </p><p style="color:blue;">InnoDB_并发票证</p>
                <div class="informaltable">
                    <table frame="box" rules="all" summary="Properties for innodb_concurrency_tickets"><colgroup><col width="30%"><col width="70%"></colgroup><thead><tr><th scope="col">Property</th>
                        <th scope="col">Value</th>
                    </tr></thead><tbody><tr><td scope="row"><span class="bold"><strong>Command-Line Format</strong></span></td>
                        <td><code class="literal">--innodb-concurrency-tickets=#</code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>System Variable</strong></span></td>
                        <td><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_concurrency_tickets">innodb_concurrency_tickets</a></code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Scope</strong></span></td>
                        <td>Global</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Dynamic</strong></span></td>
                        <td>Yes</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Type</strong></span></td>
                        <td>Integer</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Default Value</strong></span></td>
                        <td><code class="literal">5000</code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Minimum Value</strong></span></td>
                        <td><code class="literal">1</code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Maximum Value</strong></span></td>
                        <td><code class="literal">4294967295</code></td>
                    </tr></tbody></table>
                </div>
                <p>
                    Determines the number of
                    <a class="link" href="glossary.html#glos_thread" title="thread">threads</a> that can enter
                    <code class="literal">InnoDB</code> concurrently. A thread is placed in
                    a queue when it tries to enter <code class="literal">InnoDB</code> if
                    the number of threads has already reached the concurrency
                    limit. When a thread is permitted to enter
                    <code class="literal">InnoDB</code>, it is given a number of <span class="quote">“<span class="quote">
          tickets</span>”</span> equal to the value of
                    <a class="link" href="innodb-storage-engine.html#sysvar_innodb_concurrency_tickets"><code class="literal">innodb_concurrency_tickets</code></a>,
                    and the thread can enter and leave <code class="literal">InnoDB</code>
                    freely until it has used up its tickets. After that point, the
                    thread again becomes subject to the concurrency check (and
                    possible queuing) the next time it tries to enter
                    <code class="literal">InnoDB</code>. The default value is 5000.
                </p><p style="color:blue;">确定可以同时进入innodb的线程数。如果线程数已经达到并发限制，那么当线程试图进入innodb时，它会被放入队列中。当一个线程被允许进入innodb时，给它一个等于innodb_concurrency_tickets值的“tickets”，线程可以自由地进入和离开innodb，直到它用完了它的tickets。在这一点之后，线程在下次尝试进入innodb时再次接受并发检查（以及可能的队列）。默认值为5000。</p><p>
                    With a small <code class="literal">innodb_concurrency_tickets</code>
                    value, small transactions that only need to process a few rows
                    compete fairly with larger transactions that process many
                    rows. The disadvantage of a small
                    <code class="literal">innodb_concurrency_tickets</code> value is that
                    large transactions must loop through the queue many times
                    before they can complete, which extends the amount of time
                    required to complete their task.
                </p><p style="color:blue;">如果innodb_concurrency_tickets值很小，那么只需要处理几行的小事务就可以与处理许多行的大事务公平竞争。innodb_concurrency_tickets值较小的缺点是，大型事务必须多次循环队列才能完成，这会延长完成任务所需的时间。</p><p>
                    With a large <code class="literal">innodb_concurrency_tickets</code>
                    value, large transactions spend less time waiting for a
                    position at the end of the queue (controlled by
                    <a class="link" href="innodb-storage-engine.html#sysvar_innodb_thread_concurrency"><code class="literal">innodb_thread_concurrency</code></a>)
                    and more time retrieving rows. Large transactions also require
                    fewer trips through the queue to complete their task. The
                    disadvantage of a large
                    <code class="literal">innodb_concurrency_tickets</code> value is that
                    too many large transactions running at the same time can
                    starve smaller transactions by making them wait a longer time
                    before executing.
                </p><p style="color:blue;">如果innodb_concurrency_tickets值较大，则大型事务等待队列末尾位置（由innodb_thread_concurrency控制）的时间较少，检索行的时间也较多。大型事务也需要较少的队列访问来完成其任务。大型innodb_concurrency_tickets值的缺点是，太多同时运行的大型事务可能会使较小的事务在执行之前等待更长的时间，从而导致事务不足。</p><p>
                    With a nonzero
                    <a class="link" href="innodb-storage-engine.html#sysvar_innodb_thread_concurrency"><code class="literal">innodb_thread_concurrency</code></a>
                    value, you may need to adjust the
                    <code class="literal">innodb_concurrency_tickets</code> value up or down
                    to find the optimal balance between larger and smaller
                    transactions. The <code class="literal">SHOW ENGINE INNODB STATUS</code>
                    report shows the number of tickets remaining for an executing
                    transaction in its current pass through the queue. This data
                    may also be obtained from the
                    <code class="literal">TRX_CONCURRENCY_TICKETS</code> column of the
                    <a class="link" href="information-schema.html#innodb-trx-table" title="24.32.26&nbsp;The INFORMATION_SCHEMA INNODB_TRX Table"><code class="literal">INFORMATION_SCHEMA.INNODB_TRX</code></a>
                    table.
                </p><p style="color:blue;">如果innodb_thread_concurrency值为非零，则可能需要向上或向下调整innodb_concurrency_tickets值，以找到较大事务和较小事务之间的最佳平衡。show engine innodb status报告显示当前通过队列的正在执行的事务的剩余票证数。此数据也可以从information schema.innodb_trx表的trx_concurrency_tickets列获得。</p><p>
                    For more information, see
                    <a class="xref" href="innodb-storage-engine.html#innodb-performance-thread_concurrency" title="14.8.5&nbsp;Configuring Thread Concurrency for InnoDB">Section&nbsp;14.8.5, “Configuring Thread Concurrency for InnoDB”</a>.
                </p><p style="color:blue;">有关更多信息，请参阅14.8.5节，“为innodb配置线程并发”。</p></li><li class="listitem"><p><a name="sysvar_innodb_data_file_path"></a>
                <a class="indexterm" name="idm140286813309088"></a>

                <a class="indexterm" name="idm140286813308048"></a>

                <code class="literal">innodb_data_file_path</code>
            </p><p style="color:blue;">innodb_data_file_路径</p>
                <div class="informaltable">
                    <table frame="box" rules="all" summary="Properties for innodb_data_file_path"><colgroup><col width="30%"><col width="70%"></colgroup><thead><tr><th scope="col">Property</th>
                        <th scope="col">Value</th>
                    </tr></thead><tbody><tr><td scope="row"><span class="bold"><strong>Command-Line Format</strong></span></td>
                        <td><code class="literal">--innodb-data-file-path=file_name</code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>System Variable</strong></span></td>
                        <td><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_data_file_path">innodb_data_file_path</a></code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Scope</strong></span></td>
                        <td>Global</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Dynamic</strong></span></td>
                        <td>No</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Type</strong></span></td>
                        <td>String</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Default Value</strong></span></td>
                        <td><code class="literal">ibdata1:12M:autoextend</code></td>
                    </tr></tbody></table>
                </div>
                <p>
                    Defines the name, size, and attributes of
                    <code class="literal">InnoDB</code> system tablespace data files.. If
                    you do not specify a value for
                    <a class="link" href="innodb-storage-engine.html#sysvar_innodb_data_file_path"><code class="literal">innodb_data_file_path</code></a>, the
                    default behavior is to create a single auto-extending data
                    file, slightly larger than 12MB, named
                    <code class="filename">ibdata1</code>.
                </p><p style="color:blue;">定义InnoDB系统表空间数据文件的名称、大小和属性。如果没有为innodb_data_file_path指定值，默认行为是创建一个自动扩展的数据文件，略大于12MB，名为ibdata1。</p><p>
                    The full syntax for a data file specification includes the
                    file name, file size, <code class="literal">autoextend</code> attribute,
                    and <code class="literal">max</code> attribute:
                </p><p style="color:blue;">数据文件规范的完整语法包括文件名、文件大小、自动扩展属性和max属性：</p><pre data-lang="none" class="programlisting"><em class="replaceable"><code>file_name</code></em>:<em class="replaceable"><code>file_size</code></em>[:autoextend[:max:<em class="replaceable"><code>max_file_size</code></em>]]
</pre><p>
                    File sizes are specified in kilobytes, megabytes, or gigabytes
                    by appending <code class="literal">K</code>, <code class="literal">M</code> or
                    <code class="literal">G</code> to the size value. If specifying the data
                    file size in kilobytes, do so in multiples of 1024. Otherwise,
                    KB values are rounded to nearest megabyte (MB) boundary. The
                    sum of file sizes must be, at a minimum, slightly larger than
                    12MB.
                </p><p style="color:blue;">文件大小是通过在大小值后面附加k、m或g以千字节、兆字节或千兆字节为单位指定的。如果以千字节为单位指定数据文件大小，请以1024的倍数指定。否则，将KB值舍入到最接近的MB边界。文件大小之和必须至少略大于12MB。</p><p>
                    For additional configuration information, see
                    <a class="xref" href="innodb-storage-engine.html#innodb-startup-data-file-configuration" title="System Tablespace Data File Configuration">System Tablespace Data File Configuration</a>. For
                    resizing instructions, see
                    <a class="xref" href="innodb-storage-engine.html#innodb-resize-system-tablespace" title="Resizing the System Tablespace">Resizing the System Tablespace</a>.
                </p><p style="color:blue;">有关其他配置信息，请参阅系统表空间数据文件配置。有关调整大小的说明，请参阅调整系统表空间的大小。</p></li><li class="listitem"><p><a name="sysvar_innodb_data_home_dir"></a>
                <a class="indexterm" name="idm140286813268640"></a>

                <a class="indexterm" name="idm140286813267600"></a>

                <code class="literal">innodb_data_home_dir</code>
            </p><p style="color:blue;">innodb_data_home_目录</p>
                <div class="informaltable">
                    <table frame="box" rules="all" summary="Properties for innodb_data_home_dir"><colgroup><col width="30%"><col width="70%"></colgroup><thead><tr><th scope="col">Property</th>
                        <th scope="col">Value</th>
                    </tr></thead><tbody><tr><td scope="row"><span class="bold"><strong>Command-Line Format</strong></span></td>
                        <td><code class="literal">--innodb-data-home-dir=dir_name</code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>System Variable</strong></span></td>
                        <td><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_data_home_dir">innodb_data_home_dir</a></code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Scope</strong></span></td>
                        <td>Global</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Dynamic</strong></span></td>
                        <td>No</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Type</strong></span></td>
                        <td>Directory name</td>
                    </tr></tbody></table>
                </div>
                <p>
                    The common part of the directory path for
                    <code class="literal">InnoDB</code>
                    <a class="link" href="glossary.html#glos_system_tablespace" title="system tablespace">system
                        tablespace</a> data files. This setting does not affect the
                    location of
                    <a class="link" href="glossary.html#glos_file_per_table" title="file-per-table">file-per-table</a>
                    tablespaces when
                    <a class="link" href="innodb-storage-engine.html#sysvar_innodb_file_per_table"><code class="literal">innodb_file_per_table</code></a> is
                    enabled. The default value is the MySQL
                    <code class="filename">data</code> directory. If you specify the value
                    as an empty string, you can specify an absolute file paths for
                    <a class="link" href="innodb-storage-engine.html#sysvar_innodb_data_file_path"><code class="literal">innodb_data_file_path</code></a>.
                </p><p style="color:blue;">innodb系统表空间数据文件的目录路径的公共部分。当启用innodb_file_per_table时，此设置不影响file per table spaces的位置。默认值是mysql数据目录。如果将值指定为空字符串，则可以为innodb_data_file_path指定绝对文件路径。</p><p>
                    A trailing slash is required when specifying a value for
                    <a class="link" href="innodb-storage-engine.html#sysvar_innodb_data_home_dir"><code class="literal">innodb_data_home_dir</code></a>. For
                    example:
                </p><p style="color:blue;">为innodb_data_home_dir指定值时，需要一个尾随斜杠。例如：</p><pre data-lang="ini" class="programlisting">[mysqld]
innodb_data_home_dir = /path/to/myibdata/
</pre><p>
                    For related information, see
                    <a class="xref" href="innodb-storage-engine.html#innodb-init-startup-configuration" title="14.8.1&nbsp;InnoDB Startup Configuration">Section&nbsp;14.8.1, “InnoDB Startup Configuration”</a>.
                </p><p style="color:blue;">有关信息，请参阅14.8.1节，“InnoDB启动配置”。</p></li><li class="listitem"><p><a name="sysvar_innodb_deadlock_detect"></a>
                <a class="indexterm" name="idm140286813233264"></a>

                <a class="indexterm" name="idm140286813232224"></a>

                <code class="literal">innodb_deadlock_detect</code>
            </p><p style="color:blue;">InnoDB_死锁_检测</p>
                <div class="informaltable">
                    <table frame="box" rules="all" summary="Properties for innodb_deadlock_detect"><colgroup><col width="30%"><col width="70%"></colgroup><thead><tr><th scope="col">Property</th>
                        <th scope="col">Value</th>
                    </tr></thead><tbody><tr><td scope="row"><span class="bold"><strong>Command-Line Format</strong></span></td>
                        <td><code class="literal">--innodb-deadlock-detect[={OFF|ON}]</code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Introduced</strong></span></td>
                        <td>5.7.15</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>System Variable</strong></span></td>
                        <td><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_deadlock_detect">innodb_deadlock_detect</a></code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Scope</strong></span></td>
                        <td>Global</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Dynamic</strong></span></td>
                        <td>Yes</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Type</strong></span></td>
                        <td>Boolean</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Default Value</strong></span></td>
                        <td><code class="literal">ON</code></td>
                    </tr></tbody></table>
                </div>
                <p>
                    This option is used to disable deadlock detection. On high
                    concurrency systems, deadlock detection can cause a slowdown
                    when numerous threads wait for the same lock. At times, it may
                    be more efficient to disable deadlock detection and rely on
                    the <a class="link" href="innodb-storage-engine.html#sysvar_innodb_lock_wait_timeout"><code class="literal">innodb_lock_wait_timeout</code></a>
                    setting for transaction rollback when a deadlock occurs.
                </p><p style="color:blue;">此选项用于禁用死锁检测。在高并发性系统中，当多个线程等待同一个锁时，死锁检测可能会导致速度减慢。有时，禁用死锁检测和在发生死锁时依赖innodb_lock_wait_timeout设置进行事务回滚可能更有效。</p><p>
                    For related information, see
                    <a class="xref" href="innodb-storage-engine.html#innodb-deadlock-detection" title="14.7.5.2&nbsp;Deadlock Detection and Rollback">Section&nbsp;14.7.5.2, “Deadlock Detection and Rollback”</a>.
                </p><p style="color:blue;">有关信息，请参阅第14.7.5.2节“死锁检测和回滚”。</p></li><li class="listitem"><p><a name="sysvar_innodb_default_row_format"></a>
                <a class="indexterm" name="idm140286813199136"></a>

                <a class="indexterm" name="idm140286813198032"></a>

                <code class="literal">innodb_default_row_format</code>
            </p><p style="color:blue;">innodb_default_row_格式</p>
                <div class="informaltable">
                    <table frame="box" rules="all" summary="Properties for innodb_default_row_format"><colgroup><col width="30%"><col width="70%"></colgroup><thead><tr><th scope="col">Property</th>
                        <th scope="col">Value</th>
                    </tr></thead><tbody><tr><td scope="row"><span class="bold"><strong>Command-Line Format</strong></span></td>
                        <td><code class="literal">--innodb-default-row-format=value</code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Introduced</strong></span></td>
                        <td>5.7.9</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>System Variable</strong></span></td>
                        <td><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_default_row_format">innodb_default_row_format</a></code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Scope</strong></span></td>
                        <td>Global</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Dynamic</strong></span></td>
                        <td>Yes</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Type</strong></span></td>
                        <td>Enumeration</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Default Value</strong></span></td>
                        <td><code class="literal">DYNAMIC</code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Valid Values</strong></span></td>
                        <td><p class="valid-value"><code class="literal">DYNAMIC</code></p><p style="color:blue;">动态的</p><p class="valid-value"><code class="literal">COMPACT</code></p><p style="color:blue;">粉盒</p><p class="valid-value"><code class="literal">REDUNDANT</code></p><p style="color:blue;">冗余</p></td>
                    </tr></tbody></table>
                </div>
                <p>
                    The <code class="literal">innodb_default_row_format</code> option
                    defines the default row format for <code class="literal">InnoDB</code>
                    tables and user-created temporary tables. The default setting
                    is <code class="literal">DYNAMIC</code>. Other permitted values are
                    <code class="literal">COMPACT</code> and <code class="literal">REDUNDANT</code>.
                    The <code class="literal">COMPRESSED</code> row format, which is not
                    supported for use in the
                    <a class="link" href="glossary.html#glos_system_tablespace" title="system tablespace">system
                        tablespace</a>, cannot be defined as the default.
                </p><p style="color:blue;">innodb_default_row_format选项定义innodb表和用户创建的临时表的默认行格式。默认设置为动态。其他允许值是紧凑和冗余的。压缩行格式不支持在系统表空间中使用，不能定义为默认格式。</p><p>
                    Newly created tables use the row format defined by
                    <a class="link" href="innodb-storage-engine.html#sysvar_innodb_default_row_format"><code class="literal">innodb_default_row_format</code></a>
                    when a <code class="literal">ROW_FORMAT</code> option is not specified
                    explicitly or when <code class="literal">ROW_FORMAT=DEFAULT</code> is
                    used.
                </p><p style="color:blue;">当没有显式指定row_format选项或使用row_format=default时，新创建的表使用innodb_default_row_format定义的行格式。</p><p>
                    When a <code class="literal">ROW_FORMAT</code> option is not specified
                    explicitly or when <code class="literal">ROW_FORMAT=DEFAULT</code> is
                    used, any operation that rebuilds a table also silently
                    changes the row format of the table to the format defined by
                    <a class="link" href="innodb-storage-engine.html#sysvar_innodb_default_row_format"><code class="literal">innodb_default_row_format</code></a>.
                    For more information, see
                    <a class="xref" href="innodb-storage-engine.html#innodb-row-format-defining" title="Defining the Row Format of a Table">Defining the Row Format of a Table</a>.
                </p><p style="color:blue;">当没有显式指定row_format选项或使用row_format=default时，任何重建表的操作也会将表的行格式静默地更改为innodb_default_row_format定义的格式。有关详细信息，请参见定义表格的行格式。</p><p>
                    Internal <code class="literal">InnoDB</code> temporary tables created by
                    the server to process queries use the
                    <code class="literal">DYNAMIC</code> row format, regardless of the
                    <a class="link" href="innodb-storage-engine.html#sysvar_innodb_default_row_format"><code class="literal">innodb_default_row_format</code></a>
                    setting.
                </p><p style="color:blue;">服务器为处理查询而创建的内部innodb临时表使用动态行格式，而不考虑innodb_默认的行格式设置。</p></li><li class="listitem"><p><a name="sysvar_innodb_disable_sort_file_cache"></a>
                <a class="indexterm" name="idm140286813146368"></a>

                <a class="indexterm" name="idm140286813145264"></a>

                <code class="literal">innodb_disable_sort_file_cache</code>
            </p><p style="color:blue;">innodb_disable_sort_file_缓存</p>
                <div class="informaltable">
                    <table frame="box" rules="all" summary="Properties for innodb_disable_sort_file_cache"><colgroup><col width="30%"><col width="70%"></colgroup><thead><tr><th scope="col">Property</th>
                        <th scope="col">Value</th>
                    </tr></thead><tbody><tr><td scope="row"><span class="bold"><strong>Command-Line Format</strong></span></td>
                        <td><code class="literal">--innodb-disable-sort-file-cache[={OFF|ON}]</code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>System Variable</strong></span></td>
                        <td><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_disable_sort_file_cache">innodb_disable_sort_file_cache</a></code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Scope</strong></span></td>
                        <td>Global</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Dynamic</strong></span></td>
                        <td>Yes</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Type</strong></span></td>
                        <td>Boolean</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Default Value</strong></span></td>
                        <td><code class="literal">OFF</code></td>
                    </tr></tbody></table>
                </div>
                <p>
                    Disables the operating system file system cache for merge-sort
                    temporary files. The effect is to open such files with the
                    equivalent of <code class="literal">O_DIRECT</code>.
                </p><p style="color:blue;">为合并排序临时文件禁用操作系统文件系统缓存。这样做的效果是打开类似于o_direct的文件。</p></li><li class="listitem"><p><a name="sysvar_innodb_disable_resize_buffer_pool_debug"></a>
                <a class="indexterm" name="idm140286813116704"></a>

                <a class="indexterm" name="idm140286813115616"></a>

                <code class="literal">innodb_disable_resize_buffer_pool_debug</code>
            </p><p style="color:blue;">innodb_disable_resize_buffer_pool_调试</p>
                <div class="informaltable">
                    <table frame="box" rules="all" summary="Properties for innodb_disable_resize_buffer_pool_debug"><colgroup><col width="30%"><col width="70%"></colgroup><thead><tr><th scope="col">Property</th>
                        <th scope="col">Value</th>
                    </tr></thead><tbody><tr><td scope="row"><span class="bold"><strong>Command-Line Format</strong></span></td>
                        <td><code class="literal">--innodb-disable-resize-buffer-pool-debug[={OFF|ON}]</code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Introduced</strong></span></td>
                        <td>5.7.6</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>System Variable</strong></span></td>
                        <td><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_disable_resize_buffer_pool_debug">innodb_disable_resize_buffer_pool_debug</a></code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Scope</strong></span></td>
                        <td>Global</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Dynamic</strong></span></td>
                        <td>Yes</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Type</strong></span></td>
                        <td>Boolean</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Default Value</strong></span></td>
                        <td><code class="literal">ON</code></td>
                    </tr></tbody></table>
                </div>
                <p>
                    Disables resizing of the <code class="literal">InnoDB</code> buffer
                    pool. This option is only available if debugging support is
                    compiled in using the <a class="link" href="installing.html#option_cmake_with_debug"><code class="option">WITH_DEBUG</code></a>
                    <span class="command"><strong>CMake</strong></span> option.
                </p><p style="color:blue;">禁止调整innodb缓冲池的大小。只有在使用with_debug cmake选项编译调试支持时，此选项才可用。</p></li><li class="listitem"><p><a name="sysvar_innodb_doublewrite"></a>
                <a class="indexterm" name="idm140286813082784"></a>

                <a class="indexterm" name="idm140286813081744"></a>

                <a class="indexterm" name="idm140286813080256"></a>

                <code class="literal">innodb_doublewrite</code>
            </p><p style="color:blue;">innodb_双写</p>
                <div class="informaltable">
                    <table frame="box" rules="all" summary="Properties for innodb_doublewrite"><colgroup><col width="30%"><col width="70%"></colgroup><thead><tr><th scope="col">Property</th>
                        <th scope="col">Value</th>
                    </tr></thead><tbody><tr><td scope="row"><span class="bold"><strong>Command-Line Format</strong></span></td>
                        <td><code class="literal">--innodb-doublewrite[={OFF|ON}]</code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>System Variable</strong></span></td>
                        <td><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_doublewrite">innodb_doublewrite</a></code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Scope</strong></span></td>
                        <td>Global</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Dynamic</strong></span></td>
                        <td>No</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Type</strong></span></td>
                        <td>Boolean</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Default Value</strong></span></td>
                        <td><code class="literal">ON</code></td>
                    </tr></tbody></table>
                </div>
                <p>
                    When enabled (the default), <code class="literal">InnoDB</code> stores
                    all data twice, first to the
                    <a class="link" href="glossary.html#glos_doublewrite_buffer" title="doublewrite buffer">doublewrite
                        buffer</a>, then to the actual
                    <a class="link" href="glossary.html#glos_data_files" title="data files">data files</a>. This
                    variable can be turned off with
                    <code class="option">--skip-innodb-doublewrite</code> for benchmarks or
                    cases when top performance is needed rather than concern for
                    data integrity or possible failures.
                </p><p style="color:blue;">启用时（默认），innodb将所有数据存储两次，首先存储到doublewrite缓冲区，然后存储到实际的数据文件。当需要最高性能而不是关注数据完整性或可能出现的故障时，可以使用--skip innodb doublewrite关闭这个变量。</p><p>
                    If system tablespace data files (<code class="filename">ibdata*</code>
                    files) are located on Fusion-io devices that support atomic
                    writes, doublewrite buffering is automatically disabled and
                    Fusion-io atomic writes are used for all data files. Because
                    the doublewrite buffer setting is global, doublewrite
                    buffering is also disabled for data files residing on
                    non-Fusion-io hardware. This feature is only supported on
                    Fusion-io hardware and only enabled for Fusion-io NVMFS on
                    Linux. To take full advantage of this feature, an
                    <a class="link" href="innodb-storage-engine.html#sysvar_innodb_flush_method"><code class="literal">innodb_flush_method</code></a> setting
                    of <code class="literal">O_DIRECT</code> is recommended.
                </p><p style="color:blue;">如果系统表空间数据文件（ibdata*文件）位于支持原子写入的fusion io设备上，则会自动禁用doublewrite缓冲，并对所有数据文件使用fusion io原子写入。由于doublewrite缓冲区设置是全局的，因此也会对驻留在非Fusion IO硬件上的数据文件禁用doublewrite缓冲。此功能仅在Fusion IO硬件上受支持，并且仅在Linux上为Fusion IO NVMFS启用。为了充分利用这一特性，建议将innodb_flush_method设置为o_direct。</p><p>
                    For related information, see
                    <a class="xref" href="innodb-storage-engine.html#innodb-doublewrite-buffer" title="14.6.5&nbsp;Doublewrite Buffer">Section&nbsp;14.6.5, “Doublewrite Buffer”</a>.
                </p><p style="color:blue;">有关信息，请参阅第14.6.5节“双写缓冲区”。</p></li><li class="listitem"><p><a name="sysvar_innodb_fast_shutdown"></a>
                <a class="indexterm" name="idm140286813044960"></a>

                <a class="indexterm" name="idm140286813043920"></a>

                <code class="literal">innodb_fast_shutdown</code>
            </p><p style="color:blue;">InnoDB_快速关闭</p>
                <div class="informaltable">
                    <table frame="box" rules="all" summary="Properties for innodb_fast_shutdown"><colgroup><col width="30%"><col width="70%"></colgroup><thead><tr><th scope="col">Property</th>
                        <th scope="col">Value</th>
                    </tr></thead><tbody><tr><td scope="row"><span class="bold"><strong>Command-Line Format</strong></span></td>
                        <td><code class="literal">--innodb-fast-shutdown=#</code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>System Variable</strong></span></td>
                        <td><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_fast_shutdown">innodb_fast_shutdown</a></code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Scope</strong></span></td>
                        <td>Global</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Dynamic</strong></span></td>
                        <td>Yes</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Type</strong></span></td>
                        <td>Integer</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Default Value</strong></span></td>
                        <td><code class="literal">1</code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Valid Values</strong></span></td>
                        <td><p class="valid-value"><code class="literal">0</code></p><p style="color:blue;">0个</p><p class="valid-value"><code class="literal">1</code></p><p style="color:blue;">1个</p><p class="valid-value"><code class="literal">2</code></p><p style="color:blue;">2个</p></td>
                    </tr></tbody></table>
                </div>
                <p>
                    The <code class="literal">InnoDB</code>
                    <a class="link" href="glossary.html#glos_shutdown" title="shutdown">shutdown</a> mode. If the
                    value is 0, <code class="literal">InnoDB</code> does a
                    <a class="link" href="glossary.html#glos_slow_shutdown" title="slow shutdown">slow shutdown</a>, a
                    full <a class="link" href="glossary.html#glos_purge" title="purge">purge</a> and a change
                    buffer merge before shutting down. If the value is 1 (the
                    default), <code class="literal">InnoDB</code> skips these operations at
                    shutdown, a process known as a
                    <a class="link" href="glossary.html#glos_fast_shutdown" title="fast shutdown">fast shutdown</a>. If
                    the value is 2, <code class="literal">InnoDB</code> flushes its logs and
                    shuts down cold, as if MySQL had crashed; no committed
                    transactions are lost, but the
                    <a class="link" href="glossary.html#glos_crash_recovery" title="crash recovery">crash recovery</a>
                    operation makes the next startup take longer.
                </p><p style="color:blue;">InnoDB关闭模式。如果该值为0，innodb会在关机前进行缓慢关机、完全清除和更改缓冲区合并。如果值为1（默认值），innodb会在关机时跳过这些操作，这是一个称为快速关机的过程。如果值为2，innodb会刷新日志并冷关机，就像mysql崩溃了一样；不会丢失提交的事务，但是崩溃恢复操作会使下一次启动花费更长的时间。</p><p>
                    The slow shutdown can take minutes, or even hours in extreme
                    cases where substantial amounts of data are still buffered.
                    Use the slow shutdown technique before upgrading or
                    downgrading between MySQL major releases, so that all data
                    files are fully prepared in case the upgrade process updates
                    the file format.
                </p><p style="color:blue;">在大量数据仍处于缓冲状态的极端情况下，缓慢关闭可能需要几分钟甚至几小时。在MySQL主要版本之间升级或降级之前，请使用慢速关闭技术，以便在升级过程更新文件格式时，所有数据文件都已准备就绪。</p><p>
                    Use <code class="literal">innodb_fast_shutdown=2</code> in emergency or
                    troubleshooting situations, to get the absolute fastest
                    shutdown if data is at risk of corruption.
                </p><p style="color:blue;">在紧急情况或故障排除情况下使用innodb_fast_shutdown=2，在数据有损坏风险时获得绝对最快的关闭。</p></li><li class="listitem"><p><a name="sysvar_innodb_fil_make_page_dirty_debug"></a>
                <a class="indexterm" name="idm140286813001408"></a>

                <a class="indexterm" name="idm140286813000368"></a>

                <code class="literal">innodb_fil_make_page_dirty_debug</code>
            </p><p style="color:blue;">innodb_fil_make_page_dirty_调试</p>
                <div class="informaltable">
                    <table frame="box" rules="all" summary="Properties for innodb_fil_make_page_dirty_debug"><colgroup><col width="30%"><col width="70%"></colgroup><thead><tr><th scope="col">Property</th>
                        <th scope="col">Value</th>
                    </tr></thead><tbody><tr><td scope="row"><span class="bold"><strong>Command-Line Format</strong></span></td>
                        <td><code class="literal">--innodb-fil-make-page-dirty-debug=#</code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>System Variable</strong></span></td>
                        <td><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_fil_make_page_dirty_debug">innodb_fil_make_page_dirty_debug</a></code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Scope</strong></span></td>
                        <td>Global</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Dynamic</strong></span></td>
                        <td>Yes</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Type</strong></span></td>
                        <td>Integer</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Default Value</strong></span></td>
                        <td><code class="literal">0</code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Maximum Value</strong></span></td>
                        <td><code class="literal">2**32-1</code></td>
                    </tr></tbody></table>
                </div>
                <p>
                    By default, setting
                    <code class="literal">innodb_fil_make_page_dirty_debug</code> to the ID
                    of a tablespace immediately dirties the first page of the
                    tablespace. If
                    <a class="link" href="innodb-storage-engine.html#sysvar_innodb_saved_page_number_debug"><code class="literal">innodb_saved_page_number_debug</code></a>
                    is set to a non-default value, setting
                    <code class="literal">innodb_fil_make_page_dirty_debug</code> dirties
                    the specified page. The
                    <code class="literal">innodb_fil_make_page_dirty_debug</code> option is
                    only available if debugging support is compiled in using the
                    <a class="link" href="installing.html#option_cmake_with_debug"><code class="option">WITH_DEBUG</code></a>
                    <span class="command"><strong>CMake</strong></span> option.
                </p><p style="color:blue;">默认情况下，将innodb_fil_make_page_dirty_debug设置为表空间的id会立即污染表空间的第一页。如果将innodb_saved_page_number_debug设置为非默认值，则将innodb_fil_make_page_dirty_debug设置为指定页。innodb_fil_make_page_dirty_debug选项仅在使用with_debug cmake选项编译调试支持时可用。</p></li><li class="listitem"><p><a name="sysvar_innodb_file_format"></a>
                <a class="indexterm" name="idm140286812964240"></a>

                <a class="indexterm" name="idm140286812963200"></a>

                <a class="indexterm" name="idm140286812961712"></a>

                <a class="indexterm" name="idm140286812960640"></a>

                <code class="literal">innodb_file_format</code>
            </p><p style="color:blue;">innodb_文件格式</p>
                <div class="informaltable">
                    <table frame="box" rules="all" summary="Properties for innodb_file_format"><colgroup><col width="30%"><col width="70%"></colgroup><thead><tr><th scope="col">Property</th>
                        <th scope="col">Value</th>
                    </tr></thead><tbody><tr><td scope="row"><span class="bold"><strong>Command-Line Format</strong></span></td>
                        <td><code class="literal">--innodb-file-format=value</code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Deprecated</strong></span></td>
                        <td>5.7.7</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>System Variable</strong></span></td>
                        <td><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_file_format">innodb_file_format</a></code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Scope</strong></span></td>
                        <td>Global</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Dynamic</strong></span></td>
                        <td>Yes</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Type</strong></span></td>
                        <td>String</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Default Value</strong></span> (&gt;= 5.7.7)</td>
                        <td><code class="literal">Barracuda</code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Default Value</strong></span> (&lt;= 5.7.6)</td>
                        <td><code class="literal">Antelope</code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Valid Values</strong></span></td>
                        <td><p class="valid-value"><code class="literal">Antelope</code></p><p style="color:blue;">羚羊</p><p class="valid-value"><code class="literal">Barracuda</code></p><p style="color:blue;">梭鱼</p></td>
                    </tr></tbody></table>
                </div>
                <p>
                    Enables an <code class="literal">InnoDB</code> file format for
                    <a class="link" href="glossary.html#glos_file_per_table" title="file-per-table">file-per-table</a>
                    tablespaces. Supported file formats are
                    <code class="literal">Antelope</code> and <code class="literal">Barracuda</code>.
                    <code class="literal">Antelope</code> is the original
                    <code class="literal">InnoDB</code> file format, which supports
                    <code class="literal">REDUNDANT</code> and <code class="literal">COMPACT</code>
                    row formats. <code class="literal">Barracuda</code> is the newer file
                    format, which supports <code class="literal">COMPRESSED</code> and
                    <code class="literal">DYNAMIC</code> row formats.
                </p><p style="color:blue;">为每表表空间的文件启用innodb文件格式。支持的文件格式是羚羊和梭鱼。羚羊是原始的innodb文件格式，它支持冗余和紧凑的行格式。Barracuda是较新的文件格式，它支持压缩和动态行格式。</p><p>
                    <code class="literal">COMPRESSED</code> and <code class="literal">DYNAMIC</code>
                    row formats enable important storage features for
                    <code class="literal">InnoDB</code> tables. See
                    <a class="xref" href="innodb-storage-engine.html#innodb-row-format" title="14.11&nbsp;InnoDB Row Formats">Section&nbsp;14.11, “InnoDB Row Formats”</a>.
                </p><p style="color:blue;">压缩和动态行格式为innodb表提供了重要的存储特性。见第14.11节，“InnoDB行格式”。</p><p>
                    Changing the
                    <a class="link" href="innodb-storage-engine.html#sysvar_innodb_file_format"><code class="literal">innodb_file_format</code></a> setting
                    does not affect the file format of existing
                    <code class="literal">InnoDB</code> tablespace files.
                </p><p style="color:blue;">更改NoNbj.FieleFrad格式设置不会影响现有的UnIDB表空间文件的文件格式。</p><p>
                    The <a class="link" href="innodb-storage-engine.html#sysvar_innodb_file_format"><code class="literal">innodb_file_format</code></a>
                    setting does not apply to general tablespaces, which support
                    tables of all row formats. See
                    <a class="xref" href="innodb-storage-engine.html#general-tablespaces" title="14.6.3.3&nbsp;General Tablespaces">Section&nbsp;14.6.3.3, “General Tablespaces”</a>.
                </p><p style="color:blue;">innodb_file_format设置不适用于通用表空间，后者支持所有行格式的表。见第14.6.3.3节“通用表空间”。</p><p>
                    The <a class="link" href="innodb-storage-engine.html#sysvar_innodb_file_format"><code class="literal">innodb_file_format</code></a>
                    default value was changed to <code class="literal">Barracuda</code> in
                    MySQL 5.7.
                </p><p style="color:blue;">在mysql 5.7中，innodb_file_格式的默认值更改为barracuda。</p><p>
                    The <a class="link" href="innodb-storage-engine.html#sysvar_innodb_file_format"><code class="literal">innodb_file_format</code></a>
                    setting is ignored when creating tables that use the
                    <code class="literal">DYNAMIC</code> row format. A table created using
                    the <code class="literal">DYNAMIC</code> row format always uses the
                    <code class="literal">Barracuda</code> file format, regardless of the
                    <a class="link" href="innodb-storage-engine.html#sysvar_innodb_file_format"><code class="literal">innodb_file_format</code></a> setting.
                    To use the <code class="literal">COMPRESSED</code> row format,
                    <a class="link" href="innodb-storage-engine.html#sysvar_innodb_file_format"><code class="literal">innodb_file_format</code></a> must be
                    set to <code class="literal">Barracuda</code>.
                </p><p style="color:blue;">创建使用动态行格式的表时，忽略innodb_file_format设置。使用动态行格式创建的表总是使用barracuda文件格式，而不管innodb_file_格式设置如何。要使用压缩行格式，必须将innodb_file_format设置为barracuda。</p><p>
                    The <a class="link" href="innodb-storage-engine.html#sysvar_innodb_file_format"><code class="literal">innodb_file_format</code></a> option
                    is deprecated and will be removed in a future release. The
                    purpose of the
                    <a class="link" href="innodb-storage-engine.html#sysvar_innodb_file_format"><code class="literal">innodb_file_format</code></a> option was
                    to allow users to downgrade to the built-in version of
                    <code class="literal">InnoDB</code> in earlier versions of MySQL. Now
                    that those MySQL versions have reached the end of their
                    product lifecycle, downgrade support provided by this option
                    is no longer necessary.
                </p><p style="color:blue;">innodb_file_format选项已弃用，将在以后的版本中删除。innodb_file_format选项的目的是允许用户降级到mysql早期版本中的innodb内置版本。现在这些mysql版本已经到了产品生命周期的末尾，不再需要使用此选项提供的降级支持。</p><p>
                    For more information, see
                    <a class="xref" href="innodb-storage-engine.html#innodb-file-format" title="14.10&nbsp;InnoDB File-Format Management">Section&nbsp;14.10, “InnoDB File-Format Management”</a>.
                </p><p style="color:blue;">有关更多信息，请参阅14.10节，“InnoDB文件格式管理”。</p></li><li class="listitem"><p><a name="sysvar_innodb_file_format_check"></a>
                <a class="indexterm" name="idm140286812890864"></a>

                <a class="indexterm" name="idm140286812889760"></a>

                <code class="literal">innodb_file_format_check</code>
            </p><p style="color:blue;">innodb_文件格式检查</p>
                <div class="informaltable">
                    <table frame="box" rules="all" summary="Properties for innodb_file_format_check"><colgroup><col width="30%"><col width="70%"></colgroup><thead><tr><th scope="col">Property</th>
                        <th scope="col">Value</th>
                    </tr></thead><tbody><tr><td scope="row"><span class="bold"><strong>Command-Line Format</strong></span></td>
                        <td><code class="literal">--innodb-file-format-check[={OFF|ON}]</code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Deprecated</strong></span></td>
                        <td>5.7.7</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>System Variable</strong></span></td>
                        <td><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_file_format_check">innodb_file_format_check</a></code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Scope</strong></span></td>
                        <td>Global</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Dynamic</strong></span></td>
                        <td>No</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Type</strong></span></td>
                        <td>Boolean</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Default Value</strong></span></td>
                        <td><code class="literal">ON</code></td>
                    </tr></tbody></table>
                </div>
                <p>
                    This variable can be set to 1 or 0 at server startup to enable
                    or disable whether <code class="literal">InnoDB</code> checks the
                    <a class="link" href="glossary.html#glos_file_format" title="file format">file format</a> tag in the
                    <a class="link" href="glossary.html#glos_system_tablespace" title="system tablespace">system
                        tablespace</a> (for example, <code class="literal">Antelope</code> or
                    <code class="literal">Barracuda</code>). If the tag is checked and is
                    higher than that supported by the current version of
                    <code class="literal">InnoDB</code>, an error occurs and
                    <code class="literal">InnoDB</code> does not start. If the tag is not
                    higher, <code class="literal">InnoDB</code> sets the value of
                    <a class="link" href="innodb-storage-engine.html#sysvar_innodb_file_format_max"><code class="literal">innodb_file_format_max</code></a> to the
                    file format tag.
                </p><p style="color:blue;">可以在服务器启动时将此变量设置为1或0，以启用或禁用innodb是否检查系统表空间中的文件格式标记（例如，羚羊或梭鱼）。如果标记被选中并且高于当前版本的innodb所支持的值，则会发生错误并且innodb不会启动。如果标记不高，innodb将innodb_file_format_max的值设置为file format标记。</p>
                <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">

                    <div class="admon-title">
                        Note
                    </div>
                    <p>
                        Despite the default value sometimes being displayed as
                        <code class="literal">ON</code> or <code class="literal">OFF</code>, always use
                        the numeric values 1 or 0 to turn this option on or off in
                        your configuration file or command line string.
                    </p><p style="color:blue;">尽管默认值有时显示为开或关，但始终使用数值1或0在配置文件或命令行字符串中打开或关闭此选项。</p>
                </div>
                <p>
                    For more information, see
                    <a class="xref" href="innodb-storage-engine.html#innodb-file-format-compatibility-checking" title="14.10.2.1&nbsp;Compatibility Check When InnoDB Is Started">Section&nbsp;14.10.2.1, “Compatibility Check When InnoDB Is Started”</a>.
                </p><p style="color:blue;">有关更多信息，请参阅14.10.2.1节，“InnoDB启动时的兼容性检查”。</p><p>
                    The <a class="link" href="innodb-storage-engine.html#sysvar_innodb_file_format_check"><code class="literal">innodb_file_format_check</code></a>
                    option is deprecated together with the
                    <a class="link" href="innodb-storage-engine.html#sysvar_innodb_file_format"><code class="literal">innodb_file_format</code></a> option.
                    Both options will be removed in a future release.
                </p><p style="color:blue;">innodb_file_format_check选项与innodb_file_format选项一起被弃用。这两个选项将在以后的版本中删除。</p></li><li class="listitem"><p><a name="sysvar_innodb_file_format_max"></a>
                <a class="indexterm" name="idm140286812845152"></a>

                <a class="indexterm" name="idm140286812844112"></a>

                <code class="literal">innodb_file_format_max</code>
            </p><p style="color:blue;">innodb_file_format_最大值</p>
                <div class="informaltable">
                    <table frame="box" rules="all" summary="Properties for innodb_file_format_max"><colgroup><col width="30%"><col width="70%"></colgroup><thead><tr><th scope="col">Property</th>
                        <th scope="col">Value</th>
                    </tr></thead><tbody><tr><td scope="row"><span class="bold"><strong>Command-Line Format</strong></span></td>
                        <td><code class="literal">--innodb-file-format-max=value</code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Deprecated</strong></span></td>
                        <td>5.7.7</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>System Variable</strong></span></td>
                        <td><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_file_format_max">innodb_file_format_max</a></code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Scope</strong></span></td>
                        <td>Global</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Dynamic</strong></span></td>
                        <td>Yes</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Type</strong></span></td>
                        <td>String</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Default Value</strong></span> (&gt;= 5.7.9)</td>
                        <td><code class="literal">Barracuda</code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Default Value</strong></span> (&lt;= 5.7.8)</td>
                        <td><code class="literal">Antelope</code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Valid Values</strong></span></td>
                        <td><p class="valid-value"><code class="literal">Antelope</code></p><p style="color:blue;">羚羊</p><p class="valid-value"><code class="literal">Barracuda</code></p><p style="color:blue;">梭鱼</p></td>
                    </tr></tbody></table>
                </div>
                <p>
                    At server startup, <code class="literal">InnoDB</code> sets the value of
                    this variable to the <a class="link" href="glossary.html#glos_file_format" title="file format">file
                    format</a> tag in the
                    <a class="link" href="glossary.html#glos_system_tablespace" title="system tablespace">system
                        tablespace</a> (for example, <code class="literal">Antelope</code> or
                    <code class="literal">Barracuda</code>). If the server creates or opens
                    a table with a <span class="quote">“<span class="quote">higher</span>”</span> file format, it sets the
                    value of
                    <a class="link" href="innodb-storage-engine.html#sysvar_innodb_file_format_max"><code class="literal">innodb_file_format_max</code></a> to
                    that format.
                </p><p style="color:blue;">在服务器启动时，innodb将此变量的值设置为系统表空间中的文件格式标记（例如，羚羊或梭鱼）。如果服务器创建或打开一个具有“更高”文件格式的表，它会将innodb_file_format_max的值设置为该格式。</p><p>
                    For related information, see
                    <a class="xref" href="innodb-storage-engine.html#innodb-file-format" title="14.10&nbsp;InnoDB File-Format Management">Section&nbsp;14.10, “InnoDB File-Format Management”</a>.
                </p><p style="color:blue;">有关信息，请参阅14.10节，“InnoDB文件格式管理”。</p><p>
                    The <a class="link" href="innodb-storage-engine.html#sysvar_innodb_file_format_max"><code class="literal">innodb_file_format_max</code></a>
                    option is deprecated together with the
                    <a class="link" href="innodb-storage-engine.html#sysvar_innodb_file_format"><code class="literal">innodb_file_format</code></a> option.
                    Both options will be removed in a future release.
                </p><p style="color:blue;">innodb_file_format_max选项与innodb_file_format选项一起被弃用。这两个选项将在以后的版本中删除。</p></li><li class="listitem"><p><a name="sysvar_innodb_file_per_table"></a>
                <a class="indexterm" name="idm140286812796000"></a>

                <a class="indexterm" name="idm140286812794960"></a>

                <code class="literal">innodb_file_per_table</code>
            </p><p style="color:blue;">innodb_file_per_表</p>
                <div class="informaltable">
                    <table frame="box" rules="all" summary="Properties for innodb_file_per_table"><colgroup><col width="30%"><col width="70%"></colgroup><thead><tr><th scope="col">Property</th>
                        <th scope="col">Value</th>
                    </tr></thead><tbody><tr><td scope="row"><span class="bold"><strong>Command-Line Format</strong></span></td>
                        <td><code class="literal">--innodb-file-per-table[={OFF|ON}]</code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>System Variable</strong></span></td>
                        <td><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_file_per_table">innodb_file_per_table</a></code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Scope</strong></span></td>
                        <td>Global</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Dynamic</strong></span></td>
                        <td>Yes</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Type</strong></span></td>
                        <td>Boolean</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Default Value</strong></span></td>
                        <td><code class="literal">ON</code></td>
                    </tr></tbody></table>
                </div>
                <p>
                    When <a class="link" href="innodb-storage-engine.html#sysvar_innodb_file_per_table"><code class="literal">innodb_file_per_table</code></a> is
                    enabled, tables are created in file-per-table tablespaces by
                    default. When disabled, tables are created in the system
                    tablespace by default. For information about file-per-table
                    tablespaces, see
                    <a class="xref" href="innodb-storage-engine.html#innodb-multiple-tablespaces" title="14.6.3.2&nbsp;File-Per-Table Tablespaces">Section&nbsp;14.6.3.2, “File-Per-Table Tablespaces”</a>. For information
                    about the <code class="literal">InnoDB</code> system tablespace, see
                    <a class="xref" href="innodb-storage-engine.html#innodb-system-tablespace" title="14.6.3.1&nbsp;The System Tablespace">Section&nbsp;14.6.3.1, “The System Tablespace”</a>.
                </p><p style="color:blue;">当启用innodb_file_per_table时，默认情况下在file per table spaces中创建表。禁用时，默认情况下在系统表空间中创建表。有关每表表空间文件的信息，请参阅14.6.3.2节“每表表空间文件”。有关innodb系统表空间的信息，请参阅14.6.3.1节“系统表空间”。</p><p>
                    The <a class="link" href="innodb-storage-engine.html#sysvar_innodb_file_per_table"><code class="literal">innodb_file_per_table</code></a>
                    variable can be configured at runtime using a
                    <a class="link" href="sql-syntax.html#set-variable" title="13.7.4.1&nbsp;SET Syntax for Variable Assignment"><code class="literal">SET
                        GLOBAL</code></a> statement, specified on the command line at
                    startup, or specified in an option file. Configuration at
                    runtime requires privileges sufficient to set global system
                    variables (see <a class="xref" href="server-administration.html#system-variable-privileges" title="5.1.8.1&nbsp;System Variable Privileges">Section&nbsp;5.1.8.1, “System Variable Privileges”</a>)
                    and immediately affects the operation of all connections.
                </p><p style="color:blue;">innodb_file_per_table变量可以在运行时使用set global语句进行配置，可以在启动时在命令行中指定，也可以在选项文件中指定。运行时配置需要足够的权限来设置全局系统变量（请参阅第5.1.8.1节“系统变量权限”），并立即影响所有连接的操作。</p><p>
                    When a table that resides in a file-per-table tablespace is
                    truncated or dropped, the freed space is returned to the
                    operating system. Truncating or dropping a table that resides
                    in the system tablespace only frees space in the system
                    tablespace. Freed space in the system tablespace can be used
                    again for <code class="literal">InnoDB</code> data but is not returned
                    to the operating system, as system tablespace data files never
                    shrink.
                </p><p style="color:blue;">当位于每个表空间的文件中的表被截断或删除时，释放的空间将返回给操作系统。截断或删除驻留在系统表空间中的表只会释放系统表空间中的空间。系统表空间中释放的空间可以再次用于innodb数据，但不会返回给操作系统，因为系统表空间数据文件永远不会收缩。</p><p>
                    When <a class="link" href="innodb-storage-engine.html#sysvar_innodb_file_per_table"><code class="literal">innodb_file_per_table</code></a> is
                    enabled, a table-copying <a class="link" href="sql-syntax.html#alter-table" title="13.1.8&nbsp;ALTER TABLE Syntax"><code class="literal">ALTER
                    TABLE</code></a> operation on a table that resides in the
                    system tablespace implicitly re-creates the table in a
                    file-per-table tablespace. To prevent this from occurring,
                    disable <a class="link" href="innodb-storage-engine.html#sysvar_innodb_file_per_table"><code class="literal">innodb_file_per_table</code></a>
                    before executing table-copying <a class="link" href="sql-syntax.html#alter-table" title="13.1.8&nbsp;ALTER TABLE Syntax"><code class="literal">ALTER
                    TABLE</code></a> operations on tables that reside in the system
                    tablespace.
                </p><p style="color:blue;">当启用innodb_file_per_table时，在系统表空间中的表上执行表复制alter table操作会隐式地在file per table table space中重新创建表。要防止这种情况发生，请在对系统表空间中的表执行表复制alter table操作之前禁用innodb_file_per_table。</p><p>
                    The <a class="link" href="innodb-storage-engine.html#sysvar_innodb_file_per_table"><code class="literal">innodb_file_per-table</code></a>
                    setting does not affect the creation of temporary tables.
                    Temporary tables are created in the temporary tablespace. See
                    <a class="xref" href="innodb-storage-engine.html#innodb-temporary-tablespace" title="14.6.3.5&nbsp;The Temporary Tablespace">Section&nbsp;14.6.3.5, “The Temporary Tablespace”</a>.
                </p><p style="color:blue;">innodb_file_per-table设置不影响临时表的创建。临时表是在临时表空间中创建的。见第14.6.3.5节“临时表空间”。</p></li><li class="listitem"><p><a name="sysvar_innodb_fill_factor"></a>
                <a class="indexterm" name="idm140286812749760"></a>

                <a class="indexterm" name="idm140286812748720"></a>

                <code class="literal">innodb_fill_factor</code>
            </p><p style="color:blue;">innodb_填充因子</p>
                <div class="informaltable">
                    <table frame="box" rules="all" summary="Properties for innodb_fill_factor"><colgroup><col width="30%"><col width="70%"></colgroup><thead><tr><th scope="col">Property</th>
                        <th scope="col">Value</th>
                    </tr></thead><tbody><tr><td scope="row"><span class="bold"><strong>Command-Line Format</strong></span></td>
                        <td><code class="literal">--innodb-fill-factor=#</code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Introduced</strong></span></td>
                        <td>5.7.5</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>System Variable</strong></span></td>
                        <td><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_fill_factor">innodb_fill_factor</a></code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Scope</strong></span></td>
                        <td>Global</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Dynamic</strong></span></td>
                        <td>Yes</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Type</strong></span></td>
                        <td>Integer</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Default Value</strong></span></td>
                        <td><code class="literal">100</code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Minimum Value</strong></span></td>
                        <td><code class="literal">10</code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Maximum Value</strong></span></td>
                        <td><code class="literal">100</code></td>
                    </tr></tbody></table>
                </div>
                <p>
                    <code class="literal">InnoDB</code> performs a bulk load when creating
                    or rebuilding indexes. This method of index creation is known
                    as a <span class="quote">“<span class="quote">sorted index build</span>”</span>.
                </p><p style="color:blue;">innodb在创建或重建索引时执行大容量加载。这种索引创建方法被称为“排序索引构建”。</p><p>
                    <code class="literal">innodb_fill_factor</code> defines the percentage
                    of space on each B-tree page that is filled during a sorted
                    index build, with the remaining space reserved for future
                    index growth. For example, setting
                    <code class="literal">innodb_fill_factor</code> to 80 reserves 20
                    percent of the space on each B-tree page for future index
                    growth. Actual percentages may vary. The
                    <code class="literal">innodb_fill_factor</code> setting is interpreted
                    as a hint rather than a hard limit.
                </p><p style="color:blue;">innodb_fill_factor定义在排序索引构建期间填充的每个b树页面上的空间百分比，剩余空间保留用于将来索引增长。例如，将innodb_fill_factor设置为80将保留每个b树页面上20%的空间，以供将来索引增长。实际百分比可能会有所不同。innodb_fill_factor设置被解释为提示，而不是硬限制。</p><p>
                    An <a class="link" href="innodb-storage-engine.html#sysvar_innodb_fill_factor"><code class="literal">innodb_fill_factor</code></a> setting
                    of 100 leaves 1/16 of the space in clustered index pages free
                    for future index growth.
                </p><p style="color:blue;">如果innodb_fill_factor设置为100，则聚集索引页中的1/16空间可供将来索引增长使用。</p><p>
                    <code class="literal">innodb_fill_factor</code> applies to both B-tree
                    leaf and non-leaf pages. It does not apply to external pages
                    used for <a class="link" href="data-types.html#blob" title="11.4.3&nbsp;The BLOB and TEXT Types"><code class="literal">TEXT</code></a> or
                    <a class="link" href="data-types.html#blob" title="11.4.3&nbsp;The BLOB and TEXT Types"><code class="literal">BLOB</code></a> entries.
                </p><p style="color:blue;">innodb_fill_factor同时适用于b-tree leaf和non leaf页面。它不适用于用于文本或blob项的外部页。</p><p>
                    For more information, see
                    <a class="xref" href="innodb-storage-engine.html#sorted-index-builds" title="14.6.2.3&nbsp;Sorted Index Builds">Section&nbsp;14.6.2.3, “Sorted Index Builds”</a>.
                </p><p style="color:blue;">有关更多信息，请参见第14.6.2.3节“排序索引生成”。</p></li><li class="listitem"><p><a name="sysvar_innodb_flush_log_at_timeout"></a>
                <a class="indexterm" name="idm140286812700848"></a>

                <a class="indexterm" name="idm140286812699744"></a>

                <code class="literal">innodb_flush_log_at_timeout</code>
            </p><p style="color:blue;">innodb_flush_log_at_超时</p>
                <div class="informaltable">
                    <table frame="box" rules="all" summary="Properties for innodb_flush_log_at_timeout"><colgroup><col width="30%"><col width="70%"></colgroup><thead><tr><th scope="col">Property</th>
                        <th scope="col">Value</th>
                    </tr></thead><tbody><tr><td scope="row"><span class="bold"><strong>Command-Line Format</strong></span></td>
                        <td><code class="literal">--innodb-flush-log-at-timeout=#</code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>System Variable</strong></span></td>
                        <td><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_flush_log_at_timeout">innodb_flush_log_at_timeout</a></code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Scope</strong></span></td>
                        <td>Global</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Dynamic</strong></span></td>
                        <td>Yes</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Type</strong></span></td>
                        <td>Integer</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Default Value</strong></span></td>
                        <td><code class="literal">1</code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Minimum Value</strong></span></td>
                        <td><code class="literal">1</code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Maximum Value</strong></span></td>
                        <td><code class="literal">2700</code></td>
                    </tr></tbody></table>
                </div>
                <p>
                    Write and flush the logs every <em class="replaceable"><code>N</code></em>
                    seconds.
                    <a class="link" href="innodb-storage-engine.html#sysvar_innodb_flush_log_at_timeout"><code class="literal">innodb_flush_log_at_timeout</code></a>
                    allows the timeout period between flushes to be increased in
                    order to reduce flushing and avoid impacting performance of
                    binary log group commit. The default setting for
                    <a class="link" href="innodb-storage-engine.html#sysvar_innodb_flush_log_at_timeout"><code class="literal">innodb_flush_log_at_timeout</code></a>
                    is once per second.
                </p><p style="color:blue;">每隔N秒写入并刷新日志。innodb_flush_log_at_timeout允许增加刷新之间的超时时间，以减少刷新并避免影响二进制日志组提交的性能。innodb_flush_log_at_timeout的默认设置是每秒一次。</p></li><li class="listitem"><p><a name="sysvar_innodb_flush_log_at_trx_commit"></a>
                <a class="indexterm" name="idm140286812662736"></a>

                <a class="indexterm" name="idm140286812661632"></a>

                <code class="literal">innodb_flush_log_at_trx_commit</code>
            </p><p style="color:blue;">innodb_flush_log_at_trx_提交</p>
                <div class="informaltable">
                    <table frame="box" rules="all" summary="Properties for innodb_flush_log_at_trx_commit"><colgroup><col width="30%"><col width="70%"></colgroup><thead><tr><th scope="col">Property</th>
                        <th scope="col">Value</th>
                    </tr></thead><tbody><tr><td scope="row"><span class="bold"><strong>Command-Line Format</strong></span></td>
                        <td><code class="literal">--innodb-flush-log-at-trx-commit=#</code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>System Variable</strong></span></td>
                        <td><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_flush_log_at_trx_commit">innodb_flush_log_at_trx_commit</a></code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Scope</strong></span></td>
                        <td>Global</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Dynamic</strong></span></td>
                        <td>Yes</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Type</strong></span></td>
                        <td>Enumeration</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Default Value</strong></span></td>
                        <td><code class="literal">1</code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Valid Values</strong></span></td>
                        <td><p class="valid-value"><code class="literal">0</code></p><p style="color:blue;">0个</p><p class="valid-value"><code class="literal">1</code></p><p style="color:blue;">1个</p><p class="valid-value"><code class="literal">2</code></p><p style="color:blue;">二</p></td>
                    </tr></tbody></table>
                </div>
                <p>
                    Controls the balance between strict
                    <a class="link" href="glossary.html#glos_acid" title="ACID">ACID</a> compliance for
                    <a class="link" href="glossary.html#glos_commit" title="commit">commit</a> operations and
                    higher performance that is possible when commit-related I/O
                    operations are rearranged and done in batches. You can achieve
                    better performance by changing the default value but then you
                    can lose transactions in a crash.
                </p><p style="color:blue;">控制提交操作的严格ACID遵从性与更高性能之间的平衡，当提交相关的I/O操作重新排列并成批完成时，这是可能的。通过更改默认值可以获得更好的性能，但是在崩溃时可能会丢失事务。</p>
                <div class="itemizedlist">
                    <ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
                        The default setting of 1 is required for full ACID
                        compliance. Logs are written and flushed to disk at each
                        transaction commit.
                    </p><p style="color:blue;">默认设置为1是完全符合ACID要求的。每次事务提交时，日志都会写入并刷新到磁盘。</p></li><li class="listitem"><p>
                        With a setting of 0, logs are written and flushed to disk
                        once per second. Transactions for which logs have not been
                        flushed can be lost in a crash.
                    </p><p style="color:blue;">设置为0时，每秒将日志写入并刷新到磁盘一次。未刷新日志的事务可能在崩溃中丢失。</p></li><li class="listitem"><p>
                        With a setting of 2, logs are written after each
                        transaction commit and flushed to disk once per second.
                        Transactions for which logs have not been flushed can be
                        lost in a crash.
                    </p><p style="color:blue;">设置为2时，每次事务提交后都会写入日志，并每秒刷新一次到磁盘。未刷新日志的事务可能在崩溃中丢失。</p></li><li class="listitem"><p>
                        For settings 0 and 2, once-per-second flushing is not 100%
                        guaranteed. Flushing may occur more frequently due to DDL
                        changes and other internal <code class="literal">InnoDB</code>
                        activities that cause logs to be flushed independently of
                        the
                        <a class="link" href="innodb-storage-engine.html#sysvar_innodb_flush_log_at_trx_commit"><code class="literal">innodb_flush_log_at_trx_commit</code></a>
                        setting, and sometimes less frequently due to scheduling
                        issues. If logs are flushed once per second, up to one
                        second of transactions can be lost in a crash. If logs are
                        flushed more or less frequently than once per second, the
                        amount of transactions that can be lost varies
                        accordingly.
                    </p><p style="color:blue;">对于设置0和2，每秒刷新一次不是100%保证的。由于ddl更改和其他内部innodb活动导致日志刷新独立于innodb_flush_log_at_trx_commit设置，刷新的频率可能更高，有时由于调度问题，刷新的频率更低。如果日志每秒刷新一次，则在崩溃中最多会丢失一秒钟的事务。如果日志刷新的频率大于或小于每秒一次，则可能丢失的事务量也会相应变化。</p></li><li class="listitem"><p>
                        Log flushing frequency is controlled by
                        <a class="link" href="innodb-storage-engine.html#sysvar_innodb_flush_log_at_timeout"><code class="literal">innodb_flush_log_at_timeout</code></a>,
                        which allows you to set log flushing frequency to
                        <em class="replaceable"><code>N</code></em> seconds (where
                        <em class="replaceable"><code>N</code></em> is <code class="literal">1 ...
                        2700</code>, with a default value of 1). However, any
                        <a class="link" href="programs.html#mysqld" title="4.3.1&nbsp;mysqld — The MySQL Server"><span class="command"><strong>mysqld</strong></span></a> process crash can erase up to
                        <em class="replaceable"><code>N</code></em> seconds of transactions.
                    </p><p style="color:blue;">日志刷新频率由innodb_flush_log_at_timeout控制，它允许您将日志刷新频率设置为n秒（其中n是1…2700，默认值为1）。但是，任何mysqld进程崩溃都可能删除多达n秒的事务。</p></li><li class="listitem"><p>
                        DDL changes and other internal <code class="literal">InnoDB</code>
                        activities flush the log independently of the
                        <code class="literal">innodb_flush_log_at_trx_commit</code> setting.
                    </p><p style="color:blue;">ddl更改和其他内部innodb活动刷新日志，与innodb_flush_log_at_trx_commit设置无关。</p></li><li class="listitem"><p>
                        <code class="literal">InnoDB</code>
                        <a class="link" href="glossary.html#glos_crash_recovery" title="crash recovery">crash recovery</a>
                        works regardless of the
                        <code class="literal">innodb_flush_log_at_trx_commit</code> setting.
                        Transactions are either applied entirely or erased
                        entirely.
                    </p><p style="color:blue;">无论innodb_flush_log_at_trx_commit设置如何，innodb崩溃恢复都可以工作。事务要么完全应用，要么完全删除。</p></li></ul>
                </div>
                <p>
                    For durability and consistency in a replication setup that
                    uses <code class="literal">InnoDB</code> with transactions:
                </p><p style="color:blue;">为了在使用InnoDB处理事务的复制设置中保持持久性和一致性：</p>
                <div class="itemizedlist">
                    <ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
                        If binary logging is enabled, set
                        <code class="literal">sync_binlog=1</code>.
                    </p><p style="color:blue;">如果启用了二进制日志记录，请将sync_binlog设置为1。</p></li><li class="listitem"><p>
                        Always set
                        <code class="literal">innodb_flush_log_at_trx_commit=1</code>.
                    </p><p style="color:blue;">始终将innodb_flush_log_设置为trx_commit=1。</p></li></ul>
                </div>
                <div class="caution" style="margin-left: 0.5in; margin-right: 0.5in;">
                    <div class="admon-title">
                        Caution
                    </div>
                    <p>
                        Many operating systems and some disk hardware fool the
                        flush-to-disk operation. They may tell
                        <a class="link" href="programs.html#mysqld" title="4.3.1&nbsp;mysqld — The MySQL Server"><span class="command"><strong>mysqld</strong></span></a> that the flush has taken place,
                        even though it has not. In this case, the durability of
                        transactions is not guaranteed even with the recommended
                        settings, and in the worst case, a power outage can corrupt
                        <code class="literal">InnoDB</code> data. Using a battery-backed disk
                        cache in the SCSI disk controller or in the disk itself
                        speeds up file flushes, and makes the operation safer. You
                        can also try to disable the caching of disk writes in
                        hardware caches.
                    </p><p style="color:blue;">许多操作系统和一些磁盘硬件欺骗了磁盘刷新操作。他们可能会告诉mysqld，已经发生了冲水，尽管还没有。在这种情况下，即使使用推荐的设置，也不能保证事务的持久性，在最坏的情况下，断电可能会损坏innodb数据。在SCSI磁盘控制器或磁盘本身中使用电池备份的磁盘缓存可以加快文件刷新速度，并使操作更安全。也可以尝试禁用硬件缓存中磁盘写入的缓存。</p>
                </div>
            </li><li class="listitem"><p><a name="sysvar_innodb_flush_method"></a>
                <a class="indexterm" name="idm140286812600752"></a>

                <a class="indexterm" name="idm140286812599712"></a>

                <code class="literal">innodb_flush_method</code>
            </p><p style="color:blue;">innodb_flush_方法</p>
                <div class="informaltable">
                    <table frame="box" rules="all" summary="Properties for innodb_flush_method"><colgroup><col width="30%"><col width="70%"></colgroup><thead><tr><th scope="col">Property</th>
                        <th scope="col">Value</th>
                    </tr></thead><tbody><tr><td scope="row"><span class="bold"><strong>Command-Line Format</strong></span></td>
                        <td><code class="literal">--innodb-flush-method=value</code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>System Variable</strong></span></td>
                        <td><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_flush_method">innodb_flush_method</a></code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Scope</strong></span></td>
                        <td>Global</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Dynamic</strong></span></td>
                        <td>No</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Type</strong></span></td>
                        <td>String</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Default Value</strong></span></td>
                        <td><code class="literal">NULL</code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Valid Values</strong></span> (Windows)</td>
                        <td><p class="valid-value"><code class="literal">async_unbuffered</code></p><p style="color:blue;">异步无缓冲</p><p class="valid-value"><code class="literal">normal</code></p><p style="color:blue;">正常的</p><p class="valid-value"><code class="literal">unbuffered</code></p><p style="color:blue;">无缓冲</p></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Valid Values</strong></span> (Unix)</td>
                        <td><p class="valid-value"><code class="literal">fsync</code></p><p style="color:blue;">同步</p><p class="valid-value"><code class="literal">O_DSYNC</code></p><p style="color:blue;">同步</p><p class="valid-value"><code class="literal">littlesync</code></p><p style="color:blue;">小燕子</p><p class="valid-value"><code class="literal">nosync</code></p><p style="color:blue;">无同步</p><p class="valid-value"><code class="literal">O_DIRECT</code></p><p style="color:blue;">直接的</p><p class="valid-value"><code class="literal">O_DIRECT_NO_FSYNC</code></p><p style="color:blue;">o_direct_no_fsync公司</p></td>
                    </tr></tbody></table>
                </div>
                <p>
                    Defines the method used to
                    <a class="link" href="glossary.html#glos_flush" title="flush">flush</a> data to
                    <code class="literal">InnoDB</code> <a class="link" href="glossary.html#glos_data_files" title="data files">data
                    files</a> and <a class="link" href="glossary.html#glos_log_file" title="log file">log
                    files</a>, which can affect I/O throughput.
                </p><p style="color:blue;">定义用于将数据刷新到InnoDB数据文件和日志文件的方法，这会影响I/O吞吐量。</p><p>
                    If <code class="literal">innodb_flush_method</code> is set to
                    <code class="literal">NULL</code> on a Unix-like system, the
                    <code class="literal">fsync</code> option is used by default. If
                    <code class="literal">innodb_flush_method</code> is set to
                    <code class="literal">NULL</code> on Windows, the
                    <code class="literal">async_unbuffered</code> option is used by default.
                </p><p style="color:blue;">如果innodb_flush_方法在类unix系统上设置为空，则默认使用fsync选项。如果innodb_flush_method在windows上设置为空，则默认使用async_unbuffered选项。</p><p>
                    The <code class="literal">innodb_flush_method</code> options for
                    Unix-like systems include:
                </p><p style="color:blue;">类unix系统的innodb_flush_方法选项包括：</p>
                <div class="itemizedlist">
                    <ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
                        <code class="literal">fsync</code>: <code class="literal">InnoDB</code> uses
                        the <code class="literal">fsync()</code> system call to flush both
                        the data and log files. <code class="literal">fsync</code> is the
                        default setting.
                    </p><p style="color:blue;">fsync:innodb使用fsync（）系统调用刷新数据和日志文件。fsync是默认设置。</p></li><li class="listitem"><p>
                        <code class="literal">O_DSYNC</code>: <code class="literal">InnoDB</code> uses
                        <code class="literal">O_SYNC</code> to open and flush the log files,
                        and <code class="literal">fsync()</code> to flush the data files.
                        <code class="literal">InnoDB</code> does not use
                        <code class="literal">O_DSYNC</code> directly because there have
                        been problems with it on many varieties of Unix.
                    </p><p style="color:blue;">o_dsync:innodb使用o_sync打开和刷新日志文件，使用fsync（）刷新数据文件。InnoDB不直接使用O_dsync，因为它在许多Unix上都有问题。</p></li><li class="listitem"><p>
                        <code class="literal">littlesync</code>: This option is used for
                        internal performance testing and is currently unsupported.
                        Use at your own risk.
                    </p><p style="color:blue;">littlesync：此选项用于内部性能测试，当前不受支持。自作自受。</p></li><li class="listitem"><p>
                        <code class="literal">nosync</code>: This option is used for
                        internal performance testing and is currently unsupported.
                        Use at your own risk.
                    </p><p style="color:blue;">nosync:此选项用于内部性能测试，当前不受支持。自作自受。</p></li><li class="listitem"><p>
                        <code class="literal">O_DIRECT</code>: <code class="literal">InnoDB</code>
                        uses <code class="literal">O_DIRECT</code> (or
                        <code class="literal">directio()</code> on Solaris) to open the data
                        files, and uses <code class="literal">fsync()</code> to flush both
                        the data and log files. This option is available on some
                        GNU/Linux versions, FreeBSD, and Solaris.
                    </p><p style="color:blue;">o_direct:innodb使用o_direct（或solaris上的directio（））打开数据文件，并使用fsync（）刷新数据和日志文件。此选项在某些gnu/linux版本、freebsd和solaris上可用。</p></li><li class="listitem"><p>
                        <code class="literal">O_DIRECT_NO_FSYNC</code>:
                        <code class="literal">InnoDB</code> uses <code class="literal">O_DIRECT</code>
                        during flushing I/O, but skips the
                        <code class="literal">fsync()</code> system call after each write
                        operation.
                    </p><p style="color:blue;">o_direct_no_fsync:innodb在刷新i/o期间使用o_direct，但在每次写入操作之后都会跳过fsync（）系统调用。</p><p>
                        Prior to MySQL 5.7.25, this setting is not suitable for
                        file systems such as XFS and EXT4, which require an
                        <code class="literal">fsync()</code> system call to synchronize file
                        system metadata changes. If you are not sure whether your
                        file system requires an <code class="literal">fsync()</code> system
                        call to synchronize file system metadata changes, use
                        <code class="literal">O_DIRECT</code> instead.
                    </p><p style="color:blue;">在mysql 5.7.25之前，此设置不适用于xfs和ext4等文件系统，因为这些文件系统需要fsync（）系统调用来同步文件系统元数据更改。如果不确定文件系统是否需要fsync（）系统调用来同步文件系统元数据更改，请改用o_direct。</p><p>
                        As of MySQL 5.7.25, <code class="literal">fsync()</code> is called
                        after creating a new file, after increasing file size, and
                        after closing a file, to ensure that file system metadata
                        changes are synchronized. The <code class="literal">fsync()</code>
                        system call is still skipped after each write operation.
                    </p><p style="color:blue;">从mysql 5.7.25开始，在创建新文件、增大文件大小和关闭文件之后调用fsync（），以确保文件系统元数据更改同步。每次写入操作后，仍会跳过fsync（）系统调用。</p><p>
                        On storage devices with cache, data loss is possible if
                        data files and redo log files reside on different storage
                        devices, and a crash occurs before data file writes are
                        flushed from the device cache. If you use or intend to use
                        different storage devices for redo logs and data files,
                        use <code class="literal">O_DIRECT</code> instead.
                    </p><p style="color:blue;">在具有高速缓存的存储设备上，如果数据文件和重做日志文件位于不同的存储设备上，并且在从设备高速缓存刷新数据文件写入之前发生崩溃，则可能会丢失数据。如果您使用或打算使用不同的存储设备来执行重做日志和数据文件，请改用o_direct。</p></li></ul>
                </div>
                <p>
                    The <code class="literal">innodb_flush_method</code> options for Windows
                    systems include:
                </p><p style="color:blue;">Windows系统的innodb_flush_方法选项包括：</p>
                <div class="itemizedlist">
                    <ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
                        <code class="literal">async_unbuffered</code>:
                        <code class="literal">InnoDB</code> uses Windows asynchronous I/O
                        and non-buffered I/O. <code class="literal">async_unbuffered</code>
                        is the default setting on Windows systems.
                    </p><p style="color:blue;">异步无缓冲：InnoDB使用Windows异步I/O和非缓冲I/O。异步无缓冲是Windows系统的默认设置。</p><p>
                        Running MySQL server on a 4K sector hard drive on Windows
                        is not supported with <code class="literal">async_unbuffered</code>.
                        The workaround is to use
                        <a class="link" href="innodb-storage-engine.html#sysvar_innodb_flush_method"><code class="literal">innodb_flush_method=normal</code></a>.
                    </p><p style="color:blue;">异步无缓冲不支持在Windows上的4K扇区硬盘上运行MySQL Server。解决方法是使用innodb_flush_method=normal。</p></li><li class="listitem"><p>
                        <code class="literal">normal</code>: <code class="literal">InnoDB</code> uses
                        simulated asynchronous I/O and buffered I/O.
                    </p><p style="color:blue;">正常：InnoDB使用模拟异步I/O和缓冲I/O。</p></li><li class="listitem"><p>
                        <code class="literal">unbuffered</code>: <code class="literal">InnoDB</code>
                        uses simulated asynchronous I/O and non-buffered I/O.
                    </p><p style="color:blue;">无缓冲：InnoDB使用模拟异步I/O和非缓冲I/O。</p></li></ul>
                </div>
                <p>
                    How each setting affects performance depends on hardware
                    configuration and workload. Benchmark your particular
                    configuration to decide which setting to use, or whether to
                    keep the default setting. Examine the
                    <a class="link" href="server-administration.html#statvar_Innodb_data_fsyncs"><code class="literal">Innodb_data_fsyncs</code></a> status
                    variable to see the overall number of
                    <code class="literal">fsync()</code> calls for each setting. The mix of
                    read and write operations in your workload can affect how a
                    setting performs. For example, on a system with a hardware
                    RAID controller and battery-backed write cache,
                    <code class="literal">O_DIRECT</code> can help to avoid double buffering
                    between the <code class="literal">InnoDB</code> buffer pool and the
                    operating system file system cache. On some systems where
                    <code class="literal">InnoDB</code> data and log files are located on a
                    SAN, the default value or <code class="literal">O_DSYNC</code> might be
                    faster for a read-heavy workload with mostly
                    <code class="literal">SELECT</code> statements. Always test this
                    parameter with hardware and workload that reflect your
                    production environment. For general I/O tuning advice, see
                    <a class="xref" href="optimization.html#optimizing-innodb-diskio" title="8.5.8&nbsp;Optimizing InnoDB Disk I/O">Section&nbsp;8.5.8, “Optimizing InnoDB Disk I/O”</a>.
                </p><p style="color:blue;">每个设置如何影响性能取决于硬件配置和工作负载。对特定配置进行基准测试，以确定要使用哪个设置，或是否保留默认设置。检查innodb_data_fsyncs status变量，查看每个设置的fsync（）调用总数。工作负载中读写操作的混合会影响设置的执行方式。例如，在一个带有硬件raid控制器和电池支持的写缓存的系统上，o_direct可以帮助避免innodb缓冲池和操作系统文件系统缓存之间的双重缓冲。在一些innodb数据和日志文件位于san上的系统上，对于以select语句为主的大量读取工作负载，默认值或o_dsync可能更快。始终使用反映生产环境的硬件和工作负载测试此参数。有关一般I/O调整建议，请参阅第8.5.8节“优化InnoDB磁盘I/O”。</p></li><li class="listitem"><p><a name="sysvar_innodb_flush_neighbors"></a>
                <a class="indexterm" name="idm140286812499552"></a>

                <code class="literal">innodb_flush_neighbors</code>
            </p><p style="color:blue;">innodb_flush_邻居</p>
                <div class="informaltable">
                    <table frame="box" rules="all" summary="Properties for innodb_flush_neighbors"><colgroup><col width="30%"><col width="70%"></colgroup><thead><tr><th scope="col">Property</th>
                        <th scope="col">Value</th>
                    </tr></thead><tbody><tr><td scope="row"><span class="bold"><strong>Command-Line Format</strong></span></td>
                        <td><code class="literal">--innodb-flush-neighbors=#</code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>System Variable</strong></span></td>
                        <td><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_flush_neighbors">innodb_flush_neighbors</a></code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Scope</strong></span></td>
                        <td>Global</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Dynamic</strong></span></td>
                        <td>Yes</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Type</strong></span></td>
                        <td>Enumeration</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Default Value</strong></span></td>
                        <td><code class="literal">1</code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Valid Values</strong></span></td>
                        <td><p class="valid-value"><code class="literal">0</code></p><p style="color:blue;">零</p><p class="valid-value"><code class="literal">1</code></p><p style="color:blue;">一</p><p class="valid-value"><code class="literal">2</code></p><p style="color:blue;">二</p></td>
                    </tr></tbody></table>
                </div>
                <p>
                    Specifies whether <a class="link" href="glossary.html#glos_flush" title="flush">flushing</a> a
                    page from the <code class="literal">InnoDB</code>
                    <a class="link" href="glossary.html#glos_buffer_pool" title="buffer pool">buffer pool</a> also
                    flushes other <a class="link" href="glossary.html#glos_dirty_page" title="dirty page">dirty
                    pages</a> in the same
                    <a class="link" href="glossary.html#glos_extent" title="extent">extent</a>.
                </p><p style="color:blue;">指定从innodb缓冲池刷新页是否也刷新同一区段中的其他脏页。</p>
                <div class="itemizedlist">
                    <ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
                        A setting of 0 disables
                        <a class="link" href="innodb-storage-engine.html#sysvar_innodb_flush_neighbors"><code class="literal">innodb_flush_neighbors</code></a>.
                        Dirty pages in the same extent are not flushed.
                    </p><p style="color:blue;">设置为0将禁用innodb_flush_neighbors。不刷新相同区域中的脏页。</p></li><li class="listitem"><p>
                        The default setting of 1 flushes contiguous dirty pages in
                        the same extent.
                    </p><p style="color:blue;">默认设置为1将刷新相同范围内的连续脏页。</p></li><li class="listitem"><p>
                        A setting of 2 flushes dirty pages in the same extent.
                    </p><p style="color:blue;">设置为2将刷新相同范围内的脏页。</p></li></ul>
                </div>
                <p>
                    When the table data is stored on a traditional
                    <a class="link" href="glossary.html#glos_hdd" title="HDD">HDD</a> storage device, flushing
                    such <a class="link" href="glossary.html#glos_neighbor_page" title="neighbor page">neighbor pages</a>
                    in one operation reduces I/O overhead (primarily for disk seek
                    operations) compared to flushing individual pages at different
                    times. For table data stored on
                    <a class="link" href="glossary.html#glos_ssd" title="SSD">SSD</a>, seek time is not a
                    significant factor and you can turn this setting off to spread
                    out write operations. For related information, see
                    <a class="xref" href="innodb-storage-engine.html#innodb-buffer-pool-flushing" title="14.8.3.5&nbsp;Configuring Buffer Pool Flushing">Section&nbsp;14.8.3.5, “Configuring Buffer Pool Flushing”</a>.
                </p><p style="color:blue;">当表数据存储在传统的hdd存储设备上时，与在不同时间刷新单个页相比，在一次操作中刷新这样的邻居页减少了i/o开销（主要用于磁盘查找操作）。对于存储在ssd上的表数据，寻道时间不是一个重要因素，您可以关闭此设置以分散写操作。有关信息，请参阅第14.8.3.5节“配置缓冲池刷新”。</p></li><li class="listitem"><p><a name="sysvar_innodb_flush_sync"></a>
                <a class="indexterm" name="idm140286812454576"></a>

                <a class="indexterm" name="idm140286812453536"></a>

                <code class="literal">innodb_flush_sync</code>
            </p><p style="color:blue;">innodb_flush_同步</p>
                <div class="informaltable">
                    <table frame="box" rules="all" summary="Properties for innodb_flush_sync"><colgroup><col width="30%"><col width="70%"></colgroup><thead><tr><th scope="col">Property</th>
                        <th scope="col">Value</th>
                    </tr></thead><tbody><tr><td scope="row"><span class="bold"><strong>Command-Line Format</strong></span></td>
                        <td><code class="literal">--innodb-flush-sync[={OFF|ON}]</code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Introduced</strong></span></td>
                        <td>5.7.8</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>System Variable</strong></span></td>
                        <td><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_flush_sync">innodb_flush_sync</a></code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Scope</strong></span></td>
                        <td>Global</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Dynamic</strong></span></td>
                        <td>Yes</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Type</strong></span></td>
                        <td>Boolean</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Default Value</strong></span></td>
                        <td><code class="literal">ON</code></td>
                    </tr></tbody></table>
                </div>
                <p>
                    The <a class="link" href="innodb-storage-engine.html#sysvar_innodb_flush_sync"><code class="literal">innodb_flush_sync</code></a>
                    variable, which is enabled by default, causes the
                    <a class="link" href="innodb-storage-engine.html#sysvar_innodb_io_capacity"><code class="literal">innodb_io_capacity</code></a> setting to
                    be ignored during bursts of I/O activity that occur at
                    <a class="link" href="glossary.html#glos_checkpoint" title="checkpoint">checkpoints</a>. To adhere
                    to the I/O rate defined by the
                    <a class="link" href="innodb-storage-engine.html#sysvar_innodb_io_capacity"><code class="literal">innodb_io_capacity</code></a> setting,
                    disable <a class="link" href="innodb-storage-engine.html#sysvar_innodb_flush_sync"><code class="literal">innodb_flush_sync</code></a>.
                </p><p style="color:blue;">默认启用的innodb_flush_sync变量会导致在检查点发生的I/O活动突发期间忽略innodb_i o_容量设置。要遵循innodb_i o_容量设置定义的I/O速率，请禁用innodb_flush_sync。</p><p>
                    For information about configuring the
                    <a class="link" href="innodb-storage-engine.html#sysvar_innodb_flush_sync"><code class="literal">innodb_flush_sync</code></a> variable,
                    see <a class="xref" href="innodb-storage-engine.html#innodb-configuring-io-capacity" title="14.8.8&nbsp;Configuring InnoDB I/O Capacity">Section&nbsp;14.8.8, “Configuring InnoDB I/O Capacity”</a>.
                </p><p style="color:blue;">有关配置innodb_flush_sync变量的信息，请参阅第14.8.8节“配置innodb i/o容量”。</p></li><li class="listitem"><p><a name="sysvar_innodb_flushing_avg_loops"></a>
                <a class="indexterm" name="idm140286812414720"></a>

                <code class="literal">innodb_flushing_avg_loops</code>
            </p><p style="color:blue;">innodb_flushing_avg_环路</p>
                <div class="informaltable">
                    <table frame="box" rules="all" summary="Properties for innodb_flushing_avg_loops"><colgroup><col width="30%"><col width="70%"></colgroup><thead><tr><th scope="col">Property</th>
                        <th scope="col">Value</th>
                    </tr></thead><tbody><tr><td scope="row"><span class="bold"><strong>Command-Line Format</strong></span></td>
                        <td><code class="literal">--innodb-flushing-avg-loops=#</code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>System Variable</strong></span></td>
                        <td><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_flushing_avg_loops">innodb_flushing_avg_loops</a></code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Scope</strong></span></td>
                        <td>Global</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Dynamic</strong></span></td>
                        <td>Yes</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Type</strong></span></td>
                        <td>Integer</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Default Value</strong></span></td>
                        <td><code class="literal">30</code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Minimum Value</strong></span></td>
                        <td><code class="literal">1</code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Maximum Value</strong></span></td>
                        <td><code class="literal">1000</code></td>
                    </tr></tbody></table>
                </div>
                <p>
                    Number of iterations for which <code class="literal">InnoDB</code> keeps
                    the previously calculated snapshot of the flushing state,
                    controlling how quickly
                    <a class="link" href="glossary.html#glos_adaptive_flushing" title="adaptive flushing">adaptive
                        flushing</a> responds to changing
                    <a class="link" href="glossary.html#glos_workload" title="workload">workloads</a>. Increasing the
                    value makes the rate of
                    <a class="link" href="glossary.html#glos_flush" title="flush">flush</a> operations change
                    smoothly and gradually as the workload changes. Decreasing the
                    value makes adaptive flushing adjust quickly to workload
                    changes, which can cause spikes in flushing activity if the
                    workload increases and decreases suddenly.
                </p><p style="color:blue;">innodb保留先前计算的刷新状态快照的迭代次数，控制自适应刷新对不断变化的工作负载的响应速度。增加该值会使刷新操作的速率随着工作负载的变化而平稳且逐渐变化。降低该值会使自适应刷新快速适应工作负载的变化，如果工作负载突然增加或减少，则可能导致刷新活动激增。</p><p>
                    For related information, see
                    <a class="xref" href="innodb-storage-engine.html#innodb-buffer-pool-flushing" title="14.8.3.5&nbsp;Configuring Buffer Pool Flushing">Section&nbsp;14.8.3.5, “Configuring Buffer Pool Flushing”</a>.
                </p><p style="color:blue;">有关信息，请参阅第14.8.3.5节“配置缓冲池刷新”。</p></li><li class="listitem"><p><a name="sysvar_innodb_force_load_corrupted"></a>
                <a class="indexterm" name="idm140286812376480"></a>

                <a class="link" href="innodb-storage-engine.html#sysvar_innodb_force_load_corrupted"><code class="literal">innodb_force_load_corrupted</code></a>
            </p><p style="color:blue;">innodb_force_load_损坏</p>
                <div class="informaltable">
                    <table frame="box" rules="all" summary="Properties for innodb_force_load_corrupted"><colgroup><col width="30%"><col width="70%"></colgroup><thead><tr><th scope="col">Property</th>
                        <th scope="col">Value</th>
                    </tr></thead><tbody><tr><td scope="row"><span class="bold"><strong>Command-Line Format</strong></span></td>
                        <td><code class="literal">--innodb-force-load-corrupted[={OFF|ON}]</code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>System Variable</strong></span></td>
                        <td><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_force_load_corrupted">innodb_force_load_corrupted</a></code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Scope</strong></span></td>
                        <td>Global</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Dynamic</strong></span></td>
                        <td>No</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Type</strong></span></td>
                        <td>Boolean</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Default Value</strong></span></td>
                        <td><code class="literal">OFF</code></td>
                    </tr></tbody></table>
                </div>
                <p>
                    Permits <code class="literal">InnoDB</code> to load tables at startup
                    that are marked as corrupted. Use only during troubleshooting,
                    to recover data that is otherwise inaccessible. When
                    troubleshooting is complete, disable this setting and restart
                    the server.
                </p><p style="color:blue;">允许innodb在启动时加载标记为损坏的表。仅在故障排除期间使用，以恢复无法访问的数据。完成故障排除后，禁用此设置并重新启动服务器。</p></li><li class="listitem"><p><a name="sysvar_innodb_force_recovery"></a>
                <a class="indexterm" name="idm140286812347712"></a>

                <a class="indexterm" name="idm140286812346672"></a>

                <code class="literal">innodb_force_recovery</code>
            </p><p style="color:blue;">innodb_force_恢复</p>
                <div class="informaltable">
                    <table frame="box" rules="all" summary="Properties for innodb_force_recovery"><colgroup><col width="30%"><col width="70%"></colgroup><thead><tr><th scope="col">Property</th>
                        <th scope="col">Value</th>
                    </tr></thead><tbody><tr><td scope="row"><span class="bold"><strong>Command-Line Format</strong></span></td>
                        <td><code class="literal">--innodb-force-recovery=#</code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>System Variable</strong></span></td>
                        <td><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_force_recovery">innodb_force_recovery</a></code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Scope</strong></span></td>
                        <td>Global</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Dynamic</strong></span></td>
                        <td>No</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Type</strong></span></td>
                        <td>Integer</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Default Value</strong></span></td>
                        <td><code class="literal">0</code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Minimum Value</strong></span></td>
                        <td><code class="literal">0</code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Maximum Value</strong></span></td>
                        <td><code class="literal">6</code></td>
                    </tr></tbody></table>
                </div>
                <p>
                    The <a class="link" href="glossary.html#glos_crash_recovery" title="crash recovery">crash recovery</a>
                    mode, typically only changed in serious troubleshooting
                    situations. Possible values are from 0 to 6. For the meanings
                    of these values and important information about
                    <code class="literal">innodb_force_recovery</code>, see
                    <a class="xref" href="innodb-storage-engine.html#forcing-innodb-recovery" title="14.21.2&nbsp;Forcing InnoDB Recovery">Section&nbsp;14.21.2, “Forcing InnoDB Recovery”</a>.
                </p><p style="color:blue;">崩溃恢复模式，通常只在严重的故障排除情况下更改。可能的值为0到6。有关这些值的含义和有关InnoDB强制恢复的重要信息，请参阅第14.21.2节“强制InnoDB恢复”。</p>
                <div class="warning" style="margin-left: 0.5in; margin-right: 0.5in;">

                    <div class="admon-title">
                        Warning
                    </div>
                    <p>
                        Only set this variable to a value greater than 0 in an
                        emergency situation so that you can start
                        <code class="literal">InnoDB</code> and dump your tables. As a safety
                        measure, <code class="literal">InnoDB</code> prevents
                        <a class="link" href="sql-syntax.html#insert" title="13.2.5&nbsp;INSERT Syntax"><code class="literal">INSERT</code></a>,
                        <a class="link" href="sql-syntax.html#update" title="13.2.11&nbsp;UPDATE Syntax"><code class="literal">UPDATE</code></a>, or
                        <a class="link" href="sql-syntax.html#delete" title="13.2.2&nbsp;DELETE Syntax"><code class="literal">DELETE</code></a> operations when
                        <code class="literal">innodb_force_recovery</code> is greater than 0.
                        An <code class="literal">innodb_force_recovery</code> setting of 4 or
                        greater places <code class="literal">InnoDB</code> into read-only
                        mode.
                    </p><p style="color:blue;">只有在紧急情况下才将此变量设置为大于0的值，以便可以启动innodb并转储表。作为安全措施，当innodb force_recovery大于0时，innodb会阻止插入、更新或删除操作。innodb_force_recovery设置为4个或4个以上的位置，innodb进入只读模式。</p><p>
                    These restrictions may cause replication administration
                    commands to fail with an error, as replication options such
                    as
                    <a class="link" href="replication.html#option_mysqld_relay-log-info-repository"><code class="option">--relay-log-info-repository=TABLE</code></a>
                    and
                    <a class="link" href="replication.html#option_mysqld_master-info-repository"><code class="option">--master-info-repository=TABLE</code></a>
                    store information in <code class="literal">InnoDB</code> tables.
                </p><p style="color:blue;">这些限制可能会导致复制管理命令失败并出现错误，因为复制选项（如--relay log info repository=table和--master info repository=table）将信息存储在innodb tables中。</p>
                </div>
            </li><li class="listitem"><p><a name="sysvar_innodb_ft_aux_table"></a>
                <a class="indexterm" name="idm140286812298832"></a>

                <a class="link" href="innodb-storage-engine.html#sysvar_innodb_ft_aux_table"><code class="literal">innodb_ft_aux_table</code></a>
            </p><p style="color:blue;">innodb_ft_aux_表</p>
                <div class="informaltable">
                    <table frame="box" rules="all" summary="Properties for innodb_ft_aux_table"><colgroup><col width="30%"><col width="70%"></colgroup><thead><tr><th scope="col">Property</th>
                        <th scope="col">Value</th>
                    </tr></thead><tbody><tr><td scope="row"><span class="bold"><strong>System Variable</strong></span></td>
                        <td><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_ft_aux_table">innodb_ft_aux_table</a></code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Scope</strong></span></td>
                        <td>Global</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Dynamic</strong></span></td>
                        <td>Yes</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Type</strong></span></td>
                        <td>String</td>
                    </tr></tbody></table>
                </div>
                <p>
                    Specifies the qualified name of an <code class="literal">InnoDB</code>
                    table containing a <code class="literal">FULLTEXT</code> index. This
                    variable is intended for diagnostic purposes and can only be
                    set at runtime. For example:
                </p><p style="color:blue;">指定包含全文索引的innodb表的限定名。此变量用于诊断目的，只能在运行时设置。例如：</p><pre data-lang="sql" class="programlisting">SET GLOBAL innodb_ft_aux_table = 'test/t1';
</pre><p>
                    After you set this variable to a name in the format
                    <code class="literal"><em class="replaceable"><code>db_name</code></em>/<em class="replaceable"><code>table_name</code></em></code>,
                    the <code class="literal">INFORMATION_SCHEMA</code> tables
                    <a class="link" href="information-schema.html#innodb-ft-index-table-table" title="24.32.12&nbsp;The INFORMATION_SCHEMA INNODB_FT_INDEX_TABLE Table"><code class="literal">INNODB_FT_INDEX_TABLE</code></a>,
                    <a class="link" href="information-schema.html#innodb-ft-index-cache-table" title="24.32.11&nbsp;The INFORMATION_SCHEMA INNODB_FT_INDEX_CACHE Table"><code class="literal">INNODB_FT_INDEX_CACHE</code></a>,
                    <a class="link" href="information-schema.html#innodb-ft-config-table" title="24.32.8&nbsp;The INFORMATION_SCHEMA INNODB_FT_CONFIG Table"><code class="literal">INNODB_FT_CONFIG</code></a>,
                    <a class="link" href="information-schema.html#innodb-ft-deleted-table" title="24.32.10&nbsp;The INFORMATION_SCHEMA INNODB_FT_DELETED Table"><code class="literal">INNODB_FT_DELETED</code></a>, and
                    <a class="link" href="information-schema.html#innodb-ft-being-deleted-table" title="24.32.7&nbsp;The INFORMATION_SCHEMA INNODB_FT_BEING_DELETED Table"><code class="literal">INNODB_FT_BEING_DELETED</code></a> show
                    information about the search index for the specified table.
                </p><p style="color:blue;">将此变量设置为db_name/table_name格式的名称后，information_schema tables innodb_ft_index_table、innodb_ft_index_cache、innodb_ft_config、innodb_ft_deleted和innodb_ft_being_deleted将显示有关指定表的搜索索引的信息。</p><p>
                    For more information, see
                    <a class="xref" href="innodb-storage-engine.html#innodb-information-schema-fulltext_index-tables" title="14.15.4&nbsp;InnoDB INFORMATION_SCHEMA FULLTEXT Index Tables">Section&nbsp;14.15.4, “InnoDB INFORMATION_SCHEMA FULLTEXT Index Tables”</a>.
                </p><p style="color:blue;">有关更多信息，请参阅14.15.4节，“innodb information_schema全文索引表”。</p></li><li class="listitem"><p><a name="sysvar_innodb_ft_cache_size"></a>
                <a class="indexterm" name="idm140286812264736"></a>

                <a class="link" href="innodb-storage-engine.html#sysvar_innodb_ft_cache_size"><code class="literal">innodb_ft_cache_size</code></a>
            </p><p style="color:blue;">InnoDB_ft_缓存大小</p>
                <div class="informaltable">
                    <table frame="box" rules="all" summary="Properties for innodb_ft_cache_size"><colgroup><col width="30%"><col width="70%"></colgroup><thead><tr><th scope="col">Property</th>
                        <th scope="col">Value</th>
                    </tr></thead><tbody><tr><td scope="row"><span class="bold"><strong>Command-Line Format</strong></span></td>
                        <td><code class="literal">--innodb-ft-cache-size=#</code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>System Variable</strong></span></td>
                        <td><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_ft_cache_size">innodb_ft_cache_size</a></code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Scope</strong></span></td>
                        <td>Global</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Dynamic</strong></span></td>
                        <td>No</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Type</strong></span></td>
                        <td>Integer</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Default Value</strong></span></td>
                        <td><code class="literal">8000000</code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Minimum Value</strong></span></td>
                        <td><code class="literal">1600000</code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Maximum Value</strong></span></td>
                        <td><code class="literal">80000000</code></td>
                    </tr></tbody></table>
                </div>
                <p>
                    The memory allocated, in bytes, for the
                    <code class="literal">InnoDB</code> <code class="literal">FULLTEXT</code> search
                    index cache, which holds a parsed document in memory while
                    creating an <code class="literal">InnoDB</code>
                    <code class="literal">FULLTEXT</code> index. Index inserts and updates
                    are only committed to disk when the
                    <code class="literal">innodb_ft_cache_size</code> size limit is reached.
                    <code class="literal">innodb_ft_cache_size</code> defines the cache size
                    on a per table basis. To set a global limit for all tables,
                    see
                    <a class="link" href="innodb-storage-engine.html#sysvar_innodb_ft_total_cache_size"><code class="literal">innodb_ft_total_cache_size</code></a>.
                </p><p style="color:blue;">为InnoDB全文搜索索引缓存分配的内存（字节），在创建InnoDB全文索引时，该缓存在内存中保存已解析的文档。索引插入和更新仅在达到innodb-ft-u缓存大小限制时提交到磁盘。innodb_ft_cache_size按表定义缓存大小。要为所有表设置全局限制，请参阅innodb_ft_total_cache_size。</p><p>
                    For more information, see
                    <a class="xref" href="innodb-storage-engine.html#innodb-fulltext-index-cache" title="InnoDB Full-Text Index Cache">InnoDB Full-Text Index Cache</a>.
                </p><p style="color:blue;">有关更多信息，请参阅innodb全文索引缓存。</p></li><li class="listitem"><p><a name="sysvar_innodb_ft_enable_diag_print"></a>
                <a class="indexterm" name="idm140286812223808"></a>

                <a class="link" href="innodb-storage-engine.html#sysvar_innodb_ft_enable_diag_print"><code class="literal">innodb_ft_enable_diag_print</code></a>
            </p><p style="color:blue;">innodb_ft_enable_diag_打印</p>
                <div class="informaltable">
                    <table frame="box" rules="all" summary="Properties for innodb_ft_enable_diag_print"><colgroup><col width="30%"><col width="70%"></colgroup><thead><tr><th scope="col">Property</th>
                        <th scope="col">Value</th>
                    </tr></thead><tbody><tr><td scope="row"><span class="bold"><strong>Command-Line Format</strong></span></td>
                        <td><code class="literal">--innodb-ft-enable-diag-print[={OFF|ON}]</code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>System Variable</strong></span></td>
                        <td><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_ft_enable_diag_print">innodb_ft_enable_diag_print</a></code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Scope</strong></span></td>
                        <td>Global</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Dynamic</strong></span></td>
                        <td>Yes</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Type</strong></span></td>
                        <td>Boolean</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Default Value</strong></span></td>
                        <td><code class="literal">OFF</code></td>
                    </tr></tbody></table>
                </div>
                <p>
                    Whether to enable additional full-text search (FTS) diagnostic
                    output. This option is primarily intended for advanced FTS
                    debugging and will not be of interest to most users. Output is
                    printed to the error log and includes information such as:
                </p><p style="color:blue;">是否启用附加全文搜索（FTS）诊断输出。此选项主要用于高级fts调试，大多数用户不会感兴趣。输出将打印到错误日志中，并包含以下信息：</p>
                <div class="itemizedlist">
                    <ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
                        FTS index sync progress (when the FTS cache limit is
                        reached). For example:
                    </p><p style="color:blue;">FTS索引同步进度（达到FTS缓存限制时）。例如：</p><pre data-lang="terminal" class="programlisting">FTS SYNC for table test, deleted count: 100 size: 10000 bytes
SYNC words: 100
</pre></li><li class="listitem"><p>
                        FTS optimize progress. For example:
                    </p><p style="color:blue;">FTS优化进度。例如：</p><pre data-lang="terminal" class="programlisting">FTS start optimize test
FTS_OPTIMIZE: optimize "mysql"
FTS_OPTIMIZE: processed "mysql"
</pre></li><li class="listitem"><p>
                        FTS index build progress. For example:
                    </p><p style="color:blue;">富时指数建设进展。例如：</p><pre data-lang="terminal" class="programlisting">Number of doc processed: 1000
</pre></li><li class="listitem"><p>
                        For FTS queries, the query parsing tree, word weight,
                        query processing time, and memory usage are printed. For
                        example:
                    </p><p style="color:blue;">对于fts查询，将打印查询解析树、字权重、查询处理时间和内存使用情况。例如：</p><pre data-lang="terminal" class="programlisting">FTS Search Processing time: 1 secs: 100 millisec: row(s) 10000
Full Search Memory: 245666 (bytes),  Row: 10000
</pre></li></ul>
                </div>
            </li><li class="listitem"><p><a name="sysvar_innodb_ft_enable_stopword"></a>
                <a class="indexterm" name="idm140286812187712"></a>

                <a class="link" href="innodb-storage-engine.html#sysvar_innodb_ft_enable_stopword"><code class="literal">innodb_ft_enable_stopword</code></a>
            </p><p style="color:blue;">InnoDB_ft_启用停止字</p>
                <div class="informaltable">
                    <table frame="box" rules="all" summary="Properties for innodb_ft_enable_stopword"><colgroup><col width="30%"><col width="70%"></colgroup><thead><tr><th scope="col">Property</th>
                        <th scope="col">Value</th>
                    </tr></thead><tbody><tr><td scope="row"><span class="bold"><strong>Command-Line Format</strong></span></td>
                        <td><code class="literal">--innodb-ft-enable-stopword[={OFF|ON}]</code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>System Variable</strong></span></td>
                        <td><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_ft_enable_stopword">innodb_ft_enable_stopword</a></code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Scope</strong></span></td>
                        <td>Global, Session</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Dynamic</strong></span></td>
                        <td>Yes</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Type</strong></span></td>
                        <td>Boolean</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Default Value</strong></span></td>
                        <td><code class="literal">ON</code></td>
                    </tr></tbody></table>
                </div>
                <p>
                    Specifies that a set of
                    <a class="link" href="glossary.html#glos_stopword" title="stopword">stopwords</a> is associated
                    with an <code class="literal">InnoDB</code> <code class="literal">FULLTEXT</code>
                    index at the time the index is created. If the
                    <a class="link" href="innodb-storage-engine.html#sysvar_innodb_ft_user_stopword_table"><code class="literal">innodb_ft_user_stopword_table</code></a>
                    option is set, the stopwords are taken from that table. Else,
                    if the
                    <a class="link" href="innodb-storage-engine.html#sysvar_innodb_ft_server_stopword_table"><code class="literal">innodb_ft_server_stopword_table</code></a>
                    option is set, the stopwords are taken from that table.
                    Otherwise, a built-in set of default stopwords is used.
                </p><p style="color:blue;">指定在创建索引时一组stopWords与innodb全文索引关联。如果设置了innodb_ft_user_stopword_table选项，则stopwords取自该表。否则，如果设置了innodb_ft_server_stopword_table选项，那么stopwords将取自该表。否则，将使用一组内置的默认停止字。</p><p>
                    For more information, see
                    <a class="xref" href="functions.html#fulltext-stopwords" title="12.9.4&nbsp;Full-Text Stopwords">Section&nbsp;12.9.4, “Full-Text Stopwords”</a>.
                </p><p style="color:blue;">有关更多信息，请参见第12.9.4节“全文停止词”。</p></li><li class="listitem"><p><a name="sysvar_innodb_ft_max_token_size"></a>
                <a class="indexterm" name="idm140286812153536"></a>

                <a class="link" href="innodb-storage-engine.html#sysvar_innodb_ft_max_token_size"><code class="literal">innodb_ft_max_token_size</code></a>
            </p><p style="color:blue;">innodb_ft_max_token_大小</p>
                <div class="informaltable">
                    <table frame="box" rules="all" summary="Properties for innodb_ft_max_token_size"><colgroup><col width="30%"><col width="70%"></colgroup><thead><tr><th scope="col">Property</th>
                        <th scope="col">Value</th>
                    </tr></thead><tbody><tr><td scope="row"><span class="bold"><strong>Command-Line Format</strong></span></td>
                        <td><code class="literal">--innodb-ft-max-token-size=#</code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>System Variable</strong></span></td>
                        <td><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_ft_max_token_size">innodb_ft_max_token_size</a></code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Scope</strong></span></td>
                        <td>Global</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Dynamic</strong></span></td>
                        <td>No</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Type</strong></span></td>
                        <td>Integer</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Default Value</strong></span></td>
                        <td><code class="literal">84</code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Minimum Value</strong></span></td>
                        <td><code class="literal">10</code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Maximum Value</strong></span> (&gt;= 5.7.3)</td>
                        <td><code class="literal">84</code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Maximum Value</strong></span> (&lt;= 5.7.2)</td>
                        <td><code class="literal">252</code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Maximum Value</strong></span></td>
                        <td><code class="literal">84</code></td>
                    </tr></tbody></table>
                </div>
                <p>
                    Maximum character length of words that are stored in an
                    <code class="literal">InnoDB</code> <code class="literal">FULLTEXT</code> index.
                    Setting a limit on this value reduces the size of the index,
                    thus speeding up queries, by omitting long keywords or
                    arbitrary collections of letters that are not real words and
                    are not likely to be search terms.
                </p><p style="color:blue;">存储在YNODB全文索引中的单词的最大字符长度。对该值设置限制可以减少索引的大小，从而加快查询速度，方法是省略长关键字或任意字母集合，这些字母不是真正的单词，也不太可能是搜索词。</p><p>
                    For more information, see
                    <a class="xref" href="functions.html#fulltext-fine-tuning" title="12.9.6&nbsp;Fine-Tuning MySQL Full-Text Search">Section&nbsp;12.9.6, “Fine-Tuning MySQL Full-Text Search”</a>.
                </p><p style="color:blue;">有关更多信息，请参阅第12.9.6节“微调mysql全文搜索”。</p></li><li class="listitem"><p><a name="sysvar_innodb_ft_min_token_size"></a>
                <a class="indexterm" name="idm140286812110256"></a>

                <a class="link" href="innodb-storage-engine.html#sysvar_innodb_ft_min_token_size"><code class="literal">innodb_ft_min_token_size</code></a>
            </p><p style="color:blue;">innodb_ft_min_token_大小</p>
                <div class="informaltable">
                    <table frame="box" rules="all" summary="Properties for innodb_ft_min_token_size"><colgroup><col width="30%"><col width="70%"></colgroup><thead><tr><th scope="col">Property</th>
                        <th scope="col">Value</th>
                    </tr></thead><tbody><tr><td scope="row"><span class="bold"><strong>Command-Line Format</strong></span></td>
                        <td><code class="literal">--innodb-ft-min-token-size=#</code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>System Variable</strong></span></td>
                        <td><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_ft_min_token_size">innodb_ft_min_token_size</a></code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Scope</strong></span></td>
                        <td>Global</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Dynamic</strong></span></td>
                        <td>No</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Type</strong></span></td>
                        <td>Integer</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Default Value</strong></span></td>
                        <td><code class="literal">3</code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Minimum Value</strong></span></td>
                        <td><code class="literal">0</code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Maximum Value</strong></span></td>
                        <td><code class="literal">16</code></td>
                    </tr></tbody></table>
                </div>
                <p>
                    Minimum length of words that are stored in an
                    <code class="literal">InnoDB</code> <code class="literal">FULLTEXT</code> index.
                    Increasing this value reduces the size of the index, thus
                    speeding up queries, by omitting common words that are
                    unlikely to be significant in a search context, such as the
                    English words <span class="quote">“<span class="quote">a</span>”</span> and <span class="quote">“<span class="quote">to</span>”</span>. For
                    content using a CJK (Chinese, Japanese, Korean) character set,
                    specify a value of 1.
                </p><p style="color:blue;">存储在innodb全文索引中的单词的最小长度。增加这个值可以减少索引的大小，从而通过省略在搜索上下文中不太可能重要的常用词（例如英语单词“a”和“to”）来加快查询速度。对于使用cjk（中文、日语、韩语）字符集的内容，请指定值1。</p><p>
                    For more information, see
                    <a class="xref" href="functions.html#fulltext-fine-tuning" title="12.9.6&nbsp;Fine-Tuning MySQL Full-Text Search">Section&nbsp;12.9.6, “Fine-Tuning MySQL Full-Text Search”</a>.
                </p><p style="color:blue;">有关更多信息，请参阅第12.9.6节“微调mysql全文搜索”。</p></li><li class="listitem"><p><a name="sysvar_innodb_ft_num_word_optimize"></a>
                <a class="indexterm" name="idm140286812072656"></a>

                <a class="link" href="innodb-storage-engine.html#sysvar_innodb_ft_num_word_optimize"><code class="literal">innodb_ft_num_word_optimize</code></a>
            </p><p style="color:blue;">innodb_ft_num_word_优化</p>
                <div class="informaltable">
                    <table frame="box" rules="all" summary="Properties for innodb_ft_num_word_optimize"><colgroup><col width="30%"><col width="70%"></colgroup><thead><tr><th scope="col">Property</th>
                        <th scope="col">Value</th>
                    </tr></thead><tbody><tr><td scope="row"><span class="bold"><strong>Command-Line Format</strong></span></td>
                        <td><code class="literal">--innodb-ft-num-word-optimize=#</code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>System Variable</strong></span></td>
                        <td><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_ft_num_word_optimize">innodb_ft_num_word_optimize</a></code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Scope</strong></span></td>
                        <td>Global</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Dynamic</strong></span></td>
                        <td>Yes</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Type</strong></span></td>
                        <td>Integer</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Default Value</strong></span></td>
                        <td><code class="literal">2000</code></td>
                    </tr></tbody></table>
                </div>
                <p>
                    Number of words to process during each
                    <a class="link" href="sql-syntax.html#optimize-table" title="13.7.2.4&nbsp;OPTIMIZE TABLE Syntax"><code class="literal">OPTIMIZE TABLE</code></a> operation on an
                    <code class="literal">InnoDB</code> <code class="literal">FULLTEXT</code> index.
                    Because a bulk insert or update operation to a table
                    containing a full-text search index could require substantial
                    index maintenance to incorporate all changes, you might do a
                    series of <a class="link" href="sql-syntax.html#optimize-table" title="13.7.2.4&nbsp;OPTIMIZE TABLE Syntax"><code class="literal">OPTIMIZE TABLE</code></a>
                    statements, each picking up where the last left off.
                </p><p style="color:blue;">在innodb全文索引上的每个优化表操作期间要处理的字数。由于对包含全文搜索索引的表执行大容量插入或更新操作可能需要大量的索引维护才能合并所有更改，因此您可以执行一系列优化表语句，每个语句都会在最后一个省略的地方执行。</p><p>
                    For more information, see
                    <a class="xref" href="functions.html#fulltext-fine-tuning" title="12.9.6&nbsp;Fine-Tuning MySQL Full-Text Search">Section&nbsp;12.9.6, “Fine-Tuning MySQL Full-Text Search”</a>.
                </p><p style="color:blue;">有关更多信息，请参阅第12.9.6节“微调mysql全文搜索”。</p></li><li class="listitem"><p><a name="sysvar_innodb_ft_result_cache_limit"></a>
                <a class="indexterm" name="idm140286812039504"></a>

                <a class="link" href="innodb-storage-engine.html#sysvar_innodb_ft_result_cache_limit"><code class="literal">innodb_ft_result_cache_limit</code></a>
            </p><p style="color:blue;">innodb_ft_result_cache_限制</p>
                <div class="informaltable">
                    <table frame="box" rules="all" summary="Properties for innodb_ft_result_cache_limit"><colgroup><col width="30%"><col width="70%"></colgroup><thead><tr><th scope="col">Property</th>
                        <th scope="col">Value</th>
                    </tr></thead><tbody><tr><td scope="row"><span class="bold"><strong>Command-Line Format</strong></span></td>
                        <td><code class="literal">--innodb-ft-result-cache-limit=#</code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Introduced</strong></span></td>
                        <td>5.7.2</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>System Variable</strong></span></td>
                        <td><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_ft_result_cache_limit">innodb_ft_result_cache_limit</a></code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Scope</strong></span></td>
                        <td>Global</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Dynamic</strong></span></td>
                        <td>Yes</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Type</strong></span></td>
                        <td>Integer</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Default Value</strong></span></td>
                        <td><code class="literal">2000000000</code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Minimum Value</strong></span></td>
                        <td><code class="literal">1000000</code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Maximum Value</strong></span> (Windows, &gt;= 5.7.2, &lt;= 5.7.3)</td>
                        <td><code class="literal">2**32-1</code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Maximum Value</strong></span> (Unix, 64-bit platforms, &gt;= 5.7.2, &lt;= 5.7.3)</td>
                        <td><code class="literal">2**64-1</code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Maximum Value</strong></span> (Unix, 32-bit platforms, &gt;= 5.7.2, &lt;= 5.7.3)</td>
                        <td><code class="literal">2**32-1</code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Maximum Value</strong></span> (&gt;= 5.7.4)</td>
                        <td><code class="literal">2**32-1</code></td>
                    </tr></tbody></table>
                </div>
                <p>
                    The <code class="literal">InnoDB</code> full-text search query result
                    cache limit (defined in bytes) per full-text search query or
                    per thread. Intermediate and final <code class="literal">InnoDB</code>
                    full-text search query results are handled in memory. Use
                    <code class="literal">innodb_ft_result_cache_limit</code> to place a
                    size limit on the full-text search query result cache to avoid
                    excessive memory consumption in case of very large
                    <code class="literal">InnoDB</code> full-text search query results
                    (millions or hundreds of millions of rows, for example).
                    Memory is allocated as required when a full-text search query
                    is processed. If the result cache size limit is reached, an
                    error is returned indicating that the query exceeds the
                    maximum allowed memory.
                </p><p style="color:blue;">每个全文搜索查询或每个线程的innodb全文搜索查询结果缓存限制（以字节为单位定义）。中间和最终的innodb全文搜索查询结果在内存中处理。使用innodb_ft_result_cache_limit对全文搜索查询结果缓存设置大小限制，以避免在出现非常大的innodb全文搜索查询结果（例如数百万或数亿行）时过度消耗内存。在处理全文搜索查询时，将根据需要分配内存。如果达到结果缓存大小限制，则返回一个错误，表示查询超出最大允许内存。</p><p>
                    The maximum value of
                    <code class="literal">innodb_ft_result_cache_limit</code> for all
                    platform types and bit sizes is 2**32-1.
                </p><p style="color:blue;">所有平台类型和位大小的UNIGBUTFFTRESULTSCACHEYL限制的最大值为2×*32 -1。</p></li><li class="listitem"><p><a name="sysvar_innodb_ft_server_stopword_table"></a>
                <a class="indexterm" name="idm140286811988000"></a>

                <a class="link" href="innodb-storage-engine.html#sysvar_innodb_ft_server_stopword_table"><code class="literal">innodb_ft_server_stopword_table</code></a>
            </p><p style="color:blue;">innodb_ft_server_stopword_表</p>
                <div class="informaltable">
                    <table frame="box" rules="all" summary="Properties for innodb_ft_server_stopword_table"><colgroup><col width="30%"><col width="70%"></colgroup><thead><tr><th scope="col">Property</th>
                        <th scope="col">Value</th>
                    </tr></thead><tbody><tr><td scope="row"><span class="bold"><strong>Command-Line Format</strong></span></td>
                        <td><code class="literal">--innodb-ft-server-stopword-table=db_name/table_name</code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>System Variable</strong></span></td>
                        <td><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_ft_server_stopword_table">innodb_ft_server_stopword_table</a></code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Scope</strong></span></td>
                        <td>Global</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Dynamic</strong></span></td>
                        <td>Yes</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Type</strong></span></td>
                        <td>String</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Default Value</strong></span></td>
                        <td><code class="literal">NULL</code></td>
                    </tr></tbody></table>
                </div>
                <p>
                    This option is used to specify your own
                    <code class="literal">InnoDB</code> <code class="literal">FULLTEXT</code> index
                    stopword list for all <code class="literal">InnoDB</code> tables. To
                    configure your own stopword list for a specific
                    <code class="literal">InnoDB</code> table, use
                    <a class="link" href="innodb-storage-engine.html#sysvar_innodb_ft_user_stopword_table"><code class="literal">innodb_ft_user_stopword_table</code></a>.
                </p><p style="color:blue;">此选项用于为所有innodb表指定自己的innodb全文索引stopword列表。要为特定的innodb表配置自己的stopword列表，请使用innodb_ft_user_stopword_table。</p><p>
                    Set <code class="literal">innodb_ft_server_stopword_table</code> to the
                    name of the table containing a list of stopwords, in the
                    format
                    <code class="literal"><em class="replaceable"><code>db_name</code></em>/<em class="replaceable"><code>table_name</code></em></code>.
                </p><p style="color:blue;">将innodb_ft_server_stopword_table设置为包含停止字列表的表的名称，格式为db_name/table_name。</p><p>
                    The stopword table must exist before you configure
                    <code class="literal">innodb_ft_server_stopword_table</code>.
                    <code class="literal">innodb_ft_enable_stopword</code> must be enabled
                    and <code class="literal">innodb_ft_server_stopword_table</code> option
                    must be configured before you create the
                    <code class="literal">FULLTEXT</code> index.
                </p><p style="color:blue;">在配置NoNdByfTyServIsStudiWordx表之前，必须存在停止字表。在创建全文索引之前，必须启用innodb_ft_enable_stopword，并且必须配置innodb_ft_server_stopword_table选项。</p><p>
                    The stopword table must be an <code class="literal">InnoDB</code> table,
                    containing a single <code class="literal">VARCHAR</code> column named
                    <code class="literal">value</code>.
                </p><p style="color:blue;">stopword表必须是innodb表，包含一个名为value的varchar列。</p><p>
                    For more information, see
                    <a class="xref" href="functions.html#fulltext-stopwords" title="12.9.4&nbsp;Full-Text Stopwords">Section&nbsp;12.9.4, “Full-Text Stopwords”</a>.
                </p><p style="color:blue;">有关更多信息，请参见第12.9.4节“全文停止词”。</p></li><li class="listitem"><p><a name="sysvar_innodb_ft_sort_pll_degree"></a>
                <a class="indexterm" name="idm140286811946192"></a>

                <a class="link" href="innodb-storage-engine.html#sysvar_innodb_ft_sort_pll_degree"><code class="literal">innodb_ft_sort_pll_degree</code></a>
            </p><p style="color:blue;">Innodb_ft_sort_pll_度</p>
                <div class="informaltable">
                    <table frame="box" rules="all" summary="Properties for innodb_ft_sort_pll_degree"><colgroup><col width="30%"><col width="70%"></colgroup><thead><tr><th scope="col">Property</th>
                        <th scope="col">Value</th>
                    </tr></thead><tbody><tr><td scope="row"><span class="bold"><strong>Command-Line Format</strong></span></td>
                        <td><code class="literal">--innodb-ft-sort-pll-degree=#</code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>System Variable</strong></span></td>
                        <td><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_ft_sort_pll_degree">innodb_ft_sort_pll_degree</a></code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Scope</strong></span></td>
                        <td>Global</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Dynamic</strong></span></td>
                        <td>No</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Type</strong></span></td>
                        <td>Integer</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Default Value</strong></span></td>
                        <td><code class="literal">2</code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Minimum Value</strong></span></td>
                        <td><code class="literal">1</code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Maximum Value</strong></span></td>
                        <td><code class="literal">32</code></td>
                    </tr></tbody></table>
                </div>
                <p>
                    Number of threads used in parallel to index and tokenize text
                    in an <code class="literal">InnoDB</code> <code class="literal">FULLTEXT</code>
                    index when building a <a class="link" href="glossary.html#glos_search_index" title="search index">search
                    index</a>.
                </p><p style="color:blue;">在构建搜索索引时，与innodb全文索引中的文本索引和标记化文本并行使用的线程数。</p><p>
                    For related information, see
                    <a class="xref" href="innodb-storage-engine.html#innodb-fulltext-index" title="14.6.2.4&nbsp;InnoDB FULLTEXT Indexes">Section&nbsp;14.6.2.4, “InnoDB FULLTEXT Indexes”</a>, and
                    <a class="link" href="innodb-storage-engine.html#sysvar_innodb_sort_buffer_size"><code class="literal">innodb_sort_buffer_size</code></a>.
                </p><p style="color:blue;">有关信息，请参阅第14.6.2.4节“innodb全文索引”和innodb_sort_buffer_size。</p></li><li class="listitem"><p><a name="sysvar_innodb_ft_total_cache_size"></a>
                <a class="indexterm" name="idm140286811907408"></a>

                <a class="link" href="innodb-storage-engine.html#sysvar_innodb_ft_total_cache_size"><code class="literal">innodb_ft_total_cache_size</code></a>
            </p><p style="color:blue;">InnoDB_ft_Total_缓存大小</p>
                <div class="informaltable">
                    <table frame="box" rules="all" summary="Properties for innodb_ft_total_cache_size"><colgroup><col width="30%"><col width="70%"></colgroup><thead><tr><th scope="col">Property</th>
                        <th scope="col">Value</th>
                    </tr></thead><tbody><tr><td scope="row"><span class="bold"><strong>Command-Line Format</strong></span></td>
                        <td><code class="literal">--innodb-ft-total-cache-size=#</code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Introduced</strong></span></td>
                        <td>5.7.2</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>System Variable</strong></span></td>
                        <td><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_ft_total_cache_size">innodb_ft_total_cache_size</a></code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Scope</strong></span></td>
                        <td>Global</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Dynamic</strong></span></td>
                        <td>No</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Type</strong></span></td>
                        <td>Integer</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Default Value</strong></span></td>
                        <td><code class="literal">640000000</code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Minimum Value</strong></span></td>
                        <td><code class="literal">32000000</code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Maximum Value</strong></span></td>
                        <td><code class="literal">1600000000</code></td>
                    </tr></tbody></table>
                </div>
                <p>
                    The total memory allocated, in bytes, for the
                    <code class="literal">InnoDB</code> full-text search index cache for all
                    tables. Creating numerous tables, each with a
                    <code class="literal">FULLTEXT</code> search index, could consume a
                    significant portion of available memory.
                    <a class="link" href="innodb-storage-engine.html#sysvar_innodb_ft_total_cache_size"><code class="literal">innodb_ft_total_cache_size</code></a>
                    defines a global memory limit for all full-text search indexes
                    to help avoid excessive memory consumption. If the global
                    limit is reached by an index operation, a forced sync is
                    triggered.
                </p><p style="color:blue;">为所有表的innodb全文搜索索引缓存分配的总内存（字节）。创建许多表（每个表都有一个全文搜索索引）可能会占用大量可用内存。innodb_ft_total_cache_size为所有全文搜索索引定义全局内存限制，以帮助避免过度内存消耗。如果索引操作达到全局限制，则会触发强制同步。</p><p>
                    For more information, see
                    <a class="xref" href="innodb-storage-engine.html#innodb-fulltext-index-cache" title="InnoDB Full-Text Index Cache">InnoDB Full-Text Index Cache</a>.
                </p><p style="color:blue;">有关更多信息，请参阅innodb全文索引缓存。</p></li><li class="listitem"><p><a name="sysvar_innodb_ft_user_stopword_table"></a>
                <a class="indexterm" name="idm140286811866416"></a>

                <a class="link" href="innodb-storage-engine.html#sysvar_innodb_ft_user_stopword_table"><code class="literal">innodb_ft_user_stopword_table</code></a>
            </p><p style="color:blue;">innodb_ft_user_stopword_表</p>
                <div class="informaltable">
                    <table frame="box" rules="all" summary="Properties for innodb_ft_user_stopword_table"><colgroup><col width="30%"><col width="70%"></colgroup><thead><tr><th scope="col">Property</th>
                        <th scope="col">Value</th>
                    </tr></thead><tbody><tr><td scope="row"><span class="bold"><strong>Command-Line Format</strong></span></td>
                        <td><code class="literal">--innodb-ft-user-stopword-table=db_name/table_name</code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>System Variable</strong></span></td>
                        <td><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_ft_user_stopword_table">innodb_ft_user_stopword_table</a></code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Scope</strong></span></td>
                        <td>Global, Session</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Dynamic</strong></span></td>
                        <td>Yes</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Type</strong></span></td>
                        <td>String</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Default Value</strong></span></td>
                        <td><code class="literal">NULL</code></td>
                    </tr></tbody></table>
                </div>
                <p>
                    This option is used to specify your own
                    <code class="literal">InnoDB</code> <code class="literal">FULLTEXT</code> index
                    stopword list on a specific table. To configure your own
                    stopword list for all <code class="literal">InnoDB</code> tables, use
                    <a class="link" href="innodb-storage-engine.html#sysvar_innodb_ft_server_stopword_table"><code class="literal">innodb_ft_server_stopword_table</code></a>.
                </p><p style="color:blue;">此选项用于在特定表上指定您自己的innodb全文索引stopword列表。要为所有innodb表配置自己的stopword列表，请使用innodb_ft_server_stopword_table。</p><p>
                    Set <code class="literal">innodb_ft_user_stopword_table</code> to the
                    name of the table containing a list of stopwords, in the
                    format
                    <code class="literal"><em class="replaceable"><code>db_name</code></em>/<em class="replaceable"><code>table_name</code></em></code>.
                </p><p style="color:blue;">将innodb_ft_user_stopword_table设置为包含停止字列表的表的名称，格式为db_name/table_name。</p><p>
                    The stopword table must exist before you configure
                    <code class="literal">innodb_ft_user_stopword_table</code>.
                    <code class="literal">innodb_ft_enable_stopword</code> must be enabled
                    and <code class="literal">innodb_ft_user_stopword_table</code> must be
                    configured before you create the <code class="literal">FULLTEXT</code>
                    index.
                </p><p style="color:blue;">在配置NoNdByftUsSeriStWordWord表之前，必须存在停止字表。创建全文索引之前，必须启用innodb_ft_enable_stopword并配置innodb_ft_user_stopword_表。</p><p>
                    The stopword table must be an <code class="literal">InnoDB</code> table,
                    containing a single <code class="literal">VARCHAR</code> column named
                    <code class="literal">value</code>.
                </p><p style="color:blue;">stopword表必须是innodb表，包含一个名为value的varchar列。</p><p>
                    For more information, see
                    <a class="xref" href="functions.html#fulltext-stopwords" title="12.9.4&nbsp;Full-Text Stopwords">Section&nbsp;12.9.4, “Full-Text Stopwords”</a>.
                </p><p style="color:blue;">有关更多信息，请参见第12.9.4节“全文停止词”。</p></li><li class="listitem"><p><a name="sysvar_innodb_io_capacity"></a>
                <a class="indexterm" name="idm140286811825312"></a>

                <a class="indexterm" name="idm140286811824272"></a>

                <code class="literal">innodb_io_capacity</code>
            </p><p style="color:blue;">InnoDB_IO_容量</p>
                <div class="informaltable">
                    <table frame="box" rules="all" summary="Properties for innodb_io_capacity"><colgroup><col width="30%"><col width="70%"></colgroup><thead><tr><th scope="col">Property</th>
                        <th scope="col">Value</th>
                    </tr></thead><tbody><tr><td scope="row"><span class="bold"><strong>Command-Line Format</strong></span></td>
                        <td><code class="literal">--innodb-io-capacity=#</code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>System Variable</strong></span></td>
                        <td><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_io_capacity">innodb_io_capacity</a></code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Scope</strong></span></td>
                        <td>Global</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Dynamic</strong></span></td>
                        <td>Yes</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Type</strong></span></td>
                        <td>Integer</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Default Value</strong></span></td>
                        <td><code class="literal">200</code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Minimum Value</strong></span></td>
                        <td><code class="literal">100</code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Maximum Value</strong></span> (64-bit platforms)</td>
                        <td><code class="literal">2**64-1</code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Maximum Value</strong></span> (32-bit platforms)</td>
                        <td><code class="literal">2**32-1</code></td>
                    </tr></tbody></table>
                </div>
                <p>
                    The <a class="link" href="innodb-storage-engine.html#sysvar_innodb_io_capacity"><code class="literal">innodb_io_capacity</code></a>
                    variable defines the number of I/O operations per second
                    (IOPS) available to <code class="literal">InnoDB</code> background
                    tasks, such as <a class="link" href="glossary.html#glos_flush" title="flush">flushing</a>
                    pages from the <a class="link" href="glossary.html#glos_buffer_pool" title="buffer pool">buffer
                    pool</a> and merging data from the
                    <a class="link" href="glossary.html#glos_change_buffer" title="change buffer">change buffer</a>.
                </p><p style="color:blue;">innodb_i o_capacity变量定义可用于innodb后台任务的每秒i/o操作数（iops），例如从缓冲池刷新页面和合并来自更改缓冲区的数据。</p><p>
                    For information about configuring the
                    <a class="link" href="innodb-storage-engine.html#sysvar_innodb_io_capacity"><code class="literal">innodb_io_capacity</code></a> variable,
                    see <a class="xref" href="innodb-storage-engine.html#innodb-configuring-io-capacity" title="14.8.8&nbsp;Configuring InnoDB I/O Capacity">Section&nbsp;14.8.8, “Configuring InnoDB I/O Capacity”</a>.
                </p><p style="color:blue;">有关配置innodb_i o_capacity变量的信息，请参阅第14.8.8节“配置innodb i/o capacity”。</p></li><li class="listitem"><p><a name="sysvar_innodb_io_capacity_max"></a>
                <a class="indexterm" name="idm140286811780064"></a>

                <code class="literal">innodb_io_capacity_max</code>
            </p><p style="color:blue;">innodb_io_capacity_最大容量</p>
                <div class="informaltable">
                    <table frame="box" rules="all" summary="Properties for innodb_io_capacity_max"><colgroup><col width="30%"><col width="70%"></colgroup><thead><tr><th scope="col">Property</th>
                        <th scope="col">Value</th>
                    </tr></thead><tbody><tr><td scope="row"><span class="bold"><strong>Command-Line Format</strong></span></td>
                        <td><code class="literal">--innodb-io-capacity-max=#</code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>System Variable</strong></span></td>
                        <td><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_io_capacity_max">innodb_io_capacity_max</a></code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Scope</strong></span></td>
                        <td>Global</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Dynamic</strong></span></td>
                        <td>Yes</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Type</strong></span></td>
                        <td>Integer</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Default Value</strong></span></td>
                        <td><code class="literal">see description</code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Minimum Value</strong></span></td>
                        <td><code class="literal">100</code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Maximum Value</strong></span> (Windows, 64-bit platforms)</td>
                        <td><code class="literal">2**32-1</code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Maximum Value</strong></span> (Unix, 64-bit platforms)</td>
                        <td><code class="literal">2**64-1</code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Maximum Value</strong></span> (32-bit platforms)</td>
                        <td><code class="literal">2**32-1</code></td>
                    </tr></tbody></table>
                </div>
                <p>
                    If flushing activity falls behind, <code class="literal">InnoDB</code>
                    can flush more aggressively, at a higher rate of I/O
                    operations per second (IOPS) than defined by the
                    <a class="link" href="innodb-storage-engine.html#sysvar_innodb_io_capacity"><code class="literal">innodb_io_capacity</code></a> variable.
                    The <a class="link" href="innodb-storage-engine.html#sysvar_innodb_io_capacity_max"><code class="literal">innodb_io_capacity_max</code></a>
                    variable defines a maximum number of IOPS performed by
                    <code class="literal">InnoDB</code> background tasks in such situations.
                </p><p style="color:blue;">如果刷新活动落后，innodb可以以比innodb_i o_capacity变量定义的更高的每秒I/O操作速率（IOPS）更积极地刷新。NoNdByIOxLoabyTyxMax变量定义了在这种情况下由INODB后台任务执行的最大IOP数。</p><p>
                    For information about configuring the
                    <a class="link" href="innodb-storage-engine.html#sysvar_innodb_io_capacity_max"><code class="literal">innodb_io_capacity_max</code></a>
                    variable, see
                    <a class="xref" href="innodb-storage-engine.html#innodb-configuring-io-capacity" title="14.8.8&nbsp;Configuring InnoDB I/O Capacity">Section&nbsp;14.8.8, “Configuring InnoDB I/O Capacity”</a>.
                </p><p style="color:blue;">有关配置innodb_i o_capacity_max变量的信息，请参阅第14.8.8节“配置innodb i/o容量”。</p></li><li class="listitem"><p><a name="sysvar_innodb_large_prefix"></a>
                <a class="indexterm" name="idm140286811733344"></a>

                <a class="indexterm" name="idm140286811732304"></a>

                <code class="literal">innodb_large_prefix</code>
            </p><p style="color:blue;">innodb_large_前缀</p>
                <div class="informaltable">
                    <table frame="box" rules="all" summary="Properties for innodb_large_prefix"><colgroup><col width="30%"><col width="70%"></colgroup><thead><tr><th scope="col">Property</th>
                        <th scope="col">Value</th>
                    </tr></thead><tbody><tr><td scope="row"><span class="bold"><strong>Command-Line Format</strong></span></td>
                        <td><code class="literal">--innodb-large-prefix[={OFF|ON}]</code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Deprecated</strong></span></td>
                        <td>5.7.7</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>System Variable</strong></span></td>
                        <td><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_large_prefix">innodb_large_prefix</a></code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Scope</strong></span></td>
                        <td>Global</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Dynamic</strong></span></td>
                        <td>Yes</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Type</strong></span></td>
                        <td>Boolean</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Default Value</strong></span> (&gt;= 5.7.7)</td>
                        <td><code class="literal">ON</code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Default Value</strong></span> (&lt;= 5.7.6)</td>
                        <td><code class="literal">OFF</code></td>
                    </tr></tbody></table>
                </div>
                <p>
                    When this option is enabled, index key prefixes longer than
                    767 bytes (up to 3072 bytes) are allowed for
                    <code class="literal">InnoDB</code> tables that use
                    <code class="literal"><a class="link" href="glossary.html#glos_dynamic_row_format" title="dynamic row format">DYNAMIC</a></code>
                    or
                    <code class="literal"><a class="link" href="glossary.html#glos_compressed_row_format" title="compressed row format">COMPRESSED</a></code>
                    row format. See <a class="xref" href="innodb-storage-engine.html#innodb-restrictions" title="14.6.1.6&nbsp;Limits on InnoDB Tables">Section&nbsp;14.6.1.6, “Limits on InnoDB Tables”</a> for
                    maximums associated with index key prefixes under various
                    settings.
                </p><p style="color:blue;">启用此选项时，对于使用动态或压缩行格式的innodb表，允许索引键前缀超过767字节（最多3072字节）。请参阅第十四条1.61.6节，“NoYDB表的限制”，用于在不同设置下与索引键前缀相关联的最大值。</p><p>
                    For tables that use
                    <code class="literal"><a class="link" href="glossary.html#glos_redundant_row_format" title="redundant row format">REDUNDANT</a></code>
                    or
                    <code class="literal"><a class="link" href="glossary.html#glos_compact_row_format" title="compact row format">COMPACT</a></code>
                    row format, this option does not affect the permitted index
                    key prefix length.
                </p><p style="color:blue;">对于使用冗余或压缩行格式的表，此选项不影响允许的索引键前缀长度。</p><p>
                    <code class="literal">innodb_large_prefix</code> is enabled by default
                    in MySQL 5.7. This change coincides with the
                    default value change for
                    <code class="literal">innodb_file_format</code>, which is set to
                    <code class="literal">Barracuda</code> by default in MySQL
                    5.7. Together, these default value changes allow
                    larger index key prefixes to be created when using
                    <code class="literal">DYNAMIC</code> or <code class="literal">COMPRESSED</code>
                    row format. If either option is set to a non-default value,
                    index key prefixes larger than 767 bytes are silently
                    truncated.
                </p><p style="color:blue;">mysql 5.7默认启用innodb_large_前缀。此更改与innodb_file_format的默认值更改一致，innodb_file_format在mysql 5.7中默认设置为barracuda。这些默认值更改允许在使用动态或压缩行格式时创建更大的索引键前缀。如果将任一选项设置为非默认值，则大于767字节的索引键前缀将被静默截断。</p><p>
                    <a class="link" href="innodb-storage-engine.html#sysvar_innodb_large_prefix"><code class="literal">innodb_large_prefix</code></a> is
                    deprecated and will be removed in a future release.
                    <a class="link" href="innodb-storage-engine.html#sysvar_innodb_large_prefix"><code class="literal">innodb_large_prefix</code></a> was
                    introduced to disable large index key prefixes for
                    compatibility with earlier versions of
                    <code class="literal">InnoDB</code> that do not support large index key
                    prefixes.
                </p><p style="color:blue;">InnoDB_large_前缀已弃用，将在以后的版本中删除。引入innodb_large_前缀是为了禁用大索引键前缀，以与不支持大索引键前缀的早期版本的innodb兼容。</p></li><li class="listitem"><p><a name="sysvar_innodb_limit_optimistic_insert_debug"></a>
                <a class="indexterm" name="idm140286811683056"></a>

                <a class="indexterm" name="idm140286811682016"></a>

                <code class="literal">innodb_limit_optimistic_insert_debug</code>
            </p><p style="color:blue;">innodb_limit_optimistic_insert_调试</p>
                <div class="informaltable">
                    <table frame="box" rules="all" summary="Properties for innodb_limit_optimistic_insert_debug"><colgroup><col width="30%"><col width="70%"></colgroup><thead><tr><th scope="col">Property</th>
                        <th scope="col">Value</th>
                    </tr></thead><tbody><tr><td scope="row"><span class="bold"><strong>Command-Line Format</strong></span></td>
                        <td><code class="literal">--innodb-limit-optimistic-insert-debug=#</code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>System Variable</strong></span></td>
                        <td><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_limit_optimistic_insert_debug">innodb_limit_optimistic_insert_debug</a></code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Scope</strong></span></td>
                        <td>Global</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Dynamic</strong></span></td>
                        <td>Yes</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Type</strong></span></td>
                        <td>Integer</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Default Value</strong></span></td>
                        <td><code class="literal">0</code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Minimum Value</strong></span></td>
                        <td><code class="literal">0</code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Maximum Value</strong></span></td>
                        <td><code class="literal">2**32-1</code></td>
                    </tr></tbody></table>
                </div>
                <p>
                    Limits the number of records per
                    <a class="link" href="glossary.html#glos_b_tree" title="B-tree">B-tree</a> page. A default
                    value of 0 means that no limit is imposed. This option is only
                    available if debugging support is compiled in using the
                    <a class="link" href="installing.html#option_cmake_with_debug"><code class="option">WITH_DEBUG</code></a>
                    <span class="command"><strong>CMake</strong></span> option.
                </p><p style="color:blue;">限制每个B树页的记录数。默认值为0表示不施加限制。只有在使用with_debug cmake选项编译调试支持时，此选项才可用。</p></li><li class="listitem"><p><a name="sysvar_innodb_lock_wait_timeout"></a>
                <a class="indexterm" name="idm140286811645616"></a>

                <a class="indexterm" name="idm140286811644512"></a>

                <code class="literal">innodb_lock_wait_timeout</code>
            </p><p style="color:blue;">innodb_lock_wait_超时</p>
                <div class="informaltable">
                    <table frame="box" rules="all" summary="Properties for innodb_lock_wait_timeout"><colgroup><col width="30%"><col width="70%"></colgroup><thead><tr><th scope="col">Property</th>
                        <th scope="col">Value</th>
                    </tr></thead><tbody><tr><td scope="row"><span class="bold"><strong>Command-Line Format</strong></span></td>
                        <td><code class="literal">--innodb-lock-wait-timeout=#</code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>System Variable</strong></span></td>
                        <td><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_lock_wait_timeout">innodb_lock_wait_timeout</a></code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Scope</strong></span></td>
                        <td>Global, Session</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Dynamic</strong></span></td>
                        <td>Yes</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Type</strong></span></td>
                        <td>Integer</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Default Value</strong></span></td>
                        <td><code class="literal">50</code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Minimum Value</strong></span></td>
                        <td><code class="literal">1</code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Maximum Value</strong></span></td>
                        <td><code class="literal">1073741824</code></td>
                    </tr></tbody></table>
                </div>
                <p>
                    The length of time in seconds an <code class="literal">InnoDB</code>
                    <a class="link" href="glossary.html#glos_transaction" title="transaction">transaction</a> waits for
                    a <a class="link" href="glossary.html#glos_row_lock" title="row lock">row lock</a> before giving
                    up. The default value is 50 seconds. A transaction that tries
                    to access a row that is locked by another
                    <code class="literal">InnoDB</code> transaction waits at most this many
                    seconds for write access to the row before issuing the
                    following error:
                </p><p style="color:blue;">InnoDB事务在放弃前等待行锁的时间（秒）。默认值为50秒。试图访问被另一个innodb事务锁定的行的事务在发出以下错误之前，最多要等待这么多秒才能对该行进行写访问：</p><pre data-lang="terminal" class="programlisting">ERROR 1205 (HY000): Lock wait timeout exceeded; try restarting transaction
</pre><p>
                    When a lock wait timeout occurs, the current statement is
                    <a class="link" href="glossary.html#glos_rollback" title="rollback">rolled back</a> (not the
                    entire transaction). To have the entire transaction roll back,
                    start the server with the
                    <a class="link" href="innodb-storage-engine.html#sysvar_innodb_rollback_on_timeout"><code class="option">--innodb-rollback-on-timeout</code></a>
                    option. See also <a class="xref" href="innodb-storage-engine.html#innodb-error-handling" title="14.21.4&nbsp;InnoDB Error Handling">Section&nbsp;14.21.4, “InnoDB Error Handling”</a>.
                </p><p style="color:blue;">当发生锁等待超时时，将回滚当前语句（而不是整个事务）。要使整个事务回滚，请使用--innodb roll back on timeout选项启动服务器。另见第14.21.4节“InnoDB错误处理”。</p><p>
                    You might decrease this value for highly interactive
                    applications or <a class="link" href="glossary.html#glos_oltp" title="OLTP">OLTP</a> systems,
                    to display user feedback quickly or put the update into a
                    queue for processing later. You might increase this value for
                    long-running back-end operations, such as a transform step in
                    a data warehouse that waits for other large insert or update
                    operations to finish.
                </p><p style="color:blue;">对于高度交互的应用程序或oltp系统，您可能会降低此值，以便快速显示用户反馈，或者将更新放入队列中以便稍后处理。对于长时间运行的后端操作，例如等待其他大型插入或更新操作完成的数据仓库中的转换步骤，可以增加此值。</p><p>
                    <code class="literal">innodb_lock_wait_timeout</code> applies to
                    <code class="literal">InnoDB</code> row locks only. A MySQL
                    <a class="link" href="glossary.html#glos_table_lock" title="table lock">table lock</a> does not
                    happen inside <code class="literal">InnoDB</code> and this timeout does
                    not apply to waits for table locks.
                </p><p style="color:blue;">innodb_lock_wait_timeout仅适用于innodb行锁。InnoDB内部不会发生MySQL表锁，此超时不适用于等待表锁。</p><p>
                    The lock wait timeout value does not apply to
                    <a class="link" href="glossary.html#glos_deadlock" title="deadlock">deadlocks</a> when
                    <a class="link" href="innodb-storage-engine.html#sysvar_innodb_deadlock_detect"><code class="literal">innodb_deadlock_detect</code></a> is
                    enabled (the default) because <code class="literal">InnoDB</code>
                    detects deadlocks immediately and rolls back one of the
                    deadlocked transactions. When
                    <a class="link" href="innodb-storage-engine.html#sysvar_innodb_deadlock_detect"><code class="literal">innodb_deadlock_detect</code></a> is
                    disabled, <code class="literal">InnoDB</code> relies on
                    <a class="link" href="innodb-storage-engine.html#sysvar_innodb_lock_wait_timeout"><code class="literal">innodb_lock_wait_timeout</code></a> for
                    transaction rollback when a deadlock occurs. See
                    <a class="xref" href="innodb-storage-engine.html#innodb-deadlock-detection" title="14.7.5.2&nbsp;Deadlock Detection and Rollback">Section&nbsp;14.7.5.2, “Deadlock Detection and Rollback”</a>.
                </p><p style="color:blue;">当启用innodb_deadlock_detect（默认）时，lock wait timeout值不适用于死锁，因为innodb会立即检测死锁并回滚其中一个死锁事务。当innodb_deadlock_detect被禁用时，innodb依赖于innodb_lock_wait_timeout在发生死锁时进行事务回滚。见第14.7.5.2节“死锁检测和回滚”。</p><p>
                    <a class="link" href="innodb-storage-engine.html#sysvar_innodb_lock_wait_timeout"><code class="literal">innodb_lock_wait_timeout</code></a> can
                    be set at runtime with the <code class="literal">SET GLOBAL</code> or
                    <code class="literal">SET SESSION</code> statement. Changing the
                    <code class="literal">GLOBAL</code> setting requires privileges
                    sufficient to set global system variables (see
                    <a class="xref" href="server-administration.html#system-variable-privileges" title="5.1.8.1&nbsp;System Variable Privileges">Section&nbsp;5.1.8.1, “System Variable Privileges”</a>) and affects the
                    operation of all clients that subsequently connect. Any client
                    can change the <code class="literal">SESSION</code> setting for
                    <a class="link" href="innodb-storage-engine.html#sysvar_innodb_lock_wait_timeout"><code class="literal">innodb_lock_wait_timeout</code></a>,
                    which affects only that client.
                </p><p style="color:blue;">innodb_lock_wait_timeout可以在运行时使用set global或set session语句设置。更改全局设置需要足够的权限来设置全局系统变量（请参阅第5.1.8.1节“系统变量权限”），并影响随后连接的所有客户端的操作。任何客户端都可以更改innodb_lock_wait_timeout的会话设置，这只影响该客户端。</p></li><li class="listitem"><p><a name="sysvar_innodb_locks_unsafe_for_binlog"></a>
                <a class="indexterm" name="idm140286811583872"></a>

                <a class="indexterm" name="idm140286811582768"></a>

                <code class="literal">innodb_locks_unsafe_for_binlog</code>
            </p><p style="color:blue;">innodb_locks_不安全</p>
                <div class="informaltable">
                    <table frame="box" rules="all" summary="Properties for innodb_locks_unsafe_for_binlog"><colgroup><col width="30%"><col width="70%"></colgroup><thead><tr><th scope="col">Property</th>
                        <th scope="col">Value</th>
                    </tr></thead><tbody><tr><td scope="row"><span class="bold"><strong>Command-Line Format</strong></span></td>
                        <td><code class="literal">--innodb-locks-unsafe-for-binlog[={OFF|ON}]</code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Deprecated</strong></span></td>
                        <td>Yes</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>System Variable</strong></span></td>
                        <td><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_locks_unsafe_for_binlog">innodb_locks_unsafe_for_binlog</a></code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Scope</strong></span></td>
                        <td>Global</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Dynamic</strong></span></td>
                        <td>No</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Type</strong></span></td>
                        <td>Boolean</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Default Value</strong></span></td>
                        <td><code class="literal">OFF</code></td>
                    </tr></tbody></table>
                </div>
                <a class="indexterm" name="idm140286811554032"></a><a class="indexterm" name="idm140286811552544"></a><a class="indexterm" name="idm140286811551056"></a><a class="indexterm" name="idm140286811549568"></a><a class="indexterm" name="idm140286811548080"></a><a class="indexterm" name="idm140286811546592"></a><a class="indexterm" name="idm140286811545104"></a><a class="indexterm" name="idm140286811543616"></a><a class="indexterm" name="idm140286811542128"></a><a class="indexterm" name="idm140286811540640"></a><p>
                    This variable affects how <code class="literal">InnoDB</code> uses
                    <a class="link" href="glossary.html#glos_gap_lock" title="gap lock">gap locking</a> for searches
                    and index scans.
                    <code class="literal">innodb_locks_unsafe_for_binlog</code> is
                    deprecated and will be removed in a future MySQL release.
                </p><p style="color:blue;">这个变量影响innodb如何使用间隙锁定进行搜索和索引扫描。innodb_locks_unsafe_for_binlog已被弃用，并将在以后的mysql版本中删除。</p><p>
                    Normally, <code class="literal">InnoDB</code> uses an algorithm called
                    next-key locking that combines index-row locking with
                    <a class="link" href="glossary.html#glos_gap_lock" title="gap lock">gap locking</a>.
                    <code class="literal">InnoDB</code> performs row-level locking in such a
                    way that when it searches or scans a table index, it sets
                    shared or exclusive locks on the index records it encounters.
                    Thus, row-level locks are actually index-record locks. In
                    addition, a next-key lock on an index record also affects the
                    gap before the index record. That is, a next-key lock is an
                    index-record lock plus a gap lock on the gap preceding the
                    index record. If one session has a shared or exclusive lock on
                    record <code class="literal">R</code> in an index, another session
                    cannot insert a new index record in the gap immediately before
                    <code class="literal">R</code> in the index order. See
                    <a class="xref" href="innodb-storage-engine.html#innodb-locking" title="14.7.1&nbsp;InnoDB Locking">Section&nbsp;14.7.1, “InnoDB Locking”</a>.
                </p><p style="color:blue;">通常，innodb使用一种称为next key locking的算法，它将索引行锁定和间隙锁定结合起来。InnoDB执行行级锁定的方式是，当它搜索或扫描表索引时，它会在遇到的索引记录上设置共享锁或独占锁。因此，行级锁实际上是索引记录锁。此外，索引记录上的下一个键锁也会影响索引记录之前的间隔。也就是说，下一个密钥锁是索引记录锁加上索引记录前面的间隙上的间隙锁。如果一个会话对索引中的记录r具有共享或独占锁，则另一个会话不能按索引顺序在r前面的间隙中插入新的索引记录。见第14.7.1节，“InnoDB锁定”。</p><p>
                    By default, the value of
                    <code class="literal">innodb_locks_unsafe_for_binlog</code> is 0
                    (disabled), which means that gap locking is enabled:
                    <code class="literal">InnoDB</code> uses next-key locks for searches and
                    index scans. To enable the variable, set it to 1. This causes
                    gap locking to be disabled: <code class="literal">InnoDB</code> uses
                    only index-record locks for searches and index scans.
                </p><p style="color:blue;">默认情况下，innodb_locks_unsafe_for_binlog的值为0（禁用），这意味着间隙锁定已启用：innodb使用next key locks进行搜索和索引扫描。要启用变量，请将其设置为1。这导致间隙锁定被禁用：innodb只使用索引记录锁进行搜索和索引扫描。</p><p>
                    Enabling <code class="literal">innodb_locks_unsafe_for_binlog</code>
                    does not disable the use of gap locking for foreign-key
                    constraint checking or duplicate-key checking.
                </p><p style="color:blue;">启用innodb_locks_unsafe_for_binlog不会禁用对外键约束检查或重复键检查使用间隙锁定。</p><p>
                    The effects of enabling
                    <code class="literal">innodb_locks_unsafe_for_binlog</code> are the same
                    as setting the transaction isolation level to
                    <a class="link" href="innodb-storage-engine.html#isolevel_read-committed"><code class="literal">READ COMMITTED</code></a>, with these
                    exceptions:
                </p><p style="color:blue;">启用innodb_locks_unsafe_for_binlog的效果与将事务隔离级别设置为read committed相同，但以下情况除外：</p>
                <div class="itemizedlist">
                    <ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
                        Enabling
                        <a class="link" href="innodb-storage-engine.html#sysvar_innodb_locks_unsafe_for_binlog"><code class="literal">innodb_locks_unsafe_for_binlog</code></a>
                        is a global setting and affects all sessions, whereas the
                        isolation level can be set globally for all sessions, or
                        individually per session.
                    </p><p style="color:blue;">启用innodb_locks_unsafe_for_binlog是一个全局设置，会影响所有会话，而隔离级别可以为所有会话全局设置，也可以为每个会话单独设置。</p></li><li class="listitem"><p>
                        <a class="link" href="innodb-storage-engine.html#sysvar_innodb_locks_unsafe_for_binlog"><code class="literal">innodb_locks_unsafe_for_binlog</code></a>
                        can be set only at server startup, whereas the isolation
                        level can be set at startup or changed at runtime.
                    </p><p style="color:blue;">innodb_locks_unsafe_for_binlog只能在服务器启动时设置，而隔离级别可以在启动时设置或在运行时更改。</p></li></ul>
                </div>
                <p>
                    <a class="link" href="innodb-storage-engine.html#isolevel_read-committed"><code class="literal">READ COMMITTED</code></a> therefore
                    offers finer and more flexible control than
                    <a class="link" href="innodb-storage-engine.html#sysvar_innodb_locks_unsafe_for_binlog"><code class="literal">innodb_locks_unsafe_for_binlog</code></a>.
                    For more information about the effect of isolation level on
                    gap locking, see
                    <a class="xref" href="innodb-storage-engine.html#innodb-transaction-isolation-levels" title="14.7.2.1&nbsp;Transaction Isolation Levels">Section&nbsp;14.7.2.1, “Transaction Isolation Levels”</a>.
                </p><p style="color:blue;">因此，Read Read提供了比NuffdBLosisSunSuffyFuxBiLoSQL更精细更灵活的控制。有关隔离级别对间隙锁定的影响的更多信息，请参阅第14.7.2.1节“事务隔离级别”。</p><p>
                    Enabling <code class="literal">innodb_locks_unsafe_for_binlog</code> may
                    cause phantom problems because other sessions can insert new
                    rows into the gaps when gap locking is disabled. Suppose that
                    there is an index on the <code class="literal">id</code> column of the
                    <code class="literal">child</code> table and that you want to read and
                    lock all rows from the table having an identifier value larger
                    than 100, with the intention of updating some column in the
                    selected rows later:
                </p><p style="color:blue;">启用innodb_locks_unsafe_for_binlog可能会导致幻象问题，因为当禁用间隙锁定时，其他会话可以在间隙中插入新行。假设子表的id列上有一个索引，并且您希望读取并锁定表中标识符值大于100的所有行，以便稍后更新选定行中的某些列：</p><pre data-lang="sql" class="programlisting">SELECT * FROM child WHERE id &gt; 100 FOR UPDATE;
</pre><p>
                    The query scans the index starting from the first record where
                    the <code class="literal">id</code> is greater than 100. If the locks
                    set on the index records in that range do not lock out inserts
                    made in the gaps, another session can insert a new row into
                    the table. Consequently, if you were to execute the same
                    <a class="link" href="sql-syntax.html#select" title="13.2.9&nbsp;SELECT Syntax"><code class="literal">SELECT</code></a> again within the same
                    transaction, you would see a new row in the result set
                    returned by the query. This also means that if new items are
                    added to the database, <code class="literal">InnoDB</code> does not
                    guarantee serializability. Therefore, if
                    <code class="literal">innodb_locks_unsafe_for_binlog</code> is enabled,
                    <code class="literal">InnoDB</code> guarantees at most an isolation
                    level of <a class="link" href="innodb-storage-engine.html#isolevel_read-committed"><code class="literal">READ COMMITTED</code></a>.
                    (Conflict serializability is still guaranteed.) For more
                    information about phantoms, see
                    <a class="xref" href="innodb-storage-engine.html#innodb-next-key-locking" title="14.7.4&nbsp;Phantom Rows">Section&nbsp;14.7.4, “Phantom Rows”</a>.
                </p><p style="color:blue;">查询从id大于100的第一条记录开始扫描索引。如果在该范围内的索引记录上设置的锁没有锁定在间隙中进行的插入，则另一个会话可以在表中插入新行。因此，如果要在同一事务中再次执行同一个select，您将在查询返回的结果集中看到一个新行。这也意味着，如果向数据库中添加了新项，innodb不保证可序列化。因此，如果innodb_locks_unsafe_for_binlog被启用，innodb最多保证一个隔离级别的read committed。（仍然保证冲突序列化。）有关幻影的更多信息，请参阅14.7.4节“幻影行”。</p><p>
                    Enabling <code class="literal">innodb_locks_unsafe_for_binlog</code> has
                    additional effects:
                </p><p style="color:blue;">启用innodb_locks_unsafe_for_binlog还有其他效果：</p>
                <div class="itemizedlist">
                    <ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
                        For <a class="link" href="sql-syntax.html#update" title="13.2.11&nbsp;UPDATE Syntax"><code class="literal">UPDATE</code></a> or
                        <a class="link" href="sql-syntax.html#delete" title="13.2.2&nbsp;DELETE Syntax"><code class="literal">DELETE</code></a> statements,
                        <code class="literal">InnoDB</code> holds locks only for rows that
                        it updates or deletes. Record locks for nonmatching rows
                        are released after MySQL has evaluated the
                        <code class="literal">WHERE</code> condition. This greatly reduces
                        the probability of deadlocks, but they can still happen.
                    </p><p style="color:blue;">对于update或delete语句，innodb只对其更新或删除的行持有锁。在mysql评估where条件之后，将释放非匹配行的记录锁。这大大降低了死锁的可能性，但它们仍然可能发生。</p></li><li class="listitem"><p>
                        For <a class="link" href="sql-syntax.html#update" title="13.2.11&nbsp;UPDATE Syntax"><code class="literal">UPDATE</code></a> statements, if a
                        row is already locked, <code class="literal">InnoDB</code> performs
                        a <span class="quote">“<span class="quote">semi-consistent</span>”</span> read, returning the
                        latest committed version to MySQL so that MySQL can
                        determine whether the row matches the
                        <code class="literal">WHERE</code> condition of the
                        <a class="link" href="sql-syntax.html#update" title="13.2.11&nbsp;UPDATE Syntax"><code class="literal">UPDATE</code></a>. If the row matches
                        (must be updated), MySQL reads the row again and this time
                        <code class="literal">InnoDB</code> either locks it or waits for a
                        lock on it.
                    </p><p style="color:blue;">对于update语句，如果一行已经被锁定，innodb执行“半一致”读取，将最新提交的版本返回给mysql，这样mysql就可以确定该行是否与更新的where条件匹配。如果行匹配（必须更新），mysql会再次读取行，这次innodb要么锁定它，要么等待对它的锁定。</p></li></ul>
                </div>
                <p>
                    Consider the following example, beginning with this table:
                </p><p style="color:blue;">请考虑以下示例，从下表开始：</p><pre data-lang="sql" class="programlisting">CREATE TABLE t (a INT NOT NULL, b INT) ENGINE = InnoDB;
INSERT INTO t VALUES (1,2),(2,3),(3,2),(4,3),(5,2);
COMMIT;
</pre><p>
                    In this case, table has no indexes, so searches and index
                    scans use the hidden clustered index for record locking (see
                    <a class="xref" href="innodb-storage-engine.html#innodb-index-types" title="14.6.2.1&nbsp;Clustered and Secondary Indexes">Section&nbsp;14.6.2.1, “Clustered and Secondary Indexes”</a>).
                </p><p style="color:blue;">在这种情况下，表没有索引，因此搜索和索引扫描使用隐藏的聚集索引进行记录锁定（请参阅14.6.2.1节，“聚集索引和辅助索引”）。</p><p>
                    Suppose that one client performs an
                    <a class="link" href="sql-syntax.html#update" title="13.2.11&nbsp;UPDATE Syntax"><code class="literal">UPDATE</code></a> using these statements:
                </p><p style="color:blue;">假设一个客户机使用以下语句执行更新：</p><pre data-lang="sql" class="programlisting">SET autocommit = 0;
UPDATE t SET b = 5 WHERE b = 3;
</pre><p>
                    Suppose also that a second client performs an
                    <a class="link" href="sql-syntax.html#update" title="13.2.11&nbsp;UPDATE Syntax"><code class="literal">UPDATE</code></a> by executing these
                    statements following those of the first client:
                </p><p style="color:blue;">还假设第二个客户机通过执行以下第一个客户机的语句来执行更新：</p><pre data-lang="sql" class="programlisting">SET autocommit = 0;
UPDATE t SET b = 4 WHERE b = 2;
</pre><p>
                    As <code class="literal">InnoDB</code> executes each
                    <a class="link" href="sql-syntax.html#update" title="13.2.11&nbsp;UPDATE Syntax"><code class="literal">UPDATE</code></a>, it first acquires an
                    exclusive lock for each row, and then determines whether to
                    modify it. If <code class="literal">InnoDB</code> does not modify the
                    row and <code class="literal">innodb_locks_unsafe_for_binlog</code> is
                    enabled, it releases the lock. Otherwise,
                    <code class="literal">InnoDB</code> retains the lock until the end of
                    the transaction. This affects transaction processing as
                    follows.
                </p><p style="color:blue;">当innodb执行每个更新时，它首先为每一行获取一个独占锁，然后决定是否修改它。如果innodb不修改行并且innodb_locks_unsafe_for_binlog被启用，那么它会释放锁。否则，innodb将保留锁直到事务结束。这会影响以下事务处理。</p><p>
                    If <code class="literal">innodb_locks_unsafe_for_binlog</code> is
                    disabled, the first <a class="link" href="sql-syntax.html#update" title="13.2.11&nbsp;UPDATE Syntax"><code class="literal">UPDATE</code></a>
                    acquires x-locks and does not release any of them:
                </p><p style="color:blue;">如果innodb_locks_unsafe_for_binlog被禁用，第一次更新将获取x-locks，并且不会释放其中的任何一个：</p><pre data-lang="none" class="programlisting">x-lock(1,2); retain x-lock
x-lock(2,3); update(2,3) to (2,5); retain x-lock
x-lock(3,2); retain x-lock
x-lock(4,3); update(4,3) to (4,5); retain x-lock
x-lock(5,2); retain x-lock
</pre><p>
                    The second <a class="link" href="sql-syntax.html#update" title="13.2.11&nbsp;UPDATE Syntax"><code class="literal">UPDATE</code></a> blocks as
                    soon as it tries to acquire any locks (because the first
                    update has retained locks on all rows), and does not proceed
                    until the first <a class="link" href="sql-syntax.html#update" title="13.2.11&nbsp;UPDATE Syntax"><code class="literal">UPDATE</code></a> commits
                    or rolls back:
                </p><p style="color:blue;">第二次更新在尝试获取任何锁时立即阻塞（因为第一次更新保留了所有行上的锁），并且在第一次更新提交或回滚之前不会继续：</p><pre data-lang="none" class="programlisting">x-lock(1,2); block and wait for first UPDATE to commit or roll back
</pre><p>
                    If <code class="literal">innodb_locks_unsafe_for_binlog</code> is
                    enabled, the first <a class="link" href="sql-syntax.html#update" title="13.2.11&nbsp;UPDATE Syntax"><code class="literal">UPDATE</code></a>
                    acquires x-locks and releases those for rows that it does not
                    modify:
                </p><p style="color:blue;">如果innodb_locks_unsafe_for_binlog被启用，第一次更新将获取x-locks并释放它不修改的行的x-locks：</p><pre data-lang="none" class="programlisting">x-lock(1,2); unlock(1,2)
x-lock(2,3); update(2,3) to (2,5); retain x-lock
x-lock(3,2); unlock(3,2)
x-lock(4,3); update(4,3) to (4,5); retain x-lock
x-lock(5,2); unlock(5,2)
</pre><p>
                    For the second <code class="literal">UPDATE</code>,
                    <code class="literal">InnoDB</code> does a
                    <span class="quote">“<span class="quote">semi-consistent</span>”</span> read, returning the latest
                    committed version of each row to MySQL so that MySQL can
                    determine whether the row matches the <code class="literal">WHERE</code>
                    condition of the <a class="link" href="sql-syntax.html#update" title="13.2.11&nbsp;UPDATE Syntax"><code class="literal">UPDATE</code></a>:
                </p><p style="color:blue;">对于第二次更新，innodb执行“半一致”读取，将每一行的最新提交版本返回给mysql，以便mysql可以确定该行是否匹配更新的where条件：</p><pre data-lang="none" class="programlisting">x-lock(1,2); update(1,2) to (1,4); retain x-lock
x-lock(2,3); unlock(2,3)
x-lock(3,2); update(3,2) to (3,4); retain x-lock
x-lock(4,3); unlock(4,3)
x-lock(5,2); update(5,2) to (5,4); retain x-lock
</pre></li><li class="listitem"><p><a name="sysvar_innodb_log_buffer_size"></a>
                <a class="indexterm" name="idm140286811460944"></a>

                <a class="indexterm" name="idm140286811459904"></a>

                <code class="literal">innodb_log_buffer_size</code>
            </p><p style="color:blue;">InnoDB_Log_缓冲区大小</p>
                <div class="informaltable">
                    <table frame="box" rules="all" summary="Properties for innodb_log_buffer_size"><colgroup><col width="30%"><col width="70%"></colgroup><thead><tr><th scope="col">Property</th>
                        <th scope="col">Value</th>
                    </tr></thead><tbody><tr><td scope="row"><span class="bold"><strong>Command-Line Format</strong></span></td>
                        <td><code class="literal">--innodb-log-buffer-size=#</code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>System Variable</strong></span></td>
                        <td><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_log_buffer_size">innodb_log_buffer_size</a></code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Scope</strong></span></td>
                        <td>Global</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Dynamic</strong></span></td>
                        <td>No</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Type</strong></span></td>
                        <td>Integer</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Default Value</strong></span> (&gt;= 5.7.6)</td>
                        <td><code class="literal">16777216</code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Default Value</strong></span> (&lt;= 5.7.5)</td>
                        <td><code class="literal">8388608</code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Minimum Value</strong></span> (&gt;= 5.7.6)</td>
                        <td><code class="literal">1048576</code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Minimum Value</strong></span> (&lt;= 5.7.5)</td>
                        <td><code class="literal">262144</code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Maximum Value</strong></span></td>
                        <td><code class="literal">4294967295</code></td>
                    </tr></tbody></table>
                </div>
                <p>
                    The size in bytes of the buffer that <code class="literal">InnoDB</code>
                    uses to write to the <a class="link" href="glossary.html#glos_log_file" title="log file">log
                    files</a> on disk. The default value changed from 8MB to
                    16MB with the introduction of 32KB and 64KB
                    <a class="link" href="innodb-storage-engine.html#sysvar_innodb_page_size"><code class="literal">innodb_page_size</code></a> values. A
                    large <a class="link" href="glossary.html#glos_log_buffer" title="log buffer">log buffer</a>
                    enables large
                    <a class="link" href="glossary.html#glos_transaction" title="transaction">transactions</a> to run
                    without the need to write the log to disk before the
                    transactions <a class="link" href="glossary.html#glos_commit" title="commit">commit</a>. Thus,
                    if you have transactions that update, insert, or delete many
                    rows, making the log buffer larger saves disk I/O. For related
                    information, see
                    <a class="xref" href="innodb-storage-engine.html#innodb-startup-memory-configuration" title="Memory Configuration">Memory Configuration</a>, and
                    <a class="xref" href="optimization.html#optimizing-innodb-logging" title="8.5.4&nbsp;Optimizing InnoDB Redo Logging">Section&nbsp;8.5.4, “Optimizing InnoDB Redo Logging”</a>. For general I/O
                    tuning advice, see <a class="xref" href="optimization.html#optimizing-innodb-diskio" title="8.5.8&nbsp;Optimizing InnoDB Disk I/O">Section&nbsp;8.5.8, “Optimizing InnoDB Disk I/O”</a>.
                </p><p style="color:blue;">innodb用来写入磁盘上日志文件的缓冲区的字节大小。由于引入了32kb和64kb的innodb_page_size值，默认值从8mb更改为16mb。大型日志缓冲区使大型事务能够运行，而无需在事务提交之前将日志写入磁盘。因此，如果您有更新、插入或删除许多行的事务，那么增大日志缓冲区可以节省磁盘I/O。有关信息，请参阅内存配置和第8.5.4节“优化InnoDB重做日志”。有关一般I/O调整建议，请参阅第8.5.8节“优化InnoDB磁盘I/O”。</p></li><li class="listitem"><p><a name="sysvar_innodb_log_checkpoint_now"></a>
                <a class="indexterm" name="idm140286811411344"></a>

                <a class="indexterm" name="idm140286811410240"></a>

                <code class="literal">innodb_log_checkpoint_now</code>
            </p><p style="color:blue;">InnoDB_Log_检查点</p>
                <div class="informaltable">
                    <table frame="box" rules="all" summary="Properties for innodb_log_checkpoint_now"><colgroup><col width="30%"><col width="70%"></colgroup><thead><tr><th scope="col">Property</th>
                        <th scope="col">Value</th>
                    </tr></thead><tbody><tr><td scope="row"><span class="bold"><strong>Command-Line Format</strong></span></td>
                        <td><code class="literal">--innodb-log-checkpoint-now[={OFF|ON}]</code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Introduced</strong></span></td>
                        <td>5.7.2</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>System Variable</strong></span></td>
                        <td><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_log_checkpoint_now">innodb_log_checkpoint_now</a></code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Scope</strong></span></td>
                        <td>Global</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Dynamic</strong></span></td>
                        <td>Yes</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Type</strong></span></td>
                        <td>Boolean</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Default Value</strong></span></td>
                        <td><code class="literal">OFF</code></td>
                    </tr></tbody></table>
                </div>
                <p>
                    Enable this debug option to force <code class="literal">InnoDB</code> to
                    write a checkpoint. This option is only available if debugging
                    support is compiled in using the
                    <a class="link" href="installing.html#option_cmake_with_debug"><code class="option">WITH_DEBUG</code></a>
                    <span class="command"><strong>CMake</strong></span> option.
                </p><p style="color:blue;">启用此调试选项以强制innodb写入检查点。只有在使用with_debug cmake选项编译调试支持时，此选项才可用。</p></li><li class="listitem"><p><a name="sysvar_innodb_log_checksum_algorithm"></a>
                <a class="indexterm" name="idm140286811377408"></a>

                <a class="link" href="innodb-storage-engine.html#sysvar_innodb_log_checksum_algorithm"><code class="literal">innodb_log_checksum_algorithm</code></a>
            </p><p style="color:blue;">InnoDB_Log_校验和算法</p>
                <div class="informaltable">
                    <table frame="box" rules="all" summary="Properties for innodb_log_checksum_algorithm"><colgroup><col width="30%"><col width="70%"></colgroup><thead><tr><th scope="col">Property</th>
                        <th scope="col">Value</th>
                    </tr></thead><tbody><tr><td scope="row"><span class="bold"><strong>Command-Line Format</strong></span></td>
                        <td><code class="literal">--innodb-log-checksum-algorithm=algorithm_name</code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Introduced</strong></span></td>
                        <td>5.7.8</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Removed</strong></span></td>
                        <td>5.7.9</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>System Variable</strong></span></td>
                        <td><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_log_checksum_algorithm">innodb_log_checksum_algorithm</a></code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Scope</strong></span></td>
                        <td>Global</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Dynamic</strong></span></td>
                        <td>Yes</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Type</strong></span></td>
                        <td>Enumeration</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Default Value</strong></span></td>
                        <td><code class="literal">innodb</code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Valid Values</strong></span></td>
                        <td><p class="valid-value"><code class="literal">innodb</code></p><p style="color:blue;">InnoDB公司</p><p class="valid-value"><code class="literal">crc32</code></p><p style="color:blue;">CRC32型</p><p class="valid-value"><code class="literal">none</code></p><p style="color:blue;">没有人</p><p class="valid-value"><code class="literal">strict_innodb</code></p><p style="color:blue;">严格的</p><p class="valid-value"><code class="literal">strict_crc32</code></p><p style="color:blue;">严格的</p><p class="valid-value"><code class="literal">strict_none</code></p><p style="color:blue;">严格的</p></td>
                    </tr></tbody></table>
                </div>
                <p>
                    This variable was removed and replaced by
                    <code class="literal">innodb_log_checksums</code>.
                </p><p style="color:blue;">此变量已被移除并替换为innodb_log_校验和。</p><p>
                    Specifies how to generate and verify the
                    <a class="link" href="glossary.html#glos_checksum" title="checksum">checksum</a> stored in each
                    redo log disk block.
                    <code class="literal">innodb_log_checksum_algorithm</code> supports same
                    algorithms as <code class="literal">innodb_checksum_algorithm</code>.
                    Previously, only the <code class="literal">innodb</code> algorithm was
                    supported for redo log disk blocks.
                    <code class="literal">innodb_log_checksum_algorithm=innodb</code> is the
                    default setting.
                </p><p style="color:blue;">指定如何生成和验证存储在每个重做日志磁盘块中的校验和。innodb_log_checksum_算法支持与innodb_checksum_算法相同的算法。以前，重做日志磁盘块只支持innodb算法。innodb_log_checksum_algorithm=innodb是默认设置。</p><p>
                    The strict forms work the same as <code class="literal">innodb</code>,
                    <code class="literal">crc32</code>, and <code class="literal">none</code>, except
                    that <code class="literal">InnoDB</code> halts if it encounters a mix of
                    checksum values in the same redo log. You can only use the
                    strict settings in a completely new instance. The strict
                    settings are somewhat faster, because they do not need to
                    compute both new and old checksum values to accept both during
                    disk reads.
                </p><p style="color:blue;">严格格式的工作原理与innodb、crc32和none相同，只是如果innodb在同一重做日志中遇到校验和值的混合，它会停止工作。只能在完全新的实例中使用严格设置。严格的设置要快一些，因为它们不需要计算新的和旧的校验和值，以便在磁盘读取期间同时接受这两个值。</p><p>
                    The following table shows the difference between the
                    <code class="literal">none</code>, <code class="literal">innodb</code>, and
                    <code class="literal">crc32</code> option values, and their strict
                    counterparts. <code class="literal">none</code>,
                    <code class="literal">innodb</code>, and <code class="literal">crc32</code> write
                    the specified type of checksum value into each data block, but
                    for compatibility accept any of the other checksum values when
                    verifying a block during a read operation. The strict form of
                    each option only recognizes one kind of checksum, which makes
                    verification faster but requires that all
                    <code class="literal">InnoDB</code> redo logs in an instance are created
                    under an identical
                    <code class="literal">innodb_log_checksum_algorithm</code> value.
                </p><p style="color:blue;">下表显示了none、innodb和crc32选项值及其严格对应值之间的差异。none、innodb和crc32将指定类型的校验和值写入每个数据块，但为了兼容性，在读取操作期间验证块时，接受任何其他校验和值。每个选项的严格形式只识别一种校验和，这使得验证更快，但要求实例中的所有innodb重做日志都在相同的innodb日志校验和算法值下创建。</p>
                <div class="table">
                    <a name="idm140286811321584"></a><p class="title"><b>Table&nbsp;14.22&nbsp;innodb_log_checksum_algorithm Settings</b></p><p style="color:blue;">表14.22 InnoDB日志校验和算法设置</p>
                    <div class="table-contents">
                        <table><colgroup><col width="20%"><col width="40%"><col width="40%"></colgroup><thead><tr>
                            <th scope="col">Value</th>
                            <th scope="col">Generated checksum (when writing)</th>
                            <th scope="col">Permitted checksums (when reading)</th>
                        </tr></thead><tbody><tr>
                            <td scope="row">none</td>
                            <td>A constant number.</td>
                            <td>Any of the checksums generated by <code class="literal">none</code>,
                                <code class="literal">innodb</code>, or <code class="literal">crc32</code>.</td>
                        </tr><tr>
                            <td scope="row">innodb</td>
                            <td>A checksum calculated in software, using the original algorithm from
                                <code class="literal">InnoDB</code>.</td>
                            <td>Any of the checksums generated by <code class="literal">none</code>,
                                <code class="literal">innodb</code>, or <code class="literal">crc32</code>.</td>
                        </tr><tr>
                            <td scope="row">crc32</td>
                            <td>A checksum calculated using the <code class="literal">crc32</code> algorithm,
                                possibly done with a hardware assist.</td>
                            <td>Any of the checksums generated by <code class="literal">none</code>,
                                <code class="literal">innodb</code>, or <code class="literal">crc32</code>.</td>
                        </tr><tr>
                            <td scope="row">strict_none</td>
                            <td>A constant number</td>
                            <td>Only the checksum generated by <code class="literal">none</code>.</td>
                        </tr><tr>
                            <td scope="row">strict_innodb</td>
                            <td>A checksum calculated in software, using the original algorithm from
                                <code class="literal">InnoDB</code>.</td>
                            <td>Only the checksum generated by <code class="literal">innodb</code>.</td>
                        </tr><tr>
                            <td scope="row">strict_crc32</td>
                            <td>A checksum calculated using the <code class="literal">crc32</code> algorithm,
                                possibly done with a hardware assist.</td>
                            <td>Only the checksum generated by <code class="literal">crc32</code>.</td>
                        </tr></tbody></table>
                    </div>

                </div>
                <br class="table-break"></li><li class="listitem"><p><a name="sysvar_innodb_log_checksums"></a>
                <a class="indexterm" name="idm140286811281328"></a>

                <a class="indexterm" name="idm140286811280288"></a>

                <code class="literal">innodb_log_checksums</code>
            </p><p style="color:blue;">InnoDB_Log_校验和</p>
                <div class="informaltable">
                    <table frame="box" rules="all" summary="Properties for innodb_log_checksums"><colgroup><col width="30%"><col width="70%"></colgroup><thead><tr><th scope="col">Property</th>
                        <th scope="col">Value</th>
                    </tr></thead><tbody><tr><td scope="row"><span class="bold"><strong>Command-Line Format</strong></span></td>
                        <td><code class="literal">--innodb-log-checksums[={OFF|ON}]</code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Introduced</strong></span></td>
                        <td>5.7.9</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>System Variable</strong></span></td>
                        <td><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_log_checksums">innodb_log_checksums</a></code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Scope</strong></span></td>
                        <td>Global</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Dynamic</strong></span></td>
                        <td>Yes</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Type</strong></span></td>
                        <td>Boolean</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Default Value</strong></span></td>
                        <td><code class="literal">ON</code></td>
                    </tr></tbody></table>
                </div>
                <p>
                    Enables or disables checksums for redo log pages.
                    <code class="literal">innodb_log_checksums</code> replaces
                    <a class="link" href="innodb-storage-engine.html#sysvar_innodb_log_checksum_algorithm"><code class="literal">innodb_log_checksum_algorithm</code></a>.
                </p><p style="color:blue;">启用或禁用重做日志页的校验和。innodb_log_校验和取代innodb_log_校验和算法。</p><p>
                    <code class="literal">innodb_log_checksums=ON</code> enables the
                    <code class="literal">CRC-32C</code> checksum algorithm for redo log
                    pages. When <code class="literal">innodb_log_checksums</code> is
                    disabled, the contents of the redo log page checksum field are
                    ignored.
                </p><p style="color:blue;">innodb_log_checksums=on为重做日志页启用CRC-32C校验和算法。禁用innodb_log_checksum时，将忽略redo log page checksum字段的内容。</p><p>
                    Checksums on the redo log header page and redo log checkpoint
                    pages are never disabled.
                </p><p style="color:blue;">重做日志头页和重做日志检查点页上的校验和从未禁用。</p></li><li class="listitem"><p><a name="sysvar_innodb_log_compressed_pages"></a>
                <a class="indexterm" name="idm140286811244752"></a>

                <code class="literal">innodb_log_compressed_pages</code>
            </p><p style="color:blue;">InnoDB_Log_压缩页面</p>
                <div class="informaltable">
                    <table frame="box" rules="all" summary="Properties for innodb_log_compressed_pages"><colgroup><col width="30%"><col width="70%"></colgroup><thead><tr><th scope="col">Property</th>
                        <th scope="col">Value</th>
                    </tr></thead><tbody><tr><td scope="row"><span class="bold"><strong>Command-Line Format</strong></span></td>
                        <td><code class="literal">--innodb-log-compressed-pages[={OFF|ON}]</code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>System Variable</strong></span></td>
                        <td><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_log_compressed_pages">innodb_log_compressed_pages</a></code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Scope</strong></span></td>
                        <td>Global</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Dynamic</strong></span></td>
                        <td>Yes</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Type</strong></span></td>
                        <td>Boolean</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Default Value</strong></span></td>
                        <td><code class="literal">ON</code></td>
                    </tr></tbody></table>
                </div>
                <p>
                    Specifies whether images of
                    <a class="link" href="glossary.html#glos_compression" title="compression">re-compressed</a>
                    <a class="link" href="glossary.html#glos_page" title="page">pages</a> are written to the
                    <a class="link" href="glossary.html#glos_redo_log" title="redo log">redo log</a>. Re-compression
                    may occur when changes are made to compressed data.
                </p><p style="color:blue;">指定是否将重新压缩页的图像写入重做日志。更改压缩数据时，可能会发生重新压缩。</p><p>
                    <code class="literal">innodb_log_compressed_pages</code> is enabled by
                    default to prevent corruption that could occur if a different
                    version of the <code class="literal">zlib</code> compression algorithm
                    is used during recovery. If you are certain that the
                    <code class="literal">zlib</code> version will not change, you can
                    disable <code class="literal">innodb_log_compressed_pages</code> to
                    reduce redo log generation for workloads that modify
                    compressed data.
                </p><p style="color:blue;">默认情况下，会启用innodb_log_compressed_pages，以防止在恢复期间使用不同版本的zlib压缩算法时可能发生的损坏。如果确定zlib版本不会更改，可以禁用innodb_log_compressed_pages，以减少修改压缩数据的工作负载的重做日志生成。</p><p>
                    To measure the effect of enabling or disabling
                    <code class="literal">innodb_log_compressed_pages</code>, compare redo
                    log generation for both settings under the same workload.
                    Options for measuring redo log generation include observing
                    the <code class="literal">Log sequence number</code> (LSN) in the
                    <code class="literal">LOG</code> section of
                    <a class="link" href="sql-syntax.html#show-engine" title="13.7.5.15&nbsp;SHOW ENGINE Syntax"><code class="literal">SHOW ENGINE
                        INNODB STATUS</code></a> output, or monitoring
                    <a class="link" href="server-administration.html#statvar_Innodb_os_log_written"><code class="literal">Innodb_os_log_written</code></a> status
                    for the number of bytes written to the redo log files.
                </p><p style="color:blue;">要测量启用或禁用innodb_log_compressed_页面的效果，请比较相同工作负载下两个设置的重做日志生成。测量重做日志生成的选项包括观察show engine innodb status output的log部分中的日志序列号（lsn），或者监视innodb os_log_writed status中写入重做日志文件的字节数。</p><p>
                    For related information, see
                    <a class="xref" href="innodb-storage-engine.html#innodb-performance-compression-oltp" title="14.9.1.6&nbsp;Compression for OLTP Workloads">Section&nbsp;14.9.1.6, “Compression for OLTP Workloads”</a>.
                </p><p style="color:blue;">有关信息，请参阅第14.9.1.6节“OLTP工作负载的压缩”。</p></li><li class="listitem"><p><a name="sysvar_innodb_log_file_size"></a>
                <a class="indexterm" name="idm140286811204832"></a>

                <a class="indexterm" name="idm140286811203792"></a>

                <code class="literal">innodb_log_file_size</code>
            </p><p style="color:blue;">InnoDB_日志文件大小</p>
                <div class="informaltable">
                    <table frame="box" rules="all" summary="Properties for innodb_log_file_size"><colgroup><col width="30%"><col width="70%"></colgroup><thead><tr><th scope="col">Property</th>
                        <th scope="col">Value</th>
                    </tr></thead><tbody><tr><td scope="row"><span class="bold"><strong>Command-Line Format</strong></span></td>
                        <td><code class="literal">--innodb-log-file-size=#</code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>System Variable</strong></span></td>
                        <td><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_log_file_size">innodb_log_file_size</a></code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Scope</strong></span></td>
                        <td>Global</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Dynamic</strong></span></td>
                        <td>No</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Type</strong></span></td>
                        <td>Integer</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Default Value</strong></span></td>
                        <td><code class="literal">50331648</code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Minimum Value</strong></span> (&gt;= 5.7.11)</td>
                        <td><code class="literal">4194304</code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Minimum Value</strong></span> (&lt;= 5.7.10)</td>
                        <td><code class="literal">1048576</code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Maximum Value</strong></span></td>
                        <td><code class="literal">512GB / innodb_log_files_in_group</code></td>
                    </tr></tbody></table>
                </div>
                <p>
                    The size in bytes of each <a class="link" href="glossary.html#glos_log_file" title="log file">log
                    file</a> in a <a class="link" href="glossary.html#glos_log_group" title="log group">log
                    group</a>. The combined size of log files
                    (<code class="literal">innodb_log_file_size</code> *
                    <a class="link" href="innodb-storage-engine.html#sysvar_innodb_log_files_in_group"><code class="literal">innodb_log_files_in_group</code></a>)
                    cannot exceed a maximum value that is slightly less than
                    512GB. A pair of 255 GB log files, for example, approaches the
                    limit but does not exceed it. The default value is 48MB.
                </p><p style="color:blue;">日志组中每个日志文件的字节大小。日志文件的组合大小不能超过一个小于0的最大值。例如，一对255gb日志文件接近限制，但不超过该限制。默认值为48MB。</p><p>
                    Generally, the combined size of the log files should be large
                    enough that the server can smooth out peaks and troughs in
                    workload activity, which often means that there is enough redo
                    log space to handle more than an hour of write activity. The
                    larger the value, the less checkpoint flush activity is
                    required in the buffer pool, saving disk I/O. Larger log files
                    also make <a class="link" href="glossary.html#glos_crash_recovery" title="crash recovery">crash
                    recovery</a> slower, although improvements to recovery
                    performance make log file size less of a consideration than it
                    was in earlier versions of MySQL.
                </p><p style="color:blue;">通常，日志文件的组合大小应该足够大，以便服务器能够平滑工作负载活动中的高峰和低谷，这通常意味着有足够的重做日志空间来处理一个多小时的写入活动。该值越大，缓冲池中所需的检查点刷新活动就越少，从而节省了磁盘I/O。较大的日志文件也会使崩溃恢复速度变慢，尽管恢复性能的提高使日志文件的大小比MySQL早期版本中要少一些考虑。</p><p>
                    The minimum <code class="literal">innodb_log_file_size</code> value was
                    increased from 1MB to 4MB in MySQL 5.7.11.
                </p><p style="color:blue;">在mysql 5.7.11中，innodb_log_file_size的最小值从1MB增加到4MB。</p><p>
                    For related information, see
                    <a class="xref" href="innodb-storage-engine.html#innodb-startup-log-file-configuration" title="Redo Log File Configuration">Redo Log File Configuration</a>. For
                    general I/O tuning advice, see
                    <a class="xref" href="optimization.html#optimizing-innodb-diskio" title="8.5.8&nbsp;Optimizing InnoDB Disk I/O">Section&nbsp;8.5.8, “Optimizing InnoDB Disk I/O”</a>.
                </p><p style="color:blue;">有关相关信息，请参阅重做日志文件配置。有关一般I/O调整建议，请参阅第8.5.8节“优化InnoDB磁盘I/O”。</p></li><li class="listitem"><p><a name="sysvar_innodb_log_files_in_group"></a>
                <a class="indexterm" name="idm140286811157456"></a>

                <a class="indexterm" name="idm140286811156352"></a>

                <code class="literal">innodb_log_files_in_group</code>
            </p><p style="color:blue;">innodb_log_files_in_组</p>
                <div class="informaltable">
                    <table frame="box" rules="all" summary="Properties for innodb_log_files_in_group"><colgroup><col width="30%"><col width="70%"></colgroup><thead><tr><th scope="col">Property</th>
                        <th scope="col">Value</th>
                    </tr></thead><tbody><tr><td scope="row"><span class="bold"><strong>Command-Line Format</strong></span></td>
                        <td><code class="literal">--innodb-log-files-in-group=#</code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>System Variable</strong></span></td>
                        <td><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_log_files_in_group">innodb_log_files_in_group</a></code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Scope</strong></span></td>
                        <td>Global</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Dynamic</strong></span></td>
                        <td>No</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Type</strong></span></td>
                        <td>Integer</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Default Value</strong></span></td>
                        <td><code class="literal">2</code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Minimum Value</strong></span></td>
                        <td><code class="literal">2</code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Maximum Value</strong></span></td>
                        <td><code class="literal">100</code></td>
                    </tr></tbody></table>
                </div>
                <p>
                    The number of <a class="link" href="glossary.html#glos_log_file" title="log file">log files</a>
                    in the <a class="link" href="glossary.html#glos_log_group" title="log group">log group</a>.
                    <code class="literal">InnoDB</code> writes to the files in a circular
                    fashion. The default (and recommended) value is 2. The
                    location of the files is specified by
                    <a class="link" href="innodb-storage-engine.html#sysvar_innodb_log_group_home_dir"><code class="literal">innodb_log_group_home_dir</code></a>.
                    The combined size of log files
                    (<a class="link" href="innodb-storage-engine.html#sysvar_innodb_log_file_size"><code class="literal">innodb_log_file_size</code></a> *
                    <code class="literal">innodb_log_files_in_group</code>) can be up to
                    512GB.
                </p><p style="color:blue;">日志组中的日志文件数。innodb以循环方式写入文件。默认（和推荐）值为2。文件的位置由innodb_log_group_home_dir指定。日志文件的组合大小（innodb_log_file_size*innodb_log_files_in_group）可以高达512GB。</p><p>
                    For related information, see
                    <a class="xref" href="innodb-storage-engine.html#innodb-startup-log-file-configuration" title="Redo Log File Configuration">Redo Log File Configuration</a>.
                </p><p style="color:blue;">有关相关信息，请参阅重做日志文件配置。</p></li><li class="listitem"><p><a name="sysvar_innodb_log_group_home_dir"></a>
                <a class="indexterm" name="idm140286811115568"></a>

                <a class="indexterm" name="idm140286811114464"></a>

                <code class="literal">innodb_log_group_home_dir</code>
            </p><p style="color:blue;">InnoDB_Log_Group_Home_目录</p>
                <div class="informaltable">
                    <table frame="box" rules="all" summary="Properties for innodb_log_group_home_dir"><colgroup><col width="30%"><col width="70%"></colgroup><thead><tr><th scope="col">Property</th>
                        <th scope="col">Value</th>
                    </tr></thead><tbody><tr><td scope="row"><span class="bold"><strong>Command-Line Format</strong></span></td>
                        <td><code class="literal">--innodb-log-group-home-dir=dir_name</code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>System Variable</strong></span></td>
                        <td><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_log_group_home_dir">innodb_log_group_home_dir</a></code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Scope</strong></span></td>
                        <td>Global</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Dynamic</strong></span></td>
                        <td>No</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Type</strong></span></td>
                        <td>Directory name</td>
                    </tr></tbody></table>
                </div>
                <p>
                    The directory path to the <code class="literal">InnoDB</code>
                    <a class="link" href="glossary.html#glos_redo_log" title="redo log">redo log</a> files, whose
                    number is specified by
                    <a class="link" href="innodb-storage-engine.html#sysvar_innodb_log_files_in_group"><code class="literal">innodb_log_files_in_group</code></a>. If
                    you do not specify any <code class="literal">InnoDB</code> log
                    variables, the default is to create two files named
                    <code class="filename">ib_logfile0</code> and
                    <code class="filename">ib_logfile1</code> in the MySQL data directory.
                    Log file size is given by the
                    <a class="link" href="innodb-storage-engine.html#sysvar_innodb_log_file_size"><code class="literal">innodb_log_file_size</code></a> system
                    variable.
                </p><p style="color:blue;">InnoDB重做日志文件的目录路径，其编号由组中的InnoDB日志文件指定。如果没有指定任何innodb日志变量，默认情况下在mysql数据目录中创建两个名为ib_logfile0和ib_logfile1的文件。日志文件大小由innodb_log_file_size系统变量指定。</p><p>
                    For related information, see
                    <a class="xref" href="innodb-storage-engine.html#innodb-startup-log-file-configuration" title="Redo Log File Configuration">Redo Log File Configuration</a>.
                </p><p style="color:blue;">有关相关信息，请参阅重做日志文件配置。</p></li><li class="listitem"><p><a name="sysvar_innodb_log_write_ahead_size"></a>
                <a class="indexterm" name="idm140286811082288"></a>

                <a class="indexterm" name="idm140286811081184"></a>

                <code class="literal">innodb_log_write_ahead_size</code>
            </p><p style="color:blue;">innodb_log_write_ahead_大小</p>
                <div class="informaltable">
                    <table frame="box" rules="all" summary="Properties for innodb_log_write_ahead_size"><colgroup><col width="30%"><col width="70%"></colgroup><thead><tr><th scope="col">Property</th>
                        <th scope="col">Value</th>
                    </tr></thead><tbody><tr><td scope="row"><span class="bold"><strong>Command-Line Format</strong></span></td>
                        <td><code class="literal">--innodb-log-write-ahead-size=#</code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Introduced</strong></span></td>
                        <td>5.7.4</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>System Variable</strong></span></td>
                        <td><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_log_write_ahead_size">innodb_log_write_ahead_size</a></code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Scope</strong></span></td>
                        <td>Global</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Dynamic</strong></span></td>
                        <td>Yes</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Type</strong></span></td>
                        <td>Integer</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Default Value</strong></span></td>
                        <td><code class="literal">8192</code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Minimum Value</strong></span></td>
                        <td><code class="literal">512 (log file block size)</code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Maximum Value</strong></span></td>
                        <td><code class="literal">Equal to innodb_page_size</code></td>
                    </tr></tbody></table>
                </div>
                <p>
                    Defines the write-ahead block size for the redo log, in bytes.
                    To avoid <span class="quote">“<span class="quote">read-on-write</span>”</span>, set
                    <a class="link" href="innodb-storage-engine.html#sysvar_innodb_log_write_ahead_size"><code class="literal">innodb_log_write_ahead_size</code></a>
                    to match the operating system or file system cache block size.
                    The default setting is 8192 bytes. Read-on-write occurs when
                    redo log blocks are not entirely cached to the operating
                    system or file system due to a mismatch between write-ahead
                    block size for the redo log and operating system or file
                    system cache block size.
                </p><p style="color:blue;">定义重做日志的预写块大小（字节）。要避免“读写”，请将innodb_log_write_ahead_size设置为与操作系统或文件系统缓存块大小匹配。默认设置为8192字节。当由于重做日志的预写块大小与操作系统或文件系统缓存块大小不匹配，重做日志块未完全缓存到操作系统或文件系统时，会发生读写操作。</p><p>
                    Valid values for
                    <a class="link" href="innodb-storage-engine.html#sysvar_innodb_log_write_ahead_size"><code class="literal">innodb_log_write_ahead_size</code></a>
                    are multiples of the <code class="literal">InnoDB</code> log file block
                    size (2<sup>n</sup>). The minimum value is the
                    <code class="literal">InnoDB</code> log file block size (512).
                    Write-ahead does not occur when the minimum value is
                    specified. The maximum value is equal to the
                    <a class="link" href="innodb-storage-engine.html#sysvar_innodb_page_size"><code class="literal">innodb_page_size</code></a> value. If
                    you specify a value for
                    <a class="link" href="innodb-storage-engine.html#sysvar_innodb_log_write_ahead_size"><code class="literal">innodb_log_write_ahead_size</code></a>
                    that is larger than the
                    <a class="link" href="innodb-storage-engine.html#sysvar_innodb_page_size"><code class="literal">innodb_page_size</code></a> value, the
                    <code class="literal">innodb_log_write_ahead_size</code> setting is
                    truncated to the
                    <a class="link" href="innodb-storage-engine.html#sysvar_innodb_page_size"><code class="literal">innodb_page_size</code></a> value.
                </p><p style="color:blue;">innodb_log_write_ahead_size的有效值是innodb日志文件块大小（2n）的倍数。最小值是innodb日志文件块大小（512）。指定最小值时，不会发生提前写入。最大值等于NoNdByPaGig.Stand值。如果为innodb_log_write_ahead_size指定的值大于innodb_page_size值，则innodb_log_write_ahead_size设置将被截断为innodb_page_size值。</p><p>
                    Setting the
                    <a class="link" href="innodb-storage-engine.html#sysvar_innodb_log_write_ahead_size"><code class="literal">innodb_log_write_ahead_size</code></a>
                    value too low in relation to the operating system or file
                    system cache block size results in
                    <span class="quote">“<span class="quote">read-on-write</span>”</span>. Setting the value too high may
                    have a slight impact on <code class="literal">fsync</code> performance
                    for log file writes due to several blocks being written at
                    once.
                </p><p style="color:blue;">将innodb_log_write_ahead_size值相对于操作系统或文件系统缓存块大小设置得过低会导致“读写”。由于一次写入多个块，将该值设置得太高可能会对fsync日志文件写入性能产生轻微影响。</p><p>
                    For related information, see
                    <a class="xref" href="optimization.html#optimizing-innodb-logging" title="8.5.4&nbsp;Optimizing InnoDB Redo Logging">Section&nbsp;8.5.4, “Optimizing InnoDB Redo Logging”</a>.
                </p><p style="color:blue;">有关信息，请参阅第8.5.4节“优化InnoDB重做日志”。</p></li><li class="listitem"><p><a name="sysvar_innodb_lru_scan_depth"></a>
                <a class="indexterm" name="idm140286811028576"></a>

                <code class="literal">innodb_lru_scan_depth</code>
            </p><p style="color:blue;">innodb_lru_扫描深度</p>
                <div class="informaltable">
                    <table frame="box" rules="all" summary="Properties for innodb_lru_scan_depth"><colgroup><col width="30%"><col width="70%"></colgroup><thead><tr><th scope="col">Property</th>
                        <th scope="col">Value</th>
                    </tr></thead><tbody><tr><td scope="row"><span class="bold"><strong>Command-Line Format</strong></span></td>
                        <td><code class="literal">--innodb-lru-scan-depth=#</code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>System Variable</strong></span></td>
                        <td><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_lru_scan_depth">innodb_lru_scan_depth</a></code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Scope</strong></span></td>
                        <td>Global</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Dynamic</strong></span></td>
                        <td>Yes</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Type</strong></span></td>
                        <td>Integer</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Default Value</strong></span></td>
                        <td><code class="literal">1024</code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Minimum Value</strong></span></td>
                        <td><code class="literal">100</code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Maximum Value</strong></span> (64-bit platforms)</td>
                        <td><code class="literal">2**64-1</code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Maximum Value</strong></span> (32-bit platforms)</td>
                        <td><code class="literal">2**32-1</code></td>
                    </tr></tbody></table>
                </div>
                <p>
                    A parameter that influences the algorithms and heuristics for
                    the <a class="link" href="glossary.html#glos_flush" title="flush">flush</a> operation for the
                    <code class="literal">InnoDB</code>
                    <a class="link" href="glossary.html#glos_buffer_pool" title="buffer pool">buffer pool</a>. Primarily
                    of interest to performance experts tuning I/O-intensive
                    workloads. It specifies, per buffer pool instance, how far
                    down the buffer pool LRU page list the page cleaner thread
                    scans looking for <a class="link" href="glossary.html#glos_dirty_page" title="dirty page">dirty
                    pages</a> to flush. This is a background operation
                    performed once per second.
                </p><p style="color:blue;">影响InnoDB缓冲池刷新操作的算法和启发式的参数。主要是性能专家对优化I/O密集型工作负载感兴趣。它指定，每个缓冲池实例，在缓冲池lru页列表中，页清除器线程扫描查找要刷新的脏页的距离。这是每秒执行一次的后台操作。</p><p>
                    A setting smaller than the default is generally suitable for
                    most workloads. A value that is much higher than necessary may
                    impact performance. Only consider increasing the value if you
                    have spare I/O capacity under a typical workload. Conversely,
                    if a write-intensive workload saturates your I/O capacity,
                    decrease the value, especially in the case of a large buffer
                    pool.
                </p><p style="color:blue;">小于默认值的设置通常适用于大多数工作负载。如果值远远高于所需值，则可能会影响性能。只有在典型工作负载下有空闲的I/O容量时，才考虑增加该值。相反，如果写密集型工作负载使I/O容量饱和，请减小该值，特别是在大缓冲池的情况下。</p><p>
                    When tuning <code class="literal">innodb_lru_scan_depth</code>, start
                    with a low value and configure the setting upward with the
                    goal of rarely seeing zero free pages. Also, consider
                    adjusting <code class="literal">innodb_lru_scan_depth</code> when
                    changing the number of buffer pool instances, since
                    <code class="literal">innodb_lru_scan_depth</code> *
                    <a class="link" href="innodb-storage-engine.html#sysvar_innodb_buffer_pool_instances"><code class="literal">innodb_buffer_pool_instances</code></a>
                    defines the amount of work performed by the page cleaner
                    thread each second.
                </p><p style="color:blue;">当调整innodb_lru_scan_depth时，从一个较低的值开始，向上配置设置，目标是很少看到零空闲页面。另外，在更改缓冲池实例数时，考虑调整innodb_lru_scan_depth，因为innodb_lru scan_depth*innodb_buffer_pool_instances定义了页面清理线程每秒执行的工作量。</p><p>
                    For related information, see
                    <a class="xref" href="innodb-storage-engine.html#innodb-buffer-pool-flushing" title="14.8.3.5&nbsp;Configuring Buffer Pool Flushing">Section&nbsp;14.8.3.5, “Configuring Buffer Pool Flushing”</a>. For general I/O
                    tuning advice, see <a class="xref" href="optimization.html#optimizing-innodb-diskio" title="8.5.8&nbsp;Optimizing InnoDB Disk I/O">Section&nbsp;8.5.8, “Optimizing InnoDB Disk I/O”</a>.
                </p><p style="color:blue;">有关信息，请参阅第14.8.3.5节“配置缓冲池刷新”。有关一般I/O调整建议，请参阅第8.5.8节“优化InnoDB磁盘I/O”。</p></li><li class="listitem"><p><a name="sysvar_innodb_max_dirty_pages_pct"></a>
                <a class="indexterm" name="idm140286810981376"></a>

                <a class="indexterm" name="idm140286810980272"></a>

                <code class="literal">innodb_max_dirty_pages_pct</code>
            </p><p style="color:blue;">innodb_max_dirty_页面</p>
                <div class="informaltable">
                    <table frame="box" rules="all" summary="Properties for innodb_max_dirty_pages_pct"><colgroup><col width="30%"><col width="70%"></colgroup><thead><tr><th scope="col">Property</th>
                        <th scope="col">Value</th>
                    </tr></thead><tbody><tr><td scope="row"><span class="bold"><strong>Command-Line Format</strong></span></td>
                        <td><code class="literal">--innodb-max-dirty-pages-pct=#</code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>System Variable</strong></span></td>
                        <td><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_max_dirty_pages_pct">innodb_max_dirty_pages_pct</a></code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Scope</strong></span></td>
                        <td>Global</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Dynamic</strong></span></td>
                        <td>Yes</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Type</strong></span></td>
                        <td>Numeric</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Default Value</strong></span></td>
                        <td><code class="literal">75</code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Minimum Value</strong></span></td>
                        <td><code class="literal">0</code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Maximum Value</strong></span> (&gt;= 5.7.5)</td>
                        <td><code class="literal">99.99</code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Maximum Value</strong></span> (&lt;= 5.7.4)</td>
                        <td><code class="literal">99</code></td>
                    </tr></tbody></table>
                </div>
                <p>
                    <code class="literal">InnoDB</code> tries to
                    <a class="link" href="glossary.html#glos_flush" title="flush">flush</a> data from the
                    <a class="link" href="glossary.html#glos_buffer_pool" title="buffer pool">buffer pool</a> so that
                    the percentage of <a class="link" href="glossary.html#glos_dirty_page" title="dirty page">dirty
                    pages</a> does not exceed this value. The default value is
                    75.
                </p><p style="color:blue;">innodb试图刷新缓冲池中的数据，以便脏页的百分比不超过此值。默认值为75。</p><p>
                    The
                    <a class="link" href="innodb-storage-engine.html#sysvar_innodb_max_dirty_pages_pct"><code class="literal">innodb_max_dirty_pages_pct</code></a>
                    setting establishes a target for flushing activity. It does
                    not affect the rate of flushing. For information about
                    managing the rate of flushing, see
                    <a class="xref" href="innodb-storage-engine.html#innodb-buffer-pool-flushing" title="14.8.3.5&nbsp;Configuring Buffer Pool Flushing">Section&nbsp;14.8.3.5, “Configuring Buffer Pool Flushing”</a>.
                </p><p style="color:blue;">innodb_max_dirty_pages_pct设置建立刷新活动的目标。不影响冲洗速度。有关管理刷新率的信息，请参阅第14.8.3.5节“配置缓冲池刷新”。</p><p>
                    For related information, see
                    <a class="xref" href="innodb-storage-engine.html#innodb-buffer-pool-flushing" title="14.8.3.5&nbsp;Configuring Buffer Pool Flushing">Section&nbsp;14.8.3.5, “Configuring Buffer Pool Flushing”</a>. For general I/O
                    tuning advice, see <a class="xref" href="optimization.html#optimizing-innodb-diskio" title="8.5.8&nbsp;Optimizing InnoDB Disk I/O">Section&nbsp;8.5.8, “Optimizing InnoDB Disk I/O”</a>.
                </p><p style="color:blue;">有关信息，请参阅第14.8.3.5节“配置缓冲池刷新”。有关一般I/O调整建议，请参阅第8.5.8节“优化InnoDB磁盘I/O”。</p></li><li class="listitem"><p><a name="sysvar_innodb_max_dirty_pages_pct_lwm"></a>
                <a class="indexterm" name="idm140286810934576"></a>

                <code class="literal">innodb_max_dirty_pages_pct_lwm</code>
            </p><p style="color:blue;">innodb_max_dirty_pages_pct_lwm</p>
                <div class="informaltable">
                    <table frame="box" rules="all" summary="Properties for innodb_max_dirty_pages_pct_lwm"><colgroup><col width="30%"><col width="70%"></colgroup><thead><tr><th scope="col">Property</th>
                        <th scope="col">Value</th>
                    </tr></thead><tbody><tr><td scope="row"><span class="bold"><strong>Command-Line Format</strong></span></td>
                        <td><code class="literal">--innodb-max-dirty-pages-pct-lwm=#</code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>System Variable</strong></span></td>
                        <td><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_max_dirty_pages_pct_lwm">innodb_max_dirty_pages_pct_lwm</a></code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Scope</strong></span></td>
                        <td>Global</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Dynamic</strong></span></td>
                        <td>Yes</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Type</strong></span></td>
                        <td>Numeric</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Default Value</strong></span></td>
                        <td><code class="literal">0</code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Minimum Value</strong></span></td>
                        <td><code class="literal">0</code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Maximum Value</strong></span> (&gt;= 5.7.5)</td>
                        <td><code class="literal">99.99</code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Maximum Value</strong></span> (&lt;= 5.7.4)</td>
                        <td><code class="literal">99</code></td>
                    </tr></tbody></table>
                </div>
                <p>
                    Defines a low water mark representing the percentage of
                    <a class="link" href="glossary.html#glos_dirty_page" title="dirty page">dirty pages</a> at which
                    preflushing is enabled to control the dirty page ratio. The
                    default of 0 disables the pre-flushing behavior entirely. For
                    more information, see
                    <a class="xref" href="innodb-storage-engine.html#innodb-buffer-pool-flushing" title="14.8.3.5&nbsp;Configuring Buffer Pool Flushing">Section&nbsp;14.8.3.5, “Configuring Buffer Pool Flushing”</a>.
                </p><p style="color:blue;">定义表示启用预刷新以控制脏页比率的脏页百分比的低水位线。默认值为0将完全禁用预刷新行为。有关更多信息，请参阅第14.8.3.5节“配置缓冲池刷新”。</p></li><li class="listitem"><p><a name="sysvar_innodb_max_purge_lag"></a>
                <a class="indexterm" name="idm140286810896080"></a>

                <a class="indexterm" name="idm140286810895040"></a>

                <code class="literal">innodb_max_purge_lag</code>
            </p><p style="color:blue;">innodb_max_purge_滞后</p>
                <div class="informaltable">
                    <table frame="box" rules="all" summary="Properties for innodb_max_purge_lag"><colgroup><col width="30%"><col width="70%"></colgroup><thead><tr><th scope="col">Property</th>
                        <th scope="col">Value</th>
                    </tr></thead><tbody><tr><td scope="row"><span class="bold"><strong>Command-Line Format</strong></span></td>
                        <td><code class="literal">--innodb-max-purge-lag=#</code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>System Variable</strong></span></td>
                        <td><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_max_purge_lag">innodb_max_purge_lag</a></code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Scope</strong></span></td>
                        <td>Global</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Dynamic</strong></span></td>
                        <td>Yes</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Type</strong></span></td>
                        <td>Integer</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Default Value</strong></span></td>
                        <td><code class="literal">0</code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Minimum Value</strong></span></td>
                        <td><code class="literal">0</code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Maximum Value</strong></span></td>
                        <td><code class="literal">4294967295</code></td>
                    </tr></tbody></table>
                </div>
                <p>
                    Specifies the maximum delay in microseconds for the delay
                    imposed when the
                    <a class="link" href="innodb-storage-engine.html#sysvar_innodb_max_purge_lag"><code class="literal">innodb_max_purge_lag</code></a>
                    threshold is exceeded. The specified
                    <a class="link" href="innodb-storage-engine.html#sysvar_innodb_max_purge_lag_delay"><code class="literal">innodb_max_purge_lag_delay</code></a>
                    value is an upper limit on the delay period calculated by the
                    <a class="link" href="innodb-storage-engine.html#sysvar_innodb_max_purge_lag"><code class="literal">innodb_max_purge_lag</code></a> formula.
                </p><p style="color:blue;">指定在超过NynBudMax PurgEng迟滞阈值时所施加的延迟的微秒最大延迟。指定的innodb_max_purge_lag_延迟值是由innodb_max_purge_lag公式计算的延迟周期的上限。</p><p>
                    For more information, see
                    <a class="xref" href="innodb-storage-engine.html#innodb-purge-configuration" title="14.8.10&nbsp;Purge Configuration">Section&nbsp;14.8.10, “Purge Configuration”</a>.
                </p><p style="color:blue;">有关更多信息，请参见第14.8.10节“清除配置”。</p></li><li class="listitem"><p><a name="sysvar_innodb_max_purge_lag_delay"></a>
                <a class="indexterm" name="idm140286810856176"></a>

                <a class="indexterm" name="idm140286810855072"></a>

                <code class="literal">innodb_max_purge_lag_delay</code>
            </p><p style="color:blue;">innodb_max_purge_lag_延迟</p>
                <div class="informaltable">
                    <table frame="box" rules="all" summary="Properties for innodb_max_purge_lag_delay"><colgroup><col width="30%"><col width="70%"></colgroup><thead><tr><th scope="col">Property</th>
                        <th scope="col">Value</th>
                    </tr></thead><tbody><tr><td scope="row"><span class="bold"><strong>Command-Line Format</strong></span></td>
                        <td><code class="literal">--innodb-max-purge-lag-delay=#</code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>System Variable</strong></span></td>
                        <td><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_max_purge_lag_delay">innodb_max_purge_lag_delay</a></code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Scope</strong></span></td>
                        <td>Global</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Dynamic</strong></span></td>
                        <td>Yes</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Type</strong></span></td>
                        <td>Integer</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Default Value</strong></span></td>
                        <td><code class="literal">0</code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Minimum Value</strong></span></td>
                        <td><code class="literal">0</code></td>
                    </tr></tbody></table>
                </div>
                <p>
                    Specifies the maximum delay in microseconds for the delay
                    imposed by the
                    <a class="link" href="innodb-storage-engine.html#sysvar_innodb_max_purge_lag"><code class="literal">innodb_max_purge_lag</code></a>
                    variable. The specified value is the upper limit on the delay
                    period computed from the formula based on the value of
                    <a class="link" href="innodb-storage-engine.html#sysvar_innodb_max_purge_lag"><code class="literal">innodb_max_purge_lag</code></a>.
                </p><p style="color:blue;">指定由NynBudMax PurgEng滞后变量所施加的延迟在微秒内的最大延迟。指定值是基于innodb_max_purge_lag值的公式计算的延迟周期的上限。</p><p>
                    For general I/O tuning advice, see
                    <a class="xref" href="optimization.html#optimizing-innodb-diskio" title="8.5.8&nbsp;Optimizing InnoDB Disk I/O">Section&nbsp;8.5.8, “Optimizing InnoDB Disk I/O”</a>.
                </p><p style="color:blue;">有关一般I/O调整建议，请参阅第8.5.8节“优化InnoDB磁盘I/O”。</p></li><li class="listitem"><p><a name="sysvar_innodb_max_undo_log_size"></a>
                <a class="indexterm" name="idm140286810820464"></a>

                <a class="indexterm" name="idm140286810819360"></a>

                <code class="literal">innodb_max_undo_log_size</code>
            </p><p style="color:blue;">innodb_max_undo_日志大小</p>
                <div class="informaltable">
                    <table frame="box" rules="all" summary="Properties for innodb_max_undo_log_size"><colgroup><col width="30%"><col width="70%"></colgroup><thead><tr><th scope="col">Property</th>
                        <th scope="col">Value</th>
                    </tr></thead><tbody><tr><td scope="row"><span class="bold"><strong>Command-Line Format</strong></span></td>
                        <td><code class="literal">--innodb-max-undo-log-size=#</code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Introduced</strong></span></td>
                        <td>5.7.5</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>System Variable</strong></span></td>
                        <td><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_max_undo_log_size">innodb_max_undo_log_size</a></code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Scope</strong></span></td>
                        <td>Global</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Dynamic</strong></span></td>
                        <td>Yes</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Type</strong></span></td>
                        <td>Integer</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Default Value</strong></span></td>
                        <td><code class="literal">1073741824</code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Minimum Value</strong></span></td>
                        <td><code class="literal">10485760</code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Maximum Value</strong></span></td>
                        <td><code class="literal">2**64-1</code></td>
                    </tr></tbody></table>
                </div>
                <p>
                    Defines a threshold size for undo tablespaces. If an undo
                    tablespace exceeds the threshold, it can be marked for
                    truncation when
                    <a class="link" href="innodb-storage-engine.html#sysvar_innodb_undo_log_truncate"><code class="literal">innodb_undo_log_truncate</code></a> is
                    enabled. The default value is 1073741824 bytes (1024 MiB).
                </p><p style="color:blue;">定义撤消表空间的阈值大小。如果undo表空间超过了阈值，那么当启用innodb_undo_log_truncate时，可以将其标记为截断。默认值为1073741824字节（1024 mib）。</p><p>
                    For more information, see
                    <a class="xref" href="innodb-storage-engine.html#truncate-undo-tablespace" title="Truncating Undo Tablespaces">Truncating Undo Tablespaces</a>.
                </p><p style="color:blue;">有关详细信息，请参见截断撤消表空间。</p></li><li class="listitem"><p><a name="sysvar_innodb_merge_threshold_set_all_debug"></a>
                <a class="indexterm" name="idm140286810780096"></a>

                <a class="indexterm" name="idm140286810779056"></a>

                <code class="literal">innodb_merge_threshold_set_all_debug</code>
            </p><p style="color:blue;">innodb_merge_threshold_set_all_调试</p>
                <div class="informaltable">
                    <table frame="box" rules="all" summary="Properties for innodb_merge_threshold_set_all_debug"><colgroup><col width="30%"><col width="70%"></colgroup><thead><tr><th scope="col">Property</th>
                        <th scope="col">Value</th>
                    </tr></thead><tbody><tr><td scope="row"><span class="bold"><strong>Command-Line Format</strong></span></td>
                        <td><code class="literal">--innodb-merge-threshold-set-all-debug=#</code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Introduced</strong></span></td>
                        <td>5.7.6</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>System Variable</strong></span></td>
                        <td><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_merge_threshold_set_all_debug">innodb_merge_threshold_set_all_debug</a></code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Scope</strong></span></td>
                        <td>Global</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Dynamic</strong></span></td>
                        <td>Yes</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Type</strong></span></td>
                        <td>Integer</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Default Value</strong></span></td>
                        <td><code class="literal">50</code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Minimum Value</strong></span></td>
                        <td><code class="literal">1</code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Maximum Value</strong></span></td>
                        <td><code class="literal">50</code></td>
                    </tr></tbody></table>
                </div>
                <p>
                    Defines a page-full percentage value for index pages that
                    overrides the current <code class="literal">MERGE_THRESHOLD</code>
                    setting for all indexes that are currently in the dictionary
                    cache. This option is only available if debugging support is
                    compiled in using the <a class="link" href="installing.html#option_cmake_with_debug"><code class="option">WITH_DEBUG</code></a>
                    <span class="command"><strong>CMake</strong></span> option. For related information, see
                    <a class="xref" href="innodb-storage-engine.html#index-page-merge-threshold" title="14.8.12&nbsp;Configuring the Merge Threshold for Index Pages">Section&nbsp;14.8.12, “Configuring the Merge Threshold for Index Pages”</a>.
                </p><p style="color:blue;">定义索引页的页完整百分比值，该值覆盖当前字典缓存中所有索引的当前合并阈值设置。只有在使用with_debug cmake选项编译调试支持时，此选项才可用。有关信息，请参阅第14.8.12节“为索引页配置合并阈值”。</p></li><li class="listitem"><p><a name="sysvar_innodb_monitor_disable"></a>
                <a class="indexterm" name="idm140286810739248"></a>

                <code class="literal">innodb_monitor_disable</code>
            </p><p style="color:blue;">InnoDB_监视器禁用</p>
                <div class="informaltable">
                    <table frame="box" rules="all" summary="Properties for innodb_monitor_disable"><colgroup><col width="30%"><col width="70%"></colgroup><thead><tr><th scope="col">Property</th>
                        <th scope="col">Value</th>
                    </tr></thead><tbody><tr><td scope="row"><span class="bold"><strong>Command-Line Format</strong></span></td>
                        <td><code class="literal">--innodb-monitor-disable={counter|module|pattern|all}</code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>System Variable</strong></span></td>
                        <td><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_monitor_disable">innodb_monitor_disable</a></code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Scope</strong></span></td>
                        <td>Global</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Dynamic</strong></span></td>
                        <td>Yes</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Type</strong></span></td>
                        <td>String</td>
                    </tr></tbody></table>
                </div>
                <p>
                    Disables <code class="literal">InnoDB</code>
                    <a class="link" href="glossary.html#glos_metrics_counter" title="metrics counter">metrics counters</a>.
                    Counter data may be queried using the
                    <a class="link" href="information-schema.html#innodb-metrics-table" title="24.32.15&nbsp;The INFORMATION_SCHEMA INNODB_METRICS Table"><code class="literal">INFORMATION_SCHEMA.INNODB_METRICS</code></a>
                    table. For usage information, see
                    <a class="xref" href="innodb-storage-engine.html#innodb-information-schema-metrics-table" title="14.15.6&nbsp;InnoDB INFORMATION_SCHEMA Metrics Table">Section&nbsp;14.15.6, “InnoDB INFORMATION_SCHEMA Metrics Table”</a>.
                </p><p style="color:blue;">禁用innodb metrics计数器。可以使用information schema.innodb_metrics表查询计数器数据。有关用法信息，请参阅14.15.6节，“innodb information_schema metrics table”。</p><p>
                    <code class="literal">innodb_monitor_disable='latch'</code> disables
                    statistics collection for
                    <a class="link" href="sql-syntax.html#show-engine" title="13.7.5.15&nbsp;SHOW ENGINE Syntax"><code class="literal">SHOW ENGINE
                        INNODB MUTEX</code></a>. For more information, see
                    <a class="xref" href="sql-syntax.html#show-engine" title="13.7.5.15&nbsp;SHOW ENGINE Syntax">Section&nbsp;13.7.5.15, “SHOW ENGINE Syntax”</a>.
                </p><p style="color:blue;">innodb_monitor_disable=“latch”禁用显示引擎innodb mutex的统计信息收集。有关详细信息，请参阅第13.7.5.15节“显示引擎语法”。</p></li><li class="listitem"><p><a name="sysvar_innodb_monitor_enable"></a>
                <a class="indexterm" name="idm140286810708288"></a>

                <code class="literal">innodb_monitor_enable</code>
            </p><p style="color:blue;">InnoDB_监视器启用</p>
                <div class="informaltable">
                    <table frame="box" rules="all" summary="Properties for innodb_monitor_enable"><colgroup><col width="30%"><col width="70%"></colgroup><thead><tr><th scope="col">Property</th>
                        <th scope="col">Value</th>
                    </tr></thead><tbody><tr><td scope="row"><span class="bold"><strong>Command-Line Format</strong></span></td>
                        <td><code class="literal">--innodb-monitor-enable={counter|module|pattern|all}</code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>System Variable</strong></span></td>
                        <td><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_monitor_enable">innodb_monitor_enable</a></code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Scope</strong></span></td>
                        <td>Global</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Dynamic</strong></span></td>
                        <td>Yes</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Type</strong></span></td>
                        <td>String</td>
                    </tr></tbody></table>
                </div>
                <p>
                    Enables <code class="literal">InnoDB</code>
                    <a class="link" href="glossary.html#glos_metrics_counter" title="metrics counter">metrics counters</a>.
                    Counter data may be queried using the
                    <a class="link" href="information-schema.html#innodb-metrics-table" title="24.32.15&nbsp;The INFORMATION_SCHEMA INNODB_METRICS Table"><code class="literal">INFORMATION_SCHEMA.INNODB_METRICS</code></a>
                    table. For usage information, see
                    <a class="xref" href="innodb-storage-engine.html#innodb-information-schema-metrics-table" title="14.15.6&nbsp;InnoDB INFORMATION_SCHEMA Metrics Table">Section&nbsp;14.15.6, “InnoDB INFORMATION_SCHEMA Metrics Table”</a>.
                </p><p style="color:blue;">启用InnoDB度量计数器。可以使用information schema.innodb_metrics表查询计数器数据。有关用法信息，请参阅14.15.6节，“innodb information_schema metrics table”。</p><p>
                    <code class="literal">innodb_monitor_enable='latch'</code> enables
                    statistics collection for
                    <a class="link" href="sql-syntax.html#show-engine" title="13.7.5.15&nbsp;SHOW ENGINE Syntax"><code class="literal">SHOW ENGINE
                        INNODB MUTEX</code></a>. For more information, see
                    <a class="xref" href="sql-syntax.html#show-engine" title="13.7.5.15&nbsp;SHOW ENGINE Syntax">Section&nbsp;13.7.5.15, “SHOW ENGINE Syntax”</a>.
                </p><p style="color:blue;">innodb_monitor_enable='latch'为显示引擎innodb mutex启用统计信息收集。有关详细信息，请参阅第13.7.5.15节“显示引擎语法”。</p></li><li class="listitem"><p><a name="sysvar_innodb_monitor_reset"></a>
                <a class="indexterm" name="idm140286810677520"></a>

                <code class="literal">innodb_monitor_reset</code>
            </p><p style="color:blue;">InnoDB_监视器复位</p>
                <div class="informaltable">
                    <table frame="box" rules="all" summary="Properties for innodb_monitor_reset"><colgroup><col width="30%"><col width="70%"></colgroup><thead><tr><th scope="col">Property</th>
                        <th scope="col">Value</th>
                    </tr></thead><tbody><tr><td scope="row"><span class="bold"><strong>Command-Line Format</strong></span></td>
                        <td><code class="literal">--innodb-monitor-reset={counter|module|pattern|all}</code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>System Variable</strong></span></td>
                        <td><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_monitor_reset">innodb_monitor_reset</a></code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Scope</strong></span></td>
                        <td>Global</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Dynamic</strong></span></td>
                        <td>Yes</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Type</strong></span></td>
                        <td>Enumeration</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Default Value</strong></span></td>
                        <td><code class="literal">empty string</code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Valid Values</strong></span></td>
                        <td><p class="valid-value"><code class="literal">counter</code></p><p style="color:blue;">柜台</p><p class="valid-value"><code class="literal">module</code></p><p style="color:blue;">模块</p><p class="valid-value"><code class="literal">pattern</code></p><p style="color:blue;">图案</p><p class="valid-value"><code class="literal">all</code></p><p style="color:blue;">全部的</p></td>
                    </tr></tbody></table>
                </div>
                <p>
                    Resets the count value for <code class="literal">InnoDB</code>
                    <a class="link" href="glossary.html#glos_metrics_counter" title="metrics counter">metrics counters</a>
                    to zero. Counter data may be queried using the
                    <a class="link" href="information-schema.html#innodb-metrics-table" title="24.32.15&nbsp;The INFORMATION_SCHEMA INNODB_METRICS Table"><code class="literal">INFORMATION_SCHEMA.INNODB_METRICS</code></a>
                    table. For usage information, see
                    <a class="xref" href="innodb-storage-engine.html#innodb-information-schema-metrics-table" title="14.15.6&nbsp;InnoDB INFORMATION_SCHEMA Metrics Table">Section&nbsp;14.15.6, “InnoDB INFORMATION_SCHEMA Metrics Table”</a>.
                </p><p style="color:blue;">将innodb metrics计数器的计数值重置为零。可以使用information schema.innodb_metrics表查询计数器数据。有关用法信息，请参阅14.15.6节，“innodb information_schema metrics table”。</p><p>
                    <code class="literal">innodb_monitor_reset='latch'</code> resets
                    statistics reported by
                    <a class="link" href="sql-syntax.html#show-engine" title="13.7.5.15&nbsp;SHOW ENGINE Syntax"><code class="literal">SHOW ENGINE
                        INNODB MUTEX</code></a>. For more information, see
                    <a class="xref" href="sql-syntax.html#show-engine" title="13.7.5.15&nbsp;SHOW ENGINE Syntax">Section&nbsp;13.7.5.15, “SHOW ENGINE Syntax”</a>.
                </p><p style="color:blue;">innodb_monitor_reset='latch'重置显示引擎innodb mutex报告的统计信息。有关详细信息，请参阅第13.7.5.15节“显示引擎语法”。</p></li><li class="listitem"><p><a name="sysvar_innodb_monitor_reset_all"></a>
                <a class="indexterm" name="idm140286810637296"></a>

                <code class="literal">innodb_monitor_reset_all</code>
            </p><p style="color:blue;">innodb_monitor_reset_所有</p>
                <div class="informaltable">
                    <table frame="box" rules="all" summary="Properties for innodb_monitor_reset_all"><colgroup><col width="30%"><col width="70%"></colgroup><thead><tr><th scope="col">Property</th>
                        <th scope="col">Value</th>
                    </tr></thead><tbody><tr><td scope="row"><span class="bold"><strong>Command-Line Format</strong></span></td>
                        <td><code class="literal">--innodb-monitor-reset-all={counter|module|pattern|all}</code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>System Variable</strong></span></td>
                        <td><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_monitor_reset_all">innodb_monitor_reset_all</a></code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Scope</strong></span></td>
                        <td>Global</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Dynamic</strong></span></td>
                        <td>Yes</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Type</strong></span></td>
                        <td>Enumeration</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Default Value</strong></span></td>
                        <td><code class="literal">empty string</code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Valid Values</strong></span></td>
                        <td><p class="valid-value"><code class="literal">counter</code></p><p style="color:blue;">柜台</p><p class="valid-value"><code class="literal">module</code></p><p style="color:blue;">模块</p><p class="valid-value"><code class="literal">pattern</code></p><p style="color:blue;">图案</p><p class="valid-value"><code class="literal">all</code></p><p style="color:blue;">全部的</p></td>
                    </tr></tbody></table>
                </div>
                <p>
                    Resets all values (minimum, maximum, and so on) for
                    <code class="literal">InnoDB</code>
                    <a class="link" href="glossary.html#glos_metrics_counter" title="metrics counter">metrics counters</a>.
                    Counter data may be queried using the
                    <a class="link" href="information-schema.html#innodb-metrics-table" title="24.32.15&nbsp;The INFORMATION_SCHEMA INNODB_METRICS Table"><code class="literal">INFORMATION_SCHEMA.INNODB_METRICS</code></a>
                    table. For usage information, see
                    <a class="xref" href="innodb-storage-engine.html#innodb-information-schema-metrics-table" title="14.15.6&nbsp;InnoDB INFORMATION_SCHEMA Metrics Table">Section&nbsp;14.15.6, “InnoDB INFORMATION_SCHEMA Metrics Table”</a>.
                </p><p style="color:blue;">为YNODB度量计数器重置所有值（最小值、最大值等）。可以使用information schema.innodb_metrics表查询计数器数据。有关用法信息，请参阅14.15.6节，“innodb information_schema metrics table”。</p></li><li class="listitem"><p><a name="sysvar_innodb_numa_interleave"></a>
                <a class="indexterm" name="idm140286810600080"></a>

                <a class="indexterm" name="idm140286810599040"></a>

                <code class="literal">innodb_numa_interleave</code>
            </p><p style="color:blue;">Innodb_Numa_交织</p>
                <div class="informaltable">
                    <table frame="box" rules="all" summary="Properties for innodb_numa_interleave"><colgroup><col width="30%"><col width="70%"></colgroup><thead><tr><th scope="col">Property</th>
                        <th scope="col">Value</th>
                    </tr></thead><tbody><tr><td scope="row"><span class="bold"><strong>Command-Line Format</strong></span></td>
                        <td><code class="literal">--innodb-numa-interleave[={OFF|ON}]</code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Introduced</strong></span></td>
                        <td>5.7.9</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>System Variable</strong></span></td>
                        <td><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_numa_interleave">innodb_numa_interleave</a></code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Scope</strong></span></td>
                        <td>Global</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Dynamic</strong></span></td>
                        <td>No</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Type</strong></span></td>
                        <td>Boolean</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Default Value</strong></span></td>
                        <td><code class="literal">OFF</code></td>
                    </tr></tbody></table>
                </div>
                <p>
                    Enables the NUMA interleave memory policy for allocation of
                    the <code class="literal">InnoDB</code> buffer pool. When
                    <code class="literal">innodb_numa_interleave</code> is enabled, the NUMA
                    memory policy is set to <code class="literal">MPOL_INTERLEAVE</code> for
                    the <a class="link" href="programs.html#mysqld" title="4.3.1&nbsp;mysqld — The MySQL Server"><span class="command"><strong>mysqld</strong></span></a> process. After the
                    <code class="literal">InnoDB</code> buffer pool is allocated, the NUMA
                    memory policy is set back to <code class="literal">MPOL_DEFAULT</code>.
                    For the <code class="literal">innodb_numa_interleave</code> option to be
                    available, MySQL must be compiled on a NUMA-enabled Linux
                    system.
                </p><p style="color:blue;">启用用于分配innodb缓冲池的numa交织内存策略。启用innodb_numa_interleave时，mysqld进程的numa内存策略设置为mpol_interleave。分配完innodb缓冲池后，numa内存策略被设置回mpol_default。要使innodb_numa_interleave选项可用，必须在支持numa的linux系统上编译mysql。</p><p>
                    As of MySQL 5.7.17, <span class="command"><strong>CMake</strong></span> sets the default
                    <a class="link" href="installing.html#option_cmake_with_numa"><code class="option">WITH_NUMA</code></a> value based on whether
                    the current platform has <code class="literal">NUMA</code> support. For
                    more information, see
                    <a class="xref" href="installing.html#source-configuration-options" title="2.9.7&nbsp;MySQL Source-Configuration Options">Section&nbsp;2.9.7, “MySQL Source-Configuration Options”</a>.
                </p><p style="color:blue;">从mysql 5.7.17开始，cmake根据当前平台是否支持numa来设置默认值。有关更多信息，请参阅2.9.7节，“MySQL源配置选项”。</p></li><li class="listitem"><p><a name="sysvar_innodb_old_blocks_pct"></a>
                <a class="indexterm" name="idm140286810559296"></a>

                <a class="indexterm" name="idm140286810558256"></a>

                <code class="literal">innodb_old_blocks_pct</code>
            </p><p style="color:blue;">Innodb_Old_Blocks_PCT公司</p>
                <div class="informaltable">
                    <table frame="box" rules="all" summary="Properties for innodb_old_blocks_pct"><colgroup><col width="30%"><col width="70%"></colgroup><thead><tr><th scope="col">Property</th>
                        <th scope="col">Value</th>
                    </tr></thead><tbody><tr><td scope="row"><span class="bold"><strong>Command-Line Format</strong></span></td>
                        <td><code class="literal">--innodb-old-blocks-pct=#</code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>System Variable</strong></span></td>
                        <td><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_old_blocks_pct">innodb_old_blocks_pct</a></code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Scope</strong></span></td>
                        <td>Global</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Dynamic</strong></span></td>
                        <td>Yes</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Type</strong></span></td>
                        <td>Integer</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Default Value</strong></span></td>
                        <td><code class="literal">37</code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Minimum Value</strong></span></td>
                        <td><code class="literal">5</code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Maximum Value</strong></span></td>
                        <td><code class="literal">95</code></td>
                    </tr></tbody></table>
                </div>
                <p>
                    Specifies the approximate percentage of the
                    <code class="literal">InnoDB</code>
                    <a class="link" href="glossary.html#glos_buffer_pool" title="buffer pool">buffer pool</a> used for
                    the old block <a class="link" href="glossary.html#glos_sublist" title="sublist">sublist</a>. The
                    range of values is 5 to 95. The default value is 37 (that is,
                    3/8 of the pool). Often used in combination with
                    <a class="link" href="innodb-storage-engine.html#sysvar_innodb_old_blocks_time"><code class="literal">innodb_old_blocks_time</code></a>.
                </p><p style="color:blue;">指定用于旧块子列表的UnIDB缓冲池的近似百分比。值的范围是5到95。默认值为37（即池的3/8）。通常与innodb-old-blocks-time结合使用。</p><p>
                    For more information, see
                    <a class="xref" href="innodb-storage-engine.html#innodb-performance-midpoint_insertion" title="14.8.3.3&nbsp;Making the Buffer Pool Scan Resistant">Section&nbsp;14.8.3.3, “Making the Buffer Pool Scan Resistant”</a>. For
                    information about buffer pool management, the
                    <a class="link" href="glossary.html#glos_lru" title="LRU">LRU</a> algorithm, and
                    <a class="link" href="glossary.html#glos_eviction" title="eviction">eviction</a> policies, see
                    <a class="xref" href="innodb-storage-engine.html#innodb-buffer-pool" title="14.5.1&nbsp;Buffer Pool">Section&nbsp;14.5.1, “Buffer Pool”</a>.
                </p><p style="color:blue;">有关更多信息，请参阅14.8.3.3节，“使缓冲池抗扫描”。有关缓冲池管理、lru算法和逐出策略的信息，请参阅第14.5.1节“缓冲池”。</p></li><li class="listitem"><p><a name="sysvar_innodb_old_blocks_time"></a>
                <a class="indexterm" name="idm140286810516976"></a>

                <a class="indexterm" name="idm140286810515936"></a>

                <code class="literal">innodb_old_blocks_time</code>
            </p><p style="color:blue;">Innodb_Old_Blocks_时间</p>
                <div class="informaltable">
                    <table frame="box" rules="all" summary="Properties for innodb_old_blocks_time"><colgroup><col width="30%"><col width="70%"></colgroup><thead><tr><th scope="col">Property</th>
                        <th scope="col">Value</th>
                    </tr></thead><tbody><tr><td scope="row"><span class="bold"><strong>Command-Line Format</strong></span></td>
                        <td><code class="literal">--innodb-old-blocks-time=#</code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>System Variable</strong></span></td>
                        <td><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_old_blocks_time">innodb_old_blocks_time</a></code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Scope</strong></span></td>
                        <td>Global</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Dynamic</strong></span></td>
                        <td>Yes</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Type</strong></span></td>
                        <td>Integer</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Default Value</strong></span></td>
                        <td><code class="literal">1000</code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Minimum Value</strong></span></td>
                        <td><code class="literal">0</code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Maximum Value</strong></span></td>
                        <td><code class="literal">2**32-1</code></td>
                    </tr></tbody></table>
                </div>
                <p>
                    Non-zero values protect against the
                    <a class="link" href="glossary.html#glos_buffer_pool" title="buffer pool">buffer pool</a> being
                    filled by data that is referenced only for a brief period,
                    such as during a <a class="link" href="glossary.html#glos_full_table_scan" title="full table scan">full
                    table scan</a>. Increasing this value offers more
                    protection against full table scans interfering with data
                    cached in the buffer pool.
                </p><p style="color:blue;">非零值保护缓冲池，防止缓冲池被仅在短时间内（如在完整表扫描期间）引用的数据填满。增加这个值可以提供更多的保护，防止全表扫描干扰缓冲池中缓存的数据。</p><p>
                    Specifies how long in milliseconds a block inserted into the
                    old <a class="link" href="glossary.html#glos_sublist" title="sublist">sublist</a> must stay
                    there after its first access before it can be moved to the new
                    sublist. If the value is 0, a block inserted into the old
                    sublist moves immediately to the new sublist the first time it
                    is accessed, no matter how soon after insertion the access
                    occurs. If the value is greater than 0, blocks remain in the
                    old sublist until an access occurs at least that many
                    milliseconds after the first access. For example, a value of
                    1000 causes blocks to stay in the old sublist for 1 second
                    after the first access before they become eligible to move to
                    the new sublist.
                </p><p style="color:blue;">指定插入到旧子列表中的块在第一次访问后必须在那里停留多长时间（毫秒），然后才能移动到新子列表。如果值为0，则插入到旧子列表中的块在第一次访问时将立即移动到新子列表中，无论插入后多久访问都是如此。如果该值大于0，则块将保留在旧子列表中，直到第一次访问后至少有那么多毫秒发生访问为止。例如，值1000会导致块在第一次访问后停留在旧子列表中1秒，然后才有资格移动到新子列表。</p><p>
                    The default value is 1000.
                </p><p style="color:blue;">默认值为1000。</p><p>
                    This variable is often used in combination with
                    <a class="link" href="innodb-storage-engine.html#sysvar_innodb_old_blocks_pct"><code class="literal">innodb_old_blocks_pct</code></a>. For
                    more information, see
                    <a class="xref" href="innodb-storage-engine.html#innodb-performance-midpoint_insertion" title="14.8.3.3&nbsp;Making the Buffer Pool Scan Resistant">Section&nbsp;14.8.3.3, “Making the Buffer Pool Scan Resistant”</a>. For
                    information about buffer pool management, the
                    <a class="link" href="glossary.html#glos_lru" title="LRU">LRU</a> algorithm, and
                    <a class="link" href="glossary.html#glos_eviction" title="eviction">eviction</a> policies, see
                    <a class="xref" href="innodb-storage-engine.html#innodb-buffer-pool" title="14.5.1&nbsp;Buffer Pool">Section&nbsp;14.5.1, “Buffer Pool”</a>.
                </p><p style="color:blue;">此变量通常与innodb_old_blocks_pct结合使用。有关更多信息，请参阅第14.8.3.3节“使缓冲池抗扫描”。有关缓冲池管理、lru算法和逐出策略的信息，请参阅第14.5.1节“缓冲池”。</p></li><li class="listitem"><p><a name="sysvar_innodb_online_alter_log_max_size"></a>
                <a class="indexterm" name="idm140286810472928"></a>

                <code class="literal">innodb_online_alter_log_max_size</code>
            </p><p style="color:blue;">InnoDB_Online_Alter_Log_Max_大小</p>
                <div class="informaltable">
                    <table frame="box" rules="all" summary="Properties for innodb_online_alter_log_max_size"><colgroup><col width="30%"><col width="70%"></colgroup><thead><tr><th scope="col">Property</th>
                        <th scope="col">Value</th>
                    </tr></thead><tbody><tr><td scope="row"><span class="bold"><strong>Command-Line Format</strong></span></td>
                        <td><code class="literal">--innodb-online-alter-log-max-size=#</code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>System Variable</strong></span></td>
                        <td><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_online_alter_log_max_size">innodb_online_alter_log_max_size</a></code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Scope</strong></span></td>
                        <td>Global</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Dynamic</strong></span></td>
                        <td>Yes</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Type</strong></span></td>
                        <td>Integer</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Default Value</strong></span></td>
                        <td><code class="literal">134217728</code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Minimum Value</strong></span></td>
                        <td><code class="literal">65536</code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Maximum Value</strong></span></td>
                        <td><code class="literal">2**64-1</code></td>
                    </tr></tbody></table>
                </div>
                <p>
                    Specifies an upper limit in bytes on the size of the temporary
                    log files used during <a class="link" href="glossary.html#glos_online_ddl" title="online DDL">online
                    DDL</a> operations for <code class="literal">InnoDB</code> tables.
                    There is one such log file for each index being created or
                    table being altered. This log file stores data inserted,
                    updated, or deleted in the table during the DDL operation. The
                    temporary log file is extended when needed by the value of
                    <a class="link" href="innodb-storage-engine.html#sysvar_innodb_sort_buffer_size"><code class="literal">innodb_sort_buffer_size</code></a>, up
                    to the maximum specified by
                    <code class="literal">innodb_online_alter_log_max_size</code>. If a
                    temporary log file exceeds the upper size limit, the
                    <a class="link" href="sql-syntax.html#alter-table" title="13.1.8&nbsp;ALTER TABLE Syntax"><code class="literal">ALTER TABLE</code></a> operation fails and
                    all uncommitted concurrent DML operations are rolled back.
                    Thus, a large value for this option allows more DML to happen
                    during an online DDL operation, but also extends the period of
                    time at the end of the DDL operation when the table is locked
                    to apply the data from the log.
                </p><p style="color:blue;">指定innodb表联机ddl操作期间使用的临时日志文件大小的字节上限。对于创建的每个索引或更改的表，都有一个这样的日志文件。此日志文件存储DDL操作期间在表中插入、更新或删除的数据。临时日志文件在需要时由UndBySoRtJuffError大小的值扩展，直到由NudidByOnLy.AutoLogLog-Max大小指定的最大值。如果临时日志文件超过了大小上限，则alter table操作将失败，所有未提交的并发dml操作都将回滚。因此，此选项的大值允许在联机ddl操作期间发生更多dml，但也会延长ddl操作结束时锁定表以应用日志中的数据的时间段。</p></li><li class="listitem"><p><a name="sysvar_innodb_open_files"></a>
                <a class="indexterm" name="idm140286810433888"></a>

                <a class="indexterm" name="idm140286810432848"></a>

                <code class="literal">innodb_open_files</code>
            </p><p style="color:blue;">innodb_open_文件</p>
                <div class="informaltable">
                    <table frame="box" rules="all" summary="Properties for innodb_open_files"><colgroup><col width="30%"><col width="70%"></colgroup><thead><tr><th scope="col">Property</th>
                        <th scope="col">Value</th>
                    </tr></thead><tbody><tr><td scope="row"><span class="bold"><strong>Command-Line Format</strong></span></td>
                        <td><code class="literal">--innodb-open-files=#</code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>System Variable</strong></span></td>
                        <td><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_open_files">innodb_open_files</a></code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Scope</strong></span></td>
                        <td>Global</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Dynamic</strong></span></td>
                        <td>No</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Type</strong></span></td>
                        <td>Integer</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Default Value</strong></span></td>
                        <td><code class="literal">-1</code> (signifies autosizing; do not assign this literal value)</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Minimum Value</strong></span></td>
                        <td><code class="literal">10</code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Maximum Value</strong></span></td>
                        <td><code class="literal">4294967295</code></td>
                    </tr></tbody></table>
                </div>
                <p>
                    This variable is only relevant if you use multiple
                    <code class="literal">InnoDB</code>
                    <a class="link" href="glossary.html#glos_tablespace" title="tablespace">tablespaces</a>. It
                    specifies the maximum number of
                    <a class="link" href="glossary.html#glos_ibd_file" title=".ibd file"><code class="filename">.ibd</code>
                        files</a> that MySQL can keep open at one time. The minimum
                    value is 10. The default value is 300 if
                    <a class="link" href="innodb-storage-engine.html#sysvar_innodb_file_per_table"><code class="literal">innodb_file_per_table</code></a> is not
                    enabled, and the higher of 300 and
                    <a class="link" href="server-administration.html#sysvar_table_open_cache"><code class="literal">table_open_cache</code></a> otherwise.
                </p><p style="color:blue;">此变量仅在使用多个innodb表空间时才相关。它指定MySQL一次可以打开的.IBD文件的最大数量。最小值是10。如果innodb_file_per_table未启用，则默认值为300；否则，300和table_open_cache中的较高值。</p><p>
                    The file descriptors used for <code class="filename">.ibd</code> files
                    are for <code class="literal">InnoDB</code> tables only. They are
                    independent of those specified by the
                    <a class="link" href="server-administration.html#sysvar_open_files_limit"><code class="literal">open_files_limit</code></a> system
                    variable, and do not affect the operation of the table cache.
                    For general I/O tuning advice, see
                    <a class="xref" href="optimization.html#optimizing-innodb-diskio" title="8.5.8&nbsp;Optimizing InnoDB Disk I/O">Section&nbsp;8.5.8, “Optimizing InnoDB Disk I/O”</a>.
                </p><p style="color:blue;">用于.ibd文件的文件描述符仅用于innodb表。它们独立于open_files_limit系统变量指定的值，不会影响表缓存的操作。有关一般I/O调整建议，请参阅第8.5.8节“优化InnoDB磁盘I/O”。</p></li><li class="listitem"><p><a name="sysvar_innodb_optimize_fulltext_only"></a>
                <a class="indexterm" name="idm140286810389216"></a>

                <code class="literal">innodb_optimize_fulltext_only</code>
            </p><p style="color:blue;">仅限InnoDB_Optimize_全文</p>
                <div class="informaltable">
                    <table frame="box" rules="all" summary="Properties for innodb_optimize_fulltext_only"><colgroup><col width="30%"><col width="70%"></colgroup><thead><tr><th scope="col">Property</th>
                        <th scope="col">Value</th>
                    </tr></thead><tbody><tr><td scope="row"><span class="bold"><strong>Command-Line Format</strong></span></td>
                        <td><code class="literal">--innodb-optimize-fulltext-only[={OFF|ON}]</code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>System Variable</strong></span></td>
                        <td><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_optimize_fulltext_only">innodb_optimize_fulltext_only</a></code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Scope</strong></span></td>
                        <td>Global</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Dynamic</strong></span></td>
                        <td>Yes</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Type</strong></span></td>
                        <td>Boolean</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Default Value</strong></span></td>
                        <td><code class="literal">OFF</code></td>
                    </tr></tbody></table>
                </div>
                <p>
                    Changes the way <a class="link" href="sql-syntax.html#optimize-table" title="13.7.2.4&nbsp;OPTIMIZE TABLE Syntax"><code class="literal">OPTIMIZE TABLE</code></a>
                    operates on <code class="literal">InnoDB</code> tables. Intended to be
                    enabled temporarily, during maintenance operations for
                    <code class="literal">InnoDB</code> tables with
                    <code class="literal">FULLTEXT</code> indexes.
                </p><p style="color:blue;">更改优化表在innodb表上操作的方式。打算在带有全文索引的innodb表的维护操作期间临时启用。</p><p>
                    By default, <a class="link" href="sql-syntax.html#optimize-table" title="13.7.2.4&nbsp;OPTIMIZE TABLE Syntax"><code class="literal">OPTIMIZE TABLE</code></a>
                    reorganizes data in the
                    <a class="link" href="glossary.html#glos_clustered_index" title="clustered index">clustered index</a> of
                    the table. When this option is enabled,
                    <a class="link" href="sql-syntax.html#optimize-table" title="13.7.2.4&nbsp;OPTIMIZE TABLE Syntax"><code class="literal">OPTIMIZE TABLE</code></a> skips the
                    reorganization of table data, and instead processes newly
                    added, deleted, and updated token data for
                    <code class="literal">InnoDB</code> <code class="literal">FULLTEXT</code> indexes.
                    For more information, see <a class="xref" href="functions.html#fulltext-optimize" title="Optimizing InnoDB Full-Text Indexes">Optimizing InnoDB Full-Text Indexes</a>.
                </p><p style="color:blue;">默认情况下，“优化表”重新组织表的聚集索引中的数据。启用此选项时，optimize table跳过表数据的重组，而是处理innodb全文索引的新添加、删除和更新的令牌数据。有关更多信息，请参阅优化innodb全文索引。</p></li><li class="listitem"><p><a name="sysvar_innodb_optimize_point_storage"></a>
                <a class="indexterm" name="idm140286810352448"></a>

                <a class="indexterm" name="idm140286810351344"></a>

                <code class="literal">innodb_optimize_point_storage</code>
            </p><p style="color:blue;">innodb_optimize_point_存储</p>
                <div class="informaltable">
                    <table frame="box" rules="all" summary="Properties for innodb_optimize_point_storage"><colgroup><col width="30%"><col width="70%"></colgroup><thead><tr><th scope="col">Property</th>
                        <th scope="col">Value</th>
                    </tr></thead><tbody><tr><td scope="row"><span class="bold"><strong>Command-Line Format</strong></span></td>
                        <td><code class="literal">--innodb-optimize-point-storage[={OFF|ON}]</code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Introduced</strong></span></td>
                        <td>5.7.5</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Removed</strong></span></td>
                        <td>5.7.6</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>System Variable</strong></span></td>
                        <td><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_optimize_point_storage">innodb_optimize_point_storage</a></code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Scope</strong></span></td>
                        <td>Session</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Dynamic</strong></span></td>
                        <td>Yes</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Type</strong></span></td>
                        <td>Boolean</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Default Value</strong></span></td>
                        <td><code class="literal">OFF</code></td>
                    </tr></tbody></table>
                </div>
                <p>
                    Enable this variable before creating a column of type
                    <code class="literal">POINT</code> to store the <code class="literal">POINT</code>
                    data type internally as variable-length
                    <code class="literal">BLOB</code> data.
                </p><p style="color:blue;">在创建point类型的列之前启用此变量，以便在内部将point数据类型存储为可变长度blob数据。</p></li><li class="listitem"><p><a name="sysvar_innodb_page_cleaners"></a>
                <a class="indexterm" name="idm140286810316048"></a>

                <code class="literal">innodb_page_cleaners</code>
            </p><p style="color:blue;">Innodb_页面清理程序</p>
                <div class="informaltable">
                    <table frame="box" rules="all" summary="Properties for innodb_page_cleaners"><colgroup><col width="30%"><col width="70%"></colgroup><thead><tr><th scope="col">Property</th>
                        <th scope="col">Value</th>
                    </tr></thead><tbody><tr><td scope="row"><span class="bold"><strong>Command-Line Format</strong></span></td>
                        <td><code class="literal">--innodb-page-cleaners=#</code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Introduced</strong></span></td>
                        <td>5.7.4</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>System Variable</strong></span></td>
                        <td><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_page_cleaners">innodb_page_cleaners</a></code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Scope</strong></span></td>
                        <td>Global</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Dynamic</strong></span></td>
                        <td>No</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Type</strong></span></td>
                        <td>Integer</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Default Value</strong></span> (&gt;= 5.7.8)</td>
                        <td><code class="literal">4</code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Default Value</strong></span> (&lt;= 5.7.7)</td>
                        <td><code class="literal">1</code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Minimum Value</strong></span></td>
                        <td><code class="literal">1</code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Maximum Value</strong></span></td>
                        <td><code class="literal">64</code></td>
                    </tr></tbody></table>
                </div>
                <p>
                    The number of page cleaner threads that flush dirty pages from
                    buffer pool instances. Page cleaner threads perform flush list
                    and LRU flushing. A single page cleaner thread was introduced
                    in MySQL 5.6 to offload buffer pool flushing
                    work from the <code class="literal">InnoDB</code> master thread. In
                    MySQL 5.7, <code class="literal">InnoDB</code> provides
                    support for multiple page cleaner threads. A value of 1
                    maintains the pre-MySQL 5.7 configuration in
                    which there is a single page cleaner thread. When there are
                    multiple page cleaner threads, buffer pool flushing tasks for
                    each buffer pool instance are dispatched to idle page cleaner
                    threads. The <code class="literal">innodb_page_cleaners</code> default
                    value was changed from 1 to 4 in MySQL 5.7. If
                    the number of page cleaner threads exceeds the number of
                    buffer pool instances, <code class="literal">innodb_page_cleaners</code>
                    is automatically set to the same value as
                    <a class="link" href="innodb-storage-engine.html#sysvar_innodb_buffer_pool_instances"><code class="literal">innodb_buffer_pool_instances</code></a>.
                </p><p style="color:blue;">从缓冲池实例刷新脏页的页清理程序线程数。页面清理器线程执行刷新列表和lru刷新。mysql 5.6中引入了一个单页清理线程，用于从innodb主线程中卸载缓冲池刷新工作。在mysql 5.7中，innodb支持多个页面清理线程。值1维护mysql 5.7之前的配置，其中有一个单页清理线程。当存在多个页清除器线程时，每个缓冲池实例的缓冲池刷新任务将被分派到空闲页清除器线程。mysql 5.7中的innodb_page_cleaners默认值从1更改为4。如果页面清理器线程数超过缓冲池实例数，innodb_page_cleaners将自动设置为与innodb_buffer_pool_instances相同的值。</p><p>
                    If your workload is write-IO bound when flushing dirty pages
                    from buffer pool instances to data files, and if your system
                    hardware has available capacity, increasing the number of page
                    cleaner threads may help improve write-IO throughput.
                </p><p style="color:blue;">如果在将脏页从缓冲池实例刷新到数据文件时工作负载是写IO绑定的，并且如果系统硬件具有可用容量，则增加页清除线程的数量可能有助于提高写IO吞吐量。</p><p>
                    Multithreaded page cleaner support is extended to shutdown and
                    recovery phases in MySQL 5.7.
                </p><p style="color:blue;">在mysql 5.7中，多线程页面清理器支持扩展到关闭和恢复阶段。</p><p>
                    The <code class="literal">setpriority()</code> system call is used on
                    Linux platforms where it is supported, and where the
                    <a class="link" href="programs.html#mysqld" title="4.3.1&nbsp;mysqld — The MySQL Server"><span class="command"><strong>mysqld</strong></span></a> execution user is authorized to give
                    <code class="literal">page_cleaner</code> threads priority over other
                    MySQL and <code class="literal">InnoDB</code> threads to help page
                    flushing keep pace with the current workload.
                    <code class="literal">setpriority()</code> support is indicated by this
                    <code class="literal">InnoDB</code> startup message:
                </p><p style="color:blue;">setpriority（）系统调用在Linux平台上使用，在Linux平台上，mysqld执行用户有权将页面清理线程的优先级赋予其他mysql和innodb线程，以帮助页面刷新与当前工作负载保持同步。setpriority（）支持由以下innodb启动消息指示：</p><pre data-lang="terminal" class="programlisting">[Note] InnoDB: If the mysqld execution user is authorized, page cleaner
thread priority can be changed. See the man page of setpriority().
</pre><p>
                    For systems where server startup and shutdown is not managed
                    by systemd, <a class="link" href="programs.html#mysqld" title="4.3.1&nbsp;mysqld — The MySQL Server"><span class="command"><strong>mysqld</strong></span></a> execution user
                    authorization can be configured in
                    <code class="filename">/etc/security/limits.conf</code>. For example,
                    if <a class="link" href="programs.html#mysqld" title="4.3.1&nbsp;mysqld — The MySQL Server"><span class="command"><strong>mysqld</strong></span></a> is run under the
                    <code class="literal">mysql</code> user, you can authorize the
                    <code class="literal">mysql</code> user by adding these lines to
                    <code class="filename">/etc/security/limits.conf</code>:
                </p><p style="color:blue;">对于服务器启动和关闭不受systemd管理的系统，可以在/etc/security/limits.conf中配置mysqld执行用户授权。例如，如果mysqld在mysql用户下运行，则可以通过在/etc/security/limits.conf中添加以下行来授权mysql用户：</p><pre data-lang="ini" class="programlisting">mysql              hard    nice       -20
mysql              soft    nice       -20
</pre><p>
                    For systemd managed systems, the same can be achieved by
                    specifying <code class="literal">LimitNICE=-20</code> in a localized
                    systemd configuration file. For example, create a file named
                    <code class="filename">override.conf</code> in
                    <code class="filename">/etc/systemd/system/mysqld.service.d/override.conf</code>
                    and add this entry:
                </p><p style="color:blue;">对于systemd管理的系统，也可以通过在本地化的systemd配置文件中指定limitnice=-20来实现。例如，在/etc/system d/system/mysqld.service.d/override.conf中创建一个名为override.conf的文件，并添加以下条目：</p><pre data-lang="ini" class="programlisting">[Service]
LimitNICE=-20
</pre><p>
                    After creating or changing <code class="filename">override.conf</code>,
                    reload the systemd configuration, then tell systemd to restart
                    the MySQL service:
                </p><p style="color:blue;">创建或更改override.conf后，重新加载systemd配置，然后告诉systemd重新启动mysql服务：</p><pre data-lang="ini" class="programlisting">systemctl daemon-reload
systemctl restart mysqld  # RPM platforms
systemctl restart mysql   # Debian platforms
</pre><p>
                    For more information about using a localized systemd
                    configuration file, see
                    <a class="xref" href="installing.html#systemd-mysql-configuration" title="Configuring systemd for MySQL">Configuring systemd for MySQL</a>.
                </p><p style="color:blue;">有关使用本地化的systemd配置文件的详细信息，请参阅为mysql配置systemd。</p><p>
                    After authorizing the <a class="link" href="programs.html#mysqld" title="4.3.1&nbsp;mysqld — The MySQL Server"><span class="command"><strong>mysqld</strong></span></a> execution
                    user, use the <span class="command"><strong>cat</strong></span> command to verify the
                    configured <code class="literal">Nice</code> limits for the
                    <a class="link" href="programs.html#mysqld" title="4.3.1&nbsp;mysqld — The MySQL Server"><span class="command"><strong>mysqld</strong></span></a> process:
                </p><p style="color:blue;">授权mysqld执行用户后，使用cat命令验证为mysqld进程配置的nice限制：</p><pre data-lang="terminal" class="programlisting">shell&gt; cat /proc/<em class="replaceable"><code>mysqld_pid</code></em>/limits | grep nice
Max nice priority         18446744073709551596 18446744073709551596
</pre></li><li class="listitem"><p><a name="sysvar_innodb_page_size"></a>
                <a class="indexterm" name="idm140286810243776"></a>

                <code class="literal">innodb_page_size</code>
            </p><p style="color:blue;">innodb_页面大小</p>
                <div class="informaltable">
                    <table frame="box" rules="all" summary="Properties for innodb_page_size"><colgroup><col width="30%"><col width="70%"></colgroup><thead><tr><th scope="col">Property</th>
                        <th scope="col">Value</th>
                    </tr></thead><tbody><tr><td scope="row"><span class="bold"><strong>Command-Line Format</strong></span></td>
                        <td><code class="literal">--innodb-page-size=#</code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>System Variable</strong></span></td>
                        <td><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_page_size">innodb_page_size</a></code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Scope</strong></span></td>
                        <td>Global</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Dynamic</strong></span></td>
                        <td>No</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Type</strong></span></td>
                        <td>Enumeration</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Default Value</strong></span></td>
                        <td><code class="literal">16384</code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Valid Values</strong></span> (&gt;= 5.7.6)</td>
                        <td><p class="valid-value"><code class="literal">4096</code></p><p style="color:blue;">4096个</p><p class="valid-value"><code class="literal">8192</code></p><p style="color:blue;">8192个</p><p class="valid-value"><code class="literal">16384</code></p><p style="color:blue;">一万六千三百八十四</p><p class="valid-value"><code class="literal">32768</code></p><p style="color:blue;">三万二千七百六十八</p><p class="valid-value"><code class="literal">65536</code></p><p style="color:blue;">65536个</p></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Valid Values</strong></span> (&lt;= 5.7.5)</td>
                        <td><p class="valid-value"><code class="literal">4096</code></p><p style="color:blue;">4096个</p><p class="valid-value"><code class="literal">8192</code></p><p style="color:blue;">8192个</p><p class="valid-value"><code class="literal">16384</code></p><p style="color:blue;">一万六千三百八十四</p></td>
                    </tr></tbody></table>
                </div>
                <p>
                    Specifies the <a class="link" href="glossary.html#glos_page_size" title="page size">page size</a>
                    for <code class="literal">InnoDB</code>
                    <a class="link" href="glossary.html#glos_tablespace" title="tablespace">tablespaces</a>. Values can
                    be specified in bytes or kilobytes. For example, a 16 kilobyte
                    page size value can be specified as 16384, 16KB, or 16k.
                </p><p style="color:blue;">指定innodb表空间的页面大小。值可以指定为字节或千字节。例如，16KB的页大小值可以指定为16384、16KB或16K。</p><p>
                    <a class="link" href="innodb-storage-engine.html#sysvar_innodb_page_size"><code class="literal">innodb_page_size</code></a> can only be
                    configured prior to initializing the MySQL instance and cannot
                    be changed afterward. If no value is specified, the instance
                    is initialized using the default page size. See
                    <a class="xref" href="innodb-storage-engine.html#innodb-init-startup-configuration" title="14.8.1&nbsp;InnoDB Startup Configuration">Section&nbsp;14.8.1, “InnoDB Startup Configuration”</a>.
                </p><p style="color:blue;">innodb_page_size只能在初始化mysql实例之前配置，之后不能更改。如果未指定值，则使用默认页大小初始化实例。见14.8.1节，“InnoDB启动配置”。</p><p>
                    Support for 32KB and 64KB page sizes was added in MySQL
                    5.7. For both 32KB and 64KB page sizes, the
                    maximum row length is approximately 16000 bytes.
                    <code class="literal">ROW_FORMAT=COMPRESSED</code> is not supported when
                    <code class="literal">innodb_page_size</code> is set to 32KB or 64KB.
                    For <code class="literal">innodb_page_size=32k</code>, extent size is
                    2MB. For <code class="literal">innodb_page_size=64KB</code>, extent size
                    is 4MB.
                    <a class="link" href="innodb-storage-engine.html#sysvar_innodb_log_buffer_size"><code class="literal">innodb_log_buffer_size</code></a> should
                    be set to at least 16M (the default) when using 32KB or 64KB
                    page sizes.
                </p><p style="color:blue;">mysql 5.7增加了对32kb和64kb页面大小的支持。对于32 KB和64KB页面大小，最大行长度约为16000字节。当innodb_page_size设置为32kb或64kb时，不支持row_format=compressed。对于innodb_page_size=32k，数据块大小为2mb。对于innodb_page_size=64kb，数据块大小为4mb。使用32KB或64KB页面大小时，InnoDB_Log_Buffer_Size应设置为至少16M（默认值）。</p><p>
                    The default 16KB page size or larger is appropriate for a wide
                    range of <a class="link" href="glossary.html#glos_workload" title="workload">workloads</a>,
                    particularly for queries involving table scans and DML
                    operations involving bulk updates. Smaller page sizes might be
                    more efficient for <a class="link" href="glossary.html#glos_oltp" title="OLTP">OLTP</a>
                    workloads involving many small writes, where contention can be
                    an issue when single pages contain many rows. Smaller pages
                    might also be efficient with
                    <a class="link" href="glossary.html#glos_ssd" title="SSD">SSD</a> storage devices, which
                    typically use small block sizes. Keeping the
                    <code class="literal">InnoDB</code> page size close to the storage
                    device block size minimizes the amount of unchanged data that
                    is rewritten to disk.
                </p><p style="color:blue;">默认的16KB或更大的页面大小适用于各种工作负载，特别是涉及表扫描和涉及批量更新的DML操作的查询。对于涉及许多小写操作的oltp工作负载，较小的页面大小可能更有效，在这些工作负载中，当单个页面包含许多行时，争用可能是一个问题。使用ssd存储设备（通常使用较小的块大小）时，较小的页面可能也很有效。将innodb页面大小保持在接近存储设备块大小的位置，可以最大限度地减少重写到磁盘的未更改数据量。</p><p>
                    The minimum file size for the first system tablespace data
                    file (<code class="literal">ibdata1</code>) differs depending on the
                    <a class="link" href="innodb-storage-engine.html#sysvar_innodb_page_size"><code class="literal">innodb_page_size</code></a> value. See
                    the <a class="link" href="innodb-storage-engine.html#sysvar_innodb_data_file_path"><code class="literal">innodb_data_file_path</code></a>
                    option description for more information.
                </p><p style="color:blue;">第一个系统表空间数据文件（ibdata1）的最小文件大小取决于innodb_page_size值。有关更多信息，请参阅innodb_data_file_path选项描述。</p><p>
                    For general I/O tuning advice, see
                    <a class="xref" href="optimization.html#optimizing-innodb-diskio" title="8.5.8&nbsp;Optimizing InnoDB Disk I/O">Section&nbsp;8.5.8, “Optimizing InnoDB Disk I/O”</a>.
                </p><p style="color:blue;">有关一般I/O调整建议，请参阅第8.5.8节“优化InnoDB磁盘I/O”。</p></li><li class="listitem"><p><a name="sysvar_innodb_print_all_deadlocks"></a>
                <a class="indexterm" name="idm140286810184400"></a>

                <a class="indexterm" name="idm140286810183296"></a>

                <code class="literal">innodb_print_all_deadlocks</code>
            </p><p style="color:blue;">innodb_print_all_死锁</p>
                <div class="informaltable">
                    <table frame="box" rules="all" summary="Properties for innodb_print_all_deadlocks"><colgroup><col width="30%"><col width="70%"></colgroup><thead><tr><th scope="col">Property</th>
                        <th scope="col">Value</th>
                    </tr></thead><tbody><tr><td scope="row"><span class="bold"><strong>Command-Line Format</strong></span></td>
                        <td><code class="literal">--innodb-print-all-deadlocks[={OFF|ON}]</code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>System Variable</strong></span></td>
                        <td><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_print_all_deadlocks">innodb_print_all_deadlocks</a></code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Scope</strong></span></td>
                        <td>Global</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Dynamic</strong></span></td>
                        <td>Yes</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Type</strong></span></td>
                        <td>Boolean</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Default Value</strong></span></td>
                        <td><code class="literal">OFF</code></td>
                    </tr></tbody></table>
                </div>
                <a class="indexterm" name="idm140286810157200"></a><p>
                    When this option is enabled, information about all
                    <a class="link" href="glossary.html#glos_deadlock" title="deadlock">deadlocks</a> in
                    <code class="literal">InnoDB</code> user transactions is recorded in the
                    <code class="literal">mysqld</code> <a class="link" href="server-administration.html#error-log" title="5.4.2&nbsp;The Error Log">error
                    log</a>. Otherwise, you see information about only the last
                    deadlock, using the <code class="literal">SHOW ENGINE INNODB
                    STATUS</code> command. An occasional
                    <code class="literal">InnoDB</code> deadlock is not necessarily an
                    issue, because <code class="literal">InnoDB</code> detects the condition
                    immediately and rolls back one of the transactions
                    automatically. You might use this option to troubleshoot why
                    deadlocks are occurring if an application does not have
                    appropriate error-handling logic to detect the rollback and
                    retry its operation. A large number of deadlocks might
                    indicate the need to restructure transactions that issue
                    <a class="link" href="glossary.html#glos_dml" title="DML">DML</a> or <code class="literal">SELECT ... FOR
                    UPDATE</code> statements for multiple tables, so that each
                    transaction accesses the tables in the same order, thus
                    avoiding the deadlock condition.
                </p><p style="color:blue;">启用此选项后，有关innodb用户事务中所有死锁的信息将记录在mysqld错误日志中。否则，您将使用show engine innodb status命令仅查看有关最后一个死锁的信息。偶尔的innodb死锁不一定是问题，因为innodb会立即检测到该情况并自动回滚其中一个事务。如果应用程序没有适当的错误处理逻辑来检测回滚并重试其操作，则可以使用此选项排除死锁发生的原因。大量死锁可能表明需要重新构造发出DML或选择…对于多个表的update语句，使每个事务以相同的顺序访问表，从而避免死锁情况。</p><p>
                    For related information, see
                    <a class="xref" href="innodb-storage-engine.html#innodb-deadlocks" title="14.7.5&nbsp;Deadlocks in InnoDB">Section&nbsp;14.7.5, “Deadlocks in InnoDB”</a>.
                </p><p style="color:blue;">有关信息，请参阅第14.7.5节“InnoDB中的死锁”。</p></li><li class="listitem"><p><a name="sysvar_innodb_purge_batch_size"></a>
                <a class="indexterm" name="idm140286810145872"></a>

                <a class="indexterm" name="idm140286810144832"></a>

                <code class="literal">innodb_purge_batch_size</code>
            </p><p style="color:blue;">InnoDB_Purge_批量大小</p>
                <div class="informaltable">
                    <table frame="box" rules="all" summary="Properties for innodb_purge_batch_size"><colgroup><col width="30%"><col width="70%"></colgroup><thead><tr><th scope="col">Property</th>
                        <th scope="col">Value</th>
                    </tr></thead><tbody><tr><td scope="row"><span class="bold"><strong>Command-Line Format</strong></span></td>
                        <td><code class="literal">--innodb-purge-batch-size=#</code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>System Variable</strong></span></td>
                        <td><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_purge_batch_size">innodb_purge_batch_size</a></code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Scope</strong></span></td>
                        <td>Global</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Dynamic</strong></span></td>
                        <td>Yes</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Type</strong></span></td>
                        <td>Integer</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Default Value</strong></span></td>
                        <td><code class="literal">300</code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Minimum Value</strong></span></td>
                        <td><code class="literal">1</code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Maximum Value</strong></span></td>
                        <td><code class="literal">5000</code></td>
                    </tr></tbody></table>
                </div>
                <p>
                    Defines the number of undo log pages that purge parses and
                    processes in one batch from the
                    <a class="link" href="glossary.html#glos_history_list" title="history list">history list</a>. In a
                    multithreaded purge configuration, the coordinator purge
                    thread divides <code class="literal">innodb_purge_batch_size</code> by
                    <a class="link" href="innodb-storage-engine.html#sysvar_innodb_purge_threads"><code class="literal">innodb_purge_threads</code></a> and
                    assigns that number of pages to each purge thread. The
                    <code class="literal">innodb_purge_batch_size</code> variable also
                    defines the number of undo log pages that purge frees after
                    every 128 iterations through the undo logs.
                </p><p style="color:blue;">定义从历史记录列表中一批清除分析和处理的撤消日志页数。在多线程清除配置中，协调器清除线程将innodb_purge_batch_size除以innodb_purge_threads，并将该页数分配给每个清除线程。innodb_purge_batch_size变量还定义了通过撤消日志每128次迭代后清除空闲的撤消日志页数。</p><p>
                    The <code class="literal">innodb_purge_batch_size</code> option is
                    intended for advanced performance tuning in combination with
                    the <a class="link" href="innodb-storage-engine.html#sysvar_innodb_purge_threads"><code class="literal">innodb_purge_threads</code></a>
                    setting. Most users need not change
                    <code class="literal">innodb_purge_batch_size</code> from its default
                    value.
                </p><p style="color:blue;">innodb_purge_batch_size选项用于结合innodb_purge_threads设置进行高级性能调整。大多数用户不需要更改innodb_purge_batch_的默认值。</p><p>
                    For related information, see
                    <a class="xref" href="innodb-storage-engine.html#innodb-purge-configuration" title="14.8.10&nbsp;Purge Configuration">Section&nbsp;14.8.10, “Purge Configuration”</a>.
                </p><p style="color:blue;">有关信息，请参见第14.8.10节“吹扫配置”。</p></li><li class="listitem"><p><a name="sysvar_innodb_purge_threads"></a>
                <a class="indexterm" name="idm140286810102592"></a>

                <a class="indexterm" name="idm140286810101552"></a>

                <code class="literal">innodb_purge_threads</code>
            </p><p style="color:blue;">innodb_purge_线程</p>
                <div class="informaltable">
                    <table frame="box" rules="all" summary="Properties for innodb_purge_threads"><colgroup><col width="30%"><col width="70%"></colgroup><thead><tr><th scope="col">Property</th>
                        <th scope="col">Value</th>
                    </tr></thead><tbody><tr><td scope="row"><span class="bold"><strong>Command-Line Format</strong></span></td>
                        <td><code class="literal">--innodb-purge-threads=#</code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>System Variable</strong></span></td>
                        <td><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_purge_threads">innodb_purge_threads</a></code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Scope</strong></span></td>
                        <td>Global</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Dynamic</strong></span></td>
                        <td>No</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Type</strong></span></td>
                        <td>Integer</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Default Value</strong></span> (&gt;= 5.7.8)</td>
                        <td><code class="literal">4</code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Default Value</strong></span> (&lt;= 5.7.7)</td>
                        <td><code class="literal">1</code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Minimum Value</strong></span></td>
                        <td><code class="literal">1</code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Maximum Value</strong></span></td>
                        <td><code class="literal">32</code></td>
                    </tr></tbody></table>
                </div>
                <p>
                    The number of background threads devoted to the
                    <code class="literal">InnoDB</code>
                    <a class="link" href="glossary.html#glos_purge" title="purge">purge</a> operation. The default
                    value is 1. Increasing the value creates additional purge
                    threads, which can improve efficiency on systems where
                    <a class="link" href="glossary.html#glos_dml" title="DML">DML</a> operations are performed
                    on multiple tables. The maximum is 32.
                </p><p style="color:blue;">用于innodb清除操作的后台线程数。默认值为1。增加该值将创建额外的清除线程，这可以提高在多个表上执行dml操作的系统上的效率。最大值为32。</p><p>
                    For related information, see
                    <a class="xref" href="innodb-storage-engine.html#innodb-purge-configuration" title="14.8.10&nbsp;Purge Configuration">Section&nbsp;14.8.10, “Purge Configuration”</a>.
                </p><p style="color:blue;">有关信息，请参见第14.8.10节“吹扫配置”。</p></li><li class="listitem"><p><a name="sysvar_innodb_purge_rseg_truncate_frequency"></a>
                <a class="indexterm" name="idm140286810060592"></a>

                <a class="indexterm" name="idm140286810059552"></a>

                <code class="literal">innodb_purge_rseg_truncate_frequency</code>
            </p><p style="color:blue;">innodb_purge_rseg_truncate_频率</p>
                <div class="informaltable">
                    <table frame="box" rules="all" summary="Properties for innodb_purge_rseg_truncate_frequency"><colgroup><col width="30%"><col width="70%"></colgroup><thead><tr><th scope="col">Property</th>
                        <th scope="col">Value</th>
                    </tr></thead><tbody><tr><td scope="row"><span class="bold"><strong>Command-Line Format</strong></span></td>
                        <td><code class="literal">--innodb-purge-rseg-truncate-frequency=#</code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Introduced</strong></span></td>
                        <td>5.7.5</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>System Variable</strong></span></td>
                        <td><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_purge_rseg_truncate_frequency">innodb_purge_rseg_truncate_frequency</a></code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Scope</strong></span></td>
                        <td>Global</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Dynamic</strong></span></td>
                        <td>Yes</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Type</strong></span></td>
                        <td>Integer</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Default Value</strong></span></td>
                        <td><code class="literal">128</code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Minimum Value</strong></span></td>
                        <td><code class="literal">1</code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Maximum Value</strong></span></td>
                        <td><code class="literal">128</code></td>
                    </tr></tbody></table>
                </div>
                <p>
                    Defines the frequency with which the purge system frees
                    rollback segments in terms of the number of times that purge
                    is invoked. An undo tablespace cannot be truncated until its
                    rollback segments are freed. Normally, the purge system frees
                    rollback segments once every 128 times that purge is invoked.
                    The default value is 128. Reducing this value increases the
                    frequency with which the purge thread frees rollback segments.
                </p><p style="color:blue;">根据调用清除的次数定义清除系统释放回滚段的频率。在释放撤消表空间的回滚段之前，不能截断撤消表空间。通常，清除系统每调用清除128次释放回滚段一次。默认值为128。减小此值会增加清除线程释放回滚段的频率。</p><p>
                    <code class="literal">innodb_purge_rseg_truncate_frequency</code> is
                    intended for use with
                    <a class="link" href="innodb-storage-engine.html#sysvar_innodb_undo_log_truncate"><code class="literal">innodb_undo_log_truncate</code></a>. For
                    more information, see
                    <a class="xref" href="innodb-storage-engine.html#truncate-undo-tablespace" title="Truncating Undo Tablespaces">Truncating Undo Tablespaces</a>.
                </p><p style="color:blue;">innodb_purge_rseg_truncate_frequency用于innodb_undo_log_truncate。有关详细信息，请参见截断撤消表空间。</p></li><li class="listitem"><p><a name="sysvar_innodb_random_read_ahead"></a>
                <a class="indexterm" name="idm140286810019408"></a>

                <code class="literal">innodb_random_read_ahead</code>
            </p><p style="color:blue;">innodb_random_read_ahead_前方</p>
                <div class="informaltable">
                    <table frame="box" rules="all" summary="Properties for innodb_random_read_ahead"><colgroup><col width="30%"><col width="70%"></colgroup><thead><tr><th scope="col">Property</th>
                        <th scope="col">Value</th>
                    </tr></thead><tbody><tr><td scope="row"><span class="bold"><strong>Command-Line Format</strong></span></td>
                        <td><code class="literal">--innodb-random-read-ahead[={OFF|ON}]</code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>System Variable</strong></span></td>
                        <td><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_random_read_ahead">innodb_random_read_ahead</a></code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Scope</strong></span></td>
                        <td>Global</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Dynamic</strong></span></td>
                        <td>Yes</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Type</strong></span></td>
                        <td>Boolean</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Default Value</strong></span></td>
                        <td><code class="literal">OFF</code></td>
                    </tr></tbody></table>
                </div>
                <p>
                    Enables the random
                    <a class="link" href="glossary.html#glos_read_ahead" title="read-ahead">read-ahead</a> technique
                    for optimizing <code class="literal">InnoDB</code> I/O.
                </p><p style="color:blue;">启用随机预读技术以优化InnoDB I/O。</p><p>
                    For details about performance considerations for different
                    types of read-ahead requests, see
                    <a class="xref" href="innodb-storage-engine.html#innodb-performance-read_ahead" title="14.8.3.4&nbsp;Configuring InnoDB Buffer Pool Prefetching (Read-Ahead)">Section&nbsp;14.8.3.4, “Configuring InnoDB Buffer Pool Prefetching (Read-Ahead)”</a>. For general
                    I/O tuning advice, see
                    <a class="xref" href="optimization.html#optimizing-innodb-diskio" title="8.5.8&nbsp;Optimizing InnoDB Disk I/O">Section&nbsp;8.5.8, “Optimizing InnoDB Disk I/O”</a>.
                </p><p style="color:blue;">有关不同类型预读请求的性能考虑的详细信息，请参阅14.8.3.4节，“配置InnoDB缓冲池预取（预读）”。有关一般I/O调整建议，请参阅第8.5.8节“优化InnoDB磁盘I/O”。</p></li><li class="listitem"><p><a name="sysvar_innodb_read_ahead_threshold"></a>
                <a class="indexterm" name="idm140286809988608"></a>

                <a class="indexterm" name="idm140286809987504"></a>

                <code class="literal">innodb_read_ahead_threshold</code>
            </p><p style="color:blue;">innodb_read_ahead_阈值</p>
                <div class="informaltable">
                    <table frame="box" rules="all" summary="Properties for innodb_read_ahead_threshold"><colgroup><col width="30%"><col width="70%"></colgroup><thead><tr><th scope="col">Property</th>
                        <th scope="col">Value</th>
                    </tr></thead><tbody><tr><td scope="row"><span class="bold"><strong>Command-Line Format</strong></span></td>
                        <td><code class="literal">--innodb-read-ahead-threshold=#</code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>System Variable</strong></span></td>
                        <td><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_read_ahead_threshold">innodb_read_ahead_threshold</a></code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Scope</strong></span></td>
                        <td>Global</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Dynamic</strong></span></td>
                        <td>Yes</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Type</strong></span></td>
                        <td>Integer</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Default Value</strong></span></td>
                        <td><code class="literal">56</code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Minimum Value</strong></span></td>
                        <td><code class="literal">0</code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Maximum Value</strong></span></td>
                        <td><code class="literal">64</code></td>
                    </tr></tbody></table>
                </div>
                <p>
                    Controls the sensitivity of linear
                    <a class="link" href="glossary.html#glos_read_ahead" title="read-ahead">read-ahead</a> that
                    <code class="literal">InnoDB</code> uses to prefetch pages into the
                    <a class="link" href="glossary.html#glos_buffer_pool" title="buffer pool">buffer pool</a>. If
                    <code class="literal">InnoDB</code> reads at least
                    <code class="literal">innodb_read_ahead_threshold</code> pages
                    sequentially from an <a class="link" href="glossary.html#glos_extent" title="extent">extent</a>
                    (64 pages), it initiates an asynchronous read for the entire
                    following extent. The permissible range of values is 0 to 64.
                    A value of 0 disables read-ahead. For the default of 56,
                    <code class="literal">InnoDB</code> must read at least 56 pages
                    sequentially from an extent to initiate an asynchronous read
                    for the following extent.
                </p><p style="color:blue;">控制innodb用于将页面预取到缓冲池的线性预读的灵敏度。如果innodb从一个区段（64页）顺序读取至少innodb_read_ahead_threshold pages，那么它将为下面的整个区段启动异步读取。允许的值范围是0到64。值为0将禁用预读。对于默认值56，innodb必须从一个区段按顺序读取至少56页，才能为以下区段启动异步读取。</p><p>
                    Knowing how many pages are read through the read-ahead
                    mechanism, and how many of these pages are evicted from the
                    buffer pool without ever being accessed, can be useful when
                    fine-tuning the
                    <a class="link" href="innodb-storage-engine.html#sysvar_innodb_read_ahead_threshold"><code class="literal">innodb_read_ahead_threshold</code></a>
                    setting. <a class="link" href="sql-syntax.html#show-engine" title="13.7.5.15&nbsp;SHOW ENGINE Syntax"><code class="literal">SHOW
                    ENGINE INNODB STATUS</code></a> output displays counter
                    information from the
                    <a class="link" href="server-administration.html#statvar_Innodb_buffer_pool_read_ahead"><code class="literal">Innodb_buffer_pool_read_ahead</code></a>
                    and
                    <a class="link" href="server-administration.html#statvar_Innodb_buffer_pool_read_ahead_evicted"><code class="literal">Innodb_buffer_pool_read_ahead_evicted</code></a>
                    global status variables, which report the number of pages
                    brought into the <a class="link" href="glossary.html#glos_buffer_pool" title="buffer pool">buffer
                    pool</a> by read-ahead requests, and the number of such
                    pages <a class="link" href="glossary.html#glos_eviction" title="eviction">evicted</a> from the
                    buffer pool without ever being accessed, respectively. The
                    status variables report global values since the last server
                    restart.
                </p><p style="color:blue;">在微调innodb-read-ahead-threshold设置时，了解通过预读机制读取了多少页，以及这些页中有多少页在从未被访问的情况下从缓冲池中逐出，这将非常有用。show engine innodb status output显示来自innodb_buffer_pool_read_ahead和innodb_buffer_read_ahead的全局状态变量的计数器信息，这些变量报告通过预读请求进入缓冲池的页数，以及从未被访问而从缓冲池中退出的页数，分别是。状态变量报告自上次服务器重新启动以来的全局值。</p><p>
                    <a class="link" href="sql-syntax.html#show-engine" title="13.7.5.15&nbsp;SHOW ENGINE Syntax"><code class="literal">SHOW ENGINE
                        INNODB STATUS</code></a> also shows the rate at which the
                    read-ahead pages are read and the rate at which such pages are
                    evicted without being accessed. The per-second averages are
                    based on the statistics collected since the last invocation of
                    <code class="literal">SHOW ENGINE INNODB STATUS</code> and are displayed
                    in the <code class="literal">BUFFER POOL AND MEMORY</code> section of
                    the <a class="link" href="sql-syntax.html#show-engine" title="13.7.5.15&nbsp;SHOW ENGINE Syntax"><code class="literal">SHOW ENGINE
                    INNODB STATUS</code></a> output.
                </p><p style="color:blue;">show engine innodb status还显示读取预读页的速率，以及在未被访问的情况下收回此类页的速率。每秒的平均值基于自上次调用show engine innodb status以来收集的统计数据，并显示在show engine innodb status输出的缓冲池和内存部分。</p><p>
                    For more information, see
                    <a class="xref" href="innodb-storage-engine.html#innodb-performance-read_ahead" title="14.8.3.4&nbsp;Configuring InnoDB Buffer Pool Prefetching (Read-Ahead)">Section&nbsp;14.8.3.4, “Configuring InnoDB Buffer Pool Prefetching (Read-Ahead)”</a>. For general
                    I/O tuning advice, see
                    <a class="xref" href="optimization.html#optimizing-innodb-diskio" title="8.5.8&nbsp;Optimizing InnoDB Disk I/O">Section&nbsp;8.5.8, “Optimizing InnoDB Disk I/O”</a>.
                </p><p style="color:blue;">有关更多信息，请参阅14.8.3.4节，“配置InnoDB缓冲池预取（预读）”。有关一般I/O调整建议，请参阅第8.5.8节“优化InnoDB磁盘I/O”。</p></li><li class="listitem"><p><a name="sysvar_innodb_read_io_threads"></a>
                <a class="indexterm" name="idm140286809933584"></a>

                <a class="indexterm" name="idm140286809932544"></a>

                <code class="literal">innodb_read_io_threads</code>
            </p><p style="color:blue;">innodb_read_io_线程</p>
                <div class="informaltable">
                    <table frame="box" rules="all" summary="Properties for innodb_read_io_threads"><colgroup><col width="30%"><col width="70%"></colgroup><thead><tr><th scope="col">Property</th>
                        <th scope="col">Value</th>
                    </tr></thead><tbody><tr><td scope="row"><span class="bold"><strong>Command-Line Format</strong></span></td>
                        <td><code class="literal">--innodb-read-io-threads=#</code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>System Variable</strong></span></td>
                        <td><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_read_io_threads">innodb_read_io_threads</a></code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Scope</strong></span></td>
                        <td>Global</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Dynamic</strong></span></td>
                        <td>No</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Type</strong></span></td>
                        <td>Integer</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Default Value</strong></span></td>
                        <td><code class="literal">4</code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Minimum Value</strong></span></td>
                        <td><code class="literal">1</code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Maximum Value</strong></span></td>
                        <td><code class="literal">64</code></td>
                    </tr></tbody></table>
                </div>
                <p>
                    The number of I/O threads for read operations in
                    <code class="literal">InnoDB</code>. Its counterpart for write threads
                    is <a class="link" href="innodb-storage-engine.html#sysvar_innodb_write_io_threads"><code class="literal">innodb_write_io_threads</code></a>.
                    For more information, see
                    <a class="xref" href="innodb-storage-engine.html#innodb-performance-multiple_io_threads" title="14.8.6&nbsp;Configuring the Number of Background InnoDB I/O Threads">Section&nbsp;14.8.6, “Configuring the Number of Background InnoDB I/O Threads”</a>. For
                    general I/O tuning advice, see
                    <a class="xref" href="optimization.html#optimizing-innodb-diskio" title="8.5.8&nbsp;Optimizing InnoDB Disk I/O">Section&nbsp;8.5.8, “Optimizing InnoDB Disk I/O”</a>.
                </p><p style="color:blue;">InnoDB中用于读取操作的I/O线程数。其对应的写线程是innodb_write_io_threads。有关更多信息，请参阅14.8.6节，“配置后台InnoDB I/O线程数”。有关一般I/O调整建议，请参阅第8.5.8节“优化InnoDB磁盘I/O”。</p>
                <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">

                    <div class="admon-title">
                        Note
                    </div>
                    <p>
                        On Linux systems, running multiple MySQL servers (typically
                        more than 12) with default settings for
                        <code class="literal">innodb_read_io_threads</code>,
                        <a class="link" href="innodb-storage-engine.html#sysvar_innodb_write_io_threads"><code class="literal">innodb_write_io_threads</code></a>,
                        and the Linux <code class="literal">aio-max-nr</code> setting can
                        exceed system limits. Ideally, increase the
                        <code class="literal">aio-max-nr</code> setting; as a workaround, you
                        might reduce the settings for one or both of the MySQL
                        variables.
                    </p><p style="color:blue;">在linux系统上，运行多个mysql服务器（通常超过12个），默认设置为innodb_read_io_线程、innodb_write_io_线程，并且linux aio max nr设置可以超过系统限制。理想情况下，增加aio max nr设置；作为解决方法，可以减少一个或两个mysql变量的设置。</p>
                </div>
            </li><li class="listitem"><p><a name="sysvar_innodb_read_only"></a>
                <a class="indexterm" name="idm140286809890768"></a>

                <code class="literal">innodb_read_only</code>
            </p><p style="color:blue;">InnoDB_只读</p>
                <div class="informaltable">
                    <table frame="box" rules="all" summary="Properties for innodb_read_only"><colgroup><col width="30%"><col width="70%"></colgroup><thead><tr><th scope="col">Property</th>
                        <th scope="col">Value</th>
                    </tr></thead><tbody><tr><td scope="row"><span class="bold"><strong>Command-Line Format</strong></span></td>
                        <td><code class="literal">--innodb-read-only[={OFF|ON}]</code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>System Variable</strong></span></td>
                        <td><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_read_only">innodb_read_only</a></code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Scope</strong></span></td>
                        <td>Global</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Dynamic</strong></span></td>
                        <td>No</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Type</strong></span></td>
                        <td>Boolean</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Default Value</strong></span></td>
                        <td><code class="literal">OFF</code></td>
                    </tr></tbody></table>
                </div>
                <p>
                    Starts <code class="literal">InnoDB</code> in read-only mode. For
                    distributing database applications or data sets on read-only
                    media. Can also be used in data warehouses to share the same
                    data directory between multiple instances. For more
                    information, see <a class="xref" href="innodb-storage-engine.html#innodb-read-only-instance" title="14.8.2&nbsp;Configuring InnoDB for Read-Only Operation">Section&nbsp;14.8.2, “Configuring InnoDB for Read-Only Operation”</a>.
                </p><p style="color:blue;">以只读模式启动InnoDB。用于在只读媒体上分发数据库应用程序或数据集。也可以在数据仓库中用于在多个实例之间共享同一数据目录。有关更多信息，请参阅14.8.2节，“为只读操作配置InnoDB”。</p></li><li class="listitem"><p><a name="sysvar_innodb_replication_delay"></a>
                <a class="indexterm" name="idm140286809861824"></a>

                <a class="indexterm" name="idm140286809860720"></a>

                <code class="literal">innodb_replication_delay</code>
            </p><p style="color:blue;">InnoDB_复制延迟</p>
                <div class="informaltable">
                    <table frame="box" rules="all" summary="Properties for innodb_replication_delay"><colgroup><col width="30%"><col width="70%"></colgroup><thead><tr><th scope="col">Property</th>
                        <th scope="col">Value</th>
                    </tr></thead><tbody><tr><td scope="row"><span class="bold"><strong>Command-Line Format</strong></span></td>
                        <td><code class="literal">--innodb-replication-delay=#</code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>System Variable</strong></span></td>
                        <td><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_replication_delay">innodb_replication_delay</a></code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Scope</strong></span></td>
                        <td>Global</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Dynamic</strong></span></td>
                        <td>Yes</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Type</strong></span></td>
                        <td>Integer</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Default Value</strong></span></td>
                        <td><code class="literal">0</code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Minimum Value</strong></span></td>
                        <td><code class="literal">0</code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Maximum Value</strong></span></td>
                        <td><code class="literal">4294967295</code></td>
                    </tr></tbody></table>
                </div>
                <p>
                    The replication thread delay in milliseconds on a slave server
                    if <a class="link" href="innodb-storage-engine.html#sysvar_innodb_thread_concurrency"><code class="literal">innodb_thread_concurrency</code></a>
                    is reached.
                </p><p style="color:blue;">如果达到innodb_thread_并发，则从服务器上的复制线程延迟（毫秒）。</p></li><li class="listitem"><p><a name="sysvar_innodb_rollback_on_timeout"></a>
                <a class="indexterm" name="idm140286809825664"></a>

                <a class="indexterm" name="idm140286809824560"></a>

                <code class="literal">innodb_rollback_on_timeout</code>
            </p><p style="color:blue;">innodb_rollback_on_超时</p>
                <div class="informaltable">
                    <table frame="box" rules="all" summary="Properties for innodb_rollback_on_timeout"><colgroup><col width="30%"><col width="70%"></colgroup><thead><tr><th scope="col">Property</th>
                        <th scope="col">Value</th>
                    </tr></thead><tbody><tr><td scope="row"><span class="bold"><strong>Command-Line Format</strong></span></td>
                        <td><code class="literal">--innodb-rollback-on-timeout[={OFF|ON}]</code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>System Variable</strong></span></td>
                        <td><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_rollback_on_timeout">innodb_rollback_on_timeout</a></code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Scope</strong></span></td>
                        <td>Global</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Dynamic</strong></span></td>
                        <td>No</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Type</strong></span></td>
                        <td>Boolean</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Default Value</strong></span></td>
                        <td><code class="literal">OFF</code></td>
                    </tr></tbody></table>
                </div>
                <p>
                    <code class="literal">InnoDB</code> <a class="link" href="glossary.html#glos_rollback" title="rollback">rolls
                    back</a> only the last statement on a transaction timeout
                    by default. If
                    <a class="link" href="innodb-storage-engine.html#sysvar_innodb_rollback_on_timeout"><code class="option">--innodb-rollback-on-timeout</code></a> is
                    specified, a transaction timeout causes
                    <code class="literal">InnoDB</code> to abort and roll back the entire
                    transaction.
                </p><p style="color:blue;">默认情况下，innodb只回滚事务超时的最后一条语句。如果指定了--innodb roll back on timeout，事务超时将导致innodb中止并回滚整个事务。</p>
                <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">

                    <div class="admon-title">
                        Note
                    </div>
                    <p>
                        If the start-transaction statement was
                        <a class="link" href="sql-syntax.html#commit" title="13.3.1&nbsp;START TRANSACTION, COMMIT, and ROLLBACK Syntax"><code class="literal">START
                            TRANSACTION</code></a> or
                        <a class="link" href="sql-syntax.html#commit" title="13.3.1&nbsp;START TRANSACTION, COMMIT, and ROLLBACK Syntax"><code class="literal">BEGIN</code></a>
                        statement, rollback does not cancel that statement. Further
                        SQL statements become part of the transaction until the
                        occurrence of <a class="link" href="sql-syntax.html#commit" title="13.3.1&nbsp;START TRANSACTION, COMMIT, and ROLLBACK Syntax"><code class="literal">COMMIT</code></a>,
                        <a class="link" href="sql-syntax.html#commit" title="13.3.1&nbsp;START TRANSACTION, COMMIT, and ROLLBACK Syntax"><code class="literal">ROLLBACK</code></a>,
                        or some SQL statement that causes an implicit commit.
                    </p><p style="color:blue;">如果start transaction语句是start transaction或begin语句，则rollback不会取消该语句。在commit、rollback或导致隐式提交的某些sql语句出现之前，其他sql语句将成为事务的一部分。</p>
                </div>
                <p>
                    For more information, see
                    <a class="xref" href="innodb-storage-engine.html#innodb-error-handling" title="14.21.4&nbsp;InnoDB Error Handling">Section&nbsp;14.21.4, “InnoDB Error Handling”</a>.
                </p><p style="color:blue;">有关更多信息，请参阅14.21.4节，“InnoDB错误处理”。</p></li><li class="listitem"><p><a name="sysvar_innodb_rollback_segments"></a>
                <a class="indexterm" name="idm140286809786432"></a>

                <code class="literal">innodb_rollback_segments</code>
            </p><p style="color:blue;">innodb_rollback_段</p>
                <div class="informaltable">
                    <table frame="box" rules="all" summary="Properties for innodb_rollback_segments"><colgroup><col width="30%"><col width="70%"></colgroup><thead><tr><th scope="col">Property</th>
                        <th scope="col">Value</th>
                    </tr></thead><tbody><tr><td scope="row"><span class="bold"><strong>Command-Line Format</strong></span></td>
                        <td><code class="literal">--innodb-rollback-segments=#</code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>System Variable</strong></span></td>
                        <td><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_rollback_segments">innodb_rollback_segments</a></code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Scope</strong></span></td>
                        <td>Global</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Dynamic</strong></span></td>
                        <td>Yes</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Type</strong></span></td>
                        <td>Integer</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Default Value</strong></span></td>
                        <td><code class="literal">128</code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Minimum Value</strong></span></td>
                        <td><code class="literal">1</code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Maximum Value</strong></span></td>
                        <td><code class="literal">128</code></td>
                    </tr></tbody></table>
                </div>
                <p>
                    Defines the number of
                    <a class="link" href="glossary.html#glos_rollback_segment" title="rollback segment">rollback segments</a>
                    used by <code class="literal">InnoDB</code> for transactions that
                    generate undo records. The number of transactions that each
                    rollback segment supports depends on the
                    <code class="literal">InnoDB</code> page size and the number of undo
                    logs assigned to each transaction. For more information, see
                    <a class="xref" href="innodb-storage-engine.html#innodb-undo-logs" title="14.6.7&nbsp;Undo Logs">Section&nbsp;14.6.7, “Undo Logs”</a>.
                </p><p style="color:blue;">定义innodb用于生成撤消记录的事务的回滚段数。每个回滚段支持的事务数取决于innodb页面大小和分配给每个事务的撤消日志数。有关更多信息，请参见第14.6.7节“撤消日志”。</p><p>
                    One rollback segment is always assigned to the system
                    tablespace, and 32 rollback segments are reserved for use by
                    temporary tables and reside in the temporary tablespace
                    (<code class="filename">ibtmp1</code>). To allocate additional rollback
                    segment,
                    <a class="link" href="innodb-storage-engine.html#sysvar_innodb_rollback_segments"><code class="literal">innodb_rollback_segments</code></a> must
                    be set to a value greater than 33. If you configure separate
                    undo tablespaces, the rollback segment in the system
                    tablespace is rendered inactive.
                </p><p style="color:blue;">一个回滚段始终分配给系统表空间，32个回滚段保留给临时表使用，并驻留在临时表空间（ibtmp1）中。要分配额外的回滚段，innodb_rollback_segments必须设置为大于33的值。如果配置单独的撤消表空间，则系统表空间中的回滚段将呈现为非活动状态。</p><p>
                    When <a class="link" href="innodb-storage-engine.html#sysvar_innodb_rollback_segments"><code class="literal">innodb_rollback_segments</code></a>
                    is set to 32 or less, <code class="literal">InnoDB</code> assigns one
                    rollback segment to the system tablespace and 32 to the
                    temporary tablespace.
                </p><p style="color:blue;">当innodb_rollback_segments设置为32或更少时，innodb会为系统表空间分配一个rollback segments，为临时表空间分配32个rollback segments。</p><p>
                    When <a class="link" href="innodb-storage-engine.html#sysvar_innodb_rollback_segments"><code class="literal">innodb_rollback_segments</code></a>
                    is set to a value greater than 32, <code class="literal">InnoDB</code>
                    assigns one rollback segment to the system tablespace, 32 to
                    the temporary tablespace, and additional rollback segments to
                    undo tablespaces, if present. If undo tablespaces are not
                    present, additional rollback segments are assigned to the
                    system tablespace.
                </p><p style="color:blue;">当innodb_rollback_segments设置为大于32的值时，innodb为系统表空间分配一个回滚段，为临时表空间分配32个回滚段，如果存在，则为撤消表空间分配其他回滚段。如果不存在撤消表空间，则会将其他回滚段分配给系统表空间。</p><p>
                    Although you can increase or decrease the number of rollback
                    segments used by <code class="literal">InnoDB</code>, the number of
                    rollback segments physically present in the system never
                    decreases. Thus, you might start with a low value and
                    gradually increase it to avoid allocating rollback segments
                    that are not required. The
                    <a class="link" href="innodb-storage-engine.html#sysvar_innodb_rollback_segments"><code class="literal">innodb_rollback_segments</code></a>
                    default and maximum value is 128.
                </p><p style="color:blue;">尽管可以增加或减少innodb使用的回滚段的数量，但是系统中实际存在的回滚段的数量永远不会减少。因此，您可以从一个较低的值开始并逐渐增加它，以避免分配不需要的回滚段。InBubjReleBead片段默认值和最大值为128。</p><p>
                    For related information, see
                    <a class="xref" href="innodb-storage-engine.html#innodb-multi-versioning" title="14.3&nbsp;InnoDB Multi-Versioning">Section&nbsp;14.3, “InnoDB Multi-Versioning”</a>. For information
                    about configuring separate undo tablespaces, see
                    <a class="xref" href="innodb-storage-engine.html#innodb-undo-tablespaces" title="14.6.3.4&nbsp;Undo Tablespaces">Section&nbsp;14.6.3.4, “Undo Tablespaces”</a>.
                </p><p style="color:blue;">有关信息，请参阅第14.3节“InnoDB多版本控制”。有关配置单独的撤消表空间的信息，请参阅14.6.3.4节“撤消表空间”。</p></li><li class="listitem"><p><a name="sysvar_innodb_saved_page_number_debug"></a>
                <a class="indexterm" name="idm140286809737200"></a>

                <a class="indexterm" name="idm140286809736160"></a>

                <code class="literal">innodb_saved_page_number_debug</code>
            </p><p style="color:blue;">innodb_saved_page_number_调试</p>
                <div class="informaltable">
                    <table frame="box" rules="all" summary="Properties for innodb_saved_page_number_debug"><colgroup><col width="30%"><col width="70%"></colgroup><thead><tr><th scope="col">Property</th>
                        <th scope="col">Value</th>
                    </tr></thead><tbody><tr><td scope="row"><span class="bold"><strong>Command-Line Format</strong></span></td>
                        <td><code class="literal">--innodb-saved-page-number-debug=#</code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>System Variable</strong></span></td>
                        <td><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_saved_page_number_debug">innodb_saved_page_number_debug</a></code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Scope</strong></span></td>
                        <td>Global</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Dynamic</strong></span></td>
                        <td>Yes</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Type</strong></span></td>
                        <td>Integer</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Default Value</strong></span></td>
                        <td><code class="literal">0</code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Maximum Value</strong></span></td>
                        <td><code class="literal">2**23-1</code></td>
                    </tr></tbody></table>
                </div>
                <p>
                    Saves a page number. Setting the
                    <a class="link" href="innodb-storage-engine.html#sysvar_innodb_fil_make_page_dirty_debug"><code class="literal">innodb_fil_make_page_dirty_debug</code></a>
                    option dirties the page defined by
                    <code class="literal">innodb_saved_page_number_debug</code>. The
                    <code class="literal">innodb_saved_page_number_debug</code> option is
                    only available if debugging support is compiled in using the
                    <a class="link" href="installing.html#option_cmake_with_debug"><code class="option">WITH_DEBUG</code></a>
                    <span class="command"><strong>CMake</strong></span> option.
                </p><p style="color:blue;">保存页码。设置innodb_fil_make_page_dirty_debug选项会损坏innodb_saved_page_number_debug定义的页面。innodb_saved_page_number_debug选项仅在使用with_debug cmake选项编译调试支持时可用。</p></li><li class="listitem"><p><a name="sysvar_innodb_sort_buffer_size"></a>
                <a class="indexterm" name="idm140286809700832"></a>

                <code class="literal">innodb_sort_buffer_size</code>
            </p><p style="color:blue;">innodb_sort_buffer_大小</p>
                <div class="informaltable">
                    <table frame="box" rules="all" summary="Properties for innodb_sort_buffer_size"><colgroup><col width="30%"><col width="70%"></colgroup><thead><tr><th scope="col">Property</th>
                        <th scope="col">Value</th>
                    </tr></thead><tbody><tr><td scope="row"><span class="bold"><strong>Command-Line Format</strong></span></td>
                        <td><code class="literal">--innodb-sort-buffer-size=#</code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>System Variable</strong></span></td>
                        <td><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_sort_buffer_size">innodb_sort_buffer_size</a></code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Scope</strong></span></td>
                        <td>Global</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Dynamic</strong></span></td>
                        <td>No</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Type</strong></span></td>
                        <td>Integer</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Default Value</strong></span></td>
                        <td><code class="literal">1048576</code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Minimum Value</strong></span></td>
                        <td><code class="literal">65536</code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Maximum Value</strong></span></td>
                        <td><code class="literal">67108864</code></td>
                    </tr></tbody></table>
                </div>
                <p>
                    Specifies the size of sort buffers used to sort data during
                    creation of an <code class="literal">InnoDB</code> index. The specified
                    size defines the amount of data that is read into memory for
                    internal sorting and then written out to disk. This process is
                    referred to as a <span class="quote">“<span class="quote">run</span>”</span>. During the merge phase,
                    pairs of buffers of the specified size are read and merged.
                    The larger the setting, the fewer runs and merges there are.
                </p><p style="color:blue;">指定在创建innodb索引期间用于排序数据的排序缓冲区的大小。指定的大小定义读入内存进行内部排序，然后写入磁盘的数据量。此过程称为“运行”。在合并阶段，读取并合并指定大小的缓冲区对。设置越大，运行和合并就越少。</p><p>
                    This sort area is only used for merge sorts during index
                    creation, not during later index maintenance operations.
                    Buffers are deallocated when index creation completes.
                </p><p style="color:blue;">此排序区域仅用于索引创建期间的合并排序，而不用于以后的索引维护操作。索引创建完成时释放缓冲区。</p><p>
                    The value of this option also controls the amount by which the
                    temporary log file is extended to record concurrent DML during
                    <a class="link" href="glossary.html#glos_online_ddl" title="online DDL">online DDL</a> operations.
                </p><p style="color:blue;">此选项的值还控制在联机DDL操作期间扩展临时日志文件以记录并发DML的量。</p><p>
                    Before this setting was made configurable, the size was
                    hardcoded to 1048576 bytes (1MB), which remains the default.
                </p><p style="color:blue;">在设置为可配置之前，大小被硬编码为1048576字节（1MB），这仍然是默认值。</p><p>
                    During an <a class="link" href="sql-syntax.html#alter-table" title="13.1.8&nbsp;ALTER TABLE Syntax"><code class="literal">ALTER TABLE</code></a> or
                    <a class="link" href="sql-syntax.html#create-table" title="13.1.18&nbsp;CREATE TABLE Syntax"><code class="literal">CREATE TABLE</code></a> statement that
                    creates an index, 3 buffers are allocated, each with a size
                    defined by this option. Additionally, auxiliary pointers are
                    allocated to rows in the sort buffer so that the sort can run
                    on pointers (as opposed to moving rows during the sort
                    operation).
                </p><p style="color:blue;">在创建索引的alter table或create table语句中，将分配3个缓冲区，每个缓冲区的大小由该选项定义。另外，辅助指针被分配给排序缓冲区中的行，以便排序可以在指针上运行（而不是在排序操作中移动行）。</p><p>
                    For a typical sort operation, a formula such as this one can
                    be used to estimate memory consumption:
                </p><p style="color:blue;">对于典型的排序操作，可以使用这样的公式来估计内存消耗：</p><pre data-lang="none" class="programlisting">(6 /*FTS_NUM_AUX_INDEX*/ * (3*@@GLOBAL.innodb_sort_buffer_size)
+ 2 * number_of_partitions * number_of_secondary_indexes_created
* (@@GLOBAL.innodb_sort_buffer_size/dict_index_get_min_size(index)*/)
* 8 /*64-bit sizeof *buf-&gt;tuples*/")
</pre><p>
                    <code class="literal">@@GLOBAL.innodb_sort_buffer_size/dict_index_get_min_size(index)</code>
                    indicates the maximum tuples held. <code class="literal">2 *
                    (@@GLOBAL.innodb_sort_buffer_size/*dict_index_get_min_size(index)*/)
                    * 8 /*64-bit size of *buf-&gt;tuples*/</code> indicates
                    auxiliary pointers allocated.
                </p><p style="color:blue;">@ @ Global .InndBySoTrpBuffryStase/DigialIndex xGETMIXMILASSIZE（index）指示保存的最大元组。2 *（@ @ Global .InndBysOrthBuffeReSythy/*DigixIndex，GETAXMILYSIZE（index）*/*）* 8 / * 64位**BUF-&gt;元组*/表示辅助指针分配。</p>
                <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">

                    <div class="admon-title">
                        Note
                    </div>
                    <p>
                        For 32-bit, multiply by 4 instead of 8.
                    </p><p style="color:blue;">对于32位，乘以4而不是8。</p>
                </div>
                <p>
                    For parallel sorts on a full-text index, multiply by the
                    <a class="link" href="innodb-storage-engine.html#sysvar_innodb_ft_sort_pll_degree"><code class="literal">innodb_ft_sort_pll_degree</code></a>
                    setting:
                </p><p style="color:blue;">对于全文索引上的并行排序，乘以innodb_ft_sort_pll_degree设置：</p><pre data-lang="none" class="programlisting">(6 /*FTS_NUM_AUX_INDEX*/ * @@GLOBAL.innodb_ft_sort_pll_degree)
</pre></li><li class="listitem"><p><a name="sysvar_innodb_spin_wait_delay"></a>
                <a class="indexterm" name="idm140286809652448"></a>

                <a class="indexterm" name="idm140286809651408"></a>

                <code class="literal">innodb_spin_wait_delay</code>
            </p><p style="color:blue;">innodb_spin_wait_延迟</p>
                <div class="informaltable">
                    <table frame="box" rules="all" summary="Properties for innodb_spin_wait_delay"><colgroup><col width="30%"><col width="70%"></colgroup><thead><tr><th scope="col">Property</th>
                        <th scope="col">Value</th>
                    </tr></thead><tbody><tr><td scope="row"><span class="bold"><strong>Command-Line Format</strong></span></td>
                        <td><code class="literal">--innodb-spin-wait-delay=#</code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>System Variable</strong></span></td>
                        <td><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_spin_wait_delay">innodb_spin_wait_delay</a></code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Scope</strong></span></td>
                        <td>Global</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Dynamic</strong></span></td>
                        <td>Yes</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Type</strong></span></td>
                        <td>Integer</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Default Value</strong></span></td>
                        <td><code class="literal">6</code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Minimum Value</strong></span></td>
                        <td><code class="literal">0</code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Maximum Value</strong></span> (64-bit platforms)</td>
                        <td><code class="literal">2**64-1</code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Maximum Value</strong></span> (32-bit platforms)</td>
                        <td><code class="literal">2**32-1</code></td>
                    </tr></tbody></table>
                </div>
                <p>
                    The maximum delay between polls for a
                    <a class="link" href="glossary.html#glos_spin" title="spin">spin</a> lock. The low-level
                    implementation of this mechanism varies depending on the
                    combination of hardware and operating system, so the delay
                    does not correspond to a fixed time interval. For more
                    information, see
                    <a class="xref" href="innodb-storage-engine.html#innodb-performance-spin_lock_polling" title="14.8.9&nbsp;Configuring Spin Lock Polling">Section&nbsp;14.8.9, “Configuring Spin Lock Polling”</a>.
                </p><p style="color:blue;">自旋锁定之间的最大延迟。这种机制的低级实现取决于硬件和操作系统的组合，因此延迟与固定的时间间隔不对应。有关更多信息，请参阅第14.8.9节“配置自旋锁轮询”。</p></li><li class="listitem"><p><a name="sysvar_innodb_stats_auto_recalc"></a>
                <a class="indexterm" name="idm140286809612240"></a>

                <code class="literal">innodb_stats_auto_recalc</code>
            </p><p style="color:blue;">InnoDB_Stats_Auto_Recalc公司</p>
                <div class="informaltable">
                    <table frame="box" rules="all" summary="Properties for innodb_stats_auto_recalc"><colgroup><col width="30%"><col width="70%"></colgroup><thead><tr><th scope="col">Property</th>
                        <th scope="col">Value</th>
                    </tr></thead><tbody><tr><td scope="row"><span class="bold"><strong>Command-Line Format</strong></span></td>
                        <td><code class="literal">--innodb-stats-auto-recalc[={OFF|ON}]</code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>System Variable</strong></span></td>
                        <td><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_stats_auto_recalc">innodb_stats_auto_recalc</a></code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Scope</strong></span></td>
                        <td>Global</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Dynamic</strong></span></td>
                        <td>Yes</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Type</strong></span></td>
                        <td>Boolean</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Default Value</strong></span></td>
                        <td><code class="literal">ON</code></td>
                    </tr></tbody></table>
                </div>
                <p>
                    Causes <code class="literal">InnoDB</code> to automatically recalculate
                    <a class="link" href="glossary.html#glos_persistent_statistics" title="persistent statistics">persistent
                        statistics</a> after the data in a table is changed
                    substantially. The threshold value is 10% of the rows in the
                    table. This setting applies to tables created when the
                    <a class="link" href="innodb-storage-engine.html#sysvar_innodb_stats_persistent"><code class="literal">innodb_stats_persistent</code></a>
                    option is enabled. Automatic statistics recalculation may also
                    be configured by specifying
                    <code class="literal">STATS_PERSISTENT=1</code> in a
                    <a class="link" href="sql-syntax.html#create-table" title="13.1.18&nbsp;CREATE TABLE Syntax"><code class="literal">CREATE TABLE</code></a> or
                    <a class="link" href="sql-syntax.html#alter-table" title="13.1.8&nbsp;ALTER TABLE Syntax"><code class="literal">ALTER TABLE</code></a> statement. The
                    amount of data sampled to produce the statistics is controlled
                    by the
                    <a class="link" href="innodb-storage-engine.html#sysvar_innodb_stats_persistent_sample_pages"><code class="literal">innodb_stats_persistent_sample_pages</code></a>
                    variable.
                </p><p style="color:blue;">使innodb在表中的数据发生实质性变化后自动重新计算持久性统计信息。阈值是表中行的10%。此设置适用于启用innodb_stats_persistent选项时创建的表。还可以通过在CREATE TABLE或ALTER TABLE语句中指定stats_persistent=1来配置自动统计重新计算。为生成统计数据而采样的数据量由innodb_stats_persistent_sample_pages变量控制。</p><p>
                    For more information, see
                    <a class="xref" href="innodb-storage-engine.html#innodb-persistent-stats" title="14.8.11.1&nbsp;Configuring Persistent Optimizer Statistics Parameters">Section&nbsp;14.8.11.1, “Configuring Persistent Optimizer Statistics Parameters”</a>.
                </p><p style="color:blue;">有关更多信息，请参阅第14.8.11.1节“配置持久优化器统计参数”。</p></li><li class="listitem"><p><a name="sysvar_innodb_stats_include_delete_marked"></a>
                <a class="indexterm" name="idm140286809576064"></a>

                <a class="indexterm" name="idm140286809575024"></a>

                <code class="literal">innodb_stats_include_delete_marked</code>
            </p><p style="color:blue;">innodb_stats_include_delete_标记</p>
                <div class="informaltable">
                    <table frame="box" rules="all" summary="Properties for innodb_stats_include_delete_marked"><colgroup><col width="30%"><col width="70%"></colgroup><thead><tr><th scope="col">Property</th>
                        <th scope="col">Value</th>
                    </tr></thead><tbody><tr><td scope="row"><span class="bold"><strong>Command-Line Format</strong></span></td>
                        <td><code class="literal">--innodb-stats-include-delete-marked[={OFF|ON}]</code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Introduced</strong></span></td>
                        <td>5.7.17</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>System Variable</strong></span></td>
                        <td><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_stats_include_delete_marked">innodb_stats_include_delete_marked</a></code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Scope</strong></span></td>
                        <td>Global</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Dynamic</strong></span></td>
                        <td>Yes</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Type</strong></span></td>
                        <td>Boolean</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Default Value</strong></span></td>
                        <td><code class="literal">OFF</code></td>
                    </tr></tbody></table>
                </div>
                <p>
                    By default, <code class="literal">InnoDB</code> reads uncommitted data
                    when calculating statistics. In the case of an uncommitted
                    transaction that deletes rows from a table,
                    <code class="literal">InnoDB</code> excludes records that are
                    delete-marked when calculating row estimates and index
                    statistics, which can lead to non-optimal execution plans for
                    other transactions that are operating on the table
                    concurrently using a transaction isolation level other than
                    <a class="link" href="innodb-storage-engine.html#isolevel_read-uncommitted"><code class="literal">READ UNCOMMITTED</code></a>. To avoid
                    this scenario,
                    <a class="link" href="innodb-storage-engine.html#sysvar_innodb_stats_include_delete_marked"><code class="literal">innodb_stats_include_delete_marked</code></a>
                    can be enabled to ensure that <code class="literal">InnoDB</code>
                    includes delete-marked records when calculating persistent
                    optimizer statistics.
                </p><p style="color:blue;">默认情况下，innodb在计算统计数据时读取未提交的数据。对于从表中删除行的未提交事务，innodb排除了在计算行估计和索引统计时标记为delete的记录，这可能会导致其他事务的非最佳执行计划，这些事务使用事务隔离级别（而不是read uncommitted）同时在表上操作。为了避免这种情况，可以启用innodb_stats_include_delete_marked以确保innodb在计算持久优化器统计信息时包含delete marked记录。</p><p>
                    When
                    <a class="link" href="innodb-storage-engine.html#sysvar_innodb_stats_include_delete_marked"><code class="literal">innodb_stats_include_delete_marked</code></a>
                    is enabled, <a class="link" href="sql-syntax.html#analyze-table" title="13.7.2.1&nbsp;ANALYZE TABLE Syntax"><code class="literal">ANALYZE TABLE</code></a>
                    considers delete-marked records when recalculating statistics.
                </p><p style="color:blue;">当启用innodb_stats_include_delete_marked时，analyze table在重新计算统计信息时会考虑删除标记的记录。</p><p>
                    <a class="link" href="innodb-storage-engine.html#sysvar_innodb_stats_include_delete_marked"><code class="literal">innodb_stats_include_delete_marked</code></a>
                    is a global setting that affects all <code class="literal">InnoDB</code>
                    tables. It is only applicable to persistent optimizer
                    statistics.
                </p><p style="color:blue;">innodb_stats_include_delete_marked是影响所有innodb表的全局设置。它只适用于持久优化器统计信息。</p><p>
                    For related information, see
                    <a class="xref" href="innodb-storage-engine.html#innodb-persistent-stats" title="14.8.11.1&nbsp;Configuring Persistent Optimizer Statistics Parameters">Section&nbsp;14.8.11.1, “Configuring Persistent Optimizer Statistics Parameters”</a>.
                </p><p style="color:blue;">有关相关信息，请参阅第14.8.11.1节“配置持久优化器统计参数”。</p></li><li class="listitem"><p><a name="sysvar_innodb_stats_method"></a>
                <a class="indexterm" name="idm140286809532592"></a>

                <a class="indexterm" name="idm140286809531552"></a>

                <code class="literal">innodb_stats_method</code>
            </p><p style="color:blue;">innodb_stats_方法</p>
                <div class="informaltable">
                    <table frame="box" rules="all" summary="Properties for innodb_stats_method"><colgroup><col width="30%"><col width="70%"></colgroup><thead><tr><th scope="col">Property</th>
                        <th scope="col">Value</th>
                    </tr></thead><tbody><tr><td scope="row"><span class="bold"><strong>Command-Line Format</strong></span></td>
                        <td><code class="literal">--innodb-stats-method=value</code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>System Variable</strong></span></td>
                        <td><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_stats_method">innodb_stats_method</a></code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Scope</strong></span></td>
                        <td>Global</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Dynamic</strong></span></td>
                        <td>Yes</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Type</strong></span></td>
                        <td>Enumeration</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Default Value</strong></span></td>
                        <td><code class="literal">nulls_equal</code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Valid Values</strong></span></td>
                        <td><p class="valid-value"><code class="literal">nulls_equal</code></p><p style="color:blue;">等于零</p><p class="valid-value"><code class="literal">nulls_unequal</code></p><p style="color:blue;">零位</p><p class="valid-value"><code class="literal">nulls_ignored</code></p><p style="color:blue;">忽略空值</p></td>
                    </tr></tbody></table>
                </div>
                <p>
                    How the server treats <code class="literal">NULL</code> values when
                    collecting <a class="link" href="glossary.html#glos_statistics" title="statistics">statistics</a>
                    about the distribution of index values for
                    <code class="literal">InnoDB</code> tables. Permitted values are
                    <code class="literal">nulls_equal</code>,
                    <code class="literal">nulls_unequal</code>, and
                    <code class="literal">nulls_ignored</code>. For
                    <code class="literal">nulls_equal</code>, all <code class="literal">NULL</code>
                    index values are considered equal and form a single value
                    group with a size equal to the number of
                    <code class="literal">NULL</code> values. For
                    <code class="literal">nulls_unequal</code>, <code class="literal">NULL</code>
                    values are considered unequal, and each
                    <code class="literal">NULL</code> forms a distinct value group of size
                    1. For <code class="literal">nulls_ignored</code>,
                    <code class="literal">NULL</code> values are ignored.
                </p><p style="color:blue;">当收集有关innodb表索引值分布的统计信息时，服务器如何处理空值。允许的值为nulls_equal、nulls_equal和nulls_ignored。对于nulls_equal，所有的空索引值都被视为相等，并形成一个大小等于空值个数的值组。对于不相等的空值，空值被视为不相等，并且每个空值形成大小为1的不同值组。对于忽略的空值，将忽略空值。</p><p>
                    The method used to generate table statistics influences how
                    the optimizer chooses indexes for query execution, as
                    described in <a class="xref" href="optimization.html#index-statistics" title="8.3.7&nbsp;InnoDB and MyISAM Index Statistics Collection">Section&nbsp;8.3.7, “InnoDB and MyISAM Index Statistics Collection”</a>.
                </p><p style="color:blue;">生成表统计信息的方法会影响优化器选择索引执行查询的方式，如8.3.7节“InnoDB和MyISAM索引统计信息收集”所述。</p></li><li class="listitem"><p><a name="sysvar_innodb_stats_on_metadata"></a>
                <a class="indexterm" name="idm140286809486784"></a>

                <a class="indexterm" name="idm140286809485680"></a>

                <code class="literal">innodb_stats_on_metadata</code>
            </p><p style="color:blue;">innodb_stats_on_元数据</p>
                <div class="informaltable">
                    <table frame="box" rules="all" summary="Properties for innodb_stats_on_metadata"><colgroup><col width="30%"><col width="70%"></colgroup><thead><tr><th scope="col">Property</th>
                        <th scope="col">Value</th>
                    </tr></thead><tbody><tr><td scope="row"><span class="bold"><strong>Command-Line Format</strong></span></td>
                        <td><code class="literal">--innodb-stats-on-metadata[={OFF|ON}]</code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>System Variable</strong></span></td>
                        <td><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_stats_on_metadata">innodb_stats_on_metadata</a></code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Scope</strong></span></td>
                        <td>Global</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Dynamic</strong></span></td>
                        <td>Yes</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Type</strong></span></td>
                        <td>Boolean</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Default Value</strong></span></td>
                        <td><code class="literal">OFF</code></td>
                    </tr></tbody></table>
                </div>
                <p>
                    This option only applies when optimizer
                    <a class="link" href="glossary.html#glos_statistics" title="statistics">statistics</a> are
                    configured to be non-persistent. Optimizer statistics are not
                    persisted to disk when
                    <a class="link" href="innodb-storage-engine.html#sysvar_innodb_stats_persistent"><code class="literal">innodb_stats_persistent</code></a> is
                    disabled or when individual tables are created or altered with
                    <code class="literal">STATS_PERSISTENT=0</code>. For more information,
                    see <a class="xref" href="innodb-storage-engine.html#innodb-statistics-estimation" title="14.8.11.2&nbsp;Configuring Non-Persistent Optimizer Statistics Parameters">Section&nbsp;14.8.11.2, “Configuring Non-Persistent Optimizer Statistics Parameters”</a>.
                </p><p style="color:blue;">仅当优化器统计信息配置为非持久性时，此选项才适用。当innodb_stats_persistent被禁用，或者当使用stats_persistent=0创建或更改单个表时，优化器统计信息不会持久化到磁盘。有关更多信息，请参阅第14.8.11.2节“配置非持久优化器统计参数”。</p><p>
                    When <code class="literal">innodb_stats_on_metadata</code> is enabled,
                    <code class="literal">InnoDB</code> updates non-persistent
                    <a class="link" href="glossary.html#glos_statistics" title="statistics">statistics</a> when
                    metadata statements such as <a class="link" href="sql-syntax.html#show-table-status" title="13.7.5.36&nbsp;SHOW TABLE STATUS Syntax"><code class="literal">SHOW TABLE
                    STATUS</code></a> or when accessing the
                    <a class="link" href="information-schema.html#tables-table" title="24.25&nbsp;The INFORMATION_SCHEMA TABLES Table"><code class="literal">INFORMATION_SCHEMA.TABLES</code></a> or
                    <a class="link" href="information-schema.html#statistics-table" title="24.24&nbsp;The INFORMATION_SCHEMA STATISTICS Table"><code class="literal">INFORMATION_SCHEMA.STATISTICS</code></a>
                    tables. (These updates are similar to what happens for
                    <a class="link" href="sql-syntax.html#analyze-table" title="13.7.2.1&nbsp;ANALYZE TABLE Syntax"><code class="literal">ANALYZE TABLE</code></a>.) When disabled,
                    <code class="literal">InnoDB</code> does not update statistics during
                    these operations. Leaving the setting disabled can improve
                    access speed for schemas that have a large number of tables or
                    indexes. It can also improve the stability of
                    <a class="link" href="glossary.html#glos_query_execution_plan" title="query execution plan">execution
                        plans</a> for queries that involve
                    <code class="literal">InnoDB</code> tables.
                </p><p style="color:blue;">当启用innodb_stats_on_metadata时，innodb会在元数据语句（如show table status）或访问information_schema.tables或information_schema.statistics表时更新非持久性统计信息。（这些更新与analyze table的情况类似。）禁用时，innodb不会在这些操作期间更新统计信息。禁用该设置可以提高具有大量表或索引的架构的访问速度。它还可以提高涉及innodb表的查询的执行计划的稳定性。</p><p>
                    To change the setting, issue the statement <code class="literal">SET GLOBAL
                    innodb_stats_on_metadata=<em class="replaceable"><code>mode</code></em></code>,
                    where <code class="literal"><em class="replaceable"><code>mode</code></em></code> is
                    either <code class="literal">ON</code> or <code class="literal">OFF</code> (or
                    <code class="literal">1</code> or <code class="literal">0</code>). Changing the
                    setting requires privileges sufficient to set global system
                    variables (see <a class="xref" href="server-administration.html#system-variable-privileges" title="5.1.8.1&nbsp;System Variable Privileges">Section&nbsp;5.1.8.1, “System Variable Privileges”</a>)
                    and immediately affects the operation of all connections.
                </p><p style="color:blue;">要更改设置，请发出语句set global innodb_stats_on_metadata=mode，其中mode为on或off（或1或0）。更改设置需要足够的权限来设置全局系统变量（请参阅第5.1.8.1节“系统变量权限”），并立即影响所有连接的操作。</p></li><li class="listitem"><p><a name="sysvar_innodb_stats_persistent"></a>
                <a class="indexterm" name="idm140286809437856"></a>

                <a class="indexterm" name="idm140286809436816"></a>

                <code class="literal">innodb_stats_persistent</code>
            </p><p style="color:blue;">innodb_stats_持久</p>
                <div class="informaltable">
                    <table frame="box" rules="all" summary="Properties for innodb_stats_persistent"><colgroup><col width="30%"><col width="70%"></colgroup><thead><tr><th scope="col">Property</th>
                        <th scope="col">Value</th>
                    </tr></thead><tbody><tr><td scope="row"><span class="bold"><strong>Command-Line Format</strong></span></td>
                        <td><code class="literal">--innodb-stats-persistent[={OFF|ON}]</code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>System Variable</strong></span></td>
                        <td><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_stats_persistent">innodb_stats_persistent</a></code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Scope</strong></span></td>
                        <td>Global</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Dynamic</strong></span></td>
                        <td>Yes</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Type</strong></span></td>
                        <td>Boolean</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Default Value</strong></span></td>
                        <td><code class="literal">ON</code></td>
                    </tr></tbody></table>
                </div>
                <p>
                    Specifies whether <code class="literal">InnoDB</code> index statistics
                    are persisted to disk. Otherwise, statistics may be
                    recalculated frequently which can lead to variations in
                    <a class="link" href="glossary.html#glos_query_execution_plan" title="query execution plan">query execution
                        plans</a>. This setting is stored with each table when the
                    table is created. You can set
                    <code class="literal">innodb_stats_persistent</code> at the global level
                    before creating a table, or use the
                    <code class="literal">STATS_PERSISTENT</code> clause of the
                    <a class="link" href="sql-syntax.html#create-table" title="13.1.18&nbsp;CREATE TABLE Syntax"><code class="literal">CREATE TABLE</code></a> and
                    <a class="link" href="sql-syntax.html#alter-table" title="13.1.8&nbsp;ALTER TABLE Syntax"><code class="literal">ALTER TABLE</code></a> statements to
                    override the system-wide setting and configure persistent
                    statistics for individual tables.
                </p><p style="color:blue;">指定InnoDB索引统计信息是否持久化到磁盘。否则，可能会频繁地重新计算统计信息，从而导致查询执行计划发生变化。创建表时，此设置与每个表一起存储。可以在创建表之前在全局级别设置innodb_stats_persistent，或者使用create table和alter table语句的stats_persistent子句覆盖系统范围的设置并为单个表配置持久统计信息。</p><p>
                    For more information, see
                    <a class="xref" href="innodb-storage-engine.html#innodb-persistent-stats" title="14.8.11.1&nbsp;Configuring Persistent Optimizer Statistics Parameters">Section&nbsp;14.8.11.1, “Configuring Persistent Optimizer Statistics Parameters”</a>.
                </p><p style="color:blue;">有关更多信息，请参阅第14.8.11.1节“配置持久优化器统计参数”。</p></li><li class="listitem"><p><a name="sysvar_innodb_stats_persistent_sample_pages"></a>
                <a class="indexterm" name="idm140286809402080"></a>

                <code class="literal">innodb_stats_persistent_sample_pages</code>
            </p><p style="color:blue;">innodb_stats_persistent_sample_页面</p>
                <div class="informaltable">
                    <table frame="box" rules="all" summary="Properties for innodb_stats_persistent_sample_pages"><colgroup><col width="30%"><col width="70%"></colgroup><thead><tr><th scope="col">Property</th>
                        <th scope="col">Value</th>
                    </tr></thead><tbody><tr><td scope="row"><span class="bold"><strong>Command-Line Format</strong></span></td>
                        <td><code class="literal">--innodb-stats-persistent-sample-pages=#</code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>System Variable</strong></span></td>
                        <td><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_stats_persistent_sample_pages">innodb_stats_persistent_sample_pages</a></code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Scope</strong></span></td>
                        <td>Global</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Dynamic</strong></span></td>
                        <td>Yes</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Type</strong></span></td>
                        <td>Integer</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Default Value</strong></span></td>
                        <td><code class="literal">20</code></td>
                    </tr></tbody></table>
                </div>
                <p>
                    The number of index <a class="link" href="glossary.html#glos_page" title="page">pages</a> to
                    sample when estimating
                    <a class="link" href="glossary.html#glos_cardinality" title="cardinality">cardinality</a> and other
                    <a class="link" href="glossary.html#glos_statistics" title="statistics">statistics</a> for an
                    indexed column, such as those calculated by
                    <a class="link" href="sql-syntax.html#analyze-table" title="13.7.2.1&nbsp;ANALYZE TABLE Syntax"><code class="literal">ANALYZE TABLE</code></a>. Increasing the
                    value improves the accuracy of index statistics, which can
                    improve the <a class="link" href="glossary.html#glos_query_execution_plan" title="query execution plan">query
                    execution plan</a>, at the expense of increased I/O during
                    the execution of <a class="link" href="sql-syntax.html#analyze-table" title="13.7.2.1&nbsp;ANALYZE TABLE Syntax"><code class="literal">ANALYZE TABLE</code></a>
                    for an <code class="literal">InnoDB</code> table. For more information,
                    see <a class="xref" href="innodb-storage-engine.html#innodb-persistent-stats" title="14.8.11.1&nbsp;Configuring Persistent Optimizer Statistics Parameters">Section&nbsp;14.8.11.1, “Configuring Persistent Optimizer Statistics Parameters”</a>.
                </p><p style="color:blue;">估计索引列的基数和其他统计信息（如由analyze table计算的统计信息）时要采样的索引页数。增加这个值可以提高索引统计的准确性，这可以改进查询执行计划，但是在执行innodb表的analyze表时会增加i/o。有关更多信息，请参阅第14.8.11.1节“配置持久优化器统计参数”。</p>
                <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">

                    <div class="admon-title">
                        Note
                    </div>
                    <p>
                        Setting a high value for
                        <code class="literal">innodb_stats_persistent_sample_pages</code>
                        could result in lengthy <a class="link" href="sql-syntax.html#analyze-table" title="13.7.2.1&nbsp;ANALYZE TABLE Syntax"><code class="literal">ANALYZE
                        TABLE</code></a> execution time. To estimate the number of
                        database pages accessed by <a class="link" href="sql-syntax.html#analyze-table" title="13.7.2.1&nbsp;ANALYZE TABLE Syntax"><code class="literal">ANALYZE
                        TABLE</code></a>, see
                        <a class="xref" href="innodb-storage-engine.html#innodb-analyze-table-complexity" title="14.8.11.3&nbsp;Estimating ANALYZE TABLE Complexity for InnoDB Tables">Section&nbsp;14.8.11.3, “Estimating ANALYZE TABLE Complexity for InnoDB Tables”</a>.
                    </p><p style="color:blue;">为innodb_stats_persistent_sample_页面设置一个高值可能会导致分析表执行时间过长。若要估计分析表访问的数据库页的数量，请参阅第14.1.3节，“估计NYNDB表的分析表复杂性”。</p>
                </div>
                <p>
                    <code class="literal">innodb_stats_persistent_sample_pages</code> only
                    applies when
                    <a class="link" href="innodb-storage-engine.html#sysvar_innodb_stats_persistent"><code class="literal">innodb_stats_persistent</code></a> is
                    enabled for a table; when
                    <a class="link" href="innodb-storage-engine.html#sysvar_innodb_stats_persistent"><code class="literal">innodb_stats_persistent</code></a> is
                    disabled,
                    <a class="link" href="innodb-storage-engine.html#sysvar_innodb_stats_transient_sample_pages"><code class="literal">innodb_stats_transient_sample_pages</code></a>
                    applies instead.
                </p><p style="color:blue;">innodb_stats_persistent_sample_页面仅在为表启用innodb_stats_persistent时适用；当innodb_stats_persistent被禁用时，innodb_stats_transient_sample_页面则适用。</p></li><li class="listitem"><p><a name="sysvar_innodb_stats_sample_pages"></a>
                <a class="indexterm" name="idm140286809357408"></a>

                <a class="indexterm" name="idm140286809356304"></a>

                <code class="literal">innodb_stats_sample_pages</code>
            </p><p style="color:blue;">innodb_stats_sample_页面</p>
                <div class="informaltable">
                    <table frame="box" rules="all" summary="Properties for innodb_stats_sample_pages"><colgroup><col width="30%"><col width="70%"></colgroup><thead><tr><th scope="col">Property</th>
                        <th scope="col">Value</th>
                    </tr></thead><tbody><tr><td scope="row"><span class="bold"><strong>Command-Line Format</strong></span></td>
                        <td><code class="literal">--innodb-stats-sample-pages=#</code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Deprecated</strong></span></td>
                        <td>Yes</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>System Variable</strong></span></td>
                        <td><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_stats_sample_pages">innodb_stats_sample_pages</a></code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Scope</strong></span></td>
                        <td>Global</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Dynamic</strong></span></td>
                        <td>Yes</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Type</strong></span></td>
                        <td>Integer</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Default Value</strong></span></td>
                        <td><code class="literal">8</code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Minimum Value</strong></span></td>
                        <td><code class="literal">1</code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Maximum Value</strong></span></td>
                        <td><code class="literal">2**64-1</code></td>
                    </tr></tbody></table>
                </div>
                <p>
                    Deprecated. Use
                    <a class="link" href="innodb-storage-engine.html#sysvar_innodb_stats_transient_sample_pages"><code class="literal">innodb_stats_transient_sample_pages</code></a>
                    instead.
                </p><p style="color:blue;">不赞成的改用innodb_stats_transient_sample_页面。</p></li><li class="listitem"><p><a name="sysvar_innodb_stats_transient_sample_pages"></a>
                <a class="indexterm" name="idm140286809318480"></a>

                <code class="literal">innodb_stats_transient_sample_pages</code>
            </p><p style="color:blue;">innodb_stats_transient_sample_页面</p>
                <div class="informaltable">
                    <table frame="box" rules="all" summary="Properties for innodb_stats_transient_sample_pages"><colgroup><col width="30%"><col width="70%"></colgroup><thead><tr><th scope="col">Property</th>
                        <th scope="col">Value</th>
                    </tr></thead><tbody><tr><td scope="row"><span class="bold"><strong>Command-Line Format</strong></span></td>
                        <td><code class="literal">--innodb-stats-transient-sample-pages=#</code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>System Variable</strong></span></td>
                        <td><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_stats_transient_sample_pages">innodb_stats_transient_sample_pages</a></code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Scope</strong></span></td>
                        <td>Global</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Dynamic</strong></span></td>
                        <td>Yes</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Type</strong></span></td>
                        <td>Integer</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Default Value</strong></span></td>
                        <td><code class="literal">8</code></td>
                    </tr></tbody></table>
                </div>
                <p>
                    The number of index <a class="link" href="glossary.html#glos_page" title="page">pages</a> to
                    sample when estimating
                    <a class="link" href="glossary.html#glos_cardinality" title="cardinality">cardinality</a> and other
                    <a class="link" href="glossary.html#glos_statistics" title="statistics">statistics</a> for an
                    indexed column, such as those calculated by
                    <a class="link" href="sql-syntax.html#analyze-table" title="13.7.2.1&nbsp;ANALYZE TABLE Syntax"><code class="literal">ANALYZE TABLE</code></a>. The default
                    value is 8. Increasing the value improves the accuracy of
                    index statistics, which can improve the
                    <a class="link" href="glossary.html#glos_query_execution_plan" title="query execution plan">query execution
                        plan</a>, at the expense of increased I/O when opening an
                    <code class="literal">InnoDB</code> table or recalculating statistics.
                    For more information, see
                    <a class="xref" href="innodb-storage-engine.html#innodb-statistics-estimation" title="14.8.11.2&nbsp;Configuring Non-Persistent Optimizer Statistics Parameters">Section&nbsp;14.8.11.2, “Configuring Non-Persistent Optimizer Statistics Parameters”</a>.
                </p><p style="color:blue;">估计索引列的基数和其他统计信息（如由analyze table计算的统计信息）时要采样的索引页数。默认值为8。增加这个值可以提高索引统计信息的准确性，这可以改善查询执行计划，但是在打开innodb表或重新计算统计信息时会增加i/o。有关更多信息，请参阅第14.8.11.2节“配置非持久优化器统计参数”。</p>
                <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">

                    <div class="admon-title">
                        Note
                    </div>
                    <p>
                        Setting a high value for
                        <code class="literal">innodb_stats_transient_sample_pages</code> could
                        result in lengthy <a class="link" href="sql-syntax.html#analyze-table" title="13.7.2.1&nbsp;ANALYZE TABLE Syntax"><code class="literal">ANALYZE
                        TABLE</code></a> execution time. To estimate the number of
                        database pages accessed by <a class="link" href="sql-syntax.html#analyze-table" title="13.7.2.1&nbsp;ANALYZE TABLE Syntax"><code class="literal">ANALYZE
                        TABLE</code></a>, see
                        <a class="xref" href="innodb-storage-engine.html#innodb-analyze-table-complexity" title="14.8.11.3&nbsp;Estimating ANALYZE TABLE Complexity for InnoDB Tables">Section&nbsp;14.8.11.3, “Estimating ANALYZE TABLE Complexity for InnoDB Tables”</a>.
                    </p><p style="color:blue;">为innodb_stats_transient_sample_页面设置一个高值可能会导致分析表执行时间过长。若要估计分析表访问的数据库页的数量，请参阅第14.1.3节，“估计NYNDB表的分析表复杂性”。</p>
                </div>
                <p>
                    <code class="literal">innodb_stats_transient_sample_pages</code> only
                    applies when
                    <a class="link" href="innodb-storage-engine.html#sysvar_innodb_stats_persistent"><code class="literal">innodb_stats_persistent</code></a> is
                    disabled for a table; when
                    <a class="link" href="innodb-storage-engine.html#sysvar_innodb_stats_persistent"><code class="literal">innodb_stats_persistent</code></a> is
                    enabled,
                    <a class="link" href="innodb-storage-engine.html#sysvar_innodb_stats_persistent_sample_pages"><code class="literal">innodb_stats_persistent_sample_pages</code></a>
                    applies instead. Takes the place of
                    <code class="literal">innodb_stats_sample_pages</code>. For more
                    information, see
                    <a class="xref" href="innodb-storage-engine.html#innodb-statistics-estimation" title="14.8.11.2&nbsp;Configuring Non-Persistent Optimizer Statistics Parameters">Section&nbsp;14.8.11.2, “Configuring Non-Persistent Optimizer Statistics Parameters”</a>.
                </p><p style="color:blue;">innodb_stats_transient_sample_pages仅在禁用表的innodb_stats_persistent时应用；启用innodb_stats_persistent时，innodb_stats_persistent_sample_pages应用。取代innodb_stats_sample_页面。有关更多信息，请参阅第14.8.11.2节“配置非持久优化器统计参数”。</p></li><li class="listitem"><p><a name="sysvar_innodb_status_output"></a>
                <a class="indexterm" name="idm140286809273456"></a>

                <a class="indexterm" name="idm140286809272416"></a>

                <code class="literal">innodb_status_output</code>
            </p><p style="color:blue;">InnoDB_状态_输出</p>
                <div class="informaltable">
                    <table frame="box" rules="all" summary="Properties for innodb_status_output"><colgroup><col width="30%"><col width="70%"></colgroup><thead><tr><th scope="col">Property</th>
                        <th scope="col">Value</th>
                    </tr></thead><tbody><tr><td scope="row"><span class="bold"><strong>Command-Line Format</strong></span></td>
                        <td><code class="literal">--innodb-status-output[={OFF|ON}]</code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Introduced</strong></span></td>
                        <td>5.7.4</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>System Variable</strong></span></td>
                        <td><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_status_output">innodb_status_output</a></code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Scope</strong></span></td>
                        <td>Global</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Dynamic</strong></span></td>
                        <td>Yes</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Type</strong></span></td>
                        <td>Boolean</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Default Value</strong></span></td>
                        <td><code class="literal">OFF</code></td>
                    </tr></tbody></table>
                </div>
                <p>
                    Enables or disables periodic output for the standard
                    <code class="literal">InnoDB</code> Monitor. Also used in combination
                    with
                    <a class="link" href="innodb-storage-engine.html#sysvar_innodb_status_output_locks"><code class="literal">innodb_status_output_locks</code></a> to
                    enable or disable periodic output for the
                    <code class="literal">InnoDB</code> Lock Monitor. For more information,
                    see <a class="xref" href="innodb-storage-engine.html#innodb-enabling-monitors" title="14.17.2&nbsp;Enabling InnoDB Monitors">Section&nbsp;14.17.2, “Enabling InnoDB Monitors”</a>.
                </p><p style="color:blue;">启用或禁用标准innodb监视器的周期输出。还与innodb_status_output_locks结合使用，以启用或禁用innodb lock监视器的周期输出。有关更多信息，请参阅14.17.2节，“启用InnoDB监视器”。</p></li><li class="listitem"><p><a name="sysvar_innodb_status_output_locks"></a>
                <a class="indexterm" name="idm140286809238496"></a>

                <a class="indexterm" name="idm140286809237392"></a>

                <code class="literal">innodb_status_output_locks</code>
            </p><p style="color:blue;">innodb_status_output_锁定</p>
                <div class="informaltable">
                    <table frame="box" rules="all" summary="Properties for innodb_status_output_locks"><colgroup><col width="30%"><col width="70%"></colgroup><thead><tr><th scope="col">Property</th>
                        <th scope="col">Value</th>
                    </tr></thead><tbody><tr><td scope="row"><span class="bold"><strong>Command-Line Format</strong></span></td>
                        <td><code class="literal">--innodb-status-output-locks[={OFF|ON}]</code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Introduced</strong></span></td>
                        <td>5.7.4</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>System Variable</strong></span></td>
                        <td><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_status_output_locks">innodb_status_output_locks</a></code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Scope</strong></span></td>
                        <td>Global</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Dynamic</strong></span></td>
                        <td>Yes</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Type</strong></span></td>
                        <td>Boolean</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Default Value</strong></span></td>
                        <td><code class="literal">OFF</code></td>
                    </tr></tbody></table>
                </div>
                <p>
                    Enables or disables the <code class="literal">InnoDB</code> Lock
                    Monitor. When enabled, the <code class="literal">InnoDB</code> Lock
                    Monitor prints additional information about locks in
                    <code class="literal">SHOW ENGINE INNODB STATUS</code> output and in
                    periodic output printed to the MySQL error log. Periodic
                    output for the <code class="literal">InnoDB</code> Lock Monitor is
                    printed as part of the standard <code class="literal">InnoDB</code>
                    Monitor output. The standard <code class="literal">InnoDB</code> Monitor
                    must therefore be enabled for the <code class="literal">InnoDB</code>
                    Lock Monitor to print data to the MySQL error log
                    periodically. For more information, see
                    <a class="xref" href="innodb-storage-engine.html#innodb-enabling-monitors" title="14.17.2&nbsp;Enabling InnoDB Monitors">Section&nbsp;14.17.2, “Enabling InnoDB Monitors”</a>.
                </p><p style="color:blue;">启用或禁用InnoDB锁定监视器。启用时，innodb lock monitor在show engine innodb status output和打印到mysql错误日志的定期输出中打印关于锁的附加信息。innodb lock monitor的周期性输出作为标准innodb monitor输出的一部分打印出来。因此，必须启用标准innodb监视器，innodb lock监视器才能定期将数据打印到mysql错误日志中。有关更多信息，请参阅14.17.2节，“启用InnoDB监视器”。</p></li><li class="listitem"><p><a name="sysvar_innodb_strict_mode"></a>
                <a class="indexterm" name="idm140286809200880"></a>

                <a class="indexterm" name="idm140286809199840"></a>

                <code class="literal">innodb_strict_mode</code>
            </p><p style="color:blue;">innodb_strict_模式</p>
                <div class="informaltable">
                    <table frame="box" rules="all" summary="Properties for innodb_strict_mode"><colgroup><col width="30%"><col width="70%"></colgroup><thead><tr><th scope="col">Property</th>
                        <th scope="col">Value</th>
                    </tr></thead><tbody><tr><td scope="row"><span class="bold"><strong>Command-Line Format</strong></span></td>
                        <td><code class="literal">--innodb-strict-mode[={OFF|ON}]</code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>System Variable</strong></span></td>
                        <td><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_strict_mode">innodb_strict_mode</a></code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Scope</strong></span></td>
                        <td>Global, Session</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Dynamic</strong></span></td>
                        <td>Yes</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Type</strong></span></td>
                        <td>Boolean</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Default Value</strong></span> (&gt;= 5.7.7)</td>
                        <td><code class="literal">ON</code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Default Value</strong></span> (&lt;= 5.7.6)</td>
                        <td><code class="literal">OFF</code></td>
                    </tr></tbody></table>
                </div>
                <p>
                    When <code class="literal">innodb_strict_mode</code> is enabled,
                    <code class="literal">InnoDB</code> returns errors rather than warnings
                    for certain conditions.
                </p><p style="color:blue;">当启用innodb_strict_mode时，innodb在某些情况下返回错误而不是警告。</p><p>
                    <a class="link" href="glossary.html#glos_strict_mode" title="strict mode">Strict mode</a> helps
                    guard against ignored typos and syntax errors in SQL, or other
                    unintended consequences of various combinations of operational
                    modes and SQL statements. When
                    <code class="literal">innodb_strict_mode</code> is enabled,
                    <code class="literal">InnoDB</code> raises error conditions in certain
                    cases, rather than issuing a warning and processing the
                    specified statement (perhaps with unintended behavior). This
                    is analogous to
                    <a class="link" href="server-administration.html#sql-mode" title="5.1.10&nbsp;Server SQL Modes"><code class="literal">sql_mode</code></a> in
                    MySQL, which controls what SQL syntax MySQL accepts, and
                    determines whether it silently ignores errors, or validates
                    input syntax and data values.
                </p><p style="color:blue;">严格模式有助于防止SQL中被忽略的输入错误和语法错误，或各种操作模式和SQL语句组合的其他意外后果。当启用innodb_strict_mode时，innodb在某些情况下会引发错误条件，而不是发出警告并处理指定的语句（可能会出现意外行为）。这类似于mysql中的sql_模式，该模式控制mysql接受的sql语法，并确定它是自动忽略错误，还是验证输入语法和数据值。</p><p>
                    The <code class="literal">innodb_strict_mode</code> setting affects the
                    handling of syntax errors for <a class="link" href="sql-syntax.html#create-table" title="13.1.18&nbsp;CREATE TABLE Syntax"><code class="literal">CREATE
                    TABLE</code></a>, <a class="link" href="sql-syntax.html#alter-table" title="13.1.8&nbsp;ALTER TABLE Syntax"><code class="literal">ALTER TABLE</code></a>,
                    <a class="link" href="sql-syntax.html#create-index" title="13.1.14&nbsp;CREATE INDEX Syntax"><code class="literal">CREATE INDEX</code></a>, and
                    <a class="link" href="sql-syntax.html#optimize-table" title="13.7.2.4&nbsp;OPTIMIZE TABLE Syntax"><code class="literal">OPTIMIZE TABLE</code></a> statements.
                    <code class="literal">innodb_strict_mode</code> also enables a record
                    size check, so that an <code class="literal">INSERT</code> or
                    <code class="literal">UPDATE</code> never fails due to the record being
                    too large for the selected page size.
                </p><p style="color:blue;">innodb_strict_mode设置影响对create table、alter table、create index和optimize table语句语法错误的处理。innodb_strict_mode还启用了记录大小检查，因此插入或更新不会由于记录对于所选页面大小太大而失败。</p><p>
                    Oracle recommends enabling
                    <code class="literal">innodb_strict_mode</code> when using
                    <code class="literal">ROW_FORMAT</code> and
                    <code class="literal">KEY_BLOCK_SIZE</code> clauses in
                    <a class="link" href="sql-syntax.html#create-table" title="13.1.18&nbsp;CREATE TABLE Syntax"><code class="literal">CREATE TABLE</code></a>,
                    <a class="link" href="sql-syntax.html#alter-table" title="13.1.8&nbsp;ALTER TABLE Syntax"><code class="literal">ALTER TABLE</code></a>, and
                    <a class="link" href="sql-syntax.html#create-index" title="13.1.14&nbsp;CREATE INDEX Syntax"><code class="literal">CREATE INDEX</code></a> statements. When
                    <code class="literal">innodb_strict_mode</code> is disabled,
                    <code class="literal">InnoDB</code> ignores conflicting clauses and
                    creates the table or index with only a warning in the message
                    log. The resulting table might have different characteristics
                    than intended, such as lack of compression support when
                    attempting to create a compressed table. When
                    <code class="literal">innodb_strict_mode</code> is enabled, such
                    problems generate an immediate error and the table or index is
                    not created.
                </p><p style="color:blue;">oracle建议在create table、alter table和create index语句中使用row_format和key_block_size子句时启用innodb_strict_模式。当innodb_strict_mode被禁用时，innodb会忽略冲突的子句，并在消息日志中创建只有警告的表或索引。生成的表可能具有不同于预期的特性，例如在尝试创建压缩表时缺少压缩支持。启用innodb_strict_mode时，此类问题会立即产生错误，并且不会创建表或索引。</p><p>
                    You can enable or disable
                    <code class="literal">innodb_strict_mode</code> on the command line when
                    starting <code class="literal">mysqld</code>, or in a MySQL
                    <a class="link" href="glossary.html#glos_configuration_file" title="configuration file">configuration
                        file</a>. You can also enable or disable
                    <code class="literal">innodb_strict_mode</code> at runtime with the
                    statement <code class="literal">SET [GLOBAL|SESSION]
                    innodb_strict_mode=<em class="replaceable"><code>mode</code></em></code>,
                    where <code class="literal"><em class="replaceable"><code>mode</code></em></code> is
                    either <code class="literal">ON</code> or <code class="literal">OFF</code>.
                    Changing the <code class="literal">GLOBAL</code> setting requires
                    privileges sufficient to set global system variables (see
                    <a class="xref" href="server-administration.html#system-variable-privileges" title="5.1.8.1&nbsp;System Variable Privileges">Section&nbsp;5.1.8.1, “System Variable Privileges”</a>) and affects the
                    operation of all clients that subsequently connect. Any client
                    can change the <code class="literal">SESSION</code> setting for
                    <code class="literal">innodb_strict_mode</code>, and the setting affects
                    only that client.
                </p><p style="color:blue;">启动mysqld或mysql配置文件时，可以在命令行上启用或禁用innodb_strict_mode。您还可以在运行时启用或禁用innodb_strict_mode，语句集为[global session]innodb_strict_mode=mode，其中mode为on或off。更改全局设置需要足够的权限来设置全局系统变量（请参阅第5.1.8.1节“系统变量权限”），并影响随后连接的所有客户端的操作。任何客户端都可以更改innodb_strict_mode的会话设置，并且该设置仅影响该客户端。</p><p>
                    <a class="link" href="innodb-storage-engine.html#sysvar_innodb_strict_mode"><code class="literal">innodb_strict_mode</code></a> is not
                    applicable to <a class="link" href="glossary.html#glos_general_tablespace" title="general tablespace">general
                    tablespaces</a>. Tablespace management rules for general
                    tablespaces are strictly enforced independently of
                    <a class="link" href="innodb-storage-engine.html#sysvar_innodb_strict_mode"><code class="literal">innodb_strict_mode</code></a>. For more
                    information, see <a class="xref" href="sql-syntax.html#create-tablespace" title="13.1.19&nbsp;CREATE TABLESPACE Syntax">Section&nbsp;13.1.19, “CREATE TABLESPACE Syntax”</a>.
                </p><p style="color:blue;">innodb_strict_mode不适用于一般表空间。一般表空间的表空间管理规则严格执行，独立于innodb_strict_模式。有关更多信息，请参阅第13.1.19节“创建表空间语法”。</p></li><li class="listitem"><p><a name="sysvar_innodb_support_xa"></a>
                <a class="indexterm" name="idm140286809131088"></a>

                <a class="indexterm" name="idm140286809130048"></a>

                <a class="indexterm" name="idm140286809128560"></a>

                <code class="literal">innodb_support_xa</code>
            </p><p style="color:blue;">InnoDB_支持</p>
                <div class="informaltable">
                    <table frame="box" rules="all" summary="Properties for innodb_support_xa"><colgroup><col width="30%"><col width="70%"></colgroup><thead><tr><th scope="col">Property</th>
                        <th scope="col">Value</th>
                    </tr></thead><tbody><tr><td scope="row"><span class="bold"><strong>Command-Line Format</strong></span></td>
                        <td><code class="literal">--innodb-support-xa[={OFF|ON}]</code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Deprecated</strong></span></td>
                        <td>5.7.10</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>System Variable</strong></span></td>
                        <td><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_support_xa">innodb_support_xa</a></code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Scope</strong></span></td>
                        <td>Global, Session</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Dynamic</strong></span></td>
                        <td>Yes</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Type</strong></span></td>
                        <td>Boolean</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Default Value</strong></span></td>
                        <td><code class="literal">ON</code></td>
                    </tr></tbody></table>
                </div>
                <p>
                    Enables <code class="literal">InnoDB</code> support for two-phase commit
                    in <a class="link" href="glossary.html#glos_xa" title="XA">XA</a> transactions, causing an
                    extra disk flush for transaction preparation. The XA mechanism
                    is used internally and is essential for any server that has
                    its binary log turned on and is accepting changes to its data
                    from more than one thread. If you disable
                    <code class="literal">innodb_support_xa</code>, transactions can be
                    written to the binary log in a different order than the live
                    database is committing them, which can produce different data
                    when the binary log is replayed in disaster recovery or on a
                    replication slave. Do not disable
                    <code class="literal">innodb_support_xa</code> on a replication master
                    server unless you have an unusual setup where only one thread
                    is able to change data.
                </p><p style="color:blue;">在xa事务中启用innodb对两阶段提交的支持，从而为事务准备带来额外的磁盘刷新。xa机制在内部使用，对于打开二进制日志并接受来自多个线程的数据更改的任何服务器都是必不可少的。如果禁用innodb_support_xa，事务可以以不同于实时数据库提交事务的顺序写入二进制日志，当在灾难恢复或复制从机上重放二进制日志时，会产生不同的数据。不要在复制主服务器上禁用innodb_support_xa，除非您有一个不寻常的设置，其中只有一个线程能够更改数据。</p><p>
                    <code class="literal">innodb_support_xa</code> is deprecated and will be
                    removed in a future MySQL release. <code class="literal">InnoDB</code>
                    support for two-phase commit in XA transactions is always
                    enabled as of MySQL 5.7.10. Disabling
                    <a class="link" href="innodb-storage-engine.html#sysvar_innodb_support_xa"><code class="literal">innodb_support_xa</code></a> is no
                    longer permitted as it makes replication unsafe and prevents
                    performance gains associated with binary log group commit.
                </p><p style="color:blue;">innodb_support_xa已弃用，将在未来的mysql版本中删除。从mysql 5.7.10开始，innodb支持xa事务中的两阶段提交。不再允许禁用innodb_support_xa，因为它会使复制不安全，并防止与二进制日志组提交相关联的性能提高。</p></li><li class="listitem"><p><a name="sysvar_innodb_sync_array_size"></a>
                <a class="indexterm" name="idm140286809091584"></a>

                <code class="literal">innodb_sync_array_size</code>
            </p><p style="color:blue;">innodb_sync_array_大小</p>
                <div class="informaltable">
                    <table frame="box" rules="all" summary="Properties for innodb_sync_array_size"><colgroup><col width="30%"><col width="70%"></colgroup><thead><tr><th scope="col">Property</th>
                        <th scope="col">Value</th>
                    </tr></thead><tbody><tr><td scope="row"><span class="bold"><strong>Command-Line Format</strong></span></td>
                        <td><code class="literal">--innodb-sync-array-size=#</code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>System Variable</strong></span></td>
                        <td><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_sync_array_size">innodb_sync_array_size</a></code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Scope</strong></span></td>
                        <td>Global</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Dynamic</strong></span></td>
                        <td>No</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Type</strong></span></td>
                        <td>Integer</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Default Value</strong></span></td>
                        <td><code class="literal">1</code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Minimum Value</strong></span></td>
                        <td><code class="literal">1</code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Maximum Value</strong></span></td>
                        <td><code class="literal">1024</code></td>
                    </tr></tbody></table>
                </div>
                <p>
                    Defines the size of the mutex/lock wait array. Increasing the
                    value splits the internal data structure used to coordinate
                    threads, for higher concurrency in workloads with large
                    numbers of waiting threads. This setting must be configured
                    when the MySQL instance is starting up, and cannot be changed
                    afterward. Increasing the value is recommended for workloads
                    that frequently produce a large number of waiting threads,
                    typically greater than 768.
                </p><p style="color:blue;">定义互斥/锁定等待数组的大小。增加该值将拆分用于协调线程的内部数据结构，以提高具有大量等待线程的工作负载的并发性。此设置必须在mysql实例启动时配置，并且之后不能更改。对于经常产生大量等待线程（通常大于768）的工作负载，建议增加该值。</p></li><li class="listitem"><p><a name="sysvar_innodb_sync_spin_loops"></a>
                <a class="indexterm" name="idm140286809057744"></a>

                <a class="indexterm" name="idm140286809056704"></a>

                <code class="literal">innodb_sync_spin_loops</code>
            </p><p style="color:blue;">innodb_sync_spin_环路</p>
                <div class="informaltable">
                    <table frame="box" rules="all" summary="Properties for innodb_sync_spin_loops"><colgroup><col width="30%"><col width="70%"></colgroup><thead><tr><th scope="col">Property</th>
                        <th scope="col">Value</th>
                    </tr></thead><tbody><tr><td scope="row"><span class="bold"><strong>Command-Line Format</strong></span></td>
                        <td><code class="literal">--innodb-sync-spin-loops=#</code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>System Variable</strong></span></td>
                        <td><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_sync_spin_loops">innodb_sync_spin_loops</a></code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Scope</strong></span></td>
                        <td>Global</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Dynamic</strong></span></td>
                        <td>Yes</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Type</strong></span></td>
                        <td>Integer</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Default Value</strong></span></td>
                        <td><code class="literal">30</code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Minimum Value</strong></span></td>
                        <td><code class="literal">0</code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Maximum Value</strong></span></td>
                        <td><code class="literal">4294967295</code></td>
                    </tr></tbody></table>
                </div>
                <p>
                    The number of times a thread waits for an
                    <code class="literal">InnoDB</code> mutex to be freed before the thread
                    is suspended.
                </p><p style="color:blue;">线程在挂起线程之前等待释放innodb互斥的次数。</p></li><li class="listitem"><p><a name="sysvar_innodb_sync_debug"></a>
                <a class="indexterm" name="idm140286809022176"></a>

                <a class="indexterm" name="idm140286809021104"></a>

                <code class="literal">innodb_sync_debug</code>
            </p><p style="color:blue;">InnoDB同步调试</p>
                <div class="informaltable">
                    <table frame="box" rules="all" summary="Properties for innodb_sync_debug"><colgroup><col width="30%"><col width="70%"></colgroup><thead><tr><th scope="col">Property</th>
                        <th scope="col">Value</th>
                    </tr></thead><tbody><tr><td scope="row"><span class="bold"><strong>Command-Line Format</strong></span></td>
                        <td><code class="literal">--innodb-sync-debug[={OFF|ON}]</code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Introduced</strong></span></td>
                        <td>5.7.8</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>System Variable</strong></span></td>
                        <td><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_sync_debug">innodb_sync_debug</a></code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Scope</strong></span></td>
                        <td>Global</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Dynamic</strong></span></td>
                        <td>No</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Type</strong></span></td>
                        <td>Boolean</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Default Value</strong></span></td>
                        <td><code class="literal">OFF</code></td>
                    </tr></tbody></table>
                </div>
                <p>
                    Enables sync debug checking for the <code class="literal">InnoDB</code>
                    storage engine. This option is only available if debugging
                    support is compiled in using the
                    <a class="link" href="installing.html#option_cmake_with_debug"><code class="option">WITH_DEBUG</code></a>
                    <span class="command"><strong>CMake</strong></span> option.
                </p><p style="color:blue;">启用InnoDB存储引擎的同步调试检查。只有在使用with_debug cmake选项编译调试支持时，此选项才可用。</p><p>
                    Previously, enabling <code class="literal">InnoDB</code> sync debug
                    checking required that the Debug Sync facility be enabled
                    using the <a class="link" href="installing.html#option_cmake_enable_debug_sync"><code class="option">ENABLE_DEBUG_SYNC</code></a>
                    <span class="command"><strong>CMake</strong></span> option. This requirement was removed
                    in MySQL 5.7 with the introduction of this
                    variable.
                </p><p style="color:blue;">以前，启用innodb sync调试检查需要使用enable_debug_sync cmake选项启用调试同步功能。随着这个变量的引入，mysql 5.7中删除了这个需求。</p></li><li class="listitem"><p><a name="sysvar_innodb_table_locks"></a>
                <a class="indexterm" name="idm140286808985328"></a>

                <a class="indexterm" name="idm140286808984288"></a>

                <code class="literal">innodb_table_locks</code>
            </p><p style="color:blue;">innodb_table_锁</p>
                <div class="informaltable">
                    <table frame="box" rules="all" summary="Properties for innodb_table_locks"><colgroup><col width="30%"><col width="70%"></colgroup><thead><tr><th scope="col">Property</th>
                        <th scope="col">Value</th>
                    </tr></thead><tbody><tr><td scope="row"><span class="bold"><strong>Command-Line Format</strong></span></td>
                        <td><code class="literal">--innodb-table-locks[={OFF|ON}]</code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>System Variable</strong></span></td>
                        <td><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_table_locks">innodb_table_locks</a></code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Scope</strong></span></td>
                        <td>Global, Session</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Dynamic</strong></span></td>
                        <td>Yes</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Type</strong></span></td>
                        <td>Boolean</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Default Value</strong></span></td>
                        <td><code class="literal">ON</code></td>
                    </tr></tbody></table>
                </div>
                <p>
                    If <a class="link" href="server-administration.html#sysvar_autocommit"><code class="literal">autocommit = 0</code></a>,
                    <code class="literal">InnoDB</code> honors <a class="link" href="sql-syntax.html#lock-tables" title="13.3.5&nbsp;LOCK TABLES and UNLOCK TABLES Syntax"><code class="literal">LOCK
                    TABLES</code></a>; MySQL does not return from <code class="literal">LOCK
                    TABLES ... WRITE</code> until all other threads have
                    released all their locks to the table. The default value of
                    <a class="link" href="innodb-storage-engine.html#sysvar_innodb_table_locks"><code class="literal">innodb_table_locks</code></a> is 1,
                    which means that <a class="link" href="sql-syntax.html#lock-tables" title="13.3.5&nbsp;LOCK TABLES and UNLOCK TABLES Syntax"><code class="literal">LOCK TABLES</code></a>
                    causes InnoDB to lock a table internally if
                    <a class="link" href="server-administration.html#sysvar_autocommit"><code class="literal">autocommit = 0</code></a>.
                </p><p style="color:blue;">如果autocommit=0，innodb支持锁表；mysql不从锁表返回……写入，直到所有其他线程都释放了对表的所有锁。innodb_table_locks的默认值是1，这意味着如果autocommit=0，lock tables会导致innodb在内部锁定一个表。</p><p>
                    In MySQL 5.7,
                    <a class="link" href="innodb-storage-engine.html#sysvar_innodb_table_locks"><code class="literal">innodb_table_locks = 0</code></a> has no
                    effect for tables locked explicitly with
                    <a class="link" href="sql-syntax.html#lock-tables" title="13.3.5&nbsp;LOCK TABLES and UNLOCK TABLES Syntax"><code class="literal">LOCK TABLES ...
                        WRITE</code></a>. It does have an effect for tables locked for
                    read or write by
                    <a class="link" href="sql-syntax.html#lock-tables" title="13.3.5&nbsp;LOCK TABLES and UNLOCK TABLES Syntax"><code class="literal">LOCK TABLES ...
                        WRITE</code></a> implicitly (for example, through triggers) or
                    by <a class="link" href="sql-syntax.html#lock-tables" title="13.3.5&nbsp;LOCK TABLES and UNLOCK TABLES Syntax"><code class="literal">LOCK TABLES
                    ... READ</code></a>.
                </p><p style="color:blue;">在mysql 5.7中，innodb_table_locks=0对用锁表显式锁定的表没有影响…写。它确实对为读或写而锁定的表有影响…隐式写入（例如，通过触发器）或通过锁表写入…阅读。</p><p>
                    For related information, see
                    <a class="xref" href="innodb-storage-engine.html#innodb-locking-transaction-model" title="14.7&nbsp;InnoDB Locking and Transaction Model">Section&nbsp;14.7, “InnoDB Locking and Transaction Model”</a>.
                </p><p style="color:blue;">有关信息，请参阅14.7节，“InnoDB锁定和事务模型”。</p></li><li class="listitem"><p><a name="sysvar_innodb_temp_data_file_path"></a>
                <a class="indexterm" name="idm140286808942096"></a>

                <a class="indexterm" name="idm140286808940992"></a>

                <code class="literal">innodb_temp_data_file_path</code>
            </p><p style="color:blue;">innodb_temp_data_file_路径</p>
                <div class="informaltable">
                    <table frame="box" rules="all" summary="Properties for innodb_temp_data_file_path"><colgroup><col width="30%"><col width="70%"></colgroup><thead><tr><th scope="col">Property</th>
                        <th scope="col">Value</th>
                    </tr></thead><tbody><tr><td scope="row"><span class="bold"><strong>Command-Line Format</strong></span></td>
                        <td><code class="literal">--innodb-temp-data-file-path=file_name</code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Introduced</strong></span></td>
                        <td>5.7.1</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>System Variable</strong></span></td>
                        <td><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_temp_data_file_path">innodb_temp_data_file_path</a></code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Scope</strong></span></td>
                        <td>Global</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Dynamic</strong></span></td>
                        <td>No</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Type</strong></span></td>
                        <td>String</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Default Value</strong></span></td>
                        <td><code class="literal">ibtmp1:12M:autoextend</code></td>
                    </tr></tbody></table>
                </div>
                <p>
                    Defines the relative path, name, size, and attributes of
                    <code class="literal">InnoDB</code>
                    <a class="link" href="glossary.html#glos_temporary_tablespace" title="temporary tablespace">temporary
                        tablespace</a> <a class="link" href="glossary.html#glos_data_files" title="data files">data
                    files</a>. If you do not specify a value for
                    <a class="link" href="innodb-storage-engine.html#sysvar_innodb_temp_data_file_path"><code class="literal">innodb_temp_data_file_path</code></a>,
                    the default behavior is to create a single, auto-extending
                    data file named <code class="filename">ibtmp1</code> in the MySQL data
                    directory. The initial file size is slightly larger than 12MB.
                </p><p style="color:blue;">定义innodb临时表空间数据文件的相对路径、名称、大小和属性。如果没有为innodb_temp_data_file_path指定值，默认行为是在mysql数据目录中创建一个名为ibtmp1的自动扩展数据文件。初始文件大小略大于12MB。</p><p>
                    The full syntax for a temporary tablespace data file
                    specification includes the file name, file size, and
                    <code class="literal">autoextend</code> and <code class="literal">max</code>
                    attributes:
                </p><p style="color:blue;">临时表空间数据文件规范的完整语法包括文件名、文件大小、autoextend和max属性：</p><pre data-lang="none" class="programlisting"><em class="replaceable"><code>file_name</code></em>:<em class="replaceable"><code>file_size</code></em>[:autoextend[:max:<em class="replaceable"><code>max_file_size</code></em>]]
</pre><p>
                    The temporary tablespace data file cannot have the same name
                    as another <code class="literal">InnoDB</code> data file. Any inability
                    or error creating a temporary tablespace data file is treated
                    as fatal and server startup is refused. The temporary
                    tablespace has a dynamically generated space ID, which can
                    change on each server restart.
                </p><p style="color:blue;">临时表空间数据文件不能与另一个innodb数据文件同名。创建临时表空间数据文件时的任何失败或错误都将被视为致命错误，服务器启动将被拒绝。临时表空间有一个动态生成的空间id，它可以在每次服务器重新启动时更改。</p><p>
                    File sizes are specified KB, MB or GB (1024MB) by appending
                    <code class="literal">K</code>, <code class="literal">M</code> or
                    <code class="literal">G</code> to the size value. The sum of the sizes
                    of the files must be slightly larger than 12MB.
                </p><p style="color:blue;">文件大小是通过在大小值后面附加k、m或g来指定的KB、MB或GB（1024MB）。文件大小之和必须略大于12MB。</p><p>
                    The size limit of individual files is determined by your
                    operating system. You can set the file size to more than 4GB
                    on operating systems that support large files. Use of raw disk
                    partitions for temporary tablespace data files is not
                    supported.
                </p><p style="color:blue;">单个文件的大小限制由您的操作系统决定。在支持大文件的操作系统上，可以将文件大小设置为大于4GB。不支持对临时表空间数据文件使用原始磁盘分区。</p><p>
                    The <code class="literal">autoextend</code> and <code class="literal">max</code>
                    attributes can be used only for the data file that is
                    specified last in the
                    <a class="link" href="innodb-storage-engine.html#sysvar_innodb_temp_data_file_path"><code class="literal">innodb_temp_data_file_path</code></a>
                    setting. For example:
                </p><p style="color:blue;">autoextend和max属性只能用于innodb_temp_data_file_path设置中最后指定的数据文件。例如：</p><pre data-lang="ini" class="programlisting">[mysqld]
innodb_temp_data_file_path=ibtmp1:50M;ibtmp2:12M:autoextend:max:500MB
</pre><p>
                    If you specify the <code class="literal">autoextend</code> option,
                    <code class="literal">InnoDB</code> extends the data file if it runs out
                    of free space. The <code class="literal">autoextend</code> increment is
                    64MB by default. To modify the increment, change the
                    <a class="link" href="innodb-storage-engine.html#sysvar_innodb_autoextend_increment"><code class="literal">innodb_autoextend_increment</code></a>
                    system variable.
                </p><p style="color:blue;">如果指定autoextend选项，innodb会在数据文件耗尽可用空间时对其进行扩展。默认情况下，自动扩展增量为64MB。要修改增量，请更改innodb_autoextend_increment系统变量。</p><p>
                    The full directory path for temporary tablespace data files is
                    formed by concatenating the paths defined by
                    <a class="link" href="innodb-storage-engine.html#sysvar_innodb_data_home_dir"><code class="literal">innodb_data_home_dir</code></a> and
                    <a class="link" href="innodb-storage-engine.html#sysvar_innodb_temp_data_file_path"><code class="literal">innodb_temp_data_file_path</code></a>.
                </p><p style="color:blue;">临时表空间数据文件的完整目录路径是通过连接innodb_data_home_dir和innodb_temp_data_file_path定义的路径形成的。</p><p>
                    The temporary tablespace is shared by all non-compressed
                    <code class="literal">InnoDB</code> temporary tables. Compressed
                    temporary tables reside in file-per-table tablespace files
                    created in the temporary file directory, which is defined by
                    the <a class="link" href="server-administration.html#sysvar_tmpdir"><code class="literal">tmpdir</code></a> configuration
                    option.
                </p><p style="color:blue;">临时表空间由所有未压缩的innodb临时表共享。压缩的临时表位于临时文件目录（由tmpdir配置选项定义）中创建的逐表文件表空间文件中。</p><p>
                    Before running <code class="literal">InnoDB</code> in read-only mode,
                    set
                    <a class="link" href="innodb-storage-engine.html#sysvar_innodb_temp_data_file_path"><code class="literal">innodb_temp_data_file_path</code></a> to
                    a location outside of the data directory. The path must be
                    relative to the data directory. For example:
                </p><p style="color:blue;">在以只读模式运行innodb之前，请将innodb临时数据文件路径设置为数据目录之外的位置。路径必须相对于数据目录。例如：</p><pre data-lang="terminal" class="programlisting">--innodb-temp-data-file-path=../../../tmp/ibtmp1:12M:autoextend
</pre><p>
                    Metadata about active <code class="literal">InnoDB</code> temporary
                    tables is located in
                    <a class="link" href="information-schema.html#innodb-temp-table-info-table" title="24.32.25&nbsp;The INFORMATION_SCHEMA INNODB_TEMP_TABLE_INFO Table"><code class="literal">INFORMATION_SCHEMA.INNODB_TEMP_TABLE_INFO</code></a>.
                </p><p style="color:blue;">有关活动innodb临时表的元数据位于information-schema.innodb-temp-table-info中。</p><p>
                    For related information, see
                    <a class="xref" href="innodb-storage-engine.html#innodb-temporary-tablespace" title="14.6.3.5&nbsp;The Temporary Tablespace">Section&nbsp;14.6.3.5, “The Temporary Tablespace”</a>.
                </p><p style="color:blue;">有关信息，请参阅第14.6.3.5节“临时表空间”。</p></li><li class="listitem"><p><a name="sysvar_innodb_thread_concurrency"></a>
                <a class="indexterm" name="idm140286808875840"></a>

                <a class="indexterm" name="idm140286808874736"></a>

                <a class="indexterm" name="idm140286808873280"></a>

                <code class="literal">innodb_thread_concurrency</code>
            </p><p style="color:blue;">innodb_线程并发</p>
                <div class="informaltable">
                    <table frame="box" rules="all" summary="Properties for innodb_thread_concurrency"><colgroup><col width="30%"><col width="70%"></colgroup><thead><tr><th scope="col">Property</th>
                        <th scope="col">Value</th>
                    </tr></thead><tbody><tr><td scope="row"><span class="bold"><strong>Command-Line Format</strong></span></td>
                        <td><code class="literal">--innodb-thread-concurrency=#</code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>System Variable</strong></span></td>
                        <td><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_thread_concurrency">innodb_thread_concurrency</a></code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Scope</strong></span></td>
                        <td>Global</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Dynamic</strong></span></td>
                        <td>Yes</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Type</strong></span></td>
                        <td>Integer</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Default Value</strong></span></td>
                        <td><code class="literal">0</code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Minimum Value</strong></span></td>
                        <td><code class="literal">0</code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Maximum Value</strong></span></td>
                        <td><code class="literal">1000</code></td>
                    </tr></tbody></table>
                </div>
                <p>
                    <code class="literal">InnoDB</code> tries to keep the number of
                    operating system threads concurrently inside
                    <code class="literal">InnoDB</code> less than or equal to the limit
                    given by this variable (<code class="literal">InnoDB</code> uses
                    operating system threads to process user transactions). Once
                    the number of threads reaches this limit, additional threads
                    are placed into a wait state within a <span class="quote">“<span class="quote">First In, First
          Out</span>”</span> (FIFO) queue for execution. Threads waiting for
                    locks are not counted in the number of concurrently executing
                    threads.
                </p><p style="color:blue;">innodb试图使innodb内并发的操作系统线程数小于或等于该变量所给出的限制（innodb使用操作系统线程来处理用户事务）。一旦线程数达到此限制，额外的线程将被置于“先进先出”（fifo）队列中等待执行。等待锁定的线程不计入并发执行的线程数。</p><p>
                    The range of this variable is 0 to 1000. A value of 0 (the
                    default) is interpreted as infinite concurrency (no
                    concurrency checking). Disabling thread concurrency checking
                    enables <code class="literal">InnoDB</code> to create as many threads as
                    it needs. A value of 0 also disables the <code class="literal">queries
                    inside InnoDB</code> and <code class="literal">queries in queue
                    counters</code> in the <code class="literal">ROW OPERATIONS</code>
                    section of <code class="literal">SHOW ENGINE INNODB STATUS</code>
                    output.
                </p><p style="color:blue;">这个变量的范围是0到1000。值0（默认值）被解释为无限并发（无并发检查）。禁用线程并发检查使innodb能够根据需要创建尽可能多的线程。值为0还会禁用innodb内的查询和show engine innodb status output的row operations部分的queue counters中的查询。</p><p>
                    Consider setting this variable if your MySQL instance shares
                    CPU resources with other applications, or if your workload or
                    number of concurrent users is growing. The correct setting
                    depends on workload, computing environment, and the version of
                    MySQL that you are running. You will need to test a range of
                    values to determine the setting that provides the best
                    performance. <code class="literal">innodb_thread_concurrency</code> is a
                    dynamic variable, which allows you to experiment with
                    different settings on a live test system. If a particular
                    setting performs poorly, you can quickly set
                    <code class="literal">innodb_thread_concurrency</code> back to 0.
                </p><p style="color:blue;">如果您的mysql实例与其他应用程序共享cpu资源，或者如果您的工作负载或并发用户数量正在增长，请考虑设置此变量。正确的设置取决于工作负载、计算环境和正在运行的mysql版本。您需要测试一系列值，以确定提供最佳性能的设置。innodb_thread_concurrency是一个动态变量，它允许您在实时测试系统上尝试不同的设置。如果某个特定设置执行得不好，可以快速将innodb_thread_concurrency设置回0。</p><p>
                    Use the following guidelines to help find and maintain an
                    appropriate setting:
                </p><p style="color:blue;">使用以下指南帮助查找和维护适当的设置：</p>
                <div class="itemizedlist">
                    <ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
                        If the number of concurrent user threads for a workload is
                        less than 64, set
                        <code class="literal">innodb_thread_concurrency=0</code>.
                    </p><p style="color:blue;">如果工作负载的并发用户线程数小于64，则将innodb_thread_concurrency设置为0。</p></li><li class="listitem"><p>
                        If your workload is consistently heavy or occasionally
                        spikes, start by setting
                        <code class="literal">innodb_thread_concurrency=128</code> and then
                        lowering the value to 96, 80, 64, and so on, until you
                        find the number of threads that provides the best
                        performance. Suppose that your system typically has 40 to
                        50 users, but periodically the number increases to 60, 70,
                        or even 200. You find that performance is stable at 80
                        concurrent users but starts to show a regression above
                        this number. In this case, you would set
                        <code class="literal">innodb_thread_concurrency=80</code> to avoid
                        impacting performance.
                    </p><p style="color:blue;">如果您的工作负载一直很重，或者偶尔会出现峰值，那么首先设置innodb_thread_concurrency=128，然后将该值降低到96、80、64，依此类推，直到找到提供最佳性能的线程数。假设您的系统通常有40到50个用户，但是周期性地增加到60、70甚至200个。您发现性能在80个并发用户时是稳定的，但开始显示高于此数字的回归。在这种情况下，您可以将innodb_thread_concurrency设置为80，以避免影响性能。</p></li><li class="listitem"><p>
                        If you do not want <code class="literal">InnoDB</code> to use more
                        than a certain number of virtual CPUs for user threads (20
                        virtual CPUs, for example), set
                        <code class="literal">innodb_thread_concurrency</code> to this
                        number (or possibly lower, depending on performance
                        results). If your goal is to isolate MySQL from other
                        applications, you may consider binding the
                        <code class="literal">mysqld</code> process exclusively to the
                        virtual CPUs. Be aware, however, that exclusive binding
                        could result in non-optimal hardware usage if the
                        <code class="literal">mysqld</code> process is not consistently
                        busy. In this case, you might bind the
                        <code class="literal">mysqld</code> process to the virtual CPUs but
                        also allow other applications to use some or all of the
                        virtual CPUs.
                    </p><p style="color:blue;">如果您不希望innodb为用户线程使用超过一定数量的虚拟cpu（例如20个虚拟cpu），请将innodb_thread_concurrency设置为该数量（或者可能更低，具体取决于性能结果）。如果您的目标是将mysql与其他应用程序隔离开来，那么可以考虑将mysqld进程专门绑定到虚拟cpu。但是，请注意，如果mysqld进程不总是很忙，则排他绑定可能会导致非最佳硬件使用。在这种情况下，您可以将mysqld进程绑定到虚拟cpu，但也允许其他应用程序使用部分或全部虚拟cpu。</p>
                        <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">

                            <div class="admon-title">
                                Note
                            </div>
                            <p>
                                From an operating system perspective, using a resource
                                management solution to manage how CPU time is shared
                                among applications may be preferable to binding the
                                <code class="literal">mysqld</code> process. For example, you
                                could assign 90% of virtual CPU time to a given
                                application while other critical processes <span class="emphasis"><em>are
                not</em></span> running, and scale that value back to 40%
                                when other critical processes <span class="emphasis"><em>are</em></span>
                                running.
                            </p><p style="color:blue;">从操作系统的角度来看，使用资源管理解决方案来管理应用程序之间如何共享cpu时间可能比绑定mysqld进程更好。例如，可以在其他关键进程未运行时将90%的虚拟CPU时间分配给给定的应用程序，并在其他关键进程运行时将该值缩放回40%。</p>
                        </div>
                    </li><li class="listitem"><p>
                        <code class="literal">innodb_thread_concurrency</code> values that
                        are too high can cause performance regression due to
                        increased contention on system internals and resources.
                    </p><p style="color:blue;">innodb_thread_并发值太高可能会由于系统内部和资源的争用增加而导致性能回归。</p></li><li class="listitem"><p>
                        In some cases, the optimal
                        <code class="literal">innodb_thread_concurrency</code> setting can
                        be smaller than the number of virtual CPUs.
                    </p><p style="color:blue;">在某些情况下，最佳的innodb_thread_并发设置可以小于虚拟cpu的数量。</p></li><li class="listitem"><p>
                        Monitor and analyze your system regularly. Changes to
                        workload, number of users, or computing environment may
                        require that you adjust the
                        <code class="literal">innodb_thread_concurrency</code> setting.
                    </p><p style="color:blue;">定期监控和分析你的系统。对工作负载、用户数或计算环境的更改可能需要调整innodb_thread_concurrency设置。</p></li></ul>
                </div>
                <p>
                    For related information, see
                    <a class="xref" href="innodb-storage-engine.html#innodb-performance-thread_concurrency" title="14.8.5&nbsp;Configuring Thread Concurrency for InnoDB">Section&nbsp;14.8.5, “Configuring Thread Concurrency for InnoDB”</a>.
                </p><p style="color:blue;">有关信息，请参阅14.8.5节“为InnoDB配置线程并发”。</p></li><li class="listitem"><p><a name="sysvar_innodb_thread_sleep_delay"></a>
                <a class="indexterm" name="idm140286808809968"></a>

                <a class="indexterm" name="idm140286808808864"></a>

                <code class="literal">innodb_thread_sleep_delay</code>
            </p><p style="color:blue;">InnoDB_线程睡眠延迟</p>
                <div class="informaltable">
                    <table frame="box" rules="all" summary="Properties for innodb_thread_sleep_delay"><colgroup><col width="30%"><col width="70%"></colgroup><thead><tr><th scope="col">Property</th>
                        <th scope="col">Value</th>
                    </tr></thead><tbody><tr><td scope="row"><span class="bold"><strong>Command-Line Format</strong></span></td>
                        <td><code class="literal">--innodb-thread-sleep-delay=#</code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>System Variable</strong></span></td>
                        <td><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_thread_sleep_delay">innodb_thread_sleep_delay</a></code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Scope</strong></span></td>
                        <td>Global</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Dynamic</strong></span></td>
                        <td>Yes</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Type</strong></span></td>
                        <td>Integer</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Default Value</strong></span></td>
                        <td><code class="literal">10000</code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Minimum Value</strong></span></td>
                        <td><code class="literal">0</code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Maximum Value</strong></span> (64-bit platforms, &lt;= 5.7.3)</td>
                        <td><code class="literal">18446744073709551615</code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Maximum Value</strong></span> (32-bit platforms, &lt;= 5.7.3)</td>
                        <td><code class="literal">4294967295</code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Maximum Value</strong></span> (&gt;= 5.7.4)</td>
                        <td><code class="literal">1000000</code></td>
                    </tr></tbody></table>
                </div>
                <p>
                    Defines how long <code class="literal">InnoDB</code> threads sleep
                    before joining the <code class="literal">InnoDB</code> queue, in
                    microseconds. The default value is 10000. A value of 0
                    disables sleep. You can set
                    <a class="link" href="innodb-storage-engine.html#sysvar_innodb_adaptive_max_sleep_delay"><code class="literal">innodb_adaptive_max_sleep_delay</code></a>
                    to the highest value you would allow for
                    <code class="literal">innodb_thread_sleep_delay</code>, and
                    <code class="literal">InnoDB</code> automatically adjusts
                    <code class="literal">innodb_thread_sleep_delay</code> up or down
                    depending on current thread-scheduling activity. This dynamic
                    adjustment helps the thread scheduling mechanism to work
                    smoothly during times when the system is lightly loaded or
                    when it is operating near full capacity.
                </p><p style="color:blue;">定义innodb线程在加入innodb队列之前睡眠的时间（微秒）。默认值为10000。值为0将禁用睡眠。您可以将innodb_adaptive_max_sleep_delay设置为innodb_thread_sleep_delay允许的最大值，innodb会根据当前的线程调度活动自动上下调整innodb_thread_sleep_delay。这种动态调整有助于线程调度机制在系统负载较轻或接近满负荷运行时顺利工作。</p><p>
                    For more information, see
                    <a class="xref" href="innodb-storage-engine.html#innodb-performance-thread_concurrency" title="14.8.5&nbsp;Configuring Thread Concurrency for InnoDB">Section&nbsp;14.8.5, “Configuring Thread Concurrency for InnoDB”</a>.
                </p><p style="color:blue;">有关更多信息，请参阅14.8.5节，“为innodb配置线程并发”。</p></li><li class="listitem"><p><a name="sysvar_innodb_tmpdir"></a>
                <a class="indexterm" name="idm140286808761840"></a>

                <a class="indexterm" name="idm140286808760832"></a>

                <code class="literal">innodb_tmpdir</code>
            </p><p style="color:blue;">innodb_tmpdir公司</p>
                <div class="informaltable">
                    <table frame="box" rules="all" summary="Properties for innodb_tmpdir"><colgroup><col width="30%"><col width="70%"></colgroup><thead><tr><th scope="col">Property</th>
                        <th scope="col">Value</th>
                    </tr></thead><tbody><tr><td scope="row"><span class="bold"><strong>Command-Line Format</strong></span></td>
                        <td><code class="literal">--innodb-tmpdir=dir_name</code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Introduced</strong></span></td>
                        <td>5.7.11</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>System Variable</strong></span></td>
                        <td><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_tmpdir">innodb_tmpdir</a></code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Scope</strong></span></td>
                        <td>Global, Session</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Dynamic</strong></span></td>
                        <td>Yes</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Type</strong></span></td>
                        <td>Directory name</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Default Value</strong></span></td>
                        <td><code class="literal">NULL</code></td>
                    </tr></tbody></table>
                </div>
                <p>
                    Used to define an alternate directory for temporary sort files
                    created during online <a class="link" href="sql-syntax.html#alter-table" title="13.1.8&nbsp;ALTER TABLE Syntax"><code class="literal">ALTER
                    TABLE</code></a> operations that rebuild the table.
                </p><p style="color:blue;">用于为在重建表的联机alter table操作期间创建的临时排序文件定义备用目录。</p><p>
                    Online <a class="link" href="sql-syntax.html#alter-table" title="13.1.8&nbsp;ALTER TABLE Syntax"><code class="literal">ALTER TABLE</code></a> operations
                    that rebuild the table also create an
                    <span class="emphasis"><em>intermediate</em></span> table file in the same
                    directory as the original table. The
                    <code class="literal">innodb_tmpdir</code> option is not applicable to
                    intermediate table files.
                </p><p style="color:blue;">重建表的联机alter table操作还会在与原始表相同的目录中创建一个中间表文件。innodb_tmpdir选项不适用于中间表文件。</p><p>
                    A valid value is any directory path other than the MySQL data
                    directory path. If the value is NULL (the default), temporary
                    files are created MySQL temporary directory
                    (<code class="literal">$TMPDIR</code> on Unix, <code class="literal">%TEMP%</code>
                    on Windows, or the directory specified by the
                    <a class="link" href="server-administration.html#sysvar_tmpdir"><code class="literal">--tmpdir</code></a> configuration
                    option). If a directory is specified, existence of the
                    directory and permissions are only checked when
                    <code class="literal">innodb_tmpdir</code> is configured using a
                    <a class="link" href="sql-syntax.html#set-variable" title="13.7.4.1&nbsp;SET Syntax for Variable Assignment"><code class="literal">SET</code></a>
                    statement. If a symlink is provided in a directory string, the
                    symlink is resolved and stored as an absolute path. The path
                    should not exceed 512 bytes. An online
                    <a class="link" href="sql-syntax.html#alter-table" title="13.1.8&nbsp;ALTER TABLE Syntax"><code class="literal">ALTER TABLE</code></a> operation reports
                    an error if <code class="literal">innodb_tmpdir</code> is set to an
                    invalid directory. <code class="literal">innodb_tmpdir</code> overrides
                    the MySQL <a class="link" href="server-administration.html#sysvar_tmpdir"><code class="literal">tmpdir</code></a> setting but
                    only for online <a class="link" href="sql-syntax.html#alter-table" title="13.1.8&nbsp;ALTER TABLE Syntax"><code class="literal">ALTER TABLE</code></a>
                    operations.
                </p><p style="color:blue;">有效值是除mysql数据目录路径以外的任何目录路径。如果该值为空（默认值），则会创建临时文件mysql临时目录（UNIX上为tmpdir，Windows上为temp%，或--tmpdir配置选项指定的目录）。如果指定了一个目录，则仅在使用SET语句配置InBudIttMPDIR时检查目录和权限的存在。如果在目录字符串中提供了符号链接，则符号链接将被解析并存储为绝对路径。路径不应超过512字节。如果innodb_tmpdir设置为无效目录，则联机alter table操作将报告错误。innodb_tmpdir覆盖mysql tmpdir设置，但仅用于联机alter table操作。</p><p>
                    The <code class="literal">FILE</code> privilege is required to configure
                    <code class="literal">innodb_tmpdir</code>.
                </p><p style="color:blue;">配置innodb_tmpdir需要文件权限。</p><p>
                    The <code class="literal">innodb_tmpdir</code> option was introduced to
                    help avoid overflowing a temporary file directory located on a
                    <code class="literal">tmpfs</code> file system. Such overflows could
                    occur as a result of large temporary sort files created during
                    online <a class="link" href="sql-syntax.html#alter-table" title="13.1.8&nbsp;ALTER TABLE Syntax"><code class="literal">ALTER TABLE</code></a> operations
                    that rebuild the table.
                </p><p style="color:blue;">引入innodb_tmpdir选项有助于避免tmpfs文件系统上的临时文件目录溢出。这种溢出可能是在重建表的联机alter table操作期间创建的大型临时排序文件的结果。</p><p>
                    In replication environments, only consider replicating the
                    <code class="literal">innodb_tmpdir</code> setting if all servers have
                    the same operating system environment. Otherwise, replicating
                    the <code class="literal">innodb_tmpdir</code> setting could result in a
                    replication failure when running online
                    <a class="link" href="sql-syntax.html#alter-table" title="13.1.8&nbsp;ALTER TABLE Syntax"><code class="literal">ALTER TABLE</code></a> operations that
                    rebuild the table. If server operating environments differ, it
                    is recommended that you configure
                    <code class="literal">innodb_tmpdir</code> on each server individually.
                </p><p style="color:blue;">在复制环境中，仅当所有服务器都具有相同的操作系统环境时，才考虑复制innodb_tmpdir设置。否则，在运行重建表的联机alter table操作时，复制innodb_tmpdir设置可能会导致复制失败。如果服务器操作环境不同，建议在每台服务器上分别配置innodb_tmpdir。</p><p>
                    For more information, see
                    <a class="xref" href="innodb-storage-engine.html#innodb-online-ddl-space-requirements" title="14.13.3&nbsp;Online DDL Space Requirements">Section&nbsp;14.13.3, “Online DDL Space Requirements”</a>. For
                    information about online <a class="link" href="sql-syntax.html#alter-table" title="13.1.8&nbsp;ALTER TABLE Syntax"><code class="literal">ALTER
                    TABLE</code></a> operations, see
                    <a class="xref" href="innodb-storage-engine.html#innodb-online-ddl" title="14.13&nbsp;InnoDB and Online DDL">Section&nbsp;14.13, “InnoDB and Online DDL”</a>.
                </p><p style="color:blue;">有关更多信息，请参见第14.13.3节“联机DDL空间要求”。有关联机alter table操作的信息，请参阅14.13节，“innodb和联机ddl”。</p></li><li class="listitem"><p><a name="sysvar_innodb_trx_purge_view_update_only_debug"></a>
                <a class="indexterm" name="idm140286808702800"></a>

                <a class="indexterm" name="idm140286808701712"></a>

                <code class="literal">innodb_trx_purge_view_update_only_debug</code>
            </p><p style="color:blue;">innodb_trx_purge_view_update_only_调试</p>
                <div class="informaltable">
                    <table frame="box" rules="all" summary="Properties for innodb_trx_purge_view_update_only_debug"><colgroup><col width="30%"><col width="70%"></colgroup><thead><tr><th scope="col">Property</th>
                        <th scope="col">Value</th>
                    </tr></thead><tbody><tr><td scope="row"><span class="bold"><strong>Command-Line Format</strong></span></td>
                        <td><code class="literal">--innodb-trx-purge-view-update-only-debug[={OFF|ON}]</code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>System Variable</strong></span></td>
                        <td><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_trx_purge_view_update_only_debug">innodb_trx_purge_view_update_only_debug</a></code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Scope</strong></span></td>
                        <td>Global</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Dynamic</strong></span></td>
                        <td>Yes</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Type</strong></span></td>
                        <td>Boolean</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Default Value</strong></span></td>
                        <td><code class="literal">OFF</code></td>
                    </tr></tbody></table>
                </div>
                <p>
                    Pauses purging of delete-marked records while allowing the
                    purge view to be updated. This option artificially creates a
                    situation in which the purge view is updated but purges have
                    not yet been performed. This option is only available if
                    debugging support is compiled in using the
                    <a class="link" href="installing.html#option_cmake_with_debug"><code class="option">WITH_DEBUG</code></a>
                    <span class="command"><strong>CMake</strong></span> option.
                </p><p style="color:blue;">暂停清除删除标记的记录，同时允许更新清除视图。此选项会人为创建一种情况，即清除视图已更新，但尚未执行清除。只有在使用with_debug cmake选项编译调试支持时，此选项才可用。</p></li><li class="listitem"><p><a name="sysvar_innodb_trx_rseg_n_slots_debug"></a>
                <a class="indexterm" name="idm140286808672080"></a>

                <a class="indexterm" name="idm140286808671040"></a>

                <code class="literal">innodb_trx_rseg_n_slots_debug</code>
            </p><p style="color:blue;">innodb_trx_rseg_n_slots_调试</p>
                <div class="informaltable">
                    <table frame="box" rules="all" summary="Properties for innodb_trx_rseg_n_slots_debug"><colgroup><col width="30%"><col width="70%"></colgroup><thead><tr><th scope="col">Property</th>
                        <th scope="col">Value</th>
                    </tr></thead><tbody><tr><td scope="row"><span class="bold"><strong>Command-Line Format</strong></span></td>
                        <td><code class="literal">--innodb-trx-rseg-n-slots-debug=#</code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>System Variable</strong></span></td>
                        <td><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_trx_rseg_n_slots_debug">innodb_trx_rseg_n_slots_debug</a></code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Scope</strong></span></td>
                        <td>Global</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Dynamic</strong></span></td>
                        <td>Yes</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Type</strong></span></td>
                        <td>Integer</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Default Value</strong></span></td>
                        <td><code class="literal">0</code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Maximum Value</strong></span></td>
                        <td><code class="literal">1024</code></td>
                    </tr></tbody></table>
                </div>
                <p>
                    Sets a debug flag that limits
                    <code class="literal">TRX_RSEG_N_SLOTS</code> to a given value for the
                    <code class="literal">trx_rsegf_undo_find_free</code> function that
                    looks for free slots for undo log segments. This option is
                    only available if debugging support is compiled in using the
                    <a class="link" href="installing.html#option_cmake_with_debug"><code class="option">WITH_DEBUG</code></a>
                    <span class="command"><strong>CMake</strong></span> option.
                </p><p style="color:blue;">设置一个调试标志，将trx rsegf_n_slots限制为trx rsegf_undo_find_free函数的给定值，该函数用于查找撤消日志段的空闲插槽。只有在使用with_debug cmake选项编译调试支持时，此选项才可用。</p></li><li class="listitem"><p><a name="sysvar_innodb_undo_directory"></a>
                <a class="indexterm" name="idm140286808636976"></a>

                <code class="literal">innodb_undo_directory</code>
            </p><p style="color:blue;">innodb_undo_目录</p>
                <div class="informaltable">
                    <table frame="box" rules="all" summary="Properties for innodb_undo_directory"><colgroup><col width="30%"><col width="70%"></colgroup><thead><tr><th scope="col">Property</th>
                        <th scope="col">Value</th>
                    </tr></thead><tbody><tr><td scope="row"><span class="bold"><strong>Command-Line Format</strong></span></td>
                        <td><code class="literal">--innodb-undo-directory=dir_name</code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>System Variable</strong></span></td>
                        <td><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_undo_directory">innodb_undo_directory</a></code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Scope</strong></span></td>
                        <td>Global</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Dynamic</strong></span></td>
                        <td>No</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Type</strong></span></td>
                        <td>Directory name</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Default Value</strong></span></td>
                        <td><code class="literal">.</code></td>
                    </tr></tbody></table>
                </div>
                <p>
                    The path where <code class="literal">InnoDB</code> creates undo
                    tablespaces. Typically used to place undo logs on a different
                    storage device. Used in conjunction with
                    <a class="link" href="innodb-storage-engine.html#sysvar_innodb_rollback_segments"><code class="literal">innodb_rollback_segments</code></a> and
                    <a class="link" href="innodb-storage-engine.html#sysvar_innodb_undo_tablespaces"><code class="literal">innodb_undo_tablespaces</code></a>.
                </p><p style="color:blue;">InnoDB创建撤消表空间的路径。通常用于在不同的存储设备上放置撤消日志。与innodb_rollback_段和innodb_undo_表空间一起使用。</p><p>
                    There is no default value (it is NULL). If a path is not
                    specified, undo tablespaces are created in the MySQL data
                    directory, as defined by
                    <a class="link" href="server-administration.html#sysvar_datadir"><code class="literal">datadir</code></a>.
                </p><p style="color:blue;">没有默认值（为空）。如果未指定路径，则按照datadir的定义，在mysql数据目录中创建undo表空间。</p><p>
                    For more information, see
                    <a class="xref" href="innodb-storage-engine.html#innodb-undo-tablespaces" title="14.6.3.4&nbsp;Undo Tablespaces">Section&nbsp;14.6.3.4, “Undo Tablespaces”</a>.
                </p><p style="color:blue;">有关更多信息，请参阅14.6.3.4节“撤消表空间”。</p></li><li class="listitem"><p><a name="sysvar_innodb_undo_log_truncate"></a>
                <a class="indexterm" name="idm140286808603472"></a>

                <a class="indexterm" name="idm140286808602368"></a>

                <code class="literal">innodb_undo_log_truncate</code>
            </p><p style="color:blue;">innodb_undo_log_truncate命令</p>
                <div class="informaltable">
                    <table frame="box" rules="all" summary="Properties for innodb_undo_log_truncate"><colgroup><col width="30%"><col width="70%"></colgroup><thead><tr><th scope="col">Property</th>
                        <th scope="col">Value</th>
                    </tr></thead><tbody><tr><td scope="row"><span class="bold"><strong>Command-Line Format</strong></span></td>
                        <td><code class="literal">--innodb-undo-log-truncate[={OFF|ON}]</code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Introduced</strong></span></td>
                        <td>5.7.5</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>System Variable</strong></span></td>
                        <td><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_undo_log_truncate">innodb_undo_log_truncate</a></code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Scope</strong></span></td>
                        <td>Global</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Dynamic</strong></span></td>
                        <td>Yes</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Type</strong></span></td>
                        <td>Boolean</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Default Value</strong></span></td>
                        <td><code class="literal">OFF</code></td>
                    </tr></tbody></table>
                </div>
                <p>
                    When enabled, undo tablespaces that exceed the threshold value
                    defined by
                    <a class="link" href="innodb-storage-engine.html#sysvar_innodb_max_undo_log_size"><code class="literal">innodb_max_undo_log_size</code></a> are
                    marked for truncation. Only undo tablespaces can be truncated.
                    Truncating undo logs that reside in the system tablespace is
                    not supported. For truncation to occur, there must be at least
                    two undo tablespaces and two redo-enabled undo logs configured
                    to use undo tablespaces. This means that
                    <a class="link" href="innodb-storage-engine.html#sysvar_innodb_undo_tablespaces"><code class="literal">innodb_undo_tablespaces</code></a> must
                    be set to a value equal to or greater than 2, and
                    <a class="link" href="innodb-storage-engine.html#sysvar_innodb_rollback_segments"><code class="literal">innodb_rollback_segments</code></a> must
                    set to a value equal to or greater than 35.
                </p><p style="color:blue;">启用时，超过innodb_max_undo_log_size定义的阈值的undo表空间将被标记为截断。只能截断撤消表空间。不支持截断驻留在系统表空间中的撤消日志。要进行截断，必须至少有两个撤消表空间和两个启用重做的撤消日志配置为使用撤消表空间。这意味着innodb_undo_tablespaces必须设置为等于或大于2的值，innodb_rollback_segments必须设置为等于或大于35的值。</p><p>
                    The
                    <a class="link" href="innodb-storage-engine.html#sysvar_innodb_purge_rseg_truncate_frequency"><code class="literal">innodb_purge_rseg_truncate_frequency</code></a>
                    variable can be used to expedite truncation of undo
                    tablespaces.
                </p><p style="color:blue;">innodb_purge_rseg_truncate_频率变量可用于加速撤销表空间的截断。</p><p>
                    For more information, see
                    <a class="xref" href="innodb-storage-engine.html#truncate-undo-tablespace" title="Truncating Undo Tablespaces">Truncating Undo Tablespaces</a>.
                </p><p style="color:blue;">有关详细信息，请参见截断撤消表空间。</p></li><li class="listitem"><p><a name="sysvar_innodb_undo_logs"></a>
                <a class="indexterm" name="idm140286808564720"></a>

                <code class="literal">innodb_undo_logs</code>
            </p><p style="color:blue;">innodb_undo_日志</p>
                <div class="informaltable">
                    <table frame="box" rules="all" summary="Properties for innodb_undo_logs"><colgroup><col width="30%"><col width="70%"></colgroup><thead><tr><th scope="col">Property</th>
                        <th scope="col">Value</th>
                    </tr></thead><tbody><tr><td scope="row"><span class="bold"><strong>Command-Line Format</strong></span></td>
                        <td><code class="literal">--innodb-undo-logs=#</code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Deprecated</strong></span></td>
                        <td>5.7.19</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>System Variable</strong></span></td>
                        <td><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_undo_logs">innodb_undo_logs</a></code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Scope</strong></span></td>
                        <td>Global</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Dynamic</strong></span></td>
                        <td>Yes</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Type</strong></span></td>
                        <td>Integer</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Default Value</strong></span></td>
                        <td><code class="literal">128</code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Minimum Value</strong></span></td>
                        <td><code class="literal">1</code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Maximum Value</strong></span></td>
                        <td><code class="literal">128</code></td>
                    </tr></tbody></table>
                </div>
                <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">
                    <div class="admon-title">
                        Note
                    </div>
                    <p>
                        <a class="link" href="innodb-storage-engine.html#sysvar_innodb_undo_logs"><code class="literal">innodb_undo_logs</code></a> is
                        deprecated and will be removed in a future release.
                    </p><p style="color:blue;">InnoDB_undo_日志已弃用，将在以后的版本中删除。</p>
                </div>
                <p>
                    Defines the number of
                    <a class="link" href="glossary.html#glos_rollback_segment" title="rollback segment">rollback segments</a>
                    used by <code class="literal">InnoDB</code>. The
                    <a class="link" href="innodb-storage-engine.html#sysvar_innodb_undo_logs"><code class="literal">innodb_undo_logs</code></a> option is an
                    alias for
                    <a class="link" href="innodb-storage-engine.html#sysvar_innodb_rollback_segments"><code class="literal">innodb_rollback_segments</code></a>. For
                    more information, see the description of
                    <a class="link" href="innodb-storage-engine.html#sysvar_innodb_rollback_segments"><code class="literal">innodb_rollback_segments</code></a>.
                </p><p style="color:blue;">定义innodb使用的回滚段数。innodb_undo_logs选项是innodb_rollback_段的别名。有关更多信息，请参阅innodb_rollback_segments的描述。</p></li><li class="listitem"><p><a name="sysvar_innodb_undo_tablespaces"></a>
                <a class="indexterm" name="idm140286808521312"></a>

                <code class="literal">innodb_undo_tablespaces</code>
            </p><p style="color:blue;">innodb_undo_表空间</p>
                <div class="informaltable">
                    <table frame="box" rules="all" summary="Properties for innodb_undo_tablespaces"><colgroup><col width="30%"><col width="70%"></colgroup><thead><tr><th scope="col">Property</th>
                        <th scope="col">Value</th>
                    </tr></thead><tbody><tr><td scope="row"><span class="bold"><strong>Command-Line Format</strong></span></td>
                        <td><code class="literal">--innodb-undo-tablespaces=#</code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Deprecated</strong></span></td>
                        <td>5.7.21</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>System Variable</strong></span></td>
                        <td><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_undo_tablespaces">innodb_undo_tablespaces</a></code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Scope</strong></span></td>
                        <td>Global</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Dynamic</strong></span></td>
                        <td>No</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Type</strong></span></td>
                        <td>Integer</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Default Value</strong></span></td>
                        <td><code class="literal">0</code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Minimum Value</strong></span></td>
                        <td><code class="literal">0</code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Maximum Value</strong></span> (&gt;= 5.7.8)</td>
                        <td><code class="literal">95</code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Maximum Value</strong></span> (&lt;= 5.7.7)</td>
                        <td><code class="literal">126</code></td>
                    </tr></tbody></table>
                </div>
                <p>
                    The number of <a class="link" href="glossary.html#glos_undo_tablespace" title="undo tablespace">undo
                    tablespaces</a> used by <code class="literal">InnoDB</code>. The
                    default value is 0.
                </p><p style="color:blue;">InnoDB使用的撤消表空间数。默认值为0。</p>
                <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">

                    <div class="admon-title">
                        Note
                    </div>
                    <p>
                        <a class="link" href="innodb-storage-engine.html#sysvar_innodb_undo_tablespaces"><code class="literal">innodb_undo_tablespaces</code></a> is
                        deprecated and will be removed in a future release.
                    </p><p style="color:blue;">innodb_undo_表空间已弃用，将在以后的版本中删除。</p>
                </div>
                <p>
                    Because undo logs can become large during long-running
                    transactions, having undo logs in multiple tablespaces reduces
                    the maximum size of any one tablespace. The undo tablespace
                    files are created in the location defined by
                    <a class="link" href="innodb-storage-engine.html#sysvar_innodb_undo_directory"><code class="literal">innodb_undo_directory</code></a>, with
                    names in the form of
                    <code class="filename">undo<em class="replaceable"><code>N</code></em></code>, where
                    <em class="replaceable"><code>N</code></em> is a sequential series of
                    integers (including leading zeros) representing the space ID.
                </p><p style="color:blue;">因为撤消日志在长时间运行的事务中可能变大，因此在多个表空间中具有撤消日志会减少任何一个表空间的最大大小。undo表空间文件是在innodb_undo_目录定义的位置创建的，其名称为undo n，其中n是表示空间id的一系列整数（包括前导零）。</p><p>
                    The initial size of an undo tablespace file depends on the
                    <a class="link" href="innodb-storage-engine.html#sysvar_innodb_page_size"><code class="literal">innodb_page_size</code></a> value. For
                    the default 16KB <code class="literal">InnoDB</code> page size, the
                    initial undo tablespace file size is 10MiB. For 4KB, 8KB,
                    32KB, and 64KB page sizes, the initial undo tablespace files
                    sizes are 7MiB, 8MiB, 20MiB, and 40MiB, respectively.
                </p><p style="color:blue;">撤消表空间文件的初始大小取决于innodb_page_size值。对于默认的16kb innodb页面大小，初始的undo表空间文件大小是10mib。对于4KB、8KB、32KB和64KB的页面大小，初始的撤消表空间文件大小分别为7MIB、8MIB、20MIB和40MIB。</p><p>
                    A minimum of two undo tablespaces is required to enable
                    truncation of undo logs. See
                    <a class="xref" href="innodb-storage-engine.html#truncate-undo-tablespace" title="Truncating Undo Tablespaces">Truncating Undo Tablespaces</a>.
                </p><p style="color:blue;">至少需要两个撤消表空间才能截断撤消日志。请参见截断撤消表空间。</p>
                <div class="important" style="margin-left: 0.5in; margin-right: 0.5in;">

                    <div class="admon-title">
                        Important
                    </div>
                    <p>
                        <a class="link" href="innodb-storage-engine.html#sysvar_innodb_undo_tablespaces"><code class="literal">innodb_undo_tablespaces</code></a> can
                        only be configured prior to initializing the MySQL instance
                        and cannot be changed afterward. If no value is specified,
                        the instance is initialized using the default setting of 0.
                        Attempting to restart <code class="literal">InnoDB</code> with a
                        greater number of undo tablespaces than specified when the
                        MySQL instance was initialized results in a startup failure
                        and an error stating that <code class="literal">InnoDB</code> did not
                        find the expected number of undo tablespaces.
                    </p><p style="color:blue;">innodb_undo_表空间只能在初始化mysql实例之前配置，之后不能更改。如果未指定值，则使用默认设置0初始化实例。尝试用比初始化mysql实例时指定的更多的undo表空间重新启动innodb会导致启动失败，并出现一个错误，指出innodb没有找到预期数量的undo表空间。</p>
                </div>
                <p>
                    32 of 128 rollback segments are reserved for temporary tables,
                    as described in <a class="xref" href="innodb-storage-engine.html#innodb-undo-logs" title="14.6.7&nbsp;Undo Logs">Section&nbsp;14.6.7, “Undo Logs”</a>. One
                    rollback segment is always assigned to the system tablespace,
                    which leaves 95 rollback segments available for undo
                    tablespaces. This means the
                    <a class="link" href="innodb-storage-engine.html#sysvar_innodb_undo_tablespaces"><code class="literal">innodb_undo_tablespaces</code></a>
                    maximum limit is 95.
                </p><p style="color:blue;">128个回滚段中的32个保留给临时表，如14.6.7节“撤消日志”所述。一个回滚段总是分配给系统表空间，这使得95个回滚段可用于撤消表空间。这意味着NoNdBuxUndoyTabLasePax最大限制为95。</p><p>
                    For more information, see
                    <a class="xref" href="innodb-storage-engine.html#innodb-undo-tablespaces" title="14.6.3.4&nbsp;Undo Tablespaces">Section&nbsp;14.6.3.4, “Undo Tablespaces”</a>.
                </p><p style="color:blue;">有关更多信息，请参阅14.6.3.4节“撤消表空间”。</p></li><li class="listitem"><p><a name="sysvar_innodb_use_native_aio"></a>
                <a class="indexterm" name="idm140286808463120"></a>

                <a class="indexterm" name="idm140286808462080"></a>

                <code class="literal">innodb_use_native_aio</code>
            </p><p style="color:blue;">innodb_use_native_aio公司</p>
                <div class="informaltable">
                    <table frame="box" rules="all" summary="Properties for innodb_use_native_aio"><colgroup><col width="30%"><col width="70%"></colgroup><thead><tr><th scope="col">Property</th>
                        <th scope="col">Value</th>
                    </tr></thead><tbody><tr><td scope="row"><span class="bold"><strong>Command-Line Format</strong></span></td>
                        <td><code class="literal">--innodb-use-native-aio[={OFF|ON}]</code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>System Variable</strong></span></td>
                        <td><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_use_native_aio">innodb_use_native_aio</a></code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Scope</strong></span></td>
                        <td>Global</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Dynamic</strong></span></td>
                        <td>No</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Type</strong></span></td>
                        <td>Boolean</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Default Value</strong></span></td>
                        <td><code class="literal">ON</code></td>
                    </tr></tbody></table>
                </div>
                <p>
                    Specifies whether to use the Linux asynchronous I/O subsystem.
                    This variable applies to Linux systems only, and cannot be
                    changed while the server is running. Normally, you do not need
                    to configure this option, because it is enabled by default.
                </p><p style="color:blue;">指定是否使用Linux异步I/O子系统。此变量仅适用于Linux系统，并且在服务器运行时无法更改。通常，您不需要配置此选项，因为它是默认启用的。</p><p>
                    The <a class="link" href="glossary.html#glos_asynchronous_io" title="asynchronous I/O">asynchronous
                    I/O</a> capability that <code class="literal">InnoDB</code> has on
                    Windows systems is available on Linux systems. (Other
                    Unix-like systems continue to use synchronous I/O calls.) This
                    feature improves the scalability of heavily I/O-bound systems,
                    which typically show many pending reads/writes in
                    <code class="literal">SHOW ENGINE INNODB STATUS\G</code> output.
                </p><p style="color:blue;">InnoDB在Windows系统上的异步I/O功能在Linux系统上可用。（其他类unix系统继续使用同步i/o调用。）此功能提高了严重i/o绑定系统的可伸缩性，通常在show engine innodb status\g输出中显示许多挂起的读/写操作。</p><p>
                    Running with a large number of <code class="literal">InnoDB</code> I/O
                    threads, and especially running multiple such instances on the
                    same server machine, can exceed capacity limits on Linux
                    systems. In this case, you may receive the following error:
                </p><p style="color:blue;">运行大量的innodb i/o线程，特别是在同一台服务器上运行多个这样的实例，可能会超出linux系统的容量限制。在这种情况下，您可能会收到以下错误：</p><pre data-lang="terminal" class="programlisting">EAGAIN: The specified maxevents exceeds the user's limit of available events.
</pre><p>
                    You can typically address this error by writing a higher limit
                    to <code class="literal">/proc/sys/fs/aio-max-nr</code>.
                </p><p style="color:blue;">通常可以通过将更高的限制写入/proc/sys/fs/aio-max-nr来解决此错误。</p><p>
                    However, if a problem with the asynchronous I/O subsystem in
                    the OS prevents <code class="literal">InnoDB</code> from starting, you
                    can start the server with
                    <a class="link" href="innodb-storage-engine.html#sysvar_innodb_use_native_aio"><code class="literal">innodb_use_native_aio=0</code></a>. This
                    option may also be disabled automatically during startup if
                    <code class="literal">InnoDB</code> detects a potential problem such as
                    a combination of <code class="literal">tmpdir</code> location,
                    <code class="literal">tmpfs</code> file system, and Linux kernel that
                    does not support AIO on <code class="literal">tmpfs</code>.
                </p><p style="color:blue;">但是，如果操作系统中的异步I/O子系统出现问题，导致InnoDB无法启动，则可以使用InnoDB use_native_a i o=0启动服务器。如果innodb检测到潜在的问题，比如tmpdir位置、tmpfs文件系统和linux内核的组合不支持tmpfs上的aio，那么在启动期间也可以自动禁用此选项。</p><p>
                    For more information, see
                    <a class="xref" href="innodb-storage-engine.html#innodb-linux-native-aio" title="14.8.7&nbsp;Using Asynchronous I/O on Linux">Section&nbsp;14.8.7, “Using Asynchronous I/O on Linux”</a>.
                </p><p style="color:blue;">有关更多信息，请参阅14.8.7节，“在Linux上使用异步I/O”。</p></li><li class="listitem"><p><a name="sysvar_innodb_use_sys_malloc"></a>
                <a class="indexterm" name="idm140286808420736"></a>

                <a class="indexterm" name="idm140286808419696"></a>

                <code class="literal">innodb_use_sys_malloc</code>
            </p><p style="color:blue;">innodb_use_sys_malloc公司</p>
                <div class="informaltable">
                    <table frame="box" rules="all" summary="Properties for innodb_use_sys_malloc"><colgroup><col width="30%"><col width="70%"></colgroup><thead><tr><th scope="col">Property</th>
                        <th scope="col">Value</th>
                    </tr></thead><tbody><tr><td scope="row"><span class="bold"><strong>Command-Line Format</strong></span></td>
                        <td><code class="literal">--innodb-use-sys-malloc[={OFF|ON}]</code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Deprecated</strong></span></td>
                        <td>Yes (removed in 5.7.4)</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>System Variable</strong></span></td>
                        <td><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_use_sys_malloc">innodb_use_sys_malloc</a></code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Scope</strong></span></td>
                        <td>Global</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Dynamic</strong></span></td>
                        <td>No</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Type</strong></span></td>
                        <td>Boolean</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Default Value</strong></span></td>
                        <td><code class="literal">ON</code></td>
                    </tr></tbody></table>
                </div>
                <p>
                    Enables the operating system memory allocator. If disabled,
                    <code class="literal">InnoDB</code> uses its own allocator. The default
                    value is <code class="literal">ON</code>. For more information, see
                    <a class="xref" href="innodb-storage-engine.html#innodb-performance-use_sys_malloc" title="14.8.4&nbsp;Configuring the Memory Allocator for InnoDB">Section&nbsp;14.8.4, “Configuring the Memory Allocator for InnoDB”</a>.
                </p><p style="color:blue;">启用操作系统内存分配器。如果禁用，innodb将使用自己的分配器。默认值为“开”。有关更多信息，请参阅14.8.4节，“为InnoDB配置内存分配器”。</p><p>
                    <a class="link" href="innodb-storage-engine.html#sysvar_innodb_use_sys_malloc"><code class="literal">innodb_use_sys_malloc</code></a> is
                    removed in MySQL 5.7.
                </p><p style="color:blue;">在mysql 5.7中删除了innodb_use_sys_malloc。</p></li><li class="listitem"><p><a name="sysvar_innodb_version"></a>
                <a class="indexterm" name="idm140286808385472"></a>

                <a class="indexterm" name="idm140286808384464"></a>

                <code class="literal">innodb_version</code>
            </p><p style="color:blue;">InnoDB_版本</p><p>
                The <code class="literal">InnoDB</code> version number. In MySQL
                5.7, separate version numbering for
                <code class="literal">InnoDB</code> does not apply and this value is the
                same the <a class="link" href="server-administration.html#sysvar_version"><code class="literal">version</code></a> number of
                the server.
            </p><p style="color:blue;">InnoDB版本号。在MySQL5.7中，InnoDB的版本号不适用于单独的版本号，该值与服务器的版本号相同。</p></li><li class="listitem"><p><a name="sysvar_innodb_write_io_threads"></a>
                <a class="indexterm" name="idm140286808377776"></a>

                <a class="indexterm" name="idm140286808376736"></a>

                <code class="literal">innodb_write_io_threads</code>
            </p><p style="color:blue;">innodb_write_io_线程</p>
                <div class="informaltable">
                    <table frame="box" rules="all" summary="Properties for innodb_write_io_threads"><colgroup><col width="30%"><col width="70%"></colgroup><thead><tr><th scope="col">Property</th>
                        <th scope="col">Value</th>
                    </tr></thead><tbody><tr><td scope="row"><span class="bold"><strong>Command-Line Format</strong></span></td>
                        <td><code class="literal">--innodb-write-io-threads=#</code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>System Variable</strong></span></td>
                        <td><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_write_io_threads">innodb_write_io_threads</a></code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Scope</strong></span></td>
                        <td>Global</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Dynamic</strong></span></td>
                        <td>No</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Type</strong></span></td>
                        <td>Integer</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Default Value</strong></span></td>
                        <td><code class="literal">4</code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Minimum Value</strong></span></td>
                        <td><code class="literal">1</code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Maximum Value</strong></span></td>
                        <td><code class="literal">64</code></td>
                    </tr></tbody></table>
                </div>
                <p>
                    The number of I/O threads for write operations in
                    <code class="literal">InnoDB</code>. The default value is 4. Its
                    counterpart for read threads is
                    <a class="link" href="innodb-storage-engine.html#sysvar_innodb_read_io_threads"><code class="literal">innodb_read_io_threads</code></a>. For
                    more information, see
                    <a class="xref" href="innodb-storage-engine.html#innodb-performance-multiple_io_threads" title="14.8.6&nbsp;Configuring the Number of Background InnoDB I/O Threads">Section&nbsp;14.8.6, “Configuring the Number of Background InnoDB I/O Threads”</a>. For
                    general I/O tuning advice, see
                    <a class="xref" href="optimization.html#optimizing-innodb-diskio" title="8.5.8&nbsp;Optimizing InnoDB Disk I/O">Section&nbsp;8.5.8, “Optimizing InnoDB Disk I/O”</a>.
                </p><p style="color:blue;">InnoDB中用于写操作的I/O线程数。默认值为4。它的读线程对应的是innodb_read_io_threads。有关更多信息，请参阅14.8.6节，“配置后台InnoDB I/O线程数”。有关一般I/O调整建议，请参阅第8.5.8节“优化InnoDB磁盘I/O”。</p>
                <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">

                    <div class="admon-title">
                        Note
                    </div>
                    <p>
                        On Linux systems, running multiple MySQL servers (typically
                        more than 12) with default settings for
                        <a class="link" href="innodb-storage-engine.html#sysvar_innodb_read_io_threads"><code class="literal">innodb_read_io_threads</code></a>,
                        <code class="literal">innodb_write_io_threads</code>, and the Linux
                        <code class="literal">aio-max-nr</code> setting can exceed system
                        limits. Ideally, increase the <code class="literal">aio-max-nr</code>
                        setting; as a workaround, you might reduce the settings for
                        one or both of the MySQL variables.
                    </p><p style="color:blue;">在linux系统上，运行多个mysql服务器（通常超过12个），默认设置为innodb_read_io_线程、innodb_write_io_线程，并且linux aio max nr设置可以超过系统限制。理想情况下，增加aio max nr设置；作为解决方法，可以减少一个或两个mysql变量的设置。</p>
                </div>
                <p>
                    Also take into consideration the value of
                    <a class="link" href="replication.html#sysvar_sync_binlog"><code class="literal">sync_binlog</code></a>, which controls
                    synchronization of the binary log to disk.
                </p><p style="color:blue;">还要考虑sync_binlog的值，它控制二进制日志到磁盘的同步。</p><p>
                    For general I/O tuning advice, see
                    <a class="xref" href="optimization.html#optimizing-innodb-diskio" title="8.5.8&nbsp;Optimizing InnoDB Disk I/O">Section&nbsp;8.5.8, “Optimizing InnoDB Disk I/O”</a>.
                </p><p style="color:blue;">有关一般I/O调整建议，请参阅第8.5.8节“优化InnoDB磁盘I/O”。</p></li></ul>
        </div>

    </div>
    <div class="section">
        <div class="titlepage">
            <div>
                <div>
                    <h2 class="title" style="clear: both"><a name="innodb-information-schema"></a>14.15&nbsp;InnoDB INFORMATION_SCHEMA Tables</h2>

                </div>

            </div>

        </div>
        <div class="toc">
            <dl class="toc"><dt><span class="section"><a href="innodb-storage-engine.html#innodb-information-schema-compression-tables">14.15.1 InnoDB INFORMATION_SCHEMA Tables about Compression</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-information-schema-transactions">14.15.2 InnoDB INFORMATION_SCHEMA Transaction and Locking Information</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-information-schema-system-tables">14.15.3 InnoDB INFORMATION_SCHEMA System Tables</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-information-schema-fulltext_index-tables">14.15.4 InnoDB INFORMATION_SCHEMA FULLTEXT Index Tables</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-information-schema-buffer-pool-tables">14.15.5 InnoDB INFORMATION_SCHEMA Buffer Pool Tables</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-information-schema-metrics-table">14.15.6 InnoDB INFORMATION_SCHEMA Metrics Table</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-information-schema-temp-table-info">14.15.7 InnoDB INFORMATION_SCHEMA Temporary Table Info Table</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-information-schema-files-table">14.15.8 Retrieving InnoDB Tablespace Metadata from INFORMATION_SCHEMA.FILES</a></span></dt></dl>
        </div>
        <a class="indexterm" name="idm140286808331520"></a><p>
        This section provides information and usage examples for
        <code class="literal">InnoDB</code>
        <a class="link" href="information-schema.html" title="Chapter&nbsp;24&nbsp;INFORMATION_SCHEMA Tables"><code class="literal">INFORMATION_SCHEMA</code></a> tables.
    </p><p style="color:blue;">本节提供innodb information_schema表的信息和使用示例。</p><p>
        <code class="literal">InnoDB</code> <code class="literal">INFORMATION_SCHEMA</code>
        tables provide metadata, status information, and statistics about
        various aspects of the <code class="literal">InnoDB</code> storage engine. You
        can view a list of <code class="literal">InnoDB</code>
        <code class="literal">INFORMATION_SCHEMA</code> tables by issuing a
        <a class="link" href="sql-syntax.html#show-tables" title="13.7.5.37&nbsp;SHOW TABLES Syntax"><code class="literal">SHOW TABLES</code></a> statement on the
        <code class="literal">INFORMATION_SCHEMA</code> database:
    </p><p style="color:blue;">innodb information_schema表提供有关innodb存储引擎各个方面的元数据、状态信息和统计信息。通过在信息架构数据库上发出show tables语句，可以查看innodb information\u架构表的列表：</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>SHOW TABLES FROM INFORMATION_SCHEMA LIKE 'INNODB%';</code></strong>
</pre><p>
        For table definitions, see <a class="xref" href="information-schema.html#innodb-i_s-tables" title="24.32&nbsp;INFORMATION_SCHEMA InnoDB Tables">Section&nbsp;24.32, “INFORMATION_SCHEMA InnoDB Tables”</a>. For
        general information regarding the <code class="literal">MySQL</code>
        <code class="literal">INFORMATION_SCHEMA</code> database, see
        <a class="xref" href="information-schema.html" title="Chapter&nbsp;24&nbsp;INFORMATION_SCHEMA Tables">Chapter&nbsp;24, <i>INFORMATION_SCHEMA Tables</i></a>.
    </p><p style="color:blue;">有关表定义，请参阅24.32节，“information_schema innodb tables”。有关mysql information_schema数据库的一般信息，请参阅第24章，information_schema tables。</p>
        <div class="section">

            <div class="titlepage">
                <div>
                    <div>
                        <h3 class="title"><a name="innodb-information-schema-compression-tables"></a>14.15.1&nbsp;InnoDB INFORMATION_SCHEMA Tables about Compression</h3>

                    </div>

                </div>

            </div>

            <div class="toc">
                <dl class="toc"><dt><span class="section"><a href="innodb-storage-engine.html#innodb-information-schema-innodb_cmp">14.15.1.1 INNODB_CMP and INNODB_CMP_RESET</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-information-schema-innodb_cmpmem">14.15.1.2 INNODB_CMPMEM and INNODB_CMPMEM_RESET</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-information-schema-examples-compression-sect">14.15.1.3 Using the Compression Information Schema Tables</a></span></dt></dl>
            </div>
            <a class="indexterm" name="idm140286808315360"></a><p>
            There are two pairs of <code class="literal">InnoDB</code>
            <code class="literal">INFORMATION_SCHEMA</code> tables about compression
            that can provide insight into how well compression is working
            overall:
        </p><p style="color:blue;">有两对关于压缩的innodb information_schema表可以提供压缩整体工作情况的细节：</p>
            <div class="itemizedlist">
                <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                    <a class="link" href="information-schema.html#innodb-cmp-table" title="24.32.4&nbsp;The INFORMATION_SCHEMA INNODB_CMP and INNODB_CMP_RESET Tables"><code class="literal">INNODB_CMP</code></a> and
                    <a class="link" href="information-schema.html#innodb-cmp-table" title="24.32.4&nbsp;The INFORMATION_SCHEMA INNODB_CMP and INNODB_CMP_RESET Tables"><code class="literal">INNODB_CMP_RESET</code></a>
                    provide information about the number of compression operations
                    and the amount of time spent performing compression.
                </p><p style="color:blue;">innodb_cmp和innodb_cmp_reset提供有关压缩操作数和执行压缩所花费时间的信息。</p></li><li class="listitem"><p>
                    <a class="link" href="information-schema.html#innodb-cmpmem-table" title="24.32.5&nbsp;The INFORMATION_SCHEMA INNODB_CMPMEM and INNODB_CMPMEM_RESET Tables"><code class="literal">INNODB_CMPMEM</code></a> and
                    <a class="link" href="information-schema.html#innodb-cmp-table" title="24.32.4&nbsp;The INFORMATION_SCHEMA INNODB_CMP and INNODB_CMP_RESET Tables"><code class="literal">INNODB_CMP_RESET</code></a>
                    provide information about the way memory is allocated for
                    compression.
                </p><p style="color:blue;">innodb_cmpmem和innodb_cmp_reset提供有关为压缩分配内存的方式的信息。</p></li></ul>
            </div>
            <div class="section">
                <div class="titlepage">
                    <div>
                        <div>
                            <h4 class="title"><a name="innodb-information-schema-innodb_cmp"></a>14.15.1.1&nbsp;INNODB_CMP and INNODB_CMP_RESET</h4>

                        </div>

                    </div>

                </div>
                <a class="indexterm" name="idm140286808303568"></a><a class="indexterm" name="idm140286808302080"></a><p>
                The <a class="link" href="information-schema.html#innodb-cmp-table" title="24.32.4&nbsp;The INFORMATION_SCHEMA INNODB_CMP and INNODB_CMP_RESET Tables"><code class="literal">INNODB_CMP</code></a> and
                <a class="link" href="information-schema.html#innodb-cmp-table" title="24.32.4&nbsp;The INFORMATION_SCHEMA INNODB_CMP and INNODB_CMP_RESET Tables"><code class="literal">INNODB_CMP_RESET</code></a>
                tables provide status information about operations related to
                compressed tables, which are described in
                <a class="xref" href="innodb-storage-engine.html#innodb-compression" title="14.9&nbsp;InnoDB Table and Page Compression">Section&nbsp;14.9, “InnoDB Table and Page Compression”</a>. The
                <code class="literal">PAGE_SIZE</code> column reports the compressed
                <a class="link" href="glossary.html#glos_page_size" title="page size">page size</a>.
            </p><p style="color:blue;">innodb_cmp和innodb_cmp_reset表提供了与压缩表相关的操作的状态信息，如第14.9节“innodb表和页面压缩”所述。“页面大小”列报告压缩的页面大小。</p><p>
                These two tables have identical contents, but reading from
                <a class="link" href="information-schema.html#innodb-cmp-table" title="24.32.4&nbsp;The INFORMATION_SCHEMA INNODB_CMP and INNODB_CMP_RESET Tables"><code class="literal">INNODB_CMP_RESET</code></a>
                resets the statistics on compression and uncompression
                operations. For example, if you archive the output of
                <a class="link" href="information-schema.html#innodb-cmp-table" title="24.32.4&nbsp;The INFORMATION_SCHEMA INNODB_CMP and INNODB_CMP_RESET Tables"><code class="literal">INNODB_CMP_RESET</code></a>
                every 60 minutes, you see the statistics for each hourly period.
                If you monitor the output of
                <a class="link" href="information-schema.html#innodb-cmp-table" title="24.32.4&nbsp;The INFORMATION_SCHEMA INNODB_CMP and INNODB_CMP_RESET Tables"><code class="literal">INNODB_CMP</code></a> (making sure never to
                read
                <a class="link" href="information-schema.html#innodb-cmp-table" title="24.32.4&nbsp;The INFORMATION_SCHEMA INNODB_CMP and INNODB_CMP_RESET Tables"><code class="literal">INNODB_CMP_RESET</code></a>),
                you see the cumulative statistics since InnoDB was started.
            </p><p style="color:blue;">这两个表具有相同的内容，但是从innodb_cmp_reset读取会重置压缩和非压缩操作的统计信息。例如，如果您每60分钟存档一次innodb_cmp_reset的输出，您将看到每小时周期的统计信息。如果监视innodb_cmp的输出（确保从不读取innodb_cmp_reset），则会看到自innodb启动以来的累积统计信息。</p><p>
                For the table definition, see
                <a class="xref" href="information-schema.html#innodb-cmp-table" title="24.32.4&nbsp;The INFORMATION_SCHEMA INNODB_CMP and INNODB_CMP_RESET Tables">Section&nbsp;24.32.4, “The INFORMATION_SCHEMA INNODB_CMP and INNODB_CMP_RESET Tables”</a>.
            </p><p style="color:blue;">有关表定义，请参阅24.32.4节，“information_schema innodb_cmp and innodb_cmp_reset tables”。</p>
            </div>
            <div class="section">
                <div class="titlepage">
                    <div>
                        <div>
                            <h4 class="title"><a name="innodb-information-schema-innodb_cmpmem"></a>14.15.1.2&nbsp;INNODB_CMPMEM and INNODB_CMPMEM_RESET</h4>

                        </div>

                    </div>

                </div>
                <a class="indexterm" name="idm140286808287200"></a><a class="indexterm" name="idm140286808285712"></a><a class="indexterm" name="idm140286808284208"></a><p>
                The <a class="link" href="information-schema.html#innodb-cmpmem-table" title="24.32.5&nbsp;The INFORMATION_SCHEMA INNODB_CMPMEM and INNODB_CMPMEM_RESET Tables"><code class="literal">INNODB_CMPMEM</code></a> and
                <a class="link" href="information-schema.html#innodb-cmpmem-table" title="24.32.5&nbsp;The INFORMATION_SCHEMA INNODB_CMPMEM and INNODB_CMPMEM_RESET Tables"><code class="literal">INNODB_CMPMEM_RESET</code></a>
                tables provide status information about compressed pages that
                reside in the buffer pool. Please consult
                <a class="xref" href="innodb-storage-engine.html#innodb-compression" title="14.9&nbsp;InnoDB Table and Page Compression">Section&nbsp;14.9, “InnoDB Table and Page Compression”</a> for further information on
                compressed tables and the use of the buffer pool. The
                <a class="link" href="information-schema.html#innodb-cmp-table" title="24.32.4&nbsp;The INFORMATION_SCHEMA INNODB_CMP and INNODB_CMP_RESET Tables"><code class="literal">INNODB_CMP</code></a> and
                <a class="link" href="information-schema.html#innodb-cmp-table" title="24.32.4&nbsp;The INFORMATION_SCHEMA INNODB_CMP and INNODB_CMP_RESET Tables"><code class="literal">INNODB_CMP_RESET</code></a>
                tables should provide more useful statistics on compression.
            </p><p style="color:blue;">innodb_cmpmem和innodb_cmpmem_reset表提供有关驻留在缓冲池中的压缩页的状态信息。有关压缩表和缓冲池使用的更多信息，请参阅第14.9节“innodb table and page compression”。innodb_cmp和innodb_cmp_reset表应该提供更有用的压缩统计信息。</p>
                <h5><a name="idm140286808276864"></a>Internal Details</h5>
                <p>
                    <code class="literal">InnoDB</code> uses a
                    <a class="link" href="glossary.html#glos_buddy_allocator" title="buddy allocator">buddy allocator</a>
                    system to manage memory allocated to
                    <a class="link" href="glossary.html#glos_page_size" title="page size">pages of various sizes</a>,
                    from 1KB to 16KB. Each row of the two tables described here
                    corresponds to a single page size.
                </p><p style="color:blue;">innodb使用一个buddy分配器系统来管理分配给大小不等的页面的内存，从1kb到16kb不等。这里描述的两个表的每一行对应一个页面大小。</p><p>
                The <a class="link" href="information-schema.html#innodb-cmpmem-table" title="24.32.5&nbsp;The INFORMATION_SCHEMA INNODB_CMPMEM and INNODB_CMPMEM_RESET Tables"><code class="literal">INNODB_CMPMEM</code></a> and
                <a class="link" href="information-schema.html#innodb-cmpmem-table" title="24.32.5&nbsp;The INFORMATION_SCHEMA INNODB_CMPMEM and INNODB_CMPMEM_RESET Tables"><code class="literal">INNODB_CMPMEM_RESET</code></a>
                tables have identical contents, but reading from
                <a class="link" href="information-schema.html#innodb-cmpmem-table" title="24.32.5&nbsp;The INFORMATION_SCHEMA INNODB_CMPMEM and INNODB_CMPMEM_RESET Tables"><code class="literal">INNODB_CMPMEM_RESET</code></a>
                resets the statistics on relocation operations. For example, if
                every 60 minutes you archived the output of
                <a class="link" href="information-schema.html#innodb-cmpmem-table" title="24.32.5&nbsp;The INFORMATION_SCHEMA INNODB_CMPMEM and INNODB_CMPMEM_RESET Tables"><code class="literal">INNODB_CMPMEM_RESET</code></a>,
                it would show the hourly statistics. If you never read
                <a class="link" href="information-schema.html#innodb-cmpmem-table" title="24.32.5&nbsp;The INFORMATION_SCHEMA INNODB_CMPMEM and INNODB_CMPMEM_RESET Tables"><code class="literal">INNODB_CMPMEM_RESET</code></a>
                and monitored the output of
                <a class="link" href="information-schema.html#innodb-cmpmem-table" title="24.32.5&nbsp;The INFORMATION_SCHEMA INNODB_CMPMEM and INNODB_CMPMEM_RESET Tables"><code class="literal">INNODB_CMPMEM</code></a> instead, it would
                show the cumulative statistics since <code class="literal">InnoDB</code>
                was started.
            </p><p style="color:blue;">innodb_cmpmem和innodb_cmpmem_reset表具有相同的内容，但是从innodb_cmpmem_reset读取会重置重新定位操作的统计信息。例如，如果每60分钟归档一次innodb_cmpmem_reset的输出，它将显示每小时的统计数据。如果您从未读取innodb_cmpmem_reset，而是监视innodb_cmpmem的输出，它将显示自innodb启动以来的累积统计信息。</p><p>
                For the table definition, see
                <a class="xref" href="information-schema.html#innodb-cmpmem-table" title="24.32.5&nbsp;The INFORMATION_SCHEMA INNODB_CMPMEM and INNODB_CMPMEM_RESET Tables">Section&nbsp;24.32.5, “The INFORMATION_SCHEMA INNODB_CMPMEM and INNODB_CMPMEM_RESET Tables”</a>.
            </p><p style="color:blue;">有关表定义，请参见第24.32.5节“信息模式innodb_cmpmem和innodb_cmpmem_reset tables”。</p>
            </div>

            <div class="section">

                <div class="titlepage">
                    <div>
                        <div>
                            <h4 class="title"><a name="innodb-information-schema-examples-compression-sect"></a>14.15.1.3&nbsp;Using the Compression Information Schema Tables</h4>

                        </div>

                    </div>

                </div>

                <div class="example">
                    <a name="innodb-information-schema-examples-compression"></a><p class="title"><b>Example&nbsp;14.1&nbsp;Using the Compression Information Schema Tables</b></p><p style="color:blue;">示例14.1使用压缩信息模式表</p>
                    <div class="example-contents">
                        <p>
                            The following is sample output from a database that contains
                            compressed tables (see <a class="xref" href="innodb-storage-engine.html#innodb-compression" title="14.9&nbsp;InnoDB Table and Page Compression">Section&nbsp;14.9, “InnoDB Table and Page Compression”</a>,
                            <a class="link" href="information-schema.html#innodb-cmp-table" title="24.32.4&nbsp;The INFORMATION_SCHEMA INNODB_CMP and INNODB_CMP_RESET Tables"><code class="literal">INNODB_CMP</code></a>,
                            <a class="link" href="information-schema.html#innodb-cmp-per-index-table" title="24.32.6&nbsp;The INFORMATION_SCHEMA INNODB_CMP_PER_INDEX and INNODB_CMP_PER_INDEX_RESET Tables"><code class="literal">INNODB_CMP_PER_INDEX</code></a>, and
                            <a class="link" href="information-schema.html#innodb-cmpmem-table" title="24.32.5&nbsp;The INFORMATION_SCHEMA INNODB_CMPMEM and INNODB_CMPMEM_RESET Tables"><code class="literal">INNODB_CMPMEM</code></a>).
                        </p><p style="color:blue;">以下是包含压缩表的数据库的示例输出（请参阅第14.9节“innodb table and page compression”、innodb_cmp、innodb_cmp_per_index和innodb_cmpmem）。</p><p>
                        The following table shows the contents of
                        <a class="link" href="information-schema.html#innodb-cmp-table" title="24.32.4&nbsp;The INFORMATION_SCHEMA INNODB_CMP and INNODB_CMP_RESET Tables"><code class="literal">INFORMATION_SCHEMA.INNODB_CMP</code></a>
                        under a light <a class="link" href="glossary.html#glos_workload" title="workload">workload</a>.
                        The only compressed page size that the buffer pool contains is
                        8K. Compressing or uncompressing pages has consumed less than
                        a second since the time the statistics were reset, because the
                        columns <code class="literal">COMPRESS_TIME</code> and
                        <code class="literal">UNCOMPRESS_TIME</code> are zero.
                    </p><p style="color:blue;">下表显示了在轻工作负载下information_schema.innodb_cmp的内容。缓冲池包含的唯一压缩页大小是8K。由于压缩时间和解压缩时间列为零，因此自统计信息重置后，压缩或解压缩页所用的时间不到一秒。</p>
                        <div class="informaltable">
                            <a name="innodb-information-schema-sample-innodb_cmp"></a><table summary="Sample data from the INFORMATION_SCHEMA.INNODB_CMP table, showing the internal workings of InnoDB table compression under a light workload."><colgroup><col width="15%"><col width="15%"><col width="15%"><col width="15%"><col width="20%"><col width="20%"></colgroup><thead><tr>
                            <th scope="col">page size</th>
                            <th scope="col">compress ops</th>
                            <th scope="col">compress ops ok</th>
                            <th scope="col">compress time</th>
                            <th scope="col">uncompress ops</th>
                            <th scope="col">uncompress time</th>
                        </tr></thead><tbody><tr>
                            <td scope="row">1024</td>
                            <td>0</td>
                            <td>0</td>
                            <td>0</td>
                            <td>0</td>
                            <td>0</td>
                        </tr><tr>
                            <td scope="row">2048</td>
                            <td>0</td>
                            <td>0</td>
                            <td>0</td>
                            <td>0</td>
                            <td>0</td>
                        </tr><tr>
                            <td scope="row">4096</td>
                            <td>0</td>
                            <td>0</td>
                            <td>0</td>
                            <td>0</td>
                            <td>0</td>
                        </tr><tr>
                            <td scope="row">8192</td>
                            <td>1048</td>
                            <td>921</td>
                            <td>0</td>
                            <td>61</td>
                            <td>0</td>
                        </tr><tr>
                            <td scope="row">16384</td>
                            <td>0</td>
                            <td>0</td>
                            <td>0</td>
                            <td>0</td>
                            <td>0</td>
                        </tr></tbody></table>
                        </div>
                        <p>
                            According to <a class="link" href="information-schema.html#innodb-cmpmem-table" title="24.32.5&nbsp;The INFORMATION_SCHEMA INNODB_CMPMEM and INNODB_CMPMEM_RESET Tables"><code class="literal">INNODB_CMPMEM</code></a>, there
                            are 6169 compressed 8KB pages in the
                            <a class="link" href="glossary.html#glos_buffer_pool" title="buffer pool">buffer pool</a>. The only
                            other allocated block size is 64 bytes. The smallest
                            <code class="literal">PAGE_SIZE</code> in
                            <a class="link" href="information-schema.html#innodb-cmpmem-table" title="24.32.5&nbsp;The INFORMATION_SCHEMA INNODB_CMPMEM and INNODB_CMPMEM_RESET Tables"><code class="literal">INNODB_CMPMEM</code></a> is used for block
                            descriptors of those compressed pages for which no
                            uncompressed page exists in the buffer pool. We see that there
                            are 5910 such pages. Indirectly, we see that 259 (6169-5910)
                            compressed pages also exist in the buffer pool in uncompressed
                            form.
                        </p><p style="color:blue;">根据innodb_cmpmem，缓冲池中有6169个压缩的8kb页面。唯一分配的块大小是64字节。在UNIQUBYCMPMEM中最小的Page大小用于那些压缩页的块描述符，在缓冲池中没有未压缩的页。我们看到这样的页面有5910页。间接地，我们看到259（6169—5910）压缩页也以非压缩的形式存在于缓冲池中。</p><p>
                        The following table shows the contents of
                        <a class="link" href="information-schema.html#innodb-cmpmem-table" title="24.32.5&nbsp;The INFORMATION_SCHEMA INNODB_CMPMEM and INNODB_CMPMEM_RESET Tables"><code class="literal">INFORMATION_SCHEMA.INNODB_CMPMEM</code></a>
                        under a light <a class="link" href="glossary.html#glos_workload" title="workload">workload</a>.
                        Some memory is unusable due to fragmentation of the memory
                        allocator for compressed pages:
                        <code class="literal">SUM(PAGE_SIZE*PAGES_FREE)=6784</code>. This is
                        because small memory allocation requests are fulfilled by
                        splitting bigger blocks, starting from the 16K blocks that are
                        allocated from the main buffer pool, using the buddy
                        allocation system. The fragmentation is this low because some
                        allocated blocks have been relocated (copied) to form bigger
                        adjacent free blocks. This copying of
                        <code class="literal">SUM(PAGE_SIZE*RELOCATION_OPS)</code> bytes has
                        consumed less than a second
                        <code class="literal">(SUM(RELOCATION_TIME)=0)</code>.
                    </p><p style="color:blue;">下表显示了轻工作负载下information_schema.innodb_cmpmem的内容。由于压缩页的内存分配器碎片化，某些内存不可用：sum（page_size*pages_free）=6784。这是因为小内存分配请求是通过使用buddy分配系统拆分更大的块来实现的，从从主缓冲池分配的16k个块开始。碎片如此之低是因为一些分配的块已经被重新定位（复制）以形成更大的相邻空闲块。复制sum（page_size*relocation_ops）字节所用的时间少于1秒（sum（relocation_time）=0）。</p>
                        <div class="informaltable">
                            <a name="innodb-information-schema-sample-innodb_cmpmem"></a><table summary="Sample data from the INFORMATION_SCHEMA.INNODB_CMPMEM table, showing buffer pool memory operations for InnoDB table compression under a light workload."><colgroup><col width="15%"><col width="15%"><col width="20%"><col width="20%"><col width="20%"></colgroup><thead><tr>
                            <th scope="col">page size</th>
                            <th scope="col">pages used</th>
                            <th scope="col">pages free</th>
                            <th scope="col">relocation ops</th>
                            <th scope="col">relocation time</th>
                        </tr></thead><tbody><tr>
                            <td scope="row">64</td>
                            <td>5910</td>
                            <td>0</td>
                            <td>2436</td>
                            <td>0</td>
                        </tr><tr>
                            <td scope="row">128</td>
                            <td>0</td>
                            <td>1</td>
                            <td>0</td>
                            <td>0</td>
                        </tr><tr>
                            <td scope="row">256</td>
                            <td>0</td>
                            <td>0</td>
                            <td>0</td>
                            <td>0</td>
                        </tr><tr>
                            <td scope="row">512</td>
                            <td>0</td>
                            <td>1</td>
                            <td>0</td>
                            <td>0</td>
                        </tr><tr>
                            <td scope="row">1024</td>
                            <td>0</td>
                            <td>0</td>
                            <td>0</td>
                            <td>0</td>
                        </tr><tr>
                            <td scope="row">2048</td>
                            <td>0</td>
                            <td>1</td>
                            <td>0</td>
                            <td>0</td>
                        </tr><tr>
                            <td scope="row">4096</td>
                            <td>0</td>
                            <td>1</td>
                            <td>0</td>
                            <td>0</td>
                        </tr><tr>
                            <td scope="row">8192</td>
                            <td>6169</td>
                            <td>0</td>
                            <td>5</td>
                            <td>0</td>
                        </tr><tr>
                            <td scope="row">16384</td>
                            <td>0</td>
                            <td>0</td>
                            <td>0</td>
                            <td>0</td>
                        </tr></tbody></table>
                        </div>

                    </div>

                </div>
                <br class="example-break">
            </div>

        </div>
        <div class="section">
            <div class="titlepage">
                <div>
                    <div>
                        <h3 class="title"><a name="innodb-information-schema-transactions"></a>14.15.2&nbsp;InnoDB INFORMATION_SCHEMA Transaction and Locking Information</h3>

                    </div>

                </div>

            </div>
            <div class="toc">
                <dl class="toc"><dt><span class="section"><a href="innodb-storage-engine.html#innodb-information-schema-examples">14.15.2.1 Using InnoDB Transaction and Locking Information</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-information-schema-understanding-innodb-locking">14.15.2.2 InnoDB Lock and Lock-Wait Information</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-information-schema-internal-data">14.15.2.3 Persistence and Consistency of InnoDB Transaction and Locking
Information</a></span></dt></dl>
            </div>
            <a class="indexterm" name="idm140286808139984"></a><p>
            Three <code class="literal">InnoDB</code>
            <code class="literal">INFORMATION_SCHEMA</code> tables enable you to monitor
            transactions and diagnose potential locking problems:
        </p><p style="color:blue;">三个innodb information_schema表使您能够监视事务并诊断潜在的锁定问题：</p>
            <div class="itemizedlist">
                <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                    <a class="link" href="information-schema.html#innodb-trx-table" title="24.32.26&nbsp;The INFORMATION_SCHEMA INNODB_TRX Table"><code class="literal">INNODB_TRX</code></a>: Provides information
                    about every transaction currently executing inside
                    <code class="literal">InnoDB</code>, including the transaction state
                    (for example, whether it is running or waiting for a lock),
                    when the transaction started, and the particular SQL statement
                    the transaction is executing.
                </p><p style="color:blue;">innodb_trx：提供innodb中当前执行的每个事务的信息，包括事务状态（例如，它是在运行还是在等待锁）、事务何时启动以及事务执行的特定sql语句。</p><a class="indexterm" name="idm140286808133504"></a></li><li class="listitem"><p>
                    <a class="link" href="information-schema.html#innodb-locks-table" title="24.32.13&nbsp;The INFORMATION_SCHEMA INNODB_LOCKS Table"><code class="literal">INNODB_LOCKS</code></a>: Each transaction in
                    InnoDB that is waiting for another transaction to release a
                    lock (<code class="literal">INNODB_TRX.TRX_STATE</code> is <code class="literal">LOCK
                    WAIT</code>) is blocked by exactly one blocking lock
                    request. That blocking lock request is for a row or table lock
                    held by another transaction in an incompatible mode. A lock
                    that blocks a transaction is always held in a mode
                    incompatible with the mode of requested lock (read vs. write,
                    shared vs. exclusive). The blocked transaction cannot proceed
                    until the other transaction commits or rolls back, thereby
                    releasing the requested lock. For every blocked transaction,
                    <a class="link" href="information-schema.html#innodb-locks-table" title="24.32.13&nbsp;The INFORMATION_SCHEMA INNODB_LOCKS Table"><code class="literal">INNODB_LOCKS</code></a> contains one row
                    that describes each lock the transaction has requested, and
                    for which it is waiting.
                    <a class="link" href="information-schema.html#innodb-locks-table" title="24.32.13&nbsp;The INFORMATION_SCHEMA INNODB_LOCKS Table"><code class="literal">INNODB_LOCKS</code></a> also contains one
                    row for each lock that is blocking another transaction,
                    whatever the state of the transaction that holds the lock
                    (<code class="literal">INNODB_TRX.TRX_STATE</code> is
                    <code class="literal">RUNNING</code>, <code class="literal">LOCK WAIT</code>,
                    <code class="literal">ROLLING BACK</code> or
                    <code class="literal">COMMITTING</code>).
                </p><p style="color:blue;">innodb_locks：innodb中等待另一个事务释放锁（innodb_trx.trx_state为lock wait）的每个事务都被一个阻塞锁请求阻塞。该阻塞锁请求用于另一个事务以不兼容模式持有的行或表锁。阻塞事务的锁总是以与请求锁模式不兼容的模式（读与写、共享与排他）持有。在另一个事务提交或回滚，从而释放请求的锁之前，被阻止的事务无法继续。对于每个被阻塞的事务，innodb_locks包含一行，描述事务请求的每个锁，以及事务正在等待的每个锁。innodb_locks还为阻塞另一个事务的每个锁包含一行，不管持有锁的事务的状态如何（innodb_trx.trx_state is running、lock wait、rolling back或committing）。</p><a class="indexterm" name="idm140286808121664"></a></li><li class="listitem"><p>
                    <a class="link" href="information-schema.html#innodb-lock-waits-table" title="24.32.14&nbsp;The INFORMATION_SCHEMA INNODB_LOCK_WAITS Table"><code class="literal">INNODB_LOCK_WAITS</code></a>: This table
                    indicates which transactions are waiting for a given lock, or
                    for which lock a given transaction is waiting. This table
                    contains one or more rows for each blocked transaction,
                    indicating the lock it has requested and any locks that are
                    blocking that request. The
                    <code class="literal">REQUESTED_LOCK_ID</code> value refers to the lock
                    requested by a transaction, and the
                    <code class="literal">BLOCKING_LOCK_ID</code> value refers to the lock
                    (held by another transaction) that prevents the first
                    transaction from proceeding. For any given blocked
                    transaction, all rows in
                    <a class="link" href="information-schema.html#innodb-lock-waits-table" title="24.32.14&nbsp;The INFORMATION_SCHEMA INNODB_LOCK_WAITS Table"><code class="literal">INNODB_LOCK_WAITS</code></a> have the same
                    value for <code class="literal">REQUESTED_LOCK_ID</code> and different
                    values for <code class="literal">BLOCKING_LOCK_ID</code>.
                </p><p style="color:blue;">innodb_lock_waits：此表指示哪些事务正在等待给定的锁，或者给定事务正在等待哪个锁。此表包含每个被阻止事务的一行或多行，指示它请求的锁和阻止该请求的任何锁。请求的锁id值是指事务请求的锁，阻塞的锁id值是指阻止第一个事务继续进行的锁（由另一个事务持有）。对于任何给定的阻塞事务，innodb_lock_waits中的所有行对于请求的_lock_id都有相同的值，对于阻塞的_lock_id则有不同的值。</p><a class="indexterm" name="idm140286808113136"></a></li></ul>
            </div>
            <p>
                For more information about the preceding tables, see
                <a class="xref" href="information-schema.html#innodb-trx-table" title="24.32.26&nbsp;The INFORMATION_SCHEMA INNODB_TRX Table">Section&nbsp;24.32.26, “The INFORMATION_SCHEMA INNODB_TRX Table”</a>,
                <a class="xref" href="information-schema.html#innodb-locks-table" title="24.32.13&nbsp;The INFORMATION_SCHEMA INNODB_LOCKS Table">Section&nbsp;24.32.13, “The INFORMATION_SCHEMA INNODB_LOCKS Table”</a>, and
                <a class="xref" href="information-schema.html#innodb-lock-waits-table" title="24.32.14&nbsp;The INFORMATION_SCHEMA INNODB_LOCK_WAITS Table">Section&nbsp;24.32.14, “The INFORMATION_SCHEMA INNODB_LOCK_WAITS Table”</a>.
            </p><p style="color:blue;">有关上述表的更多信息，请参见第24.32.26节，“information_schema innodb_trx table”，第24.32.13节，“information_schema innodb_locks table”，第24.32.14节，“information_schema innodb_lock_waits table”。</p>
            <div class="section">

                <div class="titlepage">
                    <div>
                        <div>
                            <h4 class="title"><a name="innodb-information-schema-examples"></a>14.15.2.1&nbsp;Using InnoDB Transaction and Locking Information</h4>
                        </div>
                    </div>
                </div>

                <div class="simplesect">

                    <div class="titlepage">
                        <div>

                            <div class="simple">
                                <h5 class="title"><a name="innodb-information-schema-examples-simple-blocking"></a>Identifying Blocking Transactions</h5>
                            </div>
                        </div>
                    </div>
                    <p>
                        It is sometimes helpful to identify which transaction blocks
                        another. The tables that contain information about
                        <code class="literal">InnoDB</code> transactions and data locks enable
                        you to determine which transaction is waiting for another, and
                        which resource is being requested. (For descriptions of these
                        tables, see
                        <a class="xref" href="innodb-storage-engine.html#innodb-information-schema-transactions" title="14.15.2&nbsp;InnoDB INFORMATION_SCHEMA Transaction and Locking Information">Section&nbsp;14.15.2, “InnoDB INFORMATION_SCHEMA Transaction and Locking Information”</a>.)
                    </p><p style="color:blue;">有时识别哪些事务阻塞了另一个事务是有帮助的。包含有关innodb事务和数据锁的信息的表使您能够确定哪个事务正在等待另一个事务，以及正在请求哪个资源。（有关这些表的说明，请参阅14.15.2节，“innodb information_schema transaction and locking information”。）</p><p>
                    Suppose that three sessions are running concurrently. Each
                    session corresponds to a MySQL thread, and executes one
                    transaction after another. Consider the state of the system
                    when these sessions have issued the following statements, but
                    none has yet committed its transaction:
                </p><p style="color:blue;">假设三个会话同时运行。每个会话对应一个mysql线程，并执行一个又一个事务。当这些会话已发出以下语句，但尚未提交其事务时，请考虑系统的状态：</p>
                    <div class="itemizedlist">
                        <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                            Session A:
                        </p><p style="color:blue;">会议A：</p><pre data-lang="sql" class="programlisting">BEGIN;
SELECT a FROM t FOR UPDATE;
SELECT SLEEP(100);
</pre></li><li class="listitem"><p>
                            Session B:
                        </p><p style="color:blue;">会议B：</p><pre data-lang="sql" class="programlisting">SELECT b FROM t FOR UPDATE;
</pre></li><li class="listitem"><p>
                            Session C:
                        </p><p style="color:blue;">会议C：</p><pre data-lang="sql" class="programlisting">SELECT c FROM t FOR UPDATE;
</pre></li></ul>
                    </div>
                    <p>
                        In this scenario, use the following query to see which
                        transactions are waiting and which transactions are blocking
                        them:
                    </p><p style="color:blue;">在此场景中，使用以下查询查看哪些事务正在等待以及哪些事务正在阻止它们：</p><pre data-lang="sql" class="programlisting">SELECT
  r.trx_id waiting_trx_id,
  r.trx_mysql_thread_id waiting_thread,
  r.trx_query waiting_query,
  b.trx_id blocking_trx_id,
  b.trx_mysql_thread_id blocking_thread,
  b.trx_query blocking_query
FROM       information_schema.innodb_lock_waits w
INNER JOIN information_schema.innodb_trx b
  ON b.trx_id = w.blocking_trx_id
INNER JOIN information_schema.innodb_trx r
  ON r.trx_id = w.requesting_trx_id;
</pre><p>
                    Or, more simply, use the <code class="literal">sys</code> schema
                    <a class="link" href="sys-schema.html#sys-innodb-lock-waits" title="26.4.3.9&nbsp;The innodb_lock_waits and x$innodb_lock_waits Views"><code class="literal">innodb_lock_waits</code></a> view:
                </p><p style="color:blue;">或者，更简单地说，使用sys schema innodb_lock_waits视图：</p><pre data-lang="sql" class="programlisting">SELECT
  waiting_trx_id,
  waiting_pid,
  waiting_query,
  blocking_trx_id,
  blocking_pid,
  blocking_query
FROM sys.innodb_lock_waits;
</pre><p>
                    If a NULL value is reported for the blocking query, see
                    <a class="xref" href="innodb-storage-engine.html#innodb-information-schema-examples-null-blocking-query" title="Identifying a Blocking Query After the Issuing Session Becomes Idle">Identifying a Blocking Query After the Issuing Session Becomes Idle</a>.
                </p><p style="color:blue;">如果为阻塞查询报告了空值，请参阅在发出会话变为空闲后标识阻塞查询。</p>
                    <div class="informaltable">
                        <table summary="The result set of a query against the INFORMATION_SCHEMA.INNODB_LOCK_WAITS and INFORMATION_SCHEMA.INNODB_TRX tables, shown in the preceding text, indicating which InnoDB threads are waiting for which other threads."><colgroup><col width="9%"><col width="9%"><col width="33%"><col width="10%"><col width="10%"><col width="33%"></colgroup><thead><tr>
                            <th scope="col">waiting trx id</th>
                            <th scope="col">waiting thread</th>
                            <th scope="col">waiting query</th>
                            <th scope="col">blocking trx id</th>
                            <th scope="col">blocking thread</th>
                            <th scope="col">blocking query</th>
                        </tr></thead><tbody><tr>
                            <td scope="row"><code class="literal">A4</code></td>
                            <td><code class="literal">6</code></td>
                            <td><code class="literal">SELECT b FROM t FOR UPDATE</code></td>
                            <td><code class="literal">A3</code></td>
                            <td><code class="literal">5</code></td>
                            <td><code class="literal">SELECT SLEEP(100)</code></td>
                        </tr><tr>
                            <td scope="row"><code class="literal">A5</code></td>
                            <td><code class="literal">7</code></td>
                            <td><code class="literal">SELECT c FROM t FOR UPDATE</code></td>
                            <td><code class="literal">A3</code></td>
                            <td><code class="literal">5</code></td>
                            <td><code class="literal">SELECT SLEEP(100)</code></td>
                        </tr><tr>
                            <td scope="row"><code class="literal">A5</code></td>
                            <td><code class="literal">7</code></td>
                            <td><code class="literal">SELECT c FROM t FOR UPDATE</code></td>
                            <td><code class="literal">A4</code></td>
                            <td><code class="literal">6</code></td>
                            <td><code class="literal">SELECT b FROM t FOR UPDATE</code></td>
                        </tr></tbody></table>
                    </div>
                    <p>
                        In the preceding table, you can identify sessions by the
                        <span class="quote">“<span class="quote">waiting query</span>”</span> or <span class="quote">“<span class="quote">blocking query</span>”</span>
                        columns. As you can see:
                    </p><p style="color:blue;">在上表中，可以通过“waiting query”或“blocking query”列标识会话。如你所见：</p>
                    <div class="itemizedlist">
                        <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                            Session B (trx id <code class="literal">A4</code>, thread
                            <code class="literal">6</code>) and Session C (trx id
                            <code class="literal">A5</code>, thread <code class="literal">7</code>) are
                            both waiting for Session A (trx id <code class="literal">A3</code>,
                            thread <code class="literal">5</code>).
                        </p><p style="color:blue;">会话B（trx id a4，线程6）和会话C（trx id a5，线程7）都在等待会话A（trx id a3，线程5）。</p></li><li class="listitem"><p>
                            Session C is waiting for Session B as well as Session A.
                        </p><p style="color:blue;">会话C正在等待会话B和会话A。</p></li></ul>
                    </div>
                    <p>
                        You can see the underlying data in the tables
                        <a class="link" href="innodb-storage-engine.html#innodb-information-schema-examples-simple-blocking-trx"><code class="literal">INNODB_TRX</code></a>,
                        <a class="link" href="innodb-storage-engine.html#innodb-information-schema-examples-simple-blocking-locks"><code class="literal">INNODB_LOCKS</code></a>,
                        and
                        <a class="link" href="innodb-storage-engine.html#innodb-information-schema-examples-simple-blocking-waits"><code class="literal">INNODB_LOCK_WAITS</code></a>.
                    </p><p style="color:blue;">您可以在innodb_trx、innodb_locks和innodb_lock_waits表中看到底层数据。</p><p>
                    The following table shows some sample contents of
                    <a class="link" href="information-schema.html#innodb-trx-table" title="24.32.26&nbsp;The INFORMATION_SCHEMA INNODB_TRX Table"><code class="literal">INFORMATION_SCHEMA.INNODB_TRX</code></a>.
                </p><p style="color:blue;">下表显示了information schema.innodb_trx的一些示例内容。</p>
                    <div class="informaltable">
                        <a name="innodb-information-schema-examples-simple-blocking-trx"></a><table summary="Sample data from the INFORMATION_SCHEMA.INNODB_TRX table, showing the typical types of entries for each column."><colgroup><col width="10%"><col width="13%"><col width="36%"><col width="30%"><col width="36%"><col width="19%"><col width="23%"><col width="45%"></colgroup><thead><tr>
                        <th scope="col">trx id</th>
                        <th scope="col">trx state</th>
                        <th scope="col">trx started</th>
                        <th scope="col">trx requested lock id</th>
                        <th scope="col">trx wait started</th>
                        <th scope="col">trx weight</th>
                        <th scope="col">trx mysql thread id</th>
                        <th scope="col">trx query</th>
                    </tr></thead><tbody><tr>
                        <td scope="row"><code class="literal">A3</code></td>
                        <td><code class="literal">RUN­NING</code></td>
                        <td><code class="literal">2008-01-15 16:44:54</code></td>
                        <td><code class="literal">NULL</code></td>
                        <td><code class="literal">NULL</code></td>
                        <td><code class="literal">2</code></td>
                        <td><code class="literal">5</code></td>
                        <td><code class="literal">SELECT SLEEP(100)</code></td>
                    </tr><tr>
                        <td scope="row"><code class="literal">A4</code></td>
                        <td><code class="literal">LOCK WAIT</code></td>
                        <td><code class="literal">2008-01-15 16:45:09</code></td>
                        <td><code class="literal">A4:1:3:2</code></td>
                        <td><code class="literal">2008-01-15 16:45:09</code></td>
                        <td><code class="literal">2</code></td>
                        <td><code class="literal">6</code></td>
                        <td><code class="literal">SELECT b FROM t FOR UPDATE</code></td>
                    </tr><tr>
                        <td scope="row"><code class="literal">A5</code></td>
                        <td><code class="literal">LOCK WAIT</code></td>
                        <td><code class="literal">2008-01-15 16:45:14</code></td>
                        <td><code class="literal">A5:1:3:2</code></td>
                        <td><code class="literal">2008-01-15 16:45:14</code></td>
                        <td><code class="literal">2</code></td>
                        <td><code class="literal">7</code></td>
                        <td><code class="literal">SELECT c FROM t FOR UPDATE</code></td>
                    </tr></tbody></table>
                    </div>
                    <p>
                        The following table shows some sample contents of
                        <a class="link" href="information-schema.html#innodb-locks-table" title="24.32.13&nbsp;The INFORMATION_SCHEMA INNODB_LOCKS Table"><code class="literal">INFORMATION_SCHEMA.INNODB_LOCKS</code></a>.
                    </p><p style="color:blue;">下表显示了information_schema.innodb_locks的一些示例内容。</p>
                    <div class="informaltable">
                        <a name="innodb-information-schema-examples-simple-blocking-locks"></a><table summary="Sample data from the INFORMATION_SCHEMA.INNODB_LOCKS table, showing the typical types of entries for each column."><colgroup><col width="26%"><col width="13%"><col width="14%"><col width="21%"><col width="31%"><col width="29%"><col width="20%"></colgroup><thead><tr>
                        <th scope="col">lock id</th>
                        <th scope="col">lock trx id</th>
                        <th scope="col">lock mode</th>
                        <th scope="col">lock type</th>
                        <th scope="col">lock table</th>
                        <th scope="col">lock index</th>
                        <th scope="col">lock data</th>
                    </tr></thead><tbody><tr>
                        <td scope="row"><code class="literal">A3:1:3:2</code></td>
                        <td><code class="literal">A3</code></td>
                        <td><code class="literal">X</code></td>
                        <td><code class="literal">RECORD</code></td>
                        <td><code class="literal">test.t</code></td>
                        <td><code class="literal">PRIMARY</code></td>
                        <td><code class="literal">0x0200</code></td>
                    </tr><tr>
                        <td scope="row"><code class="literal">A4:1:3:2</code></td>
                        <td><code class="literal">A4</code></td>
                        <td><code class="literal">X</code></td>
                        <td><code class="literal">RECORD</code></td>
                        <td><code class="literal">test.t</code></td>
                        <td><code class="literal">PRIMARY</code></td>
                        <td><code class="literal">0x0200</code></td>
                    </tr><tr>
                        <td scope="row"><code class="literal">A5:1:3:2</code></td>
                        <td><code class="literal">A5</code></td>
                        <td><code class="literal">X</code></td>
                        <td><code class="literal">RECORD</code></td>
                        <td><code class="literal">test.t</code></td>
                        <td><code class="literal">PRIMARY</code></td>
                        <td><code class="literal">0x0200</code></td>
                    </tr></tbody></table>
                    </div>
                    <p>
                        The following table shows some sample contents of
                        <a class="link" href="information-schema.html#innodb-lock-waits-table" title="24.32.14&nbsp;The INFORMATION_SCHEMA INNODB_LOCK_WAITS Table"><code class="literal">INFORMATION_SCHEMA.INNODB_LOCK_WAITS</code></a>.
                    </p><p style="color:blue;">下表显示了information_schema.innodb_lock_waits的一些示例内容。</p>
                    <div class="informaltable">
                        <a name="innodb-information-schema-examples-simple-blocking-waits"></a><table summary="Sample data from the INFORMATION_SCHEMA.INNODB_LOCK_WAITS table, showing the typical types of entries for each column."><colgroup><col width="10%"><col width="15%"><col width="10%"><col width="15%"></colgroup><thead><tr>
                        <th scope="col">requesting trx id</th>
                        <th scope="col">requested lock id</th>
                        <th scope="col">blocking trx id</th>
                        <th scope="col">blocking lock id</th>
                    </tr></thead><tbody><tr>
                        <td scope="row"><code class="literal">A4</code></td>
                        <td><code class="literal">A4:1:3:2</code></td>
                        <td><code class="literal">A3</code></td>
                        <td><code class="literal">A3:1:3:2</code></td>
                    </tr><tr>
                        <td scope="row"><code class="literal">A5</code></td>
                        <td><code class="literal">A5:1:3:2</code></td>
                        <td><code class="literal">A3</code></td>
                        <td><code class="literal">A3:1:3:2</code></td>
                    </tr><tr>
                        <td scope="row"><code class="literal">A5</code></td>
                        <td><code class="literal">A5:1:3:2</code></td>
                        <td><code class="literal">A4</code></td>
                        <td><code class="literal">A4:1:3:2</code></td>
                    </tr></tbody></table>
                    </div>

                </div>
                <div class="simplesect">
                    <div class="titlepage">
                        <div>
                            <div class="simple">
                                <h5 class="title"><a name="innodb-information-schema-examples-null-blocking-query"></a>Identifying a Blocking Query After the Issuing Session Becomes Idle</h5>

                            </div>

                        </div>

                    </div>
                    <p>
                        When identifying blocking transactions, a NULL value is
                        reported for the blocking query if the session that issued the
                        query has become idle. In this case, use the following steps
                        to determine the blocking query:
                    </p><p style="color:blue;">在识别阻塞事务时，如果发出查询的会话变为空闲，则会为阻塞查询报告一个空值。在这种情况下，使用以下步骤确定阻塞查询：</p>
                    <div class="orderedlist">
                        <ol class="orderedlist" type="1"><li class="listitem"><p>
                            Identify the processlist ID of the blocking transaction.
                            In the <a class="link" href="sys-schema.html#sys-innodb-lock-waits" title="26.4.3.9&nbsp;The innodb_lock_waits and x$innodb_lock_waits Views"><code class="literal">sys.innodb_lock_waits</code></a>
                            table, the processlist ID of the blocking transaction is
                            the <code class="literal">blocking_pid</code> value.
                        </p><p style="color:blue;">标识阻塞事务的processlist id。在sys.innodb_lock_waits表中，阻塞事务的processlist id是阻塞pid值。</p></li><li class="listitem"><p>
                            Using the <code class="literal">blocking_pid</code>, query the MySQL
                            Performance Schema <a class="link" href="performance-schema.html#threads-table" title="25.12.16.3&nbsp;The threads Table"><code class="literal">threads</code></a>
                            table to determine the <code class="literal">THREAD_ID</code> of the
                            blocking transaction. For example, if the
                            <code class="literal">blocking_pid</code> is 6, issue this query:
                        </p><p style="color:blue;">使用阻塞PID，查询mysql performance schema threads表以确定阻塞事务的线程ID。例如，如果阻塞PID为6，则发出以下查询：</p><pre data-lang="sql" class="programlisting">SELECT THREAD_ID FROM performance_schema.threads WHERE PROCESSLIST_ID = 6;
</pre></li><li class="listitem"><p>
                            Using the <code class="literal">THREAD_ID</code>, query the
                            Performance Schema
                            <a class="link" href="performance-schema.html#events-statements-current-table" title="25.12.6.1&nbsp;The events_statements_current Table"><code class="literal">events_statements_current</code></a>
                            table to determine the last query executed by the thread.
                            For example, if the <code class="literal">THREAD_ID</code> is 28,
                            issue this query:
                        </p><p style="color:blue;">使用thread_id，查询performance schema events_statements_current表，以确定线程执行的最后一个查询。例如，如果线程id是28，则发出以下查询：</p><pre data-lang="sql" class="programlisting">SELECT THREAD_ID, SQL_TEXT FROM performance_schema.events_statements_current
WHERE THREAD_ID = 28\G
</pre></li><li class="listitem"><p>
                            If the last query executed by the thread is not enough
                            information to determine why a lock is held, you can query
                            the Performance Schema
                            <a class="link" href="performance-schema.html#events-statements-history-table" title="25.12.6.2&nbsp;The events_statements_history Table"><code class="literal">events_statements_history</code></a>
                            table to view the last 10 statements executed by the
                            thread.
                        </p><p style="color:blue;">如果线程执行的最后一个查询没有足够的信息来确定锁定的原因，可以查询performance schema events_statements_history表来查看线程执行的最后10个语句。</p><pre data-lang="sql" class="programlisting">SELECT THREAD_ID, SQL_TEXT FROM performance_schema.events_statements_history
WHERE THREAD_ID = 28 ORDER BY EVENT_ID;
</pre></li></ol>
                    </div>

                </div>
                <div class="simplesect">
                    <div class="titlepage">
                        <div>
                            <div class="simple">
                                <h5 class="title"><a name="innodb-information-schema-sample-locks"></a>Correlating InnoDB Transactions with MySQL Sessions</h5>

                            </div>

                        </div>

                    </div>
                    <p>
                        Sometimes it is useful to correlate internal
                        <code class="literal">InnoDB</code> locking information with the
                        session-level information maintained by MySQL. For example,
                        you might like to know, for a given <code class="literal">InnoDB</code>
                        transaction ID, the corresponding MySQL session ID and name of
                        the session that may be holding a lock, and thus blocking
                        other transactions.
                    </p><p style="color:blue;">有时将内部innodb锁定信息与mysql维护的会话级信息关联起来是很有用的。例如，您可能想知道，对于给定的innodb事务id，对应的mysql会话id和可能持有锁的会话的名称，从而阻塞其他事务。</p><p>
                    The following output from the
                    <code class="literal">INFORMATION_SCHEMA</code> tables is taken from a
                    somewhat loaded system. As can be seen, there are several
                    transactions running.
                </p><p style="color:blue;">信息架构表的以下输出来自一个有点加载的系统。可以看到，有几个事务正在运行。</p><p>
                    The following <code class="literal">INNODB_LOCKS</code> and
                    <code class="literal">INNODB_LOCK_WAITS</code> tables show that:
                </p><p style="color:blue;">以下innodb_locks和innodb_lock_waits表显示：</p>
                    <div class="itemizedlist">
                        <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                            Transaction <code class="literal">77F</code> (executing an
                            <a class="link" href="sql-syntax.html#insert" title="13.2.5&nbsp;INSERT Syntax"><code class="literal">INSERT</code></a>) is waiting for
                            transactions <code class="literal">77E</code>,
                            <code class="literal">77D</code>, and <code class="literal">77B</code> to
                            commit.
                        </p><p style="color:blue;">事务77F（执行插入）正在等待事务77E、77D和77B提交。</p></li><li class="listitem"><p>
                            Transaction <code class="literal">77E</code> (executing an
                            <a class="link" href="sql-syntax.html#insert" title="13.2.5&nbsp;INSERT Syntax"><code class="literal">INSERT</code></a>) is waiting for
                            transactions <code class="literal">77D</code> and
                            <code class="literal">77B</code> to commit.
                        </p><p style="color:blue;">事务77E（执行插入）正在等待事务77D和77B提交。</p></li><li class="listitem"><p>
                            Transaction <code class="literal">77D</code> (executing an
                            <a class="link" href="sql-syntax.html#insert" title="13.2.5&nbsp;INSERT Syntax"><code class="literal">INSERT</code></a>) is waiting for
                            transaction <code class="literal">77B</code> to commit.
                        </p><p style="color:blue;">事务77D（执行插入）正在等待事务77B提交。</p></li><li class="listitem"><p>
                            Transaction <code class="literal">77B</code> (executing an
                            <a class="link" href="sql-syntax.html#insert" title="13.2.5&nbsp;INSERT Syntax"><code class="literal">INSERT</code></a>) is waiting for
                            transaction <code class="literal">77A</code> to commit.
                        </p><p style="color:blue;">事务77B（执行插入）正在等待事务77A提交。</p></li><li class="listitem"><p>
                            Transaction <code class="literal">77A</code> is running, currently
                            executing <a class="link" href="sql-syntax.html#select" title="13.2.9&nbsp;SELECT Syntax"><code class="literal">SELECT</code></a>.
                        </p><p style="color:blue;">事务77a正在运行，当前正在执行select。</p></li><li class="listitem"><p>
                            Transaction <code class="literal">E56</code> (executing an
                            <a class="link" href="sql-syntax.html#insert" title="13.2.5&nbsp;INSERT Syntax"><code class="literal">INSERT</code></a>) is waiting for
                            transaction <code class="literal">E55</code> to commit.
                        </p><p style="color:blue;">事务E56（执行插入）正在等待事务E55提交。</p></li><li class="listitem"><p>
                            Transaction <code class="literal">E55</code> (executing an
                            <a class="link" href="sql-syntax.html#insert" title="13.2.5&nbsp;INSERT Syntax"><code class="literal">INSERT</code></a>) is waiting for
                            transaction <code class="literal">19C</code> to commit.
                        </p><p style="color:blue;">事务e55（执行插入）正在等待事务19c提交。</p></li><li class="listitem"><p>
                            Transaction <code class="literal">19C</code> is running, currently
                            executing an <a class="link" href="sql-syntax.html#insert" title="13.2.5&nbsp;INSERT Syntax"><code class="literal">INSERT</code></a>.
                        </p><p style="color:blue;">事务19c正在运行，当前正在执行插入。</p></li></ul>
                    </div>
                    <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">
                        <div class="admon-title">
                            Note
                        </div>
                        <p>
                            There may be inconsistencies between queries shown in the
                            <code class="literal">INFORMATION_SCHEMA</code>
                            <a class="link" href="information-schema.html#processlist-table" title="24.18&nbsp;The INFORMATION_SCHEMA PROCESSLIST Table"><code class="literal">PROCESSLIST</code></a> and
                            <a class="link" href="information-schema.html#innodb-trx-table" title="24.32.26&nbsp;The INFORMATION_SCHEMA INNODB_TRX Table"><code class="literal">INNODB_TRX</code></a> tables. For an
                            explanation, see
                            <a class="xref" href="innodb-storage-engine.html#innodb-information-schema-internal-data" title="14.15.2.3&nbsp;Persistence and Consistency of InnoDB Transaction and Locking Information">Section&nbsp;14.15.2.3, “Persistence and Consistency of InnoDB Transaction and Locking
                                Information”</a>.
                        </p><p style="color:blue;">在information_schema processlist中显示的查询与innodb_trx表之间可能存在不一致。有关解释，请参阅14.15.2.3节，“InnoDB事务和锁定信息的持久性和一致性”。</p>
                    </div>
                    <p>
                        The following table shows the contents of
                        <a class="link" href="information-schema.html#processlist-table" title="24.18&nbsp;The INFORMATION_SCHEMA PROCESSLIST Table"><code class="literal">INFORMATION_SCHEMA.PROCESSLIST</code></a>
                        for a system running a heavy
                        <a class="link" href="glossary.html#glos_workload" title="workload">workload</a>.
                    </p><p style="color:blue;">下表显示了运行繁重工作负载的系统的information_schema.processlist的内容。</p>
                    <div class="informaltable">
                        <a name="innodb-information-schema-sample-processlist"></a><table summary="Sample data from the INFORMATION_SCHEMA.PROCESSLIST table, showing the internal workings of MySQL processes under a heavy workload."><colgroup><col width="8%"><col width="11%"><col width="21%"><col width="10%"><col width="20%"><col width="10%"><col width="20%"><col width="25%"></colgroup><thead><tr>
                        <th scope="col">ID</th>
                        <th scope="col">USER</th>
                        <th scope="col">HOST</th>
                        <th scope="col">DB</th>
                        <th scope="col">COMMAND</th>
                        <th scope="col">TIME</th>
                        <th scope="col">STATE</th>
                        <th scope="col">INFO</th>
                    </tr></thead><tbody><tr>
                        <td scope="row"><code class="literal">384</code></td>
                        <td><code class="literal">root</code></td>
                        <td><code class="literal">localhost</code></td>
                        <td><code class="literal">test</code></td>
                        <td><code class="literal">Query</code></td>
                        <td><code class="literal">10</code></td>
                        <td><code class="literal">update</code></td>
                        <td><code class="literal">INSERT INTO t2 VALUES …</code></td>
                    </tr><tr>
                        <td scope="row"><code class="literal">257</code></td>
                        <td><code class="literal">root</code></td>
                        <td><code class="literal">localhost</code></td>
                        <td><code class="literal">test</code></td>
                        <td><code class="literal">Query</code></td>
                        <td><code class="literal">3</code></td>
                        <td><code class="literal">update</code></td>
                        <td><code class="literal">INSERT INTO t2 VALUES …</code></td>
                    </tr><tr>
                        <td scope="row"><code class="literal">130</code></td>
                        <td><code class="literal">root</code></td>
                        <td><code class="literal">localhost</code></td>
                        <td><code class="literal">test</code></td>
                        <td><code class="literal">Query</code></td>
                        <td><code class="literal">0</code></td>
                        <td><code class="literal">update</code></td>
                        <td><code class="literal">INSERT INTO t2 VALUES …</code></td>
                    </tr><tr>
                        <td scope="row"><code class="literal">61</code></td>
                        <td><code class="literal">root</code></td>
                        <td><code class="literal">localhost</code></td>
                        <td><code class="literal">test</code></td>
                        <td><code class="literal">Query</code></td>
                        <td><code class="literal">1</code></td>
                        <td><code class="literal">update</code></td>
                        <td><code class="literal">INSERT INTO t2 VALUES …</code></td>
                    </tr><tr>
                        <td scope="row"><code class="literal">8</code></td>
                        <td><code class="literal">root</code></td>
                        <td><code class="literal">localhost</code></td>
                        <td><code class="literal">test</code></td>
                        <td><code class="literal">Query</code></td>
                        <td><code class="literal">1</code></td>
                        <td><code class="literal">update</code></td>
                        <td><code class="literal">INSERT INTO t2 VALUES …</code></td>
                    </tr><tr>
                        <td scope="row"><code class="literal">4</code></td>
                        <td><code class="literal">root</code></td>
                        <td><code class="literal">localhost</code></td>
                        <td><code class="literal">test</code></td>
                        <td><code class="literal">Query</code></td>
                        <td><code class="literal">0</code></td>
                        <td><code class="literal">preparing</code></td>
                        <td><code class="literal">SELECT * FROM PROCESSLIST</code></td>
                    </tr><tr>
                        <td scope="row"><code class="literal">2</code></td>
                        <td><code class="literal">root</code></td>
                        <td><code class="literal">localhost</code></td>
                        <td><code class="literal">test</code></td>
                        <td><code class="literal">Sleep</code></td>
                        <td><code class="literal">566</code></td>
                        <td><code class="literal"></code></td>
                        <td><code class="literal">NULL</code></td>
                    </tr></tbody></table>
                    </div>
                    <p>
                        The following table shows the contents of
                        <a class="link" href="information-schema.html#innodb-trx-table" title="24.32.26&nbsp;The INFORMATION_SCHEMA INNODB_TRX Table"><code class="literal">INFORMATION_SCHEMA.INNODB_TRX</code></a> for
                        a system running a heavy
                        <a class="link" href="glossary.html#glos_workload" title="workload">workload</a>.
                    </p><p style="color:blue;">下表显示了运行繁重工作负载的系统的information_schema.innodb_trx的内容。</p>
                    <div class="informaltable">
                        <a name="innodb-information-schema-sample-innodb-trx"></a><table summary="Sample data from the INFORMATION_SCHEMA.INNODB_TRX table, showing the internal workings of InnoDB transactions under a heavy workload."><colgroup><col width="8%"><col width="10%"><col width="19%"><col width="21%"><col width="19%"><col width="10%"><col width="10%"><col width="31%"></colgroup><thead><tr>
                        <th scope="col">trx id</th>
                        <th scope="col">trx state</th>
                        <th scope="col">trx started</th>
                        <th scope="col">trx requested lock id</th>
                        <th scope="col">trx wait started</th>
                        <th scope="col">trx weight</th>
                        <th scope="col">trx mysql thread id</th>
                        <th scope="col">trx query</th>
                    </tr></thead><tbody><tr>
                        <td scope="row"><code class="literal">77F</code></td>
                        <td><code class="literal">LOCK WAIT</code></td>
                        <td><code class="literal">2008-01-15 13:10:16</code></td>
                        <td><code class="literal">77F</code></td>
                        <td><code class="literal">2008-01-15 13:10:16</code></td>
                        <td><code class="literal">1</code></td>
                        <td><code class="literal">876</code></td>
                        <td><code class="literal">INSERT INTO t09 (D, B, C) VALUES …</code></td>
                    </tr><tr>
                        <td scope="row"><code class="literal">77E</code></td>
                        <td><code class="literal">LOCK WAIT</code></td>
                        <td><code class="literal">2008-01-15 13:10:16</code></td>
                        <td><code class="literal">77E</code></td>
                        <td><code class="literal">2008-01-15 13:10:16</code></td>
                        <td><code class="literal">1</code></td>
                        <td><code class="literal">875</code></td>
                        <td><code class="literal">INSERT INTO t09 (D, B, C) VALUES …</code></td>
                    </tr><tr>
                        <td scope="row"><code class="literal">77D</code></td>
                        <td><code class="literal">LOCK WAIT</code></td>
                        <td><code class="literal">2008-01-15 13:10:16</code></td>
                        <td><code class="literal">77D</code></td>
                        <td><code class="literal">2008-01-15 13:10:16</code></td>
                        <td><code class="literal">1</code></td>
                        <td><code class="literal">874</code></td>
                        <td><code class="literal">INSERT INTO t09 (D, B, C) VALUES …</code></td>
                    </tr><tr>
                        <td scope="row"><code class="literal">77B</code></td>
                        <td><code class="literal">LOCK WAIT</code></td>
                        <td><code class="literal">2008-01-15 13:10:16</code></td>
                        <td><code class="literal">77B:733:12:1</code></td>
                        <td><code class="literal">2008-01-15 13:10:16</code></td>
                        <td><code class="literal">4</code></td>
                        <td><code class="literal">873</code></td>
                        <td><code class="literal">INSERT INTO t09 (D, B, C) VALUES …</code></td>
                    </tr><tr>
                        <td scope="row"><code class="literal">77A</code></td>
                        <td><code class="literal">RUN­NING</code></td>
                        <td><code class="literal">2008-01-15 13:10:16</code></td>
                        <td><code class="literal">NULL</code></td>
                        <td><code class="literal">NULL</code></td>
                        <td><code class="literal">4</code></td>
                        <td><code class="literal">872</code></td>
                        <td><code class="literal">SELECT b, c FROM t09 WHERE …</code></td>
                    </tr><tr>
                        <td scope="row"><code class="literal">E56</code></td>
                        <td><code class="literal">LOCK WAIT</code></td>
                        <td><code class="literal">2008-01-15 13:10:06</code></td>
                        <td><code class="literal">E56:743:6:2</code></td>
                        <td><code class="literal">2008-01-15 13:10:06</code></td>
                        <td><code class="literal">5</code></td>
                        <td><code class="literal">384</code></td>
                        <td><code class="literal">INSERT INTO t2 VALUES …</code></td>
                    </tr><tr>
                        <td scope="row"><code class="literal">E55</code></td>
                        <td><code class="literal">LOCK WAIT</code></td>
                        <td><code class="literal">2008-01-15 13:10:06</code></td>
                        <td><code class="literal">E55:743:38:2</code></td>
                        <td><code class="literal">2008-01-15 13:10:13</code></td>
                        <td><code class="literal">965</code></td>
                        <td><code class="literal">257</code></td>
                        <td><code class="literal">INSERT INTO t2 VALUES …</code></td>
                    </tr><tr>
                        <td scope="row"><code class="literal">19C</code></td>
                        <td><code class="literal">RUN­NING</code></td>
                        <td><code class="literal">2008-01-15 13:09:10</code></td>
                        <td><code class="literal">NULL</code></td>
                        <td><code class="literal">NULL</code></td>
                        <td><code class="literal">2900</code></td>
                        <td><code class="literal">130</code></td>
                        <td><code class="literal">INSERT INTO t2 VALUES …</code></td>
                    </tr><tr>
                        <td scope="row"><code class="literal">E15</code></td>
                        <td><code class="literal">RUN­NING</code></td>
                        <td><code class="literal">2008-01-15 13:08:59</code></td>
                        <td><code class="literal">NULL</code></td>
                        <td><code class="literal">NULL</code></td>
                        <td><code class="literal">5395</code></td>
                        <td><code class="literal">61</code></td>
                        <td><code class="literal">INSERT INTO t2 VALUES …</code></td>
                    </tr><tr>
                        <td scope="row"><code class="literal">51D</code></td>
                        <td><code class="literal">RUN­NING</code></td>
                        <td><code class="literal">2008-01-15 13:08:47</code></td>
                        <td><code class="literal">NULL</code></td>
                        <td><code class="literal">NULL</code></td>
                        <td><code class="literal">9807</code></td>
                        <td><code class="literal">8</code></td>
                        <td><code class="literal">INSERT INTO t2 VALUES …</code></td>
                    </tr></tbody></table>
                    </div>
                    <p>
                        The following table shows the contents of
                        <a class="link" href="information-schema.html#innodb-lock-waits-table" title="24.32.14&nbsp;The INFORMATION_SCHEMA INNODB_LOCK_WAITS Table"><code class="literal">INFORMATION_SCHEMA.INNODB_LOCK_WAITS</code></a>
                        for a system running a heavy
                        <a class="link" href="glossary.html#glos_workload" title="workload">workload</a>.
                    </p><p style="color:blue;">下表显示了information_schema的内容。innodb_lock_等待运行繁重工作负载的系统。</p>
                    <div class="informaltable">
                        <a name="innodb-information-schema-sample-innodb-lock-waits"></a><table summary="Sample data from the INFORMATION_SCHEMA.INNODB_LOCK_WAITS table, showing the internal workings of InnoDB locking under a heavy workload."><colgroup><col width="25%"><col width="25%"><col width="25%"><col width="25%"></colgroup><thead><tr>
                        <th scope="col">requesting trx id</th>
                        <th scope="col">requested lock id</th>
                        <th scope="col">blocking trx id</th>
                        <th scope="col">blocking lock id</th>
                    </tr></thead><tbody><tr>
                        <td scope="row"><code class="literal">77F</code></td>
                        <td><code class="literal">77F:806</code></td>
                        <td><code class="literal">77E</code></td>
                        <td><code class="literal">77E:806</code></td>
                    </tr><tr>
                        <td scope="row"><code class="literal">77F</code></td>
                        <td><code class="literal">77F:806</code></td>
                        <td><code class="literal">77D</code></td>
                        <td><code class="literal">77D:806</code></td>
                    </tr><tr>
                        <td scope="row"><code class="literal">77F</code></td>
                        <td><code class="literal">77F:806</code></td>
                        <td><code class="literal">77B</code></td>
                        <td><code class="literal">77B:806</code></td>
                    </tr><tr>
                        <td scope="row"><code class="literal">77E</code></td>
                        <td><code class="literal">77E:806</code></td>
                        <td><code class="literal">77D</code></td>
                        <td><code class="literal">77D:806</code></td>
                    </tr><tr>
                        <td scope="row"><code class="literal">77E</code></td>
                        <td><code class="literal">77E:806</code></td>
                        <td><code class="literal">77B</code></td>
                        <td><code class="literal">77B:806</code></td>
                    </tr><tr>
                        <td scope="row"><code class="literal">77D</code></td>
                        <td><code class="literal">77D:806</code></td>
                        <td><code class="literal">77B</code></td>
                        <td><code class="literal">77B:806</code></td>
                    </tr><tr>
                        <td scope="row"><code class="literal">77B</code></td>
                        <td><code class="literal">77B:733:12:1</code></td>
                        <td><code class="literal">77A</code></td>
                        <td><code class="literal">77A:733:12:1</code></td>
                    </tr><tr>
                        <td scope="row"><code class="literal">E56</code></td>
                        <td><code class="literal">E56:743:6:2</code></td>
                        <td><code class="literal">E55</code></td>
                        <td><code class="literal">E55:743:6:2</code></td>
                    </tr><tr>
                        <td scope="row"><code class="literal">E55</code></td>
                        <td><code class="literal">E55:743:38:2</code></td>
                        <td><code class="literal">19C</code></td>
                        <td><code class="literal">19C:743:38:2</code></td>
                    </tr></tbody></table>
                    </div>
                    <p>
                        The following table shows the contents of
                        <a class="link" href="information-schema.html#innodb-locks-table" title="24.32.13&nbsp;The INFORMATION_SCHEMA INNODB_LOCKS Table"><code class="literal">INFORMATION_SCHEMA.INNODB_LOCKS</code></a>
                        for a system running a heavy
                        <a class="link" href="glossary.html#glos_workload" title="workload">workload</a>.
                    </p><p style="color:blue;">下表显示了运行繁重工作负载的系统的information_schema.innodb_锁的内容。</p>
                    <div class="informaltable">
                        <a name="innodb-information-schema-sample-innodb-locks"></a><table summary="Sample data from the INFORMATION_SCHEMA.INNODB_LOCKS table, showing the internal workings of InnoDB locking under a heavy workload."><colgroup><col width="18%"><col width="9%"><col width="12%"><col width="12%"><col width="14%"><col width="17%"><col width="17%"></colgroup><thead><tr>
                        <th scope="col">lock id</th>
                        <th scope="col">lock trx id</th>
                        <th scope="col">lock mode</th>
                        <th scope="col">lock type</th>
                        <th scope="col">lock table</th>
                        <th scope="col">lock index</th>
                        <th scope="col">lock data</th>
                    </tr></thead><tbody><tr>
                        <td scope="row"><code class="literal">77F:806</code></td>
                        <td><code class="literal">77F</code></td>
                        <td><code class="literal">AUTO_INC</code></td>
                        <td><code class="literal">TABLE</code></td>
                        <td><code class="literal">test.t09</code></td>
                        <td><code class="literal">NULL</code></td>
                        <td><code class="literal">NULL</code></td>
                    </tr><tr>
                        <td scope="row"><code class="literal">77E:806</code></td>
                        <td><code class="literal">77E</code></td>
                        <td><code class="literal">AUTO_INC</code></td>
                        <td><code class="literal">TABLE</code></td>
                        <td><code class="literal">test.t09</code></td>
                        <td><code class="literal">NULL</code></td>
                        <td><code class="literal">NULL</code></td>
                    </tr><tr>
                        <td scope="row"><code class="literal">77D:806</code></td>
                        <td><code class="literal">77D</code></td>
                        <td><code class="literal">AUTO_INC</code></td>
                        <td><code class="literal">TABLE</code></td>
                        <td><code class="literal">test.t09</code></td>
                        <td><code class="literal">NULL</code></td>
                        <td><code class="literal">NULL</code></td>
                    </tr><tr>
                        <td scope="row"><code class="literal">77B:806</code></td>
                        <td><code class="literal">77B</code></td>
                        <td><code class="literal">AUTO_INC</code></td>
                        <td><code class="literal">TABLE</code></td>
                        <td><code class="literal">test.t09</code></td>
                        <td><code class="literal">NULL</code></td>
                        <td><code class="literal">NULL</code></td>
                    </tr><tr>
                        <td scope="row"><code class="literal">77B:733:12:1</code></td>
                        <td><code class="literal">77B</code></td>
                        <td><code class="literal">X</code></td>
                        <td><code class="literal">RECORD</code></td>
                        <td><code class="literal">test.t09</code></td>
                        <td><code class="literal">PRIMARY</code></td>
                        <td><code class="literal">supremum pseudo-record</code></td>
                    </tr><tr>
                        <td scope="row"><code class="literal">77A:733:12:1</code></td>
                        <td><code class="literal">77A</code></td>
                        <td><code class="literal">X</code></td>
                        <td><code class="literal">RECORD</code></td>
                        <td><code class="literal">test.t09</code></td>
                        <td><code class="literal">PRIMARY</code></td>
                        <td><code class="literal">supremum pseudo-record</code></td>
                    </tr><tr>
                        <td scope="row"><code class="literal">E56:743:6:2</code></td>
                        <td><code class="literal">E56</code></td>
                        <td><code class="literal">S</code></td>
                        <td><code class="literal">RECORD</code></td>
                        <td><code class="literal">test.t2</code></td>
                        <td><code class="literal">PRIMARY</code></td>
                        <td><code class="literal">0, 0</code></td>
                    </tr><tr>
                        <td scope="row"><code class="literal">E55:743:6:2</code></td>
                        <td><code class="literal">E55</code></td>
                        <td><code class="literal">X</code></td>
                        <td><code class="literal">RECORD</code></td>
                        <td><code class="literal">test.t2</code></td>
                        <td><code class="literal">PRIMARY</code></td>
                        <td><code class="literal">0, 0</code></td>
                    </tr><tr>
                        <td scope="row"><code class="literal">E55:743:38:2</code></td>
                        <td><code class="literal">E55</code></td>
                        <td><code class="literal">S</code></td>
                        <td><code class="literal">RECORD</code></td>
                        <td><code class="literal">test.t2</code></td>
                        <td><code class="literal">PRIMARY</code></td>
                        <td><code class="literal">1922, 1922</code></td>
                    </tr><tr>
                        <td scope="row"><code class="literal">19C:743:38:2</code></td>
                        <td><code class="literal">19C</code></td>
                        <td><code class="literal">X</code></td>
                        <td><code class="literal">RECORD</code></td>
                        <td><code class="literal">test.t2</code></td>
                        <td><code class="literal">PRIMARY</code></td>
                        <td><code class="literal">1922, 1922</code></td>
                    </tr></tbody></table>
                    </div>

                </div>

            </div>
            <div class="section">
                <div class="titlepage">
                    <div>
                        <div>
                            <h4 class="title"><a name="innodb-information-schema-understanding-innodb-locking"></a>14.15.2.2&nbsp;InnoDB Lock and Lock-Wait Information</h4>

                        </div>

                    </div>

                </div>
                <p>
                    When a transaction updates a row in a table, or locks it with
                    <code class="literal">SELECT FOR UPDATE</code>, <code class="literal">InnoDB</code>
                    establishes a list or queue of locks on that row. Similarly,
                    <code class="literal">InnoDB</code> maintains a list of locks on a table
                    for table-level locks. If a second transaction wants to update a
                    row or lock a table already locked by a prior transaction in an
                    incompatible mode, <code class="literal">InnoDB</code> adds a lock request
                    for the row to the corresponding queue. For a lock to be
                    acquired by a transaction, all incompatible lock requests
                    previously entered into the lock queue for that row or table
                    must be removed (which occurs when the transactions holding or
                    requesting those locks either commit or roll back).
                </p><p style="color:blue;">当事务更新表中的一行时，或者使用select for update锁定它时，innodb会在该行上建立一个锁列表或队列。类似地，innodb为表级锁维护表上的锁列表。如果第二个事务想要更新一行，或者在不兼容的模式下锁定一个已经被前一个事务锁定的表，innodb会将对该行的锁定请求添加到相应的队列中。对于要由事务获取的锁，必须删除以前为该行或表进入锁队列的所有不兼容的锁请求（当持有或请求这些锁的事务提交或回滚时发生这种情况）。</p><p>
                A transaction may have any number of lock requests for different
                rows or tables. At any given time, a transaction may request a
                lock that is held by another transaction, in which case it is
                blocked by that other transaction. The requesting transaction
                must wait for the transaction that holds the blocking lock to
                commit or roll back. If a transaction is not waiting for a lock,
                it is in a <code class="literal">RUNNING</code> state. If a transaction is
                waiting for a lock, it is in a <code class="literal">LOCK WAIT</code>
                state. (The <code class="literal">INFORMATION_SCHEMA</code>
                <a class="link" href="information-schema.html#innodb-trx-table" title="24.32.26&nbsp;The INFORMATION_SCHEMA INNODB_TRX Table"><code class="literal">INNODB_TRX</code></a> table indicates
                transaction state values.)
            </p><p style="color:blue;">对于不同的行或表，事务可以有任意数量的锁请求。在任何给定的时间，一个事务可以请求另一个事务持有的锁，在这种情况下，它被另一个事务阻止。请求事务必须等待持有阻塞锁的事务提交或回滚。如果事务没有等待锁，则它处于运行状态。如果事务正在等待锁，则它处于锁等待状态。（information_schema innodb_trx表指示事务状态值。）</p><p>
                The <a class="link" href="information-schema.html#innodb-locks-table" title="24.32.13&nbsp;The INFORMATION_SCHEMA INNODB_LOCKS Table"><code class="literal">INNODB_LOCKS</code></a> table holds one or
                more rows for each <code class="literal">LOCK WAIT</code> transaction,
                indicating any lock requests that prevent its progress. This
                table also contains one row describing each lock in a queue of
                locks pending for a given row or table. The
                <a class="link" href="information-schema.html#innodb-lock-waits-table" title="24.32.14&nbsp;The INFORMATION_SCHEMA INNODB_LOCK_WAITS Table"><code class="literal">INNODB_LOCK_WAITS</code></a> table shows which
                locks already held by a transaction are blocking locks requested
                by other transactions.
            </p><p style="color:blue;">innodb_locks表为每个lock wait事务保存一行或多行，指示阻止其进行的任何锁请求。此表还包含一行，用于描述给定行或表的挂起锁队列中的每个锁。innodb_lock_waits表显示事务已经持有的哪些锁正在阻塞其他事务请求的锁。</p>
            </div>
            <div class="section">
                <div class="titlepage">
                    <div>
                        <div>
                            <h4 class="title"><a name="innodb-information-schema-internal-data"></a>14.15.2.3&nbsp;Persistence and Consistency of InnoDB Transaction and Locking
                                Information</h4>
                        </div>
                    </div>
                </div>
                <p>
                    The data exposed by the transaction and locking tables
                    (<a class="link" href="information-schema.html#innodb-trx-table" title="24.32.26&nbsp;The INFORMATION_SCHEMA INNODB_TRX Table"><code class="literal">INNODB_TRX</code></a>,
                    <a class="link" href="information-schema.html#innodb-locks-table" title="24.32.13&nbsp;The INFORMATION_SCHEMA INNODB_LOCKS Table"><code class="literal">INNODB_LOCKS</code></a>, and
                    <a class="link" href="information-schema.html#innodb-lock-waits-table" title="24.32.14&nbsp;The INFORMATION_SCHEMA INNODB_LOCK_WAITS Table"><code class="literal">INNODB_LOCK_WAITS</code></a>) represents a
                    glimpse into fast-changing data. This is not like user tables,
                    where the data changes only when application-initiated updates
                    occur. The underlying data is internal system-managed data, and
                    can change very quickly.
                </p><p style="color:blue;">事务表和锁定表（innodb_trx、innodb_locks和innodb_lock_waits）公开的数据表示对快速变化的数据的一瞥。这与用户表不同，只有在应用程序启动更新时数据才会更改。底层数据是内部系统管理的数据，可以很快地更改。</p><p>
                For performance reasons, and to minimize the chance of
                misleading joins between the transaction and locking tables,
                <code class="literal">InnoDB</code> collects the required transaction and
                locking information into an intermediate buffer whenever a
                <code class="literal">SELECT</code> on any of the tables is issued. This
                buffer is refreshed only if more than 0.1 seconds has elapsed
                since the last time the buffer was read. The data needed to fill
                the three tables is fetched atomically and consistently and is
                saved in this global internal buffer, forming a point-in-time
                <span class="quote">“<span class="quote">snapshot</span>”</span>. If multiple table accesses occur within
                0.1 seconds (as they almost certainly do when MySQL processes a
                join among these tables), then the same snapshot is used to
                satisfy the query.
            </p><p style="color:blue;">出于性能方面的原因，为了尽量减少事务和锁定表之间误导性连接的可能性，innodb在对任何表发出select时都会将所需的事务和锁定信息收集到中间缓冲区中。仅当自上次读取缓冲区以来已超过0.1秒时，才会刷新此缓冲区。填充这三个表所需的数据是原子地、一致地获取的，并保存在这个全局内部缓冲区中，形成一个时间点“快照”。如果在0.1秒内发生多个表访问（就像mysql处理这些表之间的连接时几乎可以肯定的那样），则使用相同的快照来满足查询。</p><p>
                A correct result is returned when you join any of these tables
                together in a single query, because the data for the three
                tables comes from the same snapshot. Because the buffer is not
                refreshed with every query of any of these tables, if you issue
                separate queries against these tables within a tenth of a
                second, the results are the same from query to query. On the
                other hand, two separate queries of the same or different tables
                issued more than a tenth of a second apart may see different
                results, since the data come from different snapshots.
            </p><p style="color:blue;">当您在单个查询中将这些表中的任何一个表连接在一起时，将返回正确的结果，因为这三个表的数据来自同一个快照。由于缓冲区不会随这些表的每个查询而刷新，因此如果在十分之一秒内对这些表发出单独的查询，则每个查询的结果都是相同的。另一方面，由于数据来自不同的快照，对相同或不同表的两个单独查询（间隔超过十分之一秒）可能会看到不同的结果。</p><p>
                Because <code class="literal">InnoDB</code> must temporarily stall while
                the transaction and locking data is collected, too frequent
                queries of these tables can negatively impact performance as
                seen by other users.
            </p><p style="color:blue;">由于在收集事务和锁定数据时，innodb必须暂时停止，因此这些表的查询过于频繁可能会对其他用户看到的性能产生负面影响。</p><p>
                As these tables contain sensitive information (at least
                <code class="literal">INNODB_LOCKS.LOCK_DATA</code> and
                <code class="literal">INNODB_TRX.TRX_QUERY</code>), for security reasons,
                only the users with the <code class="literal">PROCESS</code> privilege are
                allowed to <code class="literal">SELECT</code> from them.
            </p><p style="color:blue;">由于这些表包含敏感信息（至少innodb_locks.lock_data和innodb_trx.trx_query），出于安全原因，仅允许具有进程特权的用户从中进行选择。</p><a class="indexterm" name="idm140286807418784"></a><p>
                As described previously, the data that fills the transaction and
                locking tables (<a class="link" href="information-schema.html#innodb-trx-table" title="24.32.26&nbsp;The INFORMATION_SCHEMA INNODB_TRX Table"><code class="literal">INNODB_TRX</code></a>,
                <a class="link" href="information-schema.html#innodb-locks-table" title="24.32.13&nbsp;The INFORMATION_SCHEMA INNODB_LOCKS Table"><code class="literal">INNODB_LOCKS</code></a> and
                <a class="link" href="information-schema.html#innodb-lock-waits-table" title="24.32.14&nbsp;The INFORMATION_SCHEMA INNODB_LOCK_WAITS Table"><code class="literal">INNODB_LOCK_WAITS</code></a>) is fetched
                automatically and saved to an intermediate buffer that provides
                a <span class="quote">“<span class="quote">point-in-time</span>”</span> snapshot. The data across all
                three tables is consistent when queried from the same snapshot.
                However, the underlying data changes so fast that similar
                glimpses at other, similarly fast-changing data, may not be in
                synchrony. Thus, you should be careful when comparing data in
                the <code class="literal">InnoDB</code> transaction and locking tables
                with data in the <a class="link" href="information-schema.html#processlist-table" title="24.18&nbsp;The INFORMATION_SCHEMA PROCESSLIST Table"><code class="literal">PROCESSLIST</code></a> table.
                The data from the <a class="link" href="information-schema.html#processlist-table" title="24.18&nbsp;The INFORMATION_SCHEMA PROCESSLIST Table"><code class="literal">PROCESSLIST</code></a> table
                does not come from the same snapshot as the data about locking
                and transactions. Even if you issue a single
                <code class="literal">SELECT</code> (joining
                <a class="link" href="information-schema.html#innodb-trx-table" title="24.32.26&nbsp;The INFORMATION_SCHEMA INNODB_TRX Table"><code class="literal">INNODB_TRX</code></a> and
                <a class="link" href="information-schema.html#processlist-table" title="24.18&nbsp;The INFORMATION_SCHEMA PROCESSLIST Table"><code class="literal">PROCESSLIST</code></a>, for example), the
                content of those tables is generally not consistent.
                <a class="link" href="information-schema.html#innodb-trx-table" title="24.32.26&nbsp;The INFORMATION_SCHEMA INNODB_TRX Table"><code class="literal">INNODB_TRX</code></a> may reference rows that
                are not present in <a class="link" href="information-schema.html#processlist-table" title="24.18&nbsp;The INFORMATION_SCHEMA PROCESSLIST Table"><code class="literal">PROCESSLIST</code></a> or
                the currently executing SQL query of a transaction shown in
                <code class="literal">INNODB_TRX.TRX_QUERY</code> may differ from the one
                in <code class="literal">PROCESSLIST.INFO</code>.
            </p><p style="color:blue;">如前所述，填充事务和锁定表（innodb_trx、innodb_locks和innodb_lock_waities）的数据将自动获取并保存到提供“时间点”快照的中间缓冲区。从同一快照查询时，所有三个表中的数据都是一致的。然而，底层数据的变化如此之快，以至于其他类似的快速变化的数据也可能不同步。因此，在比较innodb transaction和locking表中的数据与processlist表中的数据时应该小心。processlist表中的数据与关于锁定和事务的数据来自不同的快照。即使发出一个select（例如加入innodb_trx和processlist），这些表的内容通常也不一致。innodb_trx可以引用processlist中不存在的行，或者innodb_trx.trx_query中显示的事务的当前执行的sql查询可能与processlist.info中的不同。</p>
            </div>

        </div>
        <div class="section">
            <div class="titlepage">
                <div>
                    <div>
                        <h3 class="title"><a name="innodb-information-schema-system-tables"></a>14.15.3&nbsp;InnoDB INFORMATION_SCHEMA System Tables</h3>

                    </div>

                </div>

            </div>
            <p>
                You can extract metadata about schema objects managed by
                <code class="literal">InnoDB</code> using <code class="literal">InnoDB</code>
                <code class="literal">INFORMATION_SCHEMA</code> system tables. This
                information comes from the <code class="literal">InnoDB</code> internal
                system tables (also referred to as the <code class="literal">InnoDB</code>
                data dictionary), which cannot be queried directly like regular
                <code class="literal">InnoDB</code> tables. Traditionally, you would get
                this type of information using the techniques from
                <a class="xref" href="innodb-storage-engine.html#innodb-monitors" title="14.17&nbsp;InnoDB Monitors">Section&nbsp;14.17, “InnoDB Monitors”</a>, setting up
                <code class="literal">InnoDB</code> monitors and parsing the output from the
                <a class="link" href="sql-syntax.html#show-engine" title="13.7.5.15&nbsp;SHOW ENGINE Syntax"><code class="literal">SHOW ENGINE INNODB
                    STATUS</code></a> statement. The <code class="literal">InnoDB</code>
                <code class="literal">INFORMATION_SCHEMA</code> table interface allows you
                to query this data using SQL.
            </p><p style="color:blue;">您可以使用innodb information_schema system tables提取innodb管理的模式对象的元数据。这些信息来自innodb内部系统表（也称为innodb数据字典），不能像普通innodb表那样直接查询。传统上，您可以使用第14.17节“innodb monitors”中的技术获取此类信息，设置innodb monitors并解析show engine innodb status语句的输出。innodb information_schema表接口允许您使用sql查询这些数据。</p><p>
            With the exception of
            <a class="link" href="information-schema.html#innodb-sys-tablestats-table" title="24.32.23&nbsp;The INFORMATION_SCHEMA INNODB_SYS_TABLESTATS View"><code class="literal">INNODB_SYS_TABLESTATS</code></a>, for which
            there is no corresponding internal system table,
            <code class="literal">InnoDB</code> <code class="literal">INFORMATION_SCHEMA</code>
            system tables are populated with data read directly from internal
            <code class="literal">InnoDB</code> system tables rather than from metadata
            that is cached in memory.
        </p><p style="color:blue;">除了innodb_sys_tablestats没有对应的内部系统表外，innodb information_schema系统表中填充的是直接从内部innodb系统表读取的数据，而不是从缓存在内存中的元数据读取的数据。</p><p>
            <code class="literal">InnoDB</code> <code class="literal">INFORMATION_SCHEMA</code>
            system tables include the tables listed below.
        </p><p style="color:blue;">innodb information_schema系统表包括下面列出的表。</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>SHOW TABLES FROM INFORMATION_SCHEMA LIKE 'INNODB_SYS%';</code></strong>
+--------------------------------------------+
| Tables_in_information_schema (INNODB_SYS%) |
+--------------------------------------------+
| INNODB_SYS_DATAFILES                       |
| INNODB_SYS_TABLESTATS                      |
| INNODB_SYS_FOREIGN                         |
| INNODB_SYS_COLUMNS                         |
| INNODB_SYS_INDEXES                         |
| INNODB_SYS_FIELDS                          |
| INNODB_SYS_TABLESPACES                     |
| INNODB_SYS_FOREIGN_COLS                    |
| INNODB_SYS_TABLES                          |
+--------------------------------------------+
</pre><p>
            The table names are indicative of the type of data provided:
        </p><p style="color:blue;">表名表示提供的数据类型：</p>
            <div class="itemizedlist">
                <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                    <a class="link" href="information-schema.html#innodb-sys-tables-table" title="24.32.22&nbsp;The INFORMATION_SCHEMA INNODB_SYS_TABLES Table"><code class="literal">INNODB_SYS_TABLES</code></a> provides
                    metadata about <code class="literal">InnoDB</code> tables, equivalent to
                    the information in the <code class="literal">SYS_TABLES</code> table in
                    the <code class="literal">InnoDB</code> data dictionary.
                </p><p style="color:blue;">innodb_sys_tables提供关于innodb tables的元数据，相当于innodb数据字典中sys_tables表中的信息。</p></li><li class="listitem"><p>
                    <a class="link" href="information-schema.html#innodb-sys-columns-table" title="24.32.16&nbsp;The INFORMATION_SCHEMA INNODB_SYS_COLUMNS Table"><code class="literal">INNODB_SYS_COLUMNS</code></a> provides
                    metadata about <code class="literal">InnoDB</code> table columns,
                    equivalent to the information in the
                    <code class="literal">SYS_COLUMNS</code> table in the
                    <code class="literal">InnoDB</code> data dictionary.
                </p><p style="color:blue;">innodb_sys_columns提供关于innodb table columns的元数据，相当于innodb数据字典中sys_columns表中的信息。</p></li><li class="listitem"><p>
                    <a class="link" href="information-schema.html#innodb-sys-indexes-table" title="24.32.21&nbsp;The INFORMATION_SCHEMA INNODB_SYS_INDEXES Table"><code class="literal">INNODB_SYS_INDEXES</code></a> provides
                    metadata about <code class="literal">InnoDB</code> indexes, equivalent
                    to the information in the <code class="literal">SYS_INDEXES</code> table
                    in the <code class="literal">InnoDB</code> data dictionary.
                </p><p style="color:blue;">innodb_sys_indexes提供关于innodb索引的元数据，相当于innodb数据字典中sys_indexes表中的信息。</p></li><li class="listitem"><p>
                    <a class="link" href="information-schema.html#innodb-sys-fields-table" title="24.32.18&nbsp;The INFORMATION_SCHEMA INNODB_SYS_FIELDS Table"><code class="literal">INNODB_SYS_FIELDS</code></a> provides
                    metadata about the key columns (fields) of
                    <code class="literal">InnoDB</code> indexes, equivalent to the
                    information in the <code class="literal">SYS_FIELDS</code> table in the
                    <code class="literal">InnoDB</code> data dictionary.
                </p><p style="color:blue;">innodb_sys_fields提供关于innodb索引键列（字段）的元数据，相当于innodb数据字典中sys_fields表中的信息。</p></li><li class="listitem"><p>
                    <a class="link" href="information-schema.html#innodb-sys-tablestats-table" title="24.32.23&nbsp;The INFORMATION_SCHEMA INNODB_SYS_TABLESTATS View"><code class="literal">INNODB_SYS_TABLESTATS</code></a> provides a
                    view of low-level status information about
                    <code class="literal">InnoDB</code> tables that is derived from
                    in-memory data structures. There is no corresponding internal
                    <code class="literal">InnoDB</code> system table.
                </p><p style="color:blue;">innodb_sys_tabstats提供了从内存数据结构派生的innodb表的低级状态信息视图。没有对应的内部innodb系统表。</p></li><li class="listitem"><p>
                    <a class="link" href="information-schema.html#innodb-sys-datafiles-table" title="24.32.17&nbsp;The INFORMATION_SCHEMA INNODB_SYS_DATAFILES Table"><code class="literal">INNODB_SYS_DATAFILES</code></a> provides
                    data file path information for <code class="literal">InnoDB</code>
                    file-per-table and general tablespaces, equivalent to
                    information in the <code class="literal">SYS_DATAFILES</code> table in
                    the <code class="literal">InnoDB</code> data dictionary.
                </p><p style="color:blue;">innodb_sys_datafiles为每个表和常规表空间提供innodb文件的数据文件路径信息，相当于innodb数据字典中sys_datafiles表中的信息。</p></li><li class="listitem"><p>
                    <a class="link" href="information-schema.html#innodb-sys-tablespaces-table" title="24.32.22.1&nbsp;The INFORMATION_SCHEMA INNODB_SYS_TABLESPACES Table"><code class="literal">INNODB_SYS_TABLESPACES</code></a> provides
                    metadata about <code class="literal">InnoDB</code> file-per-table and
                    general tablespaces, equivalent to the information in the
                    <code class="literal">SYS_TABLESPACES</code> table in the
                    <code class="literal">InnoDB</code> data dictionary.
                </p><p style="color:blue;">innodb_sys_tablespaces为每个表和常规表空间提供关于innodb文件的元数据，相当于innodb数据字典中sys_tablespaces表中的信息。</p></li><li class="listitem"><p>
                    <a class="link" href="information-schema.html#innodb-sys-foreign-table" title="24.32.19&nbsp;The INFORMATION_SCHEMA INNODB_SYS_FOREIGN Table"><code class="literal">INNODB_SYS_FOREIGN</code></a> provides
                    metadata about foreign keys defined on
                    <code class="literal">InnoDB</code> tables, equivalent to the
                    information in the <code class="literal">SYS_FOREIGN</code> table in the
                    <code class="literal">InnoDB</code> data dictionary.
                </p><p style="color:blue;">innodb_sys_foreign提供关于innodb表上定义的外键的元数据，相当于innodb数据字典中sys_foreign表中的信息。</p></li><li class="listitem"><p>
                    <a class="link" href="information-schema.html#innodb-sys-foreign-cols-table" title="24.32.20&nbsp;The INFORMATION_SCHEMA INNODB_SYS_FOREIGN_COLS Table"><code class="literal">INNODB_SYS_FOREIGN_COLS</code></a> provides
                    metadata about the columns of foreign keys that are defined on
                    <code class="literal">InnoDB</code> tables, equivalent to the
                    information in the <code class="literal">SYS_FOREIGN_COLS</code> table
                    in the <code class="literal">InnoDB</code> data dictionary.
                </p><p style="color:blue;">innodb_sys_foreign_cols提供关于innodb表上定义的外键列的元数据，相当于innodb数据字典中sys_foreign_cols表中的信息。</p></li></ul>
            </div>
            <p>
                <code class="literal">InnoDB</code> <code class="literal">INFORMATION_SCHEMA</code>
                system tables can be joined together through fields such as
                <code class="literal">TABLE_ID</code>, <code class="literal">INDEX_ID</code>, and
                <code class="literal">SPACE</code>, allowing you to easily retrieve all
                available data for an object you want to study or monitor.
            </p><p style="color:blue;">innodb information_schema系统表可以通过table_id、index_id和space等字段连接在一起，允许您轻松检索要研究或监视的对象的所有可用数据。</p><p>
            Refer to the <code class="literal">InnoDB</code>
            <a class="link" href="information-schema.html#innodb-i_s-tables" title="24.32&nbsp;INFORMATION_SCHEMA InnoDB Tables">INFORMATION_SCHEMA</a>
            documentation for information about the columns of each table.
        </p><p style="color:blue;">有关每个表的列的信息，请参阅innodb information_schema文档。</p>
            <div class="example">
                <a name="innodb-information-schema-system-tables-example"></a><p class="title"><b>Example&nbsp;14.2&nbsp;InnoDB INFORMATION_SCHEMA System Tables</b></p><p style="color:blue;">示例14.2 innodb information_schema系统表</p>
                <div class="example-contents">
                    <p>
                        This example uses a simple table (<code class="literal">t1</code>) with a
                        single index (<code class="literal">i1</code>) to demonstrate the type of
                        metadata found in the <code class="literal">InnoDB</code>
                        <code class="literal">INFORMATION_SCHEMA</code> system tables.
                    </p><p style="color:blue;">本例使用一个简单的表（T1）和一个索引（I1）来演示innodb information_schema系统表中的元数据类型。</p>
                    <div class="orderedlist">
                        <ol class="orderedlist" type="1"><li class="listitem"><p>
                            Create a test database and table <code class="literal">t1</code>:
                        </p><p style="color:blue;">创建测试数据库和表T1：</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>CREATE DATABASE test;</code></strong>

mysql&gt; <strong class="userinput"><code>USE test;</code></strong>

mysql&gt; <strong class="userinput"><code>CREATE TABLE t1 (</code></strong>
       <strong class="userinput"><code>col1 INT,</code></strong>
       <strong class="userinput"><code>col2 CHAR(10),</code></strong>
       <strong class="userinput"><code>col3 VARCHAR(10))</code></strong>
       <strong class="userinput"><code>ENGINE = InnoDB;</code></strong>

mysql&gt; <strong class="userinput"><code>CREATE INDEX i1 ON t1(col1);</code></strong>
</pre></li><li class="listitem"><p>
                            After creating the table <code class="literal">t1</code>, query
                            <a class="link" href="information-schema.html#innodb-sys-tables-table" title="24.32.22&nbsp;The INFORMATION_SCHEMA INNODB_SYS_TABLES Table"><code class="literal">INNODB_SYS_TABLES</code></a> to locate the
                            metadata for <code class="literal">test/t1</code>:
                        </p><p style="color:blue;">创建表T1后，查询innodb_sys_tables以找到test/T1的元数据：</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT * FROM INFORMATION_SCHEMA.INNODB_SYS_TABLES WHERE NAME='test/t1' \G</code></strong>
*************************** 1. row ***************************
     TABLE_ID: 71
         NAME: test/t1
         FLAG: 1
       N_COLS: 6
        SPACE: 57
  FILE_FORMAT: Antelope
   ROW_FORMAT: Compact
ZIP_PAGE_SIZE: 0
...
</pre><p>
                            Table <code class="literal">t1</code> has a
                            <code class="literal">TABLE_ID</code> of 71. The
                            <code class="literal">FLAG</code> field provides bit level information
                            about table format and storage characteristics. There are
                            six columns, three of which are hidden columns created by
                            <code class="literal">InnoDB</code> (<code class="literal">DB_ROW_ID</code>,
                            <code class="literal">DB_TRX_ID</code>, and
                            <code class="literal">DB_ROLL_PTR</code>). The ID of the table's
                            <code class="literal">SPACE</code> is 57 (a value of 0 would indicate
                            that the table resides in the system tablespace). The
                            <code class="literal">FILE_FORMAT</code> is Antelope, and the
                            <code class="literal">ROW_FORMAT</code> is Compact.
                            <code class="literal">ZIP_PAGE_SIZE</code> only applies to tables with
                            a <code class="literal">Compressed</code> row format.
                        </p><p style="color:blue;">表T1的表ID为71。标记字段提供有关表格式和存储特性的位级信息。共有六列，其中三列是innodb创建的隐藏列（db_row_id、db_trx_id和db_roll_ptr）。表空间的id是57（值为0表示表位于系统表空间中）。文件格式是羚羊，行格式是紧凑的。zip_page_size仅适用于压缩行格式的表。</p></li><li class="listitem"><p>
                            Using the <code class="literal">TABLE_ID</code> information from
                            <a class="link" href="information-schema.html#innodb-sys-tables-table" title="24.32.22&nbsp;The INFORMATION_SCHEMA INNODB_SYS_TABLES Table"><code class="literal">INNODB_SYS_TABLES</code></a>, query the
                            <a class="link" href="information-schema.html#innodb-sys-columns-table" title="24.32.16&nbsp;The INFORMATION_SCHEMA INNODB_SYS_COLUMNS Table"><code class="literal">INNODB_SYS_COLUMNS</code></a> table for
                            information about the table's columns.
                        </p><p style="color:blue;">使用innodb_sys_table s中的table_id信息，查询innodb_sys_columns表以获取有关该表的列的信息。</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT * FROM INFORMATION_SCHEMA.INNODB_SYS_COLUMNS where TABLE_ID = 71 \G</code></strong>
*************************** 1. row ***************************
TABLE_ID: 71
    NAME: col1
     POS: 0
   MTYPE: 6
  PRTYPE: 1027
     LEN: 4
*************************** 2. row ***************************
TABLE_ID: 71
    NAME: col2
     POS: 1
   MTYPE: 2
  PRTYPE: 524542
     LEN: 10
*************************** 3. row ***************************
TABLE_ID: 71
    NAME: col3
     POS: 2
   MTYPE: 1
  PRTYPE: 524303
     LEN: 10
</pre><p>
                            In addition to the <code class="literal">TABLE_ID</code> and column
                            <code class="literal">NAME</code>,
                            <a class="link" href="information-schema.html#innodb-sys-columns-table" title="24.32.16&nbsp;The INFORMATION_SCHEMA INNODB_SYS_COLUMNS Table"><code class="literal">INNODB_SYS_COLUMNS</code></a> provides the
                            ordinal position (<code class="literal">POS</code>) of each column
                            (starting from 0 and incrementing sequentially), the column
                            <code class="literal">MTYPE</code> or <span class="quote">“<span class="quote">main type</span>”</span> (6 =
                            INT, 2 = CHAR, 1 = VARCHAR), the <code class="literal">PRTYPE</code>
                            or <span class="quote">“<span class="quote">precise type</span>”</span> (a binary value with bits
                            that represent the MySQL data type, character set code, and
                            nullability), and the column length
                            (<code class="literal">LEN</code>).
                        </p><p style="color:blue;">除了表id和列名之外，innodb_sys_columns还提供了每列的序号位置（pos）（从0开始并按顺序递增）、列mtype或“main type”（6=int，2=char，1=varchar）、prtype或“precise type”（二进制值，其位表示mysql数据类型、字符集代码，以及列长度（len）。</p></li><li class="listitem"><p>
                            Using the <code class="literal">TABLE_ID</code> information from
                            <a class="link" href="information-schema.html#innodb-sys-tables-table" title="24.32.22&nbsp;The INFORMATION_SCHEMA INNODB_SYS_TABLES Table"><code class="literal">INNODB_SYS_TABLES</code></a> once again,
                            query <a class="link" href="information-schema.html#innodb-sys-indexes-table" title="24.32.21&nbsp;The INFORMATION_SCHEMA INNODB_SYS_INDEXES Table"><code class="literal">INNODB_SYS_INDEXES</code></a> for
                            information about the indexes associated with table
                            <code class="literal">t1</code>.
                        </p><p style="color:blue;">再次使用innodb_sys_tables中的table_id信息，查询innodb_sys_indexes以获取与table t1相关联的索引的信息。</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT * FROM INFORMATION_SCHEMA.INNODB_SYS_INDEXES WHERE TABLE_ID = 71 \G</code></strong>
*************************** 1. row ***************************
       INDEX_ID: 111
           NAME: GEN_CLUST_INDEX
       TABLE_ID: 71
           TYPE: 1
       N_FIELDS: 0
        PAGE_NO: 3
          SPACE: 57
MERGE_THRESHOLD: 50
*************************** 2. row ***************************
       INDEX_ID: 112
           NAME: i1
       TABLE_ID: 71
           TYPE: 0
       N_FIELDS: 1
        PAGE_NO: 4
          SPACE: 57
MERGE_THRESHOLD: 50
</pre><p>
                            <a class="link" href="information-schema.html#innodb-sys-indexes-table" title="24.32.21&nbsp;The INFORMATION_SCHEMA INNODB_SYS_INDEXES Table"><code class="literal">INNODB_SYS_INDEXES</code></a> returns data
                            for two indexes. The first index is
                            <code class="literal">GEN_CLUST_INDEX</code>, which is a clustered
                            index created by <code class="literal">InnoDB</code> if the table does
                            not have a user-defined clustered index. The second index
                            (<code class="literal">i1</code>) is the user-defined secondary index.
                        </p><p style="color:blue;">innodb_sys_indexes返回两个索引的数据。第一个索引是gen_clust_index，如果表没有用户定义的聚集索引，它是innodb创建的聚集索引。第二个索引（i1）是用户定义的辅助索引。</p><p>
                            The <code class="literal">INDEX_ID</code> is an identifier for the
                            index that is unique across all databases in an instance.
                            The <code class="literal">TABLE_ID</code> identifies the table that
                            the index is associated with. The index
                            <code class="literal">TYPE</code> value indicates the type of index (1
                            = Clustered Index, 0 = Secondary index). The
                            <code class="literal">N_FILEDS</code> value is the number of fields
                            that comprise the index. <code class="literal">PAGE_NO</code> is the
                            root page number of the index B-tree, and
                            <code class="literal">SPACE</code> is the ID of the tablespace where
                            the index resides. A nonzero value indicates that the index
                            does not reside in the system tablespace.
                            <code class="literal">MERGE_THRESHOLD</code> defines a percentage
                            threshold value for the amount of data in an index page. If
                            the amount of data in an index page falls below the this
                            value (the default is 50%) when a row is deleted or when a
                            row is shortened by an update operation,
                            <code class="literal">InnoDB</code> attempts to merge the index page
                            with a neighboring index page.
                        </p><p style="color:blue;">索引id是索引的标识符，它在实例中的所有数据库中都是唯一的。表id标识与索引关联的表。索引类型值指示索引的类型（1=聚集索引，0=辅助索引）。n_fileds值是组成索引的字段数。page_no是索引b树的根页码，space是索引所在表空间的id。非零值表示索引不在系统表空间中。merge_threshold定义索引页中数据量的百分比阈值。如果删除行或更新操作缩短行时，索引页中的数据量低于此值（默认值为50%），InnoDB会尝试将索引页与相邻的索引页合并。</p></li><li class="listitem"><p>
                            Using the <code class="literal">INDEX_ID</code> information from
                            <a class="link" href="information-schema.html#innodb-sys-indexes-table" title="24.32.21&nbsp;The INFORMATION_SCHEMA INNODB_SYS_INDEXES Table"><code class="literal">INNODB_SYS_INDEXES</code></a>, query
                            <a class="link" href="information-schema.html#innodb-sys-fields-table" title="24.32.18&nbsp;The INFORMATION_SCHEMA INNODB_SYS_FIELDS Table"><code class="literal">INNODB_SYS_FIELDS</code></a> for
                            information about the fields of index <code class="literal">i1</code>.
                        </p><p style="color:blue;">使用innodb_sys_index中的index_id信息，查询innodb_sys_fields以获取有关索引i1的字段的信息。</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT * FROM INFORMATION_SCHEMA.INNODB_SYS_FIELDS where INDEX_ID = 112 \G</code></strong>
*************************** 1. row ***************************
INDEX_ID: 112
    NAME: col1
     POS: 0
</pre><p>
                            <a class="link" href="information-schema.html#innodb-sys-fields-table" title="24.32.18&nbsp;The INFORMATION_SCHEMA INNODB_SYS_FIELDS Table"><code class="literal">INNODB_SYS_FIELDS</code></a> provides the
                            <code class="literal">NAME</code> of the indexed field and its ordinal
                            position within the index. If the index (i1) had been
                            defined on multiple fields,
                            <a class="link" href="information-schema.html#innodb-sys-fields-table" title="24.32.18&nbsp;The INFORMATION_SCHEMA INNODB_SYS_FIELDS Table"><code class="literal">INNODB_SYS_FIELDS</code></a> would provide
                            metadata for each of the indexed fields.
                        </p><p style="color:blue;">innodb_sys_fields提供索引字段的名称及其在索引中的序号位置。如果索引（i1）是在多个字段上定义的，那么innodb_sys_字段将为每个索引字段提供元数据。</p></li><li class="listitem"><p>
                            Using the <code class="literal">SPACE</code> information from
                            <a class="link" href="information-schema.html#innodb-sys-tables-table" title="24.32.22&nbsp;The INFORMATION_SCHEMA INNODB_SYS_TABLES Table"><code class="literal">INNODB_SYS_TABLES</code></a>, query
                            <a class="link" href="information-schema.html#innodb-sys-tablespaces-table" title="24.32.22.1&nbsp;The INFORMATION_SCHEMA INNODB_SYS_TABLESPACES Table"><code class="literal">INNODB_SYS_TABLESPACES</code></a> table
                            for information about the table's tablespace.
                        </p><p style="color:blue;">使用innodb_sys_table s中的空间信息，查询innodb_sys_tables spaces table以获取该表的表空间信息。</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT * FROM INFORMATION_SCHEMA.INNODB_SYS_TABLESPACES WHERE SPACE = 57 \G</code></strong>
*************************** 1. row ***************************
        SPACE: 57
         NAME: test/t1
         FLAG: 0
  FILE_FORMAT: Antelope
   ROW_FORMAT: Compact or Redundant
    PAGE_SIZE: 16384
ZIP_PAGE_SIZE: 0
</pre><p>
                            In addition to the <code class="literal">SPACE</code> ID of the
                            tablespace and the <code class="literal">NAME</code> of the associated
                            table, <a class="link" href="information-schema.html#innodb-sys-tablespaces-table" title="24.32.22.1&nbsp;The INFORMATION_SCHEMA INNODB_SYS_TABLESPACES Table"><code class="literal">INNODB_SYS_TABLESPACES</code></a>
                            provides tablespace <code class="literal">FLAG</code> data, which is
                            bit level information about tablespace format and storage
                            characteristics. Also provided are tablespace
                            <code class="literal">FILE_FORMAT</code>,
                            <code class="literal">ROW_FORMAT</code>, <code class="literal">PAGE_SIZE</code>,
                            and several other tablespace metadata items.
                        </p><p style="color:blue;">除了表空间的空间id和相关表的名称之外，innodb_sys_tablespaces还提供表空间标志数据，这是关于表空间格式和存储特性的位级信息。还提供了表空间文件格式、行格式、页大小和其他几个表空间元数据项。</p></li><li class="listitem"><p>
                            Using the <code class="literal">SPACE</code> information from
                            <a class="link" href="information-schema.html#innodb-sys-tables-table" title="24.32.22&nbsp;The INFORMATION_SCHEMA INNODB_SYS_TABLES Table"><code class="literal">INNODB_SYS_TABLES</code></a> once again,
                            query <a class="link" href="information-schema.html#innodb-sys-datafiles-table" title="24.32.17&nbsp;The INFORMATION_SCHEMA INNODB_SYS_DATAFILES Table"><code class="literal">INNODB_SYS_DATAFILES</code></a> for
                            the location of the tablespace data file.
                        </p><p style="color:blue;">再次使用innodb_sys_表中的空间信息，查询innodb_sys_数据文件以获取表空间数据文件的位置。</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT * FROM INFORMATION_SCHEMA.INNODB_SYS_DATAFILES WHERE SPACE = 57 \G</code></strong>
*************************** 1. row ***************************
SPACE: 57
 PATH: ./test/t1.ibd
</pre><p>
                            The datafile is located in the <code class="literal">test</code>
                            directory under MySQL's <code class="literal">data</code> directory.
                            If a
                            <a class="link" href="glossary.html#glos_file_per_table" title="file-per-table">file-per-table</a>
                            tablespace were created in a location outside the MySQL data
                            directory using the <code class="literal">DATA DIRECTORY</code> clause
                            of the <a class="link" href="sql-syntax.html#create-table" title="13.1.18&nbsp;CREATE TABLE Syntax"><code class="literal">CREATE TABLE</code></a>
                            statement, the tablespace <code class="literal">PATH</code> would be a
                            fully qualified directory path.
                        </p><p style="color:blue;">数据文件位于mysql数据目录下的测试目录中。如果使用create table语句的data directory子句在mysql数据目录之外的位置创建每个表表空间的文件，那么表空间路径将是完全限定的目录路径。</p></li><li class="listitem"><p>
                            As a final step, insert a row into table
                            <code class="literal">t1</code> (<code class="literal">TABLE_ID = 71</code>) and
                            view the data in the
                            <a class="link" href="information-schema.html#innodb-sys-tablestats-table" title="24.32.23&nbsp;The INFORMATION_SCHEMA INNODB_SYS_TABLESTATS View"><code class="literal">INNODB_SYS_TABLESTATS</code></a> table.
                            The data in this table is used by the MySQL optimizer to
                            calculate which index to use when querying an
                            <code class="literal">InnoDB</code> table. This information is derived
                            from in-memory data structures. There is no corresponding
                            internal <code class="literal">InnoDB</code> system table.
                        </p><p style="color:blue;">最后一步，将一行插入表T1（table_id=71）并查看innodb_sys_tablestats表中的数据。mysql优化器使用此表中的数据计算查询innodb表时要使用的索引。此信息来自内存中的数据结构。没有对应的内部innodb系统表。</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>INSERT INTO t1 VALUES(5, 'abc', 'def');</code></strong>
Query OK, 1 row affected (0.06 sec)

mysql&gt; <strong class="userinput"><code>SELECT * FROM INFORMATION_SCHEMA.INNODB_SYS_TABLESTATS where TABLE_ID = 71 \G</code></strong>
*************************** 1. row ***************************
         TABLE_ID: 71
             NAME: test/t1
STATS_INITIALIZED: Initialized
         NUM_ROWS: 1
 CLUST_INDEX_SIZE: 1
 OTHER_INDEX_SIZE: 0
 MODIFIED_COUNTER: 1
          AUTOINC: 0
        REF_COUNT: 1
</pre><p>
                            The <code class="literal">STATS_INITIALIZED</code> field indicates
                            whether or not statistics have been collected for the table.
                            <code class="literal">NUM_ROWS</code> is the current estimated number
                            of rows in the table. The
                            <code class="literal">CLUST_INDEX_SIZE</code> and
                            <code class="literal">OTHER_INDEX_SIZE</code> fields report the number
                            of pages on disk that store clustered and secondary indexes
                            for the table, respectively. The
                            <code class="literal">MODIFIED_COUNTER</code> value shows the number
                            of rows modified by DML operations and cascade operations
                            from foreign keys. The <code class="literal">AUTOINC</code> value is
                            the next number to be issued for any autoincrement-based
                            operation. There are no autoincrement columns defined on
                            table <code class="literal">t1</code>, so the value is 0. The
                            <code class="literal">REF_COUNT</code> value is a counter. When the
                            counter reaches 0, it signifies that the table metadata can
                            be evicted from the table cache.
                        </p><p style="color:blue;">stats_initialized字段指示是否已为表收集统计信息。num_rows是表中当前估计的行数。clust_index_size和其他_index_size字段分别报告磁盘上存储表的聚集索引和辅助索引的页数。modified_counter值显示由dml操作和来自外键的级联操作修改的行数。autoinc值是为任何基于autoincrement的操作发出的下一个数字。表T1上没有定义自动递增列，因此该值为0。ref_count值是一个计数器。当计数器达到0时，表示可以从表缓存中逐出表元数据。</p></li></ol>
                    </div>

                </div>

            </div>
            <br class="example-break">
            <div class="example">
                <a name="innodb-information-schema-fk-system-tables-example"></a><p class="title"><b>Example&nbsp;14.3&nbsp;Foreign Key INFORMATION_SCHEMA System Tables</b></p><p style="color:blue;">示例14.3外键信息模式系统表</p>
                <div class="example-contents">
                    <p>
                        The <a class="link" href="information-schema.html#innodb-sys-foreign-table" title="24.32.19&nbsp;The INFORMATION_SCHEMA INNODB_SYS_FOREIGN Table"><code class="literal">INNODB_SYS_FOREIGN</code></a> and
                        <a class="link" href="information-schema.html#innodb-sys-foreign-cols-table" title="24.32.20&nbsp;The INFORMATION_SCHEMA INNODB_SYS_FOREIGN_COLS Table"><code class="literal">INNODB_SYS_FOREIGN_COLS</code></a> tables
                        provide data about foreign key relationships. This example uses
                        a parent table and child table with a foreign key relationship
                        to demonstrate the data found in the
                        <a class="link" href="information-schema.html#innodb-sys-foreign-table" title="24.32.19&nbsp;The INFORMATION_SCHEMA INNODB_SYS_FOREIGN Table"><code class="literal">INNODB_SYS_FOREIGN</code></a> and
                        <a class="link" href="information-schema.html#innodb-sys-foreign-cols-table" title="24.32.20&nbsp;The INFORMATION_SCHEMA INNODB_SYS_FOREIGN_COLS Table"><code class="literal">INNODB_SYS_FOREIGN_COLS</code></a> tables.
                    </p><p style="color:blue;">innodb_sys_foreign和innodb_sys_foreign_cols表提供有关外键关系的数据。本例使用具有外键关系的父表和子表来演示在innodb sys_foreign和innodb sys_foreign_cols表中找到的数据。</p>
                    <div class="orderedlist">
                        <ol class="orderedlist" type="1"><li class="listitem"><p>
                            Create the test database with parent and child tables:
                        </p><p style="color:blue;">使用父表和子表创建测试数据库：</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>CREATE DATABASE test;</code></strong>

mysql&gt; <strong class="userinput"><code>USE test;</code></strong>

mysql&gt; <strong class="userinput"><code>CREATE TABLE parent (id INT NOT NULL,</code></strong>
       <strong class="userinput"><code>PRIMARY KEY (id)) ENGINE=INNODB;</code></strong>

mysql&gt; <strong class="userinput"><code>CREATE TABLE child (id INT, parent_id INT,</code></strong>
       <strong class="userinput"><code>INDEX par_ind (parent_id),</code></strong>
       <strong class="userinput"><code>CONSTRAINT fk1</code></strong>
       <strong class="userinput"><code>FOREIGN KEY (parent_id) REFERENCES parent(id)</code></strong>
       <strong class="userinput"><code>ON DELETE CASCADE) ENGINE=INNODB;</code></strong>
</pre></li><li class="listitem"><p>
                            After the parent and child tables are created, query
                            <a class="link" href="information-schema.html#innodb-sys-foreign-table" title="24.32.19&nbsp;The INFORMATION_SCHEMA INNODB_SYS_FOREIGN Table"><code class="literal">INNODB_SYS_FOREIGN</code></a> and locate
                            the foreign key data for the <code class="literal">test/child</code>
                            and <code class="literal">test/parent</code> foreign key relationship:
                        </p><p style="color:blue;">创建父表和子表后，查询innodb_sys_foreign，找到test/child和test/parent外键关系的外键数据：</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT * FROM INFORMATION_SCHEMA.INNODB_SYS_FOREIGN \G</code></strong>
*************************** 1. row ***************************
      ID: test/fk1
FOR_NAME: test/child
REF_NAME: test/parent
  N_COLS: 1
    TYPE: 1
</pre><p>
                            Metadata includes the foreign key <code class="literal">ID</code>
                            (<code class="literal">fk1</code>), which is named for the
                            <code class="literal">CONSTRAINT</code> that was defined on the child
                            table. The <code class="literal">FOR_NAME</code> is the name of the
                            child table where the foreign key is defined.
                            <code class="literal">REF_NAME</code> is the name of the parent table
                            (the <span class="quote">“<span class="quote">referenced</span>”</span> table).
                            <code class="literal">N_COLS</code> is the number of columns in the
                            foreign key index. <code class="literal">TYPE</code> is a numerical
                            value representing bit flags that provide additional
                            information about the foreign key column. In this case, the
                            <code class="literal">TYPE</code> value is 1, which indicates that the
                            <code class="literal">ON DELETE CASCADE</code> option was specified
                            for the foreign key. See the
                            <a class="link" href="information-schema.html#innodb-sys-foreign-table" title="24.32.19&nbsp;The INFORMATION_SCHEMA INNODB_SYS_FOREIGN Table"><code class="literal">INNODB_SYS_FOREIGN</code></a> table
                            definition for more information about
                            <code class="literal">TYPE</code> values.
                        </p><p style="color:blue;">元数据包括外键id（fk1），它是为子表上定义的约束命名的。for_name是定义外键的子表的名称。ref_name是父表（“referenced”表）的名称。n_cols是外键索引中的列数。类型是一个数字值，表示提供有关外键列的附加信息的位标志。在本例中，type值为1，这表示为外键指定了on delete cascade选项。有关类型值的更多信息，请参阅innodb_sys_foreign表定义。</p></li><li class="listitem"><p>
                            Using the foreign key <code class="literal">ID</code>, query
                            <a class="link" href="information-schema.html#innodb-sys-foreign-cols-table" title="24.32.20&nbsp;The INFORMATION_SCHEMA INNODB_SYS_FOREIGN_COLS Table"><code class="literal">INNODB_SYS_FOREIGN_COLS</code></a> to view
                            data about the columns of the foreign key.
                        </p><p style="color:blue;">使用外键id，查询innodb_sys_foreign_cols以查看关于外键列的数据。</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT * FROM INFORMATION_SCHEMA.INNODB_SYS_FOREIGN_COLS WHERE ID = 'test/fk1' \G</code></strong>
*************************** 1. row ***************************
          ID: test/fk1
FOR_COL_NAME: parent_id
REF_COL_NAME: id
         POS: 0
</pre><p>
                            <code class="literal">FOR_COL_NAME</code> is the name of the foreign
                            key column in the child table, and
                            <code class="literal">REF_COL_NAME</code> is the name of the
                            referenced column in the parent table. The
                            <code class="literal">POS</code> value is the ordinal position of the
                            key field within the foreign key index, starting at zero.
                        </p><p style="color:blue;">for col_name是子表中外键列的名称，ref_col_name是父表中被引用列的名称。pos值是外键索引中键字段的序号位置，从零开始。</p></li></ol>
                    </div>

                </div>

            </div>
            <br class="example-break">
            <div class="example">
                <a name="innodb-information-schema-system-tables-join-example"></a><p class="title"><b>Example&nbsp;14.4&nbsp;Joining InnoDB INFORMATION_SCHEMA System Tables</b></p><p style="color:blue;">示例14.4连接innodb information_schema系统表</p>
                <div class="example-contents">
                    <p>
                        This example demonstrates joining three
                        <code class="literal">InnoDB</code> <code class="literal">INFORMATION_SCHEMA</code>
                        system tables (<a class="link" href="information-schema.html#innodb-sys-tables-table" title="24.32.22&nbsp;The INFORMATION_SCHEMA INNODB_SYS_TABLES Table"><code class="literal">INNODB_SYS_TABLES</code></a>,
                        <a class="link" href="information-schema.html#innodb-sys-tablespaces-table" title="24.32.22.1&nbsp;The INFORMATION_SCHEMA INNODB_SYS_TABLESPACES Table"><code class="literal">INNODB_SYS_TABLESPACES</code></a>, and
                        <a class="link" href="information-schema.html#innodb-sys-tablestats-table" title="24.32.23&nbsp;The INFORMATION_SCHEMA INNODB_SYS_TABLESTATS View"><code class="literal">INNODB_SYS_TABLESTATS</code></a>) to gather
                        file format, row format, page size, and index size information
                        about tables in the employees sample database.
                    </p><p style="color:blue;">此示例演示如何将三个innodb information_schema系统表（innodb_sys_tables、innodb_sys_tables spaces和innodb_sys_tables tats）合并到employees示例数据库中，以收集有关表的文件格式、行格式、页面大小和索引大小信息。</p><p>
                    The following table name aliases are used to shorten the query
                    string:
                </p><p style="color:blue;">以下表名别名用于缩短查询字符串：</p>
                    <div class="itemizedlist">
                        <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                            <a class="link" href="information-schema.html#innodb-sys-tables-table" title="24.32.22&nbsp;The INFORMATION_SCHEMA INNODB_SYS_TABLES Table"><code class="literal">INFORMATION_SCHEMA.INNODB_SYS_TABLES</code></a>:
                            a
                        </p><p style="color:blue;">information_schema.innodb_sys_tables:一个</p></li><li class="listitem"><p>
                            <a class="link" href="information-schema.html#innodb-sys-tablespaces-table" title="24.32.22.1&nbsp;The INFORMATION_SCHEMA INNODB_SYS_TABLESPACES Table"><code class="literal">INFORMATION_SCHEMA.INNODB_SYS_TABLESPACES</code></a>:
                            b
                        </p><p style="color:blue;">information_schema.innodb_sys_表空间：b</p></li><li class="listitem"><p>
                            <a class="link" href="information-schema.html#innodb-sys-tablestats-table" title="24.32.23&nbsp;The INFORMATION_SCHEMA INNODB_SYS_TABLESTATS View"><code class="literal">INFORMATION_SCHEMA.INNODB_SYS_TABLESTATS</code></a>:
                            c
                        </p><p style="color:blue;">information_schema.innodb_sys_表状态：C</p></li></ul>
                    </div>
                    <p>
                        An <a class="link" href="functions.html#function_if"><code class="literal">IF()</code></a> control flow function is
                        used to account for compressed tables. If a table is compressed,
                        the index size is calculated using
                        <code class="literal">ZIP_PAGE_SIZE</code> rather than
                        <code class="literal">PAGE_SIZE</code>.
                        <code class="literal">CLUST_INDEX_SIZE</code> and
                        <code class="literal">OTHER_INDEX_SIZE</code>, which are reported in
                        bytes, are divided by <code class="literal">1024*1024</code> to provide
                        index sizes in megabytes (MBs). MB values are rounded to zero
                        decimal spaces using the <a class="link" href="functions.html#function_round"><code class="literal">ROUND()</code></a>
                        function.
                    </p><p style="color:blue;">if（）控制流函数用于解释压缩表。如果表是压缩的，则索引大小是使用ZIP页面大小而不是页面大小计算的。clust_index_size和以字节为单位报告的其他_index_size除以1024*1024，以提供以兆字节（mbs）为单位的索引大小。使用round（）函数将MB值舍入为零个十进制空格。</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT a.NAME, a.FILE_FORMAT, a.ROW_FORMAT,</code></strong>
        <strong class="userinput"><code>@page_size :=</code></strong>
         <strong class="userinput"><code>IF(a.ROW_FORMAT='Compressed',</code></strong>
          <strong class="userinput"><code>b.ZIP_PAGE_SIZE, b.PAGE_SIZE)</code></strong>
          <strong class="userinput"><code>AS page_size,</code></strong>
         <strong class="userinput"><code>ROUND((@page_size * c.CLUST_INDEX_SIZE)</code></strong>
          <strong class="userinput"><code>/(1024*1024)) AS pk_mb,</code></strong>
         <strong class="userinput"><code>ROUND((@page_size * c.OTHER_INDEX_SIZE)</code></strong>
          <strong class="userinput"><code>/(1024*1024)) AS secidx_mb</code></strong>
       <strong class="userinput"><code>FROM INFORMATION_SCHEMA.INNODB_SYS_TABLES a</code></strong>
       <strong class="userinput"><code>INNER JOIN INFORMATION_SCHEMA.INNODB_SYS_TABLESPACES b on a.NAME = b.NAME</code></strong>
       <strong class="userinput"><code>INNER JOIN INFORMATION_SCHEMA.INNODB_SYS_TABLESTATS c on b.NAME = c.NAME</code></strong>
       <strong class="userinput"><code>WHERE a.NAME LIKE 'employees/%'</code></strong>
       <strong class="userinput"><code>ORDER BY a.NAME DESC;</code></strong>
+------------------------+-------------+------------+-----------+-------+-----------+
| NAME                   | FILE_FORMAT | ROW_FORMAT | page_size | pk_mb | secidx_mb |
+------------------------+-------------+------------+-----------+-------+-----------+
| employees/titles       | Antelope    | Compact    |     16384 |    20 |        11 |
| employees/salaries     | Antelope    | Compact    |     16384 |    91 |        33 |
| employees/employees    | Antelope    | Compact    |     16384 |    15 |         0 |
| employees/dept_manager | Antelope    | Compact    |     16384 |     0 |         0 |
| employees/dept_emp     | Antelope    | Compact    |     16384 |    12 |        10 |
| employees/departments  | Antelope    | Compact    |     16384 |     0 |         0 |
+------------------------+-------------+------------+-----------+-------+-----------+
</pre>
                </div>

            </div>
            <br class="example-break">
        </div>
        <div class="section">
            <div class="titlepage">
                <div>
                    <div>
                        <h3 class="title"><a name="innodb-information-schema-fulltext_index-tables"></a>14.15.4&nbsp;InnoDB INFORMATION_SCHEMA FULLTEXT Index Tables</h3>

                    </div>

                </div>

            </div>
            <p>
                The following tables provide metadata for
                <code class="literal">FULLTEXT</code> indexes:
            </p><p style="color:blue;">下表提供了全文索引的元数据：</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>SHOW TABLES FROM INFORMATION_SCHEMA LIKE 'INNODB_FT%';</code></strong>
+-------------------------------------------+
| Tables_in_INFORMATION_SCHEMA (INNODB_FT%) |
+-------------------------------------------+
| INNODB_FT_CONFIG                          |
| INNODB_FT_BEING_DELETED                   |
| INNODB_FT_DELETED                         |
| INNODB_FT_DEFAULT_STOPWORD                |
| INNODB_FT_INDEX_TABLE                     |
| INNODB_FT_INDEX_CACHE                     |
+-------------------------------------------+
</pre>
            <h4><a name="idm140286807152288"></a>Table Overview</h4>
            <div class="itemizedlist">
                <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                    <a class="link" href="information-schema.html#innodb-ft-config-table" title="24.32.8&nbsp;The INFORMATION_SCHEMA INNODB_FT_CONFIG Table"><code class="literal">INNODB_FT_CONFIG</code></a>: Provides
                    metadata about the <code class="literal">FULLTEXT</code> index and
                    associated processing for an <code class="literal">InnoDB</code> table.
                </p><p style="color:blue;">innodb_ft_config：提供有关innodb表的全文索引和相关处理的元数据。</p></li><li class="listitem"><p>
                    <a class="link" href="information-schema.html#innodb-ft-being-deleted-table" title="24.32.7&nbsp;The INFORMATION_SCHEMA INNODB_FT_BEING_DELETED Table"><code class="literal">INNODB_FT_BEING_DELETED</code></a>: Provides
                    a snapshot of the
                    <a class="link" href="information-schema.html#innodb-ft-deleted-table" title="24.32.10&nbsp;The INFORMATION_SCHEMA INNODB_FT_DELETED Table"><code class="literal">INNODB_FT_DELETED</code></a> table; it is
                    used only during an <a class="link" href="sql-syntax.html#optimize-table" title="13.7.2.4&nbsp;OPTIMIZE TABLE Syntax"><code class="literal">OPTIMIZE
                    TABLE</code></a> maintenance operation. When
                    <a class="link" href="sql-syntax.html#optimize-table" title="13.7.2.4&nbsp;OPTIMIZE TABLE Syntax"><code class="literal">OPTIMIZE TABLE</code></a> is run, the
                    <a class="link" href="information-schema.html#innodb-ft-being-deleted-table" title="24.32.7&nbsp;The INFORMATION_SCHEMA INNODB_FT_BEING_DELETED Table"><code class="literal">INNODB_FT_BEING_DELETED</code></a> table is
                    emptied, and <code class="literal">DOC_ID</code> values are removed from
                    the <a class="link" href="information-schema.html#innodb-ft-deleted-table" title="24.32.10&nbsp;The INFORMATION_SCHEMA INNODB_FT_DELETED Table"><code class="literal">INNODB_FT_DELETED</code></a> table.
                    Because the contents of
                    <a class="link" href="information-schema.html#innodb-ft-being-deleted-table" title="24.32.7&nbsp;The INFORMATION_SCHEMA INNODB_FT_BEING_DELETED Table"><code class="literal">INNODB_FT_BEING_DELETED</code></a> typically
                    have a short lifetime, this table has limited utility for
                    monitoring or debugging. For information about running
                    <a class="link" href="sql-syntax.html#optimize-table" title="13.7.2.4&nbsp;OPTIMIZE TABLE Syntax"><code class="literal">OPTIMIZE TABLE</code></a> on tables with
                    <code class="literal">FULLTEXT</code> indexes, see
                    <a class="xref" href="functions.html#fulltext-fine-tuning" title="12.9.6&nbsp;Fine-Tuning MySQL Full-Text Search">Section&nbsp;12.9.6, “Fine-Tuning MySQL Full-Text Search”</a>.
                </p><p style="color:blue;">innodb_ft_being_deleted：提供innodb_ft_deleted表的快照；仅在优化表维护操作期间使用。运行optimize table时，innodb_ft_being_deleted table被清空，doc_id值从innodb_ft_deleted table中移除。由于被删除的innodb_ft_的内容通常具有很短的生命周期，因此此表用于监视或调试的实用程序有限。有关在具有全文索引的表上运行优化表的信息，请参阅12.9.6节“微调mysql全文搜索”。</p></li><li class="listitem"><p>
                    <a class="link" href="information-schema.html#innodb-ft-deleted-table" title="24.32.10&nbsp;The INFORMATION_SCHEMA INNODB_FT_DELETED Table"><code class="literal">INNODB_FT_DELETED</code></a>: Stores rows
                    that are deleted from the <code class="literal">FULLTEXT</code> index
                    for an <code class="literal">InnoDB</code> table. To avoid expensive
                    index reorganization during DML operations for an
                    <code class="literal">InnoDB</code> <code class="literal">FULLTEXT</code> index,
                    the information about newly deleted words is stored
                    separately, filtered out of search results when you do a text
                    search, and removed from the main search index only when you
                    issue an <a class="link" href="sql-syntax.html#optimize-table" title="13.7.2.4&nbsp;OPTIMIZE TABLE Syntax"><code class="literal">OPTIMIZE TABLE</code></a>
                    statement for the <code class="literal">InnoDB</code> table.
                </p><p style="color:blue;">innodb_ft_deleted：存储从innodb表的全文索引中删除的行。为了避免在innodb全文索引的dml操作期间进行昂贵的索引重组，新删除的单词的信息将单独存储，在执行文本搜索时从搜索结果中筛选出来，并且仅在为innodb表发出optimize table语句时才从主搜索索引中删除。</p></li><li class="listitem"><p>
                    <a class="link" href="information-schema.html#innodb-ft-default-stopword-table" title="24.32.9&nbsp;The INFORMATION_SCHEMA INNODB_FT_DEFAULT_STOPWORD Table"><code class="literal">INNODB_FT_DEFAULT_STOPWORD</code></a>: Holds
                    a list of <a class="link" href="glossary.html#glos_stopword" title="stopword">stopwords</a> that
                    are used by default when creating a
                    <code class="literal">FULLTEXT</code> index on <code class="literal">InnoDB</code>
                    tables.
                </p><p style="color:blue;">innodb_ft_default_stopword：保存在innodb表上创建全文索引时默认使用的stopword列表。</p><p>
                    For information about the
                    <a class="link" href="information-schema.html#innodb-ft-default-stopword-table" title="24.32.9&nbsp;The INFORMATION_SCHEMA INNODB_FT_DEFAULT_STOPWORD Table"><code class="literal">INNODB_FT_DEFAULT_STOPWORD</code></a> table,
                    see <a class="xref" href="functions.html#fulltext-stopwords" title="12.9.4&nbsp;Full-Text Stopwords">Section&nbsp;12.9.4, “Full-Text Stopwords”</a>.
                </p><p style="color:blue;">有关innodb_ft_default_stopword表的信息，请参阅第12.9.4节“全文stopwords”。</p></li><li class="listitem"><p>
                    <a class="link" href="information-schema.html#innodb-ft-index-table-table" title="24.32.12&nbsp;The INFORMATION_SCHEMA INNODB_FT_INDEX_TABLE Table"><code class="literal">INNODB_FT_INDEX_TABLE</code></a>: Provides
                    information about the inverted index used to process text
                    searches against the <code class="literal">FULLTEXT</code> index of an
                    <code class="literal">InnoDB</code> table.
                </p><p style="color:blue;">innodb_ft_index_table：提供有关用于处理针对innodb表全文索引的文本搜索的反向索引的信息。</p></li><li class="listitem"><p>
                    <a class="link" href="information-schema.html#innodb-ft-index-cache-table" title="24.32.11&nbsp;The INFORMATION_SCHEMA INNODB_FT_INDEX_CACHE Table"><code class="literal">INNODB_FT_INDEX_CACHE</code></a>: Provides
                    token information about newly inserted rows in a
                    <code class="literal">FULLTEXT</code> index. To avoid expensive index
                    reorganization during DML operations, the information about
                    newly indexed words is stored separately, and combined with
                    the main search index only when <a class="link" href="sql-syntax.html#optimize-table" title="13.7.2.4&nbsp;OPTIMIZE TABLE Syntax"><code class="literal">OPTIMIZE
                    TABLE</code></a> is run, when the server is shut down, or when
                    the cache size exceeds a limit defined by the
                    <a class="link" href="innodb-storage-engine.html#sysvar_innodb_ft_cache_size"><code class="literal">innodb_ft_cache_size</code></a> or
                    <a class="link" href="innodb-storage-engine.html#sysvar_innodb_ft_total_cache_size"><code class="literal">innodb_ft_total_cache_size</code></a>
                    system variable.
                </p><p style="color:blue;">innodb_ft_index_cache：提供有关全文索引中新插入行的标记信息。为了避免dml操作中代价高昂的索引重组，新索引词的信息单独存储，只有在运行optimize table时，在服务器关闭时，才与主搜索索引结合使用，或者当缓存大小超过innodb-ft-u cache-size或innodb-ft-u total-cache-size系统变量定义的限制时。</p></li></ul>
            </div>
            <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">
                <div class="admon-title">
                    Note
                </div>
                <p>
                    With the exception of the
                    <a class="link" href="information-schema.html#innodb-ft-default-stopword-table" title="24.32.9&nbsp;The INFORMATION_SCHEMA INNODB_FT_DEFAULT_STOPWORD Table"><code class="literal">INNODB_FT_DEFAULT_STOPWORD</code></a> table,
                    these tables are empty initially. Before querying any of them,
                    set the value of the
                    <a class="link" href="innodb-storage-engine.html#sysvar_innodb_ft_aux_table"><code class="literal">innodb_ft_aux_table</code></a> system
                    variable to the name (including the database name) of the table
                    that contains the <code class="literal">FULLTEXT</code> index (for
                    example, <code class="literal">test/articles</code>).
                </p><p style="color:blue;">除了innodb_ft_default_stopword表之外，这些表最初是空的。在查询它们之前，请将innodb_ft_aux_table系统变量的值设置为包含全文索引（例如，test/articles）的表的名称（包括数据库名称）。</p>
            </div>

            <div class="example">
                <a name="innodb-information-schema-fulltext-tables-example"></a><p class="title"><b>Example&nbsp;14.5&nbsp;InnoDB FULLTEXT Index INFORMATION_SCHEMA Tables</b></p><p style="color:blue;">示例14.5 innodb全文索引信息模式表</p>
                <div class="example-contents">
                    <p>
                        This example uses a table with a <code class="literal">FULLTEXT</code>
                        index to demonstrate the data contained in the
                        <code class="literal">FULLTEXT</code> index
                        <code class="literal">INFORMATION_SCHEMA</code> tables.
                    </p><p style="color:blue;">此示例使用带有全文索引的表来演示全文索引信息架构表中包含的数据。</p>
                    <div class="orderedlist">
                        <ol class="orderedlist" type="1"><li class="listitem"><p>
                            Create a table with a <code class="literal">FULLTEXT</code> index and
                            insert some data:
                        </p><p style="color:blue;">创建带有全文索引的表并插入一些数据：</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>CREATE TABLE articles (</code></strong>
         <strong class="userinput"><code>id INT UNSIGNED AUTO_INCREMENT NOT NULL PRIMARY KEY,</code></strong>
         <strong class="userinput"><code>title VARCHAR(200),</code></strong>
         <strong class="userinput"><code>body TEXT,</code></strong>
         <strong class="userinput"><code>FULLTEXT (title,body)</code></strong>
       <strong class="userinput"><code>) ENGINE=InnoDB;</code></strong>

mysql&gt; <strong class="userinput"><code>INSERT INTO articles (title,body) VALUES</code></strong>
       <strong class="userinput"><code>('MySQL Tutorial','DBMS stands for DataBase ...'),</code></strong>
       <strong class="userinput"><code>('How To Use MySQL Well','After you went through a ...'),</code></strong>
       <strong class="userinput"><code>('Optimizing MySQL','In this tutorial we will show ...'),</code></strong>
       <strong class="userinput"><code>('1001 MySQL Tricks','1. Never run mysqld as root. 2. ...'),</code></strong>
       <strong class="userinput"><code>('MySQL vs. YourSQL','In the following database comparison ...'),</code></strong>
       <strong class="userinput"><code>('MySQL Security','When configured properly, MySQL ...');</code></strong>
</pre></li><li class="listitem"><p>
                            Set the <a class="link" href="innodb-storage-engine.html#sysvar_innodb_ft_aux_table"><code class="literal">innodb_ft_aux_table</code></a>
                            variable to the name of the table with the
                            <code class="literal">FULLTEXT</code> index. If this variable is not
                            set, the <code class="literal">InnoDB</code>
                            <code class="literal">FULLTEXT</code>
                            <code class="literal">INFORMATION_SCHEMA</code> tables are empty, with
                            the exception of
                            <a class="link" href="information-schema.html#innodb-ft-default-stopword-table" title="24.32.9&nbsp;The INFORMATION_SCHEMA INNODB_FT_DEFAULT_STOPWORD Table"><code class="literal">INNODB_FT_DEFAULT_STOPWORD</code></a>.
                        </p><p style="color:blue;">将innodb_ft_aux_table变量设置为具有全文索引的表的名称。如果未设置此变量，则innodb fulltext information_schema表为空，innodb_ft_default_stopword除外。</p><pre data-lang="sql" class="programlisting">SET GLOBAL innodb_ft_aux_table = 'test/articles';
</pre></li><li class="listitem"><p>
                            Query the <a class="link" href="information-schema.html#innodb-ft-index-cache-table" title="24.32.11&nbsp;The INFORMATION_SCHEMA INNODB_FT_INDEX_CACHE Table"><code class="literal">INNODB_FT_INDEX_CACHE</code></a>
                            table, which shows information about newly inserted rows in
                            a <code class="literal">FULLTEXT</code> index. To avoid expensive
                            index reorganization during DML operations, data for newly
                            inserted rows remains in the <code class="literal">FULLTEXT</code>
                            index cache until <a class="link" href="sql-syntax.html#optimize-table" title="13.7.2.4&nbsp;OPTIMIZE TABLE Syntax"><code class="literal">OPTIMIZE
                            TABLE</code></a> is run (or until the server is shut down or
                            cache limits are exceeded).
                        </p><p style="color:blue;">查询innodb_ft_index_cache表，该表显示有关全文索引中新插入行的信息。为了避免在DML操作期间进行昂贵的索引重组，新插入行的数据将保留在全文索引缓存中，直到运行优化表（或直到服务器关闭或超过缓存限制）。</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT * FROM INFORMATION_SCHEMA.INNODB_FT_INDEX_CACHE LIMIT 5;</code></strong>
+------------+--------------+-------------+-----------+--------+----------+
| WORD       | FIRST_DOC_ID | LAST_DOC_ID | DOC_COUNT | DOC_ID | POSITION |
+------------+--------------+-------------+-----------+--------+----------+
| 1001       |            5 |           5 |         1 |      5 |        0 |
| after      |            3 |           3 |         1 |      3 |       22 |
| comparison |            6 |           6 |         1 |      6 |       44 |
| configured |            7 |           7 |         1 |      7 |       20 |
| database   |            2 |           6 |         2 |      2 |       31 |
+------------+--------------+-------------+-----------+--------+----------+
</pre></li><li class="listitem"><p>
                            Enable the
                            <a class="link" href="innodb-storage-engine.html#sysvar_innodb_optimize_fulltext_only"><code class="literal">innodb_optimize_fulltext_only</code></a>
                            system variable and run <a class="link" href="sql-syntax.html#optimize-table" title="13.7.2.4&nbsp;OPTIMIZE TABLE Syntax"><code class="literal">OPTIMIZE
                            TABLE</code></a> on the table that contains the
                            <code class="literal">FULLTEXT</code> index. This operation flushes
                            the contents of the <code class="literal">FULLTEXT</code> index cache
                            to the main <code class="literal">FULLTEXT</code> index.
                            <a class="link" href="innodb-storage-engine.html#sysvar_innodb_optimize_fulltext_only"><code class="literal">innodb_optimize_fulltext_only</code></a>
                            changes the way the <a class="link" href="sql-syntax.html#optimize-table" title="13.7.2.4&nbsp;OPTIMIZE TABLE Syntax"><code class="literal">OPTIMIZE
                            TABLE</code></a> statement operates on
                            <code class="literal">InnoDB</code> tables, and is intended to be
                            enabled temporarily, during maintenance operations on
                            <code class="literal">InnoDB</code> tables with
                            <code class="literal">FULLTEXT</code> indexes.
                        </p><p style="color:blue;">启用innodb_optimize_fulltext_only系统变量，并在包含全文索引的表上运行optimize table。此操作将全文索引缓存的内容刷新到主全文索引。innodb_optimize_fulltext_只改变optimize table语句对innodb tables的操作方式，并打算在对innodb tables进行全文索引的维护操作期间临时启用。</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>SET GLOBAL innodb_optimize_fulltext_only=ON;</code></strong>

mysql&gt; <strong class="userinput"><code>OPTIMIZE TABLE articles;</code></strong>
+---------------+----------+----------+----------+
| Table         | Op       | Msg_type | Msg_text |
+---------------+----------+----------+----------+
| test.articles | optimize | status   | OK       |
+---------------+----------+----------+----------+
</pre></li><li class="listitem"><p>
                            Query the <a class="link" href="information-schema.html#innodb-ft-index-table-table" title="24.32.12&nbsp;The INFORMATION_SCHEMA INNODB_FT_INDEX_TABLE Table"><code class="literal">INNODB_FT_INDEX_TABLE</code></a>
                            table to view information about data in the main
                            <code class="literal">FULLTEXT</code> index, including information
                            about the data that was just flushed from the
                            <code class="literal">FULLTEXT</code> index cache.
                        </p><p style="color:blue;">查询innodb_ft_index_表以查看有关主全文索引中数据的信息，包括有关刚从全文索引缓存刷新的数据的信息。</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT * FROM INFORMATION_SCHEMA.INNODB_FT_INDEX_TABLE LIMIT 5;</code></strong>
+------------+--------------+-------------+-----------+--------+----------+
| WORD       | FIRST_DOC_ID | LAST_DOC_ID | DOC_COUNT | DOC_ID | POSITION |
+------------+--------------+-------------+-----------+--------+----------+
| 1001       |            5 |           5 |         1 |      5 |        0 |
| after      |            3 |           3 |         1 |      3 |       22 |
| comparison |            6 |           6 |         1 |      6 |       44 |
| configured |            7 |           7 |         1 |      7 |       20 |
| database   |            2 |           6 |         2 |      2 |       31 |
+------------+--------------+-------------+-----------+--------+----------+
</pre><p>
                            The <a class="link" href="information-schema.html#innodb-ft-index-cache-table" title="24.32.11&nbsp;The INFORMATION_SCHEMA INNODB_FT_INDEX_CACHE Table"><code class="literal">INNODB_FT_INDEX_CACHE</code></a> table
                            is now empty since the <a class="link" href="sql-syntax.html#optimize-table" title="13.7.2.4&nbsp;OPTIMIZE TABLE Syntax"><code class="literal">OPTIMIZE
                            TABLE</code></a> operation flushed the
                            <code class="literal">FULLTEXT</code> index cache.
                        </p><p style="color:blue;">由于优化表操作刷新了全文索引缓存，innodb_ft_index_cache表现在为空。</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT * FROM INFORMATION_SCHEMA.INNODB_FT_INDEX_CACHE LIMIT 5;</code></strong>
Empty set (0.00 sec)
</pre></li><li class="listitem"><p>
                            Delete some records from the
                            <code class="literal">test/articles</code> table.
                        </p><p style="color:blue;">从test/articles表中删除一些记录。</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>DELETE FROM test.articles WHERE id &lt; 4;</code></strong>
</pre></li><li class="listitem"><p>
                            Query the <a class="link" href="information-schema.html#innodb-ft-deleted-table" title="24.32.10&nbsp;The INFORMATION_SCHEMA INNODB_FT_DELETED Table"><code class="literal">INNODB_FT_DELETED</code></a>
                            table. This table records rows that are deleted from the
                            <code class="literal">FULLTEXT</code> index. To avoid expensive index
                            reorganization during DML operations, information about
                            newly deleted records is stored separately, filtered out of
                            search results when you do a text search, and removed from
                            the main search index when you run
                            <a class="link" href="sql-syntax.html#optimize-table" title="13.7.2.4&nbsp;OPTIMIZE TABLE Syntax"><code class="literal">OPTIMIZE TABLE</code></a>.
                        </p><p style="color:blue;">查询innodb_ft_deleted表。此表记录从全文索引中删除的行。为了避免在DML操作期间进行昂贵的索引重组，有关新删除记录的信息将单独存储，在执行文本搜索时从搜索结果中筛选出来，并在运行优化表时从主搜索索引中删除。</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT * FROM INFORMATION_SCHEMA.INNODB_FT_DELETED;</code></strong>
+--------+
| DOC_ID |
+--------+
|      2 |
|      3 |
|      4 |
+--------+
</pre></li><li class="listitem"><p>
                            Run <a class="link" href="sql-syntax.html#optimize-table" title="13.7.2.4&nbsp;OPTIMIZE TABLE Syntax"><code class="literal">OPTIMIZE TABLE</code></a> to remove
                            the deleted records.
                        </p><p style="color:blue;">运行优化表以删除删除的记录。</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>OPTIMIZE TABLE articles;</code></strong>
+---------------+----------+----------+----------+
| Table         | Op       | Msg_type | Msg_text |
+---------------+----------+----------+----------+
| test.articles | optimize | status   | OK       |
+---------------+----------+----------+----------+
</pre><p>
                            The <a class="link" href="information-schema.html#innodb-ft-deleted-table" title="24.32.10&nbsp;The INFORMATION_SCHEMA INNODB_FT_DELETED Table"><code class="literal">INNODB_FT_DELETED</code></a> table
                            should now be empty.
                        </p><p style="color:blue;">innodb_ft_deleted表现在应该是空的。</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT * FROM INFORMATION_SCHEMA.INNODB_FT_DELETED;</code></strong>
Empty set (0.00 sec)
</pre></li><li class="listitem"><p>
                            Query the <a class="link" href="information-schema.html#innodb-ft-config-table" title="24.32.8&nbsp;The INFORMATION_SCHEMA INNODB_FT_CONFIG Table"><code class="literal">INNODB_FT_CONFIG</code></a>
                            table. This table contains metadata about the
                            <code class="literal">FULLTEXT</code> index and related processing:
                        </p><p style="color:blue;">查询innodb_ft_config表。此表包含有关全文索引和相关处理的元数据：</p>
                            <div class="itemizedlist">
                                <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                                    <code class="literal">optimize_checkpoint_limit</code>: The number
                                    of seconds after which an <a class="link" href="sql-syntax.html#optimize-table" title="13.7.2.4&nbsp;OPTIMIZE TABLE Syntax"><code class="literal">OPTIMIZE
                                    TABLE</code></a> run stops.
                                </p><p style="color:blue;">优化检查点限制：优化表运行停止的秒数。</p></li><li class="listitem"><p>
                                    <code class="literal">synced_doc_id</code>: The next
                                    <code class="literal">DOC_ID</code> to be issued.
                                </p><p style="color:blue;">同步的文档ID：下一个要发布的文档ID。</p></li><li class="listitem"><p>
                                    <code class="literal">stopword_table_name</code>: The
                                    <em class="replaceable"><code>database/table</code></em> name for a
                                    user-defined stopword table. The
                                    <code class="literal">VALUE</code> column is empty if there is no
                                    user-defined stopword table.
                                </p><p style="color:blue;">stopword_table_name：用户定义的stopword表的数据库/表名。如果没有用户定义的stopword表，则value列为空。</p></li><li class="listitem"><p>
                                    <code class="literal">use_stopword</code>: Indicates whether a
                                    stopword table is used, which is defined when the
                                    <code class="literal">FULLTEXT</code> index is created.
                                </p><p style="color:blue;">use_stopword：指示是否使用stopword表，该表是在创建全文索引时定义的。</p></li></ul>
                            </div>
                            <pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT * FROM INFORMATION_SCHEMA.INNODB_FT_CONFIG;</code></strong>
+---------------------------+-------+
| KEY                       | VALUE |
+---------------------------+-------+
| optimize_checkpoint_limit | 180   |
| synced_doc_id             | 8     |
| stopword_table_name       |       |
| use_stopword              | 1     |
+---------------------------+-------+
</pre></li><li class="listitem"><p>
                            Disable
                            <a class="link" href="innodb-storage-engine.html#sysvar_innodb_optimize_fulltext_only"><code class="literal">innodb_optimize_fulltext_only</code></a>,
                            since it is intended to be enabled only temporarily:
                        </p><p style="color:blue;">禁用innodb_optimize_fulltext_only，因为它只打算暂时启用：</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>SET GLOBAL innodb_optimize_fulltext_only=OFF;</code></strong>
</pre></li></ol>
                    </div>

                </div>

            </div>
            <br class="example-break">
        </div>
        <div class="section">
            <div class="titlepage">
                <div>
                    <div>
                        <h3 class="title"><a name="innodb-information-schema-buffer-pool-tables"></a>14.15.5&nbsp;InnoDB INFORMATION_SCHEMA Buffer Pool Tables</h3>

                    </div>

                </div>

            </div>
            <p>
                The <code class="literal">InnoDB</code>
                <code class="literal">INFORMATION_SCHEMA</code> buffer pool tables provide
                buffer pool status information and metadata about the pages within
                the <code class="literal">InnoDB</code> buffer pool.
            </p><p style="color:blue;">innodb information_schema buffer pool表提供关于innodb缓冲池中页面的缓冲池状态信息和元数据。</p><p>
            The <code class="literal">InnoDB</code>
            <code class="literal">INFORMATION_SCHEMA</code> buffer pool tables include
            those listed below:
        </p><p style="color:blue;">innodb information_schema buffer pool表包括以下列表：</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>SHOW TABLES FROM INFORMATION_SCHEMA LIKE 'INNODB_BUFFER%';</code></strong>
+-----------------------------------------------+
| Tables_in_INFORMATION_SCHEMA (INNODB_BUFFER%) |
+-----------------------------------------------+
| INNODB_BUFFER_PAGE_LRU                        |
| INNODB_BUFFER_PAGE                            |
| INNODB_BUFFER_POOL_STATS                      |
+-----------------------------------------------+
</pre>
            <h4><a name="idm140286807004752"></a>Table Overview</h4>
            <div class="itemizedlist">
                <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                    <a class="link" href="information-schema.html#innodb-buffer-page-table" title="24.32.1&nbsp;The INFORMATION_SCHEMA INNODB_BUFFER_PAGE Table"><code class="literal">INNODB_BUFFER_PAGE</code></a>: Holds
                    information about each page in the <code class="literal">InnoDB</code>
                    buffer pool.
                </p><p style="color:blue;">innodb_buffer_page：保存关于innodb缓冲池中每个页面的信息。</p></li><li class="listitem"><p>
                    <a class="link" href="information-schema.html#innodb-buffer-page-lru-table" title="24.32.2&nbsp;The INFORMATION_SCHEMA INNODB_BUFFER_PAGE_LRU Table"><code class="literal">INNODB_BUFFER_PAGE_LRU</code></a>: Holds
                    information about the pages in the <code class="literal">InnoDB</code>
                    buffer pool, in particular how they are ordered in the LRU
                    list that determines which pages to evict from the buffer pool
                    when it becomes full. The
                    <a class="link" href="information-schema.html#innodb-buffer-page-lru-table" title="24.32.2&nbsp;The INFORMATION_SCHEMA INNODB_BUFFER_PAGE_LRU Table"><code class="literal">INNODB_BUFFER_PAGE_LRU</code></a> table has
                    the same columns as the
                    <a class="link" href="information-schema.html#innodb-buffer-page-table" title="24.32.1&nbsp;The INFORMATION_SCHEMA INNODB_BUFFER_PAGE Table"><code class="literal">INNODB_BUFFER_PAGE</code></a> table, except
                    that the <a class="link" href="information-schema.html#innodb-buffer-page-lru-table" title="24.32.2&nbsp;The INFORMATION_SCHEMA INNODB_BUFFER_PAGE_LRU Table"><code class="literal">INNODB_BUFFER_PAGE_LRU</code></a>
                    table has an <code class="literal">LRU_POSITION</code> column instead of
                    a <code class="literal">BLOCK_ID</code> column.
                </p><p style="color:blue;">innodb_buffer_page_lru：保存有关innodb缓冲池中的页面的信息，特别是它们在lru列表中的顺序，该列表确定当缓冲池满时要从中退出哪些页面。innodb_buffer_page_lru表的列与innodb_buffer_page表的列相同，只是innodb_buffer_page_lru表有一个lru_position列，而不是block_id列。</p></li><li class="listitem"><p>
                    <a class="link" href="information-schema.html#innodb-buffer-pool-stats-table" title="24.32.3&nbsp;The INFORMATION_SCHEMA INNODB_BUFFER_POOL_STATS Table"><code class="literal">INNODB_BUFFER_POOL_STATS</code></a>:
                    Provides buffer pool status information. Much of the same
                    information is provided by
                    <a class="link" href="sql-syntax.html#show-engine" title="13.7.5.15&nbsp;SHOW ENGINE Syntax"><code class="literal">SHOW ENGINE
                        INNODB STATUS</code></a> output, or may be obtained using
                    <code class="literal">InnoDB</code> buffer pool server status variables.
                </p><p style="color:blue;">innodb_buffer_pool_stats：提供缓冲池状态信息。许多相同的信息由show engine innodb status output提供，或者可以使用innodb缓冲池服务器状态变量获得。</p></li></ul>
            </div>
            <div class="warning" style="margin-left: 0.5in; margin-right: 0.5in;">
                <div class="admon-title">
                    Warning
                </div>
                <p>
                    Querying the <a class="link" href="information-schema.html#innodb-buffer-page-table" title="24.32.1&nbsp;The INFORMATION_SCHEMA INNODB_BUFFER_PAGE Table"><code class="literal">INNODB_BUFFER_PAGE</code></a> or
                    <a class="link" href="information-schema.html#innodb-buffer-page-lru-table" title="24.32.2&nbsp;The INFORMATION_SCHEMA INNODB_BUFFER_PAGE_LRU Table"><code class="literal">INNODB_BUFFER_PAGE_LRU</code></a> table can
                    affect performance. Do not query these tables on a production
                    system unless you are aware of the performance impact and have
                    determined it to be acceptable. To avoid impacting performance
                    on a production system, reproduce the issue you want to
                    investigate and query buffer pool statistics on a test instance.
                </p><p style="color:blue;">查询innodb_buffer_页或innodb_buffer_page_lru表可能会影响性能。不要在生产系统上查询这些表，除非您知道性能影响并确定它是可接受的。为了避免影响生产系统的性能，请重现要调查的问题，并在测试实例上查询缓冲池统计信息。</p>
            </div>

            <div class="example">
                <a name="innodb-information-schema-buffer-pool-system-data-example"></a><p class="title"><b>Example&nbsp;14.6&nbsp;Querying System Data in the INNODB_BUFFER_PAGE Table</b></p><p style="color:blue;">示例14.6查询innodb_buffer_page表中的系统数据</p>
                <div class="example-contents">
                    <p>
                        This query provides an approximate count of pages that contain
                        system data by excluding pages where the
                        <code class="literal">TABLE_NAME</code> value is either
                        <code class="literal">NULL</code> or includes a slash <code class="literal">/</code>
                        or period <code class="literal">.</code> in the table name, which
                        indicates a user-defined table.
                    </p><p style="color:blue;">此查询提供了一个包含系统数据的页面的近似计数，其中排除了Table名称NULL值为空或包含斜杠/或周期的页。在表名中，表示用户定义的表。</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT COUNT(*) FROM INFORMATION_SCHEMA.INNODB_BUFFER_PAGE</code></strong>
       <strong class="userinput"><code>WHERE TABLE_NAME IS NULL OR (INSTR(TABLE_NAME, '/') = 0 AND INSTR(TABLE_NAME, '.') = 0);</code></strong>
+----------+
| COUNT(*) |
+----------+
|     1516 |
+----------+
</pre><p>
                    This query returns the approximate number of pages that contain
                    system data, the total number of buffer pool pages, and an
                    approximate percentage of pages that contain system data.
                </p><p style="color:blue;">此查询返回包含系统数据、缓冲池总页数和包含系统数据的页的近似百分比的页的近似页数。</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT</code></strong>
       <strong class="userinput"><code>(SELECT COUNT(*) FROM INFORMATION_SCHEMA.INNODB_BUFFER_PAGE</code></strong>
       <strong class="userinput"><code>WHERE TABLE_NAME IS NULL OR (INSTR(TABLE_NAME, '/') = 0 AND INSTR(TABLE_NAME, '.') = 0)</code></strong>
       <strong class="userinput"><code>) AS system_pages,</code></strong>
       <strong class="userinput"><code>(</code></strong>
       <strong class="userinput"><code>SELECT COUNT(*)</code></strong>
       <strong class="userinput"><code>FROM INFORMATION_SCHEMA.INNODB_BUFFER_PAGE</code></strong>
       <strong class="userinput"><code>) AS total_pages,</code></strong>
       <strong class="userinput"><code>(</code></strong>
       <strong class="userinput"><code>SELECT ROUND((system_pages/total_pages) * 100)</code></strong>
       <strong class="userinput"><code>) AS system_page_percentage;</code></strong>
+--------------+-------------+------------------------+
| system_pages | total_pages | system_page_percentage |
+--------------+-------------+------------------------+
|          295 |        8192 |                      4 |
+--------------+-------------+------------------------+
</pre><p>
                    The type of system data in the buffer pool can be determined by
                    querying the <code class="literal">PAGE_TYPE</code> value. For example,
                    the following query returns eight distinct
                    <code class="literal">PAGE_TYPE</code> values among the pages that contain
                    system data:
                </p><p style="color:blue;">缓冲池中系统数据的类型可以通过查询页类型值来确定。例如，以下查询在包含系统数据的页中返回八个不同的页类型值：</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT DISTINCT PAGE_TYPE FROM INFORMATION_SCHEMA.INNODB_BUFFER_PAGE</code></strong>
       <strong class="userinput"><code>WHERE TABLE_NAME IS NULL OR (INSTR(TABLE_NAME, '/') = 0 AND INSTR(TABLE_NAME, '.') = 0);</code></strong>
+-------------------+
| PAGE_TYPE         |
+-------------------+
| SYSTEM            |
| IBUF_BITMAP       |
| UNKNOWN           |
| FILE_SPACE_HEADER |
| INODE             |
| UNDO_LOG          |
| ALLOCATED         |
+-------------------+
</pre>
                </div>

            </div>
            <br class="example-break">
            <div class="example">
                <a name="innodb-information-schema-buffer-pool-user-data-example"></a><p class="title"><b>Example&nbsp;14.7&nbsp;Querying User Data in the INNODB_BUFFER_PAGE Table</b></p><p style="color:blue;">示例14.7查询innodb_buffer_page表中的用户数据</p>
                <div class="example-contents">
                    <p>
                        This query provides an approximate count of pages containing
                        user data by counting pages where the
                        <code class="literal">TABLE_NAME</code> value is <code class="literal">NOT
                        NULL</code> and <code class="literal">NOT LIKE
                        '%INNODB_SYS_TABLES%'</code>.
                    </p><p style="color:blue;">该查询通过对Table名称值不为NULL的页进行计数，而不使用“%NoNdBySysStAs%%”的页来提供包含用户数据的近似计数。</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT COUNT(*) FROM INFORMATION_SCHEMA.INNODB_BUFFER_PAGE</code></strong>
       <strong class="userinput"><code>WHERE TABLE_NAME IS NOT NULL AND TABLE_NAME NOT LIKE '%INNODB_SYS_TABLES%';</code></strong>
+----------+
| COUNT(*) |
+----------+
|     7897 |
+----------+
</pre><p>
                    This query returns the approximate number of pages that contain
                    user data, the total number of buffer pool pages, and an
                    approximate percentage of pages that contain user data.
                </p><p style="color:blue;">此查询返回包含用户数据的大致页数、缓冲池页的总数以及包含用户数据的页面的大致百分比。</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT</code></strong>
       <strong class="userinput"><code>(SELECT COUNT(*) FROM INFORMATION_SCHEMA.INNODB_BUFFER_PAGE</code></strong>
       <strong class="userinput"><code>WHERE TABLE_NAME IS NOT NULL AND (INSTR(TABLE_NAME, '/') &gt; 0 OR INSTR(TABLE_NAME, '.') &gt; 0)</code></strong>
       <strong class="userinput"><code>) AS user_pages,</code></strong>
       <strong class="userinput"><code>(</code></strong>
       <strong class="userinput"><code>SELECT COUNT(*)</code></strong>
       <strong class="userinput"><code>FROM INFORMATION_SCHEMA.INNODB_BUFFER_PAGE</code></strong>
       <strong class="userinput"><code>) AS total_pages,</code></strong>
       <strong class="userinput"><code>(</code></strong>
       <strong class="userinput"><code>SELECT ROUND((user_pages/total_pages) * 100)</code></strong>
       <strong class="userinput"><code>) AS user_page_percentage;</code></strong>
+------------+-------------+----------------------+
| user_pages | total_pages | user_page_percentage |
+------------+-------------+----------------------+
|       7897 |        8192 |                   96 |
+------------+-------------+----------------------+
</pre><p>
                    This query identifies user-defined tables with pages in the
                    buffer pool:
                </p><p style="color:blue;">此查询标识缓冲池中包含页的用户定义表：</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT DISTINCT TABLE_NAME FROM INFORMATION_SCHEMA.INNODB_BUFFER_PAGE</code></strong>
       <strong class="userinput"><code>WHERE TABLE_NAME IS NOT NULL AND (INSTR(TABLE_NAME, '/') &gt; 0 OR INSTR(TABLE_NAME, '.') &gt; 0)</code></strong>
       <strong class="userinput"><code>AND TABLE_NAME NOT LIKE '`mysql`.`innodb_%';</code></strong>
+-------------------------+
| TABLE_NAME              |
+-------------------------+
| `employees`.`salaries`  |
| `employees`.`employees` |
+-------------------------+
</pre>
                </div>

            </div>
            <br class="example-break">
            <div class="example">
                <a name="innodb-information-schema-buffer-pool-index-data-example"></a><p class="title"><b>Example&nbsp;14.8&nbsp;Querying Index Data in the INNODB_BUFFER_PAGE Table</b></p><p style="color:blue;">示例14.8查询innodb_buffer_page表中的索引数据</p>
                <div class="example-contents">
                    <p>
                        For information about index pages, query the
                        <code class="literal">INDEX_NAME</code> column using the name of the
                        index. For example, the following query returns the number of
                        pages and total data size of pages for the
                        <code class="literal">emp_no</code> index that is defined on the
                        <code class="literal">employees.salaries</code> table:
                    </p><p style="color:blue;">有关索引页的信息，请使用索引的名称查询“索引名称”列。例如，以下查询返回employees.salaries表中定义的emp_no索引的页数和总数据大小：</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT INDEX_NAME, COUNT(*) AS Pages,</code></strong>
       <strong class="userinput"><code>ROUND(SUM(IF(COMPRESSED_SIZE = 0, @@GLOBAL.innodb_page_size, COMPRESSED_SIZE))/1024/1024)</code></strong>
       <strong class="userinput"><code>AS 'Total Data (MB)'</code></strong>
       <strong class="userinput"><code>FROM INFORMATION_SCHEMA.INNODB_BUFFER_PAGE</code></strong>
       <strong class="userinput"><code>WHERE INDEX_NAME='emp_no' AND TABLE_NAME = '`employees`.`salaries`';</code></strong>
+------------+-------+-----------------+
| INDEX_NAME | Pages | Total Data (MB) |
+------------+-------+-----------------+
| emp_no     |  1609 |              25 |
+------------+-------+-----------------+
</pre><p>
                    This query returns the number of pages and total data size of
                    pages for all indexes defined on the
                    <code class="literal">employees.salaries</code> table:
                </p><p style="color:blue;">此查询返回employees.salaries表中定义的所有索引的页数和总数据大小：</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT INDEX_NAME, COUNT(*) AS Pages,</code></strong>
       <strong class="userinput"><code>ROUND(SUM(IF(COMPRESSED_SIZE = 0, @@GLOBAL.innodb_page_size, COMPRESSED_SIZE))/1024/1024)</code></strong>
       <strong class="userinput"><code>AS 'Total Data (MB)'</code></strong>
       <strong class="userinput"><code>FROM INFORMATION_SCHEMA.INNODB_BUFFER_PAGE</code></strong>
       <strong class="userinput"><code>WHERE TABLE_NAME = '`employees`.`salaries`'</code></strong>
       <strong class="userinput"><code>GROUP BY INDEX_NAME;</code></strong>
+------------+-------+-----------------+
| INDEX_NAME | Pages | Total Data (MB) |
+------------+-------+-----------------+
| emp_no     |  1608 |              25 |
| PRIMARY    |  6086 |              95 |
+------------+-------+-----------------+
</pre>
                </div>

            </div>
            <br class="example-break">
            <div class="example">
                <a name="innodb-information-schema-buffer-pool-lru-position-example"></a><p class="title"><b>Example&nbsp;14.9&nbsp;Querying LRU_POSITION Data in the INNODB_BUFFER_PAGE_LRU Table</b></p><p style="color:blue;">示例14.9查询innodb_buffer_page_lru表中的lru位置数据</p>
                <div class="example-contents">
                    <p>
                        The <a class="link" href="information-schema.html#innodb-buffer-page-lru-table" title="24.32.2&nbsp;The INFORMATION_SCHEMA INNODB_BUFFER_PAGE_LRU Table"><code class="literal">INNODB_BUFFER_PAGE_LRU</code></a> table
                        holds information about the pages in the
                        <code class="literal">InnoDB</code> buffer pool, in particular how they
                        are ordered that determines which pages to evict from the buffer
                        pool when it becomes full. The definition for this page is the
                        same as for <a class="link" href="information-schema.html#innodb-buffer-page-table" title="24.32.1&nbsp;The INFORMATION_SCHEMA INNODB_BUFFER_PAGE Table"><code class="literal">INNODB_BUFFER_PAGE</code></a>,
                        except this table has an <code class="literal">LRU_POSITION</code> column
                        instead of a <code class="literal">BLOCK_ID</code> column.
                    </p><p style="color:blue;">innodb_buffer_page_lru表保存有关innodb缓冲池中的页的信息，特别是它们的排序方式，该排序方式决定了当缓冲池满时要从中退出哪些页。此页的定义与innodb_buffer_页相同，只是此表有一个lru_position列而不是block_id列。</p><p>
                    This query counts the number of positions at a specific location
                    in the LRU list occupied by pages of the
                    <code class="literal">employees.employees</code> table.
                </p><p style="color:blue;">此查询统计employees.employees表的页面占用的lru列表中特定位置的职位数。</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT COUNT(LRU_POSITION) FROM INFORMATION_SCHEMA.INNODB_BUFFER_PAGE_LRU</code></strong>
       <strong class="userinput"><code>WHERE TABLE_NAME='`employees`.`employees`' AND LRU_POSITION &lt; 3072;</code></strong>
+---------------------+
| COUNT(LRU_POSITION) |
+---------------------+
|                 548 |
+---------------------+
</pre>
                </div>

            </div>
            <br class="example-break">
            <div class="example">
                <a name="innodb-information-schema-buffer-pool-stats-example"></a><p class="title"><b>Example&nbsp;14.10&nbsp;Querying the INNODB_BUFFER_POOL_STATS Table</b></p><p style="color:blue;">示例14.10查询innodb_buffer_pool_stats表</p>
                <div class="example-contents">
                    <p>
                        The <a class="link" href="information-schema.html#innodb-buffer-pool-stats-table" title="24.32.3&nbsp;The INFORMATION_SCHEMA INNODB_BUFFER_POOL_STATS Table"><code class="literal">INNODB_BUFFER_POOL_STATS</code></a> table
                        provides information similar to
                        <a class="link" href="sql-syntax.html#show-engine" title="13.7.5.15&nbsp;SHOW ENGINE Syntax"><code class="literal">SHOW ENGINE INNODB
                            STATUS</code></a> and <code class="literal">InnoDB</code> buffer pool
                        status variables.
                    </p><p style="color:blue;">innodb_buffer_pool_stats表提供的信息类似于显示引擎innodb status和innodb buffer pool status变量。</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT * FROM information_schema.INNODB_BUFFER_POOL_STATS \G</code></strong>
*************************** 1. row ***************************
                         POOL_ID: 0
                       POOL_SIZE: 8192
                    FREE_BUFFERS: 1
                  DATABASE_PAGES: 8173
              OLD_DATABASE_PAGES: 3014
         MODIFIED_DATABASE_PAGES: 0
              PENDING_DECOMPRESS: 0
                   PENDING_READS: 0
               PENDING_FLUSH_LRU: 0
              PENDING_FLUSH_LIST: 0
                PAGES_MADE_YOUNG: 15907
            PAGES_NOT_MADE_YOUNG: 3803101
           PAGES_MADE_YOUNG_RATE: 0
       PAGES_MADE_NOT_YOUNG_RATE: 0
               NUMBER_PAGES_READ: 3270
            NUMBER_PAGES_CREATED: 13176
            NUMBER_PAGES_WRITTEN: 15109
                 PAGES_READ_RATE: 0
               PAGES_CREATE_RATE: 0
              PAGES_WRITTEN_RATE: 0
                NUMBER_PAGES_GET: 33069332
                        HIT_RATE: 0
    YOUNG_MAKE_PER_THOUSAND_GETS: 0
NOT_YOUNG_MAKE_PER_THOUSAND_GETS: 0
         NUMBER_PAGES_READ_AHEAD: 2713
       NUMBER_READ_AHEAD_EVICTED: 0
                 READ_AHEAD_RATE: 0
         READ_AHEAD_EVICTED_RATE: 0
                    LRU_IO_TOTAL: 0
                  LRU_IO_CURRENT: 0
                UNCOMPRESS_TOTAL: 0
              UNCOMPRESS_CURRENT: 0
</pre><p>
                    For comparison,
                    <a class="link" href="sql-syntax.html#show-engine" title="13.7.5.15&nbsp;SHOW ENGINE Syntax"><code class="literal">SHOW ENGINE INNODB
                        STATUS</code></a> output and <code class="literal">InnoDB</code> buffer
                    pool status variable output is shown below, based on the same
                    data set.
                </p><p style="color:blue;">为了进行比较，显示引擎innodb状态输出和innodb缓冲池状态变量输出如下所示，基于相同的数据集。</p><p>
                    For more information about
                    <a class="link" href="sql-syntax.html#show-engine" title="13.7.5.15&nbsp;SHOW ENGINE Syntax"><code class="literal">SHOW ENGINE INNODB
                        STATUS</code></a> output, see
                    <a class="xref" href="innodb-storage-engine.html#innodb-standard-monitor" title="14.17.3&nbsp;InnoDB Standard Monitor and Lock Monitor Output">Section&nbsp;14.17.3, “InnoDB Standard Monitor and Lock Monitor Output”</a>.
                </p><p style="color:blue;">有关显示引擎InnoDB状态输出的更多信息，请参阅14.17.3节，“InnoDB标准监视器和锁定监视器输出”。</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>SHOW ENGINE INNODB STATUS \G</code></strong>
...
----------------------
BUFFER POOL AND MEMORY
----------------------
Total large memory allocated 137428992
Dictionary memory allocated 579084
Buffer pool size   8192
Free buffers       1
Database pages     8173
Old database pages 3014
Modified db pages  0
Pending reads 0
Pending writes: LRU 0, flush list 0, single page 0
Pages made young 15907, not young 3803101
0.00 youngs/s, 0.00 non-youngs/s
Pages read 3270, created 13176, written 15109
0.00 reads/s, 0.00 creates/s, 0.00 writes/s
No buffer pool page gets since the last printout
Pages read ahead 0.00/s, evicted without access 0.00/s, Random read ahead 0.00/s
LRU len: 8173, unzip_LRU len: 0
I/O sum[0]:cur[0], unzip sum[0]:cur[0]
...
</pre><p>
                    For status variable descriptions, see
                    <a class="xref" href="server-administration.html#server-status-variables" title="5.1.9&nbsp;Server Status Variables">Section&nbsp;5.1.9, “Server Status Variables”</a>.
                </p><p style="color:blue;">有关状态变量的说明，请参阅第5.1.9节“服务器状态变量”。</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>SHOW STATUS LIKE 'Innodb_buffer%';</code></strong>
+---------------------------------------+-------------+
| Variable_name                         | Value       |
+---------------------------------------+-------------+
| Innodb_buffer_pool_dump_status        | not started |
| Innodb_buffer_pool_load_status        | not started |
| Innodb_buffer_pool_resize_status      | not started |
| Innodb_buffer_pool_pages_data         | 8173        |
| Innodb_buffer_pool_bytes_data         | 133906432   |
| Innodb_buffer_pool_pages_dirty        | 0           |
| Innodb_buffer_pool_bytes_dirty        | 0           |
| Innodb_buffer_pool_pages_flushed      | 15109       |
| Innodb_buffer_pool_pages_free         | 1           |
| Innodb_buffer_pool_pages_misc         | 18          |
| Innodb_buffer_pool_pages_total        | 8192        |
| Innodb_buffer_pool_read_ahead_rnd     | 0           |
| Innodb_buffer_pool_read_ahead         | 2713        |
| Innodb_buffer_pool_read_ahead_evicted | 0           |
| Innodb_buffer_pool_read_requests      | 33069332    |
| Innodb_buffer_pool_reads              | 558         |
| Innodb_buffer_pool_wait_free          | 0           |
| Innodb_buffer_pool_write_requests     | 11985961    |
+---------------------------------------+-------------+
</pre>
                </div>

            </div>
            <br class="example-break">
        </div>
        <div class="section">
            <div class="titlepage">
                <div>
                    <div>
                        <h3 class="title"><a name="innodb-information-schema-metrics-table"></a>14.15.6&nbsp;InnoDB INFORMATION_SCHEMA Metrics Table</h3>

                    </div>

                </div>

            </div>
            <p>
                The <a class="link" href="information-schema.html#innodb-metrics-table" title="24.32.15&nbsp;The INFORMATION_SCHEMA INNODB_METRICS Table"><code class="literal">INNODB_METRICS</code></a> table provides
                information about <code class="literal">InnoDB</code> performance and
                resource-related counters.
            </p><p style="color:blue;">innodb_metrics表提供有关innodb性能和资源相关计数器的信息。</p><p>
            <a class="link" href="information-schema.html#innodb-metrics-table" title="24.32.15&nbsp;The INFORMATION_SCHEMA INNODB_METRICS Table"><code class="literal">INNODB_METRICS</code></a> table columns are
            shown below. For column descriptions, see
            <a class="xref" href="information-schema.html#innodb-metrics-table" title="24.32.15&nbsp;The INFORMATION_SCHEMA INNODB_METRICS Table">Section&nbsp;24.32.15, “The INFORMATION_SCHEMA INNODB_METRICS Table”</a>.
        </p><p style="color:blue;">innodb_metrics表列如下所示。有关列描述，请参见第24.32.15节“information_schema innodb_metrics table”。</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT * FROM INFORMATION_SCHEMA.INNODB_METRICS WHERE NAME="dml_inserts" \G</code></strong>
*************************** 1. row ***************************
           NAME: dml_inserts
      SUBSYSTEM: dml
          COUNT: 46273
      MAX_COUNT: 46273
      MIN_COUNT: NULL
      AVG_COUNT: 492.2659574468085
    COUNT_RESET: 46273
MAX_COUNT_RESET: 46273
MIN_COUNT_RESET: NULL
AVG_COUNT_RESET: NULL
   TIME_ENABLED: 2014-11-28 16:07:53
  TIME_DISABLED: NULL
   TIME_ELAPSED: 94
     TIME_RESET: NULL
         STATUS: enabled
           TYPE: status_counter
        COMMENT: Number of rows inserted
</pre>
            <h4><a name="idm140286806888208"></a>Enabling, Disabling, and Resetting Counters</h4>
            <p>
                You can enable, disable, and reset counters using the following
                variables:
            </p><p style="color:blue;">您可以使用以下变量启用、禁用和重置计数器：</p>
            <div class="itemizedlist">
                <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                    <a class="link" href="innodb-storage-engine.html#sysvar_innodb_monitor_enable"><code class="literal">innodb_monitor_enable</code></a>:
                    Enables counters.
                </p><p style="color:blue;">innodb_monitor_enable：启用计数器。</p><pre data-lang="sql" class="programlisting">SET GLOBAL innodb_monitor_enable = [counter-name|module_name|pattern|all];
</pre></li><li class="listitem"><p>
                    <a class="link" href="innodb-storage-engine.html#sysvar_innodb_monitor_disable"><code class="literal">innodb_monitor_disable</code></a>:
                    Disables counters.
                </p><p style="color:blue;">innodb_monitor_disable：禁用计数器。</p><pre data-lang="sql" class="programlisting">SET GLOBAL innodb_monitor_disable = [counter-name|module_name|pattern|all];
</pre></li><li class="listitem"><p>
                    <a class="link" href="innodb-storage-engine.html#sysvar_innodb_monitor_reset"><code class="literal">innodb_monitor_reset</code></a>: Resets
                    counter values to zero.
                </p><p style="color:blue;">innodb_monitor_reset：将计数器值重置为零。</p><pre data-lang="sql" class="programlisting">SET GLOBAL innodb_monitor_reset = [counter-name|module_name|pattern|all];
</pre></li><li class="listitem"><p>
                    <a class="link" href="innodb-storage-engine.html#sysvar_innodb_monitor_reset_all"><code class="literal">innodb_monitor_reset_all</code></a>:
                    Resets all counter values. A counter must be disabled before
                    using
                    <a class="link" href="innodb-storage-engine.html#sysvar_innodb_monitor_reset_all"><code class="literal">innodb_monitor_reset_all</code></a>.
                </p><p style="color:blue;">innodb_monitor_reset_all：重置所有计数器值。在使用innodb_monitor_reset_all之前，必须禁用计数器。</p><pre data-lang="sql" class="programlisting">SET GLOBAL innodb_monitor_reset_all = [counter-name|module_name|pattern|all];
</pre></li></ul>
            </div>
            <p>
                Counters and counter modules can also be enabled at startup using
                the MySQL server configuration file. For example, to enable the
                <code class="literal">log</code> module,
                <code class="literal">metadata_table_handles_opened</code> and
                <code class="literal">metadata_table_handles_closed</code> counters, enter
                the following line in the <code class="literal">[mysqld]</code> section of
                the MySQL server configuration file..
            </p><p style="color:blue;">计数器和计数器模块也可以在启动时使用mysql服务器配置文件启用。例如，要启用日志模块、metadata_table_handles_opened和metadata_table_handles_closed计数器，请在mysql服务器配置文件的[mysqld]部分中输入以下行。</p><pre data-lang="ini" class="programlisting">[mysqld]
innodb_monitor_enable = module_recovery,metadata_table_handles_opened,metadata_table_handles_closed
</pre><p>
            When enabling multiple counters or modules in a configuration
            file, specify the
            <a class="link" href="innodb-storage-engine.html#sysvar_innodb_monitor_enable"><code class="literal">innodb_monitor_enable</code></a> variable
            followed by counter and module names separated by a comma, as
            shown above. Only the
            <a class="link" href="innodb-storage-engine.html#sysvar_innodb_monitor_enable"><code class="literal">innodb_monitor_enable</code></a> variable
            can be used in a configuration file. The
            <a class="link" href="innodb-storage-engine.html#sysvar_innodb_monitor_disable"><code class="literal">innodb_monitor_disable</code></a> and
            <a class="link" href="innodb-storage-engine.html#sysvar_innodb_monitor_reset"><code class="literal">innodb_monitor_reset</code></a> variables
            are supported on the command line only.
        </p><p style="color:blue;">在一个配置文件中启用多个计数器或模块时，指定innodb_monitor_enable变量，后跟以逗号分隔的计数器和模块名称，如上图所示。配置文件中只能使用innodb_monitor_enable变量。innodb_monitor_disable和innodb_monitor_reset变量仅在命令行上受支持。</p>
            <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">

                <div class="admon-title">
                    Note
                </div>
                <p>
                    Because each counter adds a degree of runtime overhead, use
                    counters conservatively on production servers to diagnose
                    specific issues or monitor specific functionality. A test or
                    development server is recommended for more extensive use of
                    counters.
                </p><p style="color:blue;">因为每个计数器都会增加一定程度的运行时开销，所以在生产服务器上保守地使用计数器来诊断特定问题或监视特定功能。建议使用测试或开发服务器以更广泛地使用计数器。</p>
            </div>
            <h4><a name="idm140286806861632"></a>Counters</h4>
            <p>
                The list of available counters is subject to change. Query the
                <a class="link" href="information-schema.html#innodb-metrics-table" title="24.32.15&nbsp;The INFORMATION_SCHEMA INNODB_METRICS Table"><code class="literal">INFORMATION_SCHEMA.INNODB_METRICS</code></a>
                table for counters available in your MySQL server version.
            </p><p style="color:blue;">可用计数器的列表可能会更改。在information_schema.innodb_metrics表中查询mysql服务器版本中可用的计数器。</p><p>
            The counters enabled by default correspond to those shown in
            <a class="link" href="sql-syntax.html#show-engine" title="13.7.5.15&nbsp;SHOW ENGINE Syntax"><code class="literal">SHOW ENGINE INNODB
                STATUS</code></a> output. Counters shown in
            <a class="link" href="sql-syntax.html#show-engine" title="13.7.5.15&nbsp;SHOW ENGINE Syntax"><code class="literal">SHOW ENGINE INNODB
                STATUS</code></a> output are always enabled at a system level but
            can be disable for the <a class="link" href="information-schema.html#innodb-metrics-table" title="24.32.15&nbsp;The INFORMATION_SCHEMA INNODB_METRICS Table"><code class="literal">INNODB_METRICS</code></a>
            table. Counter status is not persistent. Unless configured
            otherwise, counters revert to their default enabled or disabled
            status when the server is restarted.
        </p><p style="color:blue;">默认启用的计数器与show engine innodb status output中显示的计数器相对应。在show engine innodb status output中显示的计数器始终在系统级别启用，但可以对innodb_metrics表禁用。计数器状态不是持久的。除非另有配置，否则当服务器重新启动时，计数器将还原为其默认的启用或禁用状态。</p><p>
            If you run programs that would be affected by the addition or
            removal of counters, it is recommended that you review the
            releases notes and query the
            <a class="link" href="information-schema.html#innodb-metrics-table" title="24.32.15&nbsp;The INFORMATION_SCHEMA INNODB_METRICS Table"><code class="literal">INNODB_METRICS</code></a> table to identify
            those changes as part of your upgrade process.
        </p><p style="color:blue;">如果您运行的程序可能会受到计数器添加或删除的影响，建议您查看发行说明并查询innodb_metrics表，以便在升级过程中识别这些更改。</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT name, subsystem, status FROM INFORMATION_SCHEMA.INNODB_METRICS ORDER BY NAME;</code></strong>
+------------------------------------------+---------------------+----------+
| name                                     | subsystem           | status   |
+------------------------------------------+---------------------+----------+
| adaptive_hash_pages_added                | adaptive_hash_index | disabled |
| adaptive_hash_pages_removed              | adaptive_hash_index | disabled |
| adaptive_hash_rows_added                 | adaptive_hash_index | disabled |
| adaptive_hash_rows_deleted_no_hash_entry | adaptive_hash_index | disabled |
| adaptive_hash_rows_removed               | adaptive_hash_index | disabled |
| adaptive_hash_rows_updated               | adaptive_hash_index | disabled |
| adaptive_hash_searches                   | adaptive_hash_index | enabled  |
| adaptive_hash_searches_btree             | adaptive_hash_index | enabled  |
| buffer_data_reads                        | buffer              | enabled  |
| buffer_data_written                      | buffer              | enabled  |
| buffer_flush_adaptive                    | buffer              | disabled |
| buffer_flush_adaptive_avg_pass           | buffer              | disabled |
| buffer_flush_adaptive_avg_time_est       | buffer              | disabled |
| buffer_flush_adaptive_avg_time_slot      | buffer              | disabled |
| buffer_flush_adaptive_avg_time_thread    | buffer              | disabled |
| buffer_flush_adaptive_pages              | buffer              | disabled |
| buffer_flush_adaptive_total_pages        | buffer              | disabled |
| buffer_flush_avg_page_rate               | buffer              | disabled |
| buffer_flush_avg_pass                    | buffer              | disabled |
| buffer_flush_avg_time                    | buffer              | disabled |
| buffer_flush_background                  | buffer              | disabled |
| buffer_flush_background_pages            | buffer              | disabled |
| buffer_flush_background_total_pages      | buffer              | disabled |
| buffer_flush_batches                     | buffer              | disabled |
| buffer_flush_batch_num_scan              | buffer              | disabled |
| buffer_flush_batch_pages                 | buffer              | disabled |
| buffer_flush_batch_scanned               | buffer              | disabled |
| buffer_flush_batch_scanned_per_call      | buffer              | disabled |
| buffer_flush_batch_total_pages           | buffer              | disabled |
| buffer_flush_lsn_avg_rate                | buffer              | disabled |
| buffer_flush_neighbor                    | buffer              | disabled |
| buffer_flush_neighbor_pages              | buffer              | disabled |
| buffer_flush_neighbor_total_pages        | buffer              | disabled |
| buffer_flush_n_to_flush_by_age           | buffer              | disabled |
| buffer_flush_n_to_flush_requested        | buffer              | disabled |
| buffer_flush_pct_for_dirty               | buffer              | disabled |
| buffer_flush_pct_for_lsn                 | buffer              | disabled |
| buffer_flush_sync                        | buffer              | disabled |
| buffer_flush_sync_pages                  | buffer              | disabled |
| buffer_flush_sync_total_pages            | buffer              | disabled |
| buffer_flush_sync_waits                  | buffer              | disabled |
| buffer_LRU_batches_evict                 | buffer              | disabled |
| buffer_LRU_batches_flush                 | buffer              | disabled |
| buffer_LRU_batch_evict_pages             | buffer              | disabled |
| buffer_LRU_batch_evict_total_pages       | buffer              | disabled |
| buffer_LRU_batch_flush_avg_pass          | buffer              | disabled |
| buffer_LRU_batch_flush_avg_time_est      | buffer              | disabled |
| buffer_LRU_batch_flush_avg_time_slot     | buffer              | disabled |
| buffer_LRU_batch_flush_avg_time_thread   | buffer              | disabled |
| buffer_LRU_batch_flush_pages             | buffer              | disabled |
| buffer_LRU_batch_flush_total_pages       | buffer              | disabled |
| buffer_LRU_batch_num_scan                | buffer              | disabled |
| buffer_LRU_batch_scanned                 | buffer              | disabled |
| buffer_LRU_batch_scanned_per_call        | buffer              | disabled |
| buffer_LRU_get_free_loops                | buffer              | disabled |
| buffer_LRU_get_free_search               | Buffer              | disabled |
| buffer_LRU_get_free_waits                | buffer              | disabled |
| buffer_LRU_search_num_scan               | buffer              | disabled |
| buffer_LRU_search_scanned                | buffer              | disabled |
| buffer_LRU_search_scanned_per_call       | buffer              | disabled |
| buffer_LRU_single_flush_failure_count    | Buffer              | disabled |
| buffer_LRU_single_flush_num_scan         | buffer              | disabled |
| buffer_LRU_single_flush_scanned          | buffer              | disabled |
| buffer_LRU_single_flush_scanned_per_call | buffer              | disabled |
| buffer_LRU_unzip_search_num_scan         | buffer              | disabled |
| buffer_LRU_unzip_search_scanned          | buffer              | disabled |
| buffer_LRU_unzip_search_scanned_per_call | buffer              | disabled |
| buffer_pages_created                     | buffer              | enabled  |
| buffer_pages_read                        | buffer              | enabled  |
| buffer_pages_written                     | buffer              | enabled  |
| buffer_page_read_blob                    | buffer_page_io      | disabled |
| buffer_page_read_fsp_hdr                 | buffer_page_io      | disabled |
| buffer_page_read_ibuf_bitmap             | buffer_page_io      | disabled |
| buffer_page_read_ibuf_free_list          | buffer_page_io      | disabled |
| buffer_page_read_index_ibuf_leaf         | buffer_page_io      | disabled |
| buffer_page_read_index_ibuf_non_leaf     | buffer_page_io      | disabled |
| buffer_page_read_index_inode             | buffer_page_io      | disabled |
| buffer_page_read_index_leaf              | buffer_page_io      | disabled |
| buffer_page_read_index_non_leaf          | buffer_page_io      | disabled |
| buffer_page_read_other                   | buffer_page_io      | disabled |
| buffer_page_read_system_page             | buffer_page_io      | disabled |
| buffer_page_read_trx_system              | buffer_page_io      | disabled |
| buffer_page_read_undo_log                | buffer_page_io      | disabled |
| buffer_page_read_xdes                    | buffer_page_io      | disabled |
| buffer_page_read_zblob                   | buffer_page_io      | disabled |
| buffer_page_read_zblob2                  | buffer_page_io      | disabled |
| buffer_page_written_blob                 | buffer_page_io      | disabled |
| buffer_page_written_fsp_hdr              | buffer_page_io      | disabled |
| buffer_page_written_ibuf_bitmap          | buffer_page_io      | disabled |
| buffer_page_written_ibuf_free_list       | buffer_page_io      | disabled |
| buffer_page_written_index_ibuf_leaf      | buffer_page_io      | disabled |
| buffer_page_written_index_ibuf_non_leaf  | buffer_page_io      | disabled |
| buffer_page_written_index_inode          | buffer_page_io      | disabled |
| buffer_page_written_index_leaf           | buffer_page_io      | disabled |
| buffer_page_written_index_non_leaf       | buffer_page_io      | disabled |
| buffer_page_written_other                | buffer_page_io      | disabled |
| buffer_page_written_system_page          | buffer_page_io      | disabled |
| buffer_page_written_trx_system           | buffer_page_io      | disabled |
| buffer_page_written_undo_log             | buffer_page_io      | disabled |
| buffer_page_written_xdes                 | buffer_page_io      | disabled |
| buffer_page_written_zblob                | buffer_page_io      | disabled |
| buffer_page_written_zblob2               | buffer_page_io      | disabled |
| buffer_pool_bytes_data                   | buffer              | enabled  |
| buffer_pool_bytes_dirty                  | buffer              | enabled  |
| buffer_pool_pages_data                   | buffer              | enabled  |
| buffer_pool_pages_dirty                  | buffer              | enabled  |
| buffer_pool_pages_free                   | buffer              | enabled  |
| buffer_pool_pages_misc                   | buffer              | enabled  |
| buffer_pool_pages_total                  | buffer              | enabled  |
| buffer_pool_reads                        | buffer              | enabled  |
| buffer_pool_read_ahead                   | buffer              | enabled  |
| buffer_pool_read_ahead_evicted           | buffer              | enabled  |
| buffer_pool_read_requests                | buffer              | enabled  |
| buffer_pool_size                         | server              | enabled  |
| buffer_pool_wait_free                    | buffer              | enabled  |
| buffer_pool_write_requests               | buffer              | enabled  |
| compression_pad_decrements               | compression         | disabled |
| compression_pad_increments               | compression         | disabled |
| compress_pages_compressed                | compression         | disabled |
| compress_pages_decompressed              | compression         | disabled |
| ddl_background_drop_indexes              | ddl                 | disabled |
| ddl_background_drop_tables               | ddl                 | disabled |
| ddl_log_file_alter_table                 | ddl                 | disabled |
| ddl_online_create_index                  | ddl                 | disabled |
| ddl_pending_alter_table                  | ddl                 | disabled |
| ddl_sort_file_alter_table                | ddl                 | disabled |
| dml_deletes                              | dml                 | enabled  |
| dml_inserts                              | dml                 | enabled  |
| dml_reads                                | dml                 | disabled |
| dml_updates                              | dml                 | enabled  |
| file_num_open_files                      | file_system         | enabled  |
| ibuf_merges                              | change_buffer       | enabled  |
| ibuf_merges_delete                       | change_buffer       | enabled  |
| ibuf_merges_delete_mark                  | change_buffer       | enabled  |
| ibuf_merges_discard_delete               | change_buffer       | enabled  |
| ibuf_merges_discard_delete_mark          | change_buffer       | enabled  |
| ibuf_merges_discard_insert               | change_buffer       | enabled  |
| ibuf_merges_insert                       | change_buffer       | enabled  |
| ibuf_size                                | change_buffer       | enabled  |
| icp_attempts                             | icp                 | disabled |
| icp_match                                | icp                 | disabled |
| icp_no_match                             | icp                 | disabled |
| icp_out_of_range                         | icp                 | disabled |
| index_page_discards                      | index               | disabled |
| index_page_merge_attempts                | index               | disabled |
| index_page_merge_successful              | index               | disabled |
| index_page_reorg_attempts                | index               | disabled |
| index_page_reorg_successful              | index               | disabled |
| index_page_splits                        | index               | disabled |
| innodb_activity_count                    | server              | enabled  |
| innodb_background_drop_table_usec        | server              | disabled |
| innodb_checkpoint_usec                   | server              | disabled |
| innodb_dblwr_pages_written               | server              | enabled  |
| innodb_dblwr_writes                      | server              | enabled  |
| innodb_dict_lru_count                    | server              | disabled |
| innodb_dict_lru_usec                     | server              | disabled |
| innodb_ibuf_merge_usec                   | server              | disabled |
| innodb_log_flush_usec                    | server              | disabled |
| innodb_master_active_loops               | server              | disabled |
| innodb_master_idle_loops                 | server              | disabled |
| innodb_master_purge_usec                 | server              | disabled |
| innodb_master_thread_sleeps              | server              | disabled |
| innodb_mem_validate_usec                 | server              | disabled |
| innodb_page_size                         | server              | enabled  |
| innodb_rwlock_sx_os_waits                | server              | enabled  |
| innodb_rwlock_sx_spin_rounds             | server              | enabled  |
| innodb_rwlock_sx_spin_waits              | server              | enabled  |
| innodb_rwlock_s_os_waits                 | server              | enabled  |
| innodb_rwlock_s_spin_rounds              | server              | enabled  |
| innodb_rwlock_s_spin_waits               | server              | enabled  |
| innodb_rwlock_x_os_waits                 | server              | enabled  |
| innodb_rwlock_x_spin_rounds              | server              | enabled  |
| innodb_rwlock_x_spin_waits               | server              | enabled  |
| lock_deadlocks                           | lock                | enabled  |
| lock_rec_locks                           | lock                | disabled |
| lock_rec_lock_created                    | lock                | disabled |
| lock_rec_lock_removed                    | lock                | disabled |
| lock_rec_lock_requests                   | lock                | disabled |
| lock_rec_lock_waits                      | lock                | disabled |
| lock_row_lock_current_waits              | lock                | enabled  |
| lock_row_lock_time                       | lock                | enabled  |
| lock_row_lock_time_avg                   | lock                | enabled  |
| lock_row_lock_time_max                   | lock                | enabled  |
| lock_row_lock_waits                      | lock                | enabled  |
| lock_table_locks                         | lock                | disabled |
| lock_table_lock_created                  | lock                | disabled |
| lock_table_lock_removed                  | lock                | disabled |
| lock_table_lock_waits                    | lock                | disabled |
| lock_timeouts                            | lock                | enabled  |
| log_checkpoints                          | recovery            | disabled |
| log_lsn_buf_pool_oldest                  | recovery            | disabled |
| log_lsn_checkpoint_age                   | recovery            | disabled |
| log_lsn_current                          | recovery            | disabled |
| log_lsn_last_checkpoint                  | recovery            | disabled |
| log_lsn_last_flush                       | recovery            | disabled |
| log_max_modified_age_async               | recovery            | disabled |
| log_max_modified_age_sync                | recovery            | disabled |
| log_num_log_io                           | recovery            | disabled |
| log_padded                               | recovery            | enabled  |
| log_pending_checkpoint_writes            | recovery            | disabled |
| log_pending_log_flushes                  | recovery            | disabled |
| log_waits                                | recovery            | enabled  |
| log_writes                               | recovery            | enabled  |
| log_write_requests                       | recovery            | enabled  |
| metadata_table_handles_closed            | metadata            | disabled |
| metadata_table_handles_opened            | metadata            | disabled |
| metadata_table_reference_count           | metadata            | disabled |
| os_data_fsyncs                           | os                  | enabled  |
| os_data_reads                            | os                  | enabled  |
| os_data_writes                           | os                  | enabled  |
| os_log_bytes_written                     | os                  | enabled  |
| os_log_fsyncs                            | os                  | enabled  |
| os_log_pending_fsyncs                    | os                  | enabled  |
| os_log_pending_writes                    | os                  | enabled  |
| os_pending_reads                         | os                  | disabled |
| os_pending_writes                        | os                  | disabled |
| purge_del_mark_records                   | purge               | disabled |
| purge_dml_delay_usec                     | purge               | disabled |
| purge_invoked                            | purge               | disabled |
| purge_resume_count                       | purge               | disabled |
| purge_stop_count                         | purge               | disabled |
| purge_undo_log_pages                     | purge               | disabled |
| purge_upd_exist_or_extern_records        | purge               | disabled |
| trx_active_transactions                  | transaction         | disabled |
| trx_commits_insert_update                | transaction         | disabled |
| trx_nl_ro_commits                        | transaction         | disabled |
| trx_rollbacks                            | transaction         | disabled |
| trx_rollbacks_savepoint                  | transaction         | disabled |
| trx_rollback_active                      | transaction         | disabled |
| trx_ro_commits                           | transaction         | disabled |
| trx_rseg_current_size                    | transaction         | disabled |
| trx_rseg_history_len                     | transaction         | enabled  |
| trx_rw_commits                           | transaction         | disabled |
| trx_undo_slots_cached                    | transaction         | disabled |
| trx_undo_slots_used                      | transaction         | disabled |
+------------------------------------------+---------------------+----------+
235 rows in set (0.01 sec)
</pre>
            <h4><a name="idm140286806819136"></a>Counter Modules</h4>
            <p>
                Each counter is associated with a particular module. Module names
                can be used to enable, disable, or reset all counters for a
                particular subsystem. For example, use
                <code class="literal">module_dml</code> to enable all counters associated
                with the <code class="literal">dml</code> subsystem.
            </p><p style="color:blue;">每个计数器都与特定模块相关联。模块名可用于启用、禁用或重置特定子系统的所有计数器。例如，使用module_dml启用与dml子系统关联的所有计数器。</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>SET GLOBAL innodb_monitor_enable = module_dml;</code></strong>

mysql&gt; <strong class="userinput"><code>SELECT name, subsystem, status FROM INFORMATION_SCHEMA.INNODB_METRICS</code></strong>
       <strong class="userinput"><code>WHERE subsystem ='dml';</code></strong>
+-------------+-----------+---------+
| name        | subsystem | status  |
+-------------+-----------+---------+
| dml_reads   | dml       | enabled |
| dml_inserts | dml       | enabled |
| dml_deletes | dml       | enabled |
| dml_updates | dml       | enabled |
+-------------+-----------+---------+
</pre><p>
            Module names can be used with
            <a class="link" href="innodb-storage-engine.html#sysvar_innodb_monitor_enable"><code class="literal">innodb_monitor_enable</code></a> and related
            variables.
        </p><p style="color:blue;">模块名可以与innodb_monitor_enable和相关变量一起使用。</p><p>
            Module names and corresponding <code class="literal">SUBSYSTEM</code> names
            are listed below.
        </p><p style="color:blue;">下面列出了模块名和相应的子系统名。</p>
            <div class="itemizedlist">
                <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                    <code class="literal">module_adaptive_hash</code> (subsystem =
                    <code class="literal">adaptive_hash_index</code>)
                </p><p style="color:blue;">模块自适应哈希（子系统=自适应哈希索引）</p></li><li class="listitem"><p>
                    <code class="literal">module_buffer</code> (subsystem =
                    <code class="literal">buffer</code>)
                </p><p style="color:blue;">模块缓冲区（子系统=缓冲区）</p></li><li class="listitem"><p>
                    <code class="literal">module_buffer_page</code> (subsystem =
                    <code class="literal">buffer_page_io</code>)
                </p><p style="color:blue;">模块缓冲页（子系统=缓冲页）</p></li><li class="listitem"><p>
                    <code class="literal">module_compress</code> (subsystem =
                    <code class="literal">compression</code>)
                </p><p style="color:blue;">模块压缩（子系统=压缩）</p></li><li class="listitem"><p>
                    <code class="literal">module_ddl</code> (subsystem =
                    <code class="literal">ddl</code>)
                </p><p style="color:blue;">模块DDL（子系统=DDL）</p></li><li class="listitem"><p>
                    <code class="literal">module_dml</code> (subsystem =
                    <code class="literal">dml</code>)
                </p><p style="color:blue;">模块DML（子系统=DML）</p></li><li class="listitem"><p>
                    <code class="literal">module_file</code> (subsystem =
                    <code class="literal">file_system</code>)
                </p><p style="color:blue;">模块文件（子系统=文件系统）</p></li><li class="listitem"><p>
                    <code class="literal">module_ibuf_system</code> (subsystem =
                    <code class="literal">change_buffer</code>)
                </p><p style="color:blue;">模块IBUF U系统（子系统=更改缓冲区）</p></li><li class="listitem"><p>
                    <code class="literal">module_icp</code> (subsystem =
                    <code class="literal">icp</code>)
                </p><p style="color:blue;">模块-ICP（子系统=ICP）</p></li><li class="listitem"><p>
                    <code class="literal">module_index</code> (subsystem =
                    <code class="literal">index</code>)
                </p><p style="color:blue;">模块索引（子系统=索引）</p></li><li class="listitem"><p>
                    <code class="literal">module_innodb</code> (subsystem =
                    <code class="literal">innodb</code>)
                </p><p style="color:blue;">InnoDB模块（子系统=InnoDB）</p></li><li class="listitem"><p>
                    <code class="literal">module_lock</code> (subsystem =
                    <code class="literal">lock</code>)
                </p><p style="color:blue;">模块锁（子系统=锁）</p></li><li class="listitem"><p>
                    <code class="literal">module_log</code> (subsystem =
                    <code class="literal">recovery</code>)
                </p><p style="color:blue;">模块日志（子系统=恢复）</p></li><li class="listitem"><p>
                    <code class="literal">module_metadata</code> (subsystem =
                    <code class="literal">metadata</code>)
                </p><p style="color:blue;">模块元数据（子系统=元数据）</p></li><li class="listitem"><p>
                    <code class="literal">module_os</code> (subsystem =
                    <code class="literal">os</code>)
                </p><p style="color:blue;">模块操作系统（子系统=操作系统）</p></li><li class="listitem"><p>
                    <code class="literal">module_purge</code> (subsystem =
                    <code class="literal">purge</code>)
                </p><p style="color:blue;">模块清除（子系统=清除）</p></li><li class="listitem"><p>
                    <code class="literal">module_trx</code> (subsystem =
                    <code class="literal">transaction</code>)
                </p><p style="color:blue;">模块TRX（子系统=事务）</p></li></ul>
            </div>

            <div class="example">
                <a name="innodb-information-schema-metrics-table-example"></a><p class="title"><b>Example&nbsp;14.11&nbsp;Working with INNODB_METRICS Table Counters</b></p><p style="color:blue;">示例14.11使用innodb_metrics表计数器</p>
                <div class="example-contents">
                    <p>
                        This example demonstrates enabling, disabling, and resetting a
                        counter, and querying counter data in the
                        <a class="link" href="information-schema.html#innodb-metrics-table" title="24.32.15&nbsp;The INFORMATION_SCHEMA INNODB_METRICS Table"><code class="literal">INNODB_METRICS</code></a> table.
                    </p><p style="color:blue;">这个例子演示了启用、禁用和重置计数器，以及查询innodb_metrics表中的计数器数据。</p>
                    <div class="orderedlist">
                        <ol class="orderedlist" type="1"><li class="listitem"><p>
                            Create a simple <code class="literal">InnoDB</code> table:
                        </p><p style="color:blue;">创建一个简单的innodb表：</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>USE test;</code></strong>
Database changed

mysql&gt; <strong class="userinput"><code>CREATE TABLE t1 (c1 INT) ENGINE=INNODB;</code></strong>
Query OK, 0 rows affected (0.02 sec)
</pre></li><li class="listitem"><p>
                            Enable the <code class="literal">dml_inserts</code> counter.
                        </p><p style="color:blue;">启用DML\U插入计数器。</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>SET GLOBAL innodb_monitor_enable = dml_inserts;</code></strong>
Query OK, 0 rows affected (0.01 sec)
</pre><p>
                            A description of the <code class="literal">dml_inserts</code> counter
                            can be found in the <code class="literal">COMMENT</code> column of the
                            <code class="literal">INNODB_METRICS</code> table:
                        </p><p style="color:blue;">dml_inserts计数器的描述可以在innodb_metrics表的comment列中找到：</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT NAME, COMMENT FROM INFORMATION_SCHEMA.INNODB_METRICS WHERE NAME="dml_inserts";</code></strong>
+-------------+-------------------------+
| NAME        | COMMENT                 |
+-------------+-------------------------+
| dml_inserts | Number of rows inserted |
+-------------+-------------------------+
</pre></li><li class="listitem"><p>
                            Query the <a class="link" href="information-schema.html#innodb-metrics-table" title="24.32.15&nbsp;The INFORMATION_SCHEMA INNODB_METRICS Table"><code class="literal">INNODB_METRICS</code></a> table
                            for the <code class="literal">dml_inserts</code> counter data. Because
                            no DML operations have been performed, the counter values
                            are zero or NULL. The <code class="literal">TIME_ENABLED</code> and
                            <code class="literal">TIME_ELAPSED</code> values indicate when the
                            counter was last enabled and how many seconds have elapsed
                            since that time.
                        </p><p style="color:blue;">查询innodb_metrics表以获取dml_inserts计数器数据。由于未执行DML操作，计数器值为零或空。time_enabled和time_elapsed值指示上次启用计数器的时间以及自该时间以来经过的秒数。</p><pre data-lang="sql" class="programlisting">mysql&gt;  <strong class="userinput"><code>SELECT * FROM INFORMATION_SCHEMA.INNODB_METRICS WHERE NAME="dml_inserts" \G</code></strong>
*************************** 1. row ***************************
           NAME: dml_inserts
      SUBSYSTEM: dml
          COUNT: 0
      MAX_COUNT: 0
      MIN_COUNT: NULL
      AVG_COUNT: 0
    COUNT_RESET: 0
MAX_COUNT_RESET: 0
MIN_COUNT_RESET: NULL
AVG_COUNT_RESET: NULL
   TIME_ENABLED: 2014-12-04 14:18:28
  TIME_DISABLED: NULL
   TIME_ELAPSED: 28
     TIME_RESET: NULL
         STATUS: enabled
           TYPE: status_counter
        COMMENT: Number of rows inserted
</pre></li><li class="listitem"><p>
                            Insert three rows of data into the table.
                        </p><p style="color:blue;">在表中插入三行数据。</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>INSERT INTO t1 values(1);</code></strong>
Query OK, 1 row affected (0.00 sec)

mysql&gt; <strong class="userinput"><code>INSERT INTO t1 values(2);</code></strong>
Query OK, 1 row affected (0.00 sec)

mysql&gt; <strong class="userinput"><code>INSERT INTO t1 values(3);</code></strong>
Query OK, 1 row affected (0.00 sec)
</pre></li><li class="listitem"><p>
                            Query the <a class="link" href="information-schema.html#innodb-metrics-table" title="24.32.15&nbsp;The INFORMATION_SCHEMA INNODB_METRICS Table"><code class="literal">INNODB_METRICS</code></a> table
                            again for the <code class="literal">dml_inserts</code> counter data. A
                            number of counter values have now incremented including
                            <code class="literal">COUNT</code>, <code class="literal">MAX_COUNT</code>,
                            <code class="literal">AVG_COUNT</code>, and
                            <code class="literal">COUNT_RESET</code>. Refer to the
                            <a class="link" href="information-schema.html#innodb-metrics-table" title="24.32.15&nbsp;The INFORMATION_SCHEMA INNODB_METRICS Table"><code class="literal">INNODB_METRICS</code></a> table definition
                            for descriptions of these values.
                        </p><p style="color:blue;">再次查询innodb_metrics表以获取dml_inserts计数器数据。许多计数器值现在已递增，包括count、max_count、avg_count和count_reset。有关这些值的说明，请参阅innodb_metrics表定义。</p><pre data-lang="sql" class="programlisting">mysql&gt;  <strong class="userinput"><code>SELECT * FROM INFORMATION_SCHEMA.INNODB_METRICS WHERE NAME="dml_inserts"\G</code></strong>
*************************** 1. row ***************************
           NAME: dml_inserts
      SUBSYSTEM: dml
          COUNT: 3
      MAX_COUNT: 3
      MIN_COUNT: NULL
      AVG_COUNT: 0.046153846153846156
    COUNT_RESET: 3
MAX_COUNT_RESET: 3
MIN_COUNT_RESET: NULL
AVG_COUNT_RESET: NULL
   TIME_ENABLED: 2014-12-04 14:18:28
  TIME_DISABLED: NULL
   TIME_ELAPSED: 65
     TIME_RESET: NULL
         STATUS: enabled
           TYPE: status_counter
        COMMENT: Number of rows inserted
</pre></li><li class="listitem"><p>
                            Reset the <code class="literal">dml_inserts</code> counter and query
                            the <a class="link" href="information-schema.html#innodb-metrics-table" title="24.32.15&nbsp;The INFORMATION_SCHEMA INNODB_METRICS Table"><code class="literal">INNODB_METRICS</code></a> table again
                            for the <code class="literal">dml_inserts</code> counter data. The
                            <code class="literal">%_RESET</code> values that were reported
                            previously, such as <code class="literal">COUNT_RESET</code> and
                            <code class="literal">MAX_RESET</code>, are set back to zero. Values
                            such as <code class="literal">COUNT</code>,
                            <code class="literal">MAX_COUNT</code>, and
                            <code class="literal">AVG_COUNT</code>, which cumulatively collect
                            data from the time the counter is enabled, are unaffected by
                            the reset.
                        </p><p style="color:blue;">重置dml_inserts计数器并再次查询innodb_metrics表以获取dml_inserts计数器数据。先前报告的%u重置值（如count_reset和max_reset）将被设置回零。从计数器启用时累积收集数据的count、max_count和avg_count等值不受重置的影响。</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>SET GLOBAL innodb_monitor_reset = dml_inserts;</code></strong>
Query OK, 0 rows affected (0.00 sec)

mysql&gt; <strong class="userinput"><code>SELECT * FROM INFORMATION_SCHEMA.INNODB_METRICS WHERE NAME="dml_inserts"\G</code></strong>
*************************** 1. row ***************************
           NAME: dml_inserts
      SUBSYSTEM: dml
          COUNT: 3
      MAX_COUNT: 3
      MIN_COUNT: NULL
      AVG_COUNT: 0.03529411764705882
    COUNT_RESET: 0
MAX_COUNT_RESET: 0
MIN_COUNT_RESET: NULL
AVG_COUNT_RESET: 0
   TIME_ENABLED: 2014-12-04 14:18:28
  TIME_DISABLED: NULL
   TIME_ELAPSED: 85
     TIME_RESET: 2014-12-04 14:19:44
         STATUS: enabled
           TYPE: status_counter
        COMMENT: Number of rows inserted
</pre></li><li class="listitem"><p>
                            To reset all counter values, you must first disable the
                            counter. Disabling the counter sets the
                            <code class="literal">STATUS</code> value to
                            <code class="literal">disabled</code>.
                        </p><p style="color:blue;">要重置所有计数器值，必须先禁用计数器。禁用计数器会将状态值设置为禁用。</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>SET GLOBAL innodb_monitor_disable = dml_inserts;</code></strong>
Query OK, 0 rows affected (0.00 sec)

mysql&gt; <strong class="userinput"><code>SELECT * FROM INFORMATION_SCHEMA.INNODB_METRICS WHERE NAME="dml_inserts"\G</code></strong>
*************************** 1. row ***************************
           NAME: dml_inserts
      SUBSYSTEM: dml
          COUNT: 3
      MAX_COUNT: 3
      MIN_COUNT: NULL
      AVG_COUNT: 0.030612244897959183
    COUNT_RESET: 0
MAX_COUNT_RESET: 0
MIN_COUNT_RESET: NULL
AVG_COUNT_RESET: 0
   TIME_ENABLED: 2014-12-04 14:18:28
  TIME_DISABLED: 2014-12-04 14:20:06
   TIME_ELAPSED: 98
     TIME_RESET: NULL
         STATUS: disabled
           TYPE: status_counter
        COMMENT: Number of rows inserted
</pre>
                            <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">

                                <div class="admon-title">
                                    Note
                                </div>
                                <p>
                                    Wildcard match is supported for counter and module names.
                                    For example, instead of specifying the full
                                    <code class="literal">dml_inserts</code> counter name, you can
                                    specify <code class="literal">dml_i%</code>. You can also enable,
                                    disable, or reset multiple counters or modules at once
                                    using a wildcard match. For example, specify
                                    <code class="literal">dml_%</code> to enable, disable, or reset all
                                    counters that begin with <code class="literal">dml_</code>.
                                </p><p style="color:blue;">计数器名和模块名支持通配符匹配。例如，您可以指定dml_i%，而不是指定完整的dml_inserts计数器名称。还可以使用通配符匹配同时启用、禁用或重置多个计数器或模块。例如，指定dml_u%以启用、禁用或重置以dml_u开头的所有计数器。</p>
                            </div>
                        </li><li class="listitem"><p>
                            After the counter is disabled, you can reset all counter
                            values using the
                            <a class="link" href="innodb-storage-engine.html#sysvar_innodb_monitor_reset_all"><code class="literal">innodb_monitor_reset_all</code></a>
                            option. All values are set to zero or NULL.
                        </p><p style="color:blue;">禁用计数器后，可以使用innodb_monitor_reset_all选项重置所有计数器值。所有值都设置为零或空。</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>SET GLOBAL innodb_monitor_reset_all = dml_inserts;</code></strong>
Query OK, 0 rows affected (0.00 sec)

mysql&gt; <strong class="userinput"><code>SELECT * FROM INFORMATION_SCHEMA.INNODB_METRICS WHERE NAME="dml_inserts"\G</code></strong>
*************************** 1. row ***************************
           NAME: dml_inserts
      SUBSYSTEM: dml
          COUNT: 0
      MAX_COUNT: NULL
      MIN_COUNT: NULL
      AVG_COUNT: NULL
    COUNT_RESET: 0
MAX_COUNT_RESET: NULL
MIN_COUNT_RESET: NULL
AVG_COUNT_RESET: NULL
   TIME_ENABLED: NULL
  TIME_DISABLED: NULL
   TIME_ELAPSED: NULL
     TIME_RESET: NULL
         STATUS: disabled
           TYPE: status_counter
        COMMENT: Number of rows inserted
</pre></li></ol>
                    </div>

                </div>

            </div>
            <br class="example-break">
        </div>
        <div class="section">
            <div class="titlepage">
                <div>
                    <div>
                        <h3 class="title"><a name="innodb-information-schema-temp-table-info"></a>14.15.7&nbsp;InnoDB INFORMATION_SCHEMA Temporary Table Info Table</h3>

                    </div>

                </div>

            </div>
            <p>
                <a class="link" href="information-schema.html#innodb-temp-table-info-table" title="24.32.25&nbsp;The INFORMATION_SCHEMA INNODB_TEMP_TABLE_INFO Table"><code class="literal">INNODB_TEMP_TABLE_INFO</code></a> provides
                information about user-created <code class="literal">InnoDB</code> temporary
                tables that are active in the <code class="literal">InnoDB</code> instance.
                It does not provide information about internal
                <code class="literal">InnoDB</code> temporary tables used by the optimizer.
            </p><p style="color:blue;">innodb_temp_table_info提供有关用户创建的innodb临时表的信息，这些表在innodb实例中处于活动状态。它不提供有关优化器使用的内部innodb临时表的信息。</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>SHOW TABLES FROM INFORMATION_SCHEMA LIKE 'INNODB_TEMP%';</code></strong>
+---------------------------------------------+
| Tables_in_INFORMATION_SCHEMA (INNODB_TEMP%) |
+---------------------------------------------+
| INNODB_TEMP_TABLE_INFO                      |
+---------------------------------------------+
</pre><p>
            For the table definition, see
            <a class="xref" href="information-schema.html#innodb-temp-table-info-table" title="24.32.25&nbsp;The INFORMATION_SCHEMA INNODB_TEMP_TABLE_INFO Table">Section&nbsp;24.32.25, “The INFORMATION_SCHEMA INNODB_TEMP_TABLE_INFO Table”</a>.
        </p><p style="color:blue;">有关表定义，请参见第24.32.25节“information_schema innodb_temp_table_info table”。</p>
            <div class="example">
                <a name="innodb-information-schema-temp-table-info-example"></a><p class="title"><b>Example&nbsp;14.12&nbsp;INNODB_TEMP_TABLE_INFO</b></p><p style="color:blue;">示例14.12 innodb_temp_table_info</p>
                <div class="example-contents">
                    <p>
                        This example demonstrates characteristics of the
                        <a class="link" href="information-schema.html#innodb-temp-table-info-table" title="24.32.25&nbsp;The INFORMATION_SCHEMA INNODB_TEMP_TABLE_INFO Table"><code class="literal">INNODB_TEMP_TABLE_INFO</code></a> table.
                    </p><p style="color:blue;">这个例子演示了innodb_temp_table_info表的特性。</p>
                    <div class="orderedlist">
                        <ol class="orderedlist" type="1"><li class="listitem"><p>
                            Create a simple <code class="literal">InnoDB</code> temporary table:
                        </p><p style="color:blue;">创建一个简单的innodb临时表：</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>CREATE TEMPORARY TABLE t1 (c1 INT PRIMARY KEY) ENGINE=INNODB;</code></strong>
</pre></li><li class="listitem"><p>
                            Query <a class="link" href="information-schema.html#innodb-temp-table-info-table" title="24.32.25&nbsp;The INFORMATION_SCHEMA INNODB_TEMP_TABLE_INFO Table"><code class="literal">INNODB_TEMP_TABLE_INFO</code></a> to
                            view the temporary table metadata.
                        </p><p style="color:blue;">查询innodb_temp_table_info查看临时表元数据。</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT * FROM INFORMATION_SCHEMA.INNODB_TEMP_TABLE_INFO\G</code></strong>
*************************** 1. row ***************************
            TABLE_ID: 194
                NAME: #sql7a79_1_0
              N_COLS: 4
               SPACE: 182
PER_TABLE_TABLESPACE: FALSE
       IS_COMPRESSED: FALSE
</pre><p>
                            The <code class="literal">TABLE_ID </code> is a unique identifier for
                            the temporary table. The <code class="literal">NAME</code> column
                            displays the system-generated name for the temporary table,
                            which is prefixed with <span class="quote">“<span class="quote">#sql</span>”</span>. The number of
                            columns (<code class="literal">N_COLS</code>) is 4 rather than 1
                            because <code class="literal">InnoDB</code> always creates three
                            hidden table columns (<code class="literal">DB_ROW_ID</code>,
                            <code class="literal">DB_TRX_ID</code>, and
                            <code class="literal">DB_ROLL_PTR</code>).
                            <code class="literal">PER_TABLE_TABLESPACE</code> and
                            <code class="literal">IS_COMPRESSED</code> report
                            <code class="literal">TRUE</code> for compressed temporary tables.
                            Otherwise, these fields report <code class="literal">FALSE</code>.
                        </p><p style="color:blue;">表id是临时表的唯一标识符。“名称”列显示系统为临时表生成的名称，该名称的前缀为“sql”。列数（n_cols）是4而不是1，因为innodb总是创建三个隐藏的表列（db_row_id、db_trx_id和db_roll_ptr）。对于压缩的临时表，per_table_table space和is_compressed report为true。否则，这些字段报告为false。</p></li><li class="listitem"><p>
                            Create a compressed temporary table.
                        </p><p style="color:blue;">创建压缩的临时表。</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>CREATE TEMPORARY TABLE t2 (c1 INT) ROW_FORMAT=COMPRESSED ENGINE=INNODB;</code></strong>
</pre></li><li class="listitem"><p>
                            Query <a class="link" href="information-schema.html#innodb-temp-table-info-table" title="24.32.25&nbsp;The INFORMATION_SCHEMA INNODB_TEMP_TABLE_INFO Table"><code class="literal">INNODB_TEMP_TABLE_INFO</code></a>
                            again.
                        </p><p style="color:blue;">再次查询innodb_temp_table_info。</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT * FROM INFORMATION_SCHEMA.INNODB_TEMP_TABLE_INFO\G</code></strong>
*************************** 1. row ***************************
            TABLE_ID: 195
                NAME: #sql7a79_1_1
              N_COLS: 4
               SPACE: 183
PER_TABLE_TABLESPACE: TRUE
       IS_COMPRESSED: TRUE
*************************** 2. row ***************************
            TABLE_ID: 194
                NAME: #sql7a79_1_0
              N_COLS: 4
               SPACE: 182
PER_TABLE_TABLESPACE: FALSE
       IS_COMPRESSED: FALSE
</pre><p>
                            <code class="literal">PER_TABLE_TABLESPACE</code> and
                            <code class="literal">IS_COMPRESSED</code> report
                            <code class="literal">TRUE</code> for the compressed temporary table.
                            The <code class="literal">SPACE</code> ID for the compressed temporary
                            table is different because compressed temporary tables are
                            created in separate file-per-table tablespaces.
                            Non-compressed temporary tables are created in the shared
                            temporary tablespace (<code class="filename">ibtmp1</code>) and
                            report the same <code class="literal">SPACE</code> ID.
                        </p><p style="color:blue;">对于压缩的临时表，per_table_table space和is_compressed report为true。压缩临时表的空间ID不同，因为压缩临时表是在每个表空间的单独文件中创建的。在共享临时表空间（ibtmp1）中创建非压缩临时表，并报告相同的空间id。</p></li><li class="listitem"><p>
                            Restart MySQL and query
                            <a class="link" href="information-schema.html#innodb-temp-table-info-table" title="24.32.25&nbsp;The INFORMATION_SCHEMA INNODB_TEMP_TABLE_INFO Table"><code class="literal">INNODB_TEMP_TABLE_INFO</code></a>.
                        </p><p style="color:blue;">重启mysql，查询innodb_temp_table_info。</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT * FROM INFORMATION_SCHEMA.INNODB_TEMP_TABLE_INFO\G</code></strong>
Empty set (0.00 sec)
</pre><p>
                            An empty set is returned because
                            <a class="link" href="information-schema.html#innodb-temp-table-info-table" title="24.32.25&nbsp;The INFORMATION_SCHEMA INNODB_TEMP_TABLE_INFO Table"><code class="literal">INNODB_TEMP_TABLE_INFO</code></a> and its
                            data are not persisted to disk when the server is shut down.
                        </p><p style="color:blue;">返回一个空集合，因为当服务器关闭时，innodb_temp_table_info及其数据不会持久化到磁盘。</p></li><li class="listitem"><p>
                            Create a new temporary table.
                        </p><p style="color:blue;">创建新的临时表。</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>CREATE TEMPORARY TABLE t1 (c1 INT PRIMARY KEY) ENGINE=INNODB;</code></strong>
</pre></li><li class="listitem"><p>
                            Query <a class="link" href="information-schema.html#innodb-temp-table-info-table" title="24.32.25&nbsp;The INFORMATION_SCHEMA INNODB_TEMP_TABLE_INFO Table"><code class="literal">INNODB_TEMP_TABLE_INFO</code></a> to
                            view the temporary table metadata.
                        </p><p style="color:blue;">查询innodb_temp_table_info查看临时表元数据。</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT * FROM INFORMATION_SCHEMA.INNODB_TEMP_TABLE_INFO\G</code></strong>
*************************** 1. row ***************************
            TABLE_ID: 196
                NAME: #sql7b0e_1_0
              N_COLS: 4
               SPACE: 184
PER_TABLE_TABLESPACE: FALSE
       IS_COMPRESSED: FALSE
</pre><p>
                            The <code class="literal">SPACE</code> ID may be different because it
                            is dynamically generated when the server is started.
                        </p><p style="color:blue;">空间id可能不同，因为它是在服务器启动时动态生成的。</p></li></ol>
                    </div>

                </div>

            </div>
            <br class="example-break">
        </div>
        <div class="section">
            <div class="titlepage">
                <div>
                    <div>
                        <h3 class="title"><a name="innodb-information-schema-files-table"></a>14.15.8&nbsp;Retrieving InnoDB Tablespace Metadata from INFORMATION_SCHEMA.FILES</h3>

                    </div>

                </div>

            </div>
            <p>
                The <a class="link" href="information-schema.html#files-table" title="24.9&nbsp;The INFORMATION_SCHEMA FILES Table"><code class="literal">INFORMATION_SCHEMA.FILES</code></a> table
                provides metadata about all <code class="literal">InnoDB</code> tablespace
                types including <a class="link" href="glossary.html#glos_file_per_table" title="file-per-table">file-per-table
                tablespaces</a>,
                <a class="link" href="glossary.html#glos_general_tablespace" title="general tablespace">general
                    tablespaces</a>, the
                <a class="link" href="glossary.html#glos_system_tablespace" title="system tablespace">system tablespace</a>,
                <a class="link" href="glossary.html#glos_temporary_tablespace" title="temporary tablespace">temporary table
                    tablespaces</a>, and <a class="link" href="glossary.html#glos_undo_tablespace" title="undo tablespace">undo
                tablespaces</a> (if present).
            </p><p style="color:blue;">information_schema.files表提供了所有innodb表空间类型的元数据，包括每个表空间的文件、常规表空间、系统表空间、临时表空间和撤消表空间（如果存在）。</p><p>
            This section provides <code class="literal">InnoDB</code>-specific usage
            examples. For more information about data provided by the
            <a class="link" href="information-schema.html#files-table" title="24.9&nbsp;The INFORMATION_SCHEMA FILES Table"><code class="literal">INFORMATION_SCHEMA.FILES</code></a> table, see
            <a class="xref" href="information-schema.html#files-table" title="24.9&nbsp;The INFORMATION_SCHEMA FILES Table">Section&nbsp;24.9, “The INFORMATION_SCHEMA FILES Table”</a>.
        </p><p style="color:blue;">本节提供了innodb特定的用法示例。有关information_schema.files表提供的数据的更多信息，请参阅第24.9节“information_schema files表”。</p>
            <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">

                <div class="admon-title">
                    Note
                </div>
                <p>
                    The <a class="link" href="information-schema.html#innodb-sys-tablespaces-table" title="24.32.22.1&nbsp;The INFORMATION_SCHEMA INNODB_SYS_TABLESPACES Table"><code class="literal">INNODB_SYS_TABLESPACES</code></a> and
                    <a class="link" href="information-schema.html#innodb-sys-datafiles-table" title="24.32.17&nbsp;The INFORMATION_SCHEMA INNODB_SYS_DATAFILES Table"><code class="literal">INNODB_SYS_DATAFILES</code></a> tables also
                    provide metadata about <code class="literal">InnoDB</code> tablespaces,
                    but data is limited to file-per-table and general tablespaces.
                </p><p style="color:blue;">innodb_sys_表空间和innodb_sys_datafiles表也提供了关于innodb表空间的元数据，但是数据仅限于每个表的文件和常规表空间。</p>
            </div>
            <p>
                This query retrieves metadata about the <code class="literal">InnoDB</code>
                system tablespace from fields of the
                <a class="link" href="information-schema.html#files-table" title="24.9&nbsp;The INFORMATION_SCHEMA FILES Table"><code class="literal">INFORMATION_SCHEMA.FILES</code></a> table that
                are pertinent to <code class="literal">InnoDB</code> tablespaces.
                <a class="link" href="information-schema.html#files-table" title="24.9&nbsp;The INFORMATION_SCHEMA FILES Table"><code class="literal">INFORMATION_SCHEMA.FILES</code></a> fields that
                are not relevant to <code class="literal">InnoDB</code> always return NULL,
                and are excluded from the query.
            </p><p style="color:blue;">此查询从information schema.files表中与innodb表空间相关的字段中检索有关innodb系统表空间的元数据。与innodb无关的information_schema.files字段始终返回空值，并从查询中排除。</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT FILE_ID, FILE_NAME, FILE_TYPE, TABLESPACE_NAME, FREE_EXTENTS,</code></strong>
       <strong class="userinput"><code>TOTAL_EXTENTS,  EXTENT_SIZE, INITIAL_SIZE, MAXIMUM_SIZE, AUTOEXTEND_SIZE, DATA_FREE, STATUS ENGINE</code></strong>
       <strong class="userinput"><code>FROM INFORMATION_SCHEMA.FILES WHERE TABLESPACE_NAME LIKE 'innodb_system' \G</code></strong>
*************************** 1. row ***************************
        FILE_ID: 0
      FILE_NAME: ./ibdata1
      FILE_TYPE: TABLESPACE
TABLESPACE_NAME: innodb_system
   FREE_EXTENTS: 0
  TOTAL_EXTENTS: 12
    EXTENT_SIZE: 1048576
   INITIAL_SIZE: 12582912
   MAXIMUM_SIZE: NULL
AUTOEXTEND_SIZE: 67108864
      DATA_FREE: 4194304
         ENGINE: NORMAL
</pre><p>
            This query retrieves the <code class="literal">FILE_ID</code> (equivalent to
            the space ID) and the <code class="literal">FILE_NAME</code> (which includes
            path information) for <code class="literal">InnoDB</code> file-per-table and
            general tablespaces. File-per-table and general tablespaces have a
            <code class="filename">.ibd</code> file extension.
        </p><p style="color:blue;">此查询检索innodb file per table和general tables spaces的文件id（相当于空间id）和文件名（包括路径信息）。每个表的文件和常规表空间的文件扩展名为.ibd。</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT FILE_ID, FILE_NAME FROM INFORMATION_SCHEMA.FILES</code></strong>
       <strong class="userinput"><code>WHERE FILE_NAME LIKE '%.ibd%' ORDER BY FILE_ID;</code></strong>
    +---------+---------------------------------------+
    | FILE_ID | FILE_NAME                             |
    +---------+---------------------------------------+
    |       2 | ./mysql/plugin.ibd                    |
    |       3 | ./mysql/servers.ibd                   |
    |       4 | ./mysql/help_topic.ibd                |
    |       5 | ./mysql/help_category.ibd             |
    |       6 | ./mysql/help_relation.ibd             |
    |       7 | ./mysql/help_keyword.ibd              |
    |       8 | ./mysql/time_zone_name.ibd            |
    |       9 | ./mysql/time_zone.ibd                 |
    |      10 | ./mysql/time_zone_transition.ibd      |
    |      11 | ./mysql/time_zone_transition_type.ibd |
    |      12 | ./mysql/time_zone_leap_second.ibd     |
    |      13 | ./mysql/innodb_table_stats.ibd        |
    |      14 | ./mysql/innodb_index_stats.ibd        |
    |      15 | ./mysql/slave_relay_log_info.ibd      |
    |      16 | ./mysql/slave_master_info.ibd         |
    |      17 | ./mysql/slave_worker_info.ibd         |
    |      18 | ./mysql/gtid_executed.ibd             |
    |      19 | ./mysql/server_cost.ibd               |
    |      20 | ./mysql/engine_cost.ibd               |
    |      21 | ./sys/sys_config.ibd                  |
    |      23 | ./test/t1.ibd                         |
    |      26 | /home/user/test/test/t2.ibd           |
    +---------+---------------------------------------+
</pre><p>
            This query retrieves the <code class="literal">FILE_ID</code> and
            <code class="literal">FILE_NAME</code> for <code class="literal">InnoDB</code>
            temporary tablespaces. Temporary tablespace file names are
            prefixed by <code class="literal">ibtmp</code>.
        </p><p style="color:blue;">此查询检索innodb临时表空间的文件id和文件名。临时表空间文件名的前缀是ibtmp。</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT FILE_ID, FILE_NAME FROM INFORMATION_SCHEMA.FILES</code></strong>
       <strong class="userinput"><code>WHERE FILE_NAME LIKE '%ibtmp%';</code></strong>
+---------+-----------+
| FILE_ID | FILE_NAME |
+---------+-----------+
|      22 | ./ibtmp1  |
+---------+-----------+
</pre><p>
            Similarly, <code class="literal">InnoDB</code> undo tablespace file names
            are prefixed by <code class="literal">undo</code>. The following query
            returns the <code class="literal">FILE_ID</code> and
            <code class="literal">FILE_NAME</code> for <code class="literal">InnoDB</code> undo
            tablespaces, if separate undo tablespaces are configured.
        </p><p style="color:blue;">类似地，innodb undo表空间文件名的前缀是undo。如果配置了单独的undo表空间，下面的查询将返回innodb undo表空间的文件id和文件名。</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT FILE_ID, FILE_NAME FROM INFORMATION_SCHEMA.FILES</code></strong>
       <strong class="userinput"><code>WHERE FILE_NAME LIKE '%undo%';</code></strong>
</pre>
        </div>

    </div>
    <div class="section">
        <div class="titlepage">
            <div>
                <div>
                    <h2 class="title" style="clear: both"><a name="innodb-performance-schema"></a>14.16&nbsp;InnoDB Integration with MySQL Performance Schema</h2>

                </div>

            </div>

        </div>
        <div class="toc">
            <dl class="toc"><dt><span class="section"><a href="innodb-storage-engine.html#monitor-alter-table-performance-schema">14.16.1 Monitoring ALTER TABLE Progress for InnoDB Tables Using Performance
Schema</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#monitor-innodb-mutex-waits-performance-schema">14.16.2 Monitoring InnoDB Mutex Waits Using Performance Schema</a></span></dt></dl>
        </div>
        <a class="indexterm" name="idm140286806611552"></a><p>
        This section provides a brief introduction to
        <code class="literal">InnoDB</code> integration with Performance Schema. For
        comprehensive Performance Schema documentation, see
        <a class="xref" href="performance-schema.html" title="Chapter&nbsp;25&nbsp;MySQL Performance Schema">Chapter&nbsp;25, <i>MySQL Performance Schema</i></a>.
    </p><p style="color:blue;">本节简要介绍了InnoDB与性能模式的集成。有关全面的性能模式文档，请参阅第25章MySQL性能模式。</p><p>
        You can profile certain internal <code class="literal">InnoDB</code>
        operations using the MySQL
        <a class="link" href="performance-schema.html" title="Chapter&nbsp;25&nbsp;MySQL Performance Schema">Performance Schema
            feature</a>. This type of tuning is primarily for expert users
        who evaluate optimization strategies to overcome performance
        bottlenecks. DBAs can also use this feature for capacity planning,
        to see whether their typical workload encounters any performance
        bottlenecks with a particular combination of CPU, RAM, and disk
        storage; and if so, to judge whether performance can be improved by
        increasing the capacity of some part of the system.
    </p><p style="color:blue;">您可以使用mysql性能模式特性分析某些内部innodb操作。这种类型的调整主要是针对评估优化策略以克服性能瓶颈的专家用户。dba还可以使用此功能进行容量规划，以查看其典型工作负载在cpu、ram和磁盘存储的特定组合中是否遇到任何性能瓶颈；如果遇到，则判断是否可以通过增加系统某些部分的容量来提高性能。</p><p>
        To use this feature to examine <code class="literal">InnoDB</code>
        performance:
    </p><p style="color:blue;">要使用此功能检查InnoDB性能：</p>
        <div class="itemizedlist">
            <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                You must be generally familiar with how to use the
                <a class="link" href="performance-schema.html" title="Chapter&nbsp;25&nbsp;MySQL Performance Schema">Performance Schema
                    feature</a>. For example, you should know how enable
                instruments and consumers, and how to query
                <code class="literal">performance_schema</code> tables to retrieve data.
                For an introductory overview, see
                <a class="xref" href="performance-schema.html#performance-schema-quick-start" title="25.1&nbsp;Performance Schema Quick Start">Section&nbsp;25.1, “Performance Schema Quick Start”</a>.
            </p><p style="color:blue;">您通常必须熟悉如何使用性能模式功能。例如，您应该知道如何启用工具和使用者，以及如何查询性能模式表以检索数据。有关介绍性概述，请参阅25.1节“性能模式快速入门”。</p></li><li class="listitem"><p>
                You should be familiar with Performance Schema instruments that
                are available for <code class="literal">InnoDB</code>. To view
                <code class="literal">InnoDB</code>-related instruments, you can query the
                <a class="link" href="performance-schema.html#setup-instruments-table" title="25.12.2.3&nbsp;The setup_instruments Table"><code class="literal">setup_instruments</code></a> table for
                instrument names that contain '<code class="literal">innodb</code>'.
            </p><p style="color:blue;">您应该熟悉innodb可用的性能模式工具。要查看与innodb相关的仪器，可以在setup_instruments表中查询包含“innodb”的仪器名称。</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT *</code></strong>
       <strong class="userinput"><code>FROM performance_schema.setup_instruments</code></strong>
       <strong class="userinput"><code>WHERE NAME LIKE '%innodb%';</code></strong>
+-------------------------------------------------------+---------+-------+
| NAME                                                  | ENABLED | TIMED |
+-------------------------------------------------------+---------+-------+
| wait/synch/mutex/innodb/commit_cond_mutex             | NO      | NO    |
| wait/synch/mutex/innodb/innobase_share_mutex          | NO      | NO    |
| wait/synch/mutex/innodb/autoinc_mutex                 | NO      | NO    |
| wait/synch/mutex/innodb/buf_pool_mutex                | NO      | NO    |
| wait/synch/mutex/innodb/buf_pool_zip_mutex            | NO      | NO    |
| wait/synch/mutex/innodb/cache_last_read_mutex         | NO      | NO    |
| wait/synch/mutex/innodb/dict_foreign_err_mutex        | NO      | NO    |
| wait/synch/mutex/innodb/dict_sys_mutex                | NO      | NO    |
| wait/synch/mutex/innodb/recalc_pool_mutex             | NO      | NO    |
| wait/synch/mutex/innodb/file_format_max_mutex         | NO      | NO    |
...
| wait/io/file/innodb/innodb_data_file                  | YES     | YES   |
| wait/io/file/innodb/innodb_log_file                   | YES     | YES   |
| wait/io/file/innodb/innodb_temp_file                  | YES     | YES   |
| stage/innodb/alter table (end)                        | YES     | YES   |
| stage/innodb/alter table (flush)                      | YES     | YES   |
| stage/innodb/alter table (insert)                     | YES     | YES   |
| stage/innodb/alter table (log apply index)            | YES     | YES   |
| stage/innodb/alter table (log apply table)            | YES     | YES   |
| stage/innodb/alter table (merge sort)                 | YES     | YES   |
| stage/innodb/alter table (read PK and internal sort)  | YES     | YES   |
| stage/innodb/buffer pool load                         | YES     | YES   |
| memory/innodb/buf_buf_pool                            | NO      | NO    |
| memory/innodb/dict_stats_bg_recalc_pool_t             | NO      | NO    |
| memory/innodb/dict_stats_index_map_t                  | NO      | NO    |
| memory/innodb/dict_stats_n_diff_on_level              | NO      | NO    |
| memory/innodb/other                                   | NO      | NO    |
| memory/innodb/row_log_buf                             | NO      | NO    |
| memory/innodb/row_merge_sort                          | NO      | NO    |
| memory/innodb/std                                     | NO      | NO    |
| memory/innodb/sync_debug_latches                      | NO      | NO    |
| memory/innodb/trx_sys_t::rw_trx_ids                   | NO      | NO    |
...
+-------------------------------------------------------+---------+-------+
155 rows in set (0.00 sec)
</pre><p>
                For additional information about the instrumented
                <code class="literal">InnoDB</code> objects, you can query Performance
                Schema
                <a class="link" href="performance-schema.html#performance-schema-instance-tables" title="25.12.3&nbsp;Performance Schema Instance Tables">instances
                    tables</a>, which provide additional information about
                instrumented objects. Instance tables relevant to
                <code class="literal">InnoDB</code> include:
            </p><p style="color:blue;">有关插入指令的innodb对象的其他信息，可以查询性能模式实例表，这些表提供了有关插入指令的对象的其他信息。与innodb相关的实例表包括：</p>
                <div class="itemizedlist">
                    <ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
                        The <a class="link" href="performance-schema.html#mutex-instances-table" title="25.12.3.3&nbsp;The mutex_instances Table"><code class="literal">mutex_instances</code></a> table
                    </p><p style="color:blue;">互斥实例表</p></li><li class="listitem"><p>
                        The <a class="link" href="performance-schema.html#rwlock-instances-table" title="25.12.3.4&nbsp;The rwlock_instances Table"><code class="literal">rwlock_instances</code></a> table
                    </p><p style="color:blue;">rwlock_实例表</p></li><li class="listitem"><p>
                        The <a class="link" href="performance-schema.html#cond-instances-table" title="25.12.3.1&nbsp;The cond_instances Table"><code class="literal">cond_instances</code></a> table
                    </p><p style="color:blue;">cond_实例表</p></li><li class="listitem"><p>
                        The <a class="link" href="performance-schema.html#file-instances-table" title="25.12.3.2&nbsp;The file_instances Table"><code class="literal">file_instances</code></a> table
                    </p><p style="color:blue;">文件实例表</p></li></ul>
                </div>
                <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">
                    <div class="admon-title">
                        Note
                    </div>
                    <p>
                        Mutexes and RW-locks related to the <code class="literal">InnoDB</code>
                        buffer pool are not included in this coverage; the same
                        applies to the output of the <code class="literal">SHOW ENGINE INNODB
                        MUTEX</code> command.
                    </p><p style="color:blue;">与innodb缓冲池相关的互斥锁和rw锁不包括在这个范围内；这同样适用于show engine innodb mutex命令的输出。</p>
                </div>
                <p>
                    For example, to view information about instrumented
                    <code class="literal">InnoDB</code> file objects seen by the Performance
                    Schema when executing file I/O instrumentation, you might issue
                    the following query:
                </p><p style="color:blue;">例如，要查看性能模式在执行文件I/O检测时看到的插入指令的InnoDB文件对象的信息，可以发出以下查询：</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT *</code></strong>
       <strong class="userinput"><code>FROM performance_schema.file_instances</code></strong>
       <strong class="userinput"><code>WHERE EVENT_NAME LIKE '%innodb%'\G</code></strong>
*************************** 1. row ***************************
 FILE_NAME: /path/to/mysql-5.7/data/ibdata1
EVENT_NAME: wait/io/file/innodb/innodb_data_file
OPEN_COUNT: 3
*************************** 2. row ***************************
 FILE_NAME: /path/to/mysql-5.7/data/ib_logfile0
EVENT_NAME: wait/io/file/innodb/innodb_log_file
OPEN_COUNT: 2
*************************** 3. row ***************************
 FILE_NAME: /path/to/mysql-5.7/data/ib_logfile1
EVENT_NAME: wait/io/file/innodb/innodb_log_file
OPEN_COUNT: 2
*************************** 4. row ***************************
 FILE_NAME: /path/to/mysql-5.7/data/mysql/engine_cost.ibd
EVENT_NAME: wait/io/file/innodb/innodb_data_file
OPEN_COUNT: 3
...
</pre></li><li class="listitem"><p>
                You should be familiar with
                <code class="literal">performance_schema</code> tables that store
                <code class="literal">InnoDB</code> event data. Tables relevant to
                <code class="literal">InnoDB</code>-related events include:
            </p><p style="color:blue;">您应该熟悉存储innodb事件数据的性能模式表。与innodb相关事件相关的表包括：</p>
                <div class="itemizedlist">
                    <ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
                        The <a class="link" href="performance-schema.html#performance-schema-wait-tables" title="25.12.4&nbsp;Performance Schema Wait Event Tables">Wait
                        Event</a> tables, which store wait events.
                    </p><p style="color:blue;">等待事件表，存储等待事件。</p></li><li class="listitem"><p>
                        The
                        <a class="link" href="performance-schema.html#performance-schema-summary-tables" title="25.12.15&nbsp;Performance Schema Summary Tables">Summary</a>
                        tables, which provide aggregated information for terminated
                        events over time. Summary tables include
                        <a class="link" href="performance-schema.html#file-summary-tables" title="25.12.15.6&nbsp;File I/O Summary Tables">file I/O summary
                            tables</a>, which aggregate information about I/O
                        operations.
                    </p><p style="color:blue;">摘要表，随时间提供已终止事件的聚合信息。摘要表包括文件I/O摘要表，这些表聚合了有关I/O操作的信息。</p></li><li class="listitem"><p>
                        <a class="link" href="performance-schema.html#performance-schema-stage-tables" title="25.12.5&nbsp;Performance Schema Stage Event Tables">Stage
                            Event</a> tables, which store event data for
                        <code class="literal">InnoDB</code> <a class="link" href="sql-syntax.html#alter-table" title="13.1.8&nbsp;ALTER TABLE Syntax"><code class="literal">ALTER
                        TABLE</code></a> and buffer pool load operations. For more
                        information, see
                        <a class="xref" href="innodb-storage-engine.html#monitor-alter-table-performance-schema" title="14.16.1&nbsp;Monitoring ALTER TABLE Progress for InnoDB Tables Using Performance Schema">Section&nbsp;14.16.1, “Monitoring ALTER TABLE Progress for InnoDB Tables Using Performance
                            Schema”</a>,
                        and
                        <a class="xref" href="innodb-storage-engine.html#monitor-buffer-pool-load-performance-schema" title="Monitoring Buffer Pool Load Progress Using Performance Schema">Monitoring Buffer Pool Load Progress Using Performance Schema</a>.
                    </p><p style="color:blue;">stage event tables，用于存储innodb alter table和缓冲池加载操作的事件数据。有关更多信息，请参阅14.16.1节，“使用性能模式监视innodb表的alter table进度”，以及使用性能模式监视缓冲池加载进度。</p></li></ul>
                </div>
                <p>
                    If you are only interested in <code class="literal">InnoDB</code>-related
                    objects, use the clause <code class="literal">WHERE EVENT_NAME LIKE
                    '%innodb%'</code> or <code class="literal">WHERE NAME LIKE
                    '%innodb%'</code> (as required) when querying these tables.
                </p><p style="color:blue;">如果您只对与innodb相关的对象感兴趣，那么在查询这些表时，请使用where event_name，如'%innodb%'或where name，如'%innodb%'（根据需要）。</p></li></ul>
        </div>
        <div class="section">
            <div class="titlepage">
                <div>
                    <div>
                        <h3 class="title"><a name="monitor-alter-table-performance-schema"></a>14.16.1&nbsp;Monitoring ALTER TABLE Progress for InnoDB Tables Using Performance
                            Schema</h3>
                    </div>
                </div>
            </div>
            <a class="indexterm" name="idm140286806551424"></a><a class="indexterm" name="idm140286806549936"></a><p>
            You can monitor <a class="link" href="sql-syntax.html#alter-table" title="13.1.8&nbsp;ALTER TABLE Syntax"><code class="literal">ALTER TABLE</code></a>
            progress for <code class="literal">InnoDB</code> tables using
            <a class="link" href="performance-schema.html" title="Chapter&nbsp;25&nbsp;MySQL Performance Schema">Performance Schema</a>.
        </p><p style="color:blue;">您可以使用性能模式监视innodb表的alter table进度。</p><p>
            There are seven stage events that represent different phases of
            <a class="link" href="sql-syntax.html#alter-table" title="13.1.8&nbsp;ALTER TABLE Syntax"><code class="literal">ALTER TABLE</code></a>. Each stage event
            reports a running total of <code class="literal">WORK_COMPLETED</code> and
            <code class="literal">WORK_ESTIMATED</code> for the overall
            <a class="link" href="sql-syntax.html#alter-table" title="13.1.8&nbsp;ALTER TABLE Syntax"><code class="literal">ALTER TABLE</code></a> operation as it
            progresses through its different phases.
            <code class="literal">WORK_ESTIMATED</code> is calculated using a formula
            that takes into account all of the work that
            <a class="link" href="sql-syntax.html#alter-table" title="13.1.8&nbsp;ALTER TABLE Syntax"><code class="literal">ALTER TABLE</code></a> performs, and may be
            revised during <a class="link" href="sql-syntax.html#alter-table" title="13.1.8&nbsp;ALTER TABLE Syntax"><code class="literal">ALTER TABLE</code></a>
            processing. <code class="literal">WORK_COMPLETED</code> and
            <code class="literal">WORK_ESTIMATED</code> values are an abstract
            representation of all of the work performed by
            <a class="link" href="sql-syntax.html#alter-table" title="13.1.8&nbsp;ALTER TABLE Syntax"><code class="literal">ALTER TABLE</code></a>.
        </p><p style="color:blue;">有七个阶段事件表示alter表的不同阶段。每个阶段事件报告整个alter table操作在其不同阶段中完成的总工时和估计的工时。使用考虑到alter table执行的所有工作的公式计算估计工时，并且可以在alter table处理期间进行修改。work_completed和work_估计值是alter table执行的所有工作的抽象表示。</p><p>
            In order of occurrence, <a class="link" href="sql-syntax.html#alter-table" title="13.1.8&nbsp;ALTER TABLE Syntax"><code class="literal">ALTER TABLE</code></a>
            stage events include:
        </p><p style="color:blue;">按发生顺序，alter table stage事件包括：</p>
            <div class="itemizedlist">
                <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                    <code class="literal">stage/innodb/alter table (read PK and internal
                        sort)</code>: This stage is active when
                    <a class="link" href="sql-syntax.html#alter-table" title="13.1.8&nbsp;ALTER TABLE Syntax"><code class="literal">ALTER TABLE</code></a> is in the
                    reading-primary-key phase. It starts with
                    <code class="literal">WORK_COMPLETED=0</code> and
                    <code class="literal">WORK_ESTIMATED</code> set to the estimated number
                    of pages in the primary key. When the stage is completed,
                    <code class="literal">WORK_ESTIMATED</code> is updated to the actual
                    number of pages in the primary key.
                </p><p style="color:blue;">stage/innodb/alter table（read pk和internal sort）：当alter table处于读取主键阶段时，此阶段处于活动状态。它以work_completed=0开始，work_estimated设置为主键中的估计页数。阶段完成后，估计工时将更新为主键中的实际页数。</p></li><li class="listitem"><p>
                    <code class="literal">stage/innodb/alter table (merge sort)</code>: This
                    stage is repeated for each index added by the
                    <a class="link" href="sql-syntax.html#alter-table" title="13.1.8&nbsp;ALTER TABLE Syntax"><code class="literal">ALTER TABLE</code></a> operation.
                </p><p style="color:blue;">stage/innodb/alter table（合并排序）：对于alter table操作添加的每个索引，都重复此阶段。</p></li><li class="listitem"><p>
                    <code class="literal">stage/innodb/alter table (insert)</code>: This
                    stage is repeated for each index added by the
                    <a class="link" href="sql-syntax.html#alter-table" title="13.1.8&nbsp;ALTER TABLE Syntax"><code class="literal">ALTER TABLE</code></a> operation.
                </p><p style="color:blue;">stage/innodb/alter table（insert）：对alter table操作添加的每个索引重复此阶段。</p></li><li class="listitem"><p>
                    <code class="literal">stage/innodb/alter table (log apply index)</code>:
                    This stage includes the application of DML log generated while
                    <a class="link" href="sql-syntax.html#alter-table" title="13.1.8&nbsp;ALTER TABLE Syntax"><code class="literal">ALTER TABLE</code></a> was running.
                </p><p style="color:blue;">stage/innodb/alter table（log apply index）：这个阶段包括alter table运行时生成的dml日志的应用。</p></li><li class="listitem"><p>
                    <code class="literal">stage/innodb/alter table (flush)</code>: Before
                    this stage begins, <code class="literal">WORK_ESTIMATED</code> is
                    updated with a more accurate estimate, based on the length of
                    the flush list.
                </p><p style="color:blue;">stage/innodb/alter table（flush）：在这个阶段开始之前，根据flush列表的长度，用更精确的估计值更新work_estimated。</p></li><li class="listitem"><p>
                    <code class="literal">stage/innodb/alter table (log apply table)</code>:
                    This stage includes the application of concurrent DML log
                    generated while <a class="link" href="sql-syntax.html#alter-table" title="13.1.8&nbsp;ALTER TABLE Syntax"><code class="literal">ALTER TABLE</code></a> was
                    running. The duration of this phase depends on the extent of
                    table changes. This phase is instant if no concurrent DML was
                    run on the table.
                </p><p style="color:blue;">stage/innodb/alter table（log apply table）：这个阶段包括alter table运行时生成的并发dml日志的应用。此阶段的持续时间取决于表更改的范围。如果没有在表上运行并发dml，则此阶段是即时的。</p></li><li class="listitem"><p>
                    <code class="literal">stage/innodb/alter table (end)</code>: Includes
                    any remaining work that appeared after the flush phase, such
                    as reapplying DML that was executed on the table while
                    <a class="link" href="sql-syntax.html#alter-table" title="13.1.8&nbsp;ALTER TABLE Syntax"><code class="literal">ALTER TABLE</code></a> was running.
                </p><p style="color:blue;">stage/innodb/alter table（end）：包括刷新阶段之后出现的任何剩余工作，例如在alter table运行时重新应用在表上执行的dml。</p></li></ul>
            </div>
            <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">
                <div class="admon-title">
                    Note
                </div>
                <p>
                    <code class="literal">InnoDB</code> <a class="link" href="sql-syntax.html#alter-table" title="13.1.8&nbsp;ALTER TABLE Syntax"><code class="literal">ALTER
                    TABLE</code></a> stage events do not currently account for the
                    addition of spatial indexes.
                </p><p style="color:blue;">innodb alter table stage事件目前不考虑空间索引的添加。</p>
            </div>
            <h4><a name="idm140286806508576"></a>ALTER TABLE Monitoring Example Using Performance Schema</h4>
            <p>
                The following example demonstrates how to enable the
                <code class="literal">stage/innodb/alter table%</code> stage event
                instruments and related consumer tables to monitor
                <a class="link" href="sql-syntax.html#alter-table" title="13.1.8&nbsp;ALTER TABLE Syntax"><code class="literal">ALTER TABLE</code></a> progress. For
                information about Performance Schema stage event instruments and
                related consumers, see
                <a class="xref" href="performance-schema.html#performance-schema-stage-tables" title="25.12.5&nbsp;Performance Schema Stage Event Tables">Section&nbsp;25.12.5, “Performance Schema Stage Event Tables”</a>.
            </p><p style="color:blue;">下面的示例演示如何启用stage/innodb/alter table%stage event instruments和相关使用者表来监视alter table进度。有关Performance Schema Stage事件工具和相关使用者的信息，请参阅25.12.5节“Performance Schema Stage事件表”。</p>
            <div class="orderedlist">
                <ol class="orderedlist" type="1"><li class="listitem"><p>
                    Enable the <code class="literal">stage/innodb/alter%</code> instruments:
                </p><p style="color:blue;">启用stage/innodb/alter%仪器：</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>UPDATE performance_schema.setup_instruments</code></strong>
       <strong class="userinput"><code>SET ENABLED = 'YES'</code></strong>
       <strong class="userinput"><code>WHERE NAME LIKE 'stage/innodb/alter%';</code></strong>
Query OK, 7 rows affected (0.00 sec)
Rows matched: 7  Changed: 7  Warnings: 0
</pre></li><li class="listitem"><p>
                    Enable the stage event consumer tables, which include
                    <a class="link" href="performance-schema.html#events-stages-current-table" title="25.12.5.1&nbsp;The events_stages_current Table"><code class="literal">events_stages_current</code></a>,
                    <a class="link" href="performance-schema.html#events-stages-history-table" title="25.12.5.2&nbsp;The events_stages_history Table"><code class="literal">events_stages_history</code></a>, and
                    <a class="link" href="performance-schema.html#events-stages-history-long-table" title="25.12.5.3&nbsp;The events_stages_history_long Table"><code class="literal">events_stages_history_long</code></a>.
                </p><p style="color:blue;">启用stage event consumer表，其中包括events_stages_current、events_stages_history和events_stages_history_long。</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>UPDATE performance_schema.setup_consumers</code></strong>
       <strong class="userinput"><code>SET ENABLED = 'YES'</code></strong>
       <strong class="userinput"><code>WHERE NAME LIKE '%stages%';</code></strong>
Query OK, 3 rows affected (0.00 sec)
Rows matched: 3  Changed: 3  Warnings: 0
</pre></li><li class="listitem"><p>
                    Run an <a class="link" href="sql-syntax.html#alter-table" title="13.1.8&nbsp;ALTER TABLE Syntax"><code class="literal">ALTER TABLE</code></a> operation.
                    In this example, a <code class="literal">middle_name</code> column is
                    added to the employees table of the employees sample database.
                </p><p style="color:blue;">运行alter table操作。在本例中，middle_name列被添加到employees示例数据库的employees表中。</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>ALTER TABLE employees.employees ADD COLUMN middle_name varchar(14) AFTER first_name;</code></strong>
Query OK, 0 rows affected (9.27 sec)
Records: 0  Duplicates: 0  Warnings: 0
</pre></li><li class="listitem"><p>
                    Check the progress of the <a class="link" href="sql-syntax.html#alter-table" title="13.1.8&nbsp;ALTER TABLE Syntax"><code class="literal">ALTER
                    TABLE</code></a> operation by querying the Performance Schema
                    <a class="link" href="performance-schema.html#events-stages-current-table" title="25.12.5.1&nbsp;The events_stages_current Table"><code class="literal">events_stages_current</code></a> table. The
                    stage event shown differs depending on which
                    <a class="link" href="sql-syntax.html#alter-table" title="13.1.8&nbsp;ALTER TABLE Syntax"><code class="literal">ALTER TABLE</code></a> phase is currently
                    in progress. The <code class="literal">WORK_COMPLETED</code> column
                    shows the work completed. The
                    <code class="literal">WORK_ESTIMATED</code> column provides an estimate
                    of the remaining work.
                </p><p style="color:blue;">通过查询performance schema events_stages_current table检查alter table操作的进度。所显示的阶段事件因当前正在进行的alter table阶段而异。“已完成的工作”列显示已完成的工作。“工时估算”列提供剩余工时的估算。</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT EVENT_NAME, WORK_COMPLETED, WORK_ESTIMATED</code></strong>
       <strong class="userinput"><code>FROM performance_schema.events_stages_current;</code></strong>
+------------------------------------------------------+----------------+----------------+
| EVENT_NAME                                           | WORK_COMPLETED | WORK_ESTIMATED |
+------------------------------------------------------+----------------+----------------+
| stage/innodb/alter table (read PK and internal sort) |            280 |           1245 |
+------------------------------------------------------+----------------+----------------+
1 row in set (0.01 sec)
</pre><p>
                    The <a class="link" href="performance-schema.html#events-stages-current-table" title="25.12.5.1&nbsp;The events_stages_current Table"><code class="literal">events_stages_current</code></a> table
                    returns an empty set if the <a class="link" href="sql-syntax.html#alter-table" title="13.1.8&nbsp;ALTER TABLE Syntax"><code class="literal">ALTER
                    TABLE</code></a> operation has completed. In this case, you can
                    check the <a class="link" href="performance-schema.html#events-stages-history-table" title="25.12.5.2&nbsp;The events_stages_history Table"><code class="literal">events_stages_history</code></a>
                    table to view event data for the completed operation. For
                    example:
                </p><p style="color:blue;">如果alter table操作已完成，则events_stages_current table返回一个空集合。在这种情况下，可以检查events_stages_history表以查看已完成操作的事件数据。例如：</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT EVENT_NAME, WORK_COMPLETED, WORK_ESTIMATED</code></strong>
       <strong class="userinput"><code>FROM performance_schema.events_stages_history;</code></strong>
+------------------------------------------------------+----------------+----------------+
| EVENT_NAME                                           | WORK_COMPLETED | WORK_ESTIMATED |
+------------------------------------------------------+----------------+----------------+
| stage/innodb/alter table (read PK and internal sort) |            886 |           1213 |
| stage/innodb/alter table (flush)                     |           1213 |           1213 |
| stage/innodb/alter table (log apply table)           |           1597 |           1597 |
| stage/innodb/alter table (end)                       |           1597 |           1597 |
| stage/innodb/alter table (log apply table)           |           1981 |           1981 |
+------------------------------------------------------+----------------+----------------+
5 rows in set (0.00 sec)
</pre><p>
                    As shown above, the <code class="literal">WORK_ESTIMATED</code> value
                    was revised during <code class="literal">ALTER TABLE</code> processing.
                    The estimated work after completion of the initial stage is
                    1213. When <code class="literal">ALTER TABLE</code> processing
                    completed, <code class="literal">WORK_ESTIMATED</code> was set to the
                    actual value, which is 1981.
                </p><p style="color:blue;">如上所示，在alter table处理期间修改了work_估计值。初期完工后的预计工作量为1213。当alter table处理完成时，work_estimated被设置为实际值，即1981。</p></li></ol>
            </div>

        </div>
        <div class="section">
            <div class="titlepage">
                <div>
                    <div>
                        <h3 class="title"><a name="monitor-innodb-mutex-waits-performance-schema"></a>14.16.2&nbsp;Monitoring InnoDB Mutex Waits Using Performance Schema</h3>

                    </div>

                </div>

            </div>
            <a class="indexterm" name="idm140286806464592"></a><a class="indexterm" name="idm140286806463104"></a><p>
            A mutex is a synchronization mechanism used in the code to enforce
            that only one thread at a given time can have access to a common
            resource. When two or more threads executing in the server need to
            access the same resource, the threads compete against each other.
            The first thread to obtain a lock on the mutex causes the other
            threads to wait until the lock is released.
        </p><p style="color:blue;">互斥锁是代码中使用的一种同步机制，用于强制在给定时间只有一个线程可以访问公共资源。当服务器中执行的两个或多个线程需要访问同一资源时，这些线程将相互竞争。第一个获取互斥锁的线程会导致其他线程等待锁被释放。</p><p>
            For <code class="literal">InnoDB</code> mutexes that are instrumented, mutex
            waits can be monitored using
            <a class="link" href="performance-schema.html" title="Chapter&nbsp;25&nbsp;MySQL Performance Schema">Performance Schema</a>. Wait
            event data collected in Performance Schema tables can help
            identify mutexes with the most waits or the greatest total wait
            time, for example.
        </p><p style="color:blue;">对于插入指令的innodb互斥体，可以使用性能模式监视互斥体等待。例如，在性能架构表中收集的等待事件数据可以帮助识别等待次数最多或总等待时间最长的互斥体。</p><p>
            The following example demonstrates how to enable
            <code class="literal">InnoDB</code> mutex wait instruments, how to enable
            associated consumers, and how to query wait event data.
        </p><p style="color:blue;">下面的示例演示如何启用innodb mutex wait instruments，如何启用关联的使用者，以及如何查询等待事件数据。</p>
            <div class="orderedlist">
                <ol class="orderedlist" type="1"><li class="listitem"><p>
                    To view available <code class="literal">InnoDB</code> mutex wait
                    instruments, query the Performance Schema
                    <a class="link" href="performance-schema.html#setup-instruments-table" title="25.12.2.3&nbsp;The setup_instruments Table"><code class="literal">setup_instruments</code></a> table, as shown
                    below. All <code class="literal">InnoDB</code> mutex wait instruments
                    are disabled by default.
                </p><p style="color:blue;">要查看可用的innodb mutex wait instruments，请查询performance schema setup_instruments表，如下所示。默认情况下，所有innodb mutex等待工具都被禁用。</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT *</code></strong>
       <strong class="userinput"><code>FROM performance_schema.setup_instruments</code></strong>
       <strong class="userinput"><code>WHERE NAME LIKE '%wait/synch/mutex/innodb%';</code></strong>
+-------------------------------------------------------+---------+-------+
| NAME                                                  | ENABLED | TIMED |
+-------------------------------------------------------+---------+-------+
| wait/synch/mutex/innodb/commit_cond_mutex             | NO      | NO    |
| wait/synch/mutex/innodb/innobase_share_mutex          | NO      | NO    |
| wait/synch/mutex/innodb/autoinc_mutex                 | NO      | NO    |
| wait/synch/mutex/innodb/buf_pool_mutex                | NO      | NO    |
| wait/synch/mutex/innodb/buf_pool_zip_mutex            | NO      | NO    |
| wait/synch/mutex/innodb/cache_last_read_mutex         | NO      | NO    |
| wait/synch/mutex/innodb/dict_foreign_err_mutex        | NO      | NO    |
| wait/synch/mutex/innodb/dict_sys_mutex                | NO      | NO    |
| wait/synch/mutex/innodb/recalc_pool_mutex             | NO      | NO    |
| wait/synch/mutex/innodb/file_format_max_mutex         | NO      | NO    |
| wait/synch/mutex/innodb/fil_system_mutex              | NO      | NO    |
| wait/synch/mutex/innodb/flush_list_mutex              | NO      | NO    |
| wait/synch/mutex/innodb/fts_bg_threads_mutex          | NO      | NO    |
| wait/synch/mutex/innodb/fts_delete_mutex              | NO      | NO    |
| wait/synch/mutex/innodb/fts_optimize_mutex            | NO      | NO    |
| wait/synch/mutex/innodb/fts_doc_id_mutex              | NO      | NO    |
| wait/synch/mutex/innodb/log_flush_order_mutex         | NO      | NO    |
| wait/synch/mutex/innodb/hash_table_mutex              | NO      | NO    |
| wait/synch/mutex/innodb/ibuf_bitmap_mutex             | NO      | NO    |
| wait/synch/mutex/innodb/ibuf_mutex                    | NO      | NO    |
| wait/synch/mutex/innodb/ibuf_pessimistic_insert_mutex | NO      | NO    |
| wait/synch/mutex/innodb/log_sys_mutex                 | NO      | NO    |
| wait/synch/mutex/innodb/page_zip_stat_per_index_mutex | NO      | NO    |
| wait/synch/mutex/innodb/purge_sys_pq_mutex            | NO      | NO    |
| wait/synch/mutex/innodb/recv_sys_mutex                | NO      | NO    |
| wait/synch/mutex/innodb/recv_writer_mutex             | NO      | NO    |
| wait/synch/mutex/innodb/redo_rseg_mutex               | NO      | NO    |
| wait/synch/mutex/innodb/noredo_rseg_mutex             | NO      | NO    |
| wait/synch/mutex/innodb/rw_lock_list_mutex            | NO      | NO    |
| wait/synch/mutex/innodb/rw_lock_mutex                 | NO      | NO    |
| wait/synch/mutex/innodb/srv_dict_tmpfile_mutex        | NO      | NO    |
| wait/synch/mutex/innodb/srv_innodb_monitor_mutex      | NO      | NO    |
| wait/synch/mutex/innodb/srv_misc_tmpfile_mutex        | NO      | NO    |
| wait/synch/mutex/innodb/srv_monitor_file_mutex        | NO      | NO    |
| wait/synch/mutex/innodb/buf_dblwr_mutex               | NO      | NO    |
| wait/synch/mutex/innodb/trx_undo_mutex                | NO      | NO    |
| wait/synch/mutex/innodb/trx_pool_mutex                | NO      | NO    |
| wait/synch/mutex/innodb/trx_pool_manager_mutex        | NO      | NO    |
| wait/synch/mutex/innodb/srv_sys_mutex                 | NO      | NO    |
| wait/synch/mutex/innodb/lock_mutex                    | NO      | NO    |
| wait/synch/mutex/innodb/lock_wait_mutex               | NO      | NO    |
| wait/synch/mutex/innodb/trx_mutex                     | NO      | NO    |
| wait/synch/mutex/innodb/srv_threads_mutex             | NO      | NO    |
| wait/synch/mutex/innodb/rtr_active_mutex              | NO      | NO    |
| wait/synch/mutex/innodb/rtr_match_mutex               | NO      | NO    |
| wait/synch/mutex/innodb/rtr_path_mutex                | NO      | NO    |
| wait/synch/mutex/innodb/rtr_ssn_mutex                 | NO      | NO    |
| wait/synch/mutex/innodb/trx_sys_mutex                 | NO      | NO    |
| wait/synch/mutex/innodb/zip_pad_mutex                 | NO      | NO    |
+-------------------------------------------------------+---------+-------+
49 rows in set (0.02 sec)
</pre></li><li class="listitem"><p>
                    Some <code class="literal">InnoDB</code> mutex instances are created at
                    server startup and are only instrumented if the associated
                    instrument is also enabled at server startup. To ensure that
                    all <code class="literal">InnoDB</code> mutex instances are instrumented
                    and enabled, add the following
                    <code class="literal">performance-schema-instrument</code> rule to your
                    MySQL configuration file:
                </p><p style="color:blue;">有些innodb mutex实例是在服务器启动时创建的，只有在服务器启动时启用了相关的工具时才会被检测。要确保所有innodb mutex实例都已检测并启用，请将以下性能架构检测规则添加到mysql配置文件中：</p><pre data-lang="ini" class="programlisting">performance-schema-instrument='wait/synch/mutex/innodb/%=ON'
</pre><p>
                    If you do not require wait event data for all
                    <code class="literal">InnoDB</code> mutexes, you can disable specific
                    instruments by adding additional
                    <code class="literal">performance-schema-instrument</code> rules to your
                    MySQL configuration file. For example, to disable
                    <code class="literal">InnoDB</code> mutex wait event instruments related
                    to full-text search, add the following rule:
                </p><p style="color:blue;">如果不需要所有innodb互斥体的wait事件数据，可以通过向mysql配置文件添加额外的性能模式工具规则来禁用特定的工具。例如，要禁用与全文搜索相关的innodb mutex wait事件工具，请添加以下规则：</p><pre data-lang="ini" class="programlisting">performance-schema-instrument='wait/synch/mutex/innodb/fts%=OFF'
</pre>
                    <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">

                        <div class="admon-title">
                            Note
                        </div>
                        <p>
                            Rules with a longer prefix such as
                            <code class="literal">wait/synch/mutex/innodb/fts%</code> take
                            precedence over rules with shorter prefixes such as
                            <code class="literal">wait/synch/mutex/innodb/%</code>.
                        </p><p style="color:blue;">前缀较长的规则（如wait/synch/mutex/innodb/fts%）优先于前缀较短的规则（如wait/synch/mutex/innodb/%）。</p>
                    </div>
                    <p>
                        After adding the
                        <code class="literal">performance-schema-instrument</code> rules to your
                        configuration file, restart the server. All the
                        <code class="literal">InnoDB</code> mutexes except for those related to
                        full text search are enabled. To verify, query the
                        <a class="link" href="performance-schema.html#setup-instruments-table" title="25.12.2.3&nbsp;The setup_instruments Table"><code class="literal">setup_instruments</code></a> table. The
                        <code class="literal">ENABLED</code> and <code class="literal">TIMED</code>
                        columns should be set to <code class="literal">YES</code> for the
                        instruments that you enabled.
                    </p><p style="color:blue;">将性能架构工具规则添加到配置文件中后，重新启动服务器。除与全文搜索相关的互斥外，所有innodb互斥都已启用。要验证，请查询setup_instruments表。对于您启用的仪器，enabled和timed列应设置为yes。</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT *</code></strong>
       <strong class="userinput"><code>FROM performance_schema.setup_instruments</code></strong>
       <strong class="userinput"><code>WHERE NAME LIKE '%wait/synch/mutex/innodb%';</code></strong>
+-------------------------------------------------------+---------+-------+
| NAME                                                  | ENABLED | TIMED |
+-------------------------------------------------------+---------+-------+
| wait/synch/mutex/innodb/commit_cond_mutex             | YES     | YES   |
| wait/synch/mutex/innodb/innobase_share_mutex          | YES     | YES   |
| wait/synch/mutex/innodb/autoinc_mutex                 | YES     | YES   |
...
| wait/synch/mutex/innodb/zip_pad_mutex                 | YES     | YES   |
+-------------------------------------------------------+---------+-------+
49 rows in set (0.00 sec)
</pre></li><li class="listitem"><p>
                    Enable wait event consumers by updating the
                    <a class="link" href="performance-schema.html#setup-consumers-table" title="25.12.2.2&nbsp;The setup_consumers Table"><code class="literal">setup_consumers</code></a> table. Wait event
                    consumers are disabled by default.
                </p><p style="color:blue;">通过更新setup\u consumers表启用等待事件使用者。默认情况下禁用等待事件使用者。</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>UPDATE performance_schema.setup_consumers</code></strong>
       <strong class="userinput"><code>SET enabled = 'YES'</code></strong>
       <strong class="userinput"><code>WHERE name like 'events_waits%';</code></strong>
Query OK, 3 rows affected (0.00 sec)
Rows matched: 3  Changed: 3  Warnings: 0
</pre><p>
                    You can verify that wait event consumers are enabled by
                    querying the <a class="link" href="performance-schema.html#setup-consumers-table" title="25.12.2.2&nbsp;The setup_consumers Table"><code class="literal">setup_consumers</code></a>
                    table. The <a class="link" href="performance-schema.html#events-waits-current-table" title="25.12.4.1&nbsp;The events_waits_current Table"><code class="literal">events_waits_current</code></a>,
                    <a class="link" href="performance-schema.html#events-waits-history-table" title="25.12.4.2&nbsp;The events_waits_history Table"><code class="literal">events_waits_history</code></a>, and
                    <a class="link" href="performance-schema.html#events-waits-history-long-table" title="25.12.4.3&nbsp;The events_waits_history_long Table"><code class="literal">events_waits_history_long</code></a>
                    consumers should be enabled.
                </p><p style="color:blue;">您可以通过查询setup_consumers表来验证是否启用了等待事件使用者。应启用事件等待当前、事件等待历史和事件等待历史消费者。</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT * FROM performance_schema.setup_consumers;</code></strong>
+----------------------------------+---------+
| NAME                             | ENABLED |
+----------------------------------+---------+
| events_stages_current            | NO      |
| events_stages_history            | NO      |
| events_stages_history_long       | NO      |
| events_statements_current        | YES     |
| events_statements_history        | YES     |
| events_statements_history_long   | NO      |
| events_transactions_current      | YES     |
| events_transactions_history      | YES     |
| events_transactions_history_long | NO      |
| events_waits_current             | YES     |
| events_waits_history             | YES     |
| events_waits_history_long        | YES     |
| global_instrumentation           | YES     |
| thread_instrumentation           | YES     |
| statements_digest                | YES     |
+----------------------------------+---------+
15 rows in set (0.00 sec)
</pre></li><li class="listitem"><p>
                    Once instruments and consumers are enabled, run the workload
                    that you want to monitor. In this example, the
                    <a class="link" href="programs.html#mysqlslap" title="4.5.8&nbsp;mysqlslap — Load Emulation Client"><span class="command"><strong>mysqlslap</strong></span></a> load emulation client is used to
                    simulate a workload.
                </p><p style="color:blue;">启用仪器和使用者后，运行要监视的工作负载。在本例中，mysqlslap负载模拟客户端用于模拟工作负载。</p><pre data-lang="terminal" class="programlisting">shell&gt; <strong class="userinput"><code>./mysqlslap --auto-generate-sql --concurrency=100 --iterations=10</code></strong>
       <strong class="userinput"><code>--number-of-queries=1000 --number-char-cols=6 --number-int-cols=6;</code></strong>
</pre></li><li class="listitem"><p>
                    Query the wait event data. In this example, wait event data is
                    queried from the
                    <a class="link" href="performance-schema.html#wait-summary-tables" title="25.12.15.1&nbsp;Wait Event Summary Tables"><code class="literal">events_waits_summary_global_by_event_name</code></a>
                    table which aggregates data found in the
                    <a class="link" href="performance-schema.html#events-waits-current-table" title="25.12.4.1&nbsp;The events_waits_current Table"><code class="literal">events_waits_current</code></a>,
                    <a class="link" href="performance-schema.html#events-waits-history-table" title="25.12.4.2&nbsp;The events_waits_history Table"><code class="literal">events_waits_history</code></a>, and
                    <a class="link" href="performance-schema.html#events-waits-history-long-table" title="25.12.4.3&nbsp;The events_waits_history_long Table"><code class="literal">events_waits_history_long</code></a> tables.
                    Data is summarized by event name
                    (<code class="literal">EVENT_NAME</code>), which is the name of the
                    instrument that produced the event. Summarized data includes:
                </p><p style="color:blue;">查询等待事件数据。在本例中，从events_waits_global_by_event_name表查询等待事件数据，该表汇总了events_waits_current、events_waits_history和events_waits_history long表中的数据。数据按事件名称（event_name）汇总，该名称是生成事件的工具的名称。汇总数据包括：</p>
                    <div class="itemizedlist">
                        <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                            <code class="literal">COUNT_STAR</code>
                        </p><p style="color:blue;">星伯爵</p><p>
                            The number of summarized wait events.
                        </p><p style="color:blue;">汇总的等待事件数。</p></li><li class="listitem"><p>
                            <code class="literal">SUM_TIMER_WAIT</code>
                        </p><p style="color:blue;">计时器等待</p><p>
                            The total wait time of the summarized timed wait events.
                        </p><p style="color:blue;">汇总的定时等待事件的总等待时间。</p></li><li class="listitem"><p>
                            <code class="literal">MIN_TIMER_WAIT</code>
                        </p><p style="color:blue;">定时器等待</p><p>
                            The minimum wait time of the summarized timed wait events.
                        </p><p style="color:blue;">汇总的定时等待事件的最小等待时间。</p></li><li class="listitem"><p>
                            <code class="literal">AVG_TIMER_WAIT</code>
                        </p><p style="color:blue;">平均计时器等待</p><p>
                            The average wait time of the summarized timed wait events.
                        </p><p style="color:blue;">汇总的定时等待事件的平均等待时间。</p></li><li class="listitem"><p>
                            <code class="literal">MAX_TIMER_WAIT</code>
                        </p><p style="color:blue;">最大计时器等待</p><p>
                            The maximum wait time of the summarized timed wait events.
                        </p><p style="color:blue;">汇总定时等待事件的最大等待时间。</p></li></ul>
                    </div>
                    <p>
                        The following query returns the instrument name
                        (<code class="literal">EVENT_NAME</code>), the number of wait events
                        (<code class="literal">COUNT_STAR</code>), and the total wait time for
                        the events for that instrument
                        (<code class="literal">SUM_TIMER_WAIT</code>). Because waits are timed
                        in picoseconds (trillionths of a second) by default, wait
                        times are divided by 1000000000 to show wait times in
                        milliseconds. Data is presented in descending order, by the
                        number of summarized wait events
                        (<code class="literal">COUNT_STAR</code>). You can adjust the
                        <code class="literal">ORDER BY</code> clause to order the data by total
                        wait time.
                    </p><p style="color:blue;">以下查询返回仪器名称（event_name）、等待事件数（count_star）和该仪器事件的总等待时间（sum_timer_wait）。由于默认情况下等待时间以皮秒（万亿分之一秒）为单位，因此等待时间除以100000000以毫秒为单位显示等待时间。数据按汇总的等待事件数（count_star）降序显示。您可以调整ORDERBY子句以按总等待时间排序数据。</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT EVENT_NAME, COUNT_STAR, SUM_TIMER_WAIT/1000000000 SUM_TIMER_WAIT_MS</code></strong>
       <strong class="userinput"><code>FROM performance_schema.events_waits_summary_global_by_event_name</code></strong>
       <strong class="userinput"><code>WHERE SUM_TIMER_WAIT &gt; 0 AND EVENT_NAME LIKE 'wait/synch/mutex/innodb/%'</code></strong>
       <strong class="userinput"><code>ORDER BY COUNT_STAR DESC;</code></strong>
+--------------------------------------------------+------------+-------------------+
| EVENT_NAME                                       | COUNT_STAR | SUM_TIMER_WAIT_MS |
+--------------------------------------------------+------------+-------------------+
| wait/synch/mutex/innodb/os_mutex                 |      78831 |           10.3283 |
| wait/synch/mutex/innodb/log_sys_mutex            |      41488 |         6510.3233 |
| wait/synch/mutex/innodb/trx_sys_mutex            |      29770 |         1107.9687 |
| wait/synch/mutex/innodb/lock_mutex               |      24212 |          104.0724 |
| wait/synch/mutex/innodb/trx_mutex                |      22756 |            1.9421 |
| wait/synch/mutex/innodb/rseg_mutex               |      20333 |            3.6220 |
| wait/synch/mutex/innodb/dict_sys_mutex           |      13422 |            2.2284 |
| wait/synch/mutex/innodb/mutex_list_mutex         |      12694 |          344.1164 |
| wait/synch/mutex/innodb/fil_system_mutex         |       9208 |            0.9542 |
| wait/synch/mutex/innodb/rw_lock_list_mutex       |       8304 |            0.1794 |
| wait/synch/mutex/innodb/trx_undo_mutex           |       6190 |            0.6801 |
| wait/synch/mutex/innodb/buf_pool_mutex           |       2869 |           29.4623 |
| wait/synch/mutex/innodb/innobase_share_mutex     |       2005 |            0.1349 |
| wait/synch/mutex/innodb/flush_list_mutex         |       1274 |            0.1300 |
| wait/synch/mutex/innodb/file_format_max_mutex    |       1016 |            0.0469 |
| wait/synch/mutex/innodb/purge_sys_bh_mutex       |       1004 |            0.0326 |
| wait/synch/mutex/innodb/buf_dblwr_mutex          |        640 |            0.0437 |
| wait/synch/mutex/innodb/log_flush_order_mutex    |        437 |            0.0510 |
| wait/synch/mutex/innodb/recv_sys_mutex           |        394 |            0.0202 |
| wait/synch/mutex/innodb/srv_sys_mutex            |        169 |            0.5259 |
| wait/synch/mutex/innodb/lock_wait_mutex          |        154 |            0.1172 |
| wait/synch/mutex/innodb/ibuf_mutex               |          9 |            0.0027 |
| wait/synch/mutex/innodb/srv_innodb_monitor_mutex |          2 |            0.0009 |
| wait/synch/mutex/innodb/ut_list_mutex            |          1 |            0.0001 |
| wait/synch/mutex/innodb/recv_writer_mutex        |          1 |            0.0005 |
+--------------------------------------------------+------------+-------------------+
25 rows in set (0.01 sec)
</pre>
                    <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">

                        <div class="admon-title">
                            Note
                        </div>
                        <p>
                            The preceding result set includes wait event data produced
                            during the startup process. To exclude this data, you can
                            truncate the
                            <a class="link" href="performance-schema.html#wait-summary-tables" title="25.12.15.1&nbsp;Wait Event Summary Tables"><code class="literal">events_waits_summary_global_by_event_name</code></a>
                            table immediately after startup and before running your
                            workload. However, the truncate operation itself may produce
                            a negligible amount wait event data.
                        </p><p style="color:blue;">前面的结果集包括启动过程中生成的等待事件数据。要排除此数据，可以在启动后和运行工作负载之前立即截断events_waits_global_by_event_name表。但是，truncate操作本身可能会产生可忽略的等待事件数据量。</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>TRUNCATE performance_schema.events_waits_summary_global_by_event_name;</code></strong>
</pre>
                    </div>
                </li></ol>
            </div>

        </div>

    </div>
    <div class="section">
        <div class="titlepage">
            <div>
                <div>
                    <h2 class="title" style="clear: both"><a name="innodb-monitors"></a>14.17&nbsp;InnoDB Monitors</h2>

                </div>

            </div>

        </div>
        <div class="toc">
            <dl class="toc"><dt><span class="section"><a href="innodb-storage-engine.html#innodb-monitor-types">14.17.1 InnoDB Monitor Types</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-enabling-monitors">14.17.2 Enabling InnoDB Monitors</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-standard-monitor">14.17.3 InnoDB Standard Monitor and Lock Monitor Output</a></span></dt></dl>
        </div>
        <a class="indexterm" name="idm140286806367536"></a><a class="indexterm" name="idm140286806366464"></a><p>
        <code class="literal">InnoDB</code> monitors provide information about the
        <code class="literal">InnoDB</code> internal state. This information is useful
        for performance tuning.
    </p><p style="color:blue;">InnoDB监视器提供有关InnoDB内部状态的信息。此信息对于性能调整非常有用。</p>
        <div class="section">

            <div class="titlepage">
                <div>
                    <div>
                        <h3 class="title"><a name="innodb-monitor-types"></a>14.17.1&nbsp;InnoDB Monitor Types</h3>
                    </div>
                </div>
            </div>
            <a class="indexterm" name="idm140286806362320"></a><a class="indexterm" name="idm140286806361248"></a><p>
            There are two types of <code class="literal">InnoDB</code> monitor:
        </p><p style="color:blue;">InnoDB监视器有两种类型：</p>
            <div class="itemizedlist">
                <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                    The standard <code class="literal">InnoDB</code> Monitor displays the
                    following types of information:
                </p><p style="color:blue;">标准innodb监视器显示以下类型的信息：</p>
                    <div class="itemizedlist">
                        <ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
                            Work done by the main background thread
                        </p><p style="color:blue;">主后台线程完成的工作</p></li><li class="listitem"><p>
                            Semaphore waits
                        </p><p style="color:blue;">信号量等待</p></li><li class="listitem"><p>
                            Data about the most recent foreign key and deadlock errors
                        </p><p style="color:blue;">有关最新外键和死锁错误的数据</p></li><li class="listitem"><p>
                            Lock waits for transactions
                        </p><p style="color:blue;">锁等待事务</p></li><li class="listitem"><p>
                            Table and record locks held by active transactions
                        </p><p style="color:blue;">活动事务持有的表和记录锁</p></li><li class="listitem"><p>
                            Pending I/O operations and related statistics
                        </p><p style="color:blue;">挂起的I/O操作和相关统计信息</p></li><li class="listitem"><p>
                            Insert buffer and adaptive hash index statistics
                        </p><p style="color:blue;">插入缓冲区和自适应哈希索引统计信息</p></li><li class="listitem"><p>
                            Redo log data
                        </p><p style="color:blue;">重做日志数据</p></li><li class="listitem"><p>
                            Buffer pool statistics
                        </p><p style="color:blue;">缓冲池统计信息</p></li><li class="listitem"><p>
                            Row operation data
                        </p><p style="color:blue;">行操作数据</p></li></ul>
                    </div>
                </li><li class="listitem"><p>
                    The <code class="literal">InnoDB</code> Lock Monitor prints additional
                    lock information as part of the standard
                    <code class="literal">InnoDB</code> Monitor output.
                </p><p style="color:blue;">innodb lock monitor作为标准innodb monitor输出的一部分打印额外的锁信息。</p></li></ul>
            </div>

        </div>
        <div class="section">
            <div class="titlepage">
                <div>
                    <div>
                        <h3 class="title"><a name="innodb-enabling-monitors"></a>14.17.2&nbsp;Enabling InnoDB Monitors</h3>

                    </div>

                </div>

            </div>
            <a class="indexterm" name="idm140286806344576"></a><a class="indexterm" name="idm140286806343088"></a><p>
            When <code class="literal">InnoDB</code> monitors are enabled for periodic
            output, <code class="literal">InnoDB</code> writes the output to
            <a class="link" href="programs.html#mysqld" title="4.3.1&nbsp;mysqld — The MySQL Server"><span class="command"><strong>mysqld</strong></span></a> server standard error output
            (<code class="literal">stderr</code>) every 15 seconds, approximately.
        </p><p style="color:blue;">当NONDB监视器被启用用于周期性输出时，NONDB大约每隔15秒将输出写入myQLSD服务器标准错误输出（STDERR）。</p><p>
            <code class="literal">InnoDB</code> sends the monitor output to
            <code class="literal">stderr</code> rather than to <code class="literal">stdout</code>
            or fixed-size memory buffers to avoid potential buffer overflows.
        </p><p style="color:blue;">innodb将监视器输出发送到stderr，而不是stdout或固定大小的内存缓冲区，以避免潜在的缓冲区溢出。</p><p>
            On Windows, <code class="literal">stderr</code> is directed to the default
            log file unless configured otherwise. If you want to direct the
            output to the console window rather than to the error log, start
            the server from a command prompt in a console window with the
            <a class="link" href="server-administration.html#option_mysqld_console"><code class="option">--console</code></a> option. For more
            information, see <a class="xref" href="server-administration.html#error-log-windows" title="5.4.2.1&nbsp;Error Logging on Windows">Section&nbsp;5.4.2.1, “Error Logging on Windows”</a>.
        </p><p style="color:blue;">在windows上，除非另有配置，否则stderr将定向到默认日志文件。如果要将输出定向到控制台窗口而不是错误日志，请使用--console选项从控制台窗口中的命令提示符启动服务器。有关详细信息，请参阅第5.4.2.1节“在Windows上登录时出错”。</p><p>
            On Unix and Unix-like systems, <code class="literal">stderr</code> is
            typically directed to the terminal unless configured otherwise.
            For more information, see <a class="xref" href="server-administration.html#error-log-unix" title="5.4.2.2&nbsp;Error Logging on Unix and Unix-Like Systems">Section&nbsp;5.4.2.2, “Error Logging on Unix and Unix-Like Systems”</a>.
        </p><p style="color:blue;">在unix和类unix系统上，除非另有配置，否则stderr通常被定向到终端。有关更多信息，请参阅5.4.2.2节，“在Unix和类Unix系统上记录错误”。</p><p>
            <code class="literal">InnoDB</code> monitors should only be enabled when you
            actually want to see monitor information because output generation
            causes some performance decrement. Also, if monitor output is
            directed to the error log, the log may become quite large if you
            forget to disable the monitor later.
        </p><p style="color:blue;">InnoDB监视器应该只在您真正想查看监视器信息时启用，因为输出生成会导致一些性能下降。另外，如果监视器输出指向错误日志，如果您稍后忘记禁用监视器，日志可能会变得很大。</p>
            <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">

                <div class="admon-title">
                    Note
                </div>
                <p>
                    To assist with troubleshooting, <code class="literal">InnoDB</code>
                    temporarily enables standard <code class="literal">InnoDB</code> Monitor
                    output under certain conditions. For more information, see
                    <a class="xref" href="innodb-storage-engine.html#innodb-troubleshooting" title="14.21&nbsp;InnoDB Troubleshooting">Section&nbsp;14.21, “InnoDB Troubleshooting”</a>.
                </p><p style="color:blue;">为了帮助排除故障，innodb在某些情况下临时启用标准innodb监视器输出。有关更多信息，请参阅14.21节，“InnoDB故障排除”。</p>
            </div>
            <p>
                <code class="literal">InnoDB</code> monitor output begins with a header
                containing a timestamp and the monitor name. For example:
            </p><p style="color:blue;">innodb监视器输出以包含时间戳和监视器名称的头开头。例如：</p><pre data-lang="sql" class="programlisting">=====================================
2014-10-16 18:37:29 0x7fc2a95c1700 INNODB MONITOR OUTPUT
=====================================
</pre><p>
            The header for the standard <code class="literal">InnoDB</code> Monitor
            (<code class="literal">INNODB MONITOR OUTPUT</code>) is also used for the
            Lock Monitor because the latter produces the same output with the
            addition of extra lock information.
        </p><p style="color:blue;">标准innodb monitor（innodb monitor output）的报头也用于锁监视器，因为后者通过添加额外的锁信息产生相同的输出。</p><p>
            The <a class="link" href="innodb-storage-engine.html#sysvar_innodb_status_output"><code class="literal">innodb_status_output</code></a> and
            <a class="link" href="innodb-storage-engine.html#sysvar_innodb_status_output_locks"><code class="literal">innodb_status_output_locks</code></a> system
            variables are used to enable the standard
            <code class="literal">InnoDB</code> Monitor and <code class="literal">InnoDB</code>
            Lock Monitor.
        </p><p style="color:blue;">innodb_status_output和innodb_status_output_locks系统变量用于启用标准innodb监视器和innodb锁定监视器。</p><p>
            The <a class="link" href="security.html#priv_process"><code class="literal">PROCESS</code></a> privilege is required
            to enable or disable <code class="literal">InnoDB</code> Monitors.
        </p><p style="color:blue;">启用或禁用innodb监视器需要进程特权。</p>
            <h4><a name="idm140286806314192"></a>Enabling the Standard InnoDB Monitor</h4>
            <p>
                Enable the standard <code class="literal">InnoDB</code> Monitor by setting
                the <a class="link" href="innodb-storage-engine.html#sysvar_innodb_status_output"><code class="literal">innodb_status_output</code></a> system
                variable to <code class="literal">ON</code>.
            </p><p style="color:blue;">通过将innodb_status_output系统变量设置为ON，启用标准innodb监视器。</p><pre data-lang="sql" class="programlisting">SET GLOBAL innodb_status_output=ON;
</pre><p>
            To disable the standard <code class="literal">InnoDB</code> Monitor, set
            <a class="link" href="innodb-storage-engine.html#sysvar_innodb_status_output"><code class="literal">innodb_status_output</code></a> to
            <code class="literal">OFF</code>.
        </p><p style="color:blue;">要禁用标准innodb监视器，请将innodb_status_output设置为off。</p><p>
            When you shut down the server, the
            <a class="link" href="innodb-storage-engine.html#sysvar_innodb_status_output"><code class="literal">innodb_status_output</code></a> variable is
            set to the default <code class="literal">OFF</code> value.
        </p><p style="color:blue;">当您关闭服务器时，innodb_status_output变量设置为默认的off值。</p>
            <h4><a name="idm140286806303872"></a>Enabling the InnoDB Lock Monitor</h4>
            <p>
                <code class="literal">InnoDB</code> Lock Monitor data is printed with the
                <code class="literal">InnoDB</code> Standard Monitor output. Both the
                <code class="literal">InnoDB</code> Standard Monitor and
                <code class="literal">InnoDB</code> Lock Monitor must be enabled to have
                <code class="literal">InnoDB</code> Lock Monitor data printed periodically.
            </p><p style="color:blue;">innodb lock monitor数据由innodb标准监视器输出打印。必须启用InnoDB标准监视器和InnoDB锁定监视器才能定期打印InnoDB锁定监视器数据。</p><p>
            To enable the <code class="literal">InnoDB</code> Lock Monitor, set the
            <a class="link" href="innodb-storage-engine.html#sysvar_innodb_status_output_locks"><code class="literal">innodb_status_output_locks</code></a> system
            variable to <code class="literal">ON</code>. Both the
            <code class="literal">InnoDB</code> standard Monitor and
            <code class="literal">InnoDB</code> Lock Monitor must be enabled to have
            <code class="literal">InnoDB</code> Lock Monitor data printed periodically:
        </p><p style="color:blue;">要启用innodb lock monitor，请将innodb_status_output_locks系统变量设置为on。必须启用InnoDB标准监视器和InnoDB锁定监视器才能定期打印InnoDB锁定监视器数据：</p><pre data-lang="sql" class="programlisting">SET GLOBAL innodb_status_output=ON;
SET GLOBAL innodb_status_output_locks=ON;
</pre><p>
            To disable the <code class="literal">InnoDB</code> Lock Monitor, set
            <a class="link" href="innodb-storage-engine.html#sysvar_innodb_status_output_locks"><code class="literal">innodb_status_output_locks</code></a> to
            <code class="literal">OFF</code>. Set
            <a class="link" href="innodb-storage-engine.html#sysvar_innodb_status_output"><code class="literal">innodb_status_output</code></a> to
            <code class="literal">OFF</code> to also disable the
            <code class="literal">InnoDB</code> Standard Monitor.
        </p><p style="color:blue;">要禁用innodb lock监视器，请将innodb_status_output_locks设置为off。将innodb_status_output设置为off，以禁用innodb标准监视器。</p><p>
            When you shut down the server, the
            <a class="link" href="innodb-storage-engine.html#sysvar_innodb_status_output"><code class="literal">innodb_status_output</code></a> and
            <a class="link" href="innodb-storage-engine.html#sysvar_innodb_status_output_locks"><code class="literal">innodb_status_output_locks</code></a>
            variables are set to the default <code class="literal">OFF</code> value.
        </p><p style="color:blue;">关闭服务器时，innodb_status_output和innodb_status_output_locks变量设置为默认的关闭值。</p>
            <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">

                <div class="admon-title">
                    Note
                </div>
                <p>
                    To enable the <code class="literal">InnoDB</code> Lock Monitor for
                    <a class="link" href="sql-syntax.html#show-engine" title="13.7.5.15&nbsp;SHOW ENGINE Syntax"><code class="literal">SHOW ENGINE INNODB
                        STATUS</code></a> output, you are only required to enable
                    <a class="link" href="innodb-storage-engine.html#sysvar_innodb_status_output_locks"><code class="literal">innodb_status_output_locks</code></a>.
                </p><p style="color:blue;">要为show engine innodb status output启用innodb lock monitor，您只需要启用innodb_status_output_locks。</p>
            </div>
            <h4><a name="idm140286806279040"></a>Obtaining Standard InnoDB Monitor Output On Demand</h4>
            <p>
                As an alternative to enabling the standard
                <code class="literal">InnoDB</code> Monitor for periodic output, you can
                obtain standard <code class="literal">InnoDB</code> Monitor output on demand
                using the <a class="link" href="sql-syntax.html#show-engine" title="13.7.5.15&nbsp;SHOW ENGINE Syntax"><code class="literal">SHOW ENGINE
                INNODB STATUS</code></a> SQL statement, which fetches the output to
                your client program. If you are using the <a class="link" href="programs.html#mysql" title="4.5.1&nbsp;mysql — The MySQL Command-Line Client"><span class="command"><strong>mysql</strong></span></a>
                interactive client, the output is more readable if you replace the
                usual semicolon statement terminator with <code class="literal">\G</code>:
            </p><p style="color:blue;">除了启用标准innodb monitor进行周期性输出之外，还可以使用show engine innodb status sql语句按需获取标准innodb monitor输出，该语句将输出获取到客户端程序。如果您使用的是mysql交互客户端，那么如果将常用的分号语句结束符替换为\g，则输出更可读：</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>SHOW ENGINE INNODB STATUS\G</code></strong>
</pre><p>
            <a class="link" href="sql-syntax.html#show-engine" title="13.7.5.15&nbsp;SHOW ENGINE Syntax"><code class="literal">SHOW ENGINE INNODB
                STATUS</code></a> output also includes <code class="literal">InnoDB</code>
            Lock Monitor data if the <code class="literal">InnoDB</code> Lock Monitor is
            enabled.
        </p><p style="color:blue;">如果启用了innodb lock monitor，那么show engine innodb status output还包括innodb lock monitor数据。</p>
            <h4><a name="idm140286806268208"></a>Directing Standard InnoDB Monitor Output to a Status File</h4>
            <p>
                Standard <code class="literal">InnoDB</code> Monitor output can be enabled
                and directed to a status file by specifying the
                <code class="option">--innodb-status-file</code> option at startup. When this
                option is used, <code class="literal">InnoDB</code> creates a file named
                <code class="filename">innodb_status.<em class="replaceable"><code>pid</code></em></code>
                in the data directory and writes output to it every 15 seconds,
                approximately.
            </p><p style="color:blue;">通过在启动时指定--innodb status file选项，可以启用标准innodb监视器输出并将其定向到状态文件。当使用此选项时，InNODB在数据目录中创建名为YNObjStasuS.PID的文件，并大约每15秒写入一次输出。</p><p>
            <code class="literal">InnoDB</code> removes the status file when the server
            is shut down normally. If an abnormal shutdown occurs, the status
            file may have to be removed manually.
        </p><p style="color:blue;">当服务器正常关闭时，innodb会删除状态文件。如果发生异常关机，可能必须手动删除状态文件。</p><p>
            The <code class="option">--innodb-status-file</code> option is intended for
            temporary use, as output generation can affect performance, and
            the
            <code class="filename">innodb_status.<em class="replaceable"><code>pid</code></em></code>
            file can become quite large over time.
        </p><p style="color:blue;">--innodb status file选项是临时使用的，因为输出生成会影响性能，并且innodb_status.pid文件会随着时间的推移变得非常大。</p>
        </div>
        <div class="section">
            <div class="titlepage">
                <div>
                    <div>
                        <h3 class="title"><a name="innodb-standard-monitor"></a>14.17.3&nbsp;InnoDB Standard Monitor and Lock Monitor Output</h3>

                    </div>

                </div>

            </div>
            <a class="indexterm" name="idm140286806259424"></a><a class="indexterm" name="idm140286806257968"></a><a class="indexterm" name="idm140286806256480"></a><a class="indexterm" name="idm140286806255408"></a><p>
            The Lock Monitor is the same as the Standard Monitor except that
            it includes additional lock information. Enabling either monitor
            for periodic output turns on the same output stream, but the
            stream includes extra information if the Lock Monitor is enabled.
            For example, if you enable the Standard Monitor and Lock Monitor,
            that turns on a single output stream. The stream includes extra
            lock information until you disable the Lock Monitor.
        </p><p style="color:blue;">锁监视器与标准监视器相同，只是它包含额外的锁信息。为周期性输出启用任一监视器将打开同一输出流，但如果启用了锁监视器，则流将包含额外信息。例如，如果启用标准监视器和锁定监视器，则打开单个输出流。流包括额外的锁信息，直到您禁用锁监视器。</p><p>
            Standard Monitor output is limited to 1MB when produced using the
            <a class="link" href="sql-syntax.html#show-engine" title="13.7.5.15&nbsp;SHOW ENGINE Syntax"><code class="literal">SHOW ENGINE INNODB
                STATUS</code></a> statement. This limit does not apply to output
            written to tserver standard error output
            (<code class="literal">stderr</code>).
        </p><p style="color:blue;">使用show engine innodb status语句生成时，标准监视器输出限制为1MB。此限制不适用于写入tserver标准错误输出（stderr）的输出。</p><p>
            Example Standard Monitor output:
        </p><p style="color:blue;">标准监视器输出示例：</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>SHOW ENGINE INNODB STATUS\G</code></strong>
*************************** 1. row ***************************
  Type: InnoDB
  Name:
Status:
=====================================
2014-10-16 18:37:29 0x7fc2a95c1700 INNODB MONITOR OUTPUT
=====================================
Per second averages calculated from the last 20 seconds
-----------------
BACKGROUND THREAD
-----------------
srv_master_thread loops: 38 srv_active, 0 srv_shutdown, 252 srv_idle
srv_master_thread log flush and writes: 290
----------
SEMAPHORES
----------
OS WAIT ARRAY INFO: reservation count 119
OS WAIT ARRAY INFO: signal count 103
Mutex spin waits 0, rounds 0, OS waits 0
RW-shared spins 38, rounds 76, OS waits 38
RW-excl spins 2, rounds 9383715, OS waits 3
RW-sx spins 0, rounds 0, OS waits 0
Spin rounds per wait: 0.00 mutex, 2.00 RW-shared, 4691857.50 RW-excl,
0.00 RW-sx
------------------------
LATEST FOREIGN KEY ERROR
------------------------
2014-10-16 18:35:18 0x7fc2a95c1700 Transaction:
TRANSACTION 1814, ACTIVE 0 sec inserting
mysql tables in use 1, locked 1
4 lock struct(s), heap size 1136, 3 row lock(s), undo log entries 3
MySQL thread id 2, OS thread handle 140474041767680, query id 74 localhost
root update
INSERT INTO child VALUES
    (NULL, 1)
    , (NULL, 2)
    , (NULL, 3)
    , (NULL, 4)
    , (NULL, 5)
    , (NULL, 6)
Foreign key constraint fails for table `mysql`.`child`:
,
  CONSTRAINT `child_ibfk_1` FOREIGN KEY (`parent_id`) REFERENCES `parent`
  (`id`) ON DELETE CASCADE ON UPDATE CASCADE
Trying to add in child table, in index par_ind tuple:
DATA TUPLE: 2 fields;
 0: len 4; hex 80000003; asc     ;;
 1: len 4; hex 80000003; asc     ;;

But in parent table `mysql`.`parent`, in index PRIMARY,
the closest match we can find is record:
PHYSICAL RECORD: n_fields 3; compact format; info bits 0
 0: len 4; hex 80000004; asc     ;;
 1: len 6; hex 00000000070a; asc       ;;
 2: len 7; hex aa0000011d0134; asc       4;;

------------------------
LATEST DETECTED DEADLOCK
------------------------
2014-10-16 18:36:30 0x7fc2a95c1700
*** (1) TRANSACTION:
TRANSACTION 1824, ACTIVE 9 sec starting index read
mysql tables in use 1, locked 1
LOCK WAIT 2 lock struct(s), heap size 1136, 1 row lock(s)
MySQL thread id 3, OS thread handle 140474041501440, query id 80 localhost
root updating
DELETE FROM t WHERE i = 1
*** (1) WAITING FOR THIS LOCK TO BE GRANTED:
RECORD LOCKS space id 35 page no 3 n bits 72 index GEN_CLUST_INDEX of table
`mysql`.`t` trx id 1824 lock_mode X waiting
Record lock, heap no 2 PHYSICAL RECORD: n_fields 4; compact format; info
bits 0
 0: len 6; hex 000000000200; asc       ;;
 1: len 6; hex 00000000071f; asc       ;;
 2: len 7; hex b80000012b0110; asc     +  ;;
 3: len 4; hex 80000001; asc     ;;

*** (2) TRANSACTION:
TRANSACTION 1825, ACTIVE 29 sec starting index read
mysql tables in use 1, locked 1
4 lock struct(s), heap size 1136, 3 row lock(s)
MySQL thread id 2, OS thread handle 140474041767680, query id 81 localhost
root updating
DELETE FROM t WHERE i = 1
*** (2) HOLDS THE LOCK(S):
RECORD LOCKS space id 35 page no 3 n bits 72 index GEN_CLUST_INDEX of table
`mysql`.`t` trx id 1825 lock mode S
Record lock, heap no 1 PHYSICAL RECORD: n_fields 1; compact format; info
bits 0
 0: len 8; hex 73757072656d756d; asc supremum;;

Record lock, heap no 2 PHYSICAL RECORD: n_fields 4; compact format; info bits 0
 0: len 6; hex 000000000200; asc       ;;
 1: len 6; hex 00000000071f; asc       ;;
 2: len 7; hex b80000012b0110; asc     +  ;;
 3: len 4; hex 80000001; asc     ;;

*** (2) WAITING FOR THIS LOCK TO BE GRANTED:
RECORD LOCKS space id 35 page no 3 n bits 72 index GEN_CLUST_INDEX of table
`mysql`.`t` trx id 1825 lock_mode X waiting
Record lock, heap no 2 PHYSICAL RECORD: n_fields 4; compact format; info
bits 0
 0: len 6; hex 000000000200; asc       ;;
 1: len 6; hex 00000000071f; asc       ;;
 2: len 7; hex b80000012b0110; asc     +  ;;
 3: len 4; hex 80000001; asc     ;;

*** WE ROLL BACK TRANSACTION (1)
------------
TRANSACTIONS
------------
Trx id counter 1950
Purge done for trx's n:o &lt; 1933 undo n:o &lt; 0 state: running but idle
History list length 23
LIST OF TRANSACTIONS FOR EACH SESSION:
---TRANSACTION 421949033065200, not started
0 lock struct(s), heap size 1136, 0 row lock(s)
---TRANSACTION 421949033064280, not started
0 lock struct(s), heap size 1136, 0 row lock(s)
---TRANSACTION 1949, ACTIVE 0 sec inserting
mysql tables in use 1, locked 1
8 lock struct(s), heap size 1136, 1850 row lock(s), undo log entries 17415
MySQL thread id 4, OS thread handle 140474041235200, query id 176 localhost
root update
INSERT INTO `salaries` VALUES (55723,39746,'1997-02-25','1998-02-25'),
(55723,40758,'1998-02-25','1999-02-25'),(55723,44559,'1999-02-25','2000-02-25'),
(55723,44081,'2000-02-25','2001-02-24'),(55723,44112,'2001-02-24','2001-08-16'),
(55724,46461,'1996-12-06','1997-12-06'),(55724,48916,'1997-12-06','1998-12-06'),
(55724,51269,'1998-12-06','1999-12-06'),(55724,51932,'1999-12-06','2000-12-05'),
(55724,52617,'2000-12-05','2001-12-05'),(55724,56658,'2001-12-05','9999-01-01'),
(55725,40000,'1993-01-30','1994-01-30'),(55725,41472,'1994-01-30','1995-01-30'),
(55725,45293,'1995-01-30','1996-01-30'),(55725,473
--------
FILE I/O
--------
I/O thread 0 state: waiting for completed aio requests (insert buffer thread)
I/O thread 1 state: waiting for completed aio requests (log thread)
I/O thread 2 state: waiting for completed aio requests (read thread)
I/O thread 3 state: waiting for completed aio requests (read thread)
I/O thread 4 state: waiting for completed aio requests (read thread)
I/O thread 5 state: waiting for completed aio requests (read thread)
I/O thread 6 state: waiting for completed aio requests (write thread)
I/O thread 7 state: waiting for completed aio requests (write thread)
I/O thread 8 state: waiting for completed aio requests (write thread)
I/O thread 9 state: waiting for completed aio requests (write thread)
Pending normal aio reads: 0 [0, 0, 0, 0] , aio writes: 0 [0, 0, 0, 0] ,
 ibuf aio reads: 0, log i/o's: 0, sync i/o's: 0
Pending flushes (fsync) log: 0; buffer pool: 0
224 OS file reads, 5770 OS file writes, 803 OS fsyncs
0.00 reads/s, 0 avg bytes/read, 264.84 writes/s, 23.05 fsyncs/s
-------------------------------------
INSERT BUFFER AND ADAPTIVE HASH INDEX
-------------------------------------
Ibuf: size 1, free list len 0, seg size 2, 0 merges
merged operations:
 insert 0, delete mark 0, delete 0
discarded operations:
 insert 0, delete mark 0, delete 0
Hash table size 4425293, node heap has 444 buffer(s)
68015.25 hash searches/s, 106259.24 non-hash searches/s
---
LOG
---
Log sequence number 165913808
Log flushed up to   164814979
Pages flushed up to 141544038
Last checkpoint at  130503656
0 pending log flushes, 0 pending chkp writes
258 log i/o's done, 6.65 log i/o's/second
----------------------
BUFFER POOL AND MEMORY
----------------------
Total large memory allocated 2198863872
Dictionary memory allocated 776332
Buffer pool size   131072
Free buffers       124908
Database pages     5720
Old database pages 2071
Modified db pages  910
Pending reads 0
Pending writes: LRU 0, flush list 0, single page 0
Pages made young 4, not young 0
0.10 youngs/s, 0.00 non-youngs/s
Pages read 197, created 5523, written 5060
0.00 reads/s, 190.89 creates/s, 244.94 writes/s
Buffer pool hit rate 1000 / 1000, young-making rate 0 / 1000 not
0 / 1000
Pages read ahead 0.00/s, evicted without access 0.00/s, Random read
ahead 0.00/s
LRU len: 5720, unzip_LRU len: 0
I/O sum[0]:cur[0], unzip sum[0]:cur[0]
----------------------
INDIVIDUAL BUFFER POOL INFO
----------------------
---BUFFER POOL 0
Buffer pool size   65536
Free buffers       62412
Database pages     2899
Old database pages 1050
Modified db pages  449
Pending reads 0
Pending writes: LRU 0, flush list 0, single page 0
Pages made young 3, not young 0
0.05 youngs/s, 0.00 non-youngs/s
Pages read 107, created 2792, written 2586
0.00 reads/s, 92.65 creates/s, 122.89 writes/s
Buffer pool hit rate 1000 / 1000, young-making rate 0 / 1000 not 0 / 1000
Pages read ahead 0.00/s, evicted without access 0.00/s, Random read ahead
0.00/s
LRU len: 2899, unzip_LRU len: 0
I/O sum[0]:cur[0], unzip sum[0]:cur[0]
---BUFFER POOL 1
Buffer pool size   65536
Free buffers       62496
Database pages     2821
Old database pages 1021
Modified db pages  461
Pending reads 0
Pending writes: LRU 0, flush list 0, single page 0
Pages made young 1, not young 0
0.05 youngs/s, 0.00 non-youngs/s
Pages read 90, created 2731, written 2474
0.00 reads/s, 98.25 creates/s, 122.04 writes/s
Buffer pool hit rate 1000 / 1000, young-making rate 0 / 1000 not 0 / 1000
Pages read ahead 0.00/s, evicted without access 0.00/s, Random read ahead
0.00/s
LRU len: 2821, unzip_LRU len: 0
I/O sum[0]:cur[0], unzip sum[0]:cur[0]
--------------
ROW OPERATIONS
--------------
0 queries inside InnoDB, 0 queries in queue
0 read views open inside InnoDB
Process ID=35909, Main thread ID=140471692396288, state: sleeping
Number of rows inserted 1526363, updated 0, deleted 3, read 11
52671.72 inserts/s, 0.00 updates/s, 0.00 deletes/s, 0.00 reads/s
----------------------------
END OF INNODB MONITOR OUTPUT
============================
</pre>
            <div class="simplesect">

                <div class="titlepage">
                    <div>

                        <div class="simple">
                            <h4 class="title"><a name="innodb-standard-monitor-output-sections"></a>Standard Monitor Output Sections</h4>
                        </div>
                    </div>
                </div>
                <a class="indexterm" name="idm140286806222960"></a><p>
                For a description of each metric reported by the Standard
                Monitor, refer to the
                <a class="ulink" href="http://dev.mysql.com/doc/mysql-em-plugin/en/myoem-metrics.html" target="_top">Metrics</a>
                chapter in the
                <a class="ulink" href="http://dev.mysql.com/doc/mysql-em-plugin/en/" target="_top">Oracle
                    Enterprise Manager for MySQL Database User's Guide</a>.
            </p><p style="color:blue;">有关标准监视器报告的每个度量的说明，请参阅《Oracle Enterprise Manager for MySQL数据库用户指南》中的“度量”一章。</p>
                <div class="itemizedlist">
                    <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                        <code class="literal">Status</code>
                    </p><p style="color:blue;">地位</p><p>
                        This section shows the timestamp, the monitor name, and the
                        number of seconds that per-second averages are based on. The
                        number of seconds is the elapsed time between the current
                        time and the last time <code class="literal">InnoDB</code> Monitor
                        output was printed.
                    </p><p style="color:blue;">此部分显示时间戳、监视器名称和每秒平均基于的秒数。秒数是当前时间与上次打印InnoDB监视器输出之间经过的时间。</p></li><li class="listitem"><p>
                        <code class="literal">BACKGROUND THREAD</code>
                    </p><p style="color:blue;">背景线</p><p>
                        The <code class="literal">srv_master_thread</code> lines shows work
                        done by the main background thread.
                    </p><p style="color:blue;">srv_master_线程行显示主后台线程完成的工作。</p></li><li class="listitem"><p>
                        <code class="literal">SEMAPHORES</code>
                    </p><p style="color:blue;">信号量</p><p>
                        This section reports threads waiting for a semaphore and
                        statistics on how many times threads have needed a spin or a
                        wait on a mutex or a rw-lock semaphore. A large number of
                        threads waiting for semaphores may be a result of disk I/O,
                        or contention problems inside <code class="literal">InnoDB</code>.
                        Contention can be due to heavy parallelism of queries or
                        problems in operating system thread scheduling. Setting the
                        <a class="link" href="innodb-storage-engine.html#sysvar_innodb_thread_concurrency"><code class="literal">innodb_thread_concurrency</code></a>
                        system variable smaller than the default value might help in
                        such situations. The <code class="literal">Spin rounds per wait</code>
                        line shows the number of spinlock rounds per OS wait for a
                        mutex.
                    </p><p style="color:blue;">本节报告等待信号量的线程，并统计线程需要自旋或等待互斥锁或rw锁信号量的次数。大量等待信号量的线程可能是磁盘I/O或InnoDB内部争用问题的结果。争用可能是由于查询的高度并行性或操作系统线程调度问题造成的。在这种情况下，将innodb_thread_concurrency系统变量设置为小于默认值可能会有帮助。每个等待行的旋转轮数显示每个操作系统等待互斥锁的旋转轮数。</p><p>
                        Mutex metrics are reported by
                        <a class="link" href="sql-syntax.html#show-engine" title="13.7.5.15&nbsp;SHOW ENGINE Syntax"><code class="literal">SHOW ENGINE
                            INNODB MUTEX</code></a>.
                    </p><p style="color:blue;">互斥度量由show engine innodb mutex报告。</p></li><li class="listitem"><p>
                        <code class="literal">LATEST FOREIGN KEY ERROR</code>
                    </p><p style="color:blue;">最新外键错误</p><p>
                        This section provides information about the most recent
                        foreign key constraint error. It is not present if no such
                        error has occurred. The contents include the statement that
                        failed as well as information about the constraint that
                        failed and the referenced and referencing tables.
                    </p><p style="color:blue;">本节提供有关最新外键约束错误的信息。如果没有发生此类错误，则不存在。内容包括失败的语句以及有关失败的约束以及引用和引用表的信息。</p></li><li class="listitem"><p>
                        <code class="literal">LATEST DETECTED DEADLOCK</code>
                    </p><p style="color:blue;">最新检测到的死锁</p><p>
                        This section provides information about the most recent
                        deadlock. It is not present if no deadlock has occurred. The
                        contents show which transactions are involved, the statement
                        each was attempting to execute, the locks they have and
                        need, and which transaction <code class="literal">InnoDB</code>
                        decided to roll back to break the deadlock. The lock modes
                        reported in this section are explained in
                        <a class="xref" href="innodb-storage-engine.html#innodb-locking" title="14.7.1&nbsp;InnoDB Locking">Section&nbsp;14.7.1, “InnoDB Locking”</a>.
                    </p><p style="color:blue;">本节提供有关最新死锁的信息。如果没有发生死锁，则不存在。内容显示了涉及哪些事务，每个事务试图执行的语句，它们拥有和需要的锁，以及innodb决定回滚哪个事务以打破死锁。本节中报告的锁定模式在第14.7.1节“InnoDB锁定”中进行了说明。</p></li><li class="listitem"><p>
                        <code class="literal">TRANSACTIONS</code>
                    </p><p style="color:blue;">交易</p><p>
                        If this section reports lock waits, your applications might
                        have lock contention. The output can also help to trace the
                        reasons for transaction deadlocks.
                    </p><p style="color:blue;">如果此部分报告锁等待，则应用程序可能会发生锁争用。输出还可以帮助跟踪事务死锁的原因。</p></li><li class="listitem"><p>
                        <code class="literal">FILE I/O</code>
                    </p><p style="color:blue;">文件I/O</p><p>
                        This section provides information about threads that
                        <code class="literal">InnoDB</code> uses to perform various types of
                        I/O. The first few of these are dedicated to general
                        <code class="literal">InnoDB</code> processing. The contents also
                        display information for pending I/O operations and
                        statistics for I/O performance.
                    </p><p style="color:blue;">本节提供了有关innodb用于执行各种类型的i/o的线程的信息，其中前几个线程专用于一般的innodb处理。内容还显示挂起I/O操作的信息和I/O性能的统计信息。</p><p>
                        The number of these threads are controlled by the
                        <a class="link" href="innodb-storage-engine.html#sysvar_innodb_read_io_threads"><code class="literal">innodb_read_io_threads</code></a> and
                        <a class="link" href="innodb-storage-engine.html#sysvar_innodb_write_io_threads"><code class="literal">innodb_write_io_threads</code></a>
                        parameters. See <a class="xref" href="innodb-storage-engine.html#innodb-parameters" title="14.14&nbsp;InnoDB Startup Options and System Variables">Section&nbsp;14.14, “InnoDB Startup Options and System Variables”</a>.
                    </p><p style="color:blue;">这些线程的数量由innodb_read_io_threads和innodb_write_io_threads参数控制。参见14.14节，“InnoDB启动选项和系统变量”。</p></li><li class="listitem"><p>
                        <code class="literal">INSERT BUFFER AND ADAPTIVE HASH INDEX</code>
                    </p><p style="color:blue;">插入缓冲区和自适应哈希索引</p><p>
                        This section shows the status of the
                        <code class="literal">InnoDB</code> insert buffer (also referred to as
                        the <a class="link" href="glossary.html#glos_change_buffer" title="change buffer">change buffer</a>)
                        and the adaptive hash index.
                    </p><p style="color:blue;">本节显示innodb insert buffer（也称为change buffer）和自适应散列索引的状态。</p><p>
                        For related information, see
                        <a class="xref" href="innodb-storage-engine.html#innodb-change-buffer" title="14.5.2&nbsp;Change Buffer">Section&nbsp;14.5.2, “Change Buffer”</a>, and
                        <a class="xref" href="innodb-storage-engine.html#innodb-adaptive-hash" title="14.5.3&nbsp;Adaptive Hash Index">Section&nbsp;14.5.3, “Adaptive Hash Index”</a>.
                    </p><p style="color:blue;">有关信息，请参阅第14.5.2节“更改缓冲区”和第14.5.3节“自适应哈希索引”。</p></li><li class="listitem"><p>
                        <code class="literal">LOG</code>
                    </p><p style="color:blue;">原木</p><p>
                        This section displays information about the
                        <code class="literal">InnoDB</code> log. The contents include the
                        current log sequence number, how far the log has been
                        flushed to disk, and the position at which
                        <code class="literal">InnoDB</code> last took a checkpoint. (See
                        <a class="xref" href="innodb-storage-engine.html#innodb-checkpoints" title="14.12.3&nbsp;InnoDB Checkpoints">Section&nbsp;14.12.3, “InnoDB Checkpoints”</a>.) The section also
                        displays information about pending writes and write
                        performance statistics.
                    </p><p style="color:blue;">本节显示有关innodb日志的信息。内容包括当前的日志序列号、日志被刷新到磁盘的距离，以及innodb上次执行检查点的位置。（请参阅第14.12.3节“innodb检查点”。）该节还显示有关挂起写入和写入性能统计的信息。</p></li><li class="listitem"><p>
                        <code class="literal">BUFFER POOL AND MEMORY</code>
                    </p><p style="color:blue;">缓冲池和内存</p><p>
                        This section gives you statistics on pages read and written.
                        You can calculate from these numbers how many data file I/O
                        operations your queries currently are doing.
                    </p><p style="color:blue;">本节提供了有关读写页面的统计信息。您可以根据这些数字计算查询当前正在执行的数据文件I/O操作的数量。</p><p>
                        For buffer pool statistics descriptions, see
                        <a class="xref" href="innodb-storage-engine.html#innodb-buffer-pool-monitoring" title="Monitoring the Buffer Pool Using the InnoDB Standard Monitor">Monitoring the Buffer Pool Using the InnoDB Standard Monitor</a>. For
                        additional information about the operation of the buffer
                        pool, see <a class="xref" href="innodb-storage-engine.html#innodb-buffer-pool" title="14.5.1&nbsp;Buffer Pool">Section&nbsp;14.5.1, “Buffer Pool”</a>.
                    </p><p style="color:blue;">有关缓冲池统计信息的描述，请参阅使用innodb标准监视器监视缓冲池。有关缓冲池操作的其他信息，请参阅第14.5.1节“缓冲池”。</p></li><li class="listitem"><p>
                        <code class="literal">ROW OPERATIONS</code>
                    </p><p style="color:blue;">行操作</p><p>
                        This section shows what the main thread is doing, including
                        the number and performance rate for each type of row
                        operation.
                    </p><p style="color:blue;">本节显示主线程正在执行的操作，包括每种行操作的数量和性能比率。</p></li></ul>
                </div>

            </div>

        </div>

    </div>
    <div class="section">
        <div class="titlepage">
            <div>
                <div>
                    <h2 class="title" style="clear: both"><a name="innodb-backup-recovery"></a>14.18&nbsp;InnoDB Backup and Recovery</h2>

                </div>

            </div>

        </div>
        <div class="toc">
            <dl class="toc"><dt><span class="section"><a href="innodb-storage-engine.html#innodb-backup">14.18.1 InnoDB Backup</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-recovery">14.18.2 InnoDB Recovery</a></span></dt></dl>
        </div>
        <p>
            This section covers topics related to <code class="literal">InnoDB</code>
            backup and recovery.
        </p><p style="color:blue;">本节介绍与InnoDB备份和恢复相关的主题。</p>
        <div class="itemizedlist">
            <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                For information about backup techniques applicable to
                <code class="literal">InnoDB</code>, see <a class="xref" href="innodb-storage-engine.html#innodb-backup" title="14.18.1&nbsp;InnoDB Backup">Section&nbsp;14.18.1, “InnoDB Backup”</a>.
            </p><p style="color:blue;">有关适用于InnoDB的备份技术的信息，请参阅第14.18.1节“InnoDB备份”。</p></li><li class="listitem"><p>
                For information about point-in-time recovery, recovery from disk
                failure or corruption, and how <code class="literal">InnoDB</code>
                performs crash recovery, see <a class="xref" href="innodb-storage-engine.html#innodb-recovery" title="14.18.2&nbsp;InnoDB Recovery">Section&nbsp;14.18.2, “InnoDB Recovery”</a>.
            </p><p style="color:blue;">有关时间点恢复、从磁盘故障或损坏中恢复以及InnoDB如何执行崩溃恢复的信息，请参阅第14.18.2节“InnoDB恢复”。</p></li></ul>
        </div>
        <div class="section">
            <div class="titlepage">
                <div>
                    <div>
                        <h3 class="title"><a name="innodb-backup"></a>14.18.1&nbsp;InnoDB Backup</h3>

                    </div>

                </div>

            </div>
            <a class="indexterm" name="idm140286806167136"></a><a class="indexterm" name="idm140286806165648"></a><p>
            The key to safe database management is making regular backups.
            Depending on your data volume, number of MySQL servers, and
            database workload, you can use these backup techniques, alone or
            in combination: <a class="link" href="glossary.html#glos_hot_backup" title="hot backup">hot backup</a>
            with MySQL Enterprise Backup;
            <a class="link" href="glossary.html#glos_cold_backup" title="cold backup">cold backup</a> by copying
            files while the MySQL server is shut down;
            <a class="link" href="glossary.html#glos_logical_backup" title="logical backup">logical backup</a> with
            <a class="link" href="programs.html#mysqldump" title="4.5.4&nbsp;mysqldump — A Database Backup Program"><span class="command"><strong>mysqldump</strong></span></a> for smaller data volumes or to record
            the structure of schema objects. Hot and cold backups are
            <a class="link" href="glossary.html#glos_physical_backup" title="physical backup">physical backups</a> that
            copy actual data files, which can be used directly by the
            <a class="link" href="programs.html#mysqld" title="4.3.1&nbsp;mysqld — The MySQL Server"><span class="command"><strong>mysqld</strong></span></a> server for faster restore.
        </p><p style="color:blue;">安全数据库管理的关键是定期备份。根据您的数据量、mysql服务器的数量和数据库工作负载，您可以单独使用这些备份技术，也可以结合使用这些技术：使用mysql企业备份进行热备份；在mysql服务器关闭时通过复制文件进行冷备份；使用mysqldump对较小的数据卷进行逻辑备份或记录架构对象的结构。热备份和冷备份是复制实际数据文件的物理备份，mysqld服务器可以直接使用这些文件来加快恢复速度。</p><p>
            Using <span class="emphasis"><em>MySQL Enterprise Backup</em></span> is the
            recommended method for backing up <code class="literal">InnoDB</code> data.
        </p><p style="color:blue;">建议使用mysql enterprise backup备份innodb数据。</p>
            <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">

                <div class="admon-title">
                    Note
                </div>
                <p>
                    <code class="literal">InnoDB</code> does not support databases that are
                    restored using third-party backup tools.
                </p><p style="color:blue;">InnoDB不支持使用第三方备份工具还原的数据库。</p>
            </div>
            <h4><a name="idm140286806154128"></a>Hot Backups</h4>
            <p>
                The <span class="command"><strong>mysqlbackup</strong></span> command, part of the MySQL
                Enterprise Backup component, lets you back up a running MySQL
                instance, including <code class="literal">InnoDB</code> tables, with minimal
                disruption to operations while producing a consistent snapshot of
                the database. When <span class="command"><strong>mysqlbackup</strong></span> is copying
                <code class="literal">InnoDB</code> tables, reads and writes to
                <code class="literal">InnoDB</code> tables can continue. MySQL Enterprise
                Backup can also create compressed backup files, and back up
                subsets of tables and databases. In conjunction with the MySQL
                binary log, users can perform point-in-time recovery. MySQL
                Enterprise Backup is part of the MySQL Enterprise subscription.
                For more details, see <a class="xref" href="mysql-enterprise.html#mysql-enterprise-backup" title="29.2&nbsp;MySQL Enterprise Backup Overview">Section&nbsp;29.2, “MySQL Enterprise Backup Overview”</a>.
            </p><p style="color:blue;">mysql back up命令是mysql企业备份组件的一部分，它允许您备份一个正在运行的mysql实例，包括innodb表，并且在生成数据库的一致快照时对操作的中断最小。当mysqlbackup复制innodb表时，可以继续对innodb表进行读写操作。mysql企业备份还可以创建压缩备份文件，并备份表和数据库的子集。结合mysql二进制日志，用户可以执行时间点恢复。mysql企业备份是mysql企业订阅的一部分。有关详细信息，请参阅29.2节“MySQL企业备份概述”。</p>
            <h4><a name="idm140286806148208"></a>Cold Backups</h4>
            <p>
                If you can shut down the MySQL server, you can make a physical
                backup that consists of all files used by
                <code class="literal">InnoDB</code> to manage its tables. Use the following
                procedure:
            </p><p style="color:blue;">如果可以关闭mysql服务器，可以进行物理备份，该备份包含innodb用来管理其表的所有文件。使用以下步骤：</p>
            <div class="orderedlist">
                <ol class="orderedlist" type="1"><li class="listitem"><p>
                    Perform a <a class="link" href="glossary.html#glos_slow_shutdown" title="slow shutdown">slow
                    shutdown</a> of the MySQL server and make sure that it
                    stops without errors.
                </p><p style="color:blue;">缓慢关闭mysql服务器，并确保它停止时没有错误。</p></li><li class="listitem"><p>
                    Copy all <code class="literal">InnoDB</code> data files
                    (<code class="filename">ibdata</code> files and
                    <code class="filename">.ibd</code> files) into a safe place.
                </p><p style="color:blue;">将所有innodb数据文件（ibdata文件和.ibd文件）复制到一个安全的地方。</p></li><li class="listitem"><p>
                    Copy all the <code class="filename">.frm</code> files for
                    <code class="literal">InnoDB</code> tables to a safe place.
                </p><p style="color:blue;">将innodb表的所有.frm文件复制到一个安全的地方。</p></li><li class="listitem"><p>
                    Copy all <code class="literal">InnoDB</code> log files
                    (<code class="filename">ib_logfile</code> files) to a safe place.
                </p><p style="color:blue;">将所有innodb日志文件（ib_logfile文件）复制到一个安全的地方。</p></li><li class="listitem"><p>
                    Copy your <code class="filename">my.cnf</code> configuration file or
                    files to a safe place.
                </p><p style="color:blue;">将my.cnf配置文件复制到安全的地方。</p></li></ol>
            </div>
            <h4><a name="idm140286806134528"></a>Logical Backups Using mysqldump</h4>
            <p>
                In addition to physical backups, it is recommended that you
                regularly create logical backups by dumping your tables using
                <a class="link" href="programs.html#mysqldump" title="4.5.4&nbsp;mysqldump — A Database Backup Program"><span class="command"><strong>mysqldump</strong></span></a>. A binary file might be corrupted
                without you noticing it. Dumped tables are stored into text files
                that are human-readable, so spotting table corruption becomes
                easier. Also, because the format is simpler, the chance for
                serious data corruption is smaller. <a class="link" href="programs.html#mysqldump" title="4.5.4&nbsp;mysqldump — A Database Backup Program"><span class="command"><strong>mysqldump</strong></span></a>
                also has a <a class="link" href="programs.html#option_mysqldump_single-transaction"><code class="option">--single-transaction</code></a>
                option for making a consistent snapshot without locking out other
                clients. See <a class="xref" href="backup-and-recovery.html#backup-policy" title="7.3.1&nbsp;Establishing a Backup Policy">Section&nbsp;7.3.1, “Establishing a Backup Policy”</a>.
            </p><p style="color:blue;">除了物理备份之外，建议您定期使用mysqldump转储表来创建逻辑备份。二进制文件可能会在您没有注意到的情况下损坏。转储的表存储在人类可读的文本文件中，因此更容易发现表损坏。另外，由于格式更简单，导致严重数据损坏的可能性更小。mysqldump还有一个--single事务选项，用于在不锁定其他客户端的情况下创建一致的快照。参见第7.3.1节“建立备份策略”。</p><p>
            Replication works with <a class="link" href="innodb-storage-engine.html" title="Chapter&nbsp;14&nbsp;The InnoDB Storage Engine"><code class="literal">InnoDB</code></a> tables,
            so you can use MySQL replication capabilities to keep a copy of
            your database at database sites requiring high availability. See
            <a class="xref" href="innodb-storage-engine.html#innodb-and-mysql-replication" title="14.19&nbsp;InnoDB and MySQL Replication">Section&nbsp;14.19, “InnoDB and MySQL Replication”</a>.
        </p><p style="color:blue;">复制与innodb表一起工作，因此可以使用mysql复制功能在需要高可用性的数据库站点上保存数据库的副本。参见14.19节，“InnoDB和MySQL复制”。</p>
        </div>
        <div class="section">
            <div class="titlepage">
                <div>
                    <div>
                        <h3 class="title"><a name="innodb-recovery"></a>14.18.2&nbsp;InnoDB Recovery</h3>

                    </div>

                </div>

            </div>
            <a class="indexterm" name="idm140286806124816"></a><a class="indexterm" name="idm140286806123328"></a><p>
            This section describes <code class="literal">InnoDB</code> recovery. Topics
            include:
        </p><p style="color:blue;">本节介绍InnoDB恢复。主题包括：</p>
            <div class="itemizedlist">
                <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><a class="xref" href="innodb-storage-engine.html#innodb-recovery-point-in-time" title="Point-in-Time Recovery">Point-in-Time Recovery</a></p><p style="color:blue;">时间点恢复</p></li><li class="listitem"><p><a class="xref" href="innodb-storage-engine.html#innodb-corruption-disk-failure-recovery" title="Recovery from Data Corruption or Disk Failure">Recovery from Data Corruption or Disk Failure</a></p><p style="color:blue;">从数据损坏或磁盘故障中恢复</p></li><li class="listitem"><p><a class="xref" href="innodb-storage-engine.html#innodb-crash-recovery" title="InnoDB Crash Recovery">InnoDB Crash Recovery</a></p><p style="color:blue;">InnoDB崩溃恢复</p></li><li class="listitem"><p><a class="xref" href="innodb-storage-engine.html#innodb-recovery-tablespace-discovery" title="Tablespace Discovery During Crash Recovery">Tablespace Discovery During Crash Recovery</a></p><p style="color:blue;">崩溃恢复期间的表空间发现</p></li></ul>
            </div>

            <div class="simplesect">

                <div class="titlepage">
                    <div>

                        <div class="simple">
                            <h4 class="title"><a name="innodb-recovery-point-in-time"></a>Point-in-Time Recovery</h4>

                        </div>

                    </div>

                </div>
                <a class="indexterm" name="idm140286806115072"></a><a class="indexterm" name="idm140286806113584"></a><p>
                To recover an <code class="literal">InnoDB</code> database to the present
                from the time at which the physical backup was made, you must
                run MySQL server with binary logging enabled, even before taking
                the backup. To achieve point-in-time recovery after restoring a
                backup, you can apply changes from the binary log that occurred
                after the backup was made. See
                <a class="xref" href="backup-and-recovery.html#point-in-time-recovery" title="7.5&nbsp;Point-in-Time (Incremental) Recovery Using the Binary Log">Section&nbsp;7.5, “Point-in-Time (Incremental) Recovery Using the Binary Log”</a>.
            </p><p style="color:blue;">要将innodb数据库从物理备份时恢复到现在，您必须在启用二进制日志记录的情况下运行mysql server，甚至在进行备份之前。要在还原备份后实现时间点恢复，可以应用在备份后对二进制日志所做的更改。参见第7.5节“使用二进制日志的时间点（增量）恢复”。</p>
            </div>
            <div class="simplesect">
                <div class="titlepage">
                    <div>
                        <div class="simple">
                            <h4 class="title"><a name="innodb-corruption-disk-failure-recovery"></a>Recovery from Data Corruption or Disk Failure</h4>

                        </div>

                    </div>

                </div>
                <a class="indexterm" name="idm140286806108352"></a><a class="indexterm" name="idm140286806106864"></a><a class="indexterm" name="idm140286806105376"></a><a class="indexterm" name="idm140286806103888"></a><p>
                If your database becomes corrupted or disk failure occurs, you
                must perform the recovery using a backup. In the case of
                corruption, first find a backup that is not corrupted. After
                restoring the base backup, do a point-in-time recovery from the
                binary log files using <a class="link" href="programs.html#mysqlbinlog" title="4.6.7&nbsp;mysqlbinlog — Utility for Processing Binary Log Files"><span class="command"><strong>mysqlbinlog</strong></span></a> and
                <a class="link" href="programs.html#mysql" title="4.5.1&nbsp;mysql — The MySQL Command-Line Client"><span class="command"><strong>mysql</strong></span></a> to restore the changes that occurred
                after the backup was made.
            </p><p style="color:blue;">如果数据库损坏或发生磁盘故障，则必须使用备份执行恢复。在损坏的情况下，首先查找未损坏的备份。还原基本备份后，使用mysqlbinlog和mysql从二进制日志文件中执行时间点恢复，以还原备份后发生的更改。</p><p>
                In some cases of database corruption, it is enough to dump,
                drop, and re-create one or a few corrupt tables. You can use the
                <a class="link" href="sql-syntax.html#check-table" title="13.7.2.2&nbsp;CHECK TABLE Syntax"><code class="literal">CHECK TABLE</code></a> statement to check
                whether a table is corrupt, although <a class="link" href="sql-syntax.html#check-table" title="13.7.2.2&nbsp;CHECK TABLE Syntax"><code class="literal">CHECK
                TABLE</code></a> naturally cannot detect every possible kind of
                corruption.
            </p><p style="color:blue;">在某些数据库损坏的情况下，转储、删除和重新创建一个或几个损坏的表就足够了。您可以使用check table语句检查表是否损坏，尽管check table自然无法检测到每种可能的损坏。</p><p>
                In some cases, apparent database page corruption is actually due
                to the operating system corrupting its own file cache, and the
                data on disk may be okay. It is best to try restarting the
                computer first. Doing so may eliminate errors that appeared to
                be database page corruption. If MySQL still has trouble starting
                because of <code class="literal">InnoDB</code> consistency problems, see
                <a class="xref" href="innodb-storage-engine.html#forcing-innodb-recovery" title="14.21.2&nbsp;Forcing InnoDB Recovery">Section&nbsp;14.21.2, “Forcing InnoDB Recovery”</a> for steps to start the
                instance in recovery mode, which permits you to dump the data.
            </p><p style="color:blue;">在某些情况下，明显的数据库页损坏实际上是由于操作系统损坏了自己的文件缓存，磁盘上的数据可能没有问题。最好先尝试重新启动计算机。这样做可以消除看起来是数据库页损坏的错误。如果MySQL由于InnoDB一致性问题仍然无法启动，请参阅14.21.2节“强制InnoDB恢复”了解在恢复模式下启动实例的步骤，这允许您转储数据。</p>
            </div>
            <div class="simplesect">
                <div class="titlepage">
                    <div>
                        <div class="simple">
                            <h4 class="title"><a name="innodb-crash-recovery"></a>InnoDB Crash Recovery</h4>

                        </div>

                    </div>

                </div>
                <a class="indexterm" name="idm140286806092608"></a><a class="indexterm" name="idm140286806091120"></a><p>
                To recover from a MySQL server crash, the only requirement is to
                restart the MySQL server. <code class="literal">InnoDB</code>
                automatically checks the logs and performs a roll-forward of the
                database to the present. <code class="literal">InnoDB</code> automatically
                rolls back uncommitted transactions that were present at the
                time of the crash. During recovery, <a class="link" href="programs.html#mysqld" title="4.3.1&nbsp;mysqld — The MySQL Server"><span class="command"><strong>mysqld</strong></span></a>
                displays output similar to this:
            </p><p style="color:blue;">要从mysql服务器崩溃中恢复，唯一的要求是重新启动mysql服务器。InnoDB会自动检查日志并将数据库前滚到当前。InnoDB会自动回滚崩溃时存在的未提交事务。在恢复过程中，mysqld显示类似于以下内容的输出：</p><pre data-lang="none" class="programlisting">InnoDB: Log scan progressed past the checkpoint lsn 369163704
InnoDB: Doing recovery: scanned up to log sequence number 374340608
InnoDB: Doing recovery: scanned up to log sequence number 379583488
InnoDB: Doing recovery: scanned up to log sequence number 384826368
InnoDB: Doing recovery: scanned up to log sequence number 390069248
InnoDB: Doing recovery: scanned up to log sequence number 395312128
InnoDB: Doing recovery: scanned up to log sequence number 400555008
InnoDB: Doing recovery: scanned up to log sequence number 405797888
InnoDB: Doing recovery: scanned up to log sequence number 411040768
InnoDB: Doing recovery: scanned up to log sequence number 414724794
InnoDB: Database was not shutdown normally!
InnoDB: Starting crash recovery.
InnoDB: 1 transaction(s) which must be rolled back or cleaned up in
total 518425 row operations to undo
InnoDB: Trx id counter is 1792
InnoDB: Starting an apply batch of log records to the database...
InnoDB: Progress in percent: 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15
16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37
38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59
60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81
82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99
InnoDB: Apply batch completed
...
InnoDB: Starting in background the rollback of uncommitted transactions
InnoDB: Rolling back trx with id 1511, 518425 rows to undo
...
InnoDB: Waiting for purge to start
InnoDB: 5.7.18 started; log sequence number 414724794
...
./mysqld: ready for connections.
</pre><a class="indexterm" name="idm140286806082112"></a><p>
                <code class="literal">InnoDB</code>
                <a class="link" href="glossary.html#glos_crash_recovery" title="crash recovery">crash recovery</a>
                consists of several steps:
            </p><p style="color:blue;">InnoDB崩溃恢复包括几个步骤：</p>
                <div class="itemizedlist">
                    <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                        Tablespace discovery
                    </p><p style="color:blue;">表空间发现</p><p>
                        Tablespace discovery is the process that
                        <code class="literal">InnoDB</code> uses to identify tablespaces that
                        require redo log application. See
                        <a class="xref" href="innodb-storage-engine.html#innodb-recovery-tablespace-discovery" title="Tablespace Discovery During Crash Recovery">Tablespace Discovery During Crash Recovery</a>.
                    </p><p style="color:blue;">表空间发现是innodb用来识别需要重做日志应用程序的表空间的过程。请参阅崩溃恢复期间的表空间发现。</p></li><li class="listitem"><p>
                        <a class="link" href="glossary.html#glos_redo_log" title="redo log">Redo log</a> application
                    </p><p style="color:blue;">重做日志应用程序</p><p>
                        Redo log application is performed during initialization,
                        before accepting any connections. If all changes are flushed
                        from the <a class="link" href="glossary.html#glos_buffer_pool" title="buffer pool">buffer pool</a>
                        to the <a class="link" href="glossary.html#glos_tablespace" title="tablespace">tablespaces</a>
                        (<code class="filename">ibdata*</code> and <code class="filename">*.ibd</code>
                        files) at the time of the shutdown or crash, redo log
                        application is skipped. <code class="literal">InnoDB</code> also skips
                        redo log application if redo log files are missing at
                        startup.
                    </p><p style="color:blue;">在接受任何连接之前，重做日志应用程序在初始化期间执行。如果在关闭或崩溃时将所有更改从缓冲池刷新到表空间（ibdata*和*.ibd文件），则将跳过重做日志应用程序。如果启动时缺少重做日志文件，InnoDB也会跳过重做日志应用程序。</p><p>
                        Removing redo logs to speed up recovery is not recommended,
                        even if some data loss is acceptable. Removing redo logs
                        should only be considered after a clean shutdown, with
                        <a class="link" href="innodb-storage-engine.html#sysvar_innodb_fast_shutdown"><code class="literal">innodb_fast_shutdown</code></a> set to
                        <code class="literal">0</code> or <code class="literal">1</code>.
                    </p><p style="color:blue;">不建议删除重做日志以加快恢复，即使某些数据丢失是可以接受的。删除重做日志只应在干净关机后考虑，innodb_fast_shutdown设置为0或1。</p><p>
                        For information about the process that
                        <code class="literal">InnoDB</code> uses to identify tablespaces that
                        require redo log application, see
                        <a class="xref" href="innodb-storage-engine.html#innodb-recovery-tablespace-discovery" title="Tablespace Discovery During Crash Recovery">Tablespace Discovery During Crash Recovery</a>.
                    </p><p style="color:blue;">有关innodb用于标识需要重做日志应用程序的表空间的进程的信息，请参阅崩溃恢复期间的表空间发现。</p></li><li class="listitem"><p>
                        <a class="link" href="glossary.html#glos_rollback" title="rollback">Roll back</a> of incomplete
                        <a class="link" href="glossary.html#glos_transaction" title="transaction">transactions</a>
                    </p><p style="color:blue;">未完成交易的回滚</p><p>
                        Incomplete transactions are any transactions that were
                        active at the time of crash or
                        <a class="link" href="glossary.html#glos_fast_shutdown" title="fast shutdown">fast shutdown</a>. The
                        time it takes to roll back an incomplete transaction can be
                        three or four times the amount of time a transaction is
                        active before it is interrupted, depending on server load.
                    </p><p style="color:blue;">不完整事务是指在崩溃或快速关闭时处于活动状态的任何事务。回滚不完整事务所需的时间可以是事务中断前活动时间的三到四倍，具体取决于服务器负载。</p><p>
                        You cannot cancel transactions that are being rolled back.
                        In extreme cases, when rolling back transactions is expected
                        to take an exceptionally long time, it may be faster to
                        start <code class="literal">InnoDB</code> with an
                        <a class="link" href="innodb-storage-engine.html#sysvar_innodb_force_recovery"><code class="literal">innodb_force_recovery</code></a>
                        setting of <code class="literal">3</code> or greater. See
                        <a class="xref" href="innodb-storage-engine.html#forcing-innodb-recovery" title="14.21.2&nbsp;Forcing InnoDB Recovery">Section&nbsp;14.21.2, “Forcing InnoDB Recovery”</a>.
                    </p><p style="color:blue;">不能取消正在回滚的事务。在极端情况下，当回滚事务预计需要非常长的时间时，如果innodb_force_recovery设置为3或更大，则启动innodb可能更快。参见第14.21.2节“强制InnoDB恢复”。</p></li><li class="listitem"><p>
                        <a class="link" href="glossary.html#glos_change_buffer" title="change buffer">Change buffer</a>
                        merge
                    </p><p style="color:blue;">更改缓冲区合并</p><p>
                        Applying changes from the change buffer (part of the
                        <a class="link" href="glossary.html#glos_system_tablespace" title="system tablespace">system
                            tablespace</a>) to leaf pages of secondary indexes, as
                        the index pages are read to the buffer pool.
                    </p><p style="color:blue;">将更改缓冲区（系统表空间的一部分）中的更改应用于辅助索引的叶页，因为索引页被读取到缓冲池中。</p></li><li class="listitem"><p>
                        <a class="link" href="glossary.html#glos_purge" title="purge">Purge</a>
                    </p><p style="color:blue;">净化</p><p>
                        Deleting delete-marked records that are no longer visible to
                        active transactions.
                    </p><p style="color:blue;">删除活动事务不再可见的删除标记记录。</p></li></ul>
                </div>
                <p>
                    The steps that follow redo log application do not depend on the
                    redo log (other than for logging the writes) and are performed
                    in parallel with normal processing. Of these, only rollback of
                    incomplete transactions is special to crash recovery. The insert
                    buffer merge and the purge are performed during normal
                    processing.
                </p><p style="color:blue;">重做日志应用程序之后的步骤不依赖于重做日志（记录写入操作除外），并且与正常处理并行执行。其中，只有不完整事务的回滚对于崩溃恢复是特殊的。插入缓冲区合并和清除在正常处理期间执行。</p><p>
                After redo log application, <code class="literal">InnoDB</code> attempts
                to accept connections as early as possible, to reduce downtime.
                As part of crash recovery, <code class="literal">InnoDB</code> rolls back
                transactions that were not committed or in <code class="literal">XA
                PREPARE</code> state when the server crashed. The rollback is
                performed by a background thread, executed in parallel with
                transactions from new connections. Until the rollback operation
                is completed, new connections may encounter locking conflicts
                with recovered transactions.
            </p><p style="color:blue;">在重做日志应用程序之后，innodb试图尽早接受连接，以减少停机时间。作为崩溃恢复的一部分，在服务器崩溃时，NYNDB回滚未提交的事务或XA准备状态。回滚由后台线程执行，与来自新连接的事务并行执行。在回滚操作完成之前，新连接可能会遇到与已恢复事务的锁定冲突。</p><p>
                In most situations, even if the MySQL server was killed
                unexpectedly in the middle of heavy activity, the recovery
                process happens automatically and no action is required of the
                DBA. If a hardware failure or severe system error corrupted
                <code class="literal">InnoDB</code> data, MySQL might refuse to start. In
                this case, see <a class="xref" href="innodb-storage-engine.html#forcing-innodb-recovery" title="14.21.2&nbsp;Forcing InnoDB Recovery">Section&nbsp;14.21.2, “Forcing InnoDB Recovery”</a>.
            </p><p style="color:blue;">在大多数情况下，即使mysql服务器在繁重的活动中意外被终止，恢复过程也会自动进行，dba不需要执行任何操作。如果硬件故障或严重的系统错误损坏了innodb数据，mysql可能会拒绝启动。在这种情况下，请参阅14.21.2节，“强制InnoDB恢复”。</p><p>
                For information about the binary log and
                <code class="literal">InnoDB</code> crash recovery, see
                <a class="xref" href="server-administration.html#binary-log" title="5.4.4&nbsp;The Binary Log">Section&nbsp;5.4.4, “The Binary Log”</a>.
            </p><p style="color:blue;">有关二进制日志和innodb崩溃恢复的信息，请参阅第5.4.4节“二进制日志”。</p>
            </div>
            <div class="simplesect">
                <div class="titlepage">
                    <div>
                        <div class="simple">
                            <h4 class="title"><a name="innodb-recovery-tablespace-discovery"></a>Tablespace Discovery During Crash Recovery</h4>

                        </div>

                    </div>

                </div>
                <a class="indexterm" name="idm140286806041872"></a><a class="indexterm" name="idm140286806040384"></a><p>
                If, during recovery, <code class="literal">InnoDB</code> encounters redo
                logs written since the last checkpoint, the redo logs must be
                applied to affected tablespaces. The process that identifies
                affected tablespaces during recovery is referred to as
                <span class="emphasis"><em>tablespace discovery</em></span>.
            </p><p style="color:blue;">如果在恢复期间，innodb遇到自上次检查点以来写入的重做日志，那么重做日志必须应用于受影响的表空间。在恢复期间标识受影响表空间的过程称为表空间发现。</p><p>
                Tablespace discovery is performed by scanning redo logs from the
                last checkpoint to the end of the log for
                <code class="literal">MLOG_FILE_NAME</code> records that are written when
                a tablespace page is modified. An
                <code class="literal">MLOG_FILE_NAME</code> record contains the tablespace
                space ID and file name.
            </p><p style="color:blue;">表空间发现是通过扫描从最后一个检查点到修改表空间页时写入的mlog_file_name记录的日志末尾的重做日志来执行的。mlog_file_name记录包含表空间id和文件名。</p><p>
                On startup, <code class="literal">InnoDB</code> opens the system
                tablespace and redo log. If there are redo log records written
                since the last checkpoint, affected tablespace files are opened
                based on <code class="literal">MLOG_FILE_NAME</code> records.
            </p><p style="color:blue;">启动时，innodb打开系统表空间并重做日志。如果有自上次检查点以来写入的重做日志记录，则会基于mlog_file_name记录打开受影响的表空间文件。</p><p>
                <code class="literal">MLOG_FILE_NAME</code> records are written for all
                persistent tablespace types including file-per-table
                tablespaces, general tablespaces, the system tablespace, and
                undo log tablespaces.
            </p><p style="color:blue;">mlog_file_name记录是为所有持久表空间类型编写的，包括每表表空间文件、常规表空间、系统表空间和撤消日志表空间。</p><p>
                Redo-log-based discovery has the following characteristics:
            </p><p style="color:blue;">基于重做日志的发现具有以下特征：</p>
                <div class="itemizedlist">
                    <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                        Only tablespace <code class="filename">*.ibd</code> files modified
                        since the last checkpoint are accessed.
                    </p><p style="color:blue;">只访问自上次检查点以来修改过的表空间*.ibd文件。</p></li><li class="listitem"><p>
                        Tablespace <code class="filename">*.ibd</code> files that are not
                        attached to the <code class="literal">InnoDB</code> instance are
                        ignored when redo logs are applied.
                    </p><p style="color:blue;">应用重做日志时，将忽略未附加到innodb实例的表空间*.ibd文件。</p></li><li class="listitem"><p>
                        If <code class="literal">MLOG_FILE_NAME</code> records for the system
                        tablespace do not match the server configuration affecting
                        system tablespace data file names, recovery fails with an
                        error before redo logs are applied.
                    </p><p style="color:blue;">如果系统表空间的mlog_file_name记录与影响系统表空间数据文件名的服务器配置不匹配，则在应用重做日志之前，恢复将失败并出现错误。</p></li><li class="listitem"><p>
                        If tablespace files referenced in the scanned portion of the
                        log are missing, startup is refused.
                    </p><p style="color:blue;">如果日志扫描部分中引用的表空间文件丢失，则拒绝启动。</p></li><li class="listitem"><p>
                        Redo logs for missing tablespace <code class="filename">*.ibd</code>
                        files are only disregarded if there is a file-delete redo
                        log record (<code class="literal">MLOG_FILE_DELETE</code>) in the log.
                        For example, a table rename failure could result in a
                        <span class="quote">“<span class="quote">missing</span>”</span> <code class="filename">*.ibd</code> file
                        without an <code class="literal">MLOG_FILE_DELETE</code> record. In
                        this case, you could manually rename the tablespace file and
                        restart crash recovery, or you could restart the server in
                        recovery mode using the
                        <a class="link" href="innodb-storage-engine.html#sysvar_innodb_force_recovery"><code class="literal">innodb_force_recovery</code></a>
                        option. Missing <code class="filename">*.ibd</code> files are ignored
                        when the server is started in recovery mode.
                    </p><p style="color:blue;">只有当日志中有文件删除重做日志记录（mlog_file_delete）时，才会忽略丢失表空间*.ibd文件的重做日志。例如，表重命名失败可能导致“丢失”*.ibd文件，而没有mlog_file_delete记录。在这种情况下，可以手动重命名表空间文件并重新启动崩溃恢复，也可以使用innodb_force_recovery选项以恢复模式重新启动服务器。在恢复模式下启动服务器时，将忽略丢失的*.ibd文件。</p></li></ul>
                </div>
                <p>
                    Redo-log-based discovery, introduced in MySQL 5.7,
                    replaces directory scans that were used in earlier MySQL
                    releases to construct a <span class="quote">“<span class="quote">space ID-to-tablespace file
        name</span>”</span> map that was required to apply redo logs.
                </p><p style="color:blue;">mysql 5.7中引入的基于重做日志的发现，取代了mysql早期版本中用于构建应用重做日志所需的“空间id到表空间文件名”映射的目录扫描。</p>
            </div>

        </div>

    </div>
    <div class="section">
        <div class="titlepage">
            <div>
                <div>
                    <h2 class="title" style="clear: both"><a name="innodb-and-mysql-replication"></a>14.19&nbsp;InnoDB and MySQL Replication</h2>

                </div>

            </div>

        </div>
        <a class="indexterm" name="idm140286806014400"></a><p>
        MySQL replication works for <code class="literal">InnoDB</code> tables as it
        does for <code class="literal">MyISAM</code> tables. It is also possible to
        use replication in a way where the storage engine on the slave is
        not the same as the original storage engine on the master. For
        example, you can replicate modifications to an
        <code class="literal">InnoDB</code> table on the master to a
        <code class="literal">MyISAM</code> table on the slave. For more information
        see, <a class="xref" href="replication.html#replication-solutions-diffengines" title="16.3.3&nbsp;Using Replication with Different Master and Slave Storage Engines">Section&nbsp;16.3.3, “Using Replication with Different Master and Slave Storage Engines”</a>.
    </p><p style="color:blue;">mysql复制对于innodb表和myisam表一样有效。也可以在从机上的存储引擎与主机上的原始存储引擎不同的情况下使用复制。例如，可以将对主节点上的innodb表的修改复制到从节点上的myisam表。有关更多信息，请参阅16.3.3节，“使用不同主/从存储引擎的复制”。</p><p>
        For information about setting up a new slave for a master, see
        <a class="xref" href="replication.html#replication-setup-slaves" title="16.1.2.5&nbsp;Setting Up Replication Slaves">Section&nbsp;16.1.2.5, “Setting Up Replication Slaves”</a>, and
        <a class="xref" href="replication.html#replication-snapshot-method" title="16.1.2.4&nbsp;Choosing a Method for Data Snapshots">Section&nbsp;16.1.2.4, “Choosing a Method for Data Snapshots”</a>. To make a new slave
        without taking down the master or an existing slave, use the
        <a class="link" href="mysql-enterprise.html#mysql-enterprise-backup" title="29.2&nbsp;MySQL Enterprise Backup Overview">MySQL Enterprise
            Backup</a> product.
    </p><p style="color:blue;">有关为主服务器设置新从属服务器的信息，请参阅第16.1.2.5节“设置复制从属服务器”和第16.1.2.4节“为数据快照选择方法”。若要生成新的从属而不取主或现有的从属，则使用MySQL企业备份产品。</p><p>
        Transactions that fail on the master do not affect replication at
        all. MySQL replication is based on the binary log where MySQL writes
        SQL statements that modify data. A transaction that fails (for
        example, because of a foreign key violation, or because it is rolled
        back) is not written to the binary log, so it is not sent to slaves.
        See <a class="xref" href="sql-syntax.html#commit" title="13.3.1&nbsp;START TRANSACTION, COMMIT, and ROLLBACK Syntax">Section&nbsp;13.3.1, “START TRANSACTION, COMMIT, and ROLLBACK Syntax”</a>.
    </p><p style="color:blue;">在主服务器上失败的事务根本不会影响复制。mysql复制基于二进制日志，mysql在其中编写修改数据的sql语句。失败的事务（例如，由于外键冲突或回滚）不会写入二进制日志，因此不会发送到从属服务器。参见第13.3.1节“启动事务、提交和回滚语法”。</p><p><b>Replication and CASCADE.&nbsp;</b>
        Cascading actions for <code class="literal">InnoDB</code> tables on the
        master are replicated on the slave <span class="emphasis"><em>only</em></span> if
        the tables sharing the foreign key relation use
        <code class="literal">InnoDB</code> on both the master and slave. This is
        true whether you are using statement-based or row-based
        replication. Suppose that you have started replication, and then
        create two tables on the master using the following
        <a class="link" href="sql-syntax.html#create-table" title="13.1.18&nbsp;CREATE TABLE Syntax"><code class="literal">CREATE TABLE</code></a> statements:
    </p><p style="color:blue;">复制和级联。只有共享外键关系的表同时在主从机上使用innodb时，主从机上的innodb表的级联操作才会复制到从机上。无论您使用的是基于语句的复制还是基于行的复制，都是这样。假设已启动复制，然后使用以下CREATE TABLE语句在主机上创建两个表：</p><pre data-lang="sql" class="programlisting">CREATE TABLE fc1 (
    i INT PRIMARY KEY,
    j INT
) ENGINE = InnoDB;

CREATE TABLE fc2 (
    m INT PRIMARY KEY,
    n INT,
    FOREIGN KEY ni (n) REFERENCES fc1 (i)
        ON DELETE CASCADE
) ENGINE = InnoDB;
</pre><p>
        Suppose that the slave does not have <code class="literal">InnoDB</code>
        support enabled. If this is the case, then the tables on the slave
        are created, but they use the <code class="literal">MyISAM</code> storage
        engine, and the <code class="literal">FOREIGN KEY</code> option is ignored.
        Now we insert some rows into the tables on the master:
    </p><p style="color:blue;">假设从机没有启用innodb支持。如果是这种情况，那么将创建从机上的表，但它们使用myisam存储引擎，并忽略外键选项。现在我们将一些行插入master上的表中：</p><pre data-lang="sql" class="programlisting">master&gt; <strong class="userinput"><code>INSERT INTO fc1 VALUES (1, 1), (2, 2);</code></strong>
Query OK, 2 rows affected (0.09 sec)
Records: 2  Duplicates: 0  Warnings: 0

master&gt; <strong class="userinput"><code>INSERT INTO fc2 VALUES (1, 1), (2, 2), (3, 1);</code></strong>
Query OK, 3 rows affected (0.19 sec)
Records: 3  Duplicates: 0  Warnings: 0
</pre><p>
        At this point, on both the master and the slave, table
        <code class="literal">fc1</code> contains 2 rows, and table
        <code class="literal">fc2</code> contains 3 rows, as shown here:
    </p><p style="color:blue;">此时，在主从机上，表fc1包含2行，表fc2包含3行，如下所示：</p><pre data-lang="sql" class="programlisting">master&gt; <strong class="userinput"><code>SELECT * FROM fc1;</code></strong>
+---+------+
| i | j    |
+---+------+
| 1 |    1 |
| 2 |    2 |
+---+------+
2 rows in set (0.00 sec)

master&gt; <strong class="userinput"><code>SELECT * FROM fc2;</code></strong>
+---+------+
| m | n    |
+---+------+
| 1 |    1 |
| 2 |    2 |
| 3 |    1 |
+---+------+
3 rows in set (0.00 sec)

slave&gt; <strong class="userinput"><code>SELECT * FROM fc1;</code></strong>
+---+------+
| i | j    |
+---+------+
| 1 |    1 |
| 2 |    2 |
+---+------+
2 rows in set (0.00 sec)

slave&gt; <strong class="userinput"><code>SELECT * FROM fc2;</code></strong>
+---+------+
| m | n    |
+---+------+
| 1 |    1 |
| 2 |    2 |
| 3 |    1 |
+---+------+
3 rows in set (0.00 sec)
</pre><p>
        Now suppose that you perform the following
        <a class="link" href="sql-syntax.html#delete" title="13.2.2&nbsp;DELETE Syntax"><code class="literal">DELETE</code></a> statement on the master:
    </p><p style="color:blue;">现在假设您在master上执行以下delete语句：</p><pre data-lang="sql" class="programlisting">master&gt; <strong class="userinput"><code>DELETE FROM fc1 WHERE i=1;</code></strong>
Query OK, 1 row affected (0.09 sec)
</pre><p>
        Due to the cascade, table <code class="literal">fc2</code> on the master now
        contains only 1 row:
    </p><p style="color:blue;">由于级联，主控上的表fc2现在只包含一行：</p><pre data-lang="sql" class="programlisting">master&gt; <strong class="userinput"><code>SELECT * FROM fc2;</code></strong>
+---+---+
| m | n |
+---+---+
| 2 | 2 |
+---+---+
1 row in set (0.00 sec)
</pre><p>
        However, the cascade does not propagate on the slave because on the
        slave the <a class="link" href="sql-syntax.html#delete" title="13.2.2&nbsp;DELETE Syntax"><code class="literal">DELETE</code></a> for
        <code class="literal">fc1</code> deletes no rows from <code class="literal">fc2</code>.
        The slave's copy of <code class="literal">fc2</code> still contains all of the
        rows that were originally inserted:
    </p><p style="color:blue;">但是，级联不会在从机上传播，因为在从机上，fc1的delete不会从fc2删除任何行。从机的fc2副本仍然包含最初插入的所有行：</p><pre data-lang="sql" class="programlisting">slave&gt; <strong class="userinput"><code>SELECT * FROM fc2;</code></strong>
+---+---+
| m | n |
+---+---+
| 1 | 1 |
| 3 | 1 |
| 2 | 2 |
+---+---+
3 rows in set (0.00 sec)
</pre><p>
        This difference is due to the fact that the cascading deletes are
        handled internally by the <code class="literal">InnoDB</code> storage engine,
        which means that none of the changes are logged.
    </p><p style="color:blue;">这种差异是因为级联删除是由innodb存储引擎内部处理的，这意味着没有记录任何更改。</p>
    </div>
    <div class="section">
        <div class="titlepage">
            <div>
                <div>
                    <h2 class="title" style="clear: both"><a name="innodb-memcached"></a>14.20&nbsp;InnoDB memcached Plugin</h2>

                </div>

            </div>

        </div>
        <div class="toc">
            <dl class="toc"><dt><span class="section"><a href="innodb-storage-engine.html#innodb-memcached-benefits">14.20.1 Benefits of the InnoDB memcached Plugin</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-memcached-intro">14.20.2 InnoDB memcached Architecture</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-memcached-setup">14.20.3 Setting Up the InnoDB memcached Plugin</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-memcached-security">14.20.4 Security Considerations for the InnoDB memcached Plugin</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-memcached-developing">14.20.5 Writing Applications for the InnoDB memcached Plugin</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-memcached-replication">14.20.6 The InnoDB memcached Plugin and Replication</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-memcached-internals">14.20.7 InnoDB memcached Plugin Internals</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-memcached-troubleshoot">14.20.8 Troubleshooting the InnoDB memcached Plugin</a></span></dt></dl>
        </div>
        <a class="indexterm" name="idm140286805971776"></a><p>
        The <code class="literal">InnoDB</code> <span class="command"><strong>memcached</strong></span> plugin
        (<code class="literal">daemon_memcached</code>) provides an integrated
        <span class="command"><strong>memcached</strong></span> daemon that automatically stores and
        retrieves data from <code class="literal">InnoDB</code> tables, turning the
        MySQL server into a fast <span class="quote">“<span class="quote">key-value store</span>”</span>. Instead of
        formulating queries in SQL, you can use simple
        <code class="literal">get</code>, <code class="literal">set</code>, and
        <code class="literal">incr</code> operations that avoid the performance
        overhead associated with SQL parsing and constructing a query
        optimization plan. You can also access the same
        <code class="literal">InnoDB</code> tables through SQL for convenience,
        complex queries, bulk operations, and other strengths of traditional
        database software.
    </p><p style="color:blue;">innodb memcached插件（daemon_memcached）提供了一个集成的memcached守护进程，它自动存储和检索innodb表中的数据，将mysql服务器变成一个快速的“键值存储”。您可以使用简单的get、set和incr操作来避免与sql解析和构造查询优化计划相关的性能开销，而不是用sql来构造查询。为了方便、复杂的查询、批量操作以及传统数据库软件的其他优点，您还可以通过sql访问相同的innodb表。</p><p>
        This <span class="quote">“<span class="quote">NoSQL-style</span>”</span> interface uses the
        <span class="command"><strong>memcached</strong></span> API to speed up database operations,
        letting <code class="literal">InnoDB</code> handle memory caching using its
        <a class="link" href="glossary.html#glos_buffer_pool" title="buffer pool">buffer pool</a> mechanism. Data
        modified through <span class="command"><strong>memcached</strong></span> operations such as
        <code class="literal">add</code>, <code class="literal">set</code>, and
        <code class="literal">incr</code> are stored to disk, in
        <code class="literal">InnoDB</code> tables. The combination of
        <span class="command"><strong>memcached</strong></span> simplicity and
        <code class="literal">InnoDB</code> reliability and consistency provides users
        with the best of both worlds, as explained in
        <a class="xref" href="innodb-storage-engine.html#innodb-memcached-benefits" title="14.20.1&nbsp;Benefits of the InnoDB memcached Plugin">Section&nbsp;14.20.1, “Benefits of the InnoDB memcached Plugin”</a>. For an architectural
        overview, see <a class="xref" href="innodb-storage-engine.html#innodb-memcached-intro" title="14.20.2&nbsp;InnoDB memcached Architecture">Section&nbsp;14.20.2, “InnoDB memcached Architecture”</a>.
    </p><p style="color:blue;">这个“nosql风格”接口使用memcached api来加速数据库操作，让innodb使用其缓冲池机制来处理内存缓存。通过memcached操作（如add、set和incr）修改的数据存储在innodb表中的磁盘上。memcached的简单性和innodb的可靠性和一致性的结合为用户提供了两个世界中最好的一面，如14.20.1节“innodb memcached插件的好处”所述。有关架构概述，请参阅第14.20.2节“InnoDB Memcached架构”。</p>
        <div class="section">

            <div class="titlepage">
                <div>
                    <div>
                        <h3 class="title"><a name="innodb-memcached-benefits"></a>14.20.1&nbsp;Benefits of the InnoDB memcached Plugin</h3>
                    </div>
                </div>
            </div>
            <p>
                This section outlines advantages the
                <code class="literal">daemon_memcached</code> plugin. The combination of
                <code class="literal">InnoDB</code> tables and <span class="command"><strong>memcached</strong></span>
                offers advantages over using either by themselves.
            </p><p style="color:blue;">本节概述daemon_memcached插件的优点。innodb tables和memcached的结合比单独使用两者都有优势。</p>
            <div class="itemizedlist">
                <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                    Direct access to the <code class="literal">InnoDB</code> storage engine
                    avoids the parsing and planning overhead of SQL.
                </p><p style="color:blue;">对innodb存储引擎的直接访问避免了sql的解析和规划开销。</p></li><li class="listitem"><p>
                    Running <span class="command"><strong>memcached</strong></span> in the same process space
                    as the MySQL server avoids the network overhead of passing
                    requests back and forth.
                </p><p style="color:blue;">在与mysql服务器相同的进程空间中运行memcached可以避免来回传递请求的网络开销。</p></li><li class="listitem"><p>
                    Data written using the <span class="command"><strong>memcached</strong></span> protocol
                    is transparently written to an <code class="literal">InnoDB</code>
                    table, without going through the MySQL SQL layer. You can
                    control frequency of writes to achieve higher raw performance
                    when updating non-critical data.
                </p><p style="color:blue;">使用memcached协议编写的数据可以透明地写入innodb表，而无需经过mysql sql层。您可以控制写入频率，以便在更新非关键数据时获得更高的原始性能。</p></li><li class="listitem"><p>
                    Data requested through the <span class="command"><strong>memcached</strong></span>
                    protocol is transparently queried from an
                    <code class="literal">InnoDB</code> table, without going through the
                    MySQL SQL layer.
                </p><p style="color:blue;">通过memcached协议请求的数据从innodb表中透明地查询，而不经过mysql sql层。</p></li><li class="listitem"><p>
                    Subsequent requests for the same data is served from the
                    <code class="literal">InnoDB</code> buffer pool. The buffer pool handles
                    the in-memory caching. You can tune performance of
                    data-intensive operations using <code class="literal">InnoDB</code>
                    configuration options.
                </p><p style="color:blue;">对相同数据的后续请求从innodb缓冲池提供。缓冲池处理内存中的缓存。您可以使用innodb配置选项来优化数据密集型操作的性能。</p></li><li class="listitem"><p>
                    Data can be unstructured or structured, depending on the type
                    of application. You can create a new table for data, or use
                    existing tables.
                </p><p style="color:blue;">数据可以是非结构化的，也可以是结构化的，这取决于应用程序的类型。可以为数据创建新表，也可以使用现有表。</p></li><li class="listitem"><p>
                    <code class="literal">InnoDB</code> can handle composing and decomposing
                    multiple column values into a single
                    <span class="command"><strong>memcached</strong></span> item value, reducing the amount
                    of string parsing and concatenation required in your
                    application. For example, you can store the string value
                    <code class="literal">2|4|6|8</code> in the <span class="command"><strong>memcached</strong></span>
                    cache, and have <code class="literal">InnoDB</code> split the value
                    based on a separator character, then store the result in four
                    numeric columns.
                </p><p style="color:blue;">innodb可以将多个列值组合和分解为单个memcached项值，从而减少应用程序中所需的字符串解析和连接量。例如，可以将字符串值2 4 6 8存储在memcached缓存中，并让innodb基于分隔符拆分该值，然后将结果存储在四个数字列中。</p></li><li class="listitem"><p>
                    The transfer between memory and disk is handled automatically,
                    simplifying application logic.
                </p><p style="color:blue;">内存和磁盘之间的传输是自动处理的，简化了应用程序逻辑。</p></li><li class="listitem"><p>
                    Data is stored in a MySQL database to protect against crashes,
                    outages, and corruption.
                </p><p style="color:blue;">数据存储在mysql数据库中，以防止崩溃、中断和损坏。</p></li><li class="listitem"><p>
                    You can access the underlying <code class="literal">InnoDB</code> table
                    through SQL for reporting, analysis, ad hoc queries, bulk
                    loading, multi-step transactional computations, set operations
                    such as union and intersection, and other operations suited to
                    the expressiveness and flexibility of SQL.
                </p><p style="color:blue;">您可以通过SQL访问底层的UNIB表，用于报告、分析、自组织查询、批量加载、多步事务性计算、集合操作和交叉点等操作，以及适合SQL的表达性和灵活性的其他操作。</p></li><li class="listitem"><p>
                    You can ensure high availability by using the
                    <code class="literal">daemon_memcached</code> plugin on a
                    <a class="link" href="glossary.html#glos_master_server" title="master server">master server</a> in
                    combination with MySQL replication.
                </p><p style="color:blue;">通过在主服务器上结合使用daemon_memcached插件和mysql复制，可以确保高可用性。</p></li></ul>
            </div>
            <div class="itemizedlist">
                <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                    The integration of <span class="command"><strong>memcached</strong></span> with MySQL
                    provides a way to make in-memory data persistent, so you can
                    use it for more significant kinds of data. You can use more
                    <code class="literal">add</code>, <code class="literal">incr</code>, and similar
                    write operations in your application without concern that data
                    could be lost. You can stop and start the
                    <span class="command"><strong>memcached</strong></span> server without losing updates
                    made to cached data. To guard against unexpected outages, you
                    can take advantage of <code class="literal">InnoDB</code> crash
                    recovery, replication, and backup capabilities.
                </p><p style="color:blue;">memcached与mysql的集成提供了一种使内存中数据持久化的方法，因此您可以将其用于更重要的数据类型。您可以在应用程序中使用更多的add、incr和类似的写操作，而不必担心数据可能丢失。您可以停止并启动memcached服务器，而不会丢失对缓存数据所做的更新。为了防止意外中断，您可以利用innodb崩溃恢复、复制和备份功能。</p></li><li class="listitem"><p>
                    The way <code class="literal">InnoDB</code> does fast
                    <a class="link" href="glossary.html#glos_primary_key" title="primary key">primary key</a> lookups is
                    a natural fit for <span class="command"><strong>memcached</strong></span> single-item
                    queries. The direct, low-level database access path used by
                    the <code class="literal">daemon_memcached</code> plugin is much more
                    efficient for key-value lookups than equivalent SQL queries.
                </p><p style="color:blue;">innodb快速查找主键的方式自然适合memcached单项查询。daemon_memcached插件使用的直接、低级数据库访问路径比等效的sql查询更有效地查找键值。</p></li><li class="listitem"><p>
                    The serialization features of <span class="command"><strong>memcached</strong></span>,
                    which can turn complex data structures, binary files, or even
                    code blocks into storeable strings, offer a simple way to get
                    such objects into a database.
                </p><p style="color:blue;">memcached的序列化特性可以将复杂的数据结构、二进制文件甚至代码块转换成可存储的字符串，为将这些对象转换成数据库提供了一种简单的方法。</p></li><li class="listitem"><p>
                    Because you can access the underlying data through SQL, you
                    can produce reports, search or update across multiple keys,
                    and call functions such as <code class="literal">AVG()</code> and
                    <code class="literal">MAX()</code> on <span class="command"><strong>memcached</strong></span> data.
                    All of these operations are expensive or complicated using
                    <span class="command"><strong>memcached</strong></span> by itself.
                </p><p style="color:blue;">因为可以通过sql访问底层数据，所以可以生成报表，跨多个键进行搜索或更新，并对memcached数据调用avg（）和max（）等函数。所有这些操作都是昂贵或复杂的使用memcached本身。</p></li><li class="listitem"><p>
                    You do not need to manually load data into
                    <span class="command"><strong>memcached</strong></span> at startup. As particular keys
                    are requested by an application, values are retrieved from the
                    database automatically, and cached in memory using the
                    <code class="literal">InnoDB</code>
                    <a class="link" href="glossary.html#glos_buffer_pool" title="buffer pool">buffer pool</a>.
                </p><p style="color:blue;">启动时不需要手动将数据加载到memcached中。当应用程序请求特定的键时，会自动从数据库中检索值，并使用innodb缓冲池缓存在内存中。</p></li><li class="listitem"><p>
                    Because <span class="command"><strong>memcached</strong></span> consumes relatively
                    little CPU, and its memory footprint is easy to control, it
                    can run comfortably alongside a MySQL instance on the same
                    system.
                </p><p style="color:blue;">由于memcached占用的cpu相对较少，而且其内存占用易于控制，因此它可以在同一个系统上与mysql实例一起轻松地运行。</p></li><li class="listitem"><p>
                    Because data consistency is enforced by mechanisms used for
                    regular <code class="literal">InnoDB</code> tables, you do not have to
                    worry about stale <span class="command"><strong>memcached</strong></span> data or
                    fallback logic to query the database in the case of a missing
                    key.
                </p><p style="color:blue;">因为数据一致性是由用于常规innodb表的机制强制实现的，所以在缺少键的情况下，不必担心过时的memcached数据或回退逻辑来查询数据库。</p></li></ul>
            </div>

        </div>
        <div class="section">
            <div class="titlepage">
                <div>
                    <div>
                        <h3 class="title"><a name="innodb-memcached-intro"></a>14.20.2&nbsp;InnoDB memcached Architecture</h3>

                    </div>

                </div>

            </div>
            <a class="indexterm" name="idm140286805903040"></a><p>
            The <code class="literal">InnoDB</code> <span class="command"><strong>memcached</strong></span> plugin
            implements <span class="command"><strong>memcached</strong></span> as a MySQL plugin daemon
            that accesses the <code class="literal">InnoDB</code> storage engine
            directly, bypassing the MySQL SQL layer.
        </p><p style="color:blue;">innodb memcached插件将memcached实现为一个mysql插件守护进程，它绕过mysql层直接访问innodb存储引擎。</p><p>
            The following diagram illustrates how an application accesses data
            through the <code class="literal">daemon_memcached</code> plugin, compared
            with SQL.
        </p><p style="color:blue;">下图说明了与sql相比，应用程序如何通过daemon_memcached插件访问数据。</p>
            <div class="figure">
                <a name="innodb-memcached-architecture-diagram"></a><p class="title"><b>Figure&nbsp;14.4&nbsp;MySQL Server with Integrated <span class="command">memcached</span> Server</b></p><p style="color:blue;">图14.4带有集成memcached服务器的mysql服务器</p>
                <div class="figure-contents">

                    <div class="mediaobject">
                        <img src="images/innodb_memcached2.jpg" width="554" height="414" alt="Shows an application accessing data in the InnoDB storage engine using both SQL and the memcached protocol. Using SQL, the application accesses data through the MySQL Server and Handler API. Using the memcached protocol, the application bypasses the MySQL Server, accessing data through the memcached plugin and InnoDB API. The memcached plugin is comprised of the innodb_memcache interface and optional local cache.">
                    </div>

                </div>

            </div>
            <br class="figure-break"><p>
            Features of the <code class="literal">daemon_memcached</code> plugin:
        </p><p style="color:blue;">daemon_memcached插件的功能：</p>
            <div class="itemizedlist">
                <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                    <span class="command"><strong>memcached</strong></span> as a daemon plugin of
                    <a class="link" href="programs.html#mysqld" title="4.3.1&nbsp;mysqld — The MySQL Server"><span class="command"><strong>mysqld</strong></span></a>. Both <a class="link" href="programs.html#mysqld" title="4.3.1&nbsp;mysqld — The MySQL Server"><span class="command"><strong>mysqld</strong></span></a> and
                    <span class="command"><strong>memcached</strong></span> run in the same process space,
                    with very low latency access to data.
                </p><p style="color:blue;">memcached作为mysqld的守护进程插件。mysqld和memcached都在同一个进程空间中运行，对数据的访问延迟非常低。</p></li><li class="listitem"><p>
                    Direct access to <code class="literal">InnoDB</code> tables, bypassing
                    the SQL parser, the optimizer, and even the Handler API layer.
                </p><p style="color:blue;">直接访问innodb表，绕过sql解析器、优化器，甚至处理程序api层。</p></li><li class="listitem"><p>
                    Standard <span class="command"><strong>memcached</strong></span> protocols, including the
                    text-based protocol and the binary protocol. The
                    <code class="literal">daemon_memcached</code> plugin passes all 55
                    compatibility tests of the <span class="command"><strong>memcapable</strong></span>
                    command.
                </p><p style="color:blue;">标准memcached协议，包括基于文本的协议和二进制协议。daemon_memcached插件通过memcapable命令的所有55个兼容性测试。</p></li><li class="listitem"><p>
                    Multi-column support. You can map multiple columns into the
                    <span class="quote">“<span class="quote">value</span>”</span> part of the key-value store, with column
                    values delimited by a user-specified separator character.
                </p><p style="color:blue;">多柱支撑。可以将多个列映射到键值存储的“值”部分，列值由用户指定的分隔符分隔。</p></li><li class="listitem"><p>
                    By default, the <span class="command"><strong>memcached</strong></span> protocol is used
                    to read and write data directly to <code class="literal">InnoDB</code>,
                    letting MySQL manage in-memory caching using the
                    <code class="literal">InnoDB</code>
                    <a class="link" href="glossary.html#glos_buffer_pool" title="buffer pool">buffer pool</a>. The
                    default settings represent a combination of high reliability
                    and the fewest surprises for database applications. For
                    example, default settings avoid uncommitted data on the
                    database side, or stale data returned for
                    <span class="command"><strong>memcached</strong></span> <code class="literal">get</code> requests.
                </p><p style="color:blue;">默认情况下，memcached协议用于直接向innodb读写数据，让mysql使用innodb缓冲池管理内存缓存。默认设置表示数据库应用程序的高可靠性和最少的意外。例如，默认设置避免数据库端的未提交数据，或为memcached get请求返回陈旧数据。</p></li><li class="listitem"><p>
                    Advanced users can configure the system as a traditional
                    <span class="command"><strong>memcached</strong></span> server, with all data cached only
                    in the <span class="command"><strong>memcached</strong></span> engine (memory caching),
                    or use a combination of the
                    <span class="quote">“<span class="quote"><span class="command"><strong>memcached</strong></span> engine</span>”</span> (memory
                    caching) and the <code class="literal">InnoDB</code>
                    <span class="command"><strong>memcached</strong></span> engine (<code class="literal">InnoDB</code>
                    as back-end persistent storage).
                </p><p style="color:blue;">高级用户可以将系统配置为传统的memcached服务器，所有数据只缓存在memcached引擎（内存缓存）中，或者使用“memcached引擎”（内存缓存）和innodb memcached引擎（innodb作为后端持久存储）的组合。</p></li></ul>
            </div>
            <div class="itemizedlist">
                <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                    Control over how often data is passed back and forth between
                    <code class="literal">InnoDB</code> and <span class="command"><strong>memcached</strong></span>
                    operations through the
                    <a class="link" href="innodb-storage-engine.html#sysvar_innodb_api_bk_commit_interval"><code class="literal">innodb_api_bk_commit_interval</code></a>,
                    <a class="link" href="innodb-storage-engine.html#sysvar_daemon_memcached_r_batch_size"><code class="literal">daemon_memcached_r_batch_size</code></a>,
                    and
                    <a class="link" href="innodb-storage-engine.html#sysvar_daemon_memcached_w_batch_size"><code class="literal">daemon_memcached_w_batch_size</code></a>
                    configuration options. Batch size options default to a value
                    of 1 for maximum reliability.
                </p><p style="color:blue;">控制通过innodb api_bk_commit_interval、daemon_memcached_r_batch_size和daemon_memcached_batch_size配置选项在innodb和memcached操作之间来回传递数据的频率。批处理大小选项默认值为1，以达到最大可靠性。</p></li><li class="listitem"><p>
                    The ability to specify <span class="command"><strong>memcached</strong></span> options
                    through the
                    <a class="link" href="innodb-storage-engine.html#sysvar_daemon_memcached_option"><code class="literal">daemon_memcached_option</code></a>
                    configuration parameter. For example, you can change the port
                    that <span class="command"><strong>memcached</strong></span> listens on, reduce the
                    maximum number of simultaneous connections, change the maximum
                    memory size for a key-value pair, or enable debugging messages
                    for the error log.
                </p><p style="color:blue;">通过daemon memcached选项配置参数指定memcached选项的能力。例如，可以更改MimcCask侦听的端口，减少同时连接的最大数量，更改键值对的最大内存大小，或者启用错误日志的调试消息。</p></li><li class="listitem"><p>
                    The <a class="link" href="innodb-storage-engine.html#sysvar_innodb_api_trx_level"><code class="literal">innodb_api_trx_level</code></a>
                    configuration option controls the transaction
                    <a class="link" href="glossary.html#glos_isolation_level" title="isolation level">isolation level</a> on
                    queries processed by <span class="command"><strong>memcached</strong></span>. Although
                    <span class="command"><strong>memcached</strong></span> has no concept of
                    <a class="link" href="glossary.html#glos_transaction" title="transaction">transactions</a>, you can
                    use this option to control how soon
                    <span class="command"><strong>memcached</strong></span> sees changes caused by SQL
                    statements issued on the table used by the
                    <span class="command"><strong>daemon_memcached</strong></span> plugin. By default,
                    <a class="link" href="innodb-storage-engine.html#sysvar_innodb_api_trx_level"><code class="literal">innodb_api_trx_level</code></a> is set
                    to <a class="link" href="innodb-storage-engine.html#isolevel_read-uncommitted"><code class="literal">READ UNCOMMITTED</code></a>.
                </p><p style="color:blue;">innodb_api_trx_level configuration选项控制memcached处理的查询的事务隔离级别。尽管memcached没有事务的概念，但是您可以使用此选项来控制memcached看到由守护进程memcached插件使用的表上发出的sql语句引起的更改的时间。默认情况下，innodb_api_trx_level设置为read uncommitted。</p></li><li class="listitem"><p>
                    The <a class="link" href="innodb-storage-engine.html#sysvar_innodb_api_enable_mdl"><code class="literal">innodb_api_enable_mdl</code></a>
                    option can be used to lock the table at the MySQL level, so
                    that the mapped table cannot be dropped or altered by
                    <a class="link" href="glossary.html#glos_ddl" title="DDL">DDL</a> through the SQL interface.
                    Without the lock, the table can be dropped from the MySQL
                    layer, but kept in <code class="literal">InnoDB</code> storage until
                    <span class="command"><strong>memcached</strong></span> or some other user stops using
                    it. <span class="quote">“<span class="quote">MDL</span>”</span> stands for <span class="quote">“<span class="quote">metadata
          locking</span>”</span>.
                </p><p style="color:blue;">innodb_api_enable_mdl选项可用于在mysql级别锁定表，这样ddl就不能通过sql接口删除或更改映射表。如果没有锁，表可以从mysql层删除，但是在memcached或其他用户停止使用它之前，它一直保存在innodb存储中。“mdl”代表“元数据锁定”。</p></li></ul>
            </div>
            <div class="simplesect">
                <div class="titlepage">
                    <div>
                        <div class="simple">
                            <h4 class="title"><a name="innodb-memcached-compare-contrast"></a>Differences Between InnoDB memcached and Traditional memcached</h4>

                        </div>

                    </div>

                </div>
                <p>
                    You may already be familiar with using
                    <span class="command"><strong>memcached</strong></span> with MySQL, as described in
                    <a class="ulink" href="https://dev.mysql.com/doc/refman/5.6/en/ha-memcached.html" target="_top">Using MySQL with <span class="command"><strong>memcached</strong></span></a>. This section describes how
                    features of the integrated <code class="literal">InnoDB</code>
                    <span class="command"><strong>memcached</strong></span> plugin differ from traditional
                    <code class="literal">memcached</code>.
                </p><p style="color:blue;">您可能已经熟悉了使用memcached with mysql，如使用mysql with memcached中所述。本节描述集成的innodb memcached插件的特性与传统的memcached有何不同。</p>
                <div class="itemizedlist">
                    <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                        Installation: The <span class="command"><strong>memcached</strong></span> library comes
                        with the MySQL server, making installation and setup
                        relatively easy. Installation involves running the
                        <code class="filename">innodb_memcached_config.sql</code> script to
                        create a <code class="literal">demo_test</code> table for
                        <span class="command"><strong>memcached</strong></span> to use, issuing an
                        <a class="link" href="sql-syntax.html#install-plugin" title="13.7.3.3&nbsp;INSTALL PLUGIN Syntax"><code class="literal">INSTALL PLUGIN</code></a> statement to
                        enable the <code class="literal">daemon_memcached</code> plugin, and
                        adding desired <span class="command"><strong>memcached</strong></span> options to a
                        MySQL configuration file or startup script. You might still
                        install the traditional <span class="command"><strong>memcached</strong></span>
                        distribution for additional utilities such as
                        <span class="command"><strong>memcp</strong></span>, <span class="command"><strong>memcat</strong></span>, and
                        <span class="command"><strong>memcapable</strong></span>.
                    </p><p style="color:blue;">安装：memcached库与mysql服务器一起提供，使得安装和设置相对容易。安装包括运行innodb_memcached_config.sql脚本来创建一个供memcached使用的demo_测试表，发出install plugin语句来启用daemon_memcached插件，以及向mysql配置文件或启动脚本添加所需的memcached选项。对于其他实用程序，如memcp、memcat和memcapable，您仍然可以安装传统的memcached发行版。</p><p>
                        For comparison with traditional
                        <span class="command"><strong>memcached</strong></span>, see
                        <a class="ulink" href="https://dev.mysql.com/doc/refman/5.6/en/ha-memcached-install.html" target="_top">Installing <span class="command"><strong>memcached</strong></span></a>.
                    </p><p style="color:blue;">有关与传统memcached的比较，请参阅安装memcached。</p></li><li class="listitem"><p>
                        Deployment: With traditional <span class="command"><strong>memcached</strong></span>,
                        it is typical to run large numbers of low-capacity
                        <span class="command"><strong>memcached</strong></span> servers. A typical deployment
                        of the <code class="literal">daemon_memcached</code> plugin, however,
                        involves a smaller number of moderate or high-powered
                        servers that are already running MySQL. The benefit of this
                        configuration is in improving efficiency of individual
                        database servers rather than exploiting unused memory or
                        distributing lookups across large numbers of servers. In the
                        default configuration, very little memory is used for
                        <span class="command"><strong>memcached</strong></span>, and in-memory lookups are
                        served from the <code class="literal">InnoDB</code>
                        <a class="link" href="glossary.html#glos_buffer_pool" title="buffer pool">buffer pool</a>, which
                        automatically caches the most recently and frequently used
                        data. As with a traditional MySQL server instance, keep the
                        value of the
                        <a class="link" href="innodb-storage-engine.html#sysvar_innodb_buffer_pool_size"><code class="literal">innodb_buffer_pool_size</code></a>
                        configuration option as high as practical (without causing
                        paging at the OS level), so that as much work as possible is
                        performed in memory.
                    </p><p style="color:blue;">部署：对于传统的memcached，运行大量的低容量memcached服务器是很典型的。不过，daemon_memcached插件的典型部署涉及少量已经运行mysql的中等或高性能服务器。这种配置的好处在于提高单个数据库服务器的效率，而不是利用未使用的内存或跨大量服务器分发查找。在默认配置中，memcached只使用很少的内存，而innodb缓冲池提供内存内查找，它自动缓存最新和最常用的数据。与传统的mysql服务器实例一样，保持innodb_buffer_pool_size配置选项的值尽可能高（不会在操作系统级别造成分页），以便在内存中执行尽可能多的工作。</p><p>
                        For comparison with traditional
                        <span class="command"><strong>memcached</strong></span>, see
                        <a class="ulink" href="https://dev.mysql.com/doc/refman/5.6/en/ha-memcached-using-deployment.html" target="_top"><span class="command"><strong>memcached</strong></span> Deployment</a>.
                    </p><p style="color:blue;">有关与传统memcached的比较，请参阅memcached部署。</p></li><li class="listitem"><p>
                        Expiry: By default (that is, using the
                        <code class="literal">innodb_only</code> caching policy), the latest
                        data from the <code class="literal">InnoDB</code> table is always
                        returned, so the expiry options have no practical effect. If
                        you change the caching policy to <code class="literal">caching</code>
                        or <code class="literal">cache_only</code>, the expiry options work as
                        usual, but requested data might be stale if it is updated in
                        the underlying table before it expires from the memory
                        cache.
                    </p><p style="color:blue;">expiry：默认情况下（即使用innodb_only缓存策略），总是返回innodb表中的最新数据，因此expiry选项没有实际效果。如果将缓存策略更改为“仅缓存”或“仅缓存”，则到期选项将正常工作，但如果请求的数据在从内存缓存过期之前在基础表中更新，则可能会过时。</p><p>
                        For comparison with traditional
                        <span class="command"><strong>memcached</strong></span>, see
                        <a class="ulink" href="https://dev.mysql.com/doc/refman/5.6/en/ha-memcached-using-expiry.html" target="_top">Data Expiry</a>.
                    </p><p style="color:blue;">有关与传统memcached的比较，请参见数据过期。</p></li><li class="listitem"><p>
                        Namespaces: <span class="command"><strong>memcached</strong></span> is like a large
                        directory where you give files elaborate names with prefixes
                        and suffixes to keep the files from conflicting. The
                        <code class="literal">daemon_memcached</code> plugin lets you use
                        similar naming conventions for keys, with one addition. Key
                        names in the format
                        <code class="literal">@@<em class="replaceable"><code>table_id</code></em>.<em class="replaceable"><code>key</code></em></code>.<em class="replaceable"><code>table_id</code></em>
                        are decoded to reference a specific a table, using mapping
                        data from the <code class="literal">innodb_memcache.containers</code>
                        table. The <em class="replaceable"><code>key</code></em> is looked up in or
                        written to the specified table.
                    </p><p style="color:blue;">namespaces:memcached就像一个大目录，在这个目录中，您可以为文件提供带有前缀和后缀的详细名称，以避免文件冲突。daemon_memcached插件允许您对键使用类似的命名约定，只需添加一个。使用来自innodb_memcache.containers表的映射数据，解码格式为@table_id.key.table_id的密钥名以引用特定的a表。键在指定表中查找或写入。</p><p>
                        The <code class="literal">@@</code> notation only works for individual
                        calls to <code class="literal">get</code>, <code class="literal">add</code>, and
                        <code class="literal">set</code> functions, but not others such as
                        <code class="literal">incr</code> or <code class="literal">delete</code>. To
                        designate a default table for subsequent
                        <span class="command"><strong>memcached</strong></span> operations within a session,
                        perform a <code class="literal">get</code> request using the
                        <code class="literal">@@</code> notation with a
                        <code class="literal"><em class="replaceable"><code>table_id</code></em></code>, but
                        without the key portion. For example:
                    </p><p style="color:blue;">@@符号只适用于get、add和set函数的单个调用，而不适用于incr或delete等其他调用。若要为会话中的后续memcached操作指定默认表，请使用带表id但不带键部分的@@符号执行get请求。例如：</p><pre data-lang="terminal" class="programlisting">get @@<em class="replaceable"><code>table_id</code></em>
</pre><p>
                        Subsequent <code class="literal">get</code>, <code class="literal">set</code>,
                        <code class="literal">incr</code>, <code class="literal">delete</code>, and
                        other operations use the table designated by
                        <code class="literal"><em class="replaceable"><code>table_id</code></em></code> in
                        the <code class="literal">innodb_memcache.containers.name</code>
                        column.
                    </p><p style="color:blue;">随后的get、set、incr、delete和其他操作使用innodb_memcache.containers.name列中table_id指定的表。</p><p>
                        For comparison with traditional
                        <span class="command"><strong>memcached</strong></span>, see
                        <a class="ulink" href="https://dev.mysql.com/doc/refman/5.6/en/ha-memcached-using-namespaces.html" target="_top">Using Namespaces</a>.
                    </p><p style="color:blue;">有关与传统memcached的比较，请参见使用名称空间。</p></li><li class="listitem"><p>
                        Hashing and distribution: The default configuration, which
                        uses the <code class="literal">innodb_only</code> caching policy, is
                        suitable for a traditional deployment configuration where
                        all data is available on all servers, such as a set of
                        replication slave servers.
                    </p><p style="color:blue;">散列和分发：默认配置使用innodb_only缓存策略，适用于传统的部署配置，其中所有服务器（如一组复制从属服务器）上都有可用的数据。</p><p>
                        If you physically divide data, as in a sharded
                        configuration, you can split data across several machines
                        running the <code class="literal">daemon_memcached</code> plugin, and
                        use the traditional <span class="command"><strong>memcached</strong></span> hashing
                        mechanism to route requests to a particular machine. On the
                        MySQL side, you would typically let all data be inserted by
                        <code class="literal">add</code> requests to
                        <span class="command"><strong>memcached</strong></span> so that appropriate values are
                        stored in the database on the appropriate server.
                    </p><p style="color:blue;">如果像在分片配置中那样对数据进行物理分割，则可以在运行daemon_memcached插件的多台计算机上分割数据，并使用传统的memcached哈希机制将请求路由到特定的计算机。在mysql方面，通常通过向memcached添加请求来插入所有数据，以便将适当的值存储在适当服务器上的数据库中。</p><p>
                        For comparison with traditional
                        <span class="command"><strong>memcached</strong></span>, see
                        <a class="ulink" href="https://dev.mysql.com/doc/refman/5.6/en/ha-memcached-using-hashtypes.html" target="_top"><span class="command"><strong>memcached</strong></span> Hashing/Distribution Types</a>.
                    </p><p style="color:blue;">有关与传统memcached的比较，请参阅memcached散列/分发类型。</p></li><li class="listitem"><p>
                        Memory usage: By default (with the
                        <code class="literal">innodb_only</code> caching policy), the
                        <span class="command"><strong>memcached</strong></span> protocol passes information
                        back and forth with <code class="literal">InnoDB</code> tables, and
                        the <code class="literal">InnoDB</code> buffer pool handles in-memory
                        lookups instead of <span class="command"><strong>memcached</strong></span> memory usage
                        growing and shrinking. Relatively little memory is used on
                        the <span class="command"><strong>memcached</strong></span> side.
                    </p><p style="color:blue;">内存使用：默认情况下（使用innodb_only caching策略），memcached协议通过innodb表来回传递信息，innodb缓冲池处理内存查找，而不是memcached内存使用的增长和收缩。memcached端使用的内存相对较少。</p><p>
                        If you switch the caching policy to
                        <code class="literal">caching</code> or <code class="literal">cache_only</code>,
                        the normal rules of <span class="command"><strong>memcached</strong></span> memory
                        usage apply. Memory for <span class="command"><strong>memcached</strong></span> data
                        values is allocated in terms of <span class="quote">“<span class="quote">slabs</span>”</span>. You
                        can control slab size and maximum memory used for
                        <span class="command"><strong>memcached</strong></span>.
                    </p><p style="color:blue;">如果将缓存策略切换到“缓存”或“仅缓存”，则应用memcached内存使用的常规规则。memcached数据值的内存按“slab”分配。您可以控制用于MycCurk的板大小和最大内存。</p><p>
                        Either way, you can monitor and troubleshoot the
                        <code class="literal">daemon_memcached</code> plugin using the
                        familiar
                        <a class="ulink" href="https://dev.mysql.com/doc/refman/5.6/en/ha-memcached-stats.html" target="_top">statistics</a> system,
                        accessed through the standard protocol, over a
                        <span class="command"><strong>telnet</strong></span> session, for example. Extra
                        utilities are not included with the
                        <code class="literal">daemon_memcached</code> plugin. You can use the
                        <a class="ulink" href="https://dev.mysql.com/doc/refman/5.6/en/ha-memcached-stats-memcached-tool.html" target="_top"><code class="literal">memcached-tool</code>
                            script</a> to install a full <span class="command"><strong>memcached</strong></span>
                        distribution.
                    </p><p style="color:blue;">无论哪种方式，您都可以使用熟悉的统计系统（例如，通过标准协议通过telnet会话访问）监视守护进程memcached插件并进行故障排除。守护程序memcached插件不包括额外的实用程序。您可以使用memcached工具脚本安装完整的memcached发行版。</p><p>
                        For comparison with traditional
                        <span class="command"><strong>memcached</strong></span>, see
                        <a class="ulink" href="https://dev.mysql.com/doc/refman/5.6/en/ha-memcached-using-memory.html" target="_top">Memory Allocation within <span class="command"><strong>memcached</strong></span></a>.
                    </p><p style="color:blue;">有关与传统memcached的比较，请参阅memcached中的内存分配。</p></li><li class="listitem"><p>
                        Thread usage: MySQL threads and <span class="command"><strong>memcached</strong></span>
                        threads co-exist on the same server. Limits imposed on
                        threads by the operating system apply to the total number of
                        threads.
                    </p><p style="color:blue;">线程使用：MySQL线程和MycCask线程共存于同一服务器上。操作系统对线程施加的限制适用于线程总数。</p><p>
                        For comparison with traditional
                        <span class="command"><strong>memcached</strong></span>, see
                        <a class="ulink" href="https://dev.mysql.com/doc/refman/5.6/en/ha-memcached-using-threads.html" target="_top"><span class="command"><strong>memcached</strong></span> Thread Support</a>.
                    </p><p style="color:blue;">有关与传统memcached的比较，请参阅memcached线程支持。</p></li><li class="listitem"><p>
                        Log usage: Because the <span class="command"><strong>memcached</strong></span> daemon
                        is run alongside the MySQL server and writes to
                        <code class="literal">stderr</code>, the <code class="literal">-v</code>,
                        <code class="literal">-vv</code>, and <code class="literal">-vvv</code> options
                        for logging write output to the MySQL
                        <a class="link" href="glossary.html#glos_error_log" title="error log">error log</a>.
                    </p><p style="color:blue;">日志用法：因为memcached守护进程与mysql服务器一起运行，并写入stderr，-v，-vv和-vvv选项，用于将写入输出记录到mysql错误日志。</p><p>
                        For comparison with traditional
                        <span class="command"><strong>memcached</strong></span>, see
                        <a class="ulink" href="https://dev.mysql.com/doc/refman/5.6/en/ha-memcached-using-logs.html" target="_top"><span class="command"><strong>memcached</strong></span> Logs</a>.
                    </p><p style="color:blue;">有关与传统memcached的比较，请参阅memcached日志。</p></li><li class="listitem"><p>
                        <span class="command"><strong>memcached</strong></span> operations: Familiar
                        <span class="command"><strong>memcached</strong></span> operations such as
                        <code class="literal">get</code>, <code class="literal">set</code>,
                        <code class="literal">add</code>, and <code class="literal">delete</code> are
                        available. Serialization (that is, the exact string format
                        representing complex data structures) depends on the
                        language interface.
                    </p><p style="color:blue;">memcached操作：提供熟悉的memcached操作，如get、set、add和delete。序列化（即表示复杂数据结构的确切字符串格式）取决于语言接口。</p><p>
                        For comparison with traditional
                        <span class="command"><strong>memcached</strong></span>, see
                        <a class="ulink" href="https://dev.mysql.com/doc/refman/5.6/en/ha-memcached-operations.html" target="_top">Basic <span class="command"><strong>memcached</strong></span> Operations</a>.
                    </p><p style="color:blue;">有关与传统memcached的比较，请参阅基本memcached操作。</p></li><li class="listitem"><p>
                        Using <span class="command"><strong>memcached</strong></span> as a MySQL front end:
                        This is the primary purpose of the <code class="literal">InnoDB</code>
                        <span class="command"><strong>memcached</strong></span> plugin. An integrated
                        <span class="command"><strong>memcached</strong></span> daemon improves application
                        performance, and having <code class="literal">InnoDB</code> handle
                        data transfers between memory and disk simplifies
                        application logic.
                    </p><p style="color:blue;">使用memcached作为mysql前端：这是innodb memcached插件的主要目的。集成的memcached守护进程提高了应用程序的性能，而让innodb处理内存和磁盘之间的数据传输简化了应用程序逻辑。</p><p>
                        For comparison with traditional
                        <span class="command"><strong>memcached</strong></span>, see
                        <a class="ulink" href="https://dev.mysql.com/doc/refman/5.6/en/ha-memcached-mysql-frontend.html" target="_top">Using <span class="command"><strong>memcached</strong></span> as a MySQL Caching Layer</a>.
                    </p><p style="color:blue;">有关与传统memcached的比较，请参见将memcached用作mysql缓存层。</p></li><li class="listitem"><p>
                        Utilities: The MySQL server includes the
                        <code class="literal">libmemcached</code> library but not additional
                        command-line utilities. To use commands such as
                        <span class="command"><strong>memcp</strong></span>, <span class="command"><strong>memcat</strong></span>, and
                        <span class="command"><strong>memcapable</strong></span> commands, install a full
                        <span class="command"><strong>memcached</strong></span> distribution. When
                        <span class="command"><strong>memrm</strong></span> and <span class="command"><strong>memflush</strong></span>
                        remove items from the cache, the items are also removed from
                        the underlying <code class="literal">InnoDB</code> table.
                    </p><p style="color:blue;">实用程序：mysql服务器包括libmemcached库，但不包括其他命令行实用程序。要使用memcp、memcat和memcapable命令，请安装完整的memcached分发版。当memrm和memflush从缓存中移除项时，这些项也会从底层的innodb表中移除。</p><p>
                        For comparison with traditional
                        <span class="command"><strong>memcached</strong></span>, see
                        <a class="ulink" href="https://dev.mysql.com/doc/refman/5.6/en/ha-memcached-interfaces-libmemcached.html#ha-memcached-interfaces-libmemcached-utilities" target="_top"><span class="command"><strong>libmemcached</strong></span> Command-Line Utilities</a>.
                    </p><p style="color:blue;">有关与传统memcached的比较，请参见libmemcached命令行实用程序。</p></li><li class="listitem"><p>
                        Programming interfaces: You can access the MySQL server
                        through the <code class="literal">daemon_memcached</code> plugin using
                        all supported languages:
                        <a class="ulink" href="https://dev.mysql.com/doc/refman/5.6/en/ha-memcached-interfaces-libmemcached.html" target="_top">C and
                            C++</a>,
                        <a class="ulink" href="https://dev.mysql.com/doc/refman/5.6/en/ha-memcached-interfaces-java.html" target="_top">Java</a>,
                        <a class="ulink" href="https://dev.mysql.com/doc/refman/5.6/en/ha-memcached-interfaces-perl.html" target="_top">Perl</a>,
                        <a class="ulink" href="https://dev.mysql.com/doc/refman/5.6/en/ha-memcached-interfaces-python.html" target="_top">Python</a>,
                        <a class="ulink" href="https://dev.mysql.com/doc/refman/5.6/en/ha-memcached-interfaces-php.html" target="_top">PHP</a>, and
                        <a class="ulink" href="https://dev.mysql.com/doc/refman/5.6/en/ha-memcached-interfaces-ruby.html" target="_top">Ruby</a>.
                        Specify the server hostname and port as with a traditional
                        <span class="command"><strong>memcached</strong></span> server. By default, the
                        <code class="literal">daemon_memcached</code> plugin listens on port
                        <code class="literal">11211</code>. You can use both the
                        <a class="ulink" href="https://dev.mysql.com/doc/refman/5.6/en/ha-memcached-interfaces-protocol.html" target="_top">text and
                            binary protocols</a>. You can customize the
                        <a class="ulink" href="https://dev.mysql.com/doc/refman/5.6/en/ha-memcached-interfaces-libmemcached.html#ha-memcached-interfaces-libmemcached-behaviors" target="_top">behavior</a>
                        of <span class="command"><strong>memcached</strong></span> functions at runtime.
                        Serialization (that is, the exact string format representing
                        complex data structures) depends on the language interface.
                    </p><p style="color:blue;">编程接口：您可以通过使用所有支持的语言：C和C++、Java、Perl、Python、PHP和Ruby来访问MySQL服务器。指定与传统memcached服务器相同的服务器主机名和端口。默认情况下，daemon_memcached插件监听端口11211。您可以同时使用文本和二进制协议。您可以在运行时自定义memcached函数的行为。序列化（即表示复杂数据结构的确切字符串格式）取决于语言接口。</p><p>
                        For comparison with traditional
                        <span class="command"><strong>memcached</strong></span>, see
                        <a class="ulink" href="https://dev.mysql.com/doc/refman/5.6/en/ha-memcached-interfaces.html" target="_top">Developing a <span class="command"><strong>memcached</strong></span> Application</a>.
                    </p><p style="color:blue;">有关与传统memcached的比较，请参见开发memcached应用程序。</p></li><li class="listitem"><p>
                        Frequently asked questions: MySQL has an extensive FAQ for
                        traditional <span class="command"><strong>memcached</strong></span>. The FAQ is mostly
                        applicable, except that using <code class="literal">InnoDB</code>
                        tables as a storage medium for <span class="command"><strong>memcached</strong></span>
                        data means that you can use <span class="command"><strong>memcached</strong></span> for
                        more write-intensive applications than before, rather than
                        as a read-only cache.
                    </p><p style="color:blue;">常见问题解答：mysql对传统memcached有广泛的常见问题解答。常见问题解答主要适用，除了使用innodb tables作为memcached数据的存储介质意味着您可以将memcached用于比以前更密集的写应用程序，而不是作为只读缓存。</p><p>
                        See <a class="ulink" href="https://dev.mysql.com/doc/refman/5.6/en/ha-memcached-faq.html" target="_top"><span class="command"><strong>memcached</strong></span> FAQ</a>.
                    </p><p style="color:blue;">参见memcached常见问题解答。</p></li></ul>
                </div>

            </div>

        </div>
        <div class="section">
            <div class="titlepage">
                <div>
                    <div>
                        <h3 class="title"><a name="innodb-memcached-setup"></a>14.20.3&nbsp;Setting Up the InnoDB memcached Plugin</h3>

                    </div>

                </div>

            </div>
            <p>
                This section describes how to set up the
                <code class="literal">daemon_memcached</code> plugin on a MySQL server.
                Because the <span class="command"><strong>memcached</strong></span> daemon is tightly
                integrated with the MySQL server to avoid network traffic and
                minimize latency, you perform this process on each MySQL instance
                that uses this feature.
            </p><p style="color:blue;">本节介绍如何在mysql服务器上设置daemon_memcached插件。由于memcached守护进程与mysql服务器紧密集成，以避免网络流量和最小化延迟，因此可以在使用此功能的每个mysql实例上执行此过程。</p>
            <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">

                <div class="admon-title">
                    Note
                </div>
                <p>
                    Before setting up the <code class="literal">daemon_memcached</code>
                    plugin, consult <a class="xref" href="innodb-storage-engine.html#innodb-memcached-security" title="14.20.4&nbsp;Security Considerations for the InnoDB memcached Plugin">Section&nbsp;14.20.4, “Security Considerations for the InnoDB memcached Plugin”</a> to
                    understand the security procedures required to prevent
                    unauthorized access.
                </p><p style="color:blue;">在设置daemon_memcached插件之前，请参考第14.20.4节“innodb memcached插件的安全注意事项”，了解防止未经授权访问所需的安全过程。</p>
            </div>
            <div class="simplesect">
                <div class="titlepage">
                    <div>
                        <div class="simple">
                            <h4 class="title"><a name="innodb-memcached-prereqs"></a>Prerequisites</h4>

                        </div>

                    </div>

                </div>
                <div class="itemizedlist">
                    <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                        The <code class="literal">daemon_memcached</code> plugin is only
                        supported on Linux, Solaris, and OS X platforms. Other
                        operating systems are not supported.
                    </p><p style="color:blue;">daemon_memcached插件仅在linux、solaris和os x平台上受支持。不支持其他操作系统。</p></li><li class="listitem"><p>
                        When building MySQL from source, you must build with
                        <a class="link" href="installing.html#option_cmake_with_innodb_memcached"><code class="option">-DWITH_INNODB_MEMCACHED=ON</code></a>.
                        This build option generates two shared libraries in the
                        MySQL plugin directory
                        (<a class="link" href="server-administration.html#sysvar_plugin_dir"><code class="literal">plugin_dir</code></a>) that are
                        required to run the <code class="literal">daemon_memcached</code>
                        plugin:
                    </p><p style="color:blue;">从源代码构建MySQL时，必须使用-dwith_innodb_memcached=on构建。此生成选项在mysql插件目录（plugin目录）中生成运行daemon memcached插件所需的两个共享库：</p>
                        <div class="itemizedlist">
                            <ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
                                <code class="filename">libmemcached.so</code>: the
                                <span class="command"><strong>memcached</strong></span> daemon plugin to MySQL.
                            </p><p style="color:blue;">libmemcached.so:mysql的memcached守护进程插件。</p></li><li class="listitem"><p>
                                <code class="filename">innodb_engine.so</code>: an
                                <code class="literal">InnoDB</code> API plugin to
                                <span class="command"><strong>memcached</strong></span>.
                            </p><p style="color:blue;">innodb_engine.so：memcached的innodb api插件。</p></li></ul>
                        </div>
                    </li><li class="listitem"><p>
                        <code class="literal">libevent</code> must be installed.
                    </p><p style="color:blue;">必须安装libevent。</p>
                        <div class="itemizedlist">
                            <ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
                                If you did not build MySQL from source, the
                                <code class="literal">libevent</code> library is not included in
                                your installation. Use the installation method for your
                                operating system to install <code class="literal">libevent</code>
                                1.4.12 or later. For example, depending on the operating
                                system, you might use <code class="literal">apt-get</code>,
                                <code class="literal">yum</code>, or <code class="literal">port
                                install</code>. For example, on Ubuntu Linux, use:
                            </p><p style="color:blue;">如果不是从源代码构建MySQL，则安装中不包括libevent库。使用操作系统的安装方法安装libevent 1.4.12或更高版本。例如，根据操作系统的不同，可以使用apt-get、yum或port-install。例如，在ubuntu linux上，使用：</p><pre data-lang="terminal" class="programlisting">sudo apt-get install libevent-dev
</pre></li><li class="listitem"><p>
                                If you installed MySQL from a source code release,
                                <code class="literal">libevent</code> 1.4.12 is bundled with the
                                package and is located at the top level of the MySQL
                                source code directory. If you use the bundled version of
                                <code class="literal">libevent</code>, no action is required. If
                                you want to use a local system version of
                                <code class="literal">libevent</code>, you must build MySQL with
                                the <a class="link" href="installing.html#option_cmake_with_libevent"><code class="option">-DWITH_LIBEVENT</code></a> build
                                option set to <code class="literal">system</code> or
                                <code class="literal">yes</code>.
                            </p><p style="color:blue;">如果从源代码版本安装mysql，libevent 1.4.12将与包捆绑在一起，位于mysql源代码目录的顶层。如果使用libevent的捆绑版本，则不需要执行任何操作。如果要使用本地系统版本的libevent，则必须在-dwith_libevent build选项设置为system或yes的情况下构建mysql。</p></li></ul>
                        </div>
                    </li></ul>
                </div>

            </div>

            <div class="simplesect">

                <div class="titlepage">
                    <div>

                        <div class="simple">
                            <h4 class="title"><a name="innodb-memcached-installing"></a>Installing and Configuring the InnoDB memcached Plugin</h4>

                        </div>

                    </div>

                </div>
                <a class="indexterm" name="idm140286805668992"></a><a class="indexterm" name="idm140286805667952"></a><a class="indexterm" name="idm140286805666880"></a>
                <div class="orderedlist">
                    <ol class="orderedlist" type="1"><li class="listitem"><p>
                        Configure the <code class="literal">daemon_memcached</code> plugin so
                        it can interact with <code class="literal">InnoDB</code> tables by
                        running the <code class="filename">innodb_memcached_config.sql</code>
                        configuration script, which is located in
                        <code class="filename"><em class="replaceable"><code>MYSQL_HOME</code></em>/share</code>.
                        This script installs the <code class="literal">innodb_memcache</code>
                        database with three required tables
                        (<code class="literal">cache_policies</code>,
                        <code class="literal">config_options</code>, and
                        <code class="literal">containers</code>). It also installs the
                        <code class="literal">demo_test</code> sample table in the
                        <code class="literal">test</code> database.
                    </p><p style="color:blue;">配置daemon_memcached插件，以便它可以通过运行位于mysql_home/share中的innodb_memcached_config.sql配置脚本与innodb表交互。此脚本安装带有三个必需表（cache策略、配置选项和容器）的innodb_memcache数据库。它还将demo_test sample表安装到测试数据库中。</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>source <em class="replaceable"><code>MYSQL_HOME</code></em>/share/innodb_memcached_config.sql</code></strong>
</pre><p>
                        Running the <code class="filename">innodb_memcached_config.sql</code>
                        script is a one-time operation. The tables remain in place
                        if you later uninstall and re-install the
                        <code class="literal">daemon_memcached</code> plugin.
                    </p><p style="color:blue;">运行innodb_memcached_config.sql脚本是一次性操作。如果您稍后卸载并重新安装daemon_memcached插件，那么这些表将保持原位。</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>USE innodb_memcache;</code></strong>
mysql&gt; <strong class="userinput"><code>SHOW TABLES;</code></strong>
+---------------------------+
| Tables_in_innodb_memcache |
+---------------------------+
| cache_policies            |
| config_options            |
| containers                |
+---------------------------+

mysql&gt; <strong class="userinput"><code>USE test;</code></strong>
mysql&gt; <strong class="userinput"><code>SHOW TABLES;</code></strong>
+----------------+
| Tables_in_test |
+----------------+
| demo_test      |
+----------------+
</pre><p>
                        Of these tables, the
                        <code class="literal">innodb_memcache.containers</code> table is the
                        most important. Entries in the <code class="literal">containers</code>
                        table provide a mapping to <code class="literal">InnoDB</code> table
                        columns. Each <code class="literal">InnoDB</code> table used with the
                        <code class="literal">daemon_memcached</code> plugin requires an entry
                        in the <code class="literal">containers</code> table.
                    </p><p style="color:blue;">在这些表中，innodb_memcache.containers表是最重要的。containers表中的条目提供到innodb表列的映射。与daemon_memcached插件一起使用的每个innodb表都需要容器表中的一个条目。</p><p>
                        The <code class="filename">innodb_memcached_config.sql</code> script
                        inserts a single entry in the <code class="literal">containers</code>
                        table that provides a mapping for the
                        <code class="literal">demo_test</code> table. It also inserts a single
                        row of data into the <code class="literal">demo_test</code> table.
                        This data allows you to immediately verify the installation
                        after the setup is completed.
                    </p><p style="color:blue;">innodb_memcached_config.sql脚本在containers表中插入一个条目，为demo_测试表提供映射。它还将一行数据插入到demo_测试表中。此数据允许您在安装完成后立即验证安装。</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT * FROM innodb_memcache.containers\G</code></strong>
*************************** 1. row ***************************
                  name: aaa
             db_schema: test
              db_table: demo_test
           key_columns: c1
         value_columns: c2
                 flags: c3
            cas_column: c4
    expire_time_column: c5
unique_idx_name_on_key: PRIMARY

mysql&gt; <strong class="userinput"><code>SELECT * FROM test.demo_test;</code></strong>
+----+------------------+------+------+------+
| c1 | c2               | c3   | c4   | c5   |
+----+------------------+------+------+------+
| AA | HELLO, HELLO     |    8 |    0 |    0 |
+----+------------------+------+------+------+
</pre><p>
                        For more information about
                        <code class="literal">innodb_memcache</code> tables and the
                        <code class="literal">demo_test</code> sample table, see
                        <a class="xref" href="innodb-storage-engine.html#innodb-memcached-internals" title="14.20.7&nbsp;InnoDB memcached Plugin Internals">Section&nbsp;14.20.7, “InnoDB memcached Plugin Internals”</a>.
                    </p><p style="color:blue;">有关innodb_memcache表和demo_test sample表的更多信息，请参阅第14.20.7节“innodb memcached plugin internals”。</p></li><li class="listitem"><p>
                        Activate the <code class="literal">daemon_memcached</code> plugin by
                        running the <a class="link" href="sql-syntax.html#install-plugin" title="13.7.3.3&nbsp;INSTALL PLUGIN Syntax"><code class="literal">INSTALL PLUGIN</code></a>
                        statement:
                    </p><p style="color:blue;">通过运行install plugin语句激活daemon_memcached插件：</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>INSTALL PLUGIN daemon_memcached soname "libmemcached.so";</code></strong>
</pre><p>
                        Once the plugin is installed, it is automatically activated
                        each time the MySQL server is restarted.
                    </p><p style="color:blue;">一旦插件安装完毕，每次mysql服务器重新启动时都会自动激活它。</p></li></ol>
                </div>

            </div>
            <div class="simplesect">
                <div class="titlepage">
                    <div>
                        <div class="simple">
                            <h4 class="title"><a name="innodb-memcached-snifftest"></a>Verifying the InnoDB and memcached Setup</h4>

                        </div>

                    </div>

                </div>
                <p>
                    To verify the <code class="literal">daemon_memcached</code> plugin setup,
                    use a <span class="command"><strong>telnet</strong></span> session to issue
                    <span class="command"><strong>memcached</strong></span> commands. By default, the
                    <span class="command"><strong>memcached</strong></span> daemon listens on port 11211.
                </p><p style="color:blue;">要验证守护进程memcached插件设置，请使用telnet会话发出memcached命令。默认情况下，memcached守护进程监听端口11211。</p>
                <div class="orderedlist">
                    <ol class="orderedlist" type="1"><li class="listitem"><p>
                        Retrieve data from the <code class="literal">test.demo_test</code>
                        table. The single row of data in the
                        <code class="literal">demo_test</code> table has a key value of
                        <code class="literal">AA</code>.
                    </p><p style="color:blue;">从test.demo_测试表中检索数据。demo_测试表中的单行数据的键值为a a。</p><pre data-lang="terminal" class="programlisting"><strong class="userinput"><code>telnet localhost 11211</code></strong>
Trying 127.0.0.1...
Connected to localhost.
Escape character is '^]'.
<strong class="userinput"><code>get AA</code></strong>
VALUE AA 8 12
HELLO, HELLO
END
</pre></li><li class="listitem"><p>
                        Insert data using a <code class="literal">set</code> command.
                    </p><p style="color:blue;">使用set命令插入数据。</p><pre data-lang="terminal" class="programlisting"><strong class="userinput"><code>set BB 10 0 16</code></strong>
<strong class="userinput"><code>GOODBYE, GOODBYE</code></strong>
STORED
</pre><p>
                        where:
                    </p><p style="color:blue;">在哪里？</p>
                        <div class="itemizedlist">
                            <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                                <code class="literal">set</code> is the command to store a value
                            </p><p style="color:blue;">set是存储值的命令</p></li><li class="listitem"><p>
                                <code class="literal">BB</code> is the key
                            </p><p style="color:blue;">BB是关键</p></li><li class="listitem"><p>
                                <code class="literal">10</code> is a flag for the operation;
                                ignored by <span class="command"><strong>memcached</strong></span> but may be used
                                by the client to indicate any type of information;
                                specify <code class="literal">0</code> if unused
                            </p><p style="color:blue;">10是操作的标志；memcached忽略，但客户端可以使用它来指示任何类型的信息；如果未使用，请指定0</p></li><li class="listitem"><p>
                                <code class="literal">0</code> is the expiration time (TTL);
                                specify <code class="literal">0</code> if unused
                            </p><p style="color:blue;">0是过期时间（ttl）；如果未使用，请指定0</p></li><li class="listitem"><p>
                                <code class="literal">16</code> is the length of the supplied
                                value block in bytes
                            </p><p style="color:blue;">16是以字节为单位提供的值块的长度</p></li><li class="listitem"><p>
                                <code class="literal">GOODBYE, GOODBYE</code> is the value that is
                                stored
                            </p><p style="color:blue;">再见，再见是存储的值</p></li></ul>
                        </div>
                    </li><li class="listitem"><p>
                        Verify that the data inserted is stored in MySQL by
                        connecting to the MySQL server and querying the
                        <code class="literal">test.demo_test</code> table.
                    </p><p style="color:blue;">通过连接到mysql服务器并查询test.demo_测试表，验证插入的数据是否存储在mysql中。</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT * FROM test.demo_test;</code></strong>
+----+------------------+------+------+------+
| c1 | c2               | c3   | c4   | c5   |
+----+------------------+------+------+------+
| AA | HELLO, HELLO     |    8 |    0 |    0 |
| BB | GOODBYE, GOODBYE |   10 |    1 |    0 |
+----+------------------+------+------+------+
</pre></li><li class="listitem"><p>
                        Return to the telnet session and retrieve the data that you
                        inserted earlier using key <code class="literal">BB</code>.
                    </p><p style="color:blue;">返回telnet会话并使用bb键检索先前插入的数据。</p><pre data-lang="terminal" class="programlisting"><strong class="userinput"><code>get BB</code></strong>
VALUE BB 10 16
GOODBYE, GOODBYE
END
<strong class="userinput"><code>quit</code></strong>
</pre></li></ol>
                </div>
                <p>
                    If you shut down the MySQL server, which also shuts off the
                    integrated <span class="command"><strong>memcached</strong></span> server, further attempts
                    to access the <span class="command"><strong>memcached</strong></span> data fail with a
                    connection error. Normally, the <span class="command"><strong>memcached</strong></span>
                    data also disappears at this point, and you would require
                    application logic to load the data back into memory when
                    <span class="command"><strong>memcached</strong></span> is restarted. However, the
                    <code class="literal">InnoDB</code> <span class="command"><strong>memcached</strong></span> plugin
                    automates this process for you.
                </p><p style="color:blue;">如果关闭mysql服务器，同时也会关闭集成memcached服务器，则进一步访问memcached数据的尝试将失败，并出现连接错误。通常，memcached数据也会在此时消失，当memcached重新启动时，需要应用程序逻辑将数据加载回内存。但是，innodb memcached插件为您自动化了这个过程。</p><p>
                When you restart MySQL, <code class="literal">get</code> operations once
                again return the key-value pairs you stored in the earlier
                <span class="command"><strong>memcached</strong></span> session. When a key is requested
                and the associated value is not already in the memory cache, the
                value is automatically queried from the MySQL
                <code class="literal">test.demo_test</code> table.
            </p><p style="color:blue;">重新启动mysql时，get操作将再次返回存储在早期memcached会话中的键值对。当请求一个键并且相关联的值不在内存缓存中时，将从mysql test.demo_测试表中自动查询该值。</p>
            </div>
            <div class="simplesect">
                <div class="titlepage">
                    <div>
                        <div class="simple">
                            <h4 class="title"><a name="innodb-memcached-new-table-setup"></a>Creating a New Table and Column Mapping</h4>

                        </div>

                    </div>

                </div>
                <p>
                    This example shows how to setup your own
                    <code class="literal">InnoDB</code> table with the
                    <code class="literal">daemon_memcached</code> plugin.
                </p><p style="color:blue;">这个例子展示了如何使用daemon_memcached插件设置自己的innodb表。</p>
                <div class="orderedlist">
                    <ol class="orderedlist" type="1"><li class="listitem"><p>
                        Create an <code class="literal">InnoDB</code> table. The table must
                        have a key column with a unique index. The key column of the
                        city table is <code class="literal">city_id</code>, which is defined
                        as the primary key. The table must also include columns for
                        <code class="literal">flags</code>, <code class="literal">cas</code>, and
                        <code class="literal">expiry</code> values. There may be one or more
                        value columns. The <code class="literal">city</code> table has three
                        value columns (<code class="literal">name</code>,
                        <code class="literal">state</code>, <code class="literal">country</code>).
                    </p><p style="color:blue;">创建一个innodb表。表必须具有具有唯一索引的键列。city表的键列是city_id，它被定义为主键。表还必须包含标志、cas和到期值的列。可能有一个或多个值列。city表有三个值列（name、state、country）。</p>
                        <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">

                            <div class="admon-title">
                                Note
                            </div>
                            <p>
                                There is no special requirement with respect to column
                                names as along as a valid mapping is added to the
                                <code class="literal">innodb_memcache.containers</code> table.
                            </p><p style="color:blue;">当一个有效的映射被添加到innodb_memcache.containers表时，对列名没有特殊要求。</p>
                        </div>
                        <pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>CREATE TABLE city (</code></strong>
       <strong class="userinput"><code>city_id VARCHAR(32),</code></strong>
       <strong class="userinput"><code>name VARCHAR(1024),</code></strong>
       <strong class="userinput"><code>state VARCHAR(1024),</code></strong>
       <strong class="userinput"><code>country VARCHAR(1024),</code></strong>
       <strong class="userinput"><code>flags INT,</code></strong>
       <strong class="userinput"><code>cas BIGINT UNSIGNED, </code></strong>
       <strong class="userinput"><code>expiry INT,</code></strong>
       <strong class="userinput"><code>primary key(city_id)</code></strong>
       ) <strong class="userinput"><code>ENGINE=InnoDB;</code></strong>
</pre></li><li class="listitem"><p>
                        Add an entry to the
                        <code class="literal">innodb_memcache.containers</code> table so that
                        the <code class="literal">daemon_memcached</code> plugin knows how to
                        access the <code class="literal">InnoDB</code> table. The entry must
                        satisfy the <code class="literal">innodb_memcache.containers</code>
                        table definition. For a description of each field, see
                        <a class="xref" href="innodb-storage-engine.html#innodb-memcached-internals" title="14.20.7&nbsp;InnoDB memcached Plugin Internals">Section&nbsp;14.20.7, “InnoDB memcached Plugin Internals”</a>.
                    </p><p style="color:blue;">在innodb_memcache.containers表中添加一个条目，以便daemon_memcached插件知道如何访问innodb表。条目必须满足innodb_memcache.containers表定义。有关每个字段的描述，请参阅14.20.7节，“innodb memcached plugin internals”。</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>DESCRIBE innodb_memcache.containers;</code></strong>
+------------------------+--------------+------+-----+---------+-------+
| Field                  | Type         | Null | Key | Default | Extra |
+------------------------+--------------+------+-----+---------+-------+
| name                   | varchar(50)  | NO   | PRI | NULL    |       |
| db_schema              | varchar(250) | NO   |     | NULL    |       |
| db_table               | varchar(250) | NO   |     | NULL    |       |
| key_columns            | varchar(250) | NO   |     | NULL    |       |
| value_columns          | varchar(250) | YES  |     | NULL    |       |
| flags                  | varchar(250) | NO   |     | 0       |       |
| cas_column             | varchar(250) | YES  |     | NULL    |       |
| expire_time_column     | varchar(250) | YES  |     | NULL    |       |
| unique_idx_name_on_key | varchar(250) | NO   |     | NULL    |       |
+------------------------+--------------+------+-----+---------+-------+
</pre><p>
                        The <code class="literal">innodb_memcache.containers</code> table
                        entry for the city table is defined as:
                    </p><p style="color:blue;">city表的innodb_memcache.containers表项定义为：</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>INSERT INTO `innodb_memcache`.`containers` (</code></strong>
       <strong class="userinput"><code>`name`, `db_schema`, `db_table`, `key_columns`, `value_columns`,</code></strong>
       <strong class="userinput"><code>`flags`, `cas_column`, `expire_time_column`, `unique_idx_name_on_key`)</code></strong>
       <strong class="userinput"><code>VALUES ('default', 'test', 'city', 'city_id', 'name|state|country', </code></strong>
       <strong class="userinput"><code>'flags','cas','expiry','PRIMARY');</code></strong>
</pre>
                        <div class="itemizedlist">
                            <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                                <code class="literal">default</code> is specified for the
                                <code class="literal">containers.name</code> column to configure
                                the <code class="literal">city</code> table as the default
                                <code class="literal">InnoDB</code> table to be used with the
                                <code class="literal">daemon_memcached</code> plugin.
                            </p><p style="color:blue;">为containers.name列指定default，将city表配置为与daemon_memcached插件一起使用的默认innodb表。</p></li><li class="listitem"><p>
                                Multiple <code class="literal">InnoDB</code> table columns
                                (<code class="literal">name</code>, <code class="literal">state</code>,
                                <code class="literal">country</code>) are mapped to
                                <code class="literal">containers.value_columns</code> using a
                                <span class="quote">“<span class="quote">|</span>”</span> delimiter.
                            </p><p style="color:blue;">使用“”分隔符将多个innodb表列（名称、状态、国家）映射到containers.value_列。</p></li><li class="listitem"><p>
                                The <code class="literal">flags</code>,
                                <code class="literal">cas_column</code>, and
                                <code class="literal">expire_time_column</code> fields of the
                                <code class="literal">innodb_memcache.containers</code> table are
                                typically not significant in applications using the
                                <code class="literal">daemon_memcached</code> plugin. However, a
                                designated <code class="literal">InnoDB</code> table column is
                                required for each. When inserting data, specify
                                <code class="literal">0</code> for these columns if they are
                                unused.
                            </p><p style="color:blue;">innodb_memcache.containers表的flags、cas_column和expire_time_column字段在使用daemon_memcached插件的应用程序中通常不重要。但是，每个表都需要一个指定的innodb表列。插入数据时，如果这些列未使用，请为它们指定0。</p></li></ul>
                        </div>
                    </li><li class="listitem"><p>
                        After updating the
                        <code class="literal">innodb_memcache.containers</code> table, restart
                        the <code class="literal">daemon_memcache</code> plugin to apply the
                        changes.
                    </p><p style="color:blue;">更新innodb_memcache.containers表后，重新启动daemon_memcache插件以应用更改。</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>UNINSTALL PLUGIN daemon_memcached;</code></strong>

mysql&gt; <strong class="userinput"><code>INSTALL PLUGIN daemon_memcached soname "libmemcached.so";</code></strong>
</pre></li><li class="listitem"><p>
                        Using telnet, insert data into the <code class="literal">city</code>
                        table using a <span class="command"><strong>memcached</strong></span>
                        <code class="literal">set</code> command.
                    </p><p style="color:blue;">使用telnet，使用memcached set命令将数据插入city表。</p><pre data-lang="terminal" class="programlisting"><strong class="userinput"><code>telnet localhost 11211</code></strong>
Trying 127.0.0.1...
Connected to localhost.
Escape character is '^]'.
<strong class="userinput"><code>set B 0 0 22</code></strong>
<strong class="userinput"><code>BANGALORE|BANGALORE|IN</code></strong>
STORED
</pre></li><li class="listitem"><p>
                        Using MySQL, query the <code class="literal">test.city</code> table to
                        verify that the data you inserted was stored.
                    </p><p style="color:blue;">使用mysql查询test.city表以验证插入的数据是否已存储。</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT * FROM test.city;</code></strong>
+---------+-----------+-----------+---------+-------+------+--------+
| city_id | name      | state     | country | flags | cas  | expiry |
+---------+-----------+-----------+---------+-------+------+--------+
| B       | BANGALORE | BANGALORE | IN      |     0 |    3 |      0 |
+---------+-----------+-----------+---------+-------+------+--------+
</pre></li><li class="listitem"><p>
                        Using MySQL, insert additional data into the
                        <code class="literal">test.city</code> table.
                    </p><p style="color:blue;">使用mysql，将其他数据插入test.city表。</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>INSERT INTO city VALUES ('C','CHENNAI','TAMIL NADU','IN', 0, 0 ,0);</code></strong>
mysql&gt; <strong class="userinput"><code>INSERT INTO city VALUES ('D','DELHI','DELHI','IN', 0, 0, 0);</code></strong>
mysql&gt; <strong class="userinput"><code>INSERT INTO city VALUES ('H','HYDERABAD','TELANGANA','IN', 0, 0, 0);</code></strong>
mysql&gt; <strong class="userinput"><code>INSERT INTO city VALUES ('M','MUMBAI','MAHARASHTRA','IN', 0, 0, 0);</code></strong>
</pre>
                        <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">

                            <div class="admon-title">
                                Note
                            </div>
                            <p>
                                It is recommended that you specify a value of
                                <code class="literal">0</code> for the <code class="literal">flags</code>,
                                <code class="literal">cas_column</code>, and
                                <code class="literal">expire_time_column</code> fields if they are
                                unused.
                            </p><p style="color:blue;">建议为标志、cas_列和expire_time_列字段（如果未使用）指定0值。</p>
                        </div>
                    </li><li class="listitem"><p>
                        Using telnet, issue a <span class="command"><strong>memcached</strong></span>
                        <code class="literal">get</code> command to retrieve data you inserted
                        using MySQL.
                    </p><p style="color:blue;">使用telnet，发出memcached get命令来检索使用mysql插入的数据。</p><pre data-lang="terminal" class="programlisting"><strong class="userinput"><code>get H</code></strong>
VALUE H 0 22
HYDERABAD|TELANGANA|IN
END
</pre></li></ol>
                </div>

            </div>
            <div class="simplesect">
                <div class="titlepage">
                    <div>
                        <div class="simple">
                            <h4 class="title"><a name="innodb-memcached-configuration"></a>Configuring the InnoDB memcached Plugin</h4>

                        </div>

                    </div>

                </div>
                <p>
                    Traditional <code class="literal">memcached</code> configuration options
                    may be specified in a MySQL configuration file or a
                    <a class="link" href="programs.html#mysqld" title="4.3.1&nbsp;mysqld — The MySQL Server"><span class="command"><strong>mysqld</strong></span></a> startup string, encoded in the
                    argument of the
                    <a class="link" href="innodb-storage-engine.html#sysvar_daemon_memcached_option"><code class="literal">daemon_memcached_option</code></a>
                    configuration parameter. <code class="literal">memcached</code>
                    configuration options take effect when the plugin is loaded,
                    which occurs each time the MySQL server is started.
                </p><p style="color:blue;">传统的memcached配置选项可以在mysql配置文件或mysqld启动字符串中指定，该字符串编码在daemon_memcached_option配置参数的参数中。memcached配置选项在加载插件时生效，每次启动mysql服务器时都会发生这种情况。</p><p>
                For example, to make <span class="command"><strong>memcached</strong></span> listen on port
                11222 instead of the default port 11211, specify
                <code class="literal">-p11222</code> as an argument of the
                <a class="link" href="innodb-storage-engine.html#sysvar_daemon_memcached_option"><code class="literal">daemon_memcached_option</code></a>
                configuration option:
            </p><p style="color:blue;">例如，要使memcached侦听端口11222而不是默认端口11211，请将-p11222指定为daemon_memcached_option配置选项的参数：</p><pre data-lang="terminal" class="programlisting">mysqld .... --daemon_memcached_option="-p11222"
</pre><p>
                Other <span class="command"><strong>memcached</strong></span> options can be encoded in the
                <a class="link" href="innodb-storage-engine.html#sysvar_daemon_memcached_option"><code class="literal">daemon_memcached_option</code></a> string.
                For example, you can specify options to reduce the maximum
                number of simultaneous connections, change the maximum memory
                size for a key-value pair, or enable debugging messages for the
                error log, and so on.
            </p><p style="color:blue;">其他memcached选项可以在daemon memcached选项字符串中编码。例如，可以指定选项以减少同时连接的最大数量、更改键值对的最大内存大小、或者启用错误日志的调试消息等。</p><p>
                There are also configuration options specific to the
                <code class="literal">daemon_memcached</code> plugin. These include:
            </p><p style="color:blue;">还有一些特定于daemon_memcached插件的配置选项。其中包括：</p>
                <div class="itemizedlist">
                    <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                        <a class="link" href="innodb-storage-engine.html#sysvar_daemon_memcached_engine_lib_name"><code class="literal">daemon_memcached_engine_lib_name</code></a>:
                        Specifies the shared library that implements the
                        <code class="literal">InnoDB</code> <span class="command"><strong>memcached</strong></span>
                        plugin. The default setting is
                        <code class="filename">innodb_engine.so</code>.
                    </p><p style="color:blue;">daemon_memcached_engine_lib_name：指定实现innodb memcached插件的共享库。默认设置为innodb_engine.so。</p></li><li class="listitem"><p>
                        <a class="link" href="innodb-storage-engine.html#sysvar_daemon_memcached_engine_lib_path"><code class="literal">daemon_memcached_engine_lib_path</code></a>:
                        The path of the directory containing the shared library that
                        implements the <code class="literal">InnoDB</code>
                        <span class="command"><strong>memcached</strong></span> plugin. The default is NULL,
                        representing the plugin directory.
                    </p><p style="color:blue;">daemon_memcached_engine_lib_path：包含实现innodb memcached插件的共享库的目录的路径。默认值为空，表示插件目录。</p></li><li class="listitem"><p>
                        <a class="link" href="innodb-storage-engine.html#sysvar_daemon_memcached_r_batch_size"><code class="literal">daemon_memcached_r_batch_size</code></a>:
                        Defines the batch commit size for read operations
                        (<code class="literal">get</code>). It specifies the number of
                        <span class="command"><strong>memcached</strong></span> read operations after which a
                        <a class="link" href="glossary.html#glos_commit" title="commit">commit</a> occurs.
                        <a class="link" href="innodb-storage-engine.html#sysvar_daemon_memcached_r_batch_size"><code class="literal">daemon_memcached_r_batch_size</code></a>
                        is set to 1 by default so that every <code class="literal">get</code>
                        request accesses the most recently committed data in the
                        <code class="literal">InnoDB</code> table, whether the data was
                        updated through <span class="command"><strong>memcached</strong></span> or by SQL. When
                        the value is greater than 1, the counter for read operations
                        is incremented with each <code class="literal">get</code> call. A
                        <code class="literal">flush_all</code> call resets both read and write
                        counters.
                    </p><p style="color:blue;">daemon_memcached_r_batch_size：定义读取操作（get）的批提交大小。它指定在提交之后执行memcached读取操作的次数。daemon_memcached_r_batch_size默认设置为1，以便每个get请求都访问innodb表中最近提交的数据，无论这些数据是通过memcached还是通过sql更新的。当该值大于1时，读取操作的计数器将随着每次get调用而递增。flush_all调用重置读和写计数器。</p></li><li class="listitem"><p>
                        <a class="link" href="innodb-storage-engine.html#sysvar_daemon_memcached_w_batch_size"><code class="literal">daemon_memcached_w_batch_size</code></a>:
                        Defines the batch commit size for write operations
                        (<code class="literal">set</code>, <code class="literal">replace</code>,
                        <code class="literal">append</code>, <code class="literal">prepend</code>,
                        <code class="literal">incr</code>, <code class="literal">decr</code>, and so
                        on).
                        <a class="link" href="innodb-storage-engine.html#sysvar_daemon_memcached_w_batch_size"><code class="literal">daemon_memcached_w_batch_size</code></a>
                        is set to 1 by default so that no uncommitted data is lost
                        in case of an outage, and so that SQL queries on the
                        underlying table access the most recent data. When the value
                        is greater than 1, the counter for write operations is
                        incremented for each <code class="literal">add</code>,
                        <code class="literal">set</code>, <code class="literal">incr</code>,
                        <code class="literal">decr</code>, and <code class="literal">delete</code> call.
                        A <code class="literal">flush_all</code> call resets both read and
                        write counters.
                    </p><p style="color:blue;">daemon_memcached_w_batch_size：定义写操作的批提交大小（set、replace、append、prepend、incr、decr等）。daemon_memcached_w_batch_size默认设置为1，以便在中断时不会丢失未提交的数据，并且底层表上的sql查询可以访问最新的数据。当该值大于1时，每个add、set、incr、decr和delete调用的写操作计数器都将递增。flush_all调用重置读和写计数器。</p></li></ul>
                </div>
                <p>
                    By default, you do not need to modify
                    <a class="link" href="innodb-storage-engine.html#sysvar_daemon_memcached_engine_lib_name"><code class="literal">daemon_memcached_engine_lib_name</code></a>
                    or
                    <a class="link" href="innodb-storage-engine.html#sysvar_daemon_memcached_engine_lib_path"><code class="literal">daemon_memcached_engine_lib_path</code></a>.
                    You might configure these options if, for example, you want to
                    use a different storage engine for <span class="command"><strong>memcached</strong></span>
                    (such as the NDB <span class="command"><strong>memcached</strong></span> engine).
                </p><p style="color:blue;">默认情况下，不需要修改daemon_memcached_engine_lib_name或daemon_memcached_engine_lib_path。例如，如果要为memcached使用不同的存储引擎（如ndb memcached引擎），可以配置这些选项。</p><p>
                <code class="literal">daemon_memcached</code> plugin configuration
                parameters may be specified in the MySQL configuration file or
                in a <a class="link" href="programs.html#mysqld" title="4.3.1&nbsp;mysqld — The MySQL Server"><span class="command"><strong>mysqld</strong></span></a> startup string. They take effect
                when you load the <code class="literal">daemon_memcached</code> plugin.
            </p><p style="color:blue;">daemon_memcached plugin配置参数可以在mysql配置文件或mysqld启动字符串中指定。它们在加载daemon_memcached插件时生效。</p><p>
                When making changes to <code class="literal">daemon_memcached</code>
                plugin configuration, reload the plugin to apply the changes. To
                do so, issue the following statements:
            </p><p style="color:blue;">更改daemon_memcached插件配置时，请重新加载插件以应用更改。为此，发表以下声明：</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>UNINSTALL PLUGIN daemon_memcached;</code></strong>

mysql&gt; <strong class="userinput"><code>INSTALL PLUGIN daemon_memcached soname "libmemcached.so";</code></strong>
</pre><p>
                Configuration settings, required tables, and data are preserved
                when the plugin is restarted.
            </p><p style="color:blue;">重新启动插件时，将保留配置设置、必需的表和数据。</p><p>
                For additional information about enabling and disabling plugins,
                see <a class="xref" href="server-administration.html#plugin-loading" title="5.5.1&nbsp;Installing and Uninstalling Plugins">Section&nbsp;5.5.1, “Installing and Uninstalling Plugins”</a>.
            </p><p style="color:blue;">有关启用和禁用插件的更多信息，请参阅第5.5.1节“安装和卸载插件”。</p>
            </div>

        </div>
        <div class="section">
            <div class="titlepage">
                <div>
                    <div>
                        <h3 class="title"><a name="innodb-memcached-security"></a>14.20.4&nbsp;Security Considerations for the InnoDB memcached Plugin</h3>

                    </div>

                </div>

            </div>
            <div class="caution" style="margin-left: 0.5in; margin-right: 0.5in;">
                <div class="admon-title">
                    Caution
                </div>
                <p>
                    Consult this section before deploying the
                    <code class="literal">daemon_memcached</code> plugin on a production
                    server, or even on a test server if the MySQL instance contains
                    sensitive data.
                </p><p style="color:blue;">在生产服务器上部署daemon_memcached插件之前，或者甚至在测试服务器上部署daemon_memcached插件（如果mysql实例包含敏感数据）。</p>
            </div>
            <p>
                Because <span class="command"><strong>memcached</strong></span> does not use an
                authentication mechanism by default, and the optional SASL
                authentication is not as strong as traditional DBMS security
                measures, only keep non-sensitive data in the MySQL instance that
                uses the <code class="literal">daemon_memcached</code> plugin, and wall off
                any servers that use this configuration from potential intruders.
                Do not allow <span class="command"><strong>memcached</strong></span> access to these servers
                from the Internet; only allow access from within a firewalled
                intranet, ideally from a subnet whose membership you can restrict.
            </p><p style="color:blue;">由于memcached默认不使用身份验证机制，可选的sasl身份验证也没有传统的dbms安全措施强，所以只能将非敏感数据保存在使用daemon_memcached插件的mysql实例中，并将使用此配置的任何服务器与潜在的入侵者隔离开来。不允许memcached从Internet访问这些服务器；只允许从防火墙内部网访问，最好是从您可以限制其成员资格的子网访问。</p>
            <div class="simplesect">

                <div class="titlepage">
                    <div>

                        <div class="simple">
                            <h4 class="title"><a name="innodb-memcached-sasl"></a>Password-Protecting memcached Using SASL</h4>
                        </div>
                    </div>
                </div>
                <a class="indexterm" name="idm140286805443120"></a><a class="indexterm" name="idm140286805442080"></a><a class="indexterm" name="idm140286805440976"></a><a class="indexterm" name="idm140286805439472"></a><a class="indexterm" name="idm140286805437968"></a><p>
                SASL support provides the capability to protect your MySQL
                database from unauthenticated access through
                <span class="command"><strong>memcached</strong></span> clients. This section explains how
                to enable SASL with the <code class="literal">daemon_memcached</code>
                plugin. The steps are almost identical to those performed to
                enabled SASL for a traditional <span class="command"><strong>memcached</strong></span>
                server.
            </p><p style="color:blue;">sasl支持提供了保护mysql数据库免受memcached客户端未经验证的访问的能力。本节介绍如何使用daemon_memcached插件启用sasl。这些步骤与为传统memcached服务器启用sasl所执行的步骤几乎相同。</p><p>
                SASL stands for <span class="quote">“<span class="quote">Simple Authentication and Security
        Layer</span>”</span>, a standard for adding authentication support to
                connection-based protocols. <span class="command"><strong>memcached</strong></span> added
                SASL support in version 1.4.3.
            </p><p style="color:blue;">sasl代表“简单身份验证和安全层”，这是一个为基于连接的协议添加身份验证支持的标准。memcached在版本1.4.3中添加了sasl支持。</p><p>
                SASL authentication is only supported with the binary protocol.
            </p><p style="color:blue;">只有二进制协议才支持sasl身份验证。</p><p>
                <span class="command"><strong>memcached</strong></span> clients are only able to access
                <code class="literal">InnoDB</code> tables that are registered in the
                <code class="literal">innodb_memcache.containers</code> table.&nbsp;Even
                though a DBA can place access restrictions on such tables,
                access through <span class="command"><strong>memcached</strong></span> applications cannot
                be controlled. For this reason, SASL support is provided to
                control access to <code class="literal">InnoDB</code> tables associated
                with the <code class="literal">daemon_memcached</code> plugin.
            </p><p style="color:blue;">memcached客户端只能访问在innodb_memcache.containers表中注册的innodb表。即使dba可以对这些表设置访问限制，也无法控制通过memcached应用程序的访问。因此，提供了sasl支持来控制对与daemon_memcached插件相关联的innodb表的访问。</p><p>
                The following section shows how to build, enable, and test an
                SASL-enabled <code class="literal">daemon_memcached</code> plugin.
            </p><p style="color:blue;">下面的部分演示如何构建、启用和测试启用sasl的daemon_memcached插件。</p>
            </div>
            <div class="simplesect">
                <div class="titlepage">
                    <div>
                        <div class="simple">
                            <h4 class="title"><a name="innodb-memcached-sasl-enabling"></a>Building and Enabling SASL with the InnoDB memcached Plugin</h4>

                        </div>

                    </div>

                </div>
                <p>
                    By default, an SASL-enabled <code class="literal">daemon_memcached</code>
                    plugin is not included in MySQL release packages, since an
                    SASL-enabled <code class="literal">daemon_memcached</code> plugin requires
                    building <span class="command"><strong>memcached</strong></span> with SASL libraries. To
                    enable SASL support, download the MySQL source and rebuild the
                    <code class="literal">daemon_memcached</code> plugin after downloading the
                    SASL libraries:
                </p><p style="color:blue;">默认情况下，启用sasl的daemon_memcached插件不包含在mysql发布包中，因为启用sasl的daemon_memcached插件需要使用sasl库构建memcached。要启用sasl支持，请下载mysql源并在下载sasl库后重新生成daemon_memcached插件：</p>
                <div class="orderedlist">
                    <ol class="orderedlist" type="1"><li class="listitem"><p>
                        Install the SASL development and utility libraries. For
                        example, on Ubuntu, use <span class="command"><strong>apt-get</strong></span> to obtain
                        the libraries:
                    </p><p style="color:blue;">安装sasl开发和实用程序库。例如，在ubuntu上，使用apt get获取库：</p><pre data-lang="terminal" class="programlisting">sudo apt-get -f install libsasl2-2 sasl2-bin libsasl2-2 libsasl2-dev libsasl2-modules
</pre></li><li class="listitem"><p>
                        Build the <code class="literal">daemon_memcached</code> plugin shared
                        libraries with SASL capability by adding
                        <code class="literal">ENABLE_MEMCACHED_SASL=1</code> to your
                        <span class="command"><strong>cmake</strong></span> options.
                        <span class="command"><strong>memcached</strong></span> also provides <span class="emphasis"><em>simple
            cleartext password support</em></span>, which facilitates
                        testing. To enable simple cleartext password support,
                        specify the <code class="literal">ENABLE_MEMCACHED_SASL_PWDB=1</code>
                        <span class="command"><strong>cmake</strong></span> option.
                    </p><p style="color:blue;">通过在cmake选项中添加enable_memcached_sasl=1，构建具有sasl功能的daemon_memcached插件共享库。memcached还提供简单的明文密码支持，这有助于测试。要启用简单的明文密码支持，请指定enable_memcached_sasl_pwdb=1 cmake选项。</p><p>
                        In summary, add following three <span class="command"><strong>cmake</strong></span>
                        options:
                    </p><p style="color:blue;">总之，添加以下三个cmake选项：</p><pre data-lang="terminal" class="programlisting">cmake ... -DWITH_INNODB_MEMCACHED=1 -DENABLE_MEMCACHED_SASL=1 -DENABLE_MEMCACHED_SASL_PWDB=1
</pre></li><li class="listitem"><p>
                        Install the <code class="literal">daemon_memcached</code> plugin, as
                        described in <a class="xref" href="innodb-storage-engine.html#innodb-memcached-setup" title="14.20.3&nbsp;Setting Up the InnoDB memcached Plugin">Section&nbsp;14.20.3, “Setting Up the InnoDB memcached Plugin”</a>.
                    </p><p style="color:blue;">安装daemon_memcached插件，如14.20.3节“设置innodb memcached插件”所述。</p></li><li class="listitem"><p>
                        Configure a user name and password file. (This example uses
                        <span class="command"><strong>memcached</strong></span> simple cleartext password
                        support.)
                    </p><p style="color:blue;">配置用户名和密码文件。（此示例使用memcached simple cleartext密码支持。）</p>
                        <div class="orderedlist">
                            <ol class="orderedlist" type="a"><li class="listitem"><p>
                                In a file, create a user named
                                <code class="literal">testname</code> and define the password as
                                <code class="literal">testpasswd</code>:
                            </p><p style="color:blue;">在文件中，创建名为testname的用户并将密码定义为testpasswd：</p><pre data-lang="terminal" class="programlisting">
echo "testname:testpasswd:::::::" &gt;/home/jy/memcached-sasl-db

</pre></li><li class="listitem"><p>
                                Configure the <code class="literal">MEMCACHED_SASL_PWDB</code>
                                environment variable to inform
                                <code class="literal">memcached</code> of the user name and
                                password file:
                            </p><p style="color:blue;">配置memcached_sasl_pwdb环境变量以通知memcached用户名和密码文件：</p><pre data-lang="terminal" class="programlisting">export MEMCACHED_SASL_PWDB=/home/jy/memcached-sasl-db
</pre></li><li class="listitem"><p>
                                Inform <code class="literal">memcached</code> that a cleartext
                                password is used:
                            </p><p style="color:blue;">通知memcached使用明文密码：</p><pre data-lang="terminal" class="programlisting">
echo "mech_list: plain" &gt; /home/jy/work2/msasl/clients/memcached.conf
export SASL_CONF_PATH=/home/jy/work2/msasl/clients
</pre></li></ol>
                        </div>
                    </li><li class="listitem"><p>
                        Enable SASL by restarting the MySQL server with the
                        <span class="command"><strong>memcached</strong></span> <code class="literal">-S</code> option
                        encoded in the
                        <a class="link" href="innodb-storage-engine.html#sysvar_daemon_memcached_option"><code class="literal">daemon_memcached_option</code></a>
                        configuration parameter:
                    </p><p style="color:blue;">通过重新启动mysql服务器启用sasl，使用daemon_memcached_option配置参数中编码的memcached-s选项：</p><pre data-lang="terminal" class="programlisting">mysqld ... --daemon_memcached_option="-S"
</pre></li><li class="listitem"><p>
                        To test the setup, use an SASL-enabled client such as
                        <a class="ulink" href="https://code.launchpad.net/~trond-norbye/libmemcached/sasl" target="_top">SASL-enabled
                            libmemcached</a>.
                    </p><p style="color:blue;">要测试设置，请使用启用sasl的客户端，如启用sasl的libmemcached。</p><pre data-lang="terminal" class="programlisting">memcp --servers=localhost:11211 --binary&nbsp; --username=testname
  --password=<em class="replaceable"><code>password</code></em> myfile.txt

memcat --servers=localhost:11211 --binary --username=testname
  --password=<em class="replaceable"><code>password</code></em> myfile.txt
</pre><p>
                        If you specify an incorrect user name or password, the
                        operation is rejected with a <code class="literal">memcache error
                        AUTHENTICATION FAILURE</code> message. In this case,
                        examine the cleartext password set in the
                        <code class="filename">memcached-sasl-db</code> file to verify that
                        the credentials you supplied are correct.
                    </p><p style="color:blue;">如果指定的用户名或密码不正确，则操作将被拒绝，并显示memcache error authentication failure消息。在这种情况下，请检查memcached sasl db文件中设置的明文密码，以验证您提供的凭据是否正确。</p></li></ol>
                </div>
                <p>
                    There are other methods to test SASL authentication with
                    <span class="command"><strong>memcached</strong></span>, but the method described above is
                    the most straightforward.
                </p><p style="color:blue;">还有其他方法可以用memcached测试sasl身份验证，但是上面描述的方法是最简单的。</p>
            </div>

        </div>
        <div class="section">
            <div class="titlepage">
                <div>
                    <div>
                        <h3 class="title"><a name="innodb-memcached-developing"></a>14.20.5&nbsp;Writing Applications for the InnoDB memcached Plugin</h3>

                    </div>

                </div>

            </div>
            <div class="toc">
                <dl class="toc"><dt><span class="section"><a href="innodb-storage-engine.html#innodb-memcached-porting-mysql">14.20.5.1 Adapting an Existing MySQL Schema for the InnoDB memcached Plugin</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-memcached-porting-memcached">14.20.5.2 Adapting a memcached Application for the InnoDB memcached Plugin</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-memcached-tuning">14.20.5.3 Tuning InnoDB memcached Plugin Performance</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-memcached-txn">14.20.5.4 Controlling Transactional Behavior of the InnoDB memcached Plugin</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-memcached-dml">14.20.5.5 Adapting DML Statements to memcached Operations</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-memcached-ddl">14.20.5.6 Performing DML and DDL Statements on the Underlying InnoDB Table</a></span></dt></dl>
            </div>
            <p>
                Typically, writing an application for the
                <code class="literal">InnoDB</code> <span class="command"><strong>memcached</strong></span> plugin
                involves some degree of rewriting or adapting existing code that
                uses MySQL or the <span class="command"><strong>memcached</strong></span> API.
            </p><p style="color:blue;">通常，为NoYDB MycCurp插件编写应用程序涉及某种程度的重写或修改现有的使用MySQL或MycCask API的代码。</p>
            <div class="itemizedlist">
                <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                    With the <code class="literal">daemon_memcached</code> plugin, instead
                    of many traditional <span class="command"><strong>memcached</strong></span> servers
                    running on low-powered machines, you have the same number of
                    <span class="command"><strong>memcached</strong></span> servers as MySQL servers, running
                    on relatively high-powered machines with substantial disk
                    storage and memory. You might reuse some existing code that
                    works with the <span class="command"><strong>memcached</strong></span> API, but
                    adaptation is likely required due to the different server
                    configuration.
                </p><p style="color:blue;">有了daemon_memcached插件，与许多运行在低能耗机器上的传统memcached服务器不同，您拥有与mysql服务器相同数量的memcached服务器，它们运行在具有大量磁盘存储和内存的相对高能耗机器上。您可能会重用一些与MycCaseAPI工作的现有代码，但由于不同的服务器配置，可能需要适应。</p></li><li class="listitem"><p>
                    The data stored through the
                    <code class="literal">daemon_memcached</code> plugin goes into
                    <a class="link" href="data-types.html#char" title="11.4.1&nbsp;The CHAR and VARCHAR Types"><code class="literal">VARCHAR</code></a>,
                    <a class="link" href="data-types.html#blob" title="11.4.3&nbsp;The BLOB and TEXT Types"><code class="literal">TEXT</code></a>, or
                    <a class="link" href="data-types.html#blob" title="11.4.3&nbsp;The BLOB and TEXT Types"><code class="literal">BLOB</code></a> columns, and must be
                    converted to do numeric operations. You can perform the
                    conversion on the application side, or by using the
                    <code class="literal">CAST()</code> function in queries.
                </p><p style="color:blue;">通过daemon_memcached插件存储的数据进入varchar、text或blob列，并且必须转换为执行数值操作。可以在应用程序端执行转换，也可以在查询中使用cast（）函数。</p></li><li class="listitem"><p>
                    Coming from a database background, you might be used to
                    general-purpose SQL tables with many columns. The tables
                    accessed by <span class="command"><strong>memcached</strong></span> code likely have only
                    a few or even a single column holding data values.
                </p><p style="color:blue;">从数据库背景来看，您可能习惯于具有许多列的通用sql表。memcached代码访问的表可能只有几列，甚至只有一列包含数据值。</p></li><li class="listitem"><p>
                    You might adapt parts of your application that perform
                    single-row queries, inserts, updates, or deletes, to improve
                    performance in critical sections of code. Both
                    <a class="link" href="glossary.html#glos_query" title="query">queries</a> (read) and
                    <a class="link" href="glossary.html#glos_dml" title="DML">DML</a> (write) operations can be
                    substantially faster when performed through the
                    <code class="literal">InnoDB</code> <span class="command"><strong>memcached</strong></span>
                    interface. The performance improvement for writes is typically
                    greater than the performance improvement for reads, so you
                    might focus on adapting code that performs logging or records
                    interactive choices on a website.
                </p><p style="color:blue;">您可以调整应用程序中执行单行查询、插入、更新或删除的部分，以提高代码关键部分的性能。当通过innodb memcached接口执行查询（读）和dml（写）操作时，速度都会大大提高。写操作的性能改进通常大于读操作的性能改进，因此您可以重点调整执行日志记录或在网站上记录交互选择的代码。</p></li></ul>
            </div>
            <p>
                The following sections explore these points in more detail.
            </p><p style="color:blue;">以下各节将更详细地探讨这些要点。</p>
            <div class="section">

                <div class="titlepage">
                    <div>
                        <div>
                            <h4 class="title"><a name="innodb-memcached-porting-mysql"></a>14.20.5.1&nbsp;Adapting an Existing MySQL Schema for the InnoDB memcached Plugin</h4>
                        </div>
                    </div>
                </div>
                <p>
                    Consider these aspects of <span class="command"><strong>memcached</strong></span>
                    applications when adapting an existing MySQL schema or
                    application to use the <code class="literal">daemon_memcached</code>
                    plugin:
                </p><p style="color:blue;">在使用现有的MySQL模式或应用程序使用DaimOnMyCaspHelp插件时，考虑MycCask应用程序的这些方面：</p>
                <div class="itemizedlist">
                    <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                        <span class="command"><strong>memcached</strong></span> keys cannot contain spaces or
                        newlines, because these characters are used as separators in
                        the ASCII protocol. If you are using lookup values that
                        contain spaces, transform or hash them into values without
                        spaces before using them as keys in calls to
                        <code class="literal">add()</code>, <code class="literal">set()</code>,
                        <code class="literal">get()</code>, and so on. Although theoretically
                        these characters are allowed in keys in programs that use
                        the binary protocol, you should restrict the characters used
                        in keys to ensure compatibility with a broad range of
                        clients.
                    </p><p style="color:blue;">memcached键不能包含空格或换行符，因为这些字符在ascii协议中用作分隔符。如果使用的是包含空格的查找值，请在将其用作add（）、set（）、get（）等调用中的键之前将其转换或散列为不带空格的值。虽然理论上这些字符在使用二进制协议的程序的密钥中是允许的，但是您应该限制密钥中使用的字符，以确保与广泛的客户端兼容。</p></li><li class="listitem"><p>
                        If there is a short numeric
                        <a class="link" href="glossary.html#glos_primary_key" title="primary key">primary key</a> column
                        in an <code class="literal">InnoDB</code> table, use it as the unique
                        lookup key for <span class="command"><strong>memcached</strong></span> by converting
                        the integer to a string value. If the
                        <span class="command"><strong>memcached</strong></span> server is used for multiple
                        applications, or with more than one
                        <code class="literal">InnoDB</code> table, consider modifying the name
                        to ensure that it is unique. For example, prepend the table
                        name, or the database name and the table name, before the
                        numeric value.
                    </p><p style="color:blue;">如果innodb表中有一个短的数字主键列，那么通过将整数转换为字符串值，将其用作memcached的唯一查找键。如果memcached服务器用于多个应用程序，或者与多个innodb表一起使用，请考虑修改名称以确保其唯一。例如，在数值前加上表名或数据库名和表名。</p>
                        <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">

                            <div class="admon-title">
                                Note
                            </div>
                            <p>
                                The <code class="literal">daemon_memcached</code> plugin supports
                                inserts and reads on mapped <code class="literal">InnoDB</code>
                                tables that have an <code class="literal">INTEGER</code> defined as
                                the primary key.
                            </p><p style="color:blue;">daemon_memcached插件支持对定义了一个整数作为主键的映射innodb表进行插入和读取。</p>
                        </div>
                    </li><li class="listitem"><p>
                        You cannot use a partitioned table for data queried or
                        stored using <span class="command"><strong>memcached</strong></span>.
                    </p><p style="color:blue;">不能对使用memcached查询或存储的数据使用分区表。</p></li><li class="listitem"><p>
                        The <span class="command"><strong>memcached</strong></span> protocol passes numeric
                        values around as strings. To store numeric values in the
                        underlying <code class="literal">InnoDB</code> table, to implement
                        counters that can be used in SQL functions such as
                        <code class="literal">SUM()</code> or <code class="literal">AVG()</code>, for
                        example:
                    </p><p style="color:blue;">memcached协议将数值作为字符串传递。要在底层innodb表中存储数值，要实现可在sum（）或avg（）等sql函数中使用的计数器，例如：</p>
                        <div class="itemizedlist">
                            <ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
                                Use <a class="link" href="data-types.html#char" title="11.4.1&nbsp;The CHAR and VARCHAR Types"><code class="literal">VARCHAR</code></a> columns with
                                enough characters to hold all the digits of the largest
                                expected number (and additional characters if
                                appropriate for the negative sign, decimal point, or
                                both).
                            </p><p style="color:blue;">使用具有足够字符的varchar列来保存最大期望数的所有数字（如果适合负号、小数点或两者的话，还可以使用其他字符）。</p></li><li class="listitem"><p>
                                In any query that performs arithmetic using column
                                values, use the <code class="literal">CAST()</code> function to
                                convert the values from string to integer, or to some
                                other numeric type. For example:
                            </p><p style="color:blue;">在使用列值执行算术运算的任何查询中，使用cast（）函数将值从字符串转换为整数或其他某种数值类型。例如：</p><pre data-lang="sql" class="programlisting"># Alphabetic entries are returned as zero.

SELECT CAST(c2 as unsigned integer) FROM demo_test;

# Since there could be numeric values of 0, can't disqualify them.
# Test the string values to find the ones that are integers, and average only those.

SELECT AVG(cast(c2 as unsigned integer)) FROM demo_test
  WHERE c2 BETWEEN '0' and '9999999999';

# Views let you hide the complexity of queries. The results are already converted;
# no need to repeat conversion functions and WHERE clauses each time.

CREATE VIEW numbers AS SELECT c1 KEY, CAST(c2 AS UNSIGNED INTEGER) val
  FROM demo_test WHERE c2 BETWEEN '0' and '9999999999';
SELECT SUM(val) FROM numbers;
</pre>
                                <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">

                                    <div class="admon-title">
                                        Note
                                    </div>
                                    <p>
                                        Any alphabetic values in the result set are converted
                                        into 0 by the call to <code class="literal">CAST()</code>. When
                                        using functions such as <code class="literal">AVG()</code>,
                                        which depend on the number of rows in the result set,
                                        include <code class="literal">WHERE</code> clauses to filter out
                                        non-numeric values.
                                    </p><p style="color:blue;">通过调用cast（）将结果集中的任何字母值转换为0。当使用avg（）等函数（取决于结果集中的行数）时，请包含where子句以筛选出非数值。</p>
                                </div>
                            </li></ul>
                        </div>
                    </li><li class="listitem"><p>
                        If the <code class="literal">InnoDB</code> column used as a key could
                        have values longer than 250 bytes, hash the value to less
                        than 250 bytes.
                    </p><p style="color:blue;">如果用作键的innodb列的值可能大于250字节，则将该值哈希到小于250字节。</p></li><li class="listitem"><p>
                        To use an existing table with the
                        <code class="literal">daemon_memcached</code> plugin, define an entry
                        for it in the <code class="literal">innodb_memcache.containers</code>
                        table. To make that table the default for all
                        <span class="command"><strong>memcached</strong></span> requests, specify a value of
                        <code class="literal">default</code> in the <code class="literal">name</code>
                        column, then restart the MySQL server to make the change
                        take effect. If you use multiple tables for different
                        classes of <span class="command"><strong>memcached</strong></span> data, set up
                        multiple entries in the
                        <code class="literal">innodb_memcache.containers</code> table with
                        <code class="literal">name</code> values of your choice, then issue a
                        <span class="command"><strong>memcached</strong></span> request in the form of
                        <code class="literal">get @@<em class="replaceable"><code>name</code></em></code> or
                        <code class="literal">set @@<em class="replaceable"><code>name</code></em></code>
                        within the application to specify the table to be used for
                        subsequent <span class="command"><strong>memcached</strong></span> requests.
                    </p><p style="color:blue;">若要使用具有DaimOnMyCasCurp插件的现有表，请在NoNdByMyCask.Cub表中为其定义一个条目。若要使该表成为所有memcached请求的默认值，请在“名称”列中指定默认值，然后重新启动mysql服务器以使更改生效。如果对不同类的memcached数据使用多个表，请在innodb_memcache.containers表中用您选择的名称值设置多个条目，然后在应用程序中以get@@name或set@@name的形式发出memcached请求，以指定要用于后续memcached请求的表。</p><p>
                        For an example of using a table other than the predefined
                        <code class="literal">test.demo_test</code> table, see
                        <a class="xref" href="innodb-storage-engine.html#innodb-memcached-tutorial-python" title="Example&nbsp;14.13&nbsp;Using Your Own Table with an InnoDB memcached Application">Example&nbsp;14.13, “Using Your Own Table with an InnoDB memcached Application”</a>. For the
                        required table layout, see
                        <a class="xref" href="innodb-storage-engine.html#innodb-memcached-internals" title="14.20.7&nbsp;InnoDB memcached Plugin Internals">Section&nbsp;14.20.7, “InnoDB memcached Plugin Internals”</a>.
                    </p><p style="color:blue;">有关使用预定义test.demo_测试表以外的表的示例，请参见示例14.13，“将自己的表与innodb memcached应用程序一起使用”。有关所需的表布局，请参阅第14.20.7节“innodb memcached plugin internals”。</p></li><li class="listitem"><p>
                        To use multiple <code class="literal">InnoDB</code> table column
                        values with <span class="command"><strong>memcached</strong></span> key-value pairs,
                        specify column names separated by comma, semicolon, space,
                        or pipe characters in the <code class="literal">value_columns</code>
                        field of the <code class="literal">innodb_memcache.containers</code>
                        entry for the <code class="literal">InnoDB</code> table. For example,
                        specify <code class="literal">col1,col2,col3</code> or
                        <code class="literal">col1|col2|col3</code> in the
                        <code class="literal">value_columns</code> field.
                    </p><p style="color:blue;">要将多个innodb表列值与memcached键值对一起使用，请在innodb表的innodb memcache.containers项的value_columns字段中指定用逗号、分号、空格或管道字符分隔的列名。例如，在“值列”字段中指定col1、col2、col3或col1 col2 col3。</p><p>
                        Concatenate the column values into a single string using the
                        pipe character as a separator before passing the string to
                        <span class="command"><strong>memcached</strong></span> <code class="literal">add</code> or
                        <code class="literal">set</code> calls. The string is unpacked
                        automatically into the correct column. Each
                        <code class="literal">get</code> call returns a single string
                        containing the column values that is also delimited by the
                        pipe character. You can unpack the values using the
                        appropriate application language syntax.
                    </p><p style="color:blue;">在将字符串传递给memcached add或set调用之前，使用管道字符作为分隔符将列值连接到单个字符串中。字符串将自动解压缩到正确的列中。每个get调用都返回一个字符串，其中包含同样由管道字符分隔的列值。您可以使用适当的应用程序语言语法解压这些值。</p></li></ul>
                </div>

                <div class="example">
                    <a name="innodb-memcached-tutorial-python"></a><p class="title"><b>Example&nbsp;14.13&nbsp;Using Your Own Table with an InnoDB memcached Application</b></p><p style="color:blue;">示例14.13将自己的表与innodb memcached应用程序一起使用</p>
                    <div class="example-contents">
                        <p>
                            This example shows how to use your own table with a sample
                            Python application that uses <code class="literal">memcached</code> for
                            data manipulation.
                        </p><p style="color:blue;">此示例演示如何将自己的表与使用memcached进行数据操作的示例python应用程序一起使用。</p><p>
                        The example assumes that the
                        <code class="literal">daemon_memcached</code> plugin is installed as
                        described in <a class="xref" href="innodb-storage-engine.html#innodb-memcached-setup" title="14.20.3&nbsp;Setting Up the InnoDB memcached Plugin">Section&nbsp;14.20.3, “Setting Up the InnoDB memcached Plugin”</a>. It also
                        assumes that your system is configured to run a Python script
                        that uses the <code class="literal">python-memcache</code> module.
                    </p><p style="color:blue;">本例假设daemon_memcached插件的安装如14.20.3节“设置innodb memcached插件”所述。它还假设您的系统配置为运行使用python memcache模块的python脚本。</p>
                        <div class="orderedlist">
                            <ol class="orderedlist" type="1"><li class="listitem"><p>
                                Create the <code class="literal">multicol</code> table which stores
                                country information including population, area, and driver
                                side data (<code class="literal">'R'</code> for right and
                                <code class="literal">'L'</code> for left).
                            </p><p style="color:blue;">创建存储国家/地区信息（包括人口、面积和驾驶员侧数据）的多表（右侧为“R”，左侧为“L”）。</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>USE test;</code></strong>

mysql&gt; <strong class="userinput"><code>CREATE TABLE `multicol` (</code></strong>
        <strong class="userinput"><code>`country` varchar(128) NOT NULL DEFAULT '',</code></strong>
        <strong class="userinput"><code>`population` varchar(10) DEFAULT NULL,</code></strong>
        <strong class="userinput"><code>`area_sq_km` varchar(9) DEFAULT NULL,</code></strong>
        <strong class="userinput"><code>`drive_side` varchar(1) DEFAULT NULL,</code></strong>
        <strong class="userinput"><code>`c3` int(11) DEFAULT NULL,</code></strong>
        <strong class="userinput"><code>`c4` bigint(20) unsigned DEFAULT NULL,</code></strong>
        <strong class="userinput"><code>`c5` int(11) DEFAULT NULL,</code></strong>
        <strong class="userinput"><code>PRIMARY KEY (`country`)</code></strong>
        <strong class="userinput"><code>) ENGINE=InnoDB DEFAULT CHARSET=latin1;</code></strong>
</pre></li><li class="listitem"><p>
                                Insert a record into the
                                <code class="literal">innodb_memcache.containers</code> table so
                                that the <code class="literal">daemon_memcached</code> plugin can
                                access the <code class="literal">multicol</code> table.
                            </p><p style="color:blue;">在innodb_memcache.containers表中插入一条记录，以便daemon_memcached插件可以访问multical表。</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>INSERT INTO innodb_memcache.containers</code></strong>
       <strong class="userinput"><code>(name,db_schema,db_table,key_columns,value_columns,flags,cas_column,</code></strong>
       <strong class="userinput"><code>expire_time_column,unique_idx_name_on_key)</code></strong>
       <strong class="userinput"><code>VALUES</code></strong>
       <strong class="userinput"><code>('bbb','test','multicol','country','population,area_sq_km,drive_side',</code></strong>
       <strong class="userinput"><code>'c3','c4','c5','PRIMARY');</code></strong>

mysql&gt; <strong class="userinput"><code>COMMIT;</code></strong>
</pre>
                                <div class="itemizedlist">
                                    <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                                        The <code class="literal">innodb_memcache.containers</code>
                                        record for the <code class="literal">multicol</code> table
                                        specifies a <code class="literal">name</code> value of
                                        <code class="literal">'bbb'</code>, which is the table
                                        identifier.
                                    </p><p style="color:blue;">multicol表的innodb_memcache.containers记录指定名称值“bbb”，这是表标识符。</p>
                                        <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">

                                            <div class="admon-title">
                                                Note
                                            </div>
                                            <p>
                                                If a single <code class="literal">InnoDB</code> table is used
                                                for all <span class="command"><strong>memcached</strong></span> applications,
                                                the <code class="literal">name</code> value can be set to
                                                <code class="literal">default</code> to avoid using
                                                <code class="literal">@@</code> notation to switch tables.
                                            </p><p style="color:blue;">如果所有memcached应用程序都使用一个innodb表，那么可以将name值设置为默认值，以避免使用@@符号来切换表。</p>
                                        </div>
                                    </li><li class="listitem"><p>
                                        The <code class="literal">db_schema</code> column is set to
                                        <code class="literal">test</code>, which is the name of the
                                        database where the <code class="literal">multicol</code> table
                                        resides.
                                    </p><p style="color:blue;">db_schema列设置为test，这是多表所在的数据库的名称。</p></li><li class="listitem"><p>
                                        The <code class="literal">db_table</code> column is set to
                                        <code class="literal">multicol</code>, which is the name of the
                                        <code class="literal">InnoDB</code> table.
                                    </p><p style="color:blue;">db_table列被设置为multicol，这是innodb表的名称。</p></li><li class="listitem"><p>
                                        <code class="literal">key_columns</code> is set to the unique
                                        <code class="literal">country</code> column. The
                                        <code class="literal">country</code> column is defined as the
                                        primary key in the <code class="literal">multicol</code> table
                                        definition.
                                    </p><p style="color:blue;">键列设置为唯一的国家列。country列被定义为multicol表定义中的主键。</p></li><li class="listitem"><p>
                                        Rather than a single <code class="literal">InnoDB</code> table
                                        column to hold a composite data value, data is divided
                                        among three table columns
                                        (<code class="literal">population</code>,
                                        <code class="literal">area_sq_km</code>, and
                                        <code class="literal">drive_side</code>). To accommodate
                                        multiple value columns, a comma-separated list of
                                        columns is specified in the
                                        <code class="literal">value_columns</code> field. The columns
                                        defined in the <code class="literal">value_columns</code> field
                                        are the columns used when storing or retrieving
                                        values.
                                    </p><p style="color:blue;">数据被分为三个表列（population、area_sq_km和drive_side），而不是一个单独的innodb表列来保存复合数据值。若要容纳多个值列，请在“值列”字段中指定以逗号分隔的列列表。值列字段中定义的列是存储或检索值时使用的列。</p></li><li class="listitem"><p>
                                        Values for the <code class="literal">flags</code>,
                                        <code class="literal">expire_time</code>, and
                                        <code class="literal">cas_column</code> fields are based on
                                        values used in the <code class="literal">demo.test</code> sample
                                        table. These fields are typically not significant in
                                        applications that use the
                                        <code class="literal">daemon_memcached</code> plugin because
                                        MySQL keeps data synchronized, and there is no need to
                                        worry about data expiring or becoming stale.
                                    </p><p style="color:blue;">flags、expire_time和cas_column字段的值基于demo.test示例表中使用的值。在使用daemon_memcached插件的应用程序中，这些字段通常不重要，因为mysql保持数据同步，不必担心数据过期或过时。</p></li><li class="listitem"><p>
                                        The <code class="literal">unique_idx_name_on_key</code> field is
                                        set to <code class="literal">PRIMARY</code>, which refers to the
                                        primary index defined on the unique
                                        <code class="literal">country</code> column in the
                                        <code class="literal">multicol</code> table.
                                    </p><p style="color:blue;">unique_idx_name_on_key字段被设置为primary，它是指在multical表的unique country列上定义的主索引。</p></li></ul>
                                </div>
                            </li><li class="listitem"><p>
                                Copy the sample Python application into a file. In this
                                example, the sample script is copied to a file named
                                <code class="filename">multicol.py</code>.
                            </p><p style="color:blue;">将示例python应用程序复制到文件中。在本例中，示例脚本被复制到名为multicol.py的文件中。</p><p>
                                The sample Python application inserts data into the
                                <code class="literal">multicol</code> table and retrieves data for
                                all keys, demonstrating how to access an
                                <code class="literal">InnoDB</code> table through the
                                <code class="literal">daemon_memcached</code> plugin.
                            </p><p style="color:blue;">示例python应用程序将数据插入multicol表并检索所有键的数据，演示如何通过daemon_memcached插件访问innodb表。</p><pre data-lang="python" class="programlisting">import sys, os
import memcache

def connect_to_memcached():
  memc = memcache.Client(['127.0.0.1:11211'], debug=0);
  print "Connected to memcached."
  return memc

def banner(message):
  print
  print "=" * len(message)
  print message
  print "=" * len(message)

country_data = [
("Canada","34820000","9984670","R"),
("USA","314242000","9826675","R"),
("Ireland","6399152","84421","L"),
("UK","62262000","243610","L"),
("Mexico","113910608","1972550","R"),
("Denmark","5543453","43094","R"),
("Norway","5002942","385252","R"),
("UAE","8264070","83600","R"),
("India","1210193422","3287263","L"),
("China","1347350000","9640821","R"),
]

def switch_table(memc,table):
  key = "@@" + table
  print "Switching default table to '" + table + "' by issuing GET for '" + key + "'."
  result = memc.get(key)

def insert_country_data(memc):
  banner("Inserting initial data via memcached interface")
  for item in country_data:
    country = item[0]
    population = item[1]
    area = item[2]
    drive_side = item[3]

    key = country
    value = "|".join([population,area,drive_side])
    print "Key = " + key
    print "Value = " + value

    if memc.add(key,value):
      print "Added new key, value pair."
    else:
      print "Updating value for existing key."
      memc.set(key,value)

def query_country_data(memc):
  banner("Retrieving data for all keys (country names)")
  for item in country_data:
    key = item[0]
    result = memc.get(key)
    print "Here is the result retrieved from the database for key " + key + ":"
    print result
    (m_population, m_area, m_drive_side) = result.split("|")
    print "Unpacked population value: " + m_population
    print "Unpacked area value      : " + m_area
    print "Unpacked drive side value: " + m_drive_side

if __name__ == '__main__':

  memc = connect_to_memcached()
  switch_table(memc,"bbb")
  insert_country_data(memc)
  query_country_data(memc)

  sys.exit(0)
</pre><p>
                                Sample Python application notes:
                            </p><p style="color:blue;">示例python应用程序说明：</p>
                                <div class="itemizedlist">
                                    <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                                        No database authorization is required to run the
                                        application, since data manipulation is performed
                                        through the <span class="command"><strong>memcached</strong></span> interface.
                                        The only required information is the port number on
                                        the local system where the
                                        <span class="command"><strong>memcached</strong></span> daemon listens.
                                    </p><p style="color:blue;">运行应用程序不需要数据库授权，因为数据操作是通过memcached接口执行的。唯一需要的信息是memcached守护进程侦听的本地系统上的端口号。</p></li><li class="listitem"><p>
                                        To make sure the application uses the
                                        <code class="literal">multicol</code> table, the
                                        <code class="literal">switch_table()</code> function is called,
                                        which performs a dummy <code class="literal">get</code> or
                                        <code class="literal">set</code> request using
                                        <code class="literal">@@</code> notation. The
                                        <code class="literal">name</code> value in the request is
                                        <code class="literal">bbb</code>, which is the
                                        <code class="literal">multicol</code> table identifier defined
                                        in the
                                        <code class="literal">innodb_memcache.containers.name</code>
                                        field.
                                    </p><p style="color:blue;">为了确保应用程序使用multical表，调用switch_table（）函数，该函数使用@@符号执行伪get或set请求。请求中的name值是bbb，它是在innodb_memcache.containers.name字段中定义的多表标识符。</p><p>
                                        A more descriptive <code class="literal">name</code> value might
                                        be used in a real-world application. This example
                                        simply illustrates that a table identifier is
                                        specified rather than the table name in <code class="literal">get
                                        @@...</code> requests.
                                    </p><p style="color:blue;">在实际应用程序中可以使用更具描述性的名称值。这个例子简单地说明了在get@@…请求。</p></li><li class="listitem"><p>
                                        The utility functions used to insert and query data
                                        demonstrate how to turn a Python data structure into
                                        pipe-separated values for sending data to MySQL with
                                        <code class="literal">add</code> or <code class="literal">set</code>
                                        requests, and how to unpack the pipe-separated values
                                        returned by <code class="literal">get</code> requests. This
                                        extra processing is only required when mapping a
                                        single <span class="command"><strong>memcached</strong></span> value to multiple
                                        MySQL table columns.
                                    </p><p style="color:blue;">用于插入和查询数据的实用程序函数演示了如何将python数据结构转换为管道分隔值，以便使用add或set请求向mysql发送数据，以及如何解压get请求返回的管道分隔值。仅当将单个memcached值映射到多个mysql表列时，才需要此额外处理。</p></li></ul>
                                </div>
                            </li><li class="listitem"><p>
                                Run the sample Python application.
                            </p><p style="color:blue;">运行示例python应用程序。</p><pre data-lang="terminal" class="programlisting">shell&gt; <strong class="userinput"><code>python multicol.py</code></strong>
</pre><p>
                                If successful, the sample application returns this output:
                            </p><p style="color:blue;">如果成功，示例应用程序将返回以下输出：</p><pre data-lang="terminal" class="programlisting">Connected to memcached.
Switching default table to 'bbb' by issuing GET for '@@bbb'.

==============================================
Inserting initial data via memcached interface
==============================================
Key = Canada
Value = 34820000|9984670|R
Added new key, value pair.
Key = USA
Value = 314242000|9826675|R
Added new key, value pair.
Key = Ireland
Value = 6399152|84421|L
Added new key, value pair.
Key = UK
Value = 62262000|243610|L
Added new key, value pair.
Key = Mexico
Value = 113910608|1972550|R
Added new key, value pair.
Key = Denmark
Value = 5543453|43094|R
Added new key, value pair.
Key = Norway
Value = 5002942|385252|R
Added new key, value pair.
Key = UAE
Value = 8264070|83600|R
Added new key, value pair.
Key = India
Value = 1210193422|3287263|L
Added new key, value pair.
Key = China
Value = 1347350000|9640821|R
Added new key, value pair.

============================================
Retrieving data for all keys (country names)
============================================
Here is the result retrieved from the database for key Canada:
34820000|9984670|R
Unpacked population value: 34820000
Unpacked area value      : 9984670
Unpacked drive side value: R
Here is the result retrieved from the database for key USA:
314242000|9826675|R
Unpacked population value: 314242000
Unpacked area value      : 9826675
Unpacked drive side value: R
Here is the result retrieved from the database for key Ireland:
6399152|84421|L
Unpacked population value: 6399152
Unpacked area value      : 84421
Unpacked drive side value: L
Here is the result retrieved from the database for key UK:
62262000|243610|L
Unpacked population value: 62262000
Unpacked area value      : 243610
Unpacked drive side value: L
Here is the result retrieved from the database for key Mexico:
113910608|1972550|R
Unpacked population value: 113910608
Unpacked area value      : 1972550
Unpacked drive side value: R
Here is the result retrieved from the database for key Denmark:
5543453|43094|R
Unpacked population value: 5543453
Unpacked area value      : 43094
Unpacked drive side value: R
Here is the result retrieved from the database for key Norway:
5002942|385252|R
Unpacked population value: 5002942
Unpacked area value      : 385252
Unpacked drive side value: R
Here is the result retrieved from the database for key UAE:
8264070|83600|R
Unpacked population value: 8264070
Unpacked area value      : 83600
Unpacked drive side value: R
Here is the result retrieved from the database for key India:
1210193422|3287263|L
Unpacked population value: 1210193422
Unpacked area value      : 3287263
Unpacked drive side value: L
Here is the result retrieved from the database for key China:
1347350000|9640821|R
Unpacked population value: 1347350000
Unpacked area value      : 9640821
Unpacked drive side value: R
</pre></li><li class="listitem"><p>
                                Query the <code class="literal">innodb_memcache.containers</code>
                                table to view the record you inserted earlier for the
                                <code class="literal">multicol</code> table. The first record is the
                                sample entry for the <code class="literal">demo_test</code> table
                                that is created during the initial
                                <code class="literal">daemon_memcached</code> plugin setup. The
                                second record is the entry you inserted for the
                                <code class="literal">multicol</code> table.
                            </p><p style="color:blue;">查询innodb_memcache.containers表以查看先前为multicol表插入的记录。第一条记录是demo_test表的示例条目，该表是在初始daemon_memcached plugin安装过程中创建的。第二条记录是为multicol表插入的条目。</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT * FROM innodb_memcache.containers\G</code></strong>
*************************** 1. row ***************************
                  name: aaa
             db_schema: test
              db_table: demo_test
           key_columns: c1
         value_columns: c2
                 flags: c3
            cas_column: c4
    expire_time_column: c5
unique_idx_name_on_key: PRIMARY
*************************** 2. row ***************************
                  name: bbb
             db_schema: test
              db_table: multicol
           key_columns: country
         value_columns: population,area_sq_km,drive_side
                 flags: c3
            cas_column: c4
    expire_time_column: c5
unique_idx_name_on_key: PRIMARY
</pre></li><li class="listitem"><p>
                                Query the <code class="literal">multicol</code> table to view data
                                inserted by the sample Python application. The data is
                                available for MySQL
                                <a class="link" href="glossary.html#glos_query" title="query">queries</a>, which
                                demonstrates how the same data can be accessed using SQL
                                or through applications (using the appropriate
                                <a class="link" href="connectors-apis.html" title="Chapter&nbsp;27&nbsp;Connectors and APIs">MySQL Connector or
                                    API</a>).
                            </p><p style="color:blue;">查询multicol表以查看示例python应用程序插入的数据。这些数据可用于mysql查询，它演示了如何使用sql或通过应用程序（使用适当的mysql连接器或api）访问相同的数据。</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT * FROM test.multicol;</code></strong>
+---------+------------+------------+------------+------+------+------+
| country | population | area_sq_km | drive_side | c3   | c4   | c5   |
+---------+------------+------------+------------+------+------+------+
| Canada  | 34820000   | 9984670    | R          |    0 |   11 |    0 |
| China   | 1347350000 | 9640821    | R          |    0 |   20 |    0 |
| Denmark | 5543453    | 43094      | R          |    0 |   16 |    0 |
| India   | 1210193422 | 3287263    | L          |    0 |   19 |    0 |
| Ireland | 6399152    | 84421      | L          |    0 |   13 |    0 |
| Mexico  | 113910608  | 1972550    | R          |    0 |   15 |    0 |
| Norway  | 5002942    | 385252     | R          |    0 |   17 |    0 |
| UAE     | 8264070    | 83600      | R          |    0 |   18 |    0 |
| UK      | 62262000   | 243610     | L          |    0 |   14 |    0 |
| USA     | 314242000  | 9826675    | R          |    0 |   12 |    0 |
+---------+------------+------------+------------+------+------+------+
</pre>
                                <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">

                                    <div class="admon-title">
                                        Note
                                    </div>
                                    <p>
                                        Always allow sufficient size to hold necessary digits,
                                        decimal points, sign characters, leading zeros, and so
                                        on when defining the length for columns that are treated
                                        as numbers. Too-long values in a string column such as a
                                        <code class="literal">VARCHAR</code> are truncated by removing
                                        some characters, which could produce nonsensical numeric
                                        values.
                                    </p><p style="color:blue;">在定义被视为数字的列的长度时，始终允许足够的大小来容纳必要的数字、小数点、符号字符、前导零等。字符串列（如varchar）中太长的值将通过删除某些字符来截断，这可能会产生无意义的数值。</p>
                                </div>
                            </li><li class="listitem"><p>
                                Optionally, run report-type queries on the
                                <code class="literal">InnoDB</code> table that stores the
                                <span class="command"><strong>memcached</strong></span> data.
                            </p><p style="color:blue;">或者，在存储memcached数据的innodb表上运行报表类型查询。</p><p>
                                You can produce reports through SQL queries, performing
                                calculations and tests across any columns, not just the
                                <code class="literal">country</code> key column. (Because the
                                following examples use data from only a few countries, the
                                numbers are for illustration purposes only.) The following
                                queries return the average population of countries where
                                people drive on the right, and the average size of
                                countries whose names start with <span class="quote">“<span class="quote">U</span>”</span>:
                            </p><p style="color:blue;">您可以通过sql查询生成报告，在任何列（而不仅仅是country key列）上执行计算和测试。（由于以下示例仅使用少数几个国家的数据，因此这些数字仅供说明。）以下查询返回人们靠右行驶的国家的平均人口，以及名称以“U”开头的国家的平均规模：</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT AVG(population) FROM multicol WHERE drive_side = 'R';</code></strong>
+-------------------+
| avg(population)   |
+-------------------+
| 261304724.7142857 |
+-------------------+

mysql&gt; <strong class="userinput"><code>SELECT SUM(area_sq_km) FROM multicol WHERE country LIKE 'U%';</code></strong>
+-----------------+
| sum(area_sq_km) |
+-----------------+
|        10153885 |
+-----------------+
</pre><p>
                                Because the <code class="literal">population</code> and
                                <code class="literal">area_sq_km</code> columns store character data
                                rather than strongly typed numeric data, functions such as
                                <code class="literal">AVG()</code> and <code class="literal">SUM()</code> work
                                by converting each value to a number first. This approach
                                <span class="emphasis"><em>does not work</em></span> for operators such as
                                <code class="literal">&lt;</code> or <code class="literal">&gt;</code>, for
                                example, when comparing character-based values, <code class="literal">9
                                &gt; 1000</code>, which is not expected from a clause
                                such as <code class="literal">ORDER BY population DESC</code>. For
                                the most accurate type treatment, perform queries against
                                views that cast numeric columns to the appropriate types.
                                This technique lets you issue simple <code class="literal">SELECT
                                *</code> queries from database applications, while
                                ensuring that casting, filtering, and ordering is correct.
                                The following example shows a view that can be queried to
                                find the top three countries in descending order of
                                population, with the results reflecting the latest data in
                                the <code class="literal">multicol</code> table, and with population
                                and area figures treated as numbers:
                            </p><p style="color:blue;">由于population和area_sq_km列存储字符数据，而不是强类型数字数据，因此avg（）和sum（）等函数首先将每个值转换为数字。此方法不适用于<or>之类的运算符，例如，在比较基于字符的值时，9&gt;1000（这不是从诸如ORDER BY POPULATION DESC之类的子句中预期的值）。要进行最精确的类型处理，请对将数字列转换为适当类型的视图执行查询。此技术允许您从数据库应用程序发出简单的select*查询，同时确保强制转换、筛选和排序是正确的。以下示例显示了一个视图，可以查询该视图以按人口降序排列的前三名国家，其结果反映多表中的最新数据，并将人口和面积数字视为数字：</or></p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>CREATE VIEW populous_countries AS</code></strong>
       <strong class="userinput"><code>SELECT</code></strong>
       <strong class="userinput"><code>country,</code></strong>
       <strong class="userinput"><code>cast(population as unsigned integer) population,</code></strong>
       <strong class="userinput"><code>cast(area_sq_km as unsigned integer) area_sq_km,</code></strong>
       <strong class="userinput"><code>drive_side FROM multicol</code></strong>
       <strong class="userinput"><code>ORDER BY CAST(population as unsigned integer) DESC</code></strong>
       <strong class="userinput"><code>LIMIT 3;</code></strong>

mysql&gt; <strong class="userinput"><code>SELECT * FROM populous_countries;</code></strong>
+---------+------------+------------+------------+
| country | population | area_sq_km | drive_side |
+---------+------------+------------+------------+
| China   | 1347350000 |    9640821 | R          |
| India   | 1210193422 |    3287263 | L          |
| USA     |  314242000 |    9826675 | R          |
+---------+------------+------------+------------+

mysql&gt; <strong class="userinput"><code>DESC populous_countries;</code></strong>
+------------+---------------------+------+-----+---------+-------+
| Field      | Type                | Null | Key | Default | Extra |
+------------+---------------------+------+-----+---------+-------+
| country    | varchar(128)        | NO   |     |         |       |
| population | bigint(10) unsigned | YES  |     | NULL    |       |
| area_sq_km | int(9) unsigned     | YES  |     | NULL    |       |
| drive_side | varchar(1)          | YES  |     | NULL    |       |
+------------+---------------------+------+-----+---------+-------+
</pre></li></ol>
                        </div>

                    </div>

                </div>
                <br class="example-break">
            </div>
            <div class="section">
                <div class="titlepage">
                    <div>
                        <div>
                            <h4 class="title"><a name="innodb-memcached-porting-memcached"></a>14.20.5.2&nbsp;Adapting a memcached Application for the InnoDB memcached Plugin</h4>

                        </div>

                    </div>

                </div>
                <p>
                    Consider these aspects of MySQL and <code class="literal">InnoDB</code>
                    tables when adapting existing <span class="command"><strong>memcached</strong></span>
                    applications to use the <code class="literal">daemon_memcached</code>
                    plugin:
                </p><p style="color:blue;">在使用现有的MycCurk应用程序使用DaimOnMyCaspHelp插件时，考虑MySQL和NoYDB表的这些方面：</p>
                <div class="itemizedlist">
                    <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                        If there are key values longer than a few bytes, it may be
                        more efficient to use a numeric auto-increment column as the
                        <a class="link" href="glossary.html#glos_primary_key" title="primary key">primary key</a> of the
                        <code class="literal">InnoDB</code> table, and to create a unique
                        <a class="link" href="glossary.html#glos_secondary_index" title="secondary index">secondary index</a>
                        on the column that contains the <span class="command"><strong>memcached</strong></span>
                        key values. This is because <code class="literal">InnoDB</code>
                        performs best for large-scale insertions if primary key
                        values are added in sorted order (as they are with
                        auto-increment values). Primary key values are included in
                        secondary indexes, which takes up unnecessary space if the
                        primary key is a long string value.
                    </p><p style="color:blue;">如果键值的长度超过几个字节，那么使用数字自动递增列作为innodb表的主键，并在包含memcached键值的列上创建唯一的二级索引可能更有效。这是因为如果主键值是按排序顺序添加的（与自动递增值一样），innodb对大规模插入的性能最好。主键值包含在辅助索引中，如果主键是长字符串值，则会占用不必要的空间。</p></li><li class="listitem"><p>
                        If you store several different classes of information using
                        <span class="command"><strong>memcached</strong></span>, consider setting up a separate
                        <code class="literal">InnoDB</code> table for each type of data.
                        Define additional table identifiers in the
                        <code class="literal">innodb_memcache.containers</code> table, and use
                        the
                        <code class="literal">@@<em class="replaceable"><code>table_id</code></em>.<em class="replaceable"><code>key</code></em></code>
                        notation to store and retrieve items from different tables.
                        Physically dividing different types of information allows
                        you tune the characteristics of each table for optimum space
                        utilization, performance, and reliability. For example, you
                        might enable
                        <a class="link" href="glossary.html#glos_compression" title="compression">compression</a> for a
                        table that holds blog posts, but not for a table that holds
                        thumbnail images. You might back up one table more
                        frequently than another because it holds critical data. You
                        might create additional
                        <a class="link" href="glossary.html#glos_secondary_index" title="secondary index">secondary
                            indexes</a> on tables that are frequently used to
                        generate reports using SQL.
                    </p><p style="color:blue;">如果使用memcached存储几个不同的信息类，请考虑为每种类型的数据设置一个单独的innodb表。在innodb_memcache.containers表中定义其他表标识符，并使用@table_id.key符号存储和检索来自不同表的项。通过物理划分不同类型的信息，可以调整每个表的特性，以获得最佳的空间利用率、性能和可靠性。例如，您可以对保存博客文章的表启用压缩，但对保存缩略图的表不启用压缩。您可能会更频繁地备份一个表，因为它保存关键数据。您可以对经常用于使用SQL生成报表的表创建其他辅助索引。</p></li><li class="listitem"><p>
                        Preferably, configure a stable set of table definitions for
                        use with the <span class="command"><strong>daemon_memcached</strong></span> plugin, and
                        leave the tables in place permanently. Changes to the
                        <code class="literal">innodb_memcache.containers</code> table take
                        effect the next time the
                        <code class="literal">innodb_memcache.containers</code> table is
                        queried. Entries in the containers table are processed at
                        startup, and are consulted whenever an unrecognized table
                        identifier (as defined by
                        <code class="literal">containers.name</code>) is requested using
                        <code class="literal">@@</code> notation. Thus, new entries are
                        visible as soon as you use the associated table identifier,
                        but changes to existing entries require a server restart
                        before they take effect.
                    </p><p style="color:blue;">最好配置一组稳定的表定义，以便与daemon_memcached插件一起使用，并将表永久保留在适当的位置。对innodb_memcache.containers表的更改将在下次查询innodb_memcache.containers表时生效。containers表中的条目在启动时被处理，并且每当使用@@符号请求不可识别的表标识符（由containers.name定义）时都会被查询。因此，在使用关联表标识符时，可以看到新的条目，但是对现有条目的更改要求服务器在它们生效之前重新启动。</p></li><li class="listitem"><p>
                        When you use the default <code class="literal">innodb_only</code>
                        caching policy, calls to <code class="literal">add()</code>,
                        <code class="literal">set()</code>, <code class="literal">incr()</code>, and so
                        on can succeed but still trigger debugging messages such as
                        <code class="literal">while expecting 'STORED', got unexpected response
                            'NOT_STORED</code>. Debug messages occur because new and
                        updated values are sent directly to the
                        <code class="literal">InnoDB</code> table without being saved in the
                        memory cache, due to the <code class="literal">innodb_only</code>
                        caching policy.
                    </p><p style="color:blue;">当使用默认的innodb_only缓存策略时，对add（）、set（）、incr（）等的调用可以成功，但仍会触发调试消息，例如，在预期“已存储”时，得到意外的响应“未存储”。出现调试消息是因为新的和更新的值直接发送到innodb表，而不保存在内存缓存中，这是由于innodb_only缓存策略造成的。</p></li></ul>
                </div>

            </div>
            <div class="section">
                <div class="titlepage">
                    <div>
                        <div>
                            <h4 class="title"><a name="innodb-memcached-tuning"></a>14.20.5.3&nbsp;Tuning InnoDB memcached Plugin Performance</h4>

                        </div>

                    </div>

                </div>
                <p>
                    Because using <code class="literal">InnoDB</code> in combination with
                    <span class="command"><strong>memcached</strong></span> involves writing all data to disk,
                    whether immediately or sometime later, raw performance is
                    expected to be somewhat slower than using
                    <span class="command"><strong>memcached</strong></span> by itself. When using the
                    <code class="literal">InnoDB</code> <span class="command"><strong>memcached</strong></span> plugin,
                    focus tuning goals for <span class="command"><strong>memcached</strong></span> operations
                    on achieving better performance than equivalent SQL operations.
                </p><p style="color:blue;">因为结合使用innodb和memcached需要将所有数据写入磁盘，无论是立即还是稍后，原始性能预计都会比单独使用memcached慢一些。在使用innodb memcached插件时，将memcached操作的优化目标集中在获得比等效sql操作更好的性能上。</p><p>
                Benchmarks suggest that queries and
                <a class="link" href="glossary.html#glos_dml" title="DML">DML</a> operations (inserts,
                updates, and deletes) that use the <span class="command"><strong>memcached</strong></span>
                interface are faster than traditional SQL. DML operations
                typically see a larger improvements. Therefore, consider
                adapting write-intensive applications to use the
                <span class="command"><strong>memcached</strong></span> interface first. Also consider
                prioritizing adaptation of write-intensive applications that use
                fast, lightweight mechanisms that lack reliability.
            </p><p style="color:blue;">基准测试表明，使用memcached接口的查询和dml操作（插入、更新和删除）比传统sql更快。DML操作通常会看到更大的改进。因此，请考虑首先调整写密集型应用程序以使用memcached接口。还可以考虑对使用缺乏可靠性的快速、轻量级机制的写密集型应用程序进行优先级调整。</p>
                <h5><a name="idm140286805134032"></a>Adapting SQL Queries</h5>
                <p>
                    The types of queries that are most suited to simple
                    <code class="literal">GET</code> requests are those with a single clause
                    or a set of <code class="literal">AND</code> conditions in the
                    <code class="literal">WHERE</code> clause:
                </p><p style="color:blue;">最适合简单GET请求的查询类型是具有单个子句或WHERE子句中的一组AND条件的查询：</p><pre data-lang="sql" class="programlisting">SQL:
SELECT col FROM tbl WHERE key = 'key_value';

memcached:
get key_value

SQL:
SELECT col FROM tbl WHERE col1 = val1 and col2 = val2 and col3 = val3;

memcached:
# Since you must always know these 3 values to look up the key,
# combine them into a unique string and use that as the key
# for all ADD, SET, and GET operations.
key_value = val1 + ":" + val2 + ":" + val3
get key_value

SQL:
SELECT 'key exists!' FROM tbl
  WHERE EXISTS (SELECT col1 FROM tbl WHERE KEY = 'key_value') LIMIT 1;

memcached:
# Test for existence of key by asking for its value and checking if the call succeeds,
# ignoring the value itself. For existence checking, you typically only store a very
# short value such as "1".
get key_value
</pre>
                <h5><a name="idm140286805129088"></a>Using System Memory</h5>
                <p>
                    For best performance, deploy the
                    <code class="literal">daemon_memcached</code> plugin on machines that are
                    configured as typical database servers, where the majority of
                    system RAM is devoted to the <code class="literal">InnoDB</code>
                    <a class="link" href="glossary.html#glos_buffer_pool" title="buffer pool">buffer pool</a>, through the
                    <a class="link" href="innodb-storage-engine.html#sysvar_innodb_buffer_pool_size"><code class="literal">innodb_buffer_pool_size</code></a>
                    configuration option. For systems with multi-gigabyte buffer
                    pools, consider raising the value of
                    <a class="link" href="innodb-storage-engine.html#sysvar_innodb_buffer_pool_instances"><code class="literal">innodb_buffer_pool_instances</code></a>
                    for maximum throughput when most operations involve data that is
                    already cached in memory.
                </p><p style="color:blue;">为了获得最佳性能，可以在配置为典型数据库服务器的机器上部署daemon_memcached插件，在这些机器上，通过innodb_buffer_pool_size配置选项，大部分系统ram用于innodb缓冲池。对于具有多兆字节缓冲池的系统，当大多数操作涉及已经缓存在内存中的数据时，考虑提高UnjdBuffErrPoPoLoLyLoad的值以获得最大吞吐量。</p>
                <h5><a name="idm140286805122832"></a>Reducing Redundant I/O</h5>
                <p>
                    <code class="literal">InnoDB</code> has a number of settings that let you
                    choose the balance between high reliability, in case of a crash,
                    and the amount of I/O overhead during high write workloads. For
                    example, consider setting the
                    <a class="link" href="innodb-storage-engine.html#sysvar_innodb_doublewrite"><code class="literal">innodb_doublewrite</code></a> to
                    <code class="literal">0</code> and
                    <a class="link" href="innodb-storage-engine.html#sysvar_innodb_flush_log_at_trx_commit"><code class="literal">innodb_flush_log_at_trx_commit</code></a>
                    to <code class="literal">2</code>. Measure performance with different
                    <a class="link" href="innodb-storage-engine.html#sysvar_innodb_flush_method"><code class="literal">innodb_flush_method</code></a> settings.
                </p><p style="color:blue;">InnoDB有很多设置，可以让您在高可靠性（在崩溃时）和高写工作负载期间的I/O开销之间选择平衡。例如，考虑将innodb_doublewrite设置为0，将innodb_flush_log_at_trx_commit设置为2。使用不同的innodb_flush_方法设置测量性能。</p>
                <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">

                    <div class="admon-title">
                        Note
                    </div>
                    <p>
                        <a class="link" href="innodb-storage-engine.html#sysvar_innodb_support_xa"><code class="literal">innodb_support_xa</code></a> is
                        deprecated and will be removed in a future release. As of
                        MySQL 5.7.10, <code class="literal">InnoDB</code> support for two-phase
                        commit in XA transactions is always enabled and disabling
                        <a class="link" href="innodb-storage-engine.html#sysvar_innodb_support_xa"><code class="literal">innodb_support_xa</code></a> is no
                        longer permitted.
                    </p><p style="color:blue;">innodb_support_xa已弃用，将在将来的版本中删除。从mysql 5.7.10开始，innodb对xa事务中的两阶段提交的支持一直处于启用状态，并且不再允许禁用innodb_support_xa。</p>
                </div>
                <p>
                    For other ways to reduce or tune I/O for table operations, see
                    <a class="xref" href="optimization.html#optimizing-innodb-diskio" title="8.5.8&nbsp;Optimizing InnoDB Disk I/O">Section&nbsp;8.5.8, “Optimizing InnoDB Disk I/O”</a>.
                </p><p style="color:blue;">有关减少或优化表操作的I/O的其他方法，请参阅8.5.8节“优化InnoDB磁盘I/O”。</p>
                <h5><a name="idm140286805110176"></a>Reducing Transactional Overhead</h5>
                <p>
                    A default value of 1 for
                    <a class="link" href="innodb-storage-engine.html#sysvar_daemon_memcached_r_batch_size"><code class="literal">daemon_memcached_r_batch_size</code></a>
                    and
                    <a class="link" href="innodb-storage-engine.html#sysvar_daemon_memcached_w_batch_size"><code class="literal">daemon_memcached_w_batch_size</code></a>
                    is intended for maximum reliability of results and safety of
                    stored or updated data.
                </p><p style="color:blue;">DaimOnMyMaCaseDeJ.R.BATCHYLASE和DaEMONYMEMCACHEDHD WH-BATCHCHY大小的默认值为1，以保证结果的最大可靠性和存储或更新数据的安全性。</p><p>
                Depending on the type of application, you might increase one or
                both of these settings to reduce the overhead of frequent
                <a class="link" href="glossary.html#glos_commit" title="commit">commit</a> operations. On a busy
                system, you might increase
                <a class="link" href="innodb-storage-engine.html#sysvar_daemon_memcached_r_batch_size"><code class="literal">daemon_memcached_r_batch_size</code></a>,
                knowing that changes to data made through SQL may not become
                visible to <span class="command"><strong>memcached</strong></span> immediately (that is,
                until <em class="replaceable"><code>N</code></em> more <code class="literal">get</code>
                operations are processed). When processing data where every
                write operation must be reliably stored, leave
                <a class="link" href="innodb-storage-engine.html#sysvar_daemon_memcached_w_batch_size"><code class="literal">daemon_memcached_w_batch_size</code></a>
                set to <code class="literal">1</code>. Increase the setting when
                processing large numbers of updates intended only for
                statistical analysis, where losing the last
                <em class="replaceable"><code>N</code></em> updates in a crash is an acceptable
                risk.
            </p><p style="color:blue;">根据应用程序的类型，可以增加其中一个或两个设置，以减少频繁提交操作的开销。在繁忙的系统上，您可能会增加daemon_memcached_r_batch_的大小，因为您知道通过sql对数据所做的更改可能不会立即对memcached可见（也就是说，在处理n个get操作之前）。在处理必须可靠存储每个写操作的数据时，将daemon_memcached_w_batch_size设置为1。在处理大量仅用于统计分析的更新时增加设置，其中在崩溃中丢失最后n个更新是可接受的风险。</p><p>
                For example, imagine a system that monitors traffic crossing a
                busy bridge, recording data for approximately 100,000 vehicles
                each day. If the application counts different types of vehicles
                to analyze traffic patterns, changing
                <a class="link" href="innodb-storage-engine.html#sysvar_daemon_memcached_w_batch_size"><code class="literal">daemon_memcached_w_batch_size</code></a>
                from <code class="literal">1</code> to <code class="literal">100</code> reduces I/O
                overhead for commit operations by 99%. In case of an outage, a
                maximum of 100 records are lost, which may be an acceptable
                margin of error. If instead the application performed automated
                toll collection for each car, you would set
                <a class="link" href="innodb-storage-engine.html#sysvar_daemon_memcached_w_batch_size"><code class="literal">daemon_memcached_w_batch_size</code></a>
                to <code class="literal">1</code> to ensure that each toll record is
                immediately saved to disk.
            </p><p style="color:blue;">例如，设想一个系统监控繁忙的桥上的交通，每天记录大约100000辆汽车的数据。如果应用程序计算不同类型的车辆来分析流量模式，那么将daemon_memcached_w_batch_size从1更改为100将提交操作的I/O开销减少99%。在停电的情况下，最多100个记录丢失，这可能是一个可接受的误差范围。如果应用程序对每辆车执行自动收费，则应将daemon_memcached_w_batch_size设置为1，以确保每个收费记录立即保存到磁盘。</p><p>
                Because of the way <code class="literal">InnoDB</code> organizes
                <span class="command"><strong>memcached</strong></span> key values on disk, if you have a
                large number of keys to create, it may be faster to sort the
                data items by key value in the application and
                <code class="literal">add</code> them in sorted order, rather than create
                keys in arbitrary order.
            </p><p style="color:blue;">由于innodb在磁盘上组织memcached键值的方式，如果要创建大量的键，那么在应用程序中按键值对数据项排序并按排序顺序添加它们可能会更快，而不是按任意顺序创建键。</p><p>
                The <span class="command"><strong>memslap</strong></span> command, which is part of the
                regular <span class="command"><strong>memcached</strong></span> distribution but not
                included with the <code class="literal">daemon_memcached</code> plugin,
                can be useful for benchmarking different configurations. It can
                also be used to generate sample key-value pairs to use in your
                own benchmarks. See
                <a class="ulink" href="https://dev.mysql.com/doc/refman/5.6/en/ha-memcached-interfaces-libmemcached.html#ha-memcached-interfaces-libmemcached-utilities" target="_top"><span class="command"><strong>libmemcached</strong></span> Command-Line Utilities</a>
                for details.
            </p><p style="color:blue;">memslap命令是常规memcached发行版的一部分，但不包含在daemon_memcached插件中，可以用于对不同配置进行基准测试。它还可以用于生成示例键值对，以便在您自己的基准测试中使用。有关详细信息，请参阅libmemcached命令行实用程序。</p>
            </div>
            <div class="section">
                <div class="titlepage">
                    <div>
                        <div>
                            <h4 class="title"><a name="innodb-memcached-txn"></a>14.20.5.4&nbsp;Controlling Transactional Behavior of the InnoDB memcached Plugin</h4>

                        </div>

                    </div>

                </div>
                <p>
                    Unlike traditional <span class="command"><strong>memcached</strong></span>, the
                    <code class="literal">daemon_memcached</code> plugin allows you to control
                    durability of data values produced through calls to
                    <code class="literal">add</code>, <code class="literal">set</code>,
                    <code class="literal">incr</code>, and so on. By default, data written
                    through the <span class="command"><strong>memcached</strong></span> interface is stored to
                    disk, and calls to <code class="literal">get</code> return the most recent
                    value from disk. Although the default behavior does not offer
                    the best possible raw performance, it is still fast compared to
                    the SQL interface for <code class="literal">InnoDB</code> tables.
                </p><p style="color:blue;">与传统的memcached不同，daemon_meched插件允许您控制通过调用add、set、incr等产生的数据值的持久性。默认情况下，通过memcached接口写入的数据存储到磁盘，并调用get从磁盘返回最新值。尽管默认行为不能提供最好的原始性能，但与innodb表的sql接口相比，它仍然很快。</p><p>
                As you gain experience using the
                <code class="literal">daemon_memcached</code> plugin, you can consider
                relaxing durability settings for non-critical classes of data,
                at the risk of losing some updated values in the event of an
                outage, or returning data that is slightly out-of-date.
            </p><p style="color:blue;">当您使用DaimOnMyCasCurp插件获得经验时，您可以考虑为非关键类数据放宽持久性设置，在中断时丢失某些更新值的风险，或者返回略微过时的数据。</p>
                <h5><a name="idm140286805077408"></a>Frequency of Commits</h5>
                <p>
                    One tradeoff between durability and raw performance is how
                    frequently new and changed data is
                    <a class="link" href="glossary.html#glos_commit" title="commit">committed</a>. If data is
                    critical, is should be committed immediately so that it is safe
                    in case of a crash or outage. If data is less critical, such as
                    counters that are reset after a crash or logging data that you
                    can afford to lose, you might prefer higher raw throughput that
                    is available with less frequent commits.
                </p><p style="color:blue;">持久性和原始性能之间的一个折衷是提交新的和更改的数据的频率。如果数据是关键的，则应立即提交，以便在发生崩溃或中断时安全。如果数据不那么重要，例如在崩溃后重置的计数器或记录您可能丢失的数据，则您可能更喜欢在提交频率较低的情况下可用的更高的原始吞吐量。</p><p>
                When a <span class="command"><strong>memcached</strong></span> operation inserts, updates,
                or deletes data in the underlying <code class="literal">InnoDB</code>
                table, the change might be committed to the
                <code class="literal">InnoDB</code> table instantly (if
                <a class="link" href="innodb-storage-engine.html#sysvar_daemon_memcached_w_batch_size"><code class="literal">daemon_memcached_w_batch_size=1</code></a>)
                or some time later (if the
                <a class="link" href="innodb-storage-engine.html#sysvar_daemon_memcached_w_batch_size"><code class="literal">daemon_memcached_w_batch_size</code></a>
                value is greater than 1). In either case, the change cannot be
                rolled back. If you increase the value of
                <a class="link" href="innodb-storage-engine.html#sysvar_daemon_memcached_w_batch_size"><code class="literal">daemon_memcached_w_batch_size</code></a>
                to avoid high I/O overhead during busy times, commits could
                become infrequent when the workload decreases. As a safety
                measure, a background thread automatically commits changes made
                through the <span class="command"><strong>memcached</strong></span> API at regular
                intervals. The interval is controlled by the
                <a class="link" href="innodb-storage-engine.html#sysvar_innodb_api_bk_commit_interval"><code class="literal">innodb_api_bk_commit_interval</code></a>
                configuration option, which has a default setting of
                <code class="literal">5</code> seconds.
            </p><p style="color:blue;">当memcached操作在底层innodb表中插入、更新或删除数据时，更改可能会立即提交到innodb表（如果daemon_memcached_w_batch_size=1）或稍后（如果daemon_memcached_w_batch_size值大于1）。无论哪种情况，更改都不能回滚。如果增加daemon_memcached_w_batch_size的值，以避免在繁忙时间出现高I/O开销，则当工作负载减少时，提交可能会变得不频繁。作为安全措施，后台线程会定期自动提交通过memcached api所做的更改。间隔由innodb_api_bk_commit_interval配置选项控制，该选项的默认设置为5秒。</p><p>
                When a <span class="command"><strong>memcached</strong></span> operation inserts or updates
                data in the underlying <code class="literal">InnoDB</code> table, the
                changed data is immediately visible to other
                <span class="command"><strong>memcached</strong></span> requests because the new value
                remains in the memory cache, even if it is not yet committed on
                the MySQL side.
            </p><p style="color:blue;">当memcached操作在底层innodb表中插入或更新数据时，更改的数据会立即对其他memcached请求可见，因为新值仍保留在内存缓存中，即使它尚未在mysql端提交。</p>
                <h5><a name="idm140286805062560"></a>Transaction Isolation</h5>
                <p>
                    When a <span class="command"><strong>memcached</strong></span> operation such as
                    <code class="literal">get</code> or <code class="literal">incr</code> causes a query
                    or DML operation on the underlying <code class="literal">InnoDB</code>
                    table, you can control whether the operation sees the very
                    latest data written to the table, only data that has been
                    committed, or other variations of transaction
                    <a class="link" href="glossary.html#glos_isolation_level" title="isolation level">isolation level</a>. Use
                    the <a class="link" href="innodb-storage-engine.html#sysvar_innodb_api_trx_level"><code class="literal">innodb_api_trx_level</code></a>
                    configuration option to control this feature. The numeric values
                    specified for this option correspond to isolation levels such as
                    <a class="link" href="innodb-storage-engine.html#isolevel_repeatable-read"><code class="literal">REPEATABLE READ</code></a>. See the
                    description of the
                    <a class="link" href="innodb-storage-engine.html#sysvar_innodb_api_trx_level"><code class="literal">innodb_api_trx_level</code></a> option for
                    information about other settings.
                </p><p style="color:blue;">当memcached操作（如get或incr）导致对底层innodb表执行查询或dml操作时，可以控制该操作是否看到写入该表的最新数据、仅看到已提交的数据或事务隔离级别的其他变体。使用innodb_api_trx_level configuration选项控制此功能。为此选项指定的数值对应于隔离级别，如可重复读取。有关其他设置的信息，请参阅innodb_api_trx_level选项的说明。</p><p>
                A strict isolation level ensures that data you retrieve is not
                rolled back or changed suddenly causing subsequent queries to
                return different values. However, strict isolation levels
                require greater <a class="link" href="glossary.html#glos_locking" title="locking">locking</a>
                overhead, which can cause waits. For a NoSQL-style application
                that does not use long-running transactions, you can typically
                use the default isolation level or switch to a less strict
                isolation level.
            </p><p style="color:blue;">严格的隔离级别确保检索的数据不会回滚或突然更改，从而导致后续查询返回不同的值。但是，严格的隔离级别需要更大的锁定开销，这可能会导致等待。对于不使用长时间运行事务的nosql样式的应用程序，通常可以使用默认隔离级别或切换到不太严格的隔离级别。</p>
                <h5><a name="idm140286805051824"></a>Disabling Row Locks for memcached DML Operations</h5>
                <p>
                    The <a class="link" href="innodb-storage-engine.html#sysvar_innodb_api_disable_rowlock"><code class="literal">innodb_api_disable_rowlock</code></a>
                    option can be used to disable row locks when
                    <span class="command"><strong>memcached</strong></span> requests through the
                    <code class="literal">daemon_memcached</code> plugin cause DML operations.
                    By default, <code class="literal">innodb_api_disable_rowlock</code> is set
                    to <code class="literal">OFF</code> which means that
                    <span class="command"><strong>memcached</strong></span> requests row locks for
                    <code class="literal">get</code> and <code class="literal">set</code> operations.
                    When <code class="literal">innodb_api_disable_rowlock</code> is set to
                    <code class="literal">ON</code>, <span class="command"><strong>memcached</strong></span> requests a
                    table lock instead of row locks.
                </p><p style="color:blue;">innodb_api_disable_rowlock选项可用于在memcached请求通过daemon_memcached plugin导致dml操作时禁用行锁。默认情况下，innodb_api_disable_rowlock设置为off，这意味着memcached为get和set操作请求行锁。当innodb_api_disable_row lock设置为on时，memcached请求表锁而不是行锁。</p><p>
                The <code class="literal">innodb_api_disable_rowlock</code> option is not
                dynamic. It must be specified at startup on the
                <a class="link" href="programs.html#mysqld" title="4.3.1&nbsp;mysqld — The MySQL Server"><span class="command"><strong>mysqld</strong></span></a> command line or entered in a MySQL
                configuration file.
            </p><p style="color:blue;">innodb_api_disable_rowlock选项不是动态的。必须在启动时在mysqld命令行中指定或在mysql配置文件中输入。</p>
                <h5><a name="idm140286805039616"></a>Allowing or Disallowing DDL</h5>
                <p>
                    By default, you can perform <a class="link" href="glossary.html#glos_ddl" title="DDL">DDL</a>
                    operations such as <a class="link" href="sql-syntax.html#alter-table" title="13.1.8&nbsp;ALTER TABLE Syntax"><code class="literal">ALTER TABLE</code></a> on
                    tables used by the <code class="literal">daemon_memcached</code> plugin.
                    To avoid potential slowdowns when these tables are used for
                    high-throughput applications, disable DDL operations on these
                    tables by enabling
                    <a class="link" href="innodb-storage-engine.html#sysvar_innodb_api_enable_mdl"><code class="literal">innodb_api_enable_mdl</code></a> at
                    startup. This option is less appropriate when accessing the same
                    tables through both <span class="command"><strong>memcached</strong></span> and SQL,
                    because it blocks <a class="link" href="sql-syntax.html#create-index" title="13.1.14&nbsp;CREATE INDEX Syntax"><code class="literal">CREATE INDEX</code></a>
                    statements on the tables, which could be important for running
                    reporting queries.
                </p><p style="color:blue;">默认情况下，您可以对守护进程memcached插件使用的表执行ddl操作，例如alter table。为了避免在将这些表用于高吞吐量应用程序时出现潜在的减速，请通过在启动时启用innodb_api_enable_mdl来禁用这些表上的ddl操作。当通过memcached和sql访问相同的表时，此选项不太合适，因为它会阻止在表上创建索引语句，这对于运行报表查询可能很重要。</p>
                <h5><a name="idm140286805032096"></a>Storing Data on Disk, in Memory, or Both</h5>
                <p>
                    The <code class="literal">innodb_memcache.cache_policies</code> table
                    specifies whether to store data written through the
                    <span class="command"><strong>memcached</strong></span> interface to disk
                    (<code class="literal">innodb_only</code>, the default); in memory only,
                    as with traditional <span class="command"><strong>memcached</strong></span>
                    (<code class="literal">cache_only</code>); or both
                    (<code class="literal">caching</code>).
                </p><p style="color:blue;">innodb_memcache.cache_policies表指定是将通过memcached接口写入磁盘的数据（仅innodb_为默认值）、仅在内存中（与传统memcached一样）（仅缓存）还是同时存储（缓存）。</p><p>
                With the <code class="literal">caching</code> setting, if
                <span class="command"><strong>memcached</strong></span> cannot find a key in memory, it
                searches for the value in an <code class="literal">InnoDB</code> table.
                Values returned from <code class="literal">get</code> calls under the
                <code class="literal">caching</code> setting could be out-of-date if the
                values were updated on disk in the <code class="literal">InnoDB</code>
                table but are not yet expired from the memory cache.
            </p><p style="color:blue;">使用缓存设置，如果memcached在内存中找不到键，它将在innodb表中搜索该值。如果在innodb表的磁盘上更新了缓存设置下的get调用返回的值，但是这些值还没有从内存缓存中过期，那么这些值可能会过期。</p><p>
                The caching policy can be set independently for
                <code class="literal">get</code>, <code class="literal">set</code> (including
                <code class="literal">incr</code> and <code class="literal">decr</code>),
                <code class="literal">delete</code>, and <code class="literal">flush</code>
                operations.
            </p><p style="color:blue;">可以为get、set（包括incr和decr）、delete和flush操作单独设置缓存策略。</p><p>
                For example, you might allow <code class="literal">get</code> and
                <code class="literal">set</code> operations to query or update a table and
                the <span class="command"><strong>memcached</strong></span> memory cache at the same time
                (using the <code class="literal">caching</code> setting), while making
                <code class="literal">delete</code>, <code class="literal">flush</code>, or both
                operate only on the in-memory copy (using the
                <code class="literal">cache_only</code> setting). That way, deleting or
                flushing an item only expires the item from the cache, and the
                latest value is returned from the <code class="literal">InnoDB</code>
                table the next time the item is requested.
            </p><p style="color:blue;">例如，您可能允许get和set操作同时查询或更新表和memcached内存缓存（使用缓存设置），而使delete、flush或两者仅对内存中的副本（使用仅缓存设置）操作。这样，删除或刷新一个项只会使缓存中的项过期，并且在下次请求该项时从innodb表返回最新值。</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT * FROM innodb_memcache.cache_policies;</code></strong>
+--------------+-------------+-------------+---------------+--------------+
| policy_name  | get_policy  | set_policy  | delete_policy | flush_policy |
+--------------+-------------+-------------+---------------+--------------+
| cache_policy | innodb_only | innodb_only | innodb_only   | innodb_only  |
+--------------+-------------+-------------+---------------+--------------+

mysql&gt; <strong class="userinput"><code>UPDATE innodb_memcache.cache_policies SET set_policy = 'caching'</code></strong>
       <strong class="userinput"><code>WHERE policy_name = 'cache_policy';</code></strong>
</pre><p>
                <code class="literal">innodb_memcache.cache_policies</code> values are
                only read at startup. After changing values in this table,
                uninstall and reinstall the <code class="literal">daemon_memcached</code>
                plugin to ensure that changes take effect.
            </p><p style="color:blue;">innodb_memcache.cache_策略值仅在启动时读取。更改此表中的值后，卸载并重新安装daemon_memcached插件，以确保更改生效。</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>UNINSTALL PLUGIN daemon_memcached;</code></strong>

mysql&gt; <strong class="userinput"><code>INSTALL PLUGIN daemon_memcached soname "libmemcached.so";</code></strong>
</pre>
            </div>
            <div class="section">
                <div class="titlepage">
                    <div>
                        <div>
                            <h4 class="title"><a name="innodb-memcached-dml"></a>14.20.5.5&nbsp;Adapting DML Statements to memcached Operations</h4>

                        </div>

                    </div>

                </div>
                <p>
                    Benchmarks suggest that the <code class="literal">daemon_memcached</code>
                    plugin speeds up <a class="link" href="glossary.html#glos_dml" title="DML">DML</a> operations
                    (inserts, updates, and deletes) more than it speeds up queries.
                    Therefore, consider focussing initial development efforts on
                    write-intensive applications that are I/O-bound, and look for
                    opportunities to use MySQL with the
                    <code class="literal">daemon_memcached</code> plugin for new
                    write-intensive applications.
                </p><p style="color:blue;">基准测试表明daemon_memcached插件加快dml操作（插入、更新和删除）的速度超过加快查询的速度。因此，考虑将最初的开发工作集中在i/o绑定的写密集型应用程序上，并寻找机会将mysql与daemon_memcached插件一起用于新的写密集型应用程序。</p><p>
                Single-row DML statements are the easiest types of statements to
                turn into <code class="literal">memcached</code> operations.
                <code class="literal">INSERT</code> becomes <code class="literal">add</code>,
                <code class="literal">UPDATE</code> becomes <code class="literal">set</code>,
                <code class="literal">incr</code> or <code class="literal">decr</code>, and
                <code class="literal">DELETE</code> becomes <code class="literal">delete</code>.
                These operations are guaranteed to only affect one row when
                issued through the <span class="command"><strong>memcached</strong></span> interface,
                because the <em class="replaceable"><code>key</code></em> is unique within the
                table.
            </p><p style="color:blue;">单行dml语句是最容易转换为memcached操作的语句类型。insert变为add，update变为set，incr或decr，delete变为delete。这些操作在通过memcached接口发出时保证只影响一行，因为键在表中是唯一的。</p><p>
                In the following SQL examples, <code class="literal">t1</code> refers to
                the table used for <span class="command"><strong>memcached</strong></span> operations,
                based on the configuration in the
                <code class="literal">innodb_memcache.containers</code> table.
                <code class="literal">key</code> refers to the column listed under
                <code class="literal">key_columns</code>, and <code class="literal">val</code>
                refers to the column listed under
                <code class="literal">value_columns</code>.

            </p><p style="color:blue;">在下面的sql示例中，t1是指用于memcached操作的表，基于innodb_memcache.containers表中的配置。key指列在key_columns下的列，val指列在value_columns下的列。</p><pre data-lang="sql" class="programlisting">INSERT INTO t1 (key,val) VALUES (<em class="replaceable"><code>some_key</code></em>,<em class="replaceable"><code>some_value</code></em>);
SELECT val FROM t1 WHERE key = <em class="replaceable"><code>some_key</code></em>;
UPDATE t1 SET val = <em class="replaceable"><code>new_value</code></em> WHERE key = <em class="replaceable"><code>some_key</code></em>;
UPDATE t1 SET val = val + x WHERE key = <em class="replaceable"><code>some_key</code></em>;
DELETE FROM t1 WHERE key = <em class="replaceable"><code>some_key</code></em>;
</pre><p>
            </p><p>
                The following <a class="link" href="sql-syntax.html#truncate-table" title="13.1.34&nbsp;TRUNCATE TABLE Syntax"><code class="literal">TRUNCATE TABLE</code></a> and
                <a class="link" href="sql-syntax.html#delete" title="13.2.2&nbsp;DELETE Syntax"><code class="literal">DELETE</code></a> statements, which remove
                all rows from the table, correspond to the
                <code class="literal">flush_all</code> operation, where
                <code class="literal">t1</code> is configured as the table for
                <span class="command"><strong>memcached</strong></span> operations, as in the previous
                example.
            </p><p style="color:blue;">下面的truncate table和delete语句将删除表中的所有行，它们对应于flush_all操作，其中T1被配置为memcached操作的表，如前一个示例所示。</p><pre data-lang="sql" class="programlisting">TRUNCATE TABLE t1;
DELETE FROM t1;
</pre>
            </div>
            <div class="section">
                <div class="titlepage">
                    <div>
                        <div>
                            <h4 class="title"><a name="innodb-memcached-ddl"></a>14.20.5.6&nbsp;Performing DML and DDL Statements on the Underlying InnoDB Table</h4>

                        </div>

                    </div>

                </div>
                <p>
                    You can access the underlying <code class="literal">InnoDB</code> table
                    (which is <code class="literal">test.demo_test</code> by default) through
                    standard SQL interfaces. However, there are some restrictions:
                </p><p style="color:blue;">您可以通过标准的sql接口访问底层的innodb表（默认情况下是test.demo_test）。但是，也有一些限制：</p>
                <div class="itemizedlist">
                    <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                        When querying a table that is also accessed through the
                        <span class="command"><strong>memcached</strong></span> interface, remember that
                        <span class="command"><strong>memcached</strong></span> operations can be configured to
                        be committed periodically rather than after every write
                        operation. This behavior is controlled by the
                        <a class="link" href="innodb-storage-engine.html#sysvar_daemon_memcached_w_batch_size"><code class="literal">daemon_memcached_w_batch_size</code></a>
                        option. If this option is set to a value greater than
                        <code class="literal">1</code>, use <a class="link" href="innodb-storage-engine.html#isolevel_read-uncommitted"><code class="literal">READ
                        UNCOMMITTED</code></a> queries to find rows that were just
                        inserted.
                    </p><p style="color:blue;">在查询也通过memcached接口访问的表时，请记住memcached操作可以配置为定期提交，而不是在每次写入操作之后提交。此行为由daemon_memcached_w_batch_size选项控制。如果此选项设置为大于1的值，请使用“读取未提交的查询”查找刚刚插入的行。</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>SET SESSSION TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;</code></strong>

mysql&gt; <strong class="userinput"><code>SELECT * FROM demo_test;</code></strong>
+------+------+------+------+-----------+------+------+------+------+------+------+
| cx&nbsp;&nbsp; | cy&nbsp;&nbsp; | c1&nbsp;&nbsp; | cz&nbsp;&nbsp; | c2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | ca&nbsp;&nbsp; | CB&nbsp;&nbsp; | c3&nbsp;&nbsp; | cu&nbsp;&nbsp; | c4&nbsp;&nbsp; | C5&nbsp;&nbsp; |
+------+------+------+------+-----------+------+------+------+------+------+------+
| NULL | NULL | a11&nbsp; | NULL | 123456789 | NULL | NULL |&nbsp;&nbsp; 10 | NULL |&nbsp;&nbsp;&nbsp; 3 | NULL |
+------+------+------+------+-----------+------+------+------+------+------+------+
</pre></li><li class="listitem"><p>
                        When modifying a table using SQL that is also accessed
                        through the <span class="command"><strong>memcached</strong></span> interface, you can
                        configure <span class="command"><strong>memcached</strong></span> operations to start a
                        new transaction periodically rather than for every read
                        operation. This behavior is controlled by the
                        <a class="link" href="innodb-storage-engine.html#sysvar_daemon_memcached_r_batch_size"><code class="literal">daemon_memcached_r_batch_size</code></a>
                        option. If this option is set to a value greater than
                        <code class="literal">1</code>, changes made to the table using SQL
                        are not immediately visible to <span class="command"><strong>memcached</strong></span>
                        operations.
                    </p><p style="color:blue;">当使用同样通过memcached接口访问的sql修改表时，可以将memcached操作配置为定期启动新事务，而不是每次读取操作。此行为由daemon_memcached_r_batch_size选项控制。如果将此选项设置为大于1的值，则使用SQL对表所做的更改不会立即对memcached操作可见。</p></li><li class="listitem"><p>
                        The <code class="literal">InnoDB</code> table is either IS (intention
                        shared) or IX (intention exclusive) locked for all
                        operations in a transaction. If you increase
                        <a class="link" href="innodb-storage-engine.html#sysvar_daemon_memcached_r_batch_size"><code class="literal">daemon_memcached_r_batch_size</code></a>
                        and
                        <a class="link" href="innodb-storage-engine.html#sysvar_daemon_memcached_w_batch_size"><code class="literal">daemon_memcached_w_batch_size</code></a>
                        substantially from their default value of
                        <code class="literal">1</code>, the table is most likely locked
                        between each operation, preventing
                        <a class="link" href="glossary.html#glos_ddl" title="DDL">DDL</a> statements on the table.
                    </p><p style="color:blue;">对于事务中的所有操作，innodb表要么是（意图共享）要么是IX（意图独占）。如果将daemon_memcached_r_batch_size和daemon_memcached_w_batch_size从默认值1大幅增加，则表很可能在每个操作之间被锁定，从而阻止表上的ddl语句。</p></li></ul>
                </div>

            </div>

        </div>
        <div class="section">
            <div class="titlepage">
                <div>
                    <div>
                        <h3 class="title"><a name="innodb-memcached-replication"></a>14.20.6&nbsp;The InnoDB memcached Plugin and Replication</h3>

                    </div>

                </div>

            </div>
            <p>
                Because the <code class="literal">daemon_memcached</code> plugin supports
                the MySQL <a class="link" href="glossary.html#glos_binary_log" title="binary log">binary log</a>,
                updates made on a <a class="link" href="glossary.html#glos_master_server" title="master server">master
                server</a> through the <span class="command"><strong>memcached</strong></span> interface
                can be replicated for backup, balancing intensive read workloads,
                and high availability. All <span class="command"><strong>memcached</strong></span> commands
                are supported with binary logging.
            </p><p style="color:blue;">由于daemon_memcached插件支持mysql二进制日志，因此可以复制通过memcached接口在主服务器上进行的更新以进行备份，从而平衡密集的读取工作负载和高可用性。二进制日志记录支持所有memcached命令。</p><p>
            You do not need to set up the <code class="literal">daemon_memcached</code>
            plugin on <a class="link" href="glossary.html#glos_slave_server" title="slave server">slave servers</a>.
            The primary advantage of this configuration is increased write
            throughput on the master. The speed of the replication mechanism
            is not affected.
        </p><p style="color:blue;">不需要在从属服务器上设置daemon_memcached插件。这种配置的主要优点是增加了主机上的写吞吐量。复制机制的速度不受影响。</p><p>
            The following sections show how to use the binary log capability
            when using the <code class="literal">daemon_memcached</code> plugin with
            MySQL replication. It is assumed that you have completed the setup
            described in <a class="xref" href="innodb-storage-engine.html#innodb-memcached-setup" title="14.20.3&nbsp;Setting Up the InnoDB memcached Plugin">Section&nbsp;14.20.3, “Setting Up the InnoDB memcached Plugin”</a>.
        </p><p style="color:blue;">以下各节说明如何在将daemon_memcached插件用于mysql复制时使用二进制日志功能。假设您已经完成了第14.20.3节“设置innodb memcached插件”中描述的设置。</p>
            <div class="simplesect">

                <div class="titlepage">
                    <div>

                        <div class="simple">
                            <h4 class="title"><a name="innodb-memcached-replication-enable-binlog"></a>Enabling the InnoDB memcached Binary Log</h4>
                        </div>
                    </div>
                </div>

                <div class="orderedlist">
                    <ol class="orderedlist" type="1"><li class="listitem"><p>
                        To use the <code class="literal">daemon_memcached</code> plugin with
                        the MySQL <a class="link" href="glossary.html#glos_binary_log" title="binary log">binary log</a>,
                        enable the
                        <a class="link" href="innodb-storage-engine.html#sysvar_innodb_api_enable_binlog"><code class="literal">innodb_api_enable_binlog</code></a>
                        configuration option on the
                        <a class="link" href="glossary.html#glos_master_server" title="master server">master server</a>.
                        This option can only be set at server startup. You must also
                        enable the MySQL binary log on the master server using the
                        <a class="link" href="replication.html#sysvar_log_bin"><code class="literal">--log-bin</code></a> option. You can
                        add these options to the MySQL configuration file, or on the
                        <a class="link" href="programs.html#mysqld" title="4.3.1&nbsp;mysqld — The MySQL Server"><span class="command"><strong>mysqld</strong></span></a> command line.
                    </p><p style="color:blue;">要将daemon_memcached插件与mysql二进制日志一起使用，请在主服务器上启用innodb_api_enable_binlog配置选项。此选项只能在服务器启动时设置。还必须使用--log bin选项在主服务器上启用mysql二进制日志。您可以将这些选项添加到mysql配置文件或mysqld命令行。</p><pre data-lang="terminal" class="programlisting">mysqld ... --log-bin -–innodb_api_enable_binlog=1
</pre></li><li class="listitem"><p>
                        Configure the master and slave server, as described in
                        <a class="xref" href="replication.html#replication-howto" title="16.1.2&nbsp;Setting Up Binary Log File Position Based Replication">Section&nbsp;16.1.2, “Setting Up Binary Log File Position Based Replication”</a>.
                    </p><p style="color:blue;">配置主服务器和从服务器，如16.1.2节“设置基于二进制日志文件位置的复制”所述。</p></li><li class="listitem"><p>
                        Use <a class="link" href="programs.html#mysqldump" title="4.5.4&nbsp;mysqldump — A Database Backup Program"><span class="command"><strong>mysqldump</strong></span></a> to create a master data
                        snapshot, and sync the snapshot to the slave server.
                    </p><p style="color:blue;">使用mysqldump创建主数据快照，并将快照同步到从属服务器。</p><pre data-lang="terminal" class="programlisting">master shell&gt; <strong class="userinput"><code>mysqldump --all-databases --lock-all-tables &gt; dbdump.db</code></strong>
slave shell&gt; <strong class="userinput"><code>mysql &lt; dbdump.db</code></strong>
</pre></li><li class="listitem"><p>
                        On the master server, issue <a class="link" href="sql-syntax.html#show-master-status" title="13.7.5.23&nbsp;SHOW MASTER STATUS Syntax"><code class="literal">SHOW MASTER
                        STATUS</code></a> to obtain the master binary log
                        coordinates.
                    </p><p style="color:blue;">在主服务器上，发出show master status以获取主二进制日志坐标。</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>SHOW MASTER STATUS;</code></strong>
</pre></li><li class="listitem"><p>
                        On the slave server, use a <a class="link" href="sql-syntax.html#change-master-to" title="13.4.2.1&nbsp;CHANGE MASTER TO Syntax"><code class="literal">CHANGE
                        MASTER TO</code></a> statement to set up a slave server using
                        the master binary log coordinates.
                    </p><p style="color:blue;">在从属服务器上，使用change master to语句使用主二进制日志坐标设置从属服务器。</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>CHANGE MASTER TO</code></strong>
&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; <strong class="userinput"><code>MASTER_HOST='localhost',</code></strong>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <strong class="userinput"><code>MASTER_USER='root',</code></strong>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp; <strong class="userinput"><code>MASTER_PASSWORD='',</code></strong>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp; <strong class="userinput"><code>MASTER_PORT = 13000,</code></strong>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <strong class="userinput"><code>MASTER_LOG_FILE='0.000001,</code></strong>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <strong class="userinput"><code>MASTER_LOG_POS=114;</code></strong>
</pre></li><li class="listitem"><p>
                        Start the slave.
                    </p><p style="color:blue;">启动奴隶。</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>START SLAVE;</code></strong>
</pre><p>
                        If the error log prints output similar to the following, the
                        slave is ready for replication.
                    </p><p style="color:blue;">如果错误日志打印类似于以下内容的输出，则从机已准备好进行复制。</p><pre data-lang="terminal" class="programlisting">2013-09-24T13:04:38.639684Z 49 [Note] Slave I/O thread: connected to
master 'root@localhost:13000', replication started in log '0.000001'
at position 114
</pre></li></ol>
                </div>

            </div>
            <div class="simplesect">
                <div class="titlepage">
                    <div>
                        <div class="simple">
                            <h4 class="title"><a name="innodb-memcached-replication-testing"></a>Testing the InnoDB memcached Replication Configuration</h4>

                        </div>

                    </div>

                </div>
                <p>
                    This example demonstrates how to test the
                    <code class="literal">InnoDB</code> <span class="command"><strong>memcached</strong></span>
                    replication configuration using the <span class="command"><strong>memcached</strong></span>
                    and telnet to insert, update, and delete data. A MySQL client is
                    used to verify results on the master and slave servers.
                </p><p style="color:blue;">这个例子演示了如何使用memcached和telnet来插入、更新和删除数据来测试innodb memcached复制配置。mysql客户端用于验证主服务器和从服务器上的结果。</p><p>
                The example uses the <code class="literal">demo_test</code> table, which
                was created by the
                <code class="filename">innodb_memcached_config.sql</code> configuration
                script during the initial setup of the
                <code class="literal">daemon_memcached</code> plugin. The
                <code class="literal">demo_test</code> table contains a single example
                record.
            </p><p style="color:blue;">该示例使用demo_test表，该表是在daemon_memcached插件的初始设置期间由innodb_memcached_config.sql配置脚本创建的。demo_测试表包含单个示例记录。</p>
                <div class="orderedlist">
                    <ol class="orderedlist" type="1"><li class="listitem"><p>
                        Use the <code class="literal">set</code> command to insert a record
                        with a key of <code class="literal">test1</code>, a flag value of
                        <code class="literal">10</code>, an expiration value of
                        <code class="literal">0</code>, a cas value of 1, and a value of
                        <code class="literal">t1</code>.
                    </p><p style="color:blue;">使用set命令插入键为test1、标志值为10、过期值为0、cas值为1和t1的记录。</p><pre data-lang="terminal" class="programlisting"><strong class="userinput"><code>telnet 127.0.0.1 11211</code></strong>
Trying 127.0.0.1...
Connected to 127.0.0.1.
Escape character is '^]'.
<strong class="userinput"><code>set test1 10 0 1</code></strong>
<strong class="userinput"><code>t1</code></strong>
STORED
</pre></li><li class="listitem"><p>
                        On the master server, check that the record was inserted
                        into the <code class="literal">demo_test</code> table. Assuming the
                        <code class="literal">demo_test</code> table was not previously
                        modified, there should be two records. The example record
                        with a key of <code class="literal">AA</code>, and the record you just
                        inserted, with a key of <code class="literal">test1</code>. The
                        <code class="literal">c1</code> column maps to the key, the
                        <code class="literal">c2</code> column to the value, the
                        <code class="literal">c3</code> column to the flag value, the
                        <code class="literal">c4</code> column to the cas value, and the
                        <code class="literal">c5</code> column to the expiration time. The
                        expiration time was set to 0, since it is unused.
                    </p><p style="color:blue;">在主服务器上，检查记录是否已插入到demo_测试表中。假设demo_测试表之前没有被修改，那么应该有两条记录。键为a a的示例记录，以及刚插入的键为test1的记录。c1列映射到键，c2列映射到值，c3列映射到标志值，c4列映射到cas值，c5列映射到过期时间。过期时间设置为0，因为它未使用。</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT * FROM test.demo_test;</code></strong>
+-------+--------------+------+------+------+
| c1    | c2           | c3   | c4   | c5   |
+-------+--------------+------+------+------+
| AA    | HELLO, HELLO |    8 |    0 |    0 |
| test1 | t1           |   10 |    1 |    0 |
+-------+--------------+------+------+------+
</pre></li><li class="listitem"><p>
                        Check to verify that the same record was replicated to the
                        slave server.
                    </p><p style="color:blue;">检查以验证是否已将同一记录复制到从属服务器。</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT * FROM test.demo_test;</code></strong>
+-------+--------------+------+------+------+
| c1    | c2           | c3   | c4   | c5   |
+-------+--------------+------+------+------+
| AA    | HELLO, HELLO |    8 |    0 |    0 |
| test1 | t1           |   10 |    1 |    0 |
+-------+--------------+------+------+------+
</pre></li><li class="listitem"><p>
                        Use the <code class="literal">set</code> command to update the key to
                        a value of <code class="literal">new</code>.
                    </p><p style="color:blue;">使用set命令将密钥更新为new值。</p><pre data-lang="terminal" class="programlisting"><strong class="userinput"><code>telnet 127.0.0.1 11211</code></strong>
Trying 127.0.0.1...
Connected to 127.0.0.1.
Escape character is '^]'.
<strong class="userinput"><code>set test1 10 0 2</code></strong>
<strong class="userinput"><code>new</code></strong>
STORED
</pre><p>
                        The update is replicated to the slave server (notice that
                        the <code class="literal">cas</code> value is also updated).
                    </p><p style="color:blue;">更新被复制到从属服务器（注意，cas值也被更新）。</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT * FROM test.demo_test;</code></strong>
+-------+--------------+------+------+------+
| c1    | c2           | c3   | c4   | c5   |
+-------+--------------+------+------+------+
| AA    | HELLO, HELLO |    8 |    0 |    0 |
| test1 | new          |   10 |    2 |    0 |
+-------+--------------+------+------+------+
</pre></li><li class="listitem"><p>
                        Delete the <code class="literal">test1</code> record using a
                        <code class="literal">delete</code> command.
                    </p><p style="color:blue;">使用delete命令删除test1记录。</p><pre data-lang="terminal" class="programlisting"><strong class="userinput"><code>telnet 127.0.0.1 11211</code></strong>
Trying 127.0.0.1...
Connected to 127.0.0.1.
Escape character is '^]'.
<strong class="userinput"><code>delete test1</code></strong>
DELETED
</pre><p>
                        When the <code class="literal">delete</code> operation is replicated
                        to the slave, the <code class="literal">test1</code> record on the
                        slave is also deleted.
                    </p><p style="color:blue;">当删除操作复制到从机时，也会删除从机上的test1记录。</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT * FROM test.demo_test;</code></strong>
+----+--------------+------+------+------+
| c1 | c2           | c3   | c4   | c5   |
+----+--------------+------+------+------+
| AA | HELLO, HELLO |    8 |    0 |    0 |
+----+--------------+------+------+------+
</pre></li><li class="listitem"><p>
                        Remove all rows from the table using the
                        <code class="literal">flush_all</code> command.
                    </p><p style="color:blue;">使用flush_all命令从表中删除所有行。</p><pre data-lang="terminal" class="programlisting"><strong class="userinput"><code>telnet 127.0.0.1 11211</code></strong>
Trying 127.0.0.1...
Connected to 127.0.0.1.
Escape character is '^]'.
<strong class="userinput"><code>flush_all</code></strong>
OK
</pre><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT * FROM test.demo_test;</code></strong>
Empty set (0.00 sec)
</pre></li><li class="listitem"><p>
                        Telnet to the master server and enter two new records.
                    </p><p style="color:blue;">telnet到主服务器并输入两个新记录。</p><pre data-lang="terminal" class="programlisting"><strong class="userinput"><code>telnet 127.0.0.1 11211</code></strong>
Trying 127.0.0.1...
Connected to 127.0.0.1.
Escape character is '^]'
<strong class="userinput"><code>set test2 10 0 4</code></strong>
<strong class="userinput"><code>again</code></strong>
STORED
<strong class="userinput"><code>set test3 10 0 5</code></strong>
<strong class="userinput"><code>again1</code></strong>
STORED
</pre></li><li class="listitem"><p>
                        Confirm that the two records were replicated to the slave
                        server.
                    </p><p style="color:blue;">确认两个记录已复制到从属服务器。</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT * FROM test.demo_test;</code></strong>
+-------+--------------+------+------+------+
| c1    | c2           | c3   | c4   | c5   |
+-------+--------------+------+------+------+
| test2 | again        |   10 |    4 |    0 |
| test3 | again1       |   10 |    5 |    0 |
+-------+--------------+------+------+------+
</pre></li><li class="listitem"><p>
                        Remove all rows from the table using the
                        <code class="literal">flush_all</code> command.
                    </p><p style="color:blue;">使用flush_all命令从表中删除所有行。</p><pre data-lang="terminal" class="programlisting"><strong class="userinput"><code>telnet 127.0.0.1 11211</code></strong>
Trying 127.0.0.1...
Connected to 127.0.0.1.
Escape character is '^]'.
<strong class="userinput"><code>flush_all</code></strong>
OK
</pre></li><li class="listitem"><p>
                        Check to ensure that the <code class="literal">flush_all</code>
                        operation was replicated on the slave server.
                    </p><p style="color:blue;">检查以确保在从属服务器上复制flush_all操作。</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT * FROM test.demo_test;</code></strong>
Empty set (0.00 sec)
</pre></li></ol>
                </div>

            </div>
            <div class="simplesect">
                <div class="titlepage">
                    <div>
                        <div class="simple">
                            <h4 class="title"><a name="innodb-memcached-binlog-notes"></a>InnoDB memcached Binary Log Notes</h4>

                        </div>

                    </div>

                </div>
                <p>
                    Binary Log Format:
                </p><p style="color:blue;">二进制日志格式：</p>
                <div class="itemizedlist">
                    <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                        Most <span class="command"><strong>memcached</strong></span> operations are mapped to
                        <a class="link" href="glossary.html#glos_dml" title="DML">DML</a> statements (analogous to
                        insert, delete, update). Since there is no actual SQL
                        statement being processed by the MySQL server, all
                        <span class="command"><strong>memcached</strong></span> commands (except for
                        <code class="literal">flush_all</code>) use Row-Based Replication
                        (RBR) logging, which is independent of any server
                        <a class="link" href="replication.html#sysvar_binlog_format"><code class="literal">binlog_format</code></a> setting.
                    </p><p style="color:blue;">大多数memcached操作都映射到dml语句（类似于insert、delete、update）。由于mysql服务器没有处理实际的sql语句，所以所有memcached命令（flush_all除外）都使用基于行的复制（rbr）日志记录，这与任何服务器binlog_格式设置无关。</p></li><li class="listitem"><p>
                        The <span class="command"><strong>memcached</strong></span>
                        <code class="literal">flush_all</code> command is mapped to the
                        <a class="link" href="sql-syntax.html#truncate-table" title="13.1.34&nbsp;TRUNCATE TABLE Syntax"><code class="literal">TRUNCATE TABLE</code></a> command. Since
                        <a class="link" href="glossary.html#glos_ddl" title="DDL">DDL</a> commands can only use
                        statement-based logging, the <code class="literal">flush_all</code>
                        command is replicated by sending a
                        <a class="link" href="sql-syntax.html#truncate-table" title="13.1.34&nbsp;TRUNCATE TABLE Syntax"><code class="literal">TRUNCATE TABLE</code></a> statement.
                    </p><p style="color:blue;">memcached flush_all命令被映射到truncate table命令。由于ddl命令只能使用基于语句的日志记录，因此通过发送truncate table语句复制flush_all命令。</p></li></ul>
                </div>
                <p>
                    Transactions:
                </p><p style="color:blue;">交易</p>
                <div class="itemizedlist">
                    <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                        The concept of
                        <a class="link" href="glossary.html#glos_transaction" title="transaction">transactions</a> has not
                        typically been part of <span class="command"><strong>memcached</strong></span>
                        applications. For performance considerations,
                        <a class="link" href="innodb-storage-engine.html#sysvar_daemon_memcached_r_batch_size"><code class="literal">daemon_memcached_r_batch_size</code></a>
                        and
                        <a class="link" href="innodb-storage-engine.html#sysvar_daemon_memcached_w_batch_size"><code class="literal">daemon_memcached_w_batch_size</code></a>
                        are used to control the batch size for read and write
                        transactions. These settings do not affect replication. Each
                        SQL operation on the underlying <code class="literal">InnoDB</code>
                        table is replicated after successful completion.
                    </p><p style="color:blue;">事务的概念通常不是memcached应用程序的一部分。出于性能考虑，daemon_memcached_r_batch_size和daemon_memcached_w_batch_size用于控制读写事务的批大小。这些设置不影响复制。成功完成后，底层innodb表上的每个sql操作都将被复制。</p></li><li class="listitem"><p>
                        The default value of
                        <a class="link" href="innodb-storage-engine.html#sysvar_daemon_memcached_w_batch_size"><code class="literal">daemon_memcached_w_batch_size</code></a>
                        is <code class="literal">1</code>, which means that each
                        <span class="command"><strong>memcached</strong></span> write operation is committed
                        immediately. This default setting incurs a certain amount of
                        performance overhead to avoid inconsistencies in the data
                        that is visible on the master and slave servers. The
                        replicated records are always available immediately on the
                        slave server. If you set
                        <a class="link" href="innodb-storage-engine.html#sysvar_daemon_memcached_w_batch_size"><code class="literal">daemon_memcached_w_batch_size</code></a>
                        to a value greater than <code class="literal">1</code>, records
                        inserted or updated through <span class="command"><strong>memcached</strong></span> are
                        not immediately visible on the master server; to view the
                        records on the master server before they are committed,
                        issue <a class="link" href="sql-syntax.html#set-transaction" title="13.3.6&nbsp;SET TRANSACTION Syntax"><code class="literal">SET
                        TRANSACTION ISOLATION LEVEL READ UNCOMMITTED</code></a>.
                    </p><p style="color:blue;">daemon_memcached_w_batch_size的默认值为1，这意味着立即提交每个memcached写操作。此默认设置会产生一定的性能开销，以避免主服务器和从服务器上可见的数据不一致。复制的记录总是在从属服务器上立即可用。如果将daemon_memcached_w_batch_size设置为大于1的值，则通过memcached插入或更新的记录在主服务器上不会立即可见；若要在提交前查看主服务器上的记录，请发出“设置事务隔离级别读取未提交”。</p></li></ul>
                </div>

            </div>

        </div>
        <div class="section">
            <div class="titlepage">
                <div>
                    <div>
                        <h3 class="title"><a name="innodb-memcached-internals"></a>14.20.7&nbsp;InnoDB memcached Plugin Internals</h3>

                    </div>

                </div>

            </div>
            <div class="simplesect">
                <div class="titlepage">
                    <div>
                        <div class="simple">
                            <h4 class="title"><a name="innodb-memcached-api"></a>InnoDB API for the InnoDB memcached Plugin</h4>

                        </div>

                    </div>

                </div>
                <p>
                    The <code class="literal">InnoDB</code> <span class="command"><strong>memcached</strong></span>
                    engine accesses <code class="literal">InnoDB</code> through
                    <code class="literal">InnoDB</code> APIs, most of which are directly
                    adopted from embedded <code class="literal">InnoDB</code>.
                    <code class="literal">InnoDB</code> API functions are passed to the
                    <code class="literal">InnoDB</code> <span class="command"><strong>memcached</strong></span> engine as
                    callback functions. <code class="literal">InnoDB</code> API functions
                    access the <code class="literal">InnoDB</code> tables directly, and are
                    mostly DML operations with the exception of
                    <a class="link" href="sql-syntax.html#truncate-table" title="13.1.34&nbsp;TRUNCATE TABLE Syntax"><code class="literal">TRUNCATE TABLE</code></a>.
                </p><p style="color:blue;">InnoDB Memcached引擎通过InnoDB API访问InnoDB，大部分直接从嵌入式InnoDB中采用。innodb api函数作为回调函数传递给innodb memcached引擎。innodb api函数直接访问innodb表，除了truncate table之外，大部分都是dml操作。</p><p>
                <span class="command"><strong>memcached</strong></span> commands are implemented through
                the <code class="literal">InnoDB</code> <span class="command"><strong>memcached</strong></span> API.
                The following table outlines how <span class="command"><strong>memcached</strong></span>
                commands are mapped to DML or DDL operations.
            </p><p style="color:blue;">memcached命令是通过innodb memcached api实现的。下表概述了memcached命令如何映射到dml或ddl操作。</p>
                <div class="table">
                    <a name="idm140286804798032"></a><p class="title"><b>Table&nbsp;14.23&nbsp;memcached Commands and Associated DML or DDL Operations</b></p><p style="color:blue;">表14.23 memcached命令和相关的dml或ddl操作</p>
                    <div class="table-contents">
                        <table frame="all" summary="memcached commands and associated DML or DDL operations."><colgroup><col width="25%"><col width="75%"></colgroup><thead><tr>
                            <th scope="col">memcached Command</th>
                            <th scope="col">DML or DDL Operations</th>
                        </tr></thead><tbody><tr>
                            <td scope="row"><code class="literal">get</code></td>
                            <td>a read/fetch command</td>
                        </tr><tr>
                            <td scope="row"><code class="literal">set</code></td>
                            <td>a search followed by an <code class="literal">INSERT</code> or
                                <code class="literal">UPDATE</code> (depending on whether or not a
                                key exists)</td>
                        </tr><tr>
                            <td scope="row"><code class="literal">add</code></td>
                            <td>a search followed by an <code class="literal">INSERT</code> or
                                <code class="literal">UPDATE</code></td>
                        </tr><tr>
                            <td scope="row"><code class="literal">replace</code></td>
                            <td>a search followed by an <code class="literal">UPDATE</code></td>
                        </tr><tr>
                            <td scope="row"><code class="literal">append</code></td>
                            <td>a search followed by an <code class="literal">UPDATE</code> (appends data to the
                                result before <code class="literal">UPDATE</code>)</td>
                        </tr><tr>
                            <td scope="row"><code class="literal">prepend</code></td>
                            <td>a search followed by an <code class="literal">UPDATE</code> (prepends data to the
                                result before <code class="literal">UPDATE</code>)</td>
                        </tr><tr>
                            <td scope="row"><code class="literal">incr</code></td>
                            <td>a search followed by an <code class="literal">UPDATE</code></td>
                        </tr><tr>
                            <td scope="row"><code class="literal">decr</code></td>
                            <td>a search followed by an <code class="literal">UPDATE</code></td>
                        </tr><tr>
                            <td scope="row"><code class="literal">delete</code></td>
                            <td>a search followed by a <code class="literal">DELETE</code></td>
                        </tr><tr>
                            <td scope="row"><code class="literal">flush_all</code></td>
                            <td><code class="literal">TRUNCATE TABLE</code> (DDL)</td>
                        </tr></tbody></table>
                    </div>

                </div>
                <br class="table-break">
            </div>
            <div class="simplesect">
                <div class="titlepage">
                    <div>
                        <div class="simple">
                            <h4 class="title"><a name="innodb-memcached-config-tables"></a>InnoDB memcached Plugin Configuration Tables</h4>

                        </div>

                    </div>

                </div>
                <a class="indexterm" name="idm140286804753728"></a><a class="indexterm" name="idm140286804752688"></a><a class="indexterm" name="idm140286804751616"></a><a class="indexterm" name="idm140286804750544"></a><p>
                This section describes configuration tables used by the
                <code class="literal">daemon_memcached</code> plugin. The
                <code class="literal">cache_policies</code> table,
                <code class="literal">config_options</code> table, and
                <code class="literal">containers</code> table are created by the
                <code class="filename">innodb_memcached_config.sql</code> configuration
                script in the <code class="literal">innodb_memcache</code> database.
            </p><p style="color:blue;">本节介绍守护程序memcached插件使用的配置表。cache_policies表、config_options表和containers表由innodb_memcached_config.sql配置脚本在innodb_memcache数据库中创建。</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>USE innodb_memcache;</code></strong>
Database changed
mysql&gt; <strong class="userinput"><code>SHOW TABLES;</code></strong>
+---------------------------+
| Tables_in_innodb_memcache |
+---------------------------+
| cache_policies            |
| config_options            |
| containers                |
+---------------------------+
</pre>
            </div>
            <div class="simplesect">
                <div class="titlepage">
                    <div>
                        <div class="simple">
                            <h4 class="title"><a name="innodb-memcached-cache-policies-table"></a>cache_policies Table</h4>

                        </div>

                    </div>

                </div>
                <p>
                    The <code class="literal">cache_policies</code> table defines a cache
                    policy for the <code class="literal">InnoDB</code>
                    <code class="literal">memcached</code> installation. You can specify
                    individual policies for <code class="literal">get</code>,
                    <code class="literal">set</code>, <code class="literal">delete</code>, and
                    <code class="literal">flush</code> operations, within a single cache
                    policy. The default setting for all operations is
                    <code class="literal">innodb_only</code>.
                </p><p style="color:blue;">cache_policies表定义了innodb memcached安装的缓存策略。可以在单个缓存策略中为get、set、delete和flush操作指定单个策略。所有操作的默认设置都是innodb_only。</p>
                <div class="itemizedlist">
                    <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                        <code class="literal">innodb_only</code>: Use
                        <code class="literal">InnoDB</code> as the data store.
                    </p><p style="color:blue;">innodb_only：使用innodb作为数据存储。</p></li><li class="listitem"><p>
                        <code class="literal">cache_only</code>: Use the
                        <span class="command"><strong>memcached</strong></span> engine as the data store.
                    </p><p style="color:blue;">仅缓存：使用memcached引擎作为数据存储。</p></li><li class="listitem"><p>
                        <code class="literal">caching</code>: Use both
                        <code class="literal">InnoDB</code> and the
                        <span class="command"><strong>memcached</strong></span> engine as data stores. In this
                        case, if <span class="command"><strong>memcached</strong></span> cannot find a key in
                        memory, it searches for the value in an
                        <code class="literal">InnoDB</code> table.
                    </p><p style="color:blue;">缓存：使用innodb和memcached引擎作为数据存储。在这种情况下，如果memcached在内存中找不到键，它将在innodb表中搜索该值。</p></li><li class="listitem"><p>
                        <code class="literal">disable</code>: Disable caching.
                    </p><p style="color:blue;">禁用：禁用缓存。</p></li></ul>
                </div>

                <div class="table">
                    <a name="idm140286804723712"></a><p class="title"><b>Table&nbsp;14.24&nbsp;cache_policies Columns</b></p><p style="color:blue;">表14.24缓存策略列</p>
                    <div class="table-contents">
                        <table frame="all" summary="Columns of the cache_policies table."><colgroup><col width="50%"><col width="50%"></colgroup><thead><tr>
                            <th scope="col">Column</th>
                            <th scope="col">Description</th>
                        </tr></thead><tbody><tr>
                            <td scope="row"><code class="literal">policy_name</code></td>
                            <td>Name of the cache policy. The default cache policy name is
                                <code class="literal">cache_policy</code>.</td>
                        </tr><tr>
                            <td scope="row"><code class="literal">get_policy</code></td>
                            <td>The cache policy for get operations. Valid values are
                                <code class="literal">innodb_only</code>,
                                <code class="literal">cache_only</code>, <code class="literal">caching</code>,
                                or <code class="literal">disabled</code>. The default setting is
                                <code class="literal">innodb_only</code>.</td>
                        </tr><tr>
                            <td scope="row"><code class="literal">set_policy</code></td>
                            <td>The cache policy for set operations. Valid values are
                                <code class="literal">innodb_only</code>,
                                <code class="literal">cache_only</code>, <code class="literal">caching</code>,
                                or <code class="literal">disabled</code>. The default setting is
                                <code class="literal">innodb_only</code>.</td>
                        </tr><tr>
                            <td scope="row"><code class="literal">delete_policy</code></td>
                            <td>The cache policy for delete operations. Valid values are
                                <code class="literal">innodb_only</code>,
                                <code class="literal">cache_only</code>, <code class="literal">caching</code>,
                                or <code class="literal">disabled</code>. The default setting is
                                <code class="literal">innodb_only</code>.</td>
                        </tr><tr>
                            <td scope="row"><code class="literal">flush_policy</code></td>
                            <td>The cache policy for flush operations. Valid values are
                                <code class="literal">innodb_only</code>,
                                <code class="literal">cache_only</code>, <code class="literal">caching</code>,
                                or <code class="literal">disabled</code>. The default setting is
                                <code class="literal">innodb_only</code>.</td>
                        </tr></tbody></table>
                    </div>

                </div>
                <br class="table-break">
            </div>
            <div class="simplesect">
                <div class="titlepage">
                    <div>
                        <div class="simple">
                            <h4 class="title"><a name="innodb-memcached-config-options-table"></a>config_options Table</h4>

                        </div>

                    </div>

                </div>
                <p>
                    The <code class="literal">config_options</code> table stores
                    <span class="command"><strong>memcached</strong></span>-related settings that can be
                    changed at runtime using SQL. Supported configuration options
                    are <code class="literal">separator</code> and
                    <code class="literal">table_map_delimiter</code>.
                </p><p style="color:blue;">config_options表存储memcached相关设置，这些设置可以在运行时使用sql进行更改。支持的配置选项包括分隔符和表映射分隔符。</p>
                <div class="table">
                    <a name="idm140286804683504"></a><p class="title"><b>Table&nbsp;14.25&nbsp;config_options Columns</b></p><p style="color:blue;">表14.25配置选项列</p>
                    <div class="table-contents">
                        <table frame="all" summary="Columns of the config_options table."><colgroup><col width="20%"><col width="80%"></colgroup><thead><tr>
                            <th scope="col">Column</th>
                            <th scope="col">Description</th>
                        </tr></thead><tbody><tr>
                            <td scope="row"><code class="literal">Name</code></td>
                            <td>Name of the <span class="command"><strong>memcached</strong></span>-related configuration option.
                                The following configuration options are supported by the
                                <code class="literal">config_options</code> table:
                                <div class="itemizedlist">
                                    <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                                        <code class="literal">separator</code>: Used to separate
                                        values of a long string into separate values when
                                        there are multiple <code class="literal">value_columns</code>
                                        defined. By default, the
                                        <code class="literal">separator</code> is a
                                        <code class="literal">|</code> character. For example, if you
                                        define <code class="literal">col1, col2</code> as value
                                        columns, and you define <code class="literal">|</code> as the
                                        separator, you can issue the following
                                        <span class="command"><strong>memcached</strong></span> command to insert
                                        values into <code class="literal">col1</code> and
                                        <code class="literal">col2</code>, respectively:
                                    </p><p style="color:blue;">分隔符：当定义了多个值列时，用于将长字符串的值分隔成单独的值。默认情况下，分隔符是一个字符。例如，如果将col1、col2定义为值列，并将定义为分隔符，则可以发出以下memcached命令将值分别插入col1和col2：</p><pre data-lang="terminal" class="programlisting">set keyx 10 0 19
valuecolx|valuecoly
</pre><p>
                                        <code class="literal">valuecol1x</code> is stored in
                                        <code class="literal">col1</code> and
                                        <code class="literal">valuecoly</code> is stored in
                                        <code class="literal">col2</code>.
                                    </p><p style="color:blue;">valuecol1x存储在col1中，valuecoly存储在col2中。</p></li><li class="listitem"><p>
                                        <code class="literal">table_map_delimiter</code>: The
                                        character separating the schema name and the table
                                        name when you use the <code class="literal">@@</code> notation
                                        in a key name to access a key in a specific table.
                                        For example, <code class="literal">@@t1.some_key</code> and
                                        <code class="literal">@@t2.some_key</code> have the same key
                                        value, but are stored in different tables.
                                    </p><p style="color:blue;">表映射分隔符：在键名中使用@@符号访问特定表中的键时，分隔架构名和表名的字符。例如，@@t1.some廑key和@t2.some廑key具有相同的键值，但存储在不同的表中。</p></li></ul>
                                </div>
                            </td>
                        </tr><tr>
                            <td scope="row"><code class="literal">Value</code></td>
                            <td>The value assigned to the <span class="command"><strong>memcached</strong></span>-related
                                configuration option.</td>
                        </tr></tbody></table>
                    </div>

                </div>
                <br class="table-break">
            </div>
            <div class="simplesect">
                <div class="titlepage">
                    <div>
                        <div class="simple">
                            <h4 class="title"><a name="innodb-memcached-containers-table"></a>containers Table</h4>

                        </div>

                    </div>

                </div>
                <p>
                    The <code class="literal">containers</code> table is the most important of
                    the three configuration tables. Each <code class="literal">InnoDB</code>
                    table that is used to store <span class="command"><strong>memcached</strong></span> values
                    must have an entry in the <code class="literal">containers</code> table.
                    The entry provides a mapping between <code class="literal">InnoDB</code>
                    table columns and container table columns, which is required for
                    <code class="literal">memcached</code> to work with
                    <code class="literal">InnoDB</code> tables.
                </p><p style="color:blue;">容器表是三个配置表中最重要的一个。用于存储memcached值的每个innodb表都必须在containers表中有一个条目。条目提供了innodb表列和容器表列之间的映射，这是memcached处理innodb表所必需的。</p><p>
                The <code class="literal">containers</code> table contains a default entry
                for the <code class="literal">test.demo_test</code> table, which is
                created by the <code class="filename">innodb_memcached_config.sql</code>
                configuration script. To use the
                <code class="literal">daemon_memcached</code> plugin with your own
                <code class="literal">InnoDB</code> table, you must create an entry in the
                <code class="literal">containers</code> table.
            </p><p style="color:blue;">containers表包含test.demo_测试表的默认项，该测试表由innodb_memcached_config.sql配置脚本创建。要在自己的innodb表中使用daemon_memcached插件，必须在containers表中创建一个条目。</p>
                <div class="table">
                    <a name="idm140286804641552"></a><p class="title"><b>Table&nbsp;14.26&nbsp;containers Columns</b></p><p style="color:blue;">表14.26集装箱栏</p>
                    <div class="table-contents">
                        <table frame="all" summary="Columns of the containers table."><colgroup><col width="30%"><col width="70%"></colgroup><thead><tr>
                            <th scope="col">Column</th>
                            <th scope="col">Description</th>
                        </tr></thead><tbody><tr>
                            <td scope="row"><code class="literal">name</code></td>
                            <td>The name given to the container. If an <code class="literal">InnoDB</code> table
                                is not requested by name using <code class="literal">@@</code>
                                notation, the <code class="literal">daemon_memcached</code> plugin
                                uses the <code class="literal">InnoDB</code> table with a
                                <code class="literal">containers.name</code> value of
                                <code class="literal">default</code>. If there is no such entry, the
                                first entry in the <code class="literal">containers</code> table,
                                ordered alphabetically by <code class="literal">name</code>
                                (ascending), determines the default
                                <code class="literal">InnoDB</code> table.</td>
                        </tr><tr>
                            <td scope="row"><code class="literal">db_schema</code></td>
                            <td>The name of the database where the <code class="literal">InnoDB</code> table
                                resides. This is a required value.</td>
                        </tr><tr>
                            <td scope="row"><code class="literal">db_table</code></td>
                            <td>The name of the <code class="literal">InnoDB</code> table that stores
                                <span class="command"><strong>memcached</strong></span> values. This is a required
                                value.</td>
                        </tr><tr>
                            <td scope="row"><code class="literal">key_columns</code></td>
                            <td>The column in the <code class="literal">InnoDB</code> table that contains lookup
                                key values for <span class="command"><strong>memcached</strong></span> operations.
                                This is a required value.</td>
                        </tr><tr>
                            <td scope="row"><code class="literal">value_columns</code></td>
                            <td>The <code class="literal">InnoDB</code> table columns (one or more) that store
                                <code class="literal">memcached</code> data. Multiple columns can be
                                specified using the separator character specified in the
                                <code class="literal">innodb_memcached.config_options</code> table.
                                By default, the separator is a pipe character
                                (<span class="quote">“<span class="quote">|</span>”</span>). To specify multiple columns, separate
                                them with the defined separator character. For example:
                                <code class="literal">col1|col2|col3</code>. This is a required
                                value.</td>
                        </tr><tr>
                            <td scope="row"><code class="literal">flags</code></td>
                            <td>The <code class="literal">InnoDB</code> table columns that are used as flags (a
                                user-defined numeric value that is stored and retrieved
                                along with the main value) for
                                <span class="command"><strong>memcached</strong></span>. A flag value can be used as
                                a column specifier for some operations (such as
                                <code class="literal">incr</code>, <code class="literal">prepend</code>) if a
                                <span class="command"><strong>memcached</strong></span> value is mapped to multiple
                                columns, so that an operation is performed on a specified
                                column. For example, if you have mapped a
                                <code class="literal">value_columns</code> to three
                                <code class="literal">InnoDB</code> table columns, and only want the
                                increment operation performed on one columns, use the
                                <code class="literal">flags</code> column to specify the column. If
                                you do not use the <code class="literal">flags</code> column, set a
                                value of <code class="literal">0</code> to indicate that it is
                                unused.</td>
                        </tr><tr>
                            <td scope="row"><code class="literal">cas_column</code></td>
                            <td>The <code class="literal">InnoDB</code> table column that stores compare-and-swap
                                (cas) values. The <code class="literal">cas_column</code> value is
                                related to the way <span class="command"><strong>memcached</strong></span> hashes
                                requests to different servers and caches data in memory.
                                Because the <code class="literal">InnoDB</code>
                                <span class="command"><strong>memcached</strong></span> plugin is tightly integrated
                                with a single <span class="command"><strong>memcached</strong></span> daemon, and the
                                in-memory caching mechanism is handled by MySQL and the
                                <a class="link" href="glossary.html#glos_buffer_pool" title="buffer pool">InnoDB buffer
                                    pool</a>, this column is rarely needed. If you do not
                                use this column, set a value of <code class="literal">0</code> to
                                indicate that it is unused.</td>
                        </tr><tr>
                            <td scope="row"><code class="literal">expire_time_column</code></td>
                            <td>The <code class="literal">InnoDB</code> table column that stores expiration
                                values. The <code class="literal">expire_time_column</code> value is
                                related to the way <span class="command"><strong>memcached</strong></span> hashes
                                requests to different servers and caches data in memory.
                                Because the <code class="literal">InnoDB</code>
                                <span class="command"><strong>memcached</strong></span> plugin is tightly integrated
                                with a single <span class="command"><strong>memcached</strong></span> daemon, and the
                                in-memory caching mechanism is handled by MySQL and the
                                <a class="link" href="glossary.html#glos_buffer_pool" title="buffer pool">InnoDB buffer
                                    pool</a>, this column is rarely needed. If you do not
                                use this column, set a value of <code class="literal">0</code> to
                                indicate that the column is unused. The maximum expire
                                time is defined as <code class="literal">INT_MAX32</code> or
                                2147483647 seconds (approximately 68 years).</td>
                        </tr><tr>
                            <td scope="row"><code class="literal">unique_idx_name_on_key</code></td>
                            <td>The name of the index on the key column. It must be a unique index. It
                                can be the <a class="link" href="glossary.html#glos_primary_key" title="primary key">primary
                                    key</a> or a
                                <a class="link" href="glossary.html#glos_secondary_index" title="secondary index">secondary
                                    index</a>. Preferably, use the primary key of the
                                <code class="literal">InnoDB</code> table. Using the primary key
                                avoids a lookup that is performed when using a secondary
                                index. You cannot make a
                                <a class="link" href="glossary.html#glos_covering_index" title="covering index">covering index</a>
                                for <span class="command"><strong>memcached</strong></span> lookups;
                                <code class="literal">InnoDB</code> returns an error if you try to
                                define a composite secondary index over both the key and
                                value columns.</td>
                        </tr></tbody></table>
                    </div>

                </div>
                <br class="table-break">
                <h5><a name="idm140286804569712"></a>containers Table Column Constraints</h5>
                <div class="itemizedlist">
                    <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                        You must supply a value for <code class="literal">db_schema</code>,
                        <code class="literal">db_name</code>, <code class="literal">key_columns</code>,
                        <code class="literal">value_columns</code> and
                        <code class="literal">unique_idx_name_on_key</code>. Specify
                        <code class="literal">0</code> for <code class="literal">flags</code>,
                        <code class="literal">cas_column</code>, and
                        <code class="literal">expire_time_column</code> if they are unused.
                        Failing to do so could cause your setup to fail.
                    </p><p style="color:blue;">必须为db_schema、db_name、key_columns、value_columns和unique_idx_name_on_key提供值。为标志、cas_列和expire_time_列（如果未使用）指定0。否则可能导致安装失败。</p></li><li class="listitem"><p>
                        <code class="literal">key_columns</code>: The maximum limit for a
                        <span class="command"><strong>memcached</strong></span> key is 250 characters, which is
                        enforced by <span class="command"><strong>memcached</strong></span>. The mapped key
                        must be a non-Null <a class="link" href="data-types.html#char" title="11.4.1&nbsp;The CHAR and VARCHAR Types"><code class="literal">CHAR</code></a> or
                        <a class="link" href="data-types.html#char" title="11.4.1&nbsp;The CHAR and VARCHAR Types"><code class="literal">VARCHAR</code></a> type.
                    </p><p style="color:blue;">KEYJUB:MimCaskKEY的最大限制是250个字符，这是由MeMcCurk强制执行的。映射键必须是非空char或varchar类型。</p></li><li class="listitem"><p>
                        <code class="literal">value_columns</code>: Must be mapped to a
                        <a class="link" href="data-types.html#char" title="11.4.1&nbsp;The CHAR and VARCHAR Types"><code class="literal">CHAR</code></a>,
                        <a class="link" href="data-types.html#char" title="11.4.1&nbsp;The CHAR and VARCHAR Types"><code class="literal">VARCHAR</code></a>, or
                        <a class="link" href="data-types.html#blob" title="11.4.3&nbsp;The BLOB and TEXT Types"><code class="literal">BLOB</code></a> column. There is no
                        length restriction and the value can be NULL.
                    </p><p style="color:blue;">value_columns:必须映射到char、varchar或blob列。没有长度限制，值可以为空。</p></li><li class="listitem"><p>
                        <code class="literal">cas_column</code>: The <code class="literal">cas</code>
                        value is a 64 bit integer. It must be mapped to a
                        <a class="link" href="data-types.html#integer-types" title="11.2.1&nbsp;Integer Types (Exact Value) - INTEGER, INT, SMALLINT, TINYINT, MEDIUMINT, BIGINT"><code class="literal">BIGINT</code></a> of at least 8 bytes.
                        If you do not use this column, set a value of
                        <code class="literal">0</code> to indicate that it is unused.
                    </p><p style="color:blue;">cas_列：cas值是64位整数。它必须映射到至少8个字节的bigint。如果不使用此列，请将值设置为0以指示该列未使用。</p></li><li class="listitem"><p>
                        <code class="literal">expiration_time_column</code>: Must mapped to an
                        <a class="link" href="data-types.html#integer-types" title="11.2.1&nbsp;Integer Types (Exact Value) - INTEGER, INT, SMALLINT, TINYINT, MEDIUMINT, BIGINT"><code class="literal">INTEGER</code></a> of at least 4 bytes.
                        Expiration time is defined as a 32-bit integer for Unix time
                        (the number of seconds since January 1, 1970, as a 32-bit
                        value), or the number of seconds starting from the current
                        time. For the latter, the number of seconds may not exceed
                        60*60*24*30 (the number of seconds in 30 days). If the
                        number sent by a client is larger, the server considers it
                        to be a real Unix time value rather than an offset from the
                        current time. If you do not use this column, set a value of
                        <code class="literal">0</code> to indicate that it is unused.
                    </p><p style="color:blue;">expiration_time_列：必须映射到至少4字节的整数。过期时间定义为UNIX时间的32位整数（自1970年1月1日起的秒数，32位值），或从当前时间开始的秒数。对于后者，秒数不能超过60*60*24*30（30天内的秒数）。如果客户机发送的数字较大，则服务器将其视为实际的unix时间值，而不是当前时间的偏移量。如果不使用此列，请将值设置为0以指示该列未使用。</p></li><li class="listitem"><p>
                        <code class="literal">flags</code>: Must be mapped to an
                        <a class="link" href="data-types.html#integer-types" title="11.2.1&nbsp;Integer Types (Exact Value) - INTEGER, INT, SMALLINT, TINYINT, MEDIUMINT, BIGINT"><code class="literal">INTEGER</code></a> of at least 32-bits
                        and can be NULL. If you do not use this column, set a value
                        of <code class="literal">0</code> to indicate that it is unused.
                    </p><p style="color:blue;">标志：必须映射到至少32位的整数，并且可以为空。如果不使用此列，请将值设置为0以指示该列未使用。</p></li></ul>
                </div>
                <p>
                    A pre-check is performed at plugin load time to enforce column
                    constraints. If mismatches are found, the plugin is not loaded.
                </p><p style="color:blue;">在插件加载时执行预检查以强制执行列约束。如果发现不匹配，则不加载插件。</p>
                <h5><a name="idm140286804538096"></a>Multiple Value Column Mapping</h5>
                <div class="itemizedlist">
                    <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                        During plugin initialization, when <code class="literal">InnoDB</code>
                        <span class="command"><strong>memcached</strong></span> is configured with information
                        defined in the <code class="literal">containers</code> table, each
                        mapped column defined in
                        <code class="literal">containers.value_columns</code> is verified
                        against the mapped <code class="literal">InnoDB</code> table. If
                        multiple <code class="literal">InnoDB</code> table columns are mapped,
                        there is a check to ensure that each column exists and is
                        the right type.
                    </p><p style="color:blue;">在插件初始化过程中，当innodb memcached配置了containers表中定义的信息时，containers.value_列中定义的每个映射列都会根据映射的innodb表进行验证。如果映射多个InDB表列，则检查以确保每个列都存在，并且是正确的类型。</p></li><li class="listitem"><p>
                        At run-time, for <code class="literal">memcached</code> insert
                        operations, if there are more delimited values than the
                        number of mapped columns, only the number of mapped values
                        are taken. For example, if there are six mapped columns, and
                        seven delimited values are provided, only the first six
                        delimited values are taken. The seventh delimited value is
                        ignored.
                    </p><p style="color:blue;">在运行时，对于memcached insert操作，如果分隔值多于映射列的数量，则只取映射值的数量。例如，如果有六个映射列，并且提供了七个分隔值，则只取前六个分隔值。忽略第七个分隔值。</p></li><li class="listitem"><p>
                        If there are fewer delimited values than mapped columns,
                        unfilled columns are set to NULL. If an unfilled column
                        cannot be set to NULL, insert operations fail.
                    </p><p style="color:blue;">如果分隔值少于映射列，则未填充列将设置为空。如果未填充列不能设置为空，则插入操作将失败。</p></li><li class="listitem"><p>
                        If a table has more columns than mapped values, the extra
                        columns do not affect results.
                    </p><p style="color:blue;">如果表的列数多于映射值，则额外的列不会影响结果。</p></li></ul>
                </div>

            </div>
            <div class="simplesect">
                <div class="titlepage">
                    <div>
                        <div class="simple">
                            <h4 class="title"><a name="innodb-memcached-demo-test-table"></a>The demo_test Example Table</h4>

                        </div>

                    </div>

                </div>
                <p>
                    The <code class="filename">innodb_memcached_config.sql</code>
                    configuration script creates a <code class="literal">demo_test</code>
                    table in the <code class="literal">test</code> database, which can be used
                    to verify <code class="literal">InnoDB</code> <span class="command"><strong>memcached</strong></span>
                    plugin installation immediately after setup.
                </p><p style="color:blue;">innodb_memcached_config.sql配置脚本在测试数据库中创建一个demo_test表，可用于在安装后立即验证innodb memcached插件的安装。</p><p>
                The <code class="filename">innodb_memcached_config.sql</code>
                configuration script also creates an entry for the
                <code class="literal">demo_test</code> table in the
                <code class="literal">innodb_memcache.containers</code> table.
            </p><p style="color:blue;">innodb_memcached_config.sql配置脚本还为innodb_memcache.containers表中的demo_test表创建一个条目。</p><pre data-lang="terminal" class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT * FROM innodb_memcache.containers\G</code></strong>
*************************** 1. row ***************************
                  name: aaa
             db_schema: test
              db_table: demo_test
           key_columns: c1
         value_columns: c2
                 flags: c3
            cas_column: c4
    expire_time_column: c5
unique_idx_name_on_key: PRIMARY

mysql&gt; <strong class="userinput"><code>SELECT * FROM test.demo_test;</code></strong>
+----+------------------+------+------+------+
| c1 | c2               | c3   | c4   | c5   |
+----+------------------+------+------+------+
| AA | HELLO, HELLO     |    8 |    0 |    0 |
+----+------------------+------+------+------+
</pre>
            </div>

        </div>
        <div class="section">
            <div class="titlepage">
                <div>
                    <div>
                        <h3 class="title"><a name="innodb-memcached-troubleshoot"></a>14.20.8&nbsp;Troubleshooting the InnoDB memcached Plugin</h3>

                    </div>

                </div>

            </div>
            <p>
                This section describes issues that you may encounter when using
                the <code class="literal">InnoDB</code> <span class="command"><strong>memcached</strong></span> plugin.
            </p><p style="color:blue;">本节描述使用innodb memcached插件时可能遇到的问题。</p>
            <div class="itemizedlist">
                <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                    If you encounter the following error in the MySQL error log,
                    the server might fail to start:
                </p><p style="color:blue;">如果在mysql错误日志中遇到以下错误，服务器可能无法启动：</p><p>
          <span class="errortext">failed to set rlimit for open files. Try running as
          root or requesting smaller maxconns value.</span>
                </p><p style="color:blue;">无法为打开的文件设置rlimit。尝试以根用户身份运行或请求较小的maxconns值。</p><p>
                    The error message is from the <span class="command"><strong>memcached</strong></span>
                    daemon. One solution is to raise the OS limit for the number
                    of open files. The commands for checking and increasing the
                    open file limit varies by operating system. This example shows
                    commands for Linux and OS X:
                </p><p style="color:blue;">错误消息来自memcached守护进程。一种解决方案是提高开放文件数量的操作系统限制。用于检查和增加打开文件限制的命令因操作系统而异。此示例显示Linux和OS X的命令：</p><pre data-lang="terminal" class="programlisting"># Linux
shell&gt; <strong class="userinput"><code>ulimit -n</code></strong>
1024
shell&gt; <strong class="userinput"><code>ulimit -n 4096</code></strong>
shell&gt; <strong class="userinput"><code>ulimit -n</code></strong>
4096

# OS X
shell&gt; <strong class="userinput"><code>ulimit -n</code></strong>
256
shell&gt; <strong class="userinput"><code>ulimit -n 4096</code></strong>
shell&gt; <strong class="userinput"><code>ulimit -n</code></strong>
4096
</pre><p>
                    The other solution is to reduce the number of concurrent
                    connections permitted for the <span class="command"><strong>memcached</strong></span>
                    daemon. To do so, encode the <code class="literal">-c</code>
                    <span class="command"><strong>memcached</strong></span> option in the
                    <a class="link" href="innodb-storage-engine.html#sysvar_daemon_memcached_option"><code class="literal">daemon_memcached_option</code></a>
                    configuration parameter in the MySQL configuration file. The
                    <code class="literal">-c</code> option has a default value of 1024.
                </p><p style="color:blue;">另一个解决方案是减少memcached守护进程允许的并发连接数。为此，请对mysql配置文件中daemon_memcached_option配置参数中的-c memcached选项进行编码。-c选项的默认值为1024。</p><pre data-lang="ini" class="programlisting">[mysqld]
...
loose-daemon_memcached_option='-c 64'
</pre></li><li class="listitem"><p>
                    To troubleshoot problems where the
                    <span class="command"><strong>memcached</strong></span> daemon is unable to store or
                    retrieve <code class="literal">InnoDB</code> table data, encode the
                    <code class="literal">-vvv</code> <span class="command"><strong>memcached</strong></span> option in
                    the <a class="link" href="innodb-storage-engine.html#sysvar_daemon_memcached_option"><code class="literal">daemon_memcached_option</code></a>
                    configuration parameter in the MySQL configuration file.
                    Examine the MySQL error log for debug output related to
                    <span class="command"><strong>memcached</strong></span> operations.
                </p><p style="color:blue;">要解决memcached守护进程无法存储或检索innodb表数据的问题，请在mysql配置文件的daemon_memcached_option配置参数中编码-vvv memcached选项。检查mysql错误日志中与memcached操作相关的调试输出。</p><pre data-lang="ini" class="programlisting">[mysqld]
...
loose-daemon_memcached_option='-vvv'
</pre></li><li class="listitem"><p>
                    If columns specified to hold <span class="command"><strong>memcached</strong></span>
                    values are the wrong data type, such as a numeric type instead
                    of a string type, attempts to store key-value pairs fail with
                    no specific error code or message.
                </p><p style="color:blue;">如果指定用于保存memcached值的列是错误的数据类型，例如数值类型而不是字符串类型，则尝试存储键值对失败，并且没有特定的错误代码或消息。</p></li><li class="listitem"><p>
                    If the <code class="literal">daemon_memcached</code> plugin causes MySQL
                    server startup issues, you can temporarily disable the
                    <code class="literal">daemon_memcached</code> plugin while
                    troubleshooting by adding this line under the
                    <code class="literal">[mysqld]</code> group in the MySQL configuration
                    file:
                </p><p style="color:blue;">如果daemon_memcached插件导致mysql服务器启动问题，则可以在故障排除时暂时禁用daemon_memcached插件，方法是在mysql配置文件的[mysqld]组下添加以下行：</p><pre data-lang="ini" class="programlisting">daemon_memcached=OFF
</pre><p>
                    For example, if you run the <a class="link" href="sql-syntax.html#install-plugin" title="13.7.3.3&nbsp;INSTALL PLUGIN Syntax"><code class="literal">INSTALL
                    PLUGIN</code></a> statement before running the
                    <code class="filename">innodb_memcached_config.sql</code> configuration
                    script to set up the necessary database and tables, the server
                    might crash and fail to start. The server could also fail to
                    start if you incorrectly configure an entry in the
                    <code class="literal">innodb_memcache.containers</code> table.
                </p><p style="color:blue;">例如，如果在运行innodb_memcached_config.sql配置脚本以设置必要的数据库和表之前运行install plugin语句，服务器可能会崩溃并无法启动。如果在innodb_memcache.containers表中不正确配置条目，服务器也可能无法启动。</p><p>
                    To uninstall the <span class="command"><strong>memcached</strong></span> plugin for a
                    MySQL instance, issue the following statement:
                </p><p style="color:blue;">要卸载MySQL实例的memcached插件，请发出以下语句：</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>UNINSTALL PLUGIN daemon_memcached;</code></strong>
</pre></li><li class="listitem"><p>
                    If you run more than one instance of MySQL on the same machine
                    with the <code class="literal">daemon_memcached</code> plugin enabled in
                    each instance, use the
                    <a class="link" href="innodb-storage-engine.html#sysvar_daemon_memcached_option"><code class="literal">daemon_memcached_option</code></a>
                    configuration parameter to specify a unique
                    <span class="command"><strong>memcached</strong></span> port for each
                    <code class="literal">daemon_memcached</code> plugin.
                </p><p style="color:blue;">如果在同一台计算机上运行多个mysql实例，并且每个实例中都启用了daemon_memcached插件，请使用daemon_memcached_option配置参数为每个daemon_memcached插件指定唯一的memcached端口。</p></li><li class="listitem"><p>
                    If an SQL statement cannot find the <code class="literal">InnoDB</code>
                    table or finds no data in the table, but
                    <span class="command"><strong>memcached</strong></span> API calls retrieve the expected
                    data, you may be missing an entry for the
                    <code class="literal">InnoDB</code> table in the
                    <code class="literal">innodb_memcache.containers</code> table, or you
                    may have not switched to the correct <code class="literal">InnoDB</code>
                    table by issuing a <code class="literal">get</code> or
                    <code class="literal">set</code> request using
                    <code class="literal">@@<em class="replaceable"><code>table_id</code></em></code>
                    notation. This problem could also occur if you change an
                    existing entry in the
                    <code class="literal">innodb_memcache.containers</code> table without
                    restarting the MySQL server afterward. The free-form storage
                    mechanism is flexible enough that your requests to store or
                    retrieve a multi-column value such as
                    <code class="literal">col1|col2|col3</code> may still work, even if the
                    daemon is using the <code class="literal">test.demo_test</code> table
                    which stores values in a single column.
                </p><p style="color:blue;">如果SQL语句找不到InnoDB表或在表中找不到数据，但Memcached API调用检索到所需的数据，则可能是InnoDB memcache.containers表中缺少InnoDB表的条目，或者是使用@@table\u id表示法发出GET或SET请求而没有切换到正确的InnoDB表。如果您在NoYbByMyCaseCH容器表中更改现有条目而不重新启动MySQL服务器，则此问题也可能发生。自由形式存储机制足够灵活，即使在守护进程使用存储在单个列中的值的Test.DeMosiTestTo表时，存储或检索多列值（如COL1）COL2μCOL3的请求仍然可以工作。</p></li><li class="listitem"><p>
                    When defining your own <code class="literal">InnoDB</code> table for use
                    with the <code class="literal">daemon_memcached</code> plugin, and
                    columns in the table are defined as <code class="literal">NOT
                    NULL</code>, ensure that values are supplied for the
                    <code class="literal">NOT NULL</code> columns when inserting a record
                    for the table into the
                    <code class="literal">innodb_memcache.containers</code> table. If the
                    <a class="link" href="sql-syntax.html#insert" title="13.2.5&nbsp;INSERT Syntax"><code class="literal">INSERT</code></a> statement for the
                    <code class="literal">innodb_memcache.containers</code> record contains
                    fewer delimited values than there are mapped columns, unfilled
                    columns are set to <code class="literal">NULL</code>. Attempting to
                    insert a <code class="literal">NULL</code> value into a <code class="literal">NOT
                    NULL</code> column causes the
                    <a class="link" href="sql-syntax.html#insert" title="13.2.5&nbsp;INSERT Syntax"><code class="literal">INSERT</code></a> to fail, which may only
                    become evident after you reinitialize the
                    <code class="literal">daemon_memcached</code> plugin to apply changes to
                    the <code class="literal">innodb_memcache.containers</code> table.
                </p><p style="color:blue;">在定义自己的innodb表以便与daemon_memcached插件一起使用时，表中的列被定义为非空，请确保在将表的记录插入innodb_memcache.containers表时为非空列提供值。如果innodb_memcache.containers记录的insert语句包含的分隔值少于映射列，则未填充列设置为空。尝试将空值插入not null列会导致插入失败，只有在重新初始化daemon_memcached插件以将更改应用于innodb_memcache.containers表之后，插入才会变得明显。</p></li><li class="listitem"><p>
                    If <code class="literal">cas_column</code> and
                    <code class="literal">expire_time_column</code> fields of the
                    <code class="literal">innodb_memcached.containers</code> table are set
                    to <code class="literal">NULL</code>, the following error is returned
                    when attempting to load the <span class="command"><strong>memcached</strong></span>
                    plugin:
                </p><p style="color:blue;">如果innodb_memcached.containers表的cas_column和expire_time_column字段设置为空，则在尝试加载memcached插件时返回以下错误：</p><pre data-lang="terminal" class="programlisting">InnoDB_Memcached: column 6 in the entry for config table 'containers' in
database 'innodb_memcache' has an invalid NULL value.
</pre><p>
                    The <span class="command"><strong>memcached</strong></span> plugin rejects usage of
                    <code class="literal">NULL</code> in the <code class="literal">cas_column</code>
                    and <code class="literal">expire_time_column</code> columns. Set the
                    value of these columns to <code class="literal">0</code> when the
                    columns are unused.
                </p><p style="color:blue;">memcached插件拒绝在cas_列和expire_time_列中使用null。当列未使用时，将这些列的值设置为0。</p></li><li class="listitem"><p>
                    As the length of the <span class="command"><strong>memcached</strong></span> key and
                    values increase, you might encounter size and length limits.
                </p><p style="color:blue;">随着memcached键的长度和值的增加，可能会遇到大小和长度限制。</p>
                    <div class="itemizedlist">
                        <ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
                            When the key exceeds 250 bytes,
                            <span class="command"><strong>memcached</strong></span> operations return an error.
                            This is currently a fixed limit within
                            <span class="command"><strong>memcached</strong></span>.
                        </p><p style="color:blue;">当密钥超过250字节时，memcached操作返回一个错误。这是目前memcached中的一个固定限制。</p></li><li class="listitem"><p>
                            <code class="literal">InnoDB</code> table limits may be encountered
                            if values exceed 768 bytes in size, 3072 bytes in size, or
                            half of the
                            <a class="link" href="innodb-storage-engine.html#sysvar_innodb_page_size"><code class="literal">innodb_page_size</code></a> value.
                            These limits primarily apply if you intend to create an
                            index on a value column to run report-generating queries
                            on that column using SQL. See
                            <a class="xref" href="innodb-storage-engine.html#innodb-restrictions" title="14.6.1.6&nbsp;Limits on InnoDB Tables">Section&nbsp;14.6.1.6, “Limits on InnoDB Tables”</a> for details.
                        </p><p style="color:blue;">如果值的大小超过768字节、3072字节或innodb_page_size值的一半，则可能会遇到innodb表限制。如果要在值列上创建索引以使用SQL在该列上运行报表生成查询，则这些限制主要适用。详见14.6.1.6节“InnoDB表的限制”。</p></li><li class="listitem"><p>
                            The maximum size for the key-value combination is 1 MB.
                        </p><p style="color:blue;">键值组合的最大大小为1 MB。</p></li></ul>
                    </div>
                </li><li class="listitem"><p>
                    If you share configuration files across MySQL servers of
                    different versions, using the latest configuration options for
                    the <code class="literal">daemon_memcached</code> plugin could cause
                    startup errors on older MySQL versions. To avoid compatibility
                    problems, use the <code class="literal">loose</code> prefix with option
                    names. For example, use
                    <code class="literal">loose-daemon_memcached_option='-c 64'</code>
                    instead of <code class="literal">daemon_memcached_option='-c 64'</code>.
                </p><p style="color:blue;">如果在不同版本的mysql服务器之间共享配置文件，则使用daemon_memcached插件的最新配置选项可能会导致较旧mysql版本的启动错误。要避免兼容性问题，请在选项名称中使用松散前缀。例如，使用loose-daemon_memcached_option='-c 64'，而不是daemon_memcached_option='-c64'。</p></li><li class="listitem"><p>
                    There is no restriction or check in place to validate
                    character set settings. <span class="command"><strong>memcached</strong></span> stores
                    and retrieves keys and values in bytes and is therefore not
                    character set sensitive. However, you must ensure that the
                    <span class="command"><strong>memcached</strong></span> client and the MySQL table use
                    the same character set.
                </p><p style="color:blue;">没有验证字符集设置的限制或签入。memcached以字节为单位存储和检索键和值，因此不区分字符集。但是，必须确保memcached客户机和mysql表使用相同的字符集。</p></li><li class="listitem"><p>
                    <span class="command"><strong>memcached</strong></span> connections are blocked from
                    accessing tables that contain an indexed virtual column.
                    Accessing an indexed virtual column requires a callback to the
                    server, but a <span class="command"><strong>memcached</strong></span> connection does not
                    have access to the server code.
                </p><p style="color:blue;">memcached连接被阻止访问包含索引虚拟列的表。访问已编制索引的虚拟列需要回调服务器，但memcached连接无权访问服务器代码。</p></li></ul>
            </div>

        </div>

    </div>
    <div class="section">
        <div class="titlepage">
            <div>
                <div>
                    <h2 class="title" style="clear: both"><a name="innodb-troubleshooting"></a>14.21&nbsp;InnoDB Troubleshooting</h2>

                </div>

            </div>

        </div>
        <div class="toc">
            <dl class="toc"><dt><span class="section"><a href="innodb-storage-engine.html#error-creating-innodb">14.21.1 Troubleshooting InnoDB I/O Problems</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#forcing-innodb-recovery">14.21.2 Forcing InnoDB Recovery</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-troubleshooting-datadict">14.21.3 Troubleshooting InnoDB Data Dictionary Operations</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-error-handling">14.21.4 InnoDB Error Handling</a></span></dt></dl>
        </div>
        <a class="indexterm" name="idm140286804424976"></a><p>
        The following general guidelines apply to troubleshooting
        <code class="literal">InnoDB</code> problems:
    </p><p style="color:blue;">以下一般指南适用于解决InnoDB问题：</p>
        <div class="itemizedlist">
            <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                When an operation fails or you suspect a bug, look at the MySQL
                server error log (see <a class="xref" href="server-administration.html#error-log" title="5.4.2&nbsp;The Error Log">Section&nbsp;5.4.2, “The Error Log”</a>).
                <a class="xref" href="error-handling.html#server-error-reference" title="B.3.1&nbsp;Server Error Message Reference">Section&nbsp;B.3.1, “Server Error Message Reference”</a> provides
                troubleshooting information for some of the common
                <code class="literal">InnoDB</code>-specific errors that you may
                encounter.
            </p><p style="color:blue;">当操作失败或怀疑有错误时，请查看mysql服务器错误日志（请参阅第5.4.2节“错误日志”）。第B.3.1节“服务器错误消息参考”提供了一些常见的InnoDB特定错误的故障排除信息。</p></li><li class="listitem"><p>
                If the failure is related to a
                <a class="link" href="glossary.html#glos_deadlock" title="deadlock">deadlock</a>, run with the
                <a class="link" href="innodb-storage-engine.html#sysvar_innodb_print_all_deadlocks"><code class="literal">innodb_print_all_deadlocks</code></a>
                option enabled so that details about each deadlock are printed
                to the MySQL server error log. For information about deadlocks,
                see <a class="xref" href="innodb-storage-engine.html#innodb-deadlocks" title="14.7.5&nbsp;Deadlocks in InnoDB">Section&nbsp;14.7.5, “Deadlocks in InnoDB”</a>.
            </p><p style="color:blue;">如果失败与死锁有关，请在启用innodb_print_all_deadlocks选项的情况下运行，以便将每个死锁的详细信息打印到mysql服务器错误日志中。有关死锁的信息，请参阅第14.7.5节“InnoDB中的死锁”。</p></li><li class="listitem"><p>
                Issues relating to the <code class="literal">InnoDB</code> data dictionary
                include failed <a class="link" href="sql-syntax.html#create-table" title="13.1.18&nbsp;CREATE TABLE Syntax"><code class="literal">CREATE TABLE</code></a>
                statements (orphan table files), inability to open
                <code class="literal">InnoDB</code> files, and <span class="errortext">system cannot
        find the path specified</span> errors. For information
                about these sorts of problems and errors, see
                <a class="xref" href="innodb-storage-engine.html#innodb-troubleshooting-datadict" title="14.21.3&nbsp;Troubleshooting InnoDB Data Dictionary Operations">Section&nbsp;14.21.3, “Troubleshooting InnoDB Data Dictionary Operations”</a>.
            </p><p style="color:blue;">与innodb数据字典相关的问题包括create table语句失败（孤立表文件）、无法打开innodb文件以及系统找不到指定路径的错误。有关此类问题和错误的信息，请参阅14.21.3节，“InnoDB数据字典操作故障排除”。</p></li><li class="listitem"><p>
                When troubleshooting, it is usually best to run the MySQL server
                from the command prompt, rather than through
                <a class="link" href="programs.html#mysqld-safe" title="4.3.2&nbsp;mysqld_safe — MySQL Server Startup Script"><span class="command"><strong>mysqld_safe</strong></span></a> or as a Windows service. You can
                then see what <a class="link" href="programs.html#mysqld" title="4.3.1&nbsp;mysqld — The MySQL Server"><span class="command"><strong>mysqld</strong></span></a> prints to the console,
                and so have a better grasp of what is going on. On Windows,
                start <a class="link" href="programs.html#mysqld" title="4.3.1&nbsp;mysqld — The MySQL Server"><span class="command"><strong>mysqld</strong></span></a> with the
                <a class="link" href="server-administration.html#option_mysqld_console"><code class="option">--console</code></a> option to direct the
                output to the console window.
            </p><p style="color:blue;">在进行故障排除时，通常最好从命令提示符运行mysql服务器，而不是通过mysqld_safe或作为windows服务运行。然后您可以看到mysqld打印到控制台的内容，从而更好地了解正在发生的事情。在Windows上，使用--console选项启动mysqld，将输出定向到控制台窗口。</p></li><li class="listitem"><p>
                <a class="indexterm" name="idm140286804404160"></a>

                <a class="indexterm" name="idm140286804402672"></a>

                Enable the <code class="literal">InnoDB</code> Monitors to obtain
                information about a problem (see
                <a class="xref" href="innodb-storage-engine.html#innodb-monitors" title="14.17&nbsp;InnoDB Monitors">Section&nbsp;14.17, “InnoDB Monitors”</a>). If the problem is
                performance-related, or your server appears to be hung, you
                should enable the standard Monitor to print information about
                the internal state of <code class="literal">InnoDB</code>. If the problem
                is with locks, enable the Lock Monitor. If the problem is with
                table creation, tablespaces, or data dictionary operations,
                refer to the
                <a class="link" href="innodb-storage-engine.html#innodb-information-schema-system-tables" title="14.15.3&nbsp;InnoDB INFORMATION_SCHEMA System Tables">InnoDB
                    Information Schema system tables</a> to examine contents of
                the <code class="literal">InnoDB</code> internal data dictionary.
            </p><p style="color:blue;">使InnoDB监视器获取有关问题的信息（请参阅第14.17节“InnoDB监视器”）。如果问题与性能有关，或者您的服务器看起来是挂起的，那么您应该启用标准监视器来打印关于innodb内部状态的信息。如果问题是锁，请启用锁监视器。如果问题是表创建、表空间或数据字典操作，请参考innodb information schema system tables检查innodb内部数据字典的内容。</p><p>
                <code class="literal">InnoDB</code> temporarily enables standard
                <code class="literal">InnoDB</code> Monitor output under the following
                conditions:
            </p><p style="color:blue;">InnoDB在以下情况下暂时启用标准InnoDB监视器输出：</p>
                <div class="itemizedlist">
                    <ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
                        A long semaphore wait
                    </p><p style="color:blue;">长时间的信号灯等待</p></li><li class="listitem"><p>
                        <code class="literal">InnoDB</code> cannot find free blocks in the
                        buffer pool
                    </p><p style="color:blue;">InnoDB在缓冲池中找不到可用块</p></li><li class="listitem"><p>
                        Over 67% of the buffer pool is occupied by lock heaps or the
                        adaptive hash index
                    </p><p style="color:blue;">超过67%的缓冲池被锁堆或自适应哈希索引占用</p></li></ul>
                </div>
            </li><li class="listitem"><p>
                If you suspect that a table is corrupt, run
                <a class="link" href="sql-syntax.html#check-table" title="13.7.2.2&nbsp;CHECK TABLE Syntax"><code class="literal">CHECK TABLE</code></a> on that table.
            </p><p style="color:blue;">如果怀疑某个表已损坏，请对该表运行check table。</p></li></ul>
        </div>
        <div class="section">
            <div class="titlepage">
                <div>
                    <div>
                        <h3 class="title"><a name="error-creating-innodb"></a>14.21.1&nbsp;Troubleshooting InnoDB I/O Problems</h3>

                    </div>

                </div>

            </div>
            <a class="indexterm" name="idm140286804387792"></a><p>
            The troubleshooting steps for <code class="literal">InnoDB</code> I/O
            problems depend on when the problem occurs: during startup of the
            MySQL server, or during normal operations when a DML or DDL
            statement fails due to problems at the file system level.
        </p><p style="color:blue;">innodb i/o问题的故障排除步骤取决于问题发生的时间：在mysql服务器启动期间，或者在正常操作期间，当dml或ddl语句由于文件系统级别的问题而失败时。</p>
            <h4><a name="idm140286804384576"></a>Initialization Problems</h4>
            <p>
                If something goes wrong when <code class="literal">InnoDB</code> attempts to
                initialize its tablespace or its log files, delete all files
                created by <code class="literal">InnoDB</code>: all
                <code class="filename">ibdata</code> files and all
                <code class="filename">ib_logfile</code> files. If you already created some
                <code class="literal">InnoDB</code> tables, also delete the corresponding
                <code class="filename">.frm</code> files for these tables, and any
                <code class="filename">.ibd</code> files if you are using multiple
                tablespaces, from the MySQL database directories. Then try the
                <code class="literal">InnoDB</code> database creation again. For easiest
                troubleshooting, start the MySQL server from a command prompt so
                that you see what is happening.
            </p><p style="color:blue;">如果innodb试图初始化其表空间或日志文件时出错，请删除innodb创建的所有文件：所有ibdata文件和所有ib_日志文件。如果您已经创建了一些innodb表，那么也要从mysql数据库目录中删除这些表对应的.frm文件，如果您使用多个表空间，则删除任何.ibd文件。然后再次尝试创建innodb数据库。为了便于故障排除，请从命令提示符启动mysql服务器，以便查看正在发生的情况。</p>
            <h4><a name="idm140286804377312"></a>Runtime Problems</h4>
            <p>
                If <code class="literal">InnoDB</code> prints an operating system error
                during a file operation, usually the problem has one of the
                following solutions:
            </p><p style="color:blue;">如果innodb在文件操作期间打印操作系统错误，通常问题有以下解决方案之一：</p>
            <div class="itemizedlist">
                <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                    Make sure the <code class="literal">InnoDB</code> data file directory
                    and the <code class="literal">InnoDB</code> log directory exist.
                </p><p style="color:blue;">确保UnIDB数据文件目录和NYNDB日志目录存在。</p></li><li class="listitem"><p>
                    Make sure <a class="link" href="programs.html#mysqld" title="4.3.1&nbsp;mysqld — The MySQL Server"><span class="command"><strong>mysqld</strong></span></a> has access rights to
                    create files in those directories.
                </p><p style="color:blue;">确保mysqld具有在这些目录中创建文件的访问权限。</p></li><li class="listitem"><p>
                    Make sure <a class="link" href="programs.html#mysqld" title="4.3.1&nbsp;mysqld — The MySQL Server"><span class="command"><strong>mysqld</strong></span></a> can read the proper
                    <code class="filename">my.cnf</code> or <code class="filename">my.ini</code>
                    option file, so that it starts with the options that you
                    specified.
                </p><p style="color:blue;">确保mysqld可以读取正确的my.cnf或my.ini选项文件，以便它从您指定的选项开始。</p></li><li class="listitem"><p>
                    Make sure the disk is not full and you are not exceeding any
                    disk quota.
                </p><p style="color:blue;">确保磁盘未满，并且没有超过任何磁盘配额。</p></li><li class="listitem"><p>
                    Make sure that the names you specify for subdirectories and
                    data files do not clash.
                </p><p style="color:blue;">确保为子目录和数据文件指定的名称不冲突。</p></li><li class="listitem"><p>
                    Doublecheck the syntax of the
                    <a class="link" href="innodb-storage-engine.html#sysvar_innodb_data_home_dir"><code class="literal">innodb_data_home_dir</code></a> and
                    <a class="link" href="innodb-storage-engine.html#sysvar_innodb_data_file_path"><code class="literal">innodb_data_file_path</code></a> values.
                    In particular, any <code class="literal">MAX</code> value in the
                    <a class="link" href="innodb-storage-engine.html#sysvar_innodb_data_file_path"><code class="literal">innodb_data_file_path</code></a> option
                    is a hard limit, and exceeding that limit causes a fatal
                    error.
                </p><p style="color:blue;">双击innodb_data_home_dir和innodb_data_file_path值的语法。特别是，innodb_data_file_path选项中的任何最大值都是硬限制，超过该限制将导致致命错误。</p></li></ul>
            </div>

        </div>
        <div class="section">
            <div class="titlepage">
                <div>
                    <div>
                        <h3 class="title"><a name="forcing-innodb-recovery"></a>14.21.2&nbsp;Forcing InnoDB Recovery</h3>

                    </div>

                </div>

            </div>
            <a class="indexterm" name="idm140286804358560"></a><a class="indexterm" name="idm140286804356656"></a><a class="indexterm" name="idm140286804355200"></a><p>
            To investigate database page corruption, you might dump your
            tables from the database with
            <a class="link" href="sql-syntax.html#select-into" title="13.2.9.1&nbsp;SELECT ... INTO Syntax"><code class="literal">SELECT ... INTO
                OUTFILE</code></a>. Usually, most of the data obtained in this way
            is intact. Serious corruption might cause <code class="literal">SELECT * FROM
            <em class="replaceable"><code>tbl_name</code></em></code> statements or
            <code class="literal">InnoDB</code> background operations to crash or
            assert, or even cause <code class="literal">InnoDB</code> roll-forward
            recovery to crash. In such cases, you can use the
            <a class="link" href="innodb-storage-engine.html#sysvar_innodb_force_recovery"><code class="literal">innodb_force_recovery</code></a> option to
            force the <code class="literal">InnoDB</code> storage engine to start up
            while preventing background operations from running, so that you
            can dump your tables. For example, you can add the following line
            to the <code class="literal">[mysqld]</code> section of your option file
            before restarting the server:
        </p><p style="color:blue;">若要调查数据库页损坏，可以使用select从数据库转储表…进入外岛。通常，用这种方法获得的大多数数据是完整的。严重损坏可能导致select*from tbl_name语句或innodb后台操作崩溃或断言，甚至导致innodb前滚恢复崩溃。在这种情况下，可以使用innodb_force_recovery选项在阻止后台操作运行的同时强制启动innodb存储引擎，以便转储表。例如，在重新启动服务器之前，可以将以下行添加到选项文件的[mysqld]部分：</p><pre data-lang="ini" class="programlisting">[mysqld]
innodb_force_recovery = 1
</pre><p>
            For information about using option files, see
            <a class="xref" href="programs.html#option-files" title="4.2.2.2&nbsp;Using Option Files">Section&nbsp;4.2.2.2, “Using Option Files”</a>.
        </p><p style="color:blue;">有关使用选项文件的信息，请参见第4.2.2.2节“使用选项文件”。</p>
            <div class="warning" style="margin-left: 0.5in; margin-right: 0.5in;">

                <div class="admon-title">
                    Warning
                </div>
                <p>
                    Only set <a class="link" href="innodb-storage-engine.html#sysvar_innodb_force_recovery"><code class="literal">innodb_force_recovery</code></a>
                    to a value greater than 0 in an emergency situation, so that you
                    can start <code class="literal">InnoDB</code> and dump your tables. Before
                    doing so, ensure that you have a backup copy of your database in
                    case you need to recreate it. Values of 4 or greater can
                    permanently corrupt data files. Only use an
                    <a class="link" href="innodb-storage-engine.html#sysvar_innodb_force_recovery"><code class="literal">innodb_force_recovery</code></a> setting
                    of 4 or greater on a production server instance after you have
                    successfully tested the setting on a separate physical copy of
                    your database. When forcing <code class="literal">InnoDB</code> recovery,
                    you should always start with
                    <a class="link" href="innodb-storage-engine.html#sysvar_innodb_force_recovery"><code class="literal">innodb_force_recovery=1</code></a> and
                    only increase the value incrementally, as necessary.
                </p><p style="color:blue;">只有在紧急情况下将innodb_force_recovery设置为大于0的值，这样您才能启动innodb并转储表。在执行此操作之前，请确保您有数据库的备份副本，以防需要重新创建它。值为4或更大可能会永久损坏数据文件。只有在成功地在数据库的单独物理副本上测试了innodb_force_recovery设置后，才能在生产服务器实例上使用该设置4或更高。当强制执行innodb recovery时，您应该始终从innodb_force_recovery=1开始，并且只在必要时递增该值。</p>
            </div>
            <p>
                <a class="link" href="innodb-storage-engine.html#sysvar_innodb_force_recovery"><code class="literal">innodb_force_recovery</code></a> is 0 by
                default (normal startup without forced recovery). The permissible
                nonzero values for
                <a class="link" href="innodb-storage-engine.html#sysvar_innodb_force_recovery"><code class="literal">innodb_force_recovery</code></a> are 1 to 6.
                A larger value includes the functionality of lesser values. For
                example, a value of 3 includes all of the functionality of values
                1 and 2.
            </p><p style="color:blue;">InnoDB_Force_Recovery默认为0（正常启动，不强制恢复）。innodb_force_recovery的允许非零值为1到6。较大的值包括较小值的功能。例如，值3包括值1和2的所有功能。</p><p>
            If you are able to dump your tables with an
            <a class="link" href="innodb-storage-engine.html#sysvar_innodb_force_recovery"><code class="literal">innodb_force_recovery</code></a> value of 3
            or less, then you are relatively safe that only some data on
            corrupt individual pages is lost. A value of 4 or greater is
            considered dangerous because data files can be permanently
            corrupted. A value of 6 is considered drastic because database
            pages are left in an obsolete state, which in turn may introduce
            more corruption into <a class="link" href="glossary.html#glos_b_tree" title="B-tree">B-trees</a>
            and other database structures.
        </p><p style="color:blue;">如果您能够转储innodb force_recovery值小于等于3的表，那么您就相对安全了，只有损坏的单个页面上的一些数据会丢失。值为4或更大被认为是危险的，因为数据文件可能会永久损坏。值6被认为是极端的，因为数据库页处于过时状态，这反过来可能会导致B树和其他数据库结构的损坏。</p><p>
            As a safety measure, <code class="literal">InnoDB</code> prevents
            <a class="link" href="sql-syntax.html#insert" title="13.2.5&nbsp;INSERT Syntax"><code class="literal">INSERT</code></a>,
            <a class="link" href="sql-syntax.html#update" title="13.2.11&nbsp;UPDATE Syntax"><code class="literal">UPDATE</code></a>, or
            <a class="link" href="sql-syntax.html#delete" title="13.2.2&nbsp;DELETE Syntax"><code class="literal">DELETE</code></a> operations when
            <a class="link" href="innodb-storage-engine.html#sysvar_innodb_force_recovery"><code class="literal">innodb_force_recovery</code></a> is greater
            than 0. An <a class="link" href="innodb-storage-engine.html#sysvar_innodb_force_recovery"><code class="literal">innodb_force_recovery</code></a>
            setting of 4 or greater places <code class="literal">InnoDB</code> in
            read-only mode.
        </p><p style="color:blue;">作为安全措施，当innodb force_recovery大于0时，innodb会阻止插入、更新或删除操作。innodb_force_recovery设置为只读模式下的4个或更多位置innodb。</p>
            <div class="itemizedlist">
                <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                    <code class="literal">1</code>
                    (<code class="literal">SRV_FORCE_IGNORE_CORRUPT</code>)
                </p><p style="color:blue;">1（srv_force_ignore_corrupt）</p><p>
                    Lets the server run even if it detects a corrupt
                    <a class="link" href="glossary.html#glos_page" title="page">page</a>. Tries to make
                    <code class="literal">SELECT * FROM
                        <em class="replaceable"><code>tbl_name</code></em></code> jump over
                    corrupt index records and pages, which helps in dumping
                    tables.
                </p><p style="color:blue;">允许服务器运行，即使它检测到损坏的页。尝试使select*from tbl_name跳过损坏的索引记录和页，这有助于转储表。</p></li><li class="listitem"><p>
                    <code class="literal">2</code>
                    (<code class="literal">SRV_FORCE_NO_BACKGROUND</code>)
                </p><p style="color:blue;">2（srv_force_no_背景）</p><p>
                    Prevents the <a class="link" href="glossary.html#glos_master_thread" title="master thread">master
                    thread</a> and any <a class="link" href="glossary.html#glos_purge_thread" title="purge thread">purge
                    threads</a> from running. If a crash would occur during the
                    <a class="link" href="glossary.html#glos_purge" title="purge">purge</a> operation, this
                    recovery value prevents it.
                </p><p style="color:blue;">防止主线程和任何清除线程运行。如果清除操作期间发生崩溃，则此恢复值将阻止崩溃。</p></li><li class="listitem"><p>
                    <code class="literal">3</code>
                    (<code class="literal">SRV_FORCE_NO_TRX_UNDO</code>)
                </p><p style="color:blue;">3（srv_force_no_trx_undo）</p><p>
                    Does not run transaction
                    <a class="link" href="glossary.html#glos_rollback" title="rollback">rollbacks</a> after
                    <a class="link" href="glossary.html#glos_crash_recovery" title="crash recovery">crash recovery</a>.
                </p><p style="color:blue;">在崩溃恢复后不运行事务回滚。</p></li><li class="listitem"><p>
                    <code class="literal">4</code>
                    (<code class="literal">SRV_FORCE_NO_IBUF_MERGE</code>)
                </p><p style="color:blue;">4（srv_force_no_ibuf_merge）</p><p>
                    Prevents <a class="link" href="glossary.html#glos_insert_buffer" title="insert buffer">insert
                    buffer</a> merge operations. If they would cause a crash,
                    does not do them. Does not calculate table
                    <a class="link" href="glossary.html#glos_statistics" title="statistics">statistics</a>. This value
                    can permanently corrupt data files. After using this value, be
                    prepared to drop and recreate all secondary indexes. Sets
                    <code class="literal">InnoDB</code> to read-only.
                </p><p style="color:blue;">防止插入缓冲区合并操作。如果他们会导致撞车，不要这样做。不计算表统计信息。此值可能会永久损坏数据文件。使用此值后，请准备删除并重新创建所有辅助索引。将innodb设置为只读。</p></li><li class="listitem"><p>
                    <code class="literal">5</code>
                    (<code class="literal">SRV_FORCE_NO_UNDO_LOG_SCAN</code>)
                </p><p style="color:blue;">5（srv_force_no_undo_log_扫描）</p><p>
                    Does not look at <a class="link" href="glossary.html#glos_undo_log" title="undo log">undo
                    logs</a> when starting the database:
                    <code class="literal">InnoDB</code> treats even incomplete transactions
                    as committed. This value can permanently corrupt data files.
                    Sets <code class="literal">InnoDB</code> to read-only.
                </p><p style="color:blue;">启动数据库时不查看撤消日志：innodb甚至将不完整的事务视为已提交。此值可能会永久损坏数据文件。将innodb设置为只读。</p></li><li class="listitem"><p>
                    <code class="literal">6</code>
                    (<code class="literal">SRV_FORCE_NO_LOG_REDO</code>)
                </p><p style="color:blue;">6（srv_force_no_log_重做）</p><p>
                    Does not do the <a class="link" href="glossary.html#glos_redo_log" title="redo log">redo log</a>
                    roll-forward in connection with recovery. This value can
                    permanently corrupt data files. Leaves database pages in an
                    obsolete state, which in turn may introduce more corruption
                    into B-trees and other database structures. Sets
                    <code class="literal">InnoDB</code> to read-only.
                </p><p style="color:blue;">不执行与恢复相关的重做日志前滚。此值可能会永久损坏数据文件。使数据库页处于过时状态，这反过来又可能导致B树和其他数据库结构的损坏。将innodb设置为只读。</p></li></ul>
            </div>
            <p>
                You can <a class="link" href="sql-syntax.html#select" title="13.2.9&nbsp;SELECT Syntax"><code class="literal">SELECT</code></a> from tables to dump
                them. With an
                <a class="link" href="innodb-storage-engine.html#sysvar_innodb_force_recovery"><code class="literal">innodb_force_recovery</code></a> value of 3
                or less you can <code class="literal">DROP</code> or
                <code class="literal">CREATE</code> tables. <a class="link" href="sql-syntax.html#drop-table" title="13.1.29&nbsp;DROP TABLE Syntax"><code class="literal">DROP
                TABLE</code></a> is also supported with an
                <a class="link" href="innodb-storage-engine.html#sysvar_innodb_force_recovery"><code class="literal">innodb_force_recovery</code></a> value
                greater than 3, up to MySQL 5.7.17. As of MySQL 5.7.18,
                <a class="link" href="sql-syntax.html#drop-table" title="13.1.29&nbsp;DROP TABLE Syntax"><code class="literal">DROP TABLE</code></a> is not permitted with an
                <a class="link" href="innodb-storage-engine.html#sysvar_innodb_force_recovery"><code class="literal">innodb_force_recovery</code></a> value
                greater than 4.
            </p><p style="color:blue;">您可以从表中选择来转储它们。如果innodb_force_recovery值小于等于3，则可以删除或创建表。drop table还支持innodb_force_recovery值大于3，直到mysql 5.7.17。从mysql 5.7.18开始，当innodb_force_recovery值大于4时，不允许使用drop table。</p><p>
            If you know that a given table is causing a crash on rollback, you
            can drop it. If you encounter a runaway rollback caused by a
            failing mass import or <a class="link" href="sql-syntax.html#alter-table" title="13.1.8&nbsp;ALTER TABLE Syntax"><code class="literal">ALTER TABLE</code></a>,
            you can kill the <a class="link" href="programs.html#mysqld" title="4.3.1&nbsp;mysqld — The MySQL Server"><span class="command"><strong>mysqld</strong></span></a> process and set
            <a class="link" href="innodb-storage-engine.html#sysvar_innodb_force_recovery"><code class="literal">innodb_force_recovery</code></a> to
            <code class="literal">3</code> to bring the database up without the
            rollback, and then <code class="literal">DROP</code> the table that is
            causing the runaway rollback.
        </p><p style="color:blue;">如果您知道给定的表在回滚时导致崩溃，则可以删除它。如果遇到由于大容量导入或alter table失败而导致的失控回滚，可以终止mysqld进程并将innodb_force_recovery设置为3以在不进行回滚的情况下启动数据库，然后删除导致失控回滚的表。</p><p>
            If corruption within the table data prevents you from dumping the
            entire table contents, a query with an <code class="literal">ORDER BY
            <em class="replaceable"><code>primary_key</code></em> DESC</code> clause might
            be able to dump the portion of the table after the corrupted part.
        </p><p style="color:blue;">如果表数据中的损坏阻止您转储整个表内容，则使用ORDER BY PRIMARY_KEY DESC子句的查询可能能够在损坏的部分之后转储表的部分。</p><p>
            If a high <a class="link" href="innodb-storage-engine.html#sysvar_innodb_force_recovery"><code class="literal">innodb_force_recovery</code></a>
            value is required to start <code class="literal">InnoDB</code>, there may be
            corrupted data structures that could cause complex queries
            (queries containing <code class="literal">WHERE</code>, <code class="literal">ORDER
            BY</code>, or other clauses) to fail. In this case, you may
            only be able to run basic <code class="literal">SELECT * FROM t</code>
            queries.
        </p><p style="color:blue;">如果启动innodb需要较高的innodb force_recovery值，则可能存在损坏的数据结构，从而导致复杂查询（包含where、order by或其他子句的查询）失败。在这种情况下，您可能只能运行基本的select*from t查询。</p>
        </div>
        <div class="section">
            <div class="titlepage">
                <div>
                    <div>
                        <h3 class="title"><a name="innodb-troubleshooting-datadict"></a>14.21.3&nbsp;Troubleshooting InnoDB Data Dictionary Operations</h3>

                    </div>

                </div>

            </div>
            <a class="indexterm" name="idm140286804270384"></a><p>
            Information about table definitions is stored both in the
            <code class="filename">.frm</code> files, and in the InnoDB
            <a class="link" href="glossary.html#glos_data_dictionary" title="data dictionary">data dictionary</a>. If
            you move <code class="filename">.frm</code> files around, or if the server
            crashes in the middle of a data dictionary operation, these
            sources of information can become inconsistent.
        </p><p style="color:blue;">有关表定义的信息存储在.frm文件和innodb数据字典中。如果移动.frm文件，或者服务器在数据字典操作过程中崩溃，这些信息源可能会变得不一致。</p><p>
            If a data dictionary corruption or consistency issue prevents you
            from starting <code class="literal">InnoDB</code>, see
            <a class="xref" href="innodb-storage-engine.html#forcing-innodb-recovery" title="14.21.2&nbsp;Forcing InnoDB Recovery">Section&nbsp;14.21.2, “Forcing InnoDB Recovery”</a> for information about
            manual recovery.
        </p><p style="color:blue;">如果数据字典损坏或一致性问题阻止您启动InnoDB，请参阅14.21.2节“强制InnoDB恢复”以了解有关手动恢复的信息。</p>
            <div class="simplesect">

                <div class="titlepage">
                    <div>

                        <div class="simple">
                            <h4 class="title"><a name="innodb-create-table-faulure"></a>CREATE TABLE Failure Due to Orphan Table</h4>
                        </div>
                    </div>
                </div>
                <a class="indexterm" name="idm140286804262448"></a><p>
                A symptom of an out-of-sync data dictionary is that a
                <a class="link" href="sql-syntax.html#create-table" title="13.1.18&nbsp;CREATE TABLE Syntax"><code class="literal">CREATE TABLE</code></a> statement fails. If
                this occurs, look in the server's error log. If the log says
                that the table already exists inside the
                <code class="literal">InnoDB</code> internal data dictionary, you have an
                orphan table inside the <code class="literal">InnoDB</code> tablespace
                files that has no corresponding <code class="filename">.frm</code> file.
                The error message looks like this:
            </p><p style="color:blue;">不同步数据字典的一个症状是CREATE TABLE语句失败。如果发生这种情况，请查看服务器的错误日志。如果日志表示该表已经存在于UnIDB内部数据字典内，则在NIDB表空间文件中有一个孤儿表，该文件没有对应的.FRM文件。错误消息如下：</p><pre data-lang="terminal" class="programlisting">InnoDB: Error: table test/parent already exists in InnoDB internal
InnoDB: data dictionary. Have you deleted the .frm file
InnoDB: and not used DROP TABLE? Have you used DROP DATABASE
InnoDB: for InnoDB tables in MySQL version &lt;= 3.23.43?
InnoDB: See the Restrictions section of the InnoDB manual.
InnoDB: You can drop the orphaned table inside InnoDB by
InnoDB: creating an InnoDB table with the same name in another
InnoDB: database and moving the .frm file to the current database.
InnoDB: Then MySQL thinks the table exists, and DROP TABLE will
InnoDB: succeed.
</pre><p>
                You can drop the orphan table by following the instructions
                given in the error message. If you are still unable to use
                <a class="link" href="sql-syntax.html#drop-table" title="13.1.29&nbsp;DROP TABLE Syntax"><code class="literal">DROP TABLE</code></a> successfully, the
                problem may be due to name completion in the
                <a class="link" href="programs.html#mysql" title="4.5.1&nbsp;mysql — The MySQL Command-Line Client"><span class="command"><strong>mysql</strong></span></a> client. To work around this problem,
                start the <a class="link" href="programs.html#mysql" title="4.5.1&nbsp;mysql — The MySQL Command-Line Client"><span class="command"><strong>mysql</strong></span></a> client with the
                <a class="link" href="programs.html#option_mysql_auto-rehash"><code class="option">--skip-auto-rehash</code></a>
                option and try <a class="link" href="sql-syntax.html#drop-table" title="13.1.29&nbsp;DROP TABLE Syntax"><code class="literal">DROP TABLE</code></a> again.
                (With name completion on, <a class="link" href="programs.html#mysql" title="4.5.1&nbsp;mysql — The MySQL Command-Line Client"><span class="command"><strong>mysql</strong></span></a> tries to
                construct a list of table names, which fails when a problem such
                as just described exists.)
            </p><p style="color:blue;">可以按照错误消息中给出的说明删除孤立表。如果仍然无法成功使用drop table，则问题可能是由于mysql客户端中的名称完成。若要解决此问题，请使用--skip auto rehash选项启动MySQL客户端，然后再次尝试删除表。（在完成名称时，MySQL试图构建一个表名列表，当存在诸如刚才描述的问题时，它会失败）。</p>
            </div>
            <div class="simplesect">
                <div class="titlepage">
                    <div>
                        <div class="simple">
                            <h4 class="title"><a name="innodb-cannot-open-data-file-error"></a>Cannot Open Datafile</h4>

                        </div>

                    </div>

                </div>
                <a class="indexterm" name="idm140286804244624"></a><p>
                With <a class="link" href="innodb-storage-engine.html#sysvar_innodb_file_per_table"><code class="literal">innodb_file_per_table</code></a>
                enabled (the default), the following messages may appear at
                startup if a
                <a class="link" href="glossary.html#glos_file_per_table" title="file-per-table">file-per-table</a>
                tablespace file (<code class="literal">.ibd</code> file) is missing:
            </p><p style="color:blue;">启用innodb_file_per_table（默认值）后，如果缺少file per table space file（.ibd file），启动时可能会显示以下消息：</p><pre data-lang="terminal" class="programlisting">[ERROR] InnoDB: Operating system error number 2 in a file operation.
[ERROR] InnoDB: The error means the system cannot find the path specified.
[ERROR] InnoDB: Cannot open datafile for read-only: './test/t1.ibd' OS error: 71
[Warning] InnoDB: Ignoring tablespace `test/t1` because it could not be opened.
</pre><p>
                To address the these messages, issue <a class="link" href="sql-syntax.html#drop-table" title="13.1.29&nbsp;DROP TABLE Syntax"><code class="literal">DROP
                TABLE</code></a> statement to remove data about the missing table
                from the data dictionary.
            </p><p style="color:blue;">若要处理这些消息，请发出DROP TABLE语句以从数据字典中删除有关丢失表的数据。</p>
            </div>
            <div class="simplesect">
                <div class="titlepage">
                    <div>
                        <div class="simple">
                            <h4 class="title"><a name="innodb-cannot-open-file-error"></a>Cannot Open File Error</h4>

                        </div>

                    </div>

                </div>
                <a class="indexterm" name="idm140286804235056"></a><p>
                Another symptom of an out-of-sync data dictionary is that MySQL
                prints an error that it cannot open an
                <code class="filename">InnoDB</code> file:
            </p><p style="color:blue;">数据字典不同步的另一个症状是mysql打印了一个错误，即它无法打开innodb文件：</p><pre data-lang="terminal" class="programlisting">ERROR 1016: Can't open file: 'child2.ibd'. (errno: 1)
</pre><p>
                In the error log you can find a message like this:
            </p><p style="color:blue;">在错误日志中，您可以找到如下消息：</p><pre data-lang="terminal" class="programlisting">InnoDB: Cannot find table test/child2 from the internal data dictionary
InnoDB: of InnoDB though the .frm file for the table exists. Maybe you
InnoDB: have deleted and recreated InnoDB data files but have forgotten
InnoDB: to delete the corresponding .frm files of InnoDB tables?
</pre><p>
                This means that there is an orphan <code class="filename">.frm</code>
                file without a corresponding table inside
                <code class="literal">InnoDB</code>. You can drop the orphan
                <code class="filename">.frm</code> file by deleting it manually.
            </p><p style="color:blue;">这意味着innodb中有一个没有对应表的孤儿.frm文件。您可以手动删除孤立的.frm文件。</p>
            </div>
            <div class="simplesect">
                <div class="titlepage">
                    <div>
                        <div class="simple">
                            <h4 class="title"><a name="innodb-orphan-intermediate-tables"></a>Orphan Intermediate Tables</h4>

                        </div>

                    </div>

                </div>
                <a class="indexterm" name="idm140286804225248"></a><p>
                If MySQL exits in the middle of an in-place
                <a class="link" href="sql-syntax.html#alter-table" title="13.1.8&nbsp;ALTER TABLE Syntax"><code class="literal">ALTER TABLE</code></a> operation
                (<code class="literal">ALGORITHM=INPLACE</code>), you may be left with an
                orphan intermediate table that takes up space on your system.
                Also, an orphan intermediate table in an otherwise empty
                <a class="link" href="glossary.html#glos_general_tablespace" title="general tablespace">general
                    tablespace</a> prevents you from dropping the general
                tablespace. This section describes how to identify and remove
                orphan intermediate tables.
            </p><p style="color:blue;">如果MySQL在就地的ALTE表操作（算法＝InPoT）中间退出，则可能会有一个孤立的中间表占用您的系统空间。另外，在一个空的通用表空间中的一个孤立中间表会阻止您删除通用表空间。本节介绍如何标识和删除孤立中间表。</p><p>
                Intermediate table names begin with an
                <code class="filename">#sql-ib</code> prefix (e.g.,
                <code class="filename">#sql-ib87-856498050</code>). The accompanying
                <code class="filename">.frm</code> file has an
                <code class="filename">#sql-*</code> prefix and is named differently
                (e.g., <code class="filename">#sql-36ab_2.frm</code>).
            </p><p style="color:blue;">中间表名以sql ib前缀开头（例如sql-ib87-856498050）。附带的.frm文件有一个sql-*前缀，并且名称不同（例如sql-36ab_2.frm）。</p><p>
                To identify orphan intermediate tables on your system, you can
                query
                <a class="link" href="information-schema.html#innodb-sys-tables-table" title="24.32.22&nbsp;The INFORMATION_SCHEMA INNODB_SYS_TABLES Table"><code class="literal">INFORMATION_SCHEMA.INNODB_SYS_TABLES</code></a>.
                Look for table names that begin with <code class="filename">#sql</code>.
                If the original table resides in a
                <a class="link" href="glossary.html#glos_file_per_table" title="file-per-table">file-per-table</a>
                tablespace, the tablespace file (the
                <code class="filename">#sql-*.ibd</code> file) for the orphan
                intermediate table should be visible in the database directory.
            </p><p style="color:blue;">要标识系统上的孤立中间表，可以查询information_schema.innodb_sys_tables。查找以SQL开头的表名。如果原始表位于每表表空间一个文件中，则孤立中间表的表空间文件（sql-*.ibd文件）应在数据库目录中可见。</p><pre data-lang="sql" class="programlisting">SELECT * FROM INFORMATION_SCHEMA.INNODB_SYS_TABLES WHERE NAME LIKE '%#sql%';
</pre><p>
                To remove an orphan intermediate table, perform the following
                steps:
            </p><p style="color:blue;">要删除孤立中间表，请执行以下步骤：</p>
                <div class="orderedlist">
                    <ol class="orderedlist" type="1"><li class="listitem"><p>
                        In the database directory, rename the
                        <code class="filename">#sql-*.frm</code> file to match the base name
                        of the orphan intermediate table:
                    </p><p style="color:blue;">在数据库目录中，重命名sql-*.frm文件以匹配孤立中间表的基名称：</p><pre data-lang="terminal" class="programlisting">shell&gt; <strong class="userinput"><code>mv #sql-36ab_2.frm #sql-ib87-856498050.frm</code></strong>
</pre>
                        <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">

                            <div class="admon-title">
                                Note
                            </div>
                            <p>
                                If there is no <code class="filename">.frm</code> file, you can
                                recreate it. The <code class="filename">.frm</code> file must have
                                the same table schema as the orphan intermediate table (it
                                must have the same columns and indexes) and must be placed
                                in the database directory of the orphan intermediate
                                table.
                            </p><p style="color:blue;">如果没有.frm文件，可以重新创建它。.frm文件必须具有与孤立中间表相同的表架构（必须具有相同的列和索引），并且必须放置在孤立中间表的数据库目录中。</p>
                        </div>
                    </li><li class="listitem"><p>
                        Drop the orphan intermediate table by issuing a
                        <a class="link" href="sql-syntax.html#drop-table" title="13.1.29&nbsp;DROP TABLE Syntax"><code class="literal">DROP TABLE</code></a> statement,
                        prefixing the name of the table with
                        <code class="literal">#mysql50#</code> and enclosing the table name in
                        backticks. For example:
                    </p><p style="color:blue;">通过发布一个下拉表语句来删除孤儿中间表，用“yyyMyLL50*”预先填充表的名称，并将表名括在后面。例如：</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>DROP TABLE `#mysql50##sql-ib87-856498050`;</code></strong>
</pre><p>
                        The <code class="literal">#mysql50#</code> prefix tells MySQL to
                        ignore <code class="literal">file name safe encoding</code> introduced
                        in MySQL 5.1. Enclosing the table name in backticks is
                        required to perform SQL statements on table names with
                        special characters such as <span class="quote">“<span class="quote">#</span>”</span>.
                    </p><p style="color:blue;">mysql50前缀告诉mysql忽略mysql 5.1中引入的文件名安全编码。对带有特殊字符（如“”）的表名执行SQL语句时，需要将表名括在倒勾号中。</p></li></ol>
                </div>
                <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">
                    <div class="admon-title">
                        Note
                    </div>
                    <p>
                        If a crash occurs during an in-place
                        <a class="link" href="sql-syntax.html#alter-table" title="13.1.8&nbsp;ALTER TABLE Syntax"><code class="literal">ALTER TABLE</code></a> operation that was
                        moving a table to a different tablespace, the recovery process
                        restores the table to its original location but leaves an
                        orphan intermediate table in the destination tablespace.
                    </p><p style="color:blue;">如果在将表移动到其他表空间的就地alter table操作期间发生崩溃，则恢复过程会将表还原到其原始位置，但会在目标表空间中保留一个孤立的中间表。</p>
                </div>

            </div>
            <div class="simplesect">
                <div class="titlepage">
                    <div>
                        <div class="simple">
                            <h4 class="title"><a name="innodb-orphan-temporary-tables"></a>Orphan Temporary Tables</h4>

                        </div>

                    </div>

                </div>
                <a class="indexterm" name="idm140286804192464"></a><p>
                If MySQL exits in the middle of a table-copying
                <a class="link" href="sql-syntax.html#alter-table" title="13.1.8&nbsp;ALTER TABLE Syntax"><code class="literal">ALTER TABLE</code></a> operation
                (<code class="literal">ALGORITHM=COPY</code>), you may be left with an
                orphan temporary table that takes up space on your system. Also,
                an orphan temporary table in an otherwise empty
                <a class="link" href="glossary.html#glos_general_tablespace" title="general tablespace">general
                    tablespace</a> prevents you from dropping the general
                tablespace. This section describes how to identify and remove
                orphan temporary tables.
            </p><p style="color:blue;">如果MySQL退出表中间的复制ALTE表操作（算法=复制），您可能会留下一个孤立的临时表，占用您的系统空间。另外，在一个空的常规表空间中，一个孤立的临时表会阻止您删除常规表空间。本节介绍如何标识和删除孤立临时表。</p><p>
                Orphan temporary table names begin with an
                <code class="filename">#sql-</code> prefix (e.g.,
                <code class="filename">#sql-540_3</code>). The accompanying
                <code class="filename">.frm</code> file has the same base name as the
                orphan temporary table.
            </p><p style="color:blue;">孤立的临时表名以sql-前缀开头（例如sql-540_3）。附带的.frm文件与孤立临时表具有相同的基名。</p>
                <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">

                    <div class="admon-title">
                        Note
                    </div>
                    <p>
                        If there is no <code class="filename">.frm</code> file, you can
                        recreate it. The <code class="filename">.frm</code> file must have the
                        same table schema as the orphan temporary table (it must have
                        the same columns and indexes) and must be placed in the
                        database directory of the orphan temporary table.
                    </p><p style="color:blue;">如果没有.frm文件，可以重新创建它。.frm文件必须与孤立临时表具有相同的表架构（必须具有相同的列和索引），并且必须放置在孤立临时表的数据库目录中。</p>
                </div>
                <p>
                    To identify orphan temporary tables on your system, you can
                    query
                    <a class="link" href="information-schema.html#innodb-sys-tables-table" title="24.32.22&nbsp;The INFORMATION_SCHEMA INNODB_SYS_TABLES Table"><code class="literal">INFORMATION_SCHEMA.INNODB_SYS_TABLES</code></a>.
                    Look for table names that begin with <code class="filename">#sql</code>.
                    If the original table resides in a
                    <a class="link" href="glossary.html#glos_file_per_table" title="file-per-table">file-per-table</a>
                    tablespace, the tablespace file (the
                    <code class="filename">#sql-*.ibd</code> file) for the orphan temporary
                    table should be visible in the database directory.
                </p><p style="color:blue;">要标识系统上的孤立临时表，可以查询information_schema.innodb_sys_tables。查找以SQL开头的表名。如果原始表位于每个表表空间的文件中，则孤立临时表的表空间文件（sql-*.ibd文件）应在数据库目录中可见。</p><pre data-lang="sql" class="programlisting">SELECT * FROM INFORMATION_SCHEMA.INNODB_SYS_TABLES WHERE NAME LIKE '%#sql%';
</pre><p>
                To remove an orphan temporary table, drop the table by issuing a
                <a class="link" href="sql-syntax.html#drop-table" title="13.1.29&nbsp;DROP TABLE Syntax"><code class="literal">DROP TABLE</code></a> statement, prefixing
                the name of the table with <code class="literal">#mysql50#</code> and
                enclosing the table name in backticks. For example:
            </p><p style="color:blue;">要删除一个孤儿临时表，可以通过发布一个DROP表语句来删除表，用*yMySqL50*预先填充表的名称，并将表名括在后面。例如：</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>DROP TABLE `#mysql50##sql-540_3`;</code></strong>
</pre><p>
                The <code class="literal">#mysql50#</code> prefix tells MySQL to ignore
                <code class="literal">file name safe encoding</code> introduced in MySQL
                5.1. Enclosing the table name in backticks is required to
                perform SQL statements on table names with special characters
                such as <span class="quote">“<span class="quote">#</span>”</span>.
            </p><p style="color:blue;">mysql50前缀告诉mysql忽略mysql 5.1中引入的文件名安全编码。对带有特殊字符（如“”）的表名执行SQL语句时，需要将表名括在倒勾号中。</p>
            </div>
            <div class="simplesect">
                <div class="titlepage">
                    <div>
                        <div class="simple">
                            <h4 class="title"><a name="innodb-tablespace-does-not-exist"></a>Tablespace Does Not Exist</h4>

                        </div>

                    </div>

                </div>
                <a class="indexterm" name="idm140286804168752"></a><p>
                With <a class="link" href="innodb-storage-engine.html#sysvar_innodb_file_per_table"><code class="literal">innodb_file_per_table</code></a>
                enabled, the following message might occur if the
                <code class="filename">.frm</code> or <code class="literal">.ibd</code> files (or
                both) are missing:
            </p><p style="color:blue;">启用innodb_file_per_表后，如果缺少.frm或.ibd文件（或两者都缺少），则可能会出现以下消息：</p><pre data-lang="terminal" class="programlisting">InnoDB: in InnoDB data dictionary has tablespace id <em class="replaceable"><code>N</code></em>,
InnoDB: but tablespace with that id or name does not exist. Have
InnoDB: you deleted or moved .ibd files?
InnoDB: This may also be a table created with CREATE TEMPORARY TABLE
InnoDB: whose .ibd and .frm files MySQL automatically removed, but the
InnoDB: table still exists in the InnoDB internal data dictionary.
</pre><p>
                If this occurs, try the following procedure to resolve the
                problem:
            </p><p style="color:blue;">如果发生这种情况，请尝试以下步骤解决问题：</p>
                <div class="orderedlist">
                    <ol class="orderedlist" type="1"><li class="listitem"><p>
                        Create a matching <code class="filename">.frm</code> file in some
                        other database directory and copy it to the database
                        directory where the orphan table is located.
                    </p><p style="color:blue;">在其他数据库目录中创建一个匹配的.frm文件，并将其复制到孤立表所在的数据库目录中。</p></li><li class="listitem"><p>
                        Issue <a class="link" href="sql-syntax.html#drop-table" title="13.1.29&nbsp;DROP TABLE Syntax"><code class="literal">DROP TABLE</code></a> for the
                        original table. That should successfully drop the table and
                        <code class="literal">InnoDB</code> should print a warning to the
                        error log that the <code class="filename">.ibd</code> file was
                        missing.
                    </p><p style="color:blue;">为原始表发出放置表。这将成功地删除该表，innodb应该在错误日志中打印一个.ibd文件丢失的警告。</p></li></ol>
                </div>

            </div>
            <div class="simplesect">
                <div class="titlepage">
                    <div>
                        <div class="simple">
                            <h4 class="title"><a name="restoring-orphaned-ibd-files"></a>Restoring Orphan File-Per-Table ibd Files</h4>

                        </div>

                    </div>

                </div>
                <a class="indexterm" name="idm140286804153808"></a><p>
                This procedure describes how to restore orphan
                <a class="link" href="glossary.html#glos_file_per_table" title="file-per-table">file-per-table</a>
                <code class="filename">.ibd</code> files to another MySQL instance. You
                might use this procedure if the system tablespace is lost or
                unrecoverable and you want to restore <code class="filename">.ibd</code>
                file backups on a new MySQL instance.
            </p><p style="color:blue;">此过程描述如何将每个表的孤立文件.ibd文件还原到另一个MySQL实例。如果系统表空间丢失或不可恢复，并且希望在新的MySQL实例上还原.ibd文件备份，则可以使用此过程。</p><p>
                The procedure is not supported for
                <a class="link" href="glossary.html#glos_general_tablespace" title="general tablespace">general
                    tablespace</a> <code class="filename">.ibd</code> files.
            </p><p style="color:blue;">常规表空间.ibd文件不支持该过程。</p><p>
                The procedure assumes that you only have
                <code class="filename">.ibd</code> file backups, you are recovering to
                the same version of MySQL that initially created the orphan
                <code class="filename">.ibd</code> files, and that
                <code class="filename">.ibd</code> file backups are clean. See
                <a class="xref" href="innodb-storage-engine.html#innodb-migration" title="14.6.1.2&nbsp;Moving or Copying InnoDB Tables">Section&nbsp;14.6.1.2, “Moving or Copying InnoDB Tables”</a> for information about
                creating clean backups.
            </p><p style="color:blue;">该过程假设您只有.ibd文件备份，您正在恢复到最初创建孤立.ibd文件的mysql版本，并且.ibd文件备份是干净的。有关创建干净备份的信息，请参阅第14.6.1.2节“移动或复制innodb表”。</p><p>
                Tablespace copying limitations outlined in
                <a class="xref" href="innodb-storage-engine.html#tablespace-copying" title="14.6.3.7&nbsp;Copying Tablespaces to Another Instance">Section&nbsp;14.6.3.7, “Copying Tablespaces to Another Instance”</a> are applicable to this
                procedure.
            </p><p style="color:blue;">第14.6.3.7节“将表空间复制到另一个实例”中概述的表空间复制限制适用于此过程。</p>
                <div class="orderedlist">
                    <ol class="orderedlist" type="1"><li class="listitem"><p>
                        On the new MySQL instance, recreate the table in a database
                        of the same name.
                    </p><p style="color:blue;">在新的mysql实例上，在同名数据库中重新创建表。</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>CREATE DATABASE sakila;</code></strong>

mysql&gt; <strong class="userinput"><code>USE sakila;</code></strong>

mysql&gt; <strong class="userinput"><code>CREATE TABLE actor (</code></strong>
         <strong class="userinput"><code>actor_id SMALLINT UNSIGNED NOT NULL AUTO_INCREMENT,</code></strong>
         <strong class="userinput"><code>first_name VARCHAR(45) NOT NULL,</code></strong>
         <strong class="userinput"><code>last_name VARCHAR(45) NOT NULL,</code></strong>
         <strong class="userinput"><code>last_update TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,</code></strong>
         <strong class="userinput"><code>PRIMARY KEY  (actor_id),</code></strong>
         <strong class="userinput"><code>KEY idx_actor_last_name (last_name)</code></strong>
       <strong class="userinput"><code>)ENGINE=InnoDB DEFAULT CHARSET=utf8;</code></strong>
</pre></li><li class="listitem"><p>
                        Discard the tablespace of the newly created table.
                    </p><p style="color:blue;">放弃新创建表的表空间。</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>ALTER TABLE sakila.actor DISCARD TABLESPACE;</code></strong>
</pre></li><li class="listitem"><p>
                        Copy the orphan <code class="literal">.ibd</code> file from your
                        backup directory to the new database directory.
                    </p><p style="color:blue;">将孤立的.ibd文件从备份目录复制到新的数据库目录。</p><pre data-lang="terminal" class="programlisting">shell&gt; <strong class="userinput"><code>cp /<code class="literal">backup_directory</code>/actor.ibd <em class="replaceable"><code>path/to/mysql-5.7/data</code></em>/sakila/</code></strong>
</pre></li><li class="listitem"><p>
                        Ensure that the <code class="filename">.ibd</code> file has the
                        necessary file permissions.
                    </p><p style="color:blue;">确保.ibd文件具有必要的文件权限。</p></li><li class="listitem"><p>
                        Import the orphan <code class="literal">.ibd</code> file. A warning is
                        issued indicating that <code class="literal">InnoDB</code> will
                        attempt to import the file without schema verification.
                    </p><p style="color:blue;">导入孤儿.ibd文件。发出警告，表示innodb将尝试在没有模式验证的情况下导入文件。</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>ALTER TABLE sakila.actor IMPORT TABLESPACE; SHOW WARNINGS;</code></strong>
Query OK, 0 rows affected, 1 warning (0.15 sec)

Warning | 1810 | InnoDB: IO Read error: (2, No such file or directory)
Error opening './sakila/actor.cfg', will attempt to import
without schema verification
</pre></li><li class="listitem"><p>
                        Query the table to verify that the <code class="literal">.ibd</code>
                        file was successfully restored.
                    </p><p style="color:blue;">查询表以验证.ibd文件是否已成功还原。</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT COUNT(*) FROM sakila.actor;</code></strong>
+----------+
| count(*) |
+----------+
|      200 |
+----------+
</pre></li></ol>
                </div>

            </div>

        </div>
        <div class="section">
            <div class="titlepage">
                <div>
                    <div>
                        <h3 class="title"><a name="innodb-error-handling"></a>14.21.4&nbsp;InnoDB Error Handling</h3>

                    </div>

                </div>

            </div>
            <a class="indexterm" name="idm140286804115152"></a><a class="indexterm" name="idm140286804113248"></a><p>
            The following items describe how <code class="literal">InnoDB</code>
            performs error handling. <code class="literal">InnoDB</code> sometimes rolls
            back only the statement that failed, other times it rolls back the
            entire transaction.
        </p><p style="color:blue;">以下项目描述了innodb如何执行错误处理。innodb有时只回滚失败的语句，有时回滚整个事务。</p>
            <div class="itemizedlist">
                <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                    If you run out of file space in a
                    <a class="link" href="glossary.html#glos_tablespace" title="tablespace">tablespace</a>, a MySQL
                    <code class="literal">Table is full</code> error occurs and
                    <code class="literal">InnoDB</code> rolls back the SQL statement.
                </p><p style="color:blue;">如果表空间中的文件空间用完，就会出现mysql table is full错误，innodb会回滚sql语句。</p></li><li class="listitem"><p>
                    A transaction <a class="link" href="glossary.html#glos_deadlock" title="deadlock">deadlock</a>
                    causes <code class="literal">InnoDB</code> to
                    <a class="link" href="glossary.html#glos_rollback" title="rollback">roll back</a> the entire
                    <a class="link" href="glossary.html#glos_transaction" title="transaction">transaction</a>. Retry the
                    whole transaction when this happens.
                </p><p style="color:blue;">事务死锁导致innodb回滚整个事务。发生这种情况时重试整个事务。</p><p>
                    A lock wait timeout causes <code class="literal">InnoDB</code> to roll
                    back only the single statement that was waiting for the lock
                    and encountered the timeout. (To have the entire transaction
                    roll back, start the server with the
                    <a class="link" href="innodb-storage-engine.html#sysvar_innodb_rollback_on_timeout"><code class="option">--innodb-rollback-on-timeout</code></a>
                    option.) Retry the statement if using the current behavior, or
                    the entire transaction if using
                    <a class="link" href="innodb-storage-engine.html#sysvar_innodb_rollback_on_timeout"><code class="option">--innodb-rollback-on-timeout</code></a>.
                </p><p style="color:blue;">锁等待超时导致innodb只回滚等待锁并遇到超时的单个语句。（要回滚整个事务，请使用--innodb roll back on timeout选项启动服务器。）如果使用当前行为，请重试该语句；如果使用--innodb rollback on timeout，请重试整个事务。</p><p>
                    Both deadlocks and lock wait timeouts are normal on busy
                    servers and it is necessary for applications to be aware that
                    they may happen and handle them by retrying. You can make them
                    less likely by doing as little work as possible between the
                    first change to data during a transaction and the commit, so
                    the locks are held for the shortest possible time and for the
                    smallest possible number of rows. Sometimes splitting work
                    between different transactions may be practical and helpful.
                </p><p style="color:blue;">在繁忙的服务器上，死锁和锁等待超时都是正常的，应用程序必须意识到它们可能会发生，并通过重试来处理它们。您可以通过在事务期间对数据的第一次更改和提交之间尽可能少地执行操作来降低发生这种情况的可能性，从而使锁保持尽可能短的时间和尽可能少的行数。有时，在不同的事务之间分割工作可能是实用和有用的。</p><p>
                    When a transaction rollback occurs due to a deadlock or lock
                    wait timeout, it cancels the effect of the statements within
                    the transaction. But if the start-transaction statement was
                    <a class="link" href="sql-syntax.html#commit" title="13.3.1&nbsp;START TRANSACTION, COMMIT, and ROLLBACK Syntax"><code class="literal">START
                        TRANSACTION</code></a> or
                    <a class="link" href="sql-syntax.html#commit" title="13.3.1&nbsp;START TRANSACTION, COMMIT, and ROLLBACK Syntax"><code class="literal">BEGIN</code></a>
                    statement, rollback does not cancel that statement. Further
                    SQL statements become part of the transaction until the
                    occurrence of <a class="link" href="sql-syntax.html#commit" title="13.3.1&nbsp;START TRANSACTION, COMMIT, and ROLLBACK Syntax"><code class="literal">COMMIT</code></a>,
                    <a class="link" href="sql-syntax.html#commit" title="13.3.1&nbsp;START TRANSACTION, COMMIT, and ROLLBACK Syntax"><code class="literal">ROLLBACK</code></a>, or
                    some SQL statement that causes an implicit commit.
                </p><p style="color:blue;">当事务回滚由于死锁或锁等待超时而发生时，它将取消事务内语句的效果。但如果start transaction语句是start transaction或begin语句，则rollback不会取消该语句。在commit、rollback或导致隐式提交的某些sql语句出现之前，其他sql语句将成为事务的一部分。</p></li><li class="listitem"><p>
                    A duplicate-key error rolls back the SQL statement, if you
                    have not specified the <code class="literal">IGNORE</code> option in
                    your statement.
                </p><p style="color:blue;">如果未在语句中指定ignore选项，则重复键错误将回滚sql语句。</p></li><li class="listitem"><p>
                    A <code class="literal">row too long error</code> rolls back the SQL
                    statement.
                </p><p style="color:blue;">行太长错误将回滚SQL语句。</p></li><li class="listitem"><p>
                    Other errors are mostly detected by the MySQL layer of code
                    (above the <code class="literal">InnoDB</code> storage engine level),
                    and they roll back the corresponding SQL statement. Locks are
                    not released in a rollback of a single SQL statement.
                </p><p style="color:blue;">其他错误主要由mysql代码层（innodb存储引擎级别之上）检测，并回滚相应的sql语句。在单个SQL语句的回滚中不会释放锁。</p></li></ul>
            </div>
            <p>
                During implicit rollbacks, as well as during the execution of an
                explicit
                <a class="link" href="sql-syntax.html#commit" title="13.3.1&nbsp;START TRANSACTION, COMMIT, and ROLLBACK Syntax"><code class="literal">ROLLBACK</code></a> SQL
                statement, <a class="link" href="sql-syntax.html#show-processlist" title="13.7.5.29&nbsp;SHOW PROCESSLIST Syntax"><code class="literal">SHOW PROCESSLIST</code></a>
                displays <code class="literal">Rolling back</code> in the
                <code class="literal">State</code> column for the relevant connection.
            </p><p style="color:blue;">在隐式回滚和显式回滚sql语句执行期间，show processlist在相关连接的state列中显示回滚。</p>
        </div>

    </div>

</div>
<div class="copyright-footer">

</div>
<div class="navfooter">
    <hr>
    <table width="100%" summary="Navigation footer">
        <tbody><tr>
            <td width="40%" align="left"><a accesskey="p" href="sql-syntax.html">Prev</a></td>
            <td width="20%" align="center"><a accesskey="u" href="">Up</a></td>
            <td width="40%" align="right">&nbsp;<a accesskey="n" href="storage-engines.html">Next</a></td>
        </tr>
        <tr>
            <td width="40%" align="left" valign="top">Chapter&nbsp;13 SQL Statement Syntax</td>
            <td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td>
            <td width="40%" align="right" valign="top">Chapter&nbsp;15 Alternative Storage Engines</td>
        </tr>
        </tbody></table>
</div>


</body></html>